
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00004ef4  00004f88  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004ef4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000225  0080011e  0080011e  00004fa6  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00004fa8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000070  00000000  00000000  00005674  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  000056e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000003a0  00000000  00000000  000057a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000026b9  00000000  00000000  00005b44  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000008b4  00000000  00000000  000081fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003545  00000000  00000000  00008ab1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003d0  00000000  00000000  0000bff8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001188  00000000  00000000  0000c3c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000e39  00000000  00000000  0000d550  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000218  00000000  00000000  0000e389  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 4f 09 	jmp	0x129e	; 0x129e <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 c9 0a 	jmp	0x1592	; 0x1592 <__vector_9>
      28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 08 09 	jmp	0x1210	; 0x1210 <__vector_12>
      34:	0c 94 97 09 	jmp	0x132e	; 0x132e <__vector_13>
      38:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	0a 1d       	adc	r16, r10
      7e:	9a 20       	and	r9, r10
      80:	9a 20       	and	r9, r10
      82:	9a 20       	and	r9, r10
      84:	9a 20       	and	r9, r10
      86:	9a 20       	and	r9, r10
      88:	4f 1d       	adc	r20, r15
      8a:	9a 20       	and	r9, r10
      8c:	9a 20       	and	r9, r10
      8e:	9a 20       	and	r9, r10
      90:	9a 20       	and	r9, r10
      92:	a3 1d       	adc	r26, r3
      94:	ee 1d       	adc	r30, r14
      96:	15 1e       	adc	r1, r21
      98:	3c 1e       	adc	r3, r28
      9a:	65 1e       	adc	r6, r21
      9c:	e4 1e       	adc	r14, r20
      9e:	fa 1e       	adc	r15, r26
      a0:	01 1f       	adc	r16, r17
      a2:	14 1f       	adc	r17, r20
      a4:	30 1f       	adc	r19, r16
      a6:	57 1f       	adc	r21, r23
      a8:	6b 1f       	adc	r22, r27
      aa:	7f 1f       	adc	r23, r31
      ac:	93 1f       	adc	r25, r19
      ae:	0e 20       	and	r0, r14
      b0:	25 20       	and	r2, r5
      b2:	3c 20       	and	r3, r12

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e4 ef       	ldi	r30, 0xF4	; 244
      c8:	fe e4       	ldi	r31, 0x4E	; 78
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <.do_copy_data_start>

000000cc <.do_copy_data_loop>:
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0

000000d0 <.do_copy_data_start>:
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <.do_copy_data_loop>

000000d6 <__do_clear_bss>:
      d6:	13 e0       	ldi	r17, 0x03	; 3
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a3 34       	cpi	r26, 0x43	; 67
      e2:	b1 07       	cpc	r27, r17
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 70 14 	call	0x28e0	; 0x28e0 <main>
      ea:	0c 94 78 27 	jmp	0x4ef0	; 0x4ef0 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 e4 0a 	jmp	0x15c8	; 0x15c8 <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 c9 02 	lds	r24, 0x02C9
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c9 f0       	breq	.+50     	; 0x12c <UpdateAudioChannel0+0x3a>
      fa:	84 30       	cpi	r24, 0x04	; 4
      fc:	30 f4       	brcc	.+12     	; 0x10a <UpdateAudioChannel0+0x18>
      fe:	81 30       	cpi	r24, 0x01	; 1
     100:	59 f0       	breq	.+22     	; 0x118 <UpdateAudioChannel0+0x26>
     102:	82 30       	cpi	r24, 0x02	; 2
     104:	09 f0       	breq	.+2      	; 0x108 <UpdateAudioChannel0+0x16>
     106:	8e c0       	rjmp	.+284    	; 0x224 <UpdateAudioChannel0+0x132>
     108:	0e c0       	rjmp	.+28     	; 0x126 <UpdateAudioChannel0+0x34>
     10a:	84 30       	cpi	r24, 0x04	; 4
     10c:	09 f4       	brne	.+2      	; 0x110 <UpdateAudioChannel0+0x1e>
     10e:	8c c0       	rjmp	.+280    	; 0x228 <UpdateAudioChannel0+0x136>
     110:	85 30       	cpi	r24, 0x05	; 5
     112:	09 f0       	breq	.+2      	; 0x116 <UpdateAudioChannel0+0x24>
     114:	87 c0       	rjmp	.+270    	; 0x224 <UpdateAudioChannel0+0x132>
     116:	0d c2       	rjmp	.+1050   	; 0x532 <UpdateAudioChannel0+0x440>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     118:	40 91 38 01 	lds	r20, 0x0138
     11c:	4f 5f       	subi	r20, 0xFF	; 255
     11e:	40 93 38 01 	sts	0x0138, r20
     122:	41 50       	subi	r20, 0x01	; 1
     124:	a3 c3       	rjmp	.+1862   	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     126:	40 91 58 02 	lds	r20, 0x0258
     12a:	f1 c1       	rjmp	.+994    	; 0x50e <UpdateAudioChannel0+0x41c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     130:	80 91 e7 02 	lds	r24, 0x02E7
     134:	90 91 e8 02 	lds	r25, 0x02E8
     138:	a0 91 e9 02 	lds	r26, 0x02E9
     13c:	b0 91 ea 02 	lds	r27, 0x02EA
     140:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     142:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     144:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     146:	80 91 e7 02 	lds	r24, 0x02E7
     14a:	90 91 e8 02 	lds	r25, 0x02E8
     14e:	a0 91 e9 02 	lds	r26, 0x02E9
     152:	b0 91 ea 02 	lds	r27, 0x02EA
     156:	89 2f       	mov	r24, r25
     158:	9a 2f       	mov	r25, r26
     15a:	ab 2f       	mov	r26, r27
     15c:	bb 27       	eor	r27, r27
     15e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     160:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     162:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     164:	80 91 e7 02 	lds	r24, 0x02E7
     168:	90 91 e8 02 	lds	r25, 0x02E8
     16c:	a0 91 e9 02 	lds	r26, 0x02E9
     170:	b0 91 ea 02 	lds	r27, 0x02EA
     174:	cd 01       	movw	r24, r26
     176:	aa 27       	eor	r26, r26
     178:	bb 27       	eor	r27, r27
     17a:	87 70       	andi	r24, 0x07	; 7
     17c:	88 68       	ori	r24, 0x88	; 136
     17e:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     180:	80 91 58 02 	lds	r24, 0x0258
     184:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     186:	80 91 e7 02 	lds	r24, 0x02E7
     18a:	90 91 e8 02 	lds	r25, 0x02E8
     18e:	a0 91 e9 02 	lds	r26, 0x02E9
     192:	b0 91 ea 02 	lds	r27, 0x02EA
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	a1 1d       	adc	r26, r1
     19a:	b1 1d       	adc	r27, r1
     19c:	80 93 e7 02 	sts	0x02E7, r24
     1a0:	90 93 e8 02 	sts	0x02E8, r25
     1a4:	a0 93 e9 02 	sts	0x02E9, r26
     1a8:	b0 93 ea 02 	sts	0x02EA, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1ac:	80 91 e7 02 	lds	r24, 0x02E7
     1b0:	90 91 e8 02 	lds	r25, 0x02E8
     1b4:	a0 91 e9 02 	lds	r26, 0x02E9
     1b8:	b0 91 ea 02 	lds	r27, 0x02EA
     1bc:	80 93 d4 02 	sts	0x02D4, r24
     1c0:	90 93 d5 02 	sts	0x02D5, r25
     1c4:	a0 93 d6 02 	sts	0x02D6, r26
     1c8:	b0 93 d7 02 	sts	0x02D7, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1cc:	80 91 e7 02 	lds	r24, 0x02E7
     1d0:	90 91 e8 02 	lds	r25, 0x02E8
     1d4:	a0 91 e9 02 	lds	r26, 0x02E9
     1d8:	b0 91 ea 02 	lds	r27, 0x02EA
     1dc:	80 93 dc 02 	sts	0x02DC, r24
     1e0:	90 93 dd 02 	sts	0x02DD, r25
     1e4:	a0 93 de 02 	sts	0x02DE, r26
     1e8:	b0 93 df 02 	sts	0x02DF, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1ec:	20 91 d4 02 	lds	r18, 0x02D4
     1f0:	30 91 d5 02 	lds	r19, 0x02D5
     1f4:	40 91 d6 02 	lds	r20, 0x02D6
     1f8:	50 91 d7 02 	lds	r21, 0x02D7
     1fc:	80 91 f6 02 	lds	r24, 0x02F6
     200:	90 91 f7 02 	lds	r25, 0x02F7
     204:	a0 91 f8 02 	lds	r26, 0x02F8
     208:	b0 91 f9 02 	lds	r27, 0x02F9
     20c:	28 17       	cp	r18, r24
     20e:	39 07       	cpc	r19, r25
     210:	4a 07       	cpc	r20, r26
     212:	5b 07       	cpc	r21, r27
     214:	28 f0       	brcs	.+10     	; 0x220 <UpdateAudioChannel0+0x12e>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     216:	10 92 c9 02 	sts	0x02C9, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	80 93 42 01 	sts	0x0142, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     220:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     222:	11 9a       	sbi	0x02, 1	; 2
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	22 c3       	rjmp	.+1604   	; 0x86c <UpdateAudioChannel0+0x77a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     228:	80 91 e7 02 	lds	r24, 0x02E7
     22c:	90 91 e8 02 	lds	r25, 0x02E8
     230:	a0 91 e9 02 	lds	r26, 0x02E9
     234:	b0 91 ea 02 	lds	r27, 0x02EA
     238:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23a:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23c:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     23e:	80 91 e7 02 	lds	r24, 0x02E7
     242:	90 91 e8 02 	lds	r25, 0x02E8
     246:	a0 91 e9 02 	lds	r26, 0x02E9
     24a:	b0 91 ea 02 	lds	r27, 0x02EA
     24e:	89 2f       	mov	r24, r25
     250:	9a 2f       	mov	r25, r26
     252:	ab 2f       	mov	r26, r27
     254:	bb 27       	eor	r27, r27
     256:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     258:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25a:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25c:	80 91 e7 02 	lds	r24, 0x02E7
     260:	90 91 e8 02 	lds	r25, 0x02E8
     264:	a0 91 e9 02 	lds	r26, 0x02E9
     268:	b0 91 ea 02 	lds	r27, 0x02EA
     26c:	cd 01       	movw	r24, r26
     26e:	aa 27       	eor	r26, r26
     270:	bb 27       	eor	r27, r27
     272:	87 70       	andi	r24, 0x07	; 7
     274:	88 68       	ori	r24, 0x88	; 136
     276:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     278:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     27a:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     27c:	80 91 ce 02 	lds	r24, 0x02CE
     280:	88 23       	and	r24, r24
     282:	09 f4       	brne	.+2      	; 0x286 <UpdateAudioChannel0+0x194>
     284:	6c c0       	rjmp	.+216    	; 0x35e <UpdateAudioChannel0+0x26c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     286:	80 91 50 01 	lds	r24, 0x0150
     28a:	90 91 51 01 	lds	r25, 0x0151
     28e:	a0 91 52 01 	lds	r26, 0x0152
     292:	b0 91 53 01 	lds	r27, 0x0153
     296:	00 97       	sbiw	r24, 0x00	; 0
     298:	a1 05       	cpc	r26, r1
     29a:	b1 05       	cpc	r27, r1
     29c:	39 f1       	breq	.+78     	; 0x2ec <UpdateAudioChannel0+0x1fa>
			{
				bankStates[BANK_0].currentAddress++;
     29e:	80 91 e7 02 	lds	r24, 0x02E7
     2a2:	90 91 e8 02 	lds	r25, 0x02E8
     2a6:	a0 91 e9 02 	lds	r26, 0x02E9
     2aa:	b0 91 ea 02 	lds	r27, 0x02EA
     2ae:	01 96       	adiw	r24, 0x01	; 1
     2b0:	a1 1d       	adc	r26, r1
     2b2:	b1 1d       	adc	r27, r1
     2b4:	80 93 e7 02 	sts	0x02E7, r24
     2b8:	90 93 e8 02 	sts	0x02E8, r25
     2bc:	a0 93 e9 02 	sts	0x02E9, r26
     2c0:	b0 93 ea 02 	sts	0x02EA, r27
				sliceRemaining[BANK_0]--;
     2c4:	80 91 50 01 	lds	r24, 0x0150
     2c8:	90 91 51 01 	lds	r25, 0x0151
     2cc:	a0 91 52 01 	lds	r26, 0x0152
     2d0:	b0 91 53 01 	lds	r27, 0x0153
     2d4:	01 97       	sbiw	r24, 0x01	; 1
     2d6:	a1 09       	sbc	r26, r1
     2d8:	b1 09       	sbc	r27, r1
     2da:	80 93 50 01 	sts	0x0150, r24
     2de:	90 93 51 01 	sts	0x0151, r25
     2e2:	a0 93 52 01 	sts	0x0152, r26
     2e6:	b0 93 53 01 	sts	0x0153, r27
     2ea:	0d c1       	rjmp	.+538    	; 0x506 <UpdateAudioChannel0+0x414>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2ec:	80 91 48 01 	lds	r24, 0x0148
     2f0:	90 91 49 01 	lds	r25, 0x0149
     2f4:	a0 91 4a 01 	lds	r26, 0x014A
     2f8:	b0 91 4b 01 	lds	r27, 0x014B
     2fc:	80 93 50 01 	sts	0x0150, r24
     300:	90 93 51 01 	sts	0x0151, r25
     304:	a0 93 52 01 	sts	0x0152, r26
     308:	b0 93 53 01 	sts	0x0153, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     30c:	80 91 46 01 	lds	r24, 0x0146
     310:	8f 5f       	subi	r24, 0xFF	; 255
     312:	80 93 46 01 	sts	0x0146, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     316:	90 91 46 01 	lds	r25, 0x0146
     31a:	80 91 ce 02 	lds	r24, 0x02CE
     31e:	98 17       	cp	r25, r24
     320:	11 f4       	brne	.+4      	; 0x326 <UpdateAudioChannel0+0x234>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     322:	10 92 46 01 	sts	0x0146, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     326:	e0 91 46 01 	lds	r30, 0x0146
     32a:	20 91 48 01 	lds	r18, 0x0148
     32e:	30 91 49 01 	lds	r19, 0x0149
     332:	40 91 4a 01 	lds	r20, 0x014A
     336:	50 91 4b 01 	lds	r21, 0x014B
     33a:	f0 e0       	ldi	r31, 0x00	; 0
     33c:	e8 5a       	subi	r30, 0xA8	; 168
     33e:	fe 4f       	sbci	r31, 0xFE	; 254
     340:	60 81       	ld	r22, Z
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 e0       	ldi	r24, 0x00	; 0
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
     34c:	60 93 e7 02 	sts	0x02E7, r22
     350:	70 93 e8 02 	sts	0x02E8, r23
     354:	80 93 e9 02 	sts	0x02E9, r24
     358:	90 93 ea 02 	sts	0x02EA, r25
     35c:	d4 c0       	rjmp	.+424    	; 0x506 <UpdateAudioChannel0+0x414>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     35e:	80 91 cd 02 	lds	r24, 0x02CD
     362:	88 23       	and	r24, r24
     364:	09 f0       	breq	.+2      	; 0x368 <UpdateAudioChannel0+0x276>
     366:	62 c0       	rjmp	.+196    	; 0x42c <UpdateAudioChannel0+0x33a>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     368:	20 91 e7 02 	lds	r18, 0x02E7
     36c:	30 91 e8 02 	lds	r19, 0x02E8
     370:	40 91 e9 02 	lds	r20, 0x02E9
     374:	50 91 ea 02 	lds	r21, 0x02EA
     378:	80 91 e0 02 	lds	r24, 0x02E0
     37c:	90 91 e1 02 	lds	r25, 0x02E1
     380:	a0 91 e2 02 	lds	r26, 0x02E2
     384:	b0 91 e3 02 	lds	r27, 0x02E3
     388:	28 17       	cp	r18, r24
     38a:	39 07       	cpc	r19, r25
     38c:	4a 07       	cpc	r20, r26
     38e:	5b 07       	cpc	r21, r27
     390:	29 f4       	brne	.+10     	; 0x39c <UpdateAudioChannel0+0x2aa>
     392:	80 91 ca 02 	lds	r24, 0x02CA
     396:	81 30       	cpi	r24, 0x01	; 1
     398:	09 f4       	brne	.+2      	; 0x39c <UpdateAudioChannel0+0x2aa>
     39a:	61 c0       	rjmp	.+194    	; 0x45e <UpdateAudioChannel0+0x36c>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39c:	20 91 e7 02 	lds	r18, 0x02E7
     3a0:	30 91 e8 02 	lds	r19, 0x02E8
     3a4:	40 91 e9 02 	lds	r20, 0x02E9
     3a8:	50 91 ea 02 	lds	r21, 0x02EA
     3ac:	80 91 e0 02 	lds	r24, 0x02E0
     3b0:	90 91 e1 02 	lds	r25, 0x02E1
     3b4:	a0 91 e2 02 	lds	r26, 0x02E2
     3b8:	b0 91 e3 02 	lds	r27, 0x02E3
     3bc:	28 17       	cp	r18, r24
     3be:	39 07       	cpc	r19, r25
     3c0:	4a 07       	cpc	r20, r26
     3c2:	5b 07       	cpc	r21, r27
     3c4:	49 f4       	brne	.+18     	; 0x3d8 <UpdateAudioChannel0+0x2e6>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c6:	80 91 dc 02 	lds	r24, 0x02DC
     3ca:	90 91 dd 02 	lds	r25, 0x02DD
     3ce:	a0 91 de 02 	lds	r26, 0x02DE
     3d2:	b0 91 df 02 	lds	r27, 0x02DF
     3d6:	8f c0       	rjmp	.+286    	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3d8:	20 91 e7 02 	lds	r18, 0x02E7
     3dc:	30 91 e8 02 	lds	r19, 0x02E8
     3e0:	40 91 e9 02 	lds	r20, 0x02E9
     3e4:	50 91 ea 02 	lds	r21, 0x02EA
     3e8:	80 91 d8 02 	lds	r24, 0x02D8
     3ec:	90 91 d9 02 	lds	r25, 0x02D9
     3f0:	a0 91 da 02 	lds	r26, 0x02DA
     3f4:	b0 91 db 02 	lds	r27, 0x02DB
     3f8:	28 17       	cp	r18, r24
     3fa:	39 07       	cpc	r19, r25
     3fc:	4a 07       	cpc	r20, r26
     3fe:	5b 07       	cpc	r21, r27
     400:	49 f4       	brne	.+18     	; 0x414 <UpdateAudioChannel0+0x322>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     402:	80 91 d4 02 	lds	r24, 0x02D4
     406:	90 91 d5 02 	lds	r25, 0x02D5
     40a:	a0 91 d6 02 	lds	r26, 0x02D6
     40e:	b0 91 d7 02 	lds	r27, 0x02D7
     412:	71 c0       	rjmp	.+226    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     414:	80 91 e7 02 	lds	r24, 0x02E7
     418:	90 91 e8 02 	lds	r25, 0x02E8
     41c:	a0 91 e9 02 	lds	r26, 0x02E9
     420:	b0 91 ea 02 	lds	r27, 0x02EA
     424:	01 97       	sbiw	r24, 0x01	; 1
     426:	a1 09       	sbc	r26, r1
     428:	b1 09       	sbc	r27, r1
     42a:	65 c0       	rjmp	.+202    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42c:	20 91 e7 02 	lds	r18, 0x02E7
     430:	30 91 e8 02 	lds	r19, 0x02E8
     434:	40 91 e9 02 	lds	r20, 0x02E9
     438:	50 91 ea 02 	lds	r21, 0x02EA
     43c:	80 91 dc 02 	lds	r24, 0x02DC
     440:	90 91 dd 02 	lds	r25, 0x02DD
     444:	a0 91 de 02 	lds	r26, 0x02DE
     448:	b0 91 df 02 	lds	r27, 0x02DF
     44c:	28 17       	cp	r18, r24
     44e:	39 07       	cpc	r19, r25
     450:	4a 07       	cpc	r20, r26
     452:	5b 07       	cpc	r21, r27
     454:	49 f4       	brne	.+18     	; 0x468 <UpdateAudioChannel0+0x376>
     456:	80 91 ca 02 	lds	r24, 0x02CA
     45a:	81 30       	cpi	r24, 0x01	; 1
     45c:	29 f4       	brne	.+10     	; 0x468 <UpdateAudioChannel0+0x376>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     45e:	10 92 c9 02 	sts	0x02C9, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     462:	10 92 d1 02 	sts	0x02D1, r1
     466:	4f c0       	rjmp	.+158    	; 0x506 <UpdateAudioChannel0+0x414>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     468:	20 91 e7 02 	lds	r18, 0x02E7
     46c:	30 91 e8 02 	lds	r19, 0x02E8
     470:	40 91 e9 02 	lds	r20, 0x02E9
     474:	50 91 ea 02 	lds	r21, 0x02EA
     478:	80 91 dc 02 	lds	r24, 0x02DC
     47c:	90 91 dd 02 	lds	r25, 0x02DD
     480:	a0 91 de 02 	lds	r26, 0x02DE
     484:	b0 91 df 02 	lds	r27, 0x02DF
     488:	28 17       	cp	r18, r24
     48a:	39 07       	cpc	r19, r25
     48c:	4a 07       	cpc	r20, r26
     48e:	5b 07       	cpc	r21, r27
     490:	49 f4       	brne	.+18     	; 0x4a4 <UpdateAudioChannel0+0x3b2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     492:	80 91 e0 02 	lds	r24, 0x02E0
     496:	90 91 e1 02 	lds	r25, 0x02E1
     49a:	a0 91 e2 02 	lds	r26, 0x02E2
     49e:	b0 91 e3 02 	lds	r27, 0x02E3
     4a2:	29 c0       	rjmp	.+82     	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     4a4:	20 91 e7 02 	lds	r18, 0x02E7
     4a8:	30 91 e8 02 	lds	r19, 0x02E8
     4ac:	40 91 e9 02 	lds	r20, 0x02E9
     4b0:	50 91 ea 02 	lds	r21, 0x02EA
     4b4:	80 91 d4 02 	lds	r24, 0x02D4
     4b8:	90 91 d5 02 	lds	r25, 0x02D5
     4bc:	a0 91 d6 02 	lds	r26, 0x02D6
     4c0:	b0 91 d7 02 	lds	r27, 0x02D7
     4c4:	28 17       	cp	r18, r24
     4c6:	39 07       	cpc	r19, r25
     4c8:	4a 07       	cpc	r20, r26
     4ca:	5b 07       	cpc	r21, r27
     4cc:	49 f4       	brne	.+18     	; 0x4e0 <UpdateAudioChannel0+0x3ee>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4ce:	80 91 d8 02 	lds	r24, 0x02D8
     4d2:	90 91 d9 02 	lds	r25, 0x02D9
     4d6:	a0 91 da 02 	lds	r26, 0x02DA
     4da:	b0 91 db 02 	lds	r27, 0x02DB
     4de:	0b c0       	rjmp	.+22     	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4e0:	80 91 e7 02 	lds	r24, 0x02E7
     4e4:	90 91 e8 02 	lds	r25, 0x02E8
     4e8:	a0 91 e9 02 	lds	r26, 0x02E9
     4ec:	b0 91 ea 02 	lds	r27, 0x02EA
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	a1 1d       	adc	r26, r1
     4f4:	b1 1d       	adc	r27, r1
     4f6:	80 93 e7 02 	sts	0x02E7, r24
     4fa:	90 93 e8 02 	sts	0x02E8, r25
     4fe:	a0 93 e9 02 	sts	0x02E9, r26
     502:	b0 93 ea 02 	sts	0x02EA, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     506:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     508:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     50a:	8f ef       	ldi	r24, 0xFF	; 255
     50c:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     50e:	80 91 d0 02 	lds	r24, 0x02D0
     512:	88 23       	and	r24, r24
     514:	09 f4       	brne	.+2      	; 0x518 <UpdateAudioChannel0+0x426>
     516:	aa c1       	rjmp	.+852    	; 0x86c <UpdateAudioChannel0+0x77a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     518:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     51a:	20 91 d0 02 	lds	r18, 0x02D0
     51e:	8f ef       	ldi	r24, 0xFF	; 255
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	02 c0       	rjmp	.+4      	; 0x528 <UpdateAudioChannel0+0x436>
     524:	88 0f       	add	r24, r24
     526:	99 1f       	adc	r25, r25
     528:	2a 95       	dec	r18
     52a:	e2 f7       	brpl	.-8      	; 0x524 <UpdateAudioChannel0+0x432>
     52c:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     52e:	40 58       	subi	r20, 0x80	; 128
     530:	9d c1       	rjmp	.+826    	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     532:	80 91 e7 02 	lds	r24, 0x02E7
     536:	90 91 e8 02 	lds	r25, 0x02E8
     53a:	a0 91 e9 02 	lds	r26, 0x02E9
     53e:	b0 91 ea 02 	lds	r27, 0x02EA
     542:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     544:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     546:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     548:	80 91 e7 02 	lds	r24, 0x02E7
     54c:	90 91 e8 02 	lds	r25, 0x02E8
     550:	a0 91 e9 02 	lds	r26, 0x02E9
     554:	b0 91 ea 02 	lds	r27, 0x02EA
     558:	89 2f       	mov	r24, r25
     55a:	9a 2f       	mov	r25, r26
     55c:	ab 2f       	mov	r26, r27
     55e:	bb 27       	eor	r27, r27
     560:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     562:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     564:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     566:	80 91 e7 02 	lds	r24, 0x02E7
     56a:	90 91 e8 02 	lds	r25, 0x02E8
     56e:	a0 91 e9 02 	lds	r26, 0x02E9
     572:	b0 91 ea 02 	lds	r27, 0x02EA
     576:	cd 01       	movw	r24, r26
     578:	aa 27       	eor	r26, r26
     57a:	bb 27       	eor	r27, r27
     57c:	87 70       	andi	r24, 0x07	; 7
     57e:	88 68       	ori	r24, 0x88	; 136
     580:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     582:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     584:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     586:	80 91 ce 02 	lds	r24, 0x02CE
     58a:	88 23       	and	r24, r24
     58c:	09 f4       	brne	.+2      	; 0x590 <UpdateAudioChannel0+0x49e>
     58e:	6c c0       	rjmp	.+216    	; 0x668 <UpdateAudioChannel0+0x576>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     590:	80 91 50 01 	lds	r24, 0x0150
     594:	90 91 51 01 	lds	r25, 0x0151
     598:	a0 91 52 01 	lds	r26, 0x0152
     59c:	b0 91 53 01 	lds	r27, 0x0153
     5a0:	00 97       	sbiw	r24, 0x00	; 0
     5a2:	a1 05       	cpc	r26, r1
     5a4:	b1 05       	cpc	r27, r1
     5a6:	39 f1       	breq	.+78     	; 0x5f6 <UpdateAudioChannel0+0x504>
			{
				bankStates[BANK_0].currentAddress++;
     5a8:	80 91 e7 02 	lds	r24, 0x02E7
     5ac:	90 91 e8 02 	lds	r25, 0x02E8
     5b0:	a0 91 e9 02 	lds	r26, 0x02E9
     5b4:	b0 91 ea 02 	lds	r27, 0x02EA
     5b8:	01 96       	adiw	r24, 0x01	; 1
     5ba:	a1 1d       	adc	r26, r1
     5bc:	b1 1d       	adc	r27, r1
     5be:	80 93 e7 02 	sts	0x02E7, r24
     5c2:	90 93 e8 02 	sts	0x02E8, r25
     5c6:	a0 93 e9 02 	sts	0x02E9, r26
     5ca:	b0 93 ea 02 	sts	0x02EA, r27
				sliceRemaining[BANK_0]--;
     5ce:	80 91 50 01 	lds	r24, 0x0150
     5d2:	90 91 51 01 	lds	r25, 0x0151
     5d6:	a0 91 52 01 	lds	r26, 0x0152
     5da:	b0 91 53 01 	lds	r27, 0x0153
     5de:	01 97       	sbiw	r24, 0x01	; 1
     5e0:	a1 09       	sbc	r26, r1
     5e2:	b1 09       	sbc	r27, r1
     5e4:	80 93 50 01 	sts	0x0150, r24
     5e8:	90 93 51 01 	sts	0x0151, r25
     5ec:	a0 93 52 01 	sts	0x0152, r26
     5f0:	b0 93 53 01 	sts	0x0153, r27
     5f4:	0d c1       	rjmp	.+538    	; 0x810 <UpdateAudioChannel0+0x71e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5f6:	80 91 48 01 	lds	r24, 0x0148
     5fa:	90 91 49 01 	lds	r25, 0x0149
     5fe:	a0 91 4a 01 	lds	r26, 0x014A
     602:	b0 91 4b 01 	lds	r27, 0x014B
     606:	80 93 50 01 	sts	0x0150, r24
     60a:	90 93 51 01 	sts	0x0151, r25
     60e:	a0 93 52 01 	sts	0x0152, r26
     612:	b0 93 53 01 	sts	0x0153, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     616:	80 91 46 01 	lds	r24, 0x0146
     61a:	8f 5f       	subi	r24, 0xFF	; 255
     61c:	80 93 46 01 	sts	0x0146, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     620:	90 91 46 01 	lds	r25, 0x0146
     624:	80 91 ce 02 	lds	r24, 0x02CE
     628:	98 17       	cp	r25, r24
     62a:	11 f4       	brne	.+4      	; 0x630 <UpdateAudioChannel0+0x53e>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     62c:	10 92 46 01 	sts	0x0146, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     630:	e0 91 46 01 	lds	r30, 0x0146
     634:	20 91 48 01 	lds	r18, 0x0148
     638:	30 91 49 01 	lds	r19, 0x0149
     63c:	40 91 4a 01 	lds	r20, 0x014A
     640:	50 91 4b 01 	lds	r21, 0x014B
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	e8 5a       	subi	r30, 0xA8	; 168
     648:	fe 4f       	sbci	r31, 0xFE	; 254
     64a:	60 81       	ld	r22, Z
     64c:	70 e0       	ldi	r23, 0x00	; 0
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
     656:	60 93 e7 02 	sts	0x02E7, r22
     65a:	70 93 e8 02 	sts	0x02E8, r23
     65e:	80 93 e9 02 	sts	0x02E9, r24
     662:	90 93 ea 02 	sts	0x02EA, r25
     666:	d4 c0       	rjmp	.+424    	; 0x810 <UpdateAudioChannel0+0x71e>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     668:	80 91 cd 02 	lds	r24, 0x02CD
     66c:	88 23       	and	r24, r24
     66e:	09 f0       	breq	.+2      	; 0x672 <UpdateAudioChannel0+0x580>
     670:	62 c0       	rjmp	.+196    	; 0x736 <UpdateAudioChannel0+0x644>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     672:	20 91 e7 02 	lds	r18, 0x02E7
     676:	30 91 e8 02 	lds	r19, 0x02E8
     67a:	40 91 e9 02 	lds	r20, 0x02E9
     67e:	50 91 ea 02 	lds	r21, 0x02EA
     682:	80 91 e0 02 	lds	r24, 0x02E0
     686:	90 91 e1 02 	lds	r25, 0x02E1
     68a:	a0 91 e2 02 	lds	r26, 0x02E2
     68e:	b0 91 e3 02 	lds	r27, 0x02E3
     692:	28 17       	cp	r18, r24
     694:	39 07       	cpc	r19, r25
     696:	4a 07       	cpc	r20, r26
     698:	5b 07       	cpc	r21, r27
     69a:	29 f4       	brne	.+10     	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     69c:	80 91 ca 02 	lds	r24, 0x02CA
     6a0:	81 30       	cpi	r24, 0x01	; 1
     6a2:	09 f4       	brne	.+2      	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     6a4:	61 c0       	rjmp	.+194    	; 0x768 <UpdateAudioChannel0+0x676>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     6a6:	20 91 e7 02 	lds	r18, 0x02E7
     6aa:	30 91 e8 02 	lds	r19, 0x02E8
     6ae:	40 91 e9 02 	lds	r20, 0x02E9
     6b2:	50 91 ea 02 	lds	r21, 0x02EA
     6b6:	80 91 e0 02 	lds	r24, 0x02E0
     6ba:	90 91 e1 02 	lds	r25, 0x02E1
     6be:	a0 91 e2 02 	lds	r26, 0x02E2
     6c2:	b0 91 e3 02 	lds	r27, 0x02E3
     6c6:	28 17       	cp	r18, r24
     6c8:	39 07       	cpc	r19, r25
     6ca:	4a 07       	cpc	r20, r26
     6cc:	5b 07       	cpc	r21, r27
     6ce:	49 f4       	brne	.+18     	; 0x6e2 <UpdateAudioChannel0+0x5f0>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6d0:	80 91 dc 02 	lds	r24, 0x02DC
     6d4:	90 91 dd 02 	lds	r25, 0x02DD
     6d8:	a0 91 de 02 	lds	r26, 0x02DE
     6dc:	b0 91 df 02 	lds	r27, 0x02DF
     6e0:	8f c0       	rjmp	.+286    	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6e2:	20 91 e7 02 	lds	r18, 0x02E7
     6e6:	30 91 e8 02 	lds	r19, 0x02E8
     6ea:	40 91 e9 02 	lds	r20, 0x02E9
     6ee:	50 91 ea 02 	lds	r21, 0x02EA
     6f2:	80 91 d8 02 	lds	r24, 0x02D8
     6f6:	90 91 d9 02 	lds	r25, 0x02D9
     6fa:	a0 91 da 02 	lds	r26, 0x02DA
     6fe:	b0 91 db 02 	lds	r27, 0x02DB
     702:	28 17       	cp	r18, r24
     704:	39 07       	cpc	r19, r25
     706:	4a 07       	cpc	r20, r26
     708:	5b 07       	cpc	r21, r27
     70a:	49 f4       	brne	.+18     	; 0x71e <UpdateAudioChannel0+0x62c>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     70c:	80 91 d4 02 	lds	r24, 0x02D4
     710:	90 91 d5 02 	lds	r25, 0x02D5
     714:	a0 91 d6 02 	lds	r26, 0x02D6
     718:	b0 91 d7 02 	lds	r27, 0x02D7
     71c:	71 c0       	rjmp	.+226    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     71e:	80 91 e7 02 	lds	r24, 0x02E7
     722:	90 91 e8 02 	lds	r25, 0x02E8
     726:	a0 91 e9 02 	lds	r26, 0x02E9
     72a:	b0 91 ea 02 	lds	r27, 0x02EA
     72e:	01 97       	sbiw	r24, 0x01	; 1
     730:	a1 09       	sbc	r26, r1
     732:	b1 09       	sbc	r27, r1
     734:	65 c0       	rjmp	.+202    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     736:	20 91 e7 02 	lds	r18, 0x02E7
     73a:	30 91 e8 02 	lds	r19, 0x02E8
     73e:	40 91 e9 02 	lds	r20, 0x02E9
     742:	50 91 ea 02 	lds	r21, 0x02EA
     746:	80 91 dc 02 	lds	r24, 0x02DC
     74a:	90 91 dd 02 	lds	r25, 0x02DD
     74e:	a0 91 de 02 	lds	r26, 0x02DE
     752:	b0 91 df 02 	lds	r27, 0x02DF
     756:	28 17       	cp	r18, r24
     758:	39 07       	cpc	r19, r25
     75a:	4a 07       	cpc	r20, r26
     75c:	5b 07       	cpc	r21, r27
     75e:	49 f4       	brne	.+18     	; 0x772 <UpdateAudioChannel0+0x680>
     760:	80 91 ca 02 	lds	r24, 0x02CA
     764:	81 30       	cpi	r24, 0x01	; 1
     766:	29 f4       	brne	.+10     	; 0x772 <UpdateAudioChannel0+0x680>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     768:	10 92 c9 02 	sts	0x02C9, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     76c:	10 92 d1 02 	sts	0x02D1, r1
     770:	4f c0       	rjmp	.+158    	; 0x810 <UpdateAudioChannel0+0x71e>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     772:	20 91 e7 02 	lds	r18, 0x02E7
     776:	30 91 e8 02 	lds	r19, 0x02E8
     77a:	40 91 e9 02 	lds	r20, 0x02E9
     77e:	50 91 ea 02 	lds	r21, 0x02EA
     782:	80 91 dc 02 	lds	r24, 0x02DC
     786:	90 91 dd 02 	lds	r25, 0x02DD
     78a:	a0 91 de 02 	lds	r26, 0x02DE
     78e:	b0 91 df 02 	lds	r27, 0x02DF
     792:	28 17       	cp	r18, r24
     794:	39 07       	cpc	r19, r25
     796:	4a 07       	cpc	r20, r26
     798:	5b 07       	cpc	r21, r27
     79a:	49 f4       	brne	.+18     	; 0x7ae <UpdateAudioChannel0+0x6bc>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     79c:	80 91 e0 02 	lds	r24, 0x02E0
     7a0:	90 91 e1 02 	lds	r25, 0x02E1
     7a4:	a0 91 e2 02 	lds	r26, 0x02E2
     7a8:	b0 91 e3 02 	lds	r27, 0x02E3
     7ac:	29 c0       	rjmp	.+82     	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     7ae:	20 91 e7 02 	lds	r18, 0x02E7
     7b2:	30 91 e8 02 	lds	r19, 0x02E8
     7b6:	40 91 e9 02 	lds	r20, 0x02E9
     7ba:	50 91 ea 02 	lds	r21, 0x02EA
     7be:	80 91 d4 02 	lds	r24, 0x02D4
     7c2:	90 91 d5 02 	lds	r25, 0x02D5
     7c6:	a0 91 d6 02 	lds	r26, 0x02D6
     7ca:	b0 91 d7 02 	lds	r27, 0x02D7
     7ce:	28 17       	cp	r18, r24
     7d0:	39 07       	cpc	r19, r25
     7d2:	4a 07       	cpc	r20, r26
     7d4:	5b 07       	cpc	r21, r27
     7d6:	49 f4       	brne	.+18     	; 0x7ea <UpdateAudioChannel0+0x6f8>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7d8:	80 91 d8 02 	lds	r24, 0x02D8
     7dc:	90 91 d9 02 	lds	r25, 0x02D9
     7e0:	a0 91 da 02 	lds	r26, 0x02DA
     7e4:	b0 91 db 02 	lds	r27, 0x02DB
     7e8:	0b c0       	rjmp	.+22     	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7ea:	80 91 e7 02 	lds	r24, 0x02E7
     7ee:	90 91 e8 02 	lds	r25, 0x02E8
     7f2:	a0 91 e9 02 	lds	r26, 0x02E9
     7f6:	b0 91 ea 02 	lds	r27, 0x02EA
     7fa:	01 96       	adiw	r24, 0x01	; 1
     7fc:	a1 1d       	adc	r26, r1
     7fe:	b1 1d       	adc	r27, r1
     800:	80 93 e7 02 	sts	0x02E7, r24
     804:	90 93 e8 02 	sts	0x02E8, r25
     808:	a0 93 e9 02 	sts	0x02E9, r26
     80c:	b0 93 ea 02 	sts	0x02EA, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM		

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     810:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     812:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     818:	80 91 d0 02 	lds	r24, 0x02D0
     81c:	88 23       	and	r24, r24
     81e:	61 f0       	breq	.+24     	; 0x838 <UpdateAudioChannel0+0x746>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     820:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     822:	20 91 d0 02 	lds	r18, 0x02D0
     826:	8f ef       	ldi	r24, 0xFF	; 255
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	02 c0       	rjmp	.+4      	; 0x830 <UpdateAudioChannel0+0x73e>
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	2a 95       	dec	r18
     832:	e2 f7       	brpl	.-8      	; 0x82c <UpdateAudioChannel0+0x73a>
     834:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     836:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     838:	24 2f       	mov	r18, r20
     83a:	33 27       	eor	r19, r19
     83c:	27 fd       	sbrc	r18, 7
     83e:	30 95       	com	r19
     840:	80 91 58 02 	lds	r24, 0x0258
     844:	99 27       	eor	r25, r25
     846:	87 fd       	sbrc	r24, 7
     848:	90 95       	com	r25
     84a:	28 0f       	add	r18, r24
     84c:	39 1f       	adc	r19, r25
     84e:	8f ef       	ldi	r24, 0xFF	; 255
     850:	20 38       	cpi	r18, 0x80	; 128
     852:	38 07       	cpc	r19, r24
     854:	14 f4       	brge	.+4      	; 0x85a <UpdateAudioChannel0+0x768>
     856:	20 e8       	ldi	r18, 0x80	; 128
     858:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     85a:	c9 01       	movw	r24, r18
     85c:	20 38       	cpi	r18, 0x80	; 128
     85e:	31 05       	cpc	r19, r1
     860:	14 f0       	brlt	.+4      	; 0x866 <UpdateAudioChannel0+0x774>
     862:	8f e7       	ldi	r24, 0x7F	; 127
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     868:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     86a:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
     86c:	84 2f       	mov	r24, r20
     86e:	08 95       	ret

00000870 <UpdateAudioChannel1>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     870:	80 91 eb 02 	lds	r24, 0x02EB
     874:	83 30       	cpi	r24, 0x03	; 3
     876:	c9 f0       	breq	.+50     	; 0x8aa <UpdateAudioChannel1+0x3a>
     878:	84 30       	cpi	r24, 0x04	; 4
     87a:	30 f4       	brcc	.+12     	; 0x888 <UpdateAudioChannel1+0x18>
     87c:	81 30       	cpi	r24, 0x01	; 1
     87e:	59 f0       	breq	.+22     	; 0x896 <UpdateAudioChannel1+0x26>
     880:	82 30       	cpi	r24, 0x02	; 2
     882:	09 f0       	breq	.+2      	; 0x886 <UpdateAudioChannel1+0x16>
     884:	8e c0       	rjmp	.+284    	; 0x9a2 <UpdateAudioChannel1+0x132>
     886:	0e c0       	rjmp	.+28     	; 0x8a4 <UpdateAudioChannel1+0x34>
     888:	84 30       	cpi	r24, 0x04	; 4
     88a:	09 f4       	brne	.+2      	; 0x88e <UpdateAudioChannel1+0x1e>
     88c:	8c c0       	rjmp	.+280    	; 0x9a6 <UpdateAudioChannel1+0x136>
     88e:	85 30       	cpi	r24, 0x05	; 5
     890:	09 f0       	breq	.+2      	; 0x894 <UpdateAudioChannel1+0x24>
     892:	87 c0       	rjmp	.+270    	; 0x9a2 <UpdateAudioChannel1+0x132>
     894:	15 c2       	rjmp	.+1066   	; 0xcc0 <UpdateAudioChannel1+0x450>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     896:	40 91 34 01 	lds	r20, 0x0134
     89a:	4f 5f       	subi	r20, 0xFF	; 255
     89c:	40 93 34 01 	sts	0x0134, r20
     8a0:	41 50       	subi	r20, 0x01	; 1
     8a2:	b3 c3       	rjmp	.+1894   	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     8a4:	40 91 58 02 	lds	r20, 0x0258
     8a8:	f9 c1       	rjmp	.+1010   	; 0xc9c <UpdateAudioChannel1+0x42c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     8aa:	8f ef       	ldi	r24, 0xFF	; 255
     8ac:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     8ae:	80 91 09 03 	lds	r24, 0x0309
     8b2:	90 91 0a 03 	lds	r25, 0x030A
     8b6:	a0 91 0b 03 	lds	r26, 0x030B
     8ba:	b0 91 0c 03 	lds	r27, 0x030C
     8be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8c0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8c2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8c4:	80 91 09 03 	lds	r24, 0x0309
     8c8:	90 91 0a 03 	lds	r25, 0x030A
     8cc:	a0 91 0b 03 	lds	r26, 0x030B
     8d0:	b0 91 0c 03 	lds	r27, 0x030C
     8d4:	89 2f       	mov	r24, r25
     8d6:	9a 2f       	mov	r25, r26
     8d8:	ab 2f       	mov	r26, r27
     8da:	bb 27       	eor	r27, r27
     8dc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8de:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8e0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8e2:	80 91 09 03 	lds	r24, 0x0309
     8e6:	90 91 0a 03 	lds	r25, 0x030A
     8ea:	a0 91 0b 03 	lds	r26, 0x030B
     8ee:	b0 91 0c 03 	lds	r27, 0x030C
     8f2:	cd 01       	movw	r24, r26
     8f4:	aa 27       	eor	r26, r26
     8f6:	bb 27       	eor	r27, r27
     8f8:	87 70       	andi	r24, 0x07	; 7
     8fa:	88 68       	ori	r24, 0x88	; 136
     8fc:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8fe:	80 91 58 02 	lds	r24, 0x0258
     902:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     904:	80 91 09 03 	lds	r24, 0x0309
     908:	90 91 0a 03 	lds	r25, 0x030A
     90c:	a0 91 0b 03 	lds	r26, 0x030B
     910:	b0 91 0c 03 	lds	r27, 0x030C
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	a1 09       	sbc	r26, r1
     918:	b1 09       	sbc	r27, r1
     91a:	80 93 09 03 	sts	0x0309, r24
     91e:	90 93 0a 03 	sts	0x030A, r25
     922:	a0 93 0b 03 	sts	0x030B, r26
     926:	b0 93 0c 03 	sts	0x030C, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     92a:	80 91 09 03 	lds	r24, 0x0309
     92e:	90 91 0a 03 	lds	r25, 0x030A
     932:	a0 91 0b 03 	lds	r26, 0x030B
     936:	b0 91 0c 03 	lds	r27, 0x030C
     93a:	80 93 f6 02 	sts	0x02F6, r24
     93e:	90 93 f7 02 	sts	0x02F7, r25
     942:	a0 93 f8 02 	sts	0x02F8, r26
     946:	b0 93 f9 02 	sts	0x02F9, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     94a:	80 91 09 03 	lds	r24, 0x0309
     94e:	90 91 0a 03 	lds	r25, 0x030A
     952:	a0 91 0b 03 	lds	r26, 0x030B
     956:	b0 91 0c 03 	lds	r27, 0x030C
     95a:	80 93 fe 02 	sts	0x02FE, r24
     95e:	90 93 ff 02 	sts	0x02FF, r25
     962:	a0 93 00 03 	sts	0x0300, r26
     966:	b0 93 01 03 	sts	0x0301, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     96a:	20 91 d4 02 	lds	r18, 0x02D4
     96e:	30 91 d5 02 	lds	r19, 0x02D5
     972:	40 91 d6 02 	lds	r20, 0x02D6
     976:	50 91 d7 02 	lds	r21, 0x02D7
     97a:	80 91 f6 02 	lds	r24, 0x02F6
     97e:	90 91 f7 02 	lds	r25, 0x02F7
     982:	a0 91 f8 02 	lds	r26, 0x02F8
     986:	b0 91 f9 02 	lds	r27, 0x02F9
     98a:	28 17       	cp	r18, r24
     98c:	39 07       	cpc	r19, r25
     98e:	4a 07       	cpc	r20, r26
     990:	5b 07       	cpc	r21, r27
     992:	28 f0       	brcs	.+10     	; 0x99e <UpdateAudioChannel1+0x12e>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     994:	10 92 eb 02 	sts	0x02EB, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	80 93 42 01 	sts	0x0142, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     99e:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     9a0:	11 9a       	sbi	0x02, 1	; 2
     9a2:	40 e0       	ldi	r20, 0x00	; 0
     9a4:	32 c3       	rjmp	.+1636   	; 0x100a <UpdateAudioChannel1+0x79a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     9a6:	80 91 09 03 	lds	r24, 0x0309
     9aa:	90 91 0a 03 	lds	r25, 0x030A
     9ae:	a0 91 0b 03 	lds	r26, 0x030B
     9b2:	b0 91 0c 03 	lds	r27, 0x030C
     9b6:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     9b8:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     9ba:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9bc:	80 91 09 03 	lds	r24, 0x0309
     9c0:	90 91 0a 03 	lds	r25, 0x030A
     9c4:	a0 91 0b 03 	lds	r26, 0x030B
     9c8:	b0 91 0c 03 	lds	r27, 0x030C
     9cc:	89 2f       	mov	r24, r25
     9ce:	9a 2f       	mov	r25, r26
     9d0:	ab 2f       	mov	r26, r27
     9d2:	bb 27       	eor	r27, r27
     9d4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9d6:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9d8:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9da:	80 91 09 03 	lds	r24, 0x0309
     9de:	90 91 0a 03 	lds	r25, 0x030A
     9e2:	a0 91 0b 03 	lds	r26, 0x030B
     9e6:	b0 91 0c 03 	lds	r27, 0x030C
     9ea:	cd 01       	movw	r24, r26
     9ec:	aa 27       	eor	r26, r26
     9ee:	bb 27       	eor	r27, r27
     9f0:	87 70       	andi	r24, 0x07	; 7
     9f2:	88 68       	ori	r24, 0x88	; 136
     9f4:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9f6:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9f8:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9fa:	80 91 f0 02 	lds	r24, 0x02F0
     9fe:	88 23       	and	r24, r24
     a00:	09 f4       	brne	.+2      	; 0xa04 <UpdateAudioChannel1+0x194>
     a02:	74 c0       	rjmp	.+232    	; 0xaec <UpdateAudioChannel1+0x27c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     a04:	80 91 54 01 	lds	r24, 0x0154
     a08:	90 91 55 01 	lds	r25, 0x0155
     a0c:	a0 91 56 01 	lds	r26, 0x0156
     a10:	b0 91 57 01 	lds	r27, 0x0157
     a14:	00 97       	sbiw	r24, 0x00	; 0
     a16:	a1 05       	cpc	r26, r1
     a18:	b1 05       	cpc	r27, r1
     a1a:	39 f1       	breq	.+78     	; 0xa6a <UpdateAudioChannel1+0x1fa>
			{
				bankStates[BANK_1].currentAddress--;
     a1c:	80 91 09 03 	lds	r24, 0x0309
     a20:	90 91 0a 03 	lds	r25, 0x030A
     a24:	a0 91 0b 03 	lds	r26, 0x030B
     a28:	b0 91 0c 03 	lds	r27, 0x030C
     a2c:	01 97       	sbiw	r24, 0x01	; 1
     a2e:	a1 09       	sbc	r26, r1
     a30:	b1 09       	sbc	r27, r1
     a32:	80 93 09 03 	sts	0x0309, r24
     a36:	90 93 0a 03 	sts	0x030A, r25
     a3a:	a0 93 0b 03 	sts	0x030B, r26
     a3e:	b0 93 0c 03 	sts	0x030C, r27
				sliceRemaining[BANK_1]--;
     a42:	80 91 54 01 	lds	r24, 0x0154
     a46:	90 91 55 01 	lds	r25, 0x0155
     a4a:	a0 91 56 01 	lds	r26, 0x0156
     a4e:	b0 91 57 01 	lds	r27, 0x0157
     a52:	01 97       	sbiw	r24, 0x01	; 1
     a54:	a1 09       	sbc	r26, r1
     a56:	b1 09       	sbc	r27, r1
     a58:	80 93 54 01 	sts	0x0154, r24
     a5c:	90 93 55 01 	sts	0x0155, r25
     a60:	a0 93 56 01 	sts	0x0156, r26
     a64:	b0 93 57 01 	sts	0x0157, r27
     a68:	15 c1       	rjmp	.+554    	; 0xc94 <UpdateAudioChannel1+0x424>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a6a:	80 91 4c 01 	lds	r24, 0x014C
     a6e:	90 91 4d 01 	lds	r25, 0x014D
     a72:	a0 91 4e 01 	lds	r26, 0x014E
     a76:	b0 91 4f 01 	lds	r27, 0x014F
     a7a:	80 93 54 01 	sts	0x0154, r24
     a7e:	90 93 55 01 	sts	0x0155, r25
     a82:	a0 93 56 01 	sts	0x0156, r26
     a86:	b0 93 57 01 	sts	0x0157, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a8a:	80 91 47 01 	lds	r24, 0x0147
     a8e:	8f 5f       	subi	r24, 0xFF	; 255
     a90:	80 93 47 01 	sts	0x0147, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a94:	90 91 47 01 	lds	r25, 0x0147
     a98:	80 91 f0 02 	lds	r24, 0x02F0
     a9c:	98 17       	cp	r25, r24
     a9e:	11 f4       	brne	.+4      	; 0xaa4 <UpdateAudioChannel1+0x234>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     aa0:	10 92 47 01 	sts	0x0147, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     aa4:	e0 91 47 01 	lds	r30, 0x0147
     aa8:	20 91 4c 01 	lds	r18, 0x014C
     aac:	30 91 4d 01 	lds	r19, 0x014D
     ab0:	40 91 4e 01 	lds	r20, 0x014E
     ab4:	50 91 4f 01 	lds	r21, 0x014F
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	e8 52       	subi	r30, 0x28	; 40
     abc:	fe 4f       	sbci	r31, 0xFE	; 254
     abe:	60 81       	ld	r22, Z
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
     aca:	2f ef       	ldi	r18, 0xFF	; 255
     acc:	3f ef       	ldi	r19, 0xFF	; 255
     ace:	47 e0       	ldi	r20, 0x07	; 7
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	26 1b       	sub	r18, r22
     ad4:	37 0b       	sbc	r19, r23
     ad6:	48 0b       	sbc	r20, r24
     ad8:	59 0b       	sbc	r21, r25
     ada:	20 93 09 03 	sts	0x0309, r18
     ade:	30 93 0a 03 	sts	0x030A, r19
     ae2:	40 93 0b 03 	sts	0x030B, r20
     ae6:	50 93 0c 03 	sts	0x030C, r21
     aea:	d4 c0       	rjmp	.+424    	; 0xc94 <UpdateAudioChannel1+0x424>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     aec:	80 91 ef 02 	lds	r24, 0x02EF
     af0:	88 23       	and	r24, r24
     af2:	09 f0       	breq	.+2      	; 0xaf6 <UpdateAudioChannel1+0x286>
     af4:	62 c0       	rjmp	.+196    	; 0xbba <UpdateAudioChannel1+0x34a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     af6:	20 91 09 03 	lds	r18, 0x0309
     afa:	30 91 0a 03 	lds	r19, 0x030A
     afe:	40 91 0b 03 	lds	r20, 0x030B
     b02:	50 91 0c 03 	lds	r21, 0x030C
     b06:	80 91 02 03 	lds	r24, 0x0302
     b0a:	90 91 03 03 	lds	r25, 0x0303
     b0e:	a0 91 04 03 	lds	r26, 0x0304
     b12:	b0 91 05 03 	lds	r27, 0x0305
     b16:	28 17       	cp	r18, r24
     b18:	39 07       	cpc	r19, r25
     b1a:	4a 07       	cpc	r20, r26
     b1c:	5b 07       	cpc	r21, r27
     b1e:	29 f4       	brne	.+10     	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b20:	80 91 ec 02 	lds	r24, 0x02EC
     b24:	81 30       	cpi	r24, 0x01	; 1
     b26:	09 f4       	brne	.+2      	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b28:	61 c0       	rjmp	.+194    	; 0xbec <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b2a:	20 91 09 03 	lds	r18, 0x0309
     b2e:	30 91 0a 03 	lds	r19, 0x030A
     b32:	40 91 0b 03 	lds	r20, 0x030B
     b36:	50 91 0c 03 	lds	r21, 0x030C
     b3a:	80 91 02 03 	lds	r24, 0x0302
     b3e:	90 91 03 03 	lds	r25, 0x0303
     b42:	a0 91 04 03 	lds	r26, 0x0304
     b46:	b0 91 05 03 	lds	r27, 0x0305
     b4a:	28 17       	cp	r18, r24
     b4c:	39 07       	cpc	r19, r25
     b4e:	4a 07       	cpc	r20, r26
     b50:	5b 07       	cpc	r21, r27
     b52:	49 f4       	brne	.+18     	; 0xb66 <UpdateAudioChannel1+0x2f6>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b54:	80 91 fe 02 	lds	r24, 0x02FE
     b58:	90 91 ff 02 	lds	r25, 0x02FF
     b5c:	a0 91 00 03 	lds	r26, 0x0300
     b60:	b0 91 01 03 	lds	r27, 0x0301
     b64:	8f c0       	rjmp	.+286    	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b66:	20 91 09 03 	lds	r18, 0x0309
     b6a:	30 91 0a 03 	lds	r19, 0x030A
     b6e:	40 91 0b 03 	lds	r20, 0x030B
     b72:	50 91 0c 03 	lds	r21, 0x030C
     b76:	80 91 fa 02 	lds	r24, 0x02FA
     b7a:	90 91 fb 02 	lds	r25, 0x02FB
     b7e:	a0 91 fc 02 	lds	r26, 0x02FC
     b82:	b0 91 fd 02 	lds	r27, 0x02FD
     b86:	28 17       	cp	r18, r24
     b88:	39 07       	cpc	r19, r25
     b8a:	4a 07       	cpc	r20, r26
     b8c:	5b 07       	cpc	r21, r27
     b8e:	49 f4       	brne	.+18     	; 0xba2 <UpdateAudioChannel1+0x332>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b90:	80 91 f6 02 	lds	r24, 0x02F6
     b94:	90 91 f7 02 	lds	r25, 0x02F7
     b98:	a0 91 f8 02 	lds	r26, 0x02F8
     b9c:	b0 91 f9 02 	lds	r27, 0x02F9
     ba0:	71 c0       	rjmp	.+226    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ba2:	80 91 09 03 	lds	r24, 0x0309
     ba6:	90 91 0a 03 	lds	r25, 0x030A
     baa:	a0 91 0b 03 	lds	r26, 0x030B
     bae:	b0 91 0c 03 	lds	r27, 0x030C
     bb2:	01 96       	adiw	r24, 0x01	; 1
     bb4:	a1 1d       	adc	r26, r1
     bb6:	b1 1d       	adc	r27, r1
     bb8:	65 c0       	rjmp	.+202    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     bba:	20 91 09 03 	lds	r18, 0x0309
     bbe:	30 91 0a 03 	lds	r19, 0x030A
     bc2:	40 91 0b 03 	lds	r20, 0x030B
     bc6:	50 91 0c 03 	lds	r21, 0x030C
     bca:	80 91 fe 02 	lds	r24, 0x02FE
     bce:	90 91 ff 02 	lds	r25, 0x02FF
     bd2:	a0 91 00 03 	lds	r26, 0x0300
     bd6:	b0 91 01 03 	lds	r27, 0x0301
     bda:	28 17       	cp	r18, r24
     bdc:	39 07       	cpc	r19, r25
     bde:	4a 07       	cpc	r20, r26
     be0:	5b 07       	cpc	r21, r27
     be2:	49 f4       	brne	.+18     	; 0xbf6 <UpdateAudioChannel1+0x386>
     be4:	80 91 ec 02 	lds	r24, 0x02EC
     be8:	81 30       	cpi	r24, 0x01	; 1
     bea:	29 f4       	brne	.+10     	; 0xbf6 <UpdateAudioChannel1+0x386>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bec:	10 92 eb 02 	sts	0x02EB, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bf0:	10 92 f3 02 	sts	0x02F3, r1
     bf4:	4f c0       	rjmp	.+158    	; 0xc94 <UpdateAudioChannel1+0x424>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bf6:	20 91 09 03 	lds	r18, 0x0309
     bfa:	30 91 0a 03 	lds	r19, 0x030A
     bfe:	40 91 0b 03 	lds	r20, 0x030B
     c02:	50 91 0c 03 	lds	r21, 0x030C
     c06:	80 91 fe 02 	lds	r24, 0x02FE
     c0a:	90 91 ff 02 	lds	r25, 0x02FF
     c0e:	a0 91 00 03 	lds	r26, 0x0300
     c12:	b0 91 01 03 	lds	r27, 0x0301
     c16:	28 17       	cp	r18, r24
     c18:	39 07       	cpc	r19, r25
     c1a:	4a 07       	cpc	r20, r26
     c1c:	5b 07       	cpc	r21, r27
     c1e:	49 f4       	brne	.+18     	; 0xc32 <UpdateAudioChannel1+0x3c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     c20:	80 91 02 03 	lds	r24, 0x0302
     c24:	90 91 03 03 	lds	r25, 0x0303
     c28:	a0 91 04 03 	lds	r26, 0x0304
     c2c:	b0 91 05 03 	lds	r27, 0x0305
     c30:	29 c0       	rjmp	.+82     	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c32:	20 91 09 03 	lds	r18, 0x0309
     c36:	30 91 0a 03 	lds	r19, 0x030A
     c3a:	40 91 0b 03 	lds	r20, 0x030B
     c3e:	50 91 0c 03 	lds	r21, 0x030C
     c42:	80 91 f6 02 	lds	r24, 0x02F6
     c46:	90 91 f7 02 	lds	r25, 0x02F7
     c4a:	a0 91 f8 02 	lds	r26, 0x02F8
     c4e:	b0 91 f9 02 	lds	r27, 0x02F9
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	4a 07       	cpc	r20, r26
     c58:	5b 07       	cpc	r21, r27
     c5a:	49 f4       	brne	.+18     	; 0xc6e <UpdateAudioChannel1+0x3fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c5c:	80 91 fa 02 	lds	r24, 0x02FA
     c60:	90 91 fb 02 	lds	r25, 0x02FB
     c64:	a0 91 fc 02 	lds	r26, 0x02FC
     c68:	b0 91 fd 02 	lds	r27, 0x02FD
     c6c:	0b c0       	rjmp	.+22     	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c6e:	80 91 09 03 	lds	r24, 0x0309
     c72:	90 91 0a 03 	lds	r25, 0x030A
     c76:	a0 91 0b 03 	lds	r26, 0x030B
     c7a:	b0 91 0c 03 	lds	r27, 0x030C
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	a1 09       	sbc	r26, r1
     c82:	b1 09       	sbc	r27, r1
     c84:	80 93 09 03 	sts	0x0309, r24
     c88:	90 93 0a 03 	sts	0x030A, r25
     c8c:	a0 93 0b 03 	sts	0x030B, r26
     c90:	b0 93 0c 03 	sts	0x030C, r27
			}
		}
		
		// Done with addy, read RAM.
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c94:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c96:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c98:	8f ef       	ldi	r24, 0xFF	; 255
     c9a:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c9c:	80 91 f2 02 	lds	r24, 0x02F2
     ca0:	88 23       	and	r24, r24
     ca2:	09 f4       	brne	.+2      	; 0xca6 <UpdateAudioChannel1+0x436>
     ca4:	b2 c1       	rjmp	.+868    	; 0x100a <UpdateAudioChannel1+0x79a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     ca6:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     ca8:	20 91 f2 02 	lds	r18, 0x02F2
     cac:	8f ef       	ldi	r24, 0xFF	; 255
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <UpdateAudioChannel1+0x446>
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	2a 95       	dec	r18
     cb8:	e2 f7       	brpl	.-8      	; 0xcb2 <UpdateAudioChannel1+0x442>
     cba:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     cbc:	40 58       	subi	r20, 0x80	; 128
     cbe:	a5 c1       	rjmp	.+842    	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     cc0:	80 91 09 03 	lds	r24, 0x0309
     cc4:	90 91 0a 03 	lds	r25, 0x030A
     cc8:	a0 91 0b 03 	lds	r26, 0x030B
     ccc:	b0 91 0c 03 	lds	r27, 0x030C
     cd0:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     cd2:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     cd4:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     cd6:	80 91 09 03 	lds	r24, 0x0309
     cda:	90 91 0a 03 	lds	r25, 0x030A
     cde:	a0 91 0b 03 	lds	r26, 0x030B
     ce2:	b0 91 0c 03 	lds	r27, 0x030C
     ce6:	89 2f       	mov	r24, r25
     ce8:	9a 2f       	mov	r25, r26
     cea:	ab 2f       	mov	r26, r27
     cec:	bb 27       	eor	r27, r27
     cee:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cf0:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cf2:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cf4:	80 91 09 03 	lds	r24, 0x0309
     cf8:	90 91 0a 03 	lds	r25, 0x030A
     cfc:	a0 91 0b 03 	lds	r26, 0x030B
     d00:	b0 91 0c 03 	lds	r27, 0x030C
     d04:	cd 01       	movw	r24, r26
     d06:	aa 27       	eor	r26, r26
     d08:	bb 27       	eor	r27, r27
     d0a:	87 70       	andi	r24, 0x07	; 7
     d0c:	88 68       	ori	r24, 0x88	; 136
     d0e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     d10:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     d12:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     d14:	80 91 f0 02 	lds	r24, 0x02F0
     d18:	88 23       	and	r24, r24
     d1a:	09 f4       	brne	.+2      	; 0xd1e <UpdateAudioChannel1+0x4ae>
     d1c:	74 c0       	rjmp	.+232    	; 0xe06 <UpdateAudioChannel1+0x596>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     d1e:	80 91 54 01 	lds	r24, 0x0154
     d22:	90 91 55 01 	lds	r25, 0x0155
     d26:	a0 91 56 01 	lds	r26, 0x0156
     d2a:	b0 91 57 01 	lds	r27, 0x0157
     d2e:	00 97       	sbiw	r24, 0x00	; 0
     d30:	a1 05       	cpc	r26, r1
     d32:	b1 05       	cpc	r27, r1
     d34:	39 f1       	breq	.+78     	; 0xd84 <UpdateAudioChannel1+0x514>
			{
				bankStates[BANK_1].currentAddress--;
     d36:	80 91 09 03 	lds	r24, 0x0309
     d3a:	90 91 0a 03 	lds	r25, 0x030A
     d3e:	a0 91 0b 03 	lds	r26, 0x030B
     d42:	b0 91 0c 03 	lds	r27, 0x030C
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 09 03 	sts	0x0309, r24
     d50:	90 93 0a 03 	sts	0x030A, r25
     d54:	a0 93 0b 03 	sts	0x030B, r26
     d58:	b0 93 0c 03 	sts	0x030C, r27
				sliceRemaining[BANK_1]--;
     d5c:	80 91 54 01 	lds	r24, 0x0154
     d60:	90 91 55 01 	lds	r25, 0x0155
     d64:	a0 91 56 01 	lds	r26, 0x0156
     d68:	b0 91 57 01 	lds	r27, 0x0157
     d6c:	01 97       	sbiw	r24, 0x01	; 1
     d6e:	a1 09       	sbc	r26, r1
     d70:	b1 09       	sbc	r27, r1
     d72:	80 93 54 01 	sts	0x0154, r24
     d76:	90 93 55 01 	sts	0x0155, r25
     d7a:	a0 93 56 01 	sts	0x0156, r26
     d7e:	b0 93 57 01 	sts	0x0157, r27
     d82:	15 c1       	rjmp	.+554    	; 0xfae <UpdateAudioChannel1+0x73e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d84:	80 91 4c 01 	lds	r24, 0x014C
     d88:	90 91 4d 01 	lds	r25, 0x014D
     d8c:	a0 91 4e 01 	lds	r26, 0x014E
     d90:	b0 91 4f 01 	lds	r27, 0x014F
     d94:	80 93 54 01 	sts	0x0154, r24
     d98:	90 93 55 01 	sts	0x0155, r25
     d9c:	a0 93 56 01 	sts	0x0156, r26
     da0:	b0 93 57 01 	sts	0x0157, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     da4:	80 91 47 01 	lds	r24, 0x0147
     da8:	8f 5f       	subi	r24, 0xFF	; 255
     daa:	80 93 47 01 	sts	0x0147, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     dae:	90 91 47 01 	lds	r25, 0x0147
     db2:	80 91 f0 02 	lds	r24, 0x02F0
     db6:	98 17       	cp	r25, r24
     db8:	11 f4       	brne	.+4      	; 0xdbe <UpdateAudioChannel1+0x54e>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     dba:	10 92 47 01 	sts	0x0147, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     dbe:	e0 91 47 01 	lds	r30, 0x0147
     dc2:	20 91 4c 01 	lds	r18, 0x014C
     dc6:	30 91 4d 01 	lds	r19, 0x014D
     dca:	40 91 4e 01 	lds	r20, 0x014E
     dce:	50 91 4f 01 	lds	r21, 0x014F
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	e8 52       	subi	r30, 0x28	; 40
     dd6:	fe 4f       	sbci	r31, 0xFE	; 254
     dd8:	60 81       	ld	r22, Z
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
     de4:	2f ef       	ldi	r18, 0xFF	; 255
     de6:	3f ef       	ldi	r19, 0xFF	; 255
     de8:	47 e0       	ldi	r20, 0x07	; 7
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	26 1b       	sub	r18, r22
     dee:	37 0b       	sbc	r19, r23
     df0:	48 0b       	sbc	r20, r24
     df2:	59 0b       	sbc	r21, r25
     df4:	20 93 09 03 	sts	0x0309, r18
     df8:	30 93 0a 03 	sts	0x030A, r19
     dfc:	40 93 0b 03 	sts	0x030B, r20
     e00:	50 93 0c 03 	sts	0x030C, r21
     e04:	d4 c0       	rjmp	.+424    	; 0xfae <UpdateAudioChannel1+0x73e>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     e06:	80 91 ef 02 	lds	r24, 0x02EF
     e0a:	88 23       	and	r24, r24
     e0c:	09 f0       	breq	.+2      	; 0xe10 <UpdateAudioChannel1+0x5a0>
     e0e:	62 c0       	rjmp	.+196    	; 0xed4 <UpdateAudioChannel1+0x664>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     e10:	20 91 09 03 	lds	r18, 0x0309
     e14:	30 91 0a 03 	lds	r19, 0x030A
     e18:	40 91 0b 03 	lds	r20, 0x030B
     e1c:	50 91 0c 03 	lds	r21, 0x030C
     e20:	80 91 02 03 	lds	r24, 0x0302
     e24:	90 91 03 03 	lds	r25, 0x0303
     e28:	a0 91 04 03 	lds	r26, 0x0304
     e2c:	b0 91 05 03 	lds	r27, 0x0305
     e30:	28 17       	cp	r18, r24
     e32:	39 07       	cpc	r19, r25
     e34:	4a 07       	cpc	r20, r26
     e36:	5b 07       	cpc	r21, r27
     e38:	29 f4       	brne	.+10     	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e3a:	80 91 ec 02 	lds	r24, 0x02EC
     e3e:	81 30       	cpi	r24, 0x01	; 1
     e40:	09 f4       	brne	.+2      	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e42:	61 c0       	rjmp	.+194    	; 0xf06 <UpdateAudioChannel1+0x696>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e44:	20 91 09 03 	lds	r18, 0x0309
     e48:	30 91 0a 03 	lds	r19, 0x030A
     e4c:	40 91 0b 03 	lds	r20, 0x030B
     e50:	50 91 0c 03 	lds	r21, 0x030C
     e54:	80 91 02 03 	lds	r24, 0x0302
     e58:	90 91 03 03 	lds	r25, 0x0303
     e5c:	a0 91 04 03 	lds	r26, 0x0304
     e60:	b0 91 05 03 	lds	r27, 0x0305
     e64:	28 17       	cp	r18, r24
     e66:	39 07       	cpc	r19, r25
     e68:	4a 07       	cpc	r20, r26
     e6a:	5b 07       	cpc	r21, r27
     e6c:	49 f4       	brne	.+18     	; 0xe80 <UpdateAudioChannel1+0x610>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e6e:	80 91 fe 02 	lds	r24, 0x02FE
     e72:	90 91 ff 02 	lds	r25, 0x02FF
     e76:	a0 91 00 03 	lds	r26, 0x0300
     e7a:	b0 91 01 03 	lds	r27, 0x0301
     e7e:	8f c0       	rjmp	.+286    	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e80:	20 91 09 03 	lds	r18, 0x0309
     e84:	30 91 0a 03 	lds	r19, 0x030A
     e88:	40 91 0b 03 	lds	r20, 0x030B
     e8c:	50 91 0c 03 	lds	r21, 0x030C
     e90:	80 91 fa 02 	lds	r24, 0x02FA
     e94:	90 91 fb 02 	lds	r25, 0x02FB
     e98:	a0 91 fc 02 	lds	r26, 0x02FC
     e9c:	b0 91 fd 02 	lds	r27, 0x02FD
     ea0:	28 17       	cp	r18, r24
     ea2:	39 07       	cpc	r19, r25
     ea4:	4a 07       	cpc	r20, r26
     ea6:	5b 07       	cpc	r21, r27
     ea8:	49 f4       	brne	.+18     	; 0xebc <UpdateAudioChannel1+0x64c>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     eaa:	80 91 f6 02 	lds	r24, 0x02F6
     eae:	90 91 f7 02 	lds	r25, 0x02F7
     eb2:	a0 91 f8 02 	lds	r26, 0x02F8
     eb6:	b0 91 f9 02 	lds	r27, 0x02F9
     eba:	71 c0       	rjmp	.+226    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ebc:	80 91 09 03 	lds	r24, 0x0309
     ec0:	90 91 0a 03 	lds	r25, 0x030A
     ec4:	a0 91 0b 03 	lds	r26, 0x030B
     ec8:	b0 91 0c 03 	lds	r27, 0x030C
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	65 c0       	rjmp	.+202    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ed4:	20 91 09 03 	lds	r18, 0x0309
     ed8:	30 91 0a 03 	lds	r19, 0x030A
     edc:	40 91 0b 03 	lds	r20, 0x030B
     ee0:	50 91 0c 03 	lds	r21, 0x030C
     ee4:	80 91 fe 02 	lds	r24, 0x02FE
     ee8:	90 91 ff 02 	lds	r25, 0x02FF
     eec:	a0 91 00 03 	lds	r26, 0x0300
     ef0:	b0 91 01 03 	lds	r27, 0x0301
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	4a 07       	cpc	r20, r26
     efa:	5b 07       	cpc	r21, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6a0>
     efe:	80 91 ec 02 	lds	r24, 0x02EC
     f02:	81 30       	cpi	r24, 0x01	; 1
     f04:	29 f4       	brne	.+10     	; 0xf10 <UpdateAudioChannel1+0x6a0>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     f06:	10 92 eb 02 	sts	0x02EB, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     f0a:	10 92 f3 02 	sts	0x02F3, r1
     f0e:	4f c0       	rjmp	.+158    	; 0xfae <UpdateAudioChannel1+0x73e>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     f10:	20 91 09 03 	lds	r18, 0x0309
     f14:	30 91 0a 03 	lds	r19, 0x030A
     f18:	40 91 0b 03 	lds	r20, 0x030B
     f1c:	50 91 0c 03 	lds	r21, 0x030C
     f20:	80 91 fe 02 	lds	r24, 0x02FE
     f24:	90 91 ff 02 	lds	r25, 0x02FF
     f28:	a0 91 00 03 	lds	r26, 0x0300
     f2c:	b0 91 01 03 	lds	r27, 0x0301
     f30:	28 17       	cp	r18, r24
     f32:	39 07       	cpc	r19, r25
     f34:	4a 07       	cpc	r20, r26
     f36:	5b 07       	cpc	r21, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6dc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     f3a:	80 91 02 03 	lds	r24, 0x0302
     f3e:	90 91 03 03 	lds	r25, 0x0303
     f42:	a0 91 04 03 	lds	r26, 0x0304
     f46:	b0 91 05 03 	lds	r27, 0x0305
     f4a:	29 c0       	rjmp	.+82     	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f4c:	20 91 09 03 	lds	r18, 0x0309
     f50:	30 91 0a 03 	lds	r19, 0x030A
     f54:	40 91 0b 03 	lds	r20, 0x030B
     f58:	50 91 0c 03 	lds	r21, 0x030C
     f5c:	80 91 f6 02 	lds	r24, 0x02F6
     f60:	90 91 f7 02 	lds	r25, 0x02F7
     f64:	a0 91 f8 02 	lds	r26, 0x02F8
     f68:	b0 91 f9 02 	lds	r27, 0x02F9
     f6c:	28 17       	cp	r18, r24
     f6e:	39 07       	cpc	r19, r25
     f70:	4a 07       	cpc	r20, r26
     f72:	5b 07       	cpc	r21, r27
     f74:	49 f4       	brne	.+18     	; 0xf88 <UpdateAudioChannel1+0x718>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f76:	80 91 fa 02 	lds	r24, 0x02FA
     f7a:	90 91 fb 02 	lds	r25, 0x02FB
     f7e:	a0 91 fc 02 	lds	r26, 0x02FC
     f82:	b0 91 fd 02 	lds	r27, 0x02FD
     f86:	0b c0       	rjmp	.+22     	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f88:	80 91 09 03 	lds	r24, 0x0309
     f8c:	90 91 0a 03 	lds	r25, 0x030A
     f90:	a0 91 0b 03 	lds	r26, 0x030B
     f94:	b0 91 0c 03 	lds	r27, 0x030C
     f98:	01 97       	sbiw	r24, 0x01	; 1
     f9a:	a1 09       	sbc	r26, r1
     f9c:	b1 09       	sbc	r27, r1
     f9e:	80 93 09 03 	sts	0x0309, r24
     fa2:	90 93 0a 03 	sts	0x030A, r25
     fa6:	a0 93 0b 03 	sts	0x030B, r26
     faa:	b0 93 0c 03 	sts	0x030C, r27
			}
		}
		
		// Finished with addy stuff, now finish data transfer
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     fae:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     fb0:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     fb2:	8f ef       	ldi	r24, 0xFF	; 255
     fb4:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     fb6:	80 91 f2 02 	lds	r24, 0x02F2
     fba:	88 23       	and	r24, r24
     fbc:	61 f0       	breq	.+24     	; 0xfd6 <UpdateAudioChannel1+0x766>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     fbe:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     fc0:	20 91 f2 02 	lds	r18, 0x02F2
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	02 c0       	rjmp	.+4      	; 0xfce <UpdateAudioChannel1+0x75e>
     fca:	88 0f       	add	r24, r24
     fcc:	99 1f       	adc	r25, r25
     fce:	2a 95       	dec	r18
     fd0:	e2 f7       	brpl	.-8      	; 0xfca <UpdateAudioChannel1+0x75a>
     fd2:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     fd4:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     fd6:	24 2f       	mov	r18, r20
     fd8:	33 27       	eor	r19, r19
     fda:	27 fd       	sbrc	r18, 7
     fdc:	30 95       	com	r19
     fde:	80 91 58 02 	lds	r24, 0x0258
     fe2:	99 27       	eor	r25, r25
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	90 95       	com	r25
     fe8:	28 0f       	add	r18, r24
     fea:	39 1f       	adc	r19, r25
     fec:	8f ef       	ldi	r24, 0xFF	; 255
     fee:	20 38       	cpi	r18, 0x80	; 128
     ff0:	38 07       	cpc	r19, r24
     ff2:	14 f4       	brge	.+4      	; 0xff8 <UpdateAudioChannel1+0x788>
     ff4:	20 e8       	ldi	r18, 0x80	; 128
     ff6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     ff8:	c9 01       	movw	r24, r18
     ffa:	20 38       	cpi	r18, 0x80	; 128
     ffc:	31 05       	cpc	r19, r1
     ffe:	14 f0       	brlt	.+4      	; 0x1004 <UpdateAudioChannel1+0x794>
    1000:	8f e7       	ldi	r24, 0x7F	; 127
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
    1006:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
    1008:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
    100a:	84 2f       	mov	r24, r20
    100c:	08 95       	ret

0000100e <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    100e:	80 91 a1 02 	lds	r24, 0x02A1
    1012:	68 2f       	mov	r22, r24
    1014:	77 27       	eor	r23, r23
    1016:	67 fd       	sbrc	r22, 7
    1018:	70 95       	com	r23
    101a:	80 91 9f 02 	lds	r24, 0x029F
    101e:	99 27       	eor	r25, r25
    1020:	87 fd       	sbrc	r24, 7
    1022:	90 95       	com	r25
    1024:	68 0f       	add	r22, r24
    1026:	79 1f       	adc	r23, r25
    1028:	8f ef       	ldi	r24, 0xFF	; 255
    102a:	60 38       	cpi	r22, 0x80	; 128
    102c:	78 07       	cpc	r23, r24
    102e:	14 f4       	brge	.+4      	; 0x1034 <OutputMultiplyBanks+0x26>
    1030:	60 e8       	ldi	r22, 0x80	; 128
    1032:	7f ef       	ldi	r23, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1034:	80 91 a2 02 	lds	r24, 0x02A2
    1038:	28 2f       	mov	r18, r24
    103a:	33 27       	eor	r19, r19
    103c:	27 fd       	sbrc	r18, 7
    103e:	30 95       	com	r19
    1040:	80 91 a0 02 	lds	r24, 0x02A0
    1044:	99 27       	eor	r25, r25
    1046:	87 fd       	sbrc	r24, 7
    1048:	90 95       	com	r25
    104a:	28 0f       	add	r18, r24
    104c:	39 1f       	adc	r19, r25
    104e:	8f ef       	ldi	r24, 0xFF	; 255
    1050:	21 38       	cpi	r18, 0x81	; 129
    1052:	38 07       	cpc	r19, r24
    1054:	14 f4       	brge	.+4      	; 0x105a <OutputMultiplyBanks+0x4c>
    1056:	21 e8       	ldi	r18, 0x81	; 129
    1058:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    105a:	a9 01       	movw	r20, r18
    105c:	20 38       	cpi	r18, 0x80	; 128
    105e:	31 05       	cpc	r19, r1
    1060:	14 f0       	brlt	.+4      	; 0x1066 <OutputMultiplyBanks+0x58>
    1062:	4f e7       	ldi	r20, 0x7F	; 127
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	9b 01       	movw	r18, r22
    1068:	60 38       	cpi	r22, 0x80	; 128
    106a:	71 05       	cpc	r23, r1
    106c:	14 f0       	brlt	.+4      	; 0x1072 <OutputMultiplyBanks+0x64>
    106e:	2f e7       	ldi	r18, 0x7F	; 127
    1070:	30 e0       	ldi	r19, 0x00	; 0
	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    1072:	42 9f       	mul	r20, r18
    1074:	c0 01       	movw	r24, r0
    1076:	43 9f       	mul	r20, r19
    1078:	90 0d       	add	r25, r0
    107a:	52 9f       	mul	r21, r18
    107c:	90 0d       	add	r25, r0
    107e:	11 24       	eor	r1, r1
    1080:	60 e4       	ldi	r22, 0x40	; 64
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <__divmodhi4>
    1088:	60 58       	subi	r22, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    108a:	80 91 a3 02 	lds	r24, 0x02A3
    108e:	68 17       	cp	r22, r24
    1090:	29 f0       	breq	.+10     	; 0x109c <OutputMultiplyBanks+0x8e>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1096:	65 b9       	out	0x05, r22	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1098:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    109a:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    109c:	60 93 a3 02 	sts	0x02A3, r22
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    10a0:	08 95       	ret

000010a2 <OutputAddBanks>:
		sum0;				// Temporary variables for saturated adds, multiplies, other math.

	unsigned char
		output;			// What to put on the DAC
	
	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);		// Sum everything that might be involved in our output waveform:
    10a2:	80 91 a0 02 	lds	r24, 0x02A0
    10a6:	28 2f       	mov	r18, r24
    10a8:	33 27       	eor	r19, r19
    10aa:	27 fd       	sbrc	r18, 7
    10ac:	30 95       	com	r19
    10ae:	80 91 9f 02 	lds	r24, 0x029F
    10b2:	99 27       	eor	r25, r25
    10b4:	87 fd       	sbrc	r24, 7
    10b6:	90 95       	com	r25
    10b8:	28 0f       	add	r18, r24
    10ba:	39 1f       	adc	r19, r25
    10bc:	80 91 a1 02 	lds	r24, 0x02A1
    10c0:	99 27       	eor	r25, r25
    10c2:	87 fd       	sbrc	r24, 7
    10c4:	90 95       	com	r25
    10c6:	28 0f       	add	r18, r24
    10c8:	39 1f       	adc	r19, r25
    10ca:	80 91 a2 02 	lds	r24, 0x02A2
    10ce:	99 27       	eor	r25, r25
    10d0:	87 fd       	sbrc	r24, 7
    10d2:	90 95       	com	r25
    10d4:	28 0f       	add	r18, r24
    10d6:	39 1f       	adc	r19, r25
    10d8:	8f ef       	ldi	r24, 0xFF	; 255
    10da:	20 38       	cpi	r18, 0x80	; 128
    10dc:	38 07       	cpc	r19, r24
    10de:	14 f4       	brge	.+4      	; 0x10e4 <OutputAddBanks+0x42>
    10e0:	20 e8       	ldi	r18, 0x80	; 128
    10e2:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
    10e4:	c9 01       	movw	r24, r18
    10e6:	20 38       	cpi	r18, 0x80	; 128
    10e8:	31 05       	cpc	r19, r1
    10ea:	14 f0       	brlt	.+4      	; 0x10f0 <OutputAddBanks+0x4e>
    10ec:	8f e7       	ldi	r24, 0x7F	; 127
    10ee:	90 e0       	ldi	r25, 0x00	; 0
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10f0:	98 2f       	mov	r25, r24
    10f2:	90 58       	subi	r25, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    10f4:	80 91 a3 02 	lds	r24, 0x02A3
    10f8:	98 17       	cp	r25, r24
    10fa:	29 f0       	breq	.+10     	; 0x1106 <__stack+0x7>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    10fc:	8f ef       	ldi	r24, 0xFF	; 255
    10fe:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1100:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1102:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1104:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1106:	90 93 a3 02 	sts	0x02A3, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    110a:	08 95       	ret

0000110c <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    110c:	80 91 a1 02 	lds	r24, 0x02A1
    1110:	48 2f       	mov	r20, r24
    1112:	55 27       	eor	r21, r21
    1114:	47 fd       	sbrc	r20, 7
    1116:	50 95       	com	r21
    1118:	80 91 9f 02 	lds	r24, 0x029F
    111c:	99 27       	eor	r25, r25
    111e:	87 fd       	sbrc	r24, 7
    1120:	90 95       	com	r25
    1122:	48 0f       	add	r20, r24
    1124:	59 1f       	adc	r21, r25
    1126:	8f ef       	ldi	r24, 0xFF	; 255
    1128:	40 38       	cpi	r20, 0x80	; 128
    112a:	58 07       	cpc	r21, r24
    112c:	14 f4       	brge	.+4      	; 0x1132 <OutputXorBanks+0x26>
    112e:	40 e8       	ldi	r20, 0x80	; 128
    1130:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1132:	80 91 a2 02 	lds	r24, 0x02A2
    1136:	28 2f       	mov	r18, r24
    1138:	33 27       	eor	r19, r19
    113a:	27 fd       	sbrc	r18, 7
    113c:	30 95       	com	r19
    113e:	80 91 a0 02 	lds	r24, 0x02A0
    1142:	99 27       	eor	r25, r25
    1144:	87 fd       	sbrc	r24, 7
    1146:	90 95       	com	r25
    1148:	28 0f       	add	r18, r24
    114a:	39 1f       	adc	r19, r25
    114c:	8f ef       	ldi	r24, 0xFF	; 255
    114e:	20 38       	cpi	r18, 0x80	; 128
    1150:	38 07       	cpc	r19, r24
    1152:	14 f4       	brge	.+4      	; 0x1158 <OutputXorBanks+0x4c>
    1154:	20 e8       	ldi	r18, 0x80	; 128
    1156:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}		
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.		
    1158:	20 38       	cpi	r18, 0x80	; 128
    115a:	31 05       	cpc	r19, r1
    115c:	14 f0       	brlt	.+4      	; 0x1162 <OutputXorBanks+0x56>
    115e:	2f e7       	ldi	r18, 0x7F	; 127
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	ca 01       	movw	r24, r20
    1164:	40 38       	cpi	r20, 0x80	; 128
    1166:	51 05       	cpc	r21, r1
    1168:	14 f0       	brlt	.+4      	; 0x116e <OutputXorBanks+0x62>
    116a:	8f e7       	ldi	r24, 0x7F	; 127
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	92 2f       	mov	r25, r18
    1170:	98 27       	eor	r25, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1172:	80 91 a3 02 	lds	r24, 0x02A3
    1176:	98 17       	cp	r25, r24
    1178:	29 f0       	breq	.+10     	; 0x1184 <OutputXorBanks+0x78>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    117a:	8f ef       	ldi	r24, 0xFF	; 255
    117c:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    117e:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1180:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1182:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1184:	90 93 a3 02 	sts	0x02A3, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    1188:	08 95       	ret

0000118a <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    118a:	80 91 a1 02 	lds	r24, 0x02A1
    118e:	48 2f       	mov	r20, r24
    1190:	55 27       	eor	r21, r21
    1192:	47 fd       	sbrc	r20, 7
    1194:	50 95       	com	r21
    1196:	80 91 9f 02 	lds	r24, 0x029F
    119a:	99 27       	eor	r25, r25
    119c:	87 fd       	sbrc	r24, 7
    119e:	90 95       	com	r25
    11a0:	48 0f       	add	r20, r24
    11a2:	59 1f       	adc	r21, r25
    11a4:	8f ef       	ldi	r24, 0xFF	; 255
    11a6:	40 38       	cpi	r20, 0x80	; 128
    11a8:	58 07       	cpc	r21, r24
    11aa:	14 f4       	brge	.+4      	; 0x11b0 <OutputAndBanks+0x26>
    11ac:	40 e8       	ldi	r20, 0x80	; 128
    11ae:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    11b0:	80 91 a2 02 	lds	r24, 0x02A2
    11b4:	28 2f       	mov	r18, r24
    11b6:	33 27       	eor	r19, r19
    11b8:	27 fd       	sbrc	r18, 7
    11ba:	30 95       	com	r19
    11bc:	80 91 a0 02 	lds	r24, 0x02A0
    11c0:	99 27       	eor	r25, r25
    11c2:	87 fd       	sbrc	r24, 7
    11c4:	90 95       	com	r25
    11c6:	28 0f       	add	r18, r24
    11c8:	39 1f       	adc	r19, r25
    11ca:	8f ef       	ldi	r24, 0xFF	; 255
    11cc:	20 38       	cpi	r18, 0x80	; 128
    11ce:	38 07       	cpc	r19, r24
    11d0:	14 f4       	brge	.+4      	; 0x11d6 <OutputAndBanks+0x4c>
    11d2:	20 e8       	ldi	r18, 0x80	; 128
    11d4:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.		
    11d6:	c9 01       	movw	r24, r18
    11d8:	20 38       	cpi	r18, 0x80	; 128
    11da:	31 05       	cpc	r19, r1
    11dc:	14 f0       	brlt	.+4      	; 0x11e2 <OutputAndBanks+0x58>
    11de:	8f e7       	ldi	r24, 0x7F	; 127
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	28 2f       	mov	r18, r24
    11e4:	20 58       	subi	r18, 0x80	; 128
    11e6:	ca 01       	movw	r24, r20
    11e8:	40 38       	cpi	r20, 0x80	; 128
    11ea:	51 05       	cpc	r21, r1
    11ec:	14 f0       	brlt	.+4      	; 0x11f2 <OutputAndBanks+0x68>
    11ee:	8f e7       	ldi	r24, 0x7F	; 127
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	98 2f       	mov	r25, r24
    11f4:	90 58       	subi	r25, 0x80	; 128
    11f6:	92 23       	and	r25, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11f8:	80 91 a3 02 	lds	r24, 0x02A3
    11fc:	98 17       	cp	r25, r24
    11fe:	29 f0       	breq	.+10     	; 0x120a <OutputAndBanks+0x80>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1200:	8f ef       	ldi	r24, 0xFF	; 255
    1202:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1204:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1206:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1208:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    120a:	90 93 a3 02 	sts	0x02A3, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    120e:	08 95       	ret

00001210 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    1210:	1f 92       	push	r1
    1212:	0f 92       	push	r0
    1214:	0f b6       	in	r0, 0x3f	; 63
    1216:	0f 92       	push	r0
    1218:	11 24       	eor	r1, r1
    121a:	2f 93       	push	r18
    121c:	3f 93       	push	r19
    121e:	4f 93       	push	r20
    1220:	5f 93       	push	r21
    1222:	6f 93       	push	r22
    1224:	7f 93       	push	r23
    1226:	8f 93       	push	r24
    1228:	9f 93       	push	r25
    122a:	af 93       	push	r26
    122c:	bf 93       	push	r27
    122e:	ef 93       	push	r30
    1230:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1232:	80 91 cb 02 	lds	r24, 0x02CB
    1236:	88 23       	and	r24, r24
    1238:	41 f0       	breq	.+16     	; 0x124a <__vector_12+0x3a>
    123a:	80 91 cb 02 	lds	r24, 0x02CB
    123e:	88 23       	and	r24, r24
    1240:	41 f0       	breq	.+16     	; 0x1252 <__vector_12+0x42>
    1242:	80 91 3a 01 	lds	r24, 0x013A
    1246:	88 23       	and	r24, r24
    1248:	21 f0       	breq	.+8      	; 0x1252 <__vector_12+0x42>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    124a:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    124e:	80 93 9f 02 	sts	0x029F, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    1252:	10 92 3a 01 	sts	0x013A, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1256:	e0 91 c5 02 	lds	r30, 0x02C5
    125a:	f0 91 c6 02 	lds	r31, 0x02C6
    125e:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1260:	80 91 7a 00 	lds	r24, 0x007A
    1264:	86 fd       	sbrc	r24, 6
    1266:	0a c0       	rjmp	.+20     	; 0x127c <__vector_12+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1268:	80 91 79 00 	lds	r24, 0x0079
    126c:	80 58       	subi	r24, 0x80	; 128
    126e:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    1272:	80 91 7a 00 	lds	r24, 0x007A
    1276:	80 64       	ori	r24, 0x40	; 64
    1278:	80 93 7a 00 	sts	0x007A, r24
	}
}
    127c:	ff 91       	pop	r31
    127e:	ef 91       	pop	r30
    1280:	bf 91       	pop	r27
    1282:	af 91       	pop	r26
    1284:	9f 91       	pop	r25
    1286:	8f 91       	pop	r24
    1288:	7f 91       	pop	r23
    128a:	6f 91       	pop	r22
    128c:	5f 91       	pop	r21
    128e:	4f 91       	pop	r20
    1290:	3f 91       	pop	r19
    1292:	2f 91       	pop	r18
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	0f 90       	pop	r0
    129a:	1f 90       	pop	r1
    129c:	18 95       	reti

0000129e <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    129e:	1f 92       	push	r1
    12a0:	0f 92       	push	r0
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	0f 92       	push	r0
    12a6:	11 24       	eor	r1, r1
    12a8:	2f 93       	push	r18
    12aa:	3f 93       	push	r19
    12ac:	4f 93       	push	r20
    12ae:	5f 93       	push	r21
    12b0:	6f 93       	push	r22
    12b2:	7f 93       	push	r23
    12b4:	8f 93       	push	r24
    12b6:	9f 93       	push	r25
    12b8:	af 93       	push	r26
    12ba:	bf 93       	push	r27
    12bc:	ef 93       	push	r30
    12be:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    12c0:	80 91 ed 02 	lds	r24, 0x02ED
    12c4:	88 23       	and	r24, r24
    12c6:	41 f0       	breq	.+16     	; 0x12d8 <__vector_6+0x3a>
    12c8:	80 91 ed 02 	lds	r24, 0x02ED
    12cc:	88 23       	and	r24, r24
    12ce:	41 f0       	breq	.+16     	; 0x12e0 <__vector_6+0x42>
    12d0:	80 91 39 01 	lds	r24, 0x0139
    12d4:	88 23       	and	r24, r24
    12d6:	21 f0       	breq	.+8      	; 0x12e0 <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    12d8:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    12dc:	80 93 a0 02 	sts	0x02A0, r24
	}	
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    12e0:	10 92 39 01 	sts	0x0139, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    12e4:	e0 91 c5 02 	lds	r30, 0x02C5
    12e8:	f0 91 c6 02 	lds	r31, 0x02C6
    12ec:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    12ee:	80 91 7a 00 	lds	r24, 0x007A
    12f2:	86 fd       	sbrc	r24, 6
    12f4:	0a c0       	rjmp	.+20     	; 0x130a <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    12f6:	80 91 79 00 	lds	r24, 0x0079
    12fa:	80 58       	subi	r24, 0x80	; 128
    12fc:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    1300:	80 91 7a 00 	lds	r24, 0x007A
    1304:	80 64       	ori	r24, 0x40	; 64
    1306:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    130a:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    130c:	ff 91       	pop	r31
    130e:	ef 91       	pop	r30
    1310:	bf 91       	pop	r27
    1312:	af 91       	pop	r26
    1314:	9f 91       	pop	r25
    1316:	8f 91       	pop	r24
    1318:	7f 91       	pop	r23
    131a:	6f 91       	pop	r22
    131c:	5f 91       	pop	r21
    131e:	4f 91       	pop	r20
    1320:	3f 91       	pop	r19
    1322:	2f 91       	pop	r18
    1324:	0f 90       	pop	r0
    1326:	0f be       	out	0x3f, r0	; 63
    1328:	0f 90       	pop	r0
    132a:	1f 90       	pop	r1
    132c:	18 95       	reti

0000132e <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    132e:	1f 92       	push	r1
    1330:	0f 92       	push	r0
    1332:	0f b6       	in	r0, 0x3f	; 63
    1334:	0f 92       	push	r0
    1336:	11 24       	eor	r1, r1
    1338:	ef 92       	push	r14
    133a:	ff 92       	push	r15
    133c:	0f 93       	push	r16
    133e:	1f 93       	push	r17
    1340:	2f 93       	push	r18
    1342:	3f 93       	push	r19
    1344:	4f 93       	push	r20
    1346:	5f 93       	push	r21
    1348:	6f 93       	push	r22
    134a:	7f 93       	push	r23
    134c:	8f 93       	push	r24
    134e:	9f 93       	push	r25
    1350:	af 93       	push	r26
    1352:	bf 93       	push	r27
    1354:	ef 93       	push	r30
    1356:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1358:	80 91 cb 02 	lds	r24, 0x02CB
    135c:	88 23       	and	r24, r24
    135e:	41 f0       	breq	.+16     	; 0x1370 <__vector_13+0x42>
    1360:	80 91 cb 02 	lds	r24, 0x02CB
    1364:	88 23       	and	r24, r24
    1366:	41 f0       	breq	.+16     	; 0x1378 <__vector_13+0x4a>
    1368:	80 91 35 01 	lds	r24, 0x0135
    136c:	88 23       	and	r24, r24
    136e:	21 f0       	breq	.+8      	; 0x1378 <__vector_13+0x4a>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    1370:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    1374:	80 93 a1 02 	sts	0x02A1, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?		### This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down...
    1378:	80 91 cf 02 	lds	r24, 0x02CF
    137c:	88 23       	and	r24, r24
    137e:	c1 f1       	breq	.+112    	; 0x13f0 <__vector_13+0xc2>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    1380:	20 91 cf 02 	lds	r18, 0x02CF
    1384:	60 91 d2 02 	lds	r22, 0x02D2
    1388:	70 91 d3 02 	lds	r23, 0x02D3
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	30 e0       	ldi	r19, 0x00	; 0
    1392:	40 e0       	ldi	r20, 0x00	; 0
    1394:	50 e0       	ldi	r21, 0x00	; 0
    1396:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    139a:	2f e7       	ldi	r18, 0x7F	; 127
    139c:	30 e0       	ldi	r19, 0x00	; 0
    139e:	40 e0       	ldi	r20, 0x00	; 0
    13a0:	50 e0       	ldi	r21, 0x00	; 0
    13a2:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. ### We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    13a6:	e0 90 88 00 	lds	r14, 0x0088
    13aa:	f0 90 89 00 	lds	r15, 0x0089
    13ae:	00 91 d2 02 	lds	r16, 0x02D2
    13b2:	10 91 d3 02 	lds	r17, 0x02D3
    13b6:	60 91 00 01 	lds	r22, 0x0100
    13ba:	70 91 01 01 	lds	r23, 0x0101
    13be:	80 91 02 01 	lds	r24, 0x0102
    13c2:	90 91 03 01 	lds	r25, 0x0103
    13c6:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
    13ca:	0e 0d       	add	r16, r14
    13cc:	1f 1d       	adc	r17, r15
    13ce:	20 91 36 01 	lds	r18, 0x0136
    13d2:	30 91 37 01 	lds	r19, 0x0137
    13d6:	02 0f       	add	r16, r18
    13d8:	13 1f       	adc	r17, r19
    13da:	06 1b       	sub	r16, r22
    13dc:	17 0b       	sbc	r17, r23
    13de:	10 93 89 00 	sts	0x0089, r17
    13e2:	00 93 88 00 	sts	0x0088, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    13e6:	70 93 37 01 	sts	0x0137, r23
    13ea:	60 93 36 01 	sts	0x0136, r22
    13ee:	0e c0       	rjmp	.+28     	; 0x140c <__vector_13+0xde>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    13f0:	20 91 88 00 	lds	r18, 0x0088
    13f4:	30 91 89 00 	lds	r19, 0x0089
    13f8:	80 91 d2 02 	lds	r24, 0x02D2
    13fc:	90 91 d3 02 	lds	r25, 0x02D3
    1400:	82 0f       	add	r24, r18
    1402:	93 1f       	adc	r25, r19
    1404:	90 93 89 00 	sts	0x0089, r25
    1408:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    140c:	10 92 35 01 	sts	0x0135, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1410:	e0 91 c5 02 	lds	r30, 0x02C5
    1414:	f0 91 c6 02 	lds	r31, 0x02C6
    1418:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    141a:	80 91 7a 00 	lds	r24, 0x007A
    141e:	86 fd       	sbrc	r24, 6
    1420:	0a c0       	rjmp	.+20     	; 0x1436 <__vector_13+0x108>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1422:	80 91 79 00 	lds	r24, 0x0079
    1426:	80 58       	subi	r24, 0x80	; 128
    1428:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    142c:	80 91 7a 00 	lds	r24, 0x007A
    1430:	80 64       	ori	r24, 0x40	; 64
    1432:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1436:	ff 91       	pop	r31
    1438:	ef 91       	pop	r30
    143a:	bf 91       	pop	r27
    143c:	af 91       	pop	r26
    143e:	9f 91       	pop	r25
    1440:	8f 91       	pop	r24
    1442:	7f 91       	pop	r23
    1444:	6f 91       	pop	r22
    1446:	5f 91       	pop	r21
    1448:	4f 91       	pop	r20
    144a:	3f 91       	pop	r19
    144c:	2f 91       	pop	r18
    144e:	1f 91       	pop	r17
    1450:	0f 91       	pop	r16
    1452:	ff 90       	pop	r15
    1454:	ef 90       	pop	r14
    1456:	0f 90       	pop	r0
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	0f 90       	pop	r0
    145c:	1f 90       	pop	r1
    145e:	18 95       	reti

00001460 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    1460:	1f 92       	push	r1
    1462:	0f 92       	push	r0
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	0f 92       	push	r0
    1468:	11 24       	eor	r1, r1
    146a:	ef 92       	push	r14
    146c:	ff 92       	push	r15
    146e:	0f 93       	push	r16
    1470:	1f 93       	push	r17
    1472:	2f 93       	push	r18
    1474:	3f 93       	push	r19
    1476:	4f 93       	push	r20
    1478:	5f 93       	push	r21
    147a:	6f 93       	push	r22
    147c:	7f 93       	push	r23
    147e:	8f 93       	push	r24
    1480:	9f 93       	push	r25
    1482:	af 93       	push	r26
    1484:	bf 93       	push	r27
    1486:	ef 93       	push	r30
    1488:	ff 93       	push	r31
		lastJitterValue;
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    148a:	80 91 ed 02 	lds	r24, 0x02ED
    148e:	88 23       	and	r24, r24
    1490:	41 f0       	breq	.+16     	; 0x14a2 <__vector_14+0x42>
    1492:	80 91 ed 02 	lds	r24, 0x02ED
    1496:	88 23       	and	r24, r24
    1498:	41 f0       	breq	.+16     	; 0x14aa <__vector_14+0x4a>
    149a:	80 91 31 01 	lds	r24, 0x0131
    149e:	88 23       	and	r24, r24
    14a0:	21 f0       	breq	.+8      	; 0x14aa <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    14a2:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    14a6:	80 93 a2 02 	sts	0x02A2, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    14aa:	80 91 f1 02 	lds	r24, 0x02F1
    14ae:	88 23       	and	r24, r24
    14b0:	c1 f1       	breq	.+112    	; 0x1522 <__vector_14+0xc2>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    14b2:	20 91 f1 02 	lds	r18, 0x02F1
    14b6:	60 91 f4 02 	lds	r22, 0x02F4
    14ba:	70 91 f5 02 	lds	r23, 0x02F5
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    14be:	80 e0       	ldi	r24, 0x00	; 0
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	40 e0       	ldi	r20, 0x00	; 0
    14c6:	50 e0       	ldi	r21, 0x00	; 0
    14c8:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    14cc:	2f e7       	ldi	r18, 0x7F	; 127
    14ce:	30 e0       	ldi	r19, 0x00	; 0
    14d0:	40 e0       	ldi	r20, 0x00	; 0
    14d2:	50 e0       	ldi	r21, 0x00	; 0
    14d4:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. ### We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    14d8:	e0 90 8a 00 	lds	r14, 0x008A
    14dc:	f0 90 8b 00 	lds	r15, 0x008B
    14e0:	00 91 f4 02 	lds	r16, 0x02F4
    14e4:	10 91 f5 02 	lds	r17, 0x02F5
    14e8:	60 91 00 01 	lds	r22, 0x0100
    14ec:	70 91 01 01 	lds	r23, 0x0101
    14f0:	80 91 02 01 	lds	r24, 0x0102
    14f4:	90 91 03 01 	lds	r25, 0x0103
    14f8:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
    14fc:	0e 0d       	add	r16, r14
    14fe:	1f 1d       	adc	r17, r15
    1500:	20 91 32 01 	lds	r18, 0x0132
    1504:	30 91 33 01 	lds	r19, 0x0133
    1508:	02 0f       	add	r16, r18
    150a:	13 1f       	adc	r17, r19
    150c:	06 1b       	sub	r16, r22
    150e:	17 0b       	sbc	r17, r23
    1510:	10 93 8b 00 	sts	0x008B, r17
    1514:	00 93 8a 00 	sts	0x008A, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    1518:	70 93 33 01 	sts	0x0133, r23
    151c:	60 93 32 01 	sts	0x0132, r22
    1520:	0e c0       	rjmp	.+28     	; 0x153e <__vector_14+0xde>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    1522:	20 91 8a 00 	lds	r18, 0x008A
    1526:	30 91 8b 00 	lds	r19, 0x008B
    152a:	80 91 f4 02 	lds	r24, 0x02F4
    152e:	90 91 f5 02 	lds	r25, 0x02F5
    1532:	82 0f       	add	r24, r18
    1534:	93 1f       	adc	r25, r19
    1536:	90 93 8b 00 	sts	0x008B, r25
    153a:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    153e:	10 92 31 01 	sts	0x0131, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1542:	e0 91 c5 02 	lds	r30, 0x02C5
    1546:	f0 91 c6 02 	lds	r31, 0x02C6
    154a:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    154c:	80 91 7a 00 	lds	r24, 0x007A
    1550:	86 fd       	sbrc	r24, 6
    1552:	0a c0       	rjmp	.+20     	; 0x1568 <__vector_14+0x108>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1554:	80 91 79 00 	lds	r24, 0x0079
    1558:	80 58       	subi	r24, 0x80	; 128
    155a:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    155e:	80 91 7a 00 	lds	r24, 0x007A
    1562:	80 64       	ori	r24, 0x40	; 64
    1564:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1568:	ff 91       	pop	r31
    156a:	ef 91       	pop	r30
    156c:	bf 91       	pop	r27
    156e:	af 91       	pop	r26
    1570:	9f 91       	pop	r25
    1572:	8f 91       	pop	r24
    1574:	7f 91       	pop	r23
    1576:	6f 91       	pop	r22
    1578:	5f 91       	pop	r21
    157a:	4f 91       	pop	r20
    157c:	3f 91       	pop	r19
    157e:	2f 91       	pop	r18
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	0f 90       	pop	r0
    158a:	0f be       	out	0x3f, r0	; 63
    158c:	0f 90       	pop	r0
    158e:	1f 90       	pop	r1
    1590:	18 95       	reti

00001592 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    1592:	1f 92       	push	r1
    1594:	0f 92       	push	r0
    1596:	0f b6       	in	r0, 0x3f	; 63
    1598:	0f 92       	push	r0
    159a:	11 24       	eor	r1, r1
    159c:	8f 93       	push	r24
    159e:	9f 93       	push	r25
	static unsigned char
		pwmCount;
	
	if(ledPwm>pwmCount)
    15a0:	80 91 3d 01 	lds	r24, 0x013D
    15a4:	90 91 30 01 	lds	r25, 0x0130
    15a8:	98 17       	cp	r25, r24
    15aa:	18 f4       	brcc	.+6      	; 0x15b2 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    15ac:	8f ef       	ldi	r24, 0xFF	; 255
    15ae:	85 b9       	out	0x05, r24	; 5
    15b0:	01 c0       	rjmp	.+2      	; 0x15b4 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    15b2:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    15b4:	9f 5f       	subi	r25, 0xFF	; 255
    15b6:	90 93 30 01 	sts	0x0130, r25
}
    15ba:	9f 91       	pop	r25
    15bc:	8f 91       	pop	r24
    15be:	0f 90       	pop	r0
    15c0:	0f be       	out	0x3f, r0	; 63
    15c2:	0f 90       	pop	r0
    15c4:	1f 90       	pop	r1
    15c6:	18 95       	reti

000015c8 <__vector_default>:


ISR(__vector_default)
{
    15c8:	1f 92       	push	r1
    15ca:	0f 92       	push	r0
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	0f 92       	push	r0
    15d0:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	0f 90       	pop	r0
    15d8:	1f 90       	pop	r1
    15da:	18 95       	reti

000015dc <HandleSoftclock>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    15dc:	a8 9b       	sbis	0x15, 0	; 21
    15de:	0a c0       	rjmp	.+20     	; 0x15f4 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    15e0:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    15e2:	80 91 0d 03 	lds	r24, 0x030D
    15e6:	90 91 0e 03 	lds	r25, 0x030E
    15ea:	01 96       	adiw	r24, 0x01	; 1
    15ec:	90 93 0e 03 	sts	0x030E, r25
    15f0:	80 93 0d 03 	sts	0x030D, r24
    15f4:	08 95       	ret

000015f6 <SetSampleClock>:
//  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrupts per timer.

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
    15f6:	28 2f       	mov	r18, r24
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	fc 01       	movw	r30, r24
    15fc:	b5 e0       	ldi	r27, 0x05	; 5
    15fe:	ee 0f       	add	r30, r30
    1600:	ff 1f       	adc	r31, r31
    1602:	ba 95       	dec	r27
    1604:	e1 f7       	brne	.-8      	; 0x15fe <SetSampleClock+0x8>
    1606:	88 0f       	add	r24, r24
    1608:	99 1f       	adc	r25, r25
    160a:	e8 0f       	add	r30, r24
    160c:	f9 1f       	adc	r31, r25
    160e:	e7 53       	subi	r30, 0x37	; 55
    1610:	fd 4f       	sbci	r31, 0xFD	; 253
    1612:	60 87       	std	Z+8, r22	; 0x08

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1614:	62 30       	cpi	r22, 0x02	; 2
    1616:	a9 f5       	brne	.+106    	; 0x1682 <SetSampleClock+0x8c>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1618:	82 2f       	mov	r24, r18
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	fc 01       	movw	r30, r24
    161e:	75 e0       	ldi	r23, 0x05	; 5
    1620:	ee 0f       	add	r30, r30
    1622:	ff 1f       	adc	r31, r31
    1624:	7a 95       	dec	r23
    1626:	e1 f7       	brne	.-8      	; 0x1620 <SetSampleClock+0x2a>
    1628:	88 0f       	add	r24, r24
    162a:	99 1f       	adc	r25, r25
    162c:	e8 0f       	add	r30, r24
    162e:	f9 1f       	adc	r31, r25
    1630:	e7 53       	subi	r30, 0x37	; 55
    1632:	fd 4f       	sbci	r31, 0xFD	; 253
    1634:	52 87       	std	Z+10, r21	; 0x0a
    1636:	41 87       	std	Z+9, r20	; 0x09

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1638:	22 23       	and	r18, r18
    163a:	79 f4       	brne	.+30     	; 0x165a <SetSampleClock+0x64>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    163c:	80 91 84 00 	lds	r24, 0x0084
    1640:	90 91 85 00 	lds	r25, 0x0085
    1644:	84 0f       	add	r24, r20
    1646:	95 1f       	adc	r25, r21
    1648:	90 93 89 00 	sts	0x0089, r25
    164c:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1650:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    1652:	80 91 6f 00 	lds	r24, 0x006F
    1656:	82 60       	ori	r24, 0x02	; 2
    1658:	0e c0       	rjmp	.+28     	; 0x1676 <SetSampleClock+0x80>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    165a:	80 91 84 00 	lds	r24, 0x0084
    165e:	90 91 85 00 	lds	r25, 0x0085
    1662:	84 0f       	add	r24, r20
    1664:	95 1f       	adc	r25, r21
    1666:	90 93 8b 00 	sts	0x008B, r25
    166a:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    166e:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1670:	80 91 6f 00 	lds	r24, 0x006F
    1674:	84 60       	ori	r24, 0x04	; 4
    1676:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.			
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	80 93 81 00 	sts	0x0081, r24
    1680:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1682:	61 30       	cpi	r22, 0x01	; 1
    1684:	a9 f4       	brne	.+42     	; 0x16b0 <SetSampleClock+0xba>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1686:	22 23       	and	r18, r18
    1688:	61 f4       	brne	.+24     	; 0x16a2 <SetSampleClock+0xac>
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    168a:	80 91 81 00 	lds	r24, 0x0081
    168e:	80 64       	ori	r24, 0x40	; 64
    1690:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1694:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1696:	80 91 6f 00 	lds	r24, 0x006F
    169a:	80 62       	ori	r24, 0x20	; 32
    169c:	80 93 6f 00 	sts	0x006F, r24
    16a0:	08 95       	ret
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    16a2:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    16a4:	84 e0       	ldi	r24, 0x04	; 4
    16a6:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    16aa:	80 e1       	ldi	r24, 0x10	; 16
    16ac:	80 93 6d 00 	sts	0x006D, r24
    16b0:	08 95       	ret

000016b2 <StartRecording>:

static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009
{
    16b2:	df 92       	push	r13
    16b4:	ef 92       	push	r14
    16b6:	ff 92       	push	r15
    16b8:	0f 93       	push	r16
    16ba:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    16bc:	df b6       	in	r13, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    16be:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    16c0:	28 2f       	mov	r18, r24
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	f9 01       	movw	r30, r18
    16c6:	05 e0       	ldi	r16, 0x05	; 5
    16c8:	ee 0f       	add	r30, r30
    16ca:	ff 1f       	adc	r31, r31
    16cc:	0a 95       	dec	r16
    16ce:	e1 f7       	brne	.-8      	; 0x16c8 <StartRecording+0x16>
    16d0:	22 0f       	add	r18, r18
    16d2:	33 1f       	adc	r19, r19
    16d4:	e2 0f       	add	r30, r18
    16d6:	f3 1f       	adc	r31, r19
    16d8:	e7 53       	subi	r30, 0x37	; 55
    16da:	fd 4f       	sbci	r31, 0xFD	; 253
    16dc:	93 e0       	ldi	r25, 0x03	; 3
    16de:	90 83       	st	Z, r25

	bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    16e0:	28 2f       	mov	r18, r24
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	f9 01       	movw	r30, r18
    16e6:	b5 e0       	ldi	r27, 0x05	; 5
    16e8:	ee 0f       	add	r30, r30
    16ea:	ff 1f       	adc	r31, r31
    16ec:	ba 95       	dec	r27
    16ee:	e1 f7       	brne	.-8      	; 0x16e8 <StartRecording+0x36>
    16f0:	22 0f       	add	r18, r18
    16f2:	33 1f       	adc	r19, r19
    16f4:	e2 0f       	add	r30, r18
    16f6:	f3 1f       	adc	r31, r19
    16f8:	e7 53       	subi	r30, 0x37	; 55
    16fa:	fd 4f       	sbci	r31, 0xFD	; 253
    16fc:	e7 84       	ldd	r14, Z+15	; 0x0f
    16fe:	f0 88       	ldd	r15, Z+16	; 0x10
    1700:	01 89       	ldd	r16, Z+17	; 0x11
    1702:	12 89       	ldd	r17, Z+18	; 0x12
    1704:	28 2f       	mov	r18, r24
    1706:	30 e0       	ldi	r19, 0x00	; 0
    1708:	f9 01       	movw	r30, r18
    170a:	75 e0       	ldi	r23, 0x05	; 5
    170c:	ee 0f       	add	r30, r30
    170e:	ff 1f       	adc	r31, r31
    1710:	7a 95       	dec	r23
    1712:	e1 f7       	brne	.-8      	; 0x170c <StartRecording+0x5a>
    1714:	22 0f       	add	r18, r18
    1716:	33 1f       	adc	r19, r19
    1718:	e2 0f       	add	r30, r18
    171a:	f3 1f       	adc	r31, r19
    171c:	e7 53       	subi	r30, 0x37	; 55
    171e:	fd 4f       	sbci	r31, 0xFD	; 253
    1720:	e6 8e       	std	Z+30, r14	; 0x1e
    1722:	f7 8e       	std	Z+31, r15	; 0x1f
    1724:	00 a3       	std	Z+32, r16	; 0x20
    1726:	11 a3       	std	Z+33, r17	; 0x21
	bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    1728:	28 2f       	mov	r18, r24
    172a:	30 e0       	ldi	r19, 0x00	; 0
    172c:	f9 01       	movw	r30, r18
    172e:	b5 e0       	ldi	r27, 0x05	; 5
    1730:	ee 0f       	add	r30, r30
    1732:	ff 1f       	adc	r31, r31
    1734:	ba 95       	dec	r27
    1736:	e1 f7       	brne	.-8      	; 0x1730 <StartRecording+0x7e>
    1738:	22 0f       	add	r18, r18
    173a:	33 1f       	adc	r19, r19
    173c:	e2 0f       	add	r30, r18
    173e:	f3 1f       	adc	r31, r19
    1740:	e7 53       	subi	r30, 0x37	; 55
    1742:	fd 4f       	sbci	r31, 0xFD	; 253
    1744:	e7 84       	ldd	r14, Z+15	; 0x0f
    1746:	f0 88       	ldd	r15, Z+16	; 0x10
    1748:	01 89       	ldd	r16, Z+17	; 0x11
    174a:	12 89       	ldd	r17, Z+18	; 0x12
    174c:	28 2f       	mov	r18, r24
    174e:	30 e0       	ldi	r19, 0x00	; 0
    1750:	f9 01       	movw	r30, r18
    1752:	75 e0       	ldi	r23, 0x05	; 5
    1754:	ee 0f       	add	r30, r30
    1756:	ff 1f       	adc	r31, r31
    1758:	7a 95       	dec	r23
    175a:	e1 f7       	brne	.-8      	; 0x1754 <StartRecording+0xa2>
    175c:	22 0f       	add	r18, r18
    175e:	33 1f       	adc	r19, r19
    1760:	e2 0f       	add	r30, r18
    1762:	f3 1f       	adc	r31, r19
    1764:	e7 53       	subi	r30, 0x37	; 55
    1766:	fd 4f       	sbci	r31, 0xFD	; 253
    1768:	e3 86       	std	Z+11, r14	; 0x0b
    176a:	f4 86       	std	Z+12, r15	; 0x0c
    176c:	05 87       	std	Z+13, r16	; 0x0d
    176e:	16 87       	std	Z+14, r17	; 0x0e
	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    1770:	28 2f       	mov	r18, r24
    1772:	30 e0       	ldi	r19, 0x00	; 0
    1774:	f9 01       	movw	r30, r18
    1776:	b5 e0       	ldi	r27, 0x05	; 5
    1778:	ee 0f       	add	r30, r30
    177a:	ff 1f       	adc	r31, r31
    177c:	ba 95       	dec	r27
    177e:	e1 f7       	brne	.-8      	; 0x1778 <StartRecording+0xc6>
    1780:	22 0f       	add	r18, r18
    1782:	33 1f       	adc	r19, r19
    1784:	e2 0f       	add	r30, r18
    1786:	f3 1f       	adc	r31, r19
    1788:	e7 53       	subi	r30, 0x37	; 55
    178a:	fd 4f       	sbci	r31, 0xFD	; 253
    178c:	e7 84       	ldd	r14, Z+15	; 0x0f
    178e:	f0 88       	ldd	r15, Z+16	; 0x10
    1790:	01 89       	ldd	r16, Z+17	; 0x11
    1792:	12 89       	ldd	r17, Z+18	; 0x12
    1794:	28 2f       	mov	r18, r24
    1796:	30 e0       	ldi	r19, 0x00	; 0
    1798:	f9 01       	movw	r30, r18
    179a:	75 e0       	ldi	r23, 0x05	; 5
    179c:	ee 0f       	add	r30, r30
    179e:	ff 1f       	adc	r31, r31
    17a0:	7a 95       	dec	r23
    17a2:	e1 f7       	brne	.-8      	; 0x179c <StartRecording+0xea>
    17a4:	22 0f       	add	r18, r18
    17a6:	33 1f       	adc	r19, r19
    17a8:	e2 0f       	add	r30, r18
    17aa:	f3 1f       	adc	r31, r19
    17ac:	e7 53       	subi	r30, 0x37	; 55
    17ae:	fd 4f       	sbci	r31, 0xFD	; 253
    17b0:	e7 8a       	std	Z+23, r14	; 0x17
    17b2:	f0 8e       	std	Z+24, r15	; 0x18
    17b4:	01 8f       	std	Z+25, r16	; 0x19
    17b6:	12 8f       	std	Z+26, r17	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    17b8:	28 2f       	mov	r18, r24
    17ba:	30 e0       	ldi	r19, 0x00	; 0
    17bc:	f9 01       	movw	r30, r18
    17be:	b5 e0       	ldi	r27, 0x05	; 5
    17c0:	ee 0f       	add	r30, r30
    17c2:	ff 1f       	adc	r31, r31
    17c4:	ba 95       	dec	r27
    17c6:	e1 f7       	brne	.-8      	; 0x17c0 <StartRecording+0x10e>
    17c8:	22 0f       	add	r18, r18
    17ca:	33 1f       	adc	r19, r19
    17cc:	e2 0f       	add	r30, r18
    17ce:	f3 1f       	adc	r31, r19
    17d0:	e7 53       	subi	r30, 0x37	; 55
    17d2:	fd 4f       	sbci	r31, 0xFD	; 253
    17d4:	e7 84       	ldd	r14, Z+15	; 0x0f
    17d6:	f0 88       	ldd	r15, Z+16	; 0x10
    17d8:	01 89       	ldd	r16, Z+17	; 0x11
    17da:	12 89       	ldd	r17, Z+18	; 0x12
    17dc:	28 2f       	mov	r18, r24
    17de:	30 e0       	ldi	r19, 0x00	; 0
    17e0:	f9 01       	movw	r30, r18
    17e2:	75 e0       	ldi	r23, 0x05	; 5
    17e4:	ee 0f       	add	r30, r30
    17e6:	ff 1f       	adc	r31, r31
    17e8:	7a 95       	dec	r23
    17ea:	e1 f7       	brne	.-8      	; 0x17e4 <StartRecording+0x132>
    17ec:	22 0f       	add	r18, r18
    17ee:	33 1f       	adc	r19, r19
    17f0:	e2 0f       	add	r30, r18
    17f2:	f3 1f       	adc	r31, r19
    17f4:	e7 53       	subi	r30, 0x37	; 55
    17f6:	fd 4f       	sbci	r31, 0xFD	; 253
    17f8:	e3 8a       	std	Z+19, r14	; 0x13
    17fa:	f4 8a       	std	Z+20, r15	; 0x14
    17fc:	05 8b       	std	Z+21, r16	; 0x15
    17fe:	16 8b       	std	Z+22, r17	; 0x16
	bankStates[theBank].sampleWindowOffset=0;									// "
    1800:	28 2f       	mov	r18, r24
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	f9 01       	movw	r30, r18
    1806:	05 e0       	ldi	r16, 0x05	; 5
    1808:	ee 0f       	add	r30, r30
    180a:	ff 1f       	adc	r31, r31
    180c:	0a 95       	dec	r16
    180e:	e1 f7       	brne	.-8      	; 0x1808 <StartRecording+0x156>
    1810:	22 0f       	add	r18, r18
    1812:	33 1f       	adc	r19, r19
    1814:	e2 0f       	add	r30, r18
    1816:	f3 1f       	adc	r31, r19
    1818:	e7 53       	subi	r30, 0x37	; 55
    181a:	fd 4f       	sbci	r31, 0xFD	; 253
    181c:	15 8e       	std	Z+29, r1	; 0x1d

	outOfRam=false;						// Plenty of ram left...
    181e:	10 92 42 01 	sts	0x0142, r1

	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1822:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    1826:	df be       	out	0x3f, r13	; 63

// Throw out the results of an old conversion since it could be very old (unless it's already going)
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1828:	80 91 7a 00 	lds	r24, 0x007A
    182c:	86 fd       	sbrc	r24, 6
    182e:	0a c0       	rjmp	.+20     	; 0x1844 <StartRecording+0x192>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1830:	80 91 79 00 	lds	r24, 0x0079
    1834:	80 58       	subi	r24, 0x80	; 128
    1836:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    183a:	80 91 7a 00 	lds	r24, 0x007A
    183e:	80 64       	ori	r24, 0x40	; 64
    1840:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1844:	1f 91       	pop	r17
    1846:	0f 91       	pop	r16
    1848:	ff 90       	pop	r15
    184a:	ef 90       	pop	r14
    184c:	df 90       	pop	r13
    184e:	08 95       	ret

00001850 <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1850:	1f 93       	push	r17
    1852:	78 2f       	mov	r23, r24
    1854:	da 01       	movw	r26, r20
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    1856:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    1858:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	fc 01       	movw	r30, r24
    185e:	35 e0       	ldi	r19, 0x05	; 5
    1860:	ee 0f       	add	r30, r30
    1862:	ff 1f       	adc	r31, r31
    1864:	3a 95       	dec	r19
    1866:	e1 f7       	brne	.-8      	; 0x1860 <StartPlayback+0x10>
    1868:	88 0f       	add	r24, r24
    186a:	99 1f       	adc	r25, r25
    186c:	e8 0f       	add	r30, r24
    186e:	f9 1f       	adc	r31, r25
    1870:	e7 53       	subi	r30, 0x37	; 55
    1872:	fd 4f       	sbci	r31, 0xFD	; 253
    1874:	84 e0       	ldi	r24, 0x04	; 4
    1876:	80 83       	st	Z, r24
ledOnOffMask|=(1<<LED_7);
    1878:	80 91 3b 01 	lds	r24, 0x013B
    187c:	80 68       	ori	r24, 0x80	; 128
    187e:	80 93 3b 01 	sts	0x013B, r24

	if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    1882:	87 2f       	mov	r24, r23
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	fc 01       	movw	r30, r24
    1888:	55 e0       	ldi	r21, 0x05	; 5
    188a:	ee 0f       	add	r30, r30
    188c:	ff 1f       	adc	r31, r31
    188e:	5a 95       	dec	r21
    1890:	e1 f7       	brne	.-8      	; 0x188a <StartPlayback+0x3a>
    1892:	88 0f       	add	r24, r24
    1894:	99 1f       	adc	r25, r25
    1896:	e8 0f       	add	r30, r24
    1898:	f9 1f       	adc	r31, r25
    189a:	e7 53       	subi	r30, 0x37	; 55
    189c:	fd 4f       	sbci	r31, 0xFD	; 253
    189e:	83 81       	ldd	r24, Z+3	; 0x03
    18a0:	88 23       	and	r24, r24
    18a2:	a9 f1       	breq	.+106    	; 0x190e <StartPlayback+0xbe>
	{
		bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    18a4:	87 2f       	mov	r24, r23
    18a6:	90 e0       	ldi	r25, 0x00	; 0
    18a8:	fc 01       	movw	r30, r24
    18aa:	35 e0       	ldi	r19, 0x05	; 5
    18ac:	ee 0f       	add	r30, r30
    18ae:	ff 1f       	adc	r31, r31
    18b0:	3a 95       	dec	r19
    18b2:	e1 f7       	brne	.-8      	; 0x18ac <StartPlayback+0x5c>
    18b4:	88 0f       	add	r24, r24
    18b6:	99 1f       	adc	r25, r25
    18b8:	e8 0f       	add	r30, r24
    18ba:	f9 1f       	adc	r31, r25
    18bc:	e7 53       	subi	r30, 0x37	; 55
    18be:	fd 4f       	sbci	r31, 0xFD	; 253
    18c0:	23 89       	ldd	r18, Z+19	; 0x13
    18c2:	34 89       	ldd	r19, Z+20	; 0x14
    18c4:	45 89       	ldd	r20, Z+21	; 0x15
    18c6:	56 89       	ldd	r21, Z+22	; 0x16
    18c8:	87 2f       	mov	r24, r23
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	fc 01       	movw	r30, r24
    18ce:	68 94       	set
    18d0:	14 f8       	bld	r1, 4
    18d2:	ee 0f       	add	r30, r30
    18d4:	ff 1f       	adc	r31, r31
    18d6:	16 94       	lsr	r1
    18d8:	e1 f7       	brne	.-8      	; 0x18d2 <StartPlayback+0x82>
    18da:	88 0f       	add	r24, r24
    18dc:	99 1f       	adc	r25, r25
    18de:	e8 0f       	add	r30, r24
    18e0:	f9 1f       	adc	r31, r25
    18e2:	e7 53       	subi	r30, 0x37	; 55
    18e4:	fd 4f       	sbci	r31, 0xFD	; 253
    18e6:	26 8f       	std	Z+30, r18	; 0x1e
    18e8:	37 8f       	std	Z+31, r19	; 0x1f
    18ea:	40 a3       	std	Z+32, r20	; 0x20
    18ec:	51 a3       	std	Z+33, r21	; 0x21
		bankStates[theBank].sampleDirection=false;	// make us run backwards.
    18ee:	87 2f       	mov	r24, r23
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	fc 01       	movw	r30, r24
    18f4:	55 e0       	ldi	r21, 0x05	; 5
    18f6:	ee 0f       	add	r30, r30
    18f8:	ff 1f       	adc	r31, r31
    18fa:	5a 95       	dec	r21
    18fc:	e1 f7       	brne	.-8      	; 0x18f6 <StartPlayback+0xa6>
    18fe:	88 0f       	add	r24, r24
    1900:	99 1f       	adc	r25, r25
    1902:	e8 0f       	add	r30, r24
    1904:	f9 1f       	adc	r31, r25
    1906:	e7 53       	subi	r30, 0x37	; 55
    1908:	fd 4f       	sbci	r31, 0xFD	; 253
    190a:	14 82       	std	Z+4, r1	; 0x04
    190c:	35 c0       	rjmp	.+106    	; 0x1978 <StartPlayback+0x128>
	}
	else
	{
		bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.	
    190e:	87 2f       	mov	r24, r23
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	fc 01       	movw	r30, r24
    1914:	35 e0       	ldi	r19, 0x05	; 5
    1916:	ee 0f       	add	r30, r30
    1918:	ff 1f       	adc	r31, r31
    191a:	3a 95       	dec	r19
    191c:	e1 f7       	brne	.-8      	; 0x1916 <StartPlayback+0xc6>
    191e:	88 0f       	add	r24, r24
    1920:	99 1f       	adc	r25, r25
    1922:	e8 0f       	add	r30, r24
    1924:	f9 1f       	adc	r31, r25
    1926:	e7 53       	subi	r30, 0x37	; 55
    1928:	fd 4f       	sbci	r31, 0xFD	; 253
    192a:	27 89       	ldd	r18, Z+23	; 0x17
    192c:	30 8d       	ldd	r19, Z+24	; 0x18
    192e:	41 8d       	ldd	r20, Z+25	; 0x19
    1930:	52 8d       	ldd	r21, Z+26	; 0x1a
    1932:	87 2f       	mov	r24, r23
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	fc 01       	movw	r30, r24
    1938:	68 94       	set
    193a:	14 f8       	bld	r1, 4
    193c:	ee 0f       	add	r30, r30
    193e:	ff 1f       	adc	r31, r31
    1940:	16 94       	lsr	r1
    1942:	e1 f7       	brne	.-8      	; 0x193c <StartPlayback+0xec>
    1944:	88 0f       	add	r24, r24
    1946:	99 1f       	adc	r25, r25
    1948:	e8 0f       	add	r30, r24
    194a:	f9 1f       	adc	r31, r25
    194c:	e7 53       	subi	r30, 0x37	; 55
    194e:	fd 4f       	sbci	r31, 0xFD	; 253
    1950:	26 8f       	std	Z+30, r18	; 0x1e
    1952:	37 8f       	std	Z+31, r19	; 0x1f
    1954:	40 a3       	std	Z+32, r20	; 0x20
    1956:	51 a3       	std	Z+33, r21	; 0x21
		bankStates[theBank].sampleDirection=true;	// make us run forwards.
    1958:	87 2f       	mov	r24, r23
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	fc 01       	movw	r30, r24
    195e:	35 e0       	ldi	r19, 0x05	; 5
    1960:	ee 0f       	add	r30, r30
    1962:	ff 1f       	adc	r31, r31
    1964:	3a 95       	dec	r19
    1966:	e1 f7       	brne	.-8      	; 0x1960 <StartPlayback+0x110>
    1968:	88 0f       	add	r24, r24
    196a:	99 1f       	adc	r25, r25
    196c:	e8 0f       	add	r30, r24
    196e:	f9 1f       	adc	r31, r25
    1970:	e7 53       	subi	r30, 0x37	; 55
    1972:	fd 4f       	sbci	r31, 0xFD	; 253
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	84 83       	std	Z+4, r24	; 0x04
	}
	
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1978:	87 2f       	mov	r24, r23
    197a:	ad 01       	movw	r20, r26
    197c:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    1980:	1f bf       	out	0x3f, r17	; 63
}
    1982:	1f 91       	pop	r17
    1984:	08 95       	ret

00001986 <StartOverdub>:
}

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    1986:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    1988:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    198a:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    198c:	28 2f       	mov	r18, r24
    198e:	30 e0       	ldi	r19, 0x00	; 0
    1990:	f9 01       	movw	r30, r18
    1992:	a5 e0       	ldi	r26, 0x05	; 5
    1994:	ee 0f       	add	r30, r30
    1996:	ff 1f       	adc	r31, r31
    1998:	aa 95       	dec	r26
    199a:	e1 f7       	brne	.-8      	; 0x1994 <StartOverdub+0xe>
    199c:	22 0f       	add	r18, r18
    199e:	33 1f       	adc	r19, r19
    19a0:	e2 0f       	add	r30, r18
    19a2:	f3 1f       	adc	r31, r19
    19a4:	e7 53       	subi	r30, 0x37	; 55
    19a6:	fd 4f       	sbci	r31, 0xFD	; 253
    19a8:	95 e0       	ldi	r25, 0x05	; 5
    19aa:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    19ac:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>
	SREG=sreg;		// Restore interrupts.
    19b0:	1f bf       	out	0x3f, r17	; 63
// Throw out the results of an old conversion since it could be very old (unless it's already going)
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    19b2:	80 91 7a 00 	lds	r24, 0x007A
    19b6:	86 fd       	sbrc	r24, 6
    19b8:	0a c0       	rjmp	.+20     	; 0x19ce <StartOverdub+0x48>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    19ba:	80 91 79 00 	lds	r24, 0x0079
    19be:	80 58       	subi	r24, 0x80	; 128
    19c0:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    19c4:	80 91 7a 00 	lds	r24, 0x007A
    19c8:	80 64       	ori	r24, 0x40	; 64
    19ca:	80 93 7a 00 	sts	0x007A, r24
	}
}
    19ce:	1f 91       	pop	r17
    19d0:	08 95       	ret

000019d2 <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
{
    19d2:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    19d4:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    19d6:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    19d8:	28 2f       	mov	r18, r24
    19da:	30 e0       	ldi	r19, 0x00	; 0
    19dc:	f9 01       	movw	r30, r18
    19de:	95 e0       	ldi	r25, 0x05	; 5
    19e0:	ee 0f       	add	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	9a 95       	dec	r25
    19e6:	e1 f7       	brne	.-8      	; 0x19e0 <StartRealtime+0xe>
    19e8:	22 0f       	add	r18, r18
    19ea:	33 1f       	adc	r19, r19
    19ec:	e2 0f       	add	r30, r18
    19ee:	f3 1f       	adc	r31, r19
    19f0:	e7 53       	subi	r30, 0x37	; 55
    19f2:	fd 4f       	sbci	r31, 0xFD	; 253
    19f4:	92 e0       	ldi	r25, 0x02	; 2
    19f6:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    19f8:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    19fc:	1f bf       	out	0x3f, r17	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    19fe:	80 91 7a 00 	lds	r24, 0x007A
    1a02:	86 fd       	sbrc	r24, 6
    1a04:	0a c0       	rjmp	.+20     	; 0x1a1a <StartRealtime+0x48>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1a06:	80 91 79 00 	lds	r24, 0x0079
    1a0a:	80 58       	subi	r24, 0x80	; 128
    1a0c:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1a10:	80 91 7a 00 	lds	r24, 0x007A
    1a14:	80 64       	ori	r24, 0x40	; 64
    1a16:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1a1a:	1f 91       	pop	r17
    1a1c:	08 95       	ret

00001a1e <GetPlaybackRateFromNote>:
	B_NOTE,
};

static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
// Here we take a midi note number and turn it into the timer one compare match interrupt value.
{
    1a1e:	28 2f       	mov	r18, r24
    1a20:	6c e0       	ldi	r22, 0x0C	; 12
    1a22:	0e 94 23 27 	call	0x4e46	; 0x4e46 <__udivmodqi4>
    1a26:	e9 2f       	mov	r30, r25
    1a28:	f0 e0       	ldi	r31, 0x00	; 0
    1a2a:	ee 0f       	add	r30, r30
    1a2c:	ff 1f       	adc	r31, r31
    1a2e:	ea 5f       	subi	r30, 0xFA	; 250
    1a30:	fe 4f       	sbci	r31, 0xFE	; 254
    1a32:	82 2f       	mov	r24, r18
    1a34:	0e 94 23 27 	call	0x4e46	; 0x4e46 <__udivmodqi4>
    1a38:	20 81       	ld	r18, Z
    1a3a:	31 81       	ldd	r19, Z+1	; 0x01
    1a3c:	02 c0       	rjmp	.+4      	; 0x1a42 <GetPlaybackRateFromNote+0x24>
    1a3e:	36 95       	lsr	r19
    1a40:	27 95       	ror	r18
    1a42:	8a 95       	dec	r24
    1a44:	e2 f7       	brpl	.-8      	; 0x1a3e <GetPlaybackRateFromNote+0x20>
	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.

}
    1a46:	c9 01       	movw	r24, r18
    1a48:	08 95       	ret

00001a4a <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    1a4a:	2f 92       	push	r2
    1a4c:	3f 92       	push	r3
    1a4e:	4f 92       	push	r4
    1a50:	5f 92       	push	r5
    1a52:	6f 92       	push	r6
    1a54:	7f 92       	push	r7
    1a56:	8f 92       	push	r8
    1a58:	9f 92       	push	r9
    1a5a:	af 92       	push	r10
    1a5c:	bf 92       	push	r11
    1a5e:	cf 92       	push	r12
    1a60:	df 92       	push	r13
    1a62:	ef 92       	push	r14
    1a64:	ff 92       	push	r15
    1a66:	0f 93       	push	r16
    1a68:	1f 93       	push	r17
    1a6a:	df 93       	push	r29
    1a6c:	cf 93       	push	r28
    1a6e:	00 d0       	rcall	.+0      	; 0x1a70 <MakeNewGranularArray+0x26>
    1a70:	0f 92       	push	r0
    1a72:	cd b7       	in	r28, 0x3d	; 61
    1a74:	de b7       	in	r29, 0x3e	; 62
    1a76:	28 2e       	mov	r2, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    1a78:	62 30       	cpi	r22, 0x02	; 2
    1a7a:	08 f4       	brcc	.+2      	; 0x1a7e <MakeNewGranularArray+0x34>
    1a7c:	f4 c0       	rjmp	.+488    	; 0x1c66 <MakeNewGranularArray+0x21c>
	{
		sreg=SREG;
    1a7e:	8f b7       	in	r24, 0x3f	; 63
    1a80:	89 83       	std	Y+1, r24	; 0x01
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    1a82:	f8 94       	cli
    1a84:	66 2e       	mov	r6, r22
    1a86:	90 e8       	ldi	r25, 0x80	; 128
    1a88:	96 17       	cp	r25, r22
    1a8a:	10 f4       	brcc	.+4      	; 0x1a90 <MakeNewGranularArray+0x46>
    1a8c:	20 e8       	ldi	r18, 0x80	; 128
    1a8e:	62 2e       	mov	r6, r18
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    1a90:	82 2c       	mov	r8, r2
    1a92:	99 24       	eor	r9, r9
    1a94:	d4 01       	movw	r26, r8
    1a96:	b6 95       	lsr	r27
    1a98:	ba 2f       	mov	r27, r26
    1a9a:	aa 27       	eor	r26, r26
    1a9c:	b7 95       	ror	r27
    1a9e:	a7 95       	ror	r26
    1aa0:	a8 5a       	subi	r26, 0xA8	; 168
    1aa2:	be 4f       	sbci	r27, 0xFE	; 254
    1aa4:	bb 83       	std	Y+3, r27	; 0x03
    1aa6:	aa 83       	std	Y+2, r26	; 0x02
    1aa8:	fd 01       	movw	r30, r26
    1aaa:	80 e0       	ldi	r24, 0x00	; 0
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    1aac:	81 93       	st	Z+, r24
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    1aae:	8f 5f       	subi	r24, 0xFF	; 255
    1ab0:	86 15       	cp	r24, r6
    1ab2:	e0 f3       	brcs	.-8      	; 0x1aac <MakeNewGranularArray+0x62>
    1ab4:	e0 90 00 01 	lds	r14, 0x0100
    1ab8:	f0 90 01 01 	lds	r15, 0x0101
    1abc:	00 91 02 01 	lds	r16, 0x0102
    1ac0:	10 91 03 01 	lds	r17, 0x0103
    1ac4:	77 24       	eor	r7, r7
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1ac6:	a6 2c       	mov	r10, r6
    1ac8:	bb 24       	eor	r11, r11
    1aca:	cc 24       	eor	r12, r12
    1acc:	dd 24       	eor	r13, r13
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1ace:	24 01       	movw	r4, r8
    1ad0:	56 94       	lsr	r5
    1ad2:	54 2c       	mov	r5, r4
    1ad4:	44 24       	eor	r4, r4
    1ad6:	57 94       	ror	r5
    1ad8:	47 94       	ror	r4
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    1ada:	ea 81       	ldd	r30, Y+2	; 0x02
    1adc:	fb 81       	ldd	r31, Y+3	; 0x03
    1ade:	30 80       	ld	r3, Z
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1ae0:	ee 0c       	add	r14, r14
    1ae2:	ff 1c       	adc	r15, r15
    1ae4:	00 1f       	adc	r16, r16
    1ae6:	11 1f       	adc	r17, r17
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1ae8:	17 ff       	sbrs	r17, 7
    1aea:	08 c0       	rjmp	.+16     	; 0x1afc <MakeNewGranularArray+0xb2>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1aec:	85 eb       	ldi	r24, 0xB5	; 181
    1aee:	95 e9       	ldi	r25, 0x95	; 149
    1af0:	aa ea       	ldi	r26, 0xAA	; 170
    1af2:	b0 e2       	ldi	r27, 0x20	; 32
    1af4:	e8 26       	eor	r14, r24
    1af6:	f9 26       	eor	r15, r25
    1af8:	0a 27       	eor	r16, r26
    1afa:	1b 27       	eor	r17, r27

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    1afc:	c8 01       	movw	r24, r16
    1afe:	b7 01       	movw	r22, r14
    1b00:	a6 01       	movw	r20, r12
    1b02:	95 01       	movw	r18, r10
    1b04:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1b08:	f2 01       	movw	r30, r4
    1b0a:	e6 0f       	add	r30, r22
    1b0c:	f1 1d       	adc	r31, r1
    1b0e:	e8 5a       	subi	r30, 0xA8	; 168
    1b10:	fe 4f       	sbci	r31, 0xFE	; 254
    1b12:	80 81       	ld	r24, Z
    1b14:	aa 81       	ldd	r26, Y+2	; 0x02
    1b16:	bb 81       	ldd	r27, Y+3	; 0x03
    1b18:	8d 93       	st	X+, r24
    1b1a:	bb 83       	std	Y+3, r27	; 0x03
    1b1c:	aa 83       	std	Y+2, r26	; 0x02
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1b1e:	30 82       	st	Z, r3
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    1b20:	73 94       	inc	r7
    1b22:	76 14       	cp	r7, r6
    1b24:	d0 f2       	brcs	.-76     	; 0x1ada <MakeNewGranularArray+0x90>
    1b26:	e0 92 00 01 	sts	0x0100, r14
    1b2a:	f0 92 01 01 	sts	0x0101, r15
    1b2e:	00 93 02 01 	sts	0x0102, r16
    1b32:	10 93 03 01 	sts	0x0103, r17
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1b36:	22 20       	and	r2, r2
    1b38:	b9 f4       	brne	.+46     	; 0x1b68 <MakeNewGranularArray+0x11e>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1b3a:	60 91 d4 02 	lds	r22, 0x02D4
    1b3e:	70 91 d5 02 	lds	r23, 0x02D5
    1b42:	80 91 d6 02 	lds	r24, 0x02D6
    1b46:	90 91 d7 02 	lds	r25, 0x02D7
    1b4a:	a6 01       	movw	r20, r12
    1b4c:	95 01       	movw	r18, r10
    1b4e:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
    1b52:	c9 01       	movw	r24, r18
    1b54:	da 01       	movw	r26, r20
    1b56:	80 93 48 01 	sts	0x0148, r24
    1b5a:	90 93 49 01 	sts	0x0149, r25
    1b5e:	a0 93 4a 01 	sts	0x014A, r26
    1b62:	b0 93 4b 01 	sts	0x014B, r27
    1b66:	1e c0       	rjmp	.+60     	; 0x1ba4 <MakeNewGranularArray+0x15a>
		}	
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;		
    1b68:	20 91 f6 02 	lds	r18, 0x02F6
    1b6c:	30 91 f7 02 	lds	r19, 0x02F7
    1b70:	40 91 f8 02 	lds	r20, 0x02F8
    1b74:	50 91 f9 02 	lds	r21, 0x02F9
    1b78:	6f ef       	ldi	r22, 0xFF	; 255
    1b7a:	7f ef       	ldi	r23, 0xFF	; 255
    1b7c:	87 e0       	ldi	r24, 0x07	; 7
    1b7e:	90 e0       	ldi	r25, 0x00	; 0
    1b80:	62 1b       	sub	r22, r18
    1b82:	73 0b       	sbc	r23, r19
    1b84:	84 0b       	sbc	r24, r20
    1b86:	95 0b       	sbc	r25, r21
    1b88:	a6 01       	movw	r20, r12
    1b8a:	95 01       	movw	r18, r10
    1b8c:	0e 94 42 27 	call	0x4e84	; 0x4e84 <__udivmodsi4>
    1b90:	c9 01       	movw	r24, r18
    1b92:	da 01       	movw	r26, r20
    1b94:	80 93 4c 01 	sts	0x014C, r24
    1b98:	90 93 4d 01 	sts	0x014D, r25
    1b9c:	a0 93 4e 01 	sts	0x014E, r26
    1ba0:	b0 93 4f 01 	sts	0x014F, r27
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1ba4:	f4 01       	movw	r30, r8
    1ba6:	ee 0f       	add	r30, r30
    1ba8:	ff 1f       	adc	r31, r31
    1baa:	c4 01       	movw	r24, r8
    1bac:	75 e0       	ldi	r23, 0x05	; 5
    1bae:	88 0f       	add	r24, r24
    1bb0:	99 1f       	adc	r25, r25
    1bb2:	7a 95       	dec	r23
    1bb4:	e1 f7       	brne	.-8      	; 0x1bae <MakeNewGranularArray+0x164>
    1bb6:	e8 0f       	add	r30, r24
    1bb8:	f9 1f       	adc	r31, r25
    1bba:	e7 53       	subi	r30, 0x37	; 55
    1bbc:	fd 4f       	sbci	r31, 0xFD	; 253
    1bbe:	65 82       	std	Z+5, r6	; 0x05
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1bc0:	f4 01       	movw	r30, r8
    1bc2:	ea 5b       	subi	r30, 0xBA	; 186
    1bc4:	fe 4f       	sbci	r31, 0xFE	; 254
    1bc6:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1bc8:	f4 01       	movw	r30, r8
    1bca:	ee 0f       	add	r30, r30
    1bcc:	ff 1f       	adc	r31, r31
    1bce:	ee 0f       	add	r30, r30
    1bd0:	ff 1f       	adc	r31, r31
    1bd2:	df 01       	movw	r26, r30
    1bd4:	a8 5b       	subi	r26, 0xB8	; 184
    1bd6:	be 4f       	sbci	r27, 0xFE	; 254
    1bd8:	8d 91       	ld	r24, X+
    1bda:	9d 91       	ld	r25, X+
    1bdc:	0d 90       	ld	r0, X+
    1bde:	bc 91       	ld	r27, X
    1be0:	a0 2d       	mov	r26, r0
    1be2:	e0 5b       	subi	r30, 0xB0	; 176
    1be4:	fe 4f       	sbci	r31, 0xFE	; 254
    1be6:	80 83       	st	Z, r24
    1be8:	91 83       	std	Z+1, r25	; 0x01
    1bea:	a2 83       	std	Z+2, r26	; 0x02
    1bec:	b3 83       	std	Z+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    1bee:	22 20       	and	r2, r2
    1bf0:	c1 f4       	brne	.+48     	; 0x1c22 <MakeNewGranularArray+0x1d8>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    1bf2:	20 91 48 01 	lds	r18, 0x0148
    1bf6:	30 91 49 01 	lds	r19, 0x0149
    1bfa:	40 91 4a 01 	lds	r20, 0x014A
    1bfe:	50 91 4b 01 	lds	r21, 0x014B
    1c02:	60 91 58 01 	lds	r22, 0x0158
    1c06:	70 e0       	ldi	r23, 0x00	; 0
    1c08:	80 e0       	ldi	r24, 0x00	; 0
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    1c10:	60 93 e7 02 	sts	0x02E7, r22
    1c14:	70 93 e8 02 	sts	0x02E8, r23
    1c18:	80 93 e9 02 	sts	0x02E9, r24
    1c1c:	90 93 ea 02 	sts	0x02EA, r25
    1c20:	1f c0       	rjmp	.+62     	; 0x1c60 <MakeNewGranularArray+0x216>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));								
    1c22:	20 91 4c 01 	lds	r18, 0x014C
    1c26:	30 91 4d 01 	lds	r19, 0x014D
    1c2a:	40 91 4e 01 	lds	r20, 0x014E
    1c2e:	50 91 4f 01 	lds	r21, 0x014F
    1c32:	60 91 d8 01 	lds	r22, 0x01D8
    1c36:	70 e0       	ldi	r23, 0x00	; 0
    1c38:	80 e0       	ldi	r24, 0x00	; 0
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    1c40:	2f ef       	ldi	r18, 0xFF	; 255
    1c42:	3f ef       	ldi	r19, 0xFF	; 255
    1c44:	47 e0       	ldi	r20, 0x07	; 7
    1c46:	50 e0       	ldi	r21, 0x00	; 0
    1c48:	26 1b       	sub	r18, r22
    1c4a:	37 0b       	sbc	r19, r23
    1c4c:	48 0b       	sbc	r20, r24
    1c4e:	59 0b       	sbc	r21, r25
    1c50:	20 93 09 03 	sts	0x0309, r18
    1c54:	30 93 0a 03 	sts	0x030A, r19
    1c58:	40 93 0b 03 	sts	0x030B, r20
    1c5c:	50 93 0c 03 	sts	0x030C, r21
		}

		SREG=sreg;		// Restore interrupts.
    1c60:	b9 81       	ldd	r27, Y+1	; 0x01
    1c62:	bf bf       	out	0x3f, r27	; 63
    1c64:	0e c0       	rjmp	.+28     	; 0x1c82 <MakeNewGranularArray+0x238>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.	
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	fc 01       	movw	r30, r24
    1c6a:	55 e0       	ldi	r21, 0x05	; 5
    1c6c:	ee 0f       	add	r30, r30
    1c6e:	ff 1f       	adc	r31, r31
    1c70:	5a 95       	dec	r21
    1c72:	e1 f7       	brne	.-8      	; 0x1c6c <MakeNewGranularArray+0x222>
    1c74:	88 0f       	add	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	e8 0f       	add	r30, r24
    1c7a:	f9 1f       	adc	r31, r25
    1c7c:	e7 53       	subi	r30, 0x37	; 55
    1c7e:	fd 4f       	sbci	r31, 0xFD	; 253
    1c80:	15 82       	std	Z+5, r1	; 0x05
	}
}
    1c82:	0f 90       	pop	r0
    1c84:	0f 90       	pop	r0
    1c86:	0f 90       	pop	r0
    1c88:	cf 91       	pop	r28
    1c8a:	df 91       	pop	r29
    1c8c:	1f 91       	pop	r17
    1c8e:	0f 91       	pop	r16
    1c90:	ff 90       	pop	r15
    1c92:	ef 90       	pop	r14
    1c94:	df 90       	pop	r13
    1c96:	cf 90       	pop	r12
    1c98:	bf 90       	pop	r11
    1c9a:	af 90       	pop	r10
    1c9c:	9f 90       	pop	r9
    1c9e:	8f 90       	pop	r8
    1ca0:	7f 90       	pop	r7
    1ca2:	6f 90       	pop	r6
    1ca4:	5f 90       	pop	r5
    1ca6:	4f 90       	pop	r4
    1ca8:	3f 90       	pop	r3
    1caa:	2f 90       	pop	r2
    1cac:	08 95       	ret

00001cae <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    1cae:	2f 92       	push	r2
    1cb0:	3f 92       	push	r3
    1cb2:	4f 92       	push	r4
    1cb4:	5f 92       	push	r5
    1cb6:	6f 92       	push	r6
    1cb8:	7f 92       	push	r7
    1cba:	8f 92       	push	r8
    1cbc:	9f 92       	push	r9
    1cbe:	af 92       	push	r10
    1cc0:	bf 92       	push	r11
    1cc2:	cf 92       	push	r12
    1cc4:	df 92       	push	r13
    1cc6:	ef 92       	push	r14
    1cc8:	ff 92       	push	r15
    1cca:	0f 93       	push	r16
    1ccc:	1f 93       	push	r17
    1cce:	df 93       	push	r29
    1cd0:	cf 93       	push	r28
    1cd2:	0f 92       	push	r0
    1cd4:	cd b7       	in	r28, 0x3d	; 61
    1cd6:	de b7       	in	r29, 0x3e	; 62
	unsigned char 
		sreg;
	unsigned long
		chunkSize;
		
	sreg=SREG;
    1cd8:	9f b7       	in	r25, 0x3f	; 63
    1cda:	99 83       	std	Y+1, r25	; 0x01
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1cdc:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1cde:	88 23       	and	r24, r24
    1ce0:	09 f0       	breq	.+2      	; 0x1ce4 <UpdateAdjustedSampleAddresses+0x36>
    1ce2:	f4 c1       	rjmp	.+1000   	; 0x20cc <UpdateAdjustedSampleAddresses+0x41e>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1ce4:	a0 90 d4 02 	lds	r10, 0x02D4
    1ce8:	b0 90 d5 02 	lds	r11, 0x02D5
    1cec:	c0 90 d6 02 	lds	r12, 0x02D6
    1cf0:	d0 90 d7 02 	lds	r13, 0x02D7
    1cf4:	03 e0       	ldi	r16, 0x03	; 3
    1cf6:	aa 0c       	add	r10, r10
    1cf8:	bb 1c       	adc	r11, r11
    1cfa:	cc 1c       	adc	r12, r12
    1cfc:	dd 1c       	adc	r13, r13
    1cfe:	0a 95       	dec	r16
    1d00:	d1 f7       	brne	.-12     	; 0x1cf6 <UpdateAdjustedSampleAddresses+0x48>
    1d02:	ab 2c       	mov	r10, r11
    1d04:	bc 2c       	mov	r11, r12
    1d06:	cd 2c       	mov	r12, r13
    1d08:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1d0a:	60 91 e4 02 	lds	r22, 0x02E4
    1d0e:	20 91 e6 02 	lds	r18, 0x02E6
    1d12:	70 e0       	ldi	r23, 0x00	; 0
    1d14:	62 0f       	add	r22, r18
    1d16:	71 1d       	adc	r23, r1
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	a6 01       	movw	r20, r12
    1d1e:	95 01       	movw	r18, r10
    1d20:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    1d24:	b3 e0       	ldi	r27, 0x03	; 3
    1d26:	96 95       	lsr	r25
    1d28:	87 95       	ror	r24
    1d2a:	77 95       	ror	r23
    1d2c:	67 95       	ror	r22
    1d2e:	ba 95       	dec	r27
    1d30:	d1 f7       	brne	.-12     	; 0x1d26 <UpdateAdjustedSampleAddresses+0x78>
    1d32:	60 93 e0 02 	sts	0x02E0, r22
    1d36:	70 93 e1 02 	sts	0x02E1, r23
    1d3a:	80 93 e2 02 	sts	0x02E2, r24
    1d3e:	90 93 e3 02 	sts	0x02E3, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    1d42:	20 90 d4 02 	lds	r2, 0x02D4
    1d46:	30 90 d5 02 	lds	r3, 0x02D5
    1d4a:	40 90 d6 02 	lds	r4, 0x02D6
    1d4e:	50 90 d7 02 	lds	r5, 0x02D7
    1d52:	60 90 e5 02 	lds	r6, 0x02E5
    1d56:	20 91 e6 02 	lds	r18, 0x02E6
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	40 e0       	ldi	r20, 0x00	; 0
    1d5e:	50 e0       	ldi	r21, 0x00	; 0
    1d60:	c6 01       	movw	r24, r12
    1d62:	b5 01       	movw	r22, r10
    1d64:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    1d68:	7b 01       	movw	r14, r22
    1d6a:	8c 01       	movw	r16, r24
    1d6c:	a3 e0       	ldi	r26, 0x03	; 3
    1d6e:	16 95       	lsr	r17
    1d70:	07 95       	ror	r16
    1d72:	f7 94       	ror	r15
    1d74:	e7 94       	ror	r14
    1d76:	aa 95       	dec	r26
    1d78:	d1 f7       	brne	.-12     	; 0x1d6e <UpdateAdjustedSampleAddresses+0xc0>
    1d7a:	e2 0c       	add	r14, r2
    1d7c:	f3 1c       	adc	r15, r3
    1d7e:	04 1d       	adc	r16, r4
    1d80:	15 1d       	adc	r17, r5
    1d82:	77 24       	eor	r7, r7
    1d84:	88 24       	eor	r8, r8
    1d86:	99 24       	eor	r9, r9
    1d88:	c6 01       	movw	r24, r12
    1d8a:	b5 01       	movw	r22, r10
    1d8c:	a4 01       	movw	r20, r8
    1d8e:	93 01       	movw	r18, r6
    1d90:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    1d94:	f3 e0       	ldi	r31, 0x03	; 3
    1d96:	96 95       	lsr	r25
    1d98:	87 95       	ror	r24
    1d9a:	77 95       	ror	r23
    1d9c:	67 95       	ror	r22
    1d9e:	fa 95       	dec	r31
    1da0:	d1 f7       	brne	.-12     	; 0x1d96 <UpdateAdjustedSampleAddresses+0xe8>
    1da2:	e6 1a       	sub	r14, r22
    1da4:	f7 0a       	sbc	r15, r23
    1da6:	08 0b       	sbc	r16, r24
    1da8:	19 0b       	sbc	r17, r25
    1daa:	e0 92 dc 02 	sts	0x02DC, r14
    1dae:	f0 92 dd 02 	sts	0x02DD, r15
    1db2:	00 93 de 02 	sts	0x02DE, r16
    1db6:	10 93 df 02 	sts	0x02DF, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1dba:	20 91 e0 02 	lds	r18, 0x02E0
    1dbe:	30 91 e1 02 	lds	r19, 0x02E1
    1dc2:	40 91 e2 02 	lds	r20, 0x02E2
    1dc6:	50 91 e3 02 	lds	r21, 0x02E3
    1dca:	80 91 dc 02 	lds	r24, 0x02DC
    1dce:	90 91 dd 02 	lds	r25, 0x02DD
    1dd2:	a0 91 de 02 	lds	r26, 0x02DE
    1dd6:	b0 91 df 02 	lds	r27, 0x02DF
    1dda:	82 17       	cp	r24, r18
    1ddc:	93 07       	cpc	r25, r19
    1dde:	a4 07       	cpc	r26, r20
    1de0:	b5 07       	cpc	r27, r21
    1de2:	50 f5       	brcc	.+84     	; 0x1e38 <UpdateAdjustedSampleAddresses+0x18a>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1de4:	80 91 cc 02 	lds	r24, 0x02CC
    1de8:	81 30       	cpi	r24, 0x01	; 1
    1dea:	19 f4       	brne	.+6      	; 0x1df2 <UpdateAdjustedSampleAddresses+0x144>
			{
				bankStates[BANK_0].sampleDirection=true;
    1dec:	80 93 cd 02 	sts	0x02CD, r24
    1df0:	02 c0       	rjmp	.+4      	; 0x1df6 <UpdateAdjustedSampleAddresses+0x148>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    1df2:	10 92 cd 02 	sts	0x02CD, r1
			}			

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    1df6:	20 91 e0 02 	lds	r18, 0x02E0
    1dfa:	30 91 e1 02 	lds	r19, 0x02E1
    1dfe:	40 91 e2 02 	lds	r20, 0x02E2
    1e02:	50 91 e3 02 	lds	r21, 0x02E3
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    1e06:	80 91 dc 02 	lds	r24, 0x02DC
    1e0a:	90 91 dd 02 	lds	r25, 0x02DD
    1e0e:	a0 91 de 02 	lds	r26, 0x02DE
    1e12:	b0 91 df 02 	lds	r27, 0x02DF
    1e16:	80 93 e0 02 	sts	0x02E0, r24
    1e1a:	90 93 e1 02 	sts	0x02E1, r25
    1e1e:	a0 93 e2 02 	sts	0x02E2, r26
    1e22:	b0 93 e3 02 	sts	0x02E3, r27
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    1e26:	20 93 dc 02 	sts	0x02DC, r18
    1e2a:	30 93 dd 02 	sts	0x02DD, r19
    1e2e:	40 93 de 02 	sts	0x02DE, r20
    1e32:	50 93 df 02 	sts	0x02DF, r21
    1e36:	0a c0       	rjmp	.+20     	; 0x1e4c <UpdateAdjustedSampleAddresses+0x19e>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    1e38:	80 91 cc 02 	lds	r24, 0x02CC
    1e3c:	81 30       	cpi	r24, 0x01	; 1
    1e3e:	19 f4       	brne	.+6      	; 0x1e46 <UpdateAdjustedSampleAddresses+0x198>
			{
				bankStates[BANK_0].sampleDirection=false;
    1e40:	10 92 cd 02 	sts	0x02CD, r1
    1e44:	03 c0       	rjmp	.+6      	; 0x1e4c <UpdateAdjustedSampleAddresses+0x19e>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    1e46:	81 e0       	ldi	r24, 0x01	; 1
    1e48:	80 93 cd 02 	sts	0x02CD, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    1e4c:	20 91 e0 02 	lds	r18, 0x02E0
    1e50:	30 91 e1 02 	lds	r19, 0x02E1
    1e54:	40 91 e2 02 	lds	r20, 0x02E2
    1e58:	50 91 e3 02 	lds	r21, 0x02E3
    1e5c:	80 91 d4 02 	lds	r24, 0x02D4
    1e60:	90 91 d5 02 	lds	r25, 0x02D5
    1e64:	a0 91 d6 02 	lds	r26, 0x02D6
    1e68:	b0 91 d7 02 	lds	r27, 0x02D7
    1e6c:	82 17       	cp	r24, r18
    1e6e:	93 07       	cpc	r25, r19
    1e70:	a4 07       	cpc	r26, r20
    1e72:	b5 07       	cpc	r27, r21
    1e74:	e0 f4       	brcc	.+56     	; 0x1eae <UpdateAdjustedSampleAddresses+0x200>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1e76:	80 91 e0 02 	lds	r24, 0x02E0
    1e7a:	90 91 e1 02 	lds	r25, 0x02E1
    1e7e:	a0 91 e2 02 	lds	r26, 0x02E2
    1e82:	b0 91 e3 02 	lds	r27, 0x02E3
    1e86:	20 91 d4 02 	lds	r18, 0x02D4
    1e8a:	30 91 d5 02 	lds	r19, 0x02D5
    1e8e:	40 91 d6 02 	lds	r20, 0x02D6
    1e92:	50 91 d7 02 	lds	r21, 0x02D7
    1e96:	82 1b       	sub	r24, r18
    1e98:	93 0b       	sbc	r25, r19
    1e9a:	a4 0b       	sbc	r26, r20
    1e9c:	b5 0b       	sbc	r27, r21
    1e9e:	80 93 e0 02 	sts	0x02E0, r24
    1ea2:	90 93 e1 02 	sts	0x02E1, r25
    1ea6:	a0 93 e2 02 	sts	0x02E2, r26
    1eaa:	b0 93 e3 02 	sts	0x02E3, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    1eae:	20 91 dc 02 	lds	r18, 0x02DC
    1eb2:	30 91 dd 02 	lds	r19, 0x02DD
    1eb6:	40 91 de 02 	lds	r20, 0x02DE
    1eba:	50 91 df 02 	lds	r21, 0x02DF
    1ebe:	80 91 d4 02 	lds	r24, 0x02D4
    1ec2:	90 91 d5 02 	lds	r25, 0x02D5
    1ec6:	a0 91 d6 02 	lds	r26, 0x02D6
    1eca:	b0 91 d7 02 	lds	r27, 0x02D7
    1ece:	82 17       	cp	r24, r18
    1ed0:	93 07       	cpc	r25, r19
    1ed2:	a4 07       	cpc	r26, r20
    1ed4:	b5 07       	cpc	r27, r21
    1ed6:	08 f0       	brcs	.+2      	; 0x1eda <UpdateAdjustedSampleAddresses+0x22c>
    1ed8:	44 c0       	rjmp	.+136    	; 0x1f62 <UpdateAdjustedSampleAddresses+0x2b4>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1eda:	80 91 dc 02 	lds	r24, 0x02DC
    1ede:	90 91 dd 02 	lds	r25, 0x02DD
    1ee2:	a0 91 de 02 	lds	r26, 0x02DE
    1ee6:	b0 91 df 02 	lds	r27, 0x02DF
    1eea:	20 91 d4 02 	lds	r18, 0x02D4
    1eee:	30 91 d5 02 	lds	r19, 0x02D5
    1ef2:	40 91 d6 02 	lds	r20, 0x02D6
    1ef6:	50 91 d7 02 	lds	r21, 0x02D7
    1efa:	82 1b       	sub	r24, r18
    1efc:	93 0b       	sbc	r25, r19
    1efe:	a4 0b       	sbc	r26, r20
    1f00:	b5 0b       	sbc	r27, r21
    1f02:	80 93 dc 02 	sts	0x02DC, r24
    1f06:	90 93 dd 02 	sts	0x02DD, r25
    1f0a:	a0 93 de 02 	sts	0x02DE, r26
    1f0e:	b0 93 df 02 	sts	0x02DF, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    1f12:	20 91 dc 02 	lds	r18, 0x02DC
    1f16:	30 91 dd 02 	lds	r19, 0x02DD
    1f1a:	40 91 de 02 	lds	r20, 0x02DE
    1f1e:	50 91 df 02 	lds	r21, 0x02DF
    1f22:	80 91 e0 02 	lds	r24, 0x02E0
    1f26:	90 91 e1 02 	lds	r25, 0x02E1
    1f2a:	a0 91 e2 02 	lds	r26, 0x02E2
    1f2e:	b0 91 e3 02 	lds	r27, 0x02E3
    1f32:	28 17       	cp	r18, r24
    1f34:	39 07       	cpc	r19, r25
    1f36:	4a 07       	cpc	r20, r26
    1f38:	5b 07       	cpc	r21, r27
    1f3a:	99 f4       	brne	.+38     	; 0x1f62 <UpdateAdjustedSampleAddresses+0x2b4>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    1f3c:	80 91 dc 02 	lds	r24, 0x02DC
    1f40:	90 91 dd 02 	lds	r25, 0x02DD
    1f44:	a0 91 de 02 	lds	r26, 0x02DE
    1f48:	b0 91 df 02 	lds	r27, 0x02DF
    1f4c:	01 97       	sbiw	r24, 0x01	; 1
    1f4e:	a1 09       	sbc	r26, r1
    1f50:	b1 09       	sbc	r27, r1
    1f52:	80 93 dc 02 	sts	0x02DC, r24
    1f56:	90 93 dd 02 	sts	0x02DD, r25
    1f5a:	a0 93 de 02 	sts	0x02DE, r26
    1f5e:	b0 93 df 02 	sts	0x02DF, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    1f62:	20 91 e0 02 	lds	r18, 0x02E0
    1f66:	30 91 e1 02 	lds	r19, 0x02E1
    1f6a:	40 91 e2 02 	lds	r20, 0x02E2
    1f6e:	50 91 e3 02 	lds	r21, 0x02E3
    1f72:	80 91 dc 02 	lds	r24, 0x02DC
    1f76:	90 91 dd 02 	lds	r25, 0x02DD
    1f7a:	a0 91 de 02 	lds	r26, 0x02DE
    1f7e:	b0 91 df 02 	lds	r27, 0x02DF
    1f82:	82 17       	cp	r24, r18
    1f84:	93 07       	cpc	r25, r19
    1f86:	a4 07       	cpc	r26, r20
    1f88:	b5 07       	cpc	r27, r21
    1f8a:	08 f0       	brcs	.+2      	; 0x1f8e <UpdateAdjustedSampleAddresses+0x2e0>
    1f8c:	5a c0       	rjmp	.+180    	; 0x2042 <UpdateAdjustedSampleAddresses+0x394>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1f8e:	20 91 e7 02 	lds	r18, 0x02E7
    1f92:	30 91 e8 02 	lds	r19, 0x02E8
    1f96:	40 91 e9 02 	lds	r20, 0x02E9
    1f9a:	50 91 ea 02 	lds	r21, 0x02EA
    1f9e:	80 91 e0 02 	lds	r24, 0x02E0
    1fa2:	90 91 e1 02 	lds	r25, 0x02E1
    1fa6:	a0 91 e2 02 	lds	r26, 0x02E2
    1faa:	b0 91 e3 02 	lds	r27, 0x02E3
    1fae:	28 17       	cp	r18, r24
    1fb0:	39 07       	cpc	r19, r25
    1fb2:	4a 07       	cpc	r20, r26
    1fb4:	5b 07       	cpc	r21, r27
    1fb6:	08 f0       	brcs	.+2      	; 0x1fba <UpdateAdjustedSampleAddresses+0x30c>
    1fb8:	94 c2       	rjmp	.+1320   	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
    1fba:	20 91 e7 02 	lds	r18, 0x02E7
    1fbe:	30 91 e8 02 	lds	r19, 0x02E8
    1fc2:	40 91 e9 02 	lds	r20, 0x02E9
    1fc6:	50 91 ea 02 	lds	r21, 0x02EA
    1fca:	80 91 dc 02 	lds	r24, 0x02DC
    1fce:	90 91 dd 02 	lds	r25, 0x02DD
    1fd2:	a0 91 de 02 	lds	r26, 0x02DE
    1fd6:	b0 91 df 02 	lds	r27, 0x02DF
    1fda:	82 17       	cp	r24, r18
    1fdc:	93 07       	cpc	r25, r19
    1fde:	a4 07       	cpc	r26, r20
    1fe0:	b5 07       	cpc	r27, r21
    1fe2:	08 f0       	brcs	.+2      	; 0x1fe6 <UpdateAdjustedSampleAddresses+0x338>
    1fe4:	7e c2       	rjmp	.+1276   	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?	
    1fe6:	20 91 e0 02 	lds	r18, 0x02E0
    1fea:	30 91 e1 02 	lds	r19, 0x02E1
    1fee:	40 91 e2 02 	lds	r20, 0x02E2
    1ff2:	50 91 e3 02 	lds	r21, 0x02E3
    1ff6:	a0 90 e7 02 	lds	r10, 0x02E7
    1ffa:	b0 90 e8 02 	lds	r11, 0x02E8
    1ffe:	c0 90 e9 02 	lds	r12, 0x02E9
    2002:	d0 90 ea 02 	lds	r13, 0x02EA
    2006:	80 91 e7 02 	lds	r24, 0x02E7
    200a:	90 91 e8 02 	lds	r25, 0x02E8
    200e:	a0 91 e9 02 	lds	r26, 0x02E9
    2012:	b0 91 ea 02 	lds	r27, 0x02EA
    2016:	e0 90 dc 02 	lds	r14, 0x02DC
    201a:	f0 90 dd 02 	lds	r15, 0x02DD
    201e:	00 91 de 02 	lds	r16, 0x02DE
    2022:	10 91 df 02 	lds	r17, 0x02DF
    2026:	2a 19       	sub	r18, r10
    2028:	3b 09       	sbc	r19, r11
    202a:	4c 09       	sbc	r20, r12
    202c:	5d 09       	sbc	r21, r13
    202e:	8e 19       	sub	r24, r14
    2030:	9f 09       	sbc	r25, r15
    2032:	a0 0b       	sbc	r26, r16
    2034:	b1 0b       	sbc	r27, r17
    2036:	28 17       	cp	r18, r24
    2038:	39 07       	cpc	r19, r25
    203a:	4a 07       	cpc	r20, r26
    203c:	5b 07       	cpc	r21, r27
    203e:	a8 f1       	brcs	.+106    	; 0x20aa <UpdateAdjustedSampleAddresses+0x3fc>
    2040:	15 c0       	rjmp	.+42     	; 0x206c <UpdateAdjustedSampleAddresses+0x3be>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    2042:	20 91 e7 02 	lds	r18, 0x02E7
    2046:	30 91 e8 02 	lds	r19, 0x02E8
    204a:	40 91 e9 02 	lds	r20, 0x02E9
    204e:	50 91 ea 02 	lds	r21, 0x02EA
    2052:	80 91 e0 02 	lds	r24, 0x02E0
    2056:	90 91 e1 02 	lds	r25, 0x02E1
    205a:	a0 91 e2 02 	lds	r26, 0x02E2
    205e:	b0 91 e3 02 	lds	r27, 0x02E3
    2062:	28 17       	cp	r18, r24
    2064:	39 07       	cpc	r19, r25
    2066:	4a 07       	cpc	r20, r26
    2068:	5b 07       	cpc	r21, r27
    206a:	48 f4       	brcc	.+18     	; 0x207e <UpdateAdjustedSampleAddresses+0x3d0>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    206c:	80 91 e0 02 	lds	r24, 0x02E0
    2070:	90 91 e1 02 	lds	r25, 0x02E1
    2074:	a0 91 e2 02 	lds	r26, 0x02E2
    2078:	b0 91 e3 02 	lds	r27, 0x02E3
    207c:	1e c0       	rjmp	.+60     	; 0x20ba <UpdateAdjustedSampleAddresses+0x40c>
			}				
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    207e:	20 91 e7 02 	lds	r18, 0x02E7
    2082:	30 91 e8 02 	lds	r19, 0x02E8
    2086:	40 91 e9 02 	lds	r20, 0x02E9
    208a:	50 91 ea 02 	lds	r21, 0x02EA
    208e:	80 91 dc 02 	lds	r24, 0x02DC
    2092:	90 91 dd 02 	lds	r25, 0x02DD
    2096:	a0 91 de 02 	lds	r26, 0x02DE
    209a:	b0 91 df 02 	lds	r27, 0x02DF
    209e:	82 17       	cp	r24, r18
    20a0:	93 07       	cpc	r25, r19
    20a2:	a4 07       	cpc	r26, r20
    20a4:	b5 07       	cpc	r27, r21
    20a6:	08 f0       	brcs	.+2      	; 0x20aa <UpdateAdjustedSampleAddresses+0x3fc>
    20a8:	1c c2       	rjmp	.+1080   	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    20aa:	80 91 dc 02 	lds	r24, 0x02DC
    20ae:	90 91 dd 02 	lds	r25, 0x02DD
    20b2:	a0 91 de 02 	lds	r26, 0x02DE
    20b6:	b0 91 df 02 	lds	r27, 0x02DF
    20ba:	80 93 e7 02 	sts	0x02E7, r24
    20be:	90 93 e8 02 	sts	0x02E8, r25
    20c2:	a0 93 e9 02 	sts	0x02E9, r26
    20c6:	b0 93 ea 02 	sts	0x02EA, r27
    20ca:	0b c2       	rjmp	.+1046   	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
		}
	}	
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    20cc:	80 91 f6 02 	lds	r24, 0x02F6
    20d0:	90 91 f7 02 	lds	r25, 0x02F7
    20d4:	a0 91 f8 02 	lds	r26, 0x02F8
    20d8:	b0 91 f9 02 	lds	r27, 0x02F9
    20dc:	ef ef       	ldi	r30, 0xFF	; 255
    20de:	ee 2e       	mov	r14, r30
    20e0:	ef ef       	ldi	r30, 0xFF	; 255
    20e2:	fe 2e       	mov	r15, r30
    20e4:	e7 e0       	ldi	r30, 0x07	; 7
    20e6:	0e 2f       	mov	r16, r30
    20e8:	11 2d       	mov	r17, r1
    20ea:	57 01       	movw	r10, r14
    20ec:	68 01       	movw	r12, r16
    20ee:	a8 1a       	sub	r10, r24
    20f0:	b9 0a       	sbc	r11, r25
    20f2:	ca 0a       	sbc	r12, r26
    20f4:	db 0a       	sbc	r13, r27
    20f6:	73 e0       	ldi	r23, 0x03	; 3
    20f8:	aa 0c       	add	r10, r10
    20fa:	bb 1c       	adc	r11, r11
    20fc:	cc 1c       	adc	r12, r12
    20fe:	dd 1c       	adc	r13, r13
    2100:	7a 95       	dec	r23
    2102:	d1 f7       	brne	.-12     	; 0x20f8 <UpdateAdjustedSampleAddresses+0x44a>
    2104:	ab 2c       	mov	r10, r11
    2106:	bc 2c       	mov	r11, r12
    2108:	cd 2c       	mov	r12, r13
    210a:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    210c:	60 91 06 03 	lds	r22, 0x0306
    2110:	20 91 08 03 	lds	r18, 0x0308
    2114:	70 e0       	ldi	r23, 0x00	; 0
    2116:	62 0f       	add	r22, r18
    2118:	71 1d       	adc	r23, r1
    211a:	80 e0       	ldi	r24, 0x00	; 0
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	a6 01       	movw	r20, r12
    2120:	95 01       	movw	r18, r10
    2122:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    2126:	53 e0       	ldi	r21, 0x03	; 3
    2128:	96 95       	lsr	r25
    212a:	87 95       	ror	r24
    212c:	77 95       	ror	r23
    212e:	67 95       	ror	r22
    2130:	5a 95       	dec	r21
    2132:	d1 f7       	brne	.-12     	; 0x2128 <UpdateAdjustedSampleAddresses+0x47a>
    2134:	e6 1a       	sub	r14, r22
    2136:	f7 0a       	sbc	r15, r23
    2138:	08 0b       	sbc	r16, r24
    213a:	19 0b       	sbc	r17, r25
    213c:	e0 92 02 03 	sts	0x0302, r14
    2140:	f0 92 03 03 	sts	0x0303, r15
    2144:	00 93 04 03 	sts	0x0304, r16
    2148:	10 93 05 03 	sts	0x0305, r17
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    214c:	20 90 f6 02 	lds	r2, 0x02F6
    2150:	30 90 f7 02 	lds	r3, 0x02F7
    2154:	40 90 f8 02 	lds	r4, 0x02F8
    2158:	50 90 f9 02 	lds	r5, 0x02F9
    215c:	20 91 07 03 	lds	r18, 0x0307
    2160:	60 90 08 03 	lds	r6, 0x0308
    2164:	30 e0       	ldi	r19, 0x00	; 0
    2166:	40 e0       	ldi	r20, 0x00	; 0
    2168:	50 e0       	ldi	r21, 0x00	; 0
    216a:	c6 01       	movw	r24, r12
    216c:	b5 01       	movw	r22, r10
    216e:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    2172:	7b 01       	movw	r14, r22
    2174:	8c 01       	movw	r16, r24
    2176:	43 e0       	ldi	r20, 0x03	; 3
    2178:	16 95       	lsr	r17
    217a:	07 95       	ror	r16
    217c:	f7 94       	ror	r15
    217e:	e7 94       	ror	r14
    2180:	4a 95       	dec	r20
    2182:	d1 f7       	brne	.-12     	; 0x2178 <UpdateAdjustedSampleAddresses+0x4ca>
    2184:	e2 0c       	add	r14, r2
    2186:	f3 1c       	adc	r15, r3
    2188:	04 1d       	adc	r16, r4
    218a:	15 1d       	adc	r17, r5
    218c:	77 24       	eor	r7, r7
    218e:	88 24       	eor	r8, r8
    2190:	99 24       	eor	r9, r9
    2192:	c6 01       	movw	r24, r12
    2194:	b5 01       	movw	r22, r10
    2196:	a4 01       	movw	r20, r8
    2198:	93 01       	movw	r18, r6
    219a:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    219e:	33 e0       	ldi	r19, 0x03	; 3
    21a0:	96 95       	lsr	r25
    21a2:	87 95       	ror	r24
    21a4:	77 95       	ror	r23
    21a6:	67 95       	ror	r22
    21a8:	3a 95       	dec	r19
    21aa:	d1 f7       	brne	.-12     	; 0x21a0 <UpdateAdjustedSampleAddresses+0x4f2>
    21ac:	e6 1a       	sub	r14, r22
    21ae:	f7 0a       	sbc	r15, r23
    21b0:	08 0b       	sbc	r16, r24
    21b2:	19 0b       	sbc	r17, r25
    21b4:	e0 92 fe 02 	sts	0x02FE, r14
    21b8:	f0 92 ff 02 	sts	0x02FF, r15
    21bc:	00 93 00 03 	sts	0x0300, r16
    21c0:	10 93 01 03 	sts	0x0301, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    21c4:	20 91 02 03 	lds	r18, 0x0302
    21c8:	30 91 03 03 	lds	r19, 0x0303
    21cc:	40 91 04 03 	lds	r20, 0x0304
    21d0:	50 91 05 03 	lds	r21, 0x0305
    21d4:	80 91 fe 02 	lds	r24, 0x02FE
    21d8:	90 91 ff 02 	lds	r25, 0x02FF
    21dc:	a0 91 00 03 	lds	r26, 0x0300
    21e0:	b0 91 01 03 	lds	r27, 0x0301
    21e4:	28 17       	cp	r18, r24
    21e6:	39 07       	cpc	r19, r25
    21e8:	4a 07       	cpc	r20, r26
    21ea:	5b 07       	cpc	r21, r27
    21ec:	50 f5       	brcc	.+84     	; 0x2242 <UpdateAdjustedSampleAddresses+0x594>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    21ee:	80 91 ee 02 	lds	r24, 0x02EE
    21f2:	81 30       	cpi	r24, 0x01	; 1
    21f4:	19 f4       	brne	.+6      	; 0x21fc <UpdateAdjustedSampleAddresses+0x54e>
			{
				bankStates[BANK_1].sampleDirection=true;
    21f6:	80 93 ef 02 	sts	0x02EF, r24
    21fa:	02 c0       	rjmp	.+4      	; 0x2200 <UpdateAdjustedSampleAddresses+0x552>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    21fc:	10 92 ef 02 	sts	0x02EF, r1
			}			

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    2200:	20 91 02 03 	lds	r18, 0x0302
    2204:	30 91 03 03 	lds	r19, 0x0303
    2208:	40 91 04 03 	lds	r20, 0x0304
    220c:	50 91 05 03 	lds	r21, 0x0305
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    2210:	80 91 fe 02 	lds	r24, 0x02FE
    2214:	90 91 ff 02 	lds	r25, 0x02FF
    2218:	a0 91 00 03 	lds	r26, 0x0300
    221c:	b0 91 01 03 	lds	r27, 0x0301
    2220:	80 93 02 03 	sts	0x0302, r24
    2224:	90 93 03 03 	sts	0x0303, r25
    2228:	a0 93 04 03 	sts	0x0304, r26
    222c:	b0 93 05 03 	sts	0x0305, r27
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    2230:	20 93 fe 02 	sts	0x02FE, r18
    2234:	30 93 ff 02 	sts	0x02FF, r19
    2238:	40 93 00 03 	sts	0x0300, r20
    223c:	50 93 01 03 	sts	0x0301, r21
    2240:	0a c0       	rjmp	.+20     	; 0x2256 <UpdateAdjustedSampleAddresses+0x5a8>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    2242:	80 91 ee 02 	lds	r24, 0x02EE
    2246:	81 30       	cpi	r24, 0x01	; 1
    2248:	19 f4       	brne	.+6      	; 0x2250 <UpdateAdjustedSampleAddresses+0x5a2>
			{
				bankStates[BANK_1].sampleDirection=false;
    224a:	10 92 ef 02 	sts	0x02EF, r1
    224e:	03 c0       	rjmp	.+6      	; 0x2256 <UpdateAdjustedSampleAddresses+0x5a8>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    2250:	81 e0       	ldi	r24, 0x01	; 1
    2252:	80 93 ef 02 	sts	0x02EF, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    2256:	20 91 02 03 	lds	r18, 0x0302
    225a:	30 91 03 03 	lds	r19, 0x0303
    225e:	40 91 04 03 	lds	r20, 0x0304
    2262:	50 91 05 03 	lds	r21, 0x0305
    2266:	80 91 f6 02 	lds	r24, 0x02F6
    226a:	90 91 f7 02 	lds	r25, 0x02F7
    226e:	a0 91 f8 02 	lds	r26, 0x02F8
    2272:	b0 91 f9 02 	lds	r27, 0x02F9
    2276:	28 17       	cp	r18, r24
    2278:	39 07       	cpc	r19, r25
    227a:	4a 07       	cpc	r20, r26
    227c:	5b 07       	cpc	r21, r27
    227e:	00 f5       	brcc	.+64     	; 0x22c0 <UpdateAdjustedSampleAddresses+0x612>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    2280:	80 91 02 03 	lds	r24, 0x0302
    2284:	90 91 03 03 	lds	r25, 0x0303
    2288:	a0 91 04 03 	lds	r26, 0x0304
    228c:	b0 91 05 03 	lds	r27, 0x0305
    2290:	20 91 f6 02 	lds	r18, 0x02F6
    2294:	30 91 f7 02 	lds	r19, 0x02F7
    2298:	40 91 f8 02 	lds	r20, 0x02F8
    229c:	50 91 f9 02 	lds	r21, 0x02F9
    22a0:	81 50       	subi	r24, 0x01	; 1
    22a2:	90 40       	sbci	r25, 0x00	; 0
    22a4:	a8 4f       	sbci	r26, 0xF8	; 248
    22a6:	bf 4f       	sbci	r27, 0xFF	; 255
    22a8:	82 1b       	sub	r24, r18
    22aa:	93 0b       	sbc	r25, r19
    22ac:	a4 0b       	sbc	r26, r20
    22ae:	b5 0b       	sbc	r27, r21
    22b0:	80 93 02 03 	sts	0x0302, r24
    22b4:	90 93 03 03 	sts	0x0303, r25
    22b8:	a0 93 04 03 	sts	0x0304, r26
    22bc:	b0 93 05 03 	sts	0x0305, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    22c0:	20 91 fe 02 	lds	r18, 0x02FE
    22c4:	30 91 ff 02 	lds	r19, 0x02FF
    22c8:	40 91 00 03 	lds	r20, 0x0300
    22cc:	50 91 01 03 	lds	r21, 0x0301
    22d0:	80 91 f6 02 	lds	r24, 0x02F6
    22d4:	90 91 f7 02 	lds	r25, 0x02F7
    22d8:	a0 91 f8 02 	lds	r26, 0x02F8
    22dc:	b0 91 f9 02 	lds	r27, 0x02F9
    22e0:	28 17       	cp	r18, r24
    22e2:	39 07       	cpc	r19, r25
    22e4:	4a 07       	cpc	r20, r26
    22e6:	5b 07       	cpc	r21, r27
    22e8:	08 f0       	brcs	.+2      	; 0x22ec <UpdateAdjustedSampleAddresses+0x63e>
    22ea:	48 c0       	rjmp	.+144    	; 0x237c <UpdateAdjustedSampleAddresses+0x6ce>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    22ec:	80 91 fe 02 	lds	r24, 0x02FE
    22f0:	90 91 ff 02 	lds	r25, 0x02FF
    22f4:	a0 91 00 03 	lds	r26, 0x0300
    22f8:	b0 91 01 03 	lds	r27, 0x0301
    22fc:	20 91 f6 02 	lds	r18, 0x02F6
    2300:	30 91 f7 02 	lds	r19, 0x02F7
    2304:	40 91 f8 02 	lds	r20, 0x02F8
    2308:	50 91 f9 02 	lds	r21, 0x02F9
    230c:	81 50       	subi	r24, 0x01	; 1
    230e:	90 40       	sbci	r25, 0x00	; 0
    2310:	a8 4f       	sbci	r26, 0xF8	; 248
    2312:	bf 4f       	sbci	r27, 0xFF	; 255
    2314:	82 1b       	sub	r24, r18
    2316:	93 0b       	sbc	r25, r19
    2318:	a4 0b       	sbc	r26, r20
    231a:	b5 0b       	sbc	r27, r21
    231c:	80 93 fe 02 	sts	0x02FE, r24
    2320:	90 93 ff 02 	sts	0x02FF, r25
    2324:	a0 93 00 03 	sts	0x0300, r26
    2328:	b0 93 01 03 	sts	0x0301, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    232c:	20 91 fe 02 	lds	r18, 0x02FE
    2330:	30 91 ff 02 	lds	r19, 0x02FF
    2334:	40 91 00 03 	lds	r20, 0x0300
    2338:	50 91 01 03 	lds	r21, 0x0301
    233c:	80 91 02 03 	lds	r24, 0x0302
    2340:	90 91 03 03 	lds	r25, 0x0303
    2344:	a0 91 04 03 	lds	r26, 0x0304
    2348:	b0 91 05 03 	lds	r27, 0x0305
    234c:	28 17       	cp	r18, r24
    234e:	39 07       	cpc	r19, r25
    2350:	4a 07       	cpc	r20, r26
    2352:	5b 07       	cpc	r21, r27
    2354:	99 f4       	brne	.+38     	; 0x237c <UpdateAdjustedSampleAddresses+0x6ce>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    2356:	80 91 fe 02 	lds	r24, 0x02FE
    235a:	90 91 ff 02 	lds	r25, 0x02FF
    235e:	a0 91 00 03 	lds	r26, 0x0300
    2362:	b0 91 01 03 	lds	r27, 0x0301
    2366:	01 96       	adiw	r24, 0x01	; 1
    2368:	a1 1d       	adc	r26, r1
    236a:	b1 1d       	adc	r27, r1
    236c:	80 93 fe 02 	sts	0x02FE, r24
    2370:	90 93 ff 02 	sts	0x02FF, r25
    2374:	a0 93 00 03 	sts	0x0300, r26
    2378:	b0 93 01 03 	sts	0x0301, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    237c:	20 91 02 03 	lds	r18, 0x0302
    2380:	30 91 03 03 	lds	r19, 0x0303
    2384:	40 91 04 03 	lds	r20, 0x0304
    2388:	50 91 05 03 	lds	r21, 0x0305
    238c:	80 91 fe 02 	lds	r24, 0x02FE
    2390:	90 91 ff 02 	lds	r25, 0x02FF
    2394:	a0 91 00 03 	lds	r26, 0x0300
    2398:	b0 91 01 03 	lds	r27, 0x0301
    239c:	28 17       	cp	r18, r24
    239e:	39 07       	cpc	r19, r25
    23a0:	4a 07       	cpc	r20, r26
    23a2:	5b 07       	cpc	r21, r27
    23a4:	08 f0       	brcs	.+2      	; 0x23a8 <UpdateAdjustedSampleAddresses+0x6fa>
    23a6:	5a c0       	rjmp	.+180    	; 0x245c <UpdateAdjustedSampleAddresses+0x7ae>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    23a8:	20 91 09 03 	lds	r18, 0x0309
    23ac:	30 91 0a 03 	lds	r19, 0x030A
    23b0:	40 91 0b 03 	lds	r20, 0x030B
    23b4:	50 91 0c 03 	lds	r21, 0x030C
    23b8:	80 91 02 03 	lds	r24, 0x0302
    23bc:	90 91 03 03 	lds	r25, 0x0303
    23c0:	a0 91 04 03 	lds	r26, 0x0304
    23c4:	b0 91 05 03 	lds	r27, 0x0305
    23c8:	82 17       	cp	r24, r18
    23ca:	93 07       	cpc	r25, r19
    23cc:	a4 07       	cpc	r26, r20
    23ce:	b5 07       	cpc	r27, r21
    23d0:	08 f0       	brcs	.+2      	; 0x23d4 <UpdateAdjustedSampleAddresses+0x726>
    23d2:	87 c0       	rjmp	.+270    	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
    23d4:	20 91 09 03 	lds	r18, 0x0309
    23d8:	30 91 0a 03 	lds	r19, 0x030A
    23dc:	40 91 0b 03 	lds	r20, 0x030B
    23e0:	50 91 0c 03 	lds	r21, 0x030C
    23e4:	80 91 fe 02 	lds	r24, 0x02FE
    23e8:	90 91 ff 02 	lds	r25, 0x02FF
    23ec:	a0 91 00 03 	lds	r26, 0x0300
    23f0:	b0 91 01 03 	lds	r27, 0x0301
    23f4:	28 17       	cp	r18, r24
    23f6:	39 07       	cpc	r19, r25
    23f8:	4a 07       	cpc	r20, r26
    23fa:	5b 07       	cpc	r21, r27
    23fc:	08 f0       	brcs	.+2      	; 0x2400 <UpdateAdjustedSampleAddresses+0x752>
    23fe:	71 c0       	rjmp	.+226    	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?	
    2400:	20 91 09 03 	lds	r18, 0x0309
    2404:	30 91 0a 03 	lds	r19, 0x030A
    2408:	40 91 0b 03 	lds	r20, 0x030B
    240c:	50 91 0c 03 	lds	r21, 0x030C
    2410:	a0 90 02 03 	lds	r10, 0x0302
    2414:	b0 90 03 03 	lds	r11, 0x0303
    2418:	c0 90 04 03 	lds	r12, 0x0304
    241c:	d0 90 05 03 	lds	r13, 0x0305
    2420:	80 91 fe 02 	lds	r24, 0x02FE
    2424:	90 91 ff 02 	lds	r25, 0x02FF
    2428:	a0 91 00 03 	lds	r26, 0x0300
    242c:	b0 91 01 03 	lds	r27, 0x0301
    2430:	e0 90 09 03 	lds	r14, 0x0309
    2434:	f0 90 0a 03 	lds	r15, 0x030A
    2438:	00 91 0b 03 	lds	r16, 0x030B
    243c:	10 91 0c 03 	lds	r17, 0x030C
    2440:	2a 19       	sub	r18, r10
    2442:	3b 09       	sbc	r19, r11
    2444:	4c 09       	sbc	r20, r12
    2446:	5d 09       	sbc	r21, r13
    2448:	8e 19       	sub	r24, r14
    244a:	9f 09       	sbc	r25, r15
    244c:	a0 0b       	sbc	r26, r16
    244e:	b1 0b       	sbc	r27, r17
    2450:	82 17       	cp	r24, r18
    2452:	93 07       	cpc	r25, r19
    2454:	a4 07       	cpc	r26, r20
    2456:	b5 07       	cpc	r27, r21
    2458:	a0 f1       	brcs	.+104    	; 0x24c2 <UpdateAdjustedSampleAddresses+0x814>
    245a:	15 c0       	rjmp	.+42     	; 0x2486 <UpdateAdjustedSampleAddresses+0x7d8>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    245c:	20 91 09 03 	lds	r18, 0x0309
    2460:	30 91 0a 03 	lds	r19, 0x030A
    2464:	40 91 0b 03 	lds	r20, 0x030B
    2468:	50 91 0c 03 	lds	r21, 0x030C
    246c:	80 91 02 03 	lds	r24, 0x0302
    2470:	90 91 03 03 	lds	r25, 0x0303
    2474:	a0 91 04 03 	lds	r26, 0x0304
    2478:	b0 91 05 03 	lds	r27, 0x0305
    247c:	82 17       	cp	r24, r18
    247e:	93 07       	cpc	r25, r19
    2480:	a4 07       	cpc	r26, r20
    2482:	b5 07       	cpc	r27, r21
    2484:	48 f4       	brcc	.+18     	; 0x2498 <UpdateAdjustedSampleAddresses+0x7ea>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    2486:	80 91 02 03 	lds	r24, 0x0302
    248a:	90 91 03 03 	lds	r25, 0x0303
    248e:	a0 91 04 03 	lds	r26, 0x0304
    2492:	b0 91 05 03 	lds	r27, 0x0305
    2496:	1d c0       	rjmp	.+58     	; 0x24d2 <UpdateAdjustedSampleAddresses+0x824>
			}				
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    2498:	20 91 09 03 	lds	r18, 0x0309
    249c:	30 91 0a 03 	lds	r19, 0x030A
    24a0:	40 91 0b 03 	lds	r20, 0x030B
    24a4:	50 91 0c 03 	lds	r21, 0x030C
    24a8:	80 91 fe 02 	lds	r24, 0x02FE
    24ac:	90 91 ff 02 	lds	r25, 0x02FF
    24b0:	a0 91 00 03 	lds	r26, 0x0300
    24b4:	b0 91 01 03 	lds	r27, 0x0301
    24b8:	28 17       	cp	r18, r24
    24ba:	39 07       	cpc	r19, r25
    24bc:	4a 07       	cpc	r20, r26
    24be:	5b 07       	cpc	r21, r27
    24c0:	80 f4       	brcc	.+32     	; 0x24e2 <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    24c2:	80 91 fe 02 	lds	r24, 0x02FE
    24c6:	90 91 ff 02 	lds	r25, 0x02FF
    24ca:	a0 91 00 03 	lds	r26, 0x0300
    24ce:	b0 91 01 03 	lds	r27, 0x0301
    24d2:	80 93 09 03 	sts	0x0309, r24
    24d6:	90 93 0a 03 	sts	0x030A, r25
    24da:	a0 93 0b 03 	sts	0x030B, r26
    24de:	b0 93 0c 03 	sts	0x030C, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    24e2:	e9 81       	ldd	r30, Y+1	; 0x01
    24e4:	ef bf       	out	0x3f, r30	; 63
}
    24e6:	0f 90       	pop	r0
    24e8:	cf 91       	pop	r28
    24ea:	df 91       	pop	r29
    24ec:	1f 91       	pop	r17
    24ee:	0f 91       	pop	r16
    24f0:	ff 90       	pop	r15
    24f2:	ef 90       	pop	r14
    24f4:	df 90       	pop	r13
    24f6:	cf 90       	pop	r12
    24f8:	bf 90       	pop	r11
    24fa:	af 90       	pop	r10
    24fc:	9f 90       	pop	r9
    24fe:	8f 90       	pop	r8
    2500:	7f 90       	pop	r7
    2502:	6f 90       	pop	r6
    2504:	5f 90       	pop	r5
    2506:	4f 90       	pop	r4
    2508:	3f 90       	pop	r3
    250a:	2f 90       	pop	r2
    250c:	08 95       	ret

0000250e <BlinkLeds>:

static void BlinkLeds(unsigned int theMask)
// Sets up the mask of leds to blink and their blink rate.
// NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from having 8 separate software clocks.
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
    250e:	a8 2f       	mov	r26, r24
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2510:	80 91 3c 01 	lds	r24, 0x013C
    2514:	68 2f       	mov	r22, r24
    2516:	70 e0       	ldi	r23, 0x00	; 0
    2518:	50 91 3b 01 	lds	r21, 0x013B
    251c:	20 e0       	ldi	r18, 0x00	; 0
    251e:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2520:	e1 e0       	ldi	r30, 0x01	; 1
    2522:	f0 e0       	ldi	r31, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2524:	cb 01       	movw	r24, r22
    2526:	02 2e       	mov	r0, r18
    2528:	02 c0       	rjmp	.+4      	; 0x252e <BlinkLeds+0x20>
    252a:	95 95       	asr	r25
    252c:	87 95       	ror	r24
    252e:	0a 94       	dec	r0
    2530:	e2 f7       	brpl	.-8      	; 0x252a <BlinkLeds+0x1c>
    2532:	80 ff       	sbrs	r24, 0
    2534:	09 c0       	rjmp	.+18     	; 0x2548 <BlinkLeds+0x3a>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2536:	cf 01       	movw	r24, r30
    2538:	02 2e       	mov	r0, r18
    253a:	02 c0       	rjmp	.+4      	; 0x2540 <BlinkLeds+0x32>
    253c:	88 0f       	add	r24, r24
    253e:	99 1f       	adc	r25, r25
    2540:	0a 94       	dec	r0
    2542:	e2 f7       	brpl	.-8      	; 0x253c <BlinkLeds+0x2e>
    2544:	80 95       	com	r24
    2546:	58 23       	and	r21, r24
    2548:	2f 5f       	subi	r18, 0xFF	; 255
    254a:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    254c:	28 30       	cpi	r18, 0x08	; 8
    254e:	31 05       	cpc	r19, r1
    2550:	49 f7       	brne	.-46     	; 0x2524 <BlinkLeds+0x16>
    2552:	50 93 3b 01 	sts	0x013B, r21
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    2556:	a0 93 3c 01 	sts	0x013C, r26
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    255a:	82 e0       	ldi	r24, 0x02	; 2
    255c:	68 e9       	ldi	r22, 0x98	; 152
    255e:	70 e0       	ldi	r23, 0x00	; 0
    2560:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
}
    2564:	08 95       	ret

00002566 <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2566:	10 92 3b 01 	sts	0x013B, r1
	BlinkLeds(0);		// Durrrr.....
    256a:	80 e0       	ldi	r24, 0x00	; 0
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
}
    2572:	08 95       	ret

00002574 <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    2574:	80 91 41 01 	lds	r24, 0x0141
    2578:	88 23       	and	r24, r24
    257a:	81 f4       	brne	.+32     	; 0x259c <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs 
    257c:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
												
		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    2580:	10 92 c9 02 	sts	0x02C9, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    2584:	10 92 d1 02 	sts	0x02D1, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    2588:	10 92 eb 02 	sts	0x02EB, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    258c:	10 92 f3 02 	sts	0x02F3, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    2590:	81 e8       	ldi	r24, 0x81	; 129
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
		subState=SS_1;		
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	13 c0       	rjmp	.+38     	; 0x25c2 <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    259c:	81 30       	cpi	r24, 0x01	; 1
    259e:	09 f5       	brne	.+66     	; 0x25e2 <DoFormatCard+0x6e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    25a0:	80 91 3e 01 	lds	r24, 0x013E
    25a4:	80 ff       	sbrs	r24, 0
    25a6:	10 c0       	rjmp	.+32     	; 0x25c8 <DoFormatCard+0x54>
    25a8:	87 ff       	sbrs	r24, 7
    25aa:	0e c0       	rjmp	.+28     	; 0x25c8 <DoFormatCard+0x54>
		{
			cardState=SD_WRITE_TOC;	// Start TOC write
    25ac:	85 e0       	ldi	r24, 0x05	; 5
    25ae:	80 93 59 02 	sts	0x0259, r24
			KillLeds();
    25b2:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs		
    25b6:	80 91 3b 01 	lds	r24, 0x013B
    25ba:	81 68       	ori	r24, 0x81	; 129
    25bc:	80 93 3b 01 	sts	0x013B, r24
			subState=SS_2;		
    25c0:	82 e0       	ldi	r24, 0x02	; 2
    25c2:	80 93 41 01 	sts	0x0141, r24
    25c6:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    25c8:	80 91 59 02 	lds	r24, 0x0259
    25cc:	88 23       	and	r24, r24
    25ce:	31 f5       	brne	.+76     	; 0x261c <DoFormatCard+0xa8>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    25d0:	87 e9       	ldi	r24, 0x97	; 151
    25d2:	93 e1       	ldi	r25, 0x13	; 19
    25d4:	90 93 c8 02 	sts	0x02C8, r25
    25d8:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    25dc:	10 92 41 01 	sts	0x0141, r1
    25e0:	08 95       	ret
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    25e2:	82 30       	cpi	r24, 0x02	; 2
    25e4:	d9 f4       	brne	.+54     	; 0x261c <DoFormatCard+0xa8>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    25e6:	80 91 59 02 	lds	r24, 0x0259
    25ea:	89 30       	cpi	r24, 0x09	; 9
    25ec:	b9 f4       	brne	.+46     	; 0x261c <DoFormatCard+0xa8>
		{
			KillLeds();
    25ee:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    25f2:	80 91 3b 01 	lds	r24, 0x013B
    25f6:	82 60       	ori	r24, 0x02	; 2
    25f8:	80 93 3b 01 	sts	0x013B, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    25fc:	80 91 59 02 	lds	r24, 0x0259
    2600:	88 23       	and	r24, r24
    2602:	21 f0       	breq	.+8      	; 0x260c <DoFormatCard+0x98>
    2604:	80 91 3f 01 	lds	r24, 0x013F
    2608:	88 23       	and	r24, r24
    260a:	41 f0       	breq	.+16     	; 0x261c <DoFormatCard+0xa8>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    260c:	87 e9       	ldi	r24, 0x97	; 151
    260e:	93 e1       	ldi	r25, 0x13	; 19
    2610:	90 93 c8 02 	sts	0x02C8, r25
    2614:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    2618:	10 92 41 01 	sts	0x0141, r1
    261c:	08 95       	ret

0000261e <DoSawtooth>:
// Also test to see if our flash is present and working.
{
	static unsigned char
		lastShuttleRead;

	if(subState==SS_0)
    261e:	80 91 41 01 	lds	r24, 0x0141
    2622:	88 23       	and	r24, r24
    2624:	41 f4       	brne	.+16     	; 0x2636 <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    2626:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    262a:	80 ec       	ldi	r24, 0xC0	; 192
    262c:	90 e0       	ldi	r25, 0x00	; 0
    262e:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
		subState=SS_1;
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	19 c0       	rjmp	.+50     	; 0x2668 <DoSawtooth+0x4a>
	}
	else if(subState==SS_1)
    2636:	81 30       	cpi	r24, 0x01	; 1
    2638:	d1 f4       	brne	.+52     	; 0x266e <DoSawtooth+0x50>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    263a:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    263c:	80 93 c9 02 	sts	0x02C9, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    2640:	80 93 d1 02 	sts	0x02D1, r24
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
    2644:	80 e0       	ldi	r24, 0x00	; 0
    2646:	61 e0       	ldi	r22, 0x01	; 1
    2648:	40 e0       	ldi	r20, 0x00	; 0
    264a:	50 e0       	ldi	r21, 0x00	; 0
    264c:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2650:	81 e5       	ldi	r24, 0x51	; 81
    2652:	98 e0       	ldi	r25, 0x08	; 8
    2654:	90 93 c6 02 	sts	0x02C6, r25
    2658:	80 93 c5 02 	sts	0x02C5, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.		
    265c:	78 94       	sei

		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the leds when it changes.
    265e:	80 91 44 01 	lds	r24, 0x0144
    2662:	80 93 2f 01 	sts	0x012F, r24

		subState=SS_2;					// And wait forever.
    2666:	82 e0       	ldi	r24, 0x02	; 2
    2668:	80 93 41 01 	sts	0x0141, r24
    266c:	08 95       	ret
	}
	else if(subState==SS_2)
    266e:	82 30       	cpi	r24, 0x02	; 2
    2670:	09 f0       	breq	.+2      	; 0x2674 <DoSawtooth+0x56>
    2672:	5c c0       	rjmp	.+184    	; 0x272c <DoSawtooth+0x10e>
	{

		if(newKeys&Im_SWITCH_0)
    2674:	80 91 3f 01 	lds	r24, 0x013F
    2678:	28 2f       	mov	r18, r24
    267a:	80 ff       	sbrs	r24, 0
    267c:	06 c0       	rjmp	.+12     	; 0x268a <DoSawtooth+0x6c>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    267e:	80 91 3b 01 	lds	r24, 0x013B
    2682:	91 e0       	ldi	r25, 0x01	; 1
    2684:	89 27       	eor	r24, r25
    2686:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_1)
    268a:	21 ff       	sbrs	r18, 1
    268c:	06 c0       	rjmp	.+12     	; 0x269a <DoSawtooth+0x7c>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    268e:	80 91 3b 01 	lds	r24, 0x013B
    2692:	92 e0       	ldi	r25, 0x02	; 2
    2694:	89 27       	eor	r24, r25
    2696:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_2)
    269a:	22 ff       	sbrs	r18, 2
    269c:	06 c0       	rjmp	.+12     	; 0x26aa <DoSawtooth+0x8c>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    269e:	80 91 3b 01 	lds	r24, 0x013B
    26a2:	94 e0       	ldi	r25, 0x04	; 4
    26a4:	89 27       	eor	r24, r25
    26a6:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_3)
    26aa:	23 ff       	sbrs	r18, 3
    26ac:	06 c0       	rjmp	.+12     	; 0x26ba <DoSawtooth+0x9c>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    26ae:	80 91 3b 01 	lds	r24, 0x013B
    26b2:	98 e0       	ldi	r25, 0x08	; 8
    26b4:	89 27       	eor	r24, r25
    26b6:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_4)
    26ba:	24 ff       	sbrs	r18, 4
    26bc:	06 c0       	rjmp	.+12     	; 0x26ca <DoSawtooth+0xac>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    26be:	80 91 3b 01 	lds	r24, 0x013B
    26c2:	90 e1       	ldi	r25, 0x10	; 16
    26c4:	89 27       	eor	r24, r25
    26c6:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_5)
    26ca:	25 ff       	sbrs	r18, 5
    26cc:	06 c0       	rjmp	.+12     	; 0x26da <DoSawtooth+0xbc>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    26ce:	80 91 3b 01 	lds	r24, 0x013B
    26d2:	90 e2       	ldi	r25, 0x20	; 32
    26d4:	89 27       	eor	r24, r25
    26d6:	80 93 3b 01 	sts	0x013B, r24
		}

		if(newKeys&Im_SWITCH_6)
    26da:	26 ff       	sbrs	r18, 6
    26dc:	0a c0       	rjmp	.+20     	; 0x26f2 <DoSawtooth+0xd4>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    26de:	80 e0       	ldi	r24, 0x00	; 0
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
		}

		if(newKeys&Im_SWITCH_6)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    26e6:	80 91 3b 01 	lds	r24, 0x013B
    26ea:	90 e4       	ldi	r25, 0x40	; 64
    26ec:	89 27       	eor	r24, r25
    26ee:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_7)
    26f2:	80 91 3f 01 	lds	r24, 0x013F
    26f6:	87 ff       	sbrs	r24, 7
    26f8:	09 c0       	rjmp	.+18     	; 0x270c <DoSawtooth+0xee>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    26fa:	80 e0       	ldi	r24, 0x00	; 0
    26fc:	90 e0       	ldi	r25, 0x00	; 0
    26fe:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    2702:	80 91 3b 01 	lds	r24, 0x013B
    2706:	80 58       	subi	r24, 0x80	; 128
    2708:	80 93 3b 01 	sts	0x013B, r24
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
    270c:	90 91 2f 01 	lds	r25, 0x012F
    2710:	80 91 44 01 	lds	r24, 0x0144
    2714:	98 17       	cp	r25, r24
    2716:	51 f0       	breq	.+20     	; 0x272c <DoSawtooth+0x10e>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    2718:	80 e0       	ldi	r24, 0x00	; 0
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    2720:	80 91 44 01 	lds	r24, 0x0144
    2724:	80 93 3b 01 	sts	0x013B, r24
			lastShuttleRead=encoderValue;
    2728:	80 93 2f 01 	sts	0x012F, r24
    272c:	08 95       	ret

0000272e <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    272e:	1f 93       	push	r17
	static unsigned char
		i;
		
	if(subState==SS_0)
    2730:	10 91 41 01 	lds	r17, 0x0141
    2734:	11 23       	and	r17, r17
    2736:	69 f4       	brne	.+26     	; 0x2752 <DoFruitcakeIntro+0x24>
	{
		KillLeds();
    2738:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
		i=0;
    273c:	10 92 26 01 	sts	0x0126, r1
		ledOnOffMask=0;
    2740:	10 92 3b 01 	sts	0x013B, r1
		subState=SS_1;
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	80 93 41 01 	sts	0x0141, r24
		SetTimer(TIMER_1,(SECOND/4));
    274a:	80 e0       	ldi	r24, 0x00	; 0
    274c:	61 e3       	ldi	r22, 0x31	; 49
    274e:	71 e0       	ldi	r23, 0x01	; 1
    2750:	6a c0       	rjmp	.+212    	; 0x2826 <DoFruitcakeIntro+0xf8>
	}
	else if(subState==SS_1)
    2752:	11 30       	cpi	r17, 0x01	; 1
    2754:	41 f4       	brne	.+16     	; 0x2766 <DoFruitcakeIntro+0x38>
	{
		if(CheckTimer(TIMER_1))
    2756:	80 e0       	ldi	r24, 0x00	; 0
    2758:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    275c:	88 23       	and	r24, r24
    275e:	09 f4       	brne	.+2      	; 0x2762 <DoFruitcakeIntro+0x34>
    2760:	91 c0       	rjmp	.+290    	; 0x2884 <DoFruitcakeIntro+0x156>
		{
			subState=SS_2;
    2762:	82 e0       	ldi	r24, 0x02	; 2
    2764:	7b c0       	rjmp	.+246    	; 0x285c <DoFruitcakeIntro+0x12e>
		}
	}

	else if(subState==SS_2)
    2766:	12 30       	cpi	r17, 0x02	; 2
    2768:	09 f0       	breq	.+2      	; 0x276c <DoFruitcakeIntro+0x3e>
    276a:	4a c0       	rjmp	.+148    	; 0x2800 <DoFruitcakeIntro+0xd2>
	{
		if(i<NUM_LEDS)
    276c:	80 91 26 01 	lds	r24, 0x0126
    2770:	88 30       	cpi	r24, 0x08	; 8
    2772:	f8 f4       	brcc	.+62     	; 0x27b2 <DoFruitcakeIntro+0x84>
		{
			if(CheckTimer(TIMER_1))
    2774:	80 e0       	ldi	r24, 0x00	; 0
    2776:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    277a:	88 23       	and	r24, r24
    277c:	09 f4       	brne	.+2      	; 0x2780 <DoFruitcakeIntro+0x52>
    277e:	82 c0       	rjmp	.+260    	; 0x2884 <DoFruitcakeIntro+0x156>
			{
				ledOnOffMask|=(1<<i);
    2780:	81 e0       	ldi	r24, 0x01	; 1
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	00 90 26 01 	lds	r0, 0x0126
    2788:	02 c0       	rjmp	.+4      	; 0x278e <DoFruitcakeIntro+0x60>
    278a:	88 0f       	add	r24, r24
    278c:	99 1f       	adc	r25, r25
    278e:	0a 94       	dec	r0
    2790:	e2 f7       	brpl	.-8      	; 0x278a <DoFruitcakeIntro+0x5c>
    2792:	20 91 3b 01 	lds	r18, 0x013B
    2796:	28 2b       	or	r18, r24
    2798:	20 93 3b 01 	sts	0x013B, r18
				SetTimer(TIMER_1,(SECOND/20));		
    279c:	80 e0       	ldi	r24, 0x00	; 0
    279e:	6d e3       	ldi	r22, 0x3D	; 61
    27a0:	70 e0       	ldi	r23, 0x00	; 0
    27a2:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
				i++;
    27a6:	80 91 26 01 	lds	r24, 0x0126
    27aa:	8f 5f       	subi	r24, 0xFF	; 255
    27ac:	80 93 26 01 	sts	0x0126, r24
    27b0:	69 c0       	rjmp	.+210    	; 0x2884 <DoFruitcakeIntro+0x156>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    27b2:	80 e0       	ldi	r24, 0x00	; 0
    27b4:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    27b8:	88 23       	and	r24, r24
    27ba:	09 f4       	brne	.+2      	; 0x27be <DoFruitcakeIntro+0x90>
    27bc:	63 c0       	rjmp	.+198    	; 0x2884 <DoFruitcakeIntro+0x156>
			{
				SetTimer(TIMER_1,(SECOND/8));
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	68 e9       	ldi	r22, 0x98	; 152
    27c2:	70 e0       	ldi	r23, 0x00	; 0
    27c4:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
				ledPwm=255;
    27c8:	9f ef       	ldi	r25, 0xFF	; 255
    27ca:	90 93 3d 01 	sts	0x013D, r25
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.	
    27ce:	80 91 64 00 	lds	r24, 0x0064
    27d2:	8f 7b       	andi	r24, 0xBF	; 191
    27d4:	80 93 64 00 	sts	0x0064, r24

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.	
    27d8:	10 93 b0 00 	sts	0x00B0, r17
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    27dc:	81 e0       	ldi	r24, 0x01	; 1
    27de:	80 93 b1 00 	sts	0x00B1, r24
				TCNT2=0;			// Init counter reg
    27e2:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    27e6:	80 e8       	ldi	r24, 0x80	; 128
    27e8:	80 93 b3 00 	sts	0x00B3, r24
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    27ec:	97 bb       	out	0x17, r25	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    27ee:	10 93 70 00 	sts	0x0070, r17

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    27f2:	82 b1       	in	r24, 0x02	; 2
    27f4:	86 60       	ori	r24, 0x06	; 6
    27f6:	82 b9       	out	0x02, r24	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    27f8:	94 b9       	out	0x04, r25	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    27fa:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;		
    27fc:	83 e0       	ldi	r24, 0x03	; 3
    27fe:	2e c0       	rjmp	.+92     	; 0x285c <DoFruitcakeIntro+0x12e>
			}
		}
	}
	else if(subState==SS_3)
    2800:	13 30       	cpi	r17, 0x03	; 3
    2802:	79 f5       	brne	.+94     	; 0x2862 <DoFruitcakeIntro+0x134>
	{		
		if(CheckTimer(TIMER_1))
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    280a:	88 23       	and	r24, r24
    280c:	d9 f1       	breq	.+118    	; 0x2884 <DoFruitcakeIntro+0x156>
		{
			if(ledPwm>1)
    280e:	80 91 3d 01 	lds	r24, 0x013D
    2812:	82 30       	cpi	r24, 0x02	; 2
    2814:	58 f0       	brcs	.+22     	; 0x282c <DoFruitcakeIntro+0xfe>
			{
				ledPwm-=2;
    2816:	80 91 3d 01 	lds	r24, 0x013D
    281a:	82 50       	subi	r24, 0x02	; 2
    281c:	80 93 3d 01 	sts	0x013D, r24
				SetTimer(TIMER_1,(SECOND/256));
    2820:	80 e0       	ldi	r24, 0x00	; 0
    2822:	64 e0       	ldi	r22, 0x04	; 4
    2824:	70 e0       	ldi	r23, 0x00	; 0
    2826:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
    282a:	2c c0       	rjmp	.+88     	; 0x2884 <DoFruitcakeIntro+0x156>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    282c:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports, begin setting CTC mode.	
    2830:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    2834:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.	
    2838:	80 91 64 00 	lds	r24, 0x0064
    283c:	80 64       	ori	r24, 0x40	; 64
    283e:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    2842:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    2844:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    2846:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    284a:	80 e1       	ldi	r24, 0x10	; 16
    284c:	80 93 3b 01 	sts	0x013B, r24
				SetTimer(TIMER_1,(SECOND/2));
    2850:	80 e0       	ldi	r24, 0x00	; 0
    2852:	62 e6       	ldi	r22, 0x62	; 98
    2854:	72 e0       	ldi	r23, 0x02	; 2
    2856:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
				subState=SS_4;
    285a:	84 e0       	ldi	r24, 0x04	; 4
    285c:	80 93 41 01 	sts	0x0141, r24
    2860:	11 c0       	rjmp	.+34     	; 0x2884 <DoFruitcakeIntro+0x156>
			}
		}
	}
	else if(subState==SS_4)
    2862:	14 30       	cpi	r17, 0x04	; 4
    2864:	79 f4       	brne	.+30     	; 0x2884 <DoFruitcakeIntro+0x156>
	{
		if(CheckTimer(TIMER_1))
    2866:	80 e0       	ldi	r24, 0x00	; 0
    2868:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    286c:	88 23       	and	r24, r24
    286e:	51 f0       	breq	.+20     	; 0x2884 <DoFruitcakeIntro+0x156>
		{
			KillLeds();
    2870:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2874:	84 e4       	ldi	r24, 0x44	; 68
    2876:	94 e1       	ldi	r25, 0x14	; 20
    2878:	90 93 c8 02 	sts	0x02C8, r25
    287c:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    2880:	10 92 41 01 	sts	0x0141, r1
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
	}
}
    2884:	1f 91       	pop	r17
    2886:	08 95       	ret

00002888 <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    2888:	80 91 41 01 	lds	r24, 0x0141
    288c:	88 23       	and	r24, r24
    288e:	41 f4       	brne	.+16     	; 0x28a0 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    2890:	68 e9       	ldi	r22, 0x98	; 152
    2892:	70 e0       	ldi	r23, 0x00	; 0
    2894:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
		subState=SS_1;
    2898:	81 e0       	ldi	r24, 0x01	; 1
    289a:	80 93 41 01 	sts	0x0141, r24
    289e:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    28a0:	80 e0       	ldi	r24, 0x00	; 0
    28a2:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    28a6:	88 23       	and	r24, r24
    28a8:	d1 f0       	breq	.+52     	; 0x28de <DoStartupSelect+0x56>
		{
			if(keyState&Im_SWITCH_0)
    28aa:	80 91 3e 01 	lds	r24, 0x013E
    28ae:	80 ff       	sbrs	r24, 0
    28b0:	03 c0       	rjmp	.+6      	; 0x28b8 <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    28b2:	8f e0       	ldi	r24, 0x0F	; 15
    28b4:	93 e1       	ldi	r25, 0x13	; 19
    28b6:	04 c0       	rjmp	.+8      	; 0x28c0 <DoStartupSelect+0x38>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    28b8:	85 ff       	sbrs	r24, 5
    28ba:	09 c0       	rjmp	.+18     	; 0x28ce <DoStartupSelect+0x46>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    28bc:	8d e7       	ldi	r24, 0x7D	; 125
    28be:	91 e2       	ldi	r25, 0x21	; 33
    28c0:	90 93 c8 02 	sts	0x02C8, r25
    28c4:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    28c8:	10 92 41 01 	sts	0x0141, r1
    28cc:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    28ce:	82 ea       	ldi	r24, 0xA2	; 162
    28d0:	97 e1       	ldi	r25, 0x17	; 23
    28d2:	90 93 c8 02 	sts	0x02C8, r25
    28d6:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    28da:	10 92 41 01 	sts	0x0141, r1
    28de:	08 95       	ret

000028e0 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    28e0:	2f 92       	push	r2
    28e2:	3f 92       	push	r3
    28e4:	4f 92       	push	r4
    28e6:	5f 92       	push	r5
    28e8:	6f 92       	push	r6
    28ea:	7f 92       	push	r7
    28ec:	8f 92       	push	r8
    28ee:	9f 92       	push	r9
    28f0:	af 92       	push	r10
    28f2:	bf 92       	push	r11
    28f4:	cf 92       	push	r12
    28f6:	df 92       	push	r13
    28f8:	ef 92       	push	r14
    28fa:	ff 92       	push	r15
    28fc:	0f 93       	push	r16
    28fe:	1f 93       	push	r17
    2900:	cf 93       	push	r28
    2902:	df 93       	push	r29
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    2904:	1f ef       	ldi	r17, 0xFF	; 255
    2906:	10 93 64 00 	sts	0x0064, r17
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    290a:	85 b7       	in	r24, 0x35	; 53
    290c:	8f 7e       	andi	r24, 0xEF	; 239
    290e:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    2910:	8f ee       	ldi	r24, 0xEF	; 239
    2912:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    2914:	88 e0       	ldi	r24, 0x08	; 8
    2916:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    2918:	90 e8       	ldi	r25, 0x80	; 128
    291a:	9a b9       	out	0x0a, r25	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    291c:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    291e:	86 e0       	ldi	r24, 0x06	; 6
    2920:	82 b9       	out	0x02, r24	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    2922:	8e e3       	ldi	r24, 0x3E	; 62
    2924:	81 b9       	out	0x01, r24	; 1

	DDRB=0xFF;			// Latch port to OP.
    2926:	14 b9       	out	0x04, r17	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    2928:	95 b9       	out	0x05, r25	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    292a:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    292c:	14 b9       	out	0x04, r17	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    292e:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    2930:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    2932:	0e 94 75 24 	call	0x48ea	; 0x48ea <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    2936:	81 e0       	ldi	r24, 0x01	; 1
    2938:	66 e2       	ldi	r22, 0x26	; 38
    293a:	70 e0       	ldi	r23, 0x00	; 0
    293c:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    2940:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    2942:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    2944:	80 b1       	in	r24, 0x00	; 0
    2946:	80 7c       	andi	r24, 0xC0	; 192
    2948:	80 93 43 01 	sts	0x0143, r24
	encoderValue=0;							// zero our relative position.
    294c:	10 92 44 01 	sts	0x0144, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    2950:	10 92 3b 01 	sts	0x013B, r1
	ledBlinkMask=0;
    2954:	10 92 3c 01 	sts	0x013C, r1
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2958:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    295a:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    295c:	15 b8       	out	0x05, r1	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    295e:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    2960:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    2962:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2964:	8f bf       	out	0x3f, r24	; 63

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    2966:	0e 94 c7 22 	call	0x458e	; 0x458e <InitMidi>
	InitUart0();
    296a:	0e 94 fc 21 	call	0x43f8	; 0x43f8 <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    296e:	80 91 64 00 	lds	r24, 0x0064
    2972:	8e 7f       	andi	r24, 0xFE	; 254
    2974:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    2978:	80 e6       	ldi	r24, 0x60	; 96
    297a:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    2984:	85 e9       	ldi	r24, 0x95	; 149
    2986:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    298a:	80 91 7a 00 	lds	r24, 0x007A
    298e:	80 64       	ori	r24, 0x40	; 64
    2990:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    2994:	80 91 64 00 	lds	r24, 0x0064
    2998:	8f 7d       	andi	r24, 0xDF	; 223
    299a:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    299e:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    29a2:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    29a4:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    29a6:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    29a8:	10 92 0e 03 	sts	0x030E, r1
    29ac:	10 92 0d 03 	sts	0x030D, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    29b0:	83 e0       	ldi	r24, 0x03	; 3
    29b2:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    29b4:	80 91 64 00 	lds	r24, 0x0064
    29b8:	87 7f       	andi	r24, 0xF7	; 247
    29ba:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    29be:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    29c2:	8f ef       	ldi	r24, 0xFF	; 255
    29c4:	9f ef       	ldi	r25, 0xFF	; 255
    29c6:	90 93 89 00 	sts	0x0089, r25
    29ca:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    29ce:	90 93 8b 00 	sts	0x008B, r25
    29d2:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    29d6:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    29da:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    29de:	10 92 85 00 	sts	0x0085, r1
    29e2:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    29e6:	16 bb       	out	0x16, r17	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    29e8:	10 92 3f 01 	sts	0x013F, r1
	keyState=0;
    29ec:	10 92 3e 01 	sts	0x013E, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    29f0:	10 92 59 02 	sts	0x0259, r1
	cardDetect=false;
    29f4:	10 92 40 01 	sts	0x0140, r1
	sdWritingFrom0=false;			// No weird ISR stuff
    29f8:	10 92 9a 02 	sts	0x029A, r1
	sdWritingFrom1=false;
    29fc:	10 92 9b 02 	sts	0x029B, r1
	sdReadingInto0=false;	
    2a00:	10 92 9c 02 	sts	0x029C, r1
	sdReadingInto1=false;	
    2a04:	10 92 9d 02 	sts	0x029D, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    2a08:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2a0a:	87 e9       	ldi	r24, 0x97	; 151
    2a0c:	93 e1       	ldi	r25, 0x13	; 19
    2a0e:	90 93 c8 02 	sts	0x02C8, r25
    2a12:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    2a16:	10 92 41 01 	sts	0x0141, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    2a1a:	ff 24       	eor	r15, r15
    2a1c:	fa 94       	dec	r15
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    2a1e:	f1 e0       	ldi	r31, 0x01	; 1
    2a20:	8f 2e       	mov	r8, r31
    2a22:	91 2c       	mov	r9, r1
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    2a24:	ea e0       	ldi	r30, 0x0A	; 10
    2a26:	ee 2e       	mov	r14, r30
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2a28:	7a eb       	ldi	r23, 0xBA	; 186
    2a2a:	67 2e       	mov	r6, r23
    2a2c:	72 e1       	ldi	r23, 0x12	; 18
    2a2e:	77 2e       	mov	r7, r23
			{
				if(SdHandshake()==true)	// Give it a shot...
				{
					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct filesystem, and if so, get the TOC as well.
					{
						cardState=SD_IDLE;				// Card is legit and ready to go.
    2a30:	69 e0       	ldi	r22, 0x09	; 9
    2a32:	36 2e       	mov	r3, r22
			break;
*/
			case SD_WRITE_TOC:							// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    2a34:	41 2c       	mov	r4, r1
    2a36:	52 e0       	ldi	r21, 0x02	; 2
    2a38:	55 2e       	mov	r5, r21
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
				cardReadyForTransfer=true;					// OK to keep writing
				cardState=SD_WAIT_FOR_TOC_WRITE_TO_FINISH;
    2a3a:	46 e0       	ldi	r20, 0x06	; 6
    2a3c:	24 2e       	mov	r2, r20
static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    2a3e:	35 eb       	ldi	r19, 0xB5	; 181
    2a40:	a3 2e       	mov	r10, r19
    2a42:	35 e9       	ldi	r19, 0x95	; 149
    2a44:	b3 2e       	mov	r11, r19
    2a46:	3a ea       	ldi	r19, 0xAA	; 170
    2a48:	c3 2e       	mov	r12, r19
    2a4a:	30 e2       	ldi	r19, 0x20	; 32
    2a4c:	d3 2e       	mov	r13, r19
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    2a54:	88 23       	and	r24, r24
    2a56:	d9 f0       	breq	.+54     	; 0x2a8e <main+0x1ae>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    2a58:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    2a5a:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    2a5c:	f5 b8       	out	0x05, r15	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    2a5e:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    2a60:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    2a62:	00 00       	nop
		asm volatile("nop"::);
    2a64:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    2a66:	83 b1       	in	r24, 0x03	; 3
    2a68:	80 95       	com	r24
    2a6a:	80 93 3e 01 	sts	0x013E, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    2a6e:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    2a70:	f4 b8       	out	0x04, r15	; 4
		SREG=sreg;					// Stop tying up interrupts		
    2a72:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    2a74:	35 99       	sbic	0x06, 5	; 6
    2a76:	04 c0       	rjmp	.+8      	; 0x2a80 <main+0x1a0>
		{
			cardDetect=true;
    2a78:	81 e0       	ldi	r24, 0x01	; 1
    2a7a:	80 93 40 01 	sts	0x0140, r24
    2a7e:	02 c0       	rjmp	.+4      	; 0x2a84 <main+0x1a4>
		}
		else
		{
			cardDetect=false;
    2a80:	10 92 40 01 	sts	0x0140, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)		
    2a84:	81 e0       	ldi	r24, 0x01	; 1
    2a86:	66 e2       	ldi	r22, 0x26	; 38
    2a88:	70 e0       	ldi	r23, 0x00	; 0
    2a8a:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    2a8e:	90 91 3e 01 	lds	r25, 0x013E
    2a92:	80 91 1e 01 	lds	r24, 0x011E
    2a96:	80 95       	com	r24
    2a98:	89 23       	and	r24, r25
    2a9a:	80 93 3f 01 	sts	0x013F, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    2a9e:	90 93 1e 01 	sts	0x011E, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;
		
	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    2aa2:	20 91 0d 03 	lds	r18, 0x030D
    2aa6:	30 91 0e 03 	lds	r19, 0x030E
    2aaa:	80 91 1f 01 	lds	r24, 0x011F
    2aae:	90 91 20 01 	lds	r25, 0x0120
    2ab2:	28 17       	cp	r18, r24
    2ab4:	39 07       	cpc	r19, r25
    2ab6:	b1 f1       	breq	.+108    	; 0x2b24 <main+0x244>
	{
		lastEncTime=systemTicks;					// update last read time.
    2ab8:	80 91 0d 03 	lds	r24, 0x030D
    2abc:	90 91 0e 03 	lds	r25, 0x030E
    2ac0:	90 93 20 01 	sts	0x0120, r25
    2ac4:	80 93 1f 01 	sts	0x011F, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    2ac8:	90 b1       	in	r25, 0x00	; 0
    2aca:	90 7c       	andi	r25, 0xC0	; 192
    2acc:	90 93 43 01 	sts	0x0143, r25

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    2ad0:	80 91 21 01 	lds	r24, 0x0121
    2ad4:	98 17       	cp	r25, r24
    2ad6:	31 f1       	breq	.+76     	; 0x2b24 <main+0x244>
		{
			if(encoderState==ENC_POS_A)
    2ad8:	99 23       	and	r25, r25
    2ada:	29 f4       	brne	.+10     	; 0x2ae6 <main+0x206>
			{
				if(lastEncoderState==ENC_POS_D)
    2adc:	80 38       	cpi	r24, 0x80	; 128
    2ade:	a9 f0       	breq	.+42     	; 0x2b0a <main+0x22a>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_B)
    2ae0:	80 34       	cpi	r24, 0x40	; 64
    2ae2:	f1 f4       	brne	.+60     	; 0x2b20 <main+0x240>
    2ae4:	18 c0       	rjmp	.+48     	; 0x2b16 <main+0x236>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_B)
    2ae6:	90 34       	cpi	r25, 0x40	; 64
    2ae8:	29 f4       	brne	.+10     	; 0x2af4 <main+0x214>
			{
				if(lastEncoderState==ENC_POS_A)
    2aea:	88 23       	and	r24, r24
    2aec:	71 f0       	breq	.+28     	; 0x2b0a <main+0x22a>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_C)
    2aee:	80 3c       	cpi	r24, 0xC0	; 192
    2af0:	b9 f4       	brne	.+46     	; 0x2b20 <main+0x240>
    2af2:	11 c0       	rjmp	.+34     	; 0x2b16 <main+0x236>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_C)
    2af4:	90 3c       	cpi	r25, 0xC0	; 192
    2af6:	29 f4       	brne	.+10     	; 0x2b02 <main+0x222>
			{
				if(lastEncoderState==ENC_POS_B)
    2af8:	80 34       	cpi	r24, 0x40	; 64
    2afa:	39 f0       	breq	.+14     	; 0x2b0a <main+0x22a>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_D)
    2afc:	80 38       	cpi	r24, 0x80	; 128
    2afe:	81 f4       	brne	.+32     	; 0x2b20 <main+0x240>
    2b00:	0a c0       	rjmp	.+20     	; 0x2b16 <main+0x236>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_D)
    2b02:	90 38       	cpi	r25, 0x80	; 128
    2b04:	69 f4       	brne	.+26     	; 0x2b20 <main+0x240>
			{
				if(lastEncoderState==ENC_POS_C)
    2b06:	80 3c       	cpi	r24, 0xC0	; 192
    2b08:	21 f4       	brne	.+8      	; 0x2b12 <main+0x232>
				{
//					encoderValue++;
					encoderValue--;
    2b0a:	80 91 44 01 	lds	r24, 0x0144
    2b0e:	81 50       	subi	r24, 0x01	; 1
    2b10:	05 c0       	rjmp	.+10     	; 0x2b1c <main+0x23c>
				}
				else if(lastEncoderState==ENC_POS_A)
    2b12:	88 23       	and	r24, r24
    2b14:	29 f4       	brne	.+10     	; 0x2b20 <main+0x240>
				{
//					encoderValue--;
					encoderValue++;
    2b16:	80 91 44 01 	lds	r24, 0x0144
    2b1a:	8f 5f       	subi	r24, 0xFF	; 255
    2b1c:	80 93 44 01 	sts	0x0144, r24
				}
			}		

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    2b20:	90 93 21 01 	sts	0x0121, r25

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    2b24:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    2b28:	80 91 3c 01 	lds	r24, 0x013C
    2b2c:	88 23       	and	r24, r24
    2b2e:	09 f4       	brne	.+2      	; 0x2b32 <main+0x252>
    2b30:	4a c0       	rjmp	.+148    	; 0x2bc6 <main+0x2e6>
    2b32:	82 e0       	ldi	r24, 0x02	; 2
    2b34:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    2b38:	88 23       	and	r24, r24
    2b3a:	09 f4       	brne	.+2      	; 0x2b3e <main+0x25e>
    2b3c:	44 c0       	rjmp	.+136    	; 0x2bc6 <main+0x2e6>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    2b3e:	80 91 3c 01 	lds	r24, 0x013C
    2b42:	68 2f       	mov	r22, r24
    2b44:	70 e0       	ldi	r23, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    2b46:	e0 91 23 01 	lds	r30, 0x0123
    2b4a:	50 91 3b 01 	lds	r21, 0x013B
    2b4e:	20 e0       	ldi	r18, 0x00	; 0
    2b50:	30 e0       	ldi	r19, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    2b52:	cb 01       	movw	r24, r22
    2b54:	02 2e       	mov	r0, r18
    2b56:	02 c0       	rjmp	.+4      	; 0x2b5c <main+0x27c>
    2b58:	95 95       	asr	r25
    2b5a:	87 95       	ror	r24
    2b5c:	0a 94       	dec	r0
    2b5e:	e2 f7       	brpl	.-8      	; 0x2b58 <main+0x278>
    2b60:	80 ff       	sbrs	r24, 0
    2b62:	14 c0       	rjmp	.+40     	; 0x2b8c <main+0x2ac>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    2b64:	ee 23       	and	r30, r30
    2b66:	49 f0       	breq	.+18     	; 0x2b7a <main+0x29a>
				{
					ledOnOffMask|=(1<<i);
    2b68:	c4 01       	movw	r24, r8
    2b6a:	02 2e       	mov	r0, r18
    2b6c:	02 c0       	rjmp	.+4      	; 0x2b72 <main+0x292>
    2b6e:	88 0f       	add	r24, r24
    2b70:	99 1f       	adc	r25, r25
    2b72:	0a 94       	dec	r0
    2b74:	e2 f7       	brpl	.-8      	; 0x2b6e <main+0x28e>
    2b76:	58 2b       	or	r21, r24
    2b78:	09 c0       	rjmp	.+18     	; 0x2b8c <main+0x2ac>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    2b7a:	c4 01       	movw	r24, r8
    2b7c:	02 2e       	mov	r0, r18
    2b7e:	02 c0       	rjmp	.+4      	; 0x2b84 <main+0x2a4>
    2b80:	88 0f       	add	r24, r24
    2b82:	99 1f       	adc	r25, r25
    2b84:	0a 94       	dec	r0
    2b86:	e2 f7       	brpl	.-8      	; 0x2b80 <main+0x2a0>
    2b88:	80 95       	com	r24
    2b8a:	58 23       	and	r21, r24
    2b8c:	2f 5f       	subi	r18, 0xFF	; 255
    2b8e:	3f 4f       	sbci	r19, 0xFF	; 255
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    2b90:	28 30       	cpi	r18, 0x08	; 8
    2b92:	31 05       	cpc	r19, r1
    2b94:	f1 f6       	brne	.-68     	; 0x2b52 <main+0x272>
    2b96:	50 93 3b 01 	sts	0x013B, r21
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    2b9a:	10 92 23 01 	sts	0x0123, r1
    2b9e:	ee 23       	and	r30, r30
    2ba0:	19 f4       	brne	.+6      	; 0x2ba8 <main+0x2c8>
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	80 93 23 01 	sts	0x0123, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    2ba8:	82 e0       	ldi	r24, 0x02	; 2
    2baa:	68 e9       	ldi	r22, 0x98	; 152
    2bac:	70 e0       	ldi	r23, 0x00	; 0
    2bae:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    2bb2:	80 91 3b 01 	lds	r24, 0x013B
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2bb6:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2bb8:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    2bba:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2bbc:	f4 b8       	out	0x04, r15	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    2bbe:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    2bc0:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2bc2:	9f bf       	out	0x3f, r25	; 63
    2bc4:	11 c0       	rjmp	.+34     	; 0x2be8 <main+0x308>

		toggle=(!toggle);						// flip the sign of the led for next time.
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    2bc6:	90 91 3b 01 	lds	r25, 0x013B
    2bca:	80 91 22 01 	lds	r24, 0x0122
    2bce:	89 17       	cp	r24, r25
    2bd0:	59 f0       	breq	.+22     	; 0x2be8 <main+0x308>
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2bd2:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2bd4:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    2bd6:	95 b9       	out	0x05, r25	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2bd8:	f4 b8       	out	0x04, r15	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    2bda:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    2bdc:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2bde:	8f bf       	out	0x3f, r24	; 63
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    2be0:	80 91 3b 01 	lds	r24, 0x013B
    2be4:	80 93 22 01 	sts	0x0122, r24
	static unsigned int
		bytesLeftInBlock;
	static unsigned long
		bytesLeftInSample;

	if(cardDetect==false)		// No card in the slot?
    2be8:	80 91 40 01 	lds	r24, 0x0140
    2bec:	90 91 59 02 	lds	r25, 0x0259
    2bf0:	88 23       	and	r24, r24
    2bf2:	21 f4       	brne	.+8      	; 0x2bfc <main+0x31c>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    2bf4:	99 23       	and	r25, r25
    2bf6:	09 f4       	brne	.+2      	; 0x2bfa <main+0x31a>
    2bf8:	55 c1       	rjmp	.+682    	; 0x2ea4 <main+0x5c4>
    2bfa:	52 c1       	rjmp	.+676    	; 0x2ea0 <main+0x5c0>
			cardState=SD_NOT_PRESENT;		// Mark the card as st elsewhere
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    2bfc:	91 30       	cpi	r25, 0x01	; 1
    2bfe:	91 f0       	breq	.+36     	; 0x2c24 <main+0x344>
    2c00:	91 30       	cpi	r25, 0x01	; 1
    2c02:	38 f0       	brcs	.+14     	; 0x2c12 <main+0x332>
    2c04:	95 30       	cpi	r25, 0x05	; 5
    2c06:	09 f4       	brne	.+2      	; 0x2c0a <main+0x32a>
    2c08:	99 c0       	rjmp	.+306    	; 0x2d3c <main+0x45c>
    2c0a:	96 30       	cpi	r25, 0x06	; 6
    2c0c:	09 f0       	breq	.+2      	; 0x2c10 <main+0x330>
    2c0e:	4a c1       	rjmp	.+660    	; 0x2ea4 <main+0x5c4>
    2c10:	e9 c0       	rjmp	.+466    	; 0x2de4 <main+0x504>
		{
			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    2c12:	81 e0       	ldi	r24, 0x01	; 1
    2c14:	80 93 59 02 	sts	0x0259, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    2c18:	83 e0       	ldi	r24, 0x03	; 3
    2c1a:	64 ec       	ldi	r22, 0xC4	; 196
    2c1c:	74 e0       	ldi	r23, 0x04	; 4
    2c1e:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
    2c22:	40 c1       	rjmp	.+640    	; 0x2ea4 <main+0x5c4>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    2c24:	83 e0       	ldi	r24, 0x03	; 3
    2c26:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    2c2a:	88 23       	and	r24, r24
    2c2c:	09 f4       	brne	.+2      	; 0x2c30 <main+0x350>
    2c2e:	3a c1       	rjmp	.+628    	; 0x2ea4 <main+0x5c4>
			{
				if(SdHandshake()==true)	// Give it a shot...
    2c30:	0e 94 ef 25 	call	0x4bde	; 0x4bde <SdHandshake>
    2c34:	81 30       	cpi	r24, 0x01	; 1
    2c36:	09 f0       	breq	.+2      	; 0x2c3a <main+0x35a>
    2c38:	7e c0       	rjmp	.+252    	; 0x2d36 <main+0x456>
	// Are the first 4 chars WTPA?
	// Stop reading, return true or false based on answer.
	
	filesystemGood=true;					// Start assuming a good filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    2c3a:	60 e0       	ldi	r22, 0x00	; 0
    2c3c:	70 e0       	ldi	r23, 0x00	; 0
    2c3e:	80 e0       	ldi	r24, 0x00	; 0
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	0e 94 cb 25 	call	0x4b96	; 0x4b96 <SdBeginSingleBlockRead>
    2c46:	81 30       	cpi	r24, 0x01	; 1
    2c48:	11 f0       	breq	.+4      	; 0x2c4e <main+0x36e>
    2c4a:	10 e0       	ldi	r17, 0x00	; 0
    2c4c:	56 c0       	rjmp	.+172    	; 0x2cfa <main+0x41a>
 		// Tue Jun 21 17:11:28 EDT 2011 
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --  
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    2c4e:	83 e0       	ldi	r24, 0x03	; 3
    2c50:	6a e7       	ldi	r22, 0x7A	; 122
    2c52:	70 e0       	ldi	r23, 0x00	; 0
    2c54:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
    2c58:	02 c0       	rjmp	.+4      	; 0x2c5e <main+0x37e>
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    2c5a:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <HandleSoftclock>
		// So --  
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    2c5e:	83 e0       	ldi	r24, 0x03	; 3
    2c60:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    2c64:	88 23       	and	r24, r24
    2c66:	29 f4       	brne	.+10     	; 0x2c72 <main+0x392>
    2c68:	8f ef       	ldi	r24, 0xFF	; 255
    2c6a:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
    2c6e:	8e 3f       	cpi	r24, 0xFE	; 254
    2c70:	a1 f7       	brne	.-24     	; 0x2c5a <main+0x37a>
		{
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
    2c72:	8f ef       	ldi	r24, 0xFF	; 255
    2c74:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
    2c78:	08 2f       	mov	r16, r24
		if(theByte!='W')
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    2c7a:	8f ef       	ldi	r24, 0xFF	; 255
    2c7c:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
		if(theByte!='T')
    2c80:	84 35       	cpi	r24, 0x54	; 84
    2c82:	11 f0       	breq	.+4      	; 0x2c88 <main+0x3a8>
    2c84:	10 e0       	ldi	r17, 0x00	; 0
    2c86:	04 c0       	rjmp	.+8      	; 0x2c90 <main+0x3b0>
    2c88:	10 e0       	ldi	r17, 0x00	; 0
    2c8a:	07 35       	cpi	r16, 0x57	; 87
    2c8c:	09 f4       	brne	.+2      	; 0x2c90 <main+0x3b0>
    2c8e:	11 e0       	ldi	r17, 0x01	; 1
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    2c90:	8f ef       	ldi	r24, 0xFF	; 255
    2c92:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
		if(theByte!='P')
    2c96:	80 35       	cpi	r24, 0x50	; 80
    2c98:	09 f0       	breq	.+2      	; 0x2c9c <main+0x3bc>
    2c9a:	10 e0       	ldi	r17, 0x00	; 0
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    2c9c:	8f ef       	ldi	r24, 0xFF	; 255
    2c9e:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
		if(theByte!='A')
    2ca2:	81 34       	cpi	r24, 0x41	; 65
    2ca4:	09 f0       	breq	.+2      	; 0x2ca8 <main+0x3c8>
    2ca6:	10 e0       	ldi	r17, 0x00	; 0
    2ca8:	c0 e0       	ldi	r28, 0x00	; 0
    2caa:	d0 e0       	ldi	r29, 0x00	; 0
			filesystemGood=false;
		}

		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
    2cac:	8f ef       	ldi	r24, 0xFF	; 255
    2cae:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
		if(theByte!='A')
		{
			filesystemGood=false;
		}

		for(i=0;i<12;i++)					// 12 don't care bytes
    2cb2:	21 96       	adiw	r28, 0x01	; 1
    2cb4:	cc 30       	cpi	r28, 0x0C	; 12
    2cb6:	d1 05       	cpc	r29, r1
    2cb8:	c9 f7       	brne	.-14     	; 0x2cac <main+0x3cc>
		{
			TransferSdByte(0xFF);
		}
		
		if(filesystemGood==true)			// Load TOC if this is a legit card
    2cba:	11 30       	cpi	r17, 0x01	; 1
    2cbc:	59 f4       	brne	.+22     	; 0x2cd4 <main+0x3f4>
    2cbe:	ca e5       	ldi	r28, 0x5A	; 90
    2cc0:	d2 e0       	ldi	r29, 0x02	; 2
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    2cc2:	8f ef       	ldi	r24, 0xFF	; 255
    2cc4:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
    2cc8:	89 93       	st	Y+, r24
			TransferSdByte(0xFF);
		}
		
		if(filesystemGood==true)			// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    2cca:	82 e0       	ldi	r24, 0x02	; 2
    2ccc:	ca 39       	cpi	r28, 0x9A	; 154
    2cce:	d8 07       	cpc	r29, r24
    2cd0:	c1 f7       	brne	.-16     	; 0x2cc2 <main+0x3e2>
    2cd2:	09 c0       	rjmp	.+18     	; 0x2ce6 <main+0x406>
    2cd4:	c0 e0       	ldi	r28, 0x00	; 0
    2cd6:	d0 e0       	ldi	r29, 0x00	; 0
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    2cd8:	8f ef       	ldi	r24, 0xFF	; 255
    2cda:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}		
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    2cde:	21 96       	adiw	r28, 0x01	; 1
    2ce0:	c0 34       	cpi	r28, 0x40	; 64
    2ce2:	d1 05       	cpc	r29, r1
    2ce4:	c9 f7       	brne	.-14     	; 0x2cd8 <main+0x3f8>
    2ce6:	c0 e0       	ldi	r28, 0x00	; 0
    2ce8:	d0 e0       	ldi	r29, 0x00	; 0
			}		
		
		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    2cea:	8f ef       	ldi	r24, 0xFF	; 255
    2cec:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
			{
				TransferSdByte(0xFF);
			}		
		
		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    2cf0:	21 96       	adiw	r28, 0x01	; 1
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	c2 3b       	cpi	r28, 0xB2	; 178
    2cf6:	d8 07       	cpc	r29, r24
    2cf8:	c1 f7       	brne	.-16     	; 0x2cea <main+0x40a>
	}	
	else
	{
		filesystemGood=false;	// Error issuing read command
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    2cfa:	80 91 c8 00 	lds	r24, 0x00C8
    2cfe:	86 ff       	sbrs	r24, 6
    2d00:	fc cf       	rjmp	.-8      	; 0x2cfa <main+0x41a>
		;

	EndSdTransfer();				// Bring CS high
    2d02:	0e 94 8c 24 	call	0x4918	; 0x4918 <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    2d06:	8f ef       	ldi	r24, 0xFF	; 255
    2d08:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
			{
				if(SdHandshake()==true)	// Give it a shot...
				{
					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct filesystem, and if so, get the TOC as well.
    2d0c:	11 30       	cpi	r17, 0x01	; 1
    2d0e:	19 f4       	brne	.+6      	; 0x2d16 <main+0x436>
					{
						cardState=SD_IDLE;				// Card is legit and ready to go.
    2d10:	30 92 59 02 	sts	0x0259, r3
    2d14:	c7 c0       	rjmp	.+398    	; 0x2ea4 <main+0x5c4>
					}
					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    2d16:	e0 92 59 02 	sts	0x0259, r14
    2d1a:	ea e5       	ldi	r30, 0x5A	; 90
    2d1c:	f2 e0       	ldi	r31, 0x02	; 2
	unsigned char
		i;
	
	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"	
    2d1e:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;
	
	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    2d20:	82 e0       	ldi	r24, 0x02	; 2
    2d22:	ea 39       	cpi	r30, 0x9A	; 154
    2d24:	f8 07       	cpc	r31, r24
    2d26:	d9 f7       	brne	.-10     	; 0x2d1e <main+0x43e>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2d28:	70 92 c8 02 	sts	0x02C8, r7
    2d2c:	60 92 c7 02 	sts	0x02C7, r6
	subState=SS_0;
    2d30:	10 92 41 01 	sts	0x0141, r1
    2d34:	b7 c0       	rjmp	.+366    	; 0x2ea4 <main+0x5c4>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    2d36:	e0 92 59 02 	sts	0x0259, r14
    2d3a:	b4 c0       	rjmp	.+360    	; 0x2ea4 <main+0x5c4>
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;
*/
			case SD_WRITE_TOC:							// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    2d3c:	60 e0       	ldi	r22, 0x00	; 0
    2d3e:	70 e0       	ldi	r23, 0x00	; 0
    2d40:	80 e0       	ldi	r24, 0x00	; 0
    2d42:	90 e0       	ldi	r25, 0x00	; 0
    2d44:	0e 94 dd 25 	call	0x4bba	; 0x4bba <SdBeginSingleBlockWrite>
    2d48:	81 30       	cpi	r24, 0x01	; 1
    2d4a:	09 f0       	breq	.+2      	; 0x2d4e <main+0x46e>
    2d4c:	a9 c0       	rjmp	.+338    	; 0x2ea0 <main+0x5c0>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    2d4e:	50 92 25 01 	sts	0x0125, r5
    2d52:	40 92 24 01 	sts	0x0124, r4

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    2d56:	8f ef       	ldi	r24, 0xFF	; 255
    2d58:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    2d5c:	8f ef       	ldi	r24, 0xFF	; 255
    2d5e:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    2d62:	8e ef       	ldi	r24, 0xFE	; 254
    2d64:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte('W');				// Send flag that this is a WTPA card
    2d68:	87 e5       	ldi	r24, 0x57	; 87
    2d6a:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte('T');
    2d6e:	84 e5       	ldi	r24, 0x54	; 84
    2d70:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte('P');
    2d74:	80 e5       	ldi	r24, 0x50	; 80
    2d76:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte('A');
    2d7a:	81 e4       	ldi	r24, 0x41	; 65
    2d7c:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				
				bytesLeftInBlock-=4;
    2d80:	80 91 24 01 	lds	r24, 0x0124
    2d84:	90 91 25 01 	lds	r25, 0x0125
    2d88:	04 97       	sbiw	r24, 0x04	; 4
    2d8a:	90 93 25 01 	sts	0x0125, r25
    2d8e:	80 93 24 01 	sts	0x0124, r24
    2d92:	10 e0       	ldi	r17, 0x00	; 0

				for(i=0;i<12;i++)					// 12 don't care bytes
				{
					TransferSdByte('x');
    2d94:	88 e7       	ldi	r24, 0x78	; 120
    2d96:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
				TransferSdByte('P');
				TransferSdByte('A');
				
				bytesLeftInBlock-=4;

				for(i=0;i<12;i++)					// 12 don't care bytes
    2d9a:	1f 5f       	subi	r17, 0xFF	; 255
    2d9c:	1c 30       	cpi	r17, 0x0C	; 12
    2d9e:	d1 f7       	brne	.-12     	; 0x2d94 <main+0x4b4>
				{
					TransferSdByte('x');
				}
				
				bytesLeftInBlock-=12;
    2da0:	80 91 24 01 	lds	r24, 0x0124
    2da4:	90 91 25 01 	lds	r25, 0x0125
    2da8:	0c 97       	sbiw	r24, 0x0c	; 12
    2daa:	90 93 25 01 	sts	0x0125, r25
    2dae:	80 93 24 01 	sts	0x0124, r24
    2db2:	ca e5       	ldi	r28, 0x5A	; 90
    2db4:	d2 e0       	ldi	r29, 0x02	; 2

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    2db6:	89 91       	ld	r24, Y+
    2db8:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
					TransferSdByte('x');
				}
				
				bytesLeftInBlock-=12;

				for(i=0;i<64;i++)					// Write table of contents.
    2dbc:	82 e0       	ldi	r24, 0x02	; 2
    2dbe:	ca 39       	cpi	r28, 0x9A	; 154
    2dc0:	d8 07       	cpc	r29, r24
    2dc2:	c9 f7       	brne	.-14     	; 0x2db6 <main+0x4d6>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    2dc4:	80 91 24 01 	lds	r24, 0x0124
    2dc8:	90 91 25 01 	lds	r25, 0x0125
    2dcc:	80 54       	subi	r24, 0x40	; 64
    2dce:	90 40       	sbci	r25, 0x00	; 0
    2dd0:	90 93 25 01 	sts	0x0125, r25
    2dd4:	80 93 24 01 	sts	0x0124, r24
				cardReadyForTransfer=true;					// OK to keep writing
    2dd8:	81 e0       	ldi	r24, 0x01	; 1
    2dda:	80 93 9e 02 	sts	0x029E, r24
				cardState=SD_WAIT_FOR_TOC_WRITE_TO_FINISH;
    2dde:	20 92 59 02 	sts	0x0259, r2
    2de2:	60 c0       	rjmp	.+192    	; 0x2ea4 <main+0x5c4>
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;

			case SD_WAIT_FOR_TOC_WRITE_TO_FINISH:
			if(cardReadyForTransfer)				// Are we writing or waiting for busy to end?
    2de4:	80 91 9e 02 	lds	r24, 0x029E
    2de8:	88 23       	and	r24, r24
    2dea:	b9 f1       	breq	.+110    	; 0x2e5a <main+0x57a>
    2dec:	c0 91 24 01 	lds	r28, 0x0124
    2df0:	d0 91 25 01 	lds	r29, 0x0125
    2df4:	c1 34       	cpi	r28, 0x41	; 65
    2df6:	d1 05       	cpc	r29, r1
    2df8:	10 f0       	brcs	.+4      	; 0x2dfe <main+0x51e>
    2dfa:	c0 e4       	ldi	r28, 0x40	; 64
    2dfc:	d0 e0       	ldi	r29, 0x00	; 0
    2dfe:	10 e0       	ldi	r17, 0x00	; 0
    2e00:	0d c0       	rjmp	.+26     	; 0x2e1c <main+0x53c>
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)
				{														
					TransferSdByte(DUMMY_BYTE);			// Send a pad
    2e02:	8f ef       	ldi	r24, 0xFF	; 255
    2e04:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
					bytesLeftInBlock--;					// One less byte to send.
    2e08:	80 91 24 01 	lds	r24, 0x0124
    2e0c:	90 91 25 01 	lds	r25, 0x0125
    2e10:	01 97       	sbiw	r24, 0x01	; 1
    2e12:	90 93 25 01 	sts	0x0125, r25
    2e16:	80 93 24 01 	sts	0x0124, r24
				else	// Less than a chunk left in the block, send the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)
    2e1a:	1f 5f       	subi	r17, 0xFF	; 255
    2e1c:	81 2f       	mov	r24, r17
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	8c 17       	cp	r24, r28
    2e22:	9d 07       	cpc	r25, r29
    2e24:	70 f3       	brcs	.-36     	; 0x2e02 <main+0x522>
				{														
					TransferSdByte(DUMMY_BYTE);			// Send a pad
					bytesLeftInBlock--;					// One less byte to send.
				}

				if(bytesLeftInBlock==0)					// Handle closing this block
    2e26:	80 91 24 01 	lds	r24, 0x0124
    2e2a:	90 91 25 01 	lds	r25, 0x0125
    2e2e:	89 2b       	or	r24, r25
    2e30:	c9 f5       	brne	.+114    	; 0x2ea4 <main+0x5c4>
				{
					TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    2e32:	8f ef       	ldi	r24, 0xFF	; 255
    2e34:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    2e38:	8f ef       	ldi	r24, 0xFF	; 255
    2e3a:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
					theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code	
    2e3e:	8f ef       	ldi	r24, 0xFF	; 255
    2e40:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>

					if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    2e44:	8f 71       	andi	r24, 0x1F	; 31
    2e46:	85 30       	cpi	r24, 0x05	; 5
    2e48:	59 f5       	brne	.+86     	; 0x2ea0 <main+0x5c0>
					{
						SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    2e4a:	83 e0       	ldi	r24, 0x03	; 3
    2e4c:	62 e6       	ldi	r22, 0x62	; 98
    2e4e:	72 e0       	ldi	r23, 0x02	; 2
    2e50:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
						cardReadyForTransfer=false;				// Now we ARE waiting on the card.
    2e54:	10 92 9e 02 	sts	0x029E, r1
    2e58:	25 c0       	rjmp	.+74     	; 0x2ea4 <main+0x5c4>
					}	
				}
			}
			else	// Card busy (not ready for transfer)
			{
				if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    2e5a:	83 e0       	ldi	r24, 0x03	; 3
    2e5c:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    2e60:	88 23       	and	r24, r24
    2e62:	f1 f4       	brne	.+60     	; 0x2ea0 <main+0x5c0>
    2e64:	10 e0       	ldi	r17, 0x00	; 0
							EndSdTransfer();				// Bring CS high
							TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
							while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
								;

							cardReadyForTransfer=true;	// Needed to exit loop
    2e66:	01 e0       	ldi	r16, 0x01	; 1
    2e68:	16 c0       	rjmp	.+44     	; 0x2e96 <main+0x5b6>
				if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
				{
					i=0;
					while((i<4)&&cardReadyForTransfer==false)	// Try a few times to see if the card is done writing.
					{
						if(TransferSdByte(DUMMY_BYTE)!=0xFF)	// Hang out for four busy bytes.
    2e6a:	8f ef       	ldi	r24, 0xFF	; 255
    2e6c:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
    2e70:	8f 3f       	cpi	r24, 0xFF	; 255
    2e72:	11 f0       	breq	.+4      	; 0x2e78 <main+0x598>
						{
							i++;
    2e74:	1f 5f       	subi	r17, 0xFF	; 255
    2e76:	0d c0       	rjmp	.+26     	; 0x2e92 <main+0x5b2>
						}
						else	// Line released, now high again (0xFF) so end command
						{
							EndSdTransfer();				// Bring CS high
    2e78:	0e 94 8c 24 	call	0x4918	; 0x4918 <EndSdTransfer>
							TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    2e7c:	8f ef       	ldi	r24, 0xFF	; 255
    2e7e:	0e 94 91 24 	call	0x4922	; 0x4922 <TransferSdByte>
							while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    2e82:	80 91 c8 00 	lds	r24, 0x00C8
    2e86:	86 ff       	sbrs	r24, 6
    2e88:	fc cf       	rjmp	.-8      	; 0x2e82 <main+0x5a2>
								;

							cardReadyForTransfer=true;	// Needed to exit loop
    2e8a:	00 93 9e 02 	sts	0x029E, r16
							cardState=SD_IDLE;			// Done writing the TOC!
    2e8e:	30 92 59 02 	sts	0x0259, r3
			else	// Card busy (not ready for transfer)
			{
				if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
				{
					i=0;
					while((i<4)&&cardReadyForTransfer==false)	// Try a few times to see if the card is done writing.
    2e92:	14 30       	cpi	r17, 0x04	; 4
    2e94:	38 f4       	brcc	.+14     	; 0x2ea4 <main+0x5c4>
    2e96:	80 91 9e 02 	lds	r24, 0x029E
    2e9a:	88 23       	and	r24, r24
    2e9c:	31 f3       	breq	.-52     	; 0x2e6a <main+0x58a>
    2e9e:	02 c0       	rjmp	.+4      	; 0x2ea4 <main+0x5c4>
						}
					}								
				}
				else	// Timed out!
				{
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
    2ea0:	10 92 59 02 	sts	0x0259, r1
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    2ea4:	80 91 00 01 	lds	r24, 0x0100
    2ea8:	90 91 01 01 	lds	r25, 0x0101
    2eac:	a0 91 02 01 	lds	r26, 0x0102
    2eb0:	b0 91 03 01 	lds	r27, 0x0103
    2eb4:	88 0f       	add	r24, r24
    2eb6:	99 1f       	adc	r25, r25
    2eb8:	aa 1f       	adc	r26, r26
    2eba:	bb 1f       	adc	r27, r27
    2ebc:	80 93 00 01 	sts	0x0100, r24
    2ec0:	90 93 01 01 	sts	0x0101, r25
    2ec4:	a0 93 02 01 	sts	0x0102, r26
    2ec8:	b0 93 03 01 	sts	0x0103, r27
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    2ecc:	b7 ff       	sbrs	r27, 7
    2ece:	0c c0       	rjmp	.+24     	; 0x2ee8 <main+0x608>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    2ed0:	8a 25       	eor	r24, r10
    2ed2:	9b 25       	eor	r25, r11
    2ed4:	ac 25       	eor	r26, r12
    2ed6:	bd 25       	eor	r27, r13
    2ed8:	80 93 00 01 	sts	0x0100, r24
    2edc:	90 93 01 01 	sts	0x0101, r25
    2ee0:	a0 93 02 01 	sts	0x0102, r26
    2ee4:	b0 93 03 01 	sts	0x0103, r27
		GetRandomLongInt();		// Keep random numbers rolling.

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    2ee8:	0e 94 f3 21 	call	0x43e6	; 0x43e6 <Uart0GotByte>
    2eec:	88 23       	and	r24, r24
    2eee:	21 f0       	breq	.+8      	; 0x2ef8 <main+0x618>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    2ef0:	0e 94 f9 21 	call	0x43f2	; 0x43f2 <Uart0GetByte>
    2ef4:	0e 94 d9 22 	call	0x45b2	; 0x45b2 <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    2ef8:	0e 94 ae 23 	call	0x475c	; 0x475c <MidiTxBufferNotEmpty>
    2efc:	88 23       	and	r24, r24
    2efe:	41 f0       	breq	.+16     	; 0x2f10 <main+0x630>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    2f00:	80 91 c0 00 	lds	r24, 0x00C0
    2f04:	85 ff       	sbrs	r24, 5
    2f06:	04 c0       	rjmp	.+8      	; 0x2f10 <main+0x630>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    2f08:	0e 94 b9 23 	call	0x4772	; 0x4772 <PopOutgoingMidiByte>
    2f0c:	80 93 c6 00 	sts	0x00C6, r24
			}				
		}

		State();				// Execute the current program state.
    2f10:	e0 91 c7 02 	lds	r30, 0x02C7
    2f14:	f0 91 c8 02 	lds	r31, 0x02C8
    2f18:	09 95       	icall
    2f1a:	99 cd       	rjmp	.-1230   	; 0x2a4e <main+0x16e>

00002f1c <GetMidiChannel>:
}


static unsigned char GetMidiChannel(unsigned char theBank)
// Get the midi channel we stored in EEPROM.
{
    2f1c:	1f 93       	push	r17
    2f1e:	18 2f       	mov	r17, r24
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    2f20:	88 23       	and	r24, r24
    2f22:	11 f4       	brne	.+4      	; 0x2f28 <GetMidiChannel+0xc>
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    2f24:	84 e0       	ldi	r24, 0x04	; 4
    2f26:	05 c0       	rjmp	.+10     	; 0x2f32 <GetMidiChannel+0x16>
	}
	else if(theBank==BANK_1)
    2f28:	81 30       	cpi	r24, 0x01	; 1
    2f2a:	11 f0       	breq	.+4      	; 0x2f30 <GetMidiChannel+0x14>
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	08 c0       	rjmp	.+16     	; 0x2f40 <GetMidiChannel+0x24>
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    2f30:	88 e0       	ldi	r24, 0x08	; 8
    2f32:	0e 94 e5 21 	call	0x43ca	; 0x43ca <EepromRead>
	}

	if(x<16)					// Legit number?
    2f36:	80 31       	cpi	r24, 0x10	; 16
    2f38:	18 f0       	brcs	.+6      	; 0x2f40 <GetMidiChannel+0x24>
    2f3a:	81 2f       	mov	r24, r17
    2f3c:	11 11       	cpse	r17, r1
    2f3e:	81 e0       	ldi	r24, 0x01	; 1
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
	}	
}
    2f40:	1f 91       	pop	r17
    2f42:	08 95       	ret

00002f44 <DoSampler>:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.

// Wed Apr  8 11:42:07 CDT 2009
// This state is based on the idea that playing, recording, and overdubbing are all discrete things and that if you're doing one you can't be doing another.
{
    2f44:	cf 92       	push	r12
    2f46:	df 92       	push	r13
    2f48:	ef 92       	push	r14
    2f4a:	ff 92       	push	r15
    2f4c:	0f 93       	push	r16
    2f4e:	1f 93       	push	r17
    2f50:	cf 93       	push	r28
    2f52:	df 93       	push	r29
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	static bool
		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
    2f54:	10 91 41 01 	lds	r17, 0x0141
    2f58:	11 23       	and	r17, r17
    2f5a:	09 f0       	breq	.+2      	; 0x2f5e <DoSampler+0x1a>
    2f5c:	9c c0       	rjmp	.+312    	; 0x3096 <DoSampler+0x152>
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    2f5e:	80 e0       	ldi	r24, 0x00	; 0
    2f60:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <GetMidiChannel>
    2f64:	80 93 0f 03 	sts	0x030F, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    2f68:	81 e0       	ldi	r24, 0x01	; 1
    2f6a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <GetMidiChannel>
    2f6e:	80 93 28 03 	sts	0x0328, r24
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    2f72:	10 92 d8 02 	sts	0x02D8, r1
    2f76:	10 92 d9 02 	sts	0x02D9, r1
    2f7a:	10 92 da 02 	sts	0x02DA, r1
    2f7e:	10 92 db 02 	sts	0x02DB, r1
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    2f82:	8f ef       	ldi	r24, 0xFF	; 255
    2f84:	9f ef       	ldi	r25, 0xFF	; 255
    2f86:	a7 e0       	ldi	r26, 0x07	; 7
    2f88:	b0 e0       	ldi	r27, 0x00	; 0
    2f8a:	80 93 fa 02 	sts	0x02FA, r24
    2f8e:	90 93 fb 02 	sts	0x02FB, r25
    2f92:	a0 93 fc 02 	sts	0x02FC, r26
    2f96:	b0 93 fd 02 	sts	0x02FD, r27
    2f9a:	04 ea       	ldi	r16, 0xA4	; 164
    2f9c:	12 e0       	ldi	r17, 0x02	; 2
    2f9e:	c0 e0       	ldi	r28, 0x00	; 0
    2fa0:	d0 e0       	ldi	r29, 0x00	; 0
			bankStates[i].loopOnce=false;
			bankStates[i].bitReduction=0;				// No crusties yet.
			bankStates[i].jitterValue=0;				// No hissies yet.
			bankStates[i].granularSlices=0;				// No remix yet.
			bankStates[i].halfSpeed=false;
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2fa2:	ee 24       	eor	r14, r14
    2fa4:	e3 94       	inc	r14
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    2fa6:	9e 01       	movw	r18, r28
    2fa8:	22 0f       	add	r18, r18
    2faa:	33 1f       	adc	r19, r19
    2fac:	ce 01       	movw	r24, r28
    2fae:	45 e0       	ldi	r20, 0x05	; 5
    2fb0:	88 0f       	add	r24, r24
    2fb2:	99 1f       	adc	r25, r25
    2fb4:	4a 95       	dec	r20
    2fb6:	e1 f7       	brne	.-8      	; 0x2fb0 <DoSampler+0x6c>
    2fb8:	28 0f       	add	r18, r24
    2fba:	39 1f       	adc	r19, r25
    2fbc:	27 53       	subi	r18, 0x37	; 55
    2fbe:	3d 4f       	sbci	r19, 0xFD	; 253
    2fc0:	f9 01       	movw	r30, r18
    2fc2:	10 82       	st	Z, r1
			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    2fc4:	10 86       	std	Z+8, r1	; 0x08
			bankStates[i].loopOnce=false;
    2fc6:	11 82       	std	Z+1, r1	; 0x01
			bankStates[i].bitReduction=0;				// No crusties yet.
    2fc8:	17 82       	std	Z+7, r1	; 0x07
			bankStates[i].jitterValue=0;				// No hissies yet.
    2fca:	16 82       	std	Z+6, r1	; 0x06
			bankStates[i].granularSlices=0;				// No remix yet.
    2fcc:	15 82       	std	Z+5, r1	; 0x05
			bankStates[i].halfSpeed=false;
    2fce:	fe 01       	movw	r30, r28
    2fd0:	94 e0       	ldi	r25, 0x04	; 4
    2fd2:	ee 0f       	add	r30, r30
    2fd4:	ff 1f       	adc	r31, r31
    2fd6:	9a 95       	dec	r25
    2fd8:	e1 f7       	brne	.-8      	; 0x2fd2 <DoSampler+0x8e>
    2fda:	ec 0f       	add	r30, r28
    2fdc:	fd 1f       	adc	r31, r29
    2fde:	ee 0f       	add	r30, r30
    2fe0:	ff 1f       	adc	r31, r31
    2fe2:	e5 53       	subi	r30, 0x35	; 53
    2fe4:	fd 4f       	sbci	r31, 0xFD	; 253
    2fe6:	10 82       	st	Z, r1
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2fe8:	f9 01       	movw	r30, r18
    2fea:	e4 82       	std	Z+4, r14	; 0x04
			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    2fec:	13 82       	std	Z+3, r1	; 0x03
			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2fee:	87 85       	ldd	r24, Z+15	; 0x0f
    2ff0:	90 89       	ldd	r25, Z+16	; 0x10
    2ff2:	a1 89       	ldd	r26, Z+17	; 0x11
    2ff4:	b2 89       	ldd	r27, Z+18	; 0x12
    2ff6:	86 8f       	std	Z+30, r24	; 0x1e
    2ff8:	97 8f       	std	Z+31, r25	; 0x1f
    2ffa:	a0 a3       	std	Z+32, r26	; 0x20
    2ffc:	b1 a3       	std	Z+33, r27	; 0x21
			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2ffe:	87 85       	ldd	r24, Z+15	; 0x0f
    3000:	90 89       	ldd	r25, Z+16	; 0x10
    3002:	a1 89       	ldd	r26, Z+17	; 0x11
    3004:	b2 89       	ldd	r27, Z+18	; 0x12
    3006:	83 87       	std	Z+11, r24	; 0x0b
    3008:	94 87       	std	Z+12, r25	; 0x0c
    300a:	a5 87       	std	Z+13, r26	; 0x0d
    300c:	b6 87       	std	Z+14, r27	; 0x0e
			realtimeOn[i]=false;								// We'll default to playback.	
    300e:	fe 01       	movw	r30, r28
    3010:	e8 5d       	subi	r30, 0xD8	; 216
    3012:	fe 4f       	sbci	r31, 0xFE	; 254
    3014:	10 82       	st	Z, r1
			editModeEntered=false;
    3016:	10 92 27 01 	sts	0x0127, r1
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    301a:	4f b7       	in	r20, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    301c:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    301e:	f9 01       	movw	r30, r18
    3020:	87 85       	ldd	r24, Z+15	; 0x0f
    3022:	90 89       	ldd	r25, Z+16	; 0x10
    3024:	a1 89       	ldd	r26, Z+17	; 0x11
    3026:	b2 89       	ldd	r27, Z+18	; 0x12
    3028:	87 8b       	std	Z+23, r24	; 0x17
    302a:	90 8f       	std	Z+24, r25	; 0x18
    302c:	a1 8f       	std	Z+25, r26	; 0x19
    302e:	b2 8f       	std	Z+26, r27	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3030:	83 85       	ldd	r24, Z+11	; 0x0b
    3032:	94 85       	ldd	r25, Z+12	; 0x0c
    3034:	a5 85       	ldd	r26, Z+13	; 0x0d
    3036:	b6 85       	ldd	r27, Z+14	; 0x0e
    3038:	83 8b       	std	Z+19, r24	; 0x13
    303a:	94 8b       	std	Z+20, r25	; 0x14
    303c:	a5 8b       	std	Z+21, r26	; 0x15
    303e:	b6 8b       	std	Z+22, r27	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    3040:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    3042:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    3044:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    3046:	4f bf       	out	0x3f, r20	; 63
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    3048:	cc 23       	and	r28, r28
    304a:	11 f4       	brne	.+4      	; 0x3050 <DoSampler+0x10c>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    304c:	87 e0       	ldi	r24, 0x07	; 7
    304e:	01 c0       	rjmp	.+2      	; 0x3052 <DoSampler+0x10e>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    3050:	8b e0       	ldi	r24, 0x0B	; 11
    3052:	0e 94 e5 21 	call	0x43ca	; 0x43ca <EepromRead>
	}

	if(x<90)					// Legit number?
    3056:	8a 35       	cpi	r24, 0x5A	; 90
    3058:	08 f0       	brcs	.+2      	; 0x305c <DoSampler+0x118>
    305a:	80 e3       	ldi	r24, 0x30	; 48
			realtimeOn[i]=false;								// We'll default to playback.	
			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
    305c:	f8 01       	movw	r30, r16
    305e:	80 83       	st	Z, r24
    3060:	11 82       	std	Z+1, r1	; 0x01
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    3062:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    3066:	f8 01       	movw	r30, r16
    3068:	81 93       	st	Z+, r24
    306a:	91 93       	st	Z+, r25
    306c:	8f 01       	movw	r16, r30
    306e:	21 96       	adiw	r28, 0x01	; 1
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    3070:	c2 30       	cpi	r28, 0x02	; 2
    3072:	d1 05       	cpc	r29, r1
    3074:	09 f0       	breq	.+2      	; 0x3078 <DoSampler+0x134>
    3076:	97 cf       	rjmp	.-210    	; 0x2fa6 <DoSampler+0x62>

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
		}

		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3078:	81 e5       	ldi	r24, 0x51	; 81
    307a:	98 e0       	ldi	r25, 0x08	; 8
    307c:	90 93 c6 02 	sts	0x02C6, r25
    3080:	80 93 c5 02 	sts	0x02C5, r24

		currentBank=BANK_0;			// Point at the first bank until we change banks.
    3084:	10 92 2e 01 	sts	0x012E, r1

		KillLeds();					// All leds off, and no blinking.
    3088:	0e 94 b3 12 	call	0x2566	; 0x2566 <KillLeds>
		subState=SS_1;
    308c:	81 e0       	ldi	r24, 0x01	; 1
    308e:	80 93 41 01 	sts	0x0141, r24
    3092:	0c 94 9a 20 	jmp	0x4134	; 0x4134 <DoSampler+0x11f0>
	}

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    3096:	11 30       	cpi	r17, 0x01	; 1
    3098:	11 f0       	breq	.+4      	; 0x309e <DoSampler+0x15a>
    309a:	0c 94 9a 20 	jmp	0x4134	; 0x4134 <DoSampler+0x11f0>
	{
		if(editModeEntered==false)	// Normal functions for buttons?
    309e:	80 91 27 01 	lds	r24, 0x0127
    30a2:	90 91 3e 01 	lds	r25, 0x013E
    30a6:	88 23       	and	r24, r24
    30a8:	09 f0       	breq	.+2      	; 0x30ac <DoSampler+0x168>
    30aa:	81 c3       	rjmp	.+1794   	; 0x37ae <DoSampler+0x86a>
		{
			if(keyState&Im_EFFECT)			// If we're holding the effect switch, our other switches call up patches instead of their normal functions.  It's like a shift key.
    30ac:	29 2f       	mov	r18, r25
    30ae:	30 e0       	ldi	r19, 0x00	; 0
    30b0:	95 ff       	sbrs	r25, 5
    30b2:	f8 c1       	rjmp	.+1008   	; 0x34a4 <DoSampler+0x560>
			{
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
    30b4:	b9 01       	movw	r22, r18
    30b6:	68 70       	andi	r22, 0x08	; 8
    30b8:	70 70       	andi	r23, 0x00	; 0
    30ba:	93 ff       	sbrs	r25, 3
    30bc:	04 c0       	rjmp	.+8      	; 0x30c6 <DoSampler+0x182>
    30be:	80 91 3f 01 	lds	r24, 0x013F
    30c2:	84 fd       	sbrc	r24, 4
    30c4:	0a c0       	rjmp	.+20     	; 0x30da <DoSampler+0x196>
    30c6:	80 91 3f 01 	lds	r24, 0x013F
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	ac 01       	movw	r20, r24
    30ce:	48 70       	andi	r20, 0x08	; 8
    30d0:	50 70       	andi	r21, 0x00	; 0
    30d2:	83 ff       	sbrs	r24, 3
    30d4:	fa c0       	rjmp	.+500    	; 0x32ca <DoSampler+0x386>
    30d6:	24 ff       	sbrs	r18, 4
    30d8:	f8 c0       	rjmp	.+496    	; 0x32ca <DoSampler+0x386>
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    30da:	81 e5       	ldi	r24, 0x51	; 81
    30dc:	98 e0       	ldi	r25, 0x08	; 8
    30de:	90 93 c6 02 	sts	0x02C6, r25
    30e2:	80 93 c5 02 	sts	0x02C5, r24
					RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    30e6:	60 91 2e 01 	lds	r22, 0x012E
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    30ea:	7f b7       	in	r23, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    30ec:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    30ee:	86 2f       	mov	r24, r22
    30f0:	90 e0       	ldi	r25, 0x00	; 0
    30f2:	fc 01       	movw	r30, r24
    30f4:	05 e0       	ldi	r16, 0x05	; 5
    30f6:	ee 0f       	add	r30, r30
    30f8:	ff 1f       	adc	r31, r31
    30fa:	0a 95       	dec	r16
    30fc:	e1 f7       	brne	.-8      	; 0x30f6 <DoSampler+0x1b2>
    30fe:	88 0f       	add	r24, r24
    3100:	99 1f       	adc	r25, r25
    3102:	e8 0f       	add	r30, r24
    3104:	f9 1f       	adc	r31, r25
    3106:	e7 53       	subi	r30, 0x37	; 55
    3108:	fd 4f       	sbci	r31, 0xFD	; 253
    310a:	27 85       	ldd	r18, Z+15	; 0x0f
    310c:	30 89       	ldd	r19, Z+16	; 0x10
    310e:	41 89       	ldd	r20, Z+17	; 0x11
    3110:	52 89       	ldd	r21, Z+18	; 0x12
    3112:	86 2f       	mov	r24, r22
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	fc 01       	movw	r30, r24
    3118:	b5 e0       	ldi	r27, 0x05	; 5
    311a:	ee 0f       	add	r30, r30
    311c:	ff 1f       	adc	r31, r31
    311e:	ba 95       	dec	r27
    3120:	e1 f7       	brne	.-8      	; 0x311a <DoSampler+0x1d6>
    3122:	88 0f       	add	r24, r24
    3124:	99 1f       	adc	r25, r25
    3126:	e8 0f       	add	r30, r24
    3128:	f9 1f       	adc	r31, r25
    312a:	e7 53       	subi	r30, 0x37	; 55
    312c:	fd 4f       	sbci	r31, 0xFD	; 253
    312e:	27 8b       	std	Z+23, r18	; 0x17
    3130:	30 8f       	std	Z+24, r19	; 0x18
    3132:	41 8f       	std	Z+25, r20	; 0x19
    3134:	52 8f       	std	Z+26, r21	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3136:	86 2f       	mov	r24, r22
    3138:	90 e0       	ldi	r25, 0x00	; 0
    313a:	fc 01       	movw	r30, r24
    313c:	05 e0       	ldi	r16, 0x05	; 5
    313e:	ee 0f       	add	r30, r30
    3140:	ff 1f       	adc	r31, r31
    3142:	0a 95       	dec	r16
    3144:	e1 f7       	brne	.-8      	; 0x313e <DoSampler+0x1fa>
    3146:	88 0f       	add	r24, r24
    3148:	99 1f       	adc	r25, r25
    314a:	e8 0f       	add	r30, r24
    314c:	f9 1f       	adc	r31, r25
    314e:	e7 53       	subi	r30, 0x37	; 55
    3150:	fd 4f       	sbci	r31, 0xFD	; 253
    3152:	23 85       	ldd	r18, Z+11	; 0x0b
    3154:	34 85       	ldd	r19, Z+12	; 0x0c
    3156:	45 85       	ldd	r20, Z+13	; 0x0d
    3158:	56 85       	ldd	r21, Z+14	; 0x0e
    315a:	86 2f       	mov	r24, r22
    315c:	90 e0       	ldi	r25, 0x00	; 0
    315e:	fc 01       	movw	r30, r24
    3160:	b5 e0       	ldi	r27, 0x05	; 5
    3162:	ee 0f       	add	r30, r30
    3164:	ff 1f       	adc	r31, r31
    3166:	ba 95       	dec	r27
    3168:	e1 f7       	brne	.-8      	; 0x3162 <DoSampler+0x21e>
    316a:	88 0f       	add	r24, r24
    316c:	99 1f       	adc	r25, r25
    316e:	e8 0f       	add	r30, r24
    3170:	f9 1f       	adc	r31, r25
    3172:	e7 53       	subi	r30, 0x37	; 55
    3174:	fd 4f       	sbci	r31, 0xFD	; 253
    3176:	23 8b       	std	Z+19, r18	; 0x13
    3178:	34 8b       	std	Z+20, r19	; 0x14
    317a:	45 8b       	std	Z+21, r20	; 0x15
    317c:	56 8b       	std	Z+22, r21	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    317e:	86 2f       	mov	r24, r22
    3180:	90 e0       	ldi	r25, 0x00	; 0
    3182:	fc 01       	movw	r30, r24
    3184:	05 e0       	ldi	r16, 0x05	; 5
    3186:	ee 0f       	add	r30, r30
    3188:	ff 1f       	adc	r31, r31
    318a:	0a 95       	dec	r16
    318c:	e1 f7       	brne	.-8      	; 0x3186 <DoSampler+0x242>
    318e:	88 0f       	add	r24, r24
    3190:	99 1f       	adc	r25, r25
    3192:	e8 0f       	add	r30, r24
    3194:	f9 1f       	adc	r31, r25
    3196:	e7 53       	subi	r30, 0x37	; 55
    3198:	fd 4f       	sbci	r31, 0xFD	; 253
    319a:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    319c:	86 2f       	mov	r24, r22
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	fc 01       	movw	r30, r24
    31a2:	b5 e0       	ldi	r27, 0x05	; 5
    31a4:	ee 0f       	add	r30, r30
    31a6:	ff 1f       	adc	r31, r31
    31a8:	ba 95       	dec	r27
    31aa:	e1 f7       	brne	.-8      	; 0x31a4 <DoSampler+0x260>
    31ac:	88 0f       	add	r24, r24
    31ae:	99 1f       	adc	r25, r25
    31b0:	e8 0f       	add	r30, r24
    31b2:	f9 1f       	adc	r31, r25
    31b4:	e7 53       	subi	r30, 0x37	; 55
    31b6:	fd 4f       	sbci	r31, 0xFD	; 253
    31b8:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    31ba:	86 2f       	mov	r24, r22
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	fc 01       	movw	r30, r24
    31c0:	65 e0       	ldi	r22, 0x05	; 5
    31c2:	ee 0f       	add	r30, r30
    31c4:	ff 1f       	adc	r31, r31
    31c6:	6a 95       	dec	r22
    31c8:	e1 f7       	brne	.-8      	; 0x31c2 <DoSampler+0x27e>
    31ca:	88 0f       	add	r24, r24
    31cc:	99 1f       	adc	r25, r25
    31ce:	e8 0f       	add	r30, r24
    31d0:	f9 1f       	adc	r31, r25
    31d2:	e7 53       	subi	r30, 0x37	; 55
    31d4:	fd 4f       	sbci	r31, 0xFD	; 253
    31d6:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    31d8:	7f bf       	out	0x3f, r23	; 63
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
					bankStates[currentBank].bitReduction=0;			// No crusties yet.
    31da:	80 91 2e 01 	lds	r24, 0x012E
    31de:	28 2f       	mov	r18, r24
    31e0:	30 e0       	ldi	r19, 0x00	; 0
    31e2:	f9 01       	movw	r30, r18
    31e4:	45 e0       	ldi	r20, 0x05	; 5
    31e6:	ee 0f       	add	r30, r30
    31e8:	ff 1f       	adc	r31, r31
    31ea:	4a 95       	dec	r20
    31ec:	e1 f7       	brne	.-8      	; 0x31e6 <DoSampler+0x2a2>
    31ee:	22 0f       	add	r18, r18
    31f0:	33 1f       	adc	r19, r19
    31f2:	e2 0f       	add	r30, r18
    31f4:	f3 1f       	adc	r31, r19
    31f6:	e7 53       	subi	r30, 0x37	; 55
    31f8:	fd 4f       	sbci	r31, 0xFD	; 253
    31fa:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentBank].jitterValue=0;			// No hissies yet.
    31fc:	28 2f       	mov	r18, r24
    31fe:	30 e0       	ldi	r19, 0x00	; 0
    3200:	f9 01       	movw	r30, r18
    3202:	05 e0       	ldi	r16, 0x05	; 5
    3204:	ee 0f       	add	r30, r30
    3206:	ff 1f       	adc	r31, r31
    3208:	0a 95       	dec	r16
    320a:	e1 f7       	brne	.-8      	; 0x3204 <DoSampler+0x2c0>
    320c:	22 0f       	add	r18, r18
    320e:	33 1f       	adc	r19, r19
    3210:	e2 0f       	add	r30, r18
    3212:	f3 1f       	adc	r31, r19
    3214:	e7 53       	subi	r30, 0x37	; 55
    3216:	fd 4f       	sbci	r31, 0xFD	; 253
    3218:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentBank].granularSlices=0;		// No remix yet.
    321a:	28 2f       	mov	r18, r24
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	f9 01       	movw	r30, r18
    3220:	b5 e0       	ldi	r27, 0x05	; 5
    3222:	ee 0f       	add	r30, r30
    3224:	ff 1f       	adc	r31, r31
    3226:	ba 95       	dec	r27
    3228:	e1 f7       	brne	.-8      	; 0x3222 <DoSampler+0x2de>
    322a:	22 0f       	add	r18, r18
    322c:	33 1f       	adc	r19, r19
    322e:	e2 0f       	add	r30, r18
    3230:	f3 1f       	adc	r31, r19
    3232:	e7 53       	subi	r30, 0x37	; 55
    3234:	fd 4f       	sbci	r31, 0xFD	; 253
    3236:	15 82       	std	Z+5, r1	; 0x05
					bankStates[currentBank].halfSpeed=false;
    3238:	28 2f       	mov	r18, r24
    323a:	30 e0       	ldi	r19, 0x00	; 0
    323c:	f9 01       	movw	r30, r18
    323e:	74 e0       	ldi	r23, 0x04	; 4
    3240:	ee 0f       	add	r30, r30
    3242:	ff 1f       	adc	r31, r31
    3244:	7a 95       	dec	r23
    3246:	e1 f7       	brne	.-8      	; 0x3240 <DoSampler+0x2fc>
    3248:	e2 0f       	add	r30, r18
    324a:	f3 1f       	adc	r31, r19
    324c:	ee 0f       	add	r30, r30
    324e:	ff 1f       	adc	r31, r31
    3250:	e5 53       	subi	r30, 0x35	; 53
    3252:	fd 4f       	sbci	r31, 0xFD	; 253
    3254:	10 82       	st	Z, r1
					bankStates[currentBank].backwardsPlayback=false;					
    3256:	28 2f       	mov	r18, r24
    3258:	30 e0       	ldi	r19, 0x00	; 0
    325a:	f9 01       	movw	r30, r18
    325c:	55 e0       	ldi	r21, 0x05	; 5
    325e:	ee 0f       	add	r30, r30
    3260:	ff 1f       	adc	r31, r31
    3262:	5a 95       	dec	r21
    3264:	e1 f7       	brne	.-8      	; 0x325e <DoSampler+0x31a>
    3266:	22 0f       	add	r18, r18
    3268:	33 1f       	adc	r19, r19
    326a:	e2 0f       	add	r30, r18
    326c:	f3 1f       	adc	r31, r19
    326e:	e7 53       	subi	r30, 0x37	; 55
    3270:	fd 4f       	sbci	r31, 0xFD	; 253
    3272:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentBank].sampleDirection=true;					
    3274:	28 2f       	mov	r18, r24
    3276:	30 e0       	ldi	r19, 0x00	; 0
    3278:	f9 01       	movw	r30, r18
    327a:	95 e0       	ldi	r25, 0x05	; 5
    327c:	ee 0f       	add	r30, r30
    327e:	ff 1f       	adc	r31, r31
    3280:	9a 95       	dec	r25
    3282:	e1 f7       	brne	.-8      	; 0x327c <DoSampler+0x338>
    3284:	22 0f       	add	r18, r18
    3286:	33 1f       	adc	r19, r19
    3288:	e2 0f       	add	r30, r18
    328a:	f3 1f       	adc	r31, r19
    328c:	e7 53       	subi	r30, 0x37	; 55
    328e:	fd 4f       	sbci	r31, 0xFD	; 253
    3290:	91 e0       	ldi	r25, 0x01	; 1
    3292:	94 83       	std	Z+4, r25	; 0x04
					bankStates[currentBank].loopOnce=false;				
    3294:	28 2f       	mov	r18, r24
    3296:	30 e0       	ldi	r19, 0x00	; 0
    3298:	f9 01       	movw	r30, r18
    329a:	15 e0       	ldi	r17, 0x05	; 5
    329c:	ee 0f       	add	r30, r30
    329e:	ff 1f       	adc	r31, r31
    32a0:	1a 95       	dec	r17
    32a2:	e1 f7       	brne	.-8      	; 0x329c <DoSampler+0x358>
    32a4:	22 0f       	add	r18, r18
    32a6:	33 1f       	adc	r19, r19
    32a8:	e2 0f       	add	r30, r18
    32aa:	f3 1f       	adc	r31, r19
    32ac:	e7 53       	subi	r30, 0x37	; 55
    32ae:	fd 4f       	sbci	r31, 0xFD	; 253
    32b0:	11 82       	std	Z+1, r1	; 0x01
					editModeEntered=false;
    32b2:	10 92 27 01 	sts	0x0127, r1
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);		// Send it out to the techno nerds.			
    32b6:	64 e0       	ldi	r22, 0x04	; 4
    32b8:	42 e1       	ldi	r20, 0x12	; 18
    32ba:	20 e0       	ldi	r18, 0x00	; 0
    32bc:	0e 94 a1 22 	call	0x4542	; 0x4542 <PutMidiMessageInOutgoingFifo>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.			
    32c0:	80 91 2e 01 	lds	r24, 0x012E
    32c4:	64 e0       	ldi	r22, 0x04	; 4
    32c6:	4b e1       	ldi	r20, 0x1B	; 27
    32c8:	1d c2       	rjmp	.+1082   	; 0x3704 <DoSampler+0x7c0>
				}
				else if(keyState&Im_SWITCH_3)	// Sample trimming
    32ca:	67 2b       	or	r22, r23
    32cc:	59 f1       	breq	.+86     	; 0x3324 <DoSampler+0x3e0>
				{
					if(keyState&Im_SWITCH_0||keyState&Im_SWITCH_1||keyState&Im_SWITCH_2)	// These are all edit commands, if we hit them then enter edit mode.
    32ce:	20 fd       	sbrc	r18, 0
    32d0:	04 c0       	rjmp	.+8      	; 0x32da <DoSampler+0x396>
    32d2:	26 70       	andi	r18, 0x06	; 6
    32d4:	30 70       	andi	r19, 0x00	; 0
    32d6:	23 2b       	or	r18, r19
    32d8:	21 f0       	breq	.+8      	; 0x32e2 <DoSampler+0x39e>
					{
						editModeEntered=true;
    32da:	81 e0       	ldi	r24, 0x01	; 1
    32dc:	80 93 27 01 	sts	0x0127, r24
    32e0:	09 c3       	rjmp	.+1554   	; 0x38f4 <DoSampler+0x9b0>
					}
					else if(newKeys&Im_SWITCH_3)		// Screw and chop (toggle) (default two key combo)
    32e2:	45 2b       	or	r20, r21
    32e4:	09 f4       	brne	.+2      	; 0x32e8 <DoSampler+0x3a4>
    32e6:	06 c3       	rjmp	.+1548   	; 0x38f4 <DoSampler+0x9b0>
					{
						if(bankStates[currentBank].halfSpeed==false)
    32e8:	20 91 2e 01 	lds	r18, 0x012E
    32ec:	82 2f       	mov	r24, r18
    32ee:	90 e0       	ldi	r25, 0x00	; 0
    32f0:	fc 01       	movw	r30, r24
    32f2:	a4 e0       	ldi	r26, 0x04	; 4
    32f4:	ee 0f       	add	r30, r30
    32f6:	ff 1f       	adc	r31, r31
    32f8:	aa 95       	dec	r26
    32fa:	e1 f7       	brne	.-8      	; 0x32f4 <DoSampler+0x3b0>
    32fc:	e8 0f       	add	r30, r24
    32fe:	f9 1f       	adc	r31, r25
    3300:	ee 0f       	add	r30, r30
    3302:	ff 1f       	adc	r31, r31
    3304:	e5 53       	subi	r30, 0x35	; 53
    3306:	fd 4f       	sbci	r31, 0xFD	; 253
    3308:	80 81       	ld	r24, Z
    330a:	88 23       	and	r24, r24
    330c:	31 f4       	brne	.+12     	; 0x331a <DoSampler+0x3d6>
						{
							bankStates[currentBank].halfSpeed=true;
    330e:	81 e0       	ldi	r24, 0x01	; 1
    3310:	80 83       	st	Z, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    3312:	82 2f       	mov	r24, r18
    3314:	64 e0       	ldi	r22, 0x04	; 4
    3316:	40 e1       	ldi	r20, 0x10	; 16
    3318:	d2 c1       	rjmp	.+932    	; 0x36be <DoSampler+0x77a>
						}
						else
						{
							bankStates[currentBank].halfSpeed=false;				
    331a:	10 82       	st	Z, r1
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    331c:	82 2f       	mov	r24, r18
    331e:	64 e0       	ldi	r22, 0x04	; 4
    3320:	40 e1       	ldi	r20, 0x10	; 16
    3322:	f0 c1       	rjmp	.+992    	; 0x3704 <DoSampler+0x7c0>
						}
					}
				}
				else if(keyState&Im_SWITCH_4)		// Realtime.
    3324:	24 ff       	sbrs	r18, 4
    3326:	52 c0       	rjmp	.+164    	; 0x33cc <DoSampler+0x488>
				{
					if(newKeys&Im_SWITCH_2)		// Do realtime (three button combo)
    3328:	82 ff       	sbrs	r24, 2
    332a:	0c c0       	rjmp	.+24     	; 0x3344 <DoSampler+0x400>
					{
						StartRealtime(currentBank,CLK_EXTERNAL,0);
    332c:	80 91 2e 01 	lds	r24, 0x012E
    3330:	61 e0       	ldi	r22, 0x01	; 1
    3332:	40 e0       	ldi	r20, 0x00	; 0
    3334:	50 e0       	ldi	r21, 0x00	; 0
    3336:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <StartRealtime>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    333a:	80 91 2e 01 	lds	r24, 0x012E
    333e:	64 e0       	ldi	r22, 0x04	; 4
    3340:	4e e0       	ldi	r20, 0x0E	; 14
    3342:	4f c1       	rjmp	.+670    	; 0x35e2 <DoSampler+0x69e>
					}
					else if(newKeys&Im_SWITCH_4)		// "Paul is Dead" mask (only pressing two keys)
    3344:	84 ff       	sbrs	r24, 4
    3346:	d6 c2       	rjmp	.+1452   	; 0x38f4 <DoSampler+0x9b0>
					{
						if(bankStates[currentBank].backwardsPlayback==false)
    3348:	20 91 2e 01 	lds	r18, 0x012E
    334c:	82 2f       	mov	r24, r18
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	fc 01       	movw	r30, r24
    3352:	65 e0       	ldi	r22, 0x05	; 5
    3354:	ee 0f       	add	r30, r30
    3356:	ff 1f       	adc	r31, r31
    3358:	6a 95       	dec	r22
    335a:	e1 f7       	brne	.-8      	; 0x3354 <DoSampler+0x410>
    335c:	88 0f       	add	r24, r24
    335e:	99 1f       	adc	r25, r25
    3360:	e8 0f       	add	r30, r24
    3362:	f9 1f       	adc	r31, r25
    3364:	e7 53       	subi	r30, 0x37	; 55
    3366:	fd 4f       	sbci	r31, 0xFD	; 253
    3368:	83 81       	ldd	r24, Z+3	; 0x03
    336a:	88 23       	and	r24, r24
    336c:	a9 f4       	brne	.+42     	; 0x3398 <DoSampler+0x454>
						{
							bankStates[currentBank].backwardsPlayback=true;
    336e:	82 2f       	mov	r24, r18
    3370:	90 e0       	ldi	r25, 0x00	; 0
    3372:	fc 01       	movw	r30, r24
    3374:	45 e0       	ldi	r20, 0x05	; 5
    3376:	ee 0f       	add	r30, r30
    3378:	ff 1f       	adc	r31, r31
    337a:	4a 95       	dec	r20
    337c:	e1 f7       	brne	.-8      	; 0x3376 <DoSampler+0x432>
    337e:	88 0f       	add	r24, r24
    3380:	99 1f       	adc	r25, r25
    3382:	e8 0f       	add	r30, r24
    3384:	f9 1f       	adc	r31, r25
    3386:	e7 53       	subi	r30, 0x37	; 55
    3388:	fd 4f       	sbci	r31, 0xFD	; 253
    338a:	81 e0       	ldi	r24, 0x01	; 1
    338c:	83 83       	std	Z+3, r24	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    338e:	82 2f       	mov	r24, r18
    3390:	64 e0       	ldi	r22, 0x04	; 4
    3392:	41 e1       	ldi	r20, 0x11	; 17
    3394:	20 e4       	ldi	r18, 0x40	; 64
    3396:	13 c0       	rjmp	.+38     	; 0x33be <DoSampler+0x47a>
						}
						else
						{
							bankStates[currentBank].backwardsPlayback=false;				
    3398:	82 2f       	mov	r24, r18
    339a:	90 e0       	ldi	r25, 0x00	; 0
    339c:	fc 01       	movw	r30, r24
    339e:	05 e0       	ldi	r16, 0x05	; 5
    33a0:	ee 0f       	add	r30, r30
    33a2:	ff 1f       	adc	r31, r31
    33a4:	0a 95       	dec	r16
    33a6:	e1 f7       	brne	.-8      	; 0x33a0 <DoSampler+0x45c>
    33a8:	88 0f       	add	r24, r24
    33aa:	99 1f       	adc	r25, r25
    33ac:	e8 0f       	add	r30, r24
    33ae:	f9 1f       	adc	r31, r25
    33b0:	e7 53       	subi	r30, 0x37	; 55
    33b2:	fd 4f       	sbci	r31, 0xFD	; 253
    33b4:	13 82       	std	Z+3, r1	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    33b6:	82 2f       	mov	r24, r18
    33b8:	64 e0       	ldi	r22, 0x04	; 4
    33ba:	41 e1       	ldi	r20, 0x11	; 17
    33bc:	20 e0       	ldi	r18, 0x00	; 0
    33be:	0e 94 a1 22 	call	0x4542	; 0x4542 <PutMidiMessageInOutgoingFifo>
						}										
						
						UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    33c2:	80 91 2e 01 	lds	r24, 0x012E
    33c6:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UpdateAdjustedSampleAddresses>
    33ca:	94 c2       	rjmp	.+1320   	; 0x38f4 <DoSampler+0x9b0>
					}
				}			
				else
				{
					if(newKeys&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    33cc:	80 ff       	sbrs	r24, 0
    33ce:	17 c0       	rjmp	.+46     	; 0x33fe <DoSampler+0x4ba>
					{
						bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    33d0:	80 91 2e 01 	lds	r24, 0x012E
    33d4:	20 91 45 01 	lds	r18, 0x0145
    33d8:	48 2f       	mov	r20, r24
    33da:	50 e0       	ldi	r21, 0x00	; 0
    33dc:	fa 01       	movw	r30, r20
    33de:	b5 e0       	ldi	r27, 0x05	; 5
    33e0:	ee 0f       	add	r30, r30
    33e2:	ff 1f       	adc	r31, r31
    33e4:	ba 95       	dec	r27
    33e6:	e1 f7       	brne	.-8      	; 0x33e0 <DoSampler+0x49c>
    33e8:	44 0f       	add	r20, r20
    33ea:	55 1f       	adc	r21, r21
    33ec:	e4 0f       	add	r30, r20
    33ee:	f5 1f       	adc	r31, r21
    33f0:	e7 53       	subi	r30, 0x37	; 55
    33f2:	fd 4f       	sbci	r31, 0xFD	; 253
    33f4:	27 83       	std	Z+7, r18	; 0x07
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    33f6:	64 e0       	ldi	r22, 0x04	; 4
    33f8:	43 e1       	ldi	r20, 0x13	; 19
    33fa:	0e 94 a1 22 	call	0x4542	; 0x4542 <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_1)		// Switch 1 sends granular data.
    33fe:	80 91 3f 01 	lds	r24, 0x013F
    3402:	81 ff       	sbrs	r24, 1
    3404:	10 c0       	rjmp	.+32     	; 0x3426 <DoSampler+0x4e2>
					{
						MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.	
    3406:	60 91 44 01 	lds	r22, 0x0144
    340a:	66 95       	lsr	r22
    340c:	80 91 2e 01 	lds	r24, 0x012E
    3410:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <MakeNewGranularArray>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    3414:	20 91 44 01 	lds	r18, 0x0144
    3418:	26 95       	lsr	r18
    341a:	80 91 2e 01 	lds	r24, 0x012E
    341e:	64 e0       	ldi	r22, 0x04	; 4
    3420:	44 e1       	ldi	r20, 0x14	; 20
    3422:	0e 94 a1 22 	call	0x4542	; 0x4542 <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_2)		// Switch 2 assigns our different ways of combining audio channels on the output.
    3426:	80 91 3f 01 	lds	r24, 0x013F
    342a:	82 ff       	sbrs	r24, 2
    342c:	63 c2       	rjmp	.+1222   	; 0x38f4 <DoSampler+0x9b0>
					{
						switch(scaledEncoderValue)
    342e:	20 91 45 01 	lds	r18, 0x0145
    3432:	21 30       	cpi	r18, 0x01	; 1
    3434:	99 f0       	breq	.+38     	; 0x345c <DoSampler+0x518>
    3436:	21 30       	cpi	r18, 0x01	; 1
    3438:	30 f0       	brcs	.+12     	; 0x3446 <DoSampler+0x502>
    343a:	22 30       	cpi	r18, 0x02	; 2
    343c:	d9 f0       	breq	.+54     	; 0x3474 <DoSampler+0x530>
    343e:	23 30       	cpi	r18, 0x03	; 3
    3440:	09 f0       	breq	.+2      	; 0x3444 <DoSampler+0x500>
    3442:	58 c2       	rjmp	.+1200   	; 0x38f4 <DoSampler+0x9b0>
    3444:	23 c0       	rjmp	.+70     	; 0x348c <DoSampler+0x548>
						{
							case 0:
							UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3446:	81 e5       	ldi	r24, 0x51	; 81
    3448:	98 e0       	ldi	r25, 0x08	; 8
    344a:	90 93 c6 02 	sts	0x02C6, r25
    344e:	80 93 c5 02 	sts	0x02C5, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3452:	80 91 2e 01 	lds	r24, 0x012E
    3456:	64 e0       	ldi	r22, 0x04	; 4
    3458:	46 e1       	ldi	r20, 0x16	; 22
    345a:	db c1       	rjmp	.+950    	; 0x3812 <DoSampler+0x8ce>
							break;

							case 1:
							UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    345c:	87 e0       	ldi	r24, 0x07	; 7
    345e:	98 e0       	ldi	r25, 0x08	; 8
    3460:	90 93 c6 02 	sts	0x02C6, r25
    3464:	80 93 c5 02 	sts	0x02C5, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3468:	80 91 2e 01 	lds	r24, 0x012E
    346c:	64 e0       	ldi	r22, 0x04	; 4
    346e:	46 e1       	ldi	r20, 0x16	; 22
    3470:	21 e0       	ldi	r18, 0x01	; 1
    3472:	cf c1       	rjmp	.+926    	; 0x3812 <DoSampler+0x8ce>
							break;
							
							case 2:
							UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3474:	85 ec       	ldi	r24, 0xC5	; 197
    3476:	98 e0       	ldi	r25, 0x08	; 8
    3478:	90 93 c6 02 	sts	0x02C6, r25
    347c:	80 93 c5 02 	sts	0x02C5, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3480:	80 91 2e 01 	lds	r24, 0x012E
    3484:	64 e0       	ldi	r22, 0x04	; 4
    3486:	46 e1       	ldi	r20, 0x16	; 22
    3488:	22 e0       	ldi	r18, 0x02	; 2
    348a:	c3 c1       	rjmp	.+902    	; 0x3812 <DoSampler+0x8ce>
							break;
							
							case 3:
							UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    348c:	86 e8       	ldi	r24, 0x86	; 134
    348e:	98 e0       	ldi	r25, 0x08	; 8
    3490:	90 93 c6 02 	sts	0x02C6, r25
    3494:	80 93 c5 02 	sts	0x02C5, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3498:	80 91 2e 01 	lds	r24, 0x012E
    349c:	64 e0       	ldi	r22, 0x04	; 4
    349e:	46 e1       	ldi	r20, 0x16	; 22
    34a0:	23 e0       	ldi	r18, 0x03	; 3
    34a2:	b7 c1       	rjmp	.+878    	; 0x3812 <DoSampler+0x8ce>
					}
				}
			}
			else
			{
				if(newKeys&Im_REC)										// Record switch pressed.
    34a4:	80 91 3f 01 	lds	r24, 0x013F
    34a8:	90 e0       	ldi	r25, 0x00	; 0
    34aa:	80 ff       	sbrs	r24, 0
    34ac:	24 c0       	rjmp	.+72     	; 0x34f6 <DoSampler+0x5b2>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    34ae:	20 91 2e 01 	lds	r18, 0x012E
    34b2:	82 2f       	mov	r24, r18
    34b4:	fc 01       	movw	r30, r24
    34b6:	75 e0       	ldi	r23, 0x05	; 5
    34b8:	ee 0f       	add	r30, r30
    34ba:	ff 1f       	adc	r31, r31
    34bc:	7a 95       	dec	r23
    34be:	e1 f7       	brne	.-8      	; 0x34b8 <DoSampler+0x574>
    34c0:	88 0f       	add	r24, r24
    34c2:	99 1f       	adc	r25, r25
    34c4:	e8 0f       	add	r30, r24
    34c6:	f9 1f       	adc	r31, r25
    34c8:	e7 53       	subi	r30, 0x37	; 55
    34ca:	fd 4f       	sbci	r31, 0xFD	; 253
    34cc:	80 81       	ld	r24, Z
    34ce:	83 30       	cpi	r24, 0x03	; 3
    34d0:	39 f4       	brne	.+14     	; 0x34e0 <DoSampler+0x59c>
					{
						StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    34d2:	82 2f       	mov	r24, r18
    34d4:	61 e0       	ldi	r22, 0x01	; 1
    34d6:	40 e0       	ldi	r20, 0x00	; 0
    34d8:	50 e0       	ldi	r21, 0x00	; 0
    34da:	0e 94 28 0c 	call	0x1850	; 0x1850 <StartPlayback>
    34de:	dc c0       	rjmp	.+440    	; 0x3698 <DoSampler+0x754>
						bankStates[currentBank].loopOnce=false;
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
					}
					else											// We're not recording right now, so start doing it.
					{
						StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    34e0:	82 2f       	mov	r24, r18
    34e2:	61 e0       	ldi	r22, 0x01	; 1
    34e4:	40 e0       	ldi	r20, 0x00	; 0
    34e6:	50 e0       	ldi	r21, 0x00	; 0
    34e8:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <StartRecording>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    34ec:	80 91 2e 01 	lds	r24, 0x012E
    34f0:	64 e0       	ldi	r22, 0x04	; 4
    34f2:	43 e0       	ldi	r20, 0x03	; 3
    34f4:	76 c0       	rjmp	.+236    	; 0x35e2 <DoSampler+0x69e>
					}
				}

				else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    34f6:	81 ff       	sbrs	r24, 1
    34f8:	76 c0       	rjmp	.+236    	; 0x35e6 <DoSampler+0x6a2>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    34fa:	60 91 2e 01 	lds	r22, 0x012E
    34fe:	86 2f       	mov	r24, r22
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	fc 01       	movw	r30, r24
    3504:	55 e0       	ldi	r21, 0x05	; 5
    3506:	ee 0f       	add	r30, r30
    3508:	ff 1f       	adc	r31, r31
    350a:	5a 95       	dec	r21
    350c:	e1 f7       	brne	.-8      	; 0x3506 <DoSampler+0x5c2>
    350e:	88 0f       	add	r24, r24
    3510:	99 1f       	adc	r25, r25
    3512:	e8 0f       	add	r30, r24
    3514:	f9 1f       	adc	r31, r25
    3516:	e7 53       	subi	r30, 0x37	; 55
    3518:	fd 4f       	sbci	r31, 0xFD	; 253
    351a:	80 81       	ld	r24, Z
    351c:	85 30       	cpi	r24, 0x05	; 5
    351e:	69 f5       	brne	.+90     	; 0x357a <DoSampler+0x636>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3520:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    3522:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    3524:	86 2f       	mov	r24, r22
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	fc 01       	movw	r30, r24
    352a:	35 e0       	ldi	r19, 0x05	; 5
    352c:	ee 0f       	add	r30, r30
    352e:	ff 1f       	adc	r31, r31
    3530:	3a 95       	dec	r19
    3532:	e1 f7       	brne	.-8      	; 0x352c <DoSampler+0x5e8>
    3534:	88 0f       	add	r24, r24
    3536:	99 1f       	adc	r25, r25
    3538:	e8 0f       	add	r30, r24
    353a:	f9 1f       	adc	r31, r25
    353c:	e7 53       	subi	r30, 0x37	; 55
    353e:	fd 4f       	sbci	r31, 0xFD	; 253
    3540:	84 e0       	ldi	r24, 0x04	; 4
    3542:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    3544:	86 2f       	mov	r24, r22
    3546:	61 e0       	ldi	r22, 0x01	; 1
    3548:	40 e0       	ldi	r20, 0x00	; 0
    354a:	50 e0       	ldi	r21, 0x00	; 0
    354c:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    3550:	1f bf       	out	0x3f, r17	; 63
				else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
				{
					if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
					{
						ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
						bankStates[currentBank].loopOnce=false;
    3552:	80 91 2e 01 	lds	r24, 0x012E
    3556:	28 2f       	mov	r18, r24
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	f9 01       	movw	r30, r18
    355c:	95 e0       	ldi	r25, 0x05	; 5
    355e:	ee 0f       	add	r30, r30
    3560:	ff 1f       	adc	r31, r31
    3562:	9a 95       	dec	r25
    3564:	e1 f7       	brne	.-8      	; 0x355e <DoSampler+0x61a>
    3566:	22 0f       	add	r18, r18
    3568:	33 1f       	adc	r19, r19
    356a:	e2 0f       	add	r30, r18
    356c:	f3 1f       	adc	r31, r19
    356e:	e7 53       	subi	r30, 0x37	; 55
    3570:	fd 4f       	sbci	r31, 0xFD	; 253
    3572:	11 82       	std	Z+1, r1	; 0x01
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    3574:	64 e0       	ldi	r22, 0x04	; 4
    3576:	49 e0       	ldi	r20, 0x09	; 9
    3578:	c5 c0       	rjmp	.+394    	; 0x3704 <DoSampler+0x7c0>
					}
					else							// We're not recording right now, so start doing it.
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    357a:	86 2f       	mov	r24, r22
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	fc 01       	movw	r30, r24
    3580:	15 e0       	ldi	r17, 0x05	; 5
    3582:	ee 0f       	add	r30, r30
    3584:	ff 1f       	adc	r31, r31
    3586:	1a 95       	dec	r17
    3588:	e1 f7       	brne	.-8      	; 0x3582 <DoSampler+0x63e>
    358a:	88 0f       	add	r24, r24
    358c:	99 1f       	adc	r25, r25
    358e:	e8 0f       	add	r30, r24
    3590:	f9 1f       	adc	r31, r25
    3592:	e7 53       	subi	r30, 0x37	; 55
    3594:	fd 4f       	sbci	r31, 0xFD	; 253
    3596:	27 85       	ldd	r18, Z+15	; 0x0f
    3598:	30 89       	ldd	r19, Z+16	; 0x10
    359a:	41 89       	ldd	r20, Z+17	; 0x11
    359c:	52 89       	ldd	r21, Z+18	; 0x12
    359e:	86 2f       	mov	r24, r22
    35a0:	90 e0       	ldi	r25, 0x00	; 0
    35a2:	fc 01       	movw	r30, r24
    35a4:	a5 e0       	ldi	r26, 0x05	; 5
    35a6:	ee 0f       	add	r30, r30
    35a8:	ff 1f       	adc	r31, r31
    35aa:	aa 95       	dec	r26
    35ac:	e1 f7       	brne	.-8      	; 0x35a6 <DoSampler+0x662>
    35ae:	88 0f       	add	r24, r24
    35b0:	99 1f       	adc	r25, r25
    35b2:	e8 0f       	add	r30, r24
    35b4:	f9 1f       	adc	r31, r25
    35b6:	e7 53       	subi	r30, 0x37	; 55
    35b8:	fd 4f       	sbci	r31, 0xFD	; 253
    35ba:	83 85       	ldd	r24, Z+11	; 0x0b
    35bc:	94 85       	ldd	r25, Z+12	; 0x0c
    35be:	a5 85       	ldd	r26, Z+13	; 0x0d
    35c0:	b6 85       	ldd	r27, Z+14	; 0x0e
    35c2:	28 17       	cp	r18, r24
    35c4:	39 07       	cpc	r19, r25
    35c6:	4a 07       	cpc	r20, r26
    35c8:	5b 07       	cpc	r21, r27
    35ca:	09 f4       	brne	.+2      	; 0x35ce <DoSampler+0x68a>
    35cc:	93 c1       	rjmp	.+806    	; 0x38f4 <DoSampler+0x9b0>
						{
							StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    35ce:	86 2f       	mov	r24, r22
    35d0:	61 e0       	ldi	r22, 0x01	; 1
    35d2:	40 e0       	ldi	r20, 0x00	; 0
    35d4:	50 e0       	ldi	r21, 0x00	; 0
    35d6:	0e 94 c3 0c 	call	0x1986	; 0x1986 <StartOverdub>
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    35da:	80 91 2e 01 	lds	r24, 0x012E
    35de:	64 e0       	ldi	r22, 0x04	; 4
    35e0:	49 e0       	ldi	r20, 0x09	; 9
    35e2:	20 e3       	ldi	r18, 0x30	; 48
    35e4:	16 c1       	rjmp	.+556    	; 0x3812 <DoSampler+0x8ce>
						}
					}
				}
				else if(newKeys&Im_PLAY_PAUSE)		// Play / Pause switch pressed.  If anything is happening this will stop it.  Otherwise, this will start playing back AS A LOOP.  This will not restart a playing sample from the beginning.
    35e6:	82 ff       	sbrs	r24, 2
    35e8:	8f c0       	rjmp	.+286    	; 0x3708 <DoSampler+0x7c4>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    35ea:	60 91 2e 01 	lds	r22, 0x012E
    35ee:	86 2f       	mov	r24, r22
    35f0:	90 e0       	ldi	r25, 0x00	; 0
    35f2:	fc 01       	movw	r30, r24
    35f4:	55 e0       	ldi	r21, 0x05	; 5
    35f6:	ee 0f       	add	r30, r30
    35f8:	ff 1f       	adc	r31, r31
    35fa:	5a 95       	dec	r21
    35fc:	e1 f7       	brne	.-8      	; 0x35f6 <DoSampler+0x6b2>
    35fe:	88 0f       	add	r24, r24
    3600:	99 1f       	adc	r25, r25
    3602:	e8 0f       	add	r30, r24
    3604:	f9 1f       	adc	r31, r25
    3606:	e7 53       	subi	r30, 0x37	; 55
    3608:	fd 4f       	sbci	r31, 0xFD	; 253
    360a:	80 81       	ld	r24, Z
    360c:	88 23       	and	r24, r24
    360e:	09 f0       	breq	.+2      	; 0x3612 <DoSampler+0x6ce>
    3610:	58 c0       	rjmp	.+176    	; 0x36c2 <DoSampler+0x77e>
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    3612:	86 2f       	mov	r24, r22
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	fc 01       	movw	r30, r24
    3618:	35 e0       	ldi	r19, 0x05	; 5
    361a:	ee 0f       	add	r30, r30
    361c:	ff 1f       	adc	r31, r31
    361e:	3a 95       	dec	r19
    3620:	e1 f7       	brne	.-8      	; 0x361a <DoSampler+0x6d6>
    3622:	88 0f       	add	r24, r24
    3624:	99 1f       	adc	r25, r25
    3626:	e8 0f       	add	r30, r24
    3628:	f9 1f       	adc	r31, r25
    362a:	e7 53       	subi	r30, 0x37	; 55
    362c:	fd 4f       	sbci	r31, 0xFD	; 253
    362e:	27 85       	ldd	r18, Z+15	; 0x0f
    3630:	30 89       	ldd	r19, Z+16	; 0x10
    3632:	41 89       	ldd	r20, Z+17	; 0x11
    3634:	52 89       	ldd	r21, Z+18	; 0x12
    3636:	86 2f       	mov	r24, r22
    3638:	90 e0       	ldi	r25, 0x00	; 0
    363a:	fc 01       	movw	r30, r24
    363c:	05 e0       	ldi	r16, 0x05	; 5
    363e:	ee 0f       	add	r30, r30
    3640:	ff 1f       	adc	r31, r31
    3642:	0a 95       	dec	r16
    3644:	e1 f7       	brne	.-8      	; 0x363e <DoSampler+0x6fa>
    3646:	88 0f       	add	r24, r24
    3648:	99 1f       	adc	r25, r25
    364a:	e8 0f       	add	r30, r24
    364c:	f9 1f       	adc	r31, r25
    364e:	e7 53       	subi	r30, 0x37	; 55
    3650:	fd 4f       	sbci	r31, 0xFD	; 253
    3652:	83 85       	ldd	r24, Z+11	; 0x0b
    3654:	94 85       	ldd	r25, Z+12	; 0x0c
    3656:	a5 85       	ldd	r26, Z+13	; 0x0d
    3658:	b6 85       	ldd	r27, Z+14	; 0x0e
    365a:	28 17       	cp	r18, r24
    365c:	39 07       	cpc	r19, r25
    365e:	4a 07       	cpc	r20, r26
    3660:	5b 07       	cpc	r21, r27
    3662:	09 f4       	brne	.+2      	; 0x3666 <DoSampler+0x722>
    3664:	47 c1       	rjmp	.+654    	; 0x38f4 <DoSampler+0x9b0>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3666:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    3668:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    366a:	86 2f       	mov	r24, r22
    366c:	90 e0       	ldi	r25, 0x00	; 0
    366e:	fc 01       	movw	r30, r24
    3670:	b5 e0       	ldi	r27, 0x05	; 5
    3672:	ee 0f       	add	r30, r30
    3674:	ff 1f       	adc	r31, r31
    3676:	ba 95       	dec	r27
    3678:	e1 f7       	brne	.-8      	; 0x3672 <DoSampler+0x72e>
    367a:	88 0f       	add	r24, r24
    367c:	99 1f       	adc	r25, r25
    367e:	e8 0f       	add	r30, r24
    3680:	f9 1f       	adc	r31, r25
    3682:	e7 53       	subi	r30, 0x37	; 55
    3684:	fd 4f       	sbci	r31, 0xFD	; 253
    3686:	84 e0       	ldi	r24, 0x04	; 4
    3688:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    368a:	86 2f       	mov	r24, r22
    368c:	61 e0       	ldi	r22, 0x01	; 1
    368e:	40 e0       	ldi	r20, 0x00	; 0
    3690:	50 e0       	ldi	r21, 0x00	; 0
    3692:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    3696:	1f bf       	out	0x3f, r17	; 63
					if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
						{
							ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
							bankStates[currentBank].loopOnce=false;
    3698:	80 91 2e 01 	lds	r24, 0x012E
    369c:	28 2f       	mov	r18, r24
    369e:	30 e0       	ldi	r19, 0x00	; 0
    36a0:	f9 01       	movw	r30, r18
    36a2:	75 e0       	ldi	r23, 0x05	; 5
    36a4:	ee 0f       	add	r30, r30
    36a6:	ff 1f       	adc	r31, r31
    36a8:	7a 95       	dec	r23
    36aa:	e1 f7       	brne	.-8      	; 0x36a4 <DoSampler+0x760>
    36ac:	22 0f       	add	r18, r18
    36ae:	33 1f       	adc	r19, r19
    36b0:	e2 0f       	add	r30, r18
    36b2:	f3 1f       	adc	r31, r19
    36b4:	e7 53       	subi	r30, 0x37	; 55
    36b6:	fd 4f       	sbci	r31, 0xFD	; 253
    36b8:	11 82       	std	Z+1, r1	; 0x01
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    36ba:	61 e0       	ldi	r22, 0x01	; 1
    36bc:	40 e3       	ldi	r20, 0x30	; 48
    36be:	20 e4       	ldi	r18, 0x40	; 64
    36c0:	a8 c0       	rjmp	.+336    	; 0x3812 <DoSampler+0x8ce>
						}
					}
					else		// Pause whatever we were doing.
					{
						bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    36c2:	86 2f       	mov	r24, r22
    36c4:	90 e0       	ldi	r25, 0x00	; 0
    36c6:	fc 01       	movw	r30, r24
    36c8:	55 e0       	ldi	r21, 0x05	; 5
    36ca:	ee 0f       	add	r30, r30
    36cc:	ff 1f       	adc	r31, r31
    36ce:	5a 95       	dec	r21
    36d0:	e1 f7       	brne	.-8      	; 0x36ca <DoSampler+0x786>
    36d2:	88 0f       	add	r24, r24
    36d4:	99 1f       	adc	r25, r25
    36d6:	e8 0f       	add	r30, r24
    36d8:	f9 1f       	adc	r31, r25
    36da:	e7 53       	subi	r30, 0x37	; 55
    36dc:	fd 4f       	sbci	r31, 0xFD	; 253
    36de:	10 82       	st	Z, r1
						bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    36e0:	86 2f       	mov	r24, r22
    36e2:	90 e0       	ldi	r25, 0x00	; 0
    36e4:	fc 01       	movw	r30, r24
    36e6:	35 e0       	ldi	r19, 0x05	; 5
    36e8:	ee 0f       	add	r30, r30
    36ea:	ff 1f       	adc	r31, r31
    36ec:	3a 95       	dec	r19
    36ee:	e1 f7       	brne	.-8      	; 0x36e8 <DoSampler+0x7a4>
    36f0:	88 0f       	add	r24, r24
    36f2:	99 1f       	adc	r25, r25
    36f4:	e8 0f       	add	r30, r24
    36f6:	f9 1f       	adc	r31, r25
    36f8:	e7 53       	subi	r30, 0x37	; 55
    36fa:	fd 4f       	sbci	r31, 0xFD	; 253
    36fc:	10 86       	std	Z+8, r1	; 0x08
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    36fe:	86 2f       	mov	r24, r22
    3700:	62 e0       	ldi	r22, 0x02	; 2
    3702:	40 e3       	ldi	r20, 0x30	; 48
    3704:	20 e0       	ldi	r18, 0x00	; 0
    3706:	85 c0       	rjmp	.+266    	; 0x3812 <DoSampler+0x8ce>
					}

				}
				else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    3708:	83 ff       	sbrs	r24, 3
    370a:	44 c0       	rjmp	.+136    	; 0x3794 <DoSampler+0x850>
				{
					if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    370c:	60 91 2e 01 	lds	r22, 0x012E
    3710:	86 2f       	mov	r24, r22
    3712:	90 e0       	ldi	r25, 0x00	; 0
    3714:	fc 01       	movw	r30, r24
    3716:	05 e0       	ldi	r16, 0x05	; 5
    3718:	ee 0f       	add	r30, r30
    371a:	ff 1f       	adc	r31, r31
    371c:	0a 95       	dec	r16
    371e:	e1 f7       	brne	.-8      	; 0x3718 <DoSampler+0x7d4>
    3720:	88 0f       	add	r24, r24
    3722:	99 1f       	adc	r25, r25
    3724:	e8 0f       	add	r30, r24
    3726:	f9 1f       	adc	r31, r25
    3728:	e7 53       	subi	r30, 0x37	; 55
    372a:	fd 4f       	sbci	r31, 0xFD	; 253
    372c:	27 85       	ldd	r18, Z+15	; 0x0f
    372e:	30 89       	ldd	r19, Z+16	; 0x10
    3730:	41 89       	ldd	r20, Z+17	; 0x11
    3732:	52 89       	ldd	r21, Z+18	; 0x12
    3734:	86 2f       	mov	r24, r22
    3736:	90 e0       	ldi	r25, 0x00	; 0
    3738:	fc 01       	movw	r30, r24
    373a:	a5 e0       	ldi	r26, 0x05	; 5
    373c:	ee 0f       	add	r30, r30
    373e:	ff 1f       	adc	r31, r31
    3740:	aa 95       	dec	r26
    3742:	e1 f7       	brne	.-8      	; 0x373c <DoSampler+0x7f8>
    3744:	88 0f       	add	r24, r24
    3746:	99 1f       	adc	r25, r25
    3748:	e8 0f       	add	r30, r24
    374a:	f9 1f       	adc	r31, r25
    374c:	e7 53       	subi	r30, 0x37	; 55
    374e:	fd 4f       	sbci	r31, 0xFD	; 253
    3750:	83 85       	ldd	r24, Z+11	; 0x0b
    3752:	94 85       	ldd	r25, Z+12	; 0x0c
    3754:	a5 85       	ldd	r26, Z+13	; 0x0d
    3756:	b6 85       	ldd	r27, Z+14	; 0x0e
    3758:	28 17       	cp	r18, r24
    375a:	39 07       	cpc	r19, r25
    375c:	4a 07       	cpc	r20, r26
    375e:	5b 07       	cpc	r21, r27
    3760:	09 f4       	brne	.+2      	; 0x3764 <DoSampler+0x820>
    3762:	c8 c0       	rjmp	.+400    	; 0x38f4 <DoSampler+0x9b0>
					{
						StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    3764:	86 2f       	mov	r24, r22
    3766:	61 e0       	ldi	r22, 0x01	; 1
    3768:	40 e0       	ldi	r20, 0x00	; 0
    376a:	50 e0       	ldi	r21, 0x00	; 0
    376c:	0e 94 28 0c 	call	0x1850	; 0x1850 <StartPlayback>
						bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    3770:	80 91 2e 01 	lds	r24, 0x012E
    3774:	28 2f       	mov	r18, r24
    3776:	30 e0       	ldi	r19, 0x00	; 0
    3778:	f9 01       	movw	r30, r18
    377a:	95 e0       	ldi	r25, 0x05	; 5
    377c:	ee 0f       	add	r30, r30
    377e:	ff 1f       	adc	r31, r31
    3780:	9a 95       	dec	r25
    3782:	e1 f7       	brne	.-8      	; 0x377c <DoSampler+0x838>
    3784:	22 0f       	add	r18, r18
    3786:	33 1f       	adc	r19, r19
    3788:	e2 0f       	add	r30, r18
    378a:	f3 1f       	adc	r31, r19
    378c:	e7 53       	subi	r30, 0x37	; 55
    378e:	fd 4f       	sbci	r31, 0xFD	; 253
    3790:	11 83       	std	Z+1, r17	; 0x01
    3792:	93 cf       	rjmp	.-218    	; 0x36ba <DoSampler+0x776>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
					}				
				}
				else if(newKeys&Im_BANK)		// Increment through banks when this button is pressed.
    3794:	84 ff       	sbrs	r24, 4
    3796:	ae c0       	rjmp	.+348    	; 0x38f4 <DoSampler+0x9b0>
				{
					currentBank++;
    3798:	80 91 2e 01 	lds	r24, 0x012E
    379c:	8f 5f       	subi	r24, 0xFF	; 255
    379e:	80 93 2e 01 	sts	0x012E, r24
					if(currentBank>=NUM_BANKS)
    37a2:	82 30       	cpi	r24, 0x02	; 2
    37a4:	08 f4       	brcc	.+2      	; 0x37a8 <DoSampler+0x864>
    37a6:	a6 c0       	rjmp	.+332    	; 0x38f4 <DoSampler+0x9b0>
					{
						currentBank=BANK_0;		// Loop around.
    37a8:	10 92 2e 01 	sts	0x012E, r1
    37ac:	a3 c0       	rjmp	.+326    	; 0x38f4 <DoSampler+0x9b0>
				}
			}
		}
		else	// In edit mode.
		{
			if(keyState&Im_SWITCH_0)		// Adjust start (three button combo)
    37ae:	89 2f       	mov	r24, r25
    37b0:	90 e0       	ldi	r25, 0x00	; 0
    37b2:	80 ff       	sbrs	r24, 0
    37b4:	31 c0       	rjmp	.+98     	; 0x3818 <DoSampler+0x8d4>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    37b6:	20 91 2e 01 	lds	r18, 0x012E
    37ba:	82 2f       	mov	r24, r18
    37bc:	fc 01       	movw	r30, r24
    37be:	15 e0       	ldi	r17, 0x05	; 5
    37c0:	ee 0f       	add	r30, r30
    37c2:	ff 1f       	adc	r31, r31
    37c4:	1a 95       	dec	r17
    37c6:	e1 f7       	brne	.-8      	; 0x37c0 <DoSampler+0x87c>
    37c8:	88 0f       	add	r24, r24
    37ca:	99 1f       	adc	r25, r25
    37cc:	e8 0f       	add	r30, r24
    37ce:	f9 1f       	adc	r31, r25
    37d0:	e7 53       	subi	r30, 0x37	; 55
    37d2:	fd 4f       	sbci	r31, 0xFD	; 253
    37d4:	83 8d       	ldd	r24, Z+27	; 0x1b
    37d6:	30 91 44 01 	lds	r19, 0x0144
    37da:	83 17       	cp	r24, r19
    37dc:	09 f4       	brne	.+2      	; 0x37e0 <DoSampler+0x89c>
    37de:	8a c0       	rjmp	.+276    	; 0x38f4 <DoSampler+0x9b0>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    37e0:	82 2f       	mov	r24, r18
    37e2:	90 e0       	ldi	r25, 0x00	; 0
    37e4:	fc 01       	movw	r30, r24
    37e6:	a5 e0       	ldi	r26, 0x05	; 5
    37e8:	ee 0f       	add	r30, r30
    37ea:	ff 1f       	adc	r31, r31
    37ec:	aa 95       	dec	r26
    37ee:	e1 f7       	brne	.-8      	; 0x37e8 <DoSampler+0x8a4>
    37f0:	88 0f       	add	r24, r24
    37f2:	99 1f       	adc	r25, r25
    37f4:	e8 0f       	add	r30, r24
    37f6:	f9 1f       	adc	r31, r25
    37f8:	e7 53       	subi	r30, 0x37	; 55
    37fa:	fd 4f       	sbci	r31, 0xFD	; 253
    37fc:	33 8f       	std	Z+27, r19	; 0x1b
	UpdateAdjustedSampleAddresses(theBank);
    37fe:	82 2f       	mov	r24, r18
    3800:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleStart(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,i);		// Send it out to the techno nerds.			
    3804:	20 91 44 01 	lds	r18, 0x0144
    3808:	26 95       	lsr	r18
    380a:	80 91 2e 01 	lds	r24, 0x012E
    380e:	64 e0       	ldi	r22, 0x04	; 4
    3810:	4c e1       	ldi	r20, 0x1C	; 28
    3812:	0e 94 a1 22 	call	0x4542	; 0x4542 <PutMidiMessageInOutgoingFifo>
    3816:	6e c0       	rjmp	.+220    	; 0x38f4 <DoSampler+0x9b0>
				}
			}
			else if(keyState&Im_SWITCH_1)		// Adjust end (three button combo)
    3818:	81 ff       	sbrs	r24, 1
    381a:	30 c0       	rjmp	.+96     	; 0x387c <DoSampler+0x938>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    381c:	20 91 2e 01 	lds	r18, 0x012E
    3820:	82 2f       	mov	r24, r18
    3822:	90 e0       	ldi	r25, 0x00	; 0
    3824:	fc 01       	movw	r30, r24
    3826:	65 e0       	ldi	r22, 0x05	; 5
    3828:	ee 0f       	add	r30, r30
    382a:	ff 1f       	adc	r31, r31
    382c:	6a 95       	dec	r22
    382e:	e1 f7       	brne	.-8      	; 0x3828 <DoSampler+0x8e4>
    3830:	88 0f       	add	r24, r24
    3832:	99 1f       	adc	r25, r25
    3834:	e8 0f       	add	r30, r24
    3836:	f9 1f       	adc	r31, r25
    3838:	e7 53       	subi	r30, 0x37	; 55
    383a:	fd 4f       	sbci	r31, 0xFD	; 253
    383c:	84 8d       	ldd	r24, Z+28	; 0x1c
    383e:	30 91 44 01 	lds	r19, 0x0144
    3842:	83 17       	cp	r24, r19
    3844:	09 f4       	brne	.+2      	; 0x3848 <DoSampler+0x904>
    3846:	56 c0       	rjmp	.+172    	; 0x38f4 <DoSampler+0x9b0>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3848:	82 2f       	mov	r24, r18
    384a:	90 e0       	ldi	r25, 0x00	; 0
    384c:	fc 01       	movw	r30, r24
    384e:	45 e0       	ldi	r20, 0x05	; 5
    3850:	ee 0f       	add	r30, r30
    3852:	ff 1f       	adc	r31, r31
    3854:	4a 95       	dec	r20
    3856:	e1 f7       	brne	.-8      	; 0x3850 <DoSampler+0x90c>
    3858:	88 0f       	add	r24, r24
    385a:	99 1f       	adc	r25, r25
    385c:	e8 0f       	add	r30, r24
    385e:	f9 1f       	adc	r31, r25
    3860:	e7 53       	subi	r30, 0x37	; 55
    3862:	fd 4f       	sbci	r31, 0xFD	; 253
    3864:	34 8f       	std	Z+28, r19	; 0x1c
	UpdateAdjustedSampleAddresses(theBank);
    3866:	82 2f       	mov	r24, r18
    3868:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleEnd(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,i);		// Send it out to the techno nerds.			
    386c:	20 91 44 01 	lds	r18, 0x0144
    3870:	26 95       	lsr	r18
    3872:	80 91 2e 01 	lds	r24, 0x012E
    3876:	64 e0       	ldi	r22, 0x04	; 4
    3878:	4d e1       	ldi	r20, 0x1D	; 29
    387a:	cb cf       	rjmp	.-106    	; 0x3812 <DoSampler+0x8ce>
				}
			}
			else if(keyState&Im_SWITCH_2)		// Adjust window (three button combo)
    387c:	82 ff       	sbrs	r24, 2
    387e:	2f c0       	rjmp	.+94     	; 0x38de <DoSampler+0x99a>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    3880:	20 91 2e 01 	lds	r18, 0x012E
    3884:	82 2f       	mov	r24, r18
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	fc 01       	movw	r30, r24
    388a:	15 e0       	ldi	r17, 0x05	; 5
    388c:	ee 0f       	add	r30, r30
    388e:	ff 1f       	adc	r31, r31
    3890:	1a 95       	dec	r17
    3892:	e1 f7       	brne	.-8      	; 0x388c <DoSampler+0x948>
    3894:	88 0f       	add	r24, r24
    3896:	99 1f       	adc	r25, r25
    3898:	e8 0f       	add	r30, r24
    389a:	f9 1f       	adc	r31, r25
    389c:	e7 53       	subi	r30, 0x37	; 55
    389e:	fd 4f       	sbci	r31, 0xFD	; 253
    38a0:	85 8d       	ldd	r24, Z+29	; 0x1d
    38a2:	30 91 44 01 	lds	r19, 0x0144
    38a6:	83 17       	cp	r24, r19
    38a8:	29 f1       	breq	.+74     	; 0x38f4 <DoSampler+0x9b0>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    38aa:	82 2f       	mov	r24, r18
    38ac:	90 e0       	ldi	r25, 0x00	; 0
    38ae:	fc 01       	movw	r30, r24
    38b0:	a5 e0       	ldi	r26, 0x05	; 5
    38b2:	ee 0f       	add	r30, r30
    38b4:	ff 1f       	adc	r31, r31
    38b6:	aa 95       	dec	r26
    38b8:	e1 f7       	brne	.-8      	; 0x38b2 <DoSampler+0x96e>
    38ba:	88 0f       	add	r24, r24
    38bc:	99 1f       	adc	r25, r25
    38be:	e8 0f       	add	r30, r24
    38c0:	f9 1f       	adc	r31, r25
    38c2:	e7 53       	subi	r30, 0x37	; 55
    38c4:	fd 4f       	sbci	r31, 0xFD	; 253
    38c6:	35 8f       	std	Z+29, r19	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    38c8:	82 2f       	mov	r24, r18
    38ca:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleWindow(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,i);		// Send it out to the techno nerds.			
    38ce:	20 91 44 01 	lds	r18, 0x0144
    38d2:	26 95       	lsr	r18
    38d4:	80 91 2e 01 	lds	r24, 0x012E
    38d8:	64 e0       	ldi	r22, 0x04	; 4
    38da:	4e e1       	ldi	r20, 0x1E	; 30
    38dc:	9a cf       	rjmp	.-204    	; 0x3812 <DoSampler+0x8ce>
				}
			}
			else if(newKeys&Im_SWITCH_3||newKeys&Im_SWITCH_4||newKeys&Im_SWITCH_5)	// Non edit-mode key hit, bail from edit mode.
    38de:	80 91 3f 01 	lds	r24, 0x013F
    38e2:	90 e0       	ldi	r25, 0x00	; 0
    38e4:	83 fd       	sbrc	r24, 3
    38e6:	04 c0       	rjmp	.+8      	; 0x38f0 <DoSampler+0x9ac>
    38e8:	80 73       	andi	r24, 0x30	; 48
    38ea:	90 70       	andi	r25, 0x00	; 0
    38ec:	89 2b       	or	r24, r25
    38ee:	11 f0       	breq	.+4      	; 0x38f4 <DoSampler+0x9b0>
			{
				editModeEntered=false;				
    38f0:	10 92 27 01 	sts	0x0127, r1
			}		
		}
		
// Dealt with Caveman inputs, now deal with MIDI.

		if(midiMessagesInIncomingFifo)
    38f4:	80 91 41 03 	lds	r24, 0x0341
    38f8:	88 23       	and	r24, r24
    38fa:	09 f4       	brne	.+2      	; 0x38fe <DoSampler+0x9ba>
    38fc:	1b c4       	rjmp	.+2102   	; 0x4134 <DoSampler+0x11f0>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    38fe:	8a e2       	ldi	r24, 0x2A	; 42
    3900:	91 e0       	ldi	r25, 0x01	; 1
    3902:	0e 94 47 22 	call	0x448e	; 0x448e <GetMidiMessageFromIncomingFifo>
			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
			{
				// Do this here.
			}
*/
			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    3906:	80 91 2b 01 	lds	r24, 0x012B
    390a:	82 30       	cpi	r24, 0x02	; 2
    390c:	89 f5       	brne	.+98     	; 0x3970 <DoSampler+0xa2c>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    390e:	80 91 2a 01 	lds	r24, 0x012A
    3912:	28 2f       	mov	r18, r24
    3914:	30 e0       	ldi	r19, 0x00	; 0
    3916:	f9 01       	movw	r30, r18
    3918:	ee 0f       	add	r30, r30
    391a:	ff 1f       	adc	r31, r31
    391c:	c9 01       	movw	r24, r18
    391e:	55 e0       	ldi	r21, 0x05	; 5
    3920:	88 0f       	add	r24, r24
    3922:	99 1f       	adc	r25, r25
    3924:	5a 95       	dec	r21
    3926:	e1 f7       	brne	.-8      	; 0x3920 <DoSampler+0x9dc>
    3928:	e8 0f       	add	r30, r24
    392a:	f9 1f       	adc	r31, r25
    392c:	e7 53       	subi	r30, 0x37	; 55
    392e:	fd 4f       	sbci	r31, 0xFD	; 253
    3930:	80 81       	ld	r24, Z
    3932:	84 30       	cpi	r24, 0x04	; 4
    3934:	21 f0       	breq	.+8      	; 0x393e <DoSampler+0x9fa>
    3936:	80 81       	ld	r24, Z
    3938:	82 30       	cpi	r24, 0x02	; 2
    393a:	09 f0       	breq	.+2      	; 0x393e <DoSampler+0x9fa>
    393c:	fb c3       	rjmp	.+2038   	; 0x4134 <DoSampler+0x11f0>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    393e:	f9 01       	movw	r30, r18
    3940:	ec 5f       	subi	r30, 0xFC	; 252
    3942:	fe 4f       	sbci	r31, 0xFE	; 254
    3944:	90 91 2c 01 	lds	r25, 0x012C
    3948:	80 81       	ld	r24, Z
    394a:	98 17       	cp	r25, r24
    394c:	09 f0       	breq	.+2      	; 0x3950 <DoSampler+0xa0c>
    394e:	f2 c3       	rjmp	.+2020   	; 0x4134 <DoSampler+0x11f0>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    3950:	f9 01       	movw	r30, r18
    3952:	45 e0       	ldi	r20, 0x05	; 5
    3954:	ee 0f       	add	r30, r30
    3956:	ff 1f       	adc	r31, r31
    3958:	4a 95       	dec	r20
    395a:	e1 f7       	brne	.-8      	; 0x3954 <DoSampler+0xa10>
    395c:	22 0f       	add	r18, r18
    395e:	33 1f       	adc	r19, r19
    3960:	e2 0f       	add	r30, r18
    3962:	f3 1f       	adc	r31, r19
    3964:	e7 53       	subi	r30, 0x37	; 55
    3966:	fd 4f       	sbci	r31, 0xFD	; 253
    3968:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
    396a:	80 91 2a 01 	lds	r24, 0x012A
    396e:	88 c0       	rjmp	.+272    	; 0x3a80 <DoSampler+0xb3c>
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    3970:	81 30       	cpi	r24, 0x01	; 1
    3972:	e1 f5       	brne	.+120    	; 0x39ec <DoSampler+0xaa8>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    3974:	10 91 2a 01 	lds	r17, 0x012A
    3978:	21 2f       	mov	r18, r17
    397a:	30 e0       	ldi	r19, 0x00	; 0
    397c:	f9 01       	movw	r30, r18
    397e:	ec 5f       	subi	r30, 0xFC	; 252
    3980:	fe 4f       	sbci	r31, 0xFE	; 254
    3982:	60 91 2c 01 	lds	r22, 0x012C
    3986:	60 83       	st	Z, r22

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
    3988:	f9 01       	movw	r30, r18
    398a:	e8 5d       	subi	r30, 0xD8	; 216
    398c:	fe 4f       	sbci	r31, 0xFE	; 254
    398e:	80 81       	ld	r24, Z
    3990:	88 23       	and	r24, r24
    3992:	49 f0       	breq	.+18     	; 0x39a6 <DoSampler+0xa62>
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.		
    3994:	86 2f       	mov	r24, r22
    3996:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    399a:	ac 01       	movw	r20, r24
    399c:	81 2f       	mov	r24, r17
    399e:	62 e0       	ldi	r22, 0x02	; 2
    39a0:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <StartRealtime>
    39a4:	c7 c3       	rjmp	.+1934   	; 0x4134 <DoSampler+0x11f0>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    39a6:	f9 01       	movw	r30, r18
    39a8:	85 e0       	ldi	r24, 0x05	; 5
    39aa:	ee 0f       	add	r30, r30
    39ac:	ff 1f       	adc	r31, r31
    39ae:	8a 95       	dec	r24
    39b0:	e1 f7       	brne	.-8      	; 0x39aa <DoSampler+0xa66>
    39b2:	22 0f       	add	r18, r18
    39b4:	33 1f       	adc	r19, r19
    39b6:	e2 0f       	add	r30, r18
    39b8:	f3 1f       	adc	r31, r19
    39ba:	e7 53       	subi	r30, 0x37	; 55
    39bc:	fd 4f       	sbci	r31, 0xFD	; 253
    39be:	27 85       	ldd	r18, Z+15	; 0x0f
    39c0:	30 89       	ldd	r19, Z+16	; 0x10
    39c2:	41 89       	ldd	r20, Z+17	; 0x11
    39c4:	52 89       	ldd	r21, Z+18	; 0x12
    39c6:	83 85       	ldd	r24, Z+11	; 0x0b
    39c8:	94 85       	ldd	r25, Z+12	; 0x0c
    39ca:	a5 85       	ldd	r26, Z+13	; 0x0d
    39cc:	b6 85       	ldd	r27, Z+14	; 0x0e
    39ce:	28 17       	cp	r18, r24
    39d0:	39 07       	cpc	r19, r25
    39d2:	4a 07       	cpc	r20, r26
    39d4:	5b 07       	cpc	r21, r27
    39d6:	09 f4       	brne	.+2      	; 0x39da <DoSampler+0xa96>
    39d8:	ad c3       	rjmp	.+1882   	; 0x4134 <DoSampler+0x11f0>
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    39da:	86 2f       	mov	r24, r22
    39dc:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    39e0:	ac 01       	movw	r20, r24
    39e2:	81 2f       	mov	r24, r17
    39e4:	62 e0       	ldi	r22, 0x02	; 2
    39e6:	0e 94 28 0c 	call	0x1850	; 0x1850 <StartPlayback>
    39ea:	a4 c3       	rjmp	.+1864   	; 0x4134 <DoSampler+0x11f0>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    39ec:	84 30       	cpi	r24, 0x04	; 4
    39ee:	09 f0       	breq	.+2      	; 0x39f2 <DoSampler+0xaae>
    39f0:	5c c3       	rjmp	.+1720   	; 0x40aa <DoSampler+0x1166>
			{
				switch(currentMidiMessage.dataByteOne)
    39f2:	80 91 2c 01 	lds	r24, 0x012C
    39f6:	90 e0       	ldi	r25, 0x00	; 0
    39f8:	fc 01       	movw	r30, r24
    39fa:	33 97       	sbiw	r30, 0x03	; 3
    39fc:	ec 31       	cpi	r30, 0x1C	; 28
    39fe:	f1 05       	cpc	r31, r1
    3a00:	08 f0       	brcs	.+2      	; 0x3a04 <DoSampler+0xac0>
    3a02:	98 c3       	rjmp	.+1840   	; 0x4134 <DoSampler+0x11f0>
    3a04:	e2 5c       	subi	r30, 0xC2	; 194
    3a06:	ff 4f       	sbci	r31, 0xFF	; 255
    3a08:	ee 0f       	add	r30, r30
    3a0a:	ff 1f       	adc	r31, r31
    3a0c:	05 90       	lpm	r0, Z+
    3a0e:	f4 91       	lpm	r31, Z+
    3a10:	e0 2d       	mov	r30, r0
    3a12:	09 94       	ijmp
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3a14:	80 91 2d 01 	lds	r24, 0x012D
    3a18:	88 23       	and	r24, r24
    3a1a:	71 f0       	breq	.+28     	; 0x3a38 <DoSampler+0xaf4>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    3a1c:	80 91 2a 01 	lds	r24, 0x012A
    3a20:	e8 2f       	mov	r30, r24
    3a22:	f0 e0       	ldi	r31, 0x00	; 0
    3a24:	ee 0f       	add	r30, r30
    3a26:	ff 1f       	adc	r31, r31
    3a28:	ec 55       	subi	r30, 0x5C	; 92
    3a2a:	fd 4f       	sbci	r31, 0xFD	; 253
    3a2c:	40 81       	ld	r20, Z
    3a2e:	51 81       	ldd	r21, Z+1	; 0x01
    3a30:	62 e0       	ldi	r22, 0x02	; 2
    3a32:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <StartRecording>
    3a36:	5e c0       	rjmp	.+188    	; 0x3af4 <DoSampler+0xbb0>
						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback after a recording.	
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    3a38:	20 91 2a 01 	lds	r18, 0x012A
    3a3c:	82 2f       	mov	r24, r18
    3a3e:	90 e0       	ldi	r25, 0x00	; 0
    3a40:	fc 01       	movw	r30, r24
    3a42:	b5 e0       	ldi	r27, 0x05	; 5
    3a44:	ee 0f       	add	r30, r30
    3a46:	ff 1f       	adc	r31, r31
    3a48:	ba 95       	dec	r27
    3a4a:	e1 f7       	brne	.-8      	; 0x3a44 <DoSampler+0xb00>
    3a4c:	88 0f       	add	r24, r24
    3a4e:	99 1f       	adc	r25, r25
    3a50:	e8 0f       	add	r30, r24
    3a52:	f9 1f       	adc	r31, r25
    3a54:	e7 53       	subi	r30, 0x37	; 55
    3a56:	fd 4f       	sbci	r31, 0xFD	; 253
    3a58:	80 81       	ld	r24, Z
    3a5a:	83 30       	cpi	r24, 0x03	; 3
    3a5c:	09 f0       	breq	.+2      	; 0x3a60 <DoSampler+0xb1c>
    3a5e:	6a c3       	rjmp	.+1748   	; 0x4134 <DoSampler+0x11f0>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    3a60:	82 2f       	mov	r24, r18
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	fc 01       	movw	r30, r24
    3a66:	75 e0       	ldi	r23, 0x05	; 5
    3a68:	ee 0f       	add	r30, r30
    3a6a:	ff 1f       	adc	r31, r31
    3a6c:	7a 95       	dec	r23
    3a6e:	e1 f7       	brne	.-8      	; 0x3a68 <DoSampler+0xb24>
    3a70:	88 0f       	add	r24, r24
    3a72:	99 1f       	adc	r25, r25
    3a74:	e8 0f       	add	r30, r24
    3a76:	f9 1f       	adc	r31, r25
    3a78:	e7 53       	subi	r30, 0x37	; 55
    3a7a:	fd 4f       	sbci	r31, 0xFD	; 253
    3a7c:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    3a7e:	82 2f       	mov	r24, r18
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	fc 01       	movw	r30, r24
    3a84:	55 e0       	ldi	r21, 0x05	; 5
    3a86:	ee 0f       	add	r30, r30
    3a88:	ff 1f       	adc	r31, r31
    3a8a:	5a 95       	dec	r21
    3a8c:	e1 f7       	brne	.-8      	; 0x3a86 <DoSampler+0xb42>
    3a8e:	88 0f       	add	r24, r24
    3a90:	99 1f       	adc	r25, r25
    3a92:	e8 0f       	add	r30, r24
    3a94:	f9 1f       	adc	r31, r25
    3a96:	e7 53       	subi	r30, 0x37	; 55
    3a98:	fd 4f       	sbci	r31, 0xFD	; 253
    3a9a:	10 86       	std	Z+8, r1	; 0x08
    3a9c:	4b c3       	rjmp	.+1686   	; 0x4134 <DoSampler+0x11f0>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3a9e:	80 91 2d 01 	lds	r24, 0x012D
    3aa2:	88 23       	and	r24, r24
    3aa4:	69 f1       	breq	.+90     	; 0x3b00 <DoSampler+0xbbc>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    3aa6:	60 91 2a 01 	lds	r22, 0x012A
    3aaa:	c6 2f       	mov	r28, r22
    3aac:	d0 e0       	ldi	r29, 0x00	; 0
    3aae:	fe 01       	movw	r30, r28
    3ab0:	ee 0f       	add	r30, r30
    3ab2:	ff 1f       	adc	r31, r31
    3ab4:	ce 01       	movw	r24, r28
    3ab6:	25 e0       	ldi	r18, 0x05	; 5
    3ab8:	88 0f       	add	r24, r24
    3aba:	99 1f       	adc	r25, r25
    3abc:	2a 95       	dec	r18
    3abe:	e1 f7       	brne	.-8      	; 0x3ab8 <DoSampler+0xb74>
    3ac0:	e8 0f       	add	r30, r24
    3ac2:	f9 1f       	adc	r31, r25
    3ac4:	e7 53       	subi	r30, 0x37	; 55
    3ac6:	fd 4f       	sbci	r31, 0xFD	; 253
    3ac8:	27 85       	ldd	r18, Z+15	; 0x0f
    3aca:	30 89       	ldd	r19, Z+16	; 0x10
    3acc:	41 89       	ldd	r20, Z+17	; 0x11
    3ace:	52 89       	ldd	r21, Z+18	; 0x12
    3ad0:	83 85       	ldd	r24, Z+11	; 0x0b
    3ad2:	94 85       	ldd	r25, Z+12	; 0x0c
    3ad4:	a5 85       	ldd	r26, Z+13	; 0x0d
    3ad6:	b6 85       	ldd	r27, Z+14	; 0x0e
    3ad8:	28 17       	cp	r18, r24
    3ada:	39 07       	cpc	r19, r25
    3adc:	4a 07       	cpc	r20, r26
    3ade:	5b 07       	cpc	r21, r27
    3ae0:	09 f4       	brne	.+2      	; 0x3ae4 <DoSampler+0xba0>
    3ae2:	28 c3       	rjmp	.+1616   	; 0x4134 <DoSampler+0x11f0>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    3ae4:	cc 5f       	subi	r28, 0xFC	; 252
    3ae6:	de 4f       	sbci	r29, 0xFE	; 254
    3ae8:	48 81       	ld	r20, Y
    3aea:	86 2f       	mov	r24, r22
    3aec:	62 e0       	ldi	r22, 0x02	; 2
    3aee:	50 e0       	ldi	r21, 0x00	; 0
    3af0:	0e 94 c3 0c 	call	0x1986	; 0x1986 <StartOverdub>
							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to playback after a recording.	
    3af4:	e0 91 2a 01 	lds	r30, 0x012A
    3af8:	f0 e0       	ldi	r31, 0x00	; 0
    3afa:	e8 5d       	subi	r30, 0xD8	; 216
    3afc:	fe 4f       	sbci	r31, 0xFE	; 254
    3afe:	ba c0       	rjmp	.+372    	; 0x3c74 <DoSampler+0xd30>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    3b00:	20 91 2a 01 	lds	r18, 0x012A
    3b04:	e2 2f       	mov	r30, r18
    3b06:	f0 e0       	ldi	r31, 0x00	; 0
    3b08:	df 01       	movw	r26, r30
    3b0a:	aa 0f       	add	r26, r26
    3b0c:	bb 1f       	adc	r27, r27
    3b0e:	cf 01       	movw	r24, r30
    3b10:	15 e0       	ldi	r17, 0x05	; 5
    3b12:	88 0f       	add	r24, r24
    3b14:	99 1f       	adc	r25, r25
    3b16:	1a 95       	dec	r17
    3b18:	e1 f7       	brne	.-8      	; 0x3b12 <DoSampler+0xbce>
    3b1a:	a8 0f       	add	r26, r24
    3b1c:	b9 1f       	adc	r27, r25
    3b1e:	a7 53       	subi	r26, 0x37	; 55
    3b20:	bd 4f       	sbci	r27, 0xFD	; 253
    3b22:	8c 91       	ld	r24, X
    3b24:	85 30       	cpi	r24, 0x05	; 5
    3b26:	09 f0       	breq	.+2      	; 0x3b2a <DoSampler+0xbe6>
    3b28:	05 c3       	rjmp	.+1546   	; 0x4134 <DoSampler+0x11f0>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    3b2a:	ec 5f       	subi	r30, 0xFC	; 252
    3b2c:	fe 4f       	sbci	r31, 0xFE	; 254
    3b2e:	40 81       	ld	r20, Z
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3b30:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    3b32:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    3b34:	84 e0       	ldi	r24, 0x04	; 4
    3b36:	8c 93       	st	X, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    3b38:	82 2f       	mov	r24, r18
    3b3a:	62 e0       	ldi	r22, 0x02	; 2
    3b3c:	50 e0       	ldi	r21, 0x00	; 0
    3b3e:	0e 94 fb 0a 	call	0x15f6	; 0x15f6 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    3b42:	1f bf       	out	0x3f, r17	; 63
    3b44:	f7 c2       	rjmp	.+1518   	; 0x4134 <DoSampler+0x11f0>
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3b46:	80 91 2d 01 	lds	r24, 0x012D
    3b4a:	88 23       	and	r24, r24
    3b4c:	99 f0       	breq	.+38     	; 0x3b74 <DoSampler+0xc30>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    3b4e:	80 91 2a 01 	lds	r24, 0x012A
    3b52:	e8 2f       	mov	r30, r24
    3b54:	f0 e0       	ldi	r31, 0x00	; 0
    3b56:	ee 0f       	add	r30, r30
    3b58:	ff 1f       	adc	r31, r31
    3b5a:	ec 55       	subi	r30, 0x5C	; 92
    3b5c:	fd 4f       	sbci	r31, 0xFD	; 253
    3b5e:	40 81       	ld	r20, Z
    3b60:	51 81       	ldd	r21, Z+1	; 0x01
    3b62:	62 e0       	ldi	r22, 0x02	; 2
    3b64:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <StartRealtime>
						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop realtime processing if we get a note off.
    3b68:	e0 91 2a 01 	lds	r30, 0x012A
    3b6c:	f0 e0       	ldi	r31, 0x00	; 0
    3b6e:	e8 5d       	subi	r30, 0xD8	; 216
    3b70:	fe 4f       	sbci	r31, 0xFE	; 254
    3b72:	6e c0       	rjmp	.+220    	; 0x3c50 <DoSampler+0xd0c>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    3b74:	20 91 2a 01 	lds	r18, 0x012A
    3b78:	82 2f       	mov	r24, r18
    3b7a:	90 e0       	ldi	r25, 0x00	; 0
    3b7c:	fc 01       	movw	r30, r24
    3b7e:	a5 e0       	ldi	r26, 0x05	; 5
    3b80:	ee 0f       	add	r30, r30
    3b82:	ff 1f       	adc	r31, r31
    3b84:	aa 95       	dec	r26
    3b86:	e1 f7       	brne	.-8      	; 0x3b80 <DoSampler+0xc3c>
    3b88:	88 0f       	add	r24, r24
    3b8a:	99 1f       	adc	r25, r25
    3b8c:	e8 0f       	add	r30, r24
    3b8e:	f9 1f       	adc	r31, r25
    3b90:	e7 53       	subi	r30, 0x37	; 55
    3b92:	fd 4f       	sbci	r31, 0xFD	; 253
    3b94:	80 81       	ld	r24, Z
    3b96:	82 30       	cpi	r24, 0x02	; 2
    3b98:	09 f0       	breq	.+2      	; 0x3b9c <DoSampler+0xc58>
    3b9a:	cc c2       	rjmp	.+1432   	; 0x4134 <DoSampler+0x11f0>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    3b9c:	82 2f       	mov	r24, r18
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	fc 01       	movw	r30, r24
    3ba2:	65 e0       	ldi	r22, 0x05	; 5
    3ba4:	ee 0f       	add	r30, r30
    3ba6:	ff 1f       	adc	r31, r31
    3ba8:	6a 95       	dec	r22
    3baa:	e1 f7       	brne	.-8      	; 0x3ba4 <DoSampler+0xc60>
    3bac:	88 0f       	add	r24, r24
    3bae:	99 1f       	adc	r25, r25
    3bb0:	e8 0f       	add	r30, r24
    3bb2:	f9 1f       	adc	r31, r25
    3bb4:	e7 53       	subi	r30, 0x37	; 55
    3bb6:	fd 4f       	sbci	r31, 0xFD	; 253
    3bb8:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    3bba:	82 2f       	mov	r24, r18
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	fc 01       	movw	r30, r24
    3bc0:	45 e0       	ldi	r20, 0x05	; 5
    3bc2:	ee 0f       	add	r30, r30
    3bc4:	ff 1f       	adc	r31, r31
    3bc6:	4a 95       	dec	r20
    3bc8:	e1 f7       	brne	.-8      	; 0x3bc2 <DoSampler+0xc7e>
    3bca:	88 0f       	add	r24, r24
    3bcc:	99 1f       	adc	r25, r25
    3bce:	e8 0f       	add	r30, r24
    3bd0:	f9 1f       	adc	r31, r25
    3bd2:	e7 53       	subi	r30, 0x37	; 55
    3bd4:	fd 4f       	sbci	r31, 0xFD	; 253
    3bd6:	10 86       	std	Z+8, r1	; 0x08
						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    3bd8:	e2 2f       	mov	r30, r18
    3bda:	8e cf       	rjmp	.-228    	; 0x3af8 <DoSampler+0xbb4>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    3bdc:	80 91 2d 01 	lds	r24, 0x012D
    3be0:	88 23       	and	r24, r24
    3be2:	89 f0       	breq	.+34     	; 0x3c06 <DoSampler+0xcc2>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    3be4:	80 91 2a 01 	lds	r24, 0x012A
    3be8:	90 e0       	ldi	r25, 0x00	; 0
    3bea:	fc 01       	movw	r30, r24
    3bec:	05 e0       	ldi	r16, 0x05	; 5
    3bee:	ee 0f       	add	r30, r30
    3bf0:	ff 1f       	adc	r31, r31
    3bf2:	0a 95       	dec	r16
    3bf4:	e1 f7       	brne	.-8      	; 0x3bee <DoSampler+0xcaa>
    3bf6:	88 0f       	add	r24, r24
    3bf8:	99 1f       	adc	r25, r25
    3bfa:	e8 0f       	add	r30, r24
    3bfc:	f9 1f       	adc	r31, r25
    3bfe:	e7 53       	subi	r30, 0x37	; 55
    3c00:	fd 4f       	sbci	r31, 0xFD	; 253
    3c02:	11 82       	std	Z+1, r1	; 0x01
    3c04:	97 c2       	rjmp	.+1326   	; 0x4134 <DoSampler+0x11f0>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    3c06:	80 91 2a 01 	lds	r24, 0x012A
    3c0a:	90 e0       	ldi	r25, 0x00	; 0
    3c0c:	fc 01       	movw	r30, r24
    3c0e:	b5 e0       	ldi	r27, 0x05	; 5
    3c10:	ee 0f       	add	r30, r30
    3c12:	ff 1f       	adc	r31, r31
    3c14:	ba 95       	dec	r27
    3c16:	e1 f7       	brne	.-8      	; 0x3c10 <DoSampler+0xccc>
    3c18:	88 0f       	add	r24, r24
    3c1a:	99 1f       	adc	r25, r25
    3c1c:	e8 0f       	add	r30, r24
    3c1e:	f9 1f       	adc	r31, r25
    3c20:	e7 53       	subi	r30, 0x37	; 55
    3c22:	fd 4f       	sbci	r31, 0xFD	; 253
    3c24:	81 e0       	ldi	r24, 0x01	; 1
    3c26:	81 83       	std	Z+1, r24	; 0x01
    3c28:	85 c2       	rjmp	.+1290   	; 0x4134 <DoSampler+0x11f0>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    3c2a:	80 91 2d 01 	lds	r24, 0x012D
    3c2e:	88 23       	and	r24, r24
    3c30:	91 f0       	breq	.+36     	; 0x3c56 <DoSampler+0xd12>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    3c32:	80 91 2a 01 	lds	r24, 0x012A
    3c36:	90 e0       	ldi	r25, 0x00	; 0
    3c38:	fc 01       	movw	r30, r24
    3c3a:	74 e0       	ldi	r23, 0x04	; 4
    3c3c:	ee 0f       	add	r30, r30
    3c3e:	ff 1f       	adc	r31, r31
    3c40:	7a 95       	dec	r23
    3c42:	e1 f7       	brne	.-8      	; 0x3c3c <DoSampler+0xcf8>
    3c44:	e8 0f       	add	r30, r24
    3c46:	f9 1f       	adc	r31, r25
    3c48:	ee 0f       	add	r30, r30
    3c4a:	ff 1f       	adc	r31, r31
    3c4c:	e5 53       	subi	r30, 0x35	; 53
    3c4e:	fd 4f       	sbci	r31, 0xFD	; 253
    3c50:	81 e0       	ldi	r24, 0x01	; 1
    3c52:	80 83       	st	Z, r24
    3c54:	6f c2       	rjmp	.+1246   	; 0x4134 <DoSampler+0x11f0>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3c56:	80 91 2a 01 	lds	r24, 0x012A
    3c5a:	90 e0       	ldi	r25, 0x00	; 0
    3c5c:	fc 01       	movw	r30, r24
    3c5e:	54 e0       	ldi	r21, 0x04	; 4
    3c60:	ee 0f       	add	r30, r30
    3c62:	ff 1f       	adc	r31, r31
    3c64:	5a 95       	dec	r21
    3c66:	e1 f7       	brne	.-8      	; 0x3c60 <DoSampler+0xd1c>
    3c68:	e8 0f       	add	r30, r24
    3c6a:	f9 1f       	adc	r31, r25
    3c6c:	ee 0f       	add	r30, r30
    3c6e:	ff 1f       	adc	r31, r31
    3c70:	e5 53       	subi	r30, 0x35	; 53
    3c72:	fd 4f       	sbci	r31, 0xFD	; 253
    3c74:	10 82       	st	Z, r1
    3c76:	5e c2       	rjmp	.+1212   	; 0x4134 <DoSampler+0x11f0>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    3c78:	80 91 2d 01 	lds	r24, 0x012D
    3c7c:	88 23       	and	r24, r24
    3c7e:	91 f0       	breq	.+36     	; 0x3ca4 <DoSampler+0xd60>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    3c80:	80 91 2a 01 	lds	r24, 0x012A
    3c84:	90 e0       	ldi	r25, 0x00	; 0
    3c86:	fc 01       	movw	r30, r24
    3c88:	35 e0       	ldi	r19, 0x05	; 5
    3c8a:	ee 0f       	add	r30, r30
    3c8c:	ff 1f       	adc	r31, r31
    3c8e:	3a 95       	dec	r19
    3c90:	e1 f7       	brne	.-8      	; 0x3c8a <DoSampler+0xd46>
    3c92:	88 0f       	add	r24, r24
    3c94:	99 1f       	adc	r25, r25
    3c96:	e8 0f       	add	r30, r24
    3c98:	f9 1f       	adc	r31, r25
    3c9a:	e7 53       	subi	r30, 0x37	; 55
    3c9c:	fd 4f       	sbci	r31, 0xFD	; 253
    3c9e:	81 e0       	ldi	r24, 0x01	; 1
    3ca0:	83 83       	std	Z+3, r24	; 0x03
    3ca2:	10 c0       	rjmp	.+32     	; 0x3cc4 <DoSampler+0xd80>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    3ca4:	80 91 2a 01 	lds	r24, 0x012A
    3ca8:	90 e0       	ldi	r25, 0x00	; 0
    3caa:	fc 01       	movw	r30, r24
    3cac:	05 e0       	ldi	r16, 0x05	; 5
    3cae:	ee 0f       	add	r30, r30
    3cb0:	ff 1f       	adc	r31, r31
    3cb2:	0a 95       	dec	r16
    3cb4:	e1 f7       	brne	.-8      	; 0x3cae <DoSampler+0xd6a>
    3cb6:	88 0f       	add	r24, r24
    3cb8:	99 1f       	adc	r25, r25
    3cba:	e8 0f       	add	r30, r24
    3cbc:	f9 1f       	adc	r31, r25
    3cbe:	e7 53       	subi	r30, 0x37	; 55
    3cc0:	fd 4f       	sbci	r31, 0xFD	; 253
    3cc2:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    3cc4:	80 91 2a 01 	lds	r24, 0x012A
    3cc8:	ed c1       	rjmp	.+986    	; 0x40a4 <DoSampler+0x1160>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    3cca:	20 91 2a 01 	lds	r18, 0x012A
    3cce:	82 2f       	mov	r24, r18
    3cd0:	90 e0       	ldi	r25, 0x00	; 0
    3cd2:	fc 01       	movw	r30, r24
    3cd4:	b5 e0       	ldi	r27, 0x05	; 5
    3cd6:	ee 0f       	add	r30, r30
    3cd8:	ff 1f       	adc	r31, r31
    3cda:	ba 95       	dec	r27
    3cdc:	e1 f7       	brne	.-8      	; 0x3cd6 <DoSampler+0xd92>
    3cde:	88 0f       	add	r24, r24
    3ce0:	99 1f       	adc	r25, r25
    3ce2:	e8 0f       	add	r30, r24
    3ce4:	f9 1f       	adc	r31, r25
    3ce6:	e7 53       	subi	r30, 0x37	; 55
    3ce8:	fd 4f       	sbci	r31, 0xFD	; 253
    3cea:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    3cec:	82 2f       	mov	r24, r18
    3cee:	90 e0       	ldi	r25, 0x00	; 0
    3cf0:	fc 01       	movw	r30, r24
    3cf2:	75 e0       	ldi	r23, 0x05	; 5
    3cf4:	ee 0f       	add	r30, r30
    3cf6:	ff 1f       	adc	r31, r31
    3cf8:	7a 95       	dec	r23
    3cfa:	e1 f7       	brne	.-8      	; 0x3cf4 <DoSampler+0xdb0>
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	e8 0f       	add	r30, r24
    3d02:	f9 1f       	adc	r31, r25
    3d04:	e7 53       	subi	r30, 0x37	; 55
    3d06:	fd 4f       	sbci	r31, 0xFD	; 253
    3d08:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    3d0a:	82 2f       	mov	r24, r18
    3d0c:	90 e0       	ldi	r25, 0x00	; 0
    3d0e:	fc 01       	movw	r30, r24
    3d10:	55 e0       	ldi	r21, 0x05	; 5
    3d12:	ee 0f       	add	r30, r30
    3d14:	ff 1f       	adc	r31, r31
    3d16:	5a 95       	dec	r21
    3d18:	e1 f7       	brne	.-8      	; 0x3d12 <DoSampler+0xdce>
    3d1a:	88 0f       	add	r24, r24
    3d1c:	99 1f       	adc	r25, r25
    3d1e:	e8 0f       	add	r30, r24
    3d20:	f9 1f       	adc	r31, r25
    3d22:	e7 53       	subi	r30, 0x37	; 55
    3d24:	fd 4f       	sbci	r31, 0xFD	; 253
    3d26:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3d28:	82 2f       	mov	r24, r18
    3d2a:	90 e0       	ldi	r25, 0x00	; 0
    3d2c:	fc 01       	movw	r30, r24
    3d2e:	35 e0       	ldi	r19, 0x05	; 5
    3d30:	ee 0f       	add	r30, r30
    3d32:	ff 1f       	adc	r31, r31
    3d34:	3a 95       	dec	r19
    3d36:	e1 f7       	brne	.-8      	; 0x3d30 <DoSampler+0xdec>
    3d38:	88 0f       	add	r24, r24
    3d3a:	99 1f       	adc	r25, r25
    3d3c:	e8 0f       	add	r30, r24
    3d3e:	f9 1f       	adc	r31, r25
    3d40:	e7 53       	subi	r30, 0x37	; 55
    3d42:	fd 4f       	sbci	r31, 0xFD	; 253
    3d44:	15 82       	std	Z+5, r1	; 0x05
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3d46:	a2 2f       	mov	r26, r18
    3d48:	b0 e0       	ldi	r27, 0x00	; 0
    3d4a:	fd 01       	movw	r30, r26
    3d4c:	14 e0       	ldi	r17, 0x04	; 4
    3d4e:	ee 0f       	add	r30, r30
    3d50:	ff 1f       	adc	r31, r31
    3d52:	1a 95       	dec	r17
    3d54:	e1 f7       	brne	.-8      	; 0x3d4e <DoSampler+0xe0a>
    3d56:	ea 0f       	add	r30, r26
    3d58:	fb 1f       	adc	r31, r27
    3d5a:	ee 0f       	add	r30, r30
    3d5c:	ff 1f       	adc	r31, r31
    3d5e:	e5 53       	subi	r30, 0x35	; 53
    3d60:	fd 4f       	sbci	r31, 0xFD	; 253
    3d62:	10 82       	st	Z, r1
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    3d64:	82 2f       	mov	r24, r18
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	fc 01       	movw	r30, r24
    3d6a:	65 e0       	ldi	r22, 0x05	; 5
    3d6c:	ee 0f       	add	r30, r30
    3d6e:	ff 1f       	adc	r31, r31
    3d70:	6a 95       	dec	r22
    3d72:	e1 f7       	brne	.-8      	; 0x3d6c <DoSampler+0xe28>
    3d74:	88 0f       	add	r24, r24
    3d76:	99 1f       	adc	r25, r25
    3d78:	e8 0f       	add	r30, r24
    3d7a:	f9 1f       	adc	r31, r25
    3d7c:	e7 53       	subi	r30, 0x37	; 55
    3d7e:	fd 4f       	sbci	r31, 0xFD	; 253
    3d80:	31 e0       	ldi	r19, 0x01	; 1
    3d82:	34 83       	std	Z+4, r19	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;					
    3d84:	82 2f       	mov	r24, r18
    3d86:	90 e0       	ldi	r25, 0x00	; 0
    3d88:	fc 01       	movw	r30, r24
    3d8a:	45 e0       	ldi	r20, 0x05	; 5
    3d8c:	ee 0f       	add	r30, r30
    3d8e:	ff 1f       	adc	r31, r31
    3d90:	4a 95       	dec	r20
    3d92:	e1 f7       	brne	.-8      	; 0x3d8c <DoSampler+0xe48>
    3d94:	88 0f       	add	r24, r24
    3d96:	99 1f       	adc	r25, r25
    3d98:	e8 0f       	add	r30, r24
    3d9a:	f9 1f       	adc	r31, r25
    3d9c:	e7 53       	subi	r30, 0x37	; 55
    3d9e:	fd 4f       	sbci	r31, 0xFD	; 253
    3da0:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    3da2:	82 2f       	mov	r24, r18
    3da4:	90 e0       	ldi	r25, 0x00	; 0
    3da6:	fc 01       	movw	r30, r24
    3da8:	15 e0       	ldi	r17, 0x05	; 5
    3daa:	ee 0f       	add	r30, r30
    3dac:	ff 1f       	adc	r31, r31
    3dae:	1a 95       	dec	r17
    3db0:	e1 f7       	brne	.-8      	; 0x3daa <DoSampler+0xe66>
    3db2:	88 0f       	add	r24, r24
    3db4:	99 1f       	adc	r25, r25
    3db6:	e8 0f       	add	r30, r24
    3db8:	f9 1f       	adc	r31, r25
    3dba:	e7 53       	subi	r30, 0x37	; 55
    3dbc:	fd 4f       	sbci	r31, 0xFD	; 253
    3dbe:	34 83       	std	Z+4, r19	; 0x04
					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    3dc0:	a8 5d       	subi	r26, 0xD8	; 216
    3dc2:	be 4f       	sbci	r27, 0xFE	; 254
    3dc4:	1c 92       	st	X, r1
    3dc6:	3c c0       	rjmp	.+120    	; 0x3e40 <DoSampler+0xefc>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    3dc8:	20 91 2d 01 	lds	r18, 0x012D
    3dcc:	28 30       	cpi	r18, 0x08	; 8
    3dce:	08 f0       	brcs	.+2      	; 0x3dd2 <DoSampler+0xe8e>
    3dd0:	b1 c1       	rjmp	.+866    	; 0x4134 <DoSampler+0x11f0>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;				
    3dd2:	80 91 2a 01 	lds	r24, 0x012A
    3dd6:	90 e0       	ldi	r25, 0x00	; 0
    3dd8:	fc 01       	movw	r30, r24
    3dda:	65 e0       	ldi	r22, 0x05	; 5
    3ddc:	ee 0f       	add	r30, r30
    3dde:	ff 1f       	adc	r31, r31
    3de0:	6a 95       	dec	r22
    3de2:	e1 f7       	brne	.-8      	; 0x3ddc <DoSampler+0xe98>
    3de4:	88 0f       	add	r24, r24
    3de6:	99 1f       	adc	r25, r25
    3de8:	e8 0f       	add	r30, r24
    3dea:	f9 1f       	adc	r31, r25
    3dec:	e7 53       	subi	r30, 0x37	; 55
    3dee:	fd 4f       	sbci	r31, 0xFD	; 253
    3df0:	27 83       	std	Z+7, r18	; 0x07
    3df2:	a0 c1       	rjmp	.+832    	; 0x4134 <DoSampler+0x11f0>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3df4:	80 91 2a 01 	lds	r24, 0x012A
    3df8:	60 91 2d 01 	lds	r22, 0x012D
    3dfc:	0e 94 25 0d 	call	0x1a4a	; 0x1a4a <MakeNewGranularArray>
    3e00:	99 c1       	rjmp	.+818    	; 0x4134 <DoSampler+0x11f0>
					break;

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;				
    3e02:	80 91 2d 01 	lds	r24, 0x012D
    3e06:	20 91 2a 01 	lds	r18, 0x012A
    3e0a:	30 e0       	ldi	r19, 0x00	; 0
    3e0c:	f9 01       	movw	r30, r18
    3e0e:	45 e0       	ldi	r20, 0x05	; 5
    3e10:	ee 0f       	add	r30, r30
    3e12:	ff 1f       	adc	r31, r31
    3e14:	4a 95       	dec	r20
    3e16:	e1 f7       	brne	.-8      	; 0x3e10 <DoSampler+0xecc>
    3e18:	22 0f       	add	r18, r18
    3e1a:	33 1f       	adc	r19, r19
    3e1c:	e2 0f       	add	r30, r18
    3e1e:	f3 1f       	adc	r31, r19
    3e20:	e7 53       	subi	r30, 0x37	; 55
    3e22:	fd 4f       	sbci	r31, 0xFD	; 253
    3e24:	86 83       	std	Z+6, r24	; 0x06
    3e26:	86 c1       	rjmp	.+780    	; 0x4134 <DoSampler+0x11f0>
					break;

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    3e28:	80 91 2d 01 	lds	r24, 0x012D
    3e2c:	81 30       	cpi	r24, 0x01	; 1
    3e2e:	59 f0       	breq	.+22     	; 0x3e46 <DoSampler+0xf02>
    3e30:	81 30       	cpi	r24, 0x01	; 1
    3e32:	30 f0       	brcs	.+12     	; 0x3e40 <DoSampler+0xefc>
    3e34:	82 30       	cpi	r24, 0x02	; 2
    3e36:	51 f0       	breq	.+20     	; 0x3e4c <DoSampler+0xf08>
    3e38:	83 30       	cpi	r24, 0x03	; 3
    3e3a:	09 f0       	breq	.+2      	; 0x3e3e <DoSampler+0xefa>
    3e3c:	7b c1       	rjmp	.+758    	; 0x4134 <DoSampler+0x11f0>
    3e3e:	09 c0       	rjmp	.+18     	; 0x3e52 <DoSampler+0xf0e>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3e40:	81 e5       	ldi	r24, 0x51	; 81
    3e42:	98 e0       	ldi	r25, 0x08	; 8
    3e44:	08 c0       	rjmp	.+16     	; 0x3e56 <DoSampler+0xf12>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3e46:	87 e0       	ldi	r24, 0x07	; 7
    3e48:	98 e0       	ldi	r25, 0x08	; 8
    3e4a:	05 c0       	rjmp	.+10     	; 0x3e56 <DoSampler+0xf12>
						break;
						
						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3e4c:	85 ec       	ldi	r24, 0xC5	; 197
    3e4e:	98 e0       	ldi	r25, 0x08	; 8
    3e50:	02 c0       	rjmp	.+4      	; 0x3e56 <DoSampler+0xf12>
						break;
						
						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    3e52:	86 e8       	ldi	r24, 0x86	; 134
    3e54:	98 e0       	ldi	r25, 0x08	; 8
    3e56:	90 93 c6 02 	sts	0x02C6, r25
    3e5a:	80 93 c5 02 	sts	0x02C5, r24
    3e5e:	6a c1       	rjmp	.+724    	; 0x4134 <DoSampler+0x11f0>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
    3e60:	cf b6       	in	r12, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    3e62:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    3e64:	d0 90 2a 01 	lds	r13, 0x012A
    3e68:	0d 2d       	mov	r16, r13
    3e6a:	10 e0       	ldi	r17, 0x00	; 0
    3e6c:	84 e0       	ldi	r24, 0x04	; 4
    3e6e:	e8 2e       	mov	r14, r24
    3e70:	81 e0       	ldi	r24, 0x01	; 1
    3e72:	f8 2e       	mov	r15, r24
    3e74:	e0 0e       	add	r14, r16
    3e76:	f1 1e       	adc	r15, r17
    3e78:	f7 01       	movw	r30, r14
    3e7a:	80 81       	ld	r24, Z
    3e7c:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    3e80:	00 0f       	add	r16, r16
    3e82:	11 1f       	adc	r17, r17
    3e84:	0c 55       	subi	r16, 0x5C	; 92
    3e86:	1d 4f       	sbci	r17, 0xFD	; 253
    3e88:	f8 01       	movw	r30, r16
    3e8a:	91 83       	std	Z+1, r25	; 0x01
    3e8c:	80 83       	st	Z, r24
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
    3e8e:	f7 01       	movw	r30, r14
    3e90:	60 81       	ld	r22, Z
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    3e92:	dd 20       	and	r13, r13
    3e94:	19 f4       	brne	.+6      	; 0x3e9c <DoSampler+0xf58>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    3e96:	87 e0       	ldi	r24, 0x07	; 7
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	05 c0       	rjmp	.+10     	; 0x3ea6 <DoSampler+0xf62>
	}
	else if(theBank==BANK_1)
    3e9c:	f1 e0       	ldi	r31, 0x01	; 1
    3e9e:	df 16       	cp	r13, r31
    3ea0:	21 f4       	brne	.+8      	; 0x3eaa <DoSampler+0xf66>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    3ea2:	8b e0       	ldi	r24, 0x0B	; 11
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	0e 94 d7 21 	call	0x43ae	; 0x43ae <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=i;		// Re-enable interrupts.
    3eaa:	cf be       	out	0x3f, r12	; 63
    3eac:	43 c1       	rjmp	.+646    	; 0x4134 <DoSampler+0x11f0>
					break;

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3eae:	80 91 2a 01 	lds	r24, 0x012A
    3eb2:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3eb6:	28 2f       	mov	r18, r24
    3eb8:	30 e0       	ldi	r19, 0x00	; 0
    3eba:	f9 01       	movw	r30, r18
    3ebc:	a5 e0       	ldi	r26, 0x05	; 5
    3ebe:	ee 0f       	add	r30, r30
    3ec0:	ff 1f       	adc	r31, r31
    3ec2:	aa 95       	dec	r26
    3ec4:	e1 f7       	brne	.-8      	; 0x3ebe <DoSampler+0xf7a>
    3ec6:	22 0f       	add	r18, r18
    3ec8:	33 1f       	adc	r19, r19
    3eca:	e2 0f       	add	r30, r18
    3ecc:	f3 1f       	adc	r31, r19
    3ece:	e7 53       	subi	r30, 0x37	; 55
    3ed0:	fd 4f       	sbci	r31, 0xFD	; 253
    3ed2:	93 8f       	std	Z+27, r25	; 0x1b
    3ed4:	e7 c0       	rjmp	.+462    	; 0x40a4 <DoSampler+0x1160>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3ed6:	80 91 2a 01 	lds	r24, 0x012A
    3eda:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3ede:	28 2f       	mov	r18, r24
    3ee0:	30 e0       	ldi	r19, 0x00	; 0
    3ee2:	f9 01       	movw	r30, r18
    3ee4:	65 e0       	ldi	r22, 0x05	; 5
    3ee6:	ee 0f       	add	r30, r30
    3ee8:	ff 1f       	adc	r31, r31
    3eea:	6a 95       	dec	r22
    3eec:	e1 f7       	brne	.-8      	; 0x3ee6 <DoSampler+0xfa2>
    3eee:	22 0f       	add	r18, r18
    3ef0:	33 1f       	adc	r19, r19
    3ef2:	e2 0f       	add	r30, r18
    3ef4:	f3 1f       	adc	r31, r19
    3ef6:	e7 53       	subi	r30, 0x37	; 55
    3ef8:	fd 4f       	sbci	r31, 0xFD	; 253
    3efa:	94 8f       	std	Z+28, r25	; 0x1c
    3efc:	d3 c0       	rjmp	.+422    	; 0x40a4 <DoSampler+0x1160>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3efe:	80 91 2a 01 	lds	r24, 0x012A
    3f02:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3f06:	28 2f       	mov	r18, r24
    3f08:	30 e0       	ldi	r19, 0x00	; 0
    3f0a:	f9 01       	movw	r30, r18
    3f0c:	45 e0       	ldi	r20, 0x05	; 5
    3f0e:	ee 0f       	add	r30, r30
    3f10:	ff 1f       	adc	r31, r31
    3f12:	4a 95       	dec	r20
    3f14:	e1 f7       	brne	.-8      	; 0x3f0e <DoSampler+0xfca>
    3f16:	22 0f       	add	r18, r18
    3f18:	33 1f       	adc	r19, r19
    3f1a:	e2 0f       	add	r30, r18
    3f1c:	f3 1f       	adc	r31, r19
    3f1e:	e7 53       	subi	r30, 0x37	; 55
    3f20:	fd 4f       	sbci	r31, 0xFD	; 253
    3f22:	95 8f       	std	Z+29, r25	; 0x1d
    3f24:	bf c0       	rjmp	.+382    	; 0x40a4 <DoSampler+0x1160>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:						
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    3f26:	60 91 2a 01 	lds	r22, 0x012A
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    3f2a:	7f b7       	in	r23, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    3f2c:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    3f2e:	86 2f       	mov	r24, r22
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	fc 01       	movw	r30, r24
    3f34:	15 e0       	ldi	r17, 0x05	; 5
    3f36:	ee 0f       	add	r30, r30
    3f38:	ff 1f       	adc	r31, r31
    3f3a:	1a 95       	dec	r17
    3f3c:	e1 f7       	brne	.-8      	; 0x3f36 <DoSampler+0xff2>
    3f3e:	88 0f       	add	r24, r24
    3f40:	99 1f       	adc	r25, r25
    3f42:	e8 0f       	add	r30, r24
    3f44:	f9 1f       	adc	r31, r25
    3f46:	e7 53       	subi	r30, 0x37	; 55
    3f48:	fd 4f       	sbci	r31, 0xFD	; 253
    3f4a:	27 85       	ldd	r18, Z+15	; 0x0f
    3f4c:	30 89       	ldd	r19, Z+16	; 0x10
    3f4e:	41 89       	ldd	r20, Z+17	; 0x11
    3f50:	52 89       	ldd	r21, Z+18	; 0x12
    3f52:	86 2f       	mov	r24, r22
    3f54:	90 e0       	ldi	r25, 0x00	; 0
    3f56:	fc 01       	movw	r30, r24
    3f58:	a5 e0       	ldi	r26, 0x05	; 5
    3f5a:	ee 0f       	add	r30, r30
    3f5c:	ff 1f       	adc	r31, r31
    3f5e:	aa 95       	dec	r26
    3f60:	e1 f7       	brne	.-8      	; 0x3f5a <DoSampler+0x1016>
    3f62:	88 0f       	add	r24, r24
    3f64:	99 1f       	adc	r25, r25
    3f66:	e8 0f       	add	r30, r24
    3f68:	f9 1f       	adc	r31, r25
    3f6a:	e7 53       	subi	r30, 0x37	; 55
    3f6c:	fd 4f       	sbci	r31, 0xFD	; 253
    3f6e:	27 8b       	std	Z+23, r18	; 0x17
    3f70:	30 8f       	std	Z+24, r19	; 0x18
    3f72:	41 8f       	std	Z+25, r20	; 0x19
    3f74:	52 8f       	std	Z+26, r21	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3f76:	86 2f       	mov	r24, r22
    3f78:	90 e0       	ldi	r25, 0x00	; 0
    3f7a:	fc 01       	movw	r30, r24
    3f7c:	15 e0       	ldi	r17, 0x05	; 5
    3f7e:	ee 0f       	add	r30, r30
    3f80:	ff 1f       	adc	r31, r31
    3f82:	1a 95       	dec	r17
    3f84:	e1 f7       	brne	.-8      	; 0x3f7e <DoSampler+0x103a>
    3f86:	88 0f       	add	r24, r24
    3f88:	99 1f       	adc	r25, r25
    3f8a:	e8 0f       	add	r30, r24
    3f8c:	f9 1f       	adc	r31, r25
    3f8e:	e7 53       	subi	r30, 0x37	; 55
    3f90:	fd 4f       	sbci	r31, 0xFD	; 253
    3f92:	23 85       	ldd	r18, Z+11	; 0x0b
    3f94:	34 85       	ldd	r19, Z+12	; 0x0c
    3f96:	45 85       	ldd	r20, Z+13	; 0x0d
    3f98:	56 85       	ldd	r21, Z+14	; 0x0e
    3f9a:	86 2f       	mov	r24, r22
    3f9c:	90 e0       	ldi	r25, 0x00	; 0
    3f9e:	fc 01       	movw	r30, r24
    3fa0:	a5 e0       	ldi	r26, 0x05	; 5
    3fa2:	ee 0f       	add	r30, r30
    3fa4:	ff 1f       	adc	r31, r31
    3fa6:	aa 95       	dec	r26
    3fa8:	e1 f7       	brne	.-8      	; 0x3fa2 <DoSampler+0x105e>
    3faa:	88 0f       	add	r24, r24
    3fac:	99 1f       	adc	r25, r25
    3fae:	e8 0f       	add	r30, r24
    3fb0:	f9 1f       	adc	r31, r25
    3fb2:	e7 53       	subi	r30, 0x37	; 55
    3fb4:	fd 4f       	sbci	r31, 0xFD	; 253
    3fb6:	23 8b       	std	Z+19, r18	; 0x13
    3fb8:	34 8b       	std	Z+20, r19	; 0x14
    3fba:	45 8b       	std	Z+21, r20	; 0x15
    3fbc:	56 8b       	std	Z+22, r21	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    3fbe:	86 2f       	mov	r24, r22
    3fc0:	90 e0       	ldi	r25, 0x00	; 0
    3fc2:	fc 01       	movw	r30, r24
    3fc4:	15 e0       	ldi	r17, 0x05	; 5
    3fc6:	ee 0f       	add	r30, r30
    3fc8:	ff 1f       	adc	r31, r31
    3fca:	1a 95       	dec	r17
    3fcc:	e1 f7       	brne	.-8      	; 0x3fc6 <DoSampler+0x1082>
    3fce:	88 0f       	add	r24, r24
    3fd0:	99 1f       	adc	r25, r25
    3fd2:	e8 0f       	add	r30, r24
    3fd4:	f9 1f       	adc	r31, r25
    3fd6:	e7 53       	subi	r30, 0x37	; 55
    3fd8:	fd 4f       	sbci	r31, 0xFD	; 253
    3fda:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    3fdc:	86 2f       	mov	r24, r22
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	fc 01       	movw	r30, r24
    3fe2:	a5 e0       	ldi	r26, 0x05	; 5
    3fe4:	ee 0f       	add	r30, r30
    3fe6:	ff 1f       	adc	r31, r31
    3fe8:	aa 95       	dec	r26
    3fea:	e1 f7       	brne	.-8      	; 0x3fe4 <DoSampler+0x10a0>
    3fec:	88 0f       	add	r24, r24
    3fee:	99 1f       	adc	r25, r25
    3ff0:	e8 0f       	add	r30, r24
    3ff2:	f9 1f       	adc	r31, r25
    3ff4:	e7 53       	subi	r30, 0x37	; 55
    3ff6:	fd 4f       	sbci	r31, 0xFD	; 253
    3ff8:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    3ffa:	86 2f       	mov	r24, r22
    3ffc:	90 e0       	ldi	r25, 0x00	; 0
    3ffe:	fc 01       	movw	r30, r24
    4000:	45 e0       	ldi	r20, 0x05	; 5
    4002:	ee 0f       	add	r30, r30
    4004:	ff 1f       	adc	r31, r31
    4006:	4a 95       	dec	r20
    4008:	e1 f7       	brne	.-8      	; 0x4002 <DoSampler+0x10be>
    400a:	88 0f       	add	r24, r24
    400c:	99 1f       	adc	r25, r25
    400e:	e8 0f       	add	r30, r24
    4010:	f9 1f       	adc	r31, r25
    4012:	e7 53       	subi	r30, 0x37	; 55
    4014:	fd 4f       	sbci	r31, 0xFD	; 253
    4016:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    4018:	7f bf       	out	0x3f, r23	; 63
    401a:	8c c0       	rjmp	.+280    	; 0x4134 <DoSampler+0x11f0>
					case MIDI_REVERT_SAMPLE_TO_FULL:						
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
					break;

					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    401c:	80 91 2a 01 	lds	r24, 0x012A
    4020:	40 91 2d 01 	lds	r20, 0x012D
    4024:	50 e0       	ldi	r21, 0x00	; 0
    4026:	44 0f       	add	r20, r20
    4028:	55 1f       	adc	r21, r21
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    402a:	28 2f       	mov	r18, r24
    402c:	30 e0       	ldi	r19, 0x00	; 0
    402e:	f9 01       	movw	r30, r18
    4030:	95 e0       	ldi	r25, 0x05	; 5
    4032:	ee 0f       	add	r30, r30
    4034:	ff 1f       	adc	r31, r31
    4036:	9a 95       	dec	r25
    4038:	e1 f7       	brne	.-8      	; 0x4032 <DoSampler+0x10ee>
    403a:	22 0f       	add	r18, r18
    403c:	33 1f       	adc	r19, r19
    403e:	e2 0f       	add	r30, r18
    4040:	f3 1f       	adc	r31, r19
    4042:	e7 53       	subi	r30, 0x37	; 55
    4044:	fd 4f       	sbci	r31, 0xFD	; 253
    4046:	43 8f       	std	Z+27, r20	; 0x1b
    4048:	2d c0       	rjmp	.+90     	; 0x40a4 <DoSampler+0x1160>
					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    404a:	80 91 2a 01 	lds	r24, 0x012A
    404e:	40 91 2d 01 	lds	r20, 0x012D
    4052:	50 e0       	ldi	r21, 0x00	; 0
    4054:	44 0f       	add	r20, r20
    4056:	55 1f       	adc	r21, r21
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    4058:	28 2f       	mov	r18, r24
    405a:	30 e0       	ldi	r19, 0x00	; 0
    405c:	f9 01       	movw	r30, r18
    405e:	b5 e0       	ldi	r27, 0x05	; 5
    4060:	ee 0f       	add	r30, r30
    4062:	ff 1f       	adc	r31, r31
    4064:	ba 95       	dec	r27
    4066:	e1 f7       	brne	.-8      	; 0x4060 <DoSampler+0x111c>
    4068:	22 0f       	add	r18, r18
    406a:	33 1f       	adc	r19, r19
    406c:	e2 0f       	add	r30, r18
    406e:	f3 1f       	adc	r31, r19
    4070:	e7 53       	subi	r30, 0x37	; 55
    4072:	fd 4f       	sbci	r31, 0xFD	; 253
    4074:	44 8f       	std	Z+28, r20	; 0x1c
    4076:	16 c0       	rjmp	.+44     	; 0x40a4 <DoSampler+0x1160>
					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    4078:	80 91 2a 01 	lds	r24, 0x012A
    407c:	40 91 2d 01 	lds	r20, 0x012D
    4080:	50 e0       	ldi	r21, 0x00	; 0
    4082:	44 0f       	add	r20, r20
    4084:	55 1f       	adc	r21, r21
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    4086:	28 2f       	mov	r18, r24
    4088:	30 e0       	ldi	r19, 0x00	; 0
    408a:	f9 01       	movw	r30, r18
    408c:	65 e0       	ldi	r22, 0x05	; 5
    408e:	ee 0f       	add	r30, r30
    4090:	ff 1f       	adc	r31, r31
    4092:	6a 95       	dec	r22
    4094:	e1 f7       	brne	.-8      	; 0x408e <DoSampler+0x114a>
    4096:	22 0f       	add	r18, r18
    4098:	33 1f       	adc	r19, r19
    409a:	e2 0f       	add	r30, r18
    409c:	f3 1f       	adc	r31, r19
    409e:	e7 53       	subi	r30, 0x37	; 55
    40a0:	fd 4f       	sbci	r31, 0xFD	; 253
    40a2:	45 8f       	std	Z+29, r20	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    40a4:	0e 94 57 0e 	call	0x1cae	; 0x1cae <UpdateAdjustedSampleAddresses>
    40a8:	45 c0       	rjmp	.+138    	; 0x4134 <DoSampler+0x11f0>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    40aa:	87 30       	cpi	r24, 0x07	; 7
    40ac:	09 f0       	breq	.+2      	; 0x40b0 <DoSampler+0x116c>
    40ae:	42 c0       	rjmp	.+132    	; 0x4134 <DoSampler+0x11f0>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    40b0:	80 91 2d 01 	lds	r24, 0x012D
    40b4:	c8 2f       	mov	r28, r24
    40b6:	d0 e0       	ldi	r29, 0x00	; 0
    40b8:	d6 95       	lsr	r29
    40ba:	dc 2f       	mov	r29, r28
    40bc:	cc 27       	eor	r28, r28
    40be:	d7 95       	ror	r29
    40c0:	c7 95       	ror	r28
    40c2:	80 91 2c 01 	lds	r24, 0x012C
    40c6:	c8 0f       	add	r28, r24
    40c8:	d1 1d       	adc	r29, r1

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    40ca:	80 e2       	ldi	r24, 0x20	; 32
    40cc:	c0 30       	cpi	r28, 0x00	; 0
    40ce:	d8 07       	cpc	r29, r24
    40d0:	d1 f0       	breq	.+52     	; 0x4106 <DoSampler+0x11c2>
    40d2:	00 91 2a 01 	lds	r16, 0x012A
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
    40d6:	e0 e2       	ldi	r30, 0x20	; 32
    40d8:	c0 30       	cpi	r28, 0x00	; 0
    40da:	de 07       	cpc	r29, r30
    40dc:	40 f4       	brcc	.+16     	; 0x40ee <DoSampler+0x11aa>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    40de:	10 e0       	ldi	r17, 0x00	; 0
    40e0:	f8 01       	movw	r30, r16
    40e2:	ec 5f       	subi	r30, 0xFC	; 252
    40e4:	fe 4f       	sbci	r31, 0xFE	; 254
    40e6:	80 81       	ld	r24, Z
    40e8:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    40ec:	07 c0       	rjmp	.+14     	; 0x40fc <DoSampler+0x11b8>
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    40ee:	10 e0       	ldi	r17, 0x00	; 0
    40f0:	f8 01       	movw	r30, r16
    40f2:	ec 5f       	subi	r30, 0xFC	; 252
    40f4:	fe 4f       	sbci	r31, 0xFE	; 254
    40f6:	80 81       	ld	r24, Z
    40f8:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    40fc:	80 50       	subi	r24, 0x00	; 0
    40fe:	90 4e       	sbci	r25, 0xE0	; 224
    4100:	8c 1b       	sub	r24, r28
    4102:	9d 0b       	sbc	r25, r29
    4104:	09 c0       	rjmp	.+18     	; 0x4118 <DoSampler+0x11d4>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    4106:	00 91 2a 01 	lds	r16, 0x012A
    410a:	10 e0       	ldi	r17, 0x00	; 0
    410c:	f8 01       	movw	r30, r16
    410e:	ec 5f       	subi	r30, 0xFC	; 252
    4110:	fe 4f       	sbci	r31, 0xFE	; 254
    4112:	80 81       	ld	r24, Z
    4114:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <GetPlaybackRateFromNote>
    4118:	f8 01       	movw	r30, r16
    411a:	35 e0       	ldi	r19, 0x05	; 5
    411c:	ee 0f       	add	r30, r30
    411e:	ff 1f       	adc	r31, r31
    4120:	3a 95       	dec	r19
    4122:	e1 f7       	brne	.-8      	; 0x411c <DoSampler+0x11d8>
    4124:	00 0f       	add	r16, r16
    4126:	11 1f       	adc	r17, r17
    4128:	e0 0f       	add	r30, r16
    412a:	f1 1f       	adc	r31, r17
    412c:	e7 53       	subi	r30, 0x37	; 55
    412e:	fd 4f       	sbci	r31, 0xFD	; 253
    4130:	92 87       	std	Z+10, r25	; 0x0a
    4132:	81 87       	std	Z+9, r24	; 0x09

static void StopUnusedInterrupts(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    4134:	80 91 d1 02 	lds	r24, 0x02D1
    4138:	81 30       	cpi	r24, 0x01	; 1
    413a:	41 f0       	breq	.+16     	; 0x414c <DoSampler+0x1208>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    413c:	10 92 9f 02 	sts	0x029F, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    4140:	80 91 6f 00 	lds	r24, 0x006F
    4144:	8f 7d       	andi	r24, 0xDF	; 223
    4146:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.	
    414a:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    414c:	80 91 f3 02 	lds	r24, 0x02F3
    4150:	81 30       	cpi	r24, 0x01	; 1
    4152:	31 f0       	breq	.+12     	; 0x4160 <DoSampler+0x121c>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    4154:	10 92 a0 02 	sts	0x02A0, r1
		PCICR=0;			// No global PCINTS.
    4158:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    415c:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    4160:	80 91 d1 02 	lds	r24, 0x02D1
    4164:	82 30       	cpi	r24, 0x02	; 2
    4166:	41 f0       	breq	.+16     	; 0x4178 <DoSampler+0x1234>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    4168:	10 92 a1 02 	sts	0x02A1, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    416c:	80 91 6f 00 	lds	r24, 0x006F
    4170:	8d 7f       	andi	r24, 0xFD	; 253
    4172:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.	
    4176:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    4178:	80 91 f3 02 	lds	r24, 0x02F3
    417c:	82 30       	cpi	r24, 0x02	; 2
    417e:	41 f0       	breq	.+16     	; 0x4190 <DoSampler+0x124c>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    4180:	10 92 a2 02 	sts	0x02A2, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    4184:	80 91 6f 00 	lds	r24, 0x006F
    4188:	8b 7f       	andi	r24, 0xFB	; 251
    418a:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.	
    418e:	b2 9a       	sbi	0x16, 2	; 22
	}

// If there's no clock to a given bank, void all its contributions to the DAC.

	if(bankStates[BANK_0].clockMode==CLK_NONE)
    4190:	80 91 d1 02 	lds	r24, 0x02D1
    4194:	88 23       	and	r24, r24
    4196:	21 f4       	brne	.+8      	; 0x41a0 <DoSampler+0x125c>
	{
		extIsrOutputBank0=0;
    4198:	10 92 9f 02 	sts	0x029F, r1
		midiOutputBank0=0;
    419c:	10 92 a1 02 	sts	0x02A1, r1
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)
    41a0:	80 91 f3 02 	lds	r24, 0x02F3
    41a4:	88 23       	and	r24, r24
    41a6:	21 f4       	brne	.+8      	; 0x41b0 <DoSampler+0x126c>
	{
		extIsrOutputBank1=0;
    41a8:	10 92 a0 02 	sts	0x02A0, r1
		midiOutputBank1=0;
    41ac:	10 92 a2 02 	sts	0x02A2, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    41b0:	80 91 44 01 	lds	r24, 0x0144
    41b4:	82 95       	swap	r24
    41b6:	86 95       	lsr	r24
    41b8:	87 70       	andi	r24, 0x07	; 7
    41ba:	80 93 45 01 	sts	0x0145, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    41be:	90 91 3b 01 	lds	r25, 0x013B
    41c2:	9f 71       	andi	r25, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    41c4:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    41c6:	90 68       	ori	r25, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    41c8:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    41ca:	90 64       	ori	r25, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    41cc:	82 fd       	sbrc	r24, 2
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    41ce:	90 62       	ori	r25, 0x20	; 32
	}

	ledOnOffMask=temp;		// Update the leds.
    41d0:	90 93 3b 01 	sts	0x013B, r25
		}
	}

	StopUnusedInterrupts();			// If we've enabled an interrupt and we aren't using it, disable it.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    41d4:	60 91 2e 01 	lds	r22, 0x012E
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    41d8:	29 2f       	mov	r18, r25
    41da:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    41dc:	86 2f       	mov	r24, r22
    41de:	90 e0       	ldi	r25, 0x00	; 0
    41e0:	fc 01       	movw	r30, r24
    41e2:	05 e0       	ldi	r16, 0x05	; 5
    41e4:	ee 0f       	add	r30, r30
    41e6:	ff 1f       	adc	r31, r31
    41e8:	0a 95       	dec	r16
    41ea:	e1 f7       	brne	.-8      	; 0x41e4 <DoSampler+0x12a0>
    41ec:	88 0f       	add	r24, r24
    41ee:	99 1f       	adc	r25, r25
    41f0:	e8 0f       	add	r30, r24
    41f2:	f9 1f       	adc	r31, r25
    41f4:	e7 53       	subi	r30, 0x37	; 55
    41f6:	fd 4f       	sbci	r31, 0xFD	; 253
    41f8:	80 81       	ld	r24, Z
    41fa:	83 30       	cpi	r24, 0x03	; 3
    41fc:	09 f4       	brne	.+2      	; 0x4200 <DoSampler+0x12bc>
	{
		temp|=Om_LED_REC;
    41fe:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    4200:	86 2f       	mov	r24, r22
    4202:	90 e0       	ldi	r25, 0x00	; 0
    4204:	fc 01       	movw	r30, r24
    4206:	b5 e0       	ldi	r27, 0x05	; 5
    4208:	ee 0f       	add	r30, r30
    420a:	ff 1f       	adc	r31, r31
    420c:	ba 95       	dec	r27
    420e:	e1 f7       	brne	.-8      	; 0x4208 <DoSampler+0x12c4>
    4210:	88 0f       	add	r24, r24
    4212:	99 1f       	adc	r25, r25
    4214:	e8 0f       	add	r30, r24
    4216:	f9 1f       	adc	r31, r25
    4218:	e7 53       	subi	r30, 0x37	; 55
    421a:	fd 4f       	sbci	r31, 0xFD	; 253
    421c:	80 81       	ld	r24, Z
    421e:	84 30       	cpi	r24, 0x04	; 4
    4220:	09 f4       	brne	.+2      	; 0x4224 <DoSampler+0x12e0>
	{
		temp|=Om_LED_PLAY;
    4222:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    4224:	86 2f       	mov	r24, r22
    4226:	90 e0       	ldi	r25, 0x00	; 0
    4228:	fc 01       	movw	r30, r24
    422a:	75 e0       	ldi	r23, 0x05	; 5
    422c:	ee 0f       	add	r30, r30
    422e:	ff 1f       	adc	r31, r31
    4230:	7a 95       	dec	r23
    4232:	e1 f7       	brne	.-8      	; 0x422c <DoSampler+0x12e8>
    4234:	88 0f       	add	r24, r24
    4236:	99 1f       	adc	r25, r25
    4238:	e8 0f       	add	r30, r24
    423a:	f9 1f       	adc	r31, r25
    423c:	e7 53       	subi	r30, 0x37	; 55
    423e:	fd 4f       	sbci	r31, 0xFD	; 253
    4240:	80 81       	ld	r24, Z
    4242:	85 30       	cpi	r24, 0x05	; 5
    4244:	09 f4       	brne	.+2      	; 0x4248 <DoSampler+0x1304>
	{
		temp|=Om_LED_ODUB;
    4246:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    4248:	86 2f       	mov	r24, r22
    424a:	90 e0       	ldi	r25, 0x00	; 0
    424c:	fc 01       	movw	r30, r24
    424e:	45 e0       	ldi	r20, 0x05	; 5
    4250:	ee 0f       	add	r30, r30
    4252:	ff 1f       	adc	r31, r31
    4254:	4a 95       	dec	r20
    4256:	e1 f7       	brne	.-8      	; 0x4250 <DoSampler+0x130c>
    4258:	88 0f       	add	r24, r24
    425a:	99 1f       	adc	r25, r25
    425c:	e8 0f       	add	r30, r24
    425e:	f9 1f       	adc	r31, r25
    4260:	e7 53       	subi	r30, 0x37	; 55
    4262:	fd 4f       	sbci	r31, 0xFD	; 253
    4264:	80 81       	ld	r24, Z
    4266:	82 30       	cpi	r24, 0x02	; 2
    4268:	09 f4       	brne	.+2      	; 0x426c <DoSampler+0x1328>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    426a:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    426c:	80 91 42 01 	lds	r24, 0x0142
    4270:	81 30       	cpi	r24, 0x01	; 1
    4272:	09 f4       	brne	.+2      	; 0x4276 <DoSampler+0x1332>
	{
		temp|=Om_LED_OUT_OF_MEM;
    4274:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    4276:	61 30       	cpi	r22, 0x01	; 1
    4278:	09 f4       	brne	.+2      	; 0x427c <DoSampler+0x1338>
	{
		temp|=Om_LED_BANK;
    427a:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    427c:	20 93 3b 01 	sts	0x013B, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    4280:	86 2f       	mov	r24, r22
    4282:	90 e0       	ldi	r25, 0x00	; 0
    4284:	fc 01       	movw	r30, r24
    4286:	05 e0       	ldi	r16, 0x05	; 5
    4288:	ee 0f       	add	r30, r30
    428a:	ff 1f       	adc	r31, r31
    428c:	0a 95       	dec	r16
    428e:	e1 f7       	brne	.-8      	; 0x4288 <DoSampler+0x1344>
    4290:	88 0f       	add	r24, r24
    4292:	99 1f       	adc	r25, r25
    4294:	e8 0f       	add	r30, r24
    4296:	f9 1f       	adc	r31, r25
    4298:	e7 53       	subi	r30, 0x37	; 55
    429a:	fd 4f       	sbci	r31, 0xFD	; 253
    429c:	27 85       	ldd	r18, Z+15	; 0x0f
    429e:	30 89       	ldd	r19, Z+16	; 0x10
    42a0:	41 89       	ldd	r20, Z+17	; 0x11
    42a2:	52 89       	ldd	r21, Z+18	; 0x12
    42a4:	86 2f       	mov	r24, r22
    42a6:	90 e0       	ldi	r25, 0x00	; 0
    42a8:	fc 01       	movw	r30, r24
    42aa:	b5 e0       	ldi	r27, 0x05	; 5
    42ac:	ee 0f       	add	r30, r30
    42ae:	ff 1f       	adc	r31, r31
    42b0:	ba 95       	dec	r27
    42b2:	e1 f7       	brne	.-8      	; 0x42ac <DoSampler+0x1368>
    42b4:	88 0f       	add	r24, r24
    42b6:	99 1f       	adc	r25, r25
    42b8:	e8 0f       	add	r30, r24
    42ba:	f9 1f       	adc	r31, r25
    42bc:	e7 53       	subi	r30, 0x37	; 55
    42be:	fd 4f       	sbci	r31, 0xFD	; 253
    42c0:	83 85       	ldd	r24, Z+11	; 0x0b
    42c2:	94 85       	ldd	r25, Z+12	; 0x0c
    42c4:	a5 85       	ldd	r26, Z+13	; 0x0d
    42c6:	b6 85       	ldd	r27, Z+14	; 0x0e
    42c8:	28 17       	cp	r18, r24
    42ca:	39 07       	cpc	r19, r25
    42cc:	4a 07       	cpc	r20, r26
    42ce:	5b 07       	cpc	r21, r27
    42d0:	39 f4       	brne	.+14     	; 0x42e0 <DoSampler+0x139c>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    42d2:	80 91 3c 01 	lds	r24, 0x013C
    42d6:	82 fd       	sbrc	r24, 2
    42d8:	07 c0       	rjmp	.+14     	; 0x42e8 <DoSampler+0x13a4>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    42da:	84 e0       	ldi	r24, 0x04	; 4
    42dc:	90 e0       	ldi	r25, 0x00	; 0
    42de:	02 c0       	rjmp	.+4      	; 0x42e4 <DoSampler+0x13a0>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    42e0:	80 e0       	ldi	r24, 0x00	; 0
    42e2:	90 e0       	ldi	r25, 0x00	; 0
    42e4:	0e 94 87 12 	call	0x250e	; 0x250e <BlinkLeds>
	}

	StopUnusedInterrupts();			// If we've enabled an interrupt and we aren't using it, disable it.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    42e8:	df 91       	pop	r29
    42ea:	cf 91       	pop	r28
    42ec:	1f 91       	pop	r17
    42ee:	0f 91       	pop	r16
    42f0:	ff 90       	pop	r15
    42f2:	ef 90       	pop	r14
    42f4:	df 90       	pop	r13
    42f6:	cf 90       	pop	r12
    42f8:	08 95       	ret

000042fa <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{	
	if(subState==SS_0)
    42fa:	80 91 41 01 	lds	r24, 0x0141
    42fe:	88 23       	and	r24, r24
    4300:	a1 f4       	brne	.+40     	; 0x432a <SetMidiChannels+0x30>
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    4302:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <GetMidiChannel>
    4306:	80 93 0f 03 	sts	0x030F, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);
    430a:	81 e0       	ldi	r24, 0x01	; 1
    430c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <GetMidiChannel>
    4310:	80 93 28 03 	sts	0x0328, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    4314:	82 95       	swap	r24
    4316:	80 7f       	andi	r24, 0xF0	; 240
    4318:	90 91 0f 03 	lds	r25, 0x030F
    431c:	98 2b       	or	r25, r24
    431e:	90 93 3b 01 	sts	0x013B, r25
		subState=SS_1;
    4322:	81 e0       	ldi	r24, 0x01	; 1
    4324:	80 93 41 01 	sts	0x0141, r24
    4328:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    432a:	80 91 3f 01 	lds	r24, 0x013F
    432e:	28 2f       	mov	r18, r24
    4330:	80 ff       	sbrs	r24, 0
    4332:	11 c0       	rjmp	.+34     	; 0x4356 <SetMidiChannels+0x5c>
		{
			midiChannelNumberA++;
    4334:	80 91 0f 03 	lds	r24, 0x030F
    4338:	8f 5f       	subi	r24, 0xFF	; 255
    433a:	80 93 0f 03 	sts	0x030F, r24
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    433e:	80 31       	cpi	r24, 0x10	; 16
    4340:	10 f0       	brcs	.+4      	; 0x4346 <SetMidiChannels+0x4c>
			{
				midiChannelNumberA=0;
    4342:	10 92 0f 03 	sts	0x030F, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    4346:	80 91 3b 01 	lds	r24, 0x013B
    434a:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    434c:	90 91 0f 03 	lds	r25, 0x030F
    4350:	89 2b       	or	r24, r25
    4352:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_1)
    4356:	21 ff       	sbrs	r18, 1
    4358:	13 c0       	rjmp	.+38     	; 0x4380 <SetMidiChannels+0x86>
		{
			midiChannelNumberB++;
    435a:	80 91 28 03 	lds	r24, 0x0328
    435e:	8f 5f       	subi	r24, 0xFF	; 255
    4360:	80 93 28 03 	sts	0x0328, r24
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    4364:	80 31       	cpi	r24, 0x10	; 16
    4366:	10 f0       	brcs	.+4      	; 0x436c <SetMidiChannels+0x72>
			{
				midiChannelNumberB=0;
    4368:	10 92 28 03 	sts	0x0328, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    436c:	90 91 3b 01 	lds	r25, 0x013B
    4370:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.		
    4372:	80 91 28 03 	lds	r24, 0x0328
    4376:	82 95       	swap	r24
    4378:	80 7f       	andi	r24, 0xF0	; 240
    437a:	89 2b       	or	r24, r25
    437c:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    4380:	22 ff       	sbrs	r18, 2
    4382:	14 c0       	rjmp	.+40     	; 0x43ac <SetMidiChannels+0xb2>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    4384:	84 e0       	ldi	r24, 0x04	; 4
    4386:	90 e0       	ldi	r25, 0x00	; 0
    4388:	60 91 0f 03 	lds	r22, 0x030F
    438c:	0e 94 d7 21 	call	0x43ae	; 0x43ae <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    4390:	88 e0       	ldi	r24, 0x08	; 8
    4392:	90 e0       	ldi	r25, 0x00	; 0
    4394:	60 91 28 03 	lds	r22, 0x0328
    4398:	0e 94 d7 21 	call	0x43ae	; 0x43ae <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    439c:	82 ea       	ldi	r24, 0xA2	; 162
    439e:	97 e1       	ldi	r25, 0x17	; 23
    43a0:	90 93 c8 02 	sts	0x02C8, r25
    43a4:	80 93 c7 02 	sts	0x02C7, r24
	subState=SS_0;
    43a8:	10 92 41 01 	sts	0x0141, r1
    43ac:	08 95       	ret

000043ae <EepromWrite>:
// NOTE:  Accepted lore is not to use eeprom address 0 since it's the most likely one to get buggered in a crash.

#include "includes.h"

void EepromWrite(unsigned int theAddress, unsigned char theData)
{
    43ae:	9c 01       	movw	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    43b0:	f9 99       	sbic	0x1f, 1	; 31
    43b2:	fe cf       	rjmp	.-4      	; 0x43b0 <EepromWrite+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    43b4:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    43b6:	f8 94       	cli

	EEAR=theAddress;
    43b8:	32 bd       	out	0x22, r19	; 34
    43ba:	21 bd       	out	0x21, r18	; 33
	EEDR=theData;
    43bc:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    43be:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    43c0:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    43c2:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    43c4:	12 bc       	out	0x22, r1	; 34
    43c6:	11 bc       	out	0x21, r1	; 33
}
    43c8:	08 95       	ret

000043ca <EepromRead>:

unsigned char EepromRead(unsigned char theAddress)
{
    43ca:	28 2f       	mov	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    43cc:	f9 99       	sbic	0x1f, 1	; 31
    43ce:	fe cf       	rjmp	.-4      	; 0x43cc <EepromRead+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    43d0:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    43d2:	f8 94       	cli

	EEAR=theAddress;
    43d4:	30 e0       	ldi	r19, 0x00	; 0
    43d6:	32 bd       	out	0x22, r19	; 34
    43d8:	21 bd       	out	0x21, r18	; 33
	EECR|=(1<<EERE);	// Start reading.
    43da:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    43dc:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    43de:	12 bc       	out	0x22, r1	; 34
    43e0:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    43e2:	80 b5       	in	r24, 0x20	; 32
}
    43e4:	08 95       	ret

000043e6 <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    43e6:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    43ea:	88 1f       	adc	r24, r24
    43ec:	88 27       	eor	r24, r24
    43ee:	88 1f       	adc	r24, r24
    43f0:	08 95       	ret

000043f2 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    43f2:	80 91 c6 00 	lds	r24, 0x00C6
}
    43f6:	08 95       	ret

000043f8 <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    43f8:	80 91 64 00 	lds	r24, 0x0064
    43fc:	8d 7f       	andi	r24, 0xFD	; 253
    43fe:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    4402:	80 91 c0 00 	lds	r24, 0x00C0
    4406:	8d 7f       	andi	r24, 0xFD	; 253
    4408:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    440c:	88 e1       	ldi	r24, 0x18	; 24
    440e:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    4412:	87 e2       	ldi	r24, 0x27	; 39
    4414:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    4418:	86 e0       	ldi	r24, 0x06	; 6
    441a:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    441e:	80 91 c0 00 	lds	r24, 0x00C0
    4422:	85 ff       	sbrs	r24, 5
    4424:	fc cf       	rjmp	.-8      	; 0x441e <InitUart0+0x26>
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4426:	80 91 c0 00 	lds	r24, 0x00C0
    442a:	87 ff       	sbrs	r24, 7
    442c:	03 c0       	rjmp	.+6      	; 0x4434 <InitUart0+0x3c>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    442e:	80 91 c6 00 	lds	r24, 0x00C6
    4432:	f9 cf       	rjmp	.-14     	; 0x4426 <InitUart0+0x2e>
    4434:	08 95       	ret

00004436 <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    4436:	e8 2f       	mov	r30, r24
    4438:	f0 e0       	ldi	r31, 0x00	; 0
    443a:	80 91 0d 03 	lds	r24, 0x030D
    443e:	90 91 0e 03 	lds	r25, 0x030E
    4442:	ee 0f       	add	r30, r30
    4444:	ff 1f       	adc	r31, r31
    4446:	df 01       	movw	r26, r30
    4448:	a8 55       	subi	r26, 0x58	; 88
    444a:	bd 4f       	sbci	r27, 0xFD	; 253
    444c:	8d 93       	st	X+, r24
    444e:	9c 93       	st	X, r25
	delayTime[timerNum]=ticks_to_wait;
    4450:	e0 55       	subi	r30, 0x50	; 80
    4452:	fd 4f       	sbci	r31, 0xFD	; 253
    4454:	71 83       	std	Z+1, r23	; 0x01
    4456:	60 83       	st	Z, r22
}
    4458:	08 95       	ret

0000445a <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    445a:	20 91 0d 03 	lds	r18, 0x030D
    445e:	30 91 0e 03 	lds	r19, 0x030E
    4462:	e8 2f       	mov	r30, r24
    4464:	f0 e0       	ldi	r31, 0x00	; 0
    4466:	40 e0       	ldi	r20, 0x00	; 0
    4468:	ee 0f       	add	r30, r30
    446a:	ff 1f       	adc	r31, r31
    446c:	df 01       	movw	r26, r30
    446e:	a8 55       	subi	r26, 0x58	; 88
    4470:	bd 4f       	sbci	r27, 0xFD	; 253
    4472:	8d 91       	ld	r24, X+
    4474:	9c 91       	ld	r25, X
    4476:	28 1b       	sub	r18, r24
    4478:	39 0b       	sbc	r19, r25
    447a:	e0 55       	subi	r30, 0x50	; 80
    447c:	fd 4f       	sbci	r31, 0xFD	; 253
    447e:	80 81       	ld	r24, Z
    4480:	91 81       	ldd	r25, Z+1	; 0x01
    4482:	28 17       	cp	r18, r24
    4484:	39 07       	cpc	r19, r25
    4486:	08 f0       	brcs	.+2      	; 0x448a <CheckTimer+0x30>
    4488:	41 e0       	ldi	r20, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    448a:	84 2f       	mov	r24, r20
    448c:	08 95       	ret

0000448e <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    448e:	cf 93       	push	r28
    4490:	df 93       	push	r29
    4492:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    4494:	20 91 41 03 	lds	r18, 0x0341
    4498:	22 23       	and	r18, r18
    449a:	19 f1       	breq	.+70     	; 0x44e2 <GetMidiMessageFromIncomingFifo+0x54>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    449c:	90 91 c0 02 	lds	r25, 0x02C0
    44a0:	e9 2f       	mov	r30, r25
    44a2:	f0 e0       	ldi	r31, 0x00	; 0
    44a4:	ee 0f       	add	r30, r30
    44a6:	ff 1f       	adc	r31, r31
    44a8:	ee 0f       	add	r30, r30
    44aa:	ff 1f       	adc	r31, r31
    44ac:	df 01       	movw	r26, r30
    44ae:	a0 5f       	subi	r26, 0xF0	; 240
    44b0:	bc 4f       	sbci	r27, 0xFC	; 252
    44b2:	11 96       	adiw	r26, 0x01	; 1
    44b4:	8c 91       	ld	r24, X
    44b6:	11 97       	sbiw	r26, 0x01	; 1
    44b8:	89 83       	std	Y+1, r24	; 0x01
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    44ba:	ee 5e       	subi	r30, 0xEE	; 238
    44bc:	fc 4f       	sbci	r31, 0xFC	; 252
    44be:	80 81       	ld	r24, Z
    44c0:	8a 83       	std	Y+2, r24	; 0x02
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    44c2:	13 96       	adiw	r26, 0x03	; 3
    44c4:	8c 91       	ld	r24, X
    44c6:	13 97       	sbiw	r26, 0x03	; 3
    44c8:	8b 83       	std	Y+3, r24	; 0x03
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    44ca:	8c 91       	ld	r24, X
    44cc:	88 83       	st	Y, r24

		midiIncomingFifoReadPointer++;			// read from the next element next time
    44ce:	9f 5f       	subi	r25, 0xFF	; 255
    44d0:	90 93 c0 02 	sts	0x02C0, r25
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    44d4:	96 30       	cpi	r25, 0x06	; 6
    44d6:	10 f0       	brcs	.+4      	; 0x44dc <GetMidiMessageFromIncomingFifo+0x4e>
		{
			midiIncomingFifoReadPointer=0;
    44d8:	10 92 c0 02 	sts	0x02C0, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    44dc:	21 50       	subi	r18, 0x01	; 1
    44de:	20 93 41 03 	sts	0x0341, r18
	}
}
    44e2:	df 91       	pop	r29
    44e4:	cf 91       	pop	r28
    44e6:	08 95       	ret

000044e8 <PutMidiMessageInIncomingFifo>:

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    44e8:	cf 93       	push	r28
    44ea:	df 93       	push	r29
    44ec:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    44ee:	20 91 41 03 	lds	r18, 0x0341
    44f2:	26 30       	cpi	r18, 0x06	; 6
    44f4:	18 f5       	brcc	.+70     	; 0x453c <PutMidiMessageInIncomingFifo+0x54>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    44f6:	90 91 bf 02 	lds	r25, 0x02BF
    44fa:	e9 2f       	mov	r30, r25
    44fc:	f0 e0       	ldi	r31, 0x00	; 0
    44fe:	ee 0f       	add	r30, r30
    4500:	ff 1f       	adc	r31, r31
    4502:	ee 0f       	add	r30, r30
    4504:	ff 1f       	adc	r31, r31
    4506:	df 01       	movw	r26, r30
    4508:	a0 5f       	subi	r26, 0xF0	; 240
    450a:	bc 4f       	sbci	r27, 0xFC	; 252
    450c:	89 81       	ldd	r24, Y+1	; 0x01
    450e:	11 96       	adiw	r26, 0x01	; 1
    4510:	8c 93       	st	X, r24
    4512:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4514:	ee 5e       	subi	r30, 0xEE	; 238
    4516:	fc 4f       	sbci	r31, 0xFC	; 252
    4518:	8a 81       	ldd	r24, Y+2	; 0x02
    451a:	80 83       	st	Z, r24
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    451c:	8b 81       	ldd	r24, Y+3	; 0x03
    451e:	13 96       	adiw	r26, 0x03	; 3
    4520:	8c 93       	st	X, r24
    4522:	13 97       	sbiw	r26, 0x03	; 3
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    4524:	88 81       	ld	r24, Y
    4526:	8c 93       	st	X, r24
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    4528:	9f 5f       	subi	r25, 0xFF	; 255
    452a:	90 93 bf 02 	sts	0x02BF, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    452e:	96 30       	cpi	r25, 0x06	; 6
    4530:	10 f0       	brcs	.+4      	; 0x4536 <PutMidiMessageInIncomingFifo+0x4e>
		{
			midiIncomingFifoWritePointer=0;
    4532:	10 92 bf 02 	sts	0x02BF, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    4536:	2f 5f       	subi	r18, 0xFF	; 255
    4538:	20 93 41 03 	sts	0x0341, r18
	}
}
    453c:	df 91       	pop	r29
    453e:	cf 91       	pop	r28
    4540:	08 95       	ret

00004542 <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    4542:	30 91 42 03 	lds	r19, 0x0342
    4546:	36 30       	cpi	r19, 0x06	; 6
    4548:	08 f5       	brcc	.+66     	; 0x458c <PutMidiMessageInOutgoingFifo+0x4a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    454a:	90 91 c2 02 	lds	r25, 0x02C2
    454e:	e9 2f       	mov	r30, r25
    4550:	f0 e0       	ldi	r31, 0x00	; 0
    4552:	ee 0f       	add	r30, r30
    4554:	ff 1f       	adc	r31, r31
    4556:	ee 0f       	add	r30, r30
    4558:	ff 1f       	adc	r31, r31
    455a:	df 01       	movw	r26, r30
    455c:	a7 5d       	subi	r26, 0xD7	; 215
    455e:	bc 4f       	sbci	r27, 0xFC	; 252
    4560:	11 96       	adiw	r26, 0x01	; 1
    4562:	6c 93       	st	X, r22
    4564:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    4566:	e5 5d       	subi	r30, 0xD5	; 213
    4568:	fc 4f       	sbci	r31, 0xFC	; 252
    456a:	40 83       	st	Z, r20
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    456c:	13 96       	adiw	r26, 0x03	; 3
    456e:	2c 93       	st	X, r18
    4570:	13 97       	sbiw	r26, 0x03	; 3
    4572:	80 91 0f 03 	lds	r24, 0x030F
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    4576:	8c 93       	st	X, r24
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    4578:	9f 5f       	subi	r25, 0xFF	; 255
    457a:	90 93 c2 02 	sts	0x02C2, r25
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    457e:	96 30       	cpi	r25, 0x06	; 6
    4580:	10 f0       	brcs	.+4      	; 0x4586 <PutMidiMessageInOutgoingFifo+0x44>
		{
			midiOutgoingFifoWritePointer=0;
    4582:	10 92 c2 02 	sts	0x02C2, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    4586:	3f 5f       	subi	r19, 0xFF	; 255
    4588:	30 93 42 03 	sts	0x0342, r19
    458c:	08 95       	ret

0000458e <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    458e:	89 e0       	ldi	r24, 0x09	; 9
    4590:	80 93 c1 02 	sts	0x02C1, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    4594:	10 92 c4 02 	sts	0x02C4, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    4598:	10 92 41 03 	sts	0x0341, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    459c:	10 92 bf 02 	sts	0x02BF, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    45a0:	10 92 c0 02 	sts	0x02C0, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    45a4:	10 92 42 03 	sts	0x0342, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    45a8:	10 92 c2 02 	sts	0x02C2, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    45ac:	10 92 c3 02 	sts	0x02C3, r1
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
	InitMidiIncomingFifo();								// Set up the receiving buffer.
	InitMidiOutgoingFifo();								// Set up xmit buffer.
}
    45b0:	08 95       	ret

000045b2 <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    45b2:	1f 93       	push	r17
    45b4:	df 93       	push	r29
    45b6:	cf 93       	push	r28
    45b8:	00 d0       	rcall	.+0      	; 0x45ba <HandleIncomingMidiByte+0x8>
    45ba:	00 d0       	rcall	.+0      	; 0x45bc <HandleIncomingMidiByte+0xa>
    45bc:	cd b7       	in	r28, 0x3d	; 61
    45be:	de b7       	in	r29, 0x3e	; 62
    45c0:	28 2f       	mov	r18, r24
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    45c2:	87 ff       	sbrs	r24, 7
    45c4:	41 c0       	rjmp	.+130    	; 0x4648 <HandleIncomingMidiByte+0x96>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    45c6:	68 2f       	mov	r22, r24
    45c8:	70 e0       	ldi	r23, 0x00	; 0
    45ca:	9b 01       	movw	r18, r22
    45cc:	2f 70       	andi	r18, 0x0F	; 15
    45ce:	30 70       	andi	r19, 0x00	; 0
    45d0:	80 91 0f 03 	lds	r24, 0x030F
    45d4:	48 2f       	mov	r20, r24
    45d6:	50 e0       	ldi	r21, 0x00	; 0
    45d8:	24 17       	cp	r18, r20
    45da:	35 07       	cpc	r19, r21
    45dc:	39 f0       	breq	.+14     	; 0x45ec <HandleIncomingMidiByte+0x3a>
    45de:	80 91 28 03 	lds	r24, 0x0328
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	28 17       	cp	r18, r24
    45e6:	39 07       	cpc	r19, r25
    45e8:	09 f0       	breq	.+2      	; 0x45ec <HandleIncomingMidiByte+0x3a>
    45ea:	ad c0       	rjmp	.+346    	; 0x4746 <HandleIncomingMidiByte+0x194>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    45ec:	cb 01       	movw	r24, r22
    45ee:	80 7f       	andi	r24, 0xF0	; 240
    45f0:	90 70       	andi	r25, 0x00	; 0
    45f2:	80 39       	cpi	r24, 0x90	; 144
    45f4:	91 05       	cpc	r25, r1
    45f6:	19 f4       	brne	.+6      	; 0x45fe <HandleIncomingMidiByte+0x4c>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    45f8:	10 92 c1 02 	sts	0x02C1, r1
    45fc:	1b c0       	rjmp	.+54     	; 0x4634 <HandleIncomingMidiByte+0x82>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    45fe:	80 38       	cpi	r24, 0x80	; 128
    4600:	91 05       	cpc	r25, r1
    4602:	39 f4       	brne	.+14     	; 0x4612 <HandleIncomingMidiByte+0x60>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    4604:	81 e0       	ldi	r24, 0x01	; 1
    4606:	80 93 c1 02 	sts	0x02C1, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    460a:	24 17       	cp	r18, r20
    460c:	35 07       	cpc	r19, r21
    460e:	c9 f4       	brne	.+50     	; 0x4642 <HandleIncomingMidiByte+0x90>
    4610:	14 c0       	rjmp	.+40     	; 0x463a <HandleIncomingMidiByte+0x88>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    4612:	80 3c       	cpi	r24, 0xC0	; 192
    4614:	91 05       	cpc	r25, r1
    4616:	11 f4       	brne	.+4      	; 0x461c <HandleIncomingMidiByte+0x6a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    4618:	82 e0       	ldi	r24, 0x02	; 2
    461a:	0a c0       	rjmp	.+20     	; 0x4630 <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    461c:	80 3e       	cpi	r24, 0xE0	; 224
    461e:	91 05       	cpc	r25, r1
    4620:	11 f4       	brne	.+4      	; 0x4626 <HandleIncomingMidiByte+0x74>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    4622:	87 e0       	ldi	r24, 0x07	; 7
    4624:	05 c0       	rjmp	.+10     	; 0x4630 <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    4626:	80 3b       	cpi	r24, 0xB0	; 176
    4628:	91 05       	cpc	r25, r1
    462a:	09 f0       	breq	.+2      	; 0x462e <HandleIncomingMidiByte+0x7c>
    462c:	8c c0       	rjmp	.+280    	; 0x4746 <HandleIncomingMidiByte+0x194>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    462e:	83 e0       	ldi	r24, 0x03	; 3
    4630:	80 93 c1 02 	sts	0x02C1, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    4634:	24 17       	cp	r18, r20
    4636:	35 07       	cpc	r19, r21
    4638:	19 f4       	brne	.+6      	; 0x4640 <HandleIncomingMidiByte+0x8e>
				{
					temporaryChannel=BANK_0;
    463a:	10 92 bd 02 	sts	0x02BD, r1
    463e:	86 c0       	rjmp	.+268    	; 0x474c <HandleIncomingMidiByte+0x19a>
				}
				else
				{
					temporaryChannel=BANK_1;
    4640:	81 e0       	ldi	r24, 0x01	; 1
    4642:	80 93 bd 02 	sts	0x02BD, r24
    4646:	82 c0       	rjmp	.+260    	; 0x474c <HandleIncomingMidiByte+0x19a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    4648:	10 91 c1 02 	lds	r17, 0x02C1
    464c:	14 30       	cpi	r17, 0x04	; 4
    464e:	09 f4       	brne	.+2      	; 0x4652 <HandleIncomingMidiByte+0xa0>
    4650:	58 c0       	rjmp	.+176    	; 0x4702 <HandleIncomingMidiByte+0x150>
    4652:	15 30       	cpi	r17, 0x05	; 5
    4654:	58 f4       	brcc	.+22     	; 0x466c <HandleIncomingMidiByte+0xba>
    4656:	11 30       	cpi	r17, 0x01	; 1
    4658:	c1 f1       	breq	.+112    	; 0x46ca <HandleIncomingMidiByte+0x118>
    465a:	11 30       	cpi	r17, 0x01	; 1
    465c:	c8 f0       	brcs	.+50     	; 0x4690 <HandleIncomingMidiByte+0xde>
    465e:	12 30       	cpi	r17, 0x02	; 2
    4660:	09 f4       	brne	.+2      	; 0x4664 <HandleIncomingMidiByte+0xb2>
    4662:	46 c0       	rjmp	.+140    	; 0x46f0 <HandleIncomingMidiByte+0x13e>
    4664:	13 30       	cpi	r17, 0x03	; 3
    4666:	09 f0       	breq	.+2      	; 0x466a <HandleIncomingMidiByte+0xb8>
    4668:	6e c0       	rjmp	.+220    	; 0x4746 <HandleIncomingMidiByte+0x194>
    466a:	47 c0       	rjmp	.+142    	; 0x46fa <HandleIncomingMidiByte+0x148>
    466c:	17 30       	cpi	r17, 0x07	; 7
    466e:	09 f4       	brne	.+2      	; 0x4672 <HandleIncomingMidiByte+0xc0>
    4670:	56 c0       	rjmp	.+172    	; 0x471e <HandleIncomingMidiByte+0x16c>
    4672:	18 30       	cpi	r17, 0x08	; 8
    4674:	30 f4       	brcc	.+12     	; 0x4682 <HandleIncomingMidiByte+0xd0>
    4676:	15 30       	cpi	r17, 0x05	; 5
    4678:	79 f0       	breq	.+30     	; 0x4698 <HandleIncomingMidiByte+0xe6>
    467a:	16 30       	cpi	r17, 0x06	; 6
    467c:	09 f0       	breq	.+2      	; 0x4680 <HandleIncomingMidiByte+0xce>
    467e:	63 c0       	rjmp	.+198    	; 0x4746 <HandleIncomingMidiByte+0x194>
    4680:	28 c0       	rjmp	.+80     	; 0x46d2 <HandleIncomingMidiByte+0x120>
    4682:	18 30       	cpi	r17, 0x08	; 8
    4684:	09 f4       	brne	.+2      	; 0x4688 <HandleIncomingMidiByte+0xd6>
    4686:	4f c0       	rjmp	.+158    	; 0x4726 <HandleIncomingMidiByte+0x174>
    4688:	19 30       	cpi	r17, 0x09	; 9
    468a:	09 f0       	breq	.+2      	; 0x468e <HandleIncomingMidiByte+0xdc>
    468c:	5c c0       	rjmp	.+184    	; 0x4746 <HandleIncomingMidiByte+0x194>
    468e:	5e c0       	rjmp	.+188    	; 0x474c <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    4690:	80 93 be 02 	sts	0x02BE, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    4694:	85 e0       	ldi	r24, 0x05	; 5
    4696:	58 c0       	rjmp	.+176    	; 0x4748 <HandleIncomingMidiByte+0x196>
    4698:	30 91 be 02 	lds	r19, 0x02BE
    469c:	40 91 bd 02 	lds	r20, 0x02BD
    46a0:	be 01       	movw	r22, r28
    46a2:	6f 5f       	subi	r22, 0xFF	; 255
    46a4:	7f 4f       	sbci	r23, 0xFF	; 255
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    46a6:	88 23       	and	r24, r24
    46a8:	29 f4       	brne	.+10     	; 0x46b4 <HandleIncomingMidiByte+0x102>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    46aa:	82 e0       	ldi	r24, 0x02	; 2
    46ac:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    46ae:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    46b0:	1c 82       	std	Y+4, r1	; 0x04
    46b2:	04 c0       	rjmp	.+8      	; 0x46bc <HandleIncomingMidiByte+0x10a>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    46b4:	81 e0       	ldi	r24, 0x01	; 1
    46b6:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    46b8:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    46ba:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    46bc:	49 83       	std	Y+1, r20	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    46be:	cb 01       	movw	r24, r22
    46c0:	0e 94 74 22 	call	0x44e8	; 0x44e8 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    46c4:	10 92 c1 02 	sts	0x02C1, r1
    46c8:	41 c0       	rjmp	.+130    	; 0x474c <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    46ca:	80 93 be 02 	sts	0x02BE, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    46ce:	86 e0       	ldi	r24, 0x06	; 6
    46d0:	3b c0       	rjmp	.+118    	; 0x4748 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    46d2:	82 e0       	ldi	r24, 0x02	; 2
    46d4:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    46d6:	80 91 be 02 	lds	r24, 0x02BE
    46da:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    46dc:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    46de:	80 91 bd 02 	lds	r24, 0x02BD
    46e2:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    46e4:	ce 01       	movw	r24, r28
    46e6:	01 96       	adiw	r24, 0x01	; 1
    46e8:	0e 94 74 22 	call	0x44e8	; 0x44e8 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    46ec:	81 e0       	ldi	r24, 0x01	; 1
    46ee:	2c c0       	rjmp	.+88     	; 0x4748 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    46f0:	83 e0       	ldi	r24, 0x03	; 3
    46f2:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    46f4:	2b 83       	std	Y+3, r18	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    46f6:	1c 82       	std	Y+4, r1	; 0x04
    46f8:	1c c0       	rjmp	.+56     	; 0x4732 <HandleIncomingMidiByte+0x180>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    46fa:	80 93 be 02 	sts	0x02BE, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    46fe:	84 e0       	ldi	r24, 0x04	; 4
    4700:	23 c0       	rjmp	.+70     	; 0x4748 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    4702:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    4704:	80 91 be 02 	lds	r24, 0x02BE
    4708:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    470a:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    470c:	80 91 bd 02 	lds	r24, 0x02BD
    4710:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    4712:	ce 01       	movw	r24, r28
    4714:	01 96       	adiw	r24, 0x01	; 1
    4716:	0e 94 74 22 	call	0x44e8	; 0x44e8 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    471a:	83 e0       	ldi	r24, 0x03	; 3
    471c:	15 c0       	rjmp	.+42     	; 0x4748 <HandleIncomingMidiByte+0x196>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    471e:	80 93 be 02 	sts	0x02BE, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    4722:	88 e0       	ldi	r24, 0x08	; 8
    4724:	11 c0       	rjmp	.+34     	; 0x4748 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    4726:	17 e0       	ldi	r17, 0x07	; 7
    4728:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    472a:	80 91 be 02 	lds	r24, 0x02BE
    472e:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    4730:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    4732:	80 91 bd 02 	lds	r24, 0x02BD
    4736:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    4738:	ce 01       	movw	r24, r28
    473a:	01 96       	adiw	r24, 0x01	; 1
    473c:	0e 94 74 22 	call	0x44e8	; 0x44e8 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    4740:	10 93 c1 02 	sts	0x02C1, r17
    4744:	03 c0       	rjmp	.+6      	; 0x474c <HandleIncomingMidiByte+0x19a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    4746:	89 e0       	ldi	r24, 0x09	; 9
    4748:	80 93 c1 02 	sts	0x02C1, r24
			break;
		}	
	}
}
    474c:	0f 90       	pop	r0
    474e:	0f 90       	pop	r0
    4750:	0f 90       	pop	r0
    4752:	0f 90       	pop	r0
    4754:	cf 91       	pop	r28
    4756:	df 91       	pop	r29
    4758:	1f 91       	pop	r17
    475a:	08 95       	ret

0000475c <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    475c:	80 91 42 03 	lds	r24, 0x0342
    4760:	88 23       	and	r24, r24
    4762:	11 f0       	breq	.+4      	; 0x4768 <MidiTxBufferNotEmpty+0xc>
    4764:	81 e0       	ldi	r24, 0x01	; 1
    4766:	08 95       	ret
    4768:	80 91 c4 02 	lds	r24, 0x02C4
    476c:	81 11       	cpse	r24, r1
    476e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    4770:	08 95       	ret

00004772 <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    4772:	80 91 c4 02 	lds	r24, 0x02C4
    4776:	83 30       	cpi	r24, 0x03	; 3
    4778:	09 f4       	brne	.+2      	; 0x477c <PopOutgoingMidiByte+0xa>
    477a:	91 c0       	rjmp	.+290    	; 0x489e <PopOutgoingMidiByte+0x12c>
    477c:	84 30       	cpi	r24, 0x04	; 4
    477e:	38 f4       	brcc	.+14     	; 0x478e <PopOutgoingMidiByte+0x1c>
    4780:	81 30       	cpi	r24, 0x01	; 1
    4782:	09 f4       	brne	.+2      	; 0x4786 <PopOutgoingMidiByte+0x14>
    4784:	88 c0       	rjmp	.+272    	; 0x4896 <PopOutgoingMidiByte+0x124>
    4786:	82 30       	cpi	r24, 0x02	; 2
    4788:	08 f0       	brcs	.+2      	; 0x478c <PopOutgoingMidiByte+0x1a>
    478a:	87 c0       	rjmp	.+270    	; 0x489a <PopOutgoingMidiByte+0x128>
    478c:	0d c0       	rjmp	.+26     	; 0x47a8 <PopOutgoingMidiByte+0x36>
    478e:	85 30       	cpi	r24, 0x05	; 5
    4790:	09 f4       	brne	.+2      	; 0x4794 <PopOutgoingMidiByte+0x22>
    4792:	8c c0       	rjmp	.+280    	; 0x48ac <PopOutgoingMidiByte+0x13a>
    4794:	85 30       	cpi	r24, 0x05	; 5
    4796:	08 f4       	brcc	.+2      	; 0x479a <PopOutgoingMidiByte+0x28>
    4798:	86 c0       	rjmp	.+268    	; 0x48a6 <PopOutgoingMidiByte+0x134>
    479a:	86 30       	cpi	r24, 0x06	; 6
    479c:	09 f4       	brne	.+2      	; 0x47a0 <PopOutgoingMidiByte+0x2e>
    479e:	89 c0       	rjmp	.+274    	; 0x48b2 <PopOutgoingMidiByte+0x140>
    47a0:	87 30       	cpi	r24, 0x07	; 7
    47a2:	09 f0       	breq	.+2      	; 0x47a6 <PopOutgoingMidiByte+0x34>
    47a4:	91 c0       	rjmp	.+290    	; 0x48c8 <PopOutgoingMidiByte+0x156>
    47a6:	8b c0       	rjmp	.+278    	; 0x48be <PopOutgoingMidiByte+0x14c>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    47a8:	20 91 42 03 	lds	r18, 0x0342
    47ac:	22 23       	and	r18, r18
    47ae:	39 f1       	breq	.+78     	; 0x47fe <PopOutgoingMidiByte+0x8c>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    47b0:	90 91 c3 02 	lds	r25, 0x02C3
    47b4:	e9 2f       	mov	r30, r25
    47b6:	f0 e0       	ldi	r31, 0x00	; 0
    47b8:	ee 0f       	add	r30, r30
    47ba:	ff 1f       	adc	r31, r31
    47bc:	ee 0f       	add	r30, r30
    47be:	ff 1f       	adc	r31, r31
    47c0:	df 01       	movw	r26, r30
    47c2:	a7 5d       	subi	r26, 0xD7	; 215
    47c4:	bc 4f       	sbci	r27, 0xFC	; 252
    47c6:	11 96       	adiw	r26, 0x01	; 1
    47c8:	8c 91       	ld	r24, X
    47ca:	11 97       	sbiw	r26, 0x01	; 1
    47cc:	80 93 ba 02 	sts	0x02BA, r24
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    47d0:	e5 5d       	subi	r30, 0xD5	; 213
    47d2:	fc 4f       	sbci	r31, 0xFC	; 252
    47d4:	80 81       	ld	r24, Z
    47d6:	80 93 bb 02 	sts	0x02BB, r24
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    47da:	13 96       	adiw	r26, 0x03	; 3
    47dc:	8c 91       	ld	r24, X
    47de:	13 97       	sbiw	r26, 0x03	; 3
    47e0:	80 93 bc 02 	sts	0x02BC, r24
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    47e4:	8c 91       	ld	r24, X
    47e6:	80 93 b9 02 	sts	0x02B9, r24

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    47ea:	9f 5f       	subi	r25, 0xFF	; 255
    47ec:	90 93 c3 02 	sts	0x02C3, r25
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    47f0:	96 30       	cpi	r25, 0x06	; 6
    47f2:	10 f0       	brcs	.+4      	; 0x47f8 <PopOutgoingMidiByte+0x86>
		{
			midiOutgoingFifoReadPointer=0;
    47f4:	10 92 c3 02 	sts	0x02C3, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    47f8:	21 50       	subi	r18, 0x01	; 1
    47fa:	20 93 42 03 	sts	0x0342, r18
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    47fe:	20 91 ba 02 	lds	r18, 0x02BA
    4802:	22 30       	cpi	r18, 0x02	; 2
    4804:	b9 f0       	breq	.+46     	; 0x4834 <PopOutgoingMidiByte+0xc2>
    4806:	23 30       	cpi	r18, 0x03	; 3
    4808:	20 f4       	brcc	.+8      	; 0x4812 <PopOutgoingMidiByte+0xa0>
    480a:	21 30       	cpi	r18, 0x01	; 1
    480c:	09 f0       	breq	.+2      	; 0x4810 <PopOutgoingMidiByte+0x9e>
    480e:	5c c0       	rjmp	.+184    	; 0x48c8 <PopOutgoingMidiByte+0x156>
    4810:	06 c0       	rjmp	.+12     	; 0x481e <PopOutgoingMidiByte+0xac>
    4812:	23 30       	cpi	r18, 0x03	; 3
    4814:	f9 f0       	breq	.+62     	; 0x4854 <PopOutgoingMidiByte+0xe2>
    4816:	24 30       	cpi	r18, 0x04	; 4
    4818:	09 f0       	breq	.+2      	; 0x481c <PopOutgoingMidiByte+0xaa>
    481a:	56 c0       	rjmp	.+172    	; 0x48c8 <PopOutgoingMidiByte+0x156>
    481c:	2b c0       	rjmp	.+86     	; 0x4874 <PopOutgoingMidiByte+0x102>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    481e:	90 91 b9 02 	lds	r25, 0x02B9
    4822:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    4824:	80 91 b8 02 	lds	r24, 0x02B8
    4828:	89 17       	cp	r24, r25
    482a:	79 f4       	brne	.+30     	; 0x484a <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    482c:	90 91 bb 02 	lds	r25, 0x02BB
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4830:	83 e0       	ldi	r24, 0x03	; 3
    4832:	2a c0       	rjmp	.+84     	; 0x4888 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    4834:	90 91 b9 02 	lds	r25, 0x02B9
    4838:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    483a:	80 91 b8 02 	lds	r24, 0x02B8
    483e:	89 17       	cp	r24, r25
    4840:	21 f4       	brne	.+8      	; 0x484a <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    4842:	90 91 bb 02 	lds	r25, 0x02BB
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    4846:	84 e0       	ldi	r24, 0x04	; 4
    4848:	1f c0       	rjmp	.+62     	; 0x4888 <PopOutgoingMidiByte+0x116>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    484a:	90 93 b8 02 	sts	0x02B8, r25
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
    484e:	20 93 c4 02 	sts	0x02C4, r18
    4852:	3b c0       	rjmp	.+118    	; 0x48ca <PopOutgoingMidiByte+0x158>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    4854:	90 91 b9 02 	lds	r25, 0x02B9
    4858:	90 6c       	ori	r25, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    485a:	80 91 b8 02 	lds	r24, 0x02B8
    485e:	89 17       	cp	r24, r25
    4860:	29 f4       	brne	.+10     	; 0x486c <PopOutgoingMidiByte+0xfa>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    4862:	90 91 bb 02 	lds	r25, 0x02BB
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    4866:	10 92 c4 02 	sts	0x02C4, r1
    486a:	2f c0       	rjmp	.+94     	; 0x48ca <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    486c:	90 93 b8 02 	sts	0x02B8, r25
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    4870:	85 e0       	ldi	r24, 0x05	; 5
    4872:	0a c0       	rjmp	.+20     	; 0x4888 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4874:	90 91 b9 02 	lds	r25, 0x02B9
    4878:	90 6b       	ori	r25, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    487a:	80 91 b8 02 	lds	r24, 0x02B8
    487e:	89 17       	cp	r24, r25
    4880:	31 f4       	brne	.+12     	; 0x488e <PopOutgoingMidiByte+0x11c>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    4882:	90 91 bb 02 	lds	r25, 0x02BB
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4886:	87 e0       	ldi	r24, 0x07	; 7
    4888:	80 93 c4 02 	sts	0x02C4, r24
    488c:	1e c0       	rjmp	.+60     	; 0x48ca <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    488e:	90 93 b8 02 	sts	0x02B8, r25
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    4892:	86 e0       	ldi	r24, 0x06	; 6
    4894:	f9 cf       	rjmp	.-14     	; 0x4888 <PopOutgoingMidiByte+0x116>
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4896:	83 e0       	ldi	r24, 0x03	; 3
    4898:	0d c0       	rjmp	.+26     	; 0x48b4 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    489a:	84 e0       	ldi	r24, 0x04	; 4
    489c:	0b c0       	rjmp	.+22     	; 0x48b4 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    489e:	10 92 c4 02 	sts	0x02C4, r1
    48a2:	90 e4       	ldi	r25, 0x40	; 64
    48a4:	12 c0       	rjmp	.+36     	; 0x48ca <PopOutgoingMidiByte+0x158>
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    48a6:	10 92 c4 02 	sts	0x02C4, r1
    48aa:	0e c0       	rjmp	.+28     	; 0x48c8 <PopOutgoingMidiByte+0x156>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    48ac:	10 92 c4 02 	sts	0x02C4, r1
    48b0:	03 c0       	rjmp	.+6      	; 0x48b8 <PopOutgoingMidiByte+0x146>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    48b2:	87 e0       	ldi	r24, 0x07	; 7
    48b4:	80 93 c4 02 	sts	0x02C4, r24
		return(theMessage.dataByteOne);								// Return the first data byte.
    48b8:	90 91 bb 02 	lds	r25, 0x02BB
    48bc:	06 c0       	rjmp	.+12     	; 0x48ca <PopOutgoingMidiByte+0x158>
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    48be:	10 92 c4 02 	sts	0x02C4, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    48c2:	90 91 bc 02 	lds	r25, 0x02BC
    48c6:	01 c0       	rjmp	.+2      	; 0x48ca <PopOutgoingMidiByte+0x158>
    48c8:	90 e0       	ldi	r25, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    48ca:	89 2f       	mov	r24, r25
    48cc:	08 95       	ret

000048ce <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    48ce:	8a b1       	in	r24, 0x0a	; 10
    48d0:	8f 7c       	andi	r24, 0xCF	; 207
    48d2:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    48d4:	8b b1       	in	r24, 0x0b	; 11
    48d6:	80 63       	ori	r24, 0x30	; 48
    48d8:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    48da:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    48de:	e4 e6       	ldi	r30, 0x64	; 100
    48e0:	f0 e0       	ldi	r31, 0x00	; 0
    48e2:	80 81       	ld	r24, Z
    48e4:	80 61       	ori	r24, 0x10	; 16
    48e6:	80 83       	st	Z, r24
}
    48e8:	08 95       	ret

000048ea <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    48ea:	e4 e6       	ldi	r30, 0x64	; 100
    48ec:	f0 e0       	ldi	r31, 0x00	; 0
    48ee:	80 81       	ld	r24, Z
    48f0:	8f 7e       	andi	r24, 0xEF	; 239
    48f2:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    48f4:	ec ec       	ldi	r30, 0xCC	; 204
    48f6:	f0 e0       	ldi	r31, 0x00	; 0
    48f8:	11 82       	std	Z+1, r1	; 0x01
    48fa:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    48fc:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    48fe:	80 ec       	ldi	r24, 0xC0	; 192
    4900:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    4904:	88 e1       	ldi	r24, 0x18	; 24
    4906:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    490a:	81 e0       	ldi	r24, 0x01	; 1
    490c:	90 e0       	ldi	r25, 0x00	; 0
    490e:	91 83       	std	Z+1, r25	; 0x01
    4910:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    4912:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS low.
    4914:	5d 9a       	sbi	0x0b, 5	; 11
}
    4916:	08 95       	ret

00004918 <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4918:	5d 9a       	sbi	0x0b, 5	; 11
}
    491a:	08 95       	ret

0000491c <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    491c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    491e:	5d 98       	cbi	0x0b, 5	; 11
}
    4920:	08 95       	ret

00004922 <TransferSdByte>:
// Slow and careful transfers; checks both send and receive buffers and waits until they're ready to move on.
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
    4922:	98 2f       	mov	r25, r24
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4924:	80 91 c8 00 	lds	r24, 0x00C8
    4928:	85 ff       	sbrs	r24, 5
    492a:	fc cf       	rjmp	.-8      	; 0x4924 <TransferSdByte+0x2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    492c:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4930:	80 91 c8 00 	lds	r24, 0x00C8
    4934:	87 ff       	sbrs	r24, 7
    4936:	fc cf       	rjmp	.-8      	; 0x4930 <TransferSdByte+0xe>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4938:	80 91 ce 00 	lds	r24, 0x00CE
}
    493c:	08 95       	ret

0000493e <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    493e:	80 91 c8 00 	lds	r24, 0x00C8
    4942:	80 64       	ori	r24, 0x40	; 64
    4944:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4948:	80 91 c8 00 	lds	r24, 0x00C8
    494c:	85 ff       	sbrs	r24, 5
    494e:	fc cf       	rjmp	.-8      	; 0x4948 <SendDummyByte+0xa>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4950:	8f ef       	ldi	r24, 0xFF	; 255
    4952:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4956:	80 91 c8 00 	lds	r24, 0x00C8
    495a:	87 ff       	sbrs	r24, 7
    495c:	fc cf       	rjmp	.-8      	; 0x4956 <SendDummyByte+0x18>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    495e:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4962:	80 91 c8 00 	lds	r24, 0x00C8
    4966:	86 ff       	sbrs	r24, 6
    4968:	fc cf       	rjmp	.-8      	; 0x4962 <SendDummyByte+0x24>
		;
}
    496a:	08 95       	ret

0000496c <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    496c:	1f 93       	push	r17
    496e:	28 2f       	mov	r18, r24

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4970:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    4972:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4974:	80 91 c8 00 	lds	r24, 0x00C8
    4978:	85 ff       	sbrs	r24, 5
    497a:	fc cf       	rjmp	.-8      	; 0x4974 <SendSdCommand+0x8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    497c:	8f ef       	ldi	r24, 0xFF	; 255
    497e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4982:	80 91 c8 00 	lds	r24, 0x00C8
    4986:	87 ff       	sbrs	r24, 7
    4988:	fc cf       	rjmp	.-8      	; 0x4982 <SendSdCommand+0x16>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    498a:	80 91 ce 00 	lds	r24, 0x00CE
		tmpCrc;

	StartSdTransfer();		// Assert CS
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    498e:	27 ff       	sbrs	r18, 7
    4990:	7a c0       	rjmp	.+244    	; 0x4a86 <SendSdCommand+0x11a>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4992:	80 91 c8 00 	lds	r24, 0x00C8
    4996:	85 ff       	sbrs	r24, 5
    4998:	fc cf       	rjmp	.-8      	; 0x4992 <SendSdCommand+0x26>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    499a:	87 e7       	ldi	r24, 0x77	; 119
    499c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    49a0:	80 91 c8 00 	lds	r24, 0x00C8
    49a4:	87 ff       	sbrs	r24, 7
    49a6:	fc cf       	rjmp	.-8      	; 0x49a0 <SendSdCommand+0x34>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    49a8:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    49ac:	80 91 c8 00 	lds	r24, 0x00C8
    49b0:	85 ff       	sbrs	r24, 5
    49b2:	fc cf       	rjmp	.-8      	; 0x49ac <SendSdCommand+0x40>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    49b4:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    49b8:	80 91 c8 00 	lds	r24, 0x00C8
    49bc:	87 ff       	sbrs	r24, 7
    49be:	fc cf       	rjmp	.-8      	; 0x49b8 <SendSdCommand+0x4c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    49c0:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    49c4:	80 91 c8 00 	lds	r24, 0x00C8
    49c8:	85 ff       	sbrs	r24, 5
    49ca:	fc cf       	rjmp	.-8      	; 0x49c4 <SendSdCommand+0x58>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    49cc:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    49d0:	80 91 c8 00 	lds	r24, 0x00C8
    49d4:	87 ff       	sbrs	r24, 7
    49d6:	fc cf       	rjmp	.-8      	; 0x49d0 <SendSdCommand+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    49d8:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    49dc:	80 91 c8 00 	lds	r24, 0x00C8
    49e0:	85 ff       	sbrs	r24, 5
    49e2:	fc cf       	rjmp	.-8      	; 0x49dc <SendSdCommand+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    49e4:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    49e8:	80 91 c8 00 	lds	r24, 0x00C8
    49ec:	87 ff       	sbrs	r24, 7
    49ee:	fc cf       	rjmp	.-8      	; 0x49e8 <SendSdCommand+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    49f0:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    49f4:	80 91 c8 00 	lds	r24, 0x00C8
    49f8:	85 ff       	sbrs	r24, 5
    49fa:	fc cf       	rjmp	.-8      	; 0x49f4 <SendSdCommand+0x88>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    49fc:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4a00:	80 91 c8 00 	lds	r24, 0x00C8
    4a04:	87 ff       	sbrs	r24, 7
    4a06:	fc cf       	rjmp	.-8      	; 0x4a00 <SendSdCommand+0x94>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4a08:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4a0c:	80 91 c8 00 	lds	r24, 0x00C8
    4a10:	85 ff       	sbrs	r24, 5
    4a12:	fc cf       	rjmp	.-8      	; 0x4a0c <SendSdCommand+0xa0>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4a14:	81 e0       	ldi	r24, 0x01	; 1
    4a16:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4a1a:	80 91 c8 00 	lds	r24, 0x00C8
    4a1e:	87 ff       	sbrs	r24, 7
    4a20:	fc cf       	rjmp	.-8      	; 0x4a1a <SendSdCommand+0xae>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4a22:	80 91 ce 00 	lds	r24, 0x00CE
    4a26:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4a28:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4a2a:	80 91 c8 00 	lds	r24, 0x00C8
    4a2e:	85 ff       	sbrs	r24, 5
    4a30:	fc cf       	rjmp	.-8      	; 0x4a2a <SendSdCommand+0xbe>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4a32:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4a36:	80 91 c8 00 	lds	r24, 0x00C8
    4a3a:	87 ff       	sbrs	r24, 7
    4a3c:	fc cf       	rjmp	.-8      	; 0x4a36 <SendSdCommand+0xca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4a3e:	10 91 ce 00 	lds	r17, 0x00CE
		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    4a42:	1f 3f       	cpi	r17, 0xFF	; 255
    4a44:	11 f4       	brne	.+4      	; 0x4a4a <SendSdCommand+0xde>
    4a46:	91 50       	subi	r25, 0x01	; 1
    4a48:	81 f7       	brne	.-32     	; 0x4a2a <SendSdCommand+0xbe>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4a4a:	80 91 c8 00 	lds	r24, 0x00C8
    4a4e:	80 64       	ori	r24, 0x40	; 64
    4a50:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4a54:	80 91 c8 00 	lds	r24, 0x00C8
    4a58:	85 ff       	sbrs	r24, 5
    4a5a:	fc cf       	rjmp	.-8      	; 0x4a54 <SendSdCommand+0xe8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4a5c:	8f ef       	ldi	r24, 0xFF	; 255
    4a5e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4a62:	80 91 c8 00 	lds	r24, 0x00C8
    4a66:	87 ff       	sbrs	r24, 7
    4a68:	fc cf       	rjmp	.-8      	; 0x4a62 <SendSdCommand+0xf6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4a6a:	80 91 ce 00 	lds	r24, 0x00CE
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4a6e:	80 91 c8 00 	lds	r24, 0x00C8
    4a72:	86 ff       	sbrs	r24, 6
    4a74:	fc cf       	rjmp	.-8      	; 0x4a6e <SendSdCommand+0x102>
			;

		if(response>1)				// Something wrong?
    4a76:	12 30       	cpi	r17, 0x02	; 2
    4a78:	10 f0       	brcs	.+4      	; 0x4a7e <SendSdCommand+0x112>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4a7a:	5d 9a       	sbi	0x0b, 5	; 11
    4a7c:	89 c0       	rjmp	.+274    	; 0x4b90 <SendSdCommand+0x224>
    4a7e:	5d 9a       	sbi	0x0b, 5	; 11
			EndSdTransfer();	// Bring CS high
			return(response);	// ACMD preambe returned something weird.  Bail.
		}

		EndSdTransfer();	// Bring CS high
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    4a80:	2f 77       	andi	r18, 0x7F	; 127

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4a82:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    4a84:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4a86:	80 91 c8 00 	lds	r24, 0x00C8
    4a8a:	85 ff       	sbrs	r24, 5
    4a8c:	fc cf       	rjmp	.-8      	; 0x4a86 <SendSdCommand+0x11a>
		StartSdTransfer();	// Assert CS
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    4a8e:	82 2f       	mov	r24, r18
    4a90:	80 64       	ori	r24, 0x40	; 64
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4a92:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4a96:	80 91 c8 00 	lds	r24, 0x00C8
    4a9a:	87 ff       	sbrs	r24, 7
    4a9c:	fc cf       	rjmp	.-8      	; 0x4a96 <SendSdCommand+0x12a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4a9e:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4aa2:	80 91 c8 00 	lds	r24, 0x00C8
    4aa6:	85 ff       	sbrs	r24, 5
    4aa8:	fc cf       	rjmp	.-8      	; 0x4aa2 <SendSdCommand+0x136>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    4aaa:	87 2f       	mov	r24, r23
    4aac:	99 27       	eor	r25, r25
    4aae:	aa 27       	eor	r26, r26
    4ab0:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4ab2:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4ab6:	80 91 c8 00 	lds	r24, 0x00C8
    4aba:	87 ff       	sbrs	r24, 7
    4abc:	fc cf       	rjmp	.-8      	; 0x4ab6 <SendSdCommand+0x14a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4abe:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4ac2:	80 91 c8 00 	lds	r24, 0x00C8
    4ac6:	85 ff       	sbrs	r24, 5
    4ac8:	fc cf       	rjmp	.-8      	; 0x4ac2 <SendSdCommand+0x156>

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    4aca:	cb 01       	movw	r24, r22
    4acc:	aa 27       	eor	r26, r26
    4ace:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4ad0:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4ad4:	80 91 c8 00 	lds	r24, 0x00C8
    4ad8:	87 ff       	sbrs	r24, 7
    4ada:	fc cf       	rjmp	.-8      	; 0x4ad4 <SendSdCommand+0x168>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4adc:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4ae0:	80 91 c8 00 	lds	r24, 0x00C8
    4ae4:	85 ff       	sbrs	r24, 5
    4ae6:	fc cf       	rjmp	.-8      	; 0x4ae0 <SendSdCommand+0x174>
	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    4ae8:	bb 27       	eor	r27, r27
    4aea:	a7 2f       	mov	r26, r23
    4aec:	96 2f       	mov	r25, r22
    4aee:	85 2f       	mov	r24, r21
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4af0:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4af4:	80 91 c8 00 	lds	r24, 0x00C8
    4af8:	87 ff       	sbrs	r24, 7
    4afa:	fc cf       	rjmp	.-8      	; 0x4af4 <SendSdCommand+0x188>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4afc:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b00:	80 91 c8 00 	lds	r24, 0x00C8
    4b04:	85 ff       	sbrs	r24, 5
    4b06:	fc cf       	rjmp	.-8      	; 0x4b00 <SendSdCommand+0x194>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b08:	40 93 ce 00 	sts	0x00CE, r20

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b0c:	80 91 c8 00 	lds	r24, 0x00C8
    4b10:	87 ff       	sbrs	r24, 7
    4b12:	fc cf       	rjmp	.-8      	; 0x4b0c <SendSdCommand+0x1a0>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b14:	80 91 ce 00 	lds	r24, 0x00CE
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    4b18:	22 23       	and	r18, r18
    4b1a:	11 f4       	brne	.+4      	; 0x4b20 <SendSdCommand+0x1b4>
    4b1c:	95 e9       	ldi	r25, 0x95	; 149
    4b1e:	05 c0       	rjmp	.+10     	; 0x4b2a <SendSdCommand+0x1be>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    4b20:	28 30       	cpi	r18, 0x08	; 8
    4b22:	11 f4       	brne	.+4      	; 0x4b28 <SendSdCommand+0x1bc>
    4b24:	97 e8       	ldi	r25, 0x87	; 135
    4b26:	01 c0       	rjmp	.+2      	; 0x4b2a <SendSdCommand+0x1be>
    4b28:	91 e0       	ldi	r25, 0x01	; 1
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b2a:	80 91 c8 00 	lds	r24, 0x00C8
    4b2e:	85 ff       	sbrs	r24, 5
    4b30:	fc cf       	rjmp	.-8      	; 0x4b2a <SendSdCommand+0x1be>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b32:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b36:	80 91 c8 00 	lds	r24, 0x00C8
    4b3a:	87 ff       	sbrs	r24, 7
    4b3c:	fc cf       	rjmp	.-8      	; 0x4b36 <SendSdCommand+0x1ca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b3e:	80 91 ce 00 	lds	r24, 0x00CE
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    4b42:	2c 30       	cpi	r18, 0x0C	; 12
    4b44:	69 f4       	brne	.+26     	; 0x4b60 <SendSdCommand+0x1f4>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b46:	80 91 c8 00 	lds	r24, 0x00C8
    4b4a:	85 ff       	sbrs	r24, 5
    4b4c:	fc cf       	rjmp	.-8      	; 0x4b46 <SendSdCommand+0x1da>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b4e:	8f ef       	ldi	r24, 0xFF	; 255
    4b50:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b54:	80 91 c8 00 	lds	r24, 0x00C8
    4b58:	87 ff       	sbrs	r24, 7
    4b5a:	fc cf       	rjmp	.-8      	; 0x4b54 <SendSdCommand+0x1e8>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b5c:	80 91 ce 00 	lds	r24, 0x00CE
    4b60:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b62:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b64:	80 91 c8 00 	lds	r24, 0x00C8
    4b68:	85 ff       	sbrs	r24, 5
    4b6a:	fc cf       	rjmp	.-8      	; 0x4b64 <SendSdCommand+0x1f8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b6c:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b70:	80 91 c8 00 	lds	r24, 0x00C8
    4b74:	87 ff       	sbrs	r24, 7
    4b76:	fc cf       	rjmp	.-8      	; 0x4b70 <SendSdCommand+0x204>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b78:	10 91 ce 00 	lds	r17, 0x00CE
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    4b7c:	1f 3f       	cpi	r17, 0xFF	; 255
    4b7e:	11 f4       	brne	.+4      	; 0x4b84 <SendSdCommand+0x218>
    4b80:	91 50       	subi	r25, 0x01	; 1
    4b82:	81 f7       	brne	.-32     	; 0x4b64 <SendSdCommand+0x1f8>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    4b84:	28 30       	cpi	r18, 0x08	; 8
    4b86:	21 f0       	breq	.+8      	; 0x4b90 <SendSdCommand+0x224>
    4b88:	2a 33       	cpi	r18, 0x3A	; 58
    4b8a:	11 f0       	breq	.+4      	; 0x4b90 <SendSdCommand+0x224>
	{
		SendDummyByte();	
    4b8c:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    4b90:	81 2f       	mov	r24, r17
    4b92:	1f 91       	pop	r17
    4b94:	08 95       	ret

00004b96 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    4b96:	ab 01       	movw	r20, r22
    4b98:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    4b9a:	e9 e0       	ldi	r30, 0x09	; 9
    4b9c:	44 0f       	add	r20, r20
    4b9e:	55 1f       	adc	r21, r21
    4ba0:	66 1f       	adc	r22, r22
    4ba2:	77 1f       	adc	r23, r23
    4ba4:	ea 95       	dec	r30
    4ba6:	d1 f7       	brne	.-12     	; 0x4b9c <SdBeginSingleBlockRead+0x6>
    4ba8:	81 e1       	ldi	r24, 0x11	; 17
    4baa:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4bae:	90 e0       	ldi	r25, 0x00	; 0
    4bb0:	88 23       	and	r24, r24
    4bb2:	09 f4       	brne	.+2      	; 0x4bb6 <SdBeginSingleBlockRead+0x20>
    4bb4:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    4bb6:	89 2f       	mov	r24, r25
    4bb8:	08 95       	ret

00004bba <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    4bba:	ab 01       	movw	r20, r22
    4bbc:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    4bbe:	f9 e0       	ldi	r31, 0x09	; 9
    4bc0:	44 0f       	add	r20, r20
    4bc2:	55 1f       	adc	r21, r21
    4bc4:	66 1f       	adc	r22, r22
    4bc6:	77 1f       	adc	r23, r23
    4bc8:	fa 95       	dec	r31
    4bca:	d1 f7       	brne	.-12     	; 0x4bc0 <SdBeginSingleBlockWrite+0x6>
    4bcc:	88 e1       	ldi	r24, 0x18	; 24
    4bce:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4bd2:	90 e0       	ldi	r25, 0x00	; 0
    4bd4:	88 23       	and	r24, r24
    4bd6:	09 f4       	brne	.+2      	; 0x4bda <SdBeginSingleBlockWrite+0x20>
    4bd8:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    4bda:	89 2f       	mov	r24, r25
    4bdc:	08 95       	ret

00004bde <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    4bde:	df 93       	push	r29
    4be0:	cf 93       	push	r28
    4be2:	00 d0       	rcall	.+0      	; 0x4be4 <SdHandshake+0x6>
    4be4:	00 d0       	rcall	.+0      	; 0x4be6 <SdHandshake+0x8>
    4be6:	cd b7       	in	r28, 0x3d	; 61
    4be8:	de b7       	in	r29, 0x3e	; 62
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4bea:	5d 9a       	sbi	0x0b, 5	; 11
    4bec:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4bee:	2f ef       	ldi	r18, 0xFF	; 255
	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4bf0:	80 91 c8 00 	lds	r24, 0x00C8
    4bf4:	80 64       	ori	r24, 0x40	; 64
    4bf6:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4bfa:	80 91 c8 00 	lds	r24, 0x00C8
    4bfe:	85 ff       	sbrs	r24, 5
    4c00:	fc cf       	rjmp	.-8      	; 0x4bfa <SdHandshake+0x1c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4c02:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4c06:	80 91 c8 00 	lds	r24, 0x00C8
    4c0a:	87 ff       	sbrs	r24, 7
    4c0c:	fc cf       	rjmp	.-8      	; 0x4c06 <SdHandshake+0x28>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4c0e:	80 91 ce 00 	lds	r24, 0x00CE
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    4c12:	9f 5f       	subi	r25, 0xFF	; 255
    4c14:	94 31       	cpi	r25, 0x14	; 20
    4c16:	61 f7       	brne	.-40     	; 0x4bf0 <SdHandshake+0x12>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4c18:	80 91 c8 00 	lds	r24, 0x00C8
    4c1c:	86 ff       	sbrs	r24, 6
    4c1e:	fc cf       	rjmp	.-8      	; 0x4c18 <SdHandshake+0x3a>

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4c20:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    4c22:	5d 98       	cbi	0x0b, 5	; 11
    4c24:	20 e0       	ldi	r18, 0x00	; 0
    4c26:	30 e0       	ldi	r19, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4c28:	9f ef       	ldi	r25, 0xFF	; 255
	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4c2a:	80 91 c8 00 	lds	r24, 0x00C8
    4c2e:	80 64       	ori	r24, 0x40	; 64
    4c30:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4c34:	80 91 c8 00 	lds	r24, 0x00C8
    4c38:	85 ff       	sbrs	r24, 5
    4c3a:	fc cf       	rjmp	.-8      	; 0x4c34 <SdHandshake+0x56>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4c3c:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4c40:	80 91 c8 00 	lds	r24, 0x00C8
    4c44:	87 ff       	sbrs	r24, 7
    4c46:	fc cf       	rjmp	.-8      	; 0x4c40 <SdHandshake+0x62>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4c48:	80 91 ce 00 	lds	r24, 0x00CE


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    4c4c:	2f 5f       	subi	r18, 0xFF	; 255
    4c4e:	3f 4f       	sbci	r19, 0xFF	; 255
    4c50:	82 e0       	ldi	r24, 0x02	; 2
    4c52:	20 30       	cpi	r18, 0x00	; 0
    4c54:	38 07       	cpc	r19, r24
    4c56:	49 f7       	brne	.-46     	; 0x4c2a <SdHandshake+0x4c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4c58:	80 91 c8 00 	lds	r24, 0x00C8
    4c5c:	86 ff       	sbrs	r24, 6
    4c5e:	fc cf       	rjmp	.-8      	; 0x4c58 <SdHandshake+0x7a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4c60:	5d 9a       	sbi	0x0b, 5	; 11
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    4c62:	80 e0       	ldi	r24, 0x00	; 0
    4c64:	40 e0       	ldi	r20, 0x00	; 0
    4c66:	50 e0       	ldi	r21, 0x00	; 0
    4c68:	60 e0       	ldi	r22, 0x00	; 0
    4c6a:	70 e0       	ldi	r23, 0x00	; 0
    4c6c:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4c70:	80 91 c8 00 	lds	r24, 0x00C8
    4c74:	86 ff       	sbrs	r24, 6
    4c76:	fc cf       	rjmp	.-8      	; 0x4c70 <SdHandshake+0x92>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4c78:	5d 9a       	sbi	0x0b, 5	; 11
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    4c7a:	80 e0       	ldi	r24, 0x00	; 0
    4c7c:	40 e0       	ldi	r20, 0x00	; 0
    4c7e:	50 e0       	ldi	r21, 0x00	; 0
    4c80:	60 e0       	ldi	r22, 0x00	; 0
    4c82:	70 e0       	ldi	r23, 0x00	; 0
    4c84:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4c88:	81 30       	cpi	r24, 0x01	; 1
    4c8a:	09 f0       	breq	.+2      	; 0x4c8e <SdHandshake+0xb0>
    4c8c:	b4 c0       	rjmp	.+360    	; 0x4df6 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4c8e:	5d 9a       	sbi	0x0b, 5	; 11
	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    4c90:	88 e0       	ldi	r24, 0x08	; 8
    4c92:	4a ea       	ldi	r20, 0xAA	; 170
    4c94:	51 e0       	ldi	r21, 0x01	; 1
    4c96:	60 e0       	ldi	r22, 0x00	; 0
    4c98:	70 e0       	ldi	r23, 0x00	; 0
    4c9a:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4c9e:	81 30       	cpi	r24, 0x01	; 1
    4ca0:	09 f0       	breq	.+2      	; 0x4ca4 <SdHandshake+0xc6>
    4ca2:	76 c0       	rjmp	.+236    	; 0x4d90 <SdHandshake+0x1b2>
    4ca4:	fe 01       	movw	r30, r28
    4ca6:	31 96       	adiw	r30, 0x01	; 1
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4ca8:	9f ef       	ldi	r25, 0xFF	; 255
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    4caa:	9e 01       	movw	r18, r28
    4cac:	2b 5f       	subi	r18, 0xFB	; 251
    4cae:	3f 4f       	sbci	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4cb0:	80 91 c8 00 	lds	r24, 0x00C8
    4cb4:	85 ff       	sbrs	r24, 5
    4cb6:	fc cf       	rjmp	.-8      	; 0x4cb0 <SdHandshake+0xd2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4cb8:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4cbc:	80 91 c8 00 	lds	r24, 0x00C8
    4cc0:	87 ff       	sbrs	r24, 7
    4cc2:	fc cf       	rjmp	.-8      	; 0x4cbc <SdHandshake+0xde>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4cc4:	80 91 ce 00 	lds	r24, 0x00CE

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    4cc8:	81 93       	st	Z+, r24
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    4cca:	e2 17       	cp	r30, r18
    4ccc:	f3 07       	cpc	r31, r19
    4cce:	81 f7       	brne	.-32     	; 0x4cb0 <SdHandshake+0xd2>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    4cd0:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4cd4:	5d 9a       	sbi	0x0b, 5	; 11
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
			EndSdTransfer();		// Bring CS high

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    4cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    4cd8:	81 30       	cpi	r24, 0x01	; 1
    4cda:	09 f0       	breq	.+2      	; 0x4cde <SdHandshake+0x100>
    4cdc:	8c c0       	rjmp	.+280    	; 0x4df6 <SdHandshake+0x218>
    4cde:	8c 81       	ldd	r24, Y+4	; 0x04
    4ce0:	8a 3a       	cpi	r24, 0xAA	; 170
    4ce2:	09 f0       	breq	.+2      	; 0x4ce6 <SdHandshake+0x108>
    4ce4:	88 c0       	rjmp	.+272    	; 0x4df6 <SdHandshake+0x218>
			{				
				SetTimer(TIMER_SD,SECOND);
    4ce6:	83 e0       	ldi	r24, 0x03	; 3
    4ce8:	64 ec       	ldi	r22, 0xC4	; 196
    4cea:	74 e0       	ldi	r23, 0x04	; 4
    4cec:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
    4cf0:	03 c0       	rjmp	.+6      	; 0x4cf8 <SdHandshake+0x11a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4cf2:	5d 9a       	sbi	0x0b, 5	; 11
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
    4cf4:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    4cf8:	83 e0       	ldi	r24, 0x03	; 3
    4cfa:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4cfe:	88 23       	and	r24, r24
    4d00:	49 f4       	brne	.+18     	; 0x4d14 <SdHandshake+0x136>
    4d02:	89 ea       	ldi	r24, 0xA9	; 169
    4d04:	40 e0       	ldi	r20, 0x00	; 0
    4d06:	50 e0       	ldi	r21, 0x00	; 0
    4d08:	60 e0       	ldi	r22, 0x00	; 0
    4d0a:	70 e0       	ldi	r23, 0x00	; 0
    4d0c:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4d10:	88 23       	and	r24, r24
    4d12:	79 f7       	brne	.-34     	; 0x4cf2 <SdHandshake+0x114>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    4d14:	83 e0       	ldi	r24, 0x03	; 3
    4d16:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4d1a:	88 23       	and	r24, r24
    4d1c:	31 f0       	breq	.+12     	; 0x4d2a <SdHandshake+0x14c>
    4d1e:	6b c0       	rjmp	.+214    	; 0x4df6 <SdHandshake+0x218>
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    4d20:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    4d24:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4d28:	5d 9a       	sbi	0x0b, 5	; 11
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4d2a:	83 e0       	ldi	r24, 0x03	; 3
    4d2c:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4d30:	88 23       	and	r24, r24
    4d32:	49 f4       	brne	.+18     	; 0x4d46 <SdHandshake+0x168>
    4d34:	8a e3       	ldi	r24, 0x3A	; 58
    4d36:	40 e0       	ldi	r20, 0x00	; 0
    4d38:	50 e0       	ldi	r21, 0x00	; 0
    4d3a:	60 e0       	ldi	r22, 0x00	; 0
    4d3c:	70 e0       	ldi	r23, 0x00	; 0
    4d3e:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4d42:	88 23       	and	r24, r24
    4d44:	69 f7       	brne	.-38     	; 0x4d20 <SdHandshake+0x142>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    4d46:	83 e0       	ldi	r24, 0x03	; 3
    4d48:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4d4c:	88 23       	and	r24, r24
    4d4e:	09 f0       	breq	.+2      	; 0x4d52 <SdHandshake+0x174>
    4d50:	52 c0       	rjmp	.+164    	; 0x4df6 <SdHandshake+0x218>
    4d52:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4d54:	2f ef       	ldi	r18, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4d56:	80 91 c8 00 	lds	r24, 0x00C8
    4d5a:	85 ff       	sbrs	r24, 5
    4d5c:	fc cf       	rjmp	.-8      	; 0x4d56 <SdHandshake+0x178>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4d5e:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4d62:	80 91 c8 00 	lds	r24, 0x00C8
    4d66:	87 ff       	sbrs	r24, 7
    4d68:	fc cf       	rjmp	.-8      	; 0x4d62 <SdHandshake+0x184>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4d6a:	80 91 ce 00 	lds	r24, 0x00CE
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
    4d6e:	9f 5f       	subi	r25, 0xFF	; 255
    4d70:	94 30       	cpi	r25, 0x04	; 4
    4d72:	89 f7       	brne	.-30     	; 0x4d56 <SdHandshake+0x178>
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    4d74:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4d78:	5d 9a       	sbi	0x0b, 5	; 11
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    4d7a:	80 e1       	ldi	r24, 0x10	; 16
    4d7c:	40 e0       	ldi	r20, 0x00	; 0
    4d7e:	52 e0       	ldi	r21, 0x02	; 2
    4d80:	60 e0       	ldi	r22, 0x00	; 0
    4d82:	70 e0       	ldi	r23, 0x00	; 0
    4d84:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4d88:	5d 9a       	sbi	0x0b, 5	; 11
						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
						EndSdTransfer();						// Bring CS high.
						SendDummyByte();						
    4d8a:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
    4d8e:	31 c0       	rjmp	.+98     	; 0x4df2 <SdHandshake+0x214>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    4d90:	0e 94 9f 24 	call	0x493e	; 0x493e <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4d94:	5d 9a       	sbi	0x0b, 5	; 11
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    4d96:	89 ea       	ldi	r24, 0xA9	; 169
    4d98:	40 e0       	ldi	r20, 0x00	; 0
    4d9a:	50 e0       	ldi	r21, 0x00	; 0
    4d9c:	60 e0       	ldi	r22, 0x00	; 0
    4d9e:	70 e0       	ldi	r23, 0x00	; 0
    4da0:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4da4:	82 30       	cpi	r24, 0x02	; 2
    4da6:	38 f5       	brcc	.+78     	; 0x4df6 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4da8:	5d 9a       	sbi	0x0b, 5	; 11
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);
    4daa:	83 e0       	ldi	r24, 0x03	; 3
    4dac:	64 ec       	ldi	r22, 0xC4	; 196
    4dae:	74 e0       	ldi	r23, 0x04	; 4
    4db0:	0e 94 1b 22 	call	0x4436	; 0x4436 <SetTimer>
    4db4:	03 c0       	rjmp	.+6      	; 0x4dbc <SdHandshake+0x1de>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
				{
					HandleSoftclock();	// Keep the timer timing.
    4db6:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4dba:	5d 9a       	sbi	0x0b, 5	; 11
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4dbc:	83 e0       	ldi	r24, 0x03	; 3
    4dbe:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4dc2:	88 23       	and	r24, r24
    4dc4:	49 f4       	brne	.+18     	; 0x4dd8 <SdHandshake+0x1fa>
    4dc6:	89 ea       	ldi	r24, 0xA9	; 169
    4dc8:	40 e0       	ldi	r20, 0x00	; 0
    4dca:	50 e0       	ldi	r21, 0x00	; 0
    4dcc:	60 e0       	ldi	r22, 0x00	; 0
    4dce:	70 e0       	ldi	r23, 0x00	; 0
    4dd0:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
    4dd4:	88 23       	and	r24, r24
    4dd6:	79 f7       	brne	.-34     	; 0x4db6 <SdHandshake+0x1d8>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    4dd8:	83 e0       	ldi	r24, 0x03	; 3
    4dda:	0e 94 2d 22 	call	0x445a	; 0x445a <CheckTimer>
    4dde:	88 23       	and	r24, r24
    4de0:	51 f4       	brne	.+20     	; 0x4df6 <SdHandshake+0x218>
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    4de2:	80 e1       	ldi	r24, 0x10	; 16
    4de4:	40 e0       	ldi	r20, 0x00	; 0
    4de6:	52 e0       	ldi	r21, 0x02	; 2
    4de8:	60 e0       	ldi	r22, 0x00	; 0
    4dea:	70 e0       	ldi	r23, 0x00	; 0
    4dec:	0e 94 b6 24 	call	0x496c	; 0x496c <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4df0:	5d 9a       	sbi	0x0b, 5	; 11
    4df2:	81 e0       	ldi	r24, 0x01	; 1
    4df4:	01 c0       	rjmp	.+2      	; 0x4df8 <SdHandshake+0x21a>
    4df6:	80 e0       	ldi	r24, 0x00	; 0
    4df8:	5d 9a       	sbi	0x0b, 5	; 11
		}
	}

	EndSdTransfer();	// Bring CS high
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    4dfa:	0f 90       	pop	r0
    4dfc:	0f 90       	pop	r0
    4dfe:	0f 90       	pop	r0
    4e00:	0f 90       	pop	r0
    4e02:	cf 91       	pop	r28
    4e04:	df 91       	pop	r29
    4e06:	08 95       	ret

00004e08 <__mulsi3>:
    4e08:	62 9f       	mul	r22, r18
    4e0a:	d0 01       	movw	r26, r0
    4e0c:	73 9f       	mul	r23, r19
    4e0e:	f0 01       	movw	r30, r0
    4e10:	82 9f       	mul	r24, r18
    4e12:	e0 0d       	add	r30, r0
    4e14:	f1 1d       	adc	r31, r1
    4e16:	64 9f       	mul	r22, r20
    4e18:	e0 0d       	add	r30, r0
    4e1a:	f1 1d       	adc	r31, r1
    4e1c:	92 9f       	mul	r25, r18
    4e1e:	f0 0d       	add	r31, r0
    4e20:	83 9f       	mul	r24, r19
    4e22:	f0 0d       	add	r31, r0
    4e24:	74 9f       	mul	r23, r20
    4e26:	f0 0d       	add	r31, r0
    4e28:	65 9f       	mul	r22, r21
    4e2a:	f0 0d       	add	r31, r0
    4e2c:	99 27       	eor	r25, r25
    4e2e:	72 9f       	mul	r23, r18
    4e30:	b0 0d       	add	r27, r0
    4e32:	e1 1d       	adc	r30, r1
    4e34:	f9 1f       	adc	r31, r25
    4e36:	63 9f       	mul	r22, r19
    4e38:	b0 0d       	add	r27, r0
    4e3a:	e1 1d       	adc	r30, r1
    4e3c:	f9 1f       	adc	r31, r25
    4e3e:	bd 01       	movw	r22, r26
    4e40:	cf 01       	movw	r24, r30
    4e42:	11 24       	eor	r1, r1
    4e44:	08 95       	ret

00004e46 <__udivmodqi4>:
    4e46:	99 1b       	sub	r25, r25
    4e48:	79 e0       	ldi	r23, 0x09	; 9
    4e4a:	04 c0       	rjmp	.+8      	; 0x4e54 <__udivmodqi4_ep>

00004e4c <__udivmodqi4_loop>:
    4e4c:	99 1f       	adc	r25, r25
    4e4e:	96 17       	cp	r25, r22
    4e50:	08 f0       	brcs	.+2      	; 0x4e54 <__udivmodqi4_ep>
    4e52:	96 1b       	sub	r25, r22

00004e54 <__udivmodqi4_ep>:
    4e54:	88 1f       	adc	r24, r24
    4e56:	7a 95       	dec	r23
    4e58:	c9 f7       	brne	.-14     	; 0x4e4c <__udivmodqi4_loop>
    4e5a:	80 95       	com	r24
    4e5c:	08 95       	ret

00004e5e <__divmodhi4>:
    4e5e:	97 fb       	bst	r25, 7
    4e60:	09 2e       	mov	r0, r25
    4e62:	07 26       	eor	r0, r23
    4e64:	0a d0       	rcall	.+20     	; 0x4e7a <__divmodhi4_neg1>
    4e66:	77 fd       	sbrc	r23, 7
    4e68:	04 d0       	rcall	.+8      	; 0x4e72 <__divmodhi4_neg2>
    4e6a:	2e d0       	rcall	.+92     	; 0x4ec8 <__udivmodhi4>
    4e6c:	06 d0       	rcall	.+12     	; 0x4e7a <__divmodhi4_neg1>
    4e6e:	00 20       	and	r0, r0
    4e70:	1a f4       	brpl	.+6      	; 0x4e78 <__divmodhi4_exit>

00004e72 <__divmodhi4_neg2>:
    4e72:	70 95       	com	r23
    4e74:	61 95       	neg	r22
    4e76:	7f 4f       	sbci	r23, 0xFF	; 255

00004e78 <__divmodhi4_exit>:
    4e78:	08 95       	ret

00004e7a <__divmodhi4_neg1>:
    4e7a:	f6 f7       	brtc	.-4      	; 0x4e78 <__divmodhi4_exit>
    4e7c:	90 95       	com	r25
    4e7e:	81 95       	neg	r24
    4e80:	9f 4f       	sbci	r25, 0xFF	; 255
    4e82:	08 95       	ret

00004e84 <__udivmodsi4>:
    4e84:	a1 e2       	ldi	r26, 0x21	; 33
    4e86:	1a 2e       	mov	r1, r26
    4e88:	aa 1b       	sub	r26, r26
    4e8a:	bb 1b       	sub	r27, r27
    4e8c:	fd 01       	movw	r30, r26
    4e8e:	0d c0       	rjmp	.+26     	; 0x4eaa <__udivmodsi4_ep>

00004e90 <__udivmodsi4_loop>:
    4e90:	aa 1f       	adc	r26, r26
    4e92:	bb 1f       	adc	r27, r27
    4e94:	ee 1f       	adc	r30, r30
    4e96:	ff 1f       	adc	r31, r31
    4e98:	a2 17       	cp	r26, r18
    4e9a:	b3 07       	cpc	r27, r19
    4e9c:	e4 07       	cpc	r30, r20
    4e9e:	f5 07       	cpc	r31, r21
    4ea0:	20 f0       	brcs	.+8      	; 0x4eaa <__udivmodsi4_ep>
    4ea2:	a2 1b       	sub	r26, r18
    4ea4:	b3 0b       	sbc	r27, r19
    4ea6:	e4 0b       	sbc	r30, r20
    4ea8:	f5 0b       	sbc	r31, r21

00004eaa <__udivmodsi4_ep>:
    4eaa:	66 1f       	adc	r22, r22
    4eac:	77 1f       	adc	r23, r23
    4eae:	88 1f       	adc	r24, r24
    4eb0:	99 1f       	adc	r25, r25
    4eb2:	1a 94       	dec	r1
    4eb4:	69 f7       	brne	.-38     	; 0x4e90 <__udivmodsi4_loop>
    4eb6:	60 95       	com	r22
    4eb8:	70 95       	com	r23
    4eba:	80 95       	com	r24
    4ebc:	90 95       	com	r25
    4ebe:	9b 01       	movw	r18, r22
    4ec0:	ac 01       	movw	r20, r24
    4ec2:	bd 01       	movw	r22, r26
    4ec4:	cf 01       	movw	r24, r30
    4ec6:	08 95       	ret

00004ec8 <__udivmodhi4>:
    4ec8:	aa 1b       	sub	r26, r26
    4eca:	bb 1b       	sub	r27, r27
    4ecc:	51 e1       	ldi	r21, 0x11	; 17
    4ece:	07 c0       	rjmp	.+14     	; 0x4ede <__udivmodhi4_ep>

00004ed0 <__udivmodhi4_loop>:
    4ed0:	aa 1f       	adc	r26, r26
    4ed2:	bb 1f       	adc	r27, r27
    4ed4:	a6 17       	cp	r26, r22
    4ed6:	b7 07       	cpc	r27, r23
    4ed8:	10 f0       	brcs	.+4      	; 0x4ede <__udivmodhi4_ep>
    4eda:	a6 1b       	sub	r26, r22
    4edc:	b7 0b       	sbc	r27, r23

00004ede <__udivmodhi4_ep>:
    4ede:	88 1f       	adc	r24, r24
    4ee0:	99 1f       	adc	r25, r25
    4ee2:	5a 95       	dec	r21
    4ee4:	a9 f7       	brne	.-22     	; 0x4ed0 <__udivmodhi4_loop>
    4ee6:	80 95       	com	r24
    4ee8:	90 95       	com	r25
    4eea:	bc 01       	movw	r22, r24
    4eec:	cd 01       	movw	r24, r26
    4eee:	08 95       	ret

00004ef0 <_exit>:
    4ef0:	f8 94       	cli

00004ef2 <__stop_program>:
    4ef2:	ff cf       	rjmp	.-2      	; 0x4ef2 <__stop_program>
