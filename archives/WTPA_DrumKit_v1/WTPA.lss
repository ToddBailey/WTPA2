
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001448  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          000002fe  00800100  00800100  000014bc  2**0
                  ALLOC
  2 .stab         000006b4  00000000  00000000  000014bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      00000082  00000000  00000000  00001b70  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 000000c0  00000000  00000000  00001bf2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000039a  00000000  00000000  00001cb2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000015dd  00000000  00000000  0000204c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008ad  00000000  00000000  00003629  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001803  00000000  00000000  00003ed6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002a0  00000000  00000000  000056dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ac6  00000000  00000000  0000597c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000596  00000000  00000000  00006442  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000130  00000000  00000000  000069d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
       4:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
       8:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
       c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      10:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      14:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      18:	0c 94 b4 01 	jmp	0x368	; 0x368 <__vector_6>
      1c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      20:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      24:	0c 94 d2 01 	jmp	0x3a4	; 0x3a4 <__vector_9>
      28:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      2c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      30:	0c 94 3f 01 	jmp	0x27e	; 0x27e <__vector_12>
      34:	0c 94 be 01 	jmp	0x37c	; 0x37c <__vector_13>
      38:	0c 94 c8 01 	jmp	0x390	; 0x390 <__vector_14>
      3c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      40:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      44:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      48:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      4c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      50:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      54:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      58:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      5c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      60:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      64:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      68:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      6c:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      70:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      74:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>
      78:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__bad_interrupt>

0000007c <__ctors_end>:
      7c:	11 24       	eor	r1, r1
      7e:	1f be       	out	0x3f, r1	; 63
      80:	cf ef       	ldi	r28, 0xFF	; 255
      82:	d0 e1       	ldi	r29, 0x10	; 16
      84:	de bf       	out	0x3e, r29	; 62
      86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_clear_bss>:
      88:	13 e0       	ldi	r17, 0x03	; 3
      8a:	a0 e0       	ldi	r26, 0x00	; 0
      8c:	b1 e0       	ldi	r27, 0x01	; 1
      8e:	01 c0       	rjmp	.+2      	; 0x92 <.do_clear_bss_start>

00000090 <.do_clear_bss_loop>:
      90:	1d 92       	st	X+, r1

00000092 <.do_clear_bss_start>:
      92:	ae 3f       	cpi	r26, 0xFE	; 254
      94:	b1 07       	cpc	r27, r17
      96:	e1 f7       	brne	.-8      	; 0x90 <.do_clear_bss_loop>
      98:	0e 94 11 02 	call	0x422	; 0x422 <main>
      9c:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <_exit>

000000a0 <__bad_interrupt>:
      a0:	0c 94 dc 01 	jmp	0x3b8	; 0x3b8 <__vector_default>

000000a4 <PlaySample>:
static struct channelStruct dmcChannels[4];

// Find an open channel and direct it to start playing a sample
// We might need to disable interrupts before we do this
static void PlaySample(unsigned long sampleNumber)
{
      a4:	cf 92       	push	r12
      a6:	df 92       	push	r13
      a8:	ef 92       	push	r14
      aa:	ff 92       	push	r15
      ac:	0f 93       	push	r16
      ae:	1f 93       	push	r17
      b0:	6b 01       	movw	r12, r22
      b2:	7c 01       	movw	r14, r24
	cli();
      b4:	f8 94       	cli
      b6:	a1 e3       	ldi	r26, 0x31	; 49
      b8:	b3 e0       	ldi	r27, 0x03	; 3
      ba:	40 e0       	ldi	r20, 0x00	; 0
      bc:	50 e0       	ldi	r21, 0x00	; 0
	for(int i=0; i < 4; i++)
	{
		if(dmcChannels[i].isPlaying == 0)
      be:	8c 91       	ld	r24, X
      c0:	88 23       	and	r24, r24
      c2:	b1 f5       	brne	.+108    	; 0x130 <PlaySample+0x8c>
		{
			dmcChannels[i].isPlaying = 1;							// Let UpdateChannel() know to start playing
      c4:	9a 01       	movw	r18, r20
      c6:	22 0f       	add	r18, r18
      c8:	33 1f       	adc	r19, r19
      ca:	24 0f       	add	r18, r20
      cc:	35 1f       	adc	r19, r21
      ce:	22 0f       	add	r18, r18
      d0:	33 1f       	adc	r19, r19
      d2:	22 0f       	add	r18, r18
      d4:	33 1f       	adc	r19, r19
      d6:	89 01       	movw	r16, r18
      d8:	0a 5d       	subi	r16, 0xDA	; 218
      da:	1c 4f       	sbci	r17, 0xFC	; 252
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	f8 01       	movw	r30, r16
      e0:	83 87       	std	Z+11, r24	; 0x0b
			dmcChannels[i].currentAddress = (sampleNumber * 4096);  // Which 4K sample? (could << 12 here, should compile that way anyway?)
      e2:	b7 01       	movw	r22, r14
      e4:	a6 01       	movw	r20, r12
      e6:	ac e0       	ldi	r26, 0x0C	; 12
      e8:	44 0f       	add	r20, r20
      ea:	55 1f       	adc	r21, r21
      ec:	66 1f       	adc	r22, r22
      ee:	77 1f       	adc	r23, r23
      f0:	aa 95       	dec	r26
      f2:	d1 f7       	brne	.-12     	; 0xe8 <PlaySample+0x44>
      f4:	40 83       	st	Z, r20
      f6:	51 83       	std	Z+1, r21	; 0x01
      f8:	62 83       	std	Z+2, r22	; 0x02
      fa:	73 83       	std	Z+3, r23	; 0x03
			dmcChannels[i].endAddress = (dmcChannels[i].currentAddress + sampleLength[sampleNumber]); //*4096	// Use the whole bank for now - until I figure out to index
      fc:	26 5d       	subi	r18, 0xD6	; 214
      fe:	3c 4f       	sbci	r19, 0xFC	; 252
     100:	f6 01       	movw	r30, r12
     102:	ee 0f       	add	r30, r30
     104:	ff 1f       	adc	r31, r31
     106:	ee 0f       	add	r30, r30
     108:	ff 1f       	adc	r31, r31
     10a:	ea 5d       	subi	r30, 0xDA	; 218
     10c:	fe 4f       	sbci	r31, 0xFE	; 254
     10e:	80 81       	ld	r24, Z
     110:	91 81       	ldd	r25, Z+1	; 0x01
     112:	a2 81       	ldd	r26, Z+2	; 0x02
     114:	b3 81       	ldd	r27, Z+3	; 0x03
     116:	84 0f       	add	r24, r20
     118:	95 1f       	adc	r25, r21
     11a:	a6 1f       	adc	r26, r22
     11c:	b7 1f       	adc	r27, r23
     11e:	f9 01       	movw	r30, r18
     120:	80 83       	st	Z, r24
     122:	91 83       	std	Z+1, r25	; 0x01
     124:	a2 83       	std	Z+2, r26	; 0x02
     126:	b3 83       	std	Z+3, r27	; 0x03
			//dmcChannels[i].endAddress = (dmcChannels[i].currentAddress + 0x400);
			// DEBUG play all of RAM
			//dmcChannels[i].endAddress = 0x80000;
			
			// Reset our other parameters
			dmcChannels[i].bitIndex = 0;
     128:	f8 01       	movw	r30, r16
     12a:	11 86       	std	Z+9, r1	; 0x09
			dmcChannels[i].deltaTrack = 0;
     12c:	12 86       	std	Z+10, r1	; 0x0a
     12e:	06 c0       	rjmp	.+12     	; 0x13c <PlaySample+0x98>
// Find an open channel and direct it to start playing a sample
// We might need to disable interrupts before we do this
static void PlaySample(unsigned long sampleNumber)
{
	cli();
	for(int i=0; i < 4; i++)
     130:	4f 5f       	subi	r20, 0xFF	; 255
     132:	5f 4f       	sbci	r21, 0xFF	; 255
     134:	1c 96       	adiw	r26, 0x0c	; 12
     136:	44 30       	cpi	r20, 0x04	; 4
     138:	51 05       	cpc	r21, r1
     13a:	09 f6       	brne	.-126    	; 0xbe <PlaySample+0x1a>
			break;
		}
		
		// Else we're all busy - take a hike kid.
	}
	sei();
     13c:	78 94       	sei
}
     13e:	1f 91       	pop	r17
     140:	0f 91       	pop	r16
     142:	ff 90       	pop	r15
     144:	ef 90       	pop	r14
     146:	df 90       	pop	r13
     148:	cf 90       	pop	r12
     14a:	08 95       	ret

0000014c <UpdateChannel>:
// 2) Counter is reset - clocked by (~22KHz?) drives out a single bit at a time
// 3) Waveform DAC adjusts a fixed amount based on the bit (0=-x / 1=+x)
// 4) When counter has reached 8 and the buffer is exhausted address is incremented and the sample IRQ (fetch byte) is triggered again
// 5) Internal counter keeps track of length and ends if not in "loop mode"
static signed char UpdateChannel(unsigned char i)
{
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29

	if(dmcChannels[i].isPlaying == 1)
     150:	68 2f       	mov	r22, r24
     152:	70 e0       	ldi	r23, 0x00	; 0
     154:	fb 01       	movw	r30, r22
     156:	ee 0f       	add	r30, r30
     158:	ff 1f       	adc	r31, r31
     15a:	e6 0f       	add	r30, r22
     15c:	f7 1f       	adc	r31, r23
     15e:	ee 0f       	add	r30, r30
     160:	ff 1f       	adc	r31, r31
     162:	ee 0f       	add	r30, r30
     164:	ff 1f       	adc	r31, r31
     166:	ea 5d       	subi	r30, 0xDA	; 218
     168:	fc 4f       	sbci	r31, 0xFC	; 252
     16a:	83 85       	ldd	r24, Z+11	; 0x0b
     16c:	81 30       	cpi	r24, 0x01	; 1
     16e:	11 f0       	breq	.+4      	; 0x174 <UpdateChannel+0x28>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	82 c0       	rjmp	.+260    	; 0x278 <UpdateChannel+0x12c>
	{
		if (((ReadRAM(dmcChannels[i].currentAddress) >> dmcChannels[i].bitIndex) & 0x01) == 0)		// Right shift register driven by an 8-bit counter - only interested in a single bit
     174:	80 81       	ld	r24, Z
     176:	91 81       	ldd	r25, Z+1	; 0x01
     178:	a2 81       	ldd	r26, Z+2	; 0x02
     17a:	b3 81       	ldd	r27, Z+3	; 0x03
{
	static unsigned char
		temp;
	
	// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
	LATCH_PORT=(address);				// Put the LSB of the address on the latch.
     17c:	85 b9       	out	0x05, r24	; 5
	PORTA|=(Om_RAM_L_ADR_LA);			// Strobe it to the latch output...
     17e:	13 9a       	sbi	0x02, 3	; 2
	PORTA&=~(Om_RAM_L_ADR_LA);			// ...Keep it there.
     180:	13 98       	cbi	0x02, 3	; 2
	
	LATCH_PORT=(address>>8);			// Put the middle byte of the address on the latch.
     182:	29 2f       	mov	r18, r25
     184:	3a 2f       	mov	r19, r26
     186:	4b 2f       	mov	r20, r27
     188:	55 27       	eor	r21, r21
     18a:	25 b9       	out	0x05, r18	; 5
	PORTA|=(Om_RAM_H_ADR_LA);			// Strobe it to the latch output...
     18c:	14 9a       	sbi	0x02, 4	; 2
	PORTA&=~(Om_RAM_H_ADR_LA);			// ...Keep it there.
     18e:	14 98       	cbi	0x02, 4	; 2
	
	PORTC=((0x88|((address>>16)&0x07)));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     190:	cd 01       	movw	r24, r26
     192:	aa 27       	eor	r26, r26
     194:	bb 27       	eor	r27, r27
     196:	87 70       	andi	r24, 0x07	; 7
     198:	88 68       	ori	r24, 0x88	; 136
     19a:	88 b9       	out	0x08, r24	; 8
	
	LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     19c:	14 b8       	out	0x04, r1	; 4
	PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     19e:	12 98       	cbi	0x02, 2	; 2
	
	// NOP(s) here?
	asm volatile("nop"::);				// Just in case the RAM needs to settle down
     1a0:	00 00       	nop
	asm volatile("nop"::);
     1a2:	00 00       	nop
	
	// Finish getting the byte from RAM.
	
	temp=LATCH_INPUT;					// Get the byte from this address in RAM.
     1a4:	83 b1       	in	r24, 0x03	; 3
     1a6:	80 93 1f 01 	sts	0x011F, r24
	PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     1aa:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     1ac:	2f ef       	ldi	r18, 0xFF	; 255
     1ae:	24 b9       	out	0x04, r18	; 4
static signed char UpdateChannel(unsigned char i)
{

	if(dmcChannels[i].isPlaying == 1)
	{
		if (((ReadRAM(dmcChannels[i].currentAddress) >> dmcChannels[i].bitIndex) & 0x01) == 0)		// Right shift register driven by an 8-bit counter - only interested in a single bit
     1b0:	90 e0       	ldi	r25, 0x00	; 0
     1b2:	fb 01       	movw	r30, r22
     1b4:	ee 0f       	add	r30, r30
     1b6:	ff 1f       	adc	r31, r31
     1b8:	e6 0f       	add	r30, r22
     1ba:	f7 1f       	adc	r31, r23
     1bc:	ee 0f       	add	r30, r30
     1be:	ff 1f       	adc	r31, r31
     1c0:	ee 0f       	add	r30, r30
     1c2:	ff 1f       	adc	r31, r31
     1c4:	ea 5d       	subi	r30, 0xDA	; 218
     1c6:	fc 4f       	sbci	r31, 0xFC	; 252
     1c8:	01 84       	ldd	r0, Z+9	; 0x09
     1ca:	02 c0       	rjmp	.+4      	; 0x1d0 <UpdateChannel+0x84>
     1cc:	95 95       	asr	r25
     1ce:	87 95       	ror	r24
     1d0:	0a 94       	dec	r0
     1d2:	e2 f7       	brpl	.-8      	; 0x1cc <UpdateChannel+0x80>
     1d4:	80 fd       	sbrc	r24, 0
     1d6:	03 c0       	rjmp	.+6      	; 0x1de <UpdateChannel+0x92>
		{
			dmcChannels[i].deltaTrack -= 1;	   // Apply delta change
     1d8:	82 85       	ldd	r24, Z+10	; 0x0a
     1da:	81 50       	subi	r24, 0x01	; 1
     1dc:	02 c0       	rjmp	.+4      	; 0x1e2 <UpdateChannel+0x96>
		}
		else 
		{
			dmcChannels[i].deltaTrack += 1;
     1de:	82 85       	ldd	r24, Z+10	; 0x0a
     1e0:	8f 5f       	subi	r24, 0xFF	; 255
     1e2:	82 87       	std	Z+10, r24	; 0x0a
		}
		
		dmcChannels[i].bitIndex++;				// Increment counter
     1e4:	fb 01       	movw	r30, r22
     1e6:	ee 0f       	add	r30, r30
     1e8:	ff 1f       	adc	r31, r31
     1ea:	e6 0f       	add	r30, r22
     1ec:	f7 1f       	adc	r31, r23
     1ee:	ee 0f       	add	r30, r30
     1f0:	ff 1f       	adc	r31, r31
     1f2:	ee 0f       	add	r30, r30
     1f4:	ff 1f       	adc	r31, r31
     1f6:	ea 5d       	subi	r30, 0xDA	; 218
     1f8:	fc 4f       	sbci	r31, 0xFC	; 252
     1fa:	81 85       	ldd	r24, Z+9	; 0x09
     1fc:	8f 5f       	subi	r24, 0xFF	; 255
     1fe:	81 87       	std	Z+9, r24	; 0x09
		
		if(dmcChannels[i].bitIndex == 8)		// If we've shifted out 8 bits fetch a new byte and reset counter
     200:	88 30       	cpi	r24, 0x08	; 8
     202:	61 f4       	brne	.+24     	; 0x21c <UpdateChannel+0xd0>
		{
			dmcChannels[i].bitIndex = 0;
     204:	11 86       	std	Z+9, r1	; 0x09
			dmcChannels[i].currentAddress++;
     206:	80 81       	ld	r24, Z
     208:	91 81       	ldd	r25, Z+1	; 0x01
     20a:	a2 81       	ldd	r26, Z+2	; 0x02
     20c:	b3 81       	ldd	r27, Z+3	; 0x03
     20e:	01 96       	adiw	r24, 0x01	; 1
     210:	a1 1d       	adc	r26, r1
     212:	b1 1d       	adc	r27, r1
     214:	80 83       	st	Z, r24
     216:	91 83       	std	Z+1, r25	; 0x01
     218:	a2 83       	std	Z+2, r26	; 0x02
     21a:	b3 83       	std	Z+3, r27	; 0x03
		}
		
		if(dmcChannels[i].currentAddress == dmcChannels[i].endAddress)	// Did we reach the end?
     21c:	fb 01       	movw	r30, r22
     21e:	ee 0f       	add	r30, r30
     220:	ff 1f       	adc	r31, r31
     222:	e6 0f       	add	r30, r22
     224:	f7 1f       	adc	r31, r23
     226:	ee 0f       	add	r30, r30
     228:	ff 1f       	adc	r31, r31
     22a:	ee 0f       	add	r30, r30
     22c:	ff 1f       	adc	r31, r31
     22e:	ef 01       	movw	r28, r30
     230:	ca 5d       	subi	r28, 0xDA	; 218
     232:	dc 4f       	sbci	r29, 0xFC	; 252
     234:	e6 5d       	subi	r30, 0xD6	; 214
     236:	fc 4f       	sbci	r31, 0xFC	; 252
     238:	28 81       	ld	r18, Y
     23a:	39 81       	ldd	r19, Y+1	; 0x01
     23c:	4a 81       	ldd	r20, Y+2	; 0x02
     23e:	5b 81       	ldd	r21, Y+3	; 0x03
     240:	80 81       	ld	r24, Z
     242:	91 81       	ldd	r25, Z+1	; 0x01
     244:	a2 81       	ldd	r26, Z+2	; 0x02
     246:	b3 81       	ldd	r27, Z+3	; 0x03
     248:	28 17       	cp	r18, r24
     24a:	39 07       	cpc	r19, r25
     24c:	4a 07       	cpc	r20, r26
     24e:	5b 07       	cpc	r21, r27
     250:	39 f4       	brne	.+14     	; 0x260 <UpdateChannel+0x114>
		{
			dmcChannels[i].currentAddress = 0;							// If so, reset parameters and free the channel
     252:	18 82       	st	Y, r1
     254:	19 82       	std	Y+1, r1	; 0x01
     256:	1a 82       	std	Y+2, r1	; 0x02
     258:	1b 82       	std	Y+3, r1	; 0x03
			dmcChannels[i].bitIndex = 0;
     25a:	19 86       	std	Y+9, r1	; 0x09
			dmcChannels[i].deltaTrack = 0;
     25c:	1a 86       	std	Y+10, r1	; 0x0a
			dmcChannels[i].isPlaying = 0;
     25e:	1b 86       	std	Y+11, r1	; 0x0b
		}
		
		return(dmcChannels[i].deltaTrack);
     260:	fb 01       	movw	r30, r22
     262:	ee 0f       	add	r30, r30
     264:	ff 1f       	adc	r31, r31
     266:	e6 0f       	add	r30, r22
     268:	f7 1f       	adc	r31, r23
     26a:	ee 0f       	add	r30, r30
     26c:	ff 1f       	adc	r31, r31
     26e:	ee 0f       	add	r30, r30
     270:	ff 1f       	adc	r31, r31
     272:	ea 5d       	subi	r30, 0xDA	; 218
     274:	fc 4f       	sbci	r31, 0xFC	; 252
     276:	82 85       	ldd	r24, Z+10	; 0x0a
	else 
	{
		return 0;
	}

}
     278:	df 91       	pop	r29
     27a:	cf 91       	pop	r28
     27c:	08 95       	ret

0000027e <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
     27e:	1f 92       	push	r1
     280:	0f 92       	push	r0
     282:	0f b6       	in	r0, 0x3f	; 63
     284:	0f 92       	push	r0
     286:	11 24       	eor	r1, r1
     288:	df 92       	push	r13
     28a:	ef 92       	push	r14
     28c:	ff 92       	push	r15
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	2f 93       	push	r18
     294:	3f 93       	push	r19
     296:	4f 93       	push	r20
     298:	5f 93       	push	r21
     29a:	6f 93       	push	r22
     29c:	7f 93       	push	r23
     29e:	8f 93       	push	r24
     2a0:	9f 93       	push	r25
     2a2:	af 93       	push	r26
     2a4:	bf 93       	push	r27
     2a6:	ef 93       	push	r30
     2a8:	ff 93       	push	r31
		sum0;				// Temporary variables for saturated adds, multiplies, other math.

	unsigned char
		output;			// What to put on the DAC
	
	sum0=UpdateChannel(0)+UpdateChannel(1)+UpdateChannel(2)+UpdateChannel(3);	// Sum everything that might be involved in our output waveform:
     2aa:	80 e0       	ldi	r24, 0x00	; 0
     2ac:	0e 94 a6 00 	call	0x14c	; 0x14c <UpdateChannel>
     2b0:	e8 2e       	mov	r14, r24
     2b2:	81 e0       	ldi	r24, 0x01	; 1
     2b4:	0e 94 a6 00 	call	0x14c	; 0x14c <UpdateChannel>
     2b8:	d8 2e       	mov	r13, r24
     2ba:	82 e0       	ldi	r24, 0x02	; 2
     2bc:	0e 94 a6 00 	call	0x14c	; 0x14c <UpdateChannel>
     2c0:	08 2f       	mov	r16, r24
     2c2:	83 e0       	ldi	r24, 0x03	; 3
     2c4:	0e 94 a6 00 	call	0x14c	; 0x14c <UpdateChannel>
     2c8:	2d 2d       	mov	r18, r13
     2ca:	33 27       	eor	r19, r19
     2cc:	27 fd       	sbrc	r18, 7
     2ce:	30 95       	com	r19
     2d0:	ff 24       	eor	r15, r15
     2d2:	e7 fc       	sbrc	r14, 7
     2d4:	f0 94       	com	r15
     2d6:	2e 0d       	add	r18, r14
     2d8:	3f 1d       	adc	r19, r15
     2da:	11 27       	eor	r17, r17
     2dc:	07 fd       	sbrc	r16, 7
     2de:	10 95       	com	r17
     2e0:	20 0f       	add	r18, r16
     2e2:	31 1f       	adc	r19, r17
     2e4:	99 27       	eor	r25, r25
     2e6:	87 fd       	sbrc	r24, 7
     2e8:	90 95       	com	r25
     2ea:	28 0f       	add	r18, r24
     2ec:	39 1f       	adc	r19, r25
     2ee:	8f ef       	ldi	r24, 0xFF	; 255
     2f0:	20 38       	cpi	r18, 0x80	; 128
     2f2:	38 07       	cpc	r19, r24
     2f4:	14 f4       	brge	.+4      	; 0x2fa <__vector_12+0x7c>
     2f6:	20 e8       	ldi	r18, 0x80	; 128
     2f8:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;	// Cast back to 8 bits.
     2fa:	c9 01       	movw	r24, r18
     2fc:	20 38       	cpi	r18, 0x80	; 128
     2fe:	31 05       	cpc	r19, r1
     300:	14 f0       	brlt	.+4      	; 0x306 <__vector_12+0x88>
     302:	8f e7       	ldi	r24, 0x7F	; 127
     304:	90 e0       	ldi	r25, 0x00	; 0
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
     306:	98 2f       	mov	r25, r24
     308:	90 58       	subi	r25, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
     30a:	80 91 56 03 	lds	r24, 0x0356
     30e:	98 17       	cp	r25, r24
     310:	29 f0       	breq	.+10     	; 0x31c <__vector_12+0x9e>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     312:	8f ef       	ldi	r24, 0xFF	; 255
     314:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
     316:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
     318:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     31a:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
     31c:	90 93 56 03 	sts	0x0356, r25

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
	OutputAudio();				// Let's do this thang
	if(!(ADCSRA&(1<<ADSC)))		// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
     320:	80 91 7a 00 	lds	r24, 0x007A
     324:	86 fd       	sbrc	r24, 6
     326:	0a c0       	rjmp	.+20     	; 0x33c <__vector_12+0xbe>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
     328:	80 91 79 00 	lds	r24, 0x0079
     32c:	80 58       	subi	r24, 0x80	; 128
     32e:	80 93 20 01 	sts	0x0120, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
     332:	80 91 7a 00 	lds	r24, 0x007A
     336:	80 64       	ori	r24, 0x40	; 64
     338:	80 93 7a 00 	sts	0x007A, r24
	}
}
     33c:	ff 91       	pop	r31
     33e:	ef 91       	pop	r30
     340:	bf 91       	pop	r27
     342:	af 91       	pop	r26
     344:	9f 91       	pop	r25
     346:	8f 91       	pop	r24
     348:	7f 91       	pop	r23
     34a:	6f 91       	pop	r22
     34c:	5f 91       	pop	r21
     34e:	4f 91       	pop	r20
     350:	3f 91       	pop	r19
     352:	2f 91       	pop	r18
     354:	1f 91       	pop	r17
     356:	0f 91       	pop	r16
     358:	ff 90       	pop	r15
     35a:	ef 90       	pop	r14
     35c:	df 90       	pop	r13
     35e:	0f 90       	pop	r0
     360:	0f be       	out	0x3f, r0	; 63
     362:	0f 90       	pop	r0
     364:	1f 90       	pop	r1
     366:	18 95       	reti

00000368 <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
     368:	1f 92       	push	r1
     36a:	0f 92       	push	r0
     36c:	0f b6       	in	r0, 0x3f	; 63
     36e:	0f 92       	push	r0
     370:	11 24       	eor	r1, r1
	
}
     372:	0f 90       	pop	r0
     374:	0f be       	out	0x3f, r0	; 63
     376:	0f 90       	pop	r0
     378:	1f 90       	pop	r1
     37a:	18 95       	reti

0000037c <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
     37c:	1f 92       	push	r1
     37e:	0f 92       	push	r0
     380:	0f b6       	in	r0, 0x3f	; 63
     382:	0f 92       	push	r0
     384:	11 24       	eor	r1, r1
	
}
     386:	0f 90       	pop	r0
     388:	0f be       	out	0x3f, r0	; 63
     38a:	0f 90       	pop	r0
     38c:	1f 90       	pop	r1
     38e:	18 95       	reti

00000390 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
     390:	1f 92       	push	r1
     392:	0f 92       	push	r0
     394:	0f b6       	in	r0, 0x3f	; 63
     396:	0f 92       	push	r0
     398:	11 24       	eor	r1, r1
	
}
     39a:	0f 90       	pop	r0
     39c:	0f be       	out	0x3f, r0	; 63
     39e:	0f 90       	pop	r0
     3a0:	1f 90       	pop	r1
     3a2:	18 95       	reti

000003a4 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
     3a4:	1f 92       	push	r1
     3a6:	0f 92       	push	r0
     3a8:	0f b6       	in	r0, 0x3f	; 63
     3aa:	0f 92       	push	r0
     3ac:	11 24       	eor	r1, r1
	
}
     3ae:	0f 90       	pop	r0
     3b0:	0f be       	out	0x3f, r0	; 63
     3b2:	0f 90       	pop	r0
     3b4:	1f 90       	pop	r1
     3b6:	18 95       	reti

000003b8 <__vector_default>:

ISR(__vector_default)
{
     3b8:	1f 92       	push	r1
     3ba:	0f 92       	push	r0
     3bc:	0f b6       	in	r0, 0x3f	; 63
     3be:	0f 92       	push	r0
     3c0:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
     3c2:	0f 90       	pop	r0
     3c4:	0f be       	out	0x3f, r0	; 63
     3c6:	0f 90       	pop	r0
     3c8:	1f 90       	pop	r1
     3ca:	18 95       	reti

000003cc <WriteLedLatch>:
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
     3cc:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
     3ce:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
     3d0:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
     3d2:	8f ef       	ldi	r24, 0xFF	; 255
     3d4:	84 b9       	out	0x04, r24	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
     3d6:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
     3d8:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
     3da:	9f bf       	out	0x3f, r25	; 63
}
     3dc:	08 95       	ret

000003de <HandleSoftclock>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
     3de:	a8 9b       	sbis	0x15, 0	; 21
     3e0:	0a c0       	rjmp	.+20     	; 0x3f6 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
     3e2:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
     3e4:	80 91 c8 03 	lds	r24, 0x03C8
     3e8:	90 91 c9 03 	lds	r25, 0x03C9
     3ec:	01 96       	adiw	r24, 0x01	; 1
     3ee:	90 93 c9 03 	sts	0x03C9, r25
     3f2:	80 93 c8 03 	sts	0x03C8, r24
     3f6:	08 95       	ret

000003f8 <ShowFailure>:
}
*/
// Crappy function to indicate that something has failed in absence of a printf
// Don't leave this function (while 1) since we're not interested in going further
static void ShowFailure(unsigned char pattern)
{	
     3f8:	1f 93       	push	r17
     3fa:	18 2f       	mov	r17, r24
	cli();						// Why bother... it's all over..
     3fc:	f8 94       	cli
	
	WriteLedLatch(pattern);		
     3fe:	81 2f       	mov	r24, r17
     400:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
	while(1)				
	{
		SetTimer(TIMER_SD,(SECOND/2));
     404:	83 e0       	ldi	r24, 0x03	; 3
     406:	62 e6       	ldi	r22, 0x62	; 98
     408:	72 e0       	ldi	r23, 0x02	; 2
     40a:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
     40e:	02 c0       	rjmp	.+4      	; 0x414 <ShowFailure+0x1c>
		while (!CheckTimer(TIMER_SD))
		{
			HandleSoftclock();
     410:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
	
	WriteLedLatch(pattern);		
	while(1)				
	{
		SetTimer(TIMER_SD,(SECOND/2));
		while (!CheckTimer(TIMER_SD))
     414:	83 e0       	ldi	r24, 0x03	; 3
     416:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
     41a:	88 23       	and	r24, r24
     41c:	c9 f3       	breq	.-14     	; 0x410 <ShowFailure+0x18>
		{
			HandleSoftclock();
		}
		pattern ^= 0xFF;		// Toggle LEDs to absolutely dazzle the user
     41e:	10 95       	com	r17
     420:	ee cf       	rjmp	.-36     	; 0x3fe <ShowFailure+0x6>

00000422 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
     422:	7f 92       	push	r7
     424:	8f 92       	push	r8
     426:	9f 92       	push	r9
     428:	af 92       	push	r10
     42a:	bf 92       	push	r11
     42c:	cf 92       	push	r12
     42e:	df 92       	push	r13
     430:	ef 92       	push	r14
     432:	ff 92       	push	r15
     434:	0f 93       	push	r16
     436:	1f 93       	push	r17
     438:	cf 93       	push	r28
     43a:	df 93       	push	r29
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
     43c:	2f ef       	ldi	r18, 0xFF	; 255
     43e:	20 93 64 00 	sts	0x0064, r18
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
     442:	85 b7       	in	r24, 0x35	; 53
     444:	8f 7e       	andi	r24, 0xEF	; 239
     446:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
     448:	8f ee       	ldi	r24, 0xEF	; 239
     44a:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
     44c:	88 e0       	ldi	r24, 0x08	; 8
     44e:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
     450:	90 e8       	ldi	r25, 0x80	; 128
     452:	9a b9       	out	0x0a, r25	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
     454:	1b b8       	out	0x0b, r1	; 11
	
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
     456:	86 e0       	ldi	r24, 0x06	; 6
     458:	82 b9       	out	0x02, r24	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
     45a:	8e e3       	ldi	r24, 0x3E	; 62
     45c:	81 b9       	out	0x01, r24	; 1

	DDRB=0xFF;			// Latch port to OP.
     45e:	24 b9       	out	0x04, r18	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
     460:	95 b9       	out	0x05, r25	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
     462:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     464:	24 b9       	out	0x04, r18	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
     466:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     468:	15 98       	cbi	0x02, 5	; 2


static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
     46a:	80 91 64 00 	lds	r24, 0x0064
     46e:	8e 7f       	andi	r24, 0xFE	; 254
     470:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
     474:	80 e6       	ldi	r24, 0x60	; 96
     476:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
     480:	85 e9       	ldi	r24, 0x95	; 149
     482:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
     486:	80 91 7a 00 	lds	r24, 0x007A
     48a:	80 64       	ori	r24, 0x40	; 64
     48c:	80 93 7a 00 	sts	0x007A, r24

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
     490:	80 91 64 00 	lds	r24, 0x0064
     494:	87 7f       	andi	r24, 0xF7	; 247
     496:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
     49a:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
     49e:	8f ef       	ldi	r24, 0xFF	; 255
     4a0:	9f ef       	ldi	r25, 0xFF	; 255
     4a2:	90 93 89 00 	sts	0x0089, r25
     4a6:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
     4aa:	90 93 8b 00 	sts	0x008B, r25
     4ae:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
     4b2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
     4b6:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
     4ba:	10 92 85 00 	sts	0x0085, r1
     4be:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
     4c2:	26 bb       	out	0x16, r18	; 22
	
	// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
	TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
     4c4:	80 91 81 00 	lds	r24, 0x0081
     4c8:	80 64       	ori	r24, 0x40	; 64
     4ca:	80 93 81 00 	sts	0x0081, r24
	TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
     4ce:	b5 9a       	sbi	0x16, 5	; 22
	TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
     4d0:	80 91 6f 00 	lds	r24, 0x006F
     4d4:	80 62       	ori	r24, 0x20	; 32
     4d6:	80 93 6f 00 	sts	0x006F, r24
	
	// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
     4da:	da 9a       	sbi	0x1b, 2	; 27
	PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
     4dc:	84 e0       	ldi	r24, 0x04	; 4
     4de:	80 93 68 00 	sts	0x0068, r24
	PCMSK2=0x10;			// PORTC pin 4 generates interrupt
     4e2:	80 e1       	ldi	r24, 0x10	; 16
     4e4:	80 93 6d 00 	sts	0x006D, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
     4e8:	80 91 64 00 	lds	r24, 0x0064
     4ec:	8f 7d       	andi	r24, 0xDF	; 223
     4ee:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
     4f2:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
     4f6:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
     4f8:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
     4fa:	25 bb       	out	0x15, r18	; 21
	systemTicks=0;
     4fc:	10 92 c9 03 	sts	0x03C9, r1
     500:	10 92 c8 03 	sts	0x03C8, r1
	//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
     504:	83 e0       	ldi	r24, 0x03	; 3
     506:	85 bd       	out	0x25, r24	; 37
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
     508:	81 e0       	ldi	r24, 0x01	; 1
     50a:	66 e2       	ldi	r22, 0x26	; 38
     50c:	70 e0       	ldi	r23, 0x00	; 0
     50e:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
     512:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
     514:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
     516:	80 b1       	in	r24, 0x00	; 0
     518:	80 7c       	andi	r24, 0xC0	; 192
     51a:	80 93 23 01 	sts	0x0123, r24
	encoderValue=0;							// zero our relative position.
     51e:	10 92 24 01 	sts	0x0124, r1
	InitAdc();
	InitSampleClock();
	InitSoftclock();
	InitSwitches();
	InitEncoder();
	InitMidi();					// Get the MIDI stack initialized.
     522:	0e 94 e5 05 	call	0xbca	; 0xbca <InitMidi>
	InitUart0();
     526:	0e 94 1a 05 	call	0xa34	; 0xa34 <InitUart0>
	InitSdInterface();
     52a:	0e 94 93 07 	call	0xf26	; 0xf26 <InitSdInterface>
{
	static unsigned long 
		currentAddress;
	static unsigned char
		currentByte;
	currentAddress = 0;
     52e:	10 92 17 01 	sts	0x0117, r1
     532:	10 92 18 01 	sts	0x0118, r1
     536:	10 92 19 01 	sts	0x0119, r1
     53a:	10 92 1a 01 	sts	0x011A, r1
	
	SetTimer(TIMER_SD,SECOND);
     53e:	83 e0       	ldi	r24, 0x03	; 3
     540:	64 ec       	ldi	r22, 0xC4	; 196
     542:	74 e0       	ldi	r23, 0x04	; 4
     544:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
     548:	02 c0       	rjmp	.+4      	; 0x54e <main+0x12c>
	while(!CheckTimer(TIMER_SD))
	{	
		HandleSoftclock();
     54a:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
	static unsigned char
		currentByte;
	currentAddress = 0;
	
	SetTimer(TIMER_SD,SECOND);
	while(!CheckTimer(TIMER_SD))
     54e:	83 e0       	ldi	r24, 0x03	; 3
     550:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
     554:	88 23       	and	r24, r24
     556:	c9 f3       	breq	.-14     	; 0x54a <main+0x128>
	{	
		HandleSoftclock();
	}
	if(SdHandshake() == false)
     558:	0e 94 0d 09 	call	0x121a	; 0x121a <SdHandshake>
     55c:	88 23       	and	r24, r24
     55e:	19 f4       	brne	.+6      	; 0x566 <main+0x144>
	{
		ShowFailure(0x55);	// Branch off here and never come back if we don't have an SD card
     560:	85 e5       	ldi	r24, 0x55	; 85
     562:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <ShowFailure>
     566:	aa 24       	eor	r10, r10
     568:	bb 24       	eor	r11, r11
     56a:	65 01       	movw	r12, r10
     56c:	45 01       	movw	r8, r10
	}
	
	for(int blockNum = 0; blockNum < (8*128); blockNum++)	// 8 blocks * 128 samples * 512B = 512KB 
	{
		StartSdTransfer();
     56e:	0e 94 ac 07 	call	0xf58	; 0xf58 <StartSdTransfer>
		
		if(SdBeginSingleBlockRead(blockNum) == true)
     572:	c6 01       	movw	r24, r12
     574:	b5 01       	movw	r22, r10
     576:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <SdBeginSingleBlockRead>
     57a:	81 30       	cpi	r24, 0x01	; 1
     57c:	09 f0       	breq	.+2      	; 0x580 <main+0x15e>
     57e:	57 c0       	rjmp	.+174    	; 0x62e <main+0x20c>
		{
			SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
     580:	83 e0       	ldi	r24, 0x03	; 3
     582:	6a e7       	ldi	r22, 0x7A	; 122
     584:	70 e0       	ldi	r23, 0x00	; 0
     586:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
     58a:	02 c0       	rjmp	.+4      	; 0x590 <main+0x16e>
			
			while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
			{
				HandleSoftclock();	// Kludgy
     58c:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
		
		if(SdBeginSingleBlockRead(blockNum) == true)
		{
			SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
			
			while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
     590:	83 e0       	ldi	r24, 0x03	; 3
     592:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
     596:	88 23       	and	r24, r24
     598:	29 f4       	brne	.+10     	; 0x5a4 <main+0x182>
     59a:	8f ef       	ldi	r24, 0xFF	; 255
     59c:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     5a0:	8e 3f       	cpi	r24, 0xFE	; 254
     5a2:	a1 f7       	brne	.-24     	; 0x58c <main+0x16a>
     5a4:	c0 e0       	ldi	r28, 0x00	; 0
     5a6:	d0 e0       	ldi	r29, 0x00	; 0
				HandleSoftclock();	// Kludgy
			}
			
			for(int i=0; i < 512; i++)
			{
				currentByte = TransferSdByte(DUMMY_BYTE);
     5a8:	8f ef       	ldi	r24, 0xFF	; 255
     5aa:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     5ae:	80 93 16 01 	sts	0x0116, r24
				WriteRAM(currentAddress, currentByte);
     5b2:	e0 90 17 01 	lds	r14, 0x0117
     5b6:	f0 90 18 01 	lds	r15, 0x0118
     5ba:	00 91 19 01 	lds	r16, 0x0119
     5be:	10 91 1a 01 	lds	r17, 0x011A
	return temp;
}

static void WriteRAM(unsigned long address, unsigned char value)
{
	LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     5c2:	9f ef       	ldi	r25, 0xFF	; 255
     5c4:	94 b9       	out	0x04, r25	; 4
	
	LATCH_PORT=(address);	// Put the LSB of the address on the latch.
     5c6:	e5 b8       	out	0x05, r14	; 5
	PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     5c8:	13 9a       	sbi	0x02, 3	; 2
	PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     5ca:	13 98       	cbi	0x02, 3	; 2
	
	LATCH_PORT=((address>>8));	// Put the middle byte of the address on the latch.
     5cc:	55 27       	eor	r21, r21
     5ce:	41 2f       	mov	r20, r17
     5d0:	30 2f       	mov	r19, r16
     5d2:	2f 2d       	mov	r18, r15
     5d4:	25 b9       	out	0x05, r18	; 5
	PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     5d6:	14 9a       	sbi	0x02, 4	; 2
	PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     5d8:	14 98       	cbi	0x02, 4	; 2
	
	PORTC=(0x88|((address>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     5da:	98 01       	movw	r18, r16
     5dc:	44 27       	eor	r20, r20
     5de:	55 27       	eor	r21, r21
     5e0:	27 70       	andi	r18, 0x07	; 7
     5e2:	28 68       	ori	r18, 0x88	; 136
     5e4:	28 b9       	out	0x08, r18	; 8
	
	LATCH_PORT=value;				// Put the data to write on the RAM's input port
     5e6:	85 b9       	out	0x05, r24	; 5
	
	// Finish writing to RAM.
	PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     5e8:	11 98       	cbi	0x02, 1	; 2
	PORTA|=(Om_RAM_WE);					// Disbale writes.
     5ea:	11 9a       	sbi	0x02, 1	; 2
			
			for(int i=0; i < 512; i++)
			{
				currentByte = TransferSdByte(DUMMY_BYTE);
				WriteRAM(currentAddress, currentByte);
				currentAddress++;
     5ec:	08 94       	sec
     5ee:	e1 1c       	adc	r14, r1
     5f0:	f1 1c       	adc	r15, r1
     5f2:	01 1d       	adc	r16, r1
     5f4:	11 1d       	adc	r17, r1
     5f6:	e0 92 17 01 	sts	0x0117, r14
     5fa:	f0 92 18 01 	sts	0x0118, r15
     5fe:	00 93 19 01 	sts	0x0119, r16
     602:	10 93 1a 01 	sts	0x011A, r17
			while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
			{
				HandleSoftclock();	// Kludgy
			}
			
			for(int i=0; i < 512; i++)
     606:	21 96       	adiw	r28, 0x01	; 1
     608:	82 e0       	ldi	r24, 0x02	; 2
     60a:	c0 30       	cpi	r28, 0x00	; 0
     60c:	d8 07       	cpc	r29, r24
     60e:	61 f6       	brne	.-104    	; 0x5a8 <main+0x186>
			{
				currentByte = TransferSdByte(DUMMY_BYTE);
				WriteRAM(currentAddress, currentByte);
				currentAddress++;
			}
			TransferSdByte(DUMMY_BYTE);		// Eat a couple of CRC bytes
     610:	8f ef       	ldi	r24, 0xFF	; 255
     612:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
			TransferSdByte(DUMMY_BYTE);
     616:	8f ef       	ldi	r24, 0xFF	; 255
     618:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
			
			WriteLedLatch(blockNum / 8);	// Show progress
     61c:	e3 e0       	ldi	r30, 0x03	; 3
     61e:	95 94       	asr	r9
     620:	87 94       	ror	r8
     622:	ea 95       	dec	r30
     624:	e1 f7       	brne	.-8      	; 0x61e <main+0x1fc>
     626:	88 2d       	mov	r24, r8
     628:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
     62c:	03 c0       	rjmp	.+6      	; 0x634 <main+0x212>
		}
		else 
		{
			ShowFailure(0x03);
     62e:	83 e0       	ldi	r24, 0x03	; 3
     630:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <ShowFailure>
		}
		
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
     634:	80 91 c8 00 	lds	r24, 0x00C8
     638:	86 ff       	sbrs	r24, 6
     63a:	fc cf       	rjmp	.-8      	; 0x634 <main+0x212>
			;
		
		EndSdTransfer();				// Bring CS high
     63c:	0e 94 aa 07 	call	0xf54	; 0xf54 <EndSdTransfer>
     640:	08 94       	sec
     642:	a1 1c       	adc	r10, r1
     644:	b1 1c       	adc	r11, r1
     646:	c1 1c       	adc	r12, r1
     648:	d1 1c       	adc	r13, r1
	if(SdHandshake() == false)
	{
		ShowFailure(0x55);	// Branch off here and never come back if we don't have an SD card
	}
	
	for(int blockNum = 0; blockNum < (8*128); blockNum++)	// 8 blocks * 128 samples * 512B = 512KB 
     64a:	e0 e0       	ldi	r30, 0x00	; 0
     64c:	ae 16       	cp	r10, r30
     64e:	e4 e0       	ldi	r30, 0x04	; 4
     650:	be 06       	cpc	r11, r30
     652:	e0 e0       	ldi	r30, 0x00	; 0
     654:	ce 06       	cpc	r12, r30
     656:	e0 e0       	ldi	r30, 0x00	; 0
     658:	de 06       	cpc	r13, r30
     65a:	09 f0       	breq	.+2      	; 0x65e <main+0x23c>
     65c:	87 cf       	rjmp	.-242    	; 0x56c <main+0x14a>
	
	// BULLSHIT LENGTH CALCULATION - stored as 4-byte values on the block immediately after the 512KB sample data
	static unsigned long
		charToInt[4];

	StartSdTransfer();
     65e:	0e 94 ac 07 	call	0xf58	; 0xf58 <StartSdTransfer>
	
	if(SdBeginSingleBlockRead(1024) == true)
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	74 e0       	ldi	r23, 0x04	; 4
     666:	80 e0       	ldi	r24, 0x00	; 0
     668:	90 e0       	ldi	r25, 0x00	; 0
     66a:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <SdBeginSingleBlockRead>
     66e:	81 30       	cpi	r24, 0x01	; 1
     670:	09 f0       	breq	.+2      	; 0x674 <main+0x252>
     672:	8b c0       	rjmp	.+278    	; 0x78a <main+0x368>
	{
		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
     674:	83 e0       	ldi	r24, 0x03	; 3
     676:	6a e7       	ldi	r22, 0x7A	; 122
     678:	70 e0       	ldi	r23, 0x00	; 0
     67a:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
     67e:	02 c0       	rjmp	.+4      	; 0x684 <main+0x262>
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
     680:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
	
	if(SdBeginSingleBlockRead(1024) == true)
	{
		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
     684:	83 e0       	ldi	r24, 0x03	; 3
     686:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
     68a:	88 23       	and	r24, r24
     68c:	29 f4       	brne	.+10     	; 0x698 <main+0x276>
     68e:	8f ef       	ldi	r24, 0xFF	; 255
     690:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     694:	8e 3f       	cpi	r24, 0xFE	; 254
     696:	a1 f7       	brne	.-24     	; 0x680 <main+0x25e>
     698:	c6 e2       	ldi	r28, 0x26	; 38
     69a:	d1 e0       	ldi	r29, 0x01	; 1
		
		
		for(int j=0; j < 128; j++)
		{
			
			charToInt[0] = TransferSdByte(DUMMY_BYTE);
     69c:	8f ef       	ldi	r24, 0xFF	; 255
     69e:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	a0 e0       	ldi	r26, 0x00	; 0
     6a6:	b0 e0       	ldi	r27, 0x00	; 0
     6a8:	80 93 06 01 	sts	0x0106, r24
     6ac:	90 93 07 01 	sts	0x0107, r25
     6b0:	a0 93 08 01 	sts	0x0108, r26
     6b4:	b0 93 09 01 	sts	0x0109, r27
			charToInt[1] = TransferSdByte(DUMMY_BYTE);
     6b8:	8f ef       	ldi	r24, 0xFF	; 255
     6ba:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	a0 e0       	ldi	r26, 0x00	; 0
     6c2:	b0 e0       	ldi	r27, 0x00	; 0
     6c4:	80 93 0a 01 	sts	0x010A, r24
     6c8:	90 93 0b 01 	sts	0x010B, r25
     6cc:	a0 93 0c 01 	sts	0x010C, r26
     6d0:	b0 93 0d 01 	sts	0x010D, r27
			charToInt[2] = TransferSdByte(DUMMY_BYTE);
     6d4:	8f ef       	ldi	r24, 0xFF	; 255
     6d6:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     6da:	90 e0       	ldi	r25, 0x00	; 0
     6dc:	a0 e0       	ldi	r26, 0x00	; 0
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	80 93 0e 01 	sts	0x010E, r24
     6e4:	90 93 0f 01 	sts	0x010F, r25
     6e8:	a0 93 10 01 	sts	0x0110, r26
     6ec:	b0 93 11 01 	sts	0x0111, r27
			charToInt[3] = TransferSdByte(DUMMY_BYTE);
     6f0:	8f ef       	ldi	r24, 0xFF	; 255
     6f2:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     6f6:	90 e0       	ldi	r25, 0x00	; 0
     6f8:	a0 e0       	ldi	r26, 0x00	; 0
     6fa:	b0 e0       	ldi	r27, 0x00	; 0
     6fc:	80 93 12 01 	sts	0x0112, r24
     700:	90 93 13 01 	sts	0x0113, r25
     704:	a0 93 14 01 	sts	0x0114, r26
     708:	b0 93 15 01 	sts	0x0115, r27
			
			sampleLength[j] = (charToInt[3] << 24) | (charToInt[2] << 16) | (charToInt[1] << 8) | (charToInt[0]);	// There might be a function to do this - whatever.
     70c:	e0 90 0e 01 	lds	r14, 0x010E
     710:	f0 90 0f 01 	lds	r15, 0x010F
     714:	00 91 10 01 	lds	r16, 0x0110
     718:	10 91 11 01 	lds	r17, 0x0111
     71c:	87 01       	movw	r16, r14
     71e:	ff 24       	eor	r15, r15
     720:	ee 24       	eor	r14, r14
     722:	20 91 0a 01 	lds	r18, 0x010A
     726:	30 91 0b 01 	lds	r19, 0x010B
     72a:	40 91 0c 01 	lds	r20, 0x010C
     72e:	50 91 0d 01 	lds	r21, 0x010D
     732:	54 2f       	mov	r21, r20
     734:	43 2f       	mov	r20, r19
     736:	32 2f       	mov	r19, r18
     738:	22 27       	eor	r18, r18
     73a:	e2 2a       	or	r14, r18
     73c:	f3 2a       	or	r15, r19
     73e:	04 2b       	or	r16, r20
     740:	15 2b       	or	r17, r21
     742:	20 91 06 01 	lds	r18, 0x0106
     746:	30 91 07 01 	lds	r19, 0x0107
     74a:	40 91 08 01 	lds	r20, 0x0108
     74e:	50 91 09 01 	lds	r21, 0x0109
     752:	e2 2a       	or	r14, r18
     754:	f3 2a       	or	r15, r19
     756:	04 2b       	or	r16, r20
     758:	15 2b       	or	r17, r21
     75a:	b8 2f       	mov	r27, r24
     75c:	aa 27       	eor	r26, r26
     75e:	99 27       	eor	r25, r25
     760:	88 27       	eor	r24, r24
     762:	e8 2a       	or	r14, r24
     764:	f9 2a       	or	r15, r25
     766:	0a 2b       	or	r16, r26
     768:	1b 2b       	or	r17, r27
     76a:	e9 92       	st	Y+, r14
     76c:	f9 92       	st	Y+, r15
     76e:	09 93       	st	Y+, r16
     770:	19 93       	st	Y+, r17
		{
			HandleSoftclock();	// Kludgy
		}
		
		
		for(int j=0; j < 128; j++)
     772:	f3 e0       	ldi	r31, 0x03	; 3
     774:	c6 32       	cpi	r28, 0x26	; 38
     776:	df 07       	cpc	r29, r31
     778:	09 f0       	breq	.+2      	; 0x77c <main+0x35a>
     77a:	90 cf       	rjmp	.-224    	; 0x69c <main+0x27a>
			
			sampleLength[j] = (charToInt[3] << 24) | (charToInt[2] << 16) | (charToInt[1] << 8) | (charToInt[0]);	// There might be a function to do this - whatever.
			//sampleLength[j] = 0x1000;	// Debug fixed length
			
		}
		TransferSdByte(DUMMY_BYTE);		// Eat a couple of CRC bytes
     77c:	8f ef       	ldi	r24, 0xFF	; 255
     77e:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
		TransferSdByte(DUMMY_BYTE);
     782:	8f ef       	ldi	r24, 0xFF	; 255
     784:	0e 94 af 07 	call	0xf5e	; 0xf5e <TransferSdByte>
     788:	03 c0       	rjmp	.+6      	; 0x790 <main+0x36e>
	}
	else 
	{
		ShowFailure(0x03);
     78a:	83 e0       	ldi	r24, 0x03	; 3
     78c:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <ShowFailure>
	}
	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
     790:	80 91 c8 00 	lds	r24, 0x00C8
     794:	86 ff       	sbrs	r24, 6
     796:	fc cf       	rjmp	.-8      	; 0x790 <main+0x36e>
		;
		
	EndSdTransfer();				// Bring CS high
     798:	0e 94 aa 07 	call	0xf54	; 0xf54 <EndSdTransfer>
	

	UnInitSdInterface();
     79c:	0e 94 85 07 	call	0xf0a	; 0xf0a <UnInitSdInterface>
	WriteLedLatch(0x01);
     7a0:	81 e0       	ldi	r24, 0x01	; 1
     7a2:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
	SDtoRAM();
	
	//ClearRAM();
	//PopulateRAM();			// Temporary really - take some variables and expand them to RAM
	
	midiChannelNumberA = 0;
     7a6:	10 92 ca 03 	sts	0x03CA, r1
	midiChannelNumberB = 9;
     7aa:	89 e0       	ldi	r24, 0x09	; 9
     7ac:	80 93 e3 03 	sts	0x03E3, r24
	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
     7b0:	78 94       	sei
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
     7b2:	ff 24       	eor	r15, r15
     7b4:	fa 94       	dec	r15
		// Wasteful code for these switches - just here for a demo - MIDI is where it's at
		if(newKeys&Im_SWITCH_0)
		{
			if(setMode)							// If you hit the 8th switch
			{
				sampleAssignment[0] = encoderValue;	// Take on that value
     7b6:	c4 e7       	ldi	r28, 0x74	; 116
     7b8:	d3 e0       	ldi	r29, 0x03	; 3
		// Copy pasta v
		if(newKeys&Im_SWITCH_1)
		{
			if(setMode)
			{
				sampleAssignment[1] = encoderValue;
     7ba:	92 e0       	ldi	r25, 0x02	; 2
     7bc:	89 2e       	mov	r8, r25
     7be:	91 2c       	mov	r9, r1
     7c0:	8c 0e       	add	r8, r28
     7c2:	9d 1e       	adc	r9, r29
		
		if(newKeys&Im_SWITCH_2)
		{
			if(setMode)
			{
				sampleAssignment[2] = encoderValue;
     7c4:	8e 01       	movw	r16, r28
     7c6:	0c 5f       	subi	r16, 0xFC	; 252
     7c8:	1f 4f       	sbci	r17, 0xFF	; 255

		if(newKeys&Im_SWITCH_3)
		{
			if(setMode)
			{
				sampleAssignment[3] = encoderValue;
     7ca:	86 e0       	ldi	r24, 0x06	; 6
     7cc:	a8 2e       	mov	r10, r24
     7ce:	b1 2c       	mov	r11, r1
     7d0:	ac 0e       	add	r10, r28
     7d2:	bd 1e       	adc	r11, r29
		
		if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
		{
			WriteLedLatch(currentMidiMessage.dataByteOne);
			PlaySample(currentMidiMessage.dataByteOne);
			currentMidiMessage.messageType = IGNORE_ME;					// Crumby way to operate especially with all the information available from midi.c - but only look at the note on to be simple (drumkit)
     7d4:	b9 e0       	ldi	r27, 0x09	; 9
     7d6:	7b 2e       	mov	r7, r27
		setMode;
	
	
	while(1)
	{
		HandleSoftclock();
     7d8:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
     7e2:	88 23       	and	r24, r24
     7e4:	d9 f0       	breq	.+54     	; 0x81c <main+0x3fa>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
     7e6:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
     7e8:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
     7ea:	f5 b8       	out	0x05, r15	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
     7ec:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
     7ee:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
     7f0:	00 00       	nop
		asm volatile("nop"::);
     7f2:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
     7f4:	83 b1       	in	r24, 0x03	; 3
     7f6:	80 95       	com	r24
     7f8:	80 93 21 01 	sts	0x0121, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
     7fc:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
     7fe:	f4 b8       	out	0x04, r15	; 4
		SREG=sreg;					// Stop tying up interrupts		
     800:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
     802:	35 99       	sbic	0x06, 5	; 6
     804:	04 c0       	rjmp	.+8      	; 0x80e <main+0x3ec>
		{
			cardDetect=true;
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	80 93 25 01 	sts	0x0125, r24
     80c:	02 c0       	rjmp	.+4      	; 0x812 <main+0x3f0>
		}
		else
		{
			cardDetect=false;
     80e:	10 92 25 01 	sts	0x0125, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)		
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	66 e2       	ldi	r22, 0x26	; 38
     816:	70 e0       	ldi	r23, 0x00	; 0
     818:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
     81c:	80 91 21 01 	lds	r24, 0x0121
     820:	c0 90 1b 01 	lds	r12, 0x011B
     824:	c0 94       	com	r12
     826:	c8 22       	and	r12, r24
     828:	c0 92 22 01 	sts	0x0122, r12
	lastKeyState=keyState;								// And store this keystate as old news.
     82c:	80 93 1b 01 	sts	0x011B, r24
	static unsigned char
	lastEncoderState=0;
	static unsigned int
	lastEncTime=0;
	
	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
     830:	20 91 c8 03 	lds	r18, 0x03C8
     834:	30 91 c9 03 	lds	r19, 0x03C9
     838:	80 91 1c 01 	lds	r24, 0x011C
     83c:	90 91 1d 01 	lds	r25, 0x011D
     840:	28 17       	cp	r18, r24
     842:	39 07       	cpc	r19, r25
     844:	b1 f1       	breq	.+108    	; 0x8b2 <main+0x490>
	{
		lastEncTime=systemTicks;					// update last read time.
     846:	80 91 c8 03 	lds	r24, 0x03C8
     84a:	90 91 c9 03 	lds	r25, 0x03C9
     84e:	90 93 1d 01 	sts	0x011D, r25
     852:	80 93 1c 01 	sts	0x011C, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
     856:	90 b1       	in	r25, 0x00	; 0
     858:	90 7c       	andi	r25, 0xC0	; 192
     85a:	90 93 23 01 	sts	0x0123, r25
		
		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
     85e:	80 91 1e 01 	lds	r24, 0x011E
     862:	98 17       	cp	r25, r24
     864:	31 f1       	breq	.+76     	; 0x8b2 <main+0x490>
		{
			if(encoderState==ENC_POS_A)
     866:	99 23       	and	r25, r25
     868:	29 f4       	brne	.+10     	; 0x874 <main+0x452>
			{
				if(lastEncoderState==ENC_POS_D)
     86a:	80 38       	cpi	r24, 0x80	; 128
     86c:	a9 f0       	breq	.+42     	; 0x898 <main+0x476>
				{
					//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_B)
     86e:	80 34       	cpi	r24, 0x40	; 64
     870:	f1 f4       	brne	.+60     	; 0x8ae <main+0x48c>
     872:	18 c0       	rjmp	.+48     	; 0x8a4 <main+0x482>
				{
					//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_B)
     874:	90 34       	cpi	r25, 0x40	; 64
     876:	29 f4       	brne	.+10     	; 0x882 <main+0x460>
			{
				if(lastEncoderState==ENC_POS_A)
     878:	88 23       	and	r24, r24
     87a:	71 f0       	breq	.+28     	; 0x898 <main+0x476>
				{
					//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_C)
     87c:	80 3c       	cpi	r24, 0xC0	; 192
     87e:	b9 f4       	brne	.+46     	; 0x8ae <main+0x48c>
     880:	11 c0       	rjmp	.+34     	; 0x8a4 <main+0x482>
				{
					//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_C)
     882:	90 3c       	cpi	r25, 0xC0	; 192
     884:	29 f4       	brne	.+10     	; 0x890 <main+0x46e>
			{
				if(lastEncoderState==ENC_POS_B)
     886:	80 34       	cpi	r24, 0x40	; 64
     888:	39 f0       	breq	.+14     	; 0x898 <main+0x476>
				{
					//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_D)
     88a:	80 38       	cpi	r24, 0x80	; 128
     88c:	81 f4       	brne	.+32     	; 0x8ae <main+0x48c>
     88e:	0a c0       	rjmp	.+20     	; 0x8a4 <main+0x482>
				{
					//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_D)
     890:	90 38       	cpi	r25, 0x80	; 128
     892:	69 f4       	brne	.+26     	; 0x8ae <main+0x48c>
			{
				if(lastEncoderState==ENC_POS_C)
     894:	80 3c       	cpi	r24, 0xC0	; 192
     896:	21 f4       	brne	.+8      	; 0x8a0 <main+0x47e>
				{
					//					encoderValue++;
					encoderValue--;
     898:	80 91 24 01 	lds	r24, 0x0124
     89c:	81 50       	subi	r24, 0x01	; 1
     89e:	05 c0       	rjmp	.+10     	; 0x8aa <main+0x488>
				}
				else if(lastEncoderState==ENC_POS_A)
     8a0:	88 23       	and	r24, r24
     8a2:	29 f4       	brne	.+10     	; 0x8ae <main+0x48c>
				{
					//					encoderValue--;
					encoderValue++;
     8a4:	80 91 24 01 	lds	r24, 0x0124
     8a8:	8f 5f       	subi	r24, 0xFF	; 255
     8aa:	80 93 24 01 	sts	0x0124, r24
				}
			}		
			
			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
     8ae:	90 93 1e 01 	sts	0x011E, r25
	{
		HandleSoftclock();
		HandleSwitches();
		HandleEncoder();
		
		if(oldEncoderState != encoderValue)
     8b2:	e0 90 24 01 	lds	r14, 0x0124
     8b6:	80 91 05 01 	lds	r24, 0x0105
     8ba:	8e 15       	cp	r24, r14
     8bc:	59 f0       	breq	.+22     	; 0x8d4 <main+0x4b2>
		{
			oldEncoderState = encoderValue;
     8be:	e0 92 05 01 	sts	0x0105, r14
			WriteLedLatch(encoderValue);
     8c2:	8e 2d       	mov	r24, r14
     8c4:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			PlaySample(encoderValue);
     8c8:	6e 2d       	mov	r22, r14
     8ca:	70 e0       	ldi	r23, 0x00	; 0
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
		}
		
		// Wasteful code for these switches - just here for a demo - MIDI is where it's at
		if(newKeys&Im_SWITCH_0)
     8d4:	dc 2c       	mov	r13, r12
     8d6:	c0 fe       	sbrs	r12, 0
     8d8:	16 c0       	rjmp	.+44     	; 0x906 <main+0x4e4>
		{
			if(setMode)							// If you hit the 8th switch
     8da:	80 91 04 01 	lds	r24, 0x0104
     8de:	88 23       	and	r24, r24
     8e0:	19 f0       	breq	.+6      	; 0x8e8 <main+0x4c6>
			{
				sampleAssignment[0] = encoderValue;	// Take on that value
     8e2:	e0 92 74 03 	sts	0x0374, r14
     8e6:	19 82       	std	Y+1, r1	; 0x01
			}
			PlaySample(sampleAssignment[0]);	// Preview sound that has just been written
     8e8:	60 91 74 03 	lds	r22, 0x0374
     8ec:	70 91 75 03 	lds	r23, 0x0375
     8f0:	88 27       	eor	r24, r24
     8f2:	77 fd       	sbrc	r23, 7
     8f4:	80 95       	com	r24
     8f6:	98 2f       	mov	r25, r24
     8f8:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
			WriteLedLatch(0x01);				// Indicate bank slot
     8fc:	81 e0       	ldi	r24, 0x01	; 1
     8fe:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			setMode = 0;					    // Clear set mode and go back to playing on press
     902:	10 92 04 01 	sts	0x0104, r1
		}
		
		// Copy pasta v
		if(newKeys&Im_SWITCH_1)
     906:	d1 fe       	sbrs	r13, 1
     908:	17 c0       	rjmp	.+46     	; 0x938 <main+0x516>
		{
			if(setMode)
     90a:	80 91 04 01 	lds	r24, 0x0104
     90e:	88 23       	and	r24, r24
     910:	21 f0       	breq	.+8      	; 0x91a <main+0x4f8>
			{
				sampleAssignment[1] = encoderValue;
     912:	e0 92 76 03 	sts	0x0376, r14
     916:	f4 01       	movw	r30, r8
     918:	11 82       	std	Z+1, r1	; 0x01
			}
			PlaySample(sampleAssignment[1]);
     91a:	60 91 76 03 	lds	r22, 0x0376
     91e:	70 91 77 03 	lds	r23, 0x0377
     922:	88 27       	eor	r24, r24
     924:	77 fd       	sbrc	r23, 7
     926:	80 95       	com	r24
     928:	98 2f       	mov	r25, r24
     92a:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
			WriteLedLatch(0x02);
     92e:	82 e0       	ldi	r24, 0x02	; 2
     930:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			setMode = 0;
     934:	10 92 04 01 	sts	0x0104, r1
		}
		
		if(newKeys&Im_SWITCH_2)
     938:	d2 fe       	sbrs	r13, 2
     93a:	17 c0       	rjmp	.+46     	; 0x96a <main+0x548>
		{
			if(setMode)
     93c:	80 91 04 01 	lds	r24, 0x0104
     940:	88 23       	and	r24, r24
     942:	21 f0       	breq	.+8      	; 0x94c <main+0x52a>
			{
				sampleAssignment[2] = encoderValue;
     944:	e0 92 78 03 	sts	0x0378, r14
     948:	f8 01       	movw	r30, r16
     94a:	11 82       	std	Z+1, r1	; 0x01
			}
			PlaySample(sampleAssignment[2]);
     94c:	60 91 78 03 	lds	r22, 0x0378
     950:	70 91 79 03 	lds	r23, 0x0379
     954:	88 27       	eor	r24, r24
     956:	77 fd       	sbrc	r23, 7
     958:	80 95       	com	r24
     95a:	98 2f       	mov	r25, r24
     95c:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
			WriteLedLatch(0x04);
     960:	84 e0       	ldi	r24, 0x04	; 4
     962:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			setMode = 0;
     966:	10 92 04 01 	sts	0x0104, r1
		}

		if(newKeys&Im_SWITCH_3)
     96a:	d3 fe       	sbrs	r13, 3
     96c:	17 c0       	rjmp	.+46     	; 0x99c <main+0x57a>
		{
			if(setMode)
     96e:	80 91 04 01 	lds	r24, 0x0104
     972:	88 23       	and	r24, r24
     974:	21 f0       	breq	.+8      	; 0x97e <main+0x55c>
			{
				sampleAssignment[3] = encoderValue;
     976:	e0 92 7a 03 	sts	0x037A, r14
     97a:	f5 01       	movw	r30, r10
     97c:	11 82       	std	Z+1, r1	; 0x01
			}
			PlaySample(sampleAssignment[3]);
     97e:	60 91 7a 03 	lds	r22, 0x037A
     982:	70 91 7b 03 	lds	r23, 0x037B
     986:	88 27       	eor	r24, r24
     988:	77 fd       	sbrc	r23, 7
     98a:	80 95       	com	r24
     98c:	98 2f       	mov	r25, r24
     98e:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
			WriteLedLatch(0x08);
     992:	88 e0       	ldi	r24, 0x08	; 8
     994:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			setMode = 0;
     998:	10 92 04 01 	sts	0x0104, r1
		}
		
		// Set mode assigns samples to the switch
		if(newKeys&Im_SWITCH_7)
     99c:	c7 fe       	sbrs	r12, 7
     99e:	06 c0       	rjmp	.+12     	; 0x9ac <main+0x58a>
		{
			setMode = 1;
     9a0:	81 e0       	ldi	r24, 0x01	; 1
     9a2:	80 93 04 01 	sts	0x0104, r24
			WriteLedLatch(0x80);
     9a6:	80 e8       	ldi	r24, 0x80	; 128
     9a8:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
		}
		
		
		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
     9ac:	0e 94 11 05 	call	0xa22	; 0xa22 <Uart0GotByte>
     9b0:	88 23       	and	r24, r24
     9b2:	21 f0       	breq	.+8      	; 0x9bc <main+0x59a>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
     9b4:	0e 94 17 05 	call	0xa2e	; 0xa2e <Uart0GetByte>
     9b8:	0e 94 f7 05 	call	0xbee	; 0xbee <HandleIncomingMidiByte>
		}
		
		static MIDI_MESSAGE
			currentMidiMessage;				// Used to point to incoming midi messages.
		
		GetMidiMessageFromIncomingFifo(&currentMidiMessage);
     9bc:	80 e0       	ldi	r24, 0x00	; 0
     9be:	91 e0       	ldi	r25, 0x01	; 1
     9c0:	0e 94 65 05 	call	0xaca	; 0xaca <GetMidiMessageFromIncomingFifo>
		
		if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
     9c4:	80 91 01 01 	lds	r24, 0x0101
     9c8:	81 30       	cpi	r24, 0x01	; 1
     9ca:	09 f0       	breq	.+2      	; 0x9ce <main+0x5ac>
     9cc:	05 cf       	rjmp	.-502    	; 0x7d8 <main+0x3b6>
		{
			WriteLedLatch(currentMidiMessage.dataByteOne);
     9ce:	80 91 02 01 	lds	r24, 0x0102
     9d2:	0e 94 e6 01 	call	0x3cc	; 0x3cc <WriteLedLatch>
			PlaySample(currentMidiMessage.dataByteOne);
     9d6:	60 91 02 01 	lds	r22, 0x0102
     9da:	70 e0       	ldi	r23, 0x00	; 0
     9dc:	80 e0       	ldi	r24, 0x00	; 0
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	0e 94 52 00 	call	0xa4	; 0xa4 <PlaySample>
			currentMidiMessage.messageType = IGNORE_ME;					// Crumby way to operate especially with all the information available from midi.c - but only look at the note on to be simple (drumkit)
     9e4:	70 92 01 01 	sts	0x0101, r7
     9e8:	f7 ce       	rjmp	.-530    	; 0x7d8 <main+0x3b6>

000009ea <EepromWrite>:
// NOTE:  Accepted lore is not to use eeprom address 0 since it's the most likely one to get buggered in a crash.

#include "includes.h"

void EepromWrite(unsigned int theAddress, unsigned char theData)
{
     9ea:	9c 01       	movw	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
     9ec:	f9 99       	sbic	0x1f, 1	; 31
     9ee:	fe cf       	rjmp	.-4      	; 0x9ec <EepromWrite+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
     9f0:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
     9f2:	f8 94       	cli

	EEAR=theAddress;
     9f4:	32 bd       	out	0x22, r19	; 34
     9f6:	21 bd       	out	0x21, r18	; 33
	EEDR=theData;
     9f8:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
     9fa:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
     9fc:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
     9fe:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
     a00:	12 bc       	out	0x22, r1	; 34
     a02:	11 bc       	out	0x21, r1	; 33
}
     a04:	08 95       	ret

00000a06 <EepromRead>:

unsigned char EepromRead(unsigned char theAddress)
{
     a06:	28 2f       	mov	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
     a08:	f9 99       	sbic	0x1f, 1	; 31
     a0a:	fe cf       	rjmp	.-4      	; 0xa08 <EepromRead+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
     a0c:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
     a0e:	f8 94       	cli

	EEAR=theAddress;
     a10:	30 e0       	ldi	r19, 0x00	; 0
     a12:	32 bd       	out	0x22, r19	; 34
     a14:	21 bd       	out	0x21, r18	; 33
	EECR|=(1<<EERE);	// Start reading.
     a16:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
     a18:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
     a1a:	12 bc       	out	0x22, r1	; 34
     a1c:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
     a1e:	80 b5       	in	r24, 0x20	; 32
}
     a20:	08 95       	ret

00000a22 <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
     a22:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
     a26:	88 1f       	adc	r24, r24
     a28:	88 27       	eor	r24, r24
     a2a:	88 1f       	adc	r24, r24
     a2c:	08 95       	ret

00000a2e <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
     a2e:	80 91 c6 00 	lds	r24, 0x00C6
}
     a32:	08 95       	ret

00000a34 <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
     a34:	80 91 64 00 	lds	r24, 0x0064
     a38:	8d 7f       	andi	r24, 0xFD	; 253
     a3a:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
     a3e:	80 91 c0 00 	lds	r24, 0x00C0
     a42:	8d 7f       	andi	r24, 0xFD	; 253
     a44:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
     a48:	88 e1       	ldi	r24, 0x18	; 24
     a4a:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
     a4e:	87 e2       	ldi	r24, 0x27	; 39
     a50:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
     a54:	86 e0       	ldi	r24, 0x06	; 6
     a56:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
     a5a:	80 91 c0 00 	lds	r24, 0x00C0
     a5e:	85 ff       	sbrs	r24, 5
     a60:	fc cf       	rjmp	.-8      	; 0xa5a <InitUart0+0x26>
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
     a62:	80 91 c0 00 	lds	r24, 0x00C0
     a66:	87 ff       	sbrs	r24, 7
     a68:	03 c0       	rjmp	.+6      	; 0xa70 <InitUart0+0x3c>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
     a6a:	80 91 c6 00 	lds	r24, 0x00C6
     a6e:	f9 cf       	rjmp	.-14     	; 0xa62 <InitUart0+0x2e>
     a70:	08 95       	ret

00000a72 <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
     a72:	e8 2f       	mov	r30, r24
     a74:	f0 e0       	ldi	r31, 0x00	; 0
     a76:	80 91 c8 03 	lds	r24, 0x03C8
     a7a:	90 91 c9 03 	lds	r25, 0x03C9
     a7e:	ee 0f       	add	r30, r30
     a80:	ff 1f       	adc	r31, r31
     a82:	df 01       	movw	r26, r30
     a84:	a9 5a       	subi	r26, 0xA9	; 169
     a86:	bc 4f       	sbci	r27, 0xFC	; 252
     a88:	8d 93       	st	X+, r24
     a8a:	9c 93       	st	X, r25
	delayTime[timerNum]=ticks_to_wait;
     a8c:	e1 5a       	subi	r30, 0xA1	; 161
     a8e:	fc 4f       	sbci	r31, 0xFC	; 252
     a90:	71 83       	std	Z+1, r23	; 0x01
     a92:	60 83       	st	Z, r22
}
     a94:	08 95       	ret

00000a96 <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
     a96:	20 91 c8 03 	lds	r18, 0x03C8
     a9a:	30 91 c9 03 	lds	r19, 0x03C9
     a9e:	e8 2f       	mov	r30, r24
     aa0:	f0 e0       	ldi	r31, 0x00	; 0
     aa2:	40 e0       	ldi	r20, 0x00	; 0
     aa4:	ee 0f       	add	r30, r30
     aa6:	ff 1f       	adc	r31, r31
     aa8:	df 01       	movw	r26, r30
     aaa:	a9 5a       	subi	r26, 0xA9	; 169
     aac:	bc 4f       	sbci	r27, 0xFC	; 252
     aae:	8d 91       	ld	r24, X+
     ab0:	9c 91       	ld	r25, X
     ab2:	28 1b       	sub	r18, r24
     ab4:	39 0b       	sbc	r19, r25
     ab6:	e1 5a       	subi	r30, 0xA1	; 161
     ab8:	fc 4f       	sbci	r31, 0xFC	; 252
     aba:	80 81       	ld	r24, Z
     abc:	91 81       	ldd	r25, Z+1	; 0x01
     abe:	28 17       	cp	r18, r24
     ac0:	39 07       	cpc	r19, r25
     ac2:	08 f0       	brcs	.+2      	; 0xac6 <CheckTimer+0x30>
     ac4:	41 e0       	ldi	r20, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
     ac6:	84 2f       	mov	r24, r20
     ac8:	08 95       	ret

00000aca <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
     ad0:	20 91 fc 03 	lds	r18, 0x03FC
     ad4:	22 23       	and	r18, r18
     ad6:	19 f1       	breq	.+70     	; 0xb1e <GetMidiMessageFromIncomingFifo+0x54>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
     ad8:	90 91 6f 03 	lds	r25, 0x036F
     adc:	e9 2f       	mov	r30, r25
     ade:	f0 e0       	ldi	r31, 0x00	; 0
     ae0:	ee 0f       	add	r30, r30
     ae2:	ff 1f       	adc	r31, r31
     ae4:	ee 0f       	add	r30, r30
     ae6:	ff 1f       	adc	r31, r31
     ae8:	df 01       	movw	r26, r30
     aea:	a5 53       	subi	r26, 0x35	; 53
     aec:	bc 4f       	sbci	r27, 0xFC	; 252
     aee:	11 96       	adiw	r26, 0x01	; 1
     af0:	8c 91       	ld	r24, X
     af2:	11 97       	sbiw	r26, 0x01	; 1
     af4:	89 83       	std	Y+1, r24	; 0x01
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
     af6:	e3 53       	subi	r30, 0x33	; 51
     af8:	fc 4f       	sbci	r31, 0xFC	; 252
     afa:	80 81       	ld	r24, Z
     afc:	8a 83       	std	Y+2, r24	; 0x02
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
     afe:	13 96       	adiw	r26, 0x03	; 3
     b00:	8c 91       	ld	r24, X
     b02:	13 97       	sbiw	r26, 0x03	; 3
     b04:	8b 83       	std	Y+3, r24	; 0x03
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
     b06:	8c 91       	ld	r24, X
     b08:	88 83       	st	Y, r24

		midiIncomingFifoReadPointer++;			// read from the next element next time
     b0a:	9f 5f       	subi	r25, 0xFF	; 255
     b0c:	90 93 6f 03 	sts	0x036F, r25
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
     b10:	96 30       	cpi	r25, 0x06	; 6
     b12:	10 f0       	brcs	.+4      	; 0xb18 <GetMidiMessageFromIncomingFifo+0x4e>
		{
			midiIncomingFifoReadPointer=0;
     b14:	10 92 6f 03 	sts	0x036F, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
     b18:	21 50       	subi	r18, 0x01	; 1
     b1a:	20 93 fc 03 	sts	0x03FC, r18
	}
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	08 95       	ret

00000b24 <PutMidiMessageInIncomingFifo>:

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
     b24:	cf 93       	push	r28
     b26:	df 93       	push	r29
     b28:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
     b2a:	20 91 fc 03 	lds	r18, 0x03FC
     b2e:	26 30       	cpi	r18, 0x06	; 6
     b30:	18 f5       	brcc	.+70     	; 0xb78 <PutMidiMessageInIncomingFifo+0x54>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
     b32:	90 91 6e 03 	lds	r25, 0x036E
     b36:	e9 2f       	mov	r30, r25
     b38:	f0 e0       	ldi	r31, 0x00	; 0
     b3a:	ee 0f       	add	r30, r30
     b3c:	ff 1f       	adc	r31, r31
     b3e:	ee 0f       	add	r30, r30
     b40:	ff 1f       	adc	r31, r31
     b42:	df 01       	movw	r26, r30
     b44:	a5 53       	subi	r26, 0x35	; 53
     b46:	bc 4f       	sbci	r27, 0xFC	; 252
     b48:	89 81       	ldd	r24, Y+1	; 0x01
     b4a:	11 96       	adiw	r26, 0x01	; 1
     b4c:	8c 93       	st	X, r24
     b4e:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
     b50:	e3 53       	subi	r30, 0x33	; 51
     b52:	fc 4f       	sbci	r31, 0xFC	; 252
     b54:	8a 81       	ldd	r24, Y+2	; 0x02
     b56:	80 83       	st	Z, r24
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	13 96       	adiw	r26, 0x03	; 3
     b5c:	8c 93       	st	X, r24
     b5e:	13 97       	sbiw	r26, 0x03	; 3
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
     b60:	88 81       	ld	r24, Y
     b62:	8c 93       	st	X, r24
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
     b64:	9f 5f       	subi	r25, 0xFF	; 255
     b66:	90 93 6e 03 	sts	0x036E, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
     b6a:	96 30       	cpi	r25, 0x06	; 6
     b6c:	10 f0       	brcs	.+4      	; 0xb72 <PutMidiMessageInIncomingFifo+0x4e>
		{
			midiIncomingFifoWritePointer=0;
     b6e:	10 92 6e 03 	sts	0x036E, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
     b72:	2f 5f       	subi	r18, 0xFF	; 255
     b74:	20 93 fc 03 	sts	0x03FC, r18
	}
}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	08 95       	ret

00000b7e <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
     b7e:	30 91 fd 03 	lds	r19, 0x03FD
     b82:	36 30       	cpi	r19, 0x06	; 6
     b84:	08 f5       	brcc	.+66     	; 0xbc8 <PutMidiMessageInOutgoingFifo+0x4a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
     b86:	90 91 71 03 	lds	r25, 0x0371
     b8a:	e9 2f       	mov	r30, r25
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	ee 0f       	add	r30, r30
     b90:	ff 1f       	adc	r31, r31
     b92:	ee 0f       	add	r30, r30
     b94:	ff 1f       	adc	r31, r31
     b96:	df 01       	movw	r26, r30
     b98:	ac 51       	subi	r26, 0x1C	; 28
     b9a:	bc 4f       	sbci	r27, 0xFC	; 252
     b9c:	11 96       	adiw	r26, 0x01	; 1
     b9e:	6c 93       	st	X, r22
     ba0:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
     ba2:	ea 51       	subi	r30, 0x1A	; 26
     ba4:	fc 4f       	sbci	r31, 0xFC	; 252
     ba6:	40 83       	st	Z, r20
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
     ba8:	13 96       	adiw	r26, 0x03	; 3
     baa:	2c 93       	st	X, r18
     bac:	13 97       	sbiw	r26, 0x03	; 3
     bae:	80 91 ca 03 	lds	r24, 0x03CA
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
     bb2:	8c 93       	st	X, r24
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
     bb4:	9f 5f       	subi	r25, 0xFF	; 255
     bb6:	90 93 71 03 	sts	0x0371, r25
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
     bba:	96 30       	cpi	r25, 0x06	; 6
     bbc:	10 f0       	brcs	.+4      	; 0xbc2 <PutMidiMessageInOutgoingFifo+0x44>
		{
			midiOutgoingFifoWritePointer=0;
     bbe:	10 92 71 03 	sts	0x0371, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
     bc2:	3f 5f       	subi	r19, 0xFF	; 255
     bc4:	30 93 fd 03 	sts	0x03FD, r19
     bc8:	08 95       	ret

00000bca <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
     bca:	89 e0       	ldi	r24, 0x09	; 9
     bcc:	80 93 70 03 	sts	0x0370, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
     bd0:	10 92 73 03 	sts	0x0373, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
     bd4:	10 92 fc 03 	sts	0x03FC, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
     bd8:	10 92 6e 03 	sts	0x036E, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
     bdc:	10 92 6f 03 	sts	0x036F, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
     be0:	10 92 fd 03 	sts	0x03FD, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
     be4:	10 92 71 03 	sts	0x0371, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
     be8:	10 92 72 03 	sts	0x0372, r1
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
	InitMidiIncomingFifo();								// Set up the receiving buffer.
	InitMidiOutgoingFifo();								// Set up xmit buffer.
}
     bec:	08 95       	ret

00000bee <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
     bee:	1f 93       	push	r17
     bf0:	df 93       	push	r29
     bf2:	cf 93       	push	r28
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <HandleIncomingMidiByte+0x8>
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <HandleIncomingMidiByte+0xa>
     bf8:	cd b7       	in	r28, 0x3d	; 61
     bfa:	de b7       	in	r29, 0x3e	; 62
     bfc:	28 2f       	mov	r18, r24
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
     bfe:	87 ff       	sbrs	r24, 7
     c00:	41 c0       	rjmp	.+130    	; 0xc84 <HandleIncomingMidiByte+0x96>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
     c02:	68 2f       	mov	r22, r24
     c04:	70 e0       	ldi	r23, 0x00	; 0
     c06:	9b 01       	movw	r18, r22
     c08:	2f 70       	andi	r18, 0x0F	; 15
     c0a:	30 70       	andi	r19, 0x00	; 0
     c0c:	80 91 ca 03 	lds	r24, 0x03CA
     c10:	48 2f       	mov	r20, r24
     c12:	50 e0       	ldi	r21, 0x00	; 0
     c14:	24 17       	cp	r18, r20
     c16:	35 07       	cpc	r19, r21
     c18:	39 f0       	breq	.+14     	; 0xc28 <HandleIncomingMidiByte+0x3a>
     c1a:	80 91 e3 03 	lds	r24, 0x03E3
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	28 17       	cp	r18, r24
     c22:	39 07       	cpc	r19, r25
     c24:	09 f0       	breq	.+2      	; 0xc28 <HandleIncomingMidiByte+0x3a>
     c26:	ad c0       	rjmp	.+346    	; 0xd82 <HandleIncomingMidiByte+0x194>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
     c28:	cb 01       	movw	r24, r22
     c2a:	80 7f       	andi	r24, 0xF0	; 240
     c2c:	90 70       	andi	r25, 0x00	; 0
     c2e:	80 39       	cpi	r24, 0x90	; 144
     c30:	91 05       	cpc	r25, r1
     c32:	19 f4       	brne	.+6      	; 0xc3a <HandleIncomingMidiByte+0x4c>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
     c34:	10 92 70 03 	sts	0x0370, r1
     c38:	1b c0       	rjmp	.+54     	; 0xc70 <HandleIncomingMidiByte+0x82>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
     c3a:	80 38       	cpi	r24, 0x80	; 128
     c3c:	91 05       	cpc	r25, r1
     c3e:	39 f4       	brne	.+14     	; 0xc4e <HandleIncomingMidiByte+0x60>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
     c40:	81 e0       	ldi	r24, 0x01	; 1
     c42:	80 93 70 03 	sts	0x0370, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
     c46:	24 17       	cp	r18, r20
     c48:	35 07       	cpc	r19, r21
     c4a:	c9 f4       	brne	.+50     	; 0xc7e <HandleIncomingMidiByte+0x90>
     c4c:	14 c0       	rjmp	.+40     	; 0xc76 <HandleIncomingMidiByte+0x88>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
     c4e:	80 3c       	cpi	r24, 0xC0	; 192
     c50:	91 05       	cpc	r25, r1
     c52:	11 f4       	brne	.+4      	; 0xc58 <HandleIncomingMidiByte+0x6a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
     c54:	82 e0       	ldi	r24, 0x02	; 2
     c56:	0a c0       	rjmp	.+20     	; 0xc6c <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
     c58:	80 3e       	cpi	r24, 0xE0	; 224
     c5a:	91 05       	cpc	r25, r1
     c5c:	11 f4       	brne	.+4      	; 0xc62 <HandleIncomingMidiByte+0x74>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
     c5e:	87 e0       	ldi	r24, 0x07	; 7
     c60:	05 c0       	rjmp	.+10     	; 0xc6c <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
     c62:	80 3b       	cpi	r24, 0xB0	; 176
     c64:	91 05       	cpc	r25, r1
     c66:	09 f0       	breq	.+2      	; 0xc6a <HandleIncomingMidiByte+0x7c>
     c68:	8c c0       	rjmp	.+280    	; 0xd82 <HandleIncomingMidiByte+0x194>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
     c6a:	83 e0       	ldi	r24, 0x03	; 3
     c6c:	80 93 70 03 	sts	0x0370, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
     c70:	24 17       	cp	r18, r20
     c72:	35 07       	cpc	r19, r21
     c74:	19 f4       	brne	.+6      	; 0xc7c <HandleIncomingMidiByte+0x8e>
				{
					temporaryChannel=BANK_0;
     c76:	10 92 6c 03 	sts	0x036C, r1
     c7a:	86 c0       	rjmp	.+268    	; 0xd88 <HandleIncomingMidiByte+0x19a>
				}
				else
				{
					temporaryChannel=BANK_1;
     c7c:	81 e0       	ldi	r24, 0x01	; 1
     c7e:	80 93 6c 03 	sts	0x036C, r24
     c82:	82 c0       	rjmp	.+260    	; 0xd88 <HandleIncomingMidiByte+0x19a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
     c84:	10 91 70 03 	lds	r17, 0x0370
     c88:	14 30       	cpi	r17, 0x04	; 4
     c8a:	09 f4       	brne	.+2      	; 0xc8e <HandleIncomingMidiByte+0xa0>
     c8c:	58 c0       	rjmp	.+176    	; 0xd3e <HandleIncomingMidiByte+0x150>
     c8e:	15 30       	cpi	r17, 0x05	; 5
     c90:	58 f4       	brcc	.+22     	; 0xca8 <HandleIncomingMidiByte+0xba>
     c92:	11 30       	cpi	r17, 0x01	; 1
     c94:	c1 f1       	breq	.+112    	; 0xd06 <HandleIncomingMidiByte+0x118>
     c96:	11 30       	cpi	r17, 0x01	; 1
     c98:	c8 f0       	brcs	.+50     	; 0xccc <HandleIncomingMidiByte+0xde>
     c9a:	12 30       	cpi	r17, 0x02	; 2
     c9c:	09 f4       	brne	.+2      	; 0xca0 <HandleIncomingMidiByte+0xb2>
     c9e:	46 c0       	rjmp	.+140    	; 0xd2c <HandleIncomingMidiByte+0x13e>
     ca0:	13 30       	cpi	r17, 0x03	; 3
     ca2:	09 f0       	breq	.+2      	; 0xca6 <HandleIncomingMidiByte+0xb8>
     ca4:	6e c0       	rjmp	.+220    	; 0xd82 <HandleIncomingMidiByte+0x194>
     ca6:	47 c0       	rjmp	.+142    	; 0xd36 <HandleIncomingMidiByte+0x148>
     ca8:	17 30       	cpi	r17, 0x07	; 7
     caa:	09 f4       	brne	.+2      	; 0xcae <HandleIncomingMidiByte+0xc0>
     cac:	56 c0       	rjmp	.+172    	; 0xd5a <HandleIncomingMidiByte+0x16c>
     cae:	18 30       	cpi	r17, 0x08	; 8
     cb0:	30 f4       	brcc	.+12     	; 0xcbe <HandleIncomingMidiByte+0xd0>
     cb2:	15 30       	cpi	r17, 0x05	; 5
     cb4:	79 f0       	breq	.+30     	; 0xcd4 <HandleIncomingMidiByte+0xe6>
     cb6:	16 30       	cpi	r17, 0x06	; 6
     cb8:	09 f0       	breq	.+2      	; 0xcbc <HandleIncomingMidiByte+0xce>
     cba:	63 c0       	rjmp	.+198    	; 0xd82 <HandleIncomingMidiByte+0x194>
     cbc:	28 c0       	rjmp	.+80     	; 0xd0e <HandleIncomingMidiByte+0x120>
     cbe:	18 30       	cpi	r17, 0x08	; 8
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <HandleIncomingMidiByte+0xd6>
     cc2:	4f c0       	rjmp	.+158    	; 0xd62 <HandleIncomingMidiByte+0x174>
     cc4:	19 30       	cpi	r17, 0x09	; 9
     cc6:	09 f0       	breq	.+2      	; 0xcca <HandleIncomingMidiByte+0xdc>
     cc8:	5c c0       	rjmp	.+184    	; 0xd82 <HandleIncomingMidiByte+0x194>
     cca:	5e c0       	rjmp	.+188    	; 0xd88 <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
     ccc:	80 93 6d 03 	sts	0x036D, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
     cd0:	85 e0       	ldi	r24, 0x05	; 5
     cd2:	58 c0       	rjmp	.+176    	; 0xd84 <HandleIncomingMidiByte+0x196>
     cd4:	30 91 6d 03 	lds	r19, 0x036D
     cd8:	40 91 6c 03 	lds	r20, 0x036C
     cdc:	be 01       	movw	r22, r28
     cde:	6f 5f       	subi	r22, 0xFF	; 255
     ce0:	7f 4f       	sbci	r23, 0xFF	; 255
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
     ce2:	88 23       	and	r24, r24
     ce4:	29 f4       	brne	.+10     	; 0xcf0 <HandleIncomingMidiByte+0x102>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
     ce6:	82 e0       	ldi	r24, 0x02	; 2
     ce8:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
     cea:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
     cec:	1c 82       	std	Y+4, r1	; 0x04
     cee:	04 c0       	rjmp	.+8      	; 0xcf8 <HandleIncomingMidiByte+0x10a>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
     cf0:	81 e0       	ldi	r24, 0x01	; 1
     cf2:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
     cf4:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
     cf6:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
     cf8:	49 83       	std	Y+1, r20	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
     cfa:	cb 01       	movw	r24, r22
     cfc:	0e 94 92 05 	call	0xb24	; 0xb24 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
     d00:	10 92 70 03 	sts	0x0370, r1
     d04:	41 c0       	rjmp	.+130    	; 0xd88 <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
     d06:	80 93 6d 03 	sts	0x036D, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
     d0a:	86 e0       	ldi	r24, 0x06	; 6
     d0c:	3b c0       	rjmp	.+118    	; 0xd84 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
     d12:	80 91 6d 03 	lds	r24, 0x036D
     d16:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
     d18:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
     d1a:	80 91 6c 03 	lds	r24, 0x036C
     d1e:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
     d20:	ce 01       	movw	r24, r28
     d22:	01 96       	adiw	r24, 0x01	; 1
     d24:	0e 94 92 05 	call	0xb24	; 0xb24 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	2c c0       	rjmp	.+88     	; 0xd84 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
     d2c:	83 e0       	ldi	r24, 0x03	; 3
     d2e:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
     d30:	2b 83       	std	Y+3, r18	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
     d32:	1c 82       	std	Y+4, r1	; 0x04
     d34:	1c c0       	rjmp	.+56     	; 0xd6e <HandleIncomingMidiByte+0x180>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
     d36:	80 93 6d 03 	sts	0x036D, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	23 c0       	rjmp	.+70     	; 0xd84 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
     d3e:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
     d40:	80 91 6d 03 	lds	r24, 0x036D
     d44:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
     d46:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
     d48:	80 91 6c 03 	lds	r24, 0x036C
     d4c:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
     d4e:	ce 01       	movw	r24, r28
     d50:	01 96       	adiw	r24, 0x01	; 1
     d52:	0e 94 92 05 	call	0xb24	; 0xb24 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
     d56:	83 e0       	ldi	r24, 0x03	; 3
     d58:	15 c0       	rjmp	.+42     	; 0xd84 <HandleIncomingMidiByte+0x196>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
     d5a:	80 93 6d 03 	sts	0x036D, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
     d5e:	88 e0       	ldi	r24, 0x08	; 8
     d60:	11 c0       	rjmp	.+34     	; 0xd84 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
     d62:	17 e0       	ldi	r17, 0x07	; 7
     d64:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
     d66:	80 91 6d 03 	lds	r24, 0x036D
     d6a:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
     d6c:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
     d6e:	80 91 6c 03 	lds	r24, 0x036C
     d72:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
     d74:	ce 01       	movw	r24, r28
     d76:	01 96       	adiw	r24, 0x01	; 1
     d78:	0e 94 92 05 	call	0xb24	; 0xb24 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
     d7c:	10 93 70 03 	sts	0x0370, r17
     d80:	03 c0       	rjmp	.+6      	; 0xd88 <HandleIncomingMidiByte+0x19a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
     d82:	89 e0       	ldi	r24, 0x09	; 9
     d84:	80 93 70 03 	sts	0x0370, r24
			break;
		}	
	}
}
     d88:	0f 90       	pop	r0
     d8a:	0f 90       	pop	r0
     d8c:	0f 90       	pop	r0
     d8e:	0f 90       	pop	r0
     d90:	cf 91       	pop	r28
     d92:	df 91       	pop	r29
     d94:	1f 91       	pop	r17
     d96:	08 95       	ret

00000d98 <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
     d98:	80 91 fd 03 	lds	r24, 0x03FD
     d9c:	88 23       	and	r24, r24
     d9e:	11 f0       	breq	.+4      	; 0xda4 <MidiTxBufferNotEmpty+0xc>
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	08 95       	ret
     da4:	80 91 73 03 	lds	r24, 0x0373
     da8:	81 11       	cpse	r24, r1
     daa:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
     dac:	08 95       	ret

00000dae <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
     dae:	80 91 73 03 	lds	r24, 0x0373
     db2:	83 30       	cpi	r24, 0x03	; 3
     db4:	09 f4       	brne	.+2      	; 0xdb8 <PopOutgoingMidiByte+0xa>
     db6:	91 c0       	rjmp	.+290    	; 0xeda <PopOutgoingMidiByte+0x12c>
     db8:	84 30       	cpi	r24, 0x04	; 4
     dba:	38 f4       	brcc	.+14     	; 0xdca <PopOutgoingMidiByte+0x1c>
     dbc:	81 30       	cpi	r24, 0x01	; 1
     dbe:	09 f4       	brne	.+2      	; 0xdc2 <PopOutgoingMidiByte+0x14>
     dc0:	88 c0       	rjmp	.+272    	; 0xed2 <PopOutgoingMidiByte+0x124>
     dc2:	82 30       	cpi	r24, 0x02	; 2
     dc4:	08 f0       	brcs	.+2      	; 0xdc8 <PopOutgoingMidiByte+0x1a>
     dc6:	87 c0       	rjmp	.+270    	; 0xed6 <PopOutgoingMidiByte+0x128>
     dc8:	0d c0       	rjmp	.+26     	; 0xde4 <PopOutgoingMidiByte+0x36>
     dca:	85 30       	cpi	r24, 0x05	; 5
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <PopOutgoingMidiByte+0x22>
     dce:	8c c0       	rjmp	.+280    	; 0xee8 <PopOutgoingMidiByte+0x13a>
     dd0:	85 30       	cpi	r24, 0x05	; 5
     dd2:	08 f4       	brcc	.+2      	; 0xdd6 <PopOutgoingMidiByte+0x28>
     dd4:	86 c0       	rjmp	.+268    	; 0xee2 <PopOutgoingMidiByte+0x134>
     dd6:	86 30       	cpi	r24, 0x06	; 6
     dd8:	09 f4       	brne	.+2      	; 0xddc <PopOutgoingMidiByte+0x2e>
     dda:	89 c0       	rjmp	.+274    	; 0xeee <PopOutgoingMidiByte+0x140>
     ddc:	87 30       	cpi	r24, 0x07	; 7
     dde:	09 f0       	breq	.+2      	; 0xde2 <PopOutgoingMidiByte+0x34>
     de0:	91 c0       	rjmp	.+290    	; 0xf04 <PopOutgoingMidiByte+0x156>
     de2:	8b c0       	rjmp	.+278    	; 0xefa <PopOutgoingMidiByte+0x14c>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
     de4:	20 91 fd 03 	lds	r18, 0x03FD
     de8:	22 23       	and	r18, r18
     dea:	39 f1       	breq	.+78     	; 0xe3a <PopOutgoingMidiByte+0x8c>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
     dec:	90 91 72 03 	lds	r25, 0x0372
     df0:	e9 2f       	mov	r30, r25
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	ee 0f       	add	r30, r30
     df6:	ff 1f       	adc	r31, r31
     df8:	ee 0f       	add	r30, r30
     dfa:	ff 1f       	adc	r31, r31
     dfc:	df 01       	movw	r26, r30
     dfe:	ac 51       	subi	r26, 0x1C	; 28
     e00:	bc 4f       	sbci	r27, 0xFC	; 252
     e02:	11 96       	adiw	r26, 0x01	; 1
     e04:	8c 91       	ld	r24, X
     e06:	11 97       	sbiw	r26, 0x01	; 1
     e08:	80 93 69 03 	sts	0x0369, r24
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
     e0c:	ea 51       	subi	r30, 0x1A	; 26
     e0e:	fc 4f       	sbci	r31, 0xFC	; 252
     e10:	80 81       	ld	r24, Z
     e12:	80 93 6a 03 	sts	0x036A, r24
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
     e16:	13 96       	adiw	r26, 0x03	; 3
     e18:	8c 91       	ld	r24, X
     e1a:	13 97       	sbiw	r26, 0x03	; 3
     e1c:	80 93 6b 03 	sts	0x036B, r24
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
     e20:	8c 91       	ld	r24, X
     e22:	80 93 68 03 	sts	0x0368, r24

		midiOutgoingFifoReadPointer++;										// read from the next element next time
     e26:	9f 5f       	subi	r25, 0xFF	; 255
     e28:	90 93 72 03 	sts	0x0372, r25
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
     e2c:	96 30       	cpi	r25, 0x06	; 6
     e2e:	10 f0       	brcs	.+4      	; 0xe34 <PopOutgoingMidiByte+0x86>
		{
			midiOutgoingFifoReadPointer=0;
     e30:	10 92 72 03 	sts	0x0372, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
     e34:	21 50       	subi	r18, 0x01	; 1
     e36:	20 93 fd 03 	sts	0x03FD, r18
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
     e3a:	20 91 69 03 	lds	r18, 0x0369
     e3e:	22 30       	cpi	r18, 0x02	; 2
     e40:	b9 f0       	breq	.+46     	; 0xe70 <PopOutgoingMidiByte+0xc2>
     e42:	23 30       	cpi	r18, 0x03	; 3
     e44:	20 f4       	brcc	.+8      	; 0xe4e <PopOutgoingMidiByte+0xa0>
     e46:	21 30       	cpi	r18, 0x01	; 1
     e48:	09 f0       	breq	.+2      	; 0xe4c <PopOutgoingMidiByte+0x9e>
     e4a:	5c c0       	rjmp	.+184    	; 0xf04 <PopOutgoingMidiByte+0x156>
     e4c:	06 c0       	rjmp	.+12     	; 0xe5a <PopOutgoingMidiByte+0xac>
     e4e:	23 30       	cpi	r18, 0x03	; 3
     e50:	f9 f0       	breq	.+62     	; 0xe90 <PopOutgoingMidiByte+0xe2>
     e52:	24 30       	cpi	r18, 0x04	; 4
     e54:	09 f0       	breq	.+2      	; 0xe58 <PopOutgoingMidiByte+0xaa>
     e56:	56 c0       	rjmp	.+172    	; 0xf04 <PopOutgoingMidiByte+0x156>
     e58:	2b c0       	rjmp	.+86     	; 0xeb0 <PopOutgoingMidiByte+0x102>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
     e5a:	90 91 68 03 	lds	r25, 0x0368
     e5e:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
     e60:	80 91 67 03 	lds	r24, 0x0367
     e64:	89 17       	cp	r24, r25
     e66:	79 f4       	brne	.+30     	; 0xe86 <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
     e68:	90 91 6a 03 	lds	r25, 0x036A
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	2a c0       	rjmp	.+84     	; 0xec4 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
     e70:	90 91 68 03 	lds	r25, 0x0368
     e74:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
     e76:	80 91 67 03 	lds	r24, 0x0367
     e7a:	89 17       	cp	r24, r25
     e7c:	21 f4       	brne	.+8      	; 0xe86 <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
     e7e:	90 91 6a 03 	lds	r25, 0x036A
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
     e82:	84 e0       	ldi	r24, 0x04	; 4
     e84:	1f c0       	rjmp	.+62     	; 0xec4 <PopOutgoingMidiByte+0x116>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
     e86:	90 93 67 03 	sts	0x0367, r25
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
     e8a:	20 93 73 03 	sts	0x0373, r18
     e8e:	3b c0       	rjmp	.+118    	; 0xf06 <PopOutgoingMidiByte+0x158>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
     e90:	90 91 68 03 	lds	r25, 0x0368
     e94:	90 6c       	ori	r25, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
     e96:	80 91 67 03 	lds	r24, 0x0367
     e9a:	89 17       	cp	r24, r25
     e9c:	29 f4       	brne	.+10     	; 0xea8 <PopOutgoingMidiByte+0xfa>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
     e9e:	90 91 6a 03 	lds	r25, 0x036A
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
     ea2:	10 92 73 03 	sts	0x0373, r1
     ea6:	2f c0       	rjmp	.+94     	; 0xf06 <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
     ea8:	90 93 67 03 	sts	0x0367, r25
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
     eac:	85 e0       	ldi	r24, 0x05	; 5
     eae:	0a c0       	rjmp	.+20     	; 0xec4 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
     eb0:	90 91 68 03 	lds	r25, 0x0368
     eb4:	90 6b       	ori	r25, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
     eb6:	80 91 67 03 	lds	r24, 0x0367
     eba:	89 17       	cp	r24, r25
     ebc:	31 f4       	brne	.+12     	; 0xeca <PopOutgoingMidiByte+0x11c>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
     ebe:	90 91 6a 03 	lds	r25, 0x036A
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
     ec2:	87 e0       	ldi	r24, 0x07	; 7
     ec4:	80 93 73 03 	sts	0x0373, r24
     ec8:	1e c0       	rjmp	.+60     	; 0xf06 <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
     eca:	90 93 67 03 	sts	0x0367, r25
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
     ece:	86 e0       	ldi	r24, 0x06	; 6
     ed0:	f9 cf       	rjmp	.-14     	; 0xec4 <PopOutgoingMidiByte+0x116>
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
     ed2:	83 e0       	ldi	r24, 0x03	; 3
     ed4:	0d c0       	rjmp	.+26     	; 0xef0 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
     ed6:	84 e0       	ldi	r24, 0x04	; 4
     ed8:	0b c0       	rjmp	.+22     	; 0xef0 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
     eda:	10 92 73 03 	sts	0x0373, r1
     ede:	90 e4       	ldi	r25, 0x40	; 64
     ee0:	12 c0       	rjmp	.+36     	; 0xf06 <PopOutgoingMidiByte+0x158>
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
     ee2:	10 92 73 03 	sts	0x0373, r1
     ee6:	0e c0       	rjmp	.+28     	; 0xf04 <PopOutgoingMidiByte+0x156>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
     ee8:	10 92 73 03 	sts	0x0373, r1
     eec:	03 c0       	rjmp	.+6      	; 0xef4 <PopOutgoingMidiByte+0x146>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
     eee:	87 e0       	ldi	r24, 0x07	; 7
     ef0:	80 93 73 03 	sts	0x0373, r24
		return(theMessage.dataByteOne);								// Return the first data byte.
     ef4:	90 91 6a 03 	lds	r25, 0x036A
     ef8:	06 c0       	rjmp	.+12     	; 0xf06 <PopOutgoingMidiByte+0x158>
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
     efa:	10 92 73 03 	sts	0x0373, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
     efe:	90 91 6b 03 	lds	r25, 0x036B
     f02:	01 c0       	rjmp	.+2      	; 0xf06 <PopOutgoingMidiByte+0x158>
     f04:	90 e0       	ldi	r25, 0x00	; 0

		default:
		return(0);
		break;
	}
}
     f06:	89 2f       	mov	r24, r25
     f08:	08 95       	ret

00000f0a <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
     f0a:	8a b1       	in	r24, 0x0a	; 10
     f0c:	8f 7c       	andi	r24, 0xCF	; 207
     f0e:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
     f10:	8b b1       	in	r24, 0x0b	; 11
     f12:	80 63       	ori	r24, 0x30	; 48
     f14:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
     f16:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
     f1a:	e4 e6       	ldi	r30, 0x64	; 100
     f1c:	f0 e0       	ldi	r31, 0x00	; 0
     f1e:	80 81       	ld	r24, Z
     f20:	80 61       	ori	r24, 0x10	; 16
     f22:	80 83       	st	Z, r24
}
     f24:	08 95       	ret

00000f26 <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
     f26:	e4 e6       	ldi	r30, 0x64	; 100
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	80 81       	ld	r24, Z
     f2c:	8f 7e       	andi	r24, 0xEF	; 239
     f2e:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
     f30:	ec ec       	ldi	r30, 0xCC	; 204
     f32:	f0 e0       	ldi	r31, 0x00	; 0
     f34:	11 82       	std	Z+1, r1	; 0x01
     f36:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
     f38:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
     f3a:	80 ec       	ldi	r24, 0xC0	; 192
     f3c:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
     f40:	88 e1       	ldi	r24, 0x18	; 24
     f42:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	91 83       	std	Z+1, r25	; 0x01
     f4c:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
     f4e:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS low.
     f50:	5d 9a       	sbi	0x0b, 5	; 11
}
     f52:	08 95       	ret

00000f54 <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
     f54:	5d 9a       	sbi	0x0b, 5	; 11
}
     f56:	08 95       	ret

00000f58 <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
     f58:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
     f5a:	5d 98       	cbi	0x0b, 5	; 11
}
     f5c:	08 95       	ret

00000f5e <TransferSdByte>:
// Slow and careful transfers; checks both send and receive buffers and waits until they're ready to move on.
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
     f5e:	98 2f       	mov	r25, r24
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
     f60:	80 91 c8 00 	lds	r24, 0x00C8
     f64:	85 ff       	sbrs	r24, 5
     f66:	fc cf       	rjmp	.-8      	; 0xf60 <TransferSdByte+0x2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
     f68:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
     f6c:	80 91 c8 00 	lds	r24, 0x00C8
     f70:	87 ff       	sbrs	r24, 7
     f72:	fc cf       	rjmp	.-8      	; 0xf6c <TransferSdByte+0xe>
		;

	return(UDR1);				// Return the data clocked in from the slave.
     f74:	80 91 ce 00 	lds	r24, 0x00CE
}
     f78:	08 95       	ret

00000f7a <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
     f7a:	80 91 c8 00 	lds	r24, 0x00C8
     f7e:	80 64       	ori	r24, 0x40	; 64
     f80:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
     f84:	80 91 c8 00 	lds	r24, 0x00C8
     f88:	85 ff       	sbrs	r24, 5
     f8a:	fc cf       	rjmp	.-8      	; 0xf84 <SendDummyByte+0xa>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
     f8c:	8f ef       	ldi	r24, 0xFF	; 255
     f8e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
     f92:	80 91 c8 00 	lds	r24, 0x00C8
     f96:	87 ff       	sbrs	r24, 7
     f98:	fc cf       	rjmp	.-8      	; 0xf92 <SendDummyByte+0x18>
		;

	return(UDR1);				// Return the data clocked in from the slave.
     f9a:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
     f9e:	80 91 c8 00 	lds	r24, 0x00C8
     fa2:	86 ff       	sbrs	r24, 6
     fa4:	fc cf       	rjmp	.-8      	; 0xf9e <SendDummyByte+0x24>
		;
}
     fa6:	08 95       	ret

00000fa8 <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
     fa8:	1f 93       	push	r17
     faa:	28 2f       	mov	r18, r24

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
     fac:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
     fae:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
     fb0:	80 91 c8 00 	lds	r24, 0x00C8
     fb4:	85 ff       	sbrs	r24, 5
     fb6:	fc cf       	rjmp	.-8      	; 0xfb0 <SendSdCommand+0x8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
     fb8:	8f ef       	ldi	r24, 0xFF	; 255
     fba:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
     fbe:	80 91 c8 00 	lds	r24, 0x00C8
     fc2:	87 ff       	sbrs	r24, 7
     fc4:	fc cf       	rjmp	.-8      	; 0xfbe <SendSdCommand+0x16>
		;

	return(UDR1);				// Return the data clocked in from the slave.
     fc6:	80 91 ce 00 	lds	r24, 0x00CE
		tmpCrc;

	StartSdTransfer();		// Assert CS
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
     fca:	27 ff       	sbrs	r18, 7
     fcc:	7a c0       	rjmp	.+244    	; 0x10c2 <SendSdCommand+0x11a>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
     fce:	80 91 c8 00 	lds	r24, 0x00C8
     fd2:	85 ff       	sbrs	r24, 5
     fd4:	fc cf       	rjmp	.-8      	; 0xfce <SendSdCommand+0x26>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
     fd6:	87 e7       	ldi	r24, 0x77	; 119
     fd8:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
     fdc:	80 91 c8 00 	lds	r24, 0x00C8
     fe0:	87 ff       	sbrs	r24, 7
     fe2:	fc cf       	rjmp	.-8      	; 0xfdc <SendSdCommand+0x34>
		;

	return(UDR1);				// Return the data clocked in from the slave.
     fe4:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
     fe8:	80 91 c8 00 	lds	r24, 0x00C8
     fec:	85 ff       	sbrs	r24, 5
     fee:	fc cf       	rjmp	.-8      	; 0xfe8 <SendSdCommand+0x40>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
     ff0:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
     ff4:	80 91 c8 00 	lds	r24, 0x00C8
     ff8:	87 ff       	sbrs	r24, 7
     ffa:	fc cf       	rjmp	.-8      	; 0xff4 <SendSdCommand+0x4c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
     ffc:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1000:	80 91 c8 00 	lds	r24, 0x00C8
    1004:	85 ff       	sbrs	r24, 5
    1006:	fc cf       	rjmp	.-8      	; 0x1000 <SendSdCommand+0x58>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1008:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    100c:	80 91 c8 00 	lds	r24, 0x00C8
    1010:	87 ff       	sbrs	r24, 7
    1012:	fc cf       	rjmp	.-8      	; 0x100c <SendSdCommand+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1014:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1018:	80 91 c8 00 	lds	r24, 0x00C8
    101c:	85 ff       	sbrs	r24, 5
    101e:	fc cf       	rjmp	.-8      	; 0x1018 <SendSdCommand+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1020:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1024:	80 91 c8 00 	lds	r24, 0x00C8
    1028:	87 ff       	sbrs	r24, 7
    102a:	fc cf       	rjmp	.-8      	; 0x1024 <SendSdCommand+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    102c:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1030:	80 91 c8 00 	lds	r24, 0x00C8
    1034:	85 ff       	sbrs	r24, 5
    1036:	fc cf       	rjmp	.-8      	; 0x1030 <SendSdCommand+0x88>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1038:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    103c:	80 91 c8 00 	lds	r24, 0x00C8
    1040:	87 ff       	sbrs	r24, 7
    1042:	fc cf       	rjmp	.-8      	; 0x103c <SendSdCommand+0x94>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1044:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1048:	80 91 c8 00 	lds	r24, 0x00C8
    104c:	85 ff       	sbrs	r24, 5
    104e:	fc cf       	rjmp	.-8      	; 0x1048 <SendSdCommand+0xa0>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1056:	80 91 c8 00 	lds	r24, 0x00C8
    105a:	87 ff       	sbrs	r24, 7
    105c:	fc cf       	rjmp	.-8      	; 0x1056 <SendSdCommand+0xae>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    105e:	80 91 ce 00 	lds	r24, 0x00CE
    1062:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1064:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1066:	80 91 c8 00 	lds	r24, 0x00C8
    106a:	85 ff       	sbrs	r24, 5
    106c:	fc cf       	rjmp	.-8      	; 0x1066 <SendSdCommand+0xbe>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    106e:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1072:	80 91 c8 00 	lds	r24, 0x00C8
    1076:	87 ff       	sbrs	r24, 7
    1078:	fc cf       	rjmp	.-8      	; 0x1072 <SendSdCommand+0xca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    107a:	10 91 ce 00 	lds	r17, 0x00CE
		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    107e:	1f 3f       	cpi	r17, 0xFF	; 255
    1080:	11 f4       	brne	.+4      	; 0x1086 <SendSdCommand+0xde>
    1082:	91 50       	subi	r25, 0x01	; 1
    1084:	81 f7       	brne	.-32     	; 0x1066 <SendSdCommand+0xbe>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    1086:	80 91 c8 00 	lds	r24, 0x00C8
    108a:	80 64       	ori	r24, 0x40	; 64
    108c:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1090:	80 91 c8 00 	lds	r24, 0x00C8
    1094:	85 ff       	sbrs	r24, 5
    1096:	fc cf       	rjmp	.-8      	; 0x1090 <SendSdCommand+0xe8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1098:	8f ef       	ldi	r24, 0xFF	; 255
    109a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    109e:	80 91 c8 00 	lds	r24, 0x00C8
    10a2:	87 ff       	sbrs	r24, 7
    10a4:	fc cf       	rjmp	.-8      	; 0x109e <SendSdCommand+0xf6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    10a6:	80 91 ce 00 	lds	r24, 0x00CE
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    10aa:	80 91 c8 00 	lds	r24, 0x00C8
    10ae:	86 ff       	sbrs	r24, 6
    10b0:	fc cf       	rjmp	.-8      	; 0x10aa <SendSdCommand+0x102>
			;

		if(response>1)				// Something wrong?
    10b2:	12 30       	cpi	r17, 0x02	; 2
    10b4:	10 f0       	brcs	.+4      	; 0x10ba <SendSdCommand+0x112>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    10b6:	5d 9a       	sbi	0x0b, 5	; 11
    10b8:	89 c0       	rjmp	.+274    	; 0x11cc <__stack+0xcd>
			EndSdTransfer();	// Bring CS high
			return(response);	// ACMD preambe returned something weird.  Bail.
		}

		EndSdTransfer();	// Bring CS high
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    10ba:	5d 9a       	sbi	0x0b, 5	; 11
    10bc:	2f 77       	andi	r18, 0x7F	; 127

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    10be:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    10c0:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    10c2:	80 91 c8 00 	lds	r24, 0x00C8
    10c6:	85 ff       	sbrs	r24, 5
    10c8:	fc cf       	rjmp	.-8      	; 0x10c2 <SendSdCommand+0x11a>
		StartSdTransfer();	// Assert CS
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    10ca:	82 2f       	mov	r24, r18
    10cc:	80 64       	ori	r24, 0x40	; 64
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    10ce:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    10d2:	80 91 c8 00 	lds	r24, 0x00C8
    10d6:	87 ff       	sbrs	r24, 7
    10d8:	fc cf       	rjmp	.-8      	; 0x10d2 <SendSdCommand+0x12a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    10da:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    10de:	80 91 c8 00 	lds	r24, 0x00C8
    10e2:	85 ff       	sbrs	r24, 5
    10e4:	fc cf       	rjmp	.-8      	; 0x10de <SendSdCommand+0x136>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    10e6:	87 2f       	mov	r24, r23
    10e8:	99 27       	eor	r25, r25
    10ea:	aa 27       	eor	r26, r26
    10ec:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    10ee:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    10f2:	80 91 c8 00 	lds	r24, 0x00C8
    10f6:	87 ff       	sbrs	r24, 7
    10f8:	fc cf       	rjmp	.-8      	; 0x10f2 <SendSdCommand+0x14a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    10fa:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    10fe:	80 91 c8 00 	lds	r24, 0x00C8
    1102:	85 ff       	sbrs	r24, 5
    1104:	fc cf       	rjmp	.-8      	; 0x10fe <SendSdCommand+0x156>

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    1106:	cb 01       	movw	r24, r22
    1108:	aa 27       	eor	r26, r26
    110a:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    110c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1110:	80 91 c8 00 	lds	r24, 0x00C8
    1114:	87 ff       	sbrs	r24, 7
    1116:	fc cf       	rjmp	.-8      	; 0x1110 <__stack+0x11>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1118:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    111c:	80 91 c8 00 	lds	r24, 0x00C8
    1120:	85 ff       	sbrs	r24, 5
    1122:	fc cf       	rjmp	.-8      	; 0x111c <__stack+0x1d>
	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    1124:	bb 27       	eor	r27, r27
    1126:	a7 2f       	mov	r26, r23
    1128:	96 2f       	mov	r25, r22
    112a:	85 2f       	mov	r24, r21
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    112c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1130:	80 91 c8 00 	lds	r24, 0x00C8
    1134:	87 ff       	sbrs	r24, 7
    1136:	fc cf       	rjmp	.-8      	; 0x1130 <__stack+0x31>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1138:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    113c:	80 91 c8 00 	lds	r24, 0x00C8
    1140:	85 ff       	sbrs	r24, 5
    1142:	fc cf       	rjmp	.-8      	; 0x113c <__stack+0x3d>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1144:	40 93 ce 00 	sts	0x00CE, r20

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1148:	80 91 c8 00 	lds	r24, 0x00C8
    114c:	87 ff       	sbrs	r24, 7
    114e:	fc cf       	rjmp	.-8      	; 0x1148 <__stack+0x49>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1150:	80 91 ce 00 	lds	r24, 0x00CE
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    1154:	22 23       	and	r18, r18
    1156:	11 f4       	brne	.+4      	; 0x115c <__stack+0x5d>
    1158:	95 e9       	ldi	r25, 0x95	; 149
    115a:	05 c0       	rjmp	.+10     	; 0x1166 <__stack+0x67>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    115c:	28 30       	cpi	r18, 0x08	; 8
    115e:	11 f4       	brne	.+4      	; 0x1164 <__stack+0x65>
    1160:	97 e8       	ldi	r25, 0x87	; 135
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <__stack+0x67>
    1164:	91 e0       	ldi	r25, 0x01	; 1
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1166:	80 91 c8 00 	lds	r24, 0x00C8
    116a:	85 ff       	sbrs	r24, 5
    116c:	fc cf       	rjmp	.-8      	; 0x1166 <__stack+0x67>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    116e:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1172:	80 91 c8 00 	lds	r24, 0x00C8
    1176:	87 ff       	sbrs	r24, 7
    1178:	fc cf       	rjmp	.-8      	; 0x1172 <__stack+0x73>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    117a:	80 91 ce 00 	lds	r24, 0x00CE
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    117e:	2c 30       	cpi	r18, 0x0C	; 12
    1180:	69 f4       	brne	.+26     	; 0x119c <__stack+0x9d>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1182:	80 91 c8 00 	lds	r24, 0x00C8
    1186:	85 ff       	sbrs	r24, 5
    1188:	fc cf       	rjmp	.-8      	; 0x1182 <__stack+0x83>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    118a:	8f ef       	ldi	r24, 0xFF	; 255
    118c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1190:	80 91 c8 00 	lds	r24, 0x00C8
    1194:	87 ff       	sbrs	r24, 7
    1196:	fc cf       	rjmp	.-8      	; 0x1190 <__stack+0x91>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1198:	80 91 ce 00 	lds	r24, 0x00CE
    119c:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    119e:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    11a0:	80 91 c8 00 	lds	r24, 0x00C8
    11a4:	85 ff       	sbrs	r24, 5
    11a6:	fc cf       	rjmp	.-8      	; 0x11a0 <__stack+0xa1>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    11a8:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    11ac:	80 91 c8 00 	lds	r24, 0x00C8
    11b0:	87 ff       	sbrs	r24, 7
    11b2:	fc cf       	rjmp	.-8      	; 0x11ac <__stack+0xad>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    11b4:	10 91 ce 00 	lds	r17, 0x00CE
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    11b8:	1f 3f       	cpi	r17, 0xFF	; 255
    11ba:	11 f4       	brne	.+4      	; 0x11c0 <__stack+0xc1>
    11bc:	91 50       	subi	r25, 0x01	; 1
    11be:	81 f7       	brne	.-32     	; 0x11a0 <__stack+0xa1>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    11c0:	28 30       	cpi	r18, 0x08	; 8
    11c2:	21 f0       	breq	.+8      	; 0x11cc <__stack+0xcd>
    11c4:	2a 33       	cpi	r18, 0x3A	; 58
    11c6:	11 f0       	breq	.+4      	; 0x11cc <__stack+0xcd>
	{
		SendDummyByte();	
    11c8:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    11cc:	81 2f       	mov	r24, r17
    11ce:	1f 91       	pop	r17
    11d0:	08 95       	ret

000011d2 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    11d2:	ab 01       	movw	r20, r22
    11d4:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    11d6:	e9 e0       	ldi	r30, 0x09	; 9
    11d8:	44 0f       	add	r20, r20
    11da:	55 1f       	adc	r21, r21
    11dc:	66 1f       	adc	r22, r22
    11de:	77 1f       	adc	r23, r23
    11e0:	ea 95       	dec	r30
    11e2:	d1 f7       	brne	.-12     	; 0x11d8 <SdBeginSingleBlockRead+0x6>
    11e4:	81 e1       	ldi	r24, 0x11	; 17
    11e6:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	88 23       	and	r24, r24
    11ee:	09 f4       	brne	.+2      	; 0x11f2 <SdBeginSingleBlockRead+0x20>
    11f0:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    11f2:	89 2f       	mov	r24, r25
    11f4:	08 95       	ret

000011f6 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    11f6:	ab 01       	movw	r20, r22
    11f8:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    11fa:	f9 e0       	ldi	r31, 0x09	; 9
    11fc:	44 0f       	add	r20, r20
    11fe:	55 1f       	adc	r21, r21
    1200:	66 1f       	adc	r22, r22
    1202:	77 1f       	adc	r23, r23
    1204:	fa 95       	dec	r31
    1206:	d1 f7       	brne	.-12     	; 0x11fc <SdBeginSingleBlockWrite+0x6>
    1208:	88 e1       	ldi	r24, 0x18	; 24
    120a:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	88 23       	and	r24, r24
    1212:	09 f4       	brne	.+2      	; 0x1216 <SdBeginSingleBlockWrite+0x20>
    1214:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    1216:	89 2f       	mov	r24, r25
    1218:	08 95       	ret

0000121a <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    121a:	df 93       	push	r29
    121c:	cf 93       	push	r28
    121e:	00 d0       	rcall	.+0      	; 0x1220 <SdHandshake+0x6>
    1220:	00 d0       	rcall	.+0      	; 0x1222 <SdHandshake+0x8>
    1222:	cd b7       	in	r28, 0x3d	; 61
    1224:	de b7       	in	r29, 0x3e	; 62
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    1226:	5d 9a       	sbi	0x0b, 5	; 11
    1228:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    122a:	2f ef       	ldi	r18, 0xFF	; 255
	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    122c:	80 91 c8 00 	lds	r24, 0x00C8
    1230:	80 64       	ori	r24, 0x40	; 64
    1232:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1236:	80 91 c8 00 	lds	r24, 0x00C8
    123a:	85 ff       	sbrs	r24, 5
    123c:	fc cf       	rjmp	.-8      	; 0x1236 <SdHandshake+0x1c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    123e:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    1242:	80 91 c8 00 	lds	r24, 0x00C8
    1246:	87 ff       	sbrs	r24, 7
    1248:	fc cf       	rjmp	.-8      	; 0x1242 <SdHandshake+0x28>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    124a:	80 91 ce 00 	lds	r24, 0x00CE
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    124e:	9f 5f       	subi	r25, 0xFF	; 255
    1250:	94 31       	cpi	r25, 0x14	; 20
    1252:	61 f7       	brne	.-40     	; 0x122c <SdHandshake+0x12>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    1254:	80 91 c8 00 	lds	r24, 0x00C8
    1258:	86 ff       	sbrs	r24, 6
    125a:	fc cf       	rjmp	.-8      	; 0x1254 <SdHandshake+0x3a>

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    125c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    125e:	5d 98       	cbi	0x0b, 5	; 11
    1260:	20 e0       	ldi	r18, 0x00	; 0
    1262:	30 e0       	ldi	r19, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1264:	9f ef       	ldi	r25, 0xFF	; 255
	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    1266:	80 91 c8 00 	lds	r24, 0x00C8
    126a:	80 64       	ori	r24, 0x40	; 64
    126c:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1270:	80 91 c8 00 	lds	r24, 0x00C8
    1274:	85 ff       	sbrs	r24, 5
    1276:	fc cf       	rjmp	.-8      	; 0x1270 <SdHandshake+0x56>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1278:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    127c:	80 91 c8 00 	lds	r24, 0x00C8
    1280:	87 ff       	sbrs	r24, 7
    1282:	fc cf       	rjmp	.-8      	; 0x127c <SdHandshake+0x62>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1284:	80 91 ce 00 	lds	r24, 0x00CE


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    1288:	2f 5f       	subi	r18, 0xFF	; 255
    128a:	3f 4f       	sbci	r19, 0xFF	; 255
    128c:	82 e0       	ldi	r24, 0x02	; 2
    128e:	20 30       	cpi	r18, 0x00	; 0
    1290:	38 07       	cpc	r19, r24
    1292:	49 f7       	brne	.-46     	; 0x1266 <SdHandshake+0x4c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    1294:	80 91 c8 00 	lds	r24, 0x00C8
    1298:	86 ff       	sbrs	r24, 6
    129a:	fc cf       	rjmp	.-8      	; 0x1294 <SdHandshake+0x7a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    129c:	5d 9a       	sbi	0x0b, 5	; 11
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	40 e0       	ldi	r20, 0x00	; 0
    12a2:	50 e0       	ldi	r21, 0x00	; 0
    12a4:	60 e0       	ldi	r22, 0x00	; 0
    12a6:	70 e0       	ldi	r23, 0x00	; 0
    12a8:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    12ac:	80 91 c8 00 	lds	r24, 0x00C8
    12b0:	86 ff       	sbrs	r24, 6
    12b2:	fc cf       	rjmp	.-8      	; 0x12ac <SdHandshake+0x92>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    12b4:	5d 9a       	sbi	0x0b, 5	; 11
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	40 e0       	ldi	r20, 0x00	; 0
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	60 e0       	ldi	r22, 0x00	; 0
    12be:	70 e0       	ldi	r23, 0x00	; 0
    12c0:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    12c4:	81 30       	cpi	r24, 0x01	; 1
    12c6:	09 f0       	breq	.+2      	; 0x12ca <SdHandshake+0xb0>
    12c8:	b4 c0       	rjmp	.+360    	; 0x1432 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    12ca:	5d 9a       	sbi	0x0b, 5	; 11
	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    12cc:	88 e0       	ldi	r24, 0x08	; 8
    12ce:	4a ea       	ldi	r20, 0xAA	; 170
    12d0:	51 e0       	ldi	r21, 0x01	; 1
    12d2:	60 e0       	ldi	r22, 0x00	; 0
    12d4:	70 e0       	ldi	r23, 0x00	; 0
    12d6:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    12da:	81 30       	cpi	r24, 0x01	; 1
    12dc:	09 f0       	breq	.+2      	; 0x12e0 <SdHandshake+0xc6>
    12de:	76 c0       	rjmp	.+236    	; 0x13cc <SdHandshake+0x1b2>
    12e0:	fe 01       	movw	r30, r28
    12e2:	31 96       	adiw	r30, 0x01	; 1
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    12e4:	9f ef       	ldi	r25, 0xFF	; 255
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    12e6:	9e 01       	movw	r18, r28
    12e8:	2b 5f       	subi	r18, 0xFB	; 251
    12ea:	3f 4f       	sbci	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    12ec:	80 91 c8 00 	lds	r24, 0x00C8
    12f0:	85 ff       	sbrs	r24, 5
    12f2:	fc cf       	rjmp	.-8      	; 0x12ec <SdHandshake+0xd2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    12f4:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    12f8:	80 91 c8 00 	lds	r24, 0x00C8
    12fc:	87 ff       	sbrs	r24, 7
    12fe:	fc cf       	rjmp	.-8      	; 0x12f8 <SdHandshake+0xde>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    1300:	80 91 ce 00 	lds	r24, 0x00CE

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    1304:	81 93       	st	Z+, r24
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    1306:	e2 17       	cp	r30, r18
    1308:	f3 07       	cpc	r31, r19
    130a:	81 f7       	brne	.-32     	; 0x12ec <SdHandshake+0xd2>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    130c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    1310:	5d 9a       	sbi	0x0b, 5	; 11
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
			EndSdTransfer();		// Bring CS high

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    1312:	8b 81       	ldd	r24, Y+3	; 0x03
    1314:	81 30       	cpi	r24, 0x01	; 1
    1316:	09 f0       	breq	.+2      	; 0x131a <SdHandshake+0x100>
    1318:	8c c0       	rjmp	.+280    	; 0x1432 <SdHandshake+0x218>
    131a:	8c 81       	ldd	r24, Y+4	; 0x04
    131c:	8a 3a       	cpi	r24, 0xAA	; 170
    131e:	09 f0       	breq	.+2      	; 0x1322 <SdHandshake+0x108>
    1320:	88 c0       	rjmp	.+272    	; 0x1432 <SdHandshake+0x218>
			{				
				SetTimer(TIMER_SD,SECOND);
    1322:	83 e0       	ldi	r24, 0x03	; 3
    1324:	64 ec       	ldi	r22, 0xC4	; 196
    1326:	74 e0       	ldi	r23, 0x04	; 4
    1328:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
    132c:	03 c0       	rjmp	.+6      	; 0x1334 <SdHandshake+0x11a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    132e:	5d 9a       	sbi	0x0b, 5	; 11
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
    1330:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    1334:	83 e0       	ldi	r24, 0x03	; 3
    1336:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    133a:	88 23       	and	r24, r24
    133c:	49 f4       	brne	.+18     	; 0x1350 <SdHandshake+0x136>
    133e:	89 ea       	ldi	r24, 0xA9	; 169
    1340:	40 e0       	ldi	r20, 0x00	; 0
    1342:	50 e0       	ldi	r21, 0x00	; 0
    1344:	60 e0       	ldi	r22, 0x00	; 0
    1346:	70 e0       	ldi	r23, 0x00	; 0
    1348:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    134c:	88 23       	and	r24, r24
    134e:	79 f7       	brne	.-34     	; 0x132e <SdHandshake+0x114>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    1350:	83 e0       	ldi	r24, 0x03	; 3
    1352:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    1356:	88 23       	and	r24, r24
    1358:	31 f0       	breq	.+12     	; 0x1366 <SdHandshake+0x14c>
    135a:	6b c0       	rjmp	.+214    	; 0x1432 <SdHandshake+0x218>
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    135c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    1360:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    1364:	5d 9a       	sbi	0x0b, 5	; 11
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    1366:	83 e0       	ldi	r24, 0x03	; 3
    1368:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    136c:	88 23       	and	r24, r24
    136e:	49 f4       	brne	.+18     	; 0x1382 <SdHandshake+0x168>
    1370:	8a e3       	ldi	r24, 0x3A	; 58
    1372:	40 e0       	ldi	r20, 0x00	; 0
    1374:	50 e0       	ldi	r21, 0x00	; 0
    1376:	60 e0       	ldi	r22, 0x00	; 0
    1378:	70 e0       	ldi	r23, 0x00	; 0
    137a:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    137e:	88 23       	and	r24, r24
    1380:	69 f7       	brne	.-38     	; 0x135c <SdHandshake+0x142>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    1382:	83 e0       	ldi	r24, 0x03	; 3
    1384:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    1388:	88 23       	and	r24, r24
    138a:	09 f0       	breq	.+2      	; 0x138e <SdHandshake+0x174>
    138c:	52 c0       	rjmp	.+164    	; 0x1432 <SdHandshake+0x218>
    138e:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    1390:	2f ef       	ldi	r18, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    1392:	80 91 c8 00 	lds	r24, 0x00C8
    1396:	85 ff       	sbrs	r24, 5
    1398:	fc cf       	rjmp	.-8      	; 0x1392 <SdHandshake+0x178>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    139a:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    139e:	80 91 c8 00 	lds	r24, 0x00C8
    13a2:	87 ff       	sbrs	r24, 7
    13a4:	fc cf       	rjmp	.-8      	; 0x139e <SdHandshake+0x184>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    13a6:	80 91 ce 00 	lds	r24, 0x00CE
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
    13aa:	9f 5f       	subi	r25, 0xFF	; 255
    13ac:	94 30       	cpi	r25, 0x04	; 4
    13ae:	89 f7       	brne	.-30     	; 0x1392 <SdHandshake+0x178>
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    13b0:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    13b4:	5d 9a       	sbi	0x0b, 5	; 11
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    13b6:	80 e1       	ldi	r24, 0x10	; 16
    13b8:	40 e0       	ldi	r20, 0x00	; 0
    13ba:	52 e0       	ldi	r21, 0x02	; 2
    13bc:	60 e0       	ldi	r22, 0x00	; 0
    13be:	70 e0       	ldi	r23, 0x00	; 0
    13c0:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    13c4:	5d 9a       	sbi	0x0b, 5	; 11
						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
						EndSdTransfer();						// Bring CS high.
						SendDummyByte();						
    13c6:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
    13ca:	31 c0       	rjmp	.+98     	; 0x142e <SdHandshake+0x214>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    13cc:	0e 94 bd 07 	call	0xf7a	; 0xf7a <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    13d0:	5d 9a       	sbi	0x0b, 5	; 11
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    13d2:	89 ea       	ldi	r24, 0xA9	; 169
    13d4:	40 e0       	ldi	r20, 0x00	; 0
    13d6:	50 e0       	ldi	r21, 0x00	; 0
    13d8:	60 e0       	ldi	r22, 0x00	; 0
    13da:	70 e0       	ldi	r23, 0x00	; 0
    13dc:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    13e0:	82 30       	cpi	r24, 0x02	; 2
    13e2:	38 f5       	brcc	.+78     	; 0x1432 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    13e4:	5d 9a       	sbi	0x0b, 5	; 11
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);
    13e6:	83 e0       	ldi	r24, 0x03	; 3
    13e8:	64 ec       	ldi	r22, 0xC4	; 196
    13ea:	74 e0       	ldi	r23, 0x04	; 4
    13ec:	0e 94 39 05 	call	0xa72	; 0xa72 <SetTimer>
    13f0:	03 c0       	rjmp	.+6      	; 0x13f8 <SdHandshake+0x1de>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
				{
					HandleSoftclock();	// Keep the timer timing.
    13f2:	0e 94 ef 01 	call	0x3de	; 0x3de <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    13f6:	5d 9a       	sbi	0x0b, 5	; 11
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    13f8:	83 e0       	ldi	r24, 0x03	; 3
    13fa:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    13fe:	88 23       	and	r24, r24
    1400:	49 f4       	brne	.+18     	; 0x1414 <SdHandshake+0x1fa>
    1402:	89 ea       	ldi	r24, 0xA9	; 169
    1404:	40 e0       	ldi	r20, 0x00	; 0
    1406:	50 e0       	ldi	r21, 0x00	; 0
    1408:	60 e0       	ldi	r22, 0x00	; 0
    140a:	70 e0       	ldi	r23, 0x00	; 0
    140c:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
    1410:	88 23       	and	r24, r24
    1412:	79 f7       	brne	.-34     	; 0x13f2 <SdHandshake+0x1d8>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    1414:	83 e0       	ldi	r24, 0x03	; 3
    1416:	0e 94 4b 05 	call	0xa96	; 0xa96 <CheckTimer>
    141a:	88 23       	and	r24, r24
    141c:	51 f4       	brne	.+20     	; 0x1432 <SdHandshake+0x218>
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    141e:	80 e1       	ldi	r24, 0x10	; 16
    1420:	40 e0       	ldi	r20, 0x00	; 0
    1422:	52 e0       	ldi	r21, 0x02	; 2
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	70 e0       	ldi	r23, 0x00	; 0
    1428:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    142c:	5d 9a       	sbi	0x0b, 5	; 11
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	01 c0       	rjmp	.+2      	; 0x1434 <SdHandshake+0x21a>
    1432:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	EndSdTransfer();	// Bring CS high
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    1434:	5d 9a       	sbi	0x0b, 5	; 11
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	cf 91       	pop	r28
    1440:	df 91       	pop	r29
    1442:	08 95       	ret

00001444 <_exit>:
    1444:	f8 94       	cli

00001446 <__stop_program>:
    1446:	ff cf       	rjmp	.-2      	; 0x1446 <__stop_program>
