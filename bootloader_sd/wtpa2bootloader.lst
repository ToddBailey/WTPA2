   1               		.file	"wtpa2bootloader.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	SetLeds:
  12               	.LFB4:
  13               		.file 1 "wtpa2bootloader.c"
   1:wtpa2bootloader.c **** // Bootloader Code for WTPA2
   2:wtpa2bootloader.c **** // Sat Apr 28 13:08:26 EDT 2012
   3:wtpa2bootloader.c **** 
   4:wtpa2bootloader.c **** // This code handles loading firmware off a micro SD card and into the application area of a WTPA2.
   5:wtpa2bootloader.c **** // For this to work, the data on the micro SD card must be formatted correctly.
   6:wtpa2bootloader.c **** 
   7:wtpa2bootloader.c **** // On power-up, WTPA2 checks first to see if the user is hitting a special button combo.  If so, it
   8:wtpa2bootloader.c **** // Once it is done, or if any of the tests are invalid, the code will vector to the start of the ap
   9:wtpa2bootloader.c **** 
  10:wtpa2bootloader.c **** // NOTE:
  11:wtpa2bootloader.c **** // For this to work right, lots of things must be done, and some things ought to be done.
  12:wtpa2bootloader.c **** // This code must be programmed into bootloader space on the AVR.
  13:wtpa2bootloader.c **** // Bootloader space bits and lock bits in the fuses must be set correctly (we ought not let the boo
  14:wtpa2bootloader.c **** // This means we must vector to the right place on startup.
  15:wtpa2bootloader.c **** // Address values are specific to the particular AVR processor we're using -- IE, the Atmega644a ha
  16:wtpa2bootloader.c **** // For reference, the application code always starts at address 0.
  17:wtpa2bootloader.c **** // Also, the page sizes are different for different AVR parts.
  18:wtpa2bootloader.c **** 
  19:wtpa2bootloader.c **** // The above also implies that you have to monkey with the Makefile (or linker) to to stick this co
  20:wtpa2bootloader.c **** // Also, programming the application via ISP can overwrite the bootloader, so when programming the 
  21:wtpa2bootloader.c **** // Lastly, the application data (and NOT the bootloader) must be sent when bootloading off an SD ca
  22:wtpa2bootloader.c **** 
  23:wtpa2bootloader.c **** // -------------------------
  24:wtpa2bootloader.c **** // -------------------------
  25:wtpa2bootloader.c **** // Bootloader Data Format:
  26:wtpa2bootloader.c **** // -------------------------
  27:wtpa2bootloader.c **** // -------------------------
  28:wtpa2bootloader.c **** // Header:
  29:wtpa2bootloader.c **** // -------
  30:wtpa2bootloader.c **** // The first block of the SDcard contains flags, data bytes, and checksums.
  31:wtpa2bootloader.c **** // The first 8 characters on the card must be ascii WTPABOOT
  32:wtpa2bootloader.c **** // The next 4 characters are the byte count of the databytes following (big endian byte order)
  33:wtpa2bootloader.c **** // The next two are 16-bit "Xmodem syle" CRC for the length AND databytes (but not WTPABOOT) -- the
  34:wtpa2bootloader.c **** 
  35:wtpa2bootloader.c **** // Data:
  36:wtpa2bootloader.c **** // -------
  37:wtpa2bootloader.c **** // The data is the BINARY image that should go onto the chip.  Since this application always starts
  38:wtpa2bootloader.c **** // We would get better error checking with a hex file, but we would need to screw around a lot with
  39:wtpa2bootloader.c **** 
  40:wtpa2bootloader.c **** // NOTES:
  41:wtpa2bootloader.c **** // The bootloader programs in PAGES.  The SD card stores in BLOCKS.  On the 644a, page size is 128 
  42:wtpa2bootloader.c **** // To keep the SD card happy, we must read in 512 byte blocks.
  43:wtpa2bootloader.c **** // Also, since we write pages at a time, but there's no guarantee our application code will be mult
  44:wtpa2bootloader.c **** // It may be useful to handle that in a "classy" way by sticking 0xBEEF in the remainder of the pag
  45:wtpa2bootloader.c **** // If the bootloader is LESS THAN 4k, it makes it possible for the application to get into the NRRW
  46:wtpa2bootloader.c **** 
  47:wtpa2bootloader.c **** // NOTE:
  48:wtpa2bootloader.c **** // THE PAGE SIZE (IN BYTES NOT WORDS) OF THE AVR TO BE BOOTLOADED MUST BE:
  49:wtpa2bootloader.c **** // a.) Less than an SD block size (512 bytes)
  50:wtpa2bootloader.c **** // b.) Must multiply cleanly into 512.
  51:wtpa2bootloader.c **** // The 644p has a page size of 128 words (256 bytes) so this is fine here.
  52:wtpa2bootloader.c **** 
  53:wtpa2bootloader.c **** // @@@ really ought to combine common code with application once we're done testing.  That means mi
  54:wtpa2bootloader.c **** // @@@ Right now, our software timers are only needed by microsd.c -- if we eliminate those, we can
  55:wtpa2bootloader.c **** 
  56:wtpa2bootloader.c **** #include "includes.h"
  57:wtpa2bootloader.c **** 
  58:wtpa2bootloader.c **** #define	LATCH_PORT		PORTB		// This is the all-purpose byte-wide data port we use to write data to t
  59:wtpa2bootloader.c **** #define	LATCH_DDR		DDRB		// Its associated DDR.
  60:wtpa2bootloader.c **** 
  61:wtpa2bootloader.c **** static const unsigned char
  62:wtpa2bootloader.c **** 	bootHeader[]={'W','T','P','A','B','O','O','T'};
  63:wtpa2bootloader.c **** static unsigned int
  64:wtpa2bootloader.c **** 	bootCrc;
  65:wtpa2bootloader.c **** static unsigned long
  66:wtpa2bootloader.c **** 	bootDataLength;
  67:wtpa2bootloader.c **** 
  68:wtpa2bootloader.c **** static unsigned char
  69:wtpa2bootloader.c **** 	bootBuffer[SD_BLOCK_LENGTH];	// Holds the block we got from the SD card before we put it in flash
  70:wtpa2bootloader.c **** 
  71:wtpa2bootloader.c **** volatile unsigned int	// This counter keeps track of software timing ticks and is referenced by the
  72:wtpa2bootloader.c **** 	systemTicks;
  73:wtpa2bootloader.c **** 
  74:wtpa2bootloader.c **** // Local Softclock Stuff
  75:wtpa2bootloader.c **** // ------------------------------------------------------------
  76:wtpa2bootloader.c **** // ------------------------------------------------------------
  77:wtpa2bootloader.c **** static void UnInitSoftclock(void)
  78:wtpa2bootloader.c **** {
  79:wtpa2bootloader.c **** 	TCCR0B=0;			// Stop the timer
  80:wtpa2bootloader.c **** 	PRR|=(1<<PRTIM0);	// Turn the TMR0 power off.
  81:wtpa2bootloader.c **** }
  82:wtpa2bootloader.c **** 
  83:wtpa2bootloader.c **** static void InitSoftclock(void)
  84:wtpa2bootloader.c **** // Wed Dec  3 22:28:06 CST 2008
  85:wtpa2bootloader.c **** // I've changed the way the softclock works from the last rev.  It's no longer and interrupt based 
  86:wtpa2bootloader.c **** // Also, since hardware TIMR1 is needed for bigger and better things than keeping human-time, we're
  87:wtpa2bootloader.c **** // This means we don't steal cycles from any other ISRs, but it also means that if we write dumb co
  88:wtpa2bootloader.c **** // we might miss a systemTick.
  89:wtpa2bootloader.c **** // NOTE:  w/ TMR0 running at 1/256 prescale at 20MHz, our smallest time unit is 3.2768mSecs.
  90:wtpa2bootloader.c **** // NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.
  91:wtpa2bootloader.c **** 
  92:wtpa2bootloader.c **** // With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing e
  93:wtpa2bootloader.c **** 
  94:wtpa2bootloader.c **** {
  95:wtpa2bootloader.c **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
  96:wtpa2bootloader.c **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
  97:wtpa2bootloader.c **** 	TCCR0A=0;			// Normal Ports.
  98:wtpa2bootloader.c **** 	TCNT0=0;			// Initialize the counter to 0.
  99:wtpa2bootloader.c **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 100:wtpa2bootloader.c **** 	systemTicks=0;
 101:wtpa2bootloader.c **** //	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
 102:wtpa2bootloader.c **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 103:wtpa2bootloader.c **** }
 104:wtpa2bootloader.c **** 
 105:wtpa2bootloader.c **** void HandleSoftclock(void)
 106:wtpa2bootloader.c **** {
 107:wtpa2bootloader.c **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 108:wtpa2bootloader.c **** 	{
 109:wtpa2bootloader.c **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 110:wtpa2bootloader.c **** 		systemTicks++;			// Increment the system ticks.
 111:wtpa2bootloader.c **** 	}
 112:wtpa2bootloader.c **** }
 113:wtpa2bootloader.c **** 
 114:wtpa2bootloader.c **** // ------------------------------------------------------------
 115:wtpa2bootloader.c **** // ------------------------------------------------------------
 116:wtpa2bootloader.c **** 
 117:wtpa2bootloader.c **** static bool CheckBootButtonsPressed(void)
 118:wtpa2bootloader.c **** // Read inputs and make sure user is pressing the keys necessary to command a bootload.
 119:wtpa2bootloader.c **** {
 120:wtpa2bootloader.c **** 	unsigned char
 121:wtpa2bootloader.c **** 		keyState;
 122:wtpa2bootloader.c **** 
 123:wtpa2bootloader.c **** 	LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 124:wtpa2bootloader.c **** 	LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 125:wtpa2bootloader.c **** 	PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 126:wtpa2bootloader.c **** 	asm volatile("nop"::);		// Needed for bus turnaround time (2 nops min)
 127:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 128:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 129:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 130:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 131:wtpa2bootloader.c **** 	asm volatile("nop"::);
 132:wtpa2bootloader.c **** 	keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 133:wtpa2bootloader.c **** 	PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 134:wtpa2bootloader.c **** 	LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 135:wtpa2bootloader.c **** 
 136:wtpa2bootloader.c **** 	if((keyState&(1<<7))&&(keyState&(1<<0)))
 137:wtpa2bootloader.c **** 	{
 138:wtpa2bootloader.c **** 		return(true);
 139:wtpa2bootloader.c **** 	}
 140:wtpa2bootloader.c **** 	return(false);
 141:wtpa2bootloader.c **** }
 142:wtpa2bootloader.c **** 
 143:wtpa2bootloader.c **** static void SetLeds(unsigned char mask)
 144:wtpa2bootloader.c **** // Puts the passed mask onto the LEDs.  Used to show bootloader progress.
 145:wtpa2bootloader.c **** {
  14               		.loc 1 145 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 146:wtpa2bootloader.c **** 	LATCH_PORT=mask;				// Put passed data onto bus.
  21               		.loc 1 146 0
  22 0000 85B9      		out 0x5,r24
 147:wtpa2bootloader.c **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
  23               		.loc 1 147 0
  24 0002 8FEF      		ldi r24,lo8(-1)
  25               	.LVL1:
  26 0004 84B9      		out 0x4,r24
 148:wtpa2bootloader.c **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
  27               		.loc 1 148 0
  28 0006 5F9A      		sbi 0xb,7
 149:wtpa2bootloader.c **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.	
  29               		.loc 1 149 0
  30 0008 5F98      		cbi 0xb,7
  31 000a 0895      		ret
  32               		.cfi_endproc
  33               	.LFE4:
  35               		.section	.text.unlikely,"ax",@progbits
  37               	UpdateCrc:
  38               	.LFB7:
 150:wtpa2bootloader.c **** }
 151:wtpa2bootloader.c **** 
 152:wtpa2bootloader.c **** // ------------------------------------------------------------
 153:wtpa2bootloader.c **** // ------------------------------------------------------------
 154:wtpa2bootloader.c **** 
 155:wtpa2bootloader.c **** 
 156:wtpa2bootloader.c **** static bool GetSdBlock(unsigned int blockAddress, unsigned char *data)
 157:wtpa2bootloader.c **** // Reads the block at the passed address into the passed array of bytes.
 158:wtpa2bootloader.c **** // Returns false if the operation times out.
 159:wtpa2bootloader.c **** {
 160:wtpa2bootloader.c **** 	bool
 161:wtpa2bootloader.c **** 		success;
 162:wtpa2bootloader.c **** 	unsigned int
 163:wtpa2bootloader.c **** 		startTime,
 164:wtpa2bootloader.c **** 		i;
 165:wtpa2bootloader.c **** 	
 166:wtpa2bootloader.c **** 	success=true;		// Everything is OK so far
 167:wtpa2bootloader.c **** 
 168:wtpa2bootloader.c **** 	if(SdBeginSingleBlockRead(blockAddress)==true)		// Start reading at block...
 169:wtpa2bootloader.c **** 	{
 170:wtpa2bootloader.c **** 		// Wait for a data packet from the card.
 171:wtpa2bootloader.c **** 		startTime=systemTicks;		
 172:wtpa2bootloader.c **** 
 173:wtpa2bootloader.c **** 		while((systemTicks<(startTime+(SECOND/10)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the 
 174:wtpa2bootloader.c **** 		{
 175:wtpa2bootloader.c **** 			HandleSoftclock();	// Kludgy
 176:wtpa2bootloader.c **** 		}
 177:wtpa2bootloader.c **** 		if(systemTicks>(startTime+(SECOND/10)))		// Did we just time out?
 178:wtpa2bootloader.c **** 		{
 179:wtpa2bootloader.c **** 			success=false;	
 180:wtpa2bootloader.c **** 		}
 181:wtpa2bootloader.c **** 
 182:wtpa2bootloader.c **** 		for(i=0;i<SD_BLOCK_LENGTH;i++)			// Get entire block
 183:wtpa2bootloader.c **** 		{
 184:wtpa2bootloader.c **** 			*data=TransferSdByte(DUMMY_BYTE);	// Read data into array we pointed to
 185:wtpa2bootloader.c **** 			data++;								// Next byte in array
 186:wtpa2bootloader.c **** 		}
 187:wtpa2bootloader.c **** 
 188:wtpa2bootloader.c **** 		TransferSdByte(DUMMY_BYTE);		// Get block CRC/Checksum whatever the SD card is using and ignore i
 189:wtpa2bootloader.c **** 		TransferSdByte(DUMMY_BYTE);
 190:wtpa2bootloader.c **** 	}	
 191:wtpa2bootloader.c **** 	else
 192:wtpa2bootloader.c **** 	{
 193:wtpa2bootloader.c **** 		success=false;	// Error issuing read command
 194:wtpa2bootloader.c **** 	}
 195:wtpa2bootloader.c **** 
 196:wtpa2bootloader.c **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 197:wtpa2bootloader.c **** 		;
 198:wtpa2bootloader.c **** 
 199:wtpa2bootloader.c **** 	EndSdTransfer();				// Bring CS high
 200:wtpa2bootloader.c **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 201:wtpa2bootloader.c **** 
 202:wtpa2bootloader.c **** 	return(success);
 203:wtpa2bootloader.c **** }
 204:wtpa2bootloader.c **** 
 205:wtpa2bootloader.c **** static bool CheckBootHeader(unsigned char *theBlock)
 206:wtpa2bootloader.c **** // Returns true if the magic letter sequence is on the card, indicating this card holds a good flas
 207:wtpa2bootloader.c **** // Correct sequence is WTPABOOT
 208:wtpa2bootloader.c **** // Also gets data length and CRC and puts those in local variables
 209:wtpa2bootloader.c **** {
 210:wtpa2bootloader.c **** 	unsigned char
 211:wtpa2bootloader.c **** 		i;
 212:wtpa2bootloader.c **** 
 213:wtpa2bootloader.c **** 	// Check the first 8 characters of passed block, return false if one is wrong
 214:wtpa2bootloader.c **** 	for(i=0;i<8;i++)
 215:wtpa2bootloader.c **** 	{
 216:wtpa2bootloader.c **** 		if(*theBlock!=bootHeader[i])	// See if the character in the block matches our header
 217:wtpa2bootloader.c **** 		{
 218:wtpa2bootloader.c **** 			return(false);				// Bail if we don't see these letters
 219:wtpa2bootloader.c **** 		}
 220:wtpa2bootloader.c **** 		theBlock++;
 221:wtpa2bootloader.c **** 	}
 222:wtpa2bootloader.c **** 
 223:wtpa2bootloader.c **** 	// Now get the 32-bit length of data (big endian byte order)
 224:wtpa2bootloader.c **** 	bootDataLength=(unsigned long)(*theBlock)<<24;
 225:wtpa2bootloader.c **** 	theBlock++;
 226:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)(*theBlock)<<16;
 227:wtpa2bootloader.c **** 	theBlock++;
 228:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)(*theBlock)<<8;
 229:wtpa2bootloader.c **** 	theBlock++;
 230:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)*theBlock;
 231:wtpa2bootloader.c **** 	theBlock++;
 232:wtpa2bootloader.c **** 
 233:wtpa2bootloader.c **** 	// Now get the 16-bit CRC (big endian byte order)
 234:wtpa2bootloader.c **** 	bootCrc=(unsigned int)(*theBlock)<<8;
 235:wtpa2bootloader.c **** 	theBlock++;
 236:wtpa2bootloader.c **** 	bootCrc|=(*theBlock);
 237:wtpa2bootloader.c **** 
 238:wtpa2bootloader.c **** 	return(true);
 239:wtpa2bootloader.c **** }
 240:wtpa2bootloader.c **** 
 241:wtpa2bootloader.c **** // ------------------------------------------------------------
 242:wtpa2bootloader.c **** // ------------------------------------------------------------
 243:wtpa2bootloader.c **** 
 244:wtpa2bootloader.c **** 
 245:wtpa2bootloader.c **** static unsigned int UpdateCrc(unsigned int crc, unsigned char inputByte)
 246:wtpa2bootloader.c **** // Updates a 16-bit CRC in the "Xmodem" style of CRC calculation.  This is cribbed more or less fro
 247:wtpa2bootloader.c **** // It is written here for debug purposes and so I can make sure I'm calculating the CRC on both end
 248:wtpa2bootloader.c **** // NOTE -- the CRC must be initialized to 0 before we begin the calculations (some other CRCs must 
 249:wtpa2bootloader.c **** // NOTE -- Since this is CHECKING the CRC made by the boot image packer, we should run through all 
 250:wtpa2bootloader.c **** {
  39               		.loc 1 250 0
  40               		.cfi_startproc
  41               	.LVL2:
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 251:wtpa2bootloader.c **** 	unsigned char
 252:wtpa2bootloader.c **** 		i;
 253:wtpa2bootloader.c **** 
 254:wtpa2bootloader.c **** 	crc=crc^((unsigned int)inputByte<<8);	// Start by XORing the CRC with the byte shifted up
  46               		.loc 1 254 0
  47 0000 362F      		mov r19,r22
  48 0002 20E0      		ldi r18,0
  49 0004 2827      		eor r18,r24
  50 0006 3927      		eor r19,r25
  51               	.LVL3:
  52 0008 48E0      		ldi r20,lo8(8)
  53               	.LVL4:
  54               	.L5:
  55 000a C901      		movw r24,r18
  56 000c 880F      		lsl r24
  57 000e 991F      		rol r25
 255:wtpa2bootloader.c **** 
 256:wtpa2bootloader.c **** 	for(i=0;i<8;i++)			// Now go through and check the individual bits of the byte.  If the top bit is
 257:wtpa2bootloader.c **** 	{
 258:wtpa2bootloader.c **** 	    if (crc&0x8000)			// High bit of 16 bit value set?
  58               		.loc 1 258 0
  59 0010 37FF      		sbrs r19,7
  60 0012 00C0      		rjmp .L3
 259:wtpa2bootloader.c **** 	    {
 260:wtpa2bootloader.c **** 	        crc=(crc<<1)^0x1021;	// Move the running CRC over and XOR it with the polynomial.  NOTE --
  61               		.loc 1 260 0
  62 0014 21E2      		ldi r18,lo8(33)
  63 0016 30E1      		ldi r19,lo8(16)
  64               	.LVL5:
  65 0018 2827      		eor r18,r24
  66 001a 3927      		eor r19,r25
  67               	.LVL6:
  68 001c 00C0      		rjmp .L4
  69               	.L3:
 261:wtpa2bootloader.c **** 		}
 262:wtpa2bootloader.c **** 	    else
 263:wtpa2bootloader.c **** 	    {
 264:wtpa2bootloader.c **** 	        crc<<=1;				// Bit not set, just move checksum
  70               		.loc 1 264 0
  71 001e 9C01      		movw r18,r24
  72               	.LVL7:
  73               	.L4:
  74 0020 4150      		subi r20,lo8(-(-1))
 256:wtpa2bootloader.c **** 	for(i=0;i<8;i++)			// Now go through and check the individual bits of the byte.  If the top bit is
  75               		.loc 1 256 0
  76 0022 01F4      		brne .L5
 265:wtpa2bootloader.c **** 		}
 266:wtpa2bootloader.c **** 	}		
 267:wtpa2bootloader.c **** 
 268:wtpa2bootloader.c **** 	return(crc);
 269:wtpa2bootloader.c **** }
  77               		.loc 1 269 0
  78 0024 C901      		movw r24,r18
  79 0026 0895      		ret
  80               		.cfi_endproc
  81               	.LFE7:
  83               		.text
  84               	.global	HandleSoftclock
  86               	HandleSoftclock:
  87               	.LFB2:
 106:wtpa2bootloader.c **** {
  88               		.loc 1 106 0
  89               		.cfi_startproc
  90               	/* prologue: function */
  91               	/* frame size = 0 */
  92               	/* stack size = 0 */
  93               	.L__stack_usage = 0
 107:wtpa2bootloader.c **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
  94               		.loc 1 107 0
  95 000c A89B      		sbis 0x15,0
  96 000e 00C0      		rjmp .L7
  97               	.LBB4:
  98               	.LBB5:
 109:wtpa2bootloader.c **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
  99               		.loc 1 109 0
 100 0010 A89A      		sbi 0x15,0
 110:wtpa2bootloader.c **** 		systemTicks++;			// Increment the system ticks.
 101               		.loc 1 110 0
 102 0012 8091 0000 		lds r24,systemTicks
 103 0016 9091 0000 		lds r25,systemTicks+1
 104 001a 0196      		adiw r24,1
 105 001c 9093 0000 		sts systemTicks+1,r25
 106 0020 8093 0000 		sts systemTicks,r24
 107               	.L7:
 108 0024 0895      		ret
 109               	.LBE5:
 110               	.LBE4:
 111               		.cfi_endproc
 112               	.LFE2:
 115               	GetSdBlock:
 116               	.LFB5:
 159:wtpa2bootloader.c **** {
 117               		.loc 1 159 0
 118               		.cfi_startproc
 119               	.LVL8:
 120 0026 CF92      		push r12
 121               	.LCFI0:
 122               		.cfi_def_cfa_offset 3
 123               		.cfi_offset 12, -2
 124 0028 DF92      		push r13
 125               	.LCFI1:
 126               		.cfi_def_cfa_offset 4
 127               		.cfi_offset 13, -3
 128 002a EF92      		push r14
 129               	.LCFI2:
 130               		.cfi_def_cfa_offset 5
 131               		.cfi_offset 14, -4
 132 002c FF92      		push r15
 133               	.LCFI3:
 134               		.cfi_def_cfa_offset 6
 135               		.cfi_offset 15, -5
 136 002e 1F93      		push r17
 137               	.LCFI4:
 138               		.cfi_def_cfa_offset 7
 139               		.cfi_offset 17, -6
 140 0030 CF93      		push r28
 141               	.LCFI5:
 142               		.cfi_def_cfa_offset 8
 143               		.cfi_offset 28, -7
 144 0032 DF93      		push r29
 145               	.LCFI6:
 146               		.cfi_def_cfa_offset 9
 147               		.cfi_offset 29, -8
 148               	/* prologue: function */
 149               	/* frame size = 0 */
 150               	/* stack size = 7 */
 151               	.L__stack_usage = 7
 152 0034 EB01      		movw r28,r22
 153               	.LVL9:
 168:wtpa2bootloader.c **** 	if(SdBeginSingleBlockRead(blockAddress)==true)		// Start reading at block...
 154               		.loc 1 168 0
 155 0036 BC01      		movw r22,r24
 156               	.LVL10:
 157 0038 80E0      		ldi r24,0
 158 003a 90E0      		ldi r25,0
 159               	.LVL11:
 160 003c 0E94 0000 		call SdBeginSingleBlockRead
 161               	.LVL12:
 162 0040 8130      		cpi r24,lo8(1)
 163 0042 01F4      		brne .L21
 171:wtpa2bootloader.c **** 		startTime=systemTicks;		
 164               		.loc 1 171 0
 165 0044 C090 0000 		lds r12,systemTicks
 166 0048 D090 0000 		lds r13,systemTicks+1
 167               	.LVL13:
 173:wtpa2bootloader.c **** 		while((systemTicks<(startTime+(SECOND/10)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the 
 168               		.loc 1 173 0
 169 004c E12C      		mov r14,__zero_reg__
 170 004e F12C      		mov r15,__zero_reg__
 171 0050 8AE7      		ldi r24,122
 172 0052 C80E      		add r12,r24
 173 0054 D11C      		adc r13,__zero_reg__
 174 0056 E11C      		adc r14,__zero_reg__
 175 0058 F11C      		adc r15,__zero_reg__
 176               	.LVL14:
 177 005a 00C0      		rjmp .L14
 178               	.L18:
 175:wtpa2bootloader.c **** 			HandleSoftclock();	// Kludgy
 179               		.loc 1 175 0
 180 005c 0E94 0000 		call HandleSoftclock
 181               	.LVL15:
 182               	.L14:
 173:wtpa2bootloader.c **** 		while((systemTicks<(startTime+(SECOND/10)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the 
 183               		.loc 1 173 0 discriminator 1
 184 0060 8091 0000 		lds r24,systemTicks
 185 0064 9091 0000 		lds r25,systemTicks+1
 186 0068 A0E0      		ldi r26,0
 187 006a B0E0      		ldi r27,0
 188 006c 8C15      		cp r24,r12
 189 006e 9D05      		cpc r25,r13
 190 0070 AE05      		cpc r26,r14
 191 0072 BF05      		cpc r27,r15
 192 0074 00F0      		brlo .L15
 193               	.L19:
 177:wtpa2bootloader.c **** 		if(systemTicks>(startTime+(SECOND/10)))		// Did we just time out?
 194               		.loc 1 177 0
 195 0076 4091 0000 		lds r20,systemTicks
 196 007a 5091 0000 		lds r21,systemTicks+1
 197 007e 60E0      		ldi r22,0
 198 0080 70E0      		ldi r23,0
 199 0082 11E0      		ldi r17,lo8(1)
 200 0084 C416      		cp r12,r20
 201 0086 D506      		cpc r13,r21
 202 0088 E606      		cpc r14,r22
 203 008a F706      		cpc r15,r23
 204 008c 00F4      		brsh .L16
 205 008e 10E0      		ldi r17,0
 206               	.L16:
 207               	.LVL16:
 156:wtpa2bootloader.c **** static bool GetSdBlock(unsigned int blockAddress, unsigned char *data)
 208               		.loc 1 156 0
 209 0090 7E01      		movw r14,r28
 210 0092 8EEF      		ldi r24,-2
 211 0094 F81A      		sub r15,r24
 212 0096 00C0      		rjmp .L17
 213               	.LVL17:
 214               	.L15:
 173:wtpa2bootloader.c **** 		while((systemTicks<(startTime+(SECOND/10)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the 
 215               		.loc 1 173 0 discriminator 2
 216 0098 8FEF      		ldi r24,lo8(-1)
 217 009a 0E94 0000 		call TransferSdByte
 218               	.LVL18:
 219 009e 8E3F      		cpi r24,lo8(-2)
 220 00a0 01F4      		brne .L18
 221 00a2 00C0      		rjmp .L19
 222               	.LVL19:
 223               	.L17:
 184:wtpa2bootloader.c **** 			*data=TransferSdByte(DUMMY_BYTE);	// Read data into array we pointed to
 224               		.loc 1 184 0 discriminator 2
 225 00a4 8FEF      		ldi r24,lo8(-1)
 226 00a6 0E94 0000 		call TransferSdByte
 227               	.LVL20:
 228 00aa 8993      		st Y+,r24
 229               	.LVL21:
 182:wtpa2bootloader.c **** 		for(i=0;i<SD_BLOCK_LENGTH;i++)			// Get entire block
 230               		.loc 1 182 0 discriminator 2
 231 00ac CE15      		cp r28,r14
 232 00ae DF05      		cpc r29,r15
 233 00b0 01F4      		brne .L17
 188:wtpa2bootloader.c **** 		TransferSdByte(DUMMY_BYTE);		// Get block CRC/Checksum whatever the SD card is using and ignore i
 234               		.loc 1 188 0
 235 00b2 8FEF      		ldi r24,lo8(-1)
 236 00b4 0E94 0000 		call TransferSdByte
 237               	.LVL22:
 189:wtpa2bootloader.c **** 		TransferSdByte(DUMMY_BYTE);
 238               		.loc 1 189 0
 239 00b8 8FEF      		ldi r24,lo8(-1)
 240 00ba 0E94 0000 		call TransferSdByte
 241               	.LVL23:
 242 00be 00C0      		rjmp .L24
 243               	.LVL24:
 244               	.L21:
 193:wtpa2bootloader.c **** 		success=false;	// Error issuing read command
 245               		.loc 1 193 0
 246 00c0 10E0      		ldi r17,0
 247               	.LVL25:
 248               	.L24:
 196:wtpa2bootloader.c **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 249               		.loc 1 196 0 discriminator 1
 250 00c2 8091 C800 		lds r24,200
 251 00c6 86FF      		sbrs r24,6
 252 00c8 00C0      		rjmp .L24
 199:wtpa2bootloader.c **** 	EndSdTransfer();				// Bring CS high
 253               		.loc 1 199 0
 254 00ca 0E94 0000 		call EndSdTransfer
 255               	.LVL26:
 200:wtpa2bootloader.c **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 256               		.loc 1 200 0
 257 00ce 8FEF      		ldi r24,lo8(-1)
 258 00d0 0E94 0000 		call TransferSdByte
 259               	.LVL27:
 203:wtpa2bootloader.c **** }
 260               		.loc 1 203 0
 261 00d4 812F      		mov r24,r17
 262               	/* epilogue start */
 263 00d6 DF91      		pop r29
 264 00d8 CF91      		pop r28
 265               	.LVL28:
 266 00da 1F91      		pop r17
 267               	.LVL29:
 268 00dc FF90      		pop r15
 269 00de EF90      		pop r14
 270 00e0 DF90      		pop r13
 271 00e2 CF90      		pop r12
 272 00e4 0895      		ret
 273               		.cfi_endproc
 274               	.LFE5:
 276               		.section	.text.startup,"ax",@progbits
 277               	.global	main
 279               	main:
 280               	.LFB9:
 270:wtpa2bootloader.c **** 
 271:wtpa2bootloader.c **** static bool CheckBootCrc(void)
 272:wtpa2bootloader.c **** // Read the whole blob of data we are to bootload.  Update the crc.  When we're done reading, retur
 273:wtpa2bootloader.c **** // NOTE -- we must have already read the CRC off the card when this is called.
 274:wtpa2bootloader.c **** {
 275:wtpa2bootloader.c **** 	unsigned long
 276:wtpa2bootloader.c **** 		bootDataIndex;
 277:wtpa2bootloader.c **** 	unsigned int
 278:wtpa2bootloader.c **** 		blockDataIndex,
 279:wtpa2bootloader.c **** 		currentBlock,
 280:wtpa2bootloader.c **** 		runningCrc;
 281:wtpa2bootloader.c **** 		
 282:wtpa2bootloader.c **** 	bootDataIndex=0;					// Start with first data bytes
 283:wtpa2bootloader.c **** 	runningCrc=0;						// CRC must be 0 to start (see Xmodem CRC rules)
 284:wtpa2bootloader.c **** 	blockDataIndex=SD_BLOCK_LENGTH;		// Haven't read in a new block
 285:wtpa2bootloader.c **** 	currentBlock=1;						// Boot data begins in block one (header is in block 0)
 286:wtpa2bootloader.c **** 	
 287:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>24)&0xFF));	// Begin CRC with byte count of boot
 288:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>16)&0xFF));	
 289:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>8)&0xFF));	
 290:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,(bootDataLength&0xFF));
 291:wtpa2bootloader.c **** 
 292:wtpa2bootloader.c **** 	while(bootDataIndex<bootDataLength)		// Stay here while there are still bytes left to input into t
 293:wtpa2bootloader.c **** 	{
 294:wtpa2bootloader.c **** 		if(blockDataIndex==SD_BLOCK_LENGTH)					// Are we done reading through this block?
 295:wtpa2bootloader.c **** 		{
 296:wtpa2bootloader.c **** 			if(GetSdBlock(currentBlock,&bootBuffer[0]))		// Read in a new block
 297:wtpa2bootloader.c **** 			{
 298:wtpa2bootloader.c **** 				currentBlock++;				// Point at the next block
 299:wtpa2bootloader.c **** 				blockDataIndex=0;			// Point at first byte of this block
 300:wtpa2bootloader.c **** 			}
 301:wtpa2bootloader.c **** 			else
 302:wtpa2bootloader.c **** 			{
 303:wtpa2bootloader.c **** 				return(false);								// Bail; read error
 304:wtpa2bootloader.c **** 			}
 305:wtpa2bootloader.c **** 		}
 306:wtpa2bootloader.c **** 
 307:wtpa2bootloader.c **** 		runningCrc=UpdateCrc(runningCrc,*((&bootBuffer[0])+blockDataIndex));	// Update CRC with the next 
 308:wtpa2bootloader.c **** 		blockDataIndex++;														// Now point at next byte in block
 309:wtpa2bootloader.c **** 		bootDataIndex++;														// Keep track of running count of bytes
 310:wtpa2bootloader.c **** 	}
 311:wtpa2bootloader.c **** 
 312:wtpa2bootloader.c **** 	// At this point we've calculated the CRC from the data length and all the data bytes.
 313:wtpa2bootloader.c **** 	// When update the calculated CRC with the passed CRC, the result should be 0
 314:wtpa2bootloader.c **** 	
 315:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootCrc>>8)&0xFF));	
 316:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,(bootCrc&0xFF));
 317:wtpa2bootloader.c **** 	
 318:wtpa2bootloader.c **** 	if(runningCrc==0)
 319:wtpa2bootloader.c **** 	{
 320:wtpa2bootloader.c **** 		return(true);
 321:wtpa2bootloader.c **** 	}
 322:wtpa2bootloader.c **** 	
 323:wtpa2bootloader.c **** 	return(false);
 324:wtpa2bootloader.c **** }
 325:wtpa2bootloader.c **** 
 326:wtpa2bootloader.c **** // ------------------------------------------------------------
 327:wtpa2bootloader.c **** // ------------------------------------------------------------
 328:wtpa2bootloader.c **** 
 329:wtpa2bootloader.c **** int main(void)
 330:wtpa2bootloader.c **** {
 281               		.loc 1 330 0
 282               		.cfi_startproc
 283 0000 5F92      		push r5
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 3
 286               		.cfi_offset 5, -2
 287 0002 6F92      		push r6
 288               	.LCFI8:
 289               		.cfi_def_cfa_offset 4
 290               		.cfi_offset 6, -3
 291 0004 7F92      		push r7
 292               	.LCFI9:
 293               		.cfi_def_cfa_offset 5
 294               		.cfi_offset 7, -4
 295 0006 8F92      		push r8
 296               	.LCFI10:
 297               		.cfi_def_cfa_offset 6
 298               		.cfi_offset 8, -5
 299 0008 9F92      		push r9
 300               	.LCFI11:
 301               		.cfi_def_cfa_offset 7
 302               		.cfi_offset 9, -6
 303 000a AF92      		push r10
 304               	.LCFI12:
 305               		.cfi_def_cfa_offset 8
 306               		.cfi_offset 10, -7
 307 000c BF92      		push r11
 308               	.LCFI13:
 309               		.cfi_def_cfa_offset 9
 310               		.cfi_offset 11, -8
 311 000e CF92      		push r12
 312               	.LCFI14:
 313               		.cfi_def_cfa_offset 10
 314               		.cfi_offset 12, -9
 315 0010 DF92      		push r13
 316               	.LCFI15:
 317               		.cfi_def_cfa_offset 11
 318               		.cfi_offset 13, -10
 319 0012 EF92      		push r14
 320               	.LCFI16:
 321               		.cfi_def_cfa_offset 12
 322               		.cfi_offset 14, -11
 323 0014 FF92      		push r15
 324               	.LCFI17:
 325               		.cfi_def_cfa_offset 13
 326               		.cfi_offset 15, -12
 327 0016 0F93      		push r16
 328               	.LCFI18:
 329               		.cfi_def_cfa_offset 14
 330               		.cfi_offset 16, -13
 331 0018 1F93      		push r17
 332               	.LCFI19:
 333               		.cfi_def_cfa_offset 15
 334               		.cfi_offset 17, -14
 335 001a CF93      		push r28
 336               	.LCFI20:
 337               		.cfi_def_cfa_offset 16
 338               		.cfi_offset 28, -15
 339 001c DF93      		push r29
 340               	.LCFI21:
 341               		.cfi_def_cfa_offset 17
 342               		.cfi_offset 29, -16
 343               	/* prologue: function */
 344               	/* frame size = 0 */
 345               	/* stack size = 15 */
 346               	.L__stack_usage = 15
 331:wtpa2bootloader.c **** 	unsigned long
 332:wtpa2bootloader.c **** 		bootDataIndex;
 333:wtpa2bootloader.c **** 	unsigned int
 334:wtpa2bootloader.c **** 		i,
 335:wtpa2bootloader.c **** 		tempWord,
 336:wtpa2bootloader.c **** 		blockDataIndex,
 337:wtpa2bootloader.c **** 		currentBlock;
 338:wtpa2bootloader.c **** 
 339:wtpa2bootloader.c **** 	unsigned char
 340:wtpa2bootloader.c **** 		ledProgress;
 341:wtpa2bootloader.c **** 
 342:wtpa2bootloader.c **** 	cli();				// Bootloader has no interrupts
 347               		.loc 1 342 0
 348               	/* #APP */
 349               	 ;  342 "wtpa2bootloader.c" 1
 350 001e F894      		cli
 351               	 ;  0 "" 2
 343:wtpa2bootloader.c **** 
 344:wtpa2bootloader.c **** 	// Set the DDRs to known state so they don't flop around.
 345:wtpa2bootloader.c **** 
 346:wtpa2bootloader.c **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
 352               		.loc 1 346 0
 353               	/* #NOAPP */
 354 0020 8FEE      		ldi r24,lo8(-17)
 355 0022 87B9      		out 0x7,r24
 347:wtpa2bootloader.c **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
 356               		.loc 1 347 0
 357 0024 88E0      		ldi r24,lo8(8)
 358 0026 88B9      		out 0x8,r24
 348:wtpa2bootloader.c **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
 359               		.loc 1 348 0
 360 0028 80E8      		ldi r24,lo8(-128)
 361 002a 8AB9      		out 0xa,r24
 349:wtpa2bootloader.c **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
 362               		.loc 1 349 0
 363 002c 1BB8      		out 0xb,__zero_reg__
 350:wtpa2bootloader.c **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
 364               		.loc 1 350 0
 365 002e 86E0      		ldi r24,lo8(6)
 366 0030 82B9      		out 0x2,r24
 351:wtpa2bootloader.c **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
 367               		.loc 1 351 0
 368 0032 8EE3      		ldi r24,lo8(62)
 369 0034 81B9      		out 0x1,r24
 352:wtpa2bootloader.c **** 	DDRB=0xFF;			// Latch port to OP.
 370               		.loc 1 352 0
 371 0036 CFEF      		ldi r28,lo8(-1)
 372 0038 C4B9      		out 0x4,r28
 353:wtpa2bootloader.c **** 
 354:wtpa2bootloader.c **** 	SetLeds(0x00);		// Init LEDs to off
 373               		.loc 1 354 0
 374 003a 80E0      		ldi r24,0
 375 003c 0E94 0000 		call SetLeds
 376               	.LVL30:
 377               	.LBB16:
 378               	.LBB17:
  95:wtpa2bootloader.c **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
 379               		.loc 1 95 0
 380 0040 8091 6400 		lds r24,100
 381 0044 8F7D      		andi r24,lo8(-33)
 382 0046 8093 6400 		sts 100,r24
  96:wtpa2bootloader.c **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
 383               		.loc 1 96 0
 384 004a 1092 6E00 		sts 110,__zero_reg__
  97:wtpa2bootloader.c **** 	TCCR0A=0;			// Normal Ports.
 385               		.loc 1 97 0
 386 004e 14BC      		out 0x24,__zero_reg__
  98:wtpa2bootloader.c **** 	TCNT0=0;			// Initialize the counter to 0.
 387               		.loc 1 98 0
 388 0050 16BC      		out 0x26,__zero_reg__
  99:wtpa2bootloader.c **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 389               		.loc 1 99 0
 390 0052 C5BB      		out 0x15,r28
 100:wtpa2bootloader.c **** 	systemTicks=0;
 391               		.loc 1 100 0
 392 0054 1092 0000 		sts systemTicks+1,__zero_reg__
 393 0058 1092 0000 		sts systemTicks,__zero_reg__
 102:wtpa2bootloader.c **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 394               		.loc 1 102 0
 395 005c 83E0      		ldi r24,lo8(3)
 396 005e 85BD      		out 0x25,r24
 397               	.LBE17:
 398               	.LBE16:
 355:wtpa2bootloader.c **** 	InitSoftclock();	// Get timer ticking
 356:wtpa2bootloader.c **** 	InitSdInterface();	// Get ready to check card
 399               		.loc 1 356 0
 400 0060 0E94 0000 		call InitSdInterface
 401               	.LVL31:
 402               	.LBB18:
 403               	.LBB19:
 123:wtpa2bootloader.c **** 	LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 404               		.loc 1 123 0
 405 0064 C5B9      		out 0x5,r28
 124:wtpa2bootloader.c **** 	LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 406               		.loc 1 124 0
 407 0066 14B8      		out 0x4,__zero_reg__
 125:wtpa2bootloader.c **** 	PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 408               		.loc 1 125 0
 409 0068 4398      		cbi 0x8,3
 126:wtpa2bootloader.c **** 	asm volatile("nop"::);		// Needed for bus turnaround time (2 nops min)
 410               		.loc 1 126 0
 411               	/* #APP */
 412               	 ;  126 "wtpa2bootloader.c" 1
 413 006a 0000      		nop
 414               	 ;  0 "" 2
 127:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 415               		.loc 1 127 0
 416               	 ;  127 "wtpa2bootloader.c" 1
 417 006c 0000      		nop
 418               	 ;  0 "" 2
 128:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 419               		.loc 1 128 0
 420               	 ;  128 "wtpa2bootloader.c" 1
 421 006e 0000      		nop
 422               	 ;  0 "" 2
 129:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 423               		.loc 1 129 0
 424               	 ;  129 "wtpa2bootloader.c" 1
 425 0070 0000      		nop
 426               	 ;  0 "" 2
 130:wtpa2bootloader.c **** 	asm volatile("nop"::);		
 427               		.loc 1 130 0
 428               	 ;  130 "wtpa2bootloader.c" 1
 429 0072 0000      		nop
 430               	 ;  0 "" 2
 131:wtpa2bootloader.c **** 	asm volatile("nop"::);
 431               		.loc 1 131 0
 432               	 ;  131 "wtpa2bootloader.c" 1
 433 0074 0000      		nop
 434               	 ;  0 "" 2
 132:wtpa2bootloader.c **** 	keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 435               		.loc 1 132 0
 436               	/* #NOAPP */
 437 0076 83B1      		in r24,0x3
 438 0078 8095      		com r24
 439               	.LVL32:
 133:wtpa2bootloader.c **** 	PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 440               		.loc 1 133 0
 441 007a 439A      		sbi 0x8,3
 134:wtpa2bootloader.c **** 	LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 442               		.loc 1 134 0
 443 007c 9FEF      		ldi r25,lo8(-1)
 444 007e 94B9      		out 0x4,r25
 136:wtpa2bootloader.c **** 	if((keyState&(1<<7))&&(keyState&(1<<0)))
 445               		.loc 1 136 0
 446 0080 87FF      		sbrs r24,7
 447 0082 00C0      		rjmp .L31
 448 0084 80FF      		sbrs r24,0
 449 0086 00C0      		rjmp .L31
 450 0088 00C0      		rjmp .L30
 451               	.LVL33:
 452               	.L52:
 453               	.LBE19:
 454               	.LBE18:
 357:wtpa2bootloader.c **** 	
 358:wtpa2bootloader.c **** 	if(CheckBootButtonsPressed()==true)	// User is pressing button combo
 359:wtpa2bootloader.c **** 	{
 360:wtpa2bootloader.c **** 		SetLeds(0x01);				// Turn on first LED
 361:wtpa2bootloader.c **** 		if(!(PINC&Im_CARD_DETECT))	// Check to see if a card is inserted
 362:wtpa2bootloader.c **** 		{
 363:wtpa2bootloader.c **** 			SetLeds(0x03);					// First two leds
 455               		.loc 1 363 0
 456 008a 83E0      		ldi r24,lo8(3)
 457 008c 0E94 0000 		call SetLeds
 458               	.LVL34:
 364:wtpa2bootloader.c **** 			while(systemTicks<(SECOND/2))	// Hang for half a second to make sure sd card has time to warm up
 459               		.loc 1 364 0
 460 0090 00C0      		rjmp .L32
 461               	.L33:
 365:wtpa2bootloader.c **** 			{
 366:wtpa2bootloader.c **** 				HandleSoftclock();			// Keep system clock moving
 462               		.loc 1 366 0
 463 0092 0E94 0000 		call HandleSoftclock
 464               	.LVL35:
 465               	.L32:
 364:wtpa2bootloader.c **** 			while(systemTicks<(SECOND/2))	// Hang for half a second to make sure sd card has time to warm up
 466               		.loc 1 364 0 discriminator 1
 467 0096 8091 0000 		lds r24,systemTicks
 468 009a 9091 0000 		lds r25,systemTicks+1
 469 009e 8236      		cpi r24,98
 470 00a0 9240      		sbci r25,2
 471 00a2 00F0      		brlo .L33
 367:wtpa2bootloader.c **** 			}
 368:wtpa2bootloader.c **** 
 369:wtpa2bootloader.c **** 			if(SdHandshake()==true)	// Attempt to initialize and access card
 472               		.loc 1 369 0
 473 00a4 0E94 0000 		call SdHandshake
 474               	.LVL36:
 475 00a8 8130      		cpi r24,lo8(1)
 476 00aa 01F0      		breq .+2
 477 00ac 00C0      		rjmp .L35
 370:wtpa2bootloader.c **** 			{
 371:wtpa2bootloader.c **** 				SetLeds(0x07);				// First three LEDs
 478               		.loc 1 371 0
 479 00ae 87E0      		ldi r24,lo8(7)
 480 00b0 0E94 0000 		call SetLeds
 481               	.LVL37:
 372:wtpa2bootloader.c **** 				if(GetSdBlock(0,bootBuffer)==true&&CheckBootHeader(bootBuffer)==true)	// Try to get the first b
 482               		.loc 1 372 0
 483 00b4 60E0      		ldi r22,lo8(bootBuffer)
 484 00b6 70E0      		ldi r23,hi8(bootBuffer)
 485 00b8 80E0      		ldi r24,0
 486 00ba 90E0      		ldi r25,0
 487 00bc 0E94 0000 		call GetSdBlock
 488               	.LVL38:
 489 00c0 8130      		cpi r24,lo8(1)
 490 00c2 01F0      		breq .+2
 491 00c4 00C0      		rjmp .L35
 492 00c6 E0E0      		ldi r30,lo8(bootBuffer)
 493 00c8 F0E0      		ldi r31,hi8(bootBuffer)
 494 00ca A0E0      		ldi r26,lo8(bootHeader)
 495 00cc B0E0      		ldi r27,hi8(bootHeader)
 496               	.L37:
 497               	.LBB20:
 498               	.LBB21:
 216:wtpa2bootloader.c **** 		if(*theBlock!=bootHeader[i])	// See if the character in the block matches our header
 499               		.loc 1 216 0
 500 00ce 9191      		ld r25,Z+
 501 00d0 8D91      		ld r24,X+
 502 00d2 9813      		cpse r25,r24
 503 00d4 00C0      		rjmp .L35
 504               	.LVL39:
 214:wtpa2bootloader.c **** 	for(i=0;i<8;i++)
 505               		.loc 1 214 0
 506 00d6 60E0      		ldi r22,hi8(bootBuffer+8)
 507 00d8 E030      		cpi r30,lo8(bootBuffer+8)
 508 00da F607      		cpc r31,r22
 509 00dc 01F4      		brne .L37
 510               	.LVL40:
 224:wtpa2bootloader.c **** 	bootDataLength=(unsigned long)(*theBlock)<<24;
 511               		.loc 1 224 0
 512 00de 8091 0000 		lds r24,bootBuffer+8
 226:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)(*theBlock)<<16;
 513               		.loc 1 226 0
 514 00e2 C090 0000 		lds r12,bootBuffer+9
 515 00e6 D12C      		mov r13,__zero_reg__
 516 00e8 E12C      		mov r14,__zero_reg__
 517 00ea F12C      		mov r15,__zero_reg__
 518 00ec 7601      		movw r14,r12
 519 00ee DD24      		clr r13
 520 00f0 CC24      		clr r12
 521 00f2 F82A      		or r15,r24
 230:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)*theBlock;
 522               		.loc 1 230 0
 523 00f4 8091 0000 		lds r24,bootBuffer+11
 228:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)(*theBlock)<<8;
 524               		.loc 1 228 0
 525 00f8 C82A      		or r12,r24
 526 00fa 8091 0000 		lds r24,bootBuffer+10
 230:wtpa2bootloader.c **** 	bootDataLength|=(unsigned long)*theBlock;
 527               		.loc 1 230 0
 528 00fe D82A      		or r13,r24
 529 0100 C092 0000 		sts bootDataLength,r12
 530 0104 D092 0000 		sts bootDataLength+1,r13
 531 0108 E092 0000 		sts bootDataLength+2,r14
 532 010c F092 0000 		sts bootDataLength+3,r15
 234:wtpa2bootloader.c **** 	bootCrc=(unsigned int)(*theBlock)<<8;
 533               		.loc 1 234 0
 534 0110 9091 0000 		lds r25,bootBuffer+12
 535 0114 80E0      		ldi r24,0
 236:wtpa2bootloader.c **** 	bootCrc|=(*theBlock);
 536               		.loc 1 236 0
 537 0116 2091 0000 		lds r18,bootBuffer+13
 538 011a 822B      		or r24,r18
 539 011c 9093 0000 		sts bootCrc+1,r25
 540 0120 8093 0000 		sts bootCrc,r24
 541               	.LBE21:
 542               	.LBE20:
 373:wtpa2bootloader.c **** 				{
 374:wtpa2bootloader.c **** 					SetLeds(0x0F);				// Four LEDs on
 543               		.loc 1 374 0
 544 0124 8FE0      		ldi r24,lo8(15)
 545 0126 0E94 0000 		call SetLeds
 546               	.LVL41:
 547               	.LBB22:
 548               	.LBB23:
 287:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>24)&0xFF));	// Begin CRC with byte count of boot
 549               		.loc 1 287 0
 550 012a 6F2D      		mov r22,r15
 551 012c 7727      		clr r23
 552 012e 8827      		clr r24
 553 0130 9927      		clr r25
 554 0132 80E0      		ldi r24,0
 555 0134 90E0      		ldi r25,0
 556 0136 0E94 0000 		call UpdateCrc
 557               	.LVL42:
 288:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>16)&0xFF));	
 558               		.loc 1 288 0
 559 013a A701      		movw r20,r14
 560 013c 6627      		clr r22
 561 013e 7727      		clr r23
 562 0140 642F      		mov r22,r20
 563 0142 0E94 0000 		call UpdateCrc
 564               	.LVL43:
 289:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootDataLength>>8)&0xFF));	
 565               		.loc 1 289 0
 566 0146 7727      		clr r23
 567 0148 6F2D      		mov r22,r15
 568 014a 5E2D      		mov r21,r14
 569 014c 4D2D      		mov r20,r13
 570 014e 642F      		mov r22,r20
 571 0150 0E94 0000 		call UpdateCrc
 572               	.LVL44:
 290:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,(bootDataLength&0xFF));
 573               		.loc 1 290 0
 574 0154 6C2D      		mov r22,r12
 575 0156 0E94 0000 		call UpdateCrc
 576               	.LVL45:
 577 015a 5C01      		movw r10,r24
 578               	.LVL46:
 285:wtpa2bootloader.c **** 	currentBlock=1;						// Boot data begins in block one (header is in block 0)
 579               		.loc 1 285 0
 580 015c 01E0      		ldi r16,lo8(1)
 581 015e 10E0      		ldi r17,0
 284:wtpa2bootloader.c **** 	blockDataIndex=SD_BLOCK_LENGTH;		// Haven't read in a new block
 582               		.loc 1 284 0
 583 0160 C0E0      		ldi r28,0
 584 0162 D2E0      		ldi r29,lo8(2)
 282:wtpa2bootloader.c **** 	bootDataIndex=0;					// Start with first data bytes
 585               		.loc 1 282 0
 586 0164 C12C      		mov r12,__zero_reg__
 587 0166 D12C      		mov r13,__zero_reg__
 588 0168 7601      		movw r14,r12
 589 016a 00C0      		rjmp .L38
 590               	.LVL47:
 591               	.L41:
 294:wtpa2bootloader.c **** 		if(blockDataIndex==SD_BLOCK_LENGTH)					// Are we done reading through this block?
 592               		.loc 1 294 0
 593 016c C115      		cp r28,__zero_reg__
 594 016e 82E0      		ldi r24,2
 595 0170 D807      		cpc r29,r24
 596 0172 01F4      		brne .L39
 296:wtpa2bootloader.c **** 			if(GetSdBlock(currentBlock,&bootBuffer[0]))		// Read in a new block
 597               		.loc 1 296 0
 598 0174 60E0      		ldi r22,lo8(bootBuffer)
 599 0176 70E0      		ldi r23,hi8(bootBuffer)
 600 0178 C801      		movw r24,r16
 601 017a 0E94 0000 		call GetSdBlock
 602               	.LVL48:
 603 017e 8823      		tst r24
 604 0180 01F4      		brne .+2
 605 0182 00C0      		rjmp .L35
 298:wtpa2bootloader.c **** 				currentBlock++;				// Point at the next block
 606               		.loc 1 298 0
 607 0184 0F5F      		subi r16,-1
 608 0186 1F4F      		sbci r17,-1
 609               	.LVL49:
 299:wtpa2bootloader.c **** 				blockDataIndex=0;			// Point at first byte of this block
 610               		.loc 1 299 0
 611 0188 C0E0      		ldi r28,0
 612 018a D0E0      		ldi r29,0
 613               	.LVL50:
 614               	.L39:
 307:wtpa2bootloader.c **** 		runningCrc=UpdateCrc(runningCrc,*((&bootBuffer[0])+blockDataIndex));	// Update CRC with the next 
 615               		.loc 1 307 0
 616 018c FE01      		movw r30,r28
 617 018e E050      		subi r30,lo8(-(bootBuffer))
 618 0190 F040      		sbci r31,hi8(-(bootBuffer))
 619 0192 6081      		ld r22,Z
 620 0194 C501      		movw r24,r10
 621 0196 0E94 0000 		call UpdateCrc
 622               	.LVL51:
 623 019a 5C01      		movw r10,r24
 624               	.LVL52:
 308:wtpa2bootloader.c **** 		blockDataIndex++;														// Now point at next byte in block
 625               		.loc 1 308 0
 626 019c 2196      		adiw r28,1
 627               	.LVL53:
 309:wtpa2bootloader.c **** 		bootDataIndex++;														// Keep track of running count of bytes
 628               		.loc 1 309 0
 629 019e AFEF      		ldi r26,-1
 630 01a0 CA1A      		sub r12,r26
 631 01a2 DA0A      		sbc r13,r26
 632 01a4 EA0A      		sbc r14,r26
 633 01a6 FA0A      		sbc r15,r26
 634               	.LVL54:
 635               	.L38:
 292:wtpa2bootloader.c **** 	while(bootDataIndex<bootDataLength)		// Stay here while there are still bytes left to input into t
 636               		.loc 1 292 0
 637 01a8 8091 0000 		lds r24,bootDataLength
 638 01ac 9091 0000 		lds r25,bootDataLength+1
 639 01b0 A091 0000 		lds r26,bootDataLength+2
 640 01b4 B091 0000 		lds r27,bootDataLength+3
 641 01b8 C816      		cp r12,r24
 642 01ba D906      		cpc r13,r25
 643 01bc EA06      		cpc r14,r26
 644 01be FB06      		cpc r15,r27
 645 01c0 00F0      		brlo .L41
 315:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,((bootCrc>>8)&0xFF));	
 646               		.loc 1 315 0
 647 01c2 C091 0000 		lds r28,bootCrc
 648               	.LVL55:
 649 01c6 6091 0000 		lds r22,bootCrc+1
 650 01ca C501      		movw r24,r10
 651 01cc 0E94 0000 		call UpdateCrc
 652               	.LVL56:
 316:wtpa2bootloader.c **** 	runningCrc=UpdateCrc(runningCrc,(bootCrc&0xFF));
 653               		.loc 1 316 0
 654 01d0 6C2F      		mov r22,r28
 655 01d2 0E94 0000 		call UpdateCrc
 656               	.LVL57:
 318:wtpa2bootloader.c **** 	if(runningCrc==0)
 657               		.loc 1 318 0
 658 01d6 892B      		or r24,r25
 659 01d8 01F0      		breq .+2
 660 01da 00C0      		rjmp .L35
 661 01dc 00C0      		rjmp .L42
 662               	.LVL58:
 663               	.L49:
 664               	.LBE23:
 665               	.LBE22:
 375:wtpa2bootloader.c **** 					if(CheckBootCrc()==true)	// Read through the image FIRST and make sure the data is not corrupt
 376:wtpa2bootloader.c **** 					{
 377:wtpa2bootloader.c **** 						// Everything checks out.  Write the new application to flash!
 378:wtpa2bootloader.c **** 						SetLeds(0x1F);				// Five LEDs on
 379:wtpa2bootloader.c **** 
 380:wtpa2bootloader.c **** 						bootDataIndex=0;					// Start with first data bytes
 381:wtpa2bootloader.c **** 						blockDataIndex=SD_BLOCK_LENGTH;		// Haven't read in a new block
 382:wtpa2bootloader.c **** 						currentBlock=1;						// Boot data begins in block one (header is in block 0)
 383:wtpa2bootloader.c **** 						ledProgress=0;						// No twinkles yet
 384:wtpa2bootloader.c **** 
 385:wtpa2bootloader.c **** 						while(bootDataIndex<bootDataLength)		// Stay here while there are still bytes left
 386:wtpa2bootloader.c **** 						{
 387:wtpa2bootloader.c **** 							if(blockDataIndex==SD_BLOCK_LENGTH)					// Are we done reading through this block?
 666               		.loc 1 387 0
 667 01de C115      		cp r28,__zero_reg__
 668 01e0 B2E0      		ldi r27,2
 669 01e2 DB07      		cpc r29,r27
 670 01e4 01F4      		brne .L59
 388:wtpa2bootloader.c **** 							{
 389:wtpa2bootloader.c **** 								if(GetSdBlock(currentBlock,&bootBuffer[0]))		// Read in a new block
 671               		.loc 1 389 0
 672 01e6 60E0      		ldi r22,lo8(bootBuffer)
 673 01e8 70E0      		ldi r23,hi8(bootBuffer)
 674 01ea C801      		movw r24,r16
 675 01ec 0E94 0000 		call GetSdBlock
 676               	.LVL59:
 677 01f0 8823      		tst r24
 678 01f2 01F0      		breq .L59
 390:wtpa2bootloader.c **** 								{
 391:wtpa2bootloader.c **** 									currentBlock++;				// Point at the next block
 679               		.loc 1 391 0
 680 01f4 0F5F      		subi r16,-1
 681 01f6 1F4F      		sbci r17,-1
 682               	.LVL60:
 392:wtpa2bootloader.c **** 									blockDataIndex=0;			// Point at first byte of this block
 393:wtpa2bootloader.c **** 
 394:wtpa2bootloader.c **** 									ledProgress++;				// Twinkle three high bits based on reading blocks
 683               		.loc 1 394 0
 684 01f8 B394      		inc r11
 685               	.LVL61:
 395:wtpa2bootloader.c **** 									if(ledProgress>7)
 686               		.loc 1 395 0
 687 01fa E7E0      		ldi r30,lo8(7)
 688 01fc EB15      		cp r30,r11
 689 01fe 00F4      		brsh .L44
 396:wtpa2bootloader.c **** 									{
 397:wtpa2bootloader.c **** 										ledProgress=0;
 690               		.loc 1 397 0
 691 0200 B12C      		mov r11,__zero_reg__
 692               	.LVL62:
 693               	.L44:
 398:wtpa2bootloader.c **** 									}
 399:wtpa2bootloader.c **** 
 400:wtpa2bootloader.c **** 									SetLeds(0x1F|(ledProgress<<5));
 694               		.loc 1 400 0
 695 0202 F0E2      		ldi r31,lo8(32)
 696 0204 BF9E      		mul r11,r31
 697 0206 C001      		movw r24,r0
 698 0208 1124      		clr __zero_reg__
 699 020a 8F61      		ori r24,lo8(31)
 700 020c 0E94 0000 		call SetLeds
 701               	.LVL63:
 392:wtpa2bootloader.c **** 									blockDataIndex=0;			// Point at first byte of this block
 702               		.loc 1 392 0
 703 0210 C0E0      		ldi r28,0
 704 0212 D0E0      		ldi r29,0
 705               	.LVL64:
 706               	.L59:
 401:wtpa2bootloader.c **** 								}
 402:wtpa2bootloader.c **** 								else
 403:wtpa2bootloader.c **** 								{
 404:wtpa2bootloader.c **** 									// Bail; read error
 405:wtpa2bootloader.c **** 								}
 406:wtpa2bootloader.c **** 							}
 407:wtpa2bootloader.c **** 
 408:wtpa2bootloader.c **** 							// We know we have some part of a block.  If there are bytes remaining, erase/fill a page, a
 409:wtpa2bootloader.c ****     						eeprom_busy_wait();					// Make sure we're clear to erase
 707               		.loc 1 409 0 discriminator 1
 708 0214 F999      		sbic 0x1f,1
 709 0216 00C0      		rjmp .L59
 410:wtpa2bootloader.c **** 							boot_page_erase(bootDataIndex);		// Erase the page that INCLUDES this byte address.  Odd, bu
 710               		.loc 1 410 0
 711 0218 C601      		movw r24,r12
 712 021a F601      		movw r30,r12
 713               	/* #APP */
 714               	 ;  410 "wtpa2bootloader.c" 1
 715 021c A092 5700 		sts 87, r10
 716 0220 E895      		spm
 717               		
 718               	 ;  0 "" 2
 719               	/* #NOAPP */
 720               	.L46:
 411:wtpa2bootloader.c ****     						boot_spm_busy_wait();      			// Wait until the memory is erased.
 721               		.loc 1 411 0 discriminator 1
 722 0222 07B6      		in __tmp_reg__,0x37
 723 0224 00FC      		sbrc __tmp_reg__,0
 724 0226 00C0      		rjmp .L46
 725               		.loc 1 411 0 is_stmt 0
 726 0228 20E0      		ldi r18,0
 727 022a 30E0      		ldi r19,0
 329:wtpa2bootloader.c **** int main(void)
 728               		.loc 1 329 0 is_stmt 1
 729 022c AE01      		movw r20,r28
 730 022e 4050      		subi r20,lo8(-(bootBuffer))
 731 0230 5040      		sbci r21,hi8(-(bootBuffer))
 732               	.LVL65:
 733               	.L47:
 329:wtpa2bootloader.c **** int main(void)
 734               		.loc 1 329 0 is_stmt 0 discriminator 2
 735 0232 DA01      		movw r26,r20
 736 0234 A20F      		add r26,r18
 737 0236 B31F      		adc r27,r19
 412:wtpa2bootloader.c **** 
 413:wtpa2bootloader.c **** 							for(i=0; i<SPM_PAGESIZE; i+=2)		// Take the bytes from our buffer and make them into little 
 414:wtpa2bootloader.c **** 							{
 415:wtpa2bootloader.c **** 								tempWord=bootBuffer[blockDataIndex++];			// Make little endian word, and keep block data po
 738               		.loc 1 415 0 is_stmt 1 discriminator 2
 739 0238 6C91      		ld r22,X
 740               	.LVL66:
 329:wtpa2bootloader.c **** int main(void)
 741               		.loc 1 329 0 discriminator 2
 742 023a F901      		movw r30,r18
 743 023c E80F      		add r30,r24
 744 023e F91F      		adc r31,r25
 416:wtpa2bootloader.c **** 								tempWord|=(bootBuffer[blockDataIndex++])<<8;
 745               		.loc 1 416 0 discriminator 2
 746 0240 1196      		adiw r26, 1
 747 0242 9C90      		ld r9,X
 748 0244 812C      		mov r8,__zero_reg__
 749 0246 D401      		movw r26,r8
 750 0248 A62B      		or r26,r22
 751 024a BD01      		movw r22,r26
 752               	.LVL67:
 417:wtpa2bootloader.c **** 								boot_page_fill(bootDataIndex+i,tempWord);		// Put this word in the AVR's dedicated page buf
 753               		.loc 1 417 0 discriminator 2
 754               	/* #APP */
 755               	 ;  417 "wtpa2bootloader.c" 1
 756 024c 0B01      		movw  r0, r22
 757 024e 7092 5700 		sts 87, r7
 758 0252 E895      		spm
 759 0254 1124      		clr  r1
 760               		
 761               	 ;  0 "" 2
 413:wtpa2bootloader.c **** 							for(i=0; i<SPM_PAGESIZE; i+=2)		// Take the bytes from our buffer and make them into little 
 762               		.loc 1 413 0 discriminator 2
 763               	/* #NOAPP */
 764 0256 2E5F      		subi r18,-2
 765 0258 3F4F      		sbci r19,-1
 766               	.LVL68:
 767 025a 2115      		cp r18,__zero_reg__
 768 025c B1E0      		ldi r27,1
 769 025e 3B07      		cpc r19,r27
 770 0260 01F4      		brne .L47
 771 0262 D395      		inc r29
 418:wtpa2bootloader.c **** 							}
 419:wtpa2bootloader.c **** 
 420:wtpa2bootloader.c **** 							boot_page_write(bootDataIndex);			// Write the page from data in the page buffer.  This writ
 772               		.loc 1 420 0
 773 0264 FC01      		movw r30,r24
 774               	/* #APP */
 775               	 ;  420 "wtpa2bootloader.c" 1
 776 0266 6092 5700 		sts 87, r6
 777 026a E895      		spm
 778               		
 779               	 ;  0 "" 2
 780               	/* #NOAPP */
 781               	.L48:
 421:wtpa2bootloader.c **** 							boot_spm_busy_wait();					// Wait for it to be done
 782               		.loc 1 421 0 discriminator 1
 783 026c 07B6      		in __tmp_reg__,0x37
 784 026e 00FC      		sbrc __tmp_reg__,0
 785 0270 00C0      		rjmp .L48
 422:wtpa2bootloader.c **** 							boot_rww_enable();						// Allow the application area to be read again
 786               		.loc 1 422 0
 787               	/* #APP */
 788               	 ;  422 "wtpa2bootloader.c" 1
 789 0272 5092 5700 		sts 87, r5
 790 0276 E895      		spm
 791               		
 792               	 ;  0 "" 2
 423:wtpa2bootloader.c **** 							
 424:wtpa2bootloader.c **** 							bootDataIndex+=SPM_PAGESIZE;			// Increment our absolute address by one page -- NOTE -- this
 793               		.loc 1 424 0
 794               	/* #NOAPP */
 795 0278 FFEF      		ldi r31,-1
 796 027a DF1A      		sub r13,r31
 797 027c EF0A      		sbc r14,r31
 798 027e FF0A      		sbc r15,r31
 799               	.LVL69:
 800               	.L53:
 385:wtpa2bootloader.c **** 						while(bootDataIndex<bootDataLength)		// Stay here while there are still bytes left
 801               		.loc 1 385 0 discriminator 1
 802 0280 8091 0000 		lds r24,bootDataLength
 803 0284 9091 0000 		lds r25,bootDataLength+1
 804 0288 A091 0000 		lds r26,bootDataLength+2
 805 028c B091 0000 		lds r27,bootDataLength+3
 806 0290 C816      		cp r12,r24
 807 0292 D906      		cpc r13,r25
 808 0294 EA06      		cpc r14,r26
 809 0296 FB06      		cpc r15,r27
 810 0298 00F4      		brsh .+2
 811 029a 00C0      		rjmp .L49
 425:wtpa2bootloader.c **** 						}						
 426:wtpa2bootloader.c **** 
 427:wtpa2bootloader.c **** 						// We have bootloaded, and presumably it has been successful!
 428:wtpa2bootloader.c **** 						SetLeds(0xFF);		// Turn on all LEDs
 812               		.loc 1 428 0
 813 029c 8FEF      		ldi r24,lo8(-1)
 814 029e 0E94 0000 		call SetLeds
 815               	.LVL70:
 816               	.L35:
 429:wtpa2bootloader.c **** 					}	
 430:wtpa2bootloader.c **** 				}
 431:wtpa2bootloader.c **** 			}
 432:wtpa2bootloader.c **** 		}
 433:wtpa2bootloader.c **** 
 434:wtpa2bootloader.c **** 		// We were commanded to bootload and made it through some amount of bootloading.
 435:wtpa2bootloader.c **** 		// Wait for some period of time so user can see LED code and tell how far the boot loading proces
 436:wtpa2bootloader.c **** 
 437:wtpa2bootloader.c **** 		HandleSoftclock();
 817               		.loc 1 437 0
 818 02a2 0E94 0000 		call HandleSoftclock
 819               	.LVL71:
 438:wtpa2bootloader.c **** 		tempWord=systemTicks;
 820               		.loc 1 438 0
 821 02a6 C090 0000 		lds r12,systemTicks
 822 02aa D090 0000 		lds r13,systemTicks+1
 823               	.LVL72:
 439:wtpa2bootloader.c **** 		while(systemTicks<(tempWord+SECOND))	// Wait a bit for user to read bootloader status LEDs
 824               		.loc 1 439 0
 825 02ae E12C      		mov r14,__zero_reg__
 826 02b0 F12C      		mov r15,__zero_reg__
 827 02b2 24EC      		ldi r18,-60
 828 02b4 C20E      		add r12,r18
 829 02b6 24E0      		ldi r18,4
 830 02b8 D21E      		adc r13,r18
 831 02ba E11C      		adc r14,__zero_reg__
 832 02bc F11C      		adc r15,__zero_reg__
 833               	.LVL73:
 834 02be 00C0      		rjmp .L50
 835               	.L51:
 440:wtpa2bootloader.c **** 		{
 441:wtpa2bootloader.c **** 			HandleSoftclock();	// Kludgy
 836               		.loc 1 441 0
 837 02c0 0E94 0000 		call HandleSoftclock
 838               	.LVL74:
 839               	.L50:
 439:wtpa2bootloader.c **** 		while(systemTicks<(tempWord+SECOND))	// Wait a bit for user to read bootloader status LEDs
 840               		.loc 1 439 0 discriminator 1
 841 02c4 8091 0000 		lds r24,systemTicks
 842 02c8 9091 0000 		lds r25,systemTicks+1
 843 02cc A0E0      		ldi r26,0
 844 02ce B0E0      		ldi r27,0
 845 02d0 8C15      		cp r24,r12
 846 02d2 9D05      		cpc r25,r13
 847 02d4 AE05      		cpc r26,r14
 848 02d6 BF05      		cpc r27,r15
 849 02d8 00F0      		brlo .L51
 850 02da 00C0      		rjmp .L31
 851               	.LVL75:
 852               	.L30:
 360:wtpa2bootloader.c **** 		SetLeds(0x01);				// Turn on first LED
 853               		.loc 1 360 0
 854 02dc 81E0      		ldi r24,lo8(1)
 855               	.LVL76:
 856 02de 0E94 0000 		call SetLeds
 857               	.LVL77:
 361:wtpa2bootloader.c **** 		if(!(PINC&Im_CARD_DETECT))	// Check to see if a card is inserted
 858               		.loc 1 361 0
 859 02e2 3599      		sbic 0x6,5
 860 02e4 00C0      		rjmp .L35
 861 02e6 00C0      		rjmp .L52
 862               	.LVL78:
 863               	.L42:
 378:wtpa2bootloader.c **** 						SetLeds(0x1F);				// Five LEDs on
 864               		.loc 1 378 0
 865 02e8 8FE1      		ldi r24,lo8(31)
 866               	.LVL79:
 867 02ea 0E94 0000 		call SetLeds
 868               	.LVL80:
 383:wtpa2bootloader.c **** 						ledProgress=0;						// No twinkles yet
 869               		.loc 1 383 0
 870 02ee B12C      		mov r11,__zero_reg__
 382:wtpa2bootloader.c **** 						currentBlock=1;						// Boot data begins in block one (header is in block 0)
 871               		.loc 1 382 0
 872 02f0 01E0      		ldi r16,lo8(1)
 873 02f2 10E0      		ldi r17,0
 874               	.LVL81:
 381:wtpa2bootloader.c **** 						blockDataIndex=SD_BLOCK_LENGTH;		// Haven't read in a new block
 875               		.loc 1 381 0
 876 02f4 C0E0      		ldi r28,0
 877 02f6 D2E0      		ldi r29,lo8(2)
 380:wtpa2bootloader.c **** 						bootDataIndex=0;					// Start with first data bytes
 878               		.loc 1 380 0
 879 02f8 C12C      		mov r12,__zero_reg__
 880 02fa D12C      		mov r13,__zero_reg__
 881 02fc 7601      		movw r14,r12
 882               	.LVL82:
 410:wtpa2bootloader.c **** 							boot_page_erase(bootDataIndex);		// Erase the page that INCLUDES this byte address.  Odd, bu
 883               		.loc 1 410 0
 884 02fe 63E0      		ldi r22,lo8(3)
 885 0300 A62E      		mov r10,r22
 417:wtpa2bootloader.c **** 								boot_page_fill(bootDataIndex+i,tempWord);		// Put this word in the AVR's dedicated page buf
 886               		.loc 1 417 0
 887 0302 7724      		clr r7
 888 0304 7394      		inc r7
 420:wtpa2bootloader.c **** 							boot_page_write(bootDataIndex);			// Write the page from data in the page buffer.  This writ
 889               		.loc 1 420 0
 890 0306 75E0      		ldi r23,lo8(5)
 891 0308 672E      		mov r6,r23
 422:wtpa2bootloader.c **** 							boot_rww_enable();						// Allow the application area to be read again
 892               		.loc 1 422 0
 893 030a E1E1      		ldi r30,lo8(17)
 894 030c 5E2E      		mov r5,r30
 385:wtpa2bootloader.c **** 						while(bootDataIndex<bootDataLength)		// Stay here while there are still bytes left
 895               		.loc 1 385 0
 896 030e 00C0      		rjmp .L53
 897               	.LVL83:
 898               	.L31:
 442:wtpa2bootloader.c **** 		}
 443:wtpa2bootloader.c **** 	}
 444:wtpa2bootloader.c **** 
 445:wtpa2bootloader.c **** 	// Undo what we did to make the bootloader happen
 446:wtpa2bootloader.c **** 	UnInitSdInterface();
 899               		.loc 1 446 0
 900 0310 0E94 0000 		call UnInitSdInterface
 901               	.LVL84:
 902               	.LBB24:
 903               	.LBB25:
  79:wtpa2bootloader.c **** 	TCCR0B=0;			// Stop the timer
 904               		.loc 1 79 0
 905 0314 15BC      		out 0x25,__zero_reg__
  80:wtpa2bootloader.c **** 	PRR|=(1<<PRTIM0);	// Turn the TMR0 power off.
 906               		.loc 1 80 0
 907 0316 8091 6400 		lds r24,100
 908 031a 8062      		ori r24,lo8(32)
 909 031c 8093 6400 		sts 100,r24
 910               	.LBE25:
 911               	.LBE24:
 447:wtpa2bootloader.c **** 	UnInitSoftclock();
 448:wtpa2bootloader.c **** 
 449:wtpa2bootloader.c **** 	// Un init buttons 
 450:wtpa2bootloader.c **** 	// Un init LEDs
 451:wtpa2bootloader.c **** 	
 452:wtpa2bootloader.c **** 	asm volatile("jmp 0000");	// Jump to normal reset vector -- start application
 912               		.loc 1 452 0
 913               	/* #APP */
 914               	 ;  452 "wtpa2bootloader.c" 1
 915 0320 0C94 0000 		jmp 0000
 916               	 ;  0 "" 2
 453:wtpa2bootloader.c **** 	return(0);					// Keep compiler quiet
 454:wtpa2bootloader.c **** }...
 917               		.loc 1 454 0
 918               	/* #NOAPP */
 919 0324 80E0      		ldi r24,0
 920 0326 90E0      		ldi r25,0
 921               	/* epilogue start */
 922 0328 DF91      		pop r29
 923 032a CF91      		pop r28
 924 032c 1F91      		pop r17
 925 032e 0F91      		pop r16
 926 0330 FF90      		pop r15
 927 0332 EF90      		pop r14
 928 0334 DF90      		pop r13
 929 0336 CF90      		pop r12
 930 0338 BF90      		pop r11
 931 033a AF90      		pop r10
 932 033c 9F90      		pop r9
 933 033e 8F90      		pop r8
 934 0340 7F90      		pop r7
 935 0342 6F90      		pop r6
 936 0344 5F90      		pop r5
 937 0346 0895      		ret
 938               		.cfi_endproc
 939               	.LFE9:
 941               		.comm	systemTicks,2,1
 942               		.local	bootBuffer
 943               		.comm	bootBuffer,512,1
 944               		.local	bootDataLength
 945               		.comm	bootDataLength,4,1
 946               		.section	.rodata
 949               	bootHeader:
 950 0000 57        		.byte	87
 951 0001 54        		.byte	84
 952 0002 50        		.byte	80
 953 0003 41        		.byte	65
 954 0004 42        		.byte	66
 955 0005 4F        		.byte	79
 956 0006 4F        		.byte	79
 957 0007 54        		.byte	84
 958               		.local	bootCrc
 959               		.comm	bootCrc,2,1
 960               		.text
 961               	.Letext0:
 962               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 963               		.file 3 "defines.h"
 964               		.file 4 "microSD.h"
DEFINED SYMBOLS
                            *ABS*:00000000 wtpa2bootloader.c
     /tmp/ccZrcVp1.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccZrcVp1.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccZrcVp1.s:4      *ABS*:0000003f __SREG__
     /tmp/ccZrcVp1.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccZrcVp1.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccZrcVp1.s:11     .text:00000000 SetLeds
     /tmp/ccZrcVp1.s:37     .text.unlikely:00000000 UpdateCrc
     /tmp/ccZrcVp1.s:86     .text:0000000c HandleSoftclock
                            *COM*:00000002 systemTicks
     /tmp/ccZrcVp1.s:115    .text:00000026 GetSdBlock
     /tmp/ccZrcVp1.s:279    .text.startup:00000000 main
                             .bss:00000000 bootBuffer
     /tmp/ccZrcVp1.s:949    .rodata:00000000 bootHeader
     /tmp/ccZrcVp1.s:943    .bss:00000200 bootDataLength
     /tmp/ccZrcVp1.s:945    .bss:00000204 bootCrc

UNDEFINED SYMBOLS
SdBeginSingleBlockRead
TransferSdByte
EndSdTransfer
InitSdInterface
SdHandshake
UnInitSdInterface
__do_copy_data
__do_clear_bss
