   1               		.file	"midi.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	GetMidiMessageFromIncomingFifo
  12               	GetMidiMessageFromIncomingFifo:
  13               	.LFB1:
  14               		.file 1 "midi.c"
   1:midi.c        **** // MIDI Library for WTPA.
   2:midi.c        **** // There's a lot of MIDI crap implemented here, but there's always room for more.
   3:midi.c        **** // Wed Dec  3 20:28:45 CST 2008
   4:midi.c        **** 
   5:midi.c        **** // Fri Apr 10 13:12:15 CDT 2009
   6:midi.c        **** // Added multiple channel support (two, currently) and updated the idea of MIDI_MESSAGE to support 
   7:midi.c        **** // Used for WTPA.
   8:midi.c        **** 
   9:midi.c        **** // 	Sun Apr 12 17:28:45 CDT 2009
  10:midi.c        **** //	Changed MIDI stack to bail on any running status if it gets a status byte it doesn't understand 
  11:midi.c        **** 
  12:midi.c        **** #include "includes.h"
  13:midi.c        **** 
  14:midi.c        **** // Programming Defines and Variables:
  15:midi.c        **** //-------------------------------------
  16:midi.c        **** // (The canonical list of message types is in midi.h)
  17:midi.c        **** 
  18:midi.c        **** MIDI_MESSAGE
  19:midi.c        **** 	midiMessageIncomingFifo[MIDI_MESSAGE_INCOMING_FIFO_SIZE];		// Make an array of MIDI_MESSAGE struct
  20:midi.c        **** MIDI_MESSAGE
  21:midi.c        **** 	midiMessageOutgoingFifo[MIDI_MESSAGE_OUTGOING_FIFO_SIZE];		// Make an array of MIDI_MESSAGE struct
  22:midi.c        **** 
  23:midi.c        **** /*
  24:midi.c        **** enum					// How many channels are we interpreting?  This data is passed to the midi handler / sound
  25:midi.c        **** {
  26:midi.c        **** 	MIDI_CHANNEL_A=0,
  27:midi.c        **** 	MIDI_CHANNEL_B,
  28:midi.c        **** 	MIDI_CHANNEL_ALL,
  29:midi.c        **** };
  30:midi.c        **** */
  31:midi.c        **** 
  32:midi.c        **** unsigned char
  33:midi.c        **** 	midiChannelNumberA,				// This is one midi channel our hardware is assigned to -- @@@ make this an
  34:midi.c        **** 	midiChannelNumberB,				// This is one midi channel our hardware is assigned to.
  35:midi.c        **** 	midiMessagesInIncomingFifo,		// How many messages in the rx queue?
  36:midi.c        **** 	midiMessagesInOutgoingFifo;		// How many messages in the tx queue?
  37:midi.c        **** 
  38:midi.c        **** static unsigned char
  39:midi.c        **** 	midiIncomingFifoWritePointer,	// Where is our next write going in the fifo?
  40:midi.c        **** 	midiIncomingFifoReadPointer,	// Where is our next read coming from in the fifo?
  41:midi.c        **** 	midiIncomingMessageState;		// Keeps track of the state out MIDI message receiving routine is in.
  42:midi.c        **** 
  43:midi.c        **** static unsigned char
  44:midi.c        **** 	midiOutgoingFifoWritePointer,	// Where is our next write going in the fifo?
  45:midi.c        **** 	midiOutgoingFifoReadPointer,	// Where is our next read coming from in the fifo?
  46:midi.c        **** 	midiOutgoingMessageState;		// Keeps track of the state out MIDI message receiving routine is in.
  47:midi.c        **** 
  48:midi.c        **** //-----------------------------------------------------------------------
  49:midi.c        **** //-----------------------------------------------------------------------
  50:midi.c        **** // MIDI Functions.
  51:midi.c        **** //-----------------------------------------------------------------------
  52:midi.c        **** //-----------------------------------------------------------------------
  53:midi.c        **** void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
  54:midi.c        **** // Returns an entire 3-byte midi message if there are any in the fifo.
  55:midi.c        **** // If there are no messages in the fifo, do nothing.
  56:midi.c        **** // These "midi messages" have been formatted to something that makes sense to the sampler from the 
  57:midi.c        **** // Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timb
  58:midi.c        **** {
  15               		.loc 1 58 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 DC01      		movw r26,r24
  59:midi.c        **** 	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
  23               		.loc 1 59 0
  24 0002 8091 0000 		lds r24,midiMessagesInIncomingFifo
  25               	.LVL1:
  26 0006 8823      		tst r24
  27 0008 01F0      		breq .L1
  60:midi.c        **** 	{
  61:midi.c        **** 		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// G
  28               		.loc 1 61 0
  29 000a 9091 0000 		lds r25,midiIncomingFifoReadPointer
  30 000e E92F      		mov r30,r25
  31 0010 F0E0      		ldi r31,0
  32 0012 EE0F      		lsl r30
  33 0014 FF1F      		rol r31
  34 0016 EE0F      		lsl r30
  35 0018 FF1F      		rol r31
  36 001a E050      		subi r30,lo8(-(midiMessageIncomingFifo))
  37 001c F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
  38 001e 2181      		ldd r18,Z+1
  39 0020 1196      		adiw r26,1
  40 0022 2C93      		st X,r18
  41 0024 1197      		sbiw r26,1
  62:midi.c        **** 		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
  42               		.loc 1 62 0
  43 0026 2281      		ldd r18,Z+2
  44 0028 1296      		adiw r26,2
  45 002a 2C93      		st X,r18
  46 002c 1297      		sbiw r26,2
  63:midi.c        **** 		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
  47               		.loc 1 63 0
  48 002e 2381      		ldd r18,Z+3
  49 0030 1396      		adiw r26,3
  50 0032 2C93      		st X,r18
  51 0034 1397      		sbiw r26,3
  64:midi.c        **** 		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
  52               		.loc 1 64 0
  53 0036 2081      		ld r18,Z
  54 0038 2C93      		st X,r18
  65:midi.c        **** 
  66:midi.c        **** 		midiIncomingFifoReadPointer++;			// read from the next element next time
  55               		.loc 1 66 0
  56 003a 9F5F      		subi r25,lo8(-(1))
  67:midi.c        **** 		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
  57               		.loc 1 67 0
  58 003c 9630      		cpi r25,lo8(6)
  59 003e 00F4      		brsh .L3
  66:midi.c        **** 		midiIncomingFifoReadPointer++;			// read from the next element next time
  60               		.loc 1 66 0
  61 0040 9093 0000 		sts midiIncomingFifoReadPointer,r25
  62               	.L4:
  68:midi.c        **** 		{
  69:midi.c        **** 			midiIncomingFifoReadPointer=0;
  70:midi.c        **** 		}
  71:midi.c        **** 
  72:midi.c        **** 		midiMessagesInIncomingFifo--;		// One less message in the fifo.
  63               		.loc 1 72 0
  64 0044 8150      		subi r24,lo8(-(-1))
  65 0046 8093 0000 		sts midiMessagesInIncomingFifo,r24
  66               	.L1:
  67 004a 0895      		ret
  68               	.L3:
  69:midi.c        **** 			midiIncomingFifoReadPointer=0;
  69               		.loc 1 69 0
  70 004c 1092 0000 		sts midiIncomingFifoReadPointer,__zero_reg__
  71 0050 00C0      		rjmp .L4
  72               		.cfi_endproc
  73               	.LFE1:
  75               	.global	PutMidiMessageInOutgoingFifo
  77               	PutMidiMessageInOutgoingFifo:
  78               	.LFB4:
  73:midi.c        **** 	}
  74:midi.c        **** }
  75:midi.c        **** 
  76:midi.c        **** static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
  77:midi.c        **** // If there is room in the fifo, put a MIDI message into it.
  78:midi.c        **** // If the fifo is full, don't do anything.
  79:midi.c        **** {
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
  81:midi.c        **** 	{
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
  86:midi.c        **** 	
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
  89:midi.c        **** 		{
  90:midi.c        **** 			midiIncomingFifoWritePointer=0;
  91:midi.c        **** 		}
  92:midi.c        **** 		
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
  94:midi.c        **** 	}
  95:midi.c        **** }
  96:midi.c        **** 
  97:midi.c        **** static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
  98:midi.c        **** // Returns the data the sampler put into the output fifo.  This is generalized data and is turned i
  99:midi.c        **** // If there are no messages in the fifo, do nothing.
 100:midi.c        **** {
 101:midi.c        **** 	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
 102:midi.c        **** 	{
 103:midi.c        **** 		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// G
 104:midi.c        **** 		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
 105:midi.c        **** 		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
 106:midi.c        **** 		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
 107:midi.c        **** 
 108:midi.c        **** 		midiOutgoingFifoReadPointer++;										// read from the next element next time
 109:midi.c        **** 		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
 110:midi.c        **** 		{
 111:midi.c        **** 			midiOutgoingFifoReadPointer=0;
 112:midi.c        **** 		}
 113:midi.c        **** 
 114:midi.c        **** 		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
 115:midi.c        **** 	}
 116:midi.c        **** }
 117:midi.c        **** 
 118:midi.c        **** void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char th
 119:midi.c        **** // If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of 
 120:midi.c        **** // The format for passing in variables is slightly different as well (we use variables and not a po
 121:midi.c        **** // If the fifo is full, don't do anything.
 122:midi.c        **** {
  79               		.loc 1 122 0
  80               		.cfi_startproc
  81               	.LVL2:
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 123:midi.c        **** 	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
  86               		.loc 1 123 0
  87 0052 9091 0000 		lds r25,midiMessagesInOutgoingFifo
  88 0056 9630      		cpi r25,lo8(6)
  89 0058 00F4      		brsh .L9
 124:midi.c        **** 	{
 125:midi.c        **** 		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
  90               		.loc 1 125 0
  91 005a 3091 0000 		lds r19,midiOutgoingFifoWritePointer
  92 005e E32F      		mov r30,r19
  93 0060 F0E0      		ldi r31,0
  94 0062 EE0F      		lsl r30
  95 0064 FF1F      		rol r31
  96 0066 EE0F      		lsl r30
  97 0068 FF1F      		rol r31
  98 006a E050      		subi r30,lo8(-(midiMessageOutgoingFifo))
  99 006c F040      		sbci r31,hi8(-(midiMessageOutgoingFifo))
 100 006e 6183      		std Z+1,r22
 126:midi.c        **** 		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
 101               		.loc 1 126 0
 102 0070 4283      		std Z+2,r20
 127:midi.c        **** 		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
 103               		.loc 1 127 0
 104 0072 2383      		std Z+3,r18
 128:midi.c        **** 		if(theBank==BANK_0)
 129:midi.c        **** 		{
 130:midi.c        **** 			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
 131:midi.c        **** 		}
 132:midi.c        **** 		else
 133:midi.c        **** 		{
 134:midi.c        **** 			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
 105               		.loc 1 134 0
 106 0074 8091 0000 		lds r24,midiChannelNumberA
 107               	.LVL3:
 108 0078 8083      		st Z,r24
 135:midi.c        **** 		}
 136:midi.c        **** 	
 137:midi.c        **** 		midiOutgoingFifoWritePointer++;			// write to the next element next time
 109               		.loc 1 137 0
 110 007a 3F5F      		subi r19,lo8(-(1))
 138:midi.c        **** 		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
 111               		.loc 1 138 0
 112 007c 3630      		cpi r19,lo8(6)
 113 007e 00F4      		brsh .L13
 137:midi.c        **** 		midiOutgoingFifoWritePointer++;			// write to the next element next time
 114               		.loc 1 137 0
 115 0080 3093 0000 		sts midiOutgoingFifoWritePointer,r19
 116               	.L14:
 139:midi.c        **** 		{
 140:midi.c        **** 			midiOutgoingFifoWritePointer=0;
 141:midi.c        **** 		}
 142:midi.c        **** 		
 143:midi.c        **** 		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
 117               		.loc 1 143 0
 118 0084 9F5F      		subi r25,lo8(-(1))
 119 0086 9093 0000 		sts midiMessagesInOutgoingFifo,r25
 120               	.L9:
 121 008a 0895      		ret
 122               	.L13:
 140:midi.c        **** 			midiOutgoingFifoWritePointer=0;
 123               		.loc 1 140 0
 124 008c 1092 0000 		sts midiOutgoingFifoWritePointer,__zero_reg__
 125 0090 00C0      		rjmp .L14
 126               		.cfi_endproc
 127               	.LFE4:
 129               	.global	InitMidi
 131               	InitMidi:
 132               	.LFB7:
 144:midi.c        **** 	}
 145:midi.c        **** }
 146:midi.c        **** 
 147:midi.c        **** static void InitMidiIncomingFifo(void)
 148:midi.c        **** // Initialize the MIDI receive fifo to empty.
 149:midi.c        **** {
 150:midi.c        **** 	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
 151:midi.c        **** 	midiIncomingFifoWritePointer=0;		// Next write is to 0.
 152:midi.c        **** 	midiIncomingFifoReadPointer=0;		// Next read is at 0.
 153:midi.c        **** }
 154:midi.c        **** 
 155:midi.c        **** static void InitMidiOutgoingFifo(void)
 156:midi.c        **** // Initialize the MIDI transmit fifo to empty.
 157:midi.c        **** {
 158:midi.c        **** 	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
 159:midi.c        **** 	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
 160:midi.c        **** 	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
 161:midi.c        **** }
 162:midi.c        **** 
 163:midi.c        **** void InitMidi(void)
 164:midi.c        **** {
 133               		.loc 1 164 0
 134               		.cfi_startproc
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
 165:midi.c        **** 	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We ne
 139               		.loc 1 165 0
 140 0092 89E0      		ldi r24,lo8(9)
 141 0094 8093 0000 		sts midiIncomingMessageState,r24
 166:midi.c        **** 	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending by
 142               		.loc 1 166 0
 143 0098 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 144               	.LBB6:
 145               	.LBB7:
 150:midi.c        **** 	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
 146               		.loc 1 150 0
 147 009c 1092 0000 		sts midiMessagesInIncomingFifo,__zero_reg__
 151:midi.c        **** 	midiIncomingFifoWritePointer=0;		// Next write is to 0.
 148               		.loc 1 151 0
 149 00a0 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 152:midi.c        **** 	midiIncomingFifoReadPointer=0;		// Next read is at 0.
 150               		.loc 1 152 0
 151 00a4 1092 0000 		sts midiIncomingFifoReadPointer,__zero_reg__
 152               	.LBE7:
 153               	.LBE6:
 154               	.LBB8:
 155               	.LBB9:
 158:midi.c        **** 	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
 156               		.loc 1 158 0
 157 00a8 1092 0000 		sts midiMessagesInOutgoingFifo,__zero_reg__
 159:midi.c        **** 	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
 158               		.loc 1 159 0
 159 00ac 1092 0000 		sts midiOutgoingFifoWritePointer,__zero_reg__
 160:midi.c        **** 	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
 160               		.loc 1 160 0
 161 00b0 1092 0000 		sts midiOutgoingFifoReadPointer,__zero_reg__
 162 00b4 0895      		ret
 163               	.LBE9:
 164               	.LBE8:
 165               		.cfi_endproc
 166               	.LFE7:
 168               	.global	HandleIncomingMidiByte
 170               	HandleIncomingMidiByte:
 171               	.LFB8:
 167:midi.c        **** 	InitMidiIncomingFifo();								// Set up the receiving buffer.
 168:midi.c        **** 	InitMidiOutgoingFifo();								// Set up xmit buffer.
 169:midi.c        **** }
 170:midi.c        **** 
 171:midi.c        **** void HandleIncomingMidiByte(unsigned char theByte)
 172:midi.c        **** // In this routine we sort out the bytes coming in over the UART and decide what to do.  It is stat
 173:midi.c        **** // This function allows for us to either act on received messages OR just toss them out and keep th
 174:midi.c        **** // more than a MIDI byte time.
 175:midi.c        **** // NOTE:  We don't (yet) account for all the types of MIDI messages that exist in the world -- righ
 176:midi.c        **** // and what would be useful for CyberTracker to receive, because that's what I'm working with.  A l
 177:midi.c        **** // This function is fed incoming midi bytes from the UART.  First, we check to see if the byte is a
 178:midi.c        **** // type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see
 179:midi.c        **** // So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes un
 180:midi.c        **** // This allows for expansion to handle different types of status messages, and makes sure we can ha
 181:midi.c        **** // Real time messages don't mung up the channel message state machine (they don't break running sta
 182:midi.c        **** // According to the MIDI spec, any voice / channel message should allow for running status, but it 
 183:midi.c        **** {
 172               		.loc 1 183 0
 173               		.cfi_startproc
 174               	.LVL4:
 175               	/* prologue: function */
 176               	/* frame size = 0 */
 177               	/* stack size = 0 */
 178               	.L__stack_usage = 0
 184:midi.c        **** 	static unsigned char	// Use this to store the first data byte of a midi message while we get the s
 185:midi.c        **** 		firstDataByte;
 186:midi.c        **** 	static unsigned char
 187:midi.c        **** 		temporaryChannel;	// Use this to store the channel we think we're going to update while we collec
 188:midi.c        **** 
 189:midi.c        **** 	MIDI_MESSAGE
 190:midi.c        **** 		theMessage;
 191:midi.c        **** 	
 192:midi.c        **** 	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status
 179               		.loc 1 192 0
 180 00b6 87FD      		sbrc r24,7
 181 00b8 00C0      		rjmp .L70
 193:midi.c        **** 	{
 194:midi.c        **** /*
 195:midi.c        **** 		// Check now to see if this is a system message which is applicable to all MIDI channels.
 196:midi.c        **** 		// For now we only handle these Real Time messages: Timing Clock, Start, and Stop.  Real time mes
 197:midi.c        **** 		// @@@ When we implement these realtime messages we will need to implement a theMessage.channelNu
 198:midi.c        **** 
 199:midi.c        **** 		if(theByte==MIDI_TIMING_CLOCK)
 200:midi.c        **** 		{
 201:midi.c        **** //			UpdateMidiClock();				// @@@ Unimplemented.		
 202:midi.c        **** 		}
 203:midi.c        **** 		else if(theByte==MIDI_REAL_TIME_START)
 204:midi.c        **** 		{
 205:midi.c        **** 			// Queue midi message
 206:midi.c        **** //			theMessage.messageType=MESSAGE_TYPE_MIDI_START;		// What kind of message is this?
 207:midi.c        **** //			theMessage.dataByteOne=0;							// No databytes.
 208:midi.c        **** //			theMessage.dataByteTwo=0;							// And what velocity?
 209:midi.c        **** 
 210:midi.c        **** //			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 211:midi.c        **** 		}
 212:midi.c        **** 		else if(theByte==MIDI_REAL_TIME_STOP)
 213:midi.c        **** 		{
 214:midi.c        **** 			// Queue midi message
 215:midi.c        **** //			theMessage.messageType=MESSAGE_TYPE_MIDI_STOP;		// What kind of message is this?
 216:midi.c        **** //			theMessage.dataByteOne=0;							// No databytes.
 217:midi.c        **** //			theMessage.dataByteTwo=0;							// And what velocity?
 218:midi.c        **** 
 219:midi.c        **** //			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 220:midi.c        **** 		}		
 221:midi.c        **** 
 222:midi.c        **** 		// Not a system message we care about.  Channel / Voice Message on our channel?
 223:midi.c        **** */
 224:midi.c        **** 		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talkin
 225:midi.c        **** 		{
 226:midi.c        **** 			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
 227:midi.c        **** 			{
 228:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON sta
 229:midi.c        **** 
 230:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 231:midi.c        **** 				{
 232:midi.c        **** 					temporaryChannel=BANK_0;
 233:midi.c        **** 				}
 234:midi.c        **** 				else
 235:midi.c        **** 				{
 236:midi.c        **** 					temporaryChannel=BANK_1;
 237:midi.c        **** 				}
 238:midi.c        **** 			}
 239:midi.c        **** 			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
 240:midi.c        **** 			{
 241:midi.c        **** 				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes
 242:midi.c        **** 
 243:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 244:midi.c        **** 				{
 245:midi.c        **** 					temporaryChannel=BANK_0;
 246:midi.c        **** 				}
 247:midi.c        **** 				else
 248:midi.c        **** 				{
 249:midi.c        **** 					temporaryChannel=BANK_1;
 250:midi.c        **** 				}
 251:midi.c        **** 			}
 252:midi.c        **** 			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
 253:midi.c        **** 			{
 254:midi.c        **** 				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applie
 255:midi.c        **** 
 256:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 257:midi.c        **** 				{
 258:midi.c        **** 					temporaryChannel=BANK_0;
 259:midi.c        **** 				}
 260:midi.c        **** 				else
 261:midi.c        **** 				{
 262:midi.c        **** 					temporaryChannel=BANK_1;
 263:midi.c        **** 				}
 264:midi.c        **** 			}
 265:midi.c        **** 			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two
 266:midi.c        **** 			{
 267:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status app
 268:midi.c        **** 
 269:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 270:midi.c        **** 				{
 271:midi.c        **** 					temporaryChannel=BANK_0;
 272:midi.c        **** 				}
 273:midi.c        **** 				else
 274:midi.c        **** 				{
 275:midi.c        **** 					temporaryChannel=BANK_1;
 276:midi.c        **** 				}
 277:midi.c        **** 			}
 278:midi.c        **** 			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes
 279:midi.c        **** 			{
 280:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AF
 281:midi.c        **** 
 282:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 283:midi.c        **** 				{
 284:midi.c        **** 					temporaryChannel=BANK_0;
 285:midi.c        **** 				}
 286:midi.c        **** 				else
 287:midi.c        **** 				{
 288:midi.c        **** 					temporaryChannel=BANK_1;
 289:midi.c        **** 				}
 290:midi.c        **** 			}			
 291:midi.c        **** 			else
 292:midi.c        **** 			{
 293:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;		// We don't understand this status byte, so drop out of ru
 294:midi.c        **** 			}
 295:midi.c        **** 		}	
 296:midi.c        **** 		else
 297:midi.c        **** 		{
 298:midi.c        **** 			midiIncomingMessageState=IGNORE_ME;		// Message is for a different channel, or otherwise unloved
 299:midi.c        **** 		}
 300:midi.c        **** 	}
 301:midi.c        **** 	else
 302:midi.c        **** 	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data byte
 303:midi.c        **** 	{
 304:midi.c        **** 		switch(midiIncomingMessageState)
 182               		.loc 1 304 0
 183 00ba 9091 0000 		lds r25,midiIncomingMessageState
 184 00be 9430      		cpi r25,lo8(4)
 185 00c0 01F4      		brne .+2
 186 00c2 00C0      		rjmp .L36
 187 00c4 00F0      		brlo .L71
 188 00c6 9730      		cpi r25,lo8(7)
 189 00c8 01F4      		brne .+2
 190 00ca 00C0      		rjmp .L39
 191 00cc 00F0      		brlo .+2
 192 00ce 00C0      		rjmp .L42
 193 00d0 9530      		cpi r25,lo8(5)
 194 00d2 01F4      		brne .+2
 195 00d4 00C0      		rjmp .L37
 196 00d6 9630      		cpi r25,lo8(6)
 197 00d8 01F4      		brne .L31
 305:midi.c        **** 		{
 306:midi.c        **** 			case GET_NOTE_ON_DATA_BYTE_ONE:				// Get the note value for the NOTE_ON.
 307:midi.c        **** 			if(theByte>127)								// SHOULD NEVER  HAPPEN.  If the note value is out of range (a status byt
 308:midi.c        **** 			{
 309:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 310:midi.c        **** 			}
 311:midi.c        **** 			else
 312:midi.c        **** 			{
 313:midi.c        **** 				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the veloc
 314:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
 315:midi.c        **** 			}
 316:midi.c        **** 			break;
 317:midi.c        **** 
 318:midi.c        **** 			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note 
 319:midi.c        **** 			if(theByte==0)									// This "note on" is really a "note off".
 320:midi.c        **** 			{
 321:midi.c        **** 				// Queue midi message
 322:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
 323:midi.c        **** 				theMessage.dataByteOne=firstDataByte;				// For what note?
 324:midi.c        **** 				theMessage.dataByteTwo=theByte;						// And what velocity?
 325:midi.c        **** 				theMessage.channelNumber=temporaryChannel;			// And what channel?
 326:midi.c        **** 
 327:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 328:midi.c        **** 	
 329:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;	// And continue dealing with NOTE_ONs until
 330:midi.c        **** 			}
 331:midi.c        **** 			else if(theByte>127)
 332:midi.c        **** 			{
 333:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is inva
 334:midi.c        **** 			}
 335:midi.c        **** 			else											// Real note on, real value.
 336:midi.c        **** 			{
 337:midi.c        **** 				// Queue midi message
 338:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
 339:midi.c        **** 				theMessage.dataByteOne=firstDataByte;			// For what note?
 340:midi.c        **** 				theMessage.dataByteTwo=theByte;					// And what velocity?
 341:midi.c        **** 				theMessage.channelNumber=temporaryChannel;		// And what channel?
 342:midi.c        **** 
 343:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 344:midi.c        **** 
 345:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until
 346:midi.c        **** 			}
 347:midi.c        **** 			break;
 348:midi.c        **** 
 349:midi.c        **** 			case GET_NOTE_OFF_DATA_BYTE_ONE:			// Get the note value to turn off, check validity.
 350:midi.c        **** 			if(theByte>127)								// If the note value is out of range, ignore and wait for new status. 
 351:midi.c        **** 			{
 352:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 353:midi.c        **** 			}
 354:midi.c        **** 			else
 355:midi.c        **** 			{
 356:midi.c        **** 				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
 357:midi.c        **** 				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
 358:midi.c        **** 			}		
 359:midi.c        **** 			break;
 360:midi.c        **** 
 361:midi.c        **** 			case GET_NOTE_OFF_DATA_BYTE_TWO:			// Get a valid velocity and turn the note off.
 362:midi.c        **** 			if(theByte>127)								// If the note value is out of range, ignore and wait for new status. 
 363:midi.c        **** 			{
 364:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 365:midi.c        **** 			}
 366:midi.c        **** 			else
 367:midi.c        **** 			{
 368:midi.c        **** 				// Queue midi message
 369:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
 370:midi.c        **** 				theMessage.dataByteOne=firstDataByte;				// For what note?
 198               		.loc 1 370 0
 199 00da 4091 0000 		lds r20,firstDataByte.1692
 371:midi.c        **** 				theMessage.dataByteTwo=theByte;						// And what velocity?
 372:midi.c        **** 				theMessage.channelNumber=temporaryChannel;			// And what channel?
 200               		.loc 1 372 0
 201 00de 3091 0000 		lds r19,temporaryChannel.1693
 202               	.LVL5:
 203               	.LBB22:
 204               	.LBB23:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 205               		.loc 1 80 0
 206 00e2 9091 0000 		lds r25,midiMessagesInIncomingFifo
 207 00e6 9630      		cpi r25,lo8(6)
 208 00e8 00F4      		brsh .L50
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 209               		.loc 1 82 0
 210 00ea 2091 0000 		lds r18,midiIncomingFifoWritePointer
 211 00ee E22F      		mov r30,r18
 212 00f0 F0E0      		ldi r31,0
 213 00f2 EE0F      		lsl r30
 214 00f4 FF1F      		rol r31
 215 00f6 EE0F      		lsl r30
 216 00f8 FF1F      		rol r31
 217 00fa E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 218 00fc F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 219 00fe 52E0      		ldi r21,lo8(2)
 220 0100 5183      		std Z+1,r21
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 221               		.loc 1 83 0
 222 0102 4283      		std Z+2,r20
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 223               		.loc 1 84 0
 224 0104 8383      		std Z+3,r24
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 225               		.loc 1 85 0
 226 0106 3083      		st Z,r19
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 227               		.loc 1 87 0
 228 0108 2F5F      		subi r18,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 229               		.loc 1 88 0
 230 010a 2630      		cpi r18,lo8(6)
 231 010c 00F0      		brlo .+2
 232 010e 00C0      		rjmp .L51
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 233               		.loc 1 87 0
 234 0110 2093 0000 		sts midiIncomingFifoWritePointer,r18
 235               	.L52:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 236               		.loc 1 93 0
 237 0114 9F5F      		subi r25,lo8(-(1))
 238 0116 9093 0000 		sts midiMessagesInIncomingFifo,r25
 239               	.L50:
 240               	.LBE23:
 241               	.LBE22:
 373:midi.c        **** 
 374:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 375:midi.c        **** 
 376:midi.c        **** 				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs unt
 242               		.loc 1 376 0
 243 011a 81E0      		ldi r24,lo8(1)
 244               	.LVL6:
 245 011c 8093 0000 		sts midiIncomingMessageState,r24
 246 0120 0895      		ret
 247               	.LVL7:
 248               	.L71:
 304:midi.c        **** 		switch(midiIncomingMessageState)
 249               		.loc 1 304 0
 250 0122 9130      		cpi r25,lo8(1)
 251 0124 01F4      		brne .+2
 252 0126 00C0      		rjmp .L33
 253 0128 00F4      		brsh .L72
 313:midi.c        **** 				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the veloc
 254               		.loc 1 313 0
 255 012a 8093 0000 		sts firstDataByte.1692,r24
 314:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
 256               		.loc 1 314 0
 257 012e 85E0      		ldi r24,lo8(5)
 258               	.LVL8:
 259 0130 8093 0000 		sts midiIncomingMessageState,r24
 260 0134 0895      		ret
 261               	.LVL9:
 262               	.L70:
 224:midi.c        **** 		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talkin
 263               		.loc 1 224 0
 264 0136 982F      		mov r25,r24
 265 0138 9F70      		andi r25,lo8(15)
 266 013a 2091 0000 		lds r18,midiChannelNumberA
 267 013e 2917      		cp r18,r25
 268 0140 01F0      		breq .L18
 224:midi.c        **** 		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talkin
 269               		.loc 1 224 0 is_stmt 0 discriminator 1
 270 0142 3091 0000 		lds r19,midiChannelNumberB
 271 0146 3917      		cp r19,r25
 272 0148 01F0      		breq .L18
 273               	.LVL10:
 274               	.L31:
 377:midi.c        **** 			}		
 378:midi.c        **** 			break;
 379:midi.c        **** 		
 380:midi.c        **** 			case GET_PROGRAM_CHANGE_DATA_BYTE:			// We got a request for program change.  Check validity and
 381:midi.c        **** 			if(theByte>127)								// If the note value is out of range, ignore and wait for new status. 
 382:midi.c        **** 			{
 383:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 384:midi.c        **** 			}
 385:midi.c        **** 			else
 386:midi.c        **** 			{
 387:midi.c        **** 				// Queue midi message
 388:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
 389:midi.c        **** 				theMessage.dataByteOne=theByte;							// ...To this program
 390:midi.c        **** 				theMessage.dataByteTwo=0;								// And no second data byte.
 391:midi.c        **** 				theMessage.channelNumber=temporaryChannel;				// And what channel?
 392:midi.c        **** 				
 393:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
 394:midi.c        **** 
 395:midi.c        **** 				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// AFAICT, theoretically, program change
 396:midi.c        **** 			}		
 397:midi.c        **** 			break;
 398:midi.c        **** 
 399:midi.c        **** 			case GET_CONTROL_CHANGE_CONTROLLER_NUM:			// Get the controller number, check validity.
 400:midi.c        **** 			if(theByte>127)									// If the value is out of range, ignore and wait for new status. 
 401:midi.c        **** 			{
 402:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 403:midi.c        **** 			}
 404:midi.c        **** 			else
 405:midi.c        **** 			{
 406:midi.c        **** 				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
 407:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
 408:midi.c        **** 			}		
 409:midi.c        **** 			break;
 410:midi.c        **** 
 411:midi.c        **** 			case GET_CONTROL_CHANGE_VALUE:				// Get a valid value and queue it.
 412:midi.c        **** 			if(theByte>127)								// If the value is out of range, ignore and wait for new status. 
 413:midi.c        **** 			{
 414:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 415:midi.c        **** 			}
 416:midi.c        **** 			else
 417:midi.c        **** 			{
 418:midi.c        **** 				// Queue midi message
 419:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
 420:midi.c        **** 				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
 421:midi.c        **** 				theMessage.dataByteTwo=theByte;							// And the value.
 422:midi.c        **** 				theMessage.channelNumber=temporaryChannel;				// And what channel?
 423:midi.c        **** 
 424:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
 425:midi.c        **** 
 426:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status 
 427:midi.c        **** 			}		
 428:midi.c        **** 			break;
 429:midi.c        **** 
 430:midi.c        **** 			case GET_PITCH_WHEEL_DATA_LSB:				// Began wanking on pitch wheel, check validity.
 431:midi.c        **** 			if(theByte>127)								// If the note value is out of range, ignore and wait for new status. 
 432:midi.c        **** 			{
 433:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 434:midi.c        **** 			}
 435:midi.c        **** 			else
 436:midi.c        **** 			{
 437:midi.c        **** 				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
 438:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
 439:midi.c        **** 			}		
 440:midi.c        **** 			break;
 441:midi.c        **** 
 442:midi.c        **** 			case GET_PITCH_WHEEL_DATA_MSB:				// Get a valid MSB and queue.
 443:midi.c        **** 			if(theByte>127)								// If the note value is out of range, ignore and wait for new status. 
 444:midi.c        **** 			{
 445:midi.c        **** 				midiIncomingMessageState=IGNORE_ME;
 446:midi.c        **** 			}
 447:midi.c        **** 			else
 448:midi.c        **** 			{
 449:midi.c        **** 				// Queue midi message
 450:midi.c        **** 				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
 451:midi.c        **** 				theMessage.dataByteOne=firstDataByte;				// LSB
 452:midi.c        **** 				theMessage.dataByteTwo=theByte;						// MSB
 453:midi.c        **** 				theMessage.channelNumber=temporaryChannel;			// And what channel?
 454:midi.c        **** 
 455:midi.c        **** 				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
 456:midi.c        **** 
 457:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel w
 458:midi.c        **** 			}		
 459:midi.c        **** 			break;
 460:midi.c        **** 
 461:midi.c        **** 
 462:midi.c        **** 			case IGNORE_ME:
 463:midi.c        **** 			// Don't do anything with the byte; it isn't something we care about.
 464:midi.c        **** 			break;
 465:midi.c        **** 
 466:midi.c        **** 			default:
 467:midi.c        **** 			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
 275               		.loc 1 467 0 is_stmt 1
 276 014a 89E0      		ldi r24,lo8(9)
 277 014c 8093 0000 		sts midiIncomingMessageState,r24
 278 0150 0895      		ret
 279               	.LVL11:
 280               	.L18:
 226:midi.c        **** 			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
 281               		.loc 1 226 0
 282 0152 807F      		andi r24,lo8(-16)
 283               	.LVL12:
 284 0154 8039      		cpi r24,lo8(-112)
 285 0156 01F4      		brne .+2
 286 0158 00C0      		rjmp .L73
 239:midi.c        **** 			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
 287               		.loc 1 239 0
 288 015a 8038      		cpi r24,lo8(-128)
 289 015c 01F4      		brne .+2
 290 015e 00C0      		rjmp .L74
 252:midi.c        **** 			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
 291               		.loc 1 252 0
 292 0160 803C      		cpi r24,lo8(-64)
 293 0162 01F4      		brne .+2
 294 0164 00C0      		rjmp .L75
 265:midi.c        **** 			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two
 295               		.loc 1 265 0
 296 0166 803E      		cpi r24,lo8(-32)
 297 0168 01F4      		brne .+2
 298 016a 00C0      		rjmp .L76
 278:midi.c        **** 			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes
 299               		.loc 1 278 0
 300 016c 803B      		cpi r24,lo8(-80)
 301 016e 01F4      		brne .L31
 280:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AF
 302               		.loc 1 280 0
 303 0170 83E0      		ldi r24,lo8(3)
 304 0172 8093 0000 		sts midiIncomingMessageState,r24
 282:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 305               		.loc 1 282 0
 306 0176 2917      		cp r18,r25
 307 0178 01F4      		brne .+2
 308 017a 00C0      		rjmp .L69
 309               	.L26:
 262:midi.c        **** 					temporaryChannel=BANK_1;
 310               		.loc 1 262 0
 311 017c 81E0      		ldi r24,lo8(1)
 312               	.L67:
 313 017e 8093 0000 		sts temporaryChannel.1693,r24
 314 0182 0895      		ret
 315               	.LVL13:
 316               	.L72:
 304:midi.c        **** 		switch(midiIncomingMessageState)
 317               		.loc 1 304 0
 318 0184 9230      		cpi r25,lo8(2)
 319 0186 01F4      		brne .+2
 320 0188 00C0      		rjmp .L34
 321 018a 9330      		cpi r25,lo8(3)
 322 018c 01F4      		brne .L31
 406:midi.c        **** 				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
 323               		.loc 1 406 0
 324 018e 8093 0000 		sts firstDataByte.1692,r24
 407:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
 325               		.loc 1 407 0
 326 0192 84E0      		ldi r24,lo8(4)
 327               	.LVL14:
 328 0194 8093 0000 		sts midiIncomingMessageState,r24
 329 0198 0895      		ret
 330               	.LVL15:
 331               	.L42:
 304:midi.c        **** 		switch(midiIncomingMessageState)
 332               		.loc 1 304 0
 333 019a 9830      		cpi r25,lo8(8)
 334 019c 01F4      		brne .+2
 335 019e 00C0      		rjmp .L40
 336 01a0 9930      		cpi r25,lo8(9)
 337 01a2 01F4      		brne .L31
 338 01a4 0895      		ret
 339               	.L37:
 319:midi.c        **** 			if(theByte==0)									// This "note on" is really a "note off".
 340               		.loc 1 319 0
 341 01a6 8823      		tst r24
 342 01a8 01F4      		brne .+2
 343 01aa 00C0      		rjmp .L77
 339:midi.c        **** 				theMessage.dataByteOne=firstDataByte;			// For what note?
 344               		.loc 1 339 0
 345 01ac 4091 0000 		lds r20,firstDataByte.1692
 341:midi.c        **** 				theMessage.channelNumber=temporaryChannel;		// And what channel?
 346               		.loc 1 341 0
 347 01b0 3091 0000 		lds r19,temporaryChannel.1693
 348               	.LVL16:
 349               	.LBB25:
 350               	.LBB26:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 351               		.loc 1 80 0
 352 01b4 9091 0000 		lds r25,midiMessagesInIncomingFifo
 353 01b8 9630      		cpi r25,lo8(6)
 354 01ba 00F4      		brsh .L47
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 355               		.loc 1 82 0
 356 01bc 2091 0000 		lds r18,midiIncomingFifoWritePointer
 357 01c0 E22F      		mov r30,r18
 358 01c2 F0E0      		ldi r31,0
 359 01c4 EE0F      		lsl r30
 360 01c6 FF1F      		rol r31
 361 01c8 EE0F      		lsl r30
 362 01ca FF1F      		rol r31
 363 01cc E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 364 01ce F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 365 01d0 51E0      		ldi r21,lo8(1)
 366 01d2 5183      		std Z+1,r21
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 367               		.loc 1 83 0
 368 01d4 4283      		std Z+2,r20
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 369               		.loc 1 84 0
 370 01d6 8383      		std Z+3,r24
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 371               		.loc 1 85 0
 372 01d8 3083      		st Z,r19
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 373               		.loc 1 87 0
 374 01da 2F5F      		subi r18,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 375               		.loc 1 88 0
 376 01dc 2630      		cpi r18,lo8(6)
 377 01de 00F0      		brlo .+2
 378 01e0 00C0      		rjmp .L48
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 379               		.loc 1 87 0
 380 01e2 2093 0000 		sts midiIncomingFifoWritePointer,r18
 381               	.L49:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 382               		.loc 1 93 0
 383 01e6 9F5F      		subi r25,lo8(-(1))
 384 01e8 9093 0000 		sts midiMessagesInIncomingFifo,r25
 385               	.LVL17:
 386               	.L47:
 387               	.LBE26:
 388               	.LBE25:
 345:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until
 389               		.loc 1 345 0
 390 01ec 1092 0000 		sts midiIncomingMessageState,__zero_reg__
 391 01f0 0895      		ret
 392               	.LVL18:
 393               	.L39:
 437:midi.c        **** 				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
 394               		.loc 1 437 0
 395 01f2 8093 0000 		sts firstDataByte.1692,r24
 438:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
 396               		.loc 1 438 0
 397 01f6 88E0      		ldi r24,lo8(8)
 398               	.LVL19:
 399 01f8 8093 0000 		sts midiIncomingMessageState,r24
 400 01fc 0895      		ret
 401               	.LVL20:
 402               	.L33:
 356:midi.c        **** 				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
 403               		.loc 1 356 0
 404 01fe 8093 0000 		sts firstDataByte.1692,r24
 357:midi.c        **** 				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
 405               		.loc 1 357 0
 406 0202 86E0      		ldi r24,lo8(6)
 407               	.LVL21:
 408 0204 8093 0000 		sts midiIncomingMessageState,r24
 409 0208 0895      		ret
 410               	.LVL22:
 411               	.L76:
 267:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status app
 412               		.loc 1 267 0
 413 020a 87E0      		ldi r24,lo8(7)
 414 020c 8093 0000 		sts midiIncomingMessageState,r24
 269:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 415               		.loc 1 269 0
 416 0210 2913      		cpse r18,r25
 417 0212 00C0      		rjmp .L26
 418               	.L69:
 284:midi.c        **** 					temporaryChannel=BANK_0;
 419               		.loc 1 284 0
 420 0214 1092 0000 		sts temporaryChannel.1693,__zero_reg__
 421 0218 0895      		ret
 422               	.L73:
 228:midi.c        **** 				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON sta
 423               		.loc 1 228 0
 424 021a 1092 0000 		sts midiIncomingMessageState,__zero_reg__
 230:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 425               		.loc 1 230 0
 426 021e 2913      		cpse r18,r25
 427 0220 00C0      		rjmp .L26
 428 0222 00C0      		rjmp .L69
 429               	.LVL23:
 430               	.L34:
 391:midi.c        **** 				theMessage.channelNumber=temporaryChannel;				// And what channel?
 431               		.loc 1 391 0
 432 0224 3091 0000 		lds r19,temporaryChannel.1693
 433               	.LVL24:
 434               	.LBB28:
 435               	.LBB29:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 436               		.loc 1 80 0
 437 0228 9091 0000 		lds r25,midiMessagesInIncomingFifo
 438 022c 9630      		cpi r25,lo8(6)
 439 022e 00F4      		brsh .L53
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 440               		.loc 1 82 0
 441 0230 2091 0000 		lds r18,midiIncomingFifoWritePointer
 442 0234 E22F      		mov r30,r18
 443 0236 F0E0      		ldi r31,0
 444 0238 EE0F      		lsl r30
 445 023a FF1F      		rol r31
 446 023c EE0F      		lsl r30
 447 023e FF1F      		rol r31
 448 0240 E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 449 0242 F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 450 0244 43E0      		ldi r20,lo8(3)
 451 0246 4183      		std Z+1,r20
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 452               		.loc 1 83 0
 453 0248 8283      		std Z+2,r24
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 454               		.loc 1 84 0
 455 024a 1382      		std Z+3,__zero_reg__
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 456               		.loc 1 85 0
 457 024c 3083      		st Z,r19
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 458               		.loc 1 87 0
 459 024e 2F5F      		subi r18,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 460               		.loc 1 88 0
 461 0250 2630      		cpi r18,lo8(6)
 462 0252 00F0      		brlo .+2
 463 0254 00C0      		rjmp .L54
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 464               		.loc 1 87 0
 465 0256 2093 0000 		sts midiIncomingFifoWritePointer,r18
 466               	.L55:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 467               		.loc 1 93 0
 468 025a 9F5F      		subi r25,lo8(-(1))
 469 025c 9093 0000 		sts midiMessagesInIncomingFifo,r25
 470               	.L53:
 471               	.LBE29:
 472               	.LBE28:
 395:midi.c        **** 				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// AFAICT, theoretically, program change
 473               		.loc 1 395 0
 474 0260 82E0      		ldi r24,lo8(2)
 475               	.LVL25:
 476 0262 8093 0000 		sts midiIncomingMessageState,r24
 477 0266 0895      		ret
 478               	.LVL26:
 479               	.L36:
 420:midi.c        **** 				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
 480               		.loc 1 420 0
 481 0268 5091 0000 		lds r21,firstDataByte.1692
 422:midi.c        **** 				theMessage.channelNumber=temporaryChannel;				// And what channel?
 482               		.loc 1 422 0
 483 026c 4091 0000 		lds r20,temporaryChannel.1693
 484               	.LVL27:
 485               	.LBB31:
 486               	.LBB32:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 487               		.loc 1 80 0
 488 0270 2091 0000 		lds r18,midiMessagesInIncomingFifo
 489 0274 2630      		cpi r18,lo8(6)
 490 0276 00F4      		brsh .L56
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 491               		.loc 1 82 0
 492 0278 3091 0000 		lds r19,midiIncomingFifoWritePointer
 493 027c E32F      		mov r30,r19
 494 027e F0E0      		ldi r31,0
 495 0280 EE0F      		lsl r30
 496 0282 FF1F      		rol r31
 497 0284 EE0F      		lsl r30
 498 0286 FF1F      		rol r31
 499 0288 E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 500 028a F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 501 028c 9183      		std Z+1,r25
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 502               		.loc 1 83 0
 503 028e 5283      		std Z+2,r21
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 504               		.loc 1 84 0
 505 0290 8383      		std Z+3,r24
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 506               		.loc 1 85 0
 507 0292 4083      		st Z,r20
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 508               		.loc 1 87 0
 509 0294 3F5F      		subi r19,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 510               		.loc 1 88 0
 511 0296 3630      		cpi r19,lo8(6)
 512 0298 00F0      		brlo .+2
 513 029a 00C0      		rjmp .L57
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 514               		.loc 1 87 0
 515 029c 3093 0000 		sts midiIncomingFifoWritePointer,r19
 516               	.L58:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 517               		.loc 1 93 0
 518 02a0 2F5F      		subi r18,lo8(-(1))
 519 02a2 2093 0000 		sts midiMessagesInIncomingFifo,r18
 520               	.L56:
 521               	.LBE32:
 522               	.LBE31:
 426:midi.c        **** 				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status 
 523               		.loc 1 426 0
 524 02a6 83E0      		ldi r24,lo8(3)
 525               	.LVL28:
 526 02a8 8093 0000 		sts midiIncomingMessageState,r24
 527 02ac 0895      		ret
 528               	.LVL29:
 529               	.L40:
 451:midi.c        **** 				theMessage.dataByteOne=firstDataByte;				// LSB
 530               		.loc 1 451 0
 531 02ae 4091 0000 		lds r20,firstDataByte.1692
 453:midi.c        **** 				theMessage.channelNumber=temporaryChannel;			// And what channel?
 532               		.loc 1 453 0
 533 02b2 3091 0000 		lds r19,temporaryChannel.1693
 534               	.LVL30:
 535               	.LBB34:
 536               	.LBB35:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 537               		.loc 1 80 0
 538 02b6 9091 0000 		lds r25,midiMessagesInIncomingFifo
 539 02ba 9630      		cpi r25,lo8(6)
 540 02bc 00F4      		brsh .L59
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 541               		.loc 1 82 0
 542 02be 2091 0000 		lds r18,midiIncomingFifoWritePointer
 543 02c2 E22F      		mov r30,r18
 544 02c4 F0E0      		ldi r31,0
 545 02c6 EE0F      		lsl r30
 546 02c8 FF1F      		rol r31
 547 02ca EE0F      		lsl r30
 548 02cc FF1F      		rol r31
 549 02ce E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 550 02d0 F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 551 02d2 57E0      		ldi r21,lo8(7)
 552 02d4 5183      		std Z+1,r21
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 553               		.loc 1 83 0
 554 02d6 4283      		std Z+2,r20
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 555               		.loc 1 84 0
 556 02d8 8383      		std Z+3,r24
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 557               		.loc 1 85 0
 558 02da 3083      		st Z,r19
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 559               		.loc 1 87 0
 560 02dc 2F5F      		subi r18,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 561               		.loc 1 88 0
 562 02de 2630      		cpi r18,lo8(6)
 563 02e0 00F0      		brlo .+2
 564 02e2 00C0      		rjmp .L60
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 565               		.loc 1 87 0
 566 02e4 2093 0000 		sts midiIncomingFifoWritePointer,r18
 567               	.L61:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 568               		.loc 1 93 0
 569 02e8 9F5F      		subi r25,lo8(-(1))
 570 02ea 9093 0000 		sts midiMessagesInIncomingFifo,r25
 571               	.L59:
 572               	.LBE35:
 573               	.LBE34:
 457:midi.c        **** 				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel w
 574               		.loc 1 457 0
 575 02ee 87E0      		ldi r24,lo8(7)
 576               	.LVL31:
 577 02f0 8093 0000 		sts midiIncomingMessageState,r24
 578 02f4 0895      		ret
 579               	.LVL32:
 580               	.L74:
 241:midi.c        **** 				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes
 581               		.loc 1 241 0
 582 02f6 81E0      		ldi r24,lo8(1)
 583 02f8 8093 0000 		sts midiIncomingMessageState,r24
 243:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 584               		.loc 1 243 0
 585 02fc 2913      		cpse r18,r25
 586 02fe 00C0      		rjmp .L67
 587 0300 00C0      		rjmp .L69
 588               	.L75:
 254:midi.c        **** 				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applie
 589               		.loc 1 254 0
 590 0302 82E0      		ldi r24,lo8(2)
 591 0304 8093 0000 		sts midiIncomingMessageState,r24
 256:midi.c        **** 				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
 592               		.loc 1 256 0
 593 0308 2913      		cpse r18,r25
 594 030a 00C0      		rjmp .L26
 595 030c 00C0      		rjmp .L69
 596               	.LVL33:
 597               	.L77:
 323:midi.c        **** 				theMessage.dataByteOne=firstDataByte;				// For what note?
 598               		.loc 1 323 0
 599 030e 3091 0000 		lds r19,firstDataByte.1692
 325:midi.c        **** 				theMessage.channelNumber=temporaryChannel;			// And what channel?
 600               		.loc 1 325 0
 601 0312 2091 0000 		lds r18,temporaryChannel.1693
 602               	.LVL34:
 603               	.LBB37:
 604               	.LBB38:
  80:midi.c        **** 	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
 605               		.loc 1 80 0
 606 0316 8091 0000 		lds r24,midiMessagesInIncomingFifo
 607               	.LVL35:
 608 031a 8630      		cpi r24,lo8(6)
 609 031c 00F0      		brlo .+2
 610 031e 00C0      		rjmp .L47
  82:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// T
 611               		.loc 1 82 0
 612 0320 9091 0000 		lds r25,midiIncomingFifoWritePointer
 613 0324 E92F      		mov r30,r25
 614 0326 F0E0      		ldi r31,0
 615 0328 EE0F      		lsl r30
 616 032a FF1F      		rol r31
 617 032c EE0F      		lsl r30
 618 032e FF1F      		rol r31
 619 0330 E050      		subi r30,lo8(-(midiMessageIncomingFifo))
 620 0332 F040      		sbci r31,hi8(-(midiMessageIncomingFifo))
 621 0334 42E0      		ldi r20,lo8(2)
 622 0336 4183      		std Z+1,r20
  83:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
 623               		.loc 1 83 0
 624 0338 3283      		std Z+2,r19
  84:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
 625               		.loc 1 84 0
 626 033a 1382      		std Z+3,__zero_reg__
  85:midi.c        **** 		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
 627               		.loc 1 85 0
 628 033c 2083      		st Z,r18
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 629               		.loc 1 87 0
 630 033e 9F5F      		subi r25,lo8(-(1))
  88:midi.c        **** 		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
 631               		.loc 1 88 0
 632 0340 9630      		cpi r25,lo8(6)
 633 0342 00F4      		brsh .L45
  87:midi.c        **** 		midiIncomingFifoWritePointer++;			// write to the next element next time
 634               		.loc 1 87 0
 635 0344 9093 0000 		sts midiIncomingFifoWritePointer,r25
 636               	.L46:
  93:midi.c        **** 		midiMessagesInIncomingFifo++;								// One more message in the fifo.
 637               		.loc 1 93 0
 638 0348 8F5F      		subi r24,lo8(-(1))
 639 034a 8093 0000 		sts midiMessagesInIncomingFifo,r24
 640 034e 00C0      		rjmp .L47
 641               	.LVL36:
 642               	.L54:
 643               	.LBE38:
 644               	.LBE37:
 645               	.LBB40:
 646               	.LBB30:
  90:midi.c        **** 			midiIncomingFifoWritePointer=0;
 647               		.loc 1 90 0
 648 0350 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 649 0354 00C0      		rjmp .L55
 650               	.LVL37:
 651               	.L51:
 652               	.LBE30:
 653               	.LBE40:
 654               	.LBB41:
 655               	.LBB24:
 656 0356 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 657 035a 00C0      		rjmp .L52
 658               	.LVL38:
 659               	.L57:
 660               	.LBE24:
 661               	.LBE41:
 662               	.LBB42:
 663               	.LBB33:
 664 035c 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 665 0360 00C0      		rjmp .L58
 666               	.LVL39:
 667               	.L60:
 668               	.LBE33:
 669               	.LBE42:
 670               	.LBB43:
 671               	.LBB36:
 672 0362 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 673 0366 00C0      		rjmp .L61
 674               	.LVL40:
 675               	.L48:
 676               	.LBE36:
 677               	.LBE43:
 678               	.LBB44:
 679               	.LBB27:
 680 0368 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 681 036c 00C0      		rjmp .L49
 682               	.LVL41:
 683               	.L45:
 684               	.LBE27:
 685               	.LBE44:
 686               	.LBB45:
 687               	.LBB39:
 688 036e 1092 0000 		sts midiIncomingFifoWritePointer,__zero_reg__
 689 0372 00C0      		rjmp .L46
 690               	.LBE39:
 691               	.LBE45:
 692               		.cfi_endproc
 693               	.LFE8:
 695               	.global	MidiTxBufferNotEmpty
 697               	MidiTxBufferNotEmpty:
 698               	.LFB9:
 468:midi.c        **** 			break;
 469:midi.c        **** 		}	
 470:midi.c        **** 	}
 471:midi.c        **** }
 472:midi.c        **** 
 473:midi.c        **** bool MidiTxBufferNotEmpty(void)
 474:midi.c        **** {
 699               		.loc 1 474 0
 700               		.cfi_startproc
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 0 */
 704               	.L__stack_usage = 0
 475:midi.c        **** 	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got somethin
 705               		.loc 1 475 0
 706 0374 8091 0000 		lds r24,midiMessagesInOutgoingFifo
 707 0378 8111      		cpse r24,__zero_reg__
 708 037a 00C0      		rjmp .L81
 709               		.loc 1 475 0 is_stmt 0 discriminator 1
 710 037c 81E0      		ldi r24,lo8(1)
 711 037e 9091 0000 		lds r25,midiOutgoingMessageState
 712 0382 9111      		cpse r25,__zero_reg__
 476:midi.c        **** 	{
 477:midi.c        **** 		return(true);
 478:midi.c        **** 	}
 479:midi.c        **** 	else
 480:midi.c        **** 	{
 481:midi.c        **** 		return(false);
 482:midi.c        **** 	}
 483:midi.c        **** }
 713               		.loc 1 483 0 is_stmt 1
 714 0384 0895      		ret
 715               	.L82:
 475:midi.c        **** 	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got somethin
 716               		.loc 1 475 0 discriminator 1
 717 0386 80E0      		ldi r24,0
 718 0388 0895      		ret
 719               	.L81:
 477:midi.c        **** 		return(true);
 720               		.loc 1 477 0
 721 038a 81E0      		ldi r24,lo8(1)
 722               		.loc 1 483 0
 723 038c 0895      		ret
 724               		.cfi_endproc
 725               	.LFE9:
 727               	.global	PopOutgoingMidiByte
 729               	PopOutgoingMidiByte:
 730               	.LFB10:
 484:midi.c        **** 
 485:midi.c        **** unsigned char PopOutgoingMidiByte(void)
 486:midi.c        **** // This looks through our outgoing midi message fifo and pops the message bytes off one by one.
 487:midi.c        **** // It is smart enough to throw out bytes if it can use running status and make NOTE_OFFs into NOTE_
 488:midi.c        **** // It is the caller's responsibility to make sure there are messages in the outgoing FIFO before ca
 489:midi.c        **** // It is generally not as flexible as the midi input handler since it never has to worry about the 
 490:midi.c        **** // NOTE:  this stack doesn't include handling for real-time events which would happen OUTSIDE of ru
 491:midi.c        **** // NOTE:  this stack sends generic velocity data.
 492:midi.c        **** // NOTE:  this stack always sends a NOTE_ON with a velocity of zero when it wants to turn a NOTE_OF
 493:midi.c        **** {
 731               		.loc 1 493 0
 732               		.cfi_startproc
 733               	/* prologue: function */
 734               	/* frame size = 0 */
 735               	/* stack size = 0 */
 736               	.L__stack_usage = 0
 494:midi.c        **** 	static MIDI_MESSAGE
 495:midi.c        **** 		theMessage;
 496:midi.c        **** 
 497:midi.c        **** 	unsigned char
 498:midi.c        **** 		theByte;
 499:midi.c        **** 
 500:midi.c        **** 	static unsigned char
 501:midi.c        **** 		lastStatusByte;		// Used to calculate running status.
 502:midi.c        **** 
 503:midi.c        **** 	switch(midiOutgoingMessageState)
 737               		.loc 1 503 0
 738 038e 8091 0000 		lds r24,midiOutgoingMessageState
 739 0392 8330      		cpi r24,lo8(3)
 740 0394 01F4      		brne .+2
 741 0396 00C0      		rjmp .L88
 742 0398 00F0      		brlo .L111
 743 039a 8530      		cpi r24,lo8(5)
 744 039c 01F4      		brne .+2
 745 039e 00C0      		rjmp .L90
 746 03a0 00F4      		brsh .+2
 747 03a2 00C0      		rjmp .L89
 748 03a4 8630      		cpi r24,lo8(6)
 749 03a6 01F4      		brne .+2
 750 03a8 00C0      		rjmp .L91
 751 03aa 8730      		cpi r24,lo8(7)
 752 03ac 01F4      		brne .+2
 753 03ae 00C0      		rjmp .L112
 754               	.L108:
 504:midi.c        **** 	{
 505:midi.c        **** 		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
 506:midi.c        **** 		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.
 507:midi.c        **** 
 508:midi.c        **** 		switch(theMessage.messageType)					// What's the new status byte.
 509:midi.c        **** 		{
 510:midi.c        **** 			case MESSAGE_TYPE_NOTE_ON:
 511:midi.c        **** 			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status mess
 512:midi.c        **** 			if(lastStatusByte==theByte)								// Same status byte as last time?
 513:midi.c        **** 			{
 514:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) 
 515:midi.c        **** 				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
 516:midi.c        **** 			}	
 517:midi.c        **** 			else
 518:midi.c        **** 			{
 519:midi.c        **** 				lastStatusByte=theByte;								// Update current running status.
 520:midi.c        **** 				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_ONE;		// Next time send the data byte.
 521:midi.c        **** 
 522:midi.c        **** 			}
 523:midi.c        **** 			break;
 524:midi.c        **** 
 525:midi.c        **** 			case MESSAGE_TYPE_NOTE_OFF:
 526:midi.c        **** 			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS
 527:midi.c        **** 			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running 
 528:midi.c        **** 			{
 529:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
 530:midi.c        **** 				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
 531:midi.c        **** 			}	
 532:midi.c        **** 			else
 533:midi.c        **** 			{
 534:midi.c        **** 				lastStatusByte=theByte;								// Update current running status.
 535:midi.c        **** 				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
 536:midi.c        **** 
 537:midi.c        **** 			}
 538:midi.c        **** 			break;
 539:midi.c        **** 
 540:midi.c        **** 			case MESSAGE_TYPE_PROGRAM_CHANGE:
 541:midi.c        **** 			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channe
 542:midi.c        **** 			if(lastStatusByte==theByte)										// Same status byte as last time?
 543:midi.c        **** 			{
 544:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status b
 545:midi.c        **** 				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only hav
 546:midi.c        **** 			}	
 547:midi.c        **** 			else
 548:midi.c        **** 			{
 549:midi.c        **** 				lastStatusByte=theByte;								// Update current running status.
 550:midi.c        **** 				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
 551:midi.c        **** 
 552:midi.c        **** 			}
 553:midi.c        **** 			break;
 554:midi.c        **** 
 555:midi.c        **** 			case MESSAGE_TYPE_CONTROL_CHANGE:
 556:midi.c        **** 			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status me
 557:midi.c        **** 			if(lastStatusByte==theByte)										// Same status byte as last time?
 558:midi.c        **** 			{
 559:midi.c        **** 				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number
 560:midi.c        **** 				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
 561:midi.c        **** 			}	
 562:midi.c        **** 			else
 563:midi.c        **** 			{
 564:midi.c        **** 				lastStatusByte=theByte;										// Update current running status.
 565:midi.c        **** 				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
 566:midi.c        **** 
 567:midi.c        **** 			}
 568:midi.c        **** 			break;
 569:midi.c        **** 
 570:midi.c        **** 			default:
 571:midi.c        **** 			theByte=0;		// Make compiler happy.
 755               		.loc 1 571 0
 756 03b0 80E0      		ldi r24,0
 572:midi.c        **** 			break;
 573:midi.c        **** 		}
 574:midi.c        **** 		return(theByte);		// Send out our byte.
 575:midi.c        **** 		break;
 576:midi.c        **** 		
 577:midi.c        **** 		case NOTE_ON_DATA_BYTE_ONE:
 578:midi.c        **** 		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
 579:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first data byte.
 580:midi.c        **** 		break;
 581:midi.c        **** 
 582:midi.c        **** 		case NOTE_OFF_DATA_BYTE_ONE:
 583:midi.c        **** 		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
 584:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first data byte.
 585:midi.c        **** 		break;
 586:midi.c        **** 
 587:midi.c        **** 		case NOTE_ON_DATA_BYTE_TWO:
 588:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 589:midi.c        **** 		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
 590:midi.c        **** 		break;
 591:midi.c        **** 
 592:midi.c        **** 		case NOTE_OFF_DATA_BYTE_TWO:
 593:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 594:midi.c        **** 		return(0);											// Return a velocity of 0 (this means a note off)
 595:midi.c        **** 		break;
 596:midi.c        **** 
 597:midi.c        **** 		case PROGRAM_CHANGE_DATA_BYTE:
 598:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 599:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first (only) data byte.
 600:midi.c        **** 		break;
 601:midi.c        **** 
 602:midi.c        **** 		case CONTROL_CHANGE_DATA_BYTE_ONE:
 603:midi.c        **** 		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
 604:midi.c        **** 		return(theMessage.dataByteOne);								// Return the first data byte.
 605:midi.c        **** 		break;	
 606:midi.c        **** 
 607:midi.c        **** 		case CONTROL_CHANGE_DATA_BYTE_TWO:
 608:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 609:midi.c        **** 		return(theMessage.dataByteTwo);						// Return the second data byte.
 610:midi.c        **** 		break;
 611:midi.c        **** 
 612:midi.c        **** 		default:
 613:midi.c        **** 		return(0);
 614:midi.c        **** 		break;
 615:midi.c        **** 	}
 616:midi.c        **** }
 757               		.loc 1 616 0
 758 03b2 0895      		ret
 759               	.L111:
 503:midi.c        **** 	switch(midiOutgoingMessageState)
 760               		.loc 1 503 0
 761 03b4 8130      		cpi r24,lo8(1)
 762 03b6 01F4      		brne .+2
 763 03b8 00C0      		rjmp .L86
 764 03ba 00F4      		brsh .L87
 765               	.LVL42:
 766               	.LBB48:
 767               	.LBB49:
 101:midi.c        **** 	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
 768               		.loc 1 101 0
 769 03bc 8091 0000 		lds r24,midiMessagesInOutgoingFifo
 770 03c0 8823      		tst r24
 771 03c2 01F4      		brne .+2
 772 03c4 00C0      		rjmp .L113
 103:midi.c        **** 		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// G
 773               		.loc 1 103 0
 774 03c6 2091 0000 		lds r18,midiOutgoingFifoReadPointer
 775 03ca E22F      		mov r30,r18
 776 03cc F0E0      		ldi r31,0
 777 03ce EE0F      		lsl r30
 778 03d0 FF1F      		rol r31
 779 03d2 EE0F      		lsl r30
 780 03d4 FF1F      		rol r31
 781 03d6 E050      		subi r30,lo8(-(midiMessageOutgoingFifo))
 782 03d8 F040      		sbci r31,hi8(-(midiMessageOutgoingFifo))
 783 03da 9181      		ldd r25,Z+1
 784 03dc 9093 0000 		sts theMessage.1713+1,r25
 104:midi.c        **** 		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
 785               		.loc 1 104 0
 786 03e0 3281      		ldd r19,Z+2
 787 03e2 3093 0000 		sts theMessage.1713+2,r19
 105:midi.c        **** 		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
 788               		.loc 1 105 0
 789 03e6 3381      		ldd r19,Z+3
 790 03e8 3093 0000 		sts theMessage.1713+3,r19
 106:midi.c        **** 		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
 791               		.loc 1 106 0
 792 03ec 3081      		ld r19,Z
 793 03ee 3093 0000 		sts theMessage.1713,r19
 108:midi.c        **** 		midiOutgoingFifoReadPointer++;										// read from the next element next time
 794               		.loc 1 108 0
 795 03f2 2F5F      		subi r18,lo8(-(1))
 109:midi.c        **** 		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
 796               		.loc 1 109 0
 797 03f4 2630      		cpi r18,lo8(6)
 798 03f6 00F4      		brsh .L96
 108:midi.c        **** 		midiOutgoingFifoReadPointer++;										// read from the next element next time
 799               		.loc 1 108 0
 800 03f8 2093 0000 		sts midiOutgoingFifoReadPointer,r18
 801               	.L97:
 114:midi.c        **** 		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
 802               		.loc 1 114 0
 803 03fc 8150      		subi r24,lo8(-(-1))
 804 03fe 8093 0000 		sts midiMessagesInOutgoingFifo,r24
 805               	.L95:
 806               	.LBE49:
 807               	.LBE48:
 508:midi.c        **** 		switch(theMessage.messageType)					// What's the new status byte.
 808               		.loc 1 508 0
 809 0402 9230      		cpi r25,lo8(2)
 810 0404 01F4      		brne .+2
 811 0406 00C0      		rjmp .L99
 812 0408 00F4      		brsh .L102
 813 040a 9130      		cpi r25,lo8(1)
 814 040c 01F4      		brne .L108
 511:midi.c        **** 			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status mess
 815               		.loc 1 511 0
 816 040e 8091 0000 		lds r24,theMessage.1713
 817 0412 8069      		ori r24,lo8(-112)
 818               	.LVL43:
 512:midi.c        **** 			if(lastStatusByte==theByte)								// Same status byte as last time?
 819               		.loc 1 512 0
 820 0414 2091 0000 		lds r18,lastStatusByte.1715
 821 0418 2817      		cp r18,r24
 822 041a 01F4      		brne .+2
 823 041c 00C0      		rjmp .L114
 824               	.L104:
 534:midi.c        **** 				lastStatusByte=theByte;								// Update current running status.
 825               		.loc 1 534 0
 826 041e 8093 0000 		sts lastStatusByte.1715,r24
 535:midi.c        **** 				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
 827               		.loc 1 535 0
 828 0422 9093 0000 		sts midiOutgoingMessageState,r25
 829 0426 0895      		ret
 830               	.LVL44:
 831               	.L89:
 593:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 832               		.loc 1 593 0
 833 0428 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 594:midi.c        **** 		return(0);											// Return a velocity of 0 (this means a note off)
 834               		.loc 1 594 0
 835 042c 80E0      		ldi r24,0
 836 042e 0895      		ret
 837               	.L87:
 583:midi.c        **** 		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
 838               		.loc 1 583 0
 839 0430 84E0      		ldi r24,lo8(4)
 840 0432 8093 0000 		sts midiOutgoingMessageState,r24
 584:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first data byte.
 841               		.loc 1 584 0
 842 0436 8091 0000 		lds r24,theMessage.1713+2
 843 043a 0895      		ret
 844               	.L90:
 598:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 845               		.loc 1 598 0
 846 043c 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 599:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first (only) data byte.
 847               		.loc 1 599 0
 848 0440 8091 0000 		lds r24,theMessage.1713+2
 849 0444 0895      		ret
 850               	.L112:
 608:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 851               		.loc 1 608 0
 852 0446 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 609:midi.c        **** 		return(theMessage.dataByteTwo);						// Return the second data byte.
 853               		.loc 1 609 0
 854 044a 8091 0000 		lds r24,theMessage.1713+3
 855 044e 0895      		ret
 856               	.L91:
 603:midi.c        **** 		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
 857               		.loc 1 603 0
 858 0450 87E0      		ldi r24,lo8(7)
 859 0452 8093 0000 		sts midiOutgoingMessageState,r24
 604:midi.c        **** 		return(theMessage.dataByteOne);								// Return the first data byte.
 860               		.loc 1 604 0
 861 0456 8091 0000 		lds r24,theMessage.1713+2
 862 045a 0895      		ret
 863               	.L86:
 578:midi.c        **** 		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
 864               		.loc 1 578 0
 865 045c 83E0      		ldi r24,lo8(3)
 866 045e 8093 0000 		sts midiOutgoingMessageState,r24
 579:midi.c        **** 		return(theMessage.dataByteOne);						// Return the first data byte.
 867               		.loc 1 579 0
 868 0462 8091 0000 		lds r24,theMessage.1713+2
 869 0466 0895      		ret
 870               	.L88:
 588:midi.c        **** 		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
 871               		.loc 1 588 0
 872 0468 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 589:midi.c        **** 		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
 873               		.loc 1 589 0
 874 046c 80E4      		ldi r24,lo8(64)
 875 046e 0895      		ret
 876               	.LVL45:
 877               	.L96:
 878               	.LBB51:
 879               	.LBB50:
 111:midi.c        **** 			midiOutgoingFifoReadPointer=0;
 880               		.loc 1 111 0
 881 0470 1092 0000 		sts midiOutgoingFifoReadPointer,__zero_reg__
 882 0474 00C0      		rjmp .L97
 883               	.L113:
 884 0476 9091 0000 		lds r25,theMessage.1713+1
 885 047a 00C0      		rjmp .L95
 886               	.L102:
 887               	.LBE50:
 888               	.LBE51:
 508:midi.c        **** 		switch(theMessage.messageType)					// What's the new status byte.
 889               		.loc 1 508 0
 890 047c 9330      		cpi r25,lo8(3)
 891 047e 01F0      		breq .L100
 892 0480 9430      		cpi r25,lo8(4)
 893 0482 01F0      		breq .+2
 894 0484 00C0      		rjmp .L108
 556:midi.c        **** 			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status me
 895               		.loc 1 556 0
 896 0486 8091 0000 		lds r24,theMessage.1713
 897 048a 806B      		ori r24,lo8(-80)
 898               	.LVL46:
 557:midi.c        **** 			if(lastStatusByte==theByte)										// Same status byte as last time?
 899               		.loc 1 557 0
 900 048c 9091 0000 		lds r25,lastStatusByte.1715
 901 0490 9817      		cp r25,r24
 902 0492 01F0      		breq .L115
 564:midi.c        **** 				lastStatusByte=theByte;										// Update current running status.
 903               		.loc 1 564 0
 904 0494 8093 0000 		sts lastStatusByte.1715,r24
 565:midi.c        **** 				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
 905               		.loc 1 565 0
 906 0498 96E0      		ldi r25,lo8(6)
 907 049a 9093 0000 		sts midiOutgoingMessageState,r25
 908 049e 0895      		ret
 909               	.LVL47:
 910               	.L99:
 526:midi.c        **** 			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS
 911               		.loc 1 526 0
 912 04a0 8091 0000 		lds r24,theMessage.1713
 913 04a4 8069      		ori r24,lo8(-112)
 914               	.LVL48:
 527:midi.c        **** 			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running 
 915               		.loc 1 527 0
 916 04a6 2091 0000 		lds r18,lastStatusByte.1715
 917 04aa 2813      		cpse r18,r24
 918 04ac 00C0      		rjmp .L104
 529:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
 919               		.loc 1 529 0
 920 04ae 8091 0000 		lds r24,theMessage.1713+2
 921               	.LVL49:
 530:midi.c        **** 				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
 922               		.loc 1 530 0
 923 04b2 94E0      		ldi r25,lo8(4)
 924 04b4 9093 0000 		sts midiOutgoingMessageState,r25
 925 04b8 0895      		ret
 926               	.LVL50:
 927               	.L100:
 541:midi.c        **** 			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channe
 928               		.loc 1 541 0
 929 04ba 8091 0000 		lds r24,theMessage.1713
 930 04be 806C      		ori r24,lo8(-64)
 931               	.LVL51:
 542:midi.c        **** 			if(lastStatusByte==theByte)										// Same status byte as last time?
 932               		.loc 1 542 0
 933 04c0 9091 0000 		lds r25,lastStatusByte.1715
 934 04c4 9817      		cp r25,r24
 935 04c6 01F0      		breq .L116
 549:midi.c        **** 				lastStatusByte=theByte;								// Update current running status.
 936               		.loc 1 549 0
 937 04c8 8093 0000 		sts lastStatusByte.1715,r24
 550:midi.c        **** 				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
 938               		.loc 1 550 0
 939 04cc 95E0      		ldi r25,lo8(5)
 940 04ce 9093 0000 		sts midiOutgoingMessageState,r25
 941 04d2 0895      		ret
 942               	.L114:
 514:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) 
 943               		.loc 1 514 0
 944 04d4 8091 0000 		lds r24,theMessage.1713+2
 945               	.LVL52:
 515:midi.c        **** 				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
 946               		.loc 1 515 0
 947 04d8 93E0      		ldi r25,lo8(3)
 948 04da 9093 0000 		sts midiOutgoingMessageState,r25
 949 04de 0895      		ret
 950               	.L115:
 559:midi.c        **** 				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number
 951               		.loc 1 559 0
 952 04e0 8091 0000 		lds r24,theMessage.1713+2
 953               	.LVL53:
 560:midi.c        **** 				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
 954               		.loc 1 560 0
 955 04e4 97E0      		ldi r25,lo8(7)
 956 04e6 9093 0000 		sts midiOutgoingMessageState,r25
 957 04ea 0895      		ret
 958               	.L116:
 544:midi.c        **** 				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status b
 959               		.loc 1 544 0
 960 04ec 8091 0000 		lds r24,theMessage.1713+2
 961               	.LVL54:
 545:midi.c        **** 				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only hav
 962               		.loc 1 545 0
 963 04f0 1092 0000 		sts midiOutgoingMessageState,__zero_reg__
 964 04f4 0895      		ret
 965               		.cfi_endproc
 966               	.LFE10:
 968               		.comm	midiMessagesInOutgoingFifo,1,1
 969               		.comm	midiMessagesInIncomingFifo,1,1
 970               		.comm	midiChannelNumberB,1,1
 971               		.comm	midiChannelNumberA,1,1
 972               		.comm	midiMessageOutgoingFifo,24,1
 973               		.comm	midiMessageIncomingFifo,24,1
 974               		.local	midiIncomingFifoReadPointer
 975               		.comm	midiIncomingFifoReadPointer,1,1
 976               		.local	midiOutgoingFifoWritePointer
 977               		.comm	midiOutgoingFifoWritePointer,1,1
 978               		.local	midiIncomingMessageState
 979               		.comm	midiIncomingMessageState,1,1
 980               		.local	midiOutgoingMessageState
 981               		.comm	midiOutgoingMessageState,1,1
 982               		.local	midiIncomingFifoWritePointer
 983               		.comm	midiIncomingFifoWritePointer,1,1
 984               		.local	midiOutgoingFifoReadPointer
 985               		.comm	midiOutgoingFifoReadPointer,1,1
 986               		.local	temporaryChannel.1693
 987               		.comm	temporaryChannel.1693,1,1
 988               		.local	firstDataByte.1692
 989               		.comm	firstDataByte.1692,1,1
 990               		.local	theMessage.1713
 991               		.comm	theMessage.1713,4,1
 992               		.local	lastStatusByte.1715
 993               		.comm	lastStatusByte.1715,1,1
 994               	.Letext0:
 995               		.file 2 "defines.h"
 996               		.file 3 "midi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 midi.c
     /tmp/ccvMmBzq.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccvMmBzq.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccvMmBzq.s:4      *ABS*:0000003f __SREG__
     /tmp/ccvMmBzq.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccvMmBzq.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccvMmBzq.s:12     .text:00000000 GetMidiMessageFromIncomingFifo
                            *COM*:00000001 midiMessagesInIncomingFifo
                             .bss:00000000 midiIncomingFifoReadPointer
                            *COM*:00000018 midiMessageIncomingFifo
     /tmp/ccvMmBzq.s:77     .text:00000052 PutMidiMessageInOutgoingFifo
                            *COM*:00000001 midiMessagesInOutgoingFifo
     /tmp/ccvMmBzq.s:975    .bss:00000001 midiOutgoingFifoWritePointer
                            *COM*:00000018 midiMessageOutgoingFifo
                            *COM*:00000001 midiChannelNumberA
     /tmp/ccvMmBzq.s:131    .text:00000092 InitMidi
     /tmp/ccvMmBzq.s:977    .bss:00000002 midiIncomingMessageState
     /tmp/ccvMmBzq.s:979    .bss:00000003 midiOutgoingMessageState
     /tmp/ccvMmBzq.s:981    .bss:00000004 midiIncomingFifoWritePointer
     /tmp/ccvMmBzq.s:983    .bss:00000005 midiOutgoingFifoReadPointer
     /tmp/ccvMmBzq.s:170    .text:000000b6 HandleIncomingMidiByte
     /tmp/ccvMmBzq.s:987    .bss:00000007 firstDataByte.1692
     /tmp/ccvMmBzq.s:985    .bss:00000006 temporaryChannel.1693
                            *COM*:00000001 midiChannelNumberB
     /tmp/ccvMmBzq.s:697    .text:00000374 MidiTxBufferNotEmpty
     /tmp/ccvMmBzq.s:729    .text:0000038e PopOutgoingMidiByte
     /tmp/ccvMmBzq.s:989    .bss:00000008 theMessage.1713
     /tmp/ccvMmBzq.s:991    .bss:0000000c lastStatusByte.1715

UNDEFINED SYMBOLS
__do_clear_bss
