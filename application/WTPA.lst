   1               		.file	"WTPA.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	UpdateAudioChannel0:
  12               	.LFB1:
  13               		.file 1 "WTPA.c"
   1:WTPA.c        **** // Where's the Party At?
   2:WTPA.c        **** // VERSION 2 DA EMPIRE STRIKES BLACK
   3:WTPA.c        **** // ==================================
   4:WTPA.c        **** // Todd Michael Bailey
   5:WTPA.c        **** // todd@narrat1ve.com
   6:WTPA.c        **** // Tue Jul  6 19:36:23 EDT 2010
   7:WTPA.c        **** 
   8:WTPA.c        **** #include	"includes.h"
   9:WTPA.c        **** #define		CURRENT_FIRMWARE_VERSION	0x12		// Starts at 0x10 for WTPA2.  0x11, messing around from 201
  10:WTPA.c        **** 
  11:WTPA.c        **** //=============================
  12:WTPA.c        **** // HOLLER-WARE LICENSE:
  13:WTPA.c        **** // Todd Bailey wrote this.  Do whatever you want with this code, but holler at me if you like it, u
  14:WTPA.c        **** // xoxoxo
  15:WTPA.c        **** // bai1ey.tm@gmail.com
  16:WTPA.c        **** //
  17:WTPA.c        **** // Todd Bailey would like to take this opportunity to shout out to:
  18:WTPA.c        **** //
  19:WTPA.c        **** // Todd Squires, who continues to be wholly intolerant of my bad programming habits and whose TB4 O
  20:WTPA.c        **** // Andrew Reitano for the Nintendo sample playback code,
  21:WTPA.c        **** // Olivier Gillet for the code review, some great ISR speed suggestions, harping on me about remova
  22:WTPA.c        **** // Nick Read, Daniel Fishkin, and Charlie Spears for slangin solder and et cet,
  23:WTPA.c        **** // ChaN for the awesome page on SD interfacing,
  24:WTPA.c        **** // Limor Fried and Phil Torrone, for staying on my ass about making kits,
  25:WTPA.c        **** // Glitched, Dan Nigrin, Altitude, Rodrigo, Sealion, and everybody else on the Narrat1ve forum for 
  26:WTPA.c        **** // BMT Toys and everybody there for putting me through the embedded-systems wringer for all those y
  27:WTPA.c        **** // Jim Williams, Paul Horowitz, Winfield Hill, and all the other people who've forgotten more than 
  28:WTPA.c        **** // and most importantly,
  29:WTPA.c        **** // You, the Customer.
  30:WTPA.c        **** //=============================
  31:WTPA.c        **** 
  32:WTPA.c        **** //=============================
  33:WTPA.c        **** // Atmel AVR Atmega644p MCU, 5v operation.
  34:WTPA.c        **** // 20MHz Crystal Oscillator.
  35:WTPA.c        **** // Originally built with:
  36:WTPA.c        **** // AVR-Binutils 2.19,
  37:WTPA.c        **** // AVR-GCC 4.3.2,
  38:WTPA.c        **** // AVR-libc 1.6.4
  39:WTPA.c        **** //==============================
  40:WTPA.c        **** 
  41:WTPA.c        **** /*
  42:WTPA.c        **** Description:
  43:WTPA.c        **** ==============================================================================
  44:WTPA.c        **** Just rock out, you know?
  45:WTPA.c        **** The real description for lots of this sampler is in the manuals.
  46:WTPA.c        **** 
  47:WTPA.c        **** Technical descriptions of just about everything can be found by grepping through the code comments.
  48:WTPA.c        **** It might be worth your time to check out the original WTPA code as well as the WTPA2 code.
  49:WTPA.c        **** 
  50:WTPA.c        **** 
  51:WTPA.c        **** Changelog:
  52:WTPA.c        **** ==============================================================================
  53:WTPA.c        **** ==============================================================================
  54:WTPA.c        **** Made a CHANGELOG file in this directory.  Only valid for WTPA2 changes once releases start.  You'll
  55:WTPA.c        **** 
  56:WTPA.c        **** 
  57:WTPA.c        **** */
  58:WTPA.c        **** 
  59:WTPA.c        **** 
  60:WTPA.c        **** // I hate Prototypes:
  61:WTPA.c        **** static void DoFruitcakeIntro(void);
  62:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  63:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  64:WTPA.c        **** //static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot);
  65:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot);
  66:WTPA.c        **** static void InitSdIsr(void);
  67:WTPA.c        **** 
  68:WTPA.c        **** //-----------------------------------------------------------------------
  69:WTPA.c        **** //-----------------------------------------------------------------------
  70:WTPA.c        **** // Lists:
  71:WTPA.c        **** //-----------------------------------------------------------------------
  72:WTPA.c        **** //-----------------------------------------------------------------------
  73:WTPA.c        **** 
  74:WTPA.c        **** // Audio ISR States -- these are the different things we can do in the audio related ISR.
  75:WTPA.c        **** //---------------------------------------------------------------------------------------
  76:WTPA.c        **** 
  77:WTPA.c        **** enum
  78:WTPA.c        **** 	{
  79:WTPA.c        **** 		AUDIO_IDLE=0,
  80:WTPA.c        **** 		AUDIO_SAWTOOTH,
  81:WTPA.c        **** 		AUDIO_REALTIME,
  82:WTPA.c        **** 		AUDIO_RECORD,
  83:WTPA.c        **** 		AUDIO_PLAYBACK,
  84:WTPA.c        **** 		AUDIO_OVERDUB,
  85:WTPA.c        **** 		NUM_AUDIO_FUNCTIONS,
  86:WTPA.c        **** 	};
  87:WTPA.c        **** 
  88:WTPA.c        **** 
  89:WTPA.c        **** // LEDs.
  90:WTPA.c        **** //-----------------------------------------------------------------------
  91:WTPA.c        **** enum					// LED enum used for keeping track of our LED masks.
  92:WTPA.c        **** 	{
  93:WTPA.c        **** 		LED_0=0,
  94:WTPA.c        **** 		LED_1,
  95:WTPA.c        **** 		LED_2,
  96:WTPA.c        **** 		LED_3,
  97:WTPA.c        **** 		LED_4,
  98:WTPA.c        **** 		LED_5,
  99:WTPA.c        **** 		LED_6,
 100:WTPA.c        **** 		LED_7,
 101:WTPA.c        **** 		NUM_LEDS,
 102:WTPA.c        **** 	};
 103:WTPA.c        **** 
 104:WTPA.c        **** // WTPA has gotten to the point where each LED pretty much corresponds to an indicator of something
 105:WTPA.c        **** // To reflect this, the masks here arrange LEDs by FUNCTION, to make code easier to read.
 106:WTPA.c        **** 
 107:WTPA.c        **** #define	Om_LED_REC			(1<<LED_0)
 108:WTPA.c        **** #define	Om_LED_ODUB			(1<<LED_1)
 109:WTPA.c        **** #define	Om_LED_PLAY			(1<<LED_2)
 110:WTPA.c        **** #define	Om_LED_OUT_OF_MEM	(1<<LED_3)	// @@@ lose this guy.
 111:WTPA.c        **** #define	Om_LED_BANK			(1<<LED_4)
 112:WTPA.c        **** #define	Om_LED_FX2			(1<<LED_5)
 113:WTPA.c        **** #define	Om_LED_FX1			(1<<LED_6)
 114:WTPA.c        **** #define	Om_LED_FX0			(1<<LED_7)
 115:WTPA.c        **** 
 116:WTPA.c        **** static unsigned char
 117:WTPA.c        **** 	ledOnOffMask,		// What leds are on and off now?
 118:WTPA.c        **** 	ledBlinkMask;		// What leds are blinking right now?
 119:WTPA.c        **** 
 120:WTPA.c        **** static volatile unsigned char
 121:WTPA.c        **** 	ledPwm;				// Used for our benighted intro.
 122:WTPA.c        **** 
 123:WTPA.c        **** //-----------------------------------------------------------------------
 124:WTPA.c        **** //-----------------------------------------------------------------------
 125:WTPA.c        **** // Application Globals:
 126:WTPA.c        **** //-----------------------------------------------------------------------
 127:WTPA.c        **** //-----------------------------------------------------------------------
 128:WTPA.c        **** 
 129:WTPA.c        **** // Keys and switch variables
 130:WTPA.c        **** //-----------------------------------------------------------------------
 131:WTPA.c        **** static unsigned char
 132:WTPA.c        **** 	keyState,
 133:WTPA.c        **** 	newKeys,
 134:WTPA.c        **** 	keysHeld;
 135:WTPA.c        **** 
 136:WTPA.c        **** static bool
 137:WTPA.c        **** 	cardDetect;		// Is SD card physically in the slot?
 138:WTPA.c        **** 
 139:WTPA.c        **** // Application flags and housekeeping.
 140:WTPA.c        **** //-----------------------------------------------------------------------
 141:WTPA.c        **** STATE_FUNC				//  Creates a pointer called State to an instance of STATE_FUNC().
 142:WTPA.c        **** 	*State;
 143:WTPA.c        **** static unsigned char
 144:WTPA.c        **** 	subState;			//  Keeps track of the minor states (sub states) the device can be in.
 145:WTPA.c        **** 
 146:WTPA.c        **** static volatile bool
 147:WTPA.c        **** 	outOfRam;				// Goes true in the ISR if we run out of RAM.
 148:WTPA.c        **** 
 149:WTPA.c        **** static unsigned char
 150:WTPA.c        **** 	encoderState,			// What the encoder switches look like.
 151:WTPA.c        **** 	encoderValue,			// Incremental ticks on the encoder.
 152:WTPA.c        **** 	scaledEncoderValue;		// The number that we display on the LEDs and use to select different effects
 153:WTPA.c        **** 
 154:WTPA.c        **** // Granular stuff
 155:WTPA.c        **** //-----------------------------------------------------------------------
 156:WTPA.c        **** 
 157:WTPA.c        **** #define	JITTER_VALUE_MAX	127
 158:WTPA.c        **** #define MAX_SLICES			128
 159:WTPA.c        **** 
 160:WTPA.c        **** static unsigned long
 161:WTPA.c        **** //	random31 __attribute__((section(".noinit")));	//32 bit random number, seeded from noinit sram (s
 162:WTPA.c        **** 	random31=0xBEEF;								// No chance to come up zero because we threw out init code.
 163:WTPA.c        **** 
 164:WTPA.c        **** static volatile unsigned char
 165:WTPA.c        **** 	granularPositionArrayPointer[NUM_BANKS];	// Where are we in the array right now?
 166:WTPA.c        **** 
 167:WTPA.c        **** static volatile unsigned long
 168:WTPA.c        **** 	sliceSize[NUM_BANKS],						// How big are our slices of memory?
 169:WTPA.c        **** 	sliceRemaining[NUM_BANKS];					// How far are we into our slice of memory?
 170:WTPA.c        **** 
 171:WTPA.c        **** static unsigned char
 172:WTPA.c        **** 	granularPositionArray[NUM_BANKS][MAX_SLICES];
 173:WTPA.c        **** 
 174:WTPA.c        **** enum	// Flags we use to determine what to set our clock source to when setting up an audio interrup
 175:WTPA.c        **** {
 176:WTPA.c        **** 	CLK_NONE=0,
 177:WTPA.c        **** 	CLK_EXTERNAL,
 178:WTPA.c        **** 	CLK_INTERNAL,
 179:WTPA.c        **** };
 180:WTPA.c        **** 
 181:WTPA.c        **** 
 182:WTPA.c        **** // ADC globals:
 183:WTPA.c        **** //-----------------------------------------------------------------------
 184:WTPA.c        **** static volatile signed char
 185:WTPA.c        **** 	adcByte;			// The current reading from the ADC.
 186:WTPA.c        **** 
 187:WTPA.c        **** // SD Card Globals:
 188:WTPA.c        **** //-----------------------------------------------------------------------
 189:WTPA.c        **** 
 190:WTPA.c        **** #define SD_WARMUP_TIME							(SECOND)		// SPEC is 250mS but why not be safe.
 191:WTPA.c        **** #define	SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER		(64)			// We leave our SD card open while reading bloc
 192:WTPA.c        **** #define	SD_FIFO_SIZE							(SD_BLOCK_LENGTH+(SD_BLOCK_LENGTH/2))	// AVR's RAM fifo for reads and wr
 193:WTPA.c        **** 
 194:WTPA.c        **** static unsigned char
 195:WTPA.c        **** 	cardState;					// Keeps track of what's going on with the SD Card -- reading, writing, not present
 196:WTPA.c        **** static unsigned char
 197:WTPA.c        **** 	sampleToc[64];				// Local RAM copy of the card's table of contents (where the samples are stored)
 198:WTPA.c        **** static volatile signed char
 199:WTPA.c        **** 	sdFifo[SD_FIFO_SIZE];		// Rolling buffer for getting bytes in and out of the SD card with the stat
 200:WTPA.c        **** 
 201:WTPA.c        **** static volatile unsigned int		// FIFO pointers for the SD card read/write buffer.
 202:WTPA.c        **** 	sdFifoReadPointer,
 203:WTPA.c        **** 	sdFifoWritePointer,
 204:WTPA.c        **** 	sdBytesInFifo;
 205:WTPA.c        **** 
 206:WTPA.c        **** // The below are variables used by the SD state machine and functions:
 207:WTPA.c        **** //static unsigned char
 208:WTPA.c        **** //	sdQueuedBank;		// Bank to play pending stream from SD card on
 209:WTPA.c        **** static unsigned int
 210:WTPA.c        **** 	sdQueuedSlot;		// Pending sample to play once the current stream is closed
 211:WTPA.c        **** static bool
 212:WTPA.c        **** 	sdPlaybackQueued,	// Is there a playback we need to immediately start once the current SD abort fi
 213:WTPA.c        **** 	sdAbortRead;		// Should the SD state machine abort a read in progress?
 214:WTPA.c        **** 
 215:WTPA.c        **** static unsigned long
 216:WTPA.c        **** 	sdSampleStartBlock;
 217:WTPA.c        **** static volatile unsigned long
 218:WTPA.c        **** 	sdRamSampleRemaining,		// Decrements as we write/read samples to/from RAM until we're done.
 219:WTPA.c        **** 	sdCardSampleRemaining;		// Decrements as we write/read samples to/from the sd card until we're don
 220:WTPA.c        **** 
 221:WTPA.c        **** static unsigned int
 222:WTPA.c        **** 	sdCurrentSlot,
 223:WTPA.c        **** 	sdCurrentBlockOffset;
 224:WTPA.c        **** 
 225:WTPA.c        **** enum					// All the things the micro sd card state machine can be doing
 226:WTPA.c        **** 	{
 227:WTPA.c        **** 		SD_NOT_PRESENT=0,
 228:WTPA.c        **** 		SD_WARMUP,
 229:WTPA.c        **** 		SD_WRITE_START,
 230:WTPA.c        **** 		SD_WRITING_BLOCK,
 231:WTPA.c        **** 		SD_WRITE_CARD_WAIT,
 232:WTPA.c        **** 		SD_WRITE_FIFO_WAIT,
 233:WTPA.c        **** 		SD_TOC_WRITE_START,
 234:WTPA.c        **** 		SD_TOC_WRITE_CONTINUE,
 235:WTPA.c        **** 		SD_TOC_WRITE_FINISH,
 236:WTPA.c        **** 		SD_READ_START,
 237:WTPA.c        **** 		SD_READING_BLOCK,
 238:WTPA.c        **** 		SD_READ_FIFO_WAIT,
 239:WTPA.c        **** 		SD_READ_TOKEN_WAIT,
 240:WTPA.c        **** 		SD_READ_ABORT,
 241:WTPA.c        **** 		SD_IDLE,
 242:WTPA.c        **** 		SD_INVALID,
 243:WTPA.c        **** 	};
 244:WTPA.c        **** 
 245:WTPA.c        **** // Variables which handle the SD card's ISR.  These generally keep track of the on-chip buffer for 
 246:WTPA.c        **** 
 247:WTPA.c        **** static unsigned char
 248:WTPA.c        **** 	sdIsrState;					// Keeps track of what the IRQ that deals with data coming off / going to the SD c
 249:WTPA.c        **** static unsigned long
 250:WTPA.c        **** 	sdRamAddress;				// Used to point to the spot in RAM where the data from the sd card is coming or 
 251:WTPA.c        **** static bool
 252:WTPA.c        **** 	sdBank0;					// Tells us whether the SD buffer is messing with the RAM in sample bank 0 or 1.
 253:WTPA.c        **** 
 254:WTPA.c        **** enum					// All the things the micro sd card's interrupt can be doing
 255:WTPA.c        **** 	{
 256:WTPA.c        **** 		SD_ISR_IDLE=0,
 257:WTPA.c        **** 		SD_ISR_LOADING_RAM,
 258:WTPA.c        **** 		SD_ISR_READING_RAM,
 259:WTPA.c        **** 		SD_ISR_STREAMING_PLAYBACK,
 260:WTPA.c        **** 	};
 261:WTPA.c        **** 
 262:WTPA.c        **** //-----------------------------------------------------------------------
 263:WTPA.c        **** 
 264:WTPA.c        **** 
 265:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 266:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 267:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 268:WTPA.c        **** // Da Code:
 269:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 270:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 271:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 272:WTPA.c        **** 
 273:WTPA.c        **** //-----------------------------------------------------------------------
 274:WTPA.c        **** //-----------------------------------------------------------------------
 275:WTPA.c        **** 
 276:WTPA.c        **** // Sun Sep 19 13:38:34 EDT 2010
 277:WTPA.c        **** // Audio Channel Update Code for each bank:
 278:WTPA.c        **** 
 279:WTPA.c        **** //-----------------------------------------------------------------------
 280:WTPA.c        **** //-----------------------------------------------------------------------
 281:WTPA.c        **** // This is where all the audio business happens in this program.
 282:WTPA.c        **** // Variables messed with in the ISRs AND mainline code should be declared volatile.
 283:WTPA.c        **** // The functions declared up here should _ONLY_ ever be called from an interrupt.
 284:WTPA.c        **** 
 285:WTPA.c        **** static unsigned char UpdateAudioChannel0(void)
 286:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 287:WTPA.c        **** // These channel update routines basically handle getting data into or out of RAM based on what the
 288:WTPA.c        **** // Each channel may write something to RAM, and will pass out a byte based on what (if anything) it
 289:WTPA.c        **** {
  14               		.loc 1 289 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
 290:WTPA.c        **** 	signed int
 291:WTPA.c        **** 		sum;			// For doing saturated adds.
 292:WTPA.c        **** 	signed char
 293:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 294:WTPA.c        **** 	static unsigned char
 295:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 296:WTPA.c        **** 
 297:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 298:WTPA.c        **** 
 299:WTPA.c        **** 	switch(bankStates[BANK_0].audioFunction)
  21               		.loc 1 299 0
  22 0000 8091 0000 		lds r24,bankStates
  23 0004 8330      		cpi r24,lo8(3)
  24 0006 01F0      		breq .L5
  25 0008 00F4      		brsh .L8
  26 000a 8130      		cpi r24,lo8(1)
  27 000c 01F0      		breq .L3
  28 000e 8230      		cpi r24,lo8(2)
  29 0010 01F0      		breq .+2
  30 0012 00C0      		rjmp .L35
  31 0014 00C0      		rjmp .L4
  32               	.L8:
  33 0016 8430      		cpi r24,lo8(4)
  34 0018 01F4      		brne .+2
  35 001a 00C0      		rjmp .L6
  36 001c 8530      		cpi r24,lo8(5)
  37 001e 01F0      		breq .+2
  38 0020 00C0      		rjmp .L35
  39 0022 00C0      		rjmp .L7
  40               	.L3:
 300:WTPA.c        **** 	{
 301:WTPA.c        **** 
 302:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 303:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 304:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
  41               		.loc 1 304 0
  42 0024 8091 0000 		lds r24,sawtooth.1751
  43               	.LVL1:
  44 0028 982F      		mov r25,r24
  45 002a 9F5F      		subi r25,lo8(-(1))
  46 002c 9093 0000 		sts sawtooth.1751,r25
 305:WTPA.c        **** 		break;
  47               		.loc 1 305 0
  48 0030 0895      		ret
  49               	.LVL2:
  50               	.L4:
 306:WTPA.c        **** 
 307:WTPA.c        **** 		case AUDIO_REALTIME:
 308:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 309:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
  51               		.loc 1 309 0
  52 0032 8091 0000 		lds r24,adcByte
  53               	.LVL3:
  54 0036 00C0      		rjmp .L51
  55               	.LVL4:
  56               	.L5:
 310:WTPA.c        **** 
 311:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 312:WTPA.c        **** 		{
 313:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 314:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 315:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 316:WTPA.c        **** 		}
 317:WTPA.c        **** 		break;
 318:WTPA.c        **** 
 319:WTPA.c        **** 		case AUDIO_RECORD:
 320:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 321:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
  57               		.loc 1 321 0
  58 0038 8FEF      		ldi r24,lo8(-1)
  59 003a 84B9      		out 0x4,r24
 322:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
  60               		.loc 1 322 0
  61 003c 8091 0000 		lds r24,bankStates+31
  62 0040 9091 0000 		lds r25,bankStates+31+1
  63 0044 A091 0000 		lds r26,bankStates+31+2
  64 0048 B091 0000 		lds r27,bankStates+31+3
  65 004c 85B9      		out 0x5,r24
 323:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
  66               		.loc 1 323 0
  67 004e 139A      		sbi 0x2,3
 324:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
  68               		.loc 1 324 0
  69 0050 1398      		cbi 0x2,3
 325:WTPA.c        **** 
 326:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
  70               		.loc 1 326 0
  71 0052 8091 0000 		lds r24,bankStates+31
  72 0056 9091 0000 		lds r25,bankStates+31+1
  73 005a A091 0000 		lds r26,bankStates+31+2
  74 005e B091 0000 		lds r27,bankStates+31+3
  75 0062 892F      		mov r24,r25
  76 0064 9A2F      		mov r25,r26
  77 0066 AB2F      		mov r26,r27
  78 0068 BB27      		clr r27
  79 006a 85B9      		out 0x5,r24
 327:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
  80               		.loc 1 327 0
  81 006c 149A      		sbi 0x2,4
 328:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
  82               		.loc 1 328 0
  83 006e 1498      		cbi 0x2,4
 329:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
  84               		.loc 1 329 0
  85 0070 8091 0000 		lds r24,bankStates+31
  86 0074 9091 0000 		lds r25,bankStates+31+1
  87 0078 A091 0000 		lds r26,bankStates+31+2
  88 007c B091 0000 		lds r27,bankStates+31+3
  89 0080 CD01      		movw r24,r26
  90 0082 AA27      		clr r26
  91 0084 BB27      		clr r27
  92 0086 8770      		andi r24,7
  93 0088 9927      		clr r25
  94 008a AA27      		clr r26
  95 008c BB27      		clr r27
  96 008e 8868      		ori r24,136
  97 0090 88B9      		out 0x8,r24
 330:WTPA.c        **** 
 331:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
  98               		.loc 1 331 0
  99 0092 8091 0000 		lds r24,adcByte
 100 0096 85B9      		out 0x5,r24
 332:WTPA.c        **** 		// Compute address while bus settles.
 333:WTPA.c        **** 
 334:WTPA.c        **** 		bankStates[BANK_0].currentAddress++;										// Next address please.
 101               		.loc 1 334 0
 102 0098 8091 0000 		lds r24,bankStates+31
 103 009c 9091 0000 		lds r25,bankStates+31+1
 104 00a0 A091 0000 		lds r26,bankStates+31+2
 105 00a4 B091 0000 		lds r27,bankStates+31+3
 106 00a8 0196      		adiw r24,1
 107 00aa A11D      		adc r26,__zero_reg__
 108 00ac B11D      		adc r27,__zero_reg__
 109 00ae 8093 0000 		sts bankStates+31,r24
 110 00b2 9093 0000 		sts bankStates+31+1,r25
 111 00b6 A093 0000 		sts bankStates+31+2,r26
 112 00ba B093 0000 		sts bankStates+31+3,r27
 335:WTPA.c        **** 		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the
 113               		.loc 1 335 0
 114 00be 8091 0000 		lds r24,bankStates+31
 115 00c2 9091 0000 		lds r25,bankStates+31+1
 116 00c6 A091 0000 		lds r26,bankStates+31+2
 117 00ca B091 0000 		lds r27,bankStates+31+3
 118 00ce 8093 0000 		sts bankStates+12,r24
 119 00d2 9093 0000 		sts bankStates+12+1,r25
 120 00d6 A093 0000 		sts bankStates+12+2,r26
 121 00da B093 0000 		sts bankStates+12+3,r27
 336:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address 
 122               		.loc 1 336 0
 123 00de 8091 0000 		lds r24,bankStates+31
 124 00e2 9091 0000 		lds r25,bankStates+31+1
 125 00e6 A091 0000 		lds r26,bankStates+31+2
 126 00ea B091 0000 		lds r27,bankStates+31+3
 127 00ee 8093 0000 		sts bankStates+20,r24
 128 00f2 9093 0000 		sts bankStates+20+1,r25
 129 00f6 A093 0000 		sts bankStates+20+2,r26
 130 00fa B093 0000 		sts bankStates+20+3,r27
 337:WTPA.c        **** 
 338:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 131               		.loc 1 338 0
 132 00fe 4091 0000 		lds r20,bankStates+12
 133 0102 5091 0000 		lds r21,bankStates+12+1
 134 0106 6091 0000 		lds r22,bankStates+12+2
 135 010a 7091 0000 		lds r23,bankStates+12+3
 136 010e 8091 0000 		lds r24,bankStates+47
 137 0112 9091 0000 		lds r25,bankStates+47+1
 138 0116 A091 0000 		lds r26,bankStates+47+2
 139 011a B091 0000 		lds r27,bankStates+47+3
 140 011e 4817      		cp r20,r24
 141 0120 5907      		cpc r21,r25
 142 0122 6A07      		cpc r22,r26
 143 0124 7B07      		cpc r23,r27
 144 0126 00F0      		brlo .L9
 339:WTPA.c        **** 		{
 340:WTPA.c        **** 			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 145               		.loc 1 340 0
 146 0128 1092 0000 		sts bankStates,__zero_reg__
 341:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 147               		.loc 1 341 0
 148 012c 81E0      		ldi r24,lo8(1)
 149 012e 8093 0000 		sts outOfRam,r24
 150               	.L9:
 342:WTPA.c        **** 		}
 343:WTPA.c        **** 
 344:WTPA.c        **** 		// Finish writing to RAM.
 345:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 151               		.loc 1 345 0
 152 0132 1198      		cbi 0x2,1
 346:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 153               		.loc 1 346 0
 154 0134 119A      		sbi 0x2,1
 155 0136 00C0      		rjmp .L35
 156               	.L6:
 347:WTPA.c        **** 		break;
 348:WTPA.c        **** 
 349:WTPA.c        **** 		case AUDIO_PLAYBACK:
 350:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 351:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 352:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 353:WTPA.c        **** 
 354:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 355:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 157               		.loc 1 355 0
 158 0138 8091 0000 		lds r24,bankStates+31
 159 013c 9091 0000 		lds r25,bankStates+31+1
 160 0140 A091 0000 		lds r26,bankStates+31+2
 161 0144 B091 0000 		lds r27,bankStates+31+3
 162 0148 85B9      		out 0x5,r24
 356:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 163               		.loc 1 356 0
 164 014a 139A      		sbi 0x2,3
 357:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 165               		.loc 1 357 0
 166 014c 1398      		cbi 0x2,3
 358:WTPA.c        **** 
 359:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 167               		.loc 1 359 0
 168 014e 8091 0000 		lds r24,bankStates+31
 169 0152 9091 0000 		lds r25,bankStates+31+1
 170 0156 A091 0000 		lds r26,bankStates+31+2
 171 015a B091 0000 		lds r27,bankStates+31+3
 172 015e 892F      		mov r24,r25
 173 0160 9A2F      		mov r25,r26
 174 0162 AB2F      		mov r26,r27
 175 0164 BB27      		clr r27
 176 0166 85B9      		out 0x5,r24
 360:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 177               		.loc 1 360 0
 178 0168 149A      		sbi 0x2,4
 361:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 179               		.loc 1 361 0
 180 016a 1498      		cbi 0x2,4
 362:WTPA.c        **** 
 363:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 181               		.loc 1 363 0
 182 016c 8091 0000 		lds r24,bankStates+31
 183 0170 9091 0000 		lds r25,bankStates+31+1
 184 0174 A091 0000 		lds r26,bankStates+31+2
 185 0178 B091 0000 		lds r27,bankStates+31+3
 186 017c CD01      		movw r24,r26
 187 017e AA27      		clr r26
 188 0180 BB27      		clr r27
 189 0182 8770      		andi r24,7
 190 0184 9927      		clr r25
 191 0186 AA27      		clr r26
 192 0188 BB27      		clr r27
 193 018a 8868      		ori r24,136
 194 018c 88B9      		out 0x8,r24
 364:WTPA.c        **** 
 365:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 195               		.loc 1 365 0
 196 018e 14B8      		out 0x4,__zero_reg__
 366:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 197               		.loc 1 366 0
 198 0190 1298      		cbi 0x2,2
 367:WTPA.c        **** 
 368:WTPA.c        **** 		// Calculate new addy while data bus settles
 369:WTPA.c        **** 
 370:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 199               		.loc 1 370 0
 200 0192 8091 0000 		lds r24,bankStates+6
 201 0196 8823      		tst r24
 202 0198 01F4      		brne .+2
 203 019a 00C0      		rjmp .L10
 371:WTPA.c        **** 		{
 372:WTPA.c        **** 			// Slice first, only worry about forward ###
 373:WTPA.c        **** 
 374:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 204               		.loc 1 374 0
 205 019c 8091 0000 		lds r24,sliceRemaining
 206 01a0 9091 0000 		lds r25,sliceRemaining+1
 207 01a4 A091 0000 		lds r26,sliceRemaining+2
 208 01a8 B091 0000 		lds r27,sliceRemaining+3
 209 01ac 892B      		or r24,r25
 210 01ae 8A2B      		or r24,r26
 211 01b0 8B2B      		or r24,r27
 212 01b2 01F0      		breq .L11
 375:WTPA.c        **** 			{
 376:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 213               		.loc 1 376 0
 214 01b4 8091 0000 		lds r24,bankStates+31
 215 01b8 9091 0000 		lds r25,bankStates+31+1
 216 01bc A091 0000 		lds r26,bankStates+31+2
 217 01c0 B091 0000 		lds r27,bankStates+31+3
 218 01c4 0196      		adiw r24,1
 219 01c6 A11D      		adc r26,__zero_reg__
 220 01c8 B11D      		adc r27,__zero_reg__
 221 01ca 8093 0000 		sts bankStates+31,r24
 222 01ce 9093 0000 		sts bankStates+31+1,r25
 223 01d2 A093 0000 		sts bankStates+31+2,r26
 224 01d6 B093 0000 		sts bankStates+31+3,r27
 377:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 225               		.loc 1 377 0
 226 01da 8091 0000 		lds r24,sliceRemaining
 227 01de 9091 0000 		lds r25,sliceRemaining+1
 228 01e2 A091 0000 		lds r26,sliceRemaining+2
 229 01e6 B091 0000 		lds r27,sliceRemaining+3
 230 01ea 0197      		sbiw r24,1
 231 01ec A109      		sbc r26,__zero_reg__
 232 01ee B109      		sbc r27,__zero_reg__
 233 01f0 8093 0000 		sts sliceRemaining,r24
 234 01f4 9093 0000 		sts sliceRemaining+1,r25
 235 01f8 A093 0000 		sts sliceRemaining+2,r26
 236 01fc B093 0000 		sts sliceRemaining+3,r27
 237 0200 00C0      		rjmp .L12
 238               	.L11:
 378:WTPA.c        **** 			}
 379:WTPA.c        **** 			else	// Slice done, jump to new slice.
 380:WTPA.c        **** 			{
 381:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 239               		.loc 1 381 0
 240 0202 8091 0000 		lds r24,sliceSize
 241 0206 9091 0000 		lds r25,sliceSize+1
 242 020a A091 0000 		lds r26,sliceSize+2
 243 020e B091 0000 		lds r27,sliceSize+3
 244 0212 8093 0000 		sts sliceRemaining,r24
 245 0216 9093 0000 		sts sliceRemaining+1,r25
 246 021a A093 0000 		sts sliceRemaining+2,r26
 247 021e B093 0000 		sts sliceRemaining+3,r27
 382:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 248               		.loc 1 382 0
 249 0222 8091 0000 		lds r24,granularPositionArrayPointer
 250 0226 8F5F      		subi r24,lo8(-(1))
 251 0228 8093 0000 		sts granularPositionArrayPointer,r24
 383:WTPA.c        **** 
 384:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 252               		.loc 1 384 0
 253 022c 9091 0000 		lds r25,granularPositionArrayPointer
 254 0230 8091 0000 		lds r24,bankStates+6
 255 0234 9813      		cpse r25,r24
 256 0236 00C0      		rjmp .L13
 385:WTPA.c        **** 				{
 386:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 257               		.loc 1 386 0
 258 0238 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 259               	.L13:
 387:WTPA.c        **** 				}
 388:WTPA.c        **** 
 389:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 260               		.loc 1 389 0
 261 023c E091 0000 		lds r30,granularPositionArrayPointer
 262 0240 2091 0000 		lds r18,sliceSize
 263 0244 3091 0000 		lds r19,sliceSize+1
 264 0248 4091 0000 		lds r20,sliceSize+2
 265 024c 5091 0000 		lds r21,sliceSize+3
 266 0250 F0E0      		ldi r31,0
 267 0252 E050      		subi r30,lo8(-(granularPositionArray))
 268 0254 F040      		sbci r31,hi8(-(granularPositionArray))
 269 0256 A081      		ld r26,Z
 270 0258 B0E0      		ldi r27,0
 271 025a 0E94 0000 		call __muluhisi3
 272 025e 6093 0000 		sts bankStates+31,r22
 273 0262 7093 0000 		sts bankStates+31+1,r23
 274 0266 8093 0000 		sts bankStates+31+2,r24
 275 026a 9093 0000 		sts bankStates+31+3,r25
 276 026e 00C0      		rjmp .L12
 277               	.L10:
 390:WTPA.c        **** 			}
 391:WTPA.c        **** 		}
 392:WTPA.c        **** 		else
 393:WTPA.c        **** 		{
 394:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 278               		.loc 1 394 0
 279 0270 8091 0000 		lds r24,bankStates+4
 395:WTPA.c        **** 			{
 396:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 280               		.loc 1 396 0
 281 0274 4091 0000 		lds r20,bankStates+31
 282 0278 5091 0000 		lds r21,bankStates+31+1
 283 027c 6091 0000 		lds r22,bankStates+31+2
 284 0280 7091 0000 		lds r23,bankStates+31+3
 394:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 285               		.loc 1 394 0
 286 0284 8111      		cpse r24,__zero_reg__
 287 0286 00C0      		rjmp .L14
 288               		.loc 1 396 0
 289 0288 8091 0000 		lds r24,bankStates+24
 290 028c 9091 0000 		lds r25,bankStates+24+1
 291 0290 A091 0000 		lds r26,bankStates+24+2
 292 0294 B091 0000 		lds r27,bankStates+24+3
 293 0298 4817      		cp r20,r24
 294 029a 5907      		cpc r21,r25
 295 029c 6A07      		cpc r22,r26
 296 029e 7B07      		cpc r23,r27
 297 02a0 01F4      		brne .L15
 298               		.loc 1 396 0 is_stmt 0 discriminator 1
 299 02a2 8091 0000 		lds r24,bankStates+1
 300 02a6 8130      		cpi r24,lo8(1)
 301 02a8 01F4      		brne .L15
 302 02aa 00C0      		rjmp .L45
 303               	.L15:
 397:WTPA.c        **** 				{
 398:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 399:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 400:WTPA.c        **** 				}
 401:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 304               		.loc 1 401 0 is_stmt 1
 305 02ac 4091 0000 		lds r20,bankStates+31
 306 02b0 5091 0000 		lds r21,bankStates+31+1
 307 02b4 6091 0000 		lds r22,bankStates+31+2
 308 02b8 7091 0000 		lds r23,bankStates+31+3
 309 02bc 8091 0000 		lds r24,bankStates+24
 310 02c0 9091 0000 		lds r25,bankStates+24+1
 311 02c4 A091 0000 		lds r26,bankStates+24+2
 312 02c8 B091 0000 		lds r27,bankStates+24+3
 313 02cc 4817      		cp r20,r24
 314 02ce 5907      		cpc r21,r25
 315 02d0 6A07      		cpc r22,r26
 316 02d2 7B07      		cpc r23,r27
 317 02d4 01F4      		brne .L16
 402:WTPA.c        **** 				{
 403:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 318               		.loc 1 403 0
 319 02d6 8091 0000 		lds r24,bankStates+20
 320 02da 9091 0000 		lds r25,bankStates+20+1
 321 02de A091 0000 		lds r26,bankStates+20+2
 322 02e2 B091 0000 		lds r27,bankStates+20+3
 323 02e6 00C0      		rjmp .L46
 324               	.L16:
 404:WTPA.c        **** 				}
 405:WTPA.c        **** 				else
 406:WTPA.c        **** 				{
 407:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 325               		.loc 1 407 0
 326 02e8 4091 0000 		lds r20,bankStates+31
 327 02ec 5091 0000 		lds r21,bankStates+31+1
 328 02f0 6091 0000 		lds r22,bankStates+31+2
 329 02f4 7091 0000 		lds r23,bankStates+31+3
 330 02f8 8091 0000 		lds r24,bankStates+16
 331 02fc 9091 0000 		lds r25,bankStates+16+1
 332 0300 A091 0000 		lds r26,bankStates+16+2
 333 0304 B091 0000 		lds r27,bankStates+16+3
 334 0308 4817      		cp r20,r24
 335 030a 5907      		cpc r21,r25
 336 030c 6A07      		cpc r22,r26
 337 030e 7B07      		cpc r23,r27
 338 0310 01F4      		brne .L17
 408:WTPA.c        **** 					{
 409:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 339               		.loc 1 409 0
 340 0312 8091 0000 		lds r24,bankStates+12
 341 0316 9091 0000 		lds r25,bankStates+12+1
 342 031a A091 0000 		lds r26,bankStates+12+2
 343 031e B091 0000 		lds r27,bankStates+12+3
 344 0322 00C0      		rjmp .L46
 345               	.L17:
 410:WTPA.c        **** 					}
 411:WTPA.c        **** 					else
 412:WTPA.c        **** 					{
 413:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 346               		.loc 1 413 0
 347 0324 8091 0000 		lds r24,bankStates+31
 348 0328 9091 0000 		lds r25,bankStates+31+1
 349 032c A091 0000 		lds r26,bankStates+31+2
 350 0330 B091 0000 		lds r27,bankStates+31+3
 351 0334 0197      		sbiw r24,1
 352 0336 A109      		sbc r26,__zero_reg__
 353 0338 B109      		sbc r27,__zero_reg__
 354 033a 00C0      		rjmp .L46
 355               	.L14:
 414:WTPA.c        **** 					}
 415:WTPA.c        **** 				}
 416:WTPA.c        **** 			}
 417:WTPA.c        **** 			else	// Going forward through the sample.
 418:WTPA.c        **** 			{
 419:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 356               		.loc 1 419 0
 357 033c 8091 0000 		lds r24,bankStates+20
 358 0340 9091 0000 		lds r25,bankStates+20+1
 359 0344 A091 0000 		lds r26,bankStates+20+2
 360 0348 B091 0000 		lds r27,bankStates+20+3
 361 034c 4817      		cp r20,r24
 362 034e 5907      		cpc r21,r25
 363 0350 6A07      		cpc r22,r26
 364 0352 7B07      		cpc r23,r27
 365 0354 01F4      		brne .L18
 366               		.loc 1 419 0 is_stmt 0 discriminator 1
 367 0356 8091 0000 		lds r24,bankStates+1
 368 035a 8130      		cpi r24,lo8(1)
 369 035c 01F4      		brne .L18
 370               	.L45:
 420:WTPA.c        **** 				{
 421:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 371               		.loc 1 421 0 is_stmt 1
 372 035e 1092 0000 		sts bankStates,__zero_reg__
 422:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 373               		.loc 1 422 0
 374 0362 1092 0000 		sts bankStates+9,__zero_reg__
 375 0366 00C0      		rjmp .L12
 376               	.L18:
 423:WTPA.c        **** 				}
 424:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 377               		.loc 1 424 0
 378 0368 4091 0000 		lds r20,bankStates+31
 379 036c 5091 0000 		lds r21,bankStates+31+1
 380 0370 6091 0000 		lds r22,bankStates+31+2
 381 0374 7091 0000 		lds r23,bankStates+31+3
 382 0378 8091 0000 		lds r24,bankStates+20
 383 037c 9091 0000 		lds r25,bankStates+20+1
 384 0380 A091 0000 		lds r26,bankStates+20+2
 385 0384 B091 0000 		lds r27,bankStates+20+3
 386 0388 4817      		cp r20,r24
 387 038a 5907      		cpc r21,r25
 388 038c 6A07      		cpc r22,r26
 389 038e 7B07      		cpc r23,r27
 390 0390 01F4      		brne .L19
 425:WTPA.c        **** 				{
 426:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 391               		.loc 1 426 0
 392 0392 8091 0000 		lds r24,bankStates+24
 393 0396 9091 0000 		lds r25,bankStates+24+1
 394 039a A091 0000 		lds r26,bankStates+24+2
 395 039e B091 0000 		lds r27,bankStates+24+3
 396 03a2 00C0      		rjmp .L46
 397               	.L19:
 427:WTPA.c        **** 				}
 428:WTPA.c        **** 				else
 429:WTPA.c        **** 				{
 430:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 398               		.loc 1 430 0
 399 03a4 4091 0000 		lds r20,bankStates+31
 400 03a8 5091 0000 		lds r21,bankStates+31+1
 401 03ac 6091 0000 		lds r22,bankStates+31+2
 402 03b0 7091 0000 		lds r23,bankStates+31+3
 403 03b4 8091 0000 		lds r24,bankStates+12
 404 03b8 9091 0000 		lds r25,bankStates+12+1
 405 03bc A091 0000 		lds r26,bankStates+12+2
 406 03c0 B091 0000 		lds r27,bankStates+12+3
 407 03c4 4817      		cp r20,r24
 408 03c6 5907      		cpc r21,r25
 409 03c8 6A07      		cpc r22,r26
 410 03ca 7B07      		cpc r23,r27
 411 03cc 01F4      		brne .L20
 431:WTPA.c        **** 					{
 432:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 412               		.loc 1 432 0
 413 03ce 8091 0000 		lds r24,bankStates+16
 414 03d2 9091 0000 		lds r25,bankStates+16+1
 415 03d6 A091 0000 		lds r26,bankStates+16+2
 416 03da B091 0000 		lds r27,bankStates+16+3
 417 03de 00C0      		rjmp .L46
 418               	.L20:
 433:WTPA.c        **** 					}
 434:WTPA.c        **** 					else
 435:WTPA.c        **** 					{
 436:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 419               		.loc 1 436 0
 420 03e0 8091 0000 		lds r24,bankStates+31
 421 03e4 9091 0000 		lds r25,bankStates+31+1
 422 03e8 A091 0000 		lds r26,bankStates+31+2
 423 03ec B091 0000 		lds r27,bankStates+31+3
 424 03f0 0196      		adiw r24,1
 425 03f2 A11D      		adc r26,__zero_reg__
 426 03f4 B11D      		adc r27,__zero_reg__
 427               	.L46:
 428 03f6 8093 0000 		sts bankStates+31,r24
 429 03fa 9093 0000 		sts bankStates+31+1,r25
 430 03fe A093 0000 		sts bankStates+31+2,r26
 431 0402 B093 0000 		sts bankStates+31+3,r27
 432               	.L12:
 437:WTPA.c        **** 					}
 438:WTPA.c        **** 				}
 439:WTPA.c        **** 			}
 440:WTPA.c        **** 		}
 441:WTPA.c        **** /*
 442:WTPA.c        **** // @@@ Isr speed test hooey
 443:WTPA.c        **** 		if(bankStates[BANK_0].currentAddress==daNextJump)
 444:WTPA.c        **** 		{
 445:WTPA.c        **** 			bankStates[BANK_0].currentAddress=daNextJumpPrime;
 446:WTPA.c        **** 		}
 447:WTPA.c        **** 		else
 448:WTPA.c        **** 		{
 449:WTPA.c        **** 			bankStates[BANK_0].currentAddress++;
 450:WTPA.c        **** 		}
 451:WTPA.c        **** 
 452:WTPA.c        **** 		if(bankStates[BANK_0].sampleDirection==false)
 453:WTPA.c        **** 		{
 454:WTPA.c        **** 			bankStates[BANK_0].currentAddress-=2;
 455:WTPA.c        **** 		}
 456:WTPA.c        **** 
 457:WTPA.c        **** */
 458:WTPA.c        **** 		// Finish getting the byte from RAM.
 459:WTPA.c        **** 
 460:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 433               		.loc 1 460 0
 434 0406 83B1      		in r24,0x3
 435               	.LVL5:
 461:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 436               		.loc 1 461 0
 437 0408 129A      		sbi 0x2,2
 462:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 438               		.loc 1 462 0
 439 040a 9FEF      		ldi r25,lo8(-1)
 440 040c 94B9      		out 0x4,r25
 441               	.L51:
 463:WTPA.c        **** 
 464:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 442               		.loc 1 464 0
 443 040e 9091 0000 		lds r25,bankStates+8
 444 0412 9923      		tst r25
 445 0414 01F4      		brne .+2
 446 0416 00C0      		rjmp .L2
 465:WTPA.c        **** 		{
 466:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 447               		.loc 1 466 0
 448 0418 8058      		subi r24,lo8(-(-128))
 449               	.LVL6:
 467:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 450               		.loc 1 467 0
 451 041a 9091 0000 		lds r25,bankStates+8
 452 041e 2FEF      		ldi r18,lo8(-1)
 453 0420 30E0      		ldi r19,0
 454 0422 092E      		mov r0,r25
 455 0424 00C0      		rjmp 2f
 456               		1:
 457 0426 220F      		lsl r18
 458               		2:
 459 0428 0A94      		dec r0
 460 042a 02F4      		brpl 1b
 461 042c 8223      		and r24,r18
 462               	.LVL7:
 468:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 463               		.loc 1 468 0
 464 042e 8058      		subi r24,lo8(-(-128))
 465               	.LVL8:
 466 0430 0895      		ret
 467               	.LVL9:
 468               	.L7:
 469:WTPA.c        **** 		}
 470:WTPA.c        **** 		break;
 471:WTPA.c        **** 
 472:WTPA.c        **** 		case AUDIO_OVERDUB:
 473:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 474:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 475:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 469               		.loc 1 475 0
 470 0432 8091 0000 		lds r24,bankStates+31
 471 0436 9091 0000 		lds r25,bankStates+31+1
 472 043a A091 0000 		lds r26,bankStates+31+2
 473 043e B091 0000 		lds r27,bankStates+31+3
 474 0442 85B9      		out 0x5,r24
 476:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 475               		.loc 1 476 0
 476 0444 139A      		sbi 0x2,3
 477:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 477               		.loc 1 477 0
 478 0446 1398      		cbi 0x2,3
 478:WTPA.c        **** 
 479:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 479               		.loc 1 479 0
 480 0448 8091 0000 		lds r24,bankStates+31
 481 044c 9091 0000 		lds r25,bankStates+31+1
 482 0450 A091 0000 		lds r26,bankStates+31+2
 483 0454 B091 0000 		lds r27,bankStates+31+3
 484 0458 892F      		mov r24,r25
 485 045a 9A2F      		mov r25,r26
 486 045c AB2F      		mov r26,r27
 487 045e BB27      		clr r27
 488 0460 85B9      		out 0x5,r24
 480:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 489               		.loc 1 480 0
 490 0462 149A      		sbi 0x2,4
 481:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 491               		.loc 1 481 0
 492 0464 1498      		cbi 0x2,4
 482:WTPA.c        **** 
 483:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 493               		.loc 1 483 0
 494 0466 8091 0000 		lds r24,bankStates+31
 495 046a 9091 0000 		lds r25,bankStates+31+1
 496 046e A091 0000 		lds r26,bankStates+31+2
 497 0472 B091 0000 		lds r27,bankStates+31+3
 498 0476 CD01      		movw r24,r26
 499 0478 AA27      		clr r26
 500 047a BB27      		clr r27
 501 047c 8770      		andi r24,7
 502 047e 9927      		clr r25
 503 0480 AA27      		clr r26
 504 0482 BB27      		clr r27
 505 0484 8868      		ori r24,136
 506 0486 88B9      		out 0x8,r24
 484:WTPA.c        **** 
 485:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 507               		.loc 1 485 0
 508 0488 14B8      		out 0x4,__zero_reg__
 486:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 509               		.loc 1 486 0
 510 048a 1298      		cbi 0x2,2
 487:WTPA.c        **** 
 488:WTPA.c        **** 		// Calculate new address while bus settles (were nops in here)
 489:WTPA.c        **** 
 490:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 511               		.loc 1 490 0
 512 048c 8091 0000 		lds r24,bankStates+6
 513 0490 8823      		tst r24
 514 0492 01F4      		brne .+2
 515 0494 00C0      		rjmp .L21
 491:WTPA.c        **** 		{
 492:WTPA.c        **** 			// Slice first, only worry about forward ###
 493:WTPA.c        **** 
 494:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 516               		.loc 1 494 0
 517 0496 8091 0000 		lds r24,sliceRemaining
 518 049a 9091 0000 		lds r25,sliceRemaining+1
 519 049e A091 0000 		lds r26,sliceRemaining+2
 520 04a2 B091 0000 		lds r27,sliceRemaining+3
 521 04a6 892B      		or r24,r25
 522 04a8 8A2B      		or r24,r26
 523 04aa 8B2B      		or r24,r27
 524 04ac 01F0      		breq .L22
 495:WTPA.c        **** 			{
 496:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 525               		.loc 1 496 0
 526 04ae 8091 0000 		lds r24,bankStates+31
 527 04b2 9091 0000 		lds r25,bankStates+31+1
 528 04b6 A091 0000 		lds r26,bankStates+31+2
 529 04ba B091 0000 		lds r27,bankStates+31+3
 530 04be 0196      		adiw r24,1
 531 04c0 A11D      		adc r26,__zero_reg__
 532 04c2 B11D      		adc r27,__zero_reg__
 533 04c4 8093 0000 		sts bankStates+31,r24
 534 04c8 9093 0000 		sts bankStates+31+1,r25
 535 04cc A093 0000 		sts bankStates+31+2,r26
 536 04d0 B093 0000 		sts bankStates+31+3,r27
 497:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 537               		.loc 1 497 0
 538 04d4 8091 0000 		lds r24,sliceRemaining
 539 04d8 9091 0000 		lds r25,sliceRemaining+1
 540 04dc A091 0000 		lds r26,sliceRemaining+2
 541 04e0 B091 0000 		lds r27,sliceRemaining+3
 542 04e4 0197      		sbiw r24,1
 543 04e6 A109      		sbc r26,__zero_reg__
 544 04e8 B109      		sbc r27,__zero_reg__
 545 04ea 8093 0000 		sts sliceRemaining,r24
 546 04ee 9093 0000 		sts sliceRemaining+1,r25
 547 04f2 A093 0000 		sts sliceRemaining+2,r26
 548 04f6 B093 0000 		sts sliceRemaining+3,r27
 549 04fa 00C0      		rjmp .L23
 550               	.L22:
 498:WTPA.c        **** 			}
 499:WTPA.c        **** 			else	// Slice done, jump to new slice.
 500:WTPA.c        **** 			{
 501:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 551               		.loc 1 501 0
 552 04fc 8091 0000 		lds r24,sliceSize
 553 0500 9091 0000 		lds r25,sliceSize+1
 554 0504 A091 0000 		lds r26,sliceSize+2
 555 0508 B091 0000 		lds r27,sliceSize+3
 556 050c 8093 0000 		sts sliceRemaining,r24
 557 0510 9093 0000 		sts sliceRemaining+1,r25
 558 0514 A093 0000 		sts sliceRemaining+2,r26
 559 0518 B093 0000 		sts sliceRemaining+3,r27
 502:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 560               		.loc 1 502 0
 561 051c 8091 0000 		lds r24,granularPositionArrayPointer
 562 0520 8F5F      		subi r24,lo8(-(1))
 563 0522 8093 0000 		sts granularPositionArrayPointer,r24
 503:WTPA.c        **** 
 504:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 564               		.loc 1 504 0
 565 0526 9091 0000 		lds r25,granularPositionArrayPointer
 566 052a 8091 0000 		lds r24,bankStates+6
 567 052e 9813      		cpse r25,r24
 568 0530 00C0      		rjmp .L24
 505:WTPA.c        **** 				{
 506:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 569               		.loc 1 506 0
 570 0532 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 571               	.L24:
 507:WTPA.c        **** 				}
 508:WTPA.c        **** 
 509:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 572               		.loc 1 509 0
 573 0536 E091 0000 		lds r30,granularPositionArrayPointer
 574 053a 2091 0000 		lds r18,sliceSize
 575 053e 3091 0000 		lds r19,sliceSize+1
 576 0542 4091 0000 		lds r20,sliceSize+2
 577 0546 5091 0000 		lds r21,sliceSize+3
 578 054a F0E0      		ldi r31,0
 579 054c E050      		subi r30,lo8(-(granularPositionArray))
 580 054e F040      		sbci r31,hi8(-(granularPositionArray))
 581 0550 A081      		ld r26,Z
 582 0552 B0E0      		ldi r27,0
 583 0554 0E94 0000 		call __muluhisi3
 584 0558 6093 0000 		sts bankStates+31,r22
 585 055c 7093 0000 		sts bankStates+31+1,r23
 586 0560 8093 0000 		sts bankStates+31+2,r24
 587 0564 9093 0000 		sts bankStates+31+3,r25
 588 0568 00C0      		rjmp .L23
 589               	.L21:
 510:WTPA.c        **** 			}
 511:WTPA.c        **** 		}
 512:WTPA.c        **** 		else
 513:WTPA.c        **** 		{
 514:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 590               		.loc 1 514 0
 591 056a 8091 0000 		lds r24,bankStates+4
 515:WTPA.c        **** 			{
 516:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 592               		.loc 1 516 0
 593 056e 4091 0000 		lds r20,bankStates+31
 594 0572 5091 0000 		lds r21,bankStates+31+1
 595 0576 6091 0000 		lds r22,bankStates+31+2
 596 057a 7091 0000 		lds r23,bankStates+31+3
 514:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 597               		.loc 1 514 0
 598 057e 8111      		cpse r24,__zero_reg__
 599 0580 00C0      		rjmp .L25
 600               		.loc 1 516 0
 601 0582 8091 0000 		lds r24,bankStates+24
 602 0586 9091 0000 		lds r25,bankStates+24+1
 603 058a A091 0000 		lds r26,bankStates+24+2
 604 058e B091 0000 		lds r27,bankStates+24+3
 605 0592 4817      		cp r20,r24
 606 0594 5907      		cpc r21,r25
 607 0596 6A07      		cpc r22,r26
 608 0598 7B07      		cpc r23,r27
 609 059a 01F4      		brne .L26
 610               		.loc 1 516 0 is_stmt 0 discriminator 1
 611 059c 8091 0000 		lds r24,bankStates+1
 612 05a0 8130      		cpi r24,lo8(1)
 613 05a2 01F4      		brne .L26
 614 05a4 00C0      		rjmp .L47
 615               	.L26:
 517:WTPA.c        **** 				{
 518:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 519:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 520:WTPA.c        **** 				}
 521:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 616               		.loc 1 521 0 is_stmt 1
 617 05a6 4091 0000 		lds r20,bankStates+31
 618 05aa 5091 0000 		lds r21,bankStates+31+1
 619 05ae 6091 0000 		lds r22,bankStates+31+2
 620 05b2 7091 0000 		lds r23,bankStates+31+3
 621 05b6 8091 0000 		lds r24,bankStates+24
 622 05ba 9091 0000 		lds r25,bankStates+24+1
 623 05be A091 0000 		lds r26,bankStates+24+2
 624 05c2 B091 0000 		lds r27,bankStates+24+3
 625 05c6 4817      		cp r20,r24
 626 05c8 5907      		cpc r21,r25
 627 05ca 6A07      		cpc r22,r26
 628 05cc 7B07      		cpc r23,r27
 629 05ce 01F4      		brne .L27
 522:WTPA.c        **** 				{
 523:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 630               		.loc 1 523 0
 631 05d0 8091 0000 		lds r24,bankStates+20
 632 05d4 9091 0000 		lds r25,bankStates+20+1
 633 05d8 A091 0000 		lds r26,bankStates+20+2
 634 05dc B091 0000 		lds r27,bankStates+20+3
 635 05e0 00C0      		rjmp .L48
 636               	.L27:
 524:WTPA.c        **** 				}
 525:WTPA.c        **** 				else
 526:WTPA.c        **** 				{
 527:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 637               		.loc 1 527 0
 638 05e2 4091 0000 		lds r20,bankStates+31
 639 05e6 5091 0000 		lds r21,bankStates+31+1
 640 05ea 6091 0000 		lds r22,bankStates+31+2
 641 05ee 7091 0000 		lds r23,bankStates+31+3
 642 05f2 8091 0000 		lds r24,bankStates+16
 643 05f6 9091 0000 		lds r25,bankStates+16+1
 644 05fa A091 0000 		lds r26,bankStates+16+2
 645 05fe B091 0000 		lds r27,bankStates+16+3
 646 0602 4817      		cp r20,r24
 647 0604 5907      		cpc r21,r25
 648 0606 6A07      		cpc r22,r26
 649 0608 7B07      		cpc r23,r27
 650 060a 01F4      		brne .L28
 528:WTPA.c        **** 					{
 529:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 651               		.loc 1 529 0
 652 060c 8091 0000 		lds r24,bankStates+12
 653 0610 9091 0000 		lds r25,bankStates+12+1
 654 0614 A091 0000 		lds r26,bankStates+12+2
 655 0618 B091 0000 		lds r27,bankStates+12+3
 656 061c 00C0      		rjmp .L48
 657               	.L28:
 530:WTPA.c        **** 					}
 531:WTPA.c        **** 					else
 532:WTPA.c        **** 					{
 533:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 658               		.loc 1 533 0
 659 061e 8091 0000 		lds r24,bankStates+31
 660 0622 9091 0000 		lds r25,bankStates+31+1
 661 0626 A091 0000 		lds r26,bankStates+31+2
 662 062a B091 0000 		lds r27,bankStates+31+3
 663 062e 0197      		sbiw r24,1
 664 0630 A109      		sbc r26,__zero_reg__
 665 0632 B109      		sbc r27,__zero_reg__
 666 0634 00C0      		rjmp .L48
 667               	.L25:
 534:WTPA.c        **** 					}
 535:WTPA.c        **** 				}
 536:WTPA.c        **** 			}
 537:WTPA.c        **** 			else	// Going forward through the sample.
 538:WTPA.c        **** 			{
 539:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 668               		.loc 1 539 0
 669 0636 8091 0000 		lds r24,bankStates+20
 670 063a 9091 0000 		lds r25,bankStates+20+1
 671 063e A091 0000 		lds r26,bankStates+20+2
 672 0642 B091 0000 		lds r27,bankStates+20+3
 673 0646 4817      		cp r20,r24
 674 0648 5907      		cpc r21,r25
 675 064a 6A07      		cpc r22,r26
 676 064c 7B07      		cpc r23,r27
 677 064e 01F4      		brne .L29
 678               		.loc 1 539 0 is_stmt 0 discriminator 1
 679 0650 8091 0000 		lds r24,bankStates+1
 680 0654 8130      		cpi r24,lo8(1)
 681 0656 01F4      		brne .L29
 682               	.L47:
 540:WTPA.c        **** 				{
 541:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 683               		.loc 1 541 0 is_stmt 1
 684 0658 1092 0000 		sts bankStates,__zero_reg__
 542:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 685               		.loc 1 542 0
 686 065c 1092 0000 		sts bankStates+9,__zero_reg__
 687 0660 00C0      		rjmp .L23
 688               	.L29:
 543:WTPA.c        **** 				}
 544:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 689               		.loc 1 544 0
 690 0662 4091 0000 		lds r20,bankStates+31
 691 0666 5091 0000 		lds r21,bankStates+31+1
 692 066a 6091 0000 		lds r22,bankStates+31+2
 693 066e 7091 0000 		lds r23,bankStates+31+3
 694 0672 8091 0000 		lds r24,bankStates+20
 695 0676 9091 0000 		lds r25,bankStates+20+1
 696 067a A091 0000 		lds r26,bankStates+20+2
 697 067e B091 0000 		lds r27,bankStates+20+3
 698 0682 4817      		cp r20,r24
 699 0684 5907      		cpc r21,r25
 700 0686 6A07      		cpc r22,r26
 701 0688 7B07      		cpc r23,r27
 702 068a 01F4      		brne .L30
 545:WTPA.c        **** 				{
 546:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 703               		.loc 1 546 0
 704 068c 8091 0000 		lds r24,bankStates+24
 705 0690 9091 0000 		lds r25,bankStates+24+1
 706 0694 A091 0000 		lds r26,bankStates+24+2
 707 0698 B091 0000 		lds r27,bankStates+24+3
 708 069c 00C0      		rjmp .L48
 709               	.L30:
 547:WTPA.c        **** 				}
 548:WTPA.c        **** 				else
 549:WTPA.c        **** 				{
 550:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 710               		.loc 1 550 0
 711 069e 4091 0000 		lds r20,bankStates+31
 712 06a2 5091 0000 		lds r21,bankStates+31+1
 713 06a6 6091 0000 		lds r22,bankStates+31+2
 714 06aa 7091 0000 		lds r23,bankStates+31+3
 715 06ae 8091 0000 		lds r24,bankStates+12
 716 06b2 9091 0000 		lds r25,bankStates+12+1
 717 06b6 A091 0000 		lds r26,bankStates+12+2
 718 06ba B091 0000 		lds r27,bankStates+12+3
 719 06be 4817      		cp r20,r24
 720 06c0 5907      		cpc r21,r25
 721 06c2 6A07      		cpc r22,r26
 722 06c4 7B07      		cpc r23,r27
 723 06c6 01F4      		brne .L31
 551:WTPA.c        **** 					{
 552:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 724               		.loc 1 552 0
 725 06c8 8091 0000 		lds r24,bankStates+16
 726 06cc 9091 0000 		lds r25,bankStates+16+1
 727 06d0 A091 0000 		lds r26,bankStates+16+2
 728 06d4 B091 0000 		lds r27,bankStates+16+3
 729 06d8 00C0      		rjmp .L48
 730               	.L31:
 553:WTPA.c        **** 					}
 554:WTPA.c        **** 					else
 555:WTPA.c        **** 					{
 556:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 731               		.loc 1 556 0
 732 06da 8091 0000 		lds r24,bankStates+31
 733 06de 9091 0000 		lds r25,bankStates+31+1
 734 06e2 A091 0000 		lds r26,bankStates+31+2
 735 06e6 B091 0000 		lds r27,bankStates+31+3
 736 06ea 0196      		adiw r24,1
 737 06ec A11D      		adc r26,__zero_reg__
 738 06ee B11D      		adc r27,__zero_reg__
 739               	.L48:
 740 06f0 8093 0000 		sts bankStates+31,r24
 741 06f4 9093 0000 		sts bankStates+31+1,r25
 742 06f8 A093 0000 		sts bankStates+31+2,r26
 743 06fc B093 0000 		sts bankStates+31+3,r27
 744               	.L23:
 557:WTPA.c        **** 					}
 558:WTPA.c        **** 				}
 559:WTPA.c        **** 			}
 560:WTPA.c        **** 		}
 561:WTPA.c        **** 
 562:WTPA.c        **** 		// Finished calculating address, bus should be settled, so finish the exchange with RAM
 563:WTPA.c        **** 
 564:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 745               		.loc 1 564 0
 746 0700 83B1      		in r24,0x3
 747               	.LVL10:
 565:WTPA.c        **** 
 566:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 748               		.loc 1 566 0
 749 0702 129A      		sbi 0x2,2
 567:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 750               		.loc 1 567 0
 751 0704 9FEF      		ldi r25,lo8(-1)
 752 0706 94B9      		out 0x4,r25
 568:WTPA.c        **** 
 569:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 753               		.loc 1 569 0
 754 0708 9091 0000 		lds r25,bankStates+8
 755 070c 9923      		tst r25
 756 070e 01F0      		breq .L32
 570:WTPA.c        **** 		{
 571:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 757               		.loc 1 571 0
 758 0710 8058      		subi r24,lo8(-(-128))
 759               	.LVL11:
 572:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 760               		.loc 1 572 0
 761 0712 9091 0000 		lds r25,bankStates+8
 762 0716 2FEF      		ldi r18,lo8(-1)
 763 0718 30E0      		ldi r19,0
 764 071a 092E      		mov r0,r25
 765 071c 00C0      		rjmp 2f
 766               		1:
 767 071e 220F      		lsl r18
 768               		2:
 769 0720 0A94      		dec r0
 770 0722 02F4      		brpl 1b
 771 0724 8223      		and r24,r18
 772               	.LVL12:
 573:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 773               		.loc 1 573 0
 774 0726 8058      		subi r24,lo8(-(-128))
 775               	.LVL13:
 776               	.L32:
 574:WTPA.c        **** 		}
 575:WTPA.c        **** 
 576:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 777               		.loc 1 576 0
 778 0728 2091 0000 		lds r18,adcByte
 779 072c 3327      		clr r19
 780 072e 27FD      		sbrc r18,7
 781 0730 3095      		com r19
 782 0732 280F      		add r18,r24
 783 0734 311D      		adc r19,__zero_reg__
 784 0736 87FD      		sbrc r24,7
 785 0738 3A95      		dec r19
 786 073a 2038      		cpi r18,-128
 787 073c 9FEF      		ldi r25,-1
 788 073e 3907      		cpc r19,r25
 789 0740 04F4      		brge .L33
 790 0742 20E8      		ldi r18,lo8(-128)
 791 0744 3FEF      		ldi r19,lo8(-1)
 792               	.L33:
 793               	.LVL14:
 577:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 578:WTPA.c        **** 		{
 579:WTPA.c        **** 			sum=127;
 580:WTPA.c        **** 		}
 581:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 582:WTPA.c        **** 		{
 583:WTPA.c        **** 			sum=-128;
 584:WTPA.c        **** 		}
 585:WTPA.c        **** 
 586:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 794               		.loc 1 586 0
 795 0746 2038      		cpi r18,-128
 796 0748 3105      		cpc r19,__zero_reg__
 797 074a 04F0      		brlt .L34
 798 074c 2FE7      		ldi r18,lo8(127)
 799 074e 30E0      		ldi r19,0
 800               	.LVL15:
 801               	.L34:
 802 0750 25B9      		out 0x5,r18
 587:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 803               		.loc 1 587 0
 804 0752 1198      		cbi 0x2,1
 588:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 805               		.loc 1 588 0
 806 0754 119A      		sbi 0x2,1
 589:WTPA.c        **** 		break;
 807               		.loc 1 589 0
 808 0756 0895      		ret
 809               	.LVL16:
 810               	.L35:
 297:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 811               		.loc 1 297 0
 812 0758 80E0      		ldi r24,0
 813               	.LVL17:
 814               	.L2:
 590:WTPA.c        **** 	}
 591:WTPA.c        **** 
 592:WTPA.c        **** 	return(outputByte);
 593:WTPA.c        **** }
 815               		.loc 1 593 0
 816 075a 0895      		ret
 817               		.cfi_endproc
 818               	.LFE1:
 821               	UpdateAudioChannel1:
 822               	.LFB2:
 594:WTPA.c        **** 
 595:WTPA.c        **** static unsigned char UpdateAudioChannel1(void)
 596:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 597:WTPA.c        **** {
 823               		.loc 1 597 0
 824               		.cfi_startproc
 825 075c 0F93      		push r16
 826               	.LCFI0:
 827               		.cfi_def_cfa_offset 3
 828               		.cfi_offset 16, -2
 829 075e 1F93      		push r17
 830               	.LCFI1:
 831               		.cfi_def_cfa_offset 4
 832               		.cfi_offset 17, -3
 833               	/* prologue: function */
 834               	/* frame size = 0 */
 835               	/* stack size = 2 */
 836               	.L__stack_usage = 2
 837               	.LVL18:
 598:WTPA.c        **** 	signed int
 599:WTPA.c        **** 		sum;			// For doing saturated adds.
 600:WTPA.c        **** 	signed char
 601:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 602:WTPA.c        **** 	static unsigned char
 603:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 604:WTPA.c        **** 
 605:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 606:WTPA.c        **** 
 607:WTPA.c        **** 	switch(bankStates[BANK_1].audioFunction)
 838               		.loc 1 607 0
 839 0760 8091 0000 		lds r24,bankStates+35
 840 0764 8330      		cpi r24,lo8(3)
 841 0766 01F0      		breq .L56
 842 0768 00F4      		brsh .L59
 843 076a 8130      		cpi r24,lo8(1)
 844 076c 01F0      		breq .L54
 845 076e 8230      		cpi r24,lo8(2)
 846 0770 01F0      		breq .+2
 847 0772 00C0      		rjmp .L86
 848 0774 00C0      		rjmp .L55
 849               	.L59:
 850 0776 8430      		cpi r24,lo8(4)
 851 0778 01F4      		brne .+2
 852 077a 00C0      		rjmp .L57
 853 077c 8530      		cpi r24,lo8(5)
 854 077e 01F0      		breq .+2
 855 0780 00C0      		rjmp .L86
 856 0782 00C0      		rjmp .L58
 857               	.L54:
 608:WTPA.c        **** 	{
 609:WTPA.c        **** 
 610:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 611:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 612:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 858               		.loc 1 612 0
 859 0784 8091 0000 		lds r24,sawtooth.1763
 860               	.LVL19:
 861 0788 982F      		mov r25,r24
 862 078a 9F5F      		subi r25,lo8(-(1))
 863 078c 9093 0000 		sts sawtooth.1763,r25
 613:WTPA.c        **** 		break;
 864               		.loc 1 613 0
 865 0790 00C0      		rjmp .L53
 866               	.LVL20:
 867               	.L55:
 614:WTPA.c        **** 
 615:WTPA.c        **** 		case AUDIO_REALTIME:
 616:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 617:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 868               		.loc 1 617 0
 869 0792 8091 0000 		lds r24,adcByte
 870               	.LVL21:
 871 0796 00C0      		rjmp .L102
 872               	.LVL22:
 873               	.L56:
 618:WTPA.c        **** 
 619:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 620:WTPA.c        **** 		{
 621:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 622:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 623:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 624:WTPA.c        **** 		}
 625:WTPA.c        **** 		break;
 626:WTPA.c        **** 
 627:WTPA.c        **** 		case AUDIO_RECORD:
 628:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 629:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 874               		.loc 1 629 0
 875 0798 8FEF      		ldi r24,lo8(-1)
 876 079a 84B9      		out 0x4,r24
 630:WTPA.c        **** 
 631:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 877               		.loc 1 631 0
 878 079c 8091 0000 		lds r24,bankStates+66
 879 07a0 9091 0000 		lds r25,bankStates+66+1
 880 07a4 A091 0000 		lds r26,bankStates+66+2
 881 07a8 B091 0000 		lds r27,bankStates+66+3
 882 07ac 85B9      		out 0x5,r24
 632:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 883               		.loc 1 632 0
 884 07ae 139A      		sbi 0x2,3
 633:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 885               		.loc 1 633 0
 886 07b0 1398      		cbi 0x2,3
 634:WTPA.c        **** 
 635:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 887               		.loc 1 635 0
 888 07b2 8091 0000 		lds r24,bankStates+66
 889 07b6 9091 0000 		lds r25,bankStates+66+1
 890 07ba A091 0000 		lds r26,bankStates+66+2
 891 07be B091 0000 		lds r27,bankStates+66+3
 892 07c2 892F      		mov r24,r25
 893 07c4 9A2F      		mov r25,r26
 894 07c6 AB2F      		mov r26,r27
 895 07c8 BB27      		clr r27
 896 07ca 85B9      		out 0x5,r24
 636:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 897               		.loc 1 636 0
 898 07cc 149A      		sbi 0x2,4
 637:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 899               		.loc 1 637 0
 900 07ce 1498      		cbi 0x2,4
 638:WTPA.c        **** 
 639:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 901               		.loc 1 639 0
 902 07d0 8091 0000 		lds r24,bankStates+66
 903 07d4 9091 0000 		lds r25,bankStates+66+1
 904 07d8 A091 0000 		lds r26,bankStates+66+2
 905 07dc B091 0000 		lds r27,bankStates+66+3
 906 07e0 CD01      		movw r24,r26
 907 07e2 AA27      		clr r26
 908 07e4 BB27      		clr r27
 909 07e6 8770      		andi r24,7
 910 07e8 9927      		clr r25
 911 07ea AA27      		clr r26
 912 07ec BB27      		clr r27
 913 07ee 8868      		ori r24,136
 914 07f0 88B9      		out 0x8,r24
 640:WTPA.c        **** 
 641:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 915               		.loc 1 641 0
 916 07f2 8091 0000 		lds r24,adcByte
 917 07f6 85B9      		out 0x5,r24
 642:WTPA.c        **** 
 643:WTPA.c        **** 		// Compute address while bus settles.
 644:WTPA.c        **** 
 645:WTPA.c        **** 		bankStates[BANK_1].currentAddress--;									// Next address please.
 918               		.loc 1 645 0
 919 07f8 8091 0000 		lds r24,bankStates+66
 920 07fc 9091 0000 		lds r25,bankStates+66+1
 921 0800 A091 0000 		lds r26,bankStates+66+2
 922 0804 B091 0000 		lds r27,bankStates+66+3
 923 0808 0197      		sbiw r24,1
 924 080a A109      		sbc r26,__zero_reg__
 925 080c B109      		sbc r27,__zero_reg__
 926 080e 8093 0000 		sts bankStates+66,r24
 927 0812 9093 0000 		sts bankStates+66+1,r25
 928 0816 A093 0000 		sts bankStates+66+2,r26
 929 081a B093 0000 		sts bankStates+66+3,r27
 646:WTPA.c        **** 		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the
 930               		.loc 1 646 0
 931 081e 8091 0000 		lds r24,bankStates+66
 932 0822 9091 0000 		lds r25,bankStates+66+1
 933 0826 A091 0000 		lds r26,bankStates+66+2
 934 082a B091 0000 		lds r27,bankStates+66+3
 935 082e 8093 0000 		sts bankStates+47,r24
 936 0832 9093 0000 		sts bankStates+47+1,r25
 937 0836 A093 0000 		sts bankStates+47+2,r26
 938 083a B093 0000 		sts bankStates+47+3,r27
 647:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address 
 939               		.loc 1 647 0
 940 083e 8091 0000 		lds r24,bankStates+66
 941 0842 9091 0000 		lds r25,bankStates+66+1
 942 0846 A091 0000 		lds r26,bankStates+66+2
 943 084a B091 0000 		lds r27,bankStates+66+3
 944 084e 8093 0000 		sts bankStates+55,r24
 945 0852 9093 0000 		sts bankStates+55+1,r25
 946 0856 A093 0000 		sts bankStates+55+2,r26
 947 085a B093 0000 		sts bankStates+55+3,r27
 648:WTPA.c        **** 
 649:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 948               		.loc 1 649 0
 949 085e 4091 0000 		lds r20,bankStates+12
 950 0862 5091 0000 		lds r21,bankStates+12+1
 951 0866 6091 0000 		lds r22,bankStates+12+2
 952 086a 7091 0000 		lds r23,bankStates+12+3
 953 086e 8091 0000 		lds r24,bankStates+47
 954 0872 9091 0000 		lds r25,bankStates+47+1
 955 0876 A091 0000 		lds r26,bankStates+47+2
 956 087a B091 0000 		lds r27,bankStates+47+3
 957 087e 4817      		cp r20,r24
 958 0880 5907      		cpc r21,r25
 959 0882 6A07      		cpc r22,r26
 960 0884 7B07      		cpc r23,r27
 961 0886 00F0      		brlo .L60
 650:WTPA.c        **** 		{
 651:WTPA.c        **** 			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 962               		.loc 1 651 0
 963 0888 1092 0000 		sts bankStates+35,__zero_reg__
 652:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 964               		.loc 1 652 0
 965 088c 81E0      		ldi r24,lo8(1)
 966 088e 8093 0000 		sts outOfRam,r24
 967               	.L60:
 653:WTPA.c        **** 		}
 654:WTPA.c        **** 
 655:WTPA.c        **** 		// Put data into RAM.
 656:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 968               		.loc 1 656 0
 969 0892 1198      		cbi 0x2,1
 657:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 970               		.loc 1 657 0
 971 0894 119A      		sbi 0x2,1
 972 0896 00C0      		rjmp .L86
 973               	.L57:
 658:WTPA.c        **** 		break;
 659:WTPA.c        **** 
 660:WTPA.c        **** 		case AUDIO_PLAYBACK:
 661:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 662:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 663:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 664:WTPA.c        **** 
 665:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 666:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 974               		.loc 1 666 0
 975 0898 8091 0000 		lds r24,bankStates+66
 976 089c 9091 0000 		lds r25,bankStates+66+1
 977 08a0 A091 0000 		lds r26,bankStates+66+2
 978 08a4 B091 0000 		lds r27,bankStates+66+3
 979 08a8 85B9      		out 0x5,r24
 667:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 980               		.loc 1 667 0
 981 08aa 139A      		sbi 0x2,3
 668:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 982               		.loc 1 668 0
 983 08ac 1398      		cbi 0x2,3
 669:WTPA.c        **** 
 670:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 984               		.loc 1 670 0
 985 08ae 8091 0000 		lds r24,bankStates+66
 986 08b2 9091 0000 		lds r25,bankStates+66+1
 987 08b6 A091 0000 		lds r26,bankStates+66+2
 988 08ba B091 0000 		lds r27,bankStates+66+3
 989 08be 892F      		mov r24,r25
 990 08c0 9A2F      		mov r25,r26
 991 08c2 AB2F      		mov r26,r27
 992 08c4 BB27      		clr r27
 993 08c6 85B9      		out 0x5,r24
 671:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 994               		.loc 1 671 0
 995 08c8 149A      		sbi 0x2,4
 672:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 996               		.loc 1 672 0
 997 08ca 1498      		cbi 0x2,4
 673:WTPA.c        **** 
 674:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 998               		.loc 1 674 0
 999 08cc 8091 0000 		lds r24,bankStates+66
 1000 08d0 9091 0000 		lds r25,bankStates+66+1
 1001 08d4 A091 0000 		lds r26,bankStates+66+2
 1002 08d8 B091 0000 		lds r27,bankStates+66+3
 1003 08dc CD01      		movw r24,r26
 1004 08de AA27      		clr r26
 1005 08e0 BB27      		clr r27
 1006 08e2 8770      		andi r24,7
 1007 08e4 9927      		clr r25
 1008 08e6 AA27      		clr r26
 1009 08e8 BB27      		clr r27
 1010 08ea 8868      		ori r24,136
 1011 08ec 88B9      		out 0x8,r24
 675:WTPA.c        **** 
 676:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1012               		.loc 1 676 0
 1013 08ee 14B8      		out 0x4,__zero_reg__
 677:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1014               		.loc 1 677 0
 1015 08f0 1298      		cbi 0x2,2
 678:WTPA.c        **** 
 679:WTPA.c        **** 		// Calculate addy while bus settles (used to be nops here)
 680:WTPA.c        **** 
 681:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1016               		.loc 1 681 0
 1017 08f2 8091 0000 		lds r24,bankStates+41
 1018 08f6 8823      		tst r24
 1019 08f8 01F4      		brne .+2
 1020 08fa 00C0      		rjmp .L61
 682:WTPA.c        **** 		{
 683:WTPA.c        **** 			// Slice first, only worry about forward ###
 684:WTPA.c        **** 
 685:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1021               		.loc 1 685 0
 1022 08fc 8091 0000 		lds r24,sliceRemaining+4
 1023 0900 9091 0000 		lds r25,sliceRemaining+4+1
 1024 0904 A091 0000 		lds r26,sliceRemaining+4+2
 1025 0908 B091 0000 		lds r27,sliceRemaining+4+3
 1026 090c 892B      		or r24,r25
 1027 090e 8A2B      		or r24,r26
 1028 0910 8B2B      		or r24,r27
 1029 0912 01F0      		breq .L62
 686:WTPA.c        **** 			{
 687:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1030               		.loc 1 687 0
 1031 0914 8091 0000 		lds r24,bankStates+66
 1032 0918 9091 0000 		lds r25,bankStates+66+1
 1033 091c A091 0000 		lds r26,bankStates+66+2
 1034 0920 B091 0000 		lds r27,bankStates+66+3
 1035 0924 0197      		sbiw r24,1
 1036 0926 A109      		sbc r26,__zero_reg__
 1037 0928 B109      		sbc r27,__zero_reg__
 1038 092a 8093 0000 		sts bankStates+66,r24
 1039 092e 9093 0000 		sts bankStates+66+1,r25
 1040 0932 A093 0000 		sts bankStates+66+2,r26
 1041 0936 B093 0000 		sts bankStates+66+3,r27
 688:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1042               		.loc 1 688 0
 1043 093a 8091 0000 		lds r24,sliceRemaining+4
 1044 093e 9091 0000 		lds r25,sliceRemaining+4+1
 1045 0942 A091 0000 		lds r26,sliceRemaining+4+2
 1046 0946 B091 0000 		lds r27,sliceRemaining+4+3
 1047 094a 0197      		sbiw r24,1
 1048 094c A109      		sbc r26,__zero_reg__
 1049 094e B109      		sbc r27,__zero_reg__
 1050 0950 8093 0000 		sts sliceRemaining+4,r24
 1051 0954 9093 0000 		sts sliceRemaining+4+1,r25
 1052 0958 A093 0000 		sts sliceRemaining+4+2,r26
 1053 095c B093 0000 		sts sliceRemaining+4+3,r27
 1054 0960 00C0      		rjmp .L63
 1055               	.L62:
 689:WTPA.c        **** 			}
 690:WTPA.c        **** 			else	// Slice done, jump to new slice.
 691:WTPA.c        **** 			{
 692:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1056               		.loc 1 692 0
 1057 0962 8091 0000 		lds r24,sliceSize+4
 1058 0966 9091 0000 		lds r25,sliceSize+4+1
 1059 096a A091 0000 		lds r26,sliceSize+4+2
 1060 096e B091 0000 		lds r27,sliceSize+4+3
 1061 0972 8093 0000 		sts sliceRemaining+4,r24
 1062 0976 9093 0000 		sts sliceRemaining+4+1,r25
 1063 097a A093 0000 		sts sliceRemaining+4+2,r26
 1064 097e B093 0000 		sts sliceRemaining+4+3,r27
 693:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1065               		.loc 1 693 0
 1066 0982 8091 0000 		lds r24,granularPositionArrayPointer+1
 1067 0986 8F5F      		subi r24,lo8(-(1))
 1068 0988 8093 0000 		sts granularPositionArrayPointer+1,r24
 694:WTPA.c        **** 
 695:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1069               		.loc 1 695 0
 1070 098c 9091 0000 		lds r25,granularPositionArrayPointer+1
 1071 0990 8091 0000 		lds r24,bankStates+41
 1072 0994 9813      		cpse r25,r24
 1073 0996 00C0      		rjmp .L64
 696:WTPA.c        **** 				{
 697:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1074               		.loc 1 697 0
 1075 0998 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1076               	.L64:
 698:WTPA.c        **** 				}
 699:WTPA.c        **** 
 700:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1077               		.loc 1 700 0
 1078 099c E091 0000 		lds r30,granularPositionArrayPointer+1
 1079 09a0 2091 0000 		lds r18,sliceSize+4
 1080 09a4 3091 0000 		lds r19,sliceSize+4+1
 1081 09a8 4091 0000 		lds r20,sliceSize+4+2
 1082 09ac 5091 0000 		lds r21,sliceSize+4+3
 1083 09b0 F0E0      		ldi r31,0
 1084 09b2 E050      		subi r30,lo8(-(granularPositionArray+128))
 1085 09b4 F040      		sbci r31,hi8(-(granularPositionArray+128))
 1086 09b6 A081      		ld r26,Z
 1087 09b8 B0E0      		ldi r27,0
 1088 09ba 0E94 0000 		call __muluhisi3
 1089 09be 0FEF      		ldi r16,lo8(-1)
 1090 09c0 1FEF      		ldi r17,lo8(-1)
 1091 09c2 27E0      		ldi r18,lo8(7)
 1092 09c4 30E0      		ldi r19,0
 1093 09c6 061B      		sub r16,r22
 1094 09c8 170B      		sbc r17,r23
 1095 09ca 280B      		sbc r18,r24
 1096 09cc 390B      		sbc r19,r25
 1097 09ce 0093 0000 		sts bankStates+66,r16
 1098 09d2 1093 0000 		sts bankStates+66+1,r17
 1099 09d6 2093 0000 		sts bankStates+66+2,r18
 1100 09da 3093 0000 		sts bankStates+66+3,r19
 1101 09de 00C0      		rjmp .L63
 1102               	.L61:
 701:WTPA.c        **** 			}
 702:WTPA.c        **** 		}
 703:WTPA.c        **** 		else
 704:WTPA.c        **** 		{
 705:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1103               		.loc 1 705 0
 1104 09e0 8091 0000 		lds r24,bankStates+39
 706:WTPA.c        **** 			{
 707:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1105               		.loc 1 707 0
 1106 09e4 4091 0000 		lds r20,bankStates+66
 1107 09e8 5091 0000 		lds r21,bankStates+66+1
 1108 09ec 6091 0000 		lds r22,bankStates+66+2
 1109 09f0 7091 0000 		lds r23,bankStates+66+3
 705:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1110               		.loc 1 705 0
 1111 09f4 8111      		cpse r24,__zero_reg__
 1112 09f6 00C0      		rjmp .L65
 1113               		.loc 1 707 0
 1114 09f8 8091 0000 		lds r24,bankStates+59
 1115 09fc 9091 0000 		lds r25,bankStates+59+1
 1116 0a00 A091 0000 		lds r26,bankStates+59+2
 1117 0a04 B091 0000 		lds r27,bankStates+59+3
 1118 0a08 4817      		cp r20,r24
 1119 0a0a 5907      		cpc r21,r25
 1120 0a0c 6A07      		cpc r22,r26
 1121 0a0e 7B07      		cpc r23,r27
 1122 0a10 01F4      		brne .L66
 1123               		.loc 1 707 0 is_stmt 0 discriminator 1
 1124 0a12 8091 0000 		lds r24,bankStates+36
 1125 0a16 8130      		cpi r24,lo8(1)
 1126 0a18 01F4      		brne .L66
 1127 0a1a 00C0      		rjmp .L96
 1128               	.L66:
 708:WTPA.c        **** 				{
 709:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 710:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 711:WTPA.c        **** 				}
 712:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1129               		.loc 1 712 0 is_stmt 1
 1130 0a1c 4091 0000 		lds r20,bankStates+66
 1131 0a20 5091 0000 		lds r21,bankStates+66+1
 1132 0a24 6091 0000 		lds r22,bankStates+66+2
 1133 0a28 7091 0000 		lds r23,bankStates+66+3
 1134 0a2c 8091 0000 		lds r24,bankStates+59
 1135 0a30 9091 0000 		lds r25,bankStates+59+1
 1136 0a34 A091 0000 		lds r26,bankStates+59+2
 1137 0a38 B091 0000 		lds r27,bankStates+59+3
 1138 0a3c 4817      		cp r20,r24
 1139 0a3e 5907      		cpc r21,r25
 1140 0a40 6A07      		cpc r22,r26
 1141 0a42 7B07      		cpc r23,r27
 1142 0a44 01F4      		brne .L67
 713:WTPA.c        **** 				{
 714:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1143               		.loc 1 714 0
 1144 0a46 8091 0000 		lds r24,bankStates+55
 1145 0a4a 9091 0000 		lds r25,bankStates+55+1
 1146 0a4e A091 0000 		lds r26,bankStates+55+2
 1147 0a52 B091 0000 		lds r27,bankStates+55+3
 1148 0a56 00C0      		rjmp .L97
 1149               	.L67:
 715:WTPA.c        **** 				}
 716:WTPA.c        **** 				else
 717:WTPA.c        **** 				{
 718:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1150               		.loc 1 718 0
 1151 0a58 4091 0000 		lds r20,bankStates+66
 1152 0a5c 5091 0000 		lds r21,bankStates+66+1
 1153 0a60 6091 0000 		lds r22,bankStates+66+2
 1154 0a64 7091 0000 		lds r23,bankStates+66+3
 1155 0a68 8091 0000 		lds r24,bankStates+51
 1156 0a6c 9091 0000 		lds r25,bankStates+51+1
 1157 0a70 A091 0000 		lds r26,bankStates+51+2
 1158 0a74 B091 0000 		lds r27,bankStates+51+3
 1159 0a78 4817      		cp r20,r24
 1160 0a7a 5907      		cpc r21,r25
 1161 0a7c 6A07      		cpc r22,r26
 1162 0a7e 7B07      		cpc r23,r27
 1163 0a80 01F4      		brne .L68
 719:WTPA.c        **** 					{
 720:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1164               		.loc 1 720 0
 1165 0a82 8091 0000 		lds r24,bankStates+47
 1166 0a86 9091 0000 		lds r25,bankStates+47+1
 1167 0a8a A091 0000 		lds r26,bankStates+47+2
 1168 0a8e B091 0000 		lds r27,bankStates+47+3
 1169 0a92 00C0      		rjmp .L97
 1170               	.L68:
 721:WTPA.c        **** 					}
 722:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 723:WTPA.c        **** 					{
 724:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1171               		.loc 1 724 0
 1172 0a94 8091 0000 		lds r24,bankStates+66
 1173 0a98 9091 0000 		lds r25,bankStates+66+1
 1174 0a9c A091 0000 		lds r26,bankStates+66+2
 1175 0aa0 B091 0000 		lds r27,bankStates+66+3
 1176 0aa4 0196      		adiw r24,1
 1177 0aa6 A11D      		adc r26,__zero_reg__
 1178 0aa8 B11D      		adc r27,__zero_reg__
 1179 0aaa 00C0      		rjmp .L97
 1180               	.L65:
 725:WTPA.c        **** 					}
 726:WTPA.c        **** 				}
 727:WTPA.c        **** 			}
 728:WTPA.c        **** 			else	// Going forward through the sample.
 729:WTPA.c        **** 			{
 730:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1181               		.loc 1 730 0
 1182 0aac 8091 0000 		lds r24,bankStates+55
 1183 0ab0 9091 0000 		lds r25,bankStates+55+1
 1184 0ab4 A091 0000 		lds r26,bankStates+55+2
 1185 0ab8 B091 0000 		lds r27,bankStates+55+3
 1186 0abc 4817      		cp r20,r24
 1187 0abe 5907      		cpc r21,r25
 1188 0ac0 6A07      		cpc r22,r26
 1189 0ac2 7B07      		cpc r23,r27
 1190 0ac4 01F4      		brne .L69
 1191               		.loc 1 730 0 is_stmt 0 discriminator 1
 1192 0ac6 8091 0000 		lds r24,bankStates+36
 1193 0aca 8130      		cpi r24,lo8(1)
 1194 0acc 01F4      		brne .L69
 1195               	.L96:
 731:WTPA.c        **** 				{
 732:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1196               		.loc 1 732 0 is_stmt 1
 1197 0ace 1092 0000 		sts bankStates+35,__zero_reg__
 733:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1198               		.loc 1 733 0
 1199 0ad2 1092 0000 		sts bankStates+44,__zero_reg__
 1200 0ad6 00C0      		rjmp .L63
 1201               	.L69:
 734:WTPA.c        **** 				}
 735:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1202               		.loc 1 735 0
 1203 0ad8 4091 0000 		lds r20,bankStates+66
 1204 0adc 5091 0000 		lds r21,bankStates+66+1
 1205 0ae0 6091 0000 		lds r22,bankStates+66+2
 1206 0ae4 7091 0000 		lds r23,bankStates+66+3
 1207 0ae8 8091 0000 		lds r24,bankStates+55
 1208 0aec 9091 0000 		lds r25,bankStates+55+1
 1209 0af0 A091 0000 		lds r26,bankStates+55+2
 1210 0af4 B091 0000 		lds r27,bankStates+55+3
 1211 0af8 4817      		cp r20,r24
 1212 0afa 5907      		cpc r21,r25
 1213 0afc 6A07      		cpc r22,r26
 1214 0afe 7B07      		cpc r23,r27
 1215 0b00 01F4      		brne .L70
 736:WTPA.c        **** 				{
 737:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1216               		.loc 1 737 0
 1217 0b02 8091 0000 		lds r24,bankStates+59
 1218 0b06 9091 0000 		lds r25,bankStates+59+1
 1219 0b0a A091 0000 		lds r26,bankStates+59+2
 1220 0b0e B091 0000 		lds r27,bankStates+59+3
 1221 0b12 00C0      		rjmp .L97
 1222               	.L70:
 738:WTPA.c        **** 				}
 739:WTPA.c        **** 				else
 740:WTPA.c        **** 				{
 741:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1223               		.loc 1 741 0
 1224 0b14 4091 0000 		lds r20,bankStates+66
 1225 0b18 5091 0000 		lds r21,bankStates+66+1
 1226 0b1c 6091 0000 		lds r22,bankStates+66+2
 1227 0b20 7091 0000 		lds r23,bankStates+66+3
 1228 0b24 8091 0000 		lds r24,bankStates+47
 1229 0b28 9091 0000 		lds r25,bankStates+47+1
 1230 0b2c A091 0000 		lds r26,bankStates+47+2
 1231 0b30 B091 0000 		lds r27,bankStates+47+3
 1232 0b34 4817      		cp r20,r24
 1233 0b36 5907      		cpc r21,r25
 1234 0b38 6A07      		cpc r22,r26
 1235 0b3a 7B07      		cpc r23,r27
 1236 0b3c 01F4      		brne .L71
 742:WTPA.c        **** 					{
 743:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1237               		.loc 1 743 0
 1238 0b3e 8091 0000 		lds r24,bankStates+51
 1239 0b42 9091 0000 		lds r25,bankStates+51+1
 1240 0b46 A091 0000 		lds r26,bankStates+51+2
 1241 0b4a B091 0000 		lds r27,bankStates+51+3
 1242 0b4e 00C0      		rjmp .L97
 1243               	.L71:
 744:WTPA.c        **** 					}
 745:WTPA.c        **** 					else
 746:WTPA.c        **** 					{
 747:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1244               		.loc 1 747 0
 1245 0b50 8091 0000 		lds r24,bankStates+66
 1246 0b54 9091 0000 		lds r25,bankStates+66+1
 1247 0b58 A091 0000 		lds r26,bankStates+66+2
 1248 0b5c B091 0000 		lds r27,bankStates+66+3
 1249 0b60 0197      		sbiw r24,1
 1250 0b62 A109      		sbc r26,__zero_reg__
 1251 0b64 B109      		sbc r27,__zero_reg__
 1252               	.L97:
 1253 0b66 8093 0000 		sts bankStates+66,r24
 1254 0b6a 9093 0000 		sts bankStates+66+1,r25
 1255 0b6e A093 0000 		sts bankStates+66+2,r26
 1256 0b72 B093 0000 		sts bankStates+66+3,r27
 1257               	.L63:
 748:WTPA.c        **** 					}
 749:WTPA.c        **** 				}
 750:WTPA.c        **** 			}
 751:WTPA.c        **** 		}
 752:WTPA.c        **** 
 753:WTPA.c        **** 		// Done with addy, read RAM.
 754:WTPA.c        **** 
 755:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 1258               		.loc 1 755 0
 1259 0b76 83B1      		in r24,0x3
 1260               	.LVL23:
 756:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1261               		.loc 1 756 0
 1262 0b78 129A      		sbi 0x2,2
 757:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1263               		.loc 1 757 0
 1264 0b7a 9FEF      		ldi r25,lo8(-1)
 1265 0b7c 94B9      		out 0x4,r25
 1266               	.L102:
 758:WTPA.c        **** 
 759:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1267               		.loc 1 759 0
 1268 0b7e 9091 0000 		lds r25,bankStates+43
 1269 0b82 9923      		tst r25
 1270 0b84 01F4      		brne .+2
 1271 0b86 00C0      		rjmp .L53
 760:WTPA.c        **** 		{
 761:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1272               		.loc 1 761 0
 1273 0b88 8058      		subi r24,lo8(-(-128))
 1274               	.LVL24:
 762:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1275               		.loc 1 762 0
 1276 0b8a 9091 0000 		lds r25,bankStates+43
 1277 0b8e 2FEF      		ldi r18,lo8(-1)
 1278 0b90 30E0      		ldi r19,0
 1279 0b92 092E      		mov r0,r25
 1280 0b94 00C0      		rjmp 2f
 1281               		1:
 1282 0b96 220F      		lsl r18
 1283               		2:
 1284 0b98 0A94      		dec r0
 1285 0b9a 02F4      		brpl 1b
 1286 0b9c 8223      		and r24,r18
 1287               	.LVL25:
 763:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1288               		.loc 1 763 0
 1289 0b9e 8058      		subi r24,lo8(-(-128))
 1290               	.LVL26:
 1291 0ba0 00C0      		rjmp .L53
 1292               	.LVL27:
 1293               	.L58:
 764:WTPA.c        **** 		}
 765:WTPA.c        **** 		break;
 766:WTPA.c        **** 
 767:WTPA.c        **** 		case AUDIO_OVERDUB:
 768:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 769:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 770:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 1294               		.loc 1 770 0
 1295 0ba2 8091 0000 		lds r24,bankStates+66
 1296 0ba6 9091 0000 		lds r25,bankStates+66+1
 1297 0baa A091 0000 		lds r26,bankStates+66+2
 1298 0bae B091 0000 		lds r27,bankStates+66+3
 1299 0bb2 85B9      		out 0x5,r24
 771:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 1300               		.loc 1 771 0
 1301 0bb4 139A      		sbi 0x2,3
 772:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 1302               		.loc 1 772 0
 1303 0bb6 1398      		cbi 0x2,3
 773:WTPA.c        **** 
 774:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 1304               		.loc 1 774 0
 1305 0bb8 8091 0000 		lds r24,bankStates+66
 1306 0bbc 9091 0000 		lds r25,bankStates+66+1
 1307 0bc0 A091 0000 		lds r26,bankStates+66+2
 1308 0bc4 B091 0000 		lds r27,bankStates+66+3
 1309 0bc8 892F      		mov r24,r25
 1310 0bca 9A2F      		mov r25,r26
 1311 0bcc AB2F      		mov r26,r27
 1312 0bce BB27      		clr r27
 1313 0bd0 85B9      		out 0x5,r24
 775:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 1314               		.loc 1 775 0
 1315 0bd2 149A      		sbi 0x2,4
 776:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 1316               		.loc 1 776 0
 1317 0bd4 1498      		cbi 0x2,4
 777:WTPA.c        **** 
 778:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 1318               		.loc 1 778 0
 1319 0bd6 8091 0000 		lds r24,bankStates+66
 1320 0bda 9091 0000 		lds r25,bankStates+66+1
 1321 0bde A091 0000 		lds r26,bankStates+66+2
 1322 0be2 B091 0000 		lds r27,bankStates+66+3
 1323 0be6 CD01      		movw r24,r26
 1324 0be8 AA27      		clr r26
 1325 0bea BB27      		clr r27
 1326 0bec 8770      		andi r24,7
 1327 0bee 9927      		clr r25
 1328 0bf0 AA27      		clr r26
 1329 0bf2 BB27      		clr r27
 1330 0bf4 8868      		ori r24,136
 1331 0bf6 88B9      		out 0x8,r24
 779:WTPA.c        **** 
 780:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1332               		.loc 1 780 0
 1333 0bf8 14B8      		out 0x4,__zero_reg__
 781:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1334               		.loc 1 781 0
 1335 0bfa 1298      		cbi 0x2,2
 782:WTPA.c        **** 
 783:WTPA.c        **** 		// Do some operations while we wait for the data bus to settle from turnaround.
 784:WTPA.c        **** 
 785:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1336               		.loc 1 785 0
 1337 0bfc 8091 0000 		lds r24,bankStates+41
 1338 0c00 8823      		tst r24
 1339 0c02 01F4      		brne .+2
 1340 0c04 00C0      		rjmp .L72
 786:WTPA.c        **** 		{
 787:WTPA.c        **** 			// Slice first, only worry about forward ###
 788:WTPA.c        **** 
 789:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1341               		.loc 1 789 0
 1342 0c06 8091 0000 		lds r24,sliceRemaining+4
 1343 0c0a 9091 0000 		lds r25,sliceRemaining+4+1
 1344 0c0e A091 0000 		lds r26,sliceRemaining+4+2
 1345 0c12 B091 0000 		lds r27,sliceRemaining+4+3
 1346 0c16 892B      		or r24,r25
 1347 0c18 8A2B      		or r24,r26
 1348 0c1a 8B2B      		or r24,r27
 1349 0c1c 01F0      		breq .L73
 790:WTPA.c        **** 			{
 791:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1350               		.loc 1 791 0
 1351 0c1e 8091 0000 		lds r24,bankStates+66
 1352 0c22 9091 0000 		lds r25,bankStates+66+1
 1353 0c26 A091 0000 		lds r26,bankStates+66+2
 1354 0c2a B091 0000 		lds r27,bankStates+66+3
 1355 0c2e 0197      		sbiw r24,1
 1356 0c30 A109      		sbc r26,__zero_reg__
 1357 0c32 B109      		sbc r27,__zero_reg__
 1358 0c34 8093 0000 		sts bankStates+66,r24
 1359 0c38 9093 0000 		sts bankStates+66+1,r25
 1360 0c3c A093 0000 		sts bankStates+66+2,r26
 1361 0c40 B093 0000 		sts bankStates+66+3,r27
 792:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1362               		.loc 1 792 0
 1363 0c44 8091 0000 		lds r24,sliceRemaining+4
 1364 0c48 9091 0000 		lds r25,sliceRemaining+4+1
 1365 0c4c A091 0000 		lds r26,sliceRemaining+4+2
 1366 0c50 B091 0000 		lds r27,sliceRemaining+4+3
 1367 0c54 0197      		sbiw r24,1
 1368 0c56 A109      		sbc r26,__zero_reg__
 1369 0c58 B109      		sbc r27,__zero_reg__
 1370 0c5a 8093 0000 		sts sliceRemaining+4,r24
 1371 0c5e 9093 0000 		sts sliceRemaining+4+1,r25
 1372 0c62 A093 0000 		sts sliceRemaining+4+2,r26
 1373 0c66 B093 0000 		sts sliceRemaining+4+3,r27
 1374 0c6a 00C0      		rjmp .L74
 1375               	.L73:
 793:WTPA.c        **** 			}
 794:WTPA.c        **** 			else	// Slice done, jump to new slice.
 795:WTPA.c        **** 			{
 796:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1376               		.loc 1 796 0
 1377 0c6c 8091 0000 		lds r24,sliceSize+4
 1378 0c70 9091 0000 		lds r25,sliceSize+4+1
 1379 0c74 A091 0000 		lds r26,sliceSize+4+2
 1380 0c78 B091 0000 		lds r27,sliceSize+4+3
 1381 0c7c 8093 0000 		sts sliceRemaining+4,r24
 1382 0c80 9093 0000 		sts sliceRemaining+4+1,r25
 1383 0c84 A093 0000 		sts sliceRemaining+4+2,r26
 1384 0c88 B093 0000 		sts sliceRemaining+4+3,r27
 797:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1385               		.loc 1 797 0
 1386 0c8c 8091 0000 		lds r24,granularPositionArrayPointer+1
 1387 0c90 8F5F      		subi r24,lo8(-(1))
 1388 0c92 8093 0000 		sts granularPositionArrayPointer+1,r24
 798:WTPA.c        **** 
 799:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1389               		.loc 1 799 0
 1390 0c96 9091 0000 		lds r25,granularPositionArrayPointer+1
 1391 0c9a 8091 0000 		lds r24,bankStates+41
 1392 0c9e 9813      		cpse r25,r24
 1393 0ca0 00C0      		rjmp .L75
 800:WTPA.c        **** 				{
 801:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1394               		.loc 1 801 0
 1395 0ca2 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1396               	.L75:
 802:WTPA.c        **** 				}
 803:WTPA.c        **** 
 804:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1397               		.loc 1 804 0
 1398 0ca6 E091 0000 		lds r30,granularPositionArrayPointer+1
 1399 0caa 2091 0000 		lds r18,sliceSize+4
 1400 0cae 3091 0000 		lds r19,sliceSize+4+1
 1401 0cb2 4091 0000 		lds r20,sliceSize+4+2
 1402 0cb6 5091 0000 		lds r21,sliceSize+4+3
 1403 0cba F0E0      		ldi r31,0
 1404 0cbc E050      		subi r30,lo8(-(granularPositionArray+128))
 1405 0cbe F040      		sbci r31,hi8(-(granularPositionArray+128))
 1406 0cc0 A081      		ld r26,Z
 1407 0cc2 B0E0      		ldi r27,0
 1408 0cc4 0E94 0000 		call __muluhisi3
 1409 0cc8 0FEF      		ldi r16,lo8(-1)
 1410 0cca 1FEF      		ldi r17,lo8(-1)
 1411 0ccc 27E0      		ldi r18,lo8(7)
 1412 0cce 30E0      		ldi r19,0
 1413 0cd0 061B      		sub r16,r22
 1414 0cd2 170B      		sbc r17,r23
 1415 0cd4 280B      		sbc r18,r24
 1416 0cd6 390B      		sbc r19,r25
 1417 0cd8 0093 0000 		sts bankStates+66,r16
 1418 0cdc 1093 0000 		sts bankStates+66+1,r17
 1419 0ce0 2093 0000 		sts bankStates+66+2,r18
 1420 0ce4 3093 0000 		sts bankStates+66+3,r19
 1421 0ce8 00C0      		rjmp .L74
 1422               	.L72:
 805:WTPA.c        **** 			}
 806:WTPA.c        **** 		}
 807:WTPA.c        **** 		else
 808:WTPA.c        **** 		{
 809:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1423               		.loc 1 809 0
 1424 0cea 8091 0000 		lds r24,bankStates+39
 810:WTPA.c        **** 			{
 811:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1425               		.loc 1 811 0
 1426 0cee 4091 0000 		lds r20,bankStates+66
 1427 0cf2 5091 0000 		lds r21,bankStates+66+1
 1428 0cf6 6091 0000 		lds r22,bankStates+66+2
 1429 0cfa 7091 0000 		lds r23,bankStates+66+3
 809:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1430               		.loc 1 809 0
 1431 0cfe 8111      		cpse r24,__zero_reg__
 1432 0d00 00C0      		rjmp .L76
 1433               		.loc 1 811 0
 1434 0d02 8091 0000 		lds r24,bankStates+59
 1435 0d06 9091 0000 		lds r25,bankStates+59+1
 1436 0d0a A091 0000 		lds r26,bankStates+59+2
 1437 0d0e B091 0000 		lds r27,bankStates+59+3
 1438 0d12 4817      		cp r20,r24
 1439 0d14 5907      		cpc r21,r25
 1440 0d16 6A07      		cpc r22,r26
 1441 0d18 7B07      		cpc r23,r27
 1442 0d1a 01F4      		brne .L77
 1443               		.loc 1 811 0 is_stmt 0 discriminator 1
 1444 0d1c 8091 0000 		lds r24,bankStates+36
 1445 0d20 8130      		cpi r24,lo8(1)
 1446 0d22 01F4      		brne .L77
 1447 0d24 00C0      		rjmp .L98
 1448               	.L77:
 812:WTPA.c        **** 				{
 813:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 814:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 815:WTPA.c        **** 				}
 816:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1449               		.loc 1 816 0 is_stmt 1
 1450 0d26 4091 0000 		lds r20,bankStates+66
 1451 0d2a 5091 0000 		lds r21,bankStates+66+1
 1452 0d2e 6091 0000 		lds r22,bankStates+66+2
 1453 0d32 7091 0000 		lds r23,bankStates+66+3
 1454 0d36 8091 0000 		lds r24,bankStates+59
 1455 0d3a 9091 0000 		lds r25,bankStates+59+1
 1456 0d3e A091 0000 		lds r26,bankStates+59+2
 1457 0d42 B091 0000 		lds r27,bankStates+59+3
 1458 0d46 4817      		cp r20,r24
 1459 0d48 5907      		cpc r21,r25
 1460 0d4a 6A07      		cpc r22,r26
 1461 0d4c 7B07      		cpc r23,r27
 1462 0d4e 01F4      		brne .L78
 817:WTPA.c        **** 				{
 818:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1463               		.loc 1 818 0
 1464 0d50 8091 0000 		lds r24,bankStates+55
 1465 0d54 9091 0000 		lds r25,bankStates+55+1
 1466 0d58 A091 0000 		lds r26,bankStates+55+2
 1467 0d5c B091 0000 		lds r27,bankStates+55+3
 1468 0d60 00C0      		rjmp .L99
 1469               	.L78:
 819:WTPA.c        **** 				}
 820:WTPA.c        **** 				else
 821:WTPA.c        **** 				{
 822:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1470               		.loc 1 822 0
 1471 0d62 4091 0000 		lds r20,bankStates+66
 1472 0d66 5091 0000 		lds r21,bankStates+66+1
 1473 0d6a 6091 0000 		lds r22,bankStates+66+2
 1474 0d6e 7091 0000 		lds r23,bankStates+66+3
 1475 0d72 8091 0000 		lds r24,bankStates+51
 1476 0d76 9091 0000 		lds r25,bankStates+51+1
 1477 0d7a A091 0000 		lds r26,bankStates+51+2
 1478 0d7e B091 0000 		lds r27,bankStates+51+3
 1479 0d82 4817      		cp r20,r24
 1480 0d84 5907      		cpc r21,r25
 1481 0d86 6A07      		cpc r22,r26
 1482 0d88 7B07      		cpc r23,r27
 1483 0d8a 01F4      		brne .L79
 823:WTPA.c        **** 					{
 824:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1484               		.loc 1 824 0
 1485 0d8c 8091 0000 		lds r24,bankStates+47
 1486 0d90 9091 0000 		lds r25,bankStates+47+1
 1487 0d94 A091 0000 		lds r26,bankStates+47+2
 1488 0d98 B091 0000 		lds r27,bankStates+47+3
 1489 0d9c 00C0      		rjmp .L99
 1490               	.L79:
 825:WTPA.c        **** 					}
 826:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 827:WTPA.c        **** 					{
 828:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1491               		.loc 1 828 0
 1492 0d9e 8091 0000 		lds r24,bankStates+66
 1493 0da2 9091 0000 		lds r25,bankStates+66+1
 1494 0da6 A091 0000 		lds r26,bankStates+66+2
 1495 0daa B091 0000 		lds r27,bankStates+66+3
 1496 0dae 0196      		adiw r24,1
 1497 0db0 A11D      		adc r26,__zero_reg__
 1498 0db2 B11D      		adc r27,__zero_reg__
 1499 0db4 00C0      		rjmp .L99
 1500               	.L76:
 829:WTPA.c        **** 					}
 830:WTPA.c        **** 				}
 831:WTPA.c        **** 			}
 832:WTPA.c        **** 			else	// Going forward through the sample.
 833:WTPA.c        **** 			{
 834:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1501               		.loc 1 834 0
 1502 0db6 8091 0000 		lds r24,bankStates+55
 1503 0dba 9091 0000 		lds r25,bankStates+55+1
 1504 0dbe A091 0000 		lds r26,bankStates+55+2
 1505 0dc2 B091 0000 		lds r27,bankStates+55+3
 1506 0dc6 4817      		cp r20,r24
 1507 0dc8 5907      		cpc r21,r25
 1508 0dca 6A07      		cpc r22,r26
 1509 0dcc 7B07      		cpc r23,r27
 1510 0dce 01F4      		brne .L80
 1511               		.loc 1 834 0 is_stmt 0 discriminator 1
 1512 0dd0 8091 0000 		lds r24,bankStates+36
 1513 0dd4 8130      		cpi r24,lo8(1)
 1514 0dd6 01F4      		brne .L80
 1515               	.L98:
 835:WTPA.c        **** 				{
 836:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1516               		.loc 1 836 0 is_stmt 1
 1517 0dd8 1092 0000 		sts bankStates+35,__zero_reg__
 837:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1518               		.loc 1 837 0
 1519 0ddc 1092 0000 		sts bankStates+44,__zero_reg__
 1520 0de0 00C0      		rjmp .L74
 1521               	.L80:
 838:WTPA.c        **** 				}
 839:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1522               		.loc 1 839 0
 1523 0de2 4091 0000 		lds r20,bankStates+66
 1524 0de6 5091 0000 		lds r21,bankStates+66+1
 1525 0dea 6091 0000 		lds r22,bankStates+66+2
 1526 0dee 7091 0000 		lds r23,bankStates+66+3
 1527 0df2 8091 0000 		lds r24,bankStates+55
 1528 0df6 9091 0000 		lds r25,bankStates+55+1
 1529 0dfa A091 0000 		lds r26,bankStates+55+2
 1530 0dfe B091 0000 		lds r27,bankStates+55+3
 1531 0e02 4817      		cp r20,r24
 1532 0e04 5907      		cpc r21,r25
 1533 0e06 6A07      		cpc r22,r26
 1534 0e08 7B07      		cpc r23,r27
 1535 0e0a 01F4      		brne .L81
 840:WTPA.c        **** 				{
 841:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1536               		.loc 1 841 0
 1537 0e0c 8091 0000 		lds r24,bankStates+59
 1538 0e10 9091 0000 		lds r25,bankStates+59+1
 1539 0e14 A091 0000 		lds r26,bankStates+59+2
 1540 0e18 B091 0000 		lds r27,bankStates+59+3
 1541 0e1c 00C0      		rjmp .L99
 1542               	.L81:
 842:WTPA.c        **** 				}
 843:WTPA.c        **** 				else
 844:WTPA.c        **** 				{
 845:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1543               		.loc 1 845 0
 1544 0e1e 4091 0000 		lds r20,bankStates+66
 1545 0e22 5091 0000 		lds r21,bankStates+66+1
 1546 0e26 6091 0000 		lds r22,bankStates+66+2
 1547 0e2a 7091 0000 		lds r23,bankStates+66+3
 1548 0e2e 8091 0000 		lds r24,bankStates+47
 1549 0e32 9091 0000 		lds r25,bankStates+47+1
 1550 0e36 A091 0000 		lds r26,bankStates+47+2
 1551 0e3a B091 0000 		lds r27,bankStates+47+3
 1552 0e3e 4817      		cp r20,r24
 1553 0e40 5907      		cpc r21,r25
 1554 0e42 6A07      		cpc r22,r26
 1555 0e44 7B07      		cpc r23,r27
 1556 0e46 01F4      		brne .L82
 846:WTPA.c        **** 					{
 847:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1557               		.loc 1 847 0
 1558 0e48 8091 0000 		lds r24,bankStates+51
 1559 0e4c 9091 0000 		lds r25,bankStates+51+1
 1560 0e50 A091 0000 		lds r26,bankStates+51+2
 1561 0e54 B091 0000 		lds r27,bankStates+51+3
 1562 0e58 00C0      		rjmp .L99
 1563               	.L82:
 848:WTPA.c        **** 					}
 849:WTPA.c        **** 					else
 850:WTPA.c        **** 					{
 851:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1564               		.loc 1 851 0
 1565 0e5a 8091 0000 		lds r24,bankStates+66
 1566 0e5e 9091 0000 		lds r25,bankStates+66+1
 1567 0e62 A091 0000 		lds r26,bankStates+66+2
 1568 0e66 B091 0000 		lds r27,bankStates+66+3
 1569 0e6a 0197      		sbiw r24,1
 1570 0e6c A109      		sbc r26,__zero_reg__
 1571 0e6e B109      		sbc r27,__zero_reg__
 1572               	.L99:
 1573 0e70 8093 0000 		sts bankStates+66,r24
 1574 0e74 9093 0000 		sts bankStates+66+1,r25
 1575 0e78 A093 0000 		sts bankStates+66+2,r26
 1576 0e7c B093 0000 		sts bankStates+66+3,r27
 1577               	.L74:
 852:WTPA.c        **** 					}
 853:WTPA.c        **** 				}
 854:WTPA.c        **** 			}
 855:WTPA.c        **** 		}
 856:WTPA.c        **** 
 857:WTPA.c        **** 		// Finished with addy stuff, now finish data transfer
 858:WTPA.c        **** 
 859:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 1578               		.loc 1 859 0
 1579 0e80 83B1      		in r24,0x3
 1580               	.LVL28:
 860:WTPA.c        **** 
 861:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1581               		.loc 1 861 0
 1582 0e82 129A      		sbi 0x2,2
 862:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1583               		.loc 1 862 0
 1584 0e84 9FEF      		ldi r25,lo8(-1)
 1585 0e86 94B9      		out 0x4,r25
 863:WTPA.c        **** 
 864:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1586               		.loc 1 864 0
 1587 0e88 9091 0000 		lds r25,bankStates+43
 1588 0e8c 9923      		tst r25
 1589 0e8e 01F0      		breq .L83
 865:WTPA.c        **** 		{
 866:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1590               		.loc 1 866 0
 1591 0e90 8058      		subi r24,lo8(-(-128))
 1592               	.LVL29:
 867:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1593               		.loc 1 867 0
 1594 0e92 9091 0000 		lds r25,bankStates+43
 1595 0e96 2FEF      		ldi r18,lo8(-1)
 1596 0e98 30E0      		ldi r19,0
 1597 0e9a 092E      		mov r0,r25
 1598 0e9c 00C0      		rjmp 2f
 1599               		1:
 1600 0e9e 220F      		lsl r18
 1601               		2:
 1602 0ea0 0A94      		dec r0
 1603 0ea2 02F4      		brpl 1b
 1604 0ea4 8223      		and r24,r18
 1605               	.LVL30:
 868:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1606               		.loc 1 868 0
 1607 0ea6 8058      		subi r24,lo8(-(-128))
 1608               	.LVL31:
 1609               	.L83:
 869:WTPA.c        **** 		}
 870:WTPA.c        **** 
 871:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 1610               		.loc 1 871 0
 1611 0ea8 2091 0000 		lds r18,adcByte
 1612 0eac 3327      		clr r19
 1613 0eae 27FD      		sbrc r18,7
 1614 0eb0 3095      		com r19
 1615 0eb2 280F      		add r18,r24
 1616 0eb4 311D      		adc r19,__zero_reg__
 1617 0eb6 87FD      		sbrc r24,7
 1618 0eb8 3A95      		dec r19
 1619 0eba 2038      		cpi r18,-128
 1620 0ebc 9FEF      		ldi r25,-1
 1621 0ebe 3907      		cpc r19,r25
 1622 0ec0 04F4      		brge .L84
 1623 0ec2 20E8      		ldi r18,lo8(-128)
 1624 0ec4 3FEF      		ldi r19,lo8(-1)
 1625               	.L84:
 1626               	.LVL32:
 872:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 873:WTPA.c        **** 		{
 874:WTPA.c        **** 			sum=127;
 875:WTPA.c        **** 		}
 876:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 877:WTPA.c        **** 		{
 878:WTPA.c        **** 			sum=-128;
 879:WTPA.c        **** 		}
 880:WTPA.c        **** 
 881:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 1627               		.loc 1 881 0
 1628 0ec6 2038      		cpi r18,-128
 1629 0ec8 3105      		cpc r19,__zero_reg__
 1630 0eca 04F0      		brlt .L85
 1631 0ecc 2FE7      		ldi r18,lo8(127)
 1632 0ece 30E0      		ldi r19,0
 1633               	.LVL33:
 1634               	.L85:
 1635 0ed0 25B9      		out 0x5,r18
 882:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 1636               		.loc 1 882 0
 1637 0ed2 1198      		cbi 0x2,1
 883:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 1638               		.loc 1 883 0
 1639 0ed4 119A      		sbi 0x2,1
 884:WTPA.c        **** 		break;
 1640               		.loc 1 884 0
 1641 0ed6 00C0      		rjmp .L53
 1642               	.LVL34:
 1643               	.L86:
 605:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 1644               		.loc 1 605 0
 1645 0ed8 80E0      		ldi r24,0
 1646               	.LVL35:
 1647               	.L53:
 1648               	/* epilogue start */
 885:WTPA.c        **** 	}
 886:WTPA.c        **** 
 887:WTPA.c        **** 	return(outputByte);
 888:WTPA.c        **** }
 1649               		.loc 1 888 0
 1650 0eda 1F91      		pop r17
 1651 0edc 0F91      		pop r16
 1652 0ede 0895      		ret
 1653               		.cfi_endproc
 1654               	.LFE2:
 1657               	OutputMultiplyBanks:
 1658               	.LFB3:
 889:WTPA.c        **** 
 890:WTPA.c        **** //-----------------------------------------------------------------------------
 891:WTPA.c        **** //-----------------------------------------------------------------------------
 892:WTPA.c        **** // DAC output handling and sample combination functions:
 893:WTPA.c        **** // These functions are called (via pointer) everytime a bank updates.
 894:WTPA.c        **** // They worry about summing (or whatever) the different audio sources and spitting them out on the 
 895:WTPA.c        **** //-----------------------------------------------------------------------------
 896:WTPA.c        **** //-----------------------------------------------------------------------------
 897:WTPA.c        **** 
 898:WTPA.c        **** // Globals used in the audio and output update functions.
 899:WTPA.c        **** 
 900:WTPA.c        **** typedef void OUTPUT_FUNCTION(void);	// Creates a datatype -- a void function called OUTPUT_FUNCTION
 901:WTPA.c        **** 
 902:WTPA.c        **** OUTPUT_FUNCTION					// Assigns a pointer called UpdateOutput to an instance of OUTPUT_FUNCTION()
 903:WTPA.c        **** 	*UpdateOutput;
 904:WTPA.c        **** 
 905:WTPA.c        **** static signed char
 906:WTPA.c        **** 	extIsrOutputBank0,
 907:WTPA.c        **** 	extIsrOutputBank1,
 908:WTPA.c        **** 	midiOutputBank0,
 909:WTPA.c        **** 	midiOutputBank1,
 910:WTPA.c        **** 	sdStreamOutput;		// Contribution to DAC coming directly off the SD card
 911:WTPA.c        **** 
 912:WTPA.c        **** static unsigned char
 913:WTPA.c        **** 	lastDacByte;	// Very possible we haven't changed output values since last time (like for instance 
 914:WTPA.c        **** 
 915:WTPA.c        **** static void OutputMultiplyBanks(void)
 916:WTPA.c        **** // Multiply the audio output of banks0 and 1 and spit it out
 917:WTPA.c        **** {
 1659               		.loc 1 917 0
 1660               		.cfi_startproc
 1661               	/* prologue: function */
 1662               	/* frame size = 0 */
 1663               	/* stack size = 0 */
 1664               	.L__stack_usage = 0
 918:WTPA.c        **** 	signed int
 919:WTPA.c        **** 		sum0,			// Temporary variables for saturated adds, multiplies, other math.
 920:WTPA.c        **** 		sum1;
 921:WTPA.c        **** 
 922:WTPA.c        **** 	unsigned char
 923:WTPA.c        **** 		output;			// What to put on the DAC
 924:WTPA.c        **** 
 925:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1665               		.loc 1 925 0
 1666 0ee0 8091 0000 		lds r24,extIsrOutputBank0
 1667 0ee4 2091 0000 		lds r18,midiOutputBank0
 1668 0ee8 3327      		clr r19
 1669 0eea 27FD      		sbrc r18,7
 1670 0eec 3095      		com r19
 1671 0eee 280F      		add r18,r24
 1672 0ef0 311D      		adc r19,__zero_reg__
 1673 0ef2 87FD      		sbrc r24,7
 1674 0ef4 3A95      		dec r19
 1675 0ef6 2038      		cpi r18,-128
 1676 0ef8 4FEF      		ldi r20,-1
 1677 0efa 3407      		cpc r19,r20
 1678 0efc 04F4      		brge .L104
 1679 0efe 20E8      		ldi r18,lo8(-128)
 1680 0f00 3FEF      		ldi r19,lo8(-1)
 1681               	.L104:
 1682               	.LVL36:
 926:WTPA.c        **** 	if(sum0>127)		// Pin high.
 927:WTPA.c        **** 	{
 928:WTPA.c        **** 		sum0=127;
 929:WTPA.c        **** 	}
 930:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
 931:WTPA.c        **** 	{
 932:WTPA.c        **** 		sum0=-128;
 933:WTPA.c        **** 	}
 934:WTPA.c        **** 
 935:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1683               		.loc 1 935 0
 1684 0f02 4091 0000 		lds r20,extIsrOutputBank1
 1685 0f06 8091 0000 		lds r24,midiOutputBank1
 1686 0f0a 9927      		clr r25
 1687 0f0c 87FD      		sbrc r24,7
 1688 0f0e 9095      		com r25
 1689 0f10 840F      		add r24,r20
 1690 0f12 911D      		adc r25,__zero_reg__
 1691 0f14 47FD      		sbrc r20,7
 1692 0f16 9A95      		dec r25
 1693 0f18 8138      		cpi r24,-127
 1694 0f1a 4FEF      		ldi r20,-1
 1695 0f1c 9407      		cpc r25,r20
 1696 0f1e 04F4      		brge .L105
 1697 0f20 81E8      		ldi r24,lo8(-127)
 1698 0f22 9FEF      		ldi r25,lo8(-1)
 1699               	.L105:
 1700               	.LVL37:
 936:WTPA.c        **** 	if(sum1>127)		// Pin high.
 937:WTPA.c        **** 	{
 938:WTPA.c        **** 		sum1=127;
 939:WTPA.c        **** 	}
 940:WTPA.c        **** 	else if(sum1<-127)		// Pin low.  (was pegged to -128)
 941:WTPA.c        **** 	{
 942:WTPA.c        **** 		sum1=-127;
 943:WTPA.c        **** 	}
 944:WTPA.c        **** 
 945:WTPA.c        **** 	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale ou
 1701               		.loc 1 945 0
 1702 0f24 2038      		cpi r18,-128
 1703 0f26 3105      		cpc r19,__zero_reg__
 1704 0f28 04F0      		brlt .L106
 1705 0f2a 2FE7      		ldi r18,lo8(127)
 1706 0f2c 30E0      		ldi r19,0
 1707               	.LVL38:
 1708               	.L106:
 1709 0f2e 8038      		cpi r24,-128
 1710 0f30 9105      		cpc r25,__zero_reg__
 1711 0f32 04F0      		brlt .L107
 1712 0f34 8FE7      		ldi r24,lo8(127)
 1713 0f36 90E0      		ldi r25,0
 1714               	.LVL39:
 1715               	.L107:
 1716 0f38 289F      		mul r18,r24
 1717 0f3a A001      		movw r20,r0
 1718 0f3c 299F      		mul r18,r25
 1719 0f3e 500D      		add r21,r0
 1720 0f40 389F      		mul r19,r24
 1721 0f42 500D      		add r21,r0
 1722 0f44 1124      		clr r1
 1723 0f46 57FF      		sbrs r21,7
 1724 0f48 00C0      		rjmp .L108
 1725 0f4a 415C      		subi r20,-63
 1726 0f4c 5F4F      		sbci r21,-1
 1727               	.L108:
 1728 0f4e CA01      		movw r24,r20
 1729 0f50 46E0      		ldi r20,6
 1730               		1:
 1731 0f52 9595      		asr r25
 1732 0f54 8795      		ror r24
 1733 0f56 4A95      		dec r20
 1734 0f58 01F4      		brne 1b
 946:WTPA.c        **** 
 947:WTPA.c        **** //@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the re
 948:WTPA.c        **** //@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide 
 949:WTPA.c        **** 
 950:WTPA.c        **** 	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
 1735               		.loc 1 950 0
 1736 0f5a 8058      		subi r24,128
 1737 0f5c 9095      		com r25
 1738 0f5e 282F      		mov r18,r24
 1739               	.LVL40:
 951:WTPA.c        **** 
 952:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1740               		.loc 1 952 0
 1741 0f60 3091 0000 		lds r19,lastDacByte
 1742 0f64 8317      		cp r24,r19
 1743 0f66 01F0      		breq .L109
 953:WTPA.c        **** 	{
 954:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1744               		.loc 1 954 0
 1745 0f68 9FEF      		ldi r25,lo8(-1)
 1746 0f6a 94B9      		out 0x4,r25
 955:WTPA.c        **** 
 956:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1747               		.loc 1 956 0
 1748 0f6c 85B9      		out 0x5,r24
 957:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1749               		.loc 1 957 0
 1750 0f6e 159A      		sbi 0x2,5
 958:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1751               		.loc 1 958 0
 1752 0f70 1598      		cbi 0x2,5
 1753               	.L109:
 959:WTPA.c        **** 	}
 960:WTPA.c        **** 
 961:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1754               		.loc 1 961 0
 1755 0f72 2093 0000 		sts lastDacByte,r18
 1756 0f76 0895      		ret
 1757               		.cfi_endproc
 1758               	.LFE3:
 1761               	OutputAddBanks:
 1762               	.LFB4:
 962:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
 963:WTPA.c        **** }
 964:WTPA.c        **** 
 965:WTPA.c        **** static void OutputAddBanks(void)
 966:WTPA.c        **** // Add audio from the two banks and spit it out (normally what we do)
 967:WTPA.c        **** {
 1763               		.loc 1 967 0
 1764               		.cfi_startproc
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 0 */
 1768               	.L__stack_usage = 0
 968:WTPA.c        **** 	signed int
 969:WTPA.c        **** 		sum0;				// Temporary variables for saturated adds, multiplies, other math.
 970:WTPA.c        **** 
 971:WTPA.c        **** 	unsigned char
 972:WTPA.c        **** 		output;			// What to put on the DAC
 973:WTPA.c        **** 
 974:WTPA.c        **** //	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everythi
 975:WTPA.c        **** 	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum e
 1769               		.loc 1 975 0
 1770 0f78 2091 0000 		lds r18,extIsrOutputBank0
 1771 0f7c 8091 0000 		lds r24,extIsrOutputBank1
 1772 0f80 9927      		clr r25
 1773 0f82 87FD      		sbrc r24,7
 1774 0f84 9095      		com r25
 1775 0f86 820F      		add r24,r18
 1776 0f88 911D      		adc r25,__zero_reg__
 1777 0f8a 27FD      		sbrc r18,7
 1778 0f8c 9A95      		dec r25
 1779 0f8e 2091 0000 		lds r18,midiOutputBank0
 1780 0f92 820F      		add r24,r18
 1781 0f94 911D      		adc r25,__zero_reg__
 1782 0f96 27FD      		sbrc r18,7
 1783 0f98 9A95      		dec r25
 1784 0f9a 2091 0000 		lds r18,midiOutputBank1
 1785 0f9e 820F      		add r24,r18
 1786 0fa0 911D      		adc r25,__zero_reg__
 1787 0fa2 27FD      		sbrc r18,7
 1788 0fa4 9A95      		dec r25
 1789 0fa6 2091 0000 		lds r18,sdStreamOutput
 1790 0faa 820F      		add r24,r18
 1791 0fac 911D      		adc r25,__zero_reg__
 1792 0fae 27FD      		sbrc r18,7
 1793 0fb0 9A95      		dec r25
 1794 0fb2 8038      		cpi r24,-128
 1795 0fb4 2FEF      		ldi r18,-1
 1796 0fb6 9207      		cpc r25,r18
 1797 0fb8 04F4      		brge .L111
 1798 0fba 80E8      		ldi r24,lo8(-128)
 1799 0fbc 9FEF      		ldi r25,lo8(-1)
 1800               	.L111:
 1801               	.LVL41:
 976:WTPA.c        **** 	if(sum0>127)		// Pin high.
 977:WTPA.c        **** 	{
 978:WTPA.c        **** 		sum0=127;
 979:WTPA.c        **** 	}
 980:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
 981:WTPA.c        **** 	{
 982:WTPA.c        **** 		sum0=-128;
 983:WTPA.c        **** 	}
 984:WTPA.c        **** 	output=(signed char)sum0;		// Cast back to 8 bits.
 985:WTPA.c        **** 	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
 1802               		.loc 1 985 0
 1803 0fbe 8038      		cpi r24,-128
 1804 0fc0 9105      		cpc r25,__zero_reg__
 1805 0fc2 04F0      		brlt .L112
 1806 0fc4 8FE7      		ldi r24,lo8(127)
 1807 0fc6 90E0      		ldi r25,0
 1808               	.LVL42:
 1809               	.L112:
 1810 0fc8 8058      		subi r24,128
 1811 0fca 282F      		mov r18,r24
 1812               	.LVL43:
 986:WTPA.c        **** 
 987:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1813               		.loc 1 987 0
 1814 0fcc 3091 0000 		lds r19,lastDacByte
 1815 0fd0 8317      		cp r24,r19
 1816 0fd2 01F0      		breq .L113
 988:WTPA.c        **** 	{
 989:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1817               		.loc 1 989 0
 1818 0fd4 9FEF      		ldi r25,lo8(-1)
 1819 0fd6 94B9      		out 0x4,r25
 990:WTPA.c        **** 
 991:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1820               		.loc 1 991 0
 1821 0fd8 85B9      		out 0x5,r24
 992:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1822               		.loc 1 992 0
 1823 0fda 159A      		sbi 0x2,5
 993:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1824               		.loc 1 993 0
 1825 0fdc 1598      		cbi 0x2,5
 1826               	.L113:
 994:WTPA.c        **** 	}
 995:WTPA.c        **** 
 996:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1827               		.loc 1 996 0
 1828 0fde 2093 0000 		sts lastDacByte,r18
 1829 0fe2 0895      		ret
 1830               		.cfi_endproc
 1831               	.LFE4:
 1834               	OutputXorBanks:
 1835               	.LFB5:
 997:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
 998:WTPA.c        **** }
 999:WTPA.c        **** 
1000:WTPA.c        **** static void OutputXorBanks(void)
1001:WTPA.c        **** // Performs a bitwise XOR and spits out the result
1002:WTPA.c        **** {
 1836               		.loc 1 1002 0
 1837               		.cfi_startproc
 1838               	/* prologue: function */
 1839               	/* frame size = 0 */
 1840               	/* stack size = 0 */
 1841               	.L__stack_usage = 0
1003:WTPA.c        **** 	signed int
1004:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1005:WTPA.c        **** 		sum1;
1006:WTPA.c        **** 
1007:WTPA.c        **** 	unsigned char
1008:WTPA.c        **** 		output;			// What to put on the DAC
1009:WTPA.c        **** 
1010:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1842               		.loc 1 1010 0
 1843 0fe4 2091 0000 		lds r18,extIsrOutputBank0
 1844 0fe8 8091 0000 		lds r24,midiOutputBank0
 1845 0fec 9927      		clr r25
 1846 0fee 87FD      		sbrc r24,7
 1847 0ff0 9095      		com r25
 1848 0ff2 820F      		add r24,r18
 1849 0ff4 911D      		adc r25,__zero_reg__
 1850 0ff6 27FD      		sbrc r18,7
 1851 0ff8 9A95      		dec r25
 1852 0ffa 8038      		cpi r24,-128
 1853 0ffc 2FEF      		ldi r18,-1
 1854 0ffe 9207      		cpc r25,r18
 1855 1000 04F4      		brge .L115
 1856 1002 80E8      		ldi r24,lo8(-128)
 1857 1004 9FEF      		ldi r25,lo8(-1)
 1858               	.L115:
 1859               	.LVL44:
1011:WTPA.c        **** 	if(sum0>127)		// Pin high.
1012:WTPA.c        **** 	{
1013:WTPA.c        **** 		sum0=127;
1014:WTPA.c        **** 	}
1015:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1016:WTPA.c        **** 	{
1017:WTPA.c        **** 		sum0=-128;
1018:WTPA.c        **** 	}
1019:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1860               		.loc 1 1019 0
 1861 1006 4091 0000 		lds r20,extIsrOutputBank1
 1862 100a 2091 0000 		lds r18,midiOutputBank1
 1863 100e 3327      		clr r19
 1864 1010 27FD      		sbrc r18,7
 1865 1012 3095      		com r19
 1866 1014 240F      		add r18,r20
 1867 1016 311D      		adc r19,__zero_reg__
 1868 1018 47FD      		sbrc r20,7
 1869 101a 3A95      		dec r19
 1870 101c 2038      		cpi r18,-128
 1871 101e 4FEF      		ldi r20,-1
 1872 1020 3407      		cpc r19,r20
 1873 1022 04F4      		brge .L116
 1874 1024 20E8      		ldi r18,lo8(-128)
 1875 1026 3FEF      		ldi r19,lo8(-1)
 1876               	.L116:
 1877               	.LVL45:
1020:WTPA.c        **** 	if(sum1>127)		// Pin high.
1021:WTPA.c        **** 	{
1022:WTPA.c        **** 		sum1=127;
1023:WTPA.c        **** 	}
1024:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1025:WTPA.c        **** 	{
1026:WTPA.c        **** 		sum1=-128;
1027:WTPA.c        **** 	}
1028:WTPA.c        **** 	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1878               		.loc 1 1028 0
 1879 1028 2038      		cpi r18,-128
 1880 102a 3105      		cpc r19,__zero_reg__
 1881 102c 04F0      		brlt .L117
 1882 102e 2FE7      		ldi r18,lo8(127)
 1883 1030 30E0      		ldi r19,0
 1884               	.LVL46:
 1885               	.L117:
 1886 1032 2058      		subi r18,128
 1887 1034 3095      		com r19
 1888 1036 8038      		cpi r24,-128
 1889 1038 9105      		cpc r25,__zero_reg__
 1890 103a 04F0      		brlt .L118
 1891 103c 8FE7      		ldi r24,lo8(127)
 1892 103e 90E0      		ldi r25,0
 1893               	.LVL47:
 1894               	.L118:
 1895 1040 8058      		subi r24,128
 1896 1042 9095      		com r25
 1897 1044 8227      		eor r24,r18
 1898               	.LVL48:
1029:WTPA.c        **** 
1030:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1899               		.loc 1 1030 0
 1900 1046 9091 0000 		lds r25,lastDacByte
 1901 104a 8917      		cp r24,r25
 1902 104c 01F0      		breq .L119
1031:WTPA.c        **** 	{
1032:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1903               		.loc 1 1032 0
 1904 104e 9FEF      		ldi r25,lo8(-1)
 1905 1050 94B9      		out 0x4,r25
1033:WTPA.c        **** 
1034:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1906               		.loc 1 1034 0
 1907 1052 85B9      		out 0x5,r24
1035:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1908               		.loc 1 1035 0
 1909 1054 159A      		sbi 0x2,5
1036:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1910               		.loc 1 1036 0
 1911 1056 1598      		cbi 0x2,5
 1912               	.L119:
1037:WTPA.c        **** 	}
1038:WTPA.c        **** 
1039:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1913               		.loc 1 1039 0
 1914 1058 8093 0000 		sts lastDacByte,r24
 1915 105c 0895      		ret
 1916               		.cfi_endproc
 1917               	.LFE5:
 1920               	OutputAndBanks:
 1921               	.LFB6:
1040:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1041:WTPA.c        **** }
1042:WTPA.c        **** 
1043:WTPA.c        **** static void OutputAndBanks(void)
1044:WTPA.c        **** // Performs a bitwise AND and spits out the result
1045:WTPA.c        **** {
 1922               		.loc 1 1045 0
 1923               		.cfi_startproc
 1924               	/* prologue: function */
 1925               	/* frame size = 0 */
 1926               	/* stack size = 0 */
 1927               	.L__stack_usage = 0
1046:WTPA.c        **** 	signed int
1047:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1048:WTPA.c        **** 		sum1;
1049:WTPA.c        **** 
1050:WTPA.c        **** 	unsigned char
1051:WTPA.c        **** 		output;			// What to put on the DAC
1052:WTPA.c        **** 
1053:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1928               		.loc 1 1053 0
 1929 105e 2091 0000 		lds r18,extIsrOutputBank0
 1930 1062 8091 0000 		lds r24,midiOutputBank0
 1931 1066 9927      		clr r25
 1932 1068 87FD      		sbrc r24,7
 1933 106a 9095      		com r25
 1934 106c 820F      		add r24,r18
 1935 106e 911D      		adc r25,__zero_reg__
 1936 1070 27FD      		sbrc r18,7
 1937 1072 9A95      		dec r25
 1938 1074 8038      		cpi r24,-128
 1939 1076 2FEF      		ldi r18,-1
 1940 1078 9207      		cpc r25,r18
 1941 107a 04F4      		brge .L121
 1942 107c 80E8      		ldi r24,lo8(-128)
 1943 107e 9FEF      		ldi r25,lo8(-1)
 1944               	.L121:
 1945               	.LVL49:
1054:WTPA.c        **** 	if(sum0>127)		// Pin high.
1055:WTPA.c        **** 	{
1056:WTPA.c        **** 		sum0=127;
1057:WTPA.c        **** 	}
1058:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1059:WTPA.c        **** 	{
1060:WTPA.c        **** 		sum0=-128;
1061:WTPA.c        **** 	}
1062:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1946               		.loc 1 1062 0
 1947 1080 4091 0000 		lds r20,extIsrOutputBank1
 1948 1084 2091 0000 		lds r18,midiOutputBank1
 1949 1088 3327      		clr r19
 1950 108a 27FD      		sbrc r18,7
 1951 108c 3095      		com r19
 1952 108e 240F      		add r18,r20
 1953 1090 311D      		adc r19,__zero_reg__
 1954 1092 47FD      		sbrc r20,7
 1955 1094 3A95      		dec r19
 1956 1096 2038      		cpi r18,-128
 1957 1098 4FEF      		ldi r20,-1
 1958 109a 3407      		cpc r19,r20
 1959 109c 04F4      		brge .L122
 1960 109e 20E8      		ldi r18,lo8(-128)
 1961 10a0 3FEF      		ldi r19,lo8(-1)
 1962               	.L122:
 1963               	.LVL50:
1063:WTPA.c        **** 	if(sum1>127)		// Pin high.
1064:WTPA.c        **** 	{
1065:WTPA.c        **** 		sum1=127;
1066:WTPA.c        **** 	}
1067:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1068:WTPA.c        **** 	{
1069:WTPA.c        **** 		sum1=-128;
1070:WTPA.c        **** 	}
1071:WTPA.c        **** 	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1964               		.loc 1 1071 0
 1965 10a2 2038      		cpi r18,-128
 1966 10a4 3105      		cpc r19,__zero_reg__
 1967 10a6 04F0      		brlt .L123
 1968 10a8 2FE7      		ldi r18,lo8(127)
 1969 10aa 30E0      		ldi r19,0
 1970               	.LVL51:
 1971               	.L123:
 1972 10ac 2058      		subi r18,128
 1973 10ae 3095      		com r19
 1974 10b0 8038      		cpi r24,-128
 1975 10b2 9105      		cpc r25,__zero_reg__
 1976 10b4 04F0      		brlt .L124
 1977 10b6 8FE7      		ldi r24,lo8(127)
 1978 10b8 90E0      		ldi r25,0
 1979               	.LVL52:
 1980               	.L124:
 1981 10ba 8058      		subi r24,128
 1982 10bc 9095      		com r25
 1983 10be 8223      		and r24,r18
 1984               	.LVL53:
1072:WTPA.c        **** 
1073:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1985               		.loc 1 1073 0
 1986 10c0 9091 0000 		lds r25,lastDacByte
 1987 10c4 8917      		cp r24,r25
 1988 10c6 01F0      		breq .L125
1074:WTPA.c        **** 	{
1075:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1989               		.loc 1 1075 0
 1990 10c8 9FEF      		ldi r25,lo8(-1)
 1991 10ca 94B9      		out 0x4,r25
1076:WTPA.c        **** 
1077:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1992               		.loc 1 1077 0
 1993 10cc 85B9      		out 0x5,r24
1078:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1994               		.loc 1 1078 0
 1995 10ce 159A      		sbi 0x2,5
1079:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1996               		.loc 1 1079 0
 1997 10d0 1598      		cbi 0x2,5
 1998               	.L125:
1080:WTPA.c        **** 	}
1081:WTPA.c        **** 
1082:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1999               		.loc 1 1082 0
 2000 10d2 8093 0000 		sts lastDacByte,r24
 2001 10d6 0895      		ret
 2002               		.cfi_endproc
 2003               	.LFE6:
 2006               	WriteLedLatch:
 2007               	.LFB20:
1083:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1084:WTPA.c        **** }
1085:WTPA.c        **** //-----------------------------------------------------------------------------
1086:WTPA.c        **** //-----------------------------------------------------------------------------
1087:WTPA.c        **** // Interrupt Vectors:
1088:WTPA.c        **** // These handle updating audio in the different banks (and the dumb LED intro)
1089:WTPA.c        **** //-----------------------------------------------------------------------------
1090:WTPA.c        **** //-----------------------------------------------------------------------------
1091:WTPA.c        **** 
1092:WTPA.c        **** ISR(TIMER1_CAPT_vect)
1093:WTPA.c        **** // The vector triggered by an external clock edge and associated with Bank0
1094:WTPA.c        **** {
1095:WTPA.c        **** 	static bool
1096:WTPA.c        **** 		flipFlop;		// Used for half-time
1097:WTPA.c        **** 
1098:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1099:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1100:WTPA.c        **** 	{
1101:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
1102:WTPA.c        **** 	}
1103:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1104:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1105:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1106:WTPA.c        **** 	{
1107:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1108:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1109:WTPA.c        **** 	}
1110:WTPA.c        **** }
1111:WTPA.c        **** 
1112:WTPA.c        **** ISR(PCINT2_vect)
1113:WTPA.c        **** // The vector triggered by a pin change and associated with Bank1
1114:WTPA.c        **** // It's on PC4
1115:WTPA.c        **** {
1116:WTPA.c        **** 	static bool
1117:WTPA.c        **** 		flipFlop;		// Used for half-time
1118:WTPA.c        **** 
1119:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1120:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1121:WTPA.c        **** 	{
1122:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
1123:WTPA.c        **** 	}
1124:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1125:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1126:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1127:WTPA.c        **** 	{
1128:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1129:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1130:WTPA.c        **** 	}
1131:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
1132:WTPA.c        **** 
1133:WTPA.c        **** // Mon May 23 16:06:37 EDT 2011
1134:WTPA.c        **** // With new hardware (relaxation osc and pulse shaper) we removed the level check above.  The clock
1135:WTPA.c        **** // However, we will need to clear the pin-change interrupt flag, since it may get set again about t
1136:WTPA.c        **** // Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and 
1137:WTPA.c        **** 
1138:WTPA.c        **** // Fri Jun 24 11:20:40 EDT 2011
1139:WTPA.c        **** // They're more like 5uS now, but still plenty short
1140:WTPA.c        **** }
1141:WTPA.c        **** 
1142:WTPA.c        **** ISR(TIMER1_COMPA_vect)
1143:WTPA.c        **** // The bank0 internal timer vectors here on an interrupt.
1144:WTPA.c        **** {
1145:WTPA.c        **** 	unsigned long
1146:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1147:WTPA.c        **** 	static unsigned int
1148:WTPA.c        **** 		lastJitterValue;
1149:WTPA.c        **** 	static bool
1150:WTPA.c        **** 		flipFlop;		// Used for half-time
1151:WTPA.c        **** 
1152:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1153:WTPA.c        **** 
1154:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1155:WTPA.c        **** 	{
1156:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
1157:WTPA.c        **** 	}
1158:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
1159:WTPA.c        **** 	{
1160:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
1161:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1162:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1163:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1164:WTPA.c        **** 	}
1165:WTPA.c        **** 	else
1166:WTPA.c        **** 	{
1167:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1168:WTPA.c        **** 	}
1169:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1170:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1171:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1172:WTPA.c        **** 	{
1173:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1174:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1175:WTPA.c        **** 	}
1176:WTPA.c        **** }
1177:WTPA.c        **** 
1178:WTPA.c        **** ISR(TIMER1_COMPB_vect)
1179:WTPA.c        **** // The interrupt associated with bank1 when it's using internal interrupts goes here.
1180:WTPA.c        **** {
1181:WTPA.c        **** 	unsigned long
1182:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1183:WTPA.c        **** 	static unsigned int
1184:WTPA.c        **** 		lastJitterValue;
1185:WTPA.c        **** 	static bool
1186:WTPA.c        **** 		flipFlop;		// Used for half-time
1187:WTPA.c        **** 
1188:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1189:WTPA.c        **** 
1190:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1191:WTPA.c        **** 	{
1192:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
1193:WTPA.c        **** 	}
1194:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
1195:WTPA.c        **** 	{
1196:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
1197:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1198:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1199:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1200:WTPA.c        **** 	}
1201:WTPA.c        **** 	else
1202:WTPA.c        **** 	{
1203:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1204:WTPA.c        **** 	}
1205:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1206:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1207:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1208:WTPA.c        **** 	{
1209:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1210:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1211:WTPA.c        **** 	}
1212:WTPA.c        **** }
1213:WTPA.c        **** 
1214:WTPA.c        **** ISR(TIMER2_COMPB_vect)
1215:WTPA.c        **** // This interrupt handles data in the SD buffer and doing what needs to be done with it.
1216:WTPA.c        **** // This includes direct playback from the SD card, writing SD data to the ram banks, and reading ra
1217:WTPA.c        **** // When writing/reading RAM, the bank in question should be locked against other RAM accesses.
1218:WTPA.c        **** {
1219:WTPA.c        **** 	unsigned char
1220:WTPA.c        **** 		theByte;
1221:WTPA.c        **** 
1222:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
1223:WTPA.c        **** 	{
1224:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1225:WTPA.c        **** 		{
1226:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1227:WTPA.c        **** 			{
1228:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1229:WTPA.c        **** 
1230:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1231:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1232:WTPA.c        **** 				{
1233:WTPA.c        **** 					sdFifoReadPointer=0;
1234:WTPA.c        **** 				}
1235:WTPA.c        **** 
1236:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1237:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1238:WTPA.c        **** 
1239:WTPA.c        **** 				// Now put this byte into the RAM bank in the correct address.
1240:WTPA.c        **** 
1241:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
1242:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
1243:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
1244:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
1245:WTPA.c        **** 
1246:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
1247:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
1248:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
1249:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
1250:WTPA.c        **** 
1251:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
1252:WTPA.c        **** 
1253:WTPA.c        **** 				// Compute address while bus settles.
1254:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
1255:WTPA.c        **** 				{
1256:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1257:WTPA.c        **** 				}
1258:WTPA.c        **** 				else
1259:WTPA.c        **** 				{
1260:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1261:WTPA.c        **** 				}
1262:WTPA.c        **** 
1263:WTPA.c        **** 				// Finish writing to RAM.
1264:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
1265:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
1266:WTPA.c        **** 
1267:WTPA.c        **** 			}
1268:WTPA.c        **** 		}
1269:WTPA.c        **** 		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current 
1270:WTPA.c        **** 		{
1271:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1272:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1273:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1274:WTPA.c        **** 
1275:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
1276:WTPA.c        **** 			{
1277:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
1278:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1279:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1280:WTPA.c        **** 			}
1281:WTPA.c        **** 			else
1282:WTPA.c        **** 			{
1283:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
1284:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1285:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1286:WTPA.c        **** 			}
1287:WTPA.c        **** 		}
1288:WTPA.c        **** 	}
1289:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
1290:WTPA.c        **** 	{
1291:WTPA.c        **** 		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pau
1292:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
1293:WTPA.c        **** 		{
1294:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
1295:WTPA.c        **** 			{
1296:WTPA.c        **** 				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
1297:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
1298:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
1299:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
1300:WTPA.c        **** 
1301:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
1302:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
1303:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
1304:WTPA.c        **** 
1305:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
1306:WTPA.c        **** 
1307:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
1308:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
1309:WTPA.c        **** 
1310:WTPA.c        **** 				// Calculate new addy while data bus settles
1311:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
1312:WTPA.c        **** 				{
1313:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1314:WTPA.c        **** 				}
1315:WTPA.c        **** 				else
1316:WTPA.c        **** 				{
1317:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1318:WTPA.c        **** 				}
1319:WTPA.c        **** 
1320:WTPA.c        **** 				// Finish getting the byte from RAM.
1321:WTPA.c        **** 
1322:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
1323:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
1324:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
1325:WTPA.c        **** 
1326:WTPA.c        **** 				// Now put this byte from RAM into the sd fifo
1327:WTPA.c        **** 
1328:WTPA.c        **** 
1329:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
1330:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
1331:WTPA.c        **** 
1332:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
1333:WTPA.c        **** 				{
1334:WTPA.c        **** 					sdFifoWritePointer=0;
1335:WTPA.c        **** 				}
1336:WTPA.c        **** 
1337:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
1338:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
1339:WTPA.c        **** 
1340:WTPA.c        **** 			}
1341:WTPA.c        **** 			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank fo
1342:WTPA.c        **** 			{
1343:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1344:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
1345:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1346:WTPA.c        **** 
1347:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
1348:WTPA.c        **** 				{
1349:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
1350:WTPA.c        **** 				}
1351:WTPA.c        **** 				else
1352:WTPA.c        **** 				{
1353:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
1354:WTPA.c        **** 				}
1355:WTPA.c        **** 			}
1356:WTPA.c        **** 		}
1357:WTPA.c        **** 	}
1358:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
1359:WTPA.c        **** 	{
1360:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1361:WTPA.c        **** 		{
1362:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1363:WTPA.c        **** 			{
1364:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1365:WTPA.c        **** 
1366:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1367:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1368:WTPA.c        **** 				{
1369:WTPA.c        **** 					sdFifoReadPointer=0;
1370:WTPA.c        **** 				}
1371:WTPA.c        **** 
1372:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1373:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1374:WTPA.c        **** 
1375:WTPA.c        **** 				// Now spit the byte out the DAC.
1376:WTPA.c        **** 
1377:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
1378:WTPA.c        **** 				UpdateOutput();				// Update the DAC
1379:WTPA.c        **** 			}
1380:WTPA.c        **** 		}
1381:WTPA.c        **** 		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
1382:WTPA.c        **** 		{
1383:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1384:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1385:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1386:WTPA.c        **** 
1387:WTPA.c        **** 			// Set this contribution to the DAC to midscale (this output source is now quiet)
1388:WTPA.c        **** 			sdStreamOutput=0;
1389:WTPA.c        **** 		}
1390:WTPA.c        **** 	}
1391:WTPA.c        **** }
1392:WTPA.c        **** 
1393:WTPA.c        **** ISR(TIMER2_COMPA_vect)
1394:WTPA.c        **** // Serves exclusively to make our gay intro happen
1395:WTPA.c        **** // As far as the PWM goes, this should happen as often as possible.
1396:WTPA.c        **** {
1397:WTPA.c        **** 	static unsigned char
1398:WTPA.c        **** 		pwmCount;
1399:WTPA.c        **** 
1400:WTPA.c        **** 	if(ledPwm>pwmCount)
1401:WTPA.c        **** 	{
1402:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
1403:WTPA.c        **** 	}
1404:WTPA.c        **** 	else
1405:WTPA.c        **** 	{
1406:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
1407:WTPA.c        **** 	}
1408:WTPA.c        **** 	pwmCount++;
1409:WTPA.c        **** }
1410:WTPA.c        **** 
1411:WTPA.c        **** ISR(__vector_default)
1412:WTPA.c        **** {
1413:WTPA.c        ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
1414:WTPA.c        **** 	//	printf("Buggy Interrupt Generated!  Flags = ");
1415:WTPA.c        **** 	//  printf("*****put interrupt register values here****");
1416:WTPA.c        **** }
1417:WTPA.c        **** 
1418:WTPA.c        **** //-----------------------------------------------------------------------
1419:WTPA.c        **** //-----------------------------------------------------------------------
1420:WTPA.c        **** // State Machine Functions.
1421:WTPA.c        **** //-----------------------------------------------------------------------
1422:WTPA.c        **** //-----------------------------------------------------------------------
1423:WTPA.c        **** 
1424:WTPA.c        **** static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should be
1425:WTPA.c        **** {
1426:WTPA.c        **** 	State=newState;
1427:WTPA.c        **** 	subState=SS_0;
1428:WTPA.c        **** }
1429:WTPA.c        **** 
1430:WTPA.c        **** //-----------------------------------------------------------------------
1431:WTPA.c        **** //-----------------------------------------------------------------------
1432:WTPA.c        **** // Local Software Clock stuff.
1433:WTPA.c        **** //-----------------------------------------------------------------------
1434:WTPA.c        **** //-----------------------------------------------------------------------
1435:WTPA.c        **** 
1436:WTPA.c        **** void HandleSoftclock(void)
1437:WTPA.c        **** {
1438:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
1439:WTPA.c        **** 	{
1440:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
1441:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
1442:WTPA.c        **** 	}
1443:WTPA.c        **** }
1444:WTPA.c        **** 
1445:WTPA.c        **** static void InitSoftclock(void)
1446:WTPA.c        **** // Wed Dec  3 22:28:06 CST 2008
1447:WTPA.c        **** // I've changed the way the softclock works from the last rev.  It's no longer and interrupt based 
1448:WTPA.c        **** // Also, since hardware TIMR1 is needed for bigger and better things than keeping human-time, we're
1449:WTPA.c        **** // This means we don't steal cycles from any other ISRs, but it also means that if we write dumb co
1450:WTPA.c        **** // we might miss a systemTick.
1451:WTPA.c        **** // NOTE:  w/ TMR0 running at 1/256 prescale at 20MHz, our smallest time unit is 3.2768mSecs.
1452:WTPA.c        **** // NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.
1453:WTPA.c        **** 
1454:WTPA.c        **** // With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing e
1455:WTPA.c        **** 
1456:WTPA.c        **** {
1457:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
1458:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
1459:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
1460:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
1461:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
1462:WTPA.c        **** 	systemTicks=0;
1463:WTPA.c        **** //	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
1464:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
1465:WTPA.c        **** }
1466:WTPA.c        **** 
1467:WTPA.c        **** //-----------------------------------------------------------------------
1468:WTPA.c        **** // LED functions:
1469:WTPA.c        **** //-----------------------------------------------------------------------
1470:WTPA.c        **** 
1471:WTPA.c        **** // Thu Apr  1 13:08:08 EDT 2010
1472:WTPA.c        **** // Changed blinking mechanisms to be smaller and blink fixed times, and also use fewer timer fcns
1473:WTPA.c        **** 
1474:WTPA.c        **** #define		BLINK_TIME			(SECOND/8)
1475:WTPA.c        **** 
1476:WTPA.c        **** static void BlinkLeds(unsigned int theMask)
1477:WTPA.c        **** // Sets up the mask of leds to blink and their blink rate.
1478:WTPA.c        **** // NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from
1479:WTPA.c        **** // NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when w
1480:WTPA.c        **** {
1481:WTPA.c        **** 	unsigned char
1482:WTPA.c        **** 		i;
1483:WTPA.c        **** 
1484:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
1485:WTPA.c        **** 	{
1486:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
1487:WTPA.c        **** 		{
1488:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
1489:WTPA.c        **** 		}
1490:WTPA.c        **** 	}
1491:WTPA.c        **** 
1492:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
1493:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
1494:WTPA.c        **** }
1495:WTPA.c        **** 
1496:WTPA.c        **** static void StopBlinking(void)
1497:WTPA.c        **** // Stops all blinking LEDs.
1498:WTPA.c        **** {
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1500:WTPA.c        **** }
1501:WTPA.c        **** 
1502:WTPA.c        **** static void KillLeds(void)
1503:WTPA.c        **** // Turns off all LEDs immediately.
1504:WTPA.c        **** {
1505:WTPA.c        **** 	ledOnOffMask=0;
1506:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1507:WTPA.c        **** }
1508:WTPA.c        **** 
1509:WTPA.c        **** static void WriteLedLatch(unsigned char theMask)
1510:WTPA.c        **** // Take the current on/off LED mask and put it onto the LED output latch.
1511:WTPA.c        **** // This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
1512:WTPA.c        **** {
 2008               		.loc 1 1512 0
 2009               		.cfi_startproc
 2010               	.LVL54:
 2011               	/* prologue: function */
 2012               	/* frame size = 0 */
 2013               	/* stack size = 0 */
 2014               	.L__stack_usage = 0
1513:WTPA.c        **** 	unsigned char
1514:WTPA.c        **** 		sreg;
1515:WTPA.c        **** 
1516:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 2015               		.loc 1 1516 0
 2016 10d8 9FB7      		in r25,__SREG__
 2017               	.LVL55:
1517:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 2018               		.loc 1 1517 0
 2019               	/* #APP */
 2020               	 ;  1517 "WTPA.c" 1
 2021 10da F894      		cli
 2022               	 ;  0 "" 2
1518:WTPA.c        **** 
1519:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 2023               		.loc 1 1519 0
 2024               	/* #NOAPP */
 2025 10dc 85B9      		out 0x5,r24
1520:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 2026               		.loc 1 1520 0
 2027 10de 8FEF      		ldi r24,lo8(-1)
 2028               	.LVL56:
 2029 10e0 84B9      		out 0x4,r24
1521:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 2030               		.loc 1 1521 0
 2031 10e2 5F9A      		sbi 0xb,7
1522:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 2032               		.loc 1 1522 0
 2033 10e4 5F98      		cbi 0xb,7
1523:WTPA.c        **** 
1524:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 2034               		.loc 1 1524 0
 2035 10e6 9FBF      		out __SREG__,r25
 2036 10e8 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE20:
 2041               	SdIsrStartStreamingAudio:
 2042               	.LFB47:
1525:WTPA.c        **** }
1526:WTPA.c        **** 
1527:WTPA.c        **** static void HandleLeds(void)
1528:WTPA.c        **** // Runs in the main loop updating the state of the LEDs.  Only messes with the databus when there's
1529:WTPA.c        **** {
1530:WTPA.c        **** 	unsigned char
1531:WTPA.c        **** 		i;
1532:WTPA.c        **** 	static bool
1533:WTPA.c        **** 		toggle;				// Flip flop for blinking.
1534:WTPA.c        **** 	static unsigned char
1535:WTPA.c        **** 		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.
1536:WTPA.c        **** 
1537:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
1538:WTPA.c        **** 	{
1539:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
1540:WTPA.c        **** 		{
1541:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
1542:WTPA.c        **** 			{
1543:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
1544:WTPA.c        **** 				{
1545:WTPA.c        **** 					ledOnOffMask|=(1<<i);
1546:WTPA.c        **** 				}
1547:WTPA.c        **** 				else
1548:WTPA.c        **** 				{
1549:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
1550:WTPA.c        **** 				}
1551:WTPA.c        **** 			}
1552:WTPA.c        **** 		}
1553:WTPA.c        **** 
1554:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
1555:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
1556:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
1557:WTPA.c        **** 	}
1558:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
1559:WTPA.c        **** 	{
1560:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
1561:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
1562:WTPA.c        **** 	}
1563:WTPA.c        **** }
1564:WTPA.c        **** 
1565:WTPA.c        **** static void InitLeds(void)
1566:WTPA.c        **** {
1567:WTPA.c        **** 	ledOnOffMask=0;
1568:WTPA.c        **** 	ledBlinkMask=0;
1569:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
1570:WTPA.c        **** }
1571:WTPA.c        **** 
1572:WTPA.c        **** //-----------------------------------------------------------------------
1573:WTPA.c        **** //-----------------------------------------------------------------------
1574:WTPA.c        **** // Switch functions:
1575:WTPA.c        **** //-----------------------------------------------------------------------
1576:WTPA.c        **** //-----------------------------------------------------------------------
1577:WTPA.c        **** 
1578:WTPA.c        **** static void InitSwitches(void)
1579:WTPA.c        **** {
1580:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
1581:WTPA.c        **** 
1582:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
1583:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
1584:WTPA.c        **** 
1585:WTPA.c        **** }
1586:WTPA.c        **** 
1587:WTPA.c        **** static void HandleSwitches(void)
1588:WTPA.c        **** // Read input pins, debounce, make keypresses positive-true, and flag newly-appeared keys.
1589:WTPA.c        **** // Make sure we've allowed enough time to turn the bus around.  The old RAM took a couple cycles be
1590:WTPA.c        **** {
1591:WTPA.c        **** 	static unsigned char
1592:WTPA.c        **** 		lastKeyState;
1593:WTPA.c        **** 	unsigned char
1594:WTPA.c        **** 		sreg;
1595:WTPA.c        **** 
1596:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
1597:WTPA.c        **** 	{
1598:WTPA.c        **** 		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
1599:WTPA.c        **** 		sreg=SREG;
1600:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
1601:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
1602:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
1603:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
1604:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
1605:WTPA.c        **** 		asm volatile("nop"::);
1606:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
1607:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
1608:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
1609:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
1610:WTPA.c        **** 
1611:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
1612:WTPA.c        **** 		{
1613:WTPA.c        **** 			cardDetect=true;
1614:WTPA.c        **** 		}
1615:WTPA.c        **** 		else
1616:WTPA.c        **** 		{
1617:WTPA.c        **** 			cardDetect=false;
1618:WTPA.c        **** 		}
1619:WTPA.c        **** 
1620:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
1621:WTPA.c        **** 	}
1622:WTPA.c        **** 
1623:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
1624:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
1625:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
1626:WTPA.c        **** }
1627:WTPA.c        **** 
1628:WTPA.c        **** //-----------------------------------------------------------------------
1629:WTPA.c        **** //-----------------------------------------------------------------------
1630:WTPA.c        **** // Encoder functions:
1631:WTPA.c        **** //-----------------------------------------------------------------------
1632:WTPA.c        **** //-----------------------------------------------------------------------
1633:WTPA.c        **** // The encoders I set this up with are 24 pulses per revolution.
1634:WTPA.c        **** // They are Bourns 652-PEC124230F-N0024, from Mouser.
1635:WTPA.c        **** // From the DS:  5mSec max bounce at 15RPM (waaay faster than we'll go) with "standard noise reduct
1636:WTPA.c        **** // This encoder (like most others) puts out 2 bit Gray code (where only one switch changes at a tim
1637:WTPA.c        **** 
1638:WTPA.c        **** // Thu Sep  2 15:04:47 EDT 2010
1639:WTPA.c        **** // OK.  More monkeying with reading the encoder shows us that a "pulse" is actually a transition of
1640:WTPA.c        **** // This is good (it means more resolution -- there are 4*24 readable transitions per revolution) bu
1641:WTPA.c        **** // Did this -- the encoder is really sensitive.  We still either miss reads or are getting switch b
1642:WTPA.c        **** 
1643:WTPA.c        **** // Thu Sep  2 16:39:43 EDT 2010 -- Added hardware filter from the panasonic datasheet.  Works a dre
1644:WTPA.c        **** 
1645:WTPA.c        **** // Encoder bit masks (dependent on port position)
1646:WTPA.c        **** #define	ENC_POS_A	0x00
1647:WTPA.c        **** #define	ENC_POS_B	0x40
1648:WTPA.c        **** #define	ENC_POS_C	0xC0
1649:WTPA.c        **** #define	ENC_POS_D	0x80
1650:WTPA.c        **** 
1651:WTPA.c        **** static void InitEncoder(void)
1652:WTPA.c        **** {
1653:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
1654:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
1655:WTPA.c        **** }
1656:WTPA.c        **** 
1657:WTPA.c        **** static void HandleEncoder(void)
1658:WTPA.c        **** // Fri Jun 24 11:29:53 EDT 2011
1659:WTPA.c        **** // Steps backwards from earlier prototype for some reason
1660:WTPA.c        **** {
1661:WTPA.c        **** 	static unsigned char
1662:WTPA.c        **** 		lastEncoderState=0;
1663:WTPA.c        **** 	static unsigned int
1664:WTPA.c        **** 		lastEncTime=0;
1665:WTPA.c        **** 
1666:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
1667:WTPA.c        **** 	{
1668:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
1669:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
1670:WTPA.c        **** 
1671:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
1672:WTPA.c        **** 		{
1673:WTPA.c        **** 			if(encoderState==ENC_POS_A)
1674:WTPA.c        **** 			{
1675:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
1676:WTPA.c        **** 				{
1677:WTPA.c        **** //					encoderValue++;
1678:WTPA.c        **** 					encoderValue--;
1679:WTPA.c        **** 				}
1680:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
1681:WTPA.c        **** 				{
1682:WTPA.c        **** //					encoderValue--;
1683:WTPA.c        **** 					encoderValue++;
1684:WTPA.c        **** 				}
1685:WTPA.c        **** 			}
1686:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
1687:WTPA.c        **** 			{
1688:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
1689:WTPA.c        **** 				{
1690:WTPA.c        **** //					encoderValue++;
1691:WTPA.c        **** 					encoderValue--;
1692:WTPA.c        **** 				}
1693:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
1694:WTPA.c        **** 				{
1695:WTPA.c        **** //					encoderValue--;
1696:WTPA.c        **** 					encoderValue++;
1697:WTPA.c        **** 				}
1698:WTPA.c        **** 			}
1699:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
1700:WTPA.c        **** 			{
1701:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
1702:WTPA.c        **** 				{
1703:WTPA.c        **** //					encoderValue++;
1704:WTPA.c        **** 					encoderValue--;
1705:WTPA.c        **** 				}
1706:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
1707:WTPA.c        **** 				{
1708:WTPA.c        **** //					encoderValue--;
1709:WTPA.c        **** 					encoderValue++;
1710:WTPA.c        **** 				}
1711:WTPA.c        **** 			}
1712:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
1713:WTPA.c        **** 			{
1714:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
1715:WTPA.c        **** 				{
1716:WTPA.c        **** //					encoderValue++;
1717:WTPA.c        **** 					encoderValue--;
1718:WTPA.c        **** 				}
1719:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
1720:WTPA.c        **** 				{
1721:WTPA.c        **** //					encoderValue--;
1722:WTPA.c        **** 					encoderValue++;
1723:WTPA.c        **** 				}
1724:WTPA.c        **** 			}
1725:WTPA.c        **** 
1726:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
1727:WTPA.c        **** 		}
1728:WTPA.c        **** 	}
1729:WTPA.c        **** }
1730:WTPA.c        **** 
1731:WTPA.c        **** //-----------------------------------------------------------------------
1732:WTPA.c        **** //-----------------------------------------------------------------------
1733:WTPA.c        **** // A/D Control Functions:
1734:WTPA.c        **** //-----------------------------------------------------------------------
1735:WTPA.c        **** //-----------------------------------------------------------------------
1736:WTPA.c        **** // WTPA2 uses only one analog input (ADC0).  It's used to sample the audio input.  In old versions 
1737:WTPA.c        **** // The best resolution we can get from this hardware is 10 bits, +/- 2 lsbs.
1738:WTPA.c        **** // The max sampling rate we can pull at full resolution is 15kHz.  We always use the ADC single end
1739:WTPA.c        **** // work in differential mode with the PDIP package.  A conversion takes 13 ADC clocks normally, or 
1740:WTPA.c        **** // The datasheet is unclear how much resolution is lost above 15kHz.  Guess we'll find out!
1741:WTPA.c        **** // NOTE:  Since the RAM can only store 8 bits per sample, we're only using 8 bits of the conversion
1742:WTPA.c        **** 
1743:WTPA.c        **** /*
1744:WTPA.c        **** static void UnInitAdc(void)
1745:WTPA.c        **** {
1746:WTPA.c        **** 	ADCSRA&=~(1<<ADEN);		// Disable ADC.
1747:WTPA.c        **** 	PRR|=(1<<PRADC);		// Power down the ADC.
1748:WTPA.c        **** }
1749:WTPA.c        **** */
1750:WTPA.c        **** 
1751:WTPA.c        **** static void InitAdc(void)
1752:WTPA.c        **** // Note, we don't set up the Adc to trigger on anything right away.
1753:WTPA.c        **** {
1754:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
1755:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
1756:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
1757:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
1758:WTPA.c        **** //	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the A
1759:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
1760:WTPA.c        **** 	// ADCSRB controls auto-triggering, which we aren't using right now.
1761:WTPA.c        **** }
1762:WTPA.c        **** 
1763:WTPA.c        **** //-----------------------------------------------------------------------
1764:WTPA.c        **** // RAM / DAC functions:
1765:WTPA.c        **** //-----------------------------------------------------------------------
1766:WTPA.c        **** 
1767:WTPA.c        **** // Fri Jun 17 19:11:18 EDT 2011
1768:WTPA.c        **** // As of WTPA2 these are all inlined where they need to go.  The notes below are for posterity
1769:WTPA.c        **** 
1770:WTPA.c        **** // Will be totally different than the oldschool serial biz.....
1771:WTPA.c        **** // Should probably all be inlined in the ISR.
1772:WTPA.c        **** // Just so you remember, Parallel SRAM pretty much always works like this:
1773:WTPA.c        **** 
1774:WTPA.c        **** // The chip is always enabled (CS is always low).  The other two control pins are active low also -
1775:WTPA.c        **** // When WE is low, the value on the DATA pins is latched into the address on the ADDRESS pins.  Ass
1776:WTPA.c        **** // When WE is high, the byte stored at the ADDRESS on pins A0-A18 is latched out on the DATA pins, 
1777:WTPA.c        **** // If OE is high, the DATA port will be high impedance no matter what.
1778:WTPA.c        **** // The ADDRESS pins can always be outputs as far as the MCU is concerned.
1779:WTPA.c        **** 
1780:WTPA.c        **** // A typical write might look like:
1781:WTPA.c        **** // 1.)  OE and WE are high.
1782:WTPA.c        **** // 2.)  The address is set and the data latches on the MCU are made into outputs. The correct value
1783:WTPA.c        **** // 3.)  WE is brought low and the data is latched in.
1784:WTPA.c        **** // 4.)  WE is brought high.  The address and data lines can now be changed without messing up data 
1785:WTPA.c        **** 
1786:WTPA.c        **** // A typical read might look like this:
1787:WTPA.c        **** // 1.)  OE and WE are high.
1788:WTPA.c        **** // 2.)  The address is set correctly and the DATA PORT on the MCU is made high impedance.
1789:WTPA.c        **** // 3.)  OE is brought low, and the data to be read shows up on the DATA lines.
1790:WTPA.c        **** // 4.)  The MCU reads the DATA lines.
1791:WTPA.c        **** // 5.)  OE can be brought high again or left low -- it only needs to change if we're going to write
1792:WTPA.c        **** 
1793:WTPA.c        **** // On 373 Parallel Latches:
1794:WTPA.c        **** // These guys are pretty simple.  In this circuit, their OE is tied low (enabled).
1795:WTPA.c        **** // While LE (Latch Enable) is High, the Latch is transparent from input port to output port.
1796:WTPA.c        **** // When LE is brought low, the current state of the inputs will be latched, and the outputs will th
1797:WTPA.c        **** // So, we will will probably just leave LE low most of the time on the latches and strobe it high w
1798:WTPA.c        **** 
1799:WTPA.c        **** 
1800:WTPA.c        **** 
1801:WTPA.c        **** //-----------------------------------------------------------------------
1802:WTPA.c        **** //-----------------------------------------------------------------------
1803:WTPA.c        **** // General Sampler/ISR Functions:
1804:WTPA.c        **** //-----------------------------------------------------------------------
1805:WTPA.c        **** //-----------------------------------------------------------------------
1806:WTPA.c        **** // We've changed these to use both OCR1x interrupts and the "normal" waveform generation mode (from
1807:WTPA.c        **** // 	This allows us to generate different pitches for the two banks using TIMER1.  We do this by rea
1808:WTPA.c        **** // 	that interrupt occurs.  The OCR value will keep rolling like this, the timer will never be rese
1809:WTPA.c        **** //  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrup
1810:WTPA.c        **** 
1811:WTPA.c        **** // Tue Aug 23 18:25:06 EDT 2011
1812:WTPA.c        **** // Updated these functions to clear the sdUsingBank(x) flags when these are called so the interrupt
1813:WTPA.c        **** 
1814:WTPA.c        **** // Thu Nov 24 19:22:24 CST 2011
1815:WTPA.c        **** // Updated to account for locking banks (removed above).  Necessary now because we can be screwing 
1816:WTPA.c        **** 
1817:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1818:WTPA.c        **** // This code is common to all the requests to start different audio modes (record, playback, overdu
1819:WTPA.c        **** // Timer interrupts should be disabled when you call this!
1820:WTPA.c        **** {
1821:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
1822:WTPA.c        **** 
1823:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
1824:WTPA.c        **** 	{
1825:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
1826:WTPA.c        **** 
1827:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
1828:WTPA.c        **** 		{
1829:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1830:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
1831:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
1832:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1833:WTPA.c        **** 		}
1834:WTPA.c        **** 		else					// Bank 1 is associated with OCR1B
1835:WTPA.c        **** 		{
1836:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1837:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
1838:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
1839:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1840:WTPA.c        **** 		}
1841:WTPA.c        **** 	}
1842:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
1843:WTPA.c        **** 	{
1844:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
1845:WTPA.c        **** 		{
1846:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
1847:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
1848:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
1849:WTPA.c        **** 		}
1850:WTPA.c        **** 		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC in
1851:WTPA.c        **** 		{
1852:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
1853:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
1854:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
1855:WTPA.c        **** 		}
1856:WTPA.c        **** 	}
1857:WTPA.c        **** }
1858:WTPA.c        **** 
1859:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1860:WTPA.c        **** // Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the re
1861:WTPA.c        **** // If we're using the internal clock, set the rate.
1862:WTPA.c        **** // Sat Apr 11 13:49:31 CDT 2009  --  ?
1863:WTPA.c        **** // Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow th
1864:WTPA.c        **** {
1865:WTPA.c        **** 
1866:WTPA.c        **** 	unsigned char
1867:WTPA.c        **** 		sreg;
1868:WTPA.c        **** 
1869:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1870:WTPA.c        **** 	{
1871:WTPA.c        **** 
1872:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1873:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1874:WTPA.c        **** 
1875:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
1876:WTPA.c        **** 
1877:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
1878:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
1879:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
1880:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
1881:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
1882:WTPA.c        **** 
1883:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
1884:WTPA.c        **** 
1885:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1886:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1887:WTPA.c        **** 
1888:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1889:WTPA.c        **** 
1890:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1891:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1892:WTPA.c        **** 		{
1893:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1894:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1895:WTPA.c        **** 		}
1896:WTPA.c        **** 	}
1897:WTPA.c        **** }
1898:WTPA.c        **** 
1899:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1900:WTPA.c        **** // Point to the beginning of the sample, select the clock source, and get the interrupts going.
1901:WTPA.c        **** // Set the clock rate if we're using the internal clock.
1902:WTPA.c        **** // Mon Jul  6 19:05:04 CDT 2009
1903:WTPA.c        **** // We've made it clear that the beginning of the sample is relative, in the sense that if we're pla
1904:WTPA.c        **** {
1905:WTPA.c        **** 	unsigned char
1906:WTPA.c        **** 		sreg;
1907:WTPA.c        **** 
1908:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1909:WTPA.c        **** 	{
1910:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1911:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1912:WTPA.c        **** 
1913:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
1914:WTPA.c        **** 
1915:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
1916:WTPA.c        **** 		{
1917:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
1918:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
1919:WTPA.c        **** 		}
1920:WTPA.c        **** 		else
1921:WTPA.c        **** 		{
1922:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
1923:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
1924:WTPA.c        **** 		}
1925:WTPA.c        **** 
1926:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1927:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1928:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1929:WTPA.c        **** 	}
1930:WTPA.c        **** }
1931:WTPA.c        **** 
1932:WTPA.c        **** static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1933:WTPA.c        **** // Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
1934:WTPA.c        **** // Used if we pause playback and want to continue where we left off, or stop overdubbing and jump r
1935:WTPA.c        **** {
1936:WTPA.c        **** 	unsigned char
1937:WTPA.c        **** 		sreg;
1938:WTPA.c        **** 
1939:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1940:WTPA.c        **** 	{
1941:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1942:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1943:WTPA.c        **** 
1944:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
1945:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1946:WTPA.c        **** 
1947:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1948:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1949:WTPA.c        **** 	}
1950:WTPA.c        **** }
1951:WTPA.c        **** 
1952:WTPA.c        **** static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1953:WTPA.c        **** // Begin recording to ram at the current RAM address.
1954:WTPA.c        **** // Continue playing back from that address, too.
1955:WTPA.c        **** {
1956:WTPA.c        **** 	unsigned char
1957:WTPA.c        **** 		sreg;
1958:WTPA.c        **** 
1959:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1960:WTPA.c        **** 	{
1961:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1962:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1963:WTPA.c        **** 
1964:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
1965:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1966:WTPA.c        **** 
1967:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1968:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1969:WTPA.c        **** 
1970:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1971:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1972:WTPA.c        **** 		{
1973:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1974:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1975:WTPA.c        **** 		}
1976:WTPA.c        **** 	}
1977:WTPA.c        **** }
1978:WTPA.c        **** 
1979:WTPA.c        **** static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1980:WTPA.c        **** // Begins processing audio in realtime on the passed channel using the passed clock source.
1981:WTPA.c        **** // Thu Nov 24 19:40:21 CST 2011
1982:WTPA.c        **** // OK to do realtime even when banks are locked since we don't use the RAM
1983:WTPA.c        **** {
1984:WTPA.c        **** 	unsigned char
1985:WTPA.c        **** 		sreg;
1986:WTPA.c        **** 
1987:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
1988:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
1989:WTPA.c        **** 
1990:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
1991:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
1992:WTPA.c        **** 
1993:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
1994:WTPA.c        **** 
1995:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1996:WTPA.c        **** 	{
1997:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
1998:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1999:WTPA.c        **** 	}
2000:WTPA.c        **** }
2001:WTPA.c        **** 
2002:WTPA.c        **** /*
2003:WTPA.c        **** static void UnInitSampleClock(void)
2004:WTPA.c        **** {
2005:WTPA.c        **** 	PRR|=(1<<PRTIM1);	// Turn the TMR1 power off.
2006:WTPA.c        **** }
2007:WTPA.c        **** */
2008:WTPA.c        **** 
2009:WTPA.c        **** static void InitSampleClock(void)
2010:WTPA.c        **** // Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
2011:WTPA.c        **** // Or just turn it on so we can use the Input Capture pin to generate interrupts for the external c
2012:WTPA.c        **** {
2013:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
2014:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
2015:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
2016:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
2017:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
2018:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
2019:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
2020:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
2021:WTPA.c        **** }
2022:WTPA.c        **** 
2023:WTPA.c        **** 
2024:WTPA.c        **** //-----------------------------------------------------------------------
2025:WTPA.c        **** // SD Memory/Filesystem handling:
2026:WTPA.c        **** //-----------------------------------------------------------------------
2027:WTPA.c        **** // Fri Jun 17 19:13:12 EDT 2011
2028:WTPA.c        **** // Update the state of the uSD card.  Detect and initialize it when it needs that kind of thing.
2029:WTPA.c        **** // Keep track of card validity and when the card is being accessed, etc etc
2030:WTPA.c        **** // WTPA2 TOC:
2031:WTPA.c        **** // ====================
2032:WTPA.c        **** // Block 0:
2033:WTPA.c        **** // 4 	chars 		"WTPA"
2034:WTPA.c        **** // 12 	bytes 		don't care
2035:WTPA.c        **** // 64	bytes		Full/Empty sample slot info (512 bits which tell whether a sample is present or not in
2036:WTPA.c        **** // 432	bytes 		don't care
2037:WTPA.c        **** 
2038:WTPA.c        **** // Samples in SD-land:
2039:WTPA.c        **** // --------------------
2040:WTPA.c        **** // WTPA has a fifo in RAM which is 768 bytes long (1.5 blocks).
2041:WTPA.c        **** // Reading, we fill it a block (512 bytes) at a time.  When there is room for 512 bytes in the FIFO
2042:WTPA.c        **** // In order to not hang our state machine for two long, a fraction of a block is read at a time.  T
2043:WTPA.c        **** // Storing parameters works by storing the sample exactly as it is written to the DAC, meaning if t
2044:WTPA.c        **** // Likewise, reducing bit depth or editing a sample will mean the sample is permanently stored that
2045:WTPA.c        **** 
2046:WTPA.c        **** // Sample Format:
2047:WTPA.c        **** // ---------------
2048:WTPA.c        **** // Sample format is currently:
2049:WTPA.c        **** // 4 bytes 	==	sample length
2050:WTPA.c        **** // n bytes	==	sample
2051:WTPA.c        **** // NOTE -- we handle the case where a sample + the four byte addy is bigger than a sample slot (512
2052:WTPA.c        **** 
2053:WTPA.c        **** static void	ClearSampleToc(void)
2054:WTPA.c        **** // Empties the TOC of samples in local ram.
2055:WTPA.c        **** {
2056:WTPA.c        **** 	unsigned char
2057:WTPA.c        **** 		i;
2058:WTPA.c        **** 
2059:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
2060:WTPA.c        **** 	{
2061:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
2062:WTPA.c        **** 	}
2063:WTPA.c        **** }
2064:WTPA.c        **** 
2065:WTPA.c        **** static bool CheckSdSlotFull(unsigned int theSlot)
2066:WTPA.c        **** // Return true if the corresponding bit in the TOC is a 1.
2067:WTPA.c        **** // This is 64 bytes of 8 bits and we want to isolate the bit in question
2068:WTPA.c        **** {
2069:WTPA.c        **** 	unsigned char
2070:WTPA.c        **** 		theByte,
2071:WTPA.c        **** 		theBit;
2072:WTPA.c        **** 
2073:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2074:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2075:WTPA.c        **** 
2076:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
2077:WTPA.c        **** 	{
2078:WTPA.c        **** 		return(true);
2079:WTPA.c        **** 	}
2080:WTPA.c        **** 	else
2081:WTPA.c        **** 	{
2082:WTPA.c        **** 		return(false);
2083:WTPA.c        **** 	}
2084:WTPA.c        **** }
2085:WTPA.c        **** 
2086:WTPA.c        **** static void MarkSdSlotFull(unsigned int theSlot)
2087:WTPA.c        **** // Changes a bit in the TOC to a 1 to mark it full.
2088:WTPA.c        **** {
2089:WTPA.c        **** 	unsigned char
2090:WTPA.c        **** 		theByte,
2091:WTPA.c        **** 		theBit;
2092:WTPA.c        **** 
2093:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2094:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2095:WTPA.c        **** 
2096:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
2097:WTPA.c        **** }
2098:WTPA.c        **** 
2099:WTPA.c        **** /*
2100:WTPA.c        **** static void MarkSdSlotEmpty(unsigned int theSlot)
2101:WTPA.c        **** // Changes a bit in the TOC to a 0 to mark it empty.
2102:WTPA.c        **** {
2103:WTPA.c        **** 	unsigned char
2104:WTPA.c        **** 		theByte,
2105:WTPA.c        **** 		theBit;
2106:WTPA.c        **** 
2107:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2108:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2109:WTPA.c        **** 
2110:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
2111:WTPA.c        **** }
2112:WTPA.c        **** */
2113:WTPA.c        **** 
2114:WTPA.c        **** static bool GetCardFilesystem(void)
2115:WTPA.c        **** // Look for the tell tale signs of the party on this card.  If they are there, read in the TOC and 
2116:WTPA.c        **** {
2117:WTPA.c        **** 	bool
2118:WTPA.c        **** 		filesystemGood;
2119:WTPA.c        **** 	unsigned int
2120:WTPA.c        **** 		i;
2121:WTPA.c        **** 	char
2122:WTPA.c        **** 		theByte;
2123:WTPA.c        **** 
2124:WTPA.c        **** 	// Start reading the card at the very beginning.
2125:WTPA.c        **** 	// Are the first 4 chars WTPA?
2126:WTPA.c        **** 	// Stop reading, return true or false based on answer.
2127:WTPA.c        **** 
2128:WTPA.c        **** 	filesystemGood=true;					// Start assuming a good filesystem
2129:WTPA.c        **** 
2130:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
2131:WTPA.c        **** 	{
2132:WTPA.c        **** 		// Wait for a data packet from the card.
2133:WTPA.c        **** 		// EITHER read in the first four bytes then pull CS high  -- SD SPEC specifies that the SD card A
2134:WTPA.c        ****  		// Tue Jun 21 17:11:28 EDT 2011
2135:WTPA.c        ****  		// @@@ this appears to be bad news.  Tends to leave DO low.
2136:WTPA.c        **** 		// So --
2137:WTPA.c        **** 		// Read the first four bytes and test them, then read the remainder of the block and checksum and
2138:WTPA.c        **** 
2139:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
2140:WTPA.c        **** 
2141:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
2142:WTPA.c        **** 		{
2143:WTPA.c        **** 			HandleSoftclock();	// Kludgy
2144:WTPA.c        **** 		}
2145:WTPA.c        **** 
2146:WTPA.c        **** 		// Check the first 4 characters
2147:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2148:WTPA.c        **** 		if(theByte!='W')
2149:WTPA.c        **** 		{
2150:WTPA.c        **** 			filesystemGood=false;
2151:WTPA.c        **** 		}
2152:WTPA.c        **** 
2153:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2154:WTPA.c        **** 		if(theByte!='T')
2155:WTPA.c        **** 		{
2156:WTPA.c        **** 			filesystemGood=false;
2157:WTPA.c        **** 		}
2158:WTPA.c        **** 
2159:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2160:WTPA.c        **** 		if(theByte!='P')
2161:WTPA.c        **** 		{
2162:WTPA.c        **** 			filesystemGood=false;
2163:WTPA.c        **** 		}
2164:WTPA.c        **** 
2165:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2166:WTPA.c        **** 		if(theByte!='A')
2167:WTPA.c        **** 		{
2168:WTPA.c        **** 			filesystemGood=false;
2169:WTPA.c        **** 		}
2170:WTPA.c        **** 
2171:WTPA.c        **** // Sat Nov 12 16:38:20 EST 2011
2172:WTPA.c        **** // Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, 
2173:WTPA.c        **** 
2174:WTPA.c        **** 		for(i=0;i<12;i++)					// 12 don't care bytes
2175:WTPA.c        **** 		{
2176:WTPA.c        **** 			TransferSdByte(0xFF);
2177:WTPA.c        **** 		}
2178:WTPA.c        **** 
2179:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
2180:WTPA.c        **** 		{
2181:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
2182:WTPA.c        **** 			{
2183:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
2184:WTPA.c        **** 			}
2185:WTPA.c        **** 		}
2186:WTPA.c        **** 		else
2187:WTPA.c        **** 		{
2188:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
2189:WTPA.c        **** 			{
2190:WTPA.c        **** 				TransferSdByte(0xFF);
2191:WTPA.c        **** 			}
2192:WTPA.c        **** 
2193:WTPA.c        **** 		}
2194:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
2195:WTPA.c        **** 		{
2196:WTPA.c        **** 			TransferSdByte(0xFF);
2197:WTPA.c        **** 		}
2198:WTPA.c        **** 	}
2199:WTPA.c        **** 	else
2200:WTPA.c        **** 	{
2201:WTPA.c        **** 		filesystemGood=false;	// Error issuing read command
2202:WTPA.c        **** 	}
2203:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
2204:WTPA.c        **** 		;
2205:WTPA.c        **** 
2206:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
2207:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
2208:WTPA.c        **** 
2209:WTPA.c        **** 	return(filesystemGood);
2210:WTPA.c        **** }
2211:WTPA.c        **** 
2212:WTPA.c        **** static void DoFormatCard(void)
2213:WTPA.c        **** // We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
2214:WTPA.c        **** // Give the user the option to purge the card of its evil ways, and do so and reboot.
2215:WTPA.c        **** {
2216:WTPA.c        **** 	if(subState==SS_0)
2217:WTPA.c        **** 	{
2218:WTPA.c        **** 		KillLeds();		// Turn off LEDs
2219:WTPA.c        **** 
2220:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
2221:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
2222:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
2223:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
2224:WTPA.c        **** 
2225:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
2226:WTPA.c        **** 		subState=SS_1;
2227:WTPA.c        **** 	}
2228:WTPA.c        **** 	else if(subState==SS_1)
2229:WTPA.c        **** 	{
2230:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
2231:WTPA.c        **** 		{
2232:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
2233:WTPA.c        **** 			KillLeds();
2234:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
2235:WTPA.c        **** 			subState=SS_2;
2236:WTPA.c        **** 		}
2237:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
2238:WTPA.c        **** 		{
2239:WTPA.c        **** 			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
2240:WTPA.c        **** 		}
2241:WTPA.c        **** 	}
2242:WTPA.c        **** 	else if(subState==SS_2)
2243:WTPA.c        **** 	{
2244:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
2245:WTPA.c        **** 		{
2246:WTPA.c        **** 			KillLeds();
2247:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
2248:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
2249:WTPA.c        **** 			{
2250:WTPA.c        **** 				SetState(DoFruitcakeIntro);	// Start sampler over again.
2251:WTPA.c        **** 			}
2252:WTPA.c        **** 		}
2253:WTPA.c        **** 	}
2254:WTPA.c        **** }
2255:WTPA.c        **** 
2256:WTPA.c        **** static bool SdStartSampleRead(unsigned int sampleSlot)
2257:WTPA.c        **** // Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
2258:WTPA.c        **** // Begins a sample read in the correct spot.
2259:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2260:WTPA.c        **** {
2261:WTPA.c        **** 	unsigned char
2262:WTPA.c        **** 		sreg;
2263:WTPA.c        **** 
2264:WTPA.c        **** 	sreg=SREG;
2265:WTPA.c        **** 	cli();		// Pause ISR
2266:WTPA.c        **** 
2267:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
2268:WTPA.c        **** 	{
2269:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
2270:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
2271:WTPA.c        **** 
2272:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
2273:WTPA.c        **** 		sdFifoWritePointer=0;
2274:WTPA.c        **** 		sdBytesInFifo=0;
2275:WTPA.c        **** 
2276:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2277:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
2278:WTPA.c        **** 
2279:WTPA.c        **** 		SREG=sreg;	// Resume ISR
2280:WTPA.c        **** 
2281:WTPA.c        **** 		return(true);
2282:WTPA.c        **** 	}
2283:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2284:WTPA.c        **** 	return(false);
2285:WTPA.c        **** }
2286:WTPA.c        **** 
2287:WTPA.c        **** static void SdStartSampleWrite(unsigned int sampleSlot, unsigned long sampleLength)
2288:WTPA.c        **** // Initializes the state machine and FIFOs for writing a sample to the SD card
2289:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2290:WTPA.c        **** // Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
2291:WTPA.c        **** {
2292:WTPA.c        **** 	unsigned char
2293:WTPA.c        **** 		sreg;
2294:WTPA.c        **** 
2295:WTPA.c        **** 	sreg=SREG;
2296:WTPA.c        **** 	cli();		// Pause ISR
2297:WTPA.c        **** 
2298:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
2299:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
2300:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
2301:WTPA.c        **** 
2302:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2303:WTPA.c        **** 	sdFifoWritePointer=0;
2304:WTPA.c        **** 	sdBytesInFifo=0;
2305:WTPA.c        **** 
2306:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
2307:WTPA.c        **** 	{
2308:WTPA.c        **** 		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get fr
2309:WTPA.c        **** 	}
2310:WTPA.c        **** 	else
2311:WTPA.c        **** 	{
2312:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
2313:WTPA.c        **** 	}
2314:WTPA.c        **** 
2315:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
2316:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
2317:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2318:WTPA.c        **** }
2319:WTPA.c        **** 
2320:WTPA.c        **** static void ResetSdCard(void)
2321:WTPA.c        **** // If we unceremoniously pull a card, do this.
2322:WTPA.c        **** {
2323:WTPA.c        **** 	unsigned char
2324:WTPA.c        **** 		sreg;
2325:WTPA.c        **** 
2326:WTPA.c        **** 	sreg=SREG;
2327:WTPA.c        **** 	cli();
2328:WTPA.c        **** 	
2329:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
2330:WTPA.c        **** 	ClearSampleToc();
2331:WTPA.c        **** 	
2332:WTPA.c        **** 	// Stop SD card ISR
2333:WTPA.c        **** 
2334:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
2335:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
2336:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
2337:WTPA.c        **** 
2338:WTPA.c        **** 	// Set this contribution to the DAC to midscale (this output source is now quiet)
2339:WTPA.c        **** 	sdStreamOutput=0;
2340:WTPA.c        **** 
2341:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2342:WTPA.c        **** 	sdFifoWritePointer=0;
2343:WTPA.c        **** 	sdBytesInFifo=0;
2344:WTPA.c        **** 
2345:WTPA.c        **** 	InitSdInterface();
2346:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
2347:WTPA.c        **** 
2348:WTPA.c        **** 	SREG=sreg;
2349:WTPA.c        **** }
2350:WTPA.c        **** 
2351:WTPA.c        **** static void UpdateCard(void)
2352:WTPA.c        **** // Updates the state machine which keeps the card reads/writes/inits going like they should.
2353:WTPA.c        **** {
2354:WTPA.c        **** 	unsigned char
2355:WTPA.c        **** 		theByte,
2356:WTPA.c        **** 		sreg,
2357:WTPA.c        **** 		i;
2358:WTPA.c        **** 
2359:WTPA.c        **** 	signed char
2360:WTPA.c        **** 		tempSample;		// Must be signed or we can get bit errors (will hold ADC data most of the time)
2361:WTPA.c        **** 
2362:WTPA.c        **** 	unsigned int
2363:WTPA.c        **** 		numTransferBytes;
2364:WTPA.c        **** 
2365:WTPA.c        **** 	static unsigned int
2366:WTPA.c        **** 		bytesLeftInBlock;	// How many bytes left in the given block
2367:WTPA.c        **** 
2368:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
2369:WTPA.c        **** 	{
2370:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
2371:WTPA.c        **** 		{
2372:WTPA.c        **** 			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2373:WTPA.c        **** 		}
2374:WTPA.c        **** 	}
2375:WTPA.c        **** 	else	// Yup, got a card
2376:WTPA.c        **** 	{
2377:WTPA.c        **** 		switch(cardState)
2378:WTPA.c        **** 		{
2379:WTPA.c        **** 
2380:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2381:WTPA.c        **** // Warmup / Init	----------------------------------------------------------------------------------
2382:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2383:WTPA.c        **** 
2384:WTPA.c        **** 			case SD_NOT_PRESENT:	// Card just inserted
2385:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
2386:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
2387:WTPA.c        **** 			break;
2388:WTPA.c        **** 
2389:WTPA.c        **** 			case SD_WARMUP:				// Card inserted, timer has been started.
2390:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
2391:WTPA.c        **** 			{
2392:WTPA.c        **** 				sdPlaybackQueued=false;
2393:WTPA.c        **** 				sdAbortRead=false;
2394:WTPA.c        **** 
2395:WTPA.c        **** 				if(SdHandshake()==true)	// Give it a shot...
2396:WTPA.c        **** 				{
2397:WTPA.c        **** 					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct file
2398:WTPA.c        **** 					{
2399:WTPA.c        **** 						cardState=SD_IDLE;		// Card is legit and ready to go.
2400:WTPA.c        **** 						InitSdIsr();			// Enable the timers necessary to give the SD card its own IRQ
2401:WTPA.c        **** 					}
2402:WTPA.c        **** 					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the 
2403:WTPA.c        **** 					{
2404:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
2405:WTPA.c        **** 						ClearSampleToc();		// Write toc to zero
2406:WTPA.c        **** 						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to m
2407:WTPA.c        **** 					}
2408:WTPA.c        **** 				}
2409:WTPA.c        **** 				else	// Not a valid handshake.  Get on with our lives.
2410:WTPA.c        **** 				{
2411:WTPA.c        **** 					cardState=SD_INVALID;
2412:WTPA.c        **** 				}
2413:WTPA.c        **** 			}
2414:WTPA.c        **** 			break;
2415:WTPA.c        **** 
2416:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2417:WTPA.c        **** // Writing Samples to the Card	--------------------------------------------------------------------
2418:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2419:WTPA.c        **** 
2420:WTPA.c        **** 			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with th
2421:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2422:WTPA.c        **** 			cli();
2423:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2424:WTPA.c        **** 			{
2425:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
2426:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
2427:WTPA.c        **** 				{
2428:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2429:WTPA.c        **** 
2430:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
2431:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
2432:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
2433:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
2434:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
2435:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
2436:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
2437:WTPA.c        **** 
2438:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
2439:WTPA.c        **** 
2440:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing o
2441:WTPA.c        **** 				}
2442:WTPA.c        **** 				else // Couldn't open card for write
2443:WTPA.c        **** 				{
2444:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2445:WTPA.c        **** 				}
2446:WTPA.c        **** 			}
2447:WTPA.c        **** 			else	// Fifo not ready yet
2448:WTPA.c        **** 			{
2449:WTPA.c        **** 				SREG=sreg;	// Turn ISR back on
2450:WTPA.c        **** 			}
2451:WTPA.c        **** 			break;
2452:WTPA.c        **** 
2453:WTPA.c        **** 			case SD_WRITING_BLOCK:										// The SD card is open and we're currently writing a block.
2454:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2455:WTPA.c        **** 			{
2456:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2457:WTPA.c        **** 			}
2458:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2459:WTPA.c        **** 			{
2460:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2461:WTPA.c        **** 			}
2462:WTPA.c        **** 
2463:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
2464:WTPA.c        **** 			{
2465:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
2466:WTPA.c        **** 				{
2467:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
2468:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
2469:WTPA.c        **** 
2470:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
2471:WTPA.c        **** 
2472:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2473:WTPA.c        **** 					{
2474:WTPA.c        **** 						sdFifoReadPointer=0;
2475:WTPA.c        **** 					}
2476:WTPA.c        **** 
2477:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2478:WTPA.c        **** 					cli();
2479:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
2480:WTPA.c        **** 					SREG=sreg;
2481:WTPA.c        **** 				}
2482:WTPA.c        **** 				else	// If sample has been loaded already
2483:WTPA.c        **** 				{
2484:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
2485:WTPA.c        **** 				}
2486:WTPA.c        **** 
2487:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
2488:WTPA.c        **** 			}
2489:WTPA.c        **** 
2490:WTPA.c        **** 			// Have we written an entire block?
2491:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
2492:WTPA.c        **** 			{
2493:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2494:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2495:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2496:WTPA.c        **** 
2497:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2498:WTPA.c        **** 				{
2499:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2500:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
2501:WTPA.c        **** 				}
2502:WTPA.c        **** 				else	// Something wrong with the write.
2503:WTPA.c        **** 				{
2504:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2505:WTPA.c        **** 				}
2506:WTPA.c        **** 			}
2507:WTPA.c        **** 			break;
2508:WTPA.c        **** 
2509:WTPA.c        **** 			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writi
2510:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
2511:WTPA.c        **** 			{
2512:WTPA.c        **** 				i=0;
2513:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2514:WTPA.c        **** 				{
2515:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2516:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2517:WTPA.c        **** 					{
2518:WTPA.c        **** 						i++;	// Try again.
2519:WTPA.c        **** 					}
2520:WTPA.c        **** 					else
2521:WTPA.c        **** 					{
2522:WTPA.c        **** 						i=4;	// Got a result, stop polling
2523:WTPA.c        **** 					}
2524:WTPA.c        **** 				}
2525:WTPA.c        **** 
2526:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
2527:WTPA.c        **** 				{
2528:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2529:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2530:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2531:WTPA.c        **** 						;
2532:WTPA.c        **** 
2533:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
2534:WTPA.c        **** 					{
2535:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
2536:WTPA.c        **** 					}
2537:WTPA.c        **** 					else	// We've written the entire sample to the SD card, and the SD card block write is done.  
2538:WTPA.c        **** 					{
2539:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
2540:WTPA.c        **** 						{
2541:WTPA.c        **** 							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been fille
2542:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
2543:WTPA.c        **** 						}
2544:WTPA.c        **** 						else
2545:WTPA.c        **** 						{
2546:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
2547:WTPA.c        **** 						}
2548:WTPA.c        **** 					}
2549:WTPA.c        **** 				}
2550:WTPA.c        **** 			}
2551:WTPA.c        **** 			else	// Timed out waiting for block to write.
2552:WTPA.c        **** 			{
2553:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2554:WTPA.c        **** 			}
2555:WTPA.c        **** 			break;
2556:WTPA.c        **** 
2557:WTPA.c        **** 			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full
2558:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
2559:WTPA.c        **** 			cli();
2560:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2561:WTPA.c        **** 			{
2562:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
2563:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
2564:WTPA.c        **** 
2565:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
2566:WTPA.c        **** 				{
2567:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2568:WTPA.c        **** 
2569:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
2570:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
2571:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
2572:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
2573:WTPA.c        **** 				}
2574:WTPA.c        **** 				else	// Couldn't successfully open block to write
2575:WTPA.c        **** 				{
2576:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2577:WTPA.c        **** 				}
2578:WTPA.c        **** 			}
2579:WTPA.c        **** 			else	// Bytes remaining in sample, but not enough in the fifo yet
2580:WTPA.c        **** 			{
2581:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
2582:WTPA.c        **** 			}
2583:WTPA.c        **** 			break;
2584:WTPA.c        **** 
2585:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2586:WTPA.c        **** // Writing TOC to the Card	------------------------------------------------------------------------
2587:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2588:WTPA.c        **** 
2589:WTPA.c        **** 			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via n
2590:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
2591:WTPA.c        **** 			{
2592:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
2593:WTPA.c        **** 
2594:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2595:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
2596:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
2597:WTPA.c        **** 				TransferSdByte('W');				// Send flag that this is a WTPA card
2598:WTPA.c        **** 				TransferSdByte('T');
2599:WTPA.c        **** 				TransferSdByte('P');
2600:WTPA.c        **** 				TransferSdByte('A');
2601:WTPA.c        **** 
2602:WTPA.c        **** 				bytesLeftInBlock-=4;
2603:WTPA.c        **** 
2604:WTPA.c        **** 				for(i=0;i<12;i++)					// 12 don't care bytes
2605:WTPA.c        **** 				{
2606:WTPA.c        **** 					TransferSdByte('x');
2607:WTPA.c        **** 				}
2608:WTPA.c        **** 
2609:WTPA.c        **** 				bytesLeftInBlock-=12;
2610:WTPA.c        **** 
2611:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
2612:WTPA.c        **** 				{
2613:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
2614:WTPA.c        **** 				}
2615:WTPA.c        **** 
2616:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
2617:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
2618:WTPA.c        **** 			}
2619:WTPA.c        **** 			else	// Block write failed
2620:WTPA.c        **** 			{
2621:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2622:WTPA.c        **** 			}
2623:WTPA.c        **** 			break;
2624:WTPA.c        **** 
2625:WTPA.c        **** 			case SD_TOC_WRITE_CONTINUE:				// Keep writing don't cares to the block until we're done.
2626:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2627:WTPA.c        **** 			{
2628:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2629:WTPA.c        **** 			}
2630:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2631:WTPA.c        **** 			{
2632:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2633:WTPA.c        **** 			}
2634:WTPA.c        **** 
2635:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
2636:WTPA.c        **** 			{
2637:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2638:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
2639:WTPA.c        **** 			}
2640:WTPA.c        **** 
2641:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
2642:WTPA.c        **** 			{
2643:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2644:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2645:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2646:WTPA.c        **** 
2647:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2648:WTPA.c        **** 				{
2649:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2650:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
2651:WTPA.c        **** 				}
2652:WTPA.c        **** 				else	// Something wrong with the write.
2653:WTPA.c        **** 				{
2654:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2655:WTPA.c        **** 				}
2656:WTPA.c        **** 			}
2657:WTPA.c        **** 			break;
2658:WTPA.c        **** 
2659:WTPA.c        **** 			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
2660:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2661:WTPA.c        **** 			{
2662:WTPA.c        **** 				i=0;
2663:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2664:WTPA.c        **** 				{
2665:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2666:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2667:WTPA.c        **** 					{
2668:WTPA.c        **** 						i++;	// Try again.
2669:WTPA.c        **** 					}
2670:WTPA.c        **** 					else
2671:WTPA.c        **** 					{
2672:WTPA.c        **** 						i=4;	// Got a result, stop polling
2673:WTPA.c        **** 					}
2674:WTPA.c        **** 				}
2675:WTPA.c        **** 
2676:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
2677:WTPA.c        **** 				{
2678:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2679:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2680:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2681:WTPA.c        **** 						;
2682:WTPA.c        **** 					cardState=SD_IDLE;				// DONE!
2683:WTPA.c        **** 				}
2684:WTPA.c        **** 			}
2685:WTPA.c        **** 			else	// Timed out waiting for block to write.
2686:WTPA.c        **** 			{
2687:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2688:WTPA.c        **** 			}
2689:WTPA.c        **** 			break;
2690:WTPA.c        **** 
2691:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2692:WTPA.c        **** // Reading Samples from the Card ------------------------------------------------------------------
2693:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2694:WTPA.c        **** 
2695:WTPA.c        **** 			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token t
2696:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2697:WTPA.c        **** 			{
2698:WTPA.c        **** 				i=0;
2699:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2700:WTPA.c        **** 				{
2701:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2702:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2703:WTPA.c        **** 					{
2704:WTPA.c        **** 						i++;	// Try again.
2705:WTPA.c        **** 					}
2706:WTPA.c        **** 					else
2707:WTPA.c        **** 					{
2708:WTPA.c        **** 						i=4;	// Got a result, stop polling
2709:WTPA.c        **** 					}
2710:WTPA.c        **** 				}
2711:WTPA.c        **** 
2712:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2713:WTPA.c        **** 				{
2714:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
2715:WTPA.c        **** 
2716:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
2717:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
2718:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
2719:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
2720:WTPA.c        **** 
2721:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
2722:WTPA.c        **** 
2723:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
2724:WTPA.c        **** 					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handl
2725:WTPA.c        **** 
2726:WTPA.c        **** 					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abor
2727:WTPA.c        **** 					{
2728:WTPA.c        **** 						cardState=SD_READ_ABORT;
2729:WTPA.c        **** 						sdAbortRead=false;
2730:WTPA.c        **** 					}
2731:WTPA.c        **** 				}
2732:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2733:WTPA.c        **** 				{
2734:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2735:WTPA.c        **** 				}
2736:WTPA.c        **** 			}
2737:WTPA.c        **** 			else	// Timed out starting read.
2738:WTPA.c        **** 			{
2739:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2740:WTPA.c        **** 			}
2741:WTPA.c        **** 			break;
2742:WTPA.c        **** 
2743:WTPA.c        **** 			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes 
2744:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
2745:WTPA.c        **** 			{
2746:WTPA.c        **** 				cardState=SD_READ_ABORT;
2747:WTPA.c        **** 				sdAbortRead=false;
2748:WTPA.c        **** 			}
2749:WTPA.c        **** 			else
2750:WTPA.c        **** 			{
2751:WTPA.c        **** 				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block
2752:WTPA.c        **** 				{
2753:WTPA.c        **** 					numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2754:WTPA.c        **** 				}
2755:WTPA.c        **** 				else	// Less than a chunk left in the block, read the rest of the block.
2756:WTPA.c        **** 				{
2757:WTPA.c        **** 					numTransferBytes=bytesLeftInBlock;
2758:WTPA.c        **** 				}
2759:WTPA.c        **** 
2760:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
2761:WTPA.c        **** 				{
2762:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
2763:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
2764:WTPA.c        **** 
2765:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
2766:WTPA.c        **** 					{
2767:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
2768:WTPA.c        **** 
2769:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
2770:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
2771:WTPA.c        **** 
2772:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2773:WTPA.c        **** 						{
2774:WTPA.c        **** 							sdFifoWritePointer=0;
2775:WTPA.c        **** 						}
2776:WTPA.c        **** 
2777:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2778:WTPA.c        **** 						cli();
2779:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
2780:WTPA.c        **** 						SREG=sreg;
2781:WTPA.c        **** 					}
2782:WTPA.c        **** 				}
2783:WTPA.c        **** 
2784:WTPA.c        **** 				// Check done-ness of block read:
2785:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
2786:WTPA.c        **** 				{
2787:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2788:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2789:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2790:WTPA.c        **** 						;
2791:WTPA.c        **** 
2792:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2793:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2794:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
2795:WTPA.c        **** 
2796:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
2797:WTPA.c        **** 					{
2798:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2799:WTPA.c        **** 							;
2800:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
2801:WTPA.c        **** 					}
2802:WTPA.c        **** 				}
2803:WTPA.c        **** 			}
2804:WTPA.c        **** 			break;
2805:WTPA.c        **** 
2806:WTPA.c        **** 			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through e
2807:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2808:WTPA.c        **** 			cli();
2809:WTPA.c        **** 
2810:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
2811:WTPA.c        **** 			{
2812:WTPA.c        **** 				SREG=sreg;				// ISR back on.
2813:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
2814:WTPA.c        **** 
2815:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
2816:WTPA.c        **** 				{
2817:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2818:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
2819:WTPA.c        **** 				}
2820:WTPA.c        **** 				else	// Read failed!
2821:WTPA.c        **** 				{
2822:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2823:WTPA.c        **** 				}
2824:WTPA.c        **** 			}
2825:WTPA.c        **** 			else	// ISR has not cleared enough of the sample out of the FIFO yet.
2826:WTPA.c        **** 			{
2827:WTPA.c        **** 				SREG=sreg;	// ISR back on.
2828:WTPA.c        **** 			}
2829:WTPA.c        **** 			break;
2830:WTPA.c        **** 
2831:WTPA.c        **** 
2832:WTPA.c        **** 			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token 
2833:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
2834:WTPA.c        **** 			{
2835:WTPA.c        **** 				i=0;
2836:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2837:WTPA.c        **** 				{
2838:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2839:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2840:WTPA.c        **** 					{
2841:WTPA.c        **** 						i++;	// Try again.
2842:WTPA.c        **** 					}
2843:WTPA.c        **** 					else
2844:WTPA.c        **** 					{
2845:WTPA.c        **** 						i=4;	// Got a result, stop polling
2846:WTPA.c        **** 					}
2847:WTPA.c        **** 				}
2848:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2849:WTPA.c        **** 				{
2850:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
2851:WTPA.c        **** 
2852:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
2853:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
2854:WTPA.c        **** 					{
2855:WTPA.c        **** 						cardState=SD_READ_ABORT;
2856:WTPA.c        **** 						sdAbortRead=false;
2857:WTPA.c        **** 					}
2858:WTPA.c        **** 				}
2859:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2860:WTPA.c        **** 				{
2861:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2862:WTPA.c        **** 				}
2863:WTPA.c        **** 			}
2864:WTPA.c        **** 			else	// Timed out starting read.
2865:WTPA.c        **** 			{
2866:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2867:WTPA.c        **** 			}
2868:WTPA.c        **** 			break;
2869:WTPA.c        **** 
2870:WTPA.c        **** 			case SD_READ_ABORT:				// We've been asked to start a new playback stream from the SD while a bl
2871:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2872:WTPA.c        **** 			{
2873:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2874:WTPA.c        **** 			}
2875:WTPA.c        **** 			else	// Less than a chunk left in the block, read the rest of the block.
2876:WTPA.c        **** 			{
2877:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2878:WTPA.c        **** 			}
2879:WTPA.c        **** 
2880:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
2881:WTPA.c        **** 			{
2882:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
2883:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
2884:WTPA.c        **** 			}
2885:WTPA.c        **** 
2886:WTPA.c        **** 			// Check done-ness of block read:
2887:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
2888:WTPA.c        **** 			{
2889:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2890:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2891:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2892:WTPA.c        **** 					;
2893:WTPA.c        **** 
2894:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
2895:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
2896:WTPA.c        **** 
2897:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2898:WTPA.c        **** 					;
2899:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
2900:WTPA.c        **** 
2901:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
2902:WTPA.c        **** 				{
2903:WTPA.c        **** 					sdPlaybackQueued=false;
2904:WTPA.c        **** //					PlaySampleFromSd(sdQueuedBank,sdQueuedSlot);	// Trigger the next stream immediately
2905:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
2906:WTPA.c        **** 				}
2907:WTPA.c        **** 			}
2908:WTPA.c        **** 			break;
2909:WTPA.c        **** 
2910:WTPA.c        **** 			case SD_IDLE:		// Do nothing if IDLE.
2911:WTPA.c        **** 			case SD_INVALID:	// If we're invalid, fall through and do nothing.
2912:WTPA.c        **** 			default:
2913:WTPA.c        **** 			break;
2914:WTPA.c        **** 		}
2915:WTPA.c        **** 	}
2916:WTPA.c        **** }
2917:WTPA.c        **** 
2918:WTPA.c        **** 
2919:WTPA.c        **** //-----------------------------------------------------------------------
2920:WTPA.c        **** //-----------------------------------------------------------------------
2921:WTPA.c        **** // SD Sample Read and Write Functions:
2922:WTPA.c        **** //-----------------------------------------------------------------------
2923:WTPA.c        **** //-----------------------------------------------------------------------
2924:WTPA.c        **** // The functions the main loop calls to get and put samples on the SD card.
2925:WTPA.c        **** // Sat Sep 24 19:08:17 EDT 2011
2926:WTPA.c        **** // This includes both the SD card state machine stuff (run from the main loop) and any ISRs needed 
2927:WTPA.c        **** 
2928:WTPA.c        **** 
2929:WTPA.c        **** static void InitSdIsr(void)
2930:WTPA.c        **** // Prepare a timer interrupt to handle filling and emptying the SD card's buffer
2931:WTPA.c        **** // This can fill the SRAM with data from the SD card, fill the SD card with data from the SRAM, or 
2932:WTPA.c        **** // NOTE -- we are using compare match B on timer 2 for this.  Compare match A is already used for t
2933:WTPA.c        **** // NOTE -- This means we have to call this after we finish the PWM business or the timer will be re
2934:WTPA.c        **** // Sat Sep 24 19:07:57 EDT 2011
2935:WTPA.c        **** // In our old code, we were reading and writing every 780 cycles (~25kHz) and playing back every 90
2936:WTPA.c        **** // In the new code we need to use 907/8 or 113 -- this gives a playback rate of about 22124, or an 
2937:WTPA.c        **** // We COULD go back and forth between 113 and 114, which gives us an average of 0.1% (1.73 cents) w
2938:WTPA.c        **** // Listening to some tests on the internet I can't tell the difference, so we do this the easy way 
2939:WTPA.c        **** // (Reading and writing don't matter, since we don't hear them and a small percentage difference wo
2940:WTPA.c        **** {
2941:WTPA.c        **** 	// Set up timer 2 OC2B to make SD buffer interrupts
2942:WTPA.c        **** 
2943:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
2944:WTPA.c        **** 
2945:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
2946:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
2947:WTPA.c        **** 	TCNT2=0;			// Init counter reg
2948:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
2949:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
2950:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
2951:WTPA.c        **** 
2952:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
2953:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
2954:WTPA.c        **** }
2955:WTPA.c        **** 
2956:WTPA.c        **** static void SdIsrStartReadingRam(unsigned char theBank)
2957:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
2958:WTPA.c        **** // Tell it to collect bytes from the passed bank and fill the buffer.
2959:WTPA.c        **** {
2960:WTPA.c        **** 	unsigned char
2961:WTPA.c        **** 		sreg;
2962:WTPA.c        **** 
2963:WTPA.c        **** 	sreg=SREG;
2964:WTPA.c        **** 	cli();		// Pause ISRs
2965:WTPA.c        **** 
2966:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
2967:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
2968:WTPA.c        **** 
2969:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
2970:WTPA.c        **** 	{
2971:WTPA.c        **** 		sdBank0=true;
2972:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
2973:WTPA.c        **** 	}
2974:WTPA.c        **** 	else
2975:WTPA.c        **** 	{
2976:WTPA.c        **** 		sdBank0=false;
2977:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
2978:WTPA.c        **** 	}
2979:WTPA.c        **** 
2980:WTPA.c        **** 	TCNT2=0;			// Init counter reg
2981:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
2982:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
2983:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
2984:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
2985:WTPA.c        **** 
2986:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
2987:WTPA.c        **** }
2988:WTPA.c        **** 
2989:WTPA.c        **** static void SdIsrStartWritingRam(unsigned char theBank)
2990:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
2991:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
2992:WTPA.c        **** {
2993:WTPA.c        **** 	unsigned char
2994:WTPA.c        **** 		sreg;
2995:WTPA.c        **** 
2996:WTPA.c        **** 	sreg=SREG;
2997:WTPA.c        **** 	cli();		// Pause ISRs
2998:WTPA.c        **** 
2999:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
3000:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
3001:WTPA.c        **** 
3002:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
3003:WTPA.c        **** 	{
3004:WTPA.c        **** 		sdBank0=true;
3005:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
3006:WTPA.c        **** 	}
3007:WTPA.c        **** 	else
3008:WTPA.c        **** 	{
3009:WTPA.c        **** 		sdBank0=false;
3010:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3011:WTPA.c        **** 	}
3012:WTPA.c        **** 
3013:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3014:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3015:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3016:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3017:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3018:WTPA.c        **** 
3019:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3020:WTPA.c        **** }
3021:WTPA.c        **** 
3022:WTPA.c        **** static void SdIsrStartStreamingAudio(void)
3023:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3024:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM.
3025:WTPA.c        **** {
 2043               		.loc 1 3025 0
 2044               		.cfi_startproc
 2045               	/* prologue: function */
 2046               	/* frame size = 0 */
 2047               	/* stack size = 0 */
 2048               	.L__stack_usage = 0
3026:WTPA.c        **** 	unsigned char
3027:WTPA.c        **** 		sreg;
3028:WTPA.c        **** 
3029:WTPA.c        **** 	sreg=SREG;
 2049               		.loc 1 3029 0
 2050 10ea 9FB7      		in r25,__SREG__
 2051               	.LVL57:
3030:WTPA.c        **** 	cli();		// Pause ISRs
 2052               		.loc 1 3030 0
 2053               	/* #APP */
 2054               	 ;  3030 "WTPA.c" 1
 2055 10ec F894      		cli
 2056               	 ;  0 "" 2
3031:WTPA.c        **** 
3032:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
 2057               		.loc 1 3032 0
 2058               	/* #NOAPP */
 2059 10ee 83E0      		ldi r24,lo8(3)
 2060 10f0 8093 0000 		sts sdIsrState,r24
3033:WTPA.c        **** 
3034:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 2061               		.loc 1 3034 0
 2062 10f4 1092 B200 		sts 178,__zero_reg__
3035:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 2063               		.loc 1 3035 0
 2064 10f8 81E7      		ldi r24,lo8(113)
 2065 10fa 8093 B300 		sts 179,r24
3036:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 2066               		.loc 1 3036 0
 2067 10fe 8FEF      		ldi r24,lo8(-1)
 2068 1100 87BB      		out 0x17,r24
3037:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 2069               		.loc 1 3037 0
 2070 1102 E0E7      		ldi r30,lo8(112)
 2071 1104 F0E0      		ldi r31,0
 2072 1106 8081      		ld r24,Z
 2073 1108 8460      		ori r24,lo8(4)
 2074 110a 8083      		st Z,r24
3038:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 2075               		.loc 1 3038 0
 2076 110c 82E0      		ldi r24,lo8(2)
 2077 110e 8093 B100 		sts 177,r24
3039:WTPA.c        **** 
3040:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 2078               		.loc 1 3040 0
 2079 1112 9FBF      		out __SREG__,r25
 2080 1114 0895      		ret
 2081               		.cfi_endproc
 2082               	.LFE47:
 2085               	GetRandomLongInt:
 2086               	.LFB60:
3041:WTPA.c        **** }
3042:WTPA.c        **** 
3043:WTPA.c        **** static unsigned long GetLengthOfSample(unsigned char theBank)
3044:WTPA.c        **** // Returns the length of the sample, handles my laziness.
3045:WTPA.c        **** {
3046:WTPA.c        **** 	unsigned long
3047:WTPA.c        **** 		theLength;
3048:WTPA.c        **** 
3049:WTPA.c        **** 	if(theBank==BANK_0)
3050:WTPA.c        **** 	{
3051:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3052:WTPA.c        **** 		{
3053:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
3054:WTPA.c        **** 		}
3055:WTPA.c        **** 		else
3056:WTPA.c        **** 		{
3057:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
3058:WTPA.c        **** 		}
3059:WTPA.c        **** 	}
3060:WTPA.c        **** 	else
3061:WTPA.c        **** 	{
3062:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3063:WTPA.c        **** 		{
3064:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
3065:WTPA.c        **** 		}
3066:WTPA.c        **** 		else
3067:WTPA.c        **** 		{
3068:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
3069:WTPA.c        **** 		}
3070:WTPA.c        **** 	}
3071:WTPA.c        **** 
3072:WTPA.c        **** 	return(theLength);
3073:WTPA.c        **** }
3074:WTPA.c        **** 
3075:WTPA.c        **** //------------------------------------------------------------------------------------------
3076:WTPA.c        **** // Below are the SD functions that we call from the mainline code to write, read and stream
3077:WTPA.c        **** //------------------------------------------------------------------------------------------
3078:WTPA.c        **** 
3079:WTPA.c        **** static void WriteSampleToSd(unsigned char theBank, unsigned int theSlot)
3080:WTPA.c        **** // Takes the sample currently in the passed bank, with any audio effects applied, and puts it in th
3081:WTPA.c        **** // Makes sure the SD card has been properly groomed first.
3082:WTPA.c        **** // NOTE: SD state machine will shut down the write process itself
3083:WTPA.c        **** {
3084:WTPA.c        **** 	unsigned long
3085:WTPA.c        **** 		theLength;
3086:WTPA.c        **** 	unsigned char
3087:WTPA.c        **** 		sreg;
3088:WTPA.c        **** 
3089:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3090:WTPA.c        **** 	{
3091:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3092:WTPA.c        **** 		{
3093:WTPA.c        **** 			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank
3094:WTPA.c        **** 
3095:WTPA.c        **** 			sreg=SREG;
3096:WTPA.c        **** 			cli();		// Pause ISR
3097:WTPA.c        **** 
3098:WTPA.c        **** 			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and 
3099:WTPA.c        **** 			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3100:WTPA.c        **** 
3101:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3102:WTPA.c        **** 		}
3103:WTPA.c        **** 	}
3104:WTPA.c        **** }
3105:WTPA.c        **** 
3106:WTPA.c        **** static void ReadSampleFromSd(unsigned char theBank, unsigned int theSlot)
3107:WTPA.c        **** // Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card 
3108:WTPA.c        **** {
3109:WTPA.c        **** 	unsigned char
3110:WTPA.c        **** 		sreg;
3111:WTPA.c        **** 
3112:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3113:WTPA.c        **** 	{
3114:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3115:WTPA.c        **** 		{
3116:WTPA.c        **** 			sreg=SREG;
3117:WTPA.c        **** 			cli();		// Pause ISR
3118:WTPA.c        **** 
3119:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
3120:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
3121:WTPA.c        **** 			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3122:WTPA.c        **** 
3123:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3124:WTPA.c        **** 		}
3125:WTPA.c        **** 	}
3126:WTPA.c        **** }
3127:WTPA.c        **** 
3128:WTPA.c        **** //static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot)
3129:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot)
3130:WTPA.c        **** // Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample i
3131:WTPA.c        **** {
3132:WTPA.c        **** 	unsigned char
3133:WTPA.c        **** 		sreg;
3134:WTPA.c        **** 
3135:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3136:WTPA.c        **** 	{
3137:WTPA.c        **** 		sreg=SREG;	 // Pause ISRs
3138:WTPA.c        **** 		cli();
3139:WTPA.c        **** 
3140:WTPA.c        **** 		SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3141:WTPA.c        **** 		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byte
3142:WTPA.c        **** 		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3143:WTPA.c        **** 
3144:WTPA.c        **** 		SREG=sreg;	// resume isr
3145:WTPA.c        **** 	}
3146:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
3147:WTPA.c        **** 	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck u
3148:WTPA.c        **** 	{
3149:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
3150:WTPA.c        **** 		{
3151:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
3152:WTPA.c        **** 			cli();
3153:WTPA.c        **** 
3154:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3155:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
3156:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3157:WTPA.c        **** 
3158:WTPA.c        **** 			SREG=sreg;	// resume isr
3159:WTPA.c        **** 		}
3160:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
3161:WTPA.c        **** 		{
3162:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3163:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3164:WTPA.c        **** 		}
3165:WTPA.c        **** 		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and
3166:WTPA.c        **** 		{
3167:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3168:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3169:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
3170:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
3171:WTPA.c        **** 
3172:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
3173:WTPA.c        **** 			cli();
3174:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
3175:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
3176:WTPA.c        **** 			SREG=sreg;
3177:WTPA.c        **** 		}
3178:WTPA.c        **** 	}
3179:WTPA.c        **** }
3180:WTPA.c        **** 
3181:WTPA.c        **** 
3182:WTPA.c        **** //static void CleanupSdPlayback(void)
3183:WTPA.c        **** // Runs in the main loop and makes sure that the SD state machine closes any blocks opened during S
3184:WTPA.c        **** // This happens if the user tells the sampler to do a different playback/record function and the IS
3185:WTPA.c        **** // NOTE -- the SD will not read from or write to RAM if the card is not idle, so we only need to wo
3186:WTPA.c        **** // Sun Nov 13 20:03:28 EST 2011
3187:WTPA.c        **** // Do we need to check for abort conditions anymore?  I kinda think not, since SD playback no longe
3188:WTPA.c        **** //{
3189:WTPA.c        **** //	if(sdIsrState==SD_ISR_IDLE)
3190:WTPA.c        **** //	{
3191:WTPA.c        **** //		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR 
3192:WTPA.c        **** //	}
3193:WTPA.c        **** 
3194:WTPA.c        **** /*
3195:WTPA.c        **** 	if(bankStates[BANK_0].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_0].audioFunction!=AUDIO_READ_
3196:WTPA.c        **** 	{
3197:WTPA.c        **** 		if(bankStates[BANK_1].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_1].audioFunction!=AUDIO_READ
3198:WTPA.c        **** 		{
3199:WTPA.c        **** 			if(cardState==SD_READ_START||cardState==SD_READING_BLOCK||cardState==SD_READ_FIFO_WAIT||cardStat
3200:WTPA.c        **** 			{
3201:WTPA.c        **** 				if(cardState==SD_READ_FIFO_WAIT)	// If we're waiting for the FIFO, we can just abort; there isn
3202:WTPA.c        **** 				{
3203:WTPA.c        **** 						cardState=SD_IDLE;	// Just end it.
3204:WTPA.c        **** 				}
3205:WTPA.c        **** 				else
3206:WTPA.c        **** 				{
3207:WTPA.c        **** 						sdAbortRead=true;	// We're in mid-read.  Let the state machine know to abort the read when it
3208:WTPA.c        **** 				}
3209:WTPA.c        **** 			}
3210:WTPA.c        **** 		}
3211:WTPA.c        **** 	}
3212:WTPA.c        **** */
3213:WTPA.c        **** //}
3214:WTPA.c        **** 
3215:WTPA.c        **** //--------------------------------------
3216:WTPA.c        **** //--------------------------------------
3217:WTPA.c        **** // MIDI Functions
3218:WTPA.c        **** //--------------------------------------
3219:WTPA.c        **** //--------------------------------------
3220:WTPA.c        **** // Control Changes messages are what tells the midi state machine what to do next.
3221:WTPA.c        **** 
3222:WTPA.c        **** /*
3223:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>5)		// About 9.6k -- This is MIDI N
3224:WTPA.c        **** #define		MIDI_GENERIC_NOTE		60											// We use this to pass our midi out note when the sampler 
3225:WTPA.c        **** */
3226:WTPA.c        **** 
3227:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>4)		// 4.8k -- This is MIDI Note 48
3228:WTPA.c        **** #define		MIDI_GENERIC_NOTE		48											// We use this to pass our midi out note when the sampler 
3229:WTPA.c        **** 
3230:WTPA.c        **** static unsigned int
3231:WTPA.c        **** 	theMidiRecordRate[NUM_BANKS];		// Make this from out EEPROM data.
3232:WTPA.c        **** 
3233:WTPA.c        **** // Control Change messages:
3234:WTPA.c        **** // The messages which control binary effects (like Half Speed, or backwards masking) are just inter
3235:WTPA.c        **** 
3236:WTPA.c        **** // Fri Mar 26 22:02:22 EDT 2010
3237:WTPA.c        **** // Renumbered to undefined CCs
3238:WTPA.c        **** 
3239:WTPA.c        **** #define		MIDI_RECORDING				3
3240:WTPA.c        **** #define		MIDI_OVERDUB				9
3241:WTPA.c        **** #define		MIDI_REALTIME				14
3242:WTPA.c        **** #define		MIDI_LOOP					15
3243:WTPA.c        **** #define		MIDI_HALF_SPEED				16
3244:WTPA.c        **** #define		MIDI_PLAY_BACKWARDS			17
3245:WTPA.c        **** #define		MIDI_CANCEL_EFFECTS			18
3246:WTPA.c        **** #define		MIDI_BIT_REDUCTION			19		// Crustiness quotient.
3247:WTPA.c        **** #define 	MIDI_GRANULARITY			20		// Beatbox.
3248:WTPA.c        **** #define 	MIDI_JITTER					21		// Hisssss
3249:WTPA.c        **** #define 	MIDI_OUTPUT_COMBINATION		22		// Set the output (SUM, XOR, AND, MULT) with this message.
3250:WTPA.c        **** #define 	MIDI_STORE_RECORD_NOTE		23		// Makes the next NOTE_ON into the record rate we'll use from 
3251:WTPA.c        **** 
3252:WTPA.c        **** // Editing functions:
3253:WTPA.c        **** 
3254:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_RESOLUTE	24
3255:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_RESOLUTE		25
3256:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE	26
3257:WTPA.c        **** #define 	MIDI_REVERT_SAMPLE_TO_FULL			27
3258:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_WIDE		28
3259:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_WIDE			29
3260:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_WIDE		30
3261:WTPA.c        **** 
3262:WTPA.c        **** static const unsigned int OctaveZeroCompareMatches[]=
3263:WTPA.c        **** // This table corresponds to a musical octave (the lowest octave we can generate with a 16-bit comp
3264:WTPA.c        **** {
3265:WTPA.c        **** 	65535,		// This is 300 Hz. (Followed by 600, 1.2k, 2.4k, 4.8k, 9.6k, 19.2k shifted over by 1 to 6 
3266:WTPA.c        **** 	61857,
3267:WTPA.c        **** 	58385,
3268:WTPA.c        **** 	55108,
3269:WTPA.c        **** 	52015,
3270:WTPA.c        **** 	49096,
3271:WTPA.c        **** 	46340,
3272:WTPA.c        **** 	43739,
3273:WTPA.c        **** 	41284,
3274:WTPA.c        **** 	38967,
3275:WTPA.c        **** 	36780,
3276:WTPA.c        **** 	34716,
3277:WTPA.c        **** };
3278:WTPA.c        **** 
3279:WTPA.c        **** enum	// Note names for lookups.
3280:WTPA.c        **** {
3281:WTPA.c        **** 	C_NOTE=0,
3282:WTPA.c        **** 	D_FLAT_NOTE,
3283:WTPA.c        **** 	D_NOTE,
3284:WTPA.c        **** 	E_FLAT_NOTE,
3285:WTPA.c        **** 	E_NOTE,
3286:WTPA.c        **** 	F_NOTE,
3287:WTPA.c        **** 	G_FLAT_NOTE,
3288:WTPA.c        **** 	G_NOTE,
3289:WTPA.c        **** 	A_FLAT_NOTE,
3290:WTPA.c        **** 	A_NOTE,
3291:WTPA.c        **** 	B_FLAT_NOTE,
3292:WTPA.c        **** 	B_NOTE,
3293:WTPA.c        **** };
3294:WTPA.c        **** 
3295:WTPA.c        **** static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
3296:WTPA.c        **** // Here we take a midi note number and turn it into the timer one compare match interrupt value.
3297:WTPA.c        **** {
3298:WTPA.c        **** 	unsigned char
3299:WTPA.c        **** 		theIndex,
3300:WTPA.c        **** 		theOctave;
3301:WTPA.c        **** 
3302:WTPA.c        **** 	theOctave=(theNote/12);	// Which octave?
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
3304:WTPA.c        **** 
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
3306:WTPA.c        **** 
3307:WTPA.c        **** }
3308:WTPA.c        **** 
3309:WTPA.c        **** //--------------------------------------
3310:WTPA.c        **** //--------------------------------------
3311:WTPA.c        **** // General Interface Functions
3312:WTPA.c        **** //--------------------------------------
3313:WTPA.c        **** //--------------------------------------
3314:WTPA.c        **** 
3315:WTPA.c        **** //==============================================
3316:WTPA.c        **** // Display update stuff, housekeeping:
3317:WTPA.c        **** 
3318:WTPA.c        **** static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
3319:WTPA.c        **** // We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for t
3320:WTPA.c        **** {
3321:WTPA.c        **** 	if(theBank==BANK_0)
3322:WTPA.c        **** 	{
3323:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
3324:WTPA.c        **** 	}
3325:WTPA.c        **** 	else if(theBank==BANK_1)
3326:WTPA.c        **** 	{
3327:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
3328:WTPA.c        **** 	}
3329:WTPA.c        **** }
3330:WTPA.c        **** 
3331:WTPA.c        **** static unsigned char GetMidiRecordNote(unsigned char theBank)
3332:WTPA.c        **** // Get the note we stored in EEPROM.
3333:WTPA.c        **** {
3334:WTPA.c        **** 	unsigned char
3335:WTPA.c        **** 		x;
3336:WTPA.c        **** 
3337:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3338:WTPA.c        **** 
3339:WTPA.c        **** 	if(theBank==BANK_0)
3340:WTPA.c        **** 	{
3341:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
3342:WTPA.c        **** 	}
3343:WTPA.c        **** 	else if(theBank==BANK_1)
3344:WTPA.c        **** 	{
3345:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
3346:WTPA.c        **** 	}
3347:WTPA.c        **** 
3348:WTPA.c        **** 	if(x<90)					// Legit number?
3349:WTPA.c        **** 	{
3350:WTPA.c        **** 		return(x);
3351:WTPA.c        **** 	}
3352:WTPA.c        **** 	else
3353:WTPA.c        **** 	{
3354:WTPA.c        **** 		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or 
3355:WTPA.c        **** 		return(x);
3356:WTPA.c        **** 	}
3357:WTPA.c        **** }
3358:WTPA.c        **** 
3359:WTPA.c        **** 
3360:WTPA.c        **** static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
3361:WTPA.c        **** // We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This
3362:WTPA.c        **** {
3363:WTPA.c        **** 	if(theBank==BANK_0)
3364:WTPA.c        **** 	{
3365:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
3366:WTPA.c        **** 	}
3367:WTPA.c        **** 	else if(theBank==BANK_1)
3368:WTPA.c        **** 	{
3369:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
3370:WTPA.c        **** 	}
3371:WTPA.c        **** }
3372:WTPA.c        **** 
3373:WTPA.c        **** 
3374:WTPA.c        **** static unsigned char GetMidiChannel(unsigned char theBank)
3375:WTPA.c        **** // Get the midi channel we stored in EEPROM.
3376:WTPA.c        **** {
3377:WTPA.c        **** 	unsigned char
3378:WTPA.c        **** 		x;
3379:WTPA.c        **** 
3380:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3381:WTPA.c        **** 
3382:WTPA.c        **** 	if(theBank==BANK_0)
3383:WTPA.c        **** 	{
3384:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
3385:WTPA.c        **** 	}
3386:WTPA.c        **** 	else if(theBank==BANK_1)
3387:WTPA.c        **** 	{
3388:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
3389:WTPA.c        **** 	}
3390:WTPA.c        **** 
3391:WTPA.c        **** 	if(x<16)					// Legit number?
3392:WTPA.c        **** 	{
3393:WTPA.c        **** 		return(x);
3394:WTPA.c        **** 	}
3395:WTPA.c        **** 	else
3396:WTPA.c        **** 	{
3397:WTPA.c        **** 		if(theBank==BANK_0)
3398:WTPA.c        **** 		{
3399:WTPA.c        **** 			x=0;			// If we've got poo poo in EEPROM or a bad address then default to the first midi channel
3400:WTPA.c        **** 		}
3401:WTPA.c        **** 		else
3402:WTPA.c        **** 		{
3403:WTPA.c        **** 			x=1;			// Return midi channel 2 if we're screwing up the second bank.
3404:WTPA.c        **** 		}
3405:WTPA.c        **** 		return(x);
3406:WTPA.c        **** 	}
3407:WTPA.c        **** }
3408:WTPA.c        **** 
3409:WTPA.c        **** static void BankStatesToLeds(unsigned char theBank)
3410:WTPA.c        **** // Looks at the current bank and decides how to set the LEDs.
3411:WTPA.c        **** {
3412:WTPA.c        **** 	unsigned char
3413:WTPA.c        **** 		temp;
3414:WTPA.c        **** 
3415:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
3416:WTPA.c        **** 
3417:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
3418:WTPA.c        **** 	{
3419:WTPA.c        **** 		temp|=Om_LED_REC;
3420:WTPA.c        **** 	}
3421:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
3422:WTPA.c        **** 	{
3423:WTPA.c        **** 		temp|=Om_LED_PLAY;
3424:WTPA.c        **** 	}
3425:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
3426:WTPA.c        **** 	{
3427:WTPA.c        **** 		temp|=Om_LED_ODUB;
3428:WTPA.c        **** 	}
3429:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
3430:WTPA.c        **** 	{
3431:WTPA.c        **** 		temp|=Om_LED_REC;
3432:WTPA.c        **** 		temp|=Om_LED_PLAY;
3433:WTPA.c        **** 		temp|=Om_LED_ODUB;
3434:WTPA.c        **** 	}
3435:WTPA.c        **** 
3436:WTPA.c        **** 	if(outOfRam==true)
3437:WTPA.c        **** 	{
3438:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
3439:WTPA.c        **** 	}
3440:WTPA.c        **** 	if(theBank==BANK_1)
3441:WTPA.c        **** 	{
3442:WTPA.c        **** 		temp|=Om_LED_BANK;
3443:WTPA.c        **** 	}
3444:WTPA.c        **** 
3445:WTPA.c        **** 	ledOnOffMask=temp;
3446:WTPA.c        **** 
3447:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
3448:WTPA.c        **** 	{
3449:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
3450:WTPA.c        **** 		{
3451:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
3452:WTPA.c        **** 		}
3453:WTPA.c        **** 	}
3454:WTPA.c        **** 	else
3455:WTPA.c        **** 	{
3456:WTPA.c        **** 		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we 
3457:WTPA.c        **** 	}
3458:WTPA.c        **** }
3459:WTPA.c        **** 
3460:WTPA.c        **** static void EncoderReadingToLeds(void)
3461:WTPA.c        **** // Take the value on our analog input, scale it, and display it on the LEDs.
3462:WTPA.c        **** // @@@ Note, this is a badly named function since it both generates the scaled global pot value AND
3463:WTPA.c        **** {
3464:WTPA.c        **** 	unsigned char
3465:WTPA.c        **** 		temp;
3466:WTPA.c        **** 
3467:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
3468:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
3469:WTPA.c        **** 
3470:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
3471:WTPA.c        **** 	{
3472:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
3473:WTPA.c        **** 	}
3474:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
3475:WTPA.c        **** 	{
3476:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
3477:WTPA.c        **** 	}
3478:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
3479:WTPA.c        **** 	{
3480:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
3481:WTPA.c        **** 	}
3482:WTPA.c        **** 
3483:WTPA.c        **** 	ledOnOffMask=temp;		// Update the leds.
3484:WTPA.c        **** }
3485:WTPA.c        **** 
3486:WTPA.c        **** static void CleanupAudioSources(void)
3487:WTPA.c        **** // Look through all the banks, and if none are using a given interrupt source, disable that interru
3488:WTPA.c        **** // Also voids the contributions those interrupts have to the audio output.
3489:WTPA.c        **** {
3490:WTPA.c        **** 	// If we aren't streaming from the SD, void contribution to the DAC
3491:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
3492:WTPA.c        **** 	{
3493:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
3494:WTPA.c        **** 	}
3495:WTPA.c        **** 
3496:WTPA.c        **** 	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
3497:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
3498:WTPA.c        **** 	{
3499:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
3500:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
3501:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
3502:WTPA.c        **** 	}
3503:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
3504:WTPA.c        **** 	{
3505:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
3506:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
3507:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
3508:WTPA.c        **** 	}
3509:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
3510:WTPA.c        **** 	{
3511:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
3512:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
3513:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
3514:WTPA.c        **** 	}
3515:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
3516:WTPA.c        **** 	{
3517:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
3518:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
3519:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
3520:WTPA.c        **** 	}
3521:WTPA.c        **** 
3522:WTPA.c        **** 	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop
3523:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
3524:WTPA.c        **** 	{
3525:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
3526:WTPA.c        **** 		{
3527:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
3528:WTPA.c        **** 		}
3529:WTPA.c        **** 	}
3530:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
3531:WTPA.c        **** 	{
3532:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
3533:WTPA.c        **** 		{
3534:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
3535:WTPA.c        **** 		}
3536:WTPA.c        **** 	}
3537:WTPA.c        **** }
3538:WTPA.c        **** 
3539:WTPA.c        **** //--------------------------------------
3540:WTPA.c        **** //--------------------------------------
3541:WTPA.c        **** // Granularizing Functions:
3542:WTPA.c        **** //--------------------------------------
3543:WTPA.c        **** //--------------------------------------
3544:WTPA.c        **** 
3545:WTPA.c        **** static unsigned long GetRandomLongInt(void)
3546:WTPA.c        **** {
 2087               		.loc 1 3546 0
 2088               		.cfi_startproc
 2089               	/* prologue: function */
 2090               	/* frame size = 0 */
 2091               	/* stack size = 0 */
 2092               	.L__stack_usage = 0
3547:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
 2093               		.loc 1 3547 0
 2094 1116 4091 0000 		lds r20,random31
 2095 111a 5091 0000 		lds r21,random31+1
 2096 111e 6091 0000 		lds r22,random31+2
 2097 1122 7091 0000 		lds r23,random31+3
3548:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
 2098               		.loc 1 3548 0
 2099 1126 DB01      		movw r26,r22
 2100 1128 CA01      		movw r24,r20
 2101 112a 880F      		lsl r24
 2102 112c 991F      		rol r25
 2103 112e AA1F      		rol r26
 2104 1130 BB1F      		rol r27
 2105 1132 76FF      		sbrs r23,6
 2106 1134 00C0      		rjmp .L131
 2107               	.L129:
3549:WTPA.c        **** 	{
3550:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 2108               		.loc 1 3550 0
 2109 1136 25EB      		ldi r18,181
 2110 1138 8227      		eor r24,r18
 2111 113a 25E9      		ldi r18,149
 2112 113c 9227      		eor r25,r18
 2113 113e 2AEA      		ldi r18,170
 2114 1140 A227      		eor r26,r18
 2115 1142 20E2      		ldi r18,32
 2116 1144 B227      		eor r27,r18
 2117               	.L131:
 2118 1146 8093 0000 		sts random31,r24
 2119 114a 9093 0000 		sts random31+1,r25
 2120 114e A093 0000 		sts random31+2,r26
 2121 1152 B093 0000 		sts random31+3,r27
3551:WTPA.c        **** 	}
3552:WTPA.c        **** 	return(random31);
 2122               		.loc 1 3552 0
 2123 1156 6091 0000 		lds r22,random31
 2124 115a 7091 0000 		lds r23,random31+1
3553:WTPA.c        **** }
 2125               		.loc 1 3553 0
 2126 115e 8091 0000 		lds r24,random31+2
 2127 1162 9091 0000 		lds r25,random31+3
 2128 1166 0895      		ret
 2129               		.cfi_endproc
 2130               	.LFE60:
 2133               	MakeNewGranularArray:
 2134               	.LFB61:
3554:WTPA.c        **** 
3555:WTPA.c        **** /*
3556:WTPA.c        **** static void InitRandom(void)
3557:WTPA.c        **** // Maximal (?) LSFR implementation complements of "curtvm" on AVRFreaks.  Thanks!
3558:WTPA.c        **** // Not sure where his tap numbers came from, but we'll see how they work out.
3559:WTPA.c        **** // This LFSR is initialized here from the poo-poo (undef'd) area of RAM and checked against zero.  
3560:WTPA.c        **** {
3561:WTPA.c        **** 	if(random31==0)	 			// If init sram happens to be 0
3562:WTPA.c        **** 	{
3563:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3564:WTPA.c        **** 	}
3565:WTPA.c        **** }
3566:WTPA.c        **** */
3567:WTPA.c        **** 
3568:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
3569:WTPA.c        **** // Make a new random order of slices as big as the user wants, up to MAX_SLICES.
3570:WTPA.c        **** // We will first fill an array with incrementing numbers up to the number of slices we care about, 
3571:WTPA.c        **** // Leave this function having updated the number of slices our sample will be divided into and the 
3572:WTPA.c        **** // Further, point to the first random slice in the randomized array, and point the sample address t
3573:WTPA.c        **** {
 2135               		.loc 1 3573 0
 2136               		.cfi_startproc
 2137               	.LVL58:
 2138 1168 2F92      		push r2
 2139               	.LCFI2:
 2140               		.cfi_def_cfa_offset 3
 2141               		.cfi_offset 2, -2
 2142 116a 3F92      		push r3
 2143               	.LCFI3:
 2144               		.cfi_def_cfa_offset 4
 2145               		.cfi_offset 3, -3
 2146 116c 4F92      		push r4
 2147               	.LCFI4:
 2148               		.cfi_def_cfa_offset 5
 2149               		.cfi_offset 4, -4
 2150 116e 5F92      		push r5
 2151               	.LCFI5:
 2152               		.cfi_def_cfa_offset 6
 2153               		.cfi_offset 5, -5
 2154 1170 6F92      		push r6
 2155               	.LCFI6:
 2156               		.cfi_def_cfa_offset 7
 2157               		.cfi_offset 6, -6
 2158 1172 7F92      		push r7
 2159               	.LCFI7:
 2160               		.cfi_def_cfa_offset 8
 2161               		.cfi_offset 7, -7
 2162 1174 8F92      		push r8
 2163               	.LCFI8:
 2164               		.cfi_def_cfa_offset 9
 2165               		.cfi_offset 8, -8
 2166 1176 9F92      		push r9
 2167               	.LCFI9:
 2168               		.cfi_def_cfa_offset 10
 2169               		.cfi_offset 9, -9
 2170 1178 AF92      		push r10
 2171               	.LCFI10:
 2172               		.cfi_def_cfa_offset 11
 2173               		.cfi_offset 10, -10
 2174 117a BF92      		push r11
 2175               	.LCFI11:
 2176               		.cfi_def_cfa_offset 12
 2177               		.cfi_offset 11, -11
 2178 117c CF92      		push r12
 2179               	.LCFI12:
 2180               		.cfi_def_cfa_offset 13
 2181               		.cfi_offset 12, -12
 2182 117e DF92      		push r13
 2183               	.LCFI13:
 2184               		.cfi_def_cfa_offset 14
 2185               		.cfi_offset 13, -13
 2186 1180 EF92      		push r14
 2187               	.LCFI14:
 2188               		.cfi_def_cfa_offset 15
 2189               		.cfi_offset 14, -14
 2190 1182 FF92      		push r15
 2191               	.LCFI15:
 2192               		.cfi_def_cfa_offset 16
 2193               		.cfi_offset 15, -15
 2194 1184 0F93      		push r16
 2195               	.LCFI16:
 2196               		.cfi_def_cfa_offset 17
 2197               		.cfi_offset 16, -16
 2198 1186 1F93      		push r17
 2199               	.LCFI17:
 2200               		.cfi_def_cfa_offset 18
 2201               		.cfi_offset 17, -17
 2202 1188 CF93      		push r28
 2203               	.LCFI18:
 2204               		.cfi_def_cfa_offset 19
 2205               		.cfi_offset 28, -18
 2206 118a DF93      		push r29
 2207               	.LCFI19:
 2208               		.cfi_def_cfa_offset 20
 2209               		.cfi_offset 29, -19
 2210               	/* prologue: function */
 2211               	/* frame size = 0 */
 2212               	/* stack size = 18 */
 2213               	.L__stack_usage = 18
 2214 118c 382E      		mov r3,r24
3574:WTPA.c        **** 	unsigned char
3575:WTPA.c        **** 		sreg,
3576:WTPA.c        **** 		i,
3577:WTPA.c        **** 		origContents,
3578:WTPA.c        **** 		randIndex,
3579:WTPA.c        **** 		randContents;
3580:WTPA.c        **** 
3581:WTPA.c        **** 	if(numSlices>1)		// Enough slices to do something?
 2215               		.loc 1 3581 0
 2216 118e 6230      		cpi r22,lo8(2)
 2217 1190 00F4      		brsh .+2
 2218 1192 00C0      		rjmp .L133
3582:WTPA.c        **** 	{
3583:WTPA.c        **** 		sreg=SREG;
 2219               		.loc 1 3583 0
 2220 1194 9FB6      		in r9,__SREG__
 2221               	.LVL59:
3584:WTPA.c        **** 		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
 2222               		.loc 1 3584 0
 2223               	/* #APP */
 2224               	 ;  3584 "WTPA.c" 1
 2225 1196 F894      		cli
 2226               	 ;  0 "" 2
 2227               	/* #NOAPP */
 2228 1198 862E      		mov r8,r22
 2229 119a 80E8      		ldi r24,lo8(-128)
 2230               	.LVL60:
 2231 119c 8617      		cp r24,r22
 2232 119e 00F4      		brsh .L134
 2233 11a0 00E8      		ldi r16,lo8(-128)
 2234 11a2 802E      		mov r8,r16
 2235               	.L134:
 2236               	.LVL61:
3568:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2237               		.loc 1 3568 0
 2238 11a4 C32D      		mov r28,r3
 2239 11a6 D0E0      		ldi r29,0
 2240 11a8 9E01      		movw r18,r28
 2241 11aa 3695      		lsr r19
 2242 11ac 322F      		mov r19,r18
 2243 11ae 2227      		clr r18
 2244 11b0 3795      		ror r19
 2245 11b2 2795      		ror r18
 2246 11b4 2050      		subi r18,lo8(-(granularPositionArray))
 2247 11b6 3040      		sbci r19,hi8(-(granularPositionArray))
 2248 11b8 80E0      		ldi r24,0
 2249 11ba 90E0      		ldi r25,0
 2250               	.LVL62:
 2251               	.L135:
3568:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2252               		.loc 1 3568 0 is_stmt 0 discriminator 2
 2253 11bc F901      		movw r30,r18
 2254 11be E80F      		add r30,r24
 2255 11c0 F91F      		adc r31,r25
3585:WTPA.c        **** 
3586:WTPA.c        **** 		if(numSlices>MAX_SLICES)
3587:WTPA.c        **** 		{
3588:WTPA.c        **** 			numSlices=MAX_SLICES;
3589:WTPA.c        **** 		}
3590:WTPA.c        **** 
3591:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
3592:WTPA.c        **** 		{
3593:WTPA.c        **** 			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwa
 2256               		.loc 1 3593 0 is_stmt 1 discriminator 2
 2257 11c2 8083      		st Z,r24
 2258               	.LVL63:
 2259 11c4 0196      		adiw r24,1
 2260               	.LVL64:
3591:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2261               		.loc 1 3591 0 discriminator 2
 2262 11c6 8815      		cp r24,r8
 2263 11c8 00F0      		brlo .L135
3568:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2264               		.loc 1 3568 0
 2265 11ca 6E01      		movw r12,r28
 2266 11cc D694      		lsr r13
 2267 11ce DC2C      		mov r13,r12
 2268 11d0 CC24      		clr r12
 2269 11d2 D794      		ror r13
 2270 11d4 C794      		ror r12
 2271 11d6 B0E0      		ldi r27,lo8(granularPositionArray)
 2272 11d8 AB2E      		mov r10,r27
 2273 11da B0E0      		ldi r27,hi8(granularPositionArray)
 2274 11dc BB2E      		mov r11,r27
 2275 11de AC0C      		add r10,r12
 2276 11e0 BD1C      		adc r11,r13
 2277 11e2 00E0      		ldi r16,0
 2278 11e4 10E0      		ldi r17,0
3594:WTPA.c        **** 		}
3595:WTPA.c        **** 
3596:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
3597:WTPA.c        **** 		{
3598:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
3599:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
 2279               		.loc 1 3599 0
 2280 11e6 482C      		mov r4,r8
 2281 11e8 512C      		mov r5,__zero_reg__
 2282 11ea 612C      		mov r6,__zero_reg__
 2283 11ec 712C      		mov r7,__zero_reg__
 2284               	.LVL65:
 2285               	.L136:
3568:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2286               		.loc 1 3568 0 discriminator 2
 2287 11ee 7501      		movw r14,r10
 2288 11f0 E00E      		add r14,r16
 2289 11f2 F11E      		adc r15,r17
3598:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
 2290               		.loc 1 3598 0 discriminator 2
 2291 11f4 D701      		movw r26,r14
 2292 11f6 2C90      		ld r2,X
 2293               	.LVL66:
 2294               		.loc 1 3599 0 discriminator 2
 2295 11f8 0E94 0000 		call GetRandomLongInt
 2296               	.LVL67:
 2297 11fc A301      		movw r20,r6
 2298 11fe 9201      		movw r18,r4
 2299 1200 0E94 0000 		call __udivmodsi4
 2300               	.LVL68:
3600:WTPA.c        **** 			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery ad
 2301               		.loc 1 3600 0 discriminator 2
 2302 1204 FB01      		movw r30,r22
 2303 1206 EC0D      		add r30,r12
 2304 1208 FD1D      		adc r31,r13
 2305 120a E050      		subi r30,lo8(-(granularPositionArray))
 2306 120c F040      		sbci r31,hi8(-(granularPositionArray))
 2307 120e 8081      		ld r24,Z
 2308               	.LVL69:
3601:WTPA.c        **** 			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the
 2309               		.loc 1 3601 0 discriminator 2
 2310 1210 D701      		movw r26,r14
 2311 1212 8C93      		st X,r24
3602:WTPA.c        **** 			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original reg
 2312               		.loc 1 3602 0 discriminator 2
 2313 1214 2082      		st Z,r2
 2314 1216 0F5F      		subi r16,-1
 2315 1218 1F4F      		sbci r17,-1
3596:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
 2316               		.loc 1 3596 0 discriminator 2
 2317 121a 0815      		cp r16,r8
 2318 121c 00F0      		brlo .L136
3603:WTPA.c        **** 		}
3604:WTPA.c        **** 
3605:WTPA.c        **** 		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
 2319               		.loc 1 3605 0
 2320 121e 3110      		cpse r3,__zero_reg__
 2321 1220 00C0      		rjmp .L137
3606:WTPA.c        **** 		{
3607:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
 2322               		.loc 1 3607 0
 2323 1222 6091 0000 		lds r22,bankStates+12
 2324 1226 7091 0000 		lds r23,bankStates+12+1
 2325 122a 8091 0000 		lds r24,bankStates+12+2
 2326 122e 9091 0000 		lds r25,bankStates+12+3
 2327 1232 A301      		movw r20,r6
 2328 1234 9201      		movw r18,r4
 2329 1236 0E94 0000 		call __udivmodsi4
 2330 123a 2093 0000 		sts sliceSize,r18
 2331 123e 3093 0000 		sts sliceSize+1,r19
 2332 1242 4093 0000 		sts sliceSize+2,r20
 2333 1246 5093 0000 		sts sliceSize+3,r21
 2334 124a 00C0      		rjmp .L138
 2335               	.L137:
3608:WTPA.c        **** 		}
3609:WTPA.c        **** 		else					// Otherwise assume banks grow down.
3610:WTPA.c        **** 		{
3611:WTPA.c        **** 			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
 2336               		.loc 1 3611 0
 2337 124c 0091 0000 		lds r16,bankStates+47
 2338 1250 1091 0000 		lds r17,bankStates+47+1
 2339 1254 2091 0000 		lds r18,bankStates+47+2
 2340 1258 3091 0000 		lds r19,bankStates+47+3
 2341 125c 6FEF      		ldi r22,lo8(-1)
 2342 125e 7FEF      		ldi r23,lo8(-1)
 2343 1260 87E0      		ldi r24,lo8(7)
 2344 1262 90E0      		ldi r25,0
 2345 1264 601B      		sub r22,r16
 2346 1266 710B      		sbc r23,r17
 2347 1268 820B      		sbc r24,r18
 2348 126a 930B      		sbc r25,r19
 2349 126c A301      		movw r20,r6
 2350 126e 9201      		movw r18,r4
 2351 1270 0E94 0000 		call __udivmodsi4
 2352 1274 2093 0000 		sts sliceSize+4,r18
 2353 1278 3093 0000 		sts sliceSize+4+1,r19
 2354 127c 4093 0000 		sts sliceSize+4+2,r20
 2355 1280 5093 0000 		sts sliceSize+4+3,r21
 2356               	.L138:
3612:WTPA.c        **** 		}
3613:WTPA.c        **** 
3614:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
 2357               		.loc 1 3614 0
 2358 1284 83E2      		ldi r24,lo8(35)
 2359               	.LVL70:
 2360 1286 8C9F      		mul r24,r28
 2361 1288 F001      		movw r30,r0
 2362 128a 8D9F      		mul r24,r29
 2363 128c F00D      		add r31,r0
 2364 128e 1124      		clr __zero_reg__
 2365 1290 E050      		subi r30,lo8(-(bankStates))
 2366 1292 F040      		sbci r31,hi8(-(bankStates))
 2367 1294 8682      		std Z+6,r8
3615:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
 2368               		.loc 1 3615 0
 2369 1296 FE01      		movw r30,r28
 2370 1298 E050      		subi r30,lo8(-(granularPositionArrayPointer))
 2371 129a F040      		sbci r31,hi8(-(granularPositionArrayPointer))
 2372 129c 1082      		st Z,__zero_reg__
3616:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
 2373               		.loc 1 3616 0
 2374 129e CC0F      		lsl r28
 2375 12a0 DD1F      		rol r29
 2376 12a2 CC0F      		lsl r28
 2377 12a4 DD1F      		rol r29
 2378 12a6 FE01      		movw r30,r28
 2379 12a8 E050      		subi r30,lo8(-(sliceSize))
 2380 12aa F040      		sbci r31,hi8(-(sliceSize))
 2381 12ac 8081      		ld r24,Z
 2382 12ae 9181      		ldd r25,Z+1
 2383 12b0 A281      		ldd r26,Z+2
 2384 12b2 B381      		ldd r27,Z+3
 2385 12b4 C050      		subi r28,lo8(-(sliceRemaining))
 2386 12b6 D040      		sbci r29,hi8(-(sliceRemaining))
 2387 12b8 8883      		st Y,r24
 2388 12ba 9983      		std Y+1,r25
 2389 12bc AA83      		std Y+2,r26
 2390 12be BB83      		std Y+3,r27
3617:WTPA.c        **** 
3618:WTPA.c        **** 		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the fir
 2391               		.loc 1 3618 0
 2392 12c0 3110      		cpse r3,__zero_reg__
 2393 12c2 00C0      		rjmp .L139
3619:WTPA.c        **** 		{
3620:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
 2394               		.loc 1 3620 0
 2395 12c4 2091 0000 		lds r18,sliceSize
 2396 12c8 3091 0000 		lds r19,sliceSize+1
 2397 12cc 4091 0000 		lds r20,sliceSize+2
 2398 12d0 5091 0000 		lds r21,sliceSize+3
 2399 12d4 A091 0000 		lds r26,granularPositionArray
 2400 12d8 B0E0      		ldi r27,0
 2401 12da 0E94 0000 		call __muluhisi3
 2402 12de 6093 0000 		sts bankStates+31,r22
 2403 12e2 7093 0000 		sts bankStates+31+1,r23
 2404 12e6 8093 0000 		sts bankStates+31+2,r24
 2405 12ea 9093 0000 		sts bankStates+31+3,r25
 2406 12ee 00C0      		rjmp .L140
 2407               	.L139:
3621:WTPA.c        **** 		}
3622:WTPA.c        **** 		else
3623:WTPA.c        **** 		{
3624:WTPA.c        **** 			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceS
 2408               		.loc 1 3624 0
 2409 12f0 2091 0000 		lds r18,sliceSize+4
 2410 12f4 3091 0000 		lds r19,sliceSize+4+1
 2411 12f8 4091 0000 		lds r20,sliceSize+4+2
 2412 12fc 5091 0000 		lds r21,sliceSize+4+3
 2413 1300 A091 0000 		lds r26,granularPositionArray+128
 2414 1304 B0E0      		ldi r27,0
 2415 1306 0E94 0000 		call __muluhisi3
 2416 130a 0FEF      		ldi r16,lo8(-1)
 2417 130c 1FEF      		ldi r17,lo8(-1)
 2418 130e 27E0      		ldi r18,lo8(7)
 2419 1310 30E0      		ldi r19,0
 2420 1312 061B      		sub r16,r22
 2421 1314 170B      		sbc r17,r23
 2422 1316 280B      		sbc r18,r24
 2423 1318 390B      		sbc r19,r25
 2424 131a 0093 0000 		sts bankStates+66,r16
 2425 131e 1093 0000 		sts bankStates+66+1,r17
 2426 1322 2093 0000 		sts bankStates+66+2,r18
 2427 1326 3093 0000 		sts bankStates+66+3,r19
 2428               	.L140:
3625:WTPA.c        **** 		}
3626:WTPA.c        **** 
3627:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 2429               		.loc 1 3627 0
 2430 132a 9FBE      		out __SREG__,r9
 2431 132c 00C0      		rjmp .L132
 2432               	.LVL71:
 2433               	.L133:
3628:WTPA.c        **** 	}
3629:WTPA.c        **** 	else
3630:WTPA.c        **** 	{
3631:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
 2434               		.loc 1 3631 0
 2435 132e B3E2      		ldi r27,lo8(35)
 2436 1330 8B9F      		mul r24,r27
 2437 1332 F001      		movw r30,r0
 2438 1334 1124      		clr __zero_reg__
 2439 1336 E050      		subi r30,lo8(-(bankStates))
 2440 1338 F040      		sbci r31,hi8(-(bankStates))
 2441 133a 1682      		std Z+6,__zero_reg__
 2442               	.LVL72:
 2443               	.L132:
 2444               	/* epilogue start */
3632:WTPA.c        **** 	}
3633:WTPA.c        **** }
 2445               		.loc 1 3633 0
 2446 133c DF91      		pop r29
 2447 133e CF91      		pop r28
 2448 1340 1F91      		pop r17
 2449 1342 0F91      		pop r16
 2450 1344 FF90      		pop r15
 2451 1346 EF90      		pop r14
 2452 1348 DF90      		pop r13
 2453 134a CF90      		pop r12
 2454 134c BF90      		pop r11
 2455 134e AF90      		pop r10
 2456 1350 9F90      		pop r9
 2457 1352 8F90      		pop r8
 2458 1354 7F90      		pop r7
 2459 1356 6F90      		pop r6
 2460 1358 5F90      		pop r5
 2461 135a 4F90      		pop r4
 2462 135c 3F90      		pop r3
 2463               	.LVL73:
 2464 135e 2F90      		pop r2
 2465 1360 0895      		ret
 2466               		.cfi_endproc
 2467               	.LFE61:
 2470               	UpdateAdjustedSampleAddresses:
 2471               	.LFB62:
3634:WTPA.c        **** 
3635:WTPA.c        **** //--------------------------------------
3636:WTPA.c        **** //--------------------------------------
3637:WTPA.c        **** // Shuttle / Loop Size Adjust Functions:
3638:WTPA.c        **** //--------------------------------------
3639:WTPA.c        **** //--------------------------------------
3640:WTPA.c        **** // These functions are called to bump the beginning of a sample forward or backward by an amount di
3641:WTPA.c        **** // The resolution of these functions is dependent on the absolute number of individual samples curr
3642:WTPA.c        **** // 	we divide the entire sample by 256 to find our "chunk size" and then shuttle the sample start /
3643:WTPA.c        **** // NOTE:  It is possible with these commands to position the sample's working boundaries such that 
3644:WTPA.c        **** // NOTE:  It is possible to move a sample's adjusted end come BEFORE its adjusted beginning.  We mu
3645:WTPA.c        **** // NOTE:  It is possible to have the sample roll around the end address.  Account for this.
3646:WTPA.c        **** 
3647:WTPA.c        **** // We will need to update the ISR so that playback rolls through the end address.
3648:WTPA.c        **** // Mon Nov  9 22:32:16 EST 2009 -- Think I got it.
3649:WTPA.c        **** 
3650:WTPA.c        **** // Thu Mar 25 21:44:28 EDT 2010
3651:WTPA.c        **** // Window problems.  When the window wraps around the absolute address of the sample, bad shit goes
3652:WTPA.c        **** // Fri Mar 26 14:46:06 EDT 2010
3653:WTPA.c        **** // Fixed.  I made some dumb changes to the ISR address wrapping and also didn't accout for the fact
3654:WTPA.c        **** 
3655:WTPA.c        **** // Fri Mar 26 18:55:07 EDT 2010
3656:WTPA.c        **** // Changed the way the whole sampler thinks about "direction" in playback.  The user sets the backw
3657:WTPA.c        **** // The variable read by the interrupt is "sampleDirection" which actually tells us which way to go 
3658:WTPA.c        **** // This system lets us arbitrarily set the way we want the sample to go, and then reverse it when t
3659:WTPA.c        **** 
3660:WTPA.c        **** static void UpdateAdjustedSampleAddresses(unsigned char theBank)
3661:WTPA.c        **** // Using window, start, and stop info, this routine sets the beginning and end point within a sampl
3662:WTPA.c        **** // We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of th
3663:WTPA.c        **** // Wed Jun 22 13:50:04 EDT 2011
3664:WTPA.c        **** // Now that we use an encoder we could adjust this more finely if we wanted to.
3665:WTPA.c        **** {
 2472               		.loc 1 3665 0
 2473               		.cfi_startproc
 2474               	.LVL74:
 2475 1362 4F92      		push r4
 2476               	.LCFI20:
 2477               		.cfi_def_cfa_offset 3
 2478               		.cfi_offset 4, -2
 2479 1364 5F92      		push r5
 2480               	.LCFI21:
 2481               		.cfi_def_cfa_offset 4
 2482               		.cfi_offset 5, -3
 2483 1366 6F92      		push r6
 2484               	.LCFI22:
 2485               		.cfi_def_cfa_offset 5
 2486               		.cfi_offset 6, -4
 2487 1368 7F92      		push r7
 2488               	.LCFI23:
 2489               		.cfi_def_cfa_offset 6
 2490               		.cfi_offset 7, -5
 2491 136a 8F92      		push r8
 2492               	.LCFI24:
 2493               		.cfi_def_cfa_offset 7
 2494               		.cfi_offset 8, -6
 2495 136c 9F92      		push r9
 2496               	.LCFI25:
 2497               		.cfi_def_cfa_offset 8
 2498               		.cfi_offset 9, -7
 2499 136e AF92      		push r10
 2500               	.LCFI26:
 2501               		.cfi_def_cfa_offset 9
 2502               		.cfi_offset 10, -8
 2503 1370 BF92      		push r11
 2504               	.LCFI27:
 2505               		.cfi_def_cfa_offset 10
 2506               		.cfi_offset 11, -9
 2507 1372 CF92      		push r12
 2508               	.LCFI28:
 2509               		.cfi_def_cfa_offset 11
 2510               		.cfi_offset 12, -10
 2511 1374 DF92      		push r13
 2512               	.LCFI29:
 2513               		.cfi_def_cfa_offset 12
 2514               		.cfi_offset 13, -11
 2515 1376 EF92      		push r14
 2516               	.LCFI30:
 2517               		.cfi_def_cfa_offset 13
 2518               		.cfi_offset 14, -12
 2519 1378 FF92      		push r15
 2520               	.LCFI31:
 2521               		.cfi_def_cfa_offset 14
 2522               		.cfi_offset 15, -13
 2523               	/* prologue: function */
 2524               	/* frame size = 0 */
 2525               	/* stack size = 12 */
 2526               	.L__stack_usage = 12
3666:WTPA.c        **** 	unsigned char
3667:WTPA.c        **** 		sreg;
3668:WTPA.c        **** 	unsigned long
3669:WTPA.c        **** 		chunkSize;
3670:WTPA.c        **** 
3671:WTPA.c        **** 	sreg=SREG;
 2527               		.loc 1 3671 0
 2528 137a EFB7      		in r30,__SREG__
 2529               	.LVL75:
3672:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 2530               		.loc 1 3672 0
 2531               	/* #APP */
 2532               	 ;  3672 "WTPA.c" 1
 2533 137c F894      		cli
 2534               	 ;  0 "" 2
3673:WTPA.c        **** 
3674:WTPA.c        **** 	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
 2535               		.loc 1 3674 0
 2536               	/* #NOAPP */
 2537 137e 8111      		cpse r24,__zero_reg__
 2538 1380 00C0      		rjmp .L145
3675:WTPA.c        **** 	{
3676:WTPA.c        **** 		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of
 2539               		.loc 1 3676 0
 2540 1382 8090 0000 		lds r8,bankStates+12
 2541 1386 9090 0000 		lds r9,bankStates+12+1
 2542 138a A090 0000 		lds r10,bankStates+12+2
 2543 138e B090 0000 		lds r11,bankStates+12+3
 2544 1392 83E0      		ldi r24,3
 2545               		1:
 2546 1394 880C      		lsl r8
 2547 1396 991C      		rol r9
 2548 1398 AA1C      		rol r10
 2549 139a BB1C      		rol r11
 2550 139c 8A95      		dec r24
 2551 139e 01F4      		brne 1b
 2552               	.LVL76:
 2553 13a0 892C      		mov r8,r9
 2554 13a2 9A2C      		mov r9,r10
 2555 13a4 AB2C      		mov r10,r11
 2556 13a6 BB24      		clr r11
 2557               	.LVL77:
3677:WTPA.c        **** 
3678:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3679:WTPA.c        **** 
3680:WTPA.c        **** 		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sam
 2558               		.loc 1 3680 0
 2559 13a8 A091 0000 		lds r26,bankStates+28
 2560 13ac 8091 0000 		lds r24,bankStates+30
 2561 13b0 B0E0      		ldi r27,0
 2562 13b2 A80F      		add r26,r24
 2563 13b4 B11D      		adc r27,__zero_reg__
 2564 13b6 A501      		movw r20,r10
 2565 13b8 9401      		movw r18,r8
 2566 13ba 0E94 0000 		call __muluhisi3
 2567 13be F3E0      		ldi r31,3
 2568               		1:
 2569 13c0 9695      		lsr r25
 2570 13c2 8795      		ror r24
 2571 13c4 7795      		ror r23
 2572 13c6 6795      		ror r22
 2573 13c8 FA95      		dec r31
 2574 13ca 01F4      		brne 1b
 2575 13cc 6093 0000 		sts bankStates+24,r22
 2576 13d0 7093 0000 		sts bankStates+24+1,r23
 2577 13d4 8093 0000 		sts bankStates+24+2,r24
 2578 13d8 9093 0000 		sts bankStates+24+3,r25
3681:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_
 2579               		.loc 1 3681 0
 2580 13dc 4090 0000 		lds r4,bankStates+12
 2581 13e0 5090 0000 		lds r5,bankStates+12+1
 2582 13e4 6090 0000 		lds r6,bankStates+12+2
 2583 13e8 7090 0000 		lds r7,bankStates+12+3
 2584 13ec F091 0000 		lds r31,bankStates+29
 2585 13f0 A091 0000 		lds r26,bankStates+30
 2586 13f4 B0E0      		ldi r27,0
 2587 13f6 0E94 0000 		call __muluhisi3
 2588 13fa 6B01      		movw r12,r22
 2589 13fc 7C01      		movw r14,r24
 2590 13fe A3E0      		ldi r26,3
 2591               		1:
 2592 1400 F694      		lsr r15
 2593 1402 E794      		ror r14
 2594 1404 D794      		ror r13
 2595 1406 C794      		ror r12
 2596 1408 AA95      		dec r26
 2597 140a 01F4      		brne 1b
 2598 140c C40C      		add r12,r4
 2599 140e D51C      		adc r13,r5
 2600 1410 E61C      		adc r14,r6
 2601 1412 F71C      		adc r15,r7
 2602 1414 AF2F      		mov r26,r31
 2603 1416 B0E0      		ldi r27,0
 2604 1418 0E94 0000 		call __muluhisi3
 2605 141c B3E0      		ldi r27,3
 2606               		1:
 2607 141e 9695      		lsr r25
 2608 1420 8795      		ror r24
 2609 1422 7795      		ror r23
 2610 1424 6795      		ror r22
 2611 1426 BA95      		dec r27
 2612 1428 01F4      		brne 1b
 2613 142a C61A      		sub r12,r22
 2614 142c D70A      		sbc r13,r23
 2615 142e E80A      		sbc r14,r24
 2616 1430 F90A      		sbc r15,r25
 2617 1432 C092 0000 		sts bankStates+20,r12
 2618 1436 D092 0000 		sts bankStates+20+1,r13
 2619 143a E092 0000 		sts bankStates+20+2,r14
 2620 143e F092 0000 		sts bankStates+20+3,r15
3682:WTPA.c        **** 
3683:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3684:WTPA.c        **** 
3685:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse play
 2621               		.loc 1 3685 0
 2622 1442 4091 0000 		lds r20,bankStates+24
 2623 1446 5091 0000 		lds r21,bankStates+24+1
 2624 144a 6091 0000 		lds r22,bankStates+24+2
 2625 144e 7091 0000 		lds r23,bankStates+24+3
 2626 1452 8091 0000 		lds r24,bankStates+20
 2627 1456 9091 0000 		lds r25,bankStates+20+1
 2628 145a A091 0000 		lds r26,bankStates+20+2
 2629 145e B091 0000 		lds r27,bankStates+20+3
 2630 1462 8417      		cp r24,r20
 2631 1464 9507      		cpc r25,r21
 2632 1466 A607      		cpc r26,r22
 2633 1468 B707      		cpc r27,r23
 2634 146a 00F4      		brsh .L146
3686:WTPA.c        **** 		{
3687:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 2635               		.loc 1 3687 0
 2636 146c 8091 0000 		lds r24,bankStates+3
 2637 1470 8130      		cpi r24,lo8(1)
 2638 1472 01F4      		brne .L147
3688:WTPA.c        **** 			{
3689:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2639               		.loc 1 3689 0
 2640 1474 8093 0000 		sts bankStates+4,r24
 2641 1478 00C0      		rjmp .L148
 2642               	.L147:
3690:WTPA.c        **** 			}
3691:WTPA.c        **** 			else
3692:WTPA.c        **** 			{
3693:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2643               		.loc 1 3693 0
 2644 147a 1092 0000 		sts bankStates+4,__zero_reg__
 2645               	.L148:
3694:WTPA.c        **** 			}
3695:WTPA.c        **** 
3696:WTPA.c        **** 			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
 2646               		.loc 1 3696 0
 2647 147e 8091 0000 		lds r24,bankStates+24
 2648 1482 9091 0000 		lds r25,bankStates+24+1
 2649 1486 A091 0000 		lds r26,bankStates+24+2
 2650 148a B091 0000 		lds r27,bankStates+24+3
 2651               	.LVL78:
3697:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to st
 2652               		.loc 1 3697 0
 2653 148e 4091 0000 		lds r20,bankStates+20
 2654 1492 5091 0000 		lds r21,bankStates+20+1
 2655 1496 6091 0000 		lds r22,bankStates+20+2
 2656 149a 7091 0000 		lds r23,bankStates+20+3
 2657 149e 4093 0000 		sts bankStates+24,r20
 2658 14a2 5093 0000 		sts bankStates+24+1,r21
 2659 14a6 6093 0000 		sts bankStates+24+2,r22
 2660 14aa 7093 0000 		sts bankStates+24+3,r23
3698:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
 2661               		.loc 1 3698 0
 2662 14ae 8093 0000 		sts bankStates+20,r24
 2663 14b2 9093 0000 		sts bankStates+20+1,r25
 2664 14b6 A093 0000 		sts bankStates+20+2,r26
 2665 14ba B093 0000 		sts bankStates+20+3,r27
 2666 14be 00C0      		rjmp .L149
 2667               	.LVL79:
 2668               	.L146:
3699:WTPA.c        **** 		}
3700:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3701:WTPA.c        **** 		{
3702:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
 2669               		.loc 1 3702 0
 2670 14c0 8091 0000 		lds r24,bankStates+3
 2671 14c4 8130      		cpi r24,lo8(1)
 2672 14c6 01F4      		brne .L150
3703:WTPA.c        **** 			{
3704:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2673               		.loc 1 3704 0
 2674 14c8 1092 0000 		sts bankStates+4,__zero_reg__
 2675 14cc 00C0      		rjmp .L149
 2676               	.L150:
3705:WTPA.c        **** 			}
3706:WTPA.c        **** 			else
3707:WTPA.c        **** 			{
3708:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2677               		.loc 1 3708 0
 2678 14ce 81E0      		ldi r24,lo8(1)
 2679 14d0 8093 0000 		sts bankStates+4,r24
 2680               	.LVL80:
 2681               	.L149:
3709:WTPA.c        **** 			}
3710:WTPA.c        **** 		}
3711:WTPA.c        **** 
3712:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3713:WTPA.c        **** 
3714:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the e
 2682               		.loc 1 3714 0
 2683 14d4 4091 0000 		lds r20,bankStates+24
 2684 14d8 5091 0000 		lds r21,bankStates+24+1
 2685 14dc 6091 0000 		lds r22,bankStates+24+2
 2686 14e0 7091 0000 		lds r23,bankStates+24+3
 2687 14e4 8091 0000 		lds r24,bankStates+12
 2688 14e8 9091 0000 		lds r25,bankStates+12+1
 2689 14ec A091 0000 		lds r26,bankStates+12+2
 2690 14f0 B091 0000 		lds r27,bankStates+12+3
 2691 14f4 8417      		cp r24,r20
 2692 14f6 9507      		cpc r25,r21
 2693 14f8 A607      		cpc r26,r22
 2694 14fa B707      		cpc r27,r23
 2695 14fc 00F4      		brsh .L151
3715:WTPA.c        **** 		{
3716:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK
 2696               		.loc 1 3716 0
 2697 14fe 8091 0000 		lds r24,bankStates+24
 2698 1502 9091 0000 		lds r25,bankStates+24+1
 2699 1506 A091 0000 		lds r26,bankStates+24+2
 2700 150a B091 0000 		lds r27,bankStates+24+3
 2701 150e 4091 0000 		lds r20,bankStates+12
 2702 1512 5091 0000 		lds r21,bankStates+12+1
 2703 1516 6091 0000 		lds r22,bankStates+12+2
 2704 151a 7091 0000 		lds r23,bankStates+12+3
 2705 151e 841B      		sub r24,r20
 2706 1520 950B      		sbc r25,r21
 2707 1522 A60B      		sbc r26,r22
 2708 1524 B70B      		sbc r27,r23
 2709 1526 8093 0000 		sts bankStates+24,r24
 2710 152a 9093 0000 		sts bankStates+24+1,r25
 2711 152e A093 0000 		sts bankStates+24+2,r26
 2712 1532 B093 0000 		sts bankStates+24+3,r27
 2713               	.L151:
3717:WTPA.c        **** 		}
3718:WTPA.c        **** 		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
 2714               		.loc 1 3718 0
 2715 1536 4091 0000 		lds r20,bankStates+20
 2716 153a 5091 0000 		lds r21,bankStates+20+1
 2717 153e 6091 0000 		lds r22,bankStates+20+2
 2718 1542 7091 0000 		lds r23,bankStates+20+3
 2719 1546 8091 0000 		lds r24,bankStates+12
 2720 154a 9091 0000 		lds r25,bankStates+12+1
 2721 154e A091 0000 		lds r26,bankStates+12+2
 2722 1552 B091 0000 		lds r27,bankStates+12+3
 2723 1556 8417      		cp r24,r20
 2724 1558 9507      		cpc r25,r21
 2725 155a A607      		cpc r26,r22
 2726 155c B707      		cpc r27,r23
 2727 155e 00F0      		brlo .+2
 2728 1560 00C0      		rjmp .L153
3719:WTPA.c        **** 		{
3720:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].
 2729               		.loc 1 3720 0
 2730 1562 8091 0000 		lds r24,bankStates+20
 2731 1566 9091 0000 		lds r25,bankStates+20+1
 2732 156a A091 0000 		lds r26,bankStates+20+2
 2733 156e B091 0000 		lds r27,bankStates+20+3
 2734 1572 4091 0000 		lds r20,bankStates+12
 2735 1576 5091 0000 		lds r21,bankStates+12+1
 2736 157a 6091 0000 		lds r22,bankStates+12+2
 2737 157e 7091 0000 		lds r23,bankStates+12+3
 2738 1582 841B      		sub r24,r20
 2739 1584 950B      		sbc r25,r21
 2740 1586 A60B      		sbc r26,r22
 2741 1588 B70B      		sbc r27,r23
 2742 158a 8093 0000 		sts bankStates+20,r24
 2743 158e 9093 0000 		sts bankStates+20+1,r25
 2744 1592 A093 0000 		sts bankStates+20+2,r26
 2745 1596 B093 0000 		sts bankStates+20+3,r27
3721:WTPA.c        **** 
3722:WTPA.c        **** 			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wra
 2746               		.loc 1 3722 0
 2747 159a 4091 0000 		lds r20,bankStates+20
 2748 159e 5091 0000 		lds r21,bankStates+20+1
 2749 15a2 6091 0000 		lds r22,bankStates+20+2
 2750 15a6 7091 0000 		lds r23,bankStates+20+3
 2751 15aa 8091 0000 		lds r24,bankStates+24
 2752 15ae 9091 0000 		lds r25,bankStates+24+1
 2753 15b2 A091 0000 		lds r26,bankStates+24+2
 2754 15b6 B091 0000 		lds r27,bankStates+24+3
 2755 15ba 4817      		cp r20,r24
 2756 15bc 5907      		cpc r21,r25
 2757 15be 6A07      		cpc r22,r26
 2758 15c0 7B07      		cpc r23,r27
 2759 15c2 01F4      		brne .L153
3723:WTPA.c        **** 			{
3724:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
 2760               		.loc 1 3724 0
 2761 15c4 8091 0000 		lds r24,bankStates+20
 2762 15c8 9091 0000 		lds r25,bankStates+20+1
 2763 15cc A091 0000 		lds r26,bankStates+20+2
 2764 15d0 B091 0000 		lds r27,bankStates+20+3
 2765 15d4 0197      		sbiw r24,1
 2766 15d6 A109      		sbc r26,__zero_reg__
 2767 15d8 B109      		sbc r27,__zero_reg__
 2768 15da 8093 0000 		sts bankStates+20,r24
 2769 15de 9093 0000 		sts bankStates+20+1,r25
 2770 15e2 A093 0000 		sts bankStates+20+2,r26
 2771 15e6 B093 0000 		sts bankStates+20+3,r27
 2772               	.L153:
3725:WTPA.c        **** 			}
3726:WTPA.c        **** 		}
3727:WTPA.c        **** 
3728:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3729:WTPA.c        **** 
3730:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapp
 2773               		.loc 1 3730 0
 2774 15ea 4091 0000 		lds r20,bankStates+24
 2775 15ee 5091 0000 		lds r21,bankStates+24+1
 2776 15f2 6091 0000 		lds r22,bankStates+24+2
 2777 15f6 7091 0000 		lds r23,bankStates+24+3
 2778 15fa 8091 0000 		lds r24,bankStates+20
 2779 15fe 9091 0000 		lds r25,bankStates+20+1
 2780 1602 A091 0000 		lds r26,bankStates+20+2
 2781 1606 B091 0000 		lds r27,bankStates+20+3
 2782 160a 8417      		cp r24,r20
 2783 160c 9507      		cpc r25,r21
 2784 160e A607      		cpc r26,r22
 2785 1610 B707      		cpc r27,r23
 2786 1612 00F0      		brlo .+2
 2787 1614 00C0      		rjmp .L155
3731:WTPA.c        **** 		{
3732:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
 2788               		.loc 1 3732 0
 2789 1616 4091 0000 		lds r20,bankStates+31
 2790 161a 5091 0000 		lds r21,bankStates+31+1
 2791 161e 6091 0000 		lds r22,bankStates+31+2
 2792 1622 7091 0000 		lds r23,bankStates+31+3
 2793 1626 8091 0000 		lds r24,bankStates+24
 2794 162a 9091 0000 		lds r25,bankStates+24+1
 2795 162e A091 0000 		lds r26,bankStates+24+2
 2796 1632 B091 0000 		lds r27,bankStates+24+3
 2797 1636 4817      		cp r20,r24
 2798 1638 5907      		cpc r21,r25
 2799 163a 6A07      		cpc r22,r26
 2800 163c 7B07      		cpc r23,r27
 2801 163e 00F0      		brlo .+2
 2802 1640 00C0      		rjmp .L157
 2803               		.loc 1 3732 0 is_stmt 0 discriminator 1
 2804 1642 4091 0000 		lds r20,bankStates+31
 2805 1646 5091 0000 		lds r21,bankStates+31+1
 2806 164a 6091 0000 		lds r22,bankStates+31+2
 2807 164e 7091 0000 		lds r23,bankStates+31+3
 2808 1652 8091 0000 		lds r24,bankStates+20
 2809 1656 9091 0000 		lds r25,bankStates+20+1
 2810 165a A091 0000 		lds r26,bankStates+20+2
 2811 165e B091 0000 		lds r27,bankStates+20+3
 2812 1662 8417      		cp r24,r20
 2813 1664 9507      		cpc r25,r21
 2814 1666 A607      		cpc r26,r22
 2815 1668 B707      		cpc r27,r23
 2816 166a 00F0      		brlo .+2
 2817 166c 00C0      		rjmp .L157
3733:WTPA.c        **** 			{
3734:WTPA.c        **** 				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BAN
 2818               		.loc 1 3734 0 is_stmt 1
 2819 166e 4091 0000 		lds r20,bankStates+24
 2820 1672 5091 0000 		lds r21,bankStates+24+1
 2821 1676 6091 0000 		lds r22,bankStates+24+2
 2822 167a 7091 0000 		lds r23,bankStates+24+3
 2823 167e 8090 0000 		lds r8,bankStates+31
 2824 1682 9090 0000 		lds r9,bankStates+31+1
 2825 1686 A090 0000 		lds r10,bankStates+31+2
 2826 168a B090 0000 		lds r11,bankStates+31+3
 2827 168e 8091 0000 		lds r24,bankStates+31
 2828 1692 9091 0000 		lds r25,bankStates+31+1
 2829 1696 A091 0000 		lds r26,bankStates+31+2
 2830 169a B091 0000 		lds r27,bankStates+31+3
 2831 169e C090 0000 		lds r12,bankStates+20
 2832 16a2 D090 0000 		lds r13,bankStates+20+1
 2833 16a6 E090 0000 		lds r14,bankStates+20+2
 2834 16aa F090 0000 		lds r15,bankStates+20+3
 2835 16ae 4819      		sub r20,r8
 2836 16b0 5909      		sbc r21,r9
 2837 16b2 6A09      		sbc r22,r10
 2838 16b4 7B09      		sbc r23,r11
 2839 16b6 8C19      		sub r24,r12
 2840 16b8 9D09      		sbc r25,r13
 2841 16ba AE09      		sbc r26,r14
 2842 16bc BF09      		sbc r27,r15
 2843 16be 4817      		cp r20,r24
 2844 16c0 5907      		cpc r21,r25
 2845 16c2 6A07      		cpc r22,r26
 2846 16c4 7B07      		cpc r23,r27
 2847 16c6 00F0      		brlo .L177
 2848 16c8 00C0      		rjmp .L176
 2849               	.L155:
3735:WTPA.c        **** 				{
3736:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;	// Round to the sta
3737:WTPA.c        **** 				}
3738:WTPA.c        **** 				else
3739:WTPA.c        **** 				{
3740:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;	// Round to the end.
3741:WTPA.c        **** 				}
3742:WTPA.c        **** 			}
3743:WTPA.c        **** 		}
3744:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is before the end).
3745:WTPA.c        **** 		{
3746:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
 2850               		.loc 1 3746 0
 2851 16ca 4091 0000 		lds r20,bankStates+31
 2852 16ce 5091 0000 		lds r21,bankStates+31+1
 2853 16d2 6091 0000 		lds r22,bankStates+31+2
 2854 16d6 7091 0000 		lds r23,bankStates+31+3
 2855 16da 8091 0000 		lds r24,bankStates+24
 2856 16de 9091 0000 		lds r25,bankStates+24+1
 2857 16e2 A091 0000 		lds r26,bankStates+24+2
 2858 16e6 B091 0000 		lds r27,bankStates+24+3
 2859 16ea 4817      		cp r20,r24
 2860 16ec 5907      		cpc r21,r25
 2861 16ee 6A07      		cpc r22,r26
 2862 16f0 7B07      		cpc r23,r27
 2863 16f2 00F4      		brsh .L160
 2864               	.L176:
3747:WTPA.c        **** 			{
3748:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the 
 2865               		.loc 1 3748 0
 2866 16f4 8091 0000 		lds r24,bankStates+24
 2867 16f8 9091 0000 		lds r25,bankStates+24+1
 2868 16fc A091 0000 		lds r26,bankStates+24+2
 2869 1700 B091 0000 		lds r27,bankStates+24+3
 2870               	.L173:
 2871 1704 8093 0000 		sts bankStates+31,r24
 2872 1708 9093 0000 		sts bankStates+31+1,r25
 2873 170c A093 0000 		sts bankStates+31+2,r26
 2874 1710 B093 0000 		sts bankStates+31+3,r27
 2875 1714 00C0      		rjmp .L157
 2876               	.L160:
3749:WTPA.c        **** 			}
3750:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
 2877               		.loc 1 3750 0
 2878 1716 4091 0000 		lds r20,bankStates+31
 2879 171a 5091 0000 		lds r21,bankStates+31+1
 2880 171e 6091 0000 		lds r22,bankStates+31+2
 2881 1722 7091 0000 		lds r23,bankStates+31+3
 2882 1726 8091 0000 		lds r24,bankStates+20
 2883 172a 9091 0000 		lds r25,bankStates+20+1
 2884 172e A091 0000 		lds r26,bankStates+20+2
 2885 1732 B091 0000 		lds r27,bankStates+20+3
 2886 1736 8417      		cp r24,r20
 2887 1738 9507      		cpc r25,r21
 2888 173a A607      		cpc r26,r22
 2889 173c B707      		cpc r27,r23
 2890 173e 00F0      		brlo .+2
 2891 1740 00C0      		rjmp .L157
 2892               	.L177:
3751:WTPA.c        **** 			{
3752:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
 2893               		.loc 1 3752 0
 2894 1742 8091 0000 		lds r24,bankStates+20
 2895 1746 9091 0000 		lds r25,bankStates+20+1
 2896 174a A091 0000 		lds r26,bankStates+20+2
 2897 174e B091 0000 		lds r27,bankStates+20+3
 2898 1752 00C0      		rjmp .L173
 2899               	.LVL81:
 2900               	.L145:
3753:WTPA.c        **** 			}
3754:WTPA.c        **** 		}
3755:WTPA.c        **** 	}
3756:WTPA.c        **** 	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
3757:WTPA.c        **** 	{
3758:WTPA.c        **** 		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
3759:WTPA.c        **** 		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of 
 2901               		.loc 1 3759 0
 2902 1754 8091 0000 		lds r24,bankStates+47
 2903 1758 9091 0000 		lds r25,bankStates+47+1
 2904 175c A091 0000 		lds r26,bankStates+47+2
 2905 1760 B091 0000 		lds r27,bankStates+47+3
 2906               	.LVL82:
 2907 1764 CC24      		clr r12
 2908 1766 CA94      		dec r12
 2909 1768 DC2C      		mov r13,r12
 2910 176a 27E0      		ldi r18,lo8(7)
 2911 176c E22E      		mov r14,r18
 2912 176e F12C      		mov r15,__zero_reg__
 2913 1770 4601      		movw r8,r12
 2914 1772 5701      		movw r10,r14
 2915 1774 881A      		sub r8,r24
 2916 1776 990A      		sbc r9,r25
 2917 1778 AA0A      		sbc r10,r26
 2918 177a BB0A      		sbc r11,r27
 2919 177c 33E0      		ldi r19,3
 2920               		1:
 2921 177e 880C      		lsl r8
 2922 1780 991C      		rol r9
 2923 1782 AA1C      		rol r10
 2924 1784 BB1C      		rol r11
 2925 1786 3A95      		dec r19
 2926 1788 01F4      		brne 1b
 2927 178a 892C      		mov r8,r9
 2928 178c 9A2C      		mov r9,r10
 2929 178e AB2C      		mov r10,r11
 2930 1790 BB24      		clr r11
 2931               	.LVL83:
3760:WTPA.c        **** 
3761:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3762:WTPA.c        **** 
3763:WTPA.c        **** 		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sam
 2932               		.loc 1 3763 0
 2933 1792 A091 0000 		lds r26,bankStates+63
 2934 1796 8091 0000 		lds r24,bankStates+65
 2935 179a B0E0      		ldi r27,0
 2936 179c A80F      		add r26,r24
 2937 179e B11D      		adc r27,__zero_reg__
 2938 17a0 A501      		movw r20,r10
 2939 17a2 9401      		movw r18,r8
 2940 17a4 0E94 0000 		call __muluhisi3
 2941 17a8 F3E0      		ldi r31,3
 2942               		1:
 2943 17aa 9695      		lsr r25
 2944 17ac 8795      		ror r24
 2945 17ae 7795      		ror r23
 2946 17b0 6795      		ror r22
 2947 17b2 FA95      		dec r31
 2948 17b4 01F4      		brne 1b
 2949 17b6 C61A      		sub r12,r22
 2950 17b8 D70A      		sbc r13,r23
 2951 17ba E80A      		sbc r14,r24
 2952 17bc F90A      		sbc r15,r25
 2953 17be C092 0000 		sts bankStates+59,r12
 2954 17c2 D092 0000 		sts bankStates+59+1,r13
 2955 17c6 E092 0000 		sts bankStates+59+2,r14
 2956 17ca F092 0000 		sts bankStates+59+3,r15
3764:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_
 2957               		.loc 1 3764 0
 2958 17ce 4090 0000 		lds r4,bankStates+47
 2959 17d2 5090 0000 		lds r5,bankStates+47+1
 2960 17d6 6090 0000 		lds r6,bankStates+47+2
 2961 17da 7090 0000 		lds r7,bankStates+47+3
 2962 17de A091 0000 		lds r26,bankStates+64
 2963 17e2 F091 0000 		lds r31,bankStates+65
 2964 17e6 B0E0      		ldi r27,0
 2965 17e8 0E94 0000 		call __muluhisi3
 2966 17ec 6B01      		movw r12,r22
 2967 17ee 7C01      		movw r14,r24
 2968 17f0 A3E0      		ldi r26,3
 2969               		1:
 2970 17f2 F694      		lsr r15
 2971 17f4 E794      		ror r14
 2972 17f6 D794      		ror r13
 2973 17f8 C794      		ror r12
 2974 17fa AA95      		dec r26
 2975 17fc 01F4      		brne 1b
 2976 17fe C40C      		add r12,r4
 2977 1800 D51C      		adc r13,r5
 2978 1802 E61C      		adc r14,r6
 2979 1804 F71C      		adc r15,r7
 2980 1806 AF2F      		mov r26,r31
 2981 1808 B0E0      		ldi r27,0
 2982 180a 0E94 0000 		call __muluhisi3
 2983 180e B3E0      		ldi r27,3
 2984               		1:
 2985 1810 9695      		lsr r25
 2986 1812 8795      		ror r24
 2987 1814 7795      		ror r23
 2988 1816 6795      		ror r22
 2989 1818 BA95      		dec r27
 2990 181a 01F4      		brne 1b
 2991 181c C61A      		sub r12,r22
 2992 181e D70A      		sbc r13,r23
 2993 1820 E80A      		sbc r14,r24
 2994 1822 F90A      		sbc r15,r25
 2995 1824 C092 0000 		sts bankStates+55,r12
 2996 1828 D092 0000 		sts bankStates+55+1,r13
 2997 182c E092 0000 		sts bankStates+55+2,r14
 2998 1830 F092 0000 		sts bankStates+55+3,r15
3765:WTPA.c        **** 
3766:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3767:WTPA.c        **** 
3768:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse play
 2999               		.loc 1 3768 0
 3000 1834 4091 0000 		lds r20,bankStates+59
 3001 1838 5091 0000 		lds r21,bankStates+59+1
 3002 183c 6091 0000 		lds r22,bankStates+59+2
 3003 1840 7091 0000 		lds r23,bankStates+59+3
 3004 1844 8091 0000 		lds r24,bankStates+55
 3005 1848 9091 0000 		lds r25,bankStates+55+1
 3006 184c A091 0000 		lds r26,bankStates+55+2
 3007 1850 B091 0000 		lds r27,bankStates+55+3
 3008 1854 4817      		cp r20,r24
 3009 1856 5907      		cpc r21,r25
 3010 1858 6A07      		cpc r22,r26
 3011 185a 7B07      		cpc r23,r27
 3012 185c 00F4      		brsh .L161
3769:WTPA.c        **** 		{
3770:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 3013               		.loc 1 3770 0
 3014 185e 8091 0000 		lds r24,bankStates+38
 3015 1862 8130      		cpi r24,lo8(1)
 3016 1864 01F4      		brne .L162
3771:WTPA.c        **** 			{
3772:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3017               		.loc 1 3772 0
 3018 1866 8093 0000 		sts bankStates+39,r24
 3019 186a 00C0      		rjmp .L163
 3020               	.L162:
3773:WTPA.c        **** 			}
3774:WTPA.c        **** 			else
3775:WTPA.c        **** 			{
3776:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3021               		.loc 1 3776 0
 3022 186c 1092 0000 		sts bankStates+39,__zero_reg__
 3023               	.L163:
3777:WTPA.c        **** 			}
3778:WTPA.c        **** 
3779:WTPA.c        **** 			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
 3024               		.loc 1 3779 0
 3025 1870 8091 0000 		lds r24,bankStates+59
 3026 1874 9091 0000 		lds r25,bankStates+59+1
 3027 1878 A091 0000 		lds r26,bankStates+59+2
 3028 187c B091 0000 		lds r27,bankStates+59+3
 3029               	.LVL84:
3780:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to st
 3030               		.loc 1 3780 0
 3031 1880 4091 0000 		lds r20,bankStates+55
 3032 1884 5091 0000 		lds r21,bankStates+55+1
 3033 1888 6091 0000 		lds r22,bankStates+55+2
 3034 188c 7091 0000 		lds r23,bankStates+55+3
 3035 1890 4093 0000 		sts bankStates+59,r20
 3036 1894 5093 0000 		sts bankStates+59+1,r21
 3037 1898 6093 0000 		sts bankStates+59+2,r22
 3038 189c 7093 0000 		sts bankStates+59+3,r23
3781:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
 3039               		.loc 1 3781 0
 3040 18a0 8093 0000 		sts bankStates+55,r24
 3041 18a4 9093 0000 		sts bankStates+55+1,r25
 3042 18a8 A093 0000 		sts bankStates+55+2,r26
 3043 18ac B093 0000 		sts bankStates+55+3,r27
 3044 18b0 00C0      		rjmp .L164
 3045               	.LVL85:
 3046               	.L161:
3782:WTPA.c        **** 		}
3783:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3784:WTPA.c        **** 		{
3785:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
 3047               		.loc 1 3785 0
 3048 18b2 8091 0000 		lds r24,bankStates+38
 3049 18b6 8130      		cpi r24,lo8(1)
 3050 18b8 01F4      		brne .L165
3786:WTPA.c        **** 			{
3787:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3051               		.loc 1 3787 0
 3052 18ba 1092 0000 		sts bankStates+39,__zero_reg__
 3053 18be 00C0      		rjmp .L164
 3054               	.L165:
3788:WTPA.c        **** 			}
3789:WTPA.c        **** 			else
3790:WTPA.c        **** 			{
3791:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3055               		.loc 1 3791 0
 3056 18c0 81E0      		ldi r24,lo8(1)
 3057 18c2 8093 0000 		sts bankStates+39,r24
 3058               	.LVL86:
 3059               	.L164:
3792:WTPA.c        **** 			}
3793:WTPA.c        **** 		}
3794:WTPA.c        **** 
3795:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3796:WTPA.c        **** 
3797:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the e
 3060               		.loc 1 3797 0
 3061 18c6 4091 0000 		lds r20,bankStates+59
 3062 18ca 5091 0000 		lds r21,bankStates+59+1
 3063 18ce 6091 0000 		lds r22,bankStates+59+2
 3064 18d2 7091 0000 		lds r23,bankStates+59+3
 3065 18d6 8091 0000 		lds r24,bankStates+47
 3066 18da 9091 0000 		lds r25,bankStates+47+1
 3067 18de A091 0000 		lds r26,bankStates+47+2
 3068 18e2 B091 0000 		lds r27,bankStates+47+3
 3069 18e6 4817      		cp r20,r24
 3070 18e8 5907      		cpc r21,r25
 3071 18ea 6A07      		cpc r22,r26
 3072 18ec 7B07      		cpc r23,r27
 3073 18ee 00F4      		brsh .L166
3798:WTPA.c        **** 		{
3799:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bank
 3074               		.loc 1 3799 0
 3075 18f0 8091 0000 		lds r24,bankStates+59
 3076 18f4 9091 0000 		lds r25,bankStates+59+1
 3077 18f8 A091 0000 		lds r26,bankStates+59+2
 3078 18fc B091 0000 		lds r27,bankStates+59+3
 3079 1900 4091 0000 		lds r20,bankStates+47
 3080 1904 5091 0000 		lds r21,bankStates+47+1
 3081 1908 6091 0000 		lds r22,bankStates+47+2
 3082 190c 7091 0000 		lds r23,bankStates+47+3
 3083 1910 0197      		sbiw r24,1
 3084 1912 A84F      		sbci r26,-8
 3085 1914 BF4F      		sbci r27,-1
 3086 1916 841B      		sub r24,r20
 3087 1918 950B      		sbc r25,r21
 3088 191a A60B      		sbc r26,r22
 3089 191c B70B      		sbc r27,r23
 3090 191e 8093 0000 		sts bankStates+59,r24
 3091 1922 9093 0000 		sts bankStates+59+1,r25
 3092 1926 A093 0000 		sts bankStates+59+2,r26
 3093 192a B093 0000 		sts bankStates+59+3,r27
 3094               	.L166:
3800:WTPA.c        **** 		}
3801:WTPA.c        **** 		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
 3095               		.loc 1 3801 0
 3096 192e 4091 0000 		lds r20,bankStates+55
 3097 1932 5091 0000 		lds r21,bankStates+55+1
 3098 1936 6091 0000 		lds r22,bankStates+55+2
 3099 193a 7091 0000 		lds r23,bankStates+55+3
 3100 193e 8091 0000 		lds r24,bankStates+47
 3101 1942 9091 0000 		lds r25,bankStates+47+1
 3102 1946 A091 0000 		lds r26,bankStates+47+2
 3103 194a B091 0000 		lds r27,bankStates+47+3
 3104 194e 4817      		cp r20,r24
 3105 1950 5907      		cpc r21,r25
 3106 1952 6A07      		cpc r22,r26
 3107 1954 7B07      		cpc r23,r27
 3108 1956 00F0      		brlo .+2
 3109 1958 00C0      		rjmp .L168
3802:WTPA.c        **** 		{
3803:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankSt
 3110               		.loc 1 3803 0
 3111 195a 8091 0000 		lds r24,bankStates+55
 3112 195e 9091 0000 		lds r25,bankStates+55+1
 3113 1962 A091 0000 		lds r26,bankStates+55+2
 3114 1966 B091 0000 		lds r27,bankStates+55+3
 3115 196a 4091 0000 		lds r20,bankStates+47
 3116 196e 5091 0000 		lds r21,bankStates+47+1
 3117 1972 6091 0000 		lds r22,bankStates+47+2
 3118 1976 7091 0000 		lds r23,bankStates+47+3
 3119 197a 0197      		sbiw r24,1
 3120 197c A84F      		sbci r26,-8
 3121 197e BF4F      		sbci r27,-1
 3122 1980 841B      		sub r24,r20
 3123 1982 950B      		sbc r25,r21
 3124 1984 A60B      		sbc r26,r22
 3125 1986 B70B      		sbc r27,r23
 3126 1988 8093 0000 		sts bankStates+55,r24
 3127 198c 9093 0000 		sts bankStates+55+1,r25
 3128 1990 A093 0000 		sts bankStates+55+2,r26
 3129 1994 B093 0000 		sts bankStates+55+3,r27
3804:WTPA.c        **** 
3805:WTPA.c        **** 			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wra
 3130               		.loc 1 3805 0
 3131 1998 4091 0000 		lds r20,bankStates+55
 3132 199c 5091 0000 		lds r21,bankStates+55+1
 3133 19a0 6091 0000 		lds r22,bankStates+55+2
 3134 19a4 7091 0000 		lds r23,bankStates+55+3
 3135 19a8 8091 0000 		lds r24,bankStates+59
 3136 19ac 9091 0000 		lds r25,bankStates+59+1
 3137 19b0 A091 0000 		lds r26,bankStates+59+2
 3138 19b4 B091 0000 		lds r27,bankStates+59+3
 3139 19b8 4817      		cp r20,r24
 3140 19ba 5907      		cpc r21,r25
 3141 19bc 6A07      		cpc r22,r26
 3142 19be 7B07      		cpc r23,r27
 3143 19c0 01F4      		brne .L168
3806:WTPA.c        **** 			{
3807:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
 3144               		.loc 1 3807 0
 3145 19c2 8091 0000 		lds r24,bankStates+55
 3146 19c6 9091 0000 		lds r25,bankStates+55+1
 3147 19ca A091 0000 		lds r26,bankStates+55+2
 3148 19ce B091 0000 		lds r27,bankStates+55+3
 3149 19d2 0196      		adiw r24,1
 3150 19d4 A11D      		adc r26,__zero_reg__
 3151 19d6 B11D      		adc r27,__zero_reg__
 3152 19d8 8093 0000 		sts bankStates+55,r24
 3153 19dc 9093 0000 		sts bankStates+55+1,r25
 3154 19e0 A093 0000 		sts bankStates+55+2,r26
 3155 19e4 B093 0000 		sts bankStates+55+3,r27
 3156               	.L168:
3808:WTPA.c        **** 			}
3809:WTPA.c        **** 		}
3810:WTPA.c        **** 
3811:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3812:WTPA.c        **** 
3813:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapp
 3157               		.loc 1 3813 0
 3158 19e8 4091 0000 		lds r20,bankStates+59
 3159 19ec 5091 0000 		lds r21,bankStates+59+1
 3160 19f0 6091 0000 		lds r22,bankStates+59+2
 3161 19f4 7091 0000 		lds r23,bankStates+59+3
 3162 19f8 8091 0000 		lds r24,bankStates+55
 3163 19fc 9091 0000 		lds r25,bankStates+55+1
 3164 1a00 A091 0000 		lds r26,bankStates+55+2
 3165 1a04 B091 0000 		lds r27,bankStates+55+3
 3166 1a08 4817      		cp r20,r24
 3167 1a0a 5907      		cpc r21,r25
 3168 1a0c 6A07      		cpc r22,r26
 3169 1a0e 7B07      		cpc r23,r27
 3170 1a10 00F0      		brlo .+2
 3171 1a12 00C0      		rjmp .L170
3814:WTPA.c        **** 		{
3815:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
 3172               		.loc 1 3815 0
 3173 1a14 4091 0000 		lds r20,bankStates+66
 3174 1a18 5091 0000 		lds r21,bankStates+66+1
 3175 1a1c 6091 0000 		lds r22,bankStates+66+2
 3176 1a20 7091 0000 		lds r23,bankStates+66+3
 3177 1a24 8091 0000 		lds r24,bankStates+59
 3178 1a28 9091 0000 		lds r25,bankStates+59+1
 3179 1a2c A091 0000 		lds r26,bankStates+59+2
 3180 1a30 B091 0000 		lds r27,bankStates+59+3
 3181 1a34 8417      		cp r24,r20
 3182 1a36 9507      		cpc r25,r21
 3183 1a38 A607      		cpc r26,r22
 3184 1a3a B707      		cpc r27,r23
 3185 1a3c 00F0      		brlo .+2
 3186 1a3e 00C0      		rjmp .L157
 3187               		.loc 1 3815 0 is_stmt 0 discriminator 1
 3188 1a40 4091 0000 		lds r20,bankStates+66
 3189 1a44 5091 0000 		lds r21,bankStates+66+1
 3190 1a48 6091 0000 		lds r22,bankStates+66+2
 3191 1a4c 7091 0000 		lds r23,bankStates+66+3
 3192 1a50 8091 0000 		lds r24,bankStates+55
 3193 1a54 9091 0000 		lds r25,bankStates+55+1
 3194 1a58 A091 0000 		lds r26,bankStates+55+2
 3195 1a5c B091 0000 		lds r27,bankStates+55+3
 3196 1a60 4817      		cp r20,r24
 3197 1a62 5907      		cpc r21,r25
 3198 1a64 6A07      		cpc r22,r26
 3199 1a66 7B07      		cpc r23,r27
 3200 1a68 00F0      		brlo .+2
 3201 1a6a 00C0      		rjmp .L157
3816:WTPA.c        **** 			{
3817:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BAN
 3202               		.loc 1 3817 0 is_stmt 1
 3203 1a6c 4091 0000 		lds r20,bankStates+66
 3204 1a70 5091 0000 		lds r21,bankStates+66+1
 3205 1a74 6091 0000 		lds r22,bankStates+66+2
 3206 1a78 7091 0000 		lds r23,bankStates+66+3
 3207 1a7c 8090 0000 		lds r8,bankStates+59
 3208 1a80 9090 0000 		lds r9,bankStates+59+1
 3209 1a84 A090 0000 		lds r10,bankStates+59+2
 3210 1a88 B090 0000 		lds r11,bankStates+59+3
 3211 1a8c 8091 0000 		lds r24,bankStates+55
 3212 1a90 9091 0000 		lds r25,bankStates+55+1
 3213 1a94 A091 0000 		lds r26,bankStates+55+2
 3214 1a98 B091 0000 		lds r27,bankStates+55+3
 3215 1a9c C090 0000 		lds r12,bankStates+66
 3216 1aa0 D090 0000 		lds r13,bankStates+66+1
 3217 1aa4 E090 0000 		lds r14,bankStates+66+2
 3218 1aa8 F090 0000 		lds r15,bankStates+66+3
 3219 1aac 4819      		sub r20,r8
 3220 1aae 5909      		sbc r21,r9
 3221 1ab0 6A09      		sbc r22,r10
 3222 1ab2 7B09      		sbc r23,r11
 3223 1ab4 8C19      		sub r24,r12
 3224 1ab6 9D09      		sbc r25,r13
 3225 1ab8 AE09      		sbc r26,r14
 3226 1aba BF09      		sbc r27,r15
 3227 1abc 8417      		cp r24,r20
 3228 1abe 9507      		cpc r25,r21
 3229 1ac0 A607      		cpc r26,r22
 3230 1ac2 B707      		cpc r27,r23
 3231 1ac4 00F0      		brlo .L175
 3232 1ac6 00C0      		rjmp .L178
 3233               	.L170:
3818:WTPA.c        **** 				{
3819:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;	// Round to the sta
3820:WTPA.c        **** 				}
3821:WTPA.c        **** 				else
3822:WTPA.c        **** 				{
3823:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;	// Round to the end.
3824:WTPA.c        **** 				}
3825:WTPA.c        **** 			}
3826:WTPA.c        **** 		}
3827:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is xxx the end).
3828:WTPA.c        **** 		{
3829:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
 3234               		.loc 1 3829 0
 3235 1ac8 4091 0000 		lds r20,bankStates+66
 3236 1acc 5091 0000 		lds r21,bankStates+66+1
 3237 1ad0 6091 0000 		lds r22,bankStates+66+2
 3238 1ad4 7091 0000 		lds r23,bankStates+66+3
 3239 1ad8 8091 0000 		lds r24,bankStates+59
 3240 1adc 9091 0000 		lds r25,bankStates+59+1
 3241 1ae0 A091 0000 		lds r26,bankStates+59+2
 3242 1ae4 B091 0000 		lds r27,bankStates+59+3
 3243 1ae8 8417      		cp r24,r20
 3244 1aea 9507      		cpc r25,r21
 3245 1aec A607      		cpc r26,r22
 3246 1aee B707      		cpc r27,r23
 3247 1af0 00F4      		brsh .L172
 3248               	.L178:
3830:WTPA.c        **** 			{
3831:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the 
 3249               		.loc 1 3831 0
 3250 1af2 8091 0000 		lds r24,bankStates+59
 3251 1af6 9091 0000 		lds r25,bankStates+59+1
 3252 1afa A091 0000 		lds r26,bankStates+59+2
 3253 1afe B091 0000 		lds r27,bankStates+59+3
 3254 1b02 00C0      		rjmp .L174
 3255               	.L172:
3832:WTPA.c        **** 			}
3833:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
 3256               		.loc 1 3833 0
 3257 1b04 4091 0000 		lds r20,bankStates+66
 3258 1b08 5091 0000 		lds r21,bankStates+66+1
 3259 1b0c 6091 0000 		lds r22,bankStates+66+2
 3260 1b10 7091 0000 		lds r23,bankStates+66+3
 3261 1b14 8091 0000 		lds r24,bankStates+55
 3262 1b18 9091 0000 		lds r25,bankStates+55+1
 3263 1b1c A091 0000 		lds r26,bankStates+55+2
 3264 1b20 B091 0000 		lds r27,bankStates+55+3
 3265 1b24 4817      		cp r20,r24
 3266 1b26 5907      		cpc r21,r25
 3267 1b28 6A07      		cpc r22,r26
 3268 1b2a 7B07      		cpc r23,r27
 3269 1b2c 00F4      		brsh .L157
 3270               	.L175:
3834:WTPA.c        **** 			{
3835:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
 3271               		.loc 1 3835 0
 3272 1b2e 8091 0000 		lds r24,bankStates+55
 3273 1b32 9091 0000 		lds r25,bankStates+55+1
 3274 1b36 A091 0000 		lds r26,bankStates+55+2
 3275 1b3a B091 0000 		lds r27,bankStates+55+3
 3276               	.L174:
 3277 1b3e 8093 0000 		sts bankStates+66,r24
 3278 1b42 9093 0000 		sts bankStates+66+1,r25
 3279 1b46 A093 0000 		sts bankStates+66+2,r26
 3280 1b4a B093 0000 		sts bankStates+66+3,r27
 3281               	.L157:
3836:WTPA.c        **** 			}
3837:WTPA.c        **** 		}
3838:WTPA.c        **** 	}
3839:WTPA.c        **** 
3840:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3282               		.loc 1 3840 0
 3283 1b4e EFBF      		out __SREG__,r30
 3284               	/* epilogue start */
3841:WTPA.c        **** }
 3285               		.loc 1 3841 0
 3286 1b50 FF90      		pop r15
 3287 1b52 EF90      		pop r14
 3288 1b54 DF90      		pop r13
 3289 1b56 CF90      		pop r12
 3290 1b58 BF90      		pop r11
 3291 1b5a AF90      		pop r10
 3292 1b5c 9F90      		pop r9
 3293 1b5e 8F90      		pop r8
 3294 1b60 7F90      		pop r7
 3295 1b62 6F90      		pop r6
 3296 1b64 5F90      		pop r5
 3297 1b66 4F90      		pop r4
 3298 1b68 0895      		ret
 3299               		.cfi_endproc
 3300               	.LFE62:
 3303               	RevertSampleToUnadjusted:
 3304               	.LFB63:
3842:WTPA.c        **** 
3843:WTPA.c        **** static void RevertSampleToUnadjusted(unsigned char theBank)
3844:WTPA.c        **** // Removes user adjustments to sample and returns it to maximum size.
3845:WTPA.c        **** // @@@ Since the current sample address must be within these bounds, there is no need to adjust it.
3846:WTPA.c        **** // @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
3847:WTPA.c        **** {
 3305               		.loc 1 3847 0
 3306               		.cfi_startproc
 3307               	.LVL87:
 3308               	/* prologue: function */
 3309               	/* frame size = 0 */
 3310               	/* stack size = 0 */
 3311               	.L__stack_usage = 0
3848:WTPA.c        **** 	unsigned char
3849:WTPA.c        **** 		sreg;
3850:WTPA.c        **** 
3851:WTPA.c        **** 	sreg=SREG;
 3312               		.loc 1 3851 0
 3313 1b6a 9FB7      		in r25,__SREG__
 3314               	.LVL88:
3852:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 3315               		.loc 1 3852 0
 3316               	/* #APP */
 3317               	 ;  3852 "WTPA.c" 1
 3318 1b6c F894      		cli
 3319               	 ;  0 "" 2
3853:WTPA.c        **** 
3854:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 3320               		.loc 1 3854 0
 3321               	/* #NOAPP */
 3322 1b6e 23E2      		ldi r18,lo8(35)
 3323 1b70 829F      		mul r24,r18
 3324 1b72 F001      		movw r30,r0
 3325 1b74 1124      		clr __zero_reg__
 3326 1b76 E050      		subi r30,lo8(-(bankStates))
 3327 1b78 F040      		sbci r31,hi8(-(bankStates))
 3328 1b7a 4089      		ldd r20,Z+16
 3329 1b7c 5189      		ldd r21,Z+17
 3330 1b7e 6289      		ldd r22,Z+18
 3331 1b80 7389      		ldd r23,Z+19
 3332 1b82 408F      		std Z+24,r20
 3333 1b84 518F      		std Z+25,r21
 3334 1b86 628F      		std Z+26,r22
 3335 1b88 738F      		std Z+27,r23
3855:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 3336               		.loc 1 3855 0
 3337 1b8a 4485      		ldd r20,Z+12
 3338 1b8c 5585      		ldd r21,Z+13
 3339 1b8e 6685      		ldd r22,Z+14
 3340 1b90 7785      		ldd r23,Z+15
 3341 1b92 448B      		std Z+20,r20
 3342 1b94 558B      		std Z+21,r21
 3343 1b96 668B      		std Z+22,r22
 3344 1b98 778B      		std Z+23,r23
3856:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 3345               		.loc 1 3856 0
 3346 1b9a 148E      		std Z+28,__zero_reg__
3857:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 3347               		.loc 1 3857 0
 3348 1b9c 158E      		std Z+29,__zero_reg__
3858:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 3349               		.loc 1 3858 0
 3350 1b9e 168E      		std Z+30,__zero_reg__
3859:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3351               		.loc 1 3859 0
 3352 1ba0 9FBF      		out __SREG__,r25
 3353 1ba2 0895      		ret
 3354               		.cfi_endproc
 3355               	.LFE63:
 3358               	BlinkLeds:
 3359               	.LFB17:
1480:WTPA.c        **** {
 3360               		.loc 1 1480 0
 3361               		.cfi_startproc
 3362               	.LVL89:
 3363               	/* prologue: function */
 3364               	/* frame size = 0 */
 3365               	/* stack size = 0 */
 3366               	.L__stack_usage = 0
1486:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3367               		.loc 1 1486 0
 3368 1ba4 4091 0000 		lds r20,ledBlinkMask
 3369 1ba8 50E0      		ldi r21,0
 3370 1baa 9091 0000 		lds r25,ledOnOffMask
 3371 1bae 20E0      		ldi r18,0
 3372 1bb0 30E0      		ldi r19,0
1488:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3373               		.loc 1 1488 0
 3374 1bb2 61E0      		ldi r22,lo8(1)
 3375 1bb4 70E0      		ldi r23,0
 3376               	.LVL90:
 3377               	.L182:
1486:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3378               		.loc 1 1486 0
 3379 1bb6 DA01      		movw r26,r20
 3380 1bb8 022E      		mov r0,r18
 3381 1bba 00C0      		rjmp 2f
 3382               		1:
 3383 1bbc B595      		asr r27
 3384 1bbe A795      		ror r26
 3385               		2:
 3386 1bc0 0A94      		dec r0
 3387 1bc2 02F4      		brpl 1b
 3388 1bc4 A0FF      		sbrs r26,0
 3389 1bc6 00C0      		rjmp .L181
1488:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3390               		.loc 1 1488 0
 3391 1bc8 DB01      		movw r26,r22
 3392 1bca 022E      		mov r0,r18
 3393 1bcc 00C0      		rjmp 2f
 3394               		1:
 3395 1bce AA0F      		lsl r26
 3396 1bd0 BB1F      		rol r27
 3397               		2:
 3398 1bd2 0A94      		dec r0
 3399 1bd4 02F4      		brpl 1b
 3400 1bd6 FD01      		movw r30,r26
 3401 1bd8 E095      		com r30
 3402 1bda 9E23      		and r25,r30
 3403               	.L181:
 3404 1bdc 2F5F      		subi r18,-1
 3405 1bde 3F4F      		sbci r19,-1
1484:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
 3406               		.loc 1 1484 0
 3407 1be0 2830      		cpi r18,8
 3408 1be2 3105      		cpc r19,__zero_reg__
 3409 1be4 01F4      		brne .L182
 3410 1be6 9093 0000 		sts ledOnOffMask,r25
1492:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 3411               		.loc 1 1492 0
 3412 1bea 8093 0000 		sts ledBlinkMask,r24
1493:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 3413               		.loc 1 1493 0
 3414 1bee 68E9      		ldi r22,lo8(-104)
 3415 1bf0 70E0      		ldi r23,0
 3416 1bf2 82E0      		ldi r24,lo8(2)
 3417               	.LVL91:
 3418 1bf4 0C94 0000 		jmp SetTimer
 3419               	.LVL92:
 3420               		.cfi_endproc
 3421               	.LFE17:
 3424               	KillLeds:
 3425               	.LFB19:
1504:WTPA.c        **** {
 3426               		.loc 1 1504 0
 3427               		.cfi_startproc
 3428               	/* prologue: function */
 3429               	/* frame size = 0 */
 3430               	/* stack size = 0 */
 3431               	.L__stack_usage = 0
1505:WTPA.c        **** 	ledOnOffMask=0;
 3432               		.loc 1 1505 0
 3433 1bf8 1092 0000 		sts ledOnOffMask,__zero_reg__
1506:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 3434               		.loc 1 1506 0
 3435 1bfc 80E0      		ldi r24,0
 3436 1bfe 90E0      		ldi r25,0
 3437 1c00 0C94 0000 		jmp BlinkLeds
 3438               	.LVL93:
 3439               		.cfi_endproc
 3440               	.LFE19:
 3443               	DoFruitcakeIntro:
 3444               	.LFB72:
3860:WTPA.c        **** }
3861:WTPA.c        **** 
3862:WTPA.c        **** static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
3863:WTPA.c        **** // Moves the memory location where the sample begins (or loops) playback farther into the sample.
3864:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3865:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3866:WTPA.c        **** {
3867:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
3868:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3869:WTPA.c        **** }
3870:WTPA.c        **** 
3871:WTPA.c        **** static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
3872:WTPA.c        **** // Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
3873:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3874:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3875:WTPA.c        **** {
3876:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
3877:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3878:WTPA.c        **** }
3879:WTPA.c        **** 
3880:WTPA.c        **** static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
3881:WTPA.c        **** // Shuttles the entire adjusted sample window farther into the sample.
3882:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3883:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3884:WTPA.c        **** {
3885:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
3886:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3887:WTPA.c        **** }
3888:WTPA.c        **** 
3889:WTPA.c        **** //--------------------------------------
3890:WTPA.c        **** //--------------------------------------
3891:WTPA.c        **** // SAMPLER Main Loop!
3892:WTPA.c        **** //--------------------------------------
3893:WTPA.c        **** //--------------------------------------
3894:WTPA.c        **** 
3895:WTPA.c        **** static unsigned char
3896:WTPA.c        **** 	currentBank;					// Keeps track of the bank we're thinking about.
3897:WTPA.c        **** 
3898:WTPA.c        **** static void UpdateUserSwitches(void)
3899:WTPA.c        **** // Take the button-mashings of the player and translate them into something useful.
3900:WTPA.c        **** // There are two "shift" keys on WTPA2 (switch 6 and 7).
3901:WTPA.c        **** // Button functions are relative to how many shift keys are being held down: 0, one, or two.
3902:WTPA.c        **** 
3903:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
3904:WTPA.c        **** // ------------------------------------------------------------------------------------------------
3905:WTPA.c        **** // No Shift:	Rec			Odub		Restart		Single		Pause		Bank		Shift1		Shift2
3906:WTPA.c        **** // Shift 1:		BitDepth	Halftime	Realtime	Granular	SumMode		Backwards	(pressed)	(not pressed)
3907:WTPA.c        **** // Shift 2:		Edit Start	Edit End	Edit Wind	Play SD		Jitter		?			(not press)	(pressed)
3908:WTPA.c        **** // Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
3909:WTPA.c        **** {
3910:WTPA.c        **** 	static unsigned char
3911:WTPA.c        **** 			lastEncoderValue;
3912:WTPA.c        **** 
3913:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3914:WTPA.c        **** 	// Two shift keys:
3915:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3916:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
3917:WTPA.c        **** 	{
3918:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
3919:WTPA.c        **** 		{
3920:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
3921:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
3922:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
3923:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
3924:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
3925:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
3926:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
3927:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
3928:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
3929:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
3930:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
3931:WTPA.c        **** 		}
3932:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)
3933:WTPA.c        **** 		{
3934:WTPA.c        **** 			// Enter SD card menu
3935:WTPA.c        **** 			WriteSampleToSd(currentBank,0);		// @@@ test
3936:WTPA.c        **** 		}
3937:WTPA.c        **** 		else if(newKeys&Im_SWITCH_1)
3938:WTPA.c        **** 		{
3939:WTPA.c        **** 			// Enter SD card menu
3940:WTPA.c        **** 			ReadSampleFromSd(currentBank,0);	// @@@ test
3941:WTPA.c        **** 		}
3942:WTPA.c        **** 	}
3943:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3944:WTPA.c        **** 	// Shift 1:
3945:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3946:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
3947:WTPA.c        **** 	{
3948:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
3949:WTPA.c        **** 		{
3950:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pre
3951:WTPA.c        **** 			{
3952:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
3953:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
3954:WTPA.c        **** 			}
3955:WTPA.c        **** 		}
3956:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
3957:WTPA.c        **** 		{
3958:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
3959:WTPA.c        **** 			{
3960:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
3961:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
3962:WTPA.c        **** 			}
3963:WTPA.c        **** 			else
3964:WTPA.c        **** 			{
3965:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
3966:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
3967:WTPA.c        **** 			}
3968:WTPA.c        **** 		}
3969:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
3970:WTPA.c        **** 		{
3971:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
3972:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
3973:WTPA.c        **** 		}
3974:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granula
3975:WTPA.c        **** 		{
3976:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
3977:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
3978:WTPA.c        **** 		}
3979:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
3980:WTPA.c        **** 		{
3981:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only change to new values
3982:WTPA.c        **** 			{
3983:WTPA.c        **** 				switch(scaledEncoderValue)
3984:WTPA.c        **** 				{
3985:WTPA.c        **** 					case 0:
3986:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
3987:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3988:WTPA.c        **** 					break;
3989:WTPA.c        **** 
3990:WTPA.c        **** 					case 1:
3991:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
3992:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3993:WTPA.c        **** 					break;
3994:WTPA.c        **** 
3995:WTPA.c        **** 					case 2:
3996:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
3997:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3998:WTPA.c        **** 					break;
3999:WTPA.c        **** 
4000:WTPA.c        **** 					case 3:
4001:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
4002:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4003:WTPA.c        **** 					break;
4004:WTPA.c        **** 
4005:WTPA.c        **** 					default:
4006:WTPA.c        **** 					break;
4007:WTPA.c        **** 				}
4008:WTPA.c        **** 			}
4009:WTPA.c        **** 		}
4010:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
4011:WTPA.c        **** 		{
4012:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
4013:WTPA.c        **** 			{
4014:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
4015:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
4016:WTPA.c        **** 			}
4017:WTPA.c        **** 			else
4018:WTPA.c        **** 			{
4019:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
4020:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
4021:WTPA.c        **** 			}
4022:WTPA.c        **** 
4023:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
4024:WTPA.c        **** 		}
4025:WTPA.c        **** 	}
4026:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4027:WTPA.c        **** 	// Shift 2:
4028:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4029:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
4030:WTPA.c        **** 	{
4031:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
4032:WTPA.c        **** 		{
4033:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
4034:WTPA.c        **** 			{
4035:WTPA.c        **** 				AdjustSampleStart(currentBank,encoderValue);
4036:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
4037:WTPA.c        **** 			}
4038:WTPA.c        **** 		}
4039:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
4040:WTPA.c        **** 		{
4041:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
4042:WTPA.c        **** 			{
4043:WTPA.c        **** 				AdjustSampleEnd(currentBank,encoderValue);
4044:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
4045:WTPA.c        **** 			}
4046:WTPA.c        **** 		}
4047:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
4048:WTPA.c        **** 		{
4049:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
4050:WTPA.c        **** 			{
4051:WTPA.c        **** 				AdjustSampleWindow(currentBank,encoderValue);
4052:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
4053:WTPA.c        **** 			}
4054:WTPA.c        **** 		}
4055:WTPA.c        **** 
4056:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
4057:WTPA.c        **** 		{
4058:WTPA.c        **** //			PlaySampleFromSd(BANK_0,0);		// @@@
4059:WTPA.c        **** 			PlaySampleFromSd(0);			// @@@ stream from slot 0
4060:WTPA.c        **** 
4061:WTPA.c        **** 		}
4062:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)		// Update Jitter
4063:WTPA.c        **** 		{
4064:WTPA.c        **** 			//	bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;		// 
4065:WTPA.c        **** 		}
4066:WTPA.c        **** 	}
4067:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4068:WTPA.c        **** 	// No shift keys pressed:
4069:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4070:WTPA.c        **** 	else	// User isn't holding shift keys, look for single key presses
4071:WTPA.c        **** 	{
4072:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
4073:WTPA.c        **** 		{
4074:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
4075:WTPA.c        **** 			{
4076:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4077:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4078:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4079:WTPA.c        **** 			}
4080:WTPA.c        **** 			else											// We're not recording right now, so start doing it.
4081:WTPA.c        **** 			{
4082:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
4083:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
4084:WTPA.c        **** 			}
4085:WTPA.c        **** 		}
4086:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
4087:WTPA.c        **** 		{
4088:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
4089:WTPA.c        **** 			{
4090:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
4091:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4092:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
4093:WTPA.c        **** 			}
4094:WTPA.c        **** 			else							// We're not recording right now, so start doing it.
4095:WTPA.c        **** 			{
4096:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
4097:WTPA.c        **** 				{
4098:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
4099:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
4100:WTPA.c        **** 				}
4101:WTPA.c        **** 			}
4102:WTPA.c        **** 		}
4103:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
4104:WTPA.c        **** 		{
4105:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4106:WTPA.c        **** 			{
4107:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4108:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4109:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4110:WTPA.c        **** 			}
4111:WTPA.c        **** 		}
4112:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
4113:WTPA.c        **** 		{
4114:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4115:WTPA.c        **** 			{
4116:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
4117:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
4118:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4119:WTPA.c        **** 			}
4120:WTPA.c        **** 		}
4121:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
4122:WTPA.c        **** 		{
4123:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
4124:WTPA.c        **** 			{
4125:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4126:WTPA.c        **** 				{
4127:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
4128:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
4129:WTPA.c        **** 				}
4130:WTPA.c        **** 			}
4131:WTPA.c        **** 			else		// Pause whatever we were doing.
4132:WTPA.c        **** 			{
4133:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
4134:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
4135:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
4136:WTPA.c        **** 			}
4137:WTPA.c        **** 
4138:WTPA.c        **** 		}
4139:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
4140:WTPA.c        **** 		{
4141:WTPA.c        **** 			currentBank++;
4142:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
4143:WTPA.c        **** 			{
4144:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
4145:WTPA.c        **** 			}
4146:WTPA.c        **** 		}
4147:WTPA.c        **** 	}
4148:WTPA.c        **** 
4149:WTPA.c        **** 	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
4150:WTPA.c        **** }
4151:WTPA.c        **** 
4152:WTPA.c        **** static void DoSampler(void)
4153:WTPA.c        **** // This state is the font from which all sampler bullshit flows.
4154:WTPA.c        **** // As WTPA stands now, the switches all basically retain the same functions regardless of what the 
4155:WTPA.c        **** // Same goes for the LEDs.  So we've gotten rid of a modal system and now just watch for commands v
4156:WTPA.c        **** // Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do somethi
4157:WTPA.c        **** // power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be 
4158:WTPA.c        **** 
4159:WTPA.c        **** // Wed Apr  8 11:42:07 CDT 2009
4160:WTPA.c        **** // This state is based on the idea that playing, recording, and overdubbing are all discrete things
4161:WTPA.c        **** {
4162:WTPA.c        **** 	unsigned char
4163:WTPA.c        **** 		i;
4164:WTPA.c        **** 
4165:WTPA.c        **** 	static MIDI_MESSAGE
4166:WTPA.c        **** 		currentMidiMessage;				// Used to point to incoming midi messages.
4167:WTPA.c        **** 
4168:WTPA.c        **** 	static unsigned char
4169:WTPA.c        **** 		currentNoteOn[NUM_BANKS]=		// Used to keep track of what notes we've got on in MIDI.
4170:WTPA.c        **** 		{
4171:WTPA.c        **** 			60,							// In case we record, then overdub immediately without playing anything, we'll need a 
4172:WTPA.c        **** 			60,
4173:WTPA.c        **** 		};
4174:WTPA.c        **** 
4175:WTPA.c        **** 	static bool
4176:WTPA.c        **** 		realtimeOn[NUM_BANKS];			// Used in MIDI to carry the realtime processing across a NOTE_OFF.
4177:WTPA.c        **** 
4178:WTPA.c        **** 	unsigned int
4179:WTPA.c        **** 		pitchWheelValue;				// Figures out what to do with the pitchbend data.
4180:WTPA.c        **** 
4181:WTPA.c        **** //	static bool
4182:WTPA.c        **** //		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we
4183:WTPA.c        **** 
4184:WTPA.c        **** 	if(subState==SS_0)
4185:WTPA.c        **** 	// Initialize everything.
4186:WTPA.c        **** 	{
4187:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
4188:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
4189:WTPA.c        **** 		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardco
4190:WTPA.c        **** 		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardco
4191:WTPA.c        **** 
4192:WTPA.c        **** 		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
4193:WTPA.c        **** 		{
4194:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
4195:WTPA.c        **** 			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet
4196:WTPA.c        **** 			bankStates[i].loopOnce=false;
4197:WTPA.c        **** 			bankStates[i].bitReduction=0;				// No crusties yet.
4198:WTPA.c        **** 			bankStates[i].jitterValue=0;				// No hissies yet.
4199:WTPA.c        **** 			bankStates[i].granularSlices=0;				// No remix yet.
4200:WTPA.c        **** 			bankStates[i].halfSpeed=false;
4201:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
4202:WTPA.c        **** 			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
4203:WTPA.c        **** 			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beg
4204:WTPA.c        **** 			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sa
4205:WTPA.c        **** 			realtimeOn[i]=false;								// We'll default to playback.
4206:WTPA.c        **** 			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
4207:WTPA.c        **** //			editModeEntered=false;
4208:WTPA.c        **** 
4209:WTPA.c        **** 			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
4210:WTPA.c        **** 
4211:WTPA.c        **** 			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
4212:WTPA.c        **** 			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful num
4213:WTPA.c        **** 		}
4214:WTPA.c        **** 
4215:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4216:WTPA.c        **** 
4217:WTPA.c        **** 		currentBank=BANK_0;			// Point at the first bank until we change banks.
4218:WTPA.c        **** 
4219:WTPA.c        **** 		KillLeds();					// All leds off, and no blinking.
4220:WTPA.c        **** 		subState=SS_1;
4221:WTPA.c        **** 	}
4222:WTPA.c        **** 
4223:WTPA.c        **** 	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different s
4224:WTPA.c        **** 	{
4225:WTPA.c        **** 		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI
4226:WTPA.c        **** 
4227:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
4228:WTPA.c        **** 		{
4229:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
4230:WTPA.c        **** /*
4231:WTPA.c        **** 			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
4232:WTPA.c        **** 			{
4233:WTPA.c        **** 				// Do this here.
4234:WTPA.c        **** 			}
4235:WTPA.c        **** */
4236:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
4237:WTPA.c        **** 			{
4238:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
4239:WTPA.c        **** 				{
4240:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
4241:WTPA.c        **** 					{
4242:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
4243:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
4244:WTPA.c        **** 					}
4245:WTPA.c        **** 				}
4246:WTPA.c        **** 			}
4247:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
4248:WTPA.c        **** 			{
4249:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
4250:WTPA.c        **** 
4251:WTPA.c        **** 				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
4252:WTPA.c        **** 				{
4253:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
4254:WTPA.c        **** 				}
4255:WTPA.c        **** 				else
4256:WTPA.c        **** 				{
4257:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
4258:WTPA.c        **** 					{
4259:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
4260:WTPA.c        **** 					}
4261:WTPA.c        **** 				}
4262:WTPA.c        **** 			}
4263:WTPA.c        **** 
4264:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
4265:WTPA.c        **** 			{
4266:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
4267:WTPA.c        **** 				{
4268:WTPA.c        **** 					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
4269:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4270:WTPA.c        **** 					{
4271:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
4272:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback 
4273:WTPA.c        **** 					}
4274:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
4275:WTPA.c        **** 					{
4276:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4277:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4278:WTPA.c        **** 					}
4279:WTPA.c        **** 					break;
4280:WTPA.c        **** 
4281:WTPA.c        **** 					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
4282:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4283:WTPA.c        **** 					{
4284:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
4285:WTPA.c        **** 						{
4286:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
4287:WTPA.c        **** 							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to pla
4288:WTPA.c        **** 						}
4289:WTPA.c        **** 					}
4290:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
4291:WTPA.c        **** 					{
4292:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
4293:WTPA.c        **** 					}
4294:WTPA.c        **** 					break;
4295:WTPA.c        **** 
4296:WTPA.c        **** 					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
4297:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4298:WTPA.c        **** 					{
4299:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
4300:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop 
4301:WTPA.c        **** 					}
4302:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
4303:WTPA.c        **** 					{
4304:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4305:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4306:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
4307:WTPA.c        **** 					}
4308:WTPA.c        **** 
4309:WTPA.c        **** 					break;
4310:WTPA.c        **** 
4311:WTPA.c        **** 					case MIDI_LOOP:							// Keep playing samples over again until note off.
4312:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4313:WTPA.c        **** 					{
4314:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4315:WTPA.c        **** 					}
4316:WTPA.c        **** 					else
4317:WTPA.c        **** 					{
4318:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
4319:WTPA.c        **** 					}
4320:WTPA.c        **** 					break;
4321:WTPA.c        **** 
4322:WTPA.c        **** 					case MIDI_HALF_SPEED:							// Skrew and chop.
4323:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4324:WTPA.c        **** 					{
4325:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
4326:WTPA.c        **** 					}
4327:WTPA.c        **** 					else
4328:WTPA.c        **** 					{
4329:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4330:WTPA.c        **** 					}
4331:WTPA.c        **** 					break;
4332:WTPA.c        **** 
4333:WTPA.c        **** 					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
4334:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4335:WTPA.c        **** 					{
4336:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
4337:WTPA.c        **** 					}
4338:WTPA.c        **** 					else
4339:WTPA.c        **** 					{
4340:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4341:WTPA.c        **** 					}
4342:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
4343:WTPA.c        **** 					break;
4344:WTPA.c        **** 
4345:WTPA.c        **** 					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
4346:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4347:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
4348:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
4349:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
4350:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4351:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4352:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4353:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4354:WTPA.c        **** 					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
4355:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4356:WTPA.c        **** 					break;
4357:WTPA.c        **** 
4358:WTPA.c        **** 					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
4359:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
4360:WTPA.c        **** 					{
4361:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
4362:WTPA.c        **** 					}
4363:WTPA.c        **** 					break;
4364:WTPA.c        **** 
4365:WTPA.c        **** 					case MIDI_GRANULARITY:						// Beatbox.
4366:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4367:WTPA.c        **** 					break;
4368:WTPA.c        **** 
4369:WTPA.c        **** 					case MIDI_JITTER:							// Hisssss
4370:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
4371:WTPA.c        **** 					break;
4372:WTPA.c        **** 
4373:WTPA.c        **** 					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
4374:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
4375:WTPA.c        **** 					{
4376:WTPA.c        **** 						case 0:
4377:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
4378:WTPA.c        **** 						break;
4379:WTPA.c        **** 
4380:WTPA.c        **** 						case 1:
4381:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
4382:WTPA.c        **** 						break;
4383:WTPA.c        **** 
4384:WTPA.c        **** 						case 2:
4385:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
4386:WTPA.c        **** 						break;
4387:WTPA.c        **** 
4388:WTPA.c        **** 						case 3:
4389:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
4390:WTPA.c        **** 						break;
4391:WTPA.c        **** 
4392:WTPA.c        **** 						default:
4393:WTPA.c        **** 						break;
4394:WTPA.c        **** 					}
4395:WTPA.c        **** 					break;
4396:WTPA.c        **** 
4397:WTPA.c        **** 					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
4398:WTPA.c        **** 					i=SREG;
4399:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
4400:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
4401:WTPA.c        **** 					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelN
4402:WTPA.c        **** 					SREG=i;		// Re-enable interrupts.
4403:WTPA.c        **** 					break;
4404:WTPA.c        **** 
4405:WTPA.c        **** //	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-siz
4406:WTPA.c        **** 
4407:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
4408:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4409:WTPA.c        **** 					break;
4410:WTPA.c        **** 
4411:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
4412:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4413:WTPA.c        **** 					break;
4414:WTPA.c        **** 
4415:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
4416:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4417:WTPA.c        **** 					break;
4418:WTPA.c        **** 
4419:WTPA.c        **** 					case MIDI_REVERT_SAMPLE_TO_FULL:
4420:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
4421:WTPA.c        **** 					break;
4422:WTPA.c        **** 
4423:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_WIDE:
4424:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4425:WTPA.c        **** 					break;
4426:WTPA.c        **** 
4427:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_WIDE:
4428:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4429:WTPA.c        **** 					break;
4430:WTPA.c        **** 
4431:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
4432:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4433:WTPA.c        **** 					break;
4434:WTPA.c        **** 
4435:WTPA.c        **** 					default:
4436:WTPA.c        **** 					break;
4437:WTPA.c        **** 				}
4438:WTPA.c        **** 			}
4439:WTPA.c        **** 
4440:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
4441:WTPA.c        **** 			{
4442:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
4443:WTPA.c        **** 
4444:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
4445:WTPA.c        **** 				{
4446:WTPA.c        **** 					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This
4447:WTPA.c        **** 					{
4448:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4449:WTPA.c        **** 					}
4450:WTPA.c        **** 					else						// Pitch the note by some amount (add value to the OCR1A).
4451:WTPA.c        **** 					{
4452:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4453:WTPA.c        **** 					}
4454:WTPA.c        **** 				}
4455:WTPA.c        **** 				else
4456:WTPA.c        **** 				{
4457:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
4458:WTPA.c        **** 				}
4459:WTPA.c        **** 			}
4460:WTPA.c        **** 		}
4461:WTPA.c        **** 	}
4462:WTPA.c        **** 
4463:WTPA.c        **** //	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle clo
4464:WTPA.c        **** 	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Voi
4465:WTPA.c        **** 	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
4466:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
4467:WTPA.c        **** }
4468:WTPA.c        **** 
4469:WTPA.c        **** //--------------------------------------
4470:WTPA.c        **** //--------------------------------------
4471:WTPA.c        **** // DAC Testing.
4472:WTPA.c        **** //--------------------------------------
4473:WTPA.c        **** //--------------------------------------
4474:WTPA.c        **** 
4475:WTPA.c        **** static void DoSawtooth(void)
4476:WTPA.c        **** // See if we can get some audio out.  And look good doing it.
4477:WTPA.c        **** // Also test to see if our flash is present and working.
4478:WTPA.c        **** {
4479:WTPA.c        **** 	static unsigned char
4480:WTPA.c        **** 		lastShuttleRead;
4481:WTPA.c        **** 
4482:WTPA.c        **** 	if(subState==SS_0)
4483:WTPA.c        **** 	{
4484:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
4485:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
4486:WTPA.c        **** 		subState=SS_1;
4487:WTPA.c        **** 	}
4488:WTPA.c        **** 	else if(subState==SS_1)
4489:WTPA.c        **** 	{
4490:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4491:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
4492:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
4493:WTPA.c        **** 		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
4494:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4495:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4496:WTPA.c        **** 
4497:WTPA.c        **** 		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the 
4498:WTPA.c        **** 
4499:WTPA.c        **** 		subState=SS_2;					// And wait forever.
4500:WTPA.c        **** 	}
4501:WTPA.c        **** 	else if(subState==SS_2)
4502:WTPA.c        **** 	{
4503:WTPA.c        **** 
4504:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4505:WTPA.c        **** 		{
4506:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
4507:WTPA.c        **** 		}
4508:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4509:WTPA.c        **** 		{
4510:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
4511:WTPA.c        **** 		}
4512:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
4513:WTPA.c        **** 		{
4514:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
4515:WTPA.c        **** 		}
4516:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
4517:WTPA.c        **** 		{
4518:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
4519:WTPA.c        **** 		}
4520:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
4521:WTPA.c        **** 		{
4522:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
4523:WTPA.c        **** 		}
4524:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
4525:WTPA.c        **** 		{
4526:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
4527:WTPA.c        **** 		}
4528:WTPA.c        **** 
4529:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
4530:WTPA.c        **** 		{
4531:WTPA.c        **** 			StopBlinking();
4532:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
4533:WTPA.c        **** 		}
4534:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
4535:WTPA.c        **** 		{
4536:WTPA.c        **** 			StopBlinking();
4537:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
4538:WTPA.c        **** 		}
4539:WTPA.c        **** 		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new v
4540:WTPA.c        **** 		{
4541:WTPA.c        **** 			StopBlinking();
4542:WTPA.c        **** 			ledOnOffMask=encoderValue;
4543:WTPA.c        **** 			lastShuttleRead=encoderValue;
4544:WTPA.c        **** 		}
4545:WTPA.c        **** 	}
4546:WTPA.c        **** }
4547:WTPA.c        **** 
4548:WTPA.c        **** /*
4549:WTPA.c        **** static void MidiOutputTestBinnis(void)
4550:WTPA.c        **** {
4551:WTPA.c        **** 	if(subState==SS_0)
4552:WTPA.c        **** 	{
4553:WTPA.c        **** 		midiChannelNumberA=0x01;			// @@@ Hardcoded midi channel for now.
4554:WTPA.c        **** 		midiChannelNumberB=0x02;			// @@@ Hardcoded midi channel for now.
4555:WTPA.c        **** 		StopReadingPot();				// Make sure this silly business is gone (for now)
4556:WTPA.c        **** 		KillLeds();						// All leds off, and no blinking.
4557:WTPA.c        **** 		subState=SS_1;
4558:WTPA.c        **** 	}
4559:WTPA.c        **** 	else
4560:WTPA.c        **** 	{
4561:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4562:WTPA.c        **** 		{
4563:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_0));	// Toggle the LED.
4564:WTPA.c        **** 			// Hardcoded Note On, middle C, Velocity 64, Midi channel 1.
4565:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4566:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4567:WTPA.c        **** 			Uart0SendByte(64);			// @@@
4568:WTPA.c        **** 
4569:WTPA.c        **** 		}
4570:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4571:WTPA.c        **** 		{
4572:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_1));	// Toggle the LED.
4573:WTPA.c        **** 			// Hardcoded Note Off, middle C, Velocity 0, Midi channel 1.
4574:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4575:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4576:WTPA.c        **** 			Uart0SendByte(0);			// @@@
4577:WTPA.c        **** 		}
4578:WTPA.c        **** 	}
4579:WTPA.c        **** }
4580:WTPA.c        **** */
4581:WTPA.c        **** 
4582:WTPA.c        **** 
4583:WTPA.c        **** static void SetMidiChannels(void)
4584:WTPA.c        **** // This is a state the user can enter at startup where they set and store desired midi channels usi
4585:WTPA.c        **** {
4586:WTPA.c        **** 	if(subState==SS_0)
4587:WTPA.c        **** 	{
4588:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
4589:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
4590:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
4591:WTPA.c        **** 		subState=SS_1;
4592:WTPA.c        **** 	}
4593:WTPA.c        **** 	else
4594:WTPA.c        **** 	{
4595:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4596:WTPA.c        **** 		{
4597:WTPA.c        **** 			midiChannelNumberA++;
4598:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
4599:WTPA.c        **** 			{
4600:WTPA.c        **** 				midiChannelNumberA=0;
4601:WTPA.c        **** 			}
4602:WTPA.c        **** 
4603:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
4604:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
4605:WTPA.c        **** 		}
4606:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4607:WTPA.c        **** 		{
4608:WTPA.c        **** 			midiChannelNumberB++;
4609:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
4610:WTPA.c        **** 			{
4611:WTPA.c        **** 				midiChannelNumberB=0;
4612:WTPA.c        **** 			}
4613:WTPA.c        **** 
4614:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
4615:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
4616:WTPA.c        **** 		}
4617:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
4618:WTPA.c        **** 		{
4619:WTPA.c        **** 			StoreMidiChannel(BANK_0,midiChannelNumberA);
4620:WTPA.c        **** 			StoreMidiChannel(BANK_1,midiChannelNumberB);
4621:WTPA.c        **** 			SetState(DoSampler);
4622:WTPA.c        **** 		}
4623:WTPA.c        **** 	}
4624:WTPA.c        **** }
4625:WTPA.c        **** 
4626:WTPA.c        **** static void DoStartupSelect(void)
4627:WTPA.c        **** // Make all our initial state decisions.
4628:WTPA.c        **** // Give switches time to settle.
4629:WTPA.c        **** {
4630:WTPA.c        **** 	if(subState==SS_0)
4631:WTPA.c        **** 	{
4632:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
4633:WTPA.c        **** 		subState=SS_1;
4634:WTPA.c        **** 	}
4635:WTPA.c        **** 	else
4636:WTPA.c        **** 	{
4637:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4638:WTPA.c        **** 		{
4639:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
4640:WTPA.c        **** 			{
4641:WTPA.c        **** 				SetState(DoSawtooth);
4642:WTPA.c        **** 			}
4643:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
4644:WTPA.c        **** 			{
4645:WTPA.c        **** 				SetState(SetMidiChannels);
4646:WTPA.c        **** 			}
4647:WTPA.c        **** 			else
4648:WTPA.c        **** 			{
4649:WTPA.c        **** 				SetState(DoSampler);
4650:WTPA.c        **** 			}
4651:WTPA.c        **** 		}
4652:WTPA.c        **** 	}
4653:WTPA.c        **** }
4654:WTPA.c        **** 
4655:WTPA.c        **** static void DoFruitcakeIntro(void)
4656:WTPA.c        **** // Oh god why.
4657:WTPA.c        **** {
 3445               		.loc 1 4657 0
 3446               		.cfi_startproc
 3447 1c04 CF93      		push r28
 3448               	.LCFI32:
 3449               		.cfi_def_cfa_offset 3
 3450               		.cfi_offset 28, -2
 3451               	/* prologue: function */
 3452               	/* frame size = 0 */
 3453               	/* stack size = 1 */
 3454               	.L__stack_usage = 1
4658:WTPA.c        **** 	static unsigned char
4659:WTPA.c        **** 		i;
4660:WTPA.c        **** 
4661:WTPA.c        **** 	if(subState==SS_0)
 3455               		.loc 1 4661 0
 3456 1c06 C091 0000 		lds r28,subState
 3457 1c0a C111      		cpse r28,__zero_reg__
 3458 1c0c 00C0      		rjmp .L189
4662:WTPA.c        **** 	{
4663:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 3459               		.loc 1 4663 0
 3460 1c0e 1092 0000 		sts cardState,__zero_reg__
4664:WTPA.c        **** 
4665:WTPA.c        **** 		KillLeds();
 3461               		.loc 1 4665 0
 3462 1c12 0E94 0000 		call KillLeds
 3463               	.LVL94:
4666:WTPA.c        **** 		i=0;
 3464               		.loc 1 4666 0
 3465 1c16 1092 0000 		sts i.2256,__zero_reg__
4667:WTPA.c        **** 		ledOnOffMask=0;
 3466               		.loc 1 4667 0
 3467 1c1a 1092 0000 		sts ledOnOffMask,__zero_reg__
4668:WTPA.c        **** 		subState=SS_1;
 3468               		.loc 1 4668 0
 3469 1c1e 81E0      		ldi r24,lo8(1)
 3470 1c20 8093 0000 		sts subState,r24
4669:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 3471               		.loc 1 4669 0
 3472 1c24 61E3      		ldi r22,lo8(49)
 3473 1c26 71E0      		ldi r23,lo8(1)
 3474 1c28 80E0      		ldi r24,0
 3475               	/* epilogue start */
4670:WTPA.c        **** 	}
4671:WTPA.c        **** 	else if(subState==SS_1)
4672:WTPA.c        **** 	{
4673:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4674:WTPA.c        **** 		{
4675:WTPA.c        **** 			subState=SS_2;
4676:WTPA.c        **** 		}
4677:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4678:WTPA.c        **** 	}
4679:WTPA.c        **** 
4680:WTPA.c        **** 	else if(subState==SS_2)
4681:WTPA.c        **** 	{
4682:WTPA.c        **** 		if(i<NUM_LEDS)
4683:WTPA.c        **** 		{
4684:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4685:WTPA.c        **** 			{
4686:WTPA.c        **** 				ledOnOffMask|=(1<<i);
4687:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
4688:WTPA.c        **** 				i++;
4689:WTPA.c        **** 			}
4690:WTPA.c        **** 		}
4691:WTPA.c        **** 		else
4692:WTPA.c        **** 		{
4693:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4694:WTPA.c        **** 			{
4695:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
4696:WTPA.c        **** 				ledPwm=255;
4697:WTPA.c        **** 				// Grudgingly enable pwm hackery.
4698:WTPA.c        **** 
4699:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
4700:WTPA.c        **** 
4701:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
4702:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
4703:WTPA.c        **** 				TCNT2=0;			// Init counter reg
4704:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
4705:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
4706:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
4707:WTPA.c        **** 
4708:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
4709:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
4710:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
4711:WTPA.c        **** 
4712:WTPA.c        **** 				subState=SS_3;
4713:WTPA.c        **** 			}
4714:WTPA.c        **** 		}
4715:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4716:WTPA.c        **** 	}
4717:WTPA.c        **** 	else if(subState==SS_3)
4718:WTPA.c        **** 	{
4719:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4720:WTPA.c        **** 		{
4721:WTPA.c        **** 			if(ledPwm>1)
4722:WTPA.c        **** 			{
4723:WTPA.c        **** 				ledPwm-=2;
4724:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
4725:WTPA.c        **** 			}
4726:WTPA.c        **** 			else
4727:WTPA.c        **** 			{
4728:WTPA.c        **** 				// Gleefully disable PWM.
4729:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
4730:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
4731:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
4732:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
4733:WTPA.c        **** 
4734:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
4735:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
4736:WTPA.c        **** 
4737:WTPA.c        **** 				KillLeds();				// App knows leds are off.
4738:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
4739:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
4740:WTPA.c        **** 				subState=SS_4;
4741:WTPA.c        **** 			}
4742:WTPA.c        **** 		}
4743:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4744:WTPA.c        **** 	}
4745:WTPA.c        **** 	else if(subState==SS_4)
4746:WTPA.c        **** 	{
4747:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4748:WTPA.c        **** 		{
4749:WTPA.c        **** 			KillLeds();
4750:WTPA.c        **** 			SetState(DoStartupSelect);		// Get crackin.
4751:WTPA.c        **** 		}
4752:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4753:WTPA.c        **** 	}
4754:WTPA.c        **** }
 3476               		.loc 1 4754 0
 3477 1c2a CF91      		pop r28
4669:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 3478               		.loc 1 4669 0
 3479 1c2c 0C94 0000 		jmp SetTimer
 3480               	.LVL95:
 3481               	.L189:
4671:WTPA.c        **** 	else if(subState==SS_1)
 3482               		.loc 1 4671 0
 3483 1c30 C130      		cpi r28,lo8(1)
 3484 1c32 01F4      		brne .L190
4673:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3485               		.loc 1 4673 0
 3486 1c34 80E0      		ldi r24,0
 3487 1c36 0E94 0000 		call CheckTimer
 3488               	.LVL96:
 3489 1c3a 8823      		tst r24
 3490 1c3c 01F4      		brne .+2
 3491 1c3e 00C0      		rjmp .L201
4675:WTPA.c        **** 			subState=SS_2;
 3492               		.loc 1 4675 0
 3493 1c40 82E0      		ldi r24,lo8(2)
 3494 1c42 00C0      		rjmp .L214
 3495               	.L190:
4680:WTPA.c        **** 	else if(subState==SS_2)
 3496               		.loc 1 4680 0
 3497 1c44 C230      		cpi r28,lo8(2)
 3498 1c46 01F0      		breq .+2
 3499 1c48 00C0      		rjmp .L193
4682:WTPA.c        **** 		if(i<NUM_LEDS)
 3500               		.loc 1 4682 0
 3501 1c4a 8091 0000 		lds r24,i.2256
 3502 1c4e 8830      		cpi r24,lo8(8)
 3503 1c50 00F4      		brsh .L194
4684:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3504               		.loc 1 4684 0
 3505 1c52 80E0      		ldi r24,0
 3506 1c54 0E94 0000 		call CheckTimer
 3507               	.LVL97:
 3508 1c58 8823      		tst r24
 3509 1c5a 01F4      		brne .+2
 3510 1c5c 00C0      		rjmp .L201
4686:WTPA.c        **** 				ledOnOffMask|=(1<<i);
 3511               		.loc 1 4686 0
 3512 1c5e 81E0      		ldi r24,lo8(1)
 3513 1c60 90E0      		ldi r25,0
 3514 1c62 0090 0000 		lds r0,i.2256
 3515 1c66 00C0      		rjmp 2f
 3516               		1:
 3517 1c68 880F      		lsl r24
 3518 1c6a 991F      		rol r25
 3519               		2:
 3520 1c6c 0A94      		dec r0
 3521 1c6e 02F4      		brpl 1b
 3522 1c70 9091 0000 		lds r25,ledOnOffMask
 3523 1c74 982B      		or r25,r24
 3524 1c76 9093 0000 		sts ledOnOffMask,r25
4687:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
 3525               		.loc 1 4687 0
 3526 1c7a 6DE3      		ldi r22,lo8(61)
 3527 1c7c 70E0      		ldi r23,0
 3528 1c7e 80E0      		ldi r24,0
 3529 1c80 0E94 0000 		call SetTimer
 3530               	.LVL98:
4688:WTPA.c        **** 				i++;
 3531               		.loc 1 4688 0
 3532 1c84 8091 0000 		lds r24,i.2256
 3533 1c88 8F5F      		subi r24,lo8(-(1))
 3534 1c8a 8093 0000 		sts i.2256,r24
 3535 1c8e 00C0      		rjmp .L201
 3536               	.L194:
4693:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3537               		.loc 1 4693 0
 3538 1c90 80E0      		ldi r24,0
 3539 1c92 0E94 0000 		call CheckTimer
 3540               	.LVL99:
 3541 1c96 8823      		tst r24
 3542 1c98 01F4      		brne .+2
 3543 1c9a 00C0      		rjmp .L201
4695:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
 3544               		.loc 1 4695 0
 3545 1c9c 68E9      		ldi r22,lo8(-104)
 3546 1c9e 70E0      		ldi r23,0
 3547 1ca0 80E0      		ldi r24,0
 3548 1ca2 0E94 0000 		call SetTimer
 3549               	.LVL100:
4696:WTPA.c        **** 				ledPwm=255;
 3550               		.loc 1 4696 0
 3551 1ca6 8FEF      		ldi r24,lo8(-1)
 3552 1ca8 8093 0000 		sts ledPwm,r24
4699:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 3553               		.loc 1 4699 0
 3554 1cac 9091 6400 		lds r25,100
 3555 1cb0 9F7B      		andi r25,lo8(-65)
 3556 1cb2 9093 6400 		sts 100,r25
4701:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 3557               		.loc 1 4701 0
 3558 1cb6 C093 B000 		sts 176,r28
4702:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
 3559               		.loc 1 4702 0
 3560 1cba 91E0      		ldi r25,lo8(1)
 3561 1cbc 9093 B100 		sts 177,r25
4703:WTPA.c        **** 				TCNT2=0;			// Init counter reg
 3562               		.loc 1 4703 0
 3563 1cc0 1092 B200 		sts 178,__zero_reg__
4704:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
 3564               		.loc 1 4704 0
 3565 1cc4 90E8      		ldi r25,lo8(-128)
 3566 1cc6 9093 B300 		sts 179,r25
4705:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 3567               		.loc 1 4705 0
 3568 1cca 87BB      		out 0x17,r24
4706:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
 3569               		.loc 1 4706 0
 3570 1ccc C093 7000 		sts 112,r28
4708:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
 3571               		.loc 1 4708 0
 3572 1cd0 92B1      		in r25,0x2
 3573 1cd2 9660      		ori r25,lo8(6)
 3574 1cd4 92B9      		out 0x2,r25
4709:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
 3575               		.loc 1 4709 0
 3576 1cd6 84B9      		out 0x4,r24
4710:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
 3577               		.loc 1 4710 0
 3578 1cd8 5F9A      		sbi 0xb,7
4712:WTPA.c        **** 				subState=SS_3;
 3579               		.loc 1 4712 0
 3580 1cda 83E0      		ldi r24,lo8(3)
 3581 1cdc 00C0      		rjmp .L214
 3582               	.L193:
4717:WTPA.c        **** 	else if(subState==SS_3)
 3583               		.loc 1 4717 0
 3584 1cde C330      		cpi r28,lo8(3)
 3585 1ce0 01F4      		brne .L198
4719:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3586               		.loc 1 4719 0
 3587 1ce2 80E0      		ldi r24,0
 3588 1ce4 0E94 0000 		call CheckTimer
 3589               	.LVL101:
 3590 1ce8 8823      		tst r24
 3591 1cea 01F0      		breq .L201
4721:WTPA.c        **** 			if(ledPwm>1)
 3592               		.loc 1 4721 0
 3593 1cec 8091 0000 		lds r24,ledPwm
 3594 1cf0 8230      		cpi r24,lo8(2)
 3595 1cf2 00F0      		brlo .L200
4723:WTPA.c        **** 				ledPwm-=2;
 3596               		.loc 1 4723 0
 3597 1cf4 8091 0000 		lds r24,ledPwm
 3598 1cf8 8250      		subi r24,lo8(-(-2))
 3599 1cfa 8093 0000 		sts ledPwm,r24
4724:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
 3600               		.loc 1 4724 0
 3601 1cfe 64E0      		ldi r22,lo8(4)
 3602 1d00 70E0      		ldi r23,0
 3603 1d02 80E0      		ldi r24,0
 3604 1d04 0E94 0000 		call SetTimer
 3605               	.LVL102:
 3606 1d08 00C0      		rjmp .L201
 3607               	.L200:
4729:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
 3608               		.loc 1 4729 0
 3609 1d0a 1092 7000 		sts 112,__zero_reg__
4730:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
 3610               		.loc 1 4730 0
 3611 1d0e 1092 B000 		sts 176,__zero_reg__
4731:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
 3612               		.loc 1 4731 0
 3613 1d12 1092 B100 		sts 177,__zero_reg__
4732:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
 3614               		.loc 1 4732 0
 3615 1d16 8091 6400 		lds r24,100
 3616 1d1a 8064      		ori r24,lo8(64)
 3617 1d1c 8093 6400 		sts 100,r24
4734:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
 3618               		.loc 1 4734 0
 3619 1d20 15B8      		out 0x5,__zero_reg__
4735:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
 3620               		.loc 1 4735 0
 3621 1d22 5F98      		cbi 0xb,7
4737:WTPA.c        **** 				KillLeds();				// App knows leds are off.
 3622               		.loc 1 4737 0
 3623 1d24 0E94 0000 		call KillLeds
 3624               	.LVL103:
4738:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
 3625               		.loc 1 4738 0
 3626 1d28 82E1      		ldi r24,lo8(18)
 3627 1d2a 8093 0000 		sts ledOnOffMask,r24
4739:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
 3628               		.loc 1 4739 0
 3629 1d2e 62E6      		ldi r22,lo8(98)
 3630 1d30 72E0      		ldi r23,lo8(2)
 3631 1d32 80E0      		ldi r24,0
 3632 1d34 0E94 0000 		call SetTimer
 3633               	.LVL104:
4740:WTPA.c        **** 				subState=SS_4;
 3634               		.loc 1 4740 0
 3635 1d38 84E0      		ldi r24,lo8(4)
 3636               	.L214:
 3637 1d3a 8093 0000 		sts subState,r24
 3638 1d3e 00C0      		rjmp .L201
 3639               	.L198:
4745:WTPA.c        **** 	else if(subState==SS_4)
 3640               		.loc 1 4745 0
 3641 1d40 C430      		cpi r28,lo8(4)
 3642 1d42 01F4      		brne .L188
4747:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3643               		.loc 1 4747 0
 3644 1d44 80E0      		ldi r24,0
 3645 1d46 0E94 0000 		call CheckTimer
 3646               	.LVL105:
 3647 1d4a 8823      		tst r24
 3648 1d4c 01F0      		breq .L201
4749:WTPA.c        **** 			KillLeds();
 3649               		.loc 1 4749 0
 3650 1d4e 0E94 0000 		call KillLeds
 3651               	.LVL106:
 3652               	.LBB48:
 3653               	.LBB49:
1426:WTPA.c        **** 	State=newState;
 3654               		.loc 1 1426 0
 3655 1d52 80E0      		ldi r24,lo8(gs(DoStartupSelect))
 3656 1d54 90E0      		ldi r25,hi8(gs(DoStartupSelect))
 3657 1d56 9093 0000 		sts State+1,r25
 3658 1d5a 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 3659               		.loc 1 1427 0
 3660 1d5e 1092 0000 		sts subState,__zero_reg__
 3661               	.LVL107:
 3662               	.L201:
 3663               	.LBE49:
 3664               	.LBE48:
4752:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 3665               		.loc 1 4752 0
 3666 1d62 1092 0000 		sts cardState,__zero_reg__
 3667               	.L188:
 3668               	/* epilogue start */
 3669               		.loc 1 4754 0
 3670 1d66 CF91      		pop r28
 3671 1d68 0895      		ret
 3672               		.cfi_endproc
 3673               	.LFE72:
 3676               	ResetSdCard:
 3677               	.LFB42:
2322:WTPA.c        **** {
 3678               		.loc 1 2322 0
 3679               		.cfi_startproc
 3680 1d6a CF93      		push r28
 3681               	.LCFI33:
 3682               		.cfi_def_cfa_offset 3
 3683               		.cfi_offset 28, -2
 3684               	/* prologue: function */
 3685               	/* frame size = 0 */
 3686               	/* stack size = 1 */
 3687               	.L__stack_usage = 1
2326:WTPA.c        **** 	sreg=SREG;
 3688               		.loc 1 2326 0
 3689 1d6c CFB7      		in r28,__SREG__
 3690               	.LVL108:
2327:WTPA.c        **** 	cli();
 3691               		.loc 1 2327 0
 3692               	/* #APP */
 3693               	 ;  2327 "WTPA.c" 1
 3694 1d6e F894      		cli
 3695               	 ;  0 "" 2
2329:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 3696               		.loc 1 2329 0
 3697               	/* #NOAPP */
 3698 1d70 0E94 0000 		call EndSdTransfer
 3699               	.LVL109:
 3700 1d74 E0E0      		ldi r30,lo8(sampleToc)
 3701 1d76 F0E0      		ldi r31,hi8(sampleToc)
 3702               	.LVL110:
 3703               	.L216:
 3704               	.LBB52:
 3705               	.LBB53:
2061:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 3706               		.loc 1 2061 0
 3707 1d78 1192      		st Z+,__zero_reg__
2059:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 3708               		.loc 1 2059 0
 3709 1d7a 80E0      		ldi r24,hi8(sampleToc+64)
 3710 1d7c E030      		cpi r30,lo8(sampleToc+64)
 3711 1d7e F807      		cpc r31,r24
 3712 1d80 01F4      		brne .L216
 3713               	.LBE53:
 3714               	.LBE52:
2334:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 3715               		.loc 1 2334 0
 3716 1d82 1092 0000 		sts sdIsrState,__zero_reg__
2335:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
 3717               		.loc 1 2335 0
 3718 1d86 1092 B100 		sts 177,__zero_reg__
2336:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 3719               		.loc 1 2336 0
 3720 1d8a 8091 7000 		lds r24,112
 3721 1d8e 8B7F      		andi r24,lo8(-5)
 3722 1d90 8093 7000 		sts 112,r24
2339:WTPA.c        **** 	sdStreamOutput=0;
 3723               		.loc 1 2339 0
 3724 1d94 1092 0000 		sts sdStreamOutput,__zero_reg__
2341:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 3725               		.loc 1 2341 0
 3726 1d98 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 3727 1d9c 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2342:WTPA.c        **** 	sdFifoWritePointer=0;
 3728               		.loc 1 2342 0
 3729 1da0 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 3730 1da4 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2343:WTPA.c        **** 	sdBytesInFifo=0;
 3731               		.loc 1 2343 0
 3732 1da8 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 3733 1dac 1092 0000 		sts sdBytesInFifo,__zero_reg__
2345:WTPA.c        **** 	InitSdInterface();
 3734               		.loc 1 2345 0
 3735 1db0 0E94 0000 		call InitSdInterface
 3736               	.LVL111:
2346:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
 3737               		.loc 1 2346 0
 3738 1db4 1092 0000 		sts cardState,__zero_reg__
2348:WTPA.c        **** 	SREG=sreg;
 3739               		.loc 1 2348 0
 3740 1db8 CFBF      		out __SREG__,r28
 3741               	/* epilogue start */
2349:WTPA.c        **** }
 3742               		.loc 1 2349 0
 3743 1dba CF91      		pop r28
 3744               	.LVL112:
 3745 1dbc 0895      		ret
 3746               		.cfi_endproc
 3747               	.LFE42:
 3750               	SdStartSampleRead:
 3751               	.LFB40:
2260:WTPA.c        **** {
 3752               		.loc 1 2260 0
 3753               		.cfi_startproc
 3754               	.LVL113:
 3755 1dbe CF92      		push r12
 3756               	.LCFI34:
 3757               		.cfi_def_cfa_offset 3
 3758               		.cfi_offset 12, -2
 3759 1dc0 DF92      		push r13
 3760               	.LCFI35:
 3761               		.cfi_def_cfa_offset 4
 3762               		.cfi_offset 13, -3
 3763 1dc2 EF92      		push r14
 3764               	.LCFI36:
 3765               		.cfi_def_cfa_offset 5
 3766               		.cfi_offset 14, -4
 3767 1dc4 FF92      		push r15
 3768               	.LCFI37:
 3769               		.cfi_def_cfa_offset 6
 3770               		.cfi_offset 15, -5
 3771 1dc6 CF93      		push r28
 3772               	.LCFI38:
 3773               		.cfi_def_cfa_offset 7
 3774               		.cfi_offset 28, -6
 3775               	/* prologue: function */
 3776               	/* frame size = 0 */
 3777               	/* stack size = 5 */
 3778               	.L__stack_usage = 5
2264:WTPA.c        **** 	sreg=SREG;
 3779               		.loc 1 2264 0
 3780 1dc8 CFB7      		in r28,__SREG__
 3781               	.LVL114:
2265:WTPA.c        **** 	cli();		// Pause ISR
 3782               		.loc 1 2265 0
 3783               	/* #APP */
 3784               	 ;  2265 "WTPA.c" 1
 3785 1dca F894      		cli
 3786               	 ;  0 "" 2
2267:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
 3787               		.loc 1 2267 0
 3788               	/* #NOAPP */
 3789 1dcc 382F      		mov r19,r24
 3790 1dce 330F      		lsl r19
 3791 1dd0 330F      		lsl r19
 3792 1dd2 20E0      		ldi r18,0
 3793 1dd4 6901      		movw r12,r18
 3794 1dd6 8FEF      		ldi r24,-1
 3795 1dd8 C81A      		sub r12,r24
 3796 1dda D80A      		sbc r13,r24
 3797               	.LVL115:
 3798 1ddc E12C      		mov r14,__zero_reg__
 3799 1dde F12C      		mov r15,__zero_reg__
 3800 1de0 C701      		movw r24,r14
 3801 1de2 B601      		movw r22,r12
 3802 1de4 0E94 0000 		call SdBeginSingleBlockRead
 3803               	.LVL116:
 3804 1de8 8130      		cpi r24,lo8(1)
 3805 1dea 01F4      		brne .L219
2269:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
 3806               		.loc 1 2269 0
 3807 1dec C092 0000 		sts sdSampleStartBlock,r12
 3808 1df0 D092 0000 		sts sdSampleStartBlock+1,r13
 3809 1df4 E092 0000 		sts sdSampleStartBlock+2,r14
 3810 1df8 F092 0000 		sts sdSampleStartBlock+3,r15
2270:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
 3811               		.loc 1 2270 0
 3812 1dfc 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 3813 1e00 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2272:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
 3814               		.loc 1 2272 0
 3815 1e04 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 3816 1e08 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2273:WTPA.c        **** 		sdFifoWritePointer=0;
 3817               		.loc 1 2273 0
 3818 1e0c 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 3819 1e10 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2274:WTPA.c        **** 		sdBytesInFifo=0;
 3820               		.loc 1 2274 0
 3821 1e14 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 3822 1e18 1092 0000 		sts sdBytesInFifo,__zero_reg__
2276:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 3823               		.loc 1 2276 0
 3824 1e1c 6AE7      		ldi r22,lo8(122)
 3825 1e1e 70E0      		ldi r23,0
 3826 1e20 83E0      		ldi r24,lo8(3)
 3827 1e22 0E94 0000 		call SetTimer
 3828               	.LVL117:
2277:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
 3829               		.loc 1 2277 0
 3830 1e26 89E0      		ldi r24,lo8(9)
 3831 1e28 8093 0000 		sts cardState,r24
2279:WTPA.c        **** 		SREG=sreg;	// Resume ISR
 3832               		.loc 1 2279 0
 3833 1e2c CFBF      		out __SREG__,r28
2281:WTPA.c        **** 		return(true);
 3834               		.loc 1 2281 0
 3835 1e2e 81E0      		ldi r24,lo8(1)
 3836 1e30 00C0      		rjmp .L220
 3837               	.L219:
2283:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 3838               		.loc 1 2283 0
 3839 1e32 CFBF      		out __SREG__,r28
2284:WTPA.c        **** 	return(false);
 3840               		.loc 1 2284 0
 3841 1e34 80E0      		ldi r24,0
 3842               	.L220:
 3843               	/* epilogue start */
2285:WTPA.c        **** }
 3844               		.loc 1 2285 0
 3845 1e36 CF91      		pop r28
 3846               	.LVL118:
 3847 1e38 FF90      		pop r15
 3848 1e3a EF90      		pop r14
 3849 1e3c DF90      		pop r13
 3850 1e3e CF90      		pop r12
 3851 1e40 0895      		ret
 3852               		.cfi_endproc
 3853               	.LFE40:
 3856               	SetSampleClock.part.0:
 3857               	.LFB74:
1817:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
 3858               		.loc 1 1817 0
 3859               		.cfi_startproc
 3860               	/* prologue: function */
 3861               	/* frame size = 0 */
 3862               	/* stack size = 0 */
 3863               	.L__stack_usage = 0
1846:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 3864               		.loc 1 1846 0
 3865 1e42 E1E8      		ldi r30,lo8(-127)
 3866 1e44 F0E0      		ldi r31,0
 3867 1e46 8081      		ld r24,Z
 3868 1e48 8064      		ori r24,lo8(64)
 3869 1e4a 8083      		st Z,r24
1847:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 3870               		.loc 1 1847 0
 3871 1e4c B59A      		sbi 0x16,5
1848:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 3872               		.loc 1 1848 0
 3873 1e4e EFE6      		ldi r30,lo8(111)
 3874 1e50 F0E0      		ldi r31,0
 3875 1e52 8081      		ld r24,Z
 3876 1e54 8062      		ori r24,lo8(32)
 3877 1e56 8083      		st Z,r24
 3878 1e58 0895      		ret
 3879               		.cfi_endproc
 3880               	.LFE74:
 3883               	SetSampleClock:
 3884               	.LFB28:
1820:WTPA.c        **** {
 3885               		.loc 1 1820 0
 3886               		.cfi_startproc
 3887               	.LVL119:
 3888               	/* prologue: function */
 3889               	/* frame size = 0 */
 3890               	/* stack size = 0 */
 3891               	.L__stack_usage = 0
1821:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 3892               		.loc 1 1821 0
 3893 1e5a 93E2      		ldi r25,lo8(35)
 3894 1e5c 899F      		mul r24,r25
 3895 1e5e F001      		movw r30,r0
 3896 1e60 1124      		clr __zero_reg__
 3897 1e62 E050      		subi r30,lo8(-(bankStates))
 3898 1e64 F040      		sbci r31,hi8(-(bankStates))
 3899 1e66 6187      		std Z+9,r22
1823:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
 3900               		.loc 1 1823 0
 3901 1e68 6230      		cpi r22,lo8(2)
 3902 1e6a 01F4      		brne .L223
1825:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 3903               		.loc 1 1825 0
 3904 1e6c 5387      		std Z+11,r21
 3905 1e6e 4287      		std Z+10,r20
1827:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 3906               		.loc 1 1827 0
 3907 1e70 8111      		cpse r24,__zero_reg__
 3908 1e72 00C0      		rjmp .L224
1829:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3909               		.loc 1 1829 0
 3910 1e74 8091 8400 		lds r24,132
 3911 1e78 9091 8500 		lds r25,132+1
 3912               	.LVL120:
 3913 1e7c 840F      		add r24,r20
 3914 1e7e 951F      		adc r25,r21
 3915 1e80 9093 8900 		sts 136+1,r25
 3916 1e84 8093 8800 		sts 136,r24
1830:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 3917               		.loc 1 1830 0
 3918 1e88 B19A      		sbi 0x16,1
1831:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 3919               		.loc 1 1831 0
 3920 1e8a 8091 6F00 		lds r24,111
 3921 1e8e 8260      		ori r24,lo8(2)
 3922 1e90 00C0      		rjmp .L227
 3923               	.LVL121:
 3924               	.L224:
1836:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3925               		.loc 1 1836 0
 3926 1e92 8091 8400 		lds r24,132
 3927 1e96 9091 8500 		lds r25,132+1
 3928               	.LVL122:
 3929 1e9a 840F      		add r24,r20
 3930 1e9c 951F      		adc r25,r21
 3931 1e9e 9093 8B00 		sts 138+1,r25
 3932 1ea2 8093 8A00 		sts 138,r24
1837:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 3933               		.loc 1 1837 0
 3934 1ea6 B29A      		sbi 0x16,2
1838:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 3935               		.loc 1 1838 0
 3936 1ea8 8091 6F00 		lds r24,111
 3937 1eac 8460      		ori r24,lo8(4)
 3938               	.L227:
 3939 1eae 8093 6F00 		sts 111,r24
1839:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 3940               		.loc 1 1839 0
 3941 1eb2 81E0      		ldi r24,lo8(1)
 3942 1eb4 8093 8100 		sts 129,r24
 3943 1eb8 0895      		ret
 3944               	.LVL123:
 3945               	.L223:
1842:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
 3946               		.loc 1 1842 0
 3947 1eba 6130      		cpi r22,lo8(1)
 3948 1ebc 01F4      		brne .L222
1844:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 3949               		.loc 1 1844 0
 3950 1ebe 8111      		cpse r24,__zero_reg__
 3951 1ec0 00C0      		rjmp .L226
 3952 1ec2 0C94 0000 		jmp SetSampleClock.part.0
 3953               	.LVL124:
 3954               	.L226:
1852:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 3955               		.loc 1 1852 0
 3956 1ec6 DA9A      		sbi 0x1b,2
1853:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 3957               		.loc 1 1853 0
 3958 1ec8 84E0      		ldi r24,lo8(4)
 3959               	.LVL125:
 3960 1eca 8093 6800 		sts 104,r24
1854:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 3961               		.loc 1 1854 0
 3962 1ece 80E1      		ldi r24,lo8(16)
 3963 1ed0 8093 6D00 		sts 109,r24
 3964               	.L222:
 3965 1ed4 0895      		ret
 3966               		.cfi_endproc
 3967               	.LFE28:
 3970               	StartPlayback:
 3971               	.LFB30:
1904:WTPA.c        **** {
 3972               		.loc 1 1904 0
 3973               		.cfi_startproc
 3974               	.LVL126:
 3975 1ed6 FF92      		push r15
 3976               	.LCFI39:
 3977               		.cfi_def_cfa_offset 3
 3978               		.cfi_offset 15, -2
 3979 1ed8 0F93      		push r16
 3980               	.LCFI40:
 3981               		.cfi_def_cfa_offset 4
 3982               		.cfi_offset 16, -3
 3983 1eda 1F93      		push r17
 3984               	.LCFI41:
 3985               		.cfi_def_cfa_offset 5
 3986               		.cfi_offset 17, -4
 3987 1edc CF93      		push r28
 3988               	.LCFI42:
 3989               		.cfi_def_cfa_offset 6
 3990               		.cfi_offset 28, -5
 3991 1ede DF93      		push r29
 3992               	.LCFI43:
 3993               		.cfi_def_cfa_offset 7
 3994               		.cfi_offset 29, -6
 3995               	/* prologue: function */
 3996               	/* frame size = 0 */
 3997               	/* stack size = 5 */
 3998               	.L__stack_usage = 5
1908:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 3999               		.loc 1 1908 0
 4000 1ee0 C82F      		mov r28,r24
 4001 1ee2 D0E0      		ldi r29,0
 4002 1ee4 93E2      		ldi r25,lo8(35)
 4003 1ee6 899F      		mul r24,r25
 4004 1ee8 F001      		movw r30,r0
 4005 1eea 1124      		clr __zero_reg__
 4006 1eec E050      		subi r30,lo8(-(bankStates))
 4007 1eee F040      		sbci r31,hi8(-(bankStates))
 4008 1ef0 9581      		ldd r25,Z+5
 4009 1ef2 9923      		tst r25
 4010 1ef4 01F0      		breq .L229
1908:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4011               		.loc 1 1908 0 is_stmt 0 discriminator 1
 4012 1ef6 9091 0000 		lds r25,sdIsrState
 4013 1efa 9150      		subi r25,lo8(-(-1))
 4014 1efc 9230      		cpi r25,lo8(2)
 4015 1efe 00F0      		brlo .L228
 4016               	.L229:
1910:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4017               		.loc 1 1910 0 is_stmt 1
 4018 1f00 FFB6      		in r15,__SREG__
 4019               	.LVL127:
1911:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4020               		.loc 1 1911 0
 4021               	/* #APP */
 4022               	 ;  1911 "WTPA.c" 1
 4023 1f02 F894      		cli
 4024               	 ;  0 "" 2
1913:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 4025               		.loc 1 1913 0
 4026               	/* #NOAPP */
 4027 1f04 93E2      		ldi r25,lo8(35)
 4028 1f06 9C9F      		mul r25,r28
 4029 1f08 F001      		movw r30,r0
 4030 1f0a 9D9F      		mul r25,r29
 4031 1f0c F00D      		add r31,r0
 4032 1f0e 1124      		clr __zero_reg__
 4033 1f10 E050      		subi r30,lo8(-(bankStates))
 4034 1f12 F040      		sbci r31,hi8(-(bankStates))
 4035 1f14 94E0      		ldi r25,lo8(4)
 4036 1f16 9083      		st Z,r25
1915:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 4037               		.loc 1 1915 0
 4038 1f18 9381      		ldd r25,Z+3
 4039 1f1a 9923      		tst r25
 4040 1f1c 01F0      		breq .L231
1917:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 4041               		.loc 1 1917 0
 4042 1f1e 0489      		ldd r16,Z+20
 4043 1f20 1589      		ldd r17,Z+21
 4044 1f22 2689      		ldd r18,Z+22
 4045 1f24 3789      		ldd r19,Z+23
 4046 1f26 078F      		std Z+31,r16
 4047 1f28 10A3      		std Z+32,r17
 4048 1f2a 21A3      		std Z+33,r18
 4049 1f2c 32A3      		std Z+34,r19
1918:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 4050               		.loc 1 1918 0
 4051 1f2e 1482      		std Z+4,__zero_reg__
 4052 1f30 00C0      		rjmp .L232
 4053               	.L231:
1922:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 4054               		.loc 1 1922 0
 4055 1f32 008D      		ldd r16,Z+24
 4056 1f34 118D      		ldd r17,Z+25
 4057 1f36 228D      		ldd r18,Z+26
 4058 1f38 338D      		ldd r19,Z+27
 4059 1f3a 078F      		std Z+31,r16
 4060 1f3c 10A3      		std Z+32,r17
 4061 1f3e 21A3      		std Z+33,r18
 4062 1f40 32A3      		std Z+34,r19
1923:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 4063               		.loc 1 1923 0
 4064 1f42 91E0      		ldi r25,lo8(1)
 4065 1f44 9483      		std Z+4,r25
 4066               	.L232:
1926:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 4067               		.loc 1 1926 0
 4068 1f46 0E94 0000 		call SetSampleClock
 4069               	.LVL128:
1927:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4070               		.loc 1 1927 0
 4071 1f4a 83E2      		ldi r24,lo8(35)
 4072 1f4c 8C9F      		mul r24,r28
 4073 1f4e F001      		movw r30,r0
 4074 1f50 8D9F      		mul r24,r29
 4075 1f52 F00D      		add r31,r0
 4076 1f54 1124      		clr __zero_reg__
 4077 1f56 E050      		subi r30,lo8(-(bankStates))
 4078 1f58 F040      		sbci r31,hi8(-(bankStates))
 4079 1f5a 81E0      		ldi r24,lo8(1)
 4080 1f5c 8583      		std Z+5,r24
1928:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4081               		.loc 1 1928 0
 4082 1f5e FFBE      		out __SREG__,r15
 4083               	.LVL129:
 4084               	.L228:
 4085               	/* epilogue start */
1930:WTPA.c        **** }
 4086               		.loc 1 1930 0
 4087 1f60 DF91      		pop r29
 4088 1f62 CF91      		pop r28
 4089               	.LVL130:
 4090 1f64 1F91      		pop r17
 4091 1f66 0F91      		pop r16
 4092 1f68 FF90      		pop r15
 4093 1f6a 0895      		ret
 4094               		.cfi_endproc
 4095               	.LFE30:
 4098               	ContinuePlayback:
 4099               	.LFB31:
1935:WTPA.c        **** {
 4100               		.loc 1 1935 0
 4101               		.cfi_startproc
 4102               	.LVL131:
 4103 1f6c 1F93      		push r17
 4104               	.LCFI44:
 4105               		.cfi_def_cfa_offset 3
 4106               		.cfi_offset 17, -2
 4107 1f6e CF93      		push r28
 4108               	.LCFI45:
 4109               		.cfi_def_cfa_offset 4
 4110               		.cfi_offset 28, -3
 4111 1f70 DF93      		push r29
 4112               	.LCFI46:
 4113               		.cfi_def_cfa_offset 5
 4114               		.cfi_offset 29, -4
 4115               	/* prologue: function */
 4116               	/* frame size = 0 */
 4117               	/* stack size = 3 */
 4118               	.L__stack_usage = 3
1939:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4119               		.loc 1 1939 0
 4120 1f72 282F      		mov r18,r24
 4121 1f74 30E0      		ldi r19,0
 4122 1f76 93E2      		ldi r25,lo8(35)
 4123 1f78 899F      		mul r24,r25
 4124 1f7a F001      		movw r30,r0
 4125 1f7c 1124      		clr __zero_reg__
 4126 1f7e E050      		subi r30,lo8(-(bankStates))
 4127 1f80 F040      		sbci r31,hi8(-(bankStates))
 4128 1f82 9581      		ldd r25,Z+5
 4129 1f84 9923      		tst r25
 4130 1f86 01F0      		breq .L237
1939:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4131               		.loc 1 1939 0 is_stmt 0 discriminator 1
 4132 1f88 9091 0000 		lds r25,sdIsrState
 4133 1f8c 9150      		subi r25,lo8(-(-1))
 4134 1f8e 9230      		cpi r25,lo8(2)
 4135 1f90 00F0      		brlo .L236
 4136               	.L237:
1941:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4137               		.loc 1 1941 0 is_stmt 1
 4138 1f92 1FB7      		in r17,__SREG__
 4139               	.LVL132:
1942:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4140               		.loc 1 1942 0
 4141               	/* #APP */
 4142               	 ;  1942 "WTPA.c" 1
 4143 1f94 F894      		cli
 4144               	 ;  0 "" 2
1944:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 4145               		.loc 1 1944 0
 4146               	/* #NOAPP */
 4147 1f96 93E2      		ldi r25,lo8(35)
 4148 1f98 929F      		mul r25,r18
 4149 1f9a E001      		movw r28,r0
 4150 1f9c 939F      		mul r25,r19
 4151 1f9e D00D      		add r29,r0
 4152 1fa0 1124      		clr __zero_reg__
 4153 1fa2 C050      		subi r28,lo8(-(bankStates))
 4154 1fa4 D040      		sbci r29,hi8(-(bankStates))
 4155 1fa6 94E0      		ldi r25,lo8(4)
 4156 1fa8 9883      		st Y,r25
1945:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4157               		.loc 1 1945 0
 4158 1faa 0E94 0000 		call SetSampleClock
 4159               	.LVL133:
1947:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4160               		.loc 1 1947 0
 4161 1fae 81E0      		ldi r24,lo8(1)
 4162 1fb0 8D83      		std Y+5,r24
1948:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4163               		.loc 1 1948 0
 4164 1fb2 1FBF      		out __SREG__,r17
 4165               	.LVL134:
 4166               	.L236:
 4167               	/* epilogue start */
1950:WTPA.c        **** }
 4168               		.loc 1 1950 0
 4169 1fb4 DF91      		pop r29
 4170 1fb6 CF91      		pop r28
 4171 1fb8 1F91      		pop r17
 4172 1fba 0895      		ret
 4173               		.cfi_endproc
 4174               	.LFE31:
 4177               	StartRecording:
 4178               	.LFB29:
1864:WTPA.c        **** {
 4179               		.loc 1 1864 0
 4180               		.cfi_startproc
 4181               	.LVL135:
 4182 1fbc FF92      		push r15
 4183               	.LCFI47:
 4184               		.cfi_def_cfa_offset 3
 4185               		.cfi_offset 15, -2
 4186 1fbe 0F93      		push r16
 4187               	.LCFI48:
 4188               		.cfi_def_cfa_offset 4
 4189               		.cfi_offset 16, -3
 4190 1fc0 1F93      		push r17
 4191               	.LCFI49:
 4192               		.cfi_def_cfa_offset 5
 4193               		.cfi_offset 17, -4
 4194 1fc2 CF93      		push r28
 4195               	.LCFI50:
 4196               		.cfi_def_cfa_offset 6
 4197               		.cfi_offset 28, -5
 4198 1fc4 DF93      		push r29
 4199               	.LCFI51:
 4200               		.cfi_def_cfa_offset 7
 4201               		.cfi_offset 29, -6
 4202               	/* prologue: function */
 4203               	/* frame size = 0 */
 4204               	/* stack size = 5 */
 4205               	.L__stack_usage = 5
1869:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4206               		.loc 1 1869 0
 4207 1fc6 282F      		mov r18,r24
 4208 1fc8 30E0      		ldi r19,0
 4209 1fca 93E2      		ldi r25,lo8(35)
 4210 1fcc 899F      		mul r24,r25
 4211 1fce F001      		movw r30,r0
 4212 1fd0 1124      		clr __zero_reg__
 4213 1fd2 E050      		subi r30,lo8(-(bankStates))
 4214 1fd4 F040      		sbci r31,hi8(-(bankStates))
 4215 1fd6 9581      		ldd r25,Z+5
 4216 1fd8 9923      		tst r25
 4217 1fda 01F0      		breq .L243
1869:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4218               		.loc 1 1869 0 is_stmt 0 discriminator 1
 4219 1fdc 9091 0000 		lds r25,sdIsrState
 4220 1fe0 9150      		subi r25,lo8(-(-1))
 4221 1fe2 9230      		cpi r25,lo8(2)
 4222 1fe4 00F4      		brsh .+2
 4223 1fe6 00C0      		rjmp .L242
 4224               	.L243:
1872:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4225               		.loc 1 1872 0 is_stmt 1
 4226 1fe8 FFB6      		in r15,__SREG__
 4227               	.LVL136:
1873:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4228               		.loc 1 1873 0
 4229               	/* #APP */
 4230               	 ;  1873 "WTPA.c" 1
 4231 1fea F894      		cli
 4232               	 ;  0 "" 2
1875:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
 4233               		.loc 1 1875 0
 4234               	/* #NOAPP */
 4235 1fec 93E2      		ldi r25,lo8(35)
 4236 1fee 929F      		mul r25,r18
 4237 1ff0 E001      		movw r28,r0
 4238 1ff2 939F      		mul r25,r19
 4239 1ff4 D00D      		add r29,r0
 4240 1ff6 1124      		clr __zero_reg__
 4241 1ff8 C050      		subi r28,lo8(-(bankStates))
 4242 1ffa D040      		sbci r29,hi8(-(bankStates))
 4243 1ffc 93E0      		ldi r25,lo8(3)
 4244 1ffe 9883      		st Y,r25
1877:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
 4245               		.loc 1 1877 0
 4246 2000 0889      		ldd r16,Y+16
 4247 2002 1989      		ldd r17,Y+17
 4248 2004 2A89      		ldd r18,Y+18
 4249 2006 3B89      		ldd r19,Y+19
 4250 2008 0F8F      		std Y+31,r16
 4251 200a 18A3      		std Y+32,r17
 4252 200c 29A3      		std Y+33,r18
 4253 200e 3AA3      		std Y+34,r19
1878:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
 4254               		.loc 1 1878 0
 4255 2010 0889      		ldd r16,Y+16
 4256 2012 1989      		ldd r17,Y+17
 4257 2014 2A89      		ldd r18,Y+18
 4258 2016 3B89      		ldd r19,Y+19
 4259 2018 0C87      		std Y+12,r16
 4260 201a 1D87      		std Y+13,r17
 4261 201c 2E87      		std Y+14,r18
 4262 201e 3F87      		std Y+15,r19
1879:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
 4263               		.loc 1 1879 0
 4264 2020 0889      		ldd r16,Y+16
 4265 2022 1989      		ldd r17,Y+17
 4266 2024 2A89      		ldd r18,Y+18
 4267 2026 3B89      		ldd r19,Y+19
 4268 2028 088F      		std Y+24,r16
 4269 202a 198F      		std Y+25,r17
 4270 202c 2A8F      		std Y+26,r18
 4271 202e 3B8F      		std Y+27,r19
1880:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
 4272               		.loc 1 1880 0
 4273 2030 0889      		ldd r16,Y+16
 4274 2032 1989      		ldd r17,Y+17
 4275 2034 2A89      		ldd r18,Y+18
 4276 2036 3B89      		ldd r19,Y+19
 4277 2038 0C8B      		std Y+20,r16
 4278 203a 1D8B      		std Y+21,r17
 4279 203c 2E8B      		std Y+22,r18
 4280 203e 3F8B      		std Y+23,r19
1881:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
 4281               		.loc 1 1881 0
 4282 2040 1E8E      		std Y+30,__zero_reg__
1883:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
 4283               		.loc 1 1883 0
 4284 2042 1092 0000 		sts outOfRam,__zero_reg__
1885:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 4285               		.loc 1 1885 0
 4286 2046 0E94 0000 		call SetSampleClock
 4287               	.LVL137:
1886:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4288               		.loc 1 1886 0
 4289 204a 81E0      		ldi r24,lo8(1)
 4290 204c 8D83      		std Y+5,r24
1888:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4291               		.loc 1 1888 0
 4292 204e FFBE      		out __SREG__,r15
1891:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4293               		.loc 1 1891 0
 4294 2050 8091 7A00 		lds r24,122
 4295 2054 86FD      		sbrc r24,6
 4296 2056 00C0      		rjmp .L242
 4297               	.LBB56:
 4298               	.LBB57:
1893:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4299               		.loc 1 1893 0
 4300 2058 8091 7900 		lds r24,121
 4301 205c 8058      		subi r24,lo8(-(-128))
 4302 205e 8093 0000 		sts adcByte,r24
1894:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4303               		.loc 1 1894 0
 4304 2062 8091 7A00 		lds r24,122
 4305 2066 8064      		ori r24,lo8(64)
 4306 2068 8093 7A00 		sts 122,r24
 4307               	.LVL138:
 4308               	.L242:
 4309               	/* epilogue start */
 4310               	.LBE57:
 4311               	.LBE56:
1897:WTPA.c        **** }
 4312               		.loc 1 1897 0
 4313 206c DF91      		pop r29
 4314 206e CF91      		pop r28
 4315 2070 1F91      		pop r17
 4316 2072 0F91      		pop r16
 4317 2074 FF90      		pop r15
 4318 2076 0895      		ret
 4319               		.cfi_endproc
 4320               	.LFE29:
 4323               	StartOverdub:
 4324               	.LFB32:
1955:WTPA.c        **** {
 4325               		.loc 1 1955 0
 4326               		.cfi_startproc
 4327               	.LVL139:
 4328 2078 1F93      		push r17
 4329               	.LCFI52:
 4330               		.cfi_def_cfa_offset 3
 4331               		.cfi_offset 17, -2
 4332 207a CF93      		push r28
 4333               	.LCFI53:
 4334               		.cfi_def_cfa_offset 4
 4335               		.cfi_offset 28, -3
 4336 207c DF93      		push r29
 4337               	.LCFI54:
 4338               		.cfi_def_cfa_offset 5
 4339               		.cfi_offset 29, -4
 4340               	/* prologue: function */
 4341               	/* frame size = 0 */
 4342               	/* stack size = 3 */
 4343               	.L__stack_usage = 3
1959:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4344               		.loc 1 1959 0
 4345 207e 282F      		mov r18,r24
 4346 2080 30E0      		ldi r19,0
 4347 2082 93E2      		ldi r25,lo8(35)
 4348 2084 899F      		mul r24,r25
 4349 2086 F001      		movw r30,r0
 4350 2088 1124      		clr __zero_reg__
 4351 208a E050      		subi r30,lo8(-(bankStates))
 4352 208c F040      		sbci r31,hi8(-(bankStates))
 4353 208e 9581      		ldd r25,Z+5
 4354 2090 9923      		tst r25
 4355 2092 01F0      		breq .L250
1959:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4356               		.loc 1 1959 0 is_stmt 0 discriminator 1
 4357 2094 9091 0000 		lds r25,sdIsrState
 4358 2098 9150      		subi r25,lo8(-(-1))
 4359 209a 9230      		cpi r25,lo8(2)
 4360 209c 00F0      		brlo .L249
 4361               	.L250:
1961:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4362               		.loc 1 1961 0 is_stmt 1
 4363 209e 1FB7      		in r17,__SREG__
 4364               	.LVL140:
1962:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4365               		.loc 1 1962 0
 4366               	/* #APP */
 4367               	 ;  1962 "WTPA.c" 1
 4368 20a0 F894      		cli
 4369               	 ;  0 "" 2
1964:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
 4370               		.loc 1 1964 0
 4371               	/* #NOAPP */
 4372 20a2 93E2      		ldi r25,lo8(35)
 4373 20a4 929F      		mul r25,r18
 4374 20a6 E001      		movw r28,r0
 4375 20a8 939F      		mul r25,r19
 4376 20aa D00D      		add r29,r0
 4377 20ac 1124      		clr __zero_reg__
 4378 20ae C050      		subi r28,lo8(-(bankStates))
 4379 20b0 D040      		sbci r29,hi8(-(bankStates))
 4380 20b2 95E0      		ldi r25,lo8(5)
 4381 20b4 9883      		st Y,r25
1965:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4382               		.loc 1 1965 0
 4383 20b6 0E94 0000 		call SetSampleClock
 4384               	.LVL141:
1967:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4385               		.loc 1 1967 0
 4386 20ba 81E0      		ldi r24,lo8(1)
 4387 20bc 8D83      		std Y+5,r24
1968:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4388               		.loc 1 1968 0
 4389 20be 1FBF      		out __SREG__,r17
1971:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4390               		.loc 1 1971 0
 4391 20c0 8091 7A00 		lds r24,122
 4392 20c4 86FD      		sbrc r24,6
 4393 20c6 00C0      		rjmp .L249
 4394               	.LBB60:
 4395               	.LBB61:
1973:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4396               		.loc 1 1973 0
 4397 20c8 8091 7900 		lds r24,121
 4398 20cc 8058      		subi r24,lo8(-(-128))
 4399 20ce 8093 0000 		sts adcByte,r24
1974:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4400               		.loc 1 1974 0
 4401 20d2 8091 7A00 		lds r24,122
 4402 20d6 8064      		ori r24,lo8(64)
 4403 20d8 8093 7A00 		sts 122,r24
 4404               	.LVL142:
 4405               	.L249:
 4406               	/* epilogue start */
 4407               	.LBE61:
 4408               	.LBE60:
1977:WTPA.c        **** }
 4409               		.loc 1 1977 0
 4410 20dc DF91      		pop r29
 4411 20de CF91      		pop r28
 4412 20e0 1F91      		pop r17
 4413 20e2 0895      		ret
 4414               		.cfi_endproc
 4415               	.LFE32:
 4418               	StartRealtime:
 4419               	.LFB33:
1983:WTPA.c        **** {
 4420               		.loc 1 1983 0
 4421               		.cfi_startproc
 4422               	.LVL143:
 4423 20e4 CF93      		push r28
 4424               	.LCFI55:
 4425               		.cfi_def_cfa_offset 3
 4426               		.cfi_offset 28, -2
 4427               	/* prologue: function */
 4428               	/* frame size = 0 */
 4429               	/* stack size = 1 */
 4430               	.L__stack_usage = 1
1987:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 4431               		.loc 1 1987 0
 4432 20e6 CFB7      		in r28,__SREG__
 4433               	.LVL144:
1988:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 4434               		.loc 1 1988 0
 4435               	/* #APP */
 4436               	 ;  1988 "WTPA.c" 1
 4437 20e8 F894      		cli
 4438               	 ;  0 "" 2
1990:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 4439               		.loc 1 1990 0
 4440               	/* #NOAPP */
 4441 20ea 93E2      		ldi r25,lo8(35)
 4442 20ec 899F      		mul r24,r25
 4443 20ee F001      		movw r30,r0
 4444 20f0 1124      		clr __zero_reg__
 4445 20f2 E050      		subi r30,lo8(-(bankStates))
 4446 20f4 F040      		sbci r31,hi8(-(bankStates))
 4447 20f6 92E0      		ldi r25,lo8(2)
 4448 20f8 9083      		st Z,r25
1991:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
 4449               		.loc 1 1991 0
 4450 20fa 0E94 0000 		call SetSampleClock
 4451               	.LVL145:
1993:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 4452               		.loc 1 1993 0
 4453 20fe CFBF      		out __SREG__,r28
1995:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 4454               		.loc 1 1995 0
 4455 2100 8091 7A00 		lds r24,122
 4456 2104 86FD      		sbrc r24,6
 4457 2106 00C0      		rjmp .L256
 4458               	.LBB64:
 4459               	.LBB65:
1997:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 4460               		.loc 1 1997 0
 4461 2108 8091 7900 		lds r24,121
 4462 210c 8058      		subi r24,lo8(-(-128))
 4463 210e 8093 0000 		sts adcByte,r24
1998:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4464               		.loc 1 1998 0
 4465 2112 8091 7A00 		lds r24,122
 4466 2116 8064      		ori r24,lo8(64)
 4467 2118 8093 7A00 		sts 122,r24
 4468               	.L256:
 4469               	/* epilogue start */
 4470               	.LBE65:
 4471               	.LBE64:
2000:WTPA.c        **** }
 4472               		.loc 1 2000 0
 4473 211c CF91      		pop r28
 4474               	.LVL146:
 4475 211e 0895      		ret
 4476               		.cfi_endproc
 4477               	.LFE33:
 4480               	DoFormatCard:
 4481               	.LFB39:
2215:WTPA.c        **** {
 4482               		.loc 1 2215 0
 4483               		.cfi_startproc
 4484               	/* prologue: function */
 4485               	/* frame size = 0 */
 4486               	/* stack size = 0 */
 4487               	.L__stack_usage = 0
2216:WTPA.c        **** 	if(subState==SS_0)
 4488               		.loc 1 2216 0
 4489 2120 8091 0000 		lds r24,subState
 4490 2124 8111      		cpse r24,__zero_reg__
 4491 2126 00C0      		rjmp .L259
2218:WTPA.c        **** 		KillLeds();		// Turn off LEDs
 4492               		.loc 1 2218 0
 4493 2128 0E94 0000 		call KillLeds
 4494               	.LVL147:
2220:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
 4495               		.loc 1 2220 0
 4496 212c 1092 0000 		sts bankStates,__zero_reg__
2221:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
 4497               		.loc 1 2221 0
 4498 2130 1092 0000 		sts bankStates+9,__zero_reg__
2222:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 4499               		.loc 1 2222 0
 4500 2134 1092 0000 		sts bankStates+35,__zero_reg__
2223:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
 4501               		.loc 1 2223 0
 4502 2138 1092 0000 		sts bankStates+44,__zero_reg__
2225:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
 4503               		.loc 1 2225 0
 4504 213c 81E8      		ldi r24,lo8(-127)
 4505 213e 90E0      		ldi r25,0
 4506 2140 0E94 0000 		call BlinkLeds
 4507               	.LVL148:
2226:WTPA.c        **** 		subState=SS_1;
 4508               		.loc 1 2226 0
 4509 2144 81E0      		ldi r24,lo8(1)
 4510 2146 00C0      		rjmp .L275
 4511               	.L259:
2228:WTPA.c        **** 	else if(subState==SS_1)
 4512               		.loc 1 2228 0
 4513 2148 8130      		cpi r24,lo8(1)
 4514 214a 01F4      		brne .L261
2230:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4515               		.loc 1 2230 0
 4516 214c 8091 0000 		lds r24,keyState
 4517 2150 80FF      		sbrs r24,0
 4518 2152 00C0      		rjmp .L262
2230:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4519               		.loc 1 2230 0 is_stmt 0 discriminator 1
 4520 2154 87FF      		sbrs r24,7
 4521 2156 00C0      		rjmp .L262
2232:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
 4522               		.loc 1 2232 0 is_stmt 1
 4523 2158 86E0      		ldi r24,lo8(6)
 4524 215a 8093 0000 		sts cardState,r24
2233:WTPA.c        **** 			KillLeds();
 4525               		.loc 1 2233 0
 4526 215e 0E94 0000 		call KillLeds
 4527               	.LVL149:
2234:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
 4528               		.loc 1 2234 0
 4529 2162 8091 0000 		lds r24,ledOnOffMask
 4530 2166 8168      		ori r24,lo8(-127)
 4531 2168 8093 0000 		sts ledOnOffMask,r24
2235:WTPA.c        **** 			subState=SS_2;
 4532               		.loc 1 2235 0
 4533 216c 82E0      		ldi r24,lo8(2)
 4534               	.L275:
 4535 216e 8093 0000 		sts subState,r24
 4536 2172 0895      		ret
 4537               	.L262:
2237:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
 4538               		.loc 1 2237 0
 4539 2174 8091 0000 		lds r24,cardState
 4540 2178 8111      		cpse r24,__zero_reg__
 4541 217a 00C0      		rjmp .L258
 4542               	.LVL150:
 4543 217c 00C0      		rjmp .L265
 4544               	.LVL151:
 4545               	.L261:
2242:WTPA.c        **** 	else if(subState==SS_2)
 4546               		.loc 1 2242 0
 4547 217e 8230      		cpi r24,lo8(2)
 4548 2180 01F4      		brne .L258
2244:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
 4549               		.loc 1 2244 0
 4550 2182 8091 0000 		lds r24,cardState
 4551 2186 8E30      		cpi r24,lo8(14)
 4552 2188 01F4      		brne .L258
 4553               	.LBB74:
 4554               	.LBB75:
2246:WTPA.c        **** 			KillLeds();
 4555               		.loc 1 2246 0
 4556 218a 0E94 0000 		call KillLeds
 4557               	.LVL152:
2247:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
 4558               		.loc 1 2247 0
 4559 218e 8091 0000 		lds r24,ledOnOffMask
 4560 2192 8260      		ori r24,lo8(2)
 4561 2194 8093 0000 		sts ledOnOffMask,r24
2248:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
 4562               		.loc 1 2248 0
 4563 2198 8091 0000 		lds r24,cardState
 4564 219c 8823      		tst r24
 4565 219e 01F0      		breq .L265
 4566 21a0 8091 0000 		lds r24,newKeys
 4567 21a4 8823      		tst r24
 4568 21a6 01F0      		breq .L258
 4569               	.L265:
 4570               	.LVL153:
 4571               	.LBB76:
 4572               	.LBB77:
1426:WTPA.c        **** 	State=newState;
 4573               		.loc 1 1426 0
 4574 21a8 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 4575 21aa 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 4576 21ac 9093 0000 		sts State+1,r25
 4577 21b0 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 4578               		.loc 1 1427 0
 4579 21b4 1092 0000 		sts subState,__zero_reg__
 4580               	.LVL154:
 4581               	.L258:
 4582 21b8 0895      		ret
 4583               	.LBE77:
 4584               	.LBE76:
 4585               	.LBE75:
 4586               	.LBE74:
 4587               		.cfi_endproc
 4588               	.LFE39:
 4591               	DoStartupSelect:
 4592               	.LFB71:
4629:WTPA.c        **** {
 4593               		.loc 1 4629 0
 4594               		.cfi_startproc
 4595               	/* prologue: function */
 4596               	/* frame size = 0 */
 4597               	/* stack size = 0 */
 4598               	.L__stack_usage = 0
4630:WTPA.c        **** 	if(subState==SS_0)
 4599               		.loc 1 4630 0
 4600 21ba 8091 0000 		lds r24,subState
 4601 21be 8111      		cpse r24,__zero_reg__
 4602 21c0 00C0      		rjmp .L277
4632:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
 4603               		.loc 1 4632 0
 4604 21c2 68E9      		ldi r22,lo8(-104)
 4605 21c4 70E0      		ldi r23,0
 4606 21c6 0E94 0000 		call SetTimer
 4607               	.LVL155:
4633:WTPA.c        **** 		subState=SS_1;
 4608               		.loc 1 4633 0
 4609 21ca 81E0      		ldi r24,lo8(1)
 4610 21cc 8093 0000 		sts subState,r24
 4611 21d0 0895      		ret
 4612               	.L277:
4637:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4613               		.loc 1 4637 0
 4614 21d2 80E0      		ldi r24,0
 4615 21d4 0E94 0000 		call CheckTimer
 4616               	.LVL156:
 4617 21d8 8823      		tst r24
 4618 21da 01F0      		breq .L276
 4619               	.LBB86:
 4620               	.LBB87:
4639:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
 4621               		.loc 1 4639 0
 4622 21dc 8091 0000 		lds r24,keyState
 4623 21e0 80FF      		sbrs r24,0
 4624 21e2 00C0      		rjmp .L279
 4625               	.LVL157:
 4626               	.LBB88:
 4627               	.LBB89:
1426:WTPA.c        **** 	State=newState;
 4628               		.loc 1 1426 0
 4629 21e4 80E0      		ldi r24,lo8(gs(DoSawtooth))
 4630 21e6 90E0      		ldi r25,hi8(gs(DoSawtooth))
 4631 21e8 00C0      		rjmp .L284
 4632               	.LVL158:
 4633               	.L279:
 4634               	.LBE89:
 4635               	.LBE88:
4643:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
 4636               		.loc 1 4643 0
 4637 21ea 85FF      		sbrs r24,5
 4638 21ec 00C0      		rjmp .L280
 4639               	.LVL159:
 4640               	.LBB90:
 4641               	.LBB91:
1426:WTPA.c        **** 	State=newState;
 4642               		.loc 1 1426 0
 4643 21ee 80E0      		ldi r24,lo8(gs(SetMidiChannels))
 4644 21f0 90E0      		ldi r25,hi8(gs(SetMidiChannels))
 4645 21f2 00C0      		rjmp .L284
 4646               	.LVL160:
 4647               	.L280:
 4648               	.LBE91:
 4649               	.LBE90:
 4650               	.LBB92:
 4651               	.LBB93:
 4652 21f4 80E0      		ldi r24,lo8(gs(DoSampler))
 4653 21f6 90E0      		ldi r25,hi8(gs(DoSampler))
 4654               	.LVL161:
 4655               	.L284:
 4656 21f8 9093 0000 		sts State+1,r25
 4657 21fc 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 4658               		.loc 1 1427 0
 4659 2200 1092 0000 		sts subState,__zero_reg__
 4660               	.L276:
 4661 2204 0895      		ret
 4662               	.LBE93:
 4663               	.LBE92:
 4664               	.LBE87:
 4665               	.LBE86:
 4666               		.cfi_endproc
 4667               	.LFE71:
 4670               	PlaySampleFromSd:
 4671               	.LFB51:
3131:WTPA.c        **** {
 4672               		.loc 1 3131 0
 4673               		.cfi_startproc
 4674               	.LVL162:
 4675 2206 CF93      		push r28
 4676               	.LCFI56:
 4677               		.cfi_def_cfa_offset 3
 4678               		.cfi_offset 28, -2
 4679               	/* prologue: function */
 4680               	/* frame size = 0 */
 4681               	/* stack size = 1 */
 4682               	.L__stack_usage = 1
3135:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 4683               		.loc 1 3135 0
 4684 2208 2091 0000 		lds r18,cardState
 4685 220c 2E30      		cpi r18,lo8(14)
 4686 220e 01F4      		brne .L286
 4687 2210 00C0      		rjmp .L294
 4688               	.L286:
3146:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
 4689               		.loc 1 3146 0
 4690 2212 3091 0000 		lds r19,sdIsrState
 4691 2216 3330      		cpi r19,lo8(3)
 4692 2218 01F4      		brne .L285
3149:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
 4693               		.loc 1 3149 0
 4694 221a 2B30      		cpi r18,lo8(11)
 4695 221c 01F4      		brne .L288
 4696               	.L294:
 4697               	.LVL163:
 4698               	.LBB96:
 4699               	.LBB97:
3151:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
 4700               		.loc 1 3151 0
 4701 221e CFB7      		in r28,__SREG__
 4702               	.LVL164:
3152:WTPA.c        **** 			cli();
 4703               		.loc 1 3152 0
 4704               	/* #APP */
 4705               	 ;  3152 "WTPA.c" 1
 4706 2220 F894      		cli
 4707               	 ;  0 "" 2
3154:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
 4708               		.loc 1 3154 0
 4709               	/* #NOAPP */
 4710 2222 0E94 0000 		call SdStartSampleRead
 4711               	.LVL165:
3155:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
 4712               		.loc 1 3155 0
 4713 2226 81E0      		ldi r24,lo8(1)
 4714 2228 90E0      		ldi r25,0
 4715 222a A0E0      		ldi r26,0
 4716 222c B0E0      		ldi r27,0
 4717 222e 8093 0000 		sts sdRamSampleRemaining,r24
 4718 2232 9093 0000 		sts sdRamSampleRemaining+1,r25
 4719 2236 A093 0000 		sts sdRamSampleRemaining+2,r26
 4720 223a B093 0000 		sts sdRamSampleRemaining+3,r27
3156:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
 4721               		.loc 1 3156 0
 4722 223e 0E94 0000 		call SdIsrStartStreamingAudio
 4723               	.LVL166:
3158:WTPA.c        **** 			SREG=sreg;	// resume isr
 4724               		.loc 1 3158 0
 4725 2242 CFBF      		out __SREG__,r28
 4726 2244 00C0      		rjmp .L285
 4727               	.LVL167:
 4728               	.L288:
 4729               	.LBE97:
 4730               	.LBE96:
3160:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4731               		.loc 1 3160 0
 4732 2246 2D30      		cpi r18,lo8(13)
 4733 2248 01F0      		breq .L289
3160:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4734               		.loc 1 3160 0 is_stmt 0 discriminator 1
 4735 224a 2091 0000 		lds r18,sdAbortRead
 4736 224e 2130      		cpi r18,lo8(1)
 4737 2250 01F4      		brne .L290
 4738               	.L289:
3163:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4739               		.loc 1 3163 0 is_stmt 1
 4740 2252 9093 0000 		sts sdQueuedSlot+1,r25
 4741 2256 8093 0000 		sts sdQueuedSlot,r24
 4742 225a 00C0      		rjmp .L285
 4743               	.L290:
3168:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4744               		.loc 1 3168 0
 4745 225c 9093 0000 		sts sdQueuedSlot+1,r25
 4746 2260 8093 0000 		sts sdQueuedSlot,r24
3169:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
 4747               		.loc 1 3169 0
 4748 2264 81E0      		ldi r24,lo8(1)
 4749               	.LVL168:
 4750 2266 8093 0000 		sts sdPlaybackQueued,r24
3170:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
 4751               		.loc 1 3170 0
 4752 226a 8093 0000 		sts sdAbortRead,r24
3172:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
 4753               		.loc 1 3172 0
 4754 226e 9FB7      		in r25,__SREG__
 4755               	.LVL169:
3173:WTPA.c        **** 			cli();
 4756               		.loc 1 3173 0
 4757               	/* #APP */
 4758               	 ;  3173 "WTPA.c" 1
 4759 2270 F894      		cli
 4760               	 ;  0 "" 2
3174:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
 4761               		.loc 1 3174 0
 4762               	/* #NOAPP */
 4763 2272 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 4764 2276 1092 0000 		sts sdBytesInFifo,__zero_reg__
3175:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
 4765               		.loc 1 3175 0
 4766 227a 8091 7000 		lds r24,112
 4767 227e 8B7F      		andi r24,lo8(-5)
 4768 2280 8093 7000 		sts 112,r24
3176:WTPA.c        **** 			SREG=sreg;
 4769               		.loc 1 3176 0
 4770 2284 9FBF      		out __SREG__,r25
 4771               	.LVL170:
 4772               	.L285:
 4773               	/* epilogue start */
3179:WTPA.c        **** }
 4774               		.loc 1 3179 0
 4775 2286 CF91      		pop r28
 4776 2288 0895      		ret
 4777               		.cfi_endproc
 4778               	.LFE51:
 4781               	DoSawtooth:
 4782               	.LFB69:
4478:WTPA.c        **** {
 4783               		.loc 1 4478 0
 4784               		.cfi_startproc
 4785               	/* prologue: function */
 4786               	/* frame size = 0 */
 4787               	/* stack size = 0 */
 4788               	.L__stack_usage = 0
4482:WTPA.c        **** 	if(subState==SS_0)
 4789               		.loc 1 4482 0
 4790 228a 8091 0000 		lds r24,subState
 4791 228e 8111      		cpse r24,__zero_reg__
 4792 2290 00C0      		rjmp .L296
4484:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
 4793               		.loc 1 4484 0
 4794 2292 0E94 0000 		call KillLeds
 4795               	.LVL171:
4485:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
 4796               		.loc 1 4485 0
 4797 2296 80EC      		ldi r24,lo8(-64)
 4798 2298 90E0      		ldi r25,0
 4799 229a 0E94 0000 		call BlinkLeds
 4800               	.LVL172:
4486:WTPA.c        **** 		subState=SS_1;
 4801               		.loc 1 4486 0
 4802 229e 81E0      		ldi r24,lo8(1)
 4803 22a0 00C0      		rjmp .L330
 4804               	.L296:
4488:WTPA.c        **** 	else if(subState==SS_1)
 4805               		.loc 1 4488 0
 4806 22a2 8130      		cpi r24,lo8(1)
 4807 22a4 01F4      		brne .L298
4490:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 4808               		.loc 1 4490 0
 4809               	/* #APP */
 4810               	 ;  4490 "WTPA.c" 1
 4811 22a6 F894      		cli
 4812               	 ;  0 "" 2
4491:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
 4813               		.loc 1 4491 0
 4814               	/* #NOAPP */
 4815 22a8 8093 0000 		sts bankStates,r24
4492:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
 4816               		.loc 1 4492 0
 4817 22ac 8093 0000 		sts bankStates+9,r24
 4818               	.LVL173:
 4819               	.LBB108:
 4820               	.LBB109:
1821:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 4821               		.loc 1 1821 0
 4822 22b0 8093 0000 		sts bankStates+9,r24
 4823 22b4 0E94 0000 		call SetSampleClock.part.0
 4824               	.LVL174:
 4825               	.LBE109:
 4826               	.LBE108:
4494:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 4827               		.loc 1 4494 0
 4828 22b8 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 4829 22ba 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 4830 22bc 9093 0000 		sts UpdateOutput+1,r25
 4831 22c0 8093 0000 		sts UpdateOutput,r24
4495:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 4832               		.loc 1 4495 0
 4833               	/* #APP */
 4834               	 ;  4495 "WTPA.c" 1
 4835 22c4 7894      		sei
 4836               	 ;  0 "" 2
4497:WTPA.c        **** 		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the 
 4837               		.loc 1 4497 0
 4838               	/* #NOAPP */
 4839 22c6 8091 0000 		lds r24,encoderValue
 4840 22ca 8093 0000 		sts lastShuttleRead.2246,r24
4499:WTPA.c        **** 		subState=SS_2;					// And wait forever.
 4841               		.loc 1 4499 0
 4842 22ce 82E0      		ldi r24,lo8(2)
 4843               	.LVL175:
 4844               	.L330:
 4845 22d0 8093 0000 		sts subState,r24
 4846 22d4 0895      		ret
 4847               	.L298:
4501:WTPA.c        **** 	else if(subState==SS_2)
 4848               		.loc 1 4501 0
 4849 22d6 8230      		cpi r24,lo8(2)
 4850 22d8 01F0      		breq .+2
 4851 22da 00C0      		rjmp .L295
 4852               	.LBB110:
 4853               	.LBB111:
4504:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 4854               		.loc 1 4504 0
 4855 22dc 8091 0000 		lds r24,newKeys
 4856 22e0 80FF      		sbrs r24,0
 4857 22e2 00C0      		rjmp .L300
4506:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
 4858               		.loc 1 4506 0
 4859 22e4 9091 0000 		lds r25,ledOnOffMask
 4860 22e8 21E0      		ldi r18,lo8(1)
 4861 22ea 9227      		eor r25,r18
 4862 22ec 9093 0000 		sts ledOnOffMask,r25
 4863               	.L300:
4508:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 4864               		.loc 1 4508 0
 4865 22f0 81FF      		sbrs r24,1
 4866 22f2 00C0      		rjmp .L301
4510:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
 4867               		.loc 1 4510 0
 4868 22f4 9091 0000 		lds r25,ledOnOffMask
 4869 22f8 22E0      		ldi r18,lo8(2)
 4870 22fa 9227      		eor r25,r18
 4871 22fc 9093 0000 		sts ledOnOffMask,r25
 4872               	.L301:
4512:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
 4873               		.loc 1 4512 0
 4874 2300 82FF      		sbrs r24,2
 4875 2302 00C0      		rjmp .L302
4514:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
 4876               		.loc 1 4514 0
 4877 2304 9091 0000 		lds r25,ledOnOffMask
 4878 2308 24E0      		ldi r18,lo8(4)
 4879 230a 9227      		eor r25,r18
 4880 230c 9093 0000 		sts ledOnOffMask,r25
 4881               	.L302:
4516:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
 4882               		.loc 1 4516 0
 4883 2310 83FF      		sbrs r24,3
 4884 2312 00C0      		rjmp .L303
4518:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
 4885               		.loc 1 4518 0
 4886 2314 9091 0000 		lds r25,ledOnOffMask
 4887 2318 28E0      		ldi r18,lo8(8)
 4888 231a 9227      		eor r25,r18
 4889 231c 9093 0000 		sts ledOnOffMask,r25
 4890               	.L303:
4520:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
 4891               		.loc 1 4520 0
 4892 2320 84FF      		sbrs r24,4
 4893 2322 00C0      		rjmp .L304
4522:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
 4894               		.loc 1 4522 0
 4895 2324 9091 0000 		lds r25,ledOnOffMask
 4896 2328 20E1      		ldi r18,lo8(16)
 4897 232a 9227      		eor r25,r18
 4898 232c 9093 0000 		sts ledOnOffMask,r25
 4899               	.L304:
4524:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
 4900               		.loc 1 4524 0
 4901 2330 85FF      		sbrs r24,5
 4902 2332 00C0      		rjmp .L305
4526:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
 4903               		.loc 1 4526 0
 4904 2334 9091 0000 		lds r25,ledOnOffMask
 4905 2338 20E2      		ldi r18,lo8(32)
 4906 233a 9227      		eor r25,r18
 4907 233c 9093 0000 		sts ledOnOffMask,r25
 4908               	.L305:
4529:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
 4909               		.loc 1 4529 0
 4910 2340 86FF      		sbrs r24,6
 4911 2342 00C0      		rjmp .L306
 4912               	.LBB112:
 4913               	.LBB113:
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4914               		.loc 1 1499 0
 4915 2344 80E0      		ldi r24,0
 4916 2346 90E0      		ldi r25,0
 4917 2348 0E94 0000 		call BlinkLeds
 4918               	.LVL176:
 4919               	.LBE113:
 4920               	.LBE112:
4532:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
 4921               		.loc 1 4532 0
 4922 234c 8091 0000 		lds r24,ledOnOffMask
 4923 2350 90E4      		ldi r25,lo8(64)
 4924 2352 8927      		eor r24,r25
 4925 2354 8093 0000 		sts ledOnOffMask,r24
 4926               	.L306:
4534:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
 4927               		.loc 1 4534 0
 4928 2358 8091 0000 		lds r24,newKeys
 4929 235c 87FF      		sbrs r24,7
 4930 235e 00C0      		rjmp .L307
 4931               	.LBB114:
 4932               	.LBB115:
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4933               		.loc 1 1499 0
 4934 2360 80E0      		ldi r24,0
 4935 2362 90E0      		ldi r25,0
 4936 2364 0E94 0000 		call BlinkLeds
 4937               	.LVL177:
 4938               	.LBE115:
 4939               	.LBE114:
4537:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
 4940               		.loc 1 4537 0
 4941 2368 8091 0000 		lds r24,ledOnOffMask
 4942 236c 8058      		subi r24,lo8(-(-128))
 4943 236e 8093 0000 		sts ledOnOffMask,r24
 4944               	.L307:
4539:WTPA.c        **** 		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new v
 4945               		.loc 1 4539 0
 4946 2372 9091 0000 		lds r25,lastShuttleRead.2246
 4947 2376 8091 0000 		lds r24,encoderValue
 4948 237a 9817      		cp r25,r24
 4949 237c 01F0      		breq .L295
 4950               	.LBB116:
 4951               	.LBB117:
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4952               		.loc 1 1499 0
 4953 237e 80E0      		ldi r24,0
 4954 2380 90E0      		ldi r25,0
 4955 2382 0E94 0000 		call BlinkLeds
 4956               	.LVL178:
 4957               	.LBE117:
 4958               	.LBE116:
4542:WTPA.c        **** 			ledOnOffMask=encoderValue;
 4959               		.loc 1 4542 0
 4960 2386 8091 0000 		lds r24,encoderValue
 4961 238a 8093 0000 		sts ledOnOffMask,r24
4543:WTPA.c        **** 			lastShuttleRead=encoderValue;
 4962               		.loc 1 4543 0
 4963 238e 8093 0000 		sts lastShuttleRead.2246,r24
 4964               	.L295:
 4965 2392 0895      		ret
 4966               	.LBE111:
 4967               	.LBE110:
 4968               		.cfi_endproc
 4969               	.LFE69:
 4972               	SetMidiChannels:
 4973               	.LFB70:
4585:WTPA.c        **** {
 4974               		.loc 1 4585 0
 4975               		.cfi_startproc
 4976               	/* prologue: function */
 4977               	/* frame size = 0 */
 4978               	/* stack size = 0 */
 4979               	.L__stack_usage = 0
4586:WTPA.c        **** 	if(subState==SS_0)
 4980               		.loc 1 4586 0
 4981 2394 8091 0000 		lds r24,subState
 4982 2398 8111      		cpse r24,__zero_reg__
 4983 239a 00C0      		rjmp .L332
 4984               	.LVL179:
 4985               	.LBB128:
 4986               	.LBB129:
3384:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 4987               		.loc 1 3384 0
 4988 239c 84E0      		ldi r24,lo8(4)
 4989 239e 0E94 0000 		call EepromRead
 4990               	.LVL180:
3391:WTPA.c        **** 	if(x<16)					// Legit number?
 4991               		.loc 1 3391 0
 4992 23a2 8031      		cpi r24,lo8(16)
 4993 23a4 00F0      		brlo .L333
3405:WTPA.c        **** 		return(x);
 4994               		.loc 1 3405 0
 4995 23a6 80E0      		ldi r24,0
 4996               	.LVL181:
 4997               	.L333:
 4998               	.LBE129:
 4999               	.LBE128:
4588:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
 5000               		.loc 1 4588 0
 5001 23a8 8093 0000 		sts midiChannelNumberA,r24
 5002               	.LVL182:
 5003               	.LBB130:
 5004               	.LBB131:
3388:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 5005               		.loc 1 3388 0
 5006 23ac 88E0      		ldi r24,lo8(8)
 5007 23ae 0E94 0000 		call EepromRead
 5008               	.LVL183:
3391:WTPA.c        **** 	if(x<16)					// Legit number?
 5009               		.loc 1 3391 0
 5010 23b2 8031      		cpi r24,lo8(16)
 5011 23b4 00F0      		brlo .L334
3405:WTPA.c        **** 		return(x);
 5012               		.loc 1 3405 0
 5013 23b6 81E0      		ldi r24,lo8(1)
 5014               	.LVL184:
 5015               	.L334:
 5016               	.LBE131:
 5017               	.LBE130:
4589:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
 5018               		.loc 1 4589 0
 5019 23b8 8093 0000 		sts midiChannelNumberB,r24
4590:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
 5020               		.loc 1 4590 0
 5021 23bc 20E1      		ldi r18,lo8(16)
 5022 23be 829F      		mul r24,r18
 5023 23c0 C001      		movw r24,r0
 5024 23c2 1124      		clr __zero_reg__
 5025 23c4 9091 0000 		lds r25,midiChannelNumberA
 5026 23c8 982B      		or r25,r24
 5027 23ca 9093 0000 		sts ledOnOffMask,r25
4591:WTPA.c        **** 		subState=SS_1;
 5028               		.loc 1 4591 0
 5029 23ce 81E0      		ldi r24,lo8(1)
 5030 23d0 8093 0000 		sts subState,r24
 5031 23d4 0895      		ret
 5032               	.LVL185:
 5033               	.L332:
4595:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 5034               		.loc 1 4595 0
 5035 23d6 2091 0000 		lds r18,newKeys
 5036 23da 20FF      		sbrs r18,0
 5037 23dc 00C0      		rjmp .L336
4597:WTPA.c        **** 			midiChannelNumberA++;
 5038               		.loc 1 4597 0
 5039 23de 8091 0000 		lds r24,midiChannelNumberA
 5040               	.LVL186:
 5041 23e2 8F5F      		subi r24,lo8(-(1))
 5042               	.LVL187:
4598:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
 5043               		.loc 1 4598 0
 5044 23e4 8031      		cpi r24,lo8(16)
 5045               	.LVL188:
 5046 23e6 00F4      		brsh .L337
4597:WTPA.c        **** 			midiChannelNumberA++;
 5047               		.loc 1 4597 0
 5048 23e8 8093 0000 		sts midiChannelNumberA,r24
 5049 23ec 00C0      		rjmp .L338
 5050               	.L337:
4600:WTPA.c        **** 				midiChannelNumberA=0;
 5051               		.loc 1 4600 0
 5052 23ee 1092 0000 		sts midiChannelNumberA,__zero_reg__
 5053               	.L338:
4603:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
 5054               		.loc 1 4603 0
 5055 23f2 8091 0000 		lds r24,ledOnOffMask
 5056               	.LVL189:
 5057 23f6 807F      		andi r24,lo8(-16)
4604:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
 5058               		.loc 1 4604 0
 5059 23f8 9091 0000 		lds r25,midiChannelNumberA
 5060 23fc 892B      		or r24,r25
 5061 23fe 8093 0000 		sts ledOnOffMask,r24
 5062               	.L336:
4606:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 5063               		.loc 1 4606 0
 5064 2402 21FF      		sbrs r18,1
 5065 2404 00C0      		rjmp .L339
4608:WTPA.c        **** 			midiChannelNumberB++;
 5066               		.loc 1 4608 0
 5067 2406 8091 0000 		lds r24,midiChannelNumberB
 5068               	.LVL190:
 5069 240a 8F5F      		subi r24,lo8(-(1))
 5070               	.LVL191:
4609:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
 5071               		.loc 1 4609 0
 5072 240c 8031      		cpi r24,lo8(16)
 5073               	.LVL192:
 5074 240e 00F4      		brsh .L340
4608:WTPA.c        **** 			midiChannelNumberB++;
 5075               		.loc 1 4608 0
 5076 2410 8093 0000 		sts midiChannelNumberB,r24
 5077 2414 00C0      		rjmp .L341
 5078               	.L340:
4611:WTPA.c        **** 				midiChannelNumberB=0;
 5079               		.loc 1 4611 0
 5080 2416 1092 0000 		sts midiChannelNumberB,__zero_reg__
 5081               	.L341:
4615:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 5082               		.loc 1 4615 0
 5083 241a 8091 0000 		lds r24,midiChannelNumberB
 5084               	.LVL193:
 5085 241e 30E1      		ldi r19,lo8(16)
 5086 2420 839F      		mul r24,r19
 5087 2422 C001      		movw r24,r0
 5088 2424 1124      		clr __zero_reg__
4614:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
 5089               		.loc 1 4614 0
 5090 2426 9091 0000 		lds r25,ledOnOffMask
 5091 242a 9F70      		andi r25,lo8(15)
4615:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 5092               		.loc 1 4615 0
 5093 242c 982B      		or r25,r24
 5094 242e 9093 0000 		sts ledOnOffMask,r25
 5095               	.L339:
4617:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
 5096               		.loc 1 4617 0
 5097 2432 22FF      		sbrs r18,2
 5098 2434 00C0      		rjmp .L331
 5099               	.LVL194:
 5100               	.LBB132:
 5101               	.LBB133:
3365:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
 5102               		.loc 1 3365 0
 5103 2436 6091 0000 		lds r22,midiChannelNumberA
 5104 243a 84E0      		ldi r24,lo8(4)
 5105 243c 90E0      		ldi r25,0
 5106 243e 0E94 0000 		call EepromWrite
 5107               	.LVL195:
 5108               	.LBE133:
 5109               	.LBE132:
 5110               	.LBB134:
 5111               	.LBB135:
3369:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
 5112               		.loc 1 3369 0
 5113 2442 6091 0000 		lds r22,midiChannelNumberB
 5114 2446 88E0      		ldi r24,lo8(8)
 5115 2448 90E0      		ldi r25,0
 5116 244a 0E94 0000 		call EepromWrite
 5117               	.LVL196:
 5118               	.LBE135:
 5119               	.LBE134:
 5120               	.LBB136:
 5121               	.LBB137:
1426:WTPA.c        **** 	State=newState;
 5122               		.loc 1 1426 0
 5123 244e 80E0      		ldi r24,lo8(gs(DoSampler))
 5124 2450 90E0      		ldi r25,hi8(gs(DoSampler))
 5125 2452 9093 0000 		sts State+1,r25
 5126 2456 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 5127               		.loc 1 1427 0
 5128 245a 1092 0000 		sts subState,__zero_reg__
 5129               	.LVL197:
 5130               	.L331:
 5131 245e 0895      		ret
 5132               	.LBE137:
 5133               	.LBE136:
 5134               		.cfi_endproc
 5135               	.LFE70:
 5138               	DoSampler:
 5139               	.LFB68:
4161:WTPA.c        **** {
 5140               		.loc 1 4161 0
 5141               		.cfi_startproc
 5142 2460 8F92      		push r8
 5143               	.LCFI57:
 5144               		.cfi_def_cfa_offset 3
 5145               		.cfi_offset 8, -2
 5146 2462 9F92      		push r9
 5147               	.LCFI58:
 5148               		.cfi_def_cfa_offset 4
 5149               		.cfi_offset 9, -3
 5150 2464 AF92      		push r10
 5151               	.LCFI59:
 5152               		.cfi_def_cfa_offset 5
 5153               		.cfi_offset 10, -4
 5154 2466 BF92      		push r11
 5155               	.LCFI60:
 5156               		.cfi_def_cfa_offset 6
 5157               		.cfi_offset 11, -5
 5158 2468 CF92      		push r12
 5159               	.LCFI61:
 5160               		.cfi_def_cfa_offset 7
 5161               		.cfi_offset 12, -6
 5162 246a DF92      		push r13
 5163               	.LCFI62:
 5164               		.cfi_def_cfa_offset 8
 5165               		.cfi_offset 13, -7
 5166 246c EF92      		push r14
 5167               	.LCFI63:
 5168               		.cfi_def_cfa_offset 9
 5169               		.cfi_offset 14, -8
 5170 246e FF92      		push r15
 5171               	.LCFI64:
 5172               		.cfi_def_cfa_offset 10
 5173               		.cfi_offset 15, -9
 5174 2470 0F93      		push r16
 5175               	.LCFI65:
 5176               		.cfi_def_cfa_offset 11
 5177               		.cfi_offset 16, -10
 5178 2472 1F93      		push r17
 5179               	.LCFI66:
 5180               		.cfi_def_cfa_offset 12
 5181               		.cfi_offset 17, -11
 5182 2474 CF93      		push r28
 5183               	.LCFI67:
 5184               		.cfi_def_cfa_offset 13
 5185               		.cfi_offset 28, -12
 5186 2476 DF93      		push r29
 5187               	.LCFI68:
 5188               		.cfi_def_cfa_offset 14
 5189               		.cfi_offset 29, -13
 5190 2478 1F92      		push __zero_reg__
 5191               	.LCFI69:
 5192               		.cfi_def_cfa_offset 15
 5193 247a CDB7      		in r28,__SP_L__
 5194 247c DEB7      		in r29,__SP_H__
 5195               	.LCFI70:
 5196               		.cfi_def_cfa_register 28
 5197               	/* prologue: function */
 5198               	/* frame size = 1 */
 5199               	/* stack size = 13 */
 5200               	.L__stack_usage = 13
4184:WTPA.c        **** 	if(subState==SS_0)
 5201               		.loc 1 4184 0
 5202 247e F090 0000 		lds r15,subState
 5203 2482 F110      		cpse r15,__zero_reg__
 5204 2484 00C0      		rjmp .L354
 5205               	.LVL198:
 5206               	.LBB200:
 5207               	.LBB201:
3384:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 5208               		.loc 1 3384 0
 5209 2486 84E0      		ldi r24,lo8(4)
 5210 2488 0E94 0000 		call EepromRead
 5211               	.LVL199:
3391:WTPA.c        **** 	if(x<16)					// Legit number?
 5212               		.loc 1 3391 0
 5213 248c 8031      		cpi r24,lo8(16)
 5214 248e 00F0      		brlo .L355
3405:WTPA.c        **** 		return(x);
 5215               		.loc 1 3405 0
 5216 2490 80E0      		ldi r24,0
 5217               	.LVL200:
 5218               	.L355:
 5219               	.LBE201:
 5220               	.LBE200:
4187:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
 5221               		.loc 1 4187 0
 5222 2492 8093 0000 		sts midiChannelNumberA,r24
 5223               	.LVL201:
 5224               	.LBB202:
 5225               	.LBB203:
3388:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 5226               		.loc 1 3388 0
 5227 2496 88E0      		ldi r24,lo8(8)
 5228 2498 0E94 0000 		call EepromRead
 5229               	.LVL202:
3391:WTPA.c        **** 	if(x<16)					// Legit number?
 5230               		.loc 1 3391 0
 5231 249c 8031      		cpi r24,lo8(16)
 5232 249e 00F0      		brlo .L356
3405:WTPA.c        **** 		return(x);
 5233               		.loc 1 3405 0
 5234 24a0 81E0      		ldi r24,lo8(1)
 5235               	.LVL203:
 5236               	.L356:
 5237               	.LBE203:
 5238               	.LBE202:
4188:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
 5239               		.loc 1 4188 0
 5240 24a2 8093 0000 		sts midiChannelNumberB,r24
4189:WTPA.c        **** 		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardco
 5241               		.loc 1 4189 0
 5242 24a6 1092 0000 		sts bankStates+16,__zero_reg__
 5243 24aa 1092 0000 		sts bankStates+16+1,__zero_reg__
 5244 24ae 1092 0000 		sts bankStates+16+2,__zero_reg__
 5245 24b2 1092 0000 		sts bankStates+16+3,__zero_reg__
4190:WTPA.c        **** 		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardco
 5246               		.loc 1 4190 0
 5247 24b6 8FEF      		ldi r24,lo8(-1)
 5248 24b8 9FEF      		ldi r25,lo8(-1)
 5249 24ba A7E0      		ldi r26,lo8(7)
 5250 24bc B0E0      		ldi r27,0
 5251 24be 8093 0000 		sts bankStates+51,r24
 5252 24c2 9093 0000 		sts bankStates+51+1,r25
 5253 24c6 A093 0000 		sts bankStates+51+2,r26
 5254 24ca B093 0000 		sts bankStates+51+3,r27
 5255               	.LVL204:
 5256 24ce 00E0      		ldi r16,lo8(realtimeOn.2211)
 5257 24d0 10E0      		ldi r17,hi8(realtimeOn.2211)
 5258 24d2 70E0      		ldi r23,lo8(theMidiRecordRate)
 5259 24d4 872E      		mov r8,r23
 5260 24d6 70E0      		ldi r23,hi8(theMidiRecordRate)
 5261 24d8 972E      		mov r9,r23
 5262 24da E12C      		mov r14,__zero_reg__
 5263 24dc F12C      		mov r15,__zero_reg__
4194:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5264               		.loc 1 4194 0
 5265 24de E3E2      		ldi r30,lo8(35)
 5266 24e0 CE2E      		mov r12,r30
4201:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
 5267               		.loc 1 4201 0
 5268 24e2 BB24      		clr r11
 5269 24e4 B394      		inc r11
 5270               	.LBB204:
 5271               	.LBB205:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5272               		.loc 1 3303 0
 5273 24e6 FCE0      		ldi r31,lo8(12)
 5274 24e8 DF2E      		mov r13,r31
 5275               	.LVL205:
 5276               	.L360:
 5277               	.LBE205:
 5278               	.LBE204:
4194:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5279               		.loc 1 4194 0 discriminator 2
 5280 24ea CE9C      		mul r12,r14
 5281 24ec F001      		movw r30,r0
 5282 24ee CF9C      		mul r12,r15
 5283 24f0 F00D      		add r31,r0
 5284 24f2 1124      		clr __zero_reg__
 5285 24f4 E050      		subi r30,lo8(-(bankStates))
 5286 24f6 F040      		sbci r31,hi8(-(bankStates))
 5287 24f8 1082      		st Z,__zero_reg__
4195:WTPA.c        **** 			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet
 5288               		.loc 1 4195 0 discriminator 2
 5289 24fa 1186      		std Z+9,__zero_reg__
4196:WTPA.c        **** 			bankStates[i].loopOnce=false;
 5290               		.loc 1 4196 0 discriminator 2
 5291 24fc 1182      		std Z+1,__zero_reg__
4197:WTPA.c        **** 			bankStates[i].bitReduction=0;				// No crusties yet.
 5292               		.loc 1 4197 0 discriminator 2
 5293 24fe 1086      		std Z+8,__zero_reg__
4198:WTPA.c        **** 			bankStates[i].jitterValue=0;				// No hissies yet.
 5294               		.loc 1 4198 0 discriminator 2
 5295 2500 1782      		std Z+7,__zero_reg__
4199:WTPA.c        **** 			bankStates[i].granularSlices=0;				// No remix yet.
 5296               		.loc 1 4199 0 discriminator 2
 5297 2502 1682      		std Z+6,__zero_reg__
4200:WTPA.c        **** 			bankStates[i].halfSpeed=false;
 5298               		.loc 1 4200 0 discriminator 2
 5299 2504 1282      		std Z+2,__zero_reg__
4201:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
 5300               		.loc 1 4201 0 discriminator 2
 5301 2506 B482      		std Z+4,r11
4202:WTPA.c        **** 			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
 5302               		.loc 1 4202 0 discriminator 2
 5303 2508 1382      		std Z+3,__zero_reg__
4203:WTPA.c        **** 			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beg
 5304               		.loc 1 4203 0 discriminator 2
 5305 250a 8089      		ldd r24,Z+16
 5306 250c 9189      		ldd r25,Z+17
 5307 250e A289      		ldd r26,Z+18
 5308 2510 B389      		ldd r27,Z+19
 5309 2512 878F      		std Z+31,r24
 5310 2514 90A3      		std Z+32,r25
 5311 2516 A1A3      		std Z+33,r26
 5312 2518 B2A3      		std Z+34,r27
4204:WTPA.c        **** 			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sa
 5313               		.loc 1 4204 0 discriminator 2
 5314 251a 8089      		ldd r24,Z+16
 5315 251c 9189      		ldd r25,Z+17
 5316 251e A289      		ldd r26,Z+18
 5317 2520 B389      		ldd r27,Z+19
 5318 2522 8487      		std Z+12,r24
 5319 2524 9587      		std Z+13,r25
 5320 2526 A687      		std Z+14,r26
 5321 2528 B787      		std Z+15,r27
4205:WTPA.c        **** 			realtimeOn[i]=false;								// We'll default to playback.
 5322               		.loc 1 4205 0 discriminator 2
 5323 252a D801      		movw r26,r16
 5324 252c 1D92      		st X+,__zero_reg__
 5325 252e 8D01      		movw r16,r26
4206:WTPA.c        **** 			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
 5326               		.loc 1 4206 0 discriminator 2
 5327 2530 1582      		std Z+5,__zero_reg__
4209:WTPA.c        **** 			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
 5328               		.loc 1 4209 0 discriminator 2
 5329 2532 8E2D      		mov r24,r14
 5330 2534 0E94 0000 		call RevertSampleToUnadjusted
 5331               	.LVL206:
 5332               	.LBB207:
 5333               	.LBB208:
3339:WTPA.c        **** 	if(theBank==BANK_0)
 5334               		.loc 1 3339 0 discriminator 2
 5335 2538 E110      		cpse r14,__zero_reg__
 5336 253a 00C0      		rjmp .L357
3341:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
 5337               		.loc 1 3341 0
 5338 253c 87E0      		ldi r24,lo8(7)
 5339 253e 00C0      		rjmp .L545
 5340               	.L357:
3345:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
 5341               		.loc 1 3345 0
 5342 2540 8BE0      		ldi r24,lo8(11)
 5343               	.L545:
 5344 2542 0E94 0000 		call EepromRead
 5345               	.LVL207:
3348:WTPA.c        **** 	if(x<90)					// Legit number?
 5346               		.loc 1 3348 0
 5347 2546 8A35      		cpi r24,lo8(90)
 5348 2548 00F0      		brlo .L359
3355:WTPA.c        **** 		return(x);
 5349               		.loc 1 3355 0
 5350 254a 80E3      		ldi r24,lo8(48)
 5351               	.LVL208:
 5352               	.L359:
 5353               	.LBE208:
 5354               	.LBE207:
 5355               	.LBB209:
 5356               	.LBB206:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5357               		.loc 1 3303 0
 5358 254c 6D2D      		mov r22,r13
 5359 254e 0E94 0000 		call __udivmodqi4
 5360               	.LVL209:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 5361               		.loc 1 3305 0
 5362 2552 E92F      		mov r30,r25
 5363 2554 F0E0      		ldi r31,0
 5364 2556 EE0F      		lsl r30
 5365 2558 FF1F      		rol r31
 5366 255a E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 5367 255c F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 5368 255e 2081      		ld r18,Z
 5369 2560 3181      		ldd r19,Z+1
 5370 2562 00C0      		rjmp 2f
 5371               		1:
 5372 2564 3695      		lsr r19
 5373 2566 2795      		ror r18
 5374               		2:
 5375 2568 8A95      		dec r24
 5376 256a 02F4      		brpl 1b
 5377               	.LBE206:
 5378               	.LBE209:
4212:WTPA.c        **** 			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful num
 5379               		.loc 1 4212 0
 5380 256c F401      		movw r30,r8
 5381 256e 2193      		st Z+,r18
 5382 2570 3193      		st Z+,r19
 5383 2572 4F01      		movw r8,r30
 5384 2574 FFEF      		ldi r31,-1
 5385 2576 EF1A      		sub r14,r31
 5386 2578 FF0A      		sbc r15,r31
 5387               	.LVL210:
4192:WTPA.c        **** 		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
 5388               		.loc 1 4192 0
 5389 257a 22E0      		ldi r18,2
 5390 257c E216      		cp r14,r18
 5391 257e F104      		cpc r15,__zero_reg__
 5392 2580 01F0      		breq .+2
 5393 2582 00C0      		rjmp .L360
4215:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 5394               		.loc 1 4215 0
 5395 2584 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5396 2586 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5397 2588 9093 0000 		sts UpdateOutput+1,r25
 5398 258c 8093 0000 		sts UpdateOutput,r24
4217:WTPA.c        **** 		currentBank=BANK_0;			// Point at the first bank until we change banks.
 5399               		.loc 1 4217 0
 5400 2590 1092 0000 		sts currentBank,__zero_reg__
4219:WTPA.c        **** 		KillLeds();					// All leds off, and no blinking.
 5401               		.loc 1 4219 0
 5402 2594 0E94 0000 		call KillLeds
 5403               	.LVL211:
4220:WTPA.c        **** 		subState=SS_1;
 5404               		.loc 1 4220 0
 5405 2598 81E0      		ldi r24,lo8(1)
 5406 259a 8093 0000 		sts subState,r24
 5407 259e 00C0      		rjmp .L361
 5408               	.LVL212:
 5409               	.L354:
4223:WTPA.c        **** 	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different s
 5410               		.loc 1 4223 0
 5411 25a0 41E0      		ldi r20,lo8(1)
 5412 25a2 F412      		cpse r15,r20
 5413 25a4 00C0      		rjmp .L361
 5414               	.LBB210:
 5415               	.LBB211:
3916:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
 5416               		.loc 1 3916 0
 5417 25a6 8091 0000 		lds r24,keysHeld
 5418 25aa 86FF      		sbrs r24,6
 5419 25ac 00C0      		rjmp .L363
 5420 25ae 87FF      		sbrs r24,7
 5421 25b0 00C0      		rjmp .L364
3918:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
 5422               		.loc 1 3918 0
 5423 25b2 8091 0000 		lds r24,newKeys
 5424 25b6 85FF      		sbrs r24,5
 5425 25b8 00C0      		rjmp .L365
3920:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
 5426               		.loc 1 3920 0
 5427 25ba 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5428 25bc 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5429 25be 9093 0000 		sts UpdateOutput+1,r25
 5430 25c2 8093 0000 		sts UpdateOutput,r24
3921:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
 5431               		.loc 1 3921 0
 5432 25c6 1091 0000 		lds r17,currentBank
 5433 25ca 812F      		mov r24,r17
 5434 25cc 0E94 0000 		call RevertSampleToUnadjusted
 5435               	.LVL213:
3922:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
 5436               		.loc 1 3922 0
 5437 25d0 83E2      		ldi r24,lo8(35)
 5438 25d2 189F      		mul r17,r24
 5439 25d4 F001      		movw r30,r0
 5440 25d6 1124      		clr __zero_reg__
 5441 25d8 E050      		subi r30,lo8(-(bankStates))
 5442 25da F040      		sbci r31,hi8(-(bankStates))
 5443 25dc 1086      		std Z+8,__zero_reg__
3923:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
 5444               		.loc 1 3923 0
 5445 25de 1782      		std Z+7,__zero_reg__
3924:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
 5446               		.loc 1 3924 0
 5447 25e0 1682      		std Z+6,__zero_reg__
3925:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
 5448               		.loc 1 3925 0
 5449 25e2 1282      		std Z+2,__zero_reg__
3926:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
 5450               		.loc 1 3926 0
 5451 25e4 1382      		std Z+3,__zero_reg__
3927:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
 5452               		.loc 1 3927 0
 5453 25e6 F482      		std Z+4,r15
3928:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
 5454               		.loc 1 3928 0
 5455 25e8 1182      		std Z+1,__zero_reg__
3929:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
 5456               		.loc 1 3929 0
 5457 25ea 20E0      		ldi r18,0
 5458 25ec 42E1      		ldi r20,lo8(18)
 5459 25ee 64E0      		ldi r22,lo8(4)
 5460 25f0 812F      		mov r24,r17
 5461 25f2 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5462               	.LVL214:
3930:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
 5463               		.loc 1 3930 0
 5464 25f6 20E0      		ldi r18,0
 5465 25f8 4BE1      		ldi r20,lo8(27)
 5466 25fa 64E0      		ldi r22,lo8(4)
 5467 25fc 8091 0000 		lds r24,currentBank
 5468 2600 00C0      		rjmp .L552
 5469               	.L365:
3932:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)
 5470               		.loc 1 3932 0
 5471 2602 80FF      		sbrs r24,0
 5472 2604 00C0      		rjmp .L367
3935:WTPA.c        **** 			WriteSampleToSd(currentBank,0);		// @@@ test
 5473               		.loc 1 3935 0
 5474 2606 1091 0000 		lds r17,currentBank
 5475               	.LVL215:
 5476               	.LBB212:
 5477               	.LBB213:
3089:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5478               		.loc 1 3089 0
 5479 260a 8091 0000 		lds r24,cardState
 5480 260e 8E30      		cpi r24,lo8(14)
 5481 2610 01F0      		breq .+2
 5482 2612 00C0      		rjmp .L366
3091:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5483               		.loc 1 3091 0
 5484 2614 212F      		mov r18,r17
 5485 2616 30E0      		ldi r19,0
 5486 2618 93E2      		ldi r25,lo8(35)
 5487 261a 199F      		mul r17,r25
 5488 261c D001      		movw r26,r0
 5489 261e 1124      		clr __zero_reg__
 5490 2620 A050      		subi r26,lo8(-(bankStates))
 5491 2622 B040      		sbci r27,hi8(-(bankStates))
 5492 2624 1596      		adiw r26, 5
 5493 2626 8C91      		ld r24,X
 5494 2628 1597      		sbiw r26, 5
 5495 262a 8111      		cpse r24,__zero_reg__
 5496 262c 00C0      		rjmp .L366
 5497               	.LVL216:
 5498               	.LBB214:
 5499               	.LBB215:
3051:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5500               		.loc 1 3051 0
 5501 262e 1696      		adiw r26, 6
 5502 2630 8C91      		ld r24,X
3049:WTPA.c        **** 	if(theBank==BANK_0)
 5503               		.loc 1 3049 0
 5504 2632 1111      		cpse r17,__zero_reg__
 5505 2634 00C0      		rjmp .L370
3051:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5506               		.loc 1 3051 0
 5507 2636 8111      		cpse r24,__zero_reg__
 5508 2638 00C0      		rjmp .L371
3053:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
 5509               		.loc 1 3053 0
 5510 263a 83E2      		ldi r24,lo8(35)
 5511 263c 829F      		mul r24,r18
 5512 263e A001      		movw r20,r0
 5513 2640 839F      		mul r24,r19
 5514 2642 500D      		add r21,r0
 5515 2644 1124      		clr __zero_reg__
 5516 2646 4050      		subi r20,lo8(-(bankStates))
 5517 2648 5040      		sbci r21,hi8(-(bankStates))
 5518 264a FA01      		movw r30,r20
 5519 264c 8489      		ldd r24,Z+20
 5520 264e 9589      		ldd r25,Z+21
 5521 2650 A689      		ldd r26,Z+22
 5522 2652 B789      		ldd r27,Z+23
 5523 2654 408D      		ldd r20,Z+24
 5524 2656 518D      		ldd r21,Z+25
 5525 2658 628D      		ldd r22,Z+26
 5526 265a 738D      		ldd r23,Z+27
 5527 265c 00C0      		rjmp .L560
 5528               	.L371:
3057:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
 5529               		.loc 1 3057 0
 5530 265e 83E2      		ldi r24,lo8(35)
 5531 2660 829F      		mul r24,r18
 5532 2662 D001      		movw r26,r0
 5533 2664 839F      		mul r24,r19
 5534 2666 B00D      		add r27,r0
 5535 2668 1124      		clr __zero_reg__
 5536 266a A050      		subi r26,lo8(-(bankStates))
 5537 266c B040      		sbci r27,hi8(-(bankStates))
 5538 266e 1C96      		adiw r26,12
 5539 2670 8D91      		ld r24,X+
 5540 2672 9D91      		ld r25,X+
 5541 2674 0D90      		ld __tmp_reg__,X+
 5542 2676 BC91      		ld r27,X
 5543 2678 A02D      		mov r26,__tmp_reg__
 5544               	.LVL217:
 5545 267a 00C0      		rjmp .L372
 5546               	.LVL218:
 5547               	.L370:
3062:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5548               		.loc 1 3062 0
 5549 267c 8111      		cpse r24,__zero_reg__
 5550 267e 00C0      		rjmp .L373
3064:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
 5551               		.loc 1 3064 0
 5552 2680 83E2      		ldi r24,lo8(35)
 5553 2682 829F      		mul r24,r18
 5554 2684 A001      		movw r20,r0
 5555 2686 839F      		mul r24,r19
 5556 2688 500D      		add r21,r0
 5557 268a 1124      		clr __zero_reg__
 5558 268c 4050      		subi r20,lo8(-(bankStates))
 5559 268e 5040      		sbci r21,hi8(-(bankStates))
 5560 2690 FA01      		movw r30,r20
 5561 2692 808D      		ldd r24,Z+24
 5562 2694 918D      		ldd r25,Z+25
 5563 2696 A28D      		ldd r26,Z+26
 5564 2698 B38D      		ldd r27,Z+27
 5565 269a 4489      		ldd r20,Z+20
 5566 269c 5589      		ldd r21,Z+21
 5567 269e 6689      		ldd r22,Z+22
 5568 26a0 7789      		ldd r23,Z+23
 5569               	.L560:
 5570 26a2 0196      		adiw r24,1
 5571 26a4 A11D      		adc r26,__zero_reg__
 5572 26a6 B11D      		adc r27,__zero_reg__
 5573 26a8 00C0      		rjmp .L546
 5574               	.L373:
3068:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
 5575               		.loc 1 3068 0
 5576 26aa 83E2      		ldi r24,lo8(35)
 5577 26ac 829F      		mul r24,r18
 5578 26ae A001      		movw r20,r0
 5579 26b0 839F      		mul r24,r19
 5580 26b2 500D      		add r21,r0
 5581 26b4 1124      		clr __zero_reg__
 5582 26b6 4050      		subi r20,lo8(-(bankStates))
 5583 26b8 5040      		sbci r21,hi8(-(bankStates))
 5584 26ba FA01      		movw r30,r20
 5585 26bc 8089      		ldd r24,Z+16
 5586 26be 9189      		ldd r25,Z+17
 5587 26c0 A289      		ldd r26,Z+18
 5588 26c2 B389      		ldd r27,Z+19
 5589 26c4 4485      		ldd r20,Z+12
 5590 26c6 5585      		ldd r21,Z+13
 5591 26c8 6685      		ldd r22,Z+14
 5592 26ca 7785      		ldd r23,Z+15
 5593               	.L546:
 5594 26cc 841B      		sub r24,r20
 5595 26ce 950B      		sbc r25,r21
 5596 26d0 A60B      		sbc r26,r22
 5597 26d2 B70B      		sbc r27,r23
 5598               	.LVL219:
 5599               	.L372:
 5600               	.LBE215:
 5601               	.LBE214:
3095:WTPA.c        **** 			sreg=SREG;
 5602               		.loc 1 3095 0
 5603 26d4 FFB7      		in r31,__SREG__
 5604               	.LVL220:
3096:WTPA.c        **** 			cli();		// Pause ISR
 5605               		.loc 1 3096 0
 5606               	/* #APP */
 5607               	 ;  3096 "WTPA.c" 1
 5608 26d6 F894      		cli
 5609               	 ;  0 "" 2
 5610               	.LVL221:
 5611               	/* #NOAPP */
 5612               	.LBB216:
 5613               	.LBB217:
2295:WTPA.c        **** 	sreg=SREG;
 5614               		.loc 1 2295 0
 5615 26d8 EFB7      		in r30,__SREG__
 5616               	.LVL222:
2296:WTPA.c        **** 	cli();		// Pause ISR
 5617               		.loc 1 2296 0
 5618               	/* #APP */
 5619               	 ;  2296 "WTPA.c" 1
 5620 26da F894      		cli
 5621               	 ;  0 "" 2
2298:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
 5622               		.loc 1 2298 0
 5623               	/* #NOAPP */
 5624 26dc 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 5625 26e0 1092 0000 		sts sdCurrentSlot,__zero_reg__
2299:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
 5626               		.loc 1 2299 0
 5627 26e4 41E0      		ldi r20,lo8(1)
 5628 26e6 50E0      		ldi r21,0
 5629 26e8 60E0      		ldi r22,0
 5630 26ea 70E0      		ldi r23,0
 5631 26ec 4093 0000 		sts sdSampleStartBlock,r20
 5632 26f0 5093 0000 		sts sdSampleStartBlock+1,r21
 5633 26f4 6093 0000 		sts sdSampleStartBlock+2,r22
 5634 26f8 7093 0000 		sts sdSampleStartBlock+3,r23
2300:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
 5635               		.loc 1 2300 0
 5636 26fc 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 5637 2700 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2302:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 5638               		.loc 1 2302 0
 5639 2704 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 5640 2708 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2303:WTPA.c        **** 	sdFifoWritePointer=0;
 5641               		.loc 1 2303 0
 5642 270c 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 5643 2710 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2304:WTPA.c        **** 	sdBytesInFifo=0;
 5644               		.loc 1 2304 0
 5645 2714 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 5646 2718 1092 0000 		sts sdBytesInFifo,__zero_reg__
2306:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
 5647               		.loc 1 2306 0
 5648 271c 8D3F      		cpi r24,-3
 5649 271e 4FEF      		ldi r20,-1
 5650 2720 9407      		cpc r25,r20
 5651 2722 47E0      		ldi r20,7
 5652 2724 A407      		cpc r26,r20
 5653 2726 B105      		cpc r27,__zero_reg__
 5654 2728 00F4      		brsh .L374
 5655 272a 00C0      		rjmp .L547
 5656               	.L374:
2312:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
 5657               		.loc 1 2312 0
 5658 272c 8CEF      		ldi r24,lo8(-4)
 5659 272e 9FEF      		ldi r25,lo8(-1)
 5660 2730 A7E0      		ldi r26,lo8(7)
 5661 2732 B0E0      		ldi r27,0
 5662               	.LVL223:
 5663               	.L547:
 5664 2734 8093 0000 		sts sdRamSampleRemaining,r24
 5665 2738 9093 0000 		sts sdRamSampleRemaining+1,r25
 5666 273c A093 0000 		sts sdRamSampleRemaining+2,r26
 5667 2740 B093 0000 		sts sdRamSampleRemaining+3,r27
2315:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
 5668               		.loc 1 2315 0
 5669 2744 8091 0000 		lds r24,sdRamSampleRemaining
 5670 2748 9091 0000 		lds r25,sdRamSampleRemaining+1
 5671 274c A091 0000 		lds r26,sdRamSampleRemaining+2
 5672 2750 B091 0000 		lds r27,sdRamSampleRemaining+3
 5673 2754 8093 0000 		sts sdCardSampleRemaining,r24
 5674 2758 9093 0000 		sts sdCardSampleRemaining+1,r25
 5675 275c A093 0000 		sts sdCardSampleRemaining+2,r26
 5676 2760 B093 0000 		sts sdCardSampleRemaining+3,r27
2316:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
 5677               		.loc 1 2316 0
 5678 2764 82E0      		ldi r24,lo8(2)
 5679 2766 8093 0000 		sts cardState,r24
2317:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 5680               		.loc 1 2317 0
 5681 276a EFBF      		out __SREG__,r30
 5682               	.LVL224:
 5683               	.LBE217:
 5684               	.LBE216:
 5685               	.LBB218:
 5686               	.LBB219:
2963:WTPA.c        **** 	sreg=SREG;
 5687               		.loc 1 2963 0
 5688 276c 4FB7      		in r20,__SREG__
 5689               	.LVL225:
2964:WTPA.c        **** 	cli();		// Pause ISRs
 5690               		.loc 1 2964 0
 5691               	/* #APP */
 5692               	 ;  2964 "WTPA.c" 1
 5693 276e F894      		cli
 5694               	 ;  0 "" 2
2966:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
 5695               		.loc 1 2966 0
 5696               	/* #NOAPP */
 5697 2770 8093 0000 		sts sdIsrState,r24
2967:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5698               		.loc 1 2967 0
 5699 2774 83E2      		ldi r24,lo8(35)
 5700 2776 829F      		mul r24,r18
 5701 2778 D001      		movw r26,r0
 5702 277a 839F      		mul r24,r19
 5703 277c B00D      		add r27,r0
 5704 277e 1124      		clr __zero_reg__
 5705 2780 A050      		subi r26,lo8(-(bankStates))
 5706 2782 B040      		sbci r27,hi8(-(bankStates))
 5707 2784 81E0      		ldi r24,lo8(1)
 5708 2786 1596      		adiw r26,5
 5709 2788 8C93      		st X,r24
2969:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5710               		.loc 1 2969 0
 5711 278a 1111      		cpse r17,__zero_reg__
 5712 278c 00C0      		rjmp .L376
2971:WTPA.c        **** 		sdBank0=true;
 5713               		.loc 1 2971 0
 5714 278e 8093 0000 		sts sdBank0,r24
2972:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5715               		.loc 1 2972 0
 5716 2792 1092 0000 		sts sdRamAddress,__zero_reg__
 5717 2796 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5718 279a 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5719 279e 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5720 27a2 00C0      		rjmp .L377
 5721               	.L376:
2976:WTPA.c        **** 		sdBank0=false;
 5722               		.loc 1 2976 0
 5723 27a4 1092 0000 		sts sdBank0,__zero_reg__
2977:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5724               		.loc 1 2977 0
 5725 27a8 8FEF      		ldi r24,lo8(-1)
 5726 27aa 9FEF      		ldi r25,lo8(-1)
 5727 27ac A7E0      		ldi r26,lo8(7)
 5728 27ae B0E0      		ldi r27,0
 5729 27b0 8093 0000 		sts sdRamAddress,r24
 5730 27b4 9093 0000 		sts sdRamAddress+1,r25
 5731 27b8 A093 0000 		sts sdRamAddress+2,r26
 5732 27bc B093 0000 		sts sdRamAddress+3,r27
 5733               	.L377:
2980:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5734               		.loc 1 2980 0
 5735 27c0 1092 B200 		sts 178,__zero_reg__
2981:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5736               		.loc 1 2981 0
 5737 27c4 81E6      		ldi r24,lo8(97)
 5738 27c6 8093 B300 		sts 179,r24
2982:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5739               		.loc 1 2982 0
 5740 27ca 8FEF      		ldi r24,lo8(-1)
 5741 27cc 87BB      		out 0x17,r24
2983:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5742               		.loc 1 2983 0
 5743 27ce 8091 7000 		lds r24,112
 5744 27d2 8460      		ori r24,lo8(4)
 5745 27d4 8093 7000 		sts 112,r24
2984:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5746               		.loc 1 2984 0
 5747 27d8 82E0      		ldi r24,lo8(2)
 5748 27da 8093 B100 		sts 177,r24
2986:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5749               		.loc 1 2986 0
 5750 27de 4FBF      		out __SREG__,r20
 5751               	.LBE219:
 5752               	.LBE218:
3101:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5753               		.loc 1 3101 0
 5754 27e0 FFBF      		out __SREG__,r31
 5755 27e2 00C0      		rjmp .L366
 5756               	.LVL226:
 5757               	.L367:
 5758               	.LBE213:
 5759               	.LBE212:
3937:WTPA.c        **** 		else if(newKeys&Im_SWITCH_1)
 5760               		.loc 1 3937 0
 5761 27e4 81FF      		sbrs r24,1
 5762 27e6 00C0      		rjmp .L366
3940:WTPA.c        **** 			ReadSampleFromSd(currentBank,0);	// @@@ test
 5763               		.loc 1 3940 0
 5764 27e8 1091 0000 		lds r17,currentBank
 5765               	.LVL227:
 5766               	.LBB220:
 5767               	.LBB221:
3112:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5768               		.loc 1 3112 0
 5769 27ec 8091 0000 		lds r24,cardState
 5770 27f0 8E30      		cpi r24,lo8(14)
 5771 27f2 01F0      		breq .+2
 5772 27f4 00C0      		rjmp .L366
3114:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5773               		.loc 1 3114 0
 5774 27f6 83E2      		ldi r24,lo8(35)
 5775 27f8 189F      		mul r17,r24
 5776 27fa 6001      		movw r12,r0
 5777 27fc 1124      		clr __zero_reg__
 5778 27fe A0E0      		ldi r26,lo8(bankStates)
 5779 2800 B0E0      		ldi r27,hi8(bankStates)
 5780 2802 CA0E      		add r12,r26
 5781 2804 DB1E      		adc r13,r27
 5782 2806 F601      		movw r30,r12
 5783 2808 8581      		ldd r24,Z+5
 5784 280a 8111      		cpse r24,__zero_reg__
 5785 280c 00C0      		rjmp .L366
3116:WTPA.c        **** 			sreg=SREG;
 5786               		.loc 1 3116 0
 5787 280e 0FB7      		in r16,__SREG__
 5788               	.LVL228:
3117:WTPA.c        **** 			cli();		// Pause ISR
 5789               		.loc 1 3117 0
 5790               	/* #APP */
 5791               	 ;  3117 "WTPA.c" 1
 5792 2810 F894      		cli
 5793               	 ;  0 "" 2
3119:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
 5794               		.loc 1 3119 0
 5795               	/* #NOAPP */
 5796 2812 80E0      		ldi r24,0
 5797 2814 90E0      		ldi r25,0
 5798 2816 0E94 0000 		call SdStartSampleRead
 5799               	.LVL229:
3120:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
 5800               		.loc 1 3120 0
 5801 281a 81E0      		ldi r24,lo8(1)
 5802 281c 90E0      		ldi r25,0
 5803 281e A0E0      		ldi r26,0
 5804 2820 B0E0      		ldi r27,0
 5805 2822 8093 0000 		sts sdRamSampleRemaining,r24
 5806 2826 9093 0000 		sts sdRamSampleRemaining+1,r25
 5807 282a A093 0000 		sts sdRamSampleRemaining+2,r26
 5808 282e B093 0000 		sts sdRamSampleRemaining+3,r27
 5809               	.LVL230:
 5810               	.LBB222:
 5811               	.LBB223:
2996:WTPA.c        **** 	sreg=SREG;
 5812               		.loc 1 2996 0
 5813 2832 2FB7      		in r18,__SREG__
 5814               	.LVL231:
2997:WTPA.c        **** 	cli();		// Pause ISRs
 5815               		.loc 1 2997 0
 5816               	/* #APP */
 5817               	 ;  2997 "WTPA.c" 1
 5818 2834 F894      		cli
 5819               	 ;  0 "" 2
2999:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
 5820               		.loc 1 2999 0
 5821               	/* #NOAPP */
 5822 2836 F092 0000 		sts sdIsrState,r15
3000:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5823               		.loc 1 3000 0
 5824 283a D601      		movw r26,r12
 5825 283c 1596      		adiw r26,5
 5826 283e FC92      		st X,r15
3002:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5827               		.loc 1 3002 0
 5828 2840 1111      		cpse r17,__zero_reg__
 5829 2842 00C0      		rjmp .L378
3004:WTPA.c        **** 		sdBank0=true;
 5830               		.loc 1 3004 0
 5831 2844 81E0      		ldi r24,lo8(1)
 5832 2846 8093 0000 		sts sdBank0,r24
3005:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5833               		.loc 1 3005 0
 5834 284a 1092 0000 		sts sdRamAddress,__zero_reg__
 5835 284e 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5836 2852 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5837 2856 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5838 285a 00C0      		rjmp .L379
 5839               	.L378:
3009:WTPA.c        **** 		sdBank0=false;
 5840               		.loc 1 3009 0
 5841 285c 1092 0000 		sts sdBank0,__zero_reg__
3010:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5842               		.loc 1 3010 0
 5843 2860 8FEF      		ldi r24,lo8(-1)
 5844 2862 9FEF      		ldi r25,lo8(-1)
 5845 2864 A7E0      		ldi r26,lo8(7)
 5846 2866 B0E0      		ldi r27,0
 5847 2868 8093 0000 		sts sdRamAddress,r24
 5848 286c 9093 0000 		sts sdRamAddress+1,r25
 5849 2870 A093 0000 		sts sdRamAddress+2,r26
 5850 2874 B093 0000 		sts sdRamAddress+3,r27
 5851               	.L379:
3013:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5852               		.loc 1 3013 0
 5853 2878 1092 B200 		sts 178,__zero_reg__
3014:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5854               		.loc 1 3014 0
 5855 287c 81E6      		ldi r24,lo8(97)
 5856 287e 8093 B300 		sts 179,r24
3015:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5857               		.loc 1 3015 0
 5858 2882 8FEF      		ldi r24,lo8(-1)
 5859 2884 87BB      		out 0x17,r24
3016:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5860               		.loc 1 3016 0
 5861 2886 8091 7000 		lds r24,112
 5862 288a 8460      		ori r24,lo8(4)
 5863 288c 8093 7000 		sts 112,r24
3017:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5864               		.loc 1 3017 0
 5865 2890 82E0      		ldi r24,lo8(2)
 5866 2892 8093 B100 		sts 177,r24
3019:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5867               		.loc 1 3019 0
 5868 2896 2FBF      		out __SREG__,r18
 5869               	.LBE223:
 5870               	.LBE222:
3123:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5871               		.loc 1 3123 0
 5872 2898 0FBF      		out __SREG__,r16
 5873 289a 00C0      		rjmp .L366
 5874               	.LVL232:
 5875               	.L364:
 5876               	.LBE221:
 5877               	.LBE220:
 5878               	.LBE211:
3948:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
 5879               		.loc 1 3948 0
 5880 289c 8091 0000 		lds r24,keyState
 5881               	.LBB230:
 5882 28a0 80FF      		sbrs r24,0
 5883 28a2 00C0      		rjmp .L380
3950:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pre
 5884               		.loc 1 3950 0
 5885 28a4 9091 0000 		lds r25,encoderValue
 5886 28a8 8091 0000 		lds r24,lastEncoderValue.2198
 5887 28ac 9817      		cp r25,r24
 5888 28ae 01F0      		breq .L380
3952:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
 5889               		.loc 1 3952 0
 5890 28b0 8091 0000 		lds r24,currentBank
 5891 28b4 2091 0000 		lds r18,scaledEncoderValue
 5892 28b8 B3E2      		ldi r27,lo8(35)
 5893 28ba 8B9F      		mul r24,r27
 5894 28bc F001      		movw r30,r0
 5895 28be 1124      		clr __zero_reg__
 5896 28c0 E050      		subi r30,lo8(-(bankStates))
 5897 28c2 F040      		sbci r31,hi8(-(bankStates))
 5898 28c4 2087      		std Z+8,r18
3953:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
 5899               		.loc 1 3953 0
 5900 28c6 43E1      		ldi r20,lo8(19)
 5901 28c8 64E0      		ldi r22,lo8(4)
 5902 28ca 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5903               	.LVL233:
 5904               	.L380:
 5905               	.LBE230:
3956:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
 5906               		.loc 1 3956 0
 5907 28ce 8091 0000 		lds r24,newKeys
 5908               	.LBB231:
 5909 28d2 81FF      		sbrs r24,1
 5910 28d4 00C0      		rjmp .L381
3958:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
 5911               		.loc 1 3958 0
 5912 28d6 8091 0000 		lds r24,currentBank
 5913 28da 23E2      		ldi r18,lo8(35)
 5914 28dc 829F      		mul r24,r18
 5915 28de F001      		movw r30,r0
 5916 28e0 1124      		clr __zero_reg__
 5917 28e2 E050      		subi r30,lo8(-(bankStates))
 5918 28e4 F040      		sbci r31,hi8(-(bankStates))
 5919 28e6 9281      		ldd r25,Z+2
 5920 28e8 9111      		cpse r25,__zero_reg__
 5921 28ea 00C0      		rjmp .L382
3960:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
 5922               		.loc 1 3960 0
 5923 28ec 91E0      		ldi r25,lo8(1)
 5924 28ee 9283      		std Z+2,r25
3961:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
 5925               		.loc 1 3961 0
 5926 28f0 20E4      		ldi r18,lo8(64)
 5927 28f2 00C0      		rjmp .L548
 5928               	.L382:
3965:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
 5929               		.loc 1 3965 0
 5930 28f4 1282      		std Z+2,__zero_reg__
3966:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
 5931               		.loc 1 3966 0
 5932 28f6 20E0      		ldi r18,0
 5933               	.L548:
 5934 28f8 40E1      		ldi r20,lo8(16)
 5935 28fa 64E0      		ldi r22,lo8(4)
 5936 28fc 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5937               	.LVL234:
 5938               	.L381:
 5939               	.LBE231:
3969:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
 5940               		.loc 1 3969 0
 5941 2900 8091 0000 		lds r24,newKeys
 5942               	.LBB232:
 5943 2904 82FF      		sbrs r24,2
 5944 2906 00C0      		rjmp .L383
3971:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
 5945               		.loc 1 3971 0
 5946 2908 1091 0000 		lds r17,currentBank
 5947 290c 40E0      		ldi r20,0
 5948 290e 50E0      		ldi r21,0
 5949 2910 61E0      		ldi r22,lo8(1)
 5950 2912 812F      		mov r24,r17
 5951 2914 0E94 0000 		call StartRealtime
 5952               	.LVL235:
3972:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
 5953               		.loc 1 3972 0
 5954 2918 20E3      		ldi r18,lo8(48)
 5955 291a 4EE0      		ldi r20,lo8(14)
 5956 291c 64E0      		ldi r22,lo8(4)
 5957 291e 812F      		mov r24,r17
 5958 2920 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5959               	.LVL236:
 5960               	.L383:
 5961               	.LBE232:
3974:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granula
 5962               		.loc 1 3974 0
 5963 2924 8091 0000 		lds r24,keyState
 5964               	.LBB233:
 5965 2928 83FF      		sbrs r24,3
 5966 292a 00C0      		rjmp .L384
 5967 292c 9091 0000 		lds r25,encoderValue
 5968 2930 8091 0000 		lds r24,lastEncoderValue.2198
 5969 2934 9813      		cpse r25,r24
 5970 2936 00C0      		rjmp .L385
 5971               	.L384:
 5972               	.LBE233:
 5973 2938 8091 0000 		lds r24,newKeys
 5974               	.LBB234:
 5975 293c 83FF      		sbrs r24,3
 5976 293e 00C0      		rjmp .L386
 5977               	.L385:
3976:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
 5978               		.loc 1 3976 0
 5979 2940 2091 0000 		lds r18,encoderValue
 5980 2944 2695      		lsr r18
 5981 2946 1091 0000 		lds r17,currentBank
 5982 294a 622F      		mov r22,r18
 5983 294c 812F      		mov r24,r17
 5984 294e 2983      		std Y+1,r18
 5985 2950 0E94 0000 		call MakeNewGranularArray
 5986               	.LVL237:
3977:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
 5987               		.loc 1 3977 0
 5988 2954 2981      		ldd r18,Y+1
 5989 2956 44E1      		ldi r20,lo8(20)
 5990 2958 64E0      		ldi r22,lo8(4)
 5991 295a 812F      		mov r24,r17
 5992 295c 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5993               	.LVL238:
 5994               	.L386:
 5995               	.LBE234:
3979:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
 5996               		.loc 1 3979 0
 5997 2960 8091 0000 		lds r24,keyState
 5998               	.LBB235:
 5999 2964 84FF      		sbrs r24,4
 6000 2966 00C0      		rjmp .L387
3981:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only change to new values
 6001               		.loc 1 3981 0
 6002 2968 9091 0000 		lds r25,encoderValue
 6003 296c 8091 0000 		lds r24,lastEncoderValue.2198
 6004 2970 9817      		cp r25,r24
 6005 2972 01F0      		breq .L387
3983:WTPA.c        **** 				switch(scaledEncoderValue)
 6006               		.loc 1 3983 0
 6007 2974 8091 0000 		lds r24,scaledEncoderValue
 6008 2978 8130      		cpi r24,lo8(1)
 6009 297a 01F0      		breq .L389
 6010 297c 00F0      		brlo .L388
 6011 297e 8230      		cpi r24,lo8(2)
 6012 2980 01F0      		breq .L390
 6013 2982 8330      		cpi r24,lo8(3)
 6014 2984 01F4      		brne .L387
 6015 2986 00C0      		rjmp .L391
 6016               	.L388:
3986:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
 6017               		.loc 1 3986 0
 6018 2988 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6019 298a 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6020 298c 9093 0000 		sts UpdateOutput+1,r25
 6021 2990 8093 0000 		sts UpdateOutput,r24
3987:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6022               		.loc 1 3987 0
 6023 2994 20E0      		ldi r18,0
 6024 2996 00C0      		rjmp .L549
 6025               	.L389:
3991:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
 6026               		.loc 1 3991 0
 6027 2998 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 6028 299a 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 6029 299c 9093 0000 		sts UpdateOutput+1,r25
 6030 29a0 8093 0000 		sts UpdateOutput,r24
3992:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6031               		.loc 1 3992 0
 6032 29a4 21E0      		ldi r18,lo8(1)
 6033 29a6 00C0      		rjmp .L549
 6034               	.L390:
3996:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
 6035               		.loc 1 3996 0
 6036 29a8 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 6037 29aa 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 6038 29ac 9093 0000 		sts UpdateOutput+1,r25
 6039 29b0 8093 0000 		sts UpdateOutput,r24
3997:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6040               		.loc 1 3997 0
 6041 29b4 22E0      		ldi r18,lo8(2)
 6042 29b6 00C0      		rjmp .L549
 6043               	.L391:
4001:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
 6044               		.loc 1 4001 0
 6045 29b8 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 6046 29ba 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 6047 29bc 9093 0000 		sts UpdateOutput+1,r25
 6048 29c0 8093 0000 		sts UpdateOutput,r24
4002:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6049               		.loc 1 4002 0
 6050 29c4 23E0      		ldi r18,lo8(3)
 6051               	.L549:
 6052 29c6 46E1      		ldi r20,lo8(22)
 6053 29c8 64E0      		ldi r22,lo8(4)
 6054 29ca 8091 0000 		lds r24,currentBank
 6055 29ce 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6056               	.LVL239:
 6057               	.L387:
 6058               	.LBE235:
4010:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
 6059               		.loc 1 4010 0
 6060 29d2 8091 0000 		lds r24,newKeys
 6061               	.LBB236:
 6062 29d6 85FF      		sbrs r24,5
 6063 29d8 00C0      		rjmp .L366
4012:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
 6064               		.loc 1 4012 0
 6065 29da 8091 0000 		lds r24,currentBank
 6066 29de 43E2      		ldi r20,lo8(35)
 6067 29e0 849F      		mul r24,r20
 6068 29e2 F001      		movw r30,r0
 6069 29e4 1124      		clr __zero_reg__
 6070 29e6 E050      		subi r30,lo8(-(bankStates))
 6071 29e8 F040      		sbci r31,hi8(-(bankStates))
 6072 29ea 9381      		ldd r25,Z+3
 6073 29ec 9111      		cpse r25,__zero_reg__
 6074 29ee 00C0      		rjmp .L392
4014:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
 6075               		.loc 1 4014 0
 6076 29f0 91E0      		ldi r25,lo8(1)
 6077 29f2 9383      		std Z+3,r25
4015:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
 6078               		.loc 1 4015 0
 6079 29f4 20E4      		ldi r18,lo8(64)
 6080 29f6 00C0      		rjmp .L550
 6081               	.L392:
4019:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
 6082               		.loc 1 4019 0
 6083 29f8 1382      		std Z+3,__zero_reg__
4020:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
 6084               		.loc 1 4020 0
 6085 29fa 20E0      		ldi r18,0
 6086               	.L550:
 6087 29fc 41E1      		ldi r20,lo8(17)
 6088 29fe 64E0      		ldi r22,lo8(4)
 6089 2a00 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6090               	.LVL240:
4023:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
 6091               		.loc 1 4023 0
 6092 2a04 8091 0000 		lds r24,currentBank
 6093 2a08 0E94 0000 		call UpdateAdjustedSampleAddresses
 6094               	.LVL241:
 6095 2a0c 00C0      		rjmp .L366
 6096               	.L363:
4029:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
 6097               		.loc 1 4029 0
 6098 2a0e 87FF      		sbrs r24,7
 6099 2a10 00C0      		rjmp .L394
4031:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
 6100               		.loc 1 4031 0
 6101 2a12 8091 0000 		lds r24,keyState
 6102 2a16 80FF      		sbrs r24,0
 6103 2a18 00C0      		rjmp .L395
4033:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
 6104               		.loc 1 4033 0
 6105 2a1a 1091 0000 		lds r17,currentBank
 6106 2a1e 83E2      		ldi r24,lo8(35)
 6107 2a20 189F      		mul r17,r24
 6108 2a22 F001      		movw r30,r0
 6109 2a24 1124      		clr __zero_reg__
 6110 2a26 E050      		subi r30,lo8(-(bankStates))
 6111 2a28 F040      		sbci r31,hi8(-(bankStates))
 6112 2a2a 848D      		ldd r24,Z+28
 6113 2a2c 0091 0000 		lds r16,encoderValue
 6114 2a30 8017      		cp r24,r16
 6115 2a32 01F0      		breq .L396
 6116               	.LVL242:
 6117               	.LBB224:
 6118               	.LBB225:
3867:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6119               		.loc 1 3867 0
 6120 2a34 048F      		std Z+28,r16
3868:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6121               		.loc 1 3868 0
 6122 2a36 812F      		mov r24,r17
 6123 2a38 0E94 0000 		call UpdateAdjustedSampleAddresses
 6124               	.LVL243:
 6125               	.LBE225:
 6126               	.LBE224:
4036:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
 6127               		.loc 1 4036 0
 6128 2a3c 202F      		mov r18,r16
 6129 2a3e 2695      		lsr r18
 6130 2a40 4CE1      		ldi r20,lo8(28)
 6131 2a42 00C0      		rjmp .L551
 6132               	.LVL244:
 6133               	.L395:
4039:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
 6134               		.loc 1 4039 0
 6135 2a44 81FF      		sbrs r24,1
 6136 2a46 00C0      		rjmp .L397
4041:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
 6137               		.loc 1 4041 0
 6138 2a48 1091 0000 		lds r17,currentBank
 6139 2a4c 93E2      		ldi r25,lo8(35)
 6140 2a4e 199F      		mul r17,r25
 6141 2a50 F001      		movw r30,r0
 6142 2a52 1124      		clr __zero_reg__
 6143 2a54 E050      		subi r30,lo8(-(bankStates))
 6144 2a56 F040      		sbci r31,hi8(-(bankStates))
 6145 2a58 858D      		ldd r24,Z+29
 6146 2a5a 0091 0000 		lds r16,encoderValue
 6147 2a5e 8017      		cp r24,r16
 6148 2a60 01F0      		breq .L396
 6149               	.LVL245:
 6150               	.LBB226:
 6151               	.LBB227:
3876:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6152               		.loc 1 3876 0
 6153 2a62 058F      		std Z+29,r16
3877:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6154               		.loc 1 3877 0
 6155 2a64 812F      		mov r24,r17
 6156 2a66 0E94 0000 		call UpdateAdjustedSampleAddresses
 6157               	.LVL246:
 6158               	.LBE227:
 6159               	.LBE226:
4044:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
 6160               		.loc 1 4044 0
 6161 2a6a 202F      		mov r18,r16
 6162 2a6c 2695      		lsr r18
 6163 2a6e 4DE1      		ldi r20,lo8(29)
 6164 2a70 00C0      		rjmp .L551
 6165               	.LVL247:
 6166               	.L397:
4047:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
 6167               		.loc 1 4047 0
 6168 2a72 82FF      		sbrs r24,2
 6169 2a74 00C0      		rjmp .L396
4049:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
 6170               		.loc 1 4049 0
 6171 2a76 1091 0000 		lds r17,currentBank
 6172 2a7a A3E2      		ldi r26,lo8(35)
 6173 2a7c 1A9F      		mul r17,r26
 6174 2a7e F001      		movw r30,r0
 6175 2a80 1124      		clr __zero_reg__
 6176 2a82 E050      		subi r30,lo8(-(bankStates))
 6177 2a84 F040      		sbci r31,hi8(-(bankStates))
 6178 2a86 868D      		ldd r24,Z+30
 6179 2a88 0091 0000 		lds r16,encoderValue
 6180 2a8c 8017      		cp r24,r16
 6181 2a8e 01F0      		breq .L396
 6182               	.LVL248:
 6183               	.LBB228:
 6184               	.LBB229:
3885:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 6185               		.loc 1 3885 0
 6186 2a90 068F      		std Z+30,r16
3886:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6187               		.loc 1 3886 0
 6188 2a92 812F      		mov r24,r17
 6189 2a94 0E94 0000 		call UpdateAdjustedSampleAddresses
 6190               	.LVL249:
 6191               	.LBE229:
 6192               	.LBE228:
4052:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
 6193               		.loc 1 4052 0
 6194 2a98 202F      		mov r18,r16
 6195 2a9a 2695      		lsr r18
 6196 2a9c 4EE1      		ldi r20,lo8(30)
 6197               	.LVL250:
 6198               	.L551:
 6199 2a9e 64E0      		ldi r22,lo8(4)
 6200 2aa0 812F      		mov r24,r17
 6201 2aa2 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6202               	.LVL251:
 6203               	.L396:
 6204               	.LBE236:
4056:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
 6205               		.loc 1 4056 0
 6206 2aa6 8091 0000 		lds r24,newKeys
 6207               	.LBB237:
 6208 2aaa 83FF      		sbrs r24,3
 6209 2aac 00C0      		rjmp .L366
4059:WTPA.c        **** 			PlaySampleFromSd(0);			// @@@ stream from slot 0
 6210               		.loc 1 4059 0
 6211 2aae 80E0      		ldi r24,0
 6212 2ab0 90E0      		ldi r25,0
 6213 2ab2 0E94 0000 		call PlaySampleFromSd
 6214               	.LVL252:
 6215 2ab6 00C0      		rjmp .L366
 6216               	.L394:
4072:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
 6217               		.loc 1 4072 0
 6218 2ab8 8091 0000 		lds r24,newKeys
 6219 2abc 80FF      		sbrs r24,0
 6220 2abe 00C0      		rjmp .L398
4074:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6221               		.loc 1 4074 0
 6222 2ac0 1091 0000 		lds r17,currentBank
 6223 2ac4 B3E2      		ldi r27,lo8(35)
 6224 2ac6 1B9F      		mul r17,r27
 6225 2ac8 7001      		movw r14,r0
 6226 2aca 1124      		clr __zero_reg__
 6227 2acc E0E0      		ldi r30,lo8(bankStates)
 6228 2ace F0E0      		ldi r31,hi8(bankStates)
 6229 2ad0 EE0E      		add r14,r30
 6230 2ad2 FF1E      		adc r15,r31
 6231 2ad4 D701      		movw r26,r14
 6232 2ad6 8C91      		ld r24,X
4076:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6233               		.loc 1 4076 0
 6234 2ad8 40E0      		ldi r20,0
 6235 2ada 50E0      		ldi r21,0
 6236 2adc 61E0      		ldi r22,lo8(1)
4074:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6237               		.loc 1 4074 0
 6238 2ade 8330      		cpi r24,lo8(3)
 6239 2ae0 01F4      		brne .L399
4076:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6240               		.loc 1 4076 0
 6241 2ae2 812F      		mov r24,r17
 6242 2ae4 0E94 0000 		call StartPlayback
 6243               	.LVL253:
4077:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6244               		.loc 1 4077 0
 6245 2ae8 F701      		movw r30,r14
 6246 2aea 1182      		std Z+1,__zero_reg__
4078:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6247               		.loc 1 4078 0
 6248 2aec 20E4      		ldi r18,lo8(64)
 6249 2aee 40E3      		ldi r20,lo8(48)
 6250 2af0 61E0      		ldi r22,lo8(1)
 6251 2af2 00C0      		rjmp .L561
 6252               	.L399:
4082:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
 6253               		.loc 1 4082 0
 6254 2af4 812F      		mov r24,r17
 6255 2af6 0E94 0000 		call StartRecording
 6256               	.LVL254:
4083:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
 6257               		.loc 1 4083 0
 6258 2afa 20E3      		ldi r18,lo8(48)
 6259 2afc 43E0      		ldi r20,lo8(3)
 6260 2afe 64E0      		ldi r22,lo8(4)
 6261               	.L561:
 6262 2b00 812F      		mov r24,r17
 6263 2b02 00C0      		rjmp .L552
 6264               	.L398:
4086:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
 6265               		.loc 1 4086 0
 6266 2b04 81FF      		sbrs r24,1
 6267 2b06 00C0      		rjmp .L400
4088:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
 6268               		.loc 1 4088 0
 6269 2b08 F090 0000 		lds r15,currentBank
 6270 2b0c F3E2      		ldi r31,lo8(35)
 6271 2b0e FF9E      		mul r15,r31
 6272 2b10 6001      		movw r12,r0
 6273 2b12 1124      		clr __zero_reg__
 6274 2b14 80E0      		ldi r24,lo8(bankStates)
 6275 2b16 90E0      		ldi r25,hi8(bankStates)
 6276 2b18 C80E      		add r12,r24
 6277 2b1a D91E      		adc r13,r25
 6278 2b1c D601      		movw r26,r12
 6279 2b1e 8C91      		ld r24,X
 6280 2b20 8530      		cpi r24,lo8(5)
 6281 2b22 01F4      		brne .L401
4090:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
 6282               		.loc 1 4090 0
 6283 2b24 40E0      		ldi r20,0
 6284 2b26 50E0      		ldi r21,0
 6285 2b28 61E0      		ldi r22,lo8(1)
 6286 2b2a 8F2D      		mov r24,r15
 6287 2b2c 0E94 0000 		call ContinuePlayback
 6288               	.LVL255:
4091:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6289               		.loc 1 4091 0
 6290 2b30 F601      		movw r30,r12
 6291 2b32 1182      		std Z+1,__zero_reg__
4092:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
 6292               		.loc 1 4092 0
 6293 2b34 20E0      		ldi r18,0
 6294 2b36 00C0      		rjmp .L563
 6295               	.L401:
4096:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
 6296               		.loc 1 4096 0
 6297 2b38 D601      		movw r26,r12
 6298 2b3a 5096      		adiw r26,16
 6299 2b3c 0D91      		ld r16,X+
 6300 2b3e 1D91      		ld r17,X+
 6301 2b40 2D91      		ld r18,X+
 6302 2b42 3C91      		ld r19,X
 6303 2b44 5397      		sbiw r26,16+3
 6304 2b46 1C96      		adiw r26,12
 6305 2b48 4D91      		ld r20,X+
 6306 2b4a 5D91      		ld r21,X+
 6307 2b4c 6D91      		ld r22,X+
 6308 2b4e 7C91      		ld r23,X
 6309 2b50 1F97      		sbiw r26,12+3
 6310 2b52 0417      		cp r16,r20
 6311 2b54 1507      		cpc r17,r21
 6312 2b56 2607      		cpc r18,r22
 6313 2b58 3707      		cpc r19,r23
 6314 2b5a 01F4      		brne .+2
 6315 2b5c 00C0      		rjmp .L366
4098:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
 6316               		.loc 1 4098 0
 6317 2b5e 40E0      		ldi r20,0
 6318 2b60 50E0      		ldi r21,0
 6319 2b62 61E0      		ldi r22,lo8(1)
 6320 2b64 8F2D      		mov r24,r15
 6321 2b66 0E94 0000 		call StartOverdub
 6322               	.LVL256:
4099:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
 6323               		.loc 1 4099 0
 6324 2b6a 20E3      		ldi r18,lo8(48)
 6325               	.L563:
 6326 2b6c 49E0      		ldi r20,lo8(9)
 6327 2b6e 64E0      		ldi r22,lo8(4)
 6328 2b70 00C0      		rjmp .L562
 6329               	.L400:
4103:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
 6330               		.loc 1 4103 0
 6331 2b72 82FF      		sbrs r24,2
 6332 2b74 00C0      		rjmp .L402
4105:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6333               		.loc 1 4105 0
 6334 2b76 F090 0000 		lds r15,currentBank
 6335 2b7a B3E2      		ldi r27,lo8(35)
 6336 2b7c FB9E      		mul r15,r27
 6337 2b7e 6001      		movw r12,r0
 6338 2b80 1124      		clr __zero_reg__
 6339 2b82 E0E0      		ldi r30,lo8(bankStates)
 6340 2b84 F0E0      		ldi r31,hi8(bankStates)
 6341 2b86 CE0E      		add r12,r30
 6342 2b88 DF1E      		adc r13,r31
 6343 2b8a D601      		movw r26,r12
 6344 2b8c 5096      		adiw r26,16
 6345 2b8e 0D91      		ld r16,X+
 6346 2b90 1D91      		ld r17,X+
 6347 2b92 2D91      		ld r18,X+
 6348 2b94 3C91      		ld r19,X
 6349 2b96 5397      		sbiw r26,16+3
 6350 2b98 1C96      		adiw r26,12
 6351 2b9a 4D91      		ld r20,X+
 6352 2b9c 5D91      		ld r21,X+
 6353 2b9e 6D91      		ld r22,X+
 6354 2ba0 7C91      		ld r23,X
 6355 2ba2 1F97      		sbiw r26,12+3
 6356 2ba4 0417      		cp r16,r20
 6357 2ba6 1507      		cpc r17,r21
 6358 2ba8 2607      		cpc r18,r22
 6359 2baa 3707      		cpc r19,r23
 6360 2bac 01F4      		brne .+2
 6361 2bae 00C0      		rjmp .L366
4107:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6362               		.loc 1 4107 0
 6363 2bb0 40E0      		ldi r20,0
 6364 2bb2 50E0      		ldi r21,0
 6365 2bb4 61E0      		ldi r22,lo8(1)
 6366 2bb6 8F2D      		mov r24,r15
 6367 2bb8 0E94 0000 		call StartPlayback
 6368               	.LVL257:
4108:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6369               		.loc 1 4108 0
 6370 2bbc F601      		movw r30,r12
 6371 2bbe 1182      		std Z+1,__zero_reg__
 6372 2bc0 00C0      		rjmp .L564
 6373               	.L402:
4112:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
 6374               		.loc 1 4112 0
 6375 2bc2 83FF      		sbrs r24,3
 6376 2bc4 00C0      		rjmp .L403
4114:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6377               		.loc 1 4114 0
 6378 2bc6 E090 0000 		lds r14,currentBank
 6379 2bca F3E2      		ldi r31,lo8(35)
 6380 2bcc EF9E      		mul r14,r31
 6381 2bce 6001      		movw r12,r0
 6382 2bd0 1124      		clr __zero_reg__
 6383 2bd2 80E0      		ldi r24,lo8(bankStates)
 6384 2bd4 90E0      		ldi r25,hi8(bankStates)
 6385 2bd6 C80E      		add r12,r24
 6386 2bd8 D91E      		adc r13,r25
 6387 2bda D601      		movw r26,r12
 6388 2bdc 5096      		adiw r26,16
 6389 2bde 0D91      		ld r16,X+
 6390 2be0 1D91      		ld r17,X+
 6391 2be2 2D91      		ld r18,X+
 6392 2be4 3C91      		ld r19,X
 6393 2be6 5397      		sbiw r26,16+3
 6394 2be8 1C96      		adiw r26,12
 6395 2bea 4D91      		ld r20,X+
 6396 2bec 5D91      		ld r21,X+
 6397 2bee 6D91      		ld r22,X+
 6398 2bf0 7C91      		ld r23,X
 6399 2bf2 1F97      		sbiw r26,12+3
 6400 2bf4 0417      		cp r16,r20
 6401 2bf6 1507      		cpc r17,r21
 6402 2bf8 2607      		cpc r18,r22
 6403 2bfa 3707      		cpc r19,r23
 6404 2bfc 01F4      		brne .+2
 6405 2bfe 00C0      		rjmp .L366
4116:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
 6406               		.loc 1 4116 0
 6407 2c00 40E0      		ldi r20,0
 6408 2c02 50E0      		ldi r21,0
 6409 2c04 61E0      		ldi r22,lo8(1)
 6410 2c06 8E2D      		mov r24,r14
 6411 2c08 0E94 0000 		call StartPlayback
 6412               	.LVL258:
4117:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
 6413               		.loc 1 4117 0
 6414 2c0c F601      		movw r30,r12
 6415 2c0e F182      		std Z+1,r15
4118:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6416               		.loc 1 4118 0
 6417 2c10 20E4      		ldi r18,lo8(64)
 6418 2c12 40E3      		ldi r20,lo8(48)
 6419 2c14 61E0      		ldi r22,lo8(1)
 6420 2c16 8E2D      		mov r24,r14
 6421               	.L552:
 6422 2c18 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6423               	.LVL259:
 6424 2c1c 00C0      		rjmp .L366
 6425               	.L403:
4121:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
 6426               		.loc 1 4121 0
 6427 2c1e 84FF      		sbrs r24,4
 6428 2c20 00C0      		rjmp .L404
4123:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
 6429               		.loc 1 4123 0
 6430 2c22 F090 0000 		lds r15,currentBank
 6431 2c26 2F2D      		mov r18,r15
 6432 2c28 30E0      		ldi r19,0
 6433 2c2a 43E2      		ldi r20,lo8(35)
 6434 2c2c F49E      		mul r15,r20
 6435 2c2e F001      		movw r30,r0
 6436 2c30 1124      		clr __zero_reg__
 6437 2c32 E050      		subi r30,lo8(-(bankStates))
 6438 2c34 F040      		sbci r31,hi8(-(bankStates))
 6439 2c36 8081      		ld r24,Z
 6440 2c38 8111      		cpse r24,__zero_reg__
 6441 2c3a 00C0      		rjmp .L405
4125:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 6442               		.loc 1 4125 0
 6443 2c3c 83E2      		ldi r24,lo8(35)
 6444 2c3e 829F      		mul r24,r18
 6445 2c40 F001      		movw r30,r0
 6446 2c42 839F      		mul r24,r19
 6447 2c44 F00D      		add r31,r0
 6448 2c46 1124      		clr __zero_reg__
 6449 2c48 E050      		subi r30,lo8(-(bankStates))
 6450 2c4a F040      		sbci r31,hi8(-(bankStates))
 6451 2c4c 0089      		ldd r16,Z+16
 6452 2c4e 1189      		ldd r17,Z+17
 6453 2c50 2289      		ldd r18,Z+18
 6454 2c52 3389      		ldd r19,Z+19
 6455 2c54 4485      		ldd r20,Z+12
 6456 2c56 5585      		ldd r21,Z+13
 6457 2c58 6685      		ldd r22,Z+14
 6458 2c5a 7785      		ldd r23,Z+15
 6459 2c5c 0417      		cp r16,r20
 6460 2c5e 1507      		cpc r17,r21
 6461 2c60 2607      		cpc r18,r22
 6462 2c62 3707      		cpc r19,r23
 6463 2c64 01F0      		breq .L366
4127:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
 6464               		.loc 1 4127 0
 6465 2c66 40E0      		ldi r20,0
 6466 2c68 50E0      		ldi r21,0
 6467 2c6a 61E0      		ldi r22,lo8(1)
 6468 2c6c 8F2D      		mov r24,r15
 6469 2c6e 0E94 0000 		call ContinuePlayback
 6470               	.LVL260:
 6471               	.L564:
4128:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
 6472               		.loc 1 4128 0
 6473 2c72 20E4      		ldi r18,lo8(64)
 6474 2c74 40E3      		ldi r20,lo8(48)
 6475 2c76 61E0      		ldi r22,lo8(1)
 6476 2c78 00C0      		rjmp .L562
 6477               	.L405:
4133:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
 6478               		.loc 1 4133 0
 6479 2c7a 83E2      		ldi r24,lo8(35)
 6480 2c7c 829F      		mul r24,r18
 6481 2c7e F001      		movw r30,r0
 6482 2c80 839F      		mul r24,r19
 6483 2c82 F00D      		add r31,r0
 6484 2c84 1124      		clr __zero_reg__
 6485 2c86 E050      		subi r30,lo8(-(bankStates))
 6486 2c88 F040      		sbci r31,hi8(-(bankStates))
 6487 2c8a 1082      		st Z,__zero_reg__
4134:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
 6488               		.loc 1 4134 0
 6489 2c8c 1186      		std Z+9,__zero_reg__
4135:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
 6490               		.loc 1 4135 0
 6491 2c8e 20E0      		ldi r18,0
 6492 2c90 40E3      		ldi r20,lo8(48)
 6493 2c92 62E0      		ldi r22,lo8(2)
 6494               	.L562:
 6495 2c94 8F2D      		mov r24,r15
 6496 2c96 00C0      		rjmp .L552
 6497               	.L404:
4139:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
 6498               		.loc 1 4139 0
 6499 2c98 85FF      		sbrs r24,5
 6500 2c9a 00C0      		rjmp .L366
4141:WTPA.c        **** 			currentBank++;
 6501               		.loc 1 4141 0
 6502 2c9c 8091 0000 		lds r24,currentBank
 6503 2ca0 8F5F      		subi r24,lo8(-(1))
 6504 2ca2 8093 0000 		sts currentBank,r24
4142:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
 6505               		.loc 1 4142 0
 6506 2ca6 8230      		cpi r24,lo8(2)
 6507 2ca8 00F0      		brlo .L366
4144:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
 6508               		.loc 1 4144 0
 6509 2caa 1092 0000 		sts currentBank,__zero_reg__
 6510               	.L366:
4149:WTPA.c        **** 	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
 6511               		.loc 1 4149 0
 6512 2cae 8091 0000 		lds r24,encoderValue
 6513 2cb2 8093 0000 		sts lastEncoderValue.2198,r24
 6514               	.LBE237:
 6515               	.LBE210:
4227:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
 6516               		.loc 1 4227 0
 6517 2cb6 8091 0000 		lds r24,midiMessagesInIncomingFifo
 6518 2cba 8823      		tst r24
 6519 2cbc 01F4      		brne .+2
 6520 2cbe 00C0      		rjmp .L361
4229:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
 6521               		.loc 1 4229 0
 6522 2cc0 80E0      		ldi r24,lo8(currentMidiMessage.2209)
 6523 2cc2 90E0      		ldi r25,hi8(currentMidiMessage.2209)
 6524 2cc4 0E94 0000 		call GetMidiMessageFromIncomingFifo
 6525               	.LVL261:
4236:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
 6526               		.loc 1 4236 0
 6527 2cc8 8091 0000 		lds r24,currentMidiMessage.2209+1
 6528 2ccc 8230      		cpi r24,lo8(2)
 6529 2cce 01F4      		brne .L407
4238:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6530               		.loc 1 4238 0
 6531 2cd0 E091 0000 		lds r30,currentMidiMessage.2209
 6532 2cd4 8E2F      		mov r24,r30
 6533 2cd6 90E0      		ldi r25,0
 6534 2cd8 A3E2      		ldi r26,lo8(35)
 6535 2cda EA9F      		mul r30,r26
 6536 2cdc F001      		movw r30,r0
 6537 2cde 1124      		clr __zero_reg__
 6538 2ce0 E050      		subi r30,lo8(-(bankStates))
 6539 2ce2 F040      		sbci r31,hi8(-(bankStates))
 6540 2ce4 2081      		ld r18,Z
 6541 2ce6 2430      		cpi r18,lo8(4)
 6542 2ce8 01F0      		breq .L408
4238:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6543               		.loc 1 4238 0 is_stmt 0 discriminator 1
 6544 2cea 2081      		ld r18,Z
 6545 2cec 2230      		cpi r18,lo8(2)
 6546 2cee 01F0      		breq .+2
 6547 2cf0 00C0      		rjmp .L361
 6548               	.L408:
4240:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
 6549               		.loc 1 4240 0 is_stmt 1
 6550 2cf2 FC01      		movw r30,r24
 6551 2cf4 E050      		subi r30,lo8(-(currentNoteOn.2210))
 6552 2cf6 F040      		sbci r31,hi8(-(currentNoteOn.2210))
 6553 2cf8 3091 0000 		lds r19,currentMidiMessage.2209+2
 6554 2cfc 2081      		ld r18,Z
 6555 2cfe 3213      		cpse r19,r18
 6556 2d00 00C0      		rjmp .L361
4242:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
 6557               		.loc 1 4242 0
 6558 2d02 23E2      		ldi r18,lo8(35)
 6559 2d04 289F      		mul r18,r24
 6560 2d06 F001      		movw r30,r0
 6561 2d08 299F      		mul r18,r25
 6562 2d0a F00D      		add r31,r0
 6563 2d0c 1124      		clr __zero_reg__
 6564 2d0e E050      		subi r30,lo8(-(bankStates))
 6565 2d10 F040      		sbci r31,hi8(-(bankStates))
 6566 2d12 00C0      		rjmp .L555
 6567               	.L407:
4247:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
 6568               		.loc 1 4247 0
 6569 2d14 8130      		cpi r24,lo8(1)
 6570 2d16 01F0      		breq .+2
 6571 2d18 00C0      		rjmp .L409
4249:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
 6572               		.loc 1 4249 0
 6573 2d1a A091 0000 		lds r26,currentMidiMessage.2209
 6574 2d1e 2A2F      		mov r18,r26
 6575 2d20 30E0      		ldi r19,0
 6576 2d22 8091 0000 		lds r24,currentMidiMessage.2209+2
 6577 2d26 F901      		movw r30,r18
 6578 2d28 E050      		subi r30,lo8(-(currentNoteOn.2210))
 6579 2d2a F040      		sbci r31,hi8(-(currentNoteOn.2210))
 6580 2d2c 8083      		st Z,r24
4251:WTPA.c        **** 				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
 6581               		.loc 1 4251 0
 6582 2d2e F901      		movw r30,r18
 6583 2d30 E050      		subi r30,lo8(-(realtimeOn.2211))
 6584 2d32 F040      		sbci r31,hi8(-(realtimeOn.2211))
 6585 2d34 9081      		ld r25,Z
 6586 2d36 9923      		tst r25
 6587 2d38 01F0      		breq .L410
 6588               	.LVL262:
 6589               	.LBB238:
 6590               	.LBB239:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6591               		.loc 1 3303 0
 6592 2d3a 6CE0      		ldi r22,lo8(12)
 6593 2d3c 0E94 0000 		call __udivmodqi4
 6594               	.LVL263:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6595               		.loc 1 3305 0
 6596 2d40 E92F      		mov r30,r25
 6597 2d42 F0E0      		ldi r31,0
 6598 2d44 EE0F      		lsl r30
 6599 2d46 FF1F      		rol r31
 6600 2d48 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6601 2d4a F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6602 2d4c 4081      		ld r20,Z
 6603 2d4e 5181      		ldd r21,Z+1
 6604 2d50 00C0      		rjmp 2f
 6605               		1:
 6606 2d52 5695      		lsr r21
 6607 2d54 4795      		ror r20
 6608               		2:
 6609 2d56 8A95      		dec r24
 6610 2d58 02F4      		brpl 1b
 6611               	.LBE239:
 6612               	.LBE238:
4253:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
 6613               		.loc 1 4253 0
 6614 2d5a 62E0      		ldi r22,lo8(2)
 6615 2d5c 8A2F      		mov r24,r26
 6616               	.LVL264:
 6617 2d5e 0E94 0000 		call StartRealtime
 6618               	.LVL265:
 6619 2d62 00C0      		rjmp .L361
 6620               	.L410:
4257:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
 6621               		.loc 1 4257 0
 6622 2d64 93E2      		ldi r25,lo8(35)
 6623 2d66 929F      		mul r25,r18
 6624 2d68 F001      		movw r30,r0
 6625 2d6a 939F      		mul r25,r19
 6626 2d6c F00D      		add r31,r0
 6627 2d6e 1124      		clr __zero_reg__
 6628 2d70 E050      		subi r30,lo8(-(bankStates))
 6629 2d72 F040      		sbci r31,hi8(-(bankStates))
 6630 2d74 0089      		ldd r16,Z+16
 6631 2d76 1189      		ldd r17,Z+17
 6632 2d78 2289      		ldd r18,Z+18
 6633 2d7a 3389      		ldd r19,Z+19
 6634 2d7c 4485      		ldd r20,Z+12
 6635 2d7e 5585      		ldd r21,Z+13
 6636 2d80 6685      		ldd r22,Z+14
 6637 2d82 7785      		ldd r23,Z+15
 6638 2d84 0417      		cp r16,r20
 6639 2d86 1507      		cpc r17,r21
 6640 2d88 2607      		cpc r18,r22
 6641 2d8a 3707      		cpc r19,r23
 6642 2d8c 01F4      		brne .+2
 6643 2d8e 00C0      		rjmp .L361
 6644               	.LVL266:
 6645               	.LBB240:
 6646               	.LBB241:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6647               		.loc 1 3303 0
 6648 2d90 6CE0      		ldi r22,lo8(12)
 6649 2d92 0E94 0000 		call __udivmodqi4
 6650               	.LVL267:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6651               		.loc 1 3305 0
 6652 2d96 E92F      		mov r30,r25
 6653 2d98 F0E0      		ldi r31,0
 6654 2d9a EE0F      		lsl r30
 6655 2d9c FF1F      		rol r31
 6656 2d9e E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6657 2da0 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6658 2da2 4081      		ld r20,Z
 6659 2da4 5181      		ldd r21,Z+1
 6660 2da6 00C0      		rjmp 2f
 6661               		1:
 6662 2da8 5695      		lsr r21
 6663 2daa 4795      		ror r20
 6664               		2:
 6665 2dac 8A95      		dec r24
 6666 2dae 02F4      		brpl 1b
 6667               	.LBE241:
 6668               	.LBE240:
4259:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
 6669               		.loc 1 4259 0
 6670 2db0 62E0      		ldi r22,lo8(2)
 6671 2db2 8A2F      		mov r24,r26
 6672               	.LVL268:
 6673 2db4 0E94 0000 		call StartPlayback
 6674               	.LVL269:
 6675 2db8 00C0      		rjmp .L361
 6676               	.L409:
4264:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
 6677               		.loc 1 4264 0
 6678 2dba 8430      		cpi r24,lo8(4)
 6679 2dbc 01F0      		breq .+2
 6680 2dbe 00C0      		rjmp .L411
4266:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
 6681               		.loc 1 4266 0
 6682 2dc0 8091 0000 		lds r24,currentMidiMessage.2209+2
 6683 2dc4 90E0      		ldi r25,0
 6684 2dc6 FC01      		movw r30,r24
 6685 2dc8 3397      		sbiw r30,3
 6686 2dca EC31      		cpi r30,28
 6687 2dcc F105      		cpc r31,__zero_reg__
 6688 2dce 00F0      		brlo .+2
 6689 2dd0 00C0      		rjmp .L361
 6690 2dd2 E050      		subi r30,lo8(-(gs(.L431)))
 6691 2dd4 F040      		sbci r31,hi8(-(gs(.L431)))
 6692 2dd6 0C94 0000 		jmp __tablejump2__
 6693               		.section	.progmem.gcc_sw_table,"a",@progbits
 6694               		.p2align	1
 6695               	.L431:
 6696 0000 0000      		.word gs(.L412)
 6697 0002 0000      		.word gs(.L361)
 6698 0004 0000      		.word gs(.L361)
 6699 0006 0000      		.word gs(.L361)
 6700 0008 0000      		.word gs(.L361)
 6701 000a 0000      		.word gs(.L361)
 6702 000c 0000      		.word gs(.L413)
 6703 000e 0000      		.word gs(.L361)
 6704 0010 0000      		.word gs(.L361)
 6705 0012 0000      		.word gs(.L361)
 6706 0014 0000      		.word gs(.L361)
 6707 0016 0000      		.word gs(.L414)
 6708 0018 0000      		.word gs(.L415)
 6709 001a 0000      		.word gs(.L416)
 6710 001c 0000      		.word gs(.L417)
 6711 001e 0000      		.word gs(.L418)
 6712 0020 0000      		.word gs(.L419)
 6713 0022 0000      		.word gs(.L420)
 6714 0024 0000      		.word gs(.L421)
 6715 0026 0000      		.word gs(.L422)
 6716 0028 0000      		.word gs(.L423)
 6717 002a 0000      		.word gs(.L424)
 6718 002c 0000      		.word gs(.L425)
 6719 002e 0000      		.word gs(.L426)
 6720 0030 0000      		.word gs(.L427)
 6721 0032 0000      		.word gs(.L428)
 6722 0034 0000      		.word gs(.L429)
 6723 0036 0000      		.word gs(.L430)
 6724               		.text
 6725               	.L412:
4269:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6726               		.loc 1 4269 0
 6727 2dda 9091 0000 		lds r25,currentMidiMessage.2209+3
 6728 2dde 8091 0000 		lds r24,currentMidiMessage.2209
 6729 2de2 9923      		tst r25
 6730 2de4 01F0      		breq .L432
4271:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
 6731               		.loc 1 4271 0
 6732 2de6 A82F      		mov r26,r24
 6733 2de8 B0E0      		ldi r27,0
 6734 2dea AA0F      		lsl r26
 6735 2dec BB1F      		rol r27
 6736 2dee A050      		subi r26,lo8(-(theMidiRecordRate))
 6737 2df0 B040      		sbci r27,hi8(-(theMidiRecordRate))
 6738 2df2 4D91      		ld r20,X+
 6739 2df4 5C91      		ld r21,X
 6740 2df6 62E0      		ldi r22,lo8(2)
 6741 2df8 0E94 0000 		call StartRecording
 6742               	.LVL270:
 6743 2dfc 00C0      		rjmp .L565
 6744               	.L432:
4274:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
 6745               		.loc 1 4274 0
 6746 2dfe B3E2      		ldi r27,lo8(35)
 6747 2e00 8B9F      		mul r24,r27
 6748 2e02 F001      		movw r30,r0
 6749 2e04 1124      		clr __zero_reg__
 6750 2e06 E050      		subi r30,lo8(-(bankStates))
 6751 2e08 F040      		sbci r31,hi8(-(bankStates))
 6752 2e0a 8081      		ld r24,Z
 6753 2e0c 8330      		cpi r24,lo8(3)
 6754 2e0e 01F0      		breq .+2
 6755 2e10 00C0      		rjmp .L361
 6756               	.L555:
4276:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 6757               		.loc 1 4276 0
 6758 2e12 1082      		st Z,__zero_reg__
4277:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 6759               		.loc 1 4277 0
 6760 2e14 1186      		std Z+9,__zero_reg__
 6761 2e16 00C0      		rjmp .L361
 6762               	.L413:
4282:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6763               		.loc 1 4282 0
 6764 2e18 9091 0000 		lds r25,currentMidiMessage.2209+3
 6765 2e1c 8091 0000 		lds r24,currentMidiMessage.2209
 6766 2e20 9923      		tst r25
 6767 2e22 01F0      		breq .L433
4284:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
 6768               		.loc 1 4284 0
 6769 2e24 A82F      		mov r26,r24
 6770 2e26 B0E0      		ldi r27,0
 6771 2e28 23E2      		ldi r18,lo8(35)
 6772 2e2a 829F      		mul r24,r18
 6773 2e2c F001      		movw r30,r0
 6774 2e2e 1124      		clr __zero_reg__
 6775 2e30 E050      		subi r30,lo8(-(bankStates))
 6776 2e32 F040      		sbci r31,hi8(-(bankStates))
 6777 2e34 0089      		ldd r16,Z+16
 6778 2e36 1189      		ldd r17,Z+17
 6779 2e38 2289      		ldd r18,Z+18
 6780 2e3a 3389      		ldd r19,Z+19
 6781 2e3c 4485      		ldd r20,Z+12
 6782 2e3e 5585      		ldd r21,Z+13
 6783 2e40 6685      		ldd r22,Z+14
 6784 2e42 7785      		ldd r23,Z+15
 6785 2e44 0417      		cp r16,r20
 6786 2e46 1507      		cpc r17,r21
 6787 2e48 2607      		cpc r18,r22
 6788 2e4a 3707      		cpc r19,r23
 6789 2e4c 01F4      		brne .+2
 6790 2e4e 00C0      		rjmp .L361
4286:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
 6791               		.loc 1 4286 0
 6792 2e50 FD01      		movw r30,r26
 6793 2e52 E050      		subi r30,lo8(-(currentNoteOn.2210))
 6794 2e54 F040      		sbci r31,hi8(-(currentNoteOn.2210))
 6795 2e56 4081      		ld r20,Z
 6796 2e58 50E0      		ldi r21,0
 6797 2e5a 62E0      		ldi r22,lo8(2)
 6798 2e5c 0E94 0000 		call StartOverdub
 6799               	.LVL271:
 6800               	.L565:
4287:WTPA.c        **** 							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to pla
 6801               		.loc 1 4287 0
 6802 2e60 E091 0000 		lds r30,currentMidiMessage.2209
 6803 2e64 F0E0      		ldi r31,0
 6804 2e66 00C0      		rjmp .L556
 6805               	.L433:
4290:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
 6806               		.loc 1 4290 0
 6807 2e68 282F      		mov r18,r24
 6808 2e6a 30E0      		ldi r19,0
 6809 2e6c 43E2      		ldi r20,lo8(35)
 6810 2e6e 849F      		mul r24,r20
 6811 2e70 F001      		movw r30,r0
 6812 2e72 1124      		clr __zero_reg__
 6813 2e74 E050      		subi r30,lo8(-(bankStates))
 6814 2e76 F040      		sbci r31,hi8(-(bankStates))
 6815 2e78 9081      		ld r25,Z
 6816 2e7a 9530      		cpi r25,lo8(5)
 6817 2e7c 01F0      		breq .+2
 6818 2e7e 00C0      		rjmp .L361
4292:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
 6819               		.loc 1 4292 0
 6820 2e80 F901      		movw r30,r18
 6821 2e82 E050      		subi r30,lo8(-(currentNoteOn.2210))
 6822 2e84 F040      		sbci r31,hi8(-(currentNoteOn.2210))
 6823 2e86 4081      		ld r20,Z
 6824 2e88 50E0      		ldi r21,0
 6825 2e8a 62E0      		ldi r22,lo8(2)
 6826 2e8c 0E94 0000 		call ContinuePlayback
 6827               	.LVL272:
 6828 2e90 00C0      		rjmp .L361
 6829               	.L414:
4297:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6830               		.loc 1 4297 0
 6831 2e92 9091 0000 		lds r25,currentMidiMessage.2209+3
 6832 2e96 8091 0000 		lds r24,currentMidiMessage.2209
 6833 2e9a 9923      		tst r25
 6834 2e9c 01F0      		breq .L434
4299:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
 6835               		.loc 1 4299 0
 6836 2e9e A82F      		mov r26,r24
 6837 2ea0 B0E0      		ldi r27,0
 6838 2ea2 AA0F      		lsl r26
 6839 2ea4 BB1F      		rol r27
 6840 2ea6 A050      		subi r26,lo8(-(theMidiRecordRate))
 6841 2ea8 B040      		sbci r27,hi8(-(theMidiRecordRate))
 6842 2eaa 4D91      		ld r20,X+
 6843 2eac 5C91      		ld r21,X
 6844 2eae 62E0      		ldi r22,lo8(2)
 6845 2eb0 0E94 0000 		call StartRealtime
 6846               	.LVL273:
4300:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop 
 6847               		.loc 1 4300 0
 6848 2eb4 E091 0000 		lds r30,currentMidiMessage.2209
 6849 2eb8 F0E0      		ldi r31,0
 6850 2eba E050      		subi r30,lo8(-(realtimeOn.2211))
 6851 2ebc F040      		sbci r31,hi8(-(realtimeOn.2211))
 6852 2ebe 81E0      		ldi r24,lo8(1)
 6853 2ec0 8083      		st Z,r24
 6854 2ec2 00C0      		rjmp .L361
 6855               	.L434:
4302:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
 6856               		.loc 1 4302 0
 6857 2ec4 282F      		mov r18,r24
 6858 2ec6 30E0      		ldi r19,0
 6859 2ec8 93E2      		ldi r25,lo8(35)
 6860 2eca 899F      		mul r24,r25
 6861 2ecc F001      		movw r30,r0
 6862 2ece 1124      		clr __zero_reg__
 6863 2ed0 E050      		subi r30,lo8(-(bankStates))
 6864 2ed2 F040      		sbci r31,hi8(-(bankStates))
 6865 2ed4 8081      		ld r24,Z
 6866 2ed6 8230      		cpi r24,lo8(2)
 6867 2ed8 01F0      		breq .+2
 6868 2eda 00C0      		rjmp .L361
4304:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 6869               		.loc 1 4304 0
 6870 2edc 1082      		st Z,__zero_reg__
4305:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 6871               		.loc 1 4305 0
 6872 2ede 1186      		std Z+9,__zero_reg__
4306:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
 6873               		.loc 1 4306 0
 6874 2ee0 F901      		movw r30,r18
 6875               	.L556:
 6876 2ee2 E050      		subi r30,lo8(-(realtimeOn.2211))
 6877 2ee4 F040      		sbci r31,hi8(-(realtimeOn.2211))
 6878 2ee6 1082      		st Z,__zero_reg__
 6879 2ee8 00C0      		rjmp .L361
 6880               	.L415:
4312:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6881               		.loc 1 4312 0
 6882 2eea 8091 0000 		lds r24,currentMidiMessage.2209+3
 6883 2eee E091 0000 		lds r30,currentMidiMessage.2209
 6884 2ef2 8823      		tst r24
 6885 2ef4 01F0      		breq .L435
4314:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 6886               		.loc 1 4314 0
 6887 2ef6 A3E2      		ldi r26,lo8(35)
 6888 2ef8 EA9F      		mul r30,r26
 6889 2efa F001      		movw r30,r0
 6890 2efc 1124      		clr __zero_reg__
 6891 2efe E050      		subi r30,lo8(-(bankStates))
 6892 2f00 F040      		sbci r31,hi8(-(bankStates))
 6893 2f02 1182      		std Z+1,__zero_reg__
 6894 2f04 00C0      		rjmp .L361
 6895               	.L435:
4318:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
 6896               		.loc 1 4318 0
 6897 2f06 B3E2      		ldi r27,lo8(35)
 6898 2f08 EB9F      		mul r30,r27
 6899 2f0a F001      		movw r30,r0
 6900 2f0c 1124      		clr __zero_reg__
 6901 2f0e E050      		subi r30,lo8(-(bankStates))
 6902 2f10 F040      		sbci r31,hi8(-(bankStates))
 6903 2f12 81E0      		ldi r24,lo8(1)
 6904 2f14 8183      		std Z+1,r24
 6905 2f16 00C0      		rjmp .L361
 6906               	.L416:
4323:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6907               		.loc 1 4323 0
 6908 2f18 8091 0000 		lds r24,currentMidiMessage.2209+3
 6909 2f1c E091 0000 		lds r30,currentMidiMessage.2209
 6910 2f20 8823      		tst r24
 6911 2f22 01F0      		breq .L436
4325:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
 6912               		.loc 1 4325 0
 6913 2f24 23E2      		ldi r18,lo8(35)
 6914 2f26 E29F      		mul r30,r18
 6915 2f28 F001      		movw r30,r0
 6916 2f2a 1124      		clr __zero_reg__
 6917 2f2c E050      		subi r30,lo8(-(bankStates))
 6918 2f2e F040      		sbci r31,hi8(-(bankStates))
 6919 2f30 81E0      		ldi r24,lo8(1)
 6920 2f32 8283      		std Z+2,r24
 6921 2f34 00C0      		rjmp .L361
 6922               	.L436:
4329:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 6923               		.loc 1 4329 0
 6924 2f36 43E2      		ldi r20,lo8(35)
 6925 2f38 E49F      		mul r30,r20
 6926 2f3a F001      		movw r30,r0
 6927 2f3c 1124      		clr __zero_reg__
 6928 2f3e E050      		subi r30,lo8(-(bankStates))
 6929 2f40 F040      		sbci r31,hi8(-(bankStates))
 6930 2f42 1282      		std Z+2,__zero_reg__
 6931 2f44 00C0      		rjmp .L361
 6932               	.L417:
4334:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6933               		.loc 1 4334 0
 6934 2f46 8091 0000 		lds r24,currentMidiMessage.2209+3
 6935 2f4a E091 0000 		lds r30,currentMidiMessage.2209
 6936 2f4e 8823      		tst r24
 6937 2f50 01F0      		breq .L437
4336:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
 6938               		.loc 1 4336 0
 6939 2f52 83E2      		ldi r24,lo8(35)
 6940 2f54 E89F      		mul r30,r24
 6941 2f56 F001      		movw r30,r0
 6942 2f58 1124      		clr __zero_reg__
 6943 2f5a E050      		subi r30,lo8(-(bankStates))
 6944 2f5c F040      		sbci r31,hi8(-(bankStates))
 6945 2f5e 81E0      		ldi r24,lo8(1)
 6946 2f60 8383      		std Z+3,r24
 6947 2f62 00C0      		rjmp .L438
 6948               	.L437:
4340:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 6949               		.loc 1 4340 0
 6950 2f64 93E2      		ldi r25,lo8(35)
 6951 2f66 E99F      		mul r30,r25
 6952 2f68 F001      		movw r30,r0
 6953 2f6a 1124      		clr __zero_reg__
 6954 2f6c E050      		subi r30,lo8(-(bankStates))
 6955 2f6e F040      		sbci r31,hi8(-(bankStates))
 6956 2f70 1382      		std Z+3,__zero_reg__
 6957               	.L438:
4342:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
 6958               		.loc 1 4342 0
 6959 2f72 8091 0000 		lds r24,currentMidiMessage.2209
 6960 2f76 00C0      		rjmp .L557
 6961               	.L418:
4346:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 6962               		.loc 1 4346 0
 6963 2f78 E091 0000 		lds r30,currentMidiMessage.2209
 6964 2f7c AE2F      		mov r26,r30
 6965 2f7e B0E0      		ldi r27,0
 6966 2f80 23E2      		ldi r18,lo8(35)
 6967 2f82 E29F      		mul r30,r18
 6968 2f84 F001      		movw r30,r0
 6969 2f86 1124      		clr __zero_reg__
 6970 2f88 E050      		subi r30,lo8(-(bankStates))
 6971 2f8a F040      		sbci r31,hi8(-(bankStates))
 6972 2f8c 1182      		std Z+1,__zero_reg__
4347:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
 6973               		.loc 1 4347 0
 6974 2f8e 1086      		std Z+8,__zero_reg__
4348:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
 6975               		.loc 1 4348 0
 6976 2f90 1782      		std Z+7,__zero_reg__
4349:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
 6977               		.loc 1 4349 0
 6978 2f92 1682      		std Z+6,__zero_reg__
4350:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 6979               		.loc 1 4350 0
 6980 2f94 1282      		std Z+2,__zero_reg__
4351:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 6981               		.loc 1 4351 0
 6982 2f96 81E0      		ldi r24,lo8(1)
 6983 2f98 8483      		std Z+4,r24
4352:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 6984               		.loc 1 4352 0
 6985 2f9a 1382      		std Z+3,__zero_reg__
4353:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 6986               		.loc 1 4353 0
 6987 2f9c 8483      		std Z+4,r24
4354:WTPA.c        **** 					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
 6988               		.loc 1 4354 0
 6989 2f9e A050      		subi r26,lo8(-(realtimeOn.2211))
 6990 2fa0 B040      		sbci r27,hi8(-(realtimeOn.2211))
 6991 2fa2 1C92      		st X,__zero_reg__
 6992 2fa4 00C0      		rjmp .L439
 6993               	.L419:
4359:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
 6994               		.loc 1 4359 0
 6995 2fa6 8091 0000 		lds r24,currentMidiMessage.2209+3
 6996 2faa 8830      		cpi r24,lo8(8)
 6997 2fac 00F0      		brlo .+2
 6998 2fae 00C0      		rjmp .L361
4361:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
 6999               		.loc 1 4361 0
 7000 2fb0 E091 0000 		lds r30,currentMidiMessage.2209
 7001 2fb4 43E2      		ldi r20,lo8(35)
 7002 2fb6 E49F      		mul r30,r20
 7003 2fb8 F001      		movw r30,r0
 7004 2fba 1124      		clr __zero_reg__
 7005 2fbc E050      		subi r30,lo8(-(bankStates))
 7006 2fbe F040      		sbci r31,hi8(-(bankStates))
 7007 2fc0 8087      		std Z+8,r24
 7008 2fc2 00C0      		rjmp .L361
 7009               	.L420:
4366:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7010               		.loc 1 4366 0
 7011 2fc4 6091 0000 		lds r22,currentMidiMessage.2209+3
 7012 2fc8 8091 0000 		lds r24,currentMidiMessage.2209
 7013 2fcc 0E94 0000 		call MakeNewGranularArray
 7014               	.LVL274:
4367:WTPA.c        **** 					break;
 7015               		.loc 1 4367 0
 7016 2fd0 00C0      		rjmp .L361
 7017               	.L421:
4370:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
 7018               		.loc 1 4370 0
 7019 2fd2 E091 0000 		lds r30,currentMidiMessage.2209
 7020 2fd6 8091 0000 		lds r24,currentMidiMessage.2209+3
 7021 2fda 93E2      		ldi r25,lo8(35)
 7022 2fdc E99F      		mul r30,r25
 7023 2fde F001      		movw r30,r0
 7024 2fe0 1124      		clr __zero_reg__
 7025 2fe2 E050      		subi r30,lo8(-(bankStates))
 7026 2fe4 F040      		sbci r31,hi8(-(bankStates))
 7027 2fe6 8783      		std Z+7,r24
4371:WTPA.c        **** 					break;
 7028               		.loc 1 4371 0
 7029 2fe8 00C0      		rjmp .L361
 7030               	.L422:
4374:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
 7031               		.loc 1 4374 0
 7032 2fea 8091 0000 		lds r24,currentMidiMessage.2209+3
 7033 2fee 8130      		cpi r24,lo8(1)
 7034 2ff0 01F0      		breq .L440
 7035 2ff2 00F0      		brlo .L439
 7036 2ff4 8230      		cpi r24,lo8(2)
 7037 2ff6 01F0      		breq .L441
 7038 2ff8 8330      		cpi r24,lo8(3)
 7039 2ffa 01F0      		breq .+2
 7040 2ffc 00C0      		rjmp .L361
 7041 2ffe 00C0      		rjmp .L442
 7042               	.L439:
4377:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
 7043               		.loc 1 4377 0
 7044 3000 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 7045 3002 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 7046 3004 00C0      		rjmp .L554
 7047               	.L440:
4381:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
 7048               		.loc 1 4381 0
 7049 3006 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 7050 3008 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 7051               	.L554:
 7052 300a 9093 0000 		sts UpdateOutput+1,r25
 7053 300e 8093 0000 		sts UpdateOutput,r24
4382:WTPA.c        **** 						break;
 7054               		.loc 1 4382 0
 7055 3012 00C0      		rjmp .L361
 7056               	.L441:
4385:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
 7057               		.loc 1 4385 0
 7058 3014 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 7059 3016 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 7060 3018 00C0      		rjmp .L554
 7061               	.L442:
4389:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
 7062               		.loc 1 4389 0
 7063 301a 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 7064 301c 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 7065 301e 00C0      		rjmp .L554
 7066               	.L423:
4398:WTPA.c        **** 					i=SREG;
 7067               		.loc 1 4398 0
 7068 3020 1FB7      		in r17,__SREG__
 7069               	.LVL275:
4399:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
 7070               		.loc 1 4399 0
 7071               	/* #APP */
 7072               	 ;  4399 "WTPA.c" 1
 7073 3022 F894      		cli
 7074               	 ;  0 "" 2
4400:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 7075               		.loc 1 4400 0
 7076               	/* #NOAPP */
 7077 3024 5091 0000 		lds r21,currentMidiMessage.2209
 7078 3028 A52F      		mov r26,r21
 7079 302a B0E0      		ldi r27,0
 7080 302c FD01      		movw r30,r26
 7081 302e E050      		subi r30,lo8(-(currentNoteOn.2210))
 7082 3030 F040      		sbci r31,hi8(-(currentNoteOn.2210))
 7083 3032 4081      		ld r20,Z
 7084               	.LVL276:
 7085 3034 AA0F      		lsl r26
 7086 3036 BB1F      		rol r27
 7087 3038 A050      		subi r26,lo8(-(theMidiRecordRate))
 7088 303a B040      		sbci r27,hi8(-(theMidiRecordRate))
 7089               	.LBB242:
 7090               	.LBB243:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7091               		.loc 1 3303 0
 7092 303c 842F      		mov r24,r20
 7093 303e 6CE0      		ldi r22,lo8(12)
 7094 3040 0E94 0000 		call __udivmodqi4
 7095               	.LVL277:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7096               		.loc 1 3305 0
 7097 3044 E92F      		mov r30,r25
 7098 3046 F0E0      		ldi r31,0
 7099 3048 EE0F      		lsl r30
 7100 304a FF1F      		rol r31
 7101               	.LVL278:
 7102 304c E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7103 304e F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7104 3050 2081      		ld r18,Z
 7105 3052 3181      		ldd r19,Z+1
 7106 3054 00C0      		rjmp 2f
 7107               		1:
 7108 3056 3695      		lsr r19
 7109 3058 2795      		ror r18
 7110               		2:
 7111 305a 8A95      		dec r24
 7112 305c 02F4      		brpl 1b
 7113               	.LBE243:
 7114               	.LBE242:
4400:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 7115               		.loc 1 4400 0
 7116 305e 2D93      		st X+,r18
 7117 3060 3C93      		st X,r19
 7118               	.LVL279:
 7119               	.LBB244:
 7120               	.LBB245:
3321:WTPA.c        **** 	if(theBank==BANK_0)
 7121               		.loc 1 3321 0
 7122 3062 5111      		cpse r21,__zero_reg__
 7123 3064 00C0      		rjmp .L443
3323:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
 7124               		.loc 1 3323 0
 7125 3066 642F      		mov r22,r20
 7126 3068 87E0      		ldi r24,lo8(7)
 7127 306a 90E0      		ldi r25,0
 7128               	.LVL280:
 7129 306c 00C0      		rjmp .L553
 7130               	.LVL281:
 7131               	.L443:
3325:WTPA.c        **** 	else if(theBank==BANK_1)
 7132               		.loc 1 3325 0
 7133 306e 5130      		cpi r21,lo8(1)
 7134 3070 01F4      		brne .L444
3327:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
 7135               		.loc 1 3327 0
 7136 3072 642F      		mov r22,r20
 7137 3074 8BE0      		ldi r24,lo8(11)
 7138 3076 90E0      		ldi r25,0
 7139               	.LVL282:
 7140               	.L553:
 7141 3078 0E94 0000 		call EepromWrite
 7142               	.LVL283:
 7143               	.L444:
 7144               	.LBE245:
 7145               	.LBE244:
4402:WTPA.c        **** 					SREG=i;		// Re-enable interrupts.
 7146               		.loc 1 4402 0
 7147 307c 1FBF      		out __SREG__,r17
4403:WTPA.c        **** 					break;
 7148               		.loc 1 4403 0
 7149 307e 00C0      		rjmp .L361
 7150               	.LVL284:
 7151               	.L424:
4408:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7152               		.loc 1 4408 0
 7153 3080 9091 0000 		lds r25,currentMidiMessage.2209+3
 7154 3084 8091 0000 		lds r24,currentMidiMessage.2209
 7155               	.LVL285:
 7156               	.LBB246:
 7157               	.LBB247:
3867:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7158               		.loc 1 3867 0
 7159 3088 A3E2      		ldi r26,lo8(35)
 7160 308a 8A9F      		mul r24,r26
 7161 308c F001      		movw r30,r0
 7162 308e 1124      		clr __zero_reg__
 7163 3090 00C0      		rjmp .L567
 7164               	.LVL286:
 7165               	.L425:
 7166               	.LBE247:
 7167               	.LBE246:
4412:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7168               		.loc 1 4412 0
 7169 3092 9091 0000 		lds r25,currentMidiMessage.2209+3
 7170 3096 8091 0000 		lds r24,currentMidiMessage.2209
 7171               	.LVL287:
 7172               	.LBB248:
 7173               	.LBB249:
3876:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7174               		.loc 1 3876 0
 7175 309a B3E2      		ldi r27,lo8(35)
 7176 309c 8B9F      		mul r24,r27
 7177 309e F001      		movw r30,r0
 7178 30a0 1124      		clr __zero_reg__
 7179 30a2 00C0      		rjmp .L566
 7180               	.LVL288:
 7181               	.L426:
 7182               	.LBE249:
 7183               	.LBE248:
4416:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7184               		.loc 1 4416 0
 7185 30a4 9091 0000 		lds r25,currentMidiMessage.2209+3
 7186 30a8 8091 0000 		lds r24,currentMidiMessage.2209
 7187               	.LVL289:
 7188               	.LBB250:
 7189               	.LBB251:
3885:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7190               		.loc 1 3885 0
 7191 30ac 23E2      		ldi r18,lo8(35)
 7192 30ae 829F      		mul r24,r18
 7193 30b0 F001      		movw r30,r0
 7194 30b2 1124      		clr __zero_reg__
 7195 30b4 00C0      		rjmp .L558
 7196               	.LVL290:
 7197               	.L427:
 7198               	.LBE251:
 7199               	.LBE250:
4420:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
 7200               		.loc 1 4420 0
 7201 30b6 8091 0000 		lds r24,currentMidiMessage.2209
 7202 30ba 0E94 0000 		call RevertSampleToUnadjusted
 7203               	.LVL291:
4421:WTPA.c        **** 					break;
 7204               		.loc 1 4421 0
 7205 30be 00C0      		rjmp .L361
 7206               	.L428:
4424:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7207               		.loc 1 4424 0
 7208 30c0 9091 0000 		lds r25,currentMidiMessage.2209+3
 7209 30c4 990F      		lsl r25
 7210 30c6 8091 0000 		lds r24,currentMidiMessage.2209
 7211               	.LVL292:
 7212               	.LBB252:
 7213               	.LBB253:
3867:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7214               		.loc 1 3867 0
 7215 30ca 43E2      		ldi r20,lo8(35)
 7216 30cc 849F      		mul r24,r20
 7217 30ce F001      		movw r30,r0
 7218 30d0 1124      		clr __zero_reg__
 7219               	.LVL293:
 7220               	.L567:
 7221 30d2 E050      		subi r30,lo8(-(bankStates))
 7222 30d4 F040      		sbci r31,hi8(-(bankStates))
 7223 30d6 948F      		std Z+28,r25
 7224 30d8 00C0      		rjmp .L557
 7225               	.L429:
 7226               	.LBE253:
 7227               	.LBE252:
4428:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7228               		.loc 1 4428 0
 7229 30da 9091 0000 		lds r25,currentMidiMessage.2209+3
 7230 30de 990F      		lsl r25
 7231 30e0 8091 0000 		lds r24,currentMidiMessage.2209
 7232               	.LVL294:
 7233               	.LBB254:
 7234               	.LBB255:
3876:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7235               		.loc 1 3876 0
 7236 30e4 A3E2      		ldi r26,lo8(35)
 7237 30e6 8A9F      		mul r24,r26
 7238 30e8 F001      		movw r30,r0
 7239 30ea 1124      		clr __zero_reg__
 7240               	.LVL295:
 7241               	.L566:
 7242 30ec E050      		subi r30,lo8(-(bankStates))
 7243 30ee F040      		sbci r31,hi8(-(bankStates))
 7244 30f0 958F      		std Z+29,r25
 7245 30f2 00C0      		rjmp .L557
 7246               	.L430:
 7247               	.LBE255:
 7248               	.LBE254:
4432:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7249               		.loc 1 4432 0
 7250 30f4 9091 0000 		lds r25,currentMidiMessage.2209+3
 7251 30f8 990F      		lsl r25
 7252 30fa 8091 0000 		lds r24,currentMidiMessage.2209
 7253               	.LVL296:
 7254               	.LBB256:
 7255               	.LBB257:
3885:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7256               		.loc 1 3885 0
 7257 30fe B3E2      		ldi r27,lo8(35)
 7258 3100 8B9F      		mul r24,r27
 7259 3102 F001      		movw r30,r0
 7260 3104 1124      		clr __zero_reg__
 7261               	.LVL297:
 7262               	.L558:
 7263 3106 E050      		subi r30,lo8(-(bankStates))
 7264 3108 F040      		sbci r31,hi8(-(bankStates))
 7265 310a 968F      		std Z+30,r25
 7266               	.L557:
3886:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 7267               		.loc 1 3886 0
 7268 310c 0E94 0000 		call UpdateAdjustedSampleAddresses
 7269               	.LVL298:
 7270 3110 00C0      		rjmp .L361
 7271               	.L411:
 7272               	.LBE257:
 7273               	.LBE256:
4440:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
 7274               		.loc 1 4440 0
 7275 3112 8730      		cpi r24,lo8(7)
 7276 3114 01F0      		breq .+2
 7277 3116 00C0      		rjmp .L361
4442:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
 7278               		.loc 1 4442 0
 7279 3118 8091 0000 		lds r24,currentMidiMessage.2209+3
 7280 311c 2091 0000 		lds r18,currentMidiMessage.2209+2
 7281 3120 30E0      		ldi r19,0
 7282 3122 E0E8      		ldi r30,lo8(-128)
 7283 3124 8E9F      		mul r24,r30
 7284 3126 200D      		add r18,r0
 7285 3128 311D      		adc r19,r1
 7286 312a 1124      		clr __zero_reg__
 7287               	.LVL299:
 7288 312c A091 0000 		lds r26,currentMidiMessage.2209
4444:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
 7289               		.loc 1 4444 0
 7290 3130 2115      		cp r18,__zero_reg__
 7291 3132 F0E2      		ldi r31,32
 7292 3134 3F07      		cpc r19,r31
 7293 3136 01F0      		breq .L445
4448:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7294               		.loc 1 4448 0
 7295 3138 B0E0      		ldi r27,0
 7296 313a FD01      		movw r30,r26
 7297 313c E050      		subi r30,lo8(-(currentNoteOn.2210))
 7298 313e F040      		sbci r31,hi8(-(currentNoteOn.2210))
 7299 3140 8081      		ld r24,Z
 7300               	.LVL300:
4452:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7301               		.loc 1 4452 0
 7302 3142 40E0      		ldi r20,0
 7303 3144 50E2      		ldi r21,lo8(32)
 7304 3146 421B      		sub r20,r18
 7305 3148 530B      		sbc r21,r19
 7306               	.LBB258:
 7307               	.LBB259:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7308               		.loc 1 3303 0
 7309 314a 6CE0      		ldi r22,lo8(12)
 7310 314c 0E94 0000 		call __udivmodqi4
 7311               	.LVL301:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7312               		.loc 1 3305 0
 7313 3150 E92F      		mov r30,r25
 7314               	.LVL302:
 7315 3152 F0E0      		ldi r31,0
 7316 3154 EE0F      		lsl r30
 7317 3156 FF1F      		rol r31
 7318 3158 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7319 315a F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7320 315c 2081      		ld r18,Z
 7321 315e 3181      		ldd r19,Z+1
 7322               	.LVL303:
 7323 3160 00C0      		rjmp 2f
 7324               		1:
 7325 3162 3695      		lsr r19
 7326 3164 2795      		ror r18
 7327               		2:
 7328 3166 8A95      		dec r24
 7329 3168 02F4      		brpl 1b
 7330               	.LBE259:
 7331               	.LBE258:
4452:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7332               		.loc 1 4452 0
 7333 316a 420F      		add r20,r18
 7334 316c 531F      		adc r21,r19
 7335 316e 83E2      		ldi r24,lo8(35)
 7336               	.LVL304:
 7337 3170 8A9F      		mul r24,r26
 7338 3172 F001      		movw r30,r0
 7339 3174 8B9F      		mul r24,r27
 7340 3176 F00D      		add r31,r0
 7341 3178 1124      		clr __zero_reg__
 7342 317a E050      		subi r30,lo8(-(bankStates))
 7343 317c F040      		sbci r31,hi8(-(bankStates))
 7344 317e 5387      		std Z+11,r21
 7345 3180 4287      		std Z+10,r20
 7346 3182 00C0      		rjmp .L361
 7347               	.LVL305:
 7348               	.L445:
4457:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7349               		.loc 1 4457 0
 7350 3184 4A2F      		mov r20,r26
 7351 3186 50E0      		ldi r21,0
 7352 3188 FA01      		movw r30,r20
 7353 318a E050      		subi r30,lo8(-(currentNoteOn.2210))
 7354 318c F040      		sbci r31,hi8(-(currentNoteOn.2210))
 7355 318e 8081      		ld r24,Z
 7356               	.LVL306:
 7357               	.LBB260:
 7358               	.LBB261:
3303:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7359               		.loc 1 3303 0
 7360 3190 6CE0      		ldi r22,lo8(12)
 7361 3192 0E94 0000 		call __udivmodqi4
 7362               	.LVL307:
3305:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7363               		.loc 1 3305 0
 7364 3196 E92F      		mov r30,r25
 7365               	.LVL308:
 7366 3198 F0E0      		ldi r31,0
 7367 319a EE0F      		lsl r30
 7368 319c FF1F      		rol r31
 7369 319e E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7370 31a0 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7371 31a2 2081      		ld r18,Z
 7372 31a4 3181      		ldd r19,Z+1
 7373               	.LVL309:
 7374 31a6 00C0      		rjmp 2f
 7375               		1:
 7376 31a8 3695      		lsr r19
 7377 31aa 2795      		ror r18
 7378               		2:
 7379 31ac 8A95      		dec r24
 7380 31ae 02F4      		brpl 1b
 7381               	.LBE261:
 7382               	.LBE260:
4457:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7383               		.loc 1 4457 0
 7384 31b0 83E2      		ldi r24,lo8(35)
 7385               	.LVL310:
 7386 31b2 849F      		mul r24,r20
 7387 31b4 F001      		movw r30,r0
 7388 31b6 859F      		mul r24,r21
 7389 31b8 F00D      		add r31,r0
 7390 31ba 1124      		clr __zero_reg__
 7391 31bc E050      		subi r30,lo8(-(bankStates))
 7392 31be F040      		sbci r31,hi8(-(bankStates))
 7393 31c0 3387      		std Z+11,r19
 7394 31c2 2287      		std Z+10,r18
 7395               	.LVL311:
 7396               	.L361:
 7397               	.LBB262:
 7398               	.LBB263:
3491:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
 7399               		.loc 1 3491 0
 7400 31c4 8091 0000 		lds r24,sdIsrState
 7401 31c8 8330      		cpi r24,lo8(3)
 7402 31ca 01F0      		breq .L447
3493:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
 7403               		.loc 1 3493 0
 7404 31cc 1092 0000 		sts sdStreamOutput,__zero_reg__
 7405               	.L447:
3497:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
 7406               		.loc 1 3497 0
 7407 31d0 8091 0000 		lds r24,bankStates+9
 7408 31d4 8130      		cpi r24,lo8(1)
 7409 31d6 01F0      		breq .L448
3499:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7410               		.loc 1 3499 0
 7411 31d8 1092 0000 		sts extIsrOutputBank0,__zero_reg__
3500:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7412               		.loc 1 3500 0
 7413 31dc 8091 6F00 		lds r24,111
 7414 31e0 8F7D      		andi r24,lo8(-33)
 7415 31e2 8093 6F00 		sts 111,r24
3501:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
 7416               		.loc 1 3501 0
 7417 31e6 B59A      		sbi 0x16,5
 7418               	.L448:
3503:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
 7419               		.loc 1 3503 0
 7420 31e8 8091 0000 		lds r24,bankStates+44
 7421 31ec 8130      		cpi r24,lo8(1)
 7422 31ee 01F0      		breq .L449
3505:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
 7423               		.loc 1 3505 0
 7424 31f0 1092 0000 		sts extIsrOutputBank1,__zero_reg__
3506:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
 7425               		.loc 1 3506 0
 7426 31f4 1092 6800 		sts 104,__zero_reg__
3507:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
 7427               		.loc 1 3507 0
 7428 31f8 1092 6D00 		sts 109,__zero_reg__
 7429               	.L449:
3509:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
 7430               		.loc 1 3509 0
 7431 31fc 8091 0000 		lds r24,bankStates+9
 7432 3200 8230      		cpi r24,lo8(2)
 7433 3202 01F0      		breq .L450
3511:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7434               		.loc 1 3511 0
 7435 3204 1092 0000 		sts midiOutputBank0,__zero_reg__
3512:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
 7436               		.loc 1 3512 0
 7437 3208 8091 6F00 		lds r24,111
 7438 320c 8D7F      		andi r24,lo8(-3)
 7439 320e 8093 6F00 		sts 111,r24
3513:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
 7440               		.loc 1 3513 0
 7441 3212 B19A      		sbi 0x16,1
 7442               	.L450:
3515:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
 7443               		.loc 1 3515 0
 7444 3214 8091 0000 		lds r24,bankStates+44
 7445 3218 8230      		cpi r24,lo8(2)
 7446 321a 01F0      		breq .L451
3517:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
 7447               		.loc 1 3517 0
 7448 321c 1092 0000 		sts midiOutputBank1,__zero_reg__
3518:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
 7449               		.loc 1 3518 0
 7450 3220 8091 6F00 		lds r24,111
 7451 3224 8B7F      		andi r24,lo8(-5)
 7452 3226 8093 6F00 		sts 111,r24
3519:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
 7453               		.loc 1 3519 0
 7454 322a B29A      		sbi 0x16,2
 7455               	.L451:
3523:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7456               		.loc 1 3523 0
 7457 322c 8091 0000 		lds r24,bankStates+9
 7458 3230 8111      		cpse r24,__zero_reg__
 7459 3232 00C0      		rjmp .L452
3525:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
 7460               		.loc 1 3525 0
 7461 3234 8091 0000 		lds r24,sdIsrState
 7462 3238 8823      		tst r24
 7463 323a 01F0      		breq .L453
 7464 323c 8330      		cpi r24,lo8(3)
 7465 323e 01F0      		breq .L453
 7466 3240 8091 0000 		lds r24,sdBank0
 7467 3244 8111      		cpse r24,__zero_reg__
 7468 3246 00C0      		rjmp .L452
 7469               	.L453:
3527:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
 7470               		.loc 1 3527 0
 7471 3248 1092 0000 		sts bankStates+5,__zero_reg__
 7472               	.L452:
3530:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7473               		.loc 1 3530 0
 7474 324c 8091 0000 		lds r24,bankStates+44
 7475 3250 8111      		cpse r24,__zero_reg__
 7476 3252 00C0      		rjmp .L454
3532:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
 7477               		.loc 1 3532 0
 7478 3254 8091 0000 		lds r24,sdIsrState
 7479 3258 8823      		tst r24
 7480 325a 01F0      		breq .L455
 7481 325c 8330      		cpi r24,lo8(3)
 7482 325e 01F0      		breq .L455
 7483 3260 8091 0000 		lds r24,sdBank0
 7484 3264 8130      		cpi r24,lo8(1)
 7485 3266 01F4      		brne .L454
 7486               	.L455:
3534:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
 7487               		.loc 1 3534 0
 7488 3268 1092 0000 		sts bankStates+40,__zero_reg__
 7489               	.L454:
 7490               	.LBE263:
 7491               	.LBE262:
 7492               	.LBB264:
 7493               	.LBB265:
3467:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
 7494               		.loc 1 3467 0
 7495 326c 8091 0000 		lds r24,encoderValue
 7496 3270 8295      		swap r24
 7497 3272 8695      		lsr r24
 7498 3274 8770      		andi r24,lo8(7)
 7499 3276 8093 0000 		sts scaledEncoderValue,r24
3468:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
 7500               		.loc 1 3468 0
 7501 327a 2091 0000 		lds r18,ledOnOffMask
 7502 327e 2F71      		andi r18,lo8(31)
 7503               	.LVL312:
3470:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
 7504               		.loc 1 3470 0
 7505 3280 80FD      		sbrc r24,0
3472:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
 7506               		.loc 1 3472 0
 7507 3282 2068      		ori r18,lo8(-128)
 7508               	.LVL313:
 7509               	.L456:
3474:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
 7510               		.loc 1 3474 0
 7511 3284 81FD      		sbrc r24,1
3476:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
 7512               		.loc 1 3476 0
 7513 3286 2064      		ori r18,lo8(64)
 7514               	.LVL314:
 7515               	.L457:
 7516               	.LBE265:
3478:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
 7517               		.loc 1 3478 0
 7518 3288 8470      		andi r24,lo8(4)
 7519               	.LBB266:
 7520 328a 01F0      		breq .L458
3480:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
 7521               		.loc 1 3480 0
 7522 328c 2062      		ori r18,lo8(32)
 7523               	.LVL315:
 7524               	.L458:
 7525               	.LBE266:
 7526               	.LBE264:
4466:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
 7527               		.loc 1 4466 0
 7528 328e 3091 0000 		lds r19,currentBank
 7529               	.LVL316:
 7530               	.LBB267:
 7531               	.LBB268:
3415:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
 7532               		.loc 1 3415 0
 7533 3292 207E      		andi r18,lo8(-32)
 7534               	.LVL317:
3417:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
 7535               		.loc 1 3417 0
 7536 3294 832F      		mov r24,r19
 7537 3296 90E0      		ldi r25,0
 7538 3298 A3E2      		ldi r26,lo8(35)
 7539 329a 3A9F      		mul r19,r26
 7540 329c F001      		movw r30,r0
 7541 329e 1124      		clr __zero_reg__
 7542 32a0 E050      		subi r30,lo8(-(bankStates))
 7543 32a2 F040      		sbci r31,hi8(-(bankStates))
 7544 32a4 4081      		ld r20,Z
 7545 32a6 4330      		cpi r20,lo8(3)
 7546 32a8 01F4      		brne .L459
3419:WTPA.c        **** 		temp|=Om_LED_REC;
 7547               		.loc 1 3419 0
 7548 32aa 2160      		ori r18,lo8(1)
 7549               	.LVL318:
 7550               	.L459:
3421:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
 7551               		.loc 1 3421 0
 7552 32ac 43E2      		ldi r20,lo8(35)
 7553 32ae 489F      		mul r20,r24
 7554 32b0 F001      		movw r30,r0
 7555 32b2 499F      		mul r20,r25
 7556 32b4 F00D      		add r31,r0
 7557 32b6 1124      		clr __zero_reg__
 7558 32b8 E050      		subi r30,lo8(-(bankStates))
 7559 32ba F040      		sbci r31,hi8(-(bankStates))
 7560 32bc 4081      		ld r20,Z
 7561 32be 4430      		cpi r20,lo8(4)
 7562 32c0 01F4      		brne .L460
3423:WTPA.c        **** 		temp|=Om_LED_PLAY;
 7563               		.loc 1 3423 0
 7564 32c2 2460      		ori r18,lo8(4)
 7565               	.LVL319:
 7566               	.L460:
3425:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
 7567               		.loc 1 3425 0
 7568 32c4 43E2      		ldi r20,lo8(35)
 7569 32c6 489F      		mul r20,r24
 7570 32c8 F001      		movw r30,r0
 7571 32ca 499F      		mul r20,r25
 7572 32cc F00D      		add r31,r0
 7573 32ce 1124      		clr __zero_reg__
 7574 32d0 E050      		subi r30,lo8(-(bankStates))
 7575 32d2 F040      		sbci r31,hi8(-(bankStates))
 7576 32d4 4081      		ld r20,Z
 7577 32d6 4530      		cpi r20,lo8(5)
 7578 32d8 01F4      		brne .L461
3427:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7579               		.loc 1 3427 0
 7580 32da 2260      		ori r18,lo8(2)
 7581               	.LVL320:
 7582               	.L461:
3429:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
 7583               		.loc 1 3429 0
 7584 32dc 43E2      		ldi r20,lo8(35)
 7585 32de 489F      		mul r20,r24
 7586 32e0 F001      		movw r30,r0
 7587 32e2 499F      		mul r20,r25
 7588 32e4 F00D      		add r31,r0
 7589 32e6 1124      		clr __zero_reg__
 7590 32e8 E050      		subi r30,lo8(-(bankStates))
 7591 32ea F040      		sbci r31,hi8(-(bankStates))
 7592 32ec 4081      		ld r20,Z
 7593 32ee 4230      		cpi r20,lo8(2)
 7594 32f0 01F4      		brne .L462
 7595               	.LVL321:
3433:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7596               		.loc 1 3433 0
 7597 32f2 2760      		ori r18,lo8(7)
 7598               	.LVL322:
 7599               	.L462:
3436:WTPA.c        **** 	if(outOfRam==true)
 7600               		.loc 1 3436 0
 7601 32f4 4091 0000 		lds r20,outOfRam
 7602 32f8 4130      		cpi r20,lo8(1)
 7603 32fa 01F4      		brne .L463
3438:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
 7604               		.loc 1 3438 0
 7605 32fc 2860      		ori r18,lo8(8)
 7606               	.LVL323:
 7607               	.L463:
3440:WTPA.c        **** 	if(theBank==BANK_1)
 7608               		.loc 1 3440 0
 7609 32fe 3130      		cpi r19,lo8(1)
 7610 3300 01F4      		brne .L464
3442:WTPA.c        **** 		temp|=Om_LED_BANK;
 7611               		.loc 1 3442 0
 7612 3302 2061      		ori r18,lo8(16)
 7613               	.LVL324:
 7614               	.L464:
3445:WTPA.c        **** 	ledOnOffMask=temp;
 7615               		.loc 1 3445 0
 7616 3304 2093 0000 		sts ledOnOffMask,r18
3447:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
 7617               		.loc 1 3447 0
 7618 3308 23E2      		ldi r18,lo8(35)
 7619               	.LVL325:
 7620 330a 289F      		mul r18,r24
 7621 330c F001      		movw r30,r0
 7622 330e 299F      		mul r18,r25
 7623 3310 F00D      		add r31,r0
 7624 3312 1124      		clr __zero_reg__
 7625 3314 E050      		subi r30,lo8(-(bankStates))
 7626 3316 F040      		sbci r31,hi8(-(bankStates))
 7627 3318 4089      		ldd r20,Z+16
 7628 331a 5189      		ldd r21,Z+17
 7629 331c 6289      		ldd r22,Z+18
 7630 331e 7389      		ldd r23,Z+19
 7631 3320 8485      		ldd r24,Z+12
 7632 3322 9585      		ldd r25,Z+13
 7633 3324 A685      		ldd r26,Z+14
 7634 3326 B785      		ldd r27,Z+15
 7635 3328 4817      		cp r20,r24
 7636 332a 5907      		cpc r21,r25
 7637 332c 6A07      		cpc r22,r26
 7638 332e 7B07      		cpc r23,r27
 7639 3330 01F4      		brne .L465
 7640               	.LBE268:
3449:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
 7641               		.loc 1 3449 0
 7642 3332 8091 0000 		lds r24,ledBlinkMask
 7643               	.LBB273:
 7644 3336 82FD      		sbrc r24,2
 7645 3338 00C0      		rjmp .L353
3451:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
 7646               		.loc 1 3451 0
 7647 333a 84E0      		ldi r24,lo8(4)
 7648 333c 90E0      		ldi r25,0
 7649 333e 00C0      		rjmp .L559
 7650               	.L465:
 7651               	.LBB269:
 7652               	.LBB270:
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 7653               		.loc 1 1499 0
 7654 3340 80E0      		ldi r24,0
 7655 3342 90E0      		ldi r25,0
 7656               	.L559:
 7657               	/* epilogue start */
 7658               	.LBE270:
 7659               	.LBE269:
 7660               	.LBE273:
 7661               	.LBE267:
4467:WTPA.c        **** }
 7662               		.loc 1 4467 0
 7663 3344 0F90      		pop __tmp_reg__
 7664 3346 DF91      		pop r29
 7665 3348 CF91      		pop r28
 7666 334a 1F91      		pop r17
 7667 334c 0F91      		pop r16
 7668 334e FF90      		pop r15
 7669 3350 EF90      		pop r14
 7670 3352 DF90      		pop r13
 7671 3354 CF90      		pop r12
 7672 3356 BF90      		pop r11
 7673 3358 AF90      		pop r10
 7674 335a 9F90      		pop r9
 7675 335c 8F90      		pop r8
 7676               	.LBB275:
 7677               	.LBB274:
 7678               	.LBB272:
 7679               	.LBB271:
1499:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 7680               		.loc 1 1499 0
 7681 335e 0C94 0000 		jmp BlinkLeds
 7682               	.LVL326:
 7683               	.L353:
 7684               	/* epilogue start */
 7685               	.LBE271:
 7686               	.LBE272:
 7687               	.LBE274:
 7688               	.LBE275:
4467:WTPA.c        **** }
 7689               		.loc 1 4467 0
 7690 3362 0F90      		pop __tmp_reg__
 7691 3364 DF91      		pop r29
 7692 3366 CF91      		pop r28
 7693 3368 1F91      		pop r17
 7694 336a 0F91      		pop r16
 7695 336c FF90      		pop r15
 7696 336e EF90      		pop r14
 7697 3370 DF90      		pop r13
 7698 3372 CF90      		pop r12
 7699 3374 BF90      		pop r11
 7700 3376 AF90      		pop r10
 7701 3378 9F90      		pop r9
 7702 337a 8F90      		pop r8
 7703 337c 0895      		ret
 7704               		.cfi_endproc
 7705               	.LFE68:
 7707               	.global	__vector_12
 7709               	__vector_12:
 7710               	.LFB7:
1094:WTPA.c        **** {
 7711               		.loc 1 1094 0
 7712               		.cfi_startproc
 7713 337e 1F92      		push r1
 7714               	.LCFI71:
 7715               		.cfi_def_cfa_offset 3
 7716               		.cfi_offset 1, -2
 7717 3380 0F92      		push r0
 7718               	.LCFI72:
 7719               		.cfi_def_cfa_offset 4
 7720               		.cfi_offset 0, -3
 7721 3382 0FB6      		in r0,__SREG__
 7722 3384 0F92      		push r0
 7723 3386 1124      		clr __zero_reg__
 7724 3388 2F93      		push r18
 7725               	.LCFI73:
 7726               		.cfi_def_cfa_offset 5
 7727               		.cfi_offset 18, -4
 7728 338a 3F93      		push r19
 7729               	.LCFI74:
 7730               		.cfi_def_cfa_offset 6
 7731               		.cfi_offset 19, -5
 7732 338c 4F93      		push r20
 7733               	.LCFI75:
 7734               		.cfi_def_cfa_offset 7
 7735               		.cfi_offset 20, -6
 7736 338e 5F93      		push r21
 7737               	.LCFI76:
 7738               		.cfi_def_cfa_offset 8
 7739               		.cfi_offset 21, -7
 7740 3390 6F93      		push r22
 7741               	.LCFI77:
 7742               		.cfi_def_cfa_offset 9
 7743               		.cfi_offset 22, -8
 7744 3392 7F93      		push r23
 7745               	.LCFI78:
 7746               		.cfi_def_cfa_offset 10
 7747               		.cfi_offset 23, -9
 7748 3394 8F93      		push r24
 7749               	.LCFI79:
 7750               		.cfi_def_cfa_offset 11
 7751               		.cfi_offset 24, -10
 7752 3396 9F93      		push r25
 7753               	.LCFI80:
 7754               		.cfi_def_cfa_offset 12
 7755               		.cfi_offset 25, -11
 7756 3398 AF93      		push r26
 7757               	.LCFI81:
 7758               		.cfi_def_cfa_offset 13
 7759               		.cfi_offset 26, -12
 7760 339a BF93      		push r27
 7761               	.LCFI82:
 7762               		.cfi_def_cfa_offset 14
 7763               		.cfi_offset 27, -13
 7764 339c EF93      		push r30
 7765               	.LCFI83:
 7766               		.cfi_def_cfa_offset 15
 7767               		.cfi_offset 30, -14
 7768 339e FF93      		push r31
 7769               	.LCFI84:
 7770               		.cfi_def_cfa_offset 16
 7771               		.cfi_offset 31, -15
 7772               	/* prologue: Signal */
 7773               	/* frame size = 0 */
 7774               	/* stack size = 15 */
 7775               	.L__stack_usage = 15
1099:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7776               		.loc 1 1099 0
 7777 33a0 8091 0000 		lds r24,bankStates+2
 7778 33a4 8823      		tst r24
 7779 33a6 01F0      		breq .L569
1099:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7780               		.loc 1 1099 0 is_stmt 0 discriminator 1
 7781 33a8 8091 0000 		lds r24,bankStates+2
 7782 33ac 8823      		tst r24
 7783 33ae 01F0      		breq .L570
 7784 33b0 8091 0000 		lds r24,flipFlop.1807
 7785 33b4 8823      		tst r24
 7786 33b6 01F0      		breq .L570
 7787               	.L569:
1101:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
 7788               		.loc 1 1101 0 is_stmt 1
 7789 33b8 0E94 0000 		call UpdateAudioChannel0
 7790               	.LVL327:
 7791 33bc 8093 0000 		sts extIsrOutputBank0,r24
 7792               	.L570:
1103:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 7793               		.loc 1 1103 0
 7794 33c0 1092 0000 		sts flipFlop.1807,__zero_reg__
1104:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 7795               		.loc 1 1104 0
 7796 33c4 E091 0000 		lds r30,UpdateOutput
 7797 33c8 F091 0000 		lds r31,UpdateOutput+1
 7798 33cc 0995      		icall
 7799               	.LVL328:
1105:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 7800               		.loc 1 1105 0
 7801 33ce 8091 7A00 		lds r24,122
 7802 33d2 86FD      		sbrc r24,6
 7803 33d4 00C0      		rjmp .L568
1107:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 7804               		.loc 1 1107 0
 7805 33d6 8091 7900 		lds r24,121
 7806 33da 8058      		subi r24,lo8(-(-128))
 7807 33dc 8093 0000 		sts adcByte,r24
1108:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 7808               		.loc 1 1108 0
 7809 33e0 8091 7A00 		lds r24,122
 7810 33e4 8064      		ori r24,lo8(64)
 7811 33e6 8093 7A00 		sts 122,r24
 7812               	.L568:
 7813               	/* epilogue start */
1110:WTPA.c        **** }
 7814               		.loc 1 1110 0
 7815 33ea FF91      		pop r31
 7816 33ec EF91      		pop r30
 7817 33ee BF91      		pop r27
 7818 33f0 AF91      		pop r26
 7819 33f2 9F91      		pop r25
 7820 33f4 8F91      		pop r24
 7821 33f6 7F91      		pop r23
 7822 33f8 6F91      		pop r22
 7823 33fa 5F91      		pop r21
 7824 33fc 4F91      		pop r20
 7825 33fe 3F91      		pop r19
 7826 3400 2F91      		pop r18
 7827 3402 0F90      		pop r0
 7828 3404 0FBE      		out __SREG__,r0
 7829 3406 0F90      		pop r0
 7830 3408 1F90      		pop r1
 7831 340a 1895      		reti
 7832               		.cfi_endproc
 7833               	.LFE7:
 7835               	.global	__vector_6
 7837               	__vector_6:
 7838               	.LFB8:
1115:WTPA.c        **** {
 7839               		.loc 1 1115 0
 7840               		.cfi_startproc
 7841 340c 1F92      		push r1
 7842               	.LCFI85:
 7843               		.cfi_def_cfa_offset 3
 7844               		.cfi_offset 1, -2
 7845 340e 0F92      		push r0
 7846               	.LCFI86:
 7847               		.cfi_def_cfa_offset 4
 7848               		.cfi_offset 0, -3
 7849 3410 0FB6      		in r0,__SREG__
 7850 3412 0F92      		push r0
 7851 3414 1124      		clr __zero_reg__
 7852 3416 2F93      		push r18
 7853               	.LCFI87:
 7854               		.cfi_def_cfa_offset 5
 7855               		.cfi_offset 18, -4
 7856 3418 3F93      		push r19
 7857               	.LCFI88:
 7858               		.cfi_def_cfa_offset 6
 7859               		.cfi_offset 19, -5
 7860 341a 4F93      		push r20
 7861               	.LCFI89:
 7862               		.cfi_def_cfa_offset 7
 7863               		.cfi_offset 20, -6
 7864 341c 5F93      		push r21
 7865               	.LCFI90:
 7866               		.cfi_def_cfa_offset 8
 7867               		.cfi_offset 21, -7
 7868 341e 6F93      		push r22
 7869               	.LCFI91:
 7870               		.cfi_def_cfa_offset 9
 7871               		.cfi_offset 22, -8
 7872 3420 7F93      		push r23
 7873               	.LCFI92:
 7874               		.cfi_def_cfa_offset 10
 7875               		.cfi_offset 23, -9
 7876 3422 8F93      		push r24
 7877               	.LCFI93:
 7878               		.cfi_def_cfa_offset 11
 7879               		.cfi_offset 24, -10
 7880 3424 9F93      		push r25
 7881               	.LCFI94:
 7882               		.cfi_def_cfa_offset 12
 7883               		.cfi_offset 25, -11
 7884 3426 AF93      		push r26
 7885               	.LCFI95:
 7886               		.cfi_def_cfa_offset 13
 7887               		.cfi_offset 26, -12
 7888 3428 BF93      		push r27
 7889               	.LCFI96:
 7890               		.cfi_def_cfa_offset 14
 7891               		.cfi_offset 27, -13
 7892 342a EF93      		push r30
 7893               	.LCFI97:
 7894               		.cfi_def_cfa_offset 15
 7895               		.cfi_offset 30, -14
 7896 342c FF93      		push r31
 7897               	.LCFI98:
 7898               		.cfi_def_cfa_offset 16
 7899               		.cfi_offset 31, -15
 7900               	/* prologue: Signal */
 7901               	/* frame size = 0 */
 7902               	/* stack size = 15 */
 7903               	.L__stack_usage = 15
1120:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 7904               		.loc 1 1120 0
 7905 342e 8091 0000 		lds r24,bankStates+37
 7906 3432 8823      		tst r24
 7907 3434 01F0      		breq .L582
1120:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 7908               		.loc 1 1120 0 is_stmt 0 discriminator 1
 7909 3436 8091 0000 		lds r24,bankStates+37
 7910 343a 8823      		tst r24
 7911 343c 01F0      		breq .L583
 7912 343e 8091 0000 		lds r24,flipFlop.1813
 7913 3442 8823      		tst r24
 7914 3444 01F0      		breq .L583
 7915               	.L582:
1122:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
 7916               		.loc 1 1122 0 is_stmt 1
 7917 3446 0E94 0000 		call UpdateAudioChannel1
 7918               	.LVL329:
 7919 344a 8093 0000 		sts extIsrOutputBank1,r24
 7920               	.L583:
1124:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 7921               		.loc 1 1124 0
 7922 344e 1092 0000 		sts flipFlop.1813,__zero_reg__
1125:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 7923               		.loc 1 1125 0
 7924 3452 E091 0000 		lds r30,UpdateOutput
 7925 3456 F091 0000 		lds r31,UpdateOutput+1
 7926 345a 0995      		icall
 7927               	.LVL330:
1126:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 7928               		.loc 1 1126 0
 7929 345c 8091 7A00 		lds r24,122
 7930 3460 86FD      		sbrc r24,6
 7931 3462 00C0      		rjmp .L584
1128:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 7932               		.loc 1 1128 0
 7933 3464 8091 7900 		lds r24,121
 7934 3468 8058      		subi r24,lo8(-(-128))
 7935 346a 8093 0000 		sts adcByte,r24
1129:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 7936               		.loc 1 1129 0
 7937 346e 8091 7A00 		lds r24,122
 7938 3472 8064      		ori r24,lo8(64)
 7939 3474 8093 7A00 		sts 122,r24
 7940               	.L584:
1131:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
 7941               		.loc 1 1131 0
 7942 3478 DA9A      		sbi 0x1b,2
 7943               	/* epilogue start */
1140:WTPA.c        **** }
 7944               		.loc 1 1140 0
 7945 347a FF91      		pop r31
 7946 347c EF91      		pop r30
 7947 347e BF91      		pop r27
 7948 3480 AF91      		pop r26
 7949 3482 9F91      		pop r25
 7950 3484 8F91      		pop r24
 7951 3486 7F91      		pop r23
 7952 3488 6F91      		pop r22
 7953 348a 5F91      		pop r21
 7954 348c 4F91      		pop r20
 7955 348e 3F91      		pop r19
 7956 3490 2F91      		pop r18
 7957 3492 0F90      		pop r0
 7958 3494 0FBE      		out __SREG__,r0
 7959 3496 0F90      		pop r0
 7960 3498 1F90      		pop r1
 7961 349a 1895      		reti
 7962               		.cfi_endproc
 7963               	.LFE8:
 7965               	.global	__vector_13
 7967               	__vector_13:
 7968               	.LFB9:
1144:WTPA.c        **** {
 7969               		.loc 1 1144 0
 7970               		.cfi_startproc
 7971 349c 1F92      		push r1
 7972               	.LCFI99:
 7973               		.cfi_def_cfa_offset 3
 7974               		.cfi_offset 1, -2
 7975 349e 0F92      		push r0
 7976               	.LCFI100:
 7977               		.cfi_def_cfa_offset 4
 7978               		.cfi_offset 0, -3
 7979 34a0 0FB6      		in r0,__SREG__
 7980 34a2 0F92      		push r0
 7981 34a4 1124      		clr __zero_reg__
 7982 34a6 0F93      		push r16
 7983               	.LCFI101:
 7984               		.cfi_def_cfa_offset 5
 7985               		.cfi_offset 16, -4
 7986 34a8 1F93      		push r17
 7987               	.LCFI102:
 7988               		.cfi_def_cfa_offset 6
 7989               		.cfi_offset 17, -5
 7990 34aa 2F93      		push r18
 7991               	.LCFI103:
 7992               		.cfi_def_cfa_offset 7
 7993               		.cfi_offset 18, -6
 7994 34ac 3F93      		push r19
 7995               	.LCFI104:
 7996               		.cfi_def_cfa_offset 8
 7997               		.cfi_offset 19, -7
 7998 34ae 4F93      		push r20
 7999               	.LCFI105:
 8000               		.cfi_def_cfa_offset 9
 8001               		.cfi_offset 20, -8
 8002 34b0 5F93      		push r21
 8003               	.LCFI106:
 8004               		.cfi_def_cfa_offset 10
 8005               		.cfi_offset 21, -9
 8006 34b2 6F93      		push r22
 8007               	.LCFI107:
 8008               		.cfi_def_cfa_offset 11
 8009               		.cfi_offset 22, -10
 8010 34b4 7F93      		push r23
 8011               	.LCFI108:
 8012               		.cfi_def_cfa_offset 12
 8013               		.cfi_offset 23, -11
 8014 34b6 8F93      		push r24
 8015               	.LCFI109:
 8016               		.cfi_def_cfa_offset 13
 8017               		.cfi_offset 24, -12
 8018 34b8 9F93      		push r25
 8019               	.LCFI110:
 8020               		.cfi_def_cfa_offset 14
 8021               		.cfi_offset 25, -13
 8022 34ba AF93      		push r26
 8023               	.LCFI111:
 8024               		.cfi_def_cfa_offset 15
 8025               		.cfi_offset 26, -14
 8026 34bc BF93      		push r27
 8027               	.LCFI112:
 8028               		.cfi_def_cfa_offset 16
 8029               		.cfi_offset 27, -15
 8030 34be CF93      		push r28
 8031               	.LCFI113:
 8032               		.cfi_def_cfa_offset 17
 8033               		.cfi_offset 28, -16
 8034 34c0 DF93      		push r29
 8035               	.LCFI114:
 8036               		.cfi_def_cfa_offset 18
 8037               		.cfi_offset 29, -17
 8038 34c2 EF93      		push r30
 8039               	.LCFI115:
 8040               		.cfi_def_cfa_offset 19
 8041               		.cfi_offset 30, -18
 8042 34c4 FF93      		push r31
 8043               	.LCFI116:
 8044               		.cfi_def_cfa_offset 20
 8045               		.cfi_offset 31, -19
 8046               	/* prologue: Signal */
 8047               	/* frame size = 0 */
 8048               	/* stack size = 19 */
 8049               	.L__stack_usage = 19
1154:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8050               		.loc 1 1154 0
 8051 34c6 8091 0000 		lds r24,bankStates+2
 8052 34ca 8823      		tst r24
 8053 34cc 01F0      		breq .L595
1154:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8054               		.loc 1 1154 0 is_stmt 0 discriminator 1
 8055 34ce 8091 0000 		lds r24,bankStates+2
 8056 34d2 8823      		tst r24
 8057 34d4 01F0      		breq .L596
 8058 34d6 8091 0000 		lds r24,flipFlop.1821
 8059 34da 8823      		tst r24
 8060 34dc 01F0      		breq .L596
 8061               	.L595:
1156:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
 8062               		.loc 1 1156 0 is_stmt 1
 8063 34de 0E94 0000 		call UpdateAudioChannel0
 8064               	.LVL331:
 8065 34e2 8093 0000 		sts midiOutputBank0,r24
 8066               	.L596:
1158:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
 8067               		.loc 1 1158 0
 8068 34e6 8091 0000 		lds r24,bankStates+7
 8069 34ea 8823      		tst r24
 8070 34ec 01F0      		breq .L597
1160:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
 8071               		.loc 1 1160 0
 8072 34ee A091 0000 		lds r26,bankStates+7
 8073 34f2 2091 0000 		lds r18,bankStates+10
 8074 34f6 3091 0000 		lds r19,bankStates+10+1
 8075               	.LVL332:
 8076 34fa B0E0      		ldi r27,0
 8077 34fc 0E94 0000 		call __umulhisi3
1161:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8078               		.loc 1 1161 0
 8079 3500 2FE7      		ldi r18,lo8(127)
 8080 3502 30E0      		ldi r19,0
 8081 3504 40E0      		ldi r20,0
 8082 3506 50E0      		ldi r21,0
 8083               	.LVL333:
 8084 3508 0E94 0000 		call __udivmodsi4
 8085               	.LVL334:
1162:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8086               		.loc 1 1162 0
 8087 350c 0091 8800 		lds r16,136
 8088 3510 1091 8900 		lds r17,136+1
 8089 3514 C091 0000 		lds r28,bankStates+10
 8090 3518 D091 0000 		lds r29,bankStates+10+1
1161:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8091               		.loc 1 1161 0
 8092 351c 6091 0000 		lds r22,random31
 8093 3520 7091 0000 		lds r23,random31+1
 8094 3524 8091 0000 		lds r24,random31+2
 8095 3528 9091 0000 		lds r25,random31+3
 8096 352c 0E94 0000 		call __udivmodsi4
 8097               	.LVL335:
1162:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8098               		.loc 1 1162 0
 8099 3530 C00F      		add r28,r16
 8100 3532 D11F      		adc r29,r17
 8101 3534 4091 0000 		lds r20,lastJitterValue.1820
 8102 3538 5091 0000 		lds r21,lastJitterValue.1820+1
 8103 353c C40F      		add r28,r20
 8104 353e D51F      		adc r29,r21
 8105 3540 C61B      		sub r28,r22
 8106 3542 D70B      		sbc r29,r23
 8107 3544 D093 8900 		sts 136+1,r29
 8108 3548 C093 8800 		sts 136,r28
1163:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8109               		.loc 1 1163 0
 8110 354c 7093 0000 		sts lastJitterValue.1820+1,r23
 8111 3550 6093 0000 		sts lastJitterValue.1820,r22
 8112 3554 00C0      		rjmp .L598
 8113               	.LVL336:
 8114               	.L597:
1167:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8115               		.loc 1 1167 0
 8116 3556 2091 8800 		lds r18,136
 8117 355a 3091 8900 		lds r19,136+1
 8118 355e 8091 0000 		lds r24,bankStates+10
 8119 3562 9091 0000 		lds r25,bankStates+10+1
 8120 3566 820F      		add r24,r18
 8121 3568 931F      		adc r25,r19
 8122 356a 9093 8900 		sts 136+1,r25
 8123 356e 8093 8800 		sts 136,r24
 8124               	.L598:
1169:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8125               		.loc 1 1169 0
 8126 3572 1092 0000 		sts flipFlop.1821,__zero_reg__
1170:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8127               		.loc 1 1170 0
 8128 3576 E091 0000 		lds r30,UpdateOutput
 8129 357a F091 0000 		lds r31,UpdateOutput+1
 8130 357e 0995      		icall
 8131               	.LVL337:
1171:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8132               		.loc 1 1171 0
 8133 3580 8091 7A00 		lds r24,122
 8134 3584 86FD      		sbrc r24,6
 8135 3586 00C0      		rjmp .L594
1173:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8136               		.loc 1 1173 0
 8137 3588 8091 7900 		lds r24,121
 8138 358c 8058      		subi r24,lo8(-(-128))
 8139 358e 8093 0000 		sts adcByte,r24
1174:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8140               		.loc 1 1174 0
 8141 3592 8091 7A00 		lds r24,122
 8142 3596 8064      		ori r24,lo8(64)
 8143 3598 8093 7A00 		sts 122,r24
 8144               	.L594:
 8145               	/* epilogue start */
1176:WTPA.c        **** }
 8146               		.loc 1 1176 0
 8147 359c FF91      		pop r31
 8148 359e EF91      		pop r30
 8149 35a0 DF91      		pop r29
 8150 35a2 CF91      		pop r28
 8151 35a4 BF91      		pop r27
 8152 35a6 AF91      		pop r26
 8153 35a8 9F91      		pop r25
 8154 35aa 8F91      		pop r24
 8155 35ac 7F91      		pop r23
 8156 35ae 6F91      		pop r22
 8157 35b0 5F91      		pop r21
 8158 35b2 4F91      		pop r20
 8159 35b4 3F91      		pop r19
 8160 35b6 2F91      		pop r18
 8161 35b8 1F91      		pop r17
 8162 35ba 0F91      		pop r16
 8163 35bc 0F90      		pop r0
 8164 35be 0FBE      		out __SREG__,r0
 8165 35c0 0F90      		pop r0
 8166 35c2 1F90      		pop r1
 8167 35c4 1895      		reti
 8168               		.cfi_endproc
 8169               	.LFE9:
 8171               	.global	__vector_14
 8173               	__vector_14:
 8174               	.LFB10:
1180:WTPA.c        **** {
 8175               		.loc 1 1180 0
 8176               		.cfi_startproc
 8177 35c6 1F92      		push r1
 8178               	.LCFI117:
 8179               		.cfi_def_cfa_offset 3
 8180               		.cfi_offset 1, -2
 8181 35c8 0F92      		push r0
 8182               	.LCFI118:
 8183               		.cfi_def_cfa_offset 4
 8184               		.cfi_offset 0, -3
 8185 35ca 0FB6      		in r0,__SREG__
 8186 35cc 0F92      		push r0
 8187 35ce 1124      		clr __zero_reg__
 8188 35d0 0F93      		push r16
 8189               	.LCFI119:
 8190               		.cfi_def_cfa_offset 5
 8191               		.cfi_offset 16, -4
 8192 35d2 1F93      		push r17
 8193               	.LCFI120:
 8194               		.cfi_def_cfa_offset 6
 8195               		.cfi_offset 17, -5
 8196 35d4 2F93      		push r18
 8197               	.LCFI121:
 8198               		.cfi_def_cfa_offset 7
 8199               		.cfi_offset 18, -6
 8200 35d6 3F93      		push r19
 8201               	.LCFI122:
 8202               		.cfi_def_cfa_offset 8
 8203               		.cfi_offset 19, -7
 8204 35d8 4F93      		push r20
 8205               	.LCFI123:
 8206               		.cfi_def_cfa_offset 9
 8207               		.cfi_offset 20, -8
 8208 35da 5F93      		push r21
 8209               	.LCFI124:
 8210               		.cfi_def_cfa_offset 10
 8211               		.cfi_offset 21, -9
 8212 35dc 6F93      		push r22
 8213               	.LCFI125:
 8214               		.cfi_def_cfa_offset 11
 8215               		.cfi_offset 22, -10
 8216 35de 7F93      		push r23
 8217               	.LCFI126:
 8218               		.cfi_def_cfa_offset 12
 8219               		.cfi_offset 23, -11
 8220 35e0 8F93      		push r24
 8221               	.LCFI127:
 8222               		.cfi_def_cfa_offset 13
 8223               		.cfi_offset 24, -12
 8224 35e2 9F93      		push r25
 8225               	.LCFI128:
 8226               		.cfi_def_cfa_offset 14
 8227               		.cfi_offset 25, -13
 8228 35e4 AF93      		push r26
 8229               	.LCFI129:
 8230               		.cfi_def_cfa_offset 15
 8231               		.cfi_offset 26, -14
 8232 35e6 BF93      		push r27
 8233               	.LCFI130:
 8234               		.cfi_def_cfa_offset 16
 8235               		.cfi_offset 27, -15
 8236 35e8 CF93      		push r28
 8237               	.LCFI131:
 8238               		.cfi_def_cfa_offset 17
 8239               		.cfi_offset 28, -16
 8240 35ea DF93      		push r29
 8241               	.LCFI132:
 8242               		.cfi_def_cfa_offset 18
 8243               		.cfi_offset 29, -17
 8244 35ec EF93      		push r30
 8245               	.LCFI133:
 8246               		.cfi_def_cfa_offset 19
 8247               		.cfi_offset 30, -18
 8248 35ee FF93      		push r31
 8249               	.LCFI134:
 8250               		.cfi_def_cfa_offset 20
 8251               		.cfi_offset 31, -19
 8252               	/* prologue: Signal */
 8253               	/* frame size = 0 */
 8254               	/* stack size = 19 */
 8255               	.L__stack_usage = 19
1190:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8256               		.loc 1 1190 0
 8257 35f0 8091 0000 		lds r24,bankStates+37
 8258 35f4 8823      		tst r24
 8259 35f6 01F0      		breq .L610
1190:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8260               		.loc 1 1190 0 is_stmt 0 discriminator 1
 8261 35f8 8091 0000 		lds r24,bankStates+37
 8262 35fc 8823      		tst r24
 8263 35fe 01F0      		breq .L611
 8264 3600 8091 0000 		lds r24,flipFlop.1829
 8265 3604 8823      		tst r24
 8266 3606 01F0      		breq .L611
 8267               	.L610:
1192:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
 8268               		.loc 1 1192 0 is_stmt 1
 8269 3608 0E94 0000 		call UpdateAudioChannel1
 8270               	.LVL338:
 8271 360c 8093 0000 		sts midiOutputBank1,r24
 8272               	.L611:
1194:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
 8273               		.loc 1 1194 0
 8274 3610 8091 0000 		lds r24,bankStates+42
 8275 3614 8823      		tst r24
 8276 3616 01F0      		breq .L612
1196:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
 8277               		.loc 1 1196 0
 8278 3618 A091 0000 		lds r26,bankStates+42
 8279 361c 2091 0000 		lds r18,bankStates+45
 8280 3620 3091 0000 		lds r19,bankStates+45+1
 8281               	.LVL339:
 8282 3624 B0E0      		ldi r27,0
 8283 3626 0E94 0000 		call __umulhisi3
1197:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8284               		.loc 1 1197 0
 8285 362a 2FE7      		ldi r18,lo8(127)
 8286 362c 30E0      		ldi r19,0
 8287 362e 40E0      		ldi r20,0
 8288 3630 50E0      		ldi r21,0
 8289               	.LVL340:
 8290 3632 0E94 0000 		call __udivmodsi4
 8291               	.LVL341:
1198:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8292               		.loc 1 1198 0
 8293 3636 0091 8A00 		lds r16,138
 8294 363a 1091 8B00 		lds r17,138+1
 8295 363e C091 0000 		lds r28,bankStates+45
 8296 3642 D091 0000 		lds r29,bankStates+45+1
1197:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8297               		.loc 1 1197 0
 8298 3646 6091 0000 		lds r22,random31
 8299 364a 7091 0000 		lds r23,random31+1
 8300 364e 8091 0000 		lds r24,random31+2
 8301 3652 9091 0000 		lds r25,random31+3
 8302 3656 0E94 0000 		call __udivmodsi4
 8303               	.LVL342:
1198:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8304               		.loc 1 1198 0
 8305 365a C00F      		add r28,r16
 8306 365c D11F      		adc r29,r17
 8307 365e 4091 0000 		lds r20,lastJitterValue.1828
 8308 3662 5091 0000 		lds r21,lastJitterValue.1828+1
 8309 3666 C40F      		add r28,r20
 8310 3668 D51F      		adc r29,r21
 8311 366a C61B      		sub r28,r22
 8312 366c D70B      		sbc r29,r23
 8313 366e D093 8B00 		sts 138+1,r29
 8314 3672 C093 8A00 		sts 138,r28
1199:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8315               		.loc 1 1199 0
 8316 3676 7093 0000 		sts lastJitterValue.1828+1,r23
 8317 367a 6093 0000 		sts lastJitterValue.1828,r22
 8318 367e 00C0      		rjmp .L613
 8319               	.LVL343:
 8320               	.L612:
1203:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8321               		.loc 1 1203 0
 8322 3680 2091 8A00 		lds r18,138
 8323 3684 3091 8B00 		lds r19,138+1
 8324 3688 8091 0000 		lds r24,bankStates+45
 8325 368c 9091 0000 		lds r25,bankStates+45+1
 8326 3690 820F      		add r24,r18
 8327 3692 931F      		adc r25,r19
 8328 3694 9093 8B00 		sts 138+1,r25
 8329 3698 8093 8A00 		sts 138,r24
 8330               	.L613:
1205:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8331               		.loc 1 1205 0
 8332 369c 1092 0000 		sts flipFlop.1829,__zero_reg__
1206:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8333               		.loc 1 1206 0
 8334 36a0 E091 0000 		lds r30,UpdateOutput
 8335 36a4 F091 0000 		lds r31,UpdateOutput+1
 8336 36a8 0995      		icall
 8337               	.LVL344:
1207:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8338               		.loc 1 1207 0
 8339 36aa 8091 7A00 		lds r24,122
 8340 36ae 86FD      		sbrc r24,6
 8341 36b0 00C0      		rjmp .L609
1209:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8342               		.loc 1 1209 0
 8343 36b2 8091 7900 		lds r24,121
 8344 36b6 8058      		subi r24,lo8(-(-128))
 8345 36b8 8093 0000 		sts adcByte,r24
1210:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8346               		.loc 1 1210 0
 8347 36bc 8091 7A00 		lds r24,122
 8348 36c0 8064      		ori r24,lo8(64)
 8349 36c2 8093 7A00 		sts 122,r24
 8350               	.L609:
 8351               	/* epilogue start */
1212:WTPA.c        **** }
 8352               		.loc 1 1212 0
 8353 36c6 FF91      		pop r31
 8354 36c8 EF91      		pop r30
 8355 36ca DF91      		pop r29
 8356 36cc CF91      		pop r28
 8357 36ce BF91      		pop r27
 8358 36d0 AF91      		pop r26
 8359 36d2 9F91      		pop r25
 8360 36d4 8F91      		pop r24
 8361 36d6 7F91      		pop r23
 8362 36d8 6F91      		pop r22
 8363 36da 5F91      		pop r21
 8364 36dc 4F91      		pop r20
 8365 36de 3F91      		pop r19
 8366 36e0 2F91      		pop r18
 8367 36e2 1F91      		pop r17
 8368 36e4 0F91      		pop r16
 8369 36e6 0F90      		pop r0
 8370 36e8 0FBE      		out __SREG__,r0
 8371 36ea 0F90      		pop r0
 8372 36ec 1F90      		pop r1
 8373 36ee 1895      		reti
 8374               		.cfi_endproc
 8375               	.LFE10:
 8377               	.global	__vector_10
 8379               	__vector_10:
 8380               	.LFB11:
1218:WTPA.c        **** {
 8381               		.loc 1 1218 0
 8382               		.cfi_startproc
 8383 36f0 1F92      		push r1
 8384               	.LCFI135:
 8385               		.cfi_def_cfa_offset 3
 8386               		.cfi_offset 1, -2
 8387 36f2 0F92      		push r0
 8388               	.LCFI136:
 8389               		.cfi_def_cfa_offset 4
 8390               		.cfi_offset 0, -3
 8391 36f4 0FB6      		in r0,__SREG__
 8392 36f6 0F92      		push r0
 8393 36f8 1124      		clr __zero_reg__
 8394 36fa 2F93      		push r18
 8395               	.LCFI137:
 8396               		.cfi_def_cfa_offset 5
 8397               		.cfi_offset 18, -4
 8398 36fc 3F93      		push r19
 8399               	.LCFI138:
 8400               		.cfi_def_cfa_offset 6
 8401               		.cfi_offset 19, -5
 8402 36fe 4F93      		push r20
 8403               	.LCFI139:
 8404               		.cfi_def_cfa_offset 7
 8405               		.cfi_offset 20, -6
 8406 3700 5F93      		push r21
 8407               	.LCFI140:
 8408               		.cfi_def_cfa_offset 8
 8409               		.cfi_offset 21, -7
 8410 3702 6F93      		push r22
 8411               	.LCFI141:
 8412               		.cfi_def_cfa_offset 9
 8413               		.cfi_offset 22, -8
 8414 3704 7F93      		push r23
 8415               	.LCFI142:
 8416               		.cfi_def_cfa_offset 10
 8417               		.cfi_offset 23, -9
 8418 3706 8F93      		push r24
 8419               	.LCFI143:
 8420               		.cfi_def_cfa_offset 11
 8421               		.cfi_offset 24, -10
 8422 3708 9F93      		push r25
 8423               	.LCFI144:
 8424               		.cfi_def_cfa_offset 12
 8425               		.cfi_offset 25, -11
 8426 370a AF93      		push r26
 8427               	.LCFI145:
 8428               		.cfi_def_cfa_offset 13
 8429               		.cfi_offset 26, -12
 8430 370c BF93      		push r27
 8431               	.LCFI146:
 8432               		.cfi_def_cfa_offset 14
 8433               		.cfi_offset 27, -13
 8434 370e EF93      		push r30
 8435               	.LCFI147:
 8436               		.cfi_def_cfa_offset 15
 8437               		.cfi_offset 30, -14
 8438 3710 FF93      		push r31
 8439               	.LCFI148:
 8440               		.cfi_def_cfa_offset 16
 8441               		.cfi_offset 31, -15
 8442               	/* prologue: Signal */
 8443               	/* frame size = 0 */
 8444               	/* stack size = 15 */
 8445               	.L__stack_usage = 15
1222:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
 8446               		.loc 1 1222 0
 8447 3712 8091 0000 		lds r24,sdIsrState
 8448 3716 8130      		cpi r24,lo8(1)
 8449 3718 01F0      		breq .+2
 8450 371a 00C0      		rjmp .L625
1224:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 8451               		.loc 1 1224 0
 8452 371c 8091 0000 		lds r24,sdRamSampleRemaining
 8453 3720 9091 0000 		lds r25,sdRamSampleRemaining+1
 8454 3724 A091 0000 		lds r26,sdRamSampleRemaining+2
 8455 3728 B091 0000 		lds r27,sdRamSampleRemaining+3
 8456 372c 892B      		or r24,r25
 8457 372e 8A2B      		or r24,r26
 8458 3730 8B2B      		or r24,r27
 8459 3732 01F4      		brne .+2
 8460 3734 00C0      		rjmp .L626
1226:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 8461               		.loc 1 1226 0
 8462 3736 8091 0000 		lds r24,sdBytesInFifo
 8463 373a 9091 0000 		lds r25,sdBytesInFifo+1
 8464 373e 892B      		or r24,r25
 8465 3740 01F4      		brne .+2
 8466 3742 00C0      		rjmp .L624
1228:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 8467               		.loc 1 1228 0
 8468 3744 E091 0000 		lds r30,sdFifoReadPointer
 8469 3748 F091 0000 		lds r31,sdFifoReadPointer+1
 8470 374c E050      		subi r30,lo8(-(sdFifo))
 8471 374e F040      		sbci r31,hi8(-(sdFifo))
 8472 3750 2081      		ld r18,Z
 8473               	.LVL345:
1230:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 8474               		.loc 1 1230 0
 8475 3752 8091 0000 		lds r24,sdFifoReadPointer
 8476 3756 9091 0000 		lds r25,sdFifoReadPointer+1
 8477 375a 0196      		adiw r24,1
 8478 375c 9093 0000 		sts sdFifoReadPointer+1,r25
 8479 3760 8093 0000 		sts sdFifoReadPointer,r24
1231:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 8480               		.loc 1 1231 0
 8481 3764 8091 0000 		lds r24,sdFifoReadPointer
 8482 3768 9091 0000 		lds r25,sdFifoReadPointer+1
 8483 376c 8115      		cp r24,__zero_reg__
 8484 376e 9340      		sbci r25,3
 8485 3770 00F0      		brlo .L628
1233:WTPA.c        **** 					sdFifoReadPointer=0;
 8486               		.loc 1 1233 0
 8487 3772 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 8488 3776 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 8489               	.L628:
1236:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 8490               		.loc 1 1236 0
 8491 377a 8091 0000 		lds r24,sdBytesInFifo
 8492 377e 9091 0000 		lds r25,sdBytesInFifo+1
 8493 3782 0197      		sbiw r24,1
 8494 3784 9093 0000 		sts sdBytesInFifo+1,r25
 8495 3788 8093 0000 		sts sdBytesInFifo,r24
1237:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 8496               		.loc 1 1237 0
 8497 378c 8091 0000 		lds r24,sdRamSampleRemaining
 8498 3790 9091 0000 		lds r25,sdRamSampleRemaining+1
 8499 3794 A091 0000 		lds r26,sdRamSampleRemaining+2
 8500 3798 B091 0000 		lds r27,sdRamSampleRemaining+3
 8501 379c 0197      		sbiw r24,1
 8502 379e A109      		sbc r26,__zero_reg__
 8503 37a0 B109      		sbc r27,__zero_reg__
 8504 37a2 8093 0000 		sts sdRamSampleRemaining,r24
 8505 37a6 9093 0000 		sts sdRamSampleRemaining+1,r25
 8506 37aa A093 0000 		sts sdRamSampleRemaining+2,r26
 8507 37ae B093 0000 		sts sdRamSampleRemaining+3,r27
1241:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
 8508               		.loc 1 1241 0
 8509 37b2 8FEF      		ldi r24,lo8(-1)
 8510 37b4 84B9      		out 0x4,r24
1242:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
 8511               		.loc 1 1242 0
 8512 37b6 8091 0000 		lds r24,sdRamAddress
 8513 37ba 85B9      		out 0x5,r24
1243:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
 8514               		.loc 1 1243 0
 8515 37bc 139A      		sbi 0x2,3
1244:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
 8516               		.loc 1 1244 0
 8517 37be 1398      		cbi 0x2,3
1246:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
 8518               		.loc 1 1246 0
 8519 37c0 4091 0000 		lds r20,sdRamAddress
 8520 37c4 5091 0000 		lds r21,sdRamAddress+1
 8521 37c8 6091 0000 		lds r22,sdRamAddress+2
 8522 37cc 7091 0000 		lds r23,sdRamAddress+3
 8523 37d0 BB27      		clr r27
 8524 37d2 A72F      		mov r26,r23
 8525 37d4 962F      		mov r25,r22
 8526 37d6 852F      		mov r24,r21
 8527 37d8 85B9      		out 0x5,r24
1247:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
 8528               		.loc 1 1247 0
 8529 37da 149A      		sbi 0x2,4
1248:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
 8530               		.loc 1 1248 0
 8531 37dc 1498      		cbi 0x2,4
1249:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
 8532               		.loc 1 1249 0
 8533 37de CB01      		movw r24,r22
 8534 37e0 AA27      		clr r26
 8535 37e2 BB27      		clr r27
 8536 37e4 8770      		andi r24,7
 8537 37e6 9927      		clr r25
 8538 37e8 AA27      		clr r26
 8539 37ea BB27      		clr r27
 8540 37ec 8868      		ori r24,136
 8541 37ee 88B9      		out 0x8,r24
1251:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
 8542               		.loc 1 1251 0
 8543 37f0 25B9      		out 0x5,r18
1254:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
 8544               		.loc 1 1254 0
 8545 37f2 8091 0000 		lds r24,sdBank0
 8546 37f6 8130      		cpi r24,lo8(1)
 8547 37f8 01F4      		brne .L629
1256:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 8548               		.loc 1 1256 0
 8549 37fa 4F5F      		subi r20,-1
 8550 37fc 5F4F      		sbci r21,-1
 8551 37fe 6F4F      		sbci r22,-1
 8552 3800 7F4F      		sbci r23,-1
 8553 3802 00C0      		rjmp .L646
 8554               	.L629:
1260:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 8555               		.loc 1 1260 0
 8556 3804 4150      		subi r20,1
 8557 3806 5109      		sbc r21,__zero_reg__
 8558 3808 6109      		sbc r22,__zero_reg__
 8559 380a 7109      		sbc r23,__zero_reg__
 8560               	.L646:
 8561 380c 4093 0000 		sts sdRamAddress,r20
 8562 3810 5093 0000 		sts sdRamAddress+1,r21
 8563 3814 6093 0000 		sts sdRamAddress+2,r22
 8564 3818 7093 0000 		sts sdRamAddress+3,r23
1264:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 8565               		.loc 1 1264 0
 8566 381c 1198      		cbi 0x2,1
1265:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
 8567               		.loc 1 1265 0
 8568 381e 119A      		sbi 0x2,1
 8569 3820 00C0      		rjmp .L624
 8570               	.LVL346:
 8571               	.L626:
1271:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8572               		.loc 1 1271 0
 8573 3822 1092 0000 		sts sdIsrState,__zero_reg__
1272:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 8574               		.loc 1 1272 0
 8575 3826 1092 B100 		sts 177,__zero_reg__
1273:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8576               		.loc 1 1273 0
 8577 382a 8091 7000 		lds r24,112
 8578 382e 8B7F      		andi r24,lo8(-5)
 8579 3830 8093 7000 		sts 112,r24
1275:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
 8580               		.loc 1 1275 0
 8581 3834 2091 0000 		lds r18,sdBank0
 8582 3838 8091 0000 		lds r24,sdRamAddress
 8583 383c 9091 0000 		lds r25,sdRamAddress+1
 8584 3840 A091 0000 		lds r26,sdRamAddress+2
 8585 3844 B091 0000 		lds r27,sdRamAddress+3
 8586 3848 2130      		cpi r18,lo8(1)
 8587 384a 01F4      		brne .L631
1277:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
 8588               		.loc 1 1277 0
 8589 384c 1092 0000 		sts bankStates+5,__zero_reg__
1278:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8590               		.loc 1 1278 0
 8591 3850 8093 0000 		sts bankStates+12,r24
 8592 3854 9093 0000 		sts bankStates+12+1,r25
 8593 3858 A093 0000 		sts bankStates+12+2,r26
 8594 385c B093 0000 		sts bankStates+12+3,r27
1279:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8595               		.loc 1 1279 0
 8596 3860 8093 0000 		sts bankStates+20,r24
 8597 3864 9093 0000 		sts bankStates+20+1,r25
 8598 3868 A093 0000 		sts bankStates+20+2,r26
 8599 386c B093 0000 		sts bankStates+20+3,r27
 8600 3870 00C0      		rjmp .L624
 8601               	.L631:
1283:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
 8602               		.loc 1 1283 0
 8603 3872 1092 0000 		sts bankStates+40,__zero_reg__
1284:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8604               		.loc 1 1284 0
 8605 3876 8093 0000 		sts bankStates+47,r24
 8606 387a 9093 0000 		sts bankStates+47+1,r25
 8607 387e A093 0000 		sts bankStates+47+2,r26
 8608 3882 B093 0000 		sts bankStates+47+3,r27
1285:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8609               		.loc 1 1285 0
 8610 3886 8093 0000 		sts bankStates+55,r24
 8611 388a 9093 0000 		sts bankStates+55+1,r25
 8612 388e A093 0000 		sts bankStates+55+2,r26
 8613 3892 B093 0000 		sts bankStates+55+3,r27
 8614 3896 00C0      		rjmp .L624
 8615               	.L625:
1289:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
 8616               		.loc 1 1289 0
 8617 3898 8230      		cpi r24,lo8(2)
 8618 389a 01F0      		breq .+2
 8619 389c 00C0      		rjmp .L632
1292:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
 8620               		.loc 1 1292 0
 8621 389e 8091 0000 		lds r24,sdBytesInFifo
 8622 38a2 9091 0000 		lds r25,sdBytesInFifo+1
 8623 38a6 8115      		cp r24,__zero_reg__
 8624 38a8 9340      		sbci r25,3
 8625 38aa 00F0      		brlo .+2
 8626 38ac 00C0      		rjmp .L624
1294:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
 8627               		.loc 1 1294 0
 8628 38ae 8091 0000 		lds r24,sdRamSampleRemaining
 8629 38b2 9091 0000 		lds r25,sdRamSampleRemaining+1
 8630 38b6 A091 0000 		lds r26,sdRamSampleRemaining+2
 8631 38ba B091 0000 		lds r27,sdRamSampleRemaining+3
 8632 38be 892B      		or r24,r25
 8633 38c0 8A2B      		or r24,r26
 8634 38c2 8B2B      		or r24,r27
 8635 38c4 01F4      		brne .+2
 8636 38c6 00C0      		rjmp .L633
1297:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
 8637               		.loc 1 1297 0
 8638 38c8 8091 0000 		lds r24,sdRamAddress
 8639 38cc 85B9      		out 0x5,r24
1298:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
 8640               		.loc 1 1298 0
 8641 38ce 139A      		sbi 0x2,3
1299:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
 8642               		.loc 1 1299 0
 8643 38d0 1398      		cbi 0x2,3
1301:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
 8644               		.loc 1 1301 0
 8645 38d2 4091 0000 		lds r20,sdRamAddress
 8646 38d6 5091 0000 		lds r21,sdRamAddress+1
 8647 38da 6091 0000 		lds r22,sdRamAddress+2
 8648 38de 7091 0000 		lds r23,sdRamAddress+3
 8649 38e2 BB27      		clr r27
 8650 38e4 A72F      		mov r26,r23
 8651 38e6 962F      		mov r25,r22
 8652 38e8 852F      		mov r24,r21
 8653 38ea 85B9      		out 0x5,r24
1302:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
 8654               		.loc 1 1302 0
 8655 38ec 149A      		sbi 0x2,4
1303:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
 8656               		.loc 1 1303 0
 8657 38ee 1498      		cbi 0x2,4
1305:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
 8658               		.loc 1 1305 0
 8659 38f0 CB01      		movw r24,r22
 8660 38f2 AA27      		clr r26
 8661 38f4 BB27      		clr r27
 8662 38f6 8770      		andi r24,7
 8663 38f8 9927      		clr r25
 8664 38fa AA27      		clr r26
 8665 38fc BB27      		clr r27
 8666 38fe 8868      		ori r24,136
 8667 3900 88B9      		out 0x8,r24
1307:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 8668               		.loc 1 1307 0
 8669 3902 14B8      		out 0x4,__zero_reg__
1308:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 8670               		.loc 1 1308 0
 8671 3904 1298      		cbi 0x2,2
1311:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
 8672               		.loc 1 1311 0
 8673 3906 8091 0000 		lds r24,sdBank0
 8674 390a 8130      		cpi r24,lo8(1)
 8675 390c 01F4      		brne .L634
1313:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 8676               		.loc 1 1313 0
 8677 390e 4F5F      		subi r20,-1
 8678 3910 5F4F      		sbci r21,-1
 8679 3912 6F4F      		sbci r22,-1
 8680 3914 7F4F      		sbci r23,-1
 8681 3916 00C0      		rjmp .L647
 8682               	.L634:
1317:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 8683               		.loc 1 1317 0
 8684 3918 4150      		subi r20,1
 8685 391a 5109      		sbc r21,__zero_reg__
 8686 391c 6109      		sbc r22,__zero_reg__
 8687 391e 7109      		sbc r23,__zero_reg__
 8688               	.L647:
 8689 3920 4093 0000 		sts sdRamAddress,r20
 8690 3924 5093 0000 		sts sdRamAddress+1,r21
 8691 3928 6093 0000 		sts sdRamAddress+2,r22
 8692 392c 7093 0000 		sts sdRamAddress+3,r23
1322:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 8693               		.loc 1 1322 0
 8694 3930 83B1      		in r24,0x3
 8695               	.LVL347:
1323:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 8696               		.loc 1 1323 0
 8697 3932 129A      		sbi 0x2,2
1324:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 8698               		.loc 1 1324 0
 8699 3934 9FEF      		ldi r25,lo8(-1)
 8700 3936 94B9      		out 0x4,r25
1329:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
 8701               		.loc 1 1329 0
 8702 3938 E091 0000 		lds r30,sdFifoWritePointer
 8703 393c F091 0000 		lds r31,sdFifoWritePointer+1
 8704 3940 E050      		subi r30,lo8(-(sdFifo))
 8705 3942 F040      		sbci r31,hi8(-(sdFifo))
 8706 3944 8083      		st Z,r24
1330:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
 8707               		.loc 1 1330 0
 8708 3946 8091 0000 		lds r24,sdFifoWritePointer
 8709 394a 9091 0000 		lds r25,sdFifoWritePointer+1
 8710               	.LVL348:
 8711 394e 0196      		adiw r24,1
 8712 3950 9093 0000 		sts sdFifoWritePointer+1,r25
 8713 3954 8093 0000 		sts sdFifoWritePointer,r24
1332:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
 8714               		.loc 1 1332 0
 8715 3958 8091 0000 		lds r24,sdFifoWritePointer
 8716 395c 9091 0000 		lds r25,sdFifoWritePointer+1
 8717 3960 8115      		cp r24,__zero_reg__
 8718 3962 9340      		sbci r25,3
 8719 3964 00F0      		brlo .L636
1334:WTPA.c        **** 					sdFifoWritePointer=0;
 8720               		.loc 1 1334 0
 8721 3966 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 8722 396a 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 8723               	.L636:
1337:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
 8724               		.loc 1 1337 0
 8725 396e 8091 0000 		lds r24,sdBytesInFifo
 8726 3972 9091 0000 		lds r25,sdBytesInFifo+1
 8727 3976 0196      		adiw r24,1
 8728 3978 9093 0000 		sts sdBytesInFifo+1,r25
 8729 397c 8093 0000 		sts sdBytesInFifo,r24
1338:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
 8730               		.loc 1 1338 0
 8731 3980 8091 0000 		lds r24,sdRamSampleRemaining
 8732 3984 9091 0000 		lds r25,sdRamSampleRemaining+1
 8733 3988 A091 0000 		lds r26,sdRamSampleRemaining+2
 8734 398c B091 0000 		lds r27,sdRamSampleRemaining+3
 8735 3990 0197      		sbiw r24,1
 8736 3992 A109      		sbc r26,__zero_reg__
 8737 3994 B109      		sbc r27,__zero_reg__
 8738 3996 8093 0000 		sts sdRamSampleRemaining,r24
 8739 399a 9093 0000 		sts sdRamSampleRemaining+1,r25
 8740 399e A093 0000 		sts sdRamSampleRemaining+2,r26
 8741 39a2 B093 0000 		sts sdRamSampleRemaining+3,r27
 8742 39a6 00C0      		rjmp .L624
 8743               	.LVL349:
 8744               	.L633:
1343:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8745               		.loc 1 1343 0
 8746 39a8 1092 0000 		sts sdIsrState,__zero_reg__
1344:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
 8747               		.loc 1 1344 0
 8748 39ac 1092 B100 		sts 177,__zero_reg__
1345:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8749               		.loc 1 1345 0
 8750 39b0 8091 7000 		lds r24,112
 8751 39b4 8B7F      		andi r24,lo8(-5)
 8752 39b6 8093 7000 		sts 112,r24
1347:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
 8753               		.loc 1 1347 0
 8754 39ba 8091 0000 		lds r24,sdBank0
 8755 39be 8130      		cpi r24,lo8(1)
 8756 39c0 01F4      		brne .L637
1349:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
 8757               		.loc 1 1349 0
 8758 39c2 1092 0000 		sts bankStates+5,__zero_reg__
 8759 39c6 00C0      		rjmp .L624
 8760               	.L637:
1353:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
 8761               		.loc 1 1353 0
 8762 39c8 1092 0000 		sts bankStates+40,__zero_reg__
 8763 39cc 00C0      		rjmp .L624
 8764               	.L632:
1358:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
 8765               		.loc 1 1358 0
 8766 39ce 8330      		cpi r24,lo8(3)
 8767 39d0 01F0      		breq .+2
 8768 39d2 00C0      		rjmp .L624
1360:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 8769               		.loc 1 1360 0
 8770 39d4 8091 0000 		lds r24,sdRamSampleRemaining
 8771 39d8 9091 0000 		lds r25,sdRamSampleRemaining+1
 8772 39dc A091 0000 		lds r26,sdRamSampleRemaining+2
 8773 39e0 B091 0000 		lds r27,sdRamSampleRemaining+3
 8774 39e4 892B      		or r24,r25
 8775 39e6 8A2B      		or r24,r26
 8776 39e8 8B2B      		or r24,r27
 8777 39ea 01F4      		brne .+2
 8778 39ec 00C0      		rjmp .L638
1362:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 8779               		.loc 1 1362 0
 8780 39ee 8091 0000 		lds r24,sdBytesInFifo
 8781 39f2 9091 0000 		lds r25,sdBytesInFifo+1
 8782 39f6 892B      		or r24,r25
 8783 39f8 01F4      		brne .+2
 8784 39fa 00C0      		rjmp .L624
1364:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 8785               		.loc 1 1364 0
 8786 39fc E091 0000 		lds r30,sdFifoReadPointer
 8787 3a00 F091 0000 		lds r31,sdFifoReadPointer+1
 8788 3a04 E050      		subi r30,lo8(-(sdFifo))
 8789 3a06 F040      		sbci r31,hi8(-(sdFifo))
 8790 3a08 2081      		ld r18,Z
 8791               	.LVL350:
1366:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 8792               		.loc 1 1366 0
 8793 3a0a 8091 0000 		lds r24,sdFifoReadPointer
 8794 3a0e 9091 0000 		lds r25,sdFifoReadPointer+1
 8795 3a12 0196      		adiw r24,1
 8796 3a14 9093 0000 		sts sdFifoReadPointer+1,r25
 8797 3a18 8093 0000 		sts sdFifoReadPointer,r24
1367:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 8798               		.loc 1 1367 0
 8799 3a1c 8091 0000 		lds r24,sdFifoReadPointer
 8800 3a20 9091 0000 		lds r25,sdFifoReadPointer+1
 8801 3a24 8115      		cp r24,__zero_reg__
 8802 3a26 9340      		sbci r25,3
 8803 3a28 00F0      		brlo .L639
1369:WTPA.c        **** 					sdFifoReadPointer=0;
 8804               		.loc 1 1369 0
 8805 3a2a 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 8806 3a2e 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 8807               	.L639:
1372:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 8808               		.loc 1 1372 0
 8809 3a32 8091 0000 		lds r24,sdBytesInFifo
 8810 3a36 9091 0000 		lds r25,sdBytesInFifo+1
 8811 3a3a 0197      		sbiw r24,1
 8812 3a3c 9093 0000 		sts sdBytesInFifo+1,r25
 8813 3a40 8093 0000 		sts sdBytesInFifo,r24
1373:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 8814               		.loc 1 1373 0
 8815 3a44 8091 0000 		lds r24,sdRamSampleRemaining
 8816 3a48 9091 0000 		lds r25,sdRamSampleRemaining+1
 8817 3a4c A091 0000 		lds r26,sdRamSampleRemaining+2
 8818 3a50 B091 0000 		lds r27,sdRamSampleRemaining+3
 8819 3a54 0197      		sbiw r24,1
 8820 3a56 A109      		sbc r26,__zero_reg__
 8821 3a58 B109      		sbc r27,__zero_reg__
 8822 3a5a 8093 0000 		sts sdRamSampleRemaining,r24
 8823 3a5e 9093 0000 		sts sdRamSampleRemaining+1,r25
 8824 3a62 A093 0000 		sts sdRamSampleRemaining+2,r26
 8825 3a66 B093 0000 		sts sdRamSampleRemaining+3,r27
1377:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
 8826               		.loc 1 1377 0
 8827 3a6a 2093 0000 		sts sdStreamOutput,r18
1378:WTPA.c        **** 				UpdateOutput();				// Update the DAC
 8828               		.loc 1 1378 0
 8829 3a6e E091 0000 		lds r30,UpdateOutput
 8830 3a72 F091 0000 		lds r31,UpdateOutput+1
 8831 3a76 0995      		icall
 8832               	.LVL351:
 8833 3a78 00C0      		rjmp .L624
 8834               	.L638:
1383:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8835               		.loc 1 1383 0
 8836 3a7a 1092 0000 		sts sdIsrState,__zero_reg__
1384:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 8837               		.loc 1 1384 0
 8838 3a7e 1092 B100 		sts 177,__zero_reg__
1385:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8839               		.loc 1 1385 0
 8840 3a82 8091 7000 		lds r24,112
 8841 3a86 8B7F      		andi r24,lo8(-5)
 8842 3a88 8093 7000 		sts 112,r24
1388:WTPA.c        **** 			sdStreamOutput=0;
 8843               		.loc 1 1388 0
 8844 3a8c 1092 0000 		sts sdStreamOutput,__zero_reg__
 8845               	.L624:
 8846               	/* epilogue start */
1391:WTPA.c        **** }
 8847               		.loc 1 1391 0
 8848 3a90 FF91      		pop r31
 8849 3a92 EF91      		pop r30
 8850 3a94 BF91      		pop r27
 8851 3a96 AF91      		pop r26
 8852 3a98 9F91      		pop r25
 8853 3a9a 8F91      		pop r24
 8854 3a9c 7F91      		pop r23
 8855 3a9e 6F91      		pop r22
 8856 3aa0 5F91      		pop r21
 8857 3aa2 4F91      		pop r20
 8858 3aa4 3F91      		pop r19
 8859 3aa6 2F91      		pop r18
 8860 3aa8 0F90      		pop r0
 8861 3aaa 0FBE      		out __SREG__,r0
 8862 3aac 0F90      		pop r0
 8863 3aae 1F90      		pop r1
 8864 3ab0 1895      		reti
 8865               		.cfi_endproc
 8866               	.LFE11:
 8868               	.global	__vector_9
 8870               	__vector_9:
 8871               	.LFB12:
1396:WTPA.c        **** {
 8872               		.loc 1 1396 0
 8873               		.cfi_startproc
 8874 3ab2 1F92      		push r1
 8875               	.LCFI149:
 8876               		.cfi_def_cfa_offset 3
 8877               		.cfi_offset 1, -2
 8878 3ab4 0F92      		push r0
 8879               	.LCFI150:
 8880               		.cfi_def_cfa_offset 4
 8881               		.cfi_offset 0, -3
 8882 3ab6 0FB6      		in r0,__SREG__
 8883 3ab8 0F92      		push r0
 8884 3aba 1124      		clr __zero_reg__
 8885 3abc 8F93      		push r24
 8886               	.LCFI151:
 8887               		.cfi_def_cfa_offset 5
 8888               		.cfi_offset 24, -4
 8889 3abe 9F93      		push r25
 8890               	.LCFI152:
 8891               		.cfi_def_cfa_offset 6
 8892               		.cfi_offset 25, -5
 8893               	/* prologue: Signal */
 8894               	/* frame size = 0 */
 8895               	/* stack size = 5 */
 8896               	.L__stack_usage = 5
1400:WTPA.c        **** 	if(ledPwm>pwmCount)
 8897               		.loc 1 1400 0
 8898 3ac0 9091 0000 		lds r25,ledPwm
 8899 3ac4 8091 0000 		lds r24,pwmCount.1841
 8900 3ac8 8917      		cp r24,r25
 8901 3aca 00F4      		brsh .L649
1402:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
 8902               		.loc 1 1402 0
 8903 3acc 9FEF      		ldi r25,lo8(-1)
 8904 3ace 95B9      		out 0x5,r25
 8905 3ad0 00C0      		rjmp .L650
 8906               	.L649:
1406:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
 8907               		.loc 1 1406 0
 8908 3ad2 15B8      		out 0x5,__zero_reg__
 8909               	.L650:
1408:WTPA.c        **** 	pwmCount++;
 8910               		.loc 1 1408 0
 8911 3ad4 8F5F      		subi r24,lo8(-(1))
 8912 3ad6 8093 0000 		sts pwmCount.1841,r24
 8913               	/* epilogue start */
1409:WTPA.c        **** }
 8914               		.loc 1 1409 0
 8915 3ada 9F91      		pop r25
 8916 3adc 8F91      		pop r24
 8917 3ade 0F90      		pop r0
 8918 3ae0 0FBE      		out __SREG__,r0
 8919 3ae2 0F90      		pop r0
 8920 3ae4 1F90      		pop r1
 8921 3ae6 1895      		reti
 8922               		.cfi_endproc
 8923               	.LFE12:
 8925               	.global	__vector_default
 8927               	__vector_default:
 8928               	.LFB13:
1412:WTPA.c        **** {
 8929               		.loc 1 1412 0
 8930               		.cfi_startproc
 8931 3ae8 1F92      		push r1
 8932               	.LCFI153:
 8933               		.cfi_def_cfa_offset 3
 8934               		.cfi_offset 1, -2
 8935 3aea 0F92      		push r0
 8936               	.LCFI154:
 8937               		.cfi_def_cfa_offset 4
 8938               		.cfi_offset 0, -3
 8939 3aec 0FB6      		in r0,__SREG__
 8940 3aee 0F92      		push r0
 8941 3af0 1124      		clr __zero_reg__
 8942               	/* prologue: Signal */
 8943               	/* frame size = 0 */
 8944               	/* stack size = 3 */
 8945               	.L__stack_usage = 3
 8946               	/* epilogue start */
1416:WTPA.c        **** }
 8947               		.loc 1 1416 0
 8948 3af2 0F90      		pop r0
 8949 3af4 0FBE      		out __SREG__,r0
 8950 3af6 0F90      		pop r0
 8951 3af8 1F90      		pop r1
 8952 3afa 1895      		reti
 8953               		.cfi_endproc
 8954               	.LFE13:
 8956               	.global	HandleSoftclock
 8958               	HandleSoftclock:
 8959               	.LFB15:
1437:WTPA.c        **** {
 8960               		.loc 1 1437 0
 8961               		.cfi_startproc
 8962               	/* prologue: function */
 8963               	/* frame size = 0 */
 8964               	/* stack size = 0 */
 8965               	.L__stack_usage = 0
1438:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 8966               		.loc 1 1438 0
 8967 3afc A89B      		sbis 0x15,0
 8968 3afe 00C0      		rjmp .L652
 8969               	.LBB278:
 8970               	.LBB279:
1440:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 8971               		.loc 1 1440 0
 8972 3b00 A89A      		sbi 0x15,0
1441:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 8973               		.loc 1 1441 0
 8974 3b02 8091 0000 		lds r24,systemTicks
 8975 3b06 9091 0000 		lds r25,systemTicks+1
 8976               	.LVL352:
 8977 3b0a 0196      		adiw r24,1
 8978               	.LVL353:
 8979 3b0c 9093 0000 		sts systemTicks+1,r25
 8980 3b10 8093 0000 		sts systemTicks,r24
 8981               	.LVL354:
 8982               	.L652:
 8983 3b14 0895      		ret
 8984               	.LBE279:
 8985               	.LBE278:
 8986               		.cfi_endproc
 8987               	.LFE15:
 8989               		.section	.text.startup,"ax",@progbits
 8990               	.global	main
 8992               	main:
 8993               	.LFB73:
4755:WTPA.c        **** 
4756:WTPA.c        **** 
4757:WTPA.c        **** //-----------------------------------------------------------------------
4758:WTPA.c        **** //-----------------------------------------------------------------------
4759:WTPA.c        **** // Program main loop.
4760:WTPA.c        **** //-----------------------------------------------------------------------
4761:WTPA.c        **** //-----------------------------------------------------------------------
4762:WTPA.c        **** 
4763:WTPA.c        **** int main(void)
4764:WTPA.c        **** // Initialize this mess.
4765:WTPA.c        **** {
 8994               		.loc 1 4765 0
 8995               		.cfi_startproc
 8996               	/* prologue: function */
 8997               	/* frame size = 0 */
 8998               	/* stack size = 0 */
 8999               	.L__stack_usage = 0
4766:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
 9000               		.loc 1 4766 0
 9001 0000 CFEF      		ldi r28,lo8(-1)
 9002 0002 C093 6400 		sts 100,r28
4767:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
 9003               		.loc 1 4767 0
 9004 0006 85B7      		in r24,0x35
 9005 0008 8F7E      		andi r24,lo8(-17)
 9006 000a 85BF      		out 0x35,r24
4768:WTPA.c        **** 
4769:WTPA.c        **** 	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initia
4770:WTPA.c        **** 
4771:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
 9007               		.loc 1 4771 0
 9008 000c 8FEE      		ldi r24,lo8(-17)
 9009 000e 87B9      		out 0x7,r24
4772:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
 9010               		.loc 1 4772 0
 9011 0010 88E0      		ldi r24,lo8(8)
 9012 0012 88B9      		out 0x8,r24
4773:WTPA.c        **** 
4774:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
 9013               		.loc 1 4774 0
 9014 0014 80E8      		ldi r24,lo8(-128)
 9015 0016 8AB9      		out 0xa,r24
4775:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
 9016               		.loc 1 4775 0
 9017 0018 1BB8      		out 0xb,__zero_reg__
4776:WTPA.c        **** 
4777:WTPA.c        **** //	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pi
4778:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
 9018               		.loc 1 4778 0
 9019 001a 96E0      		ldi r25,lo8(6)
 9020 001c 92B9      		out 0x2,r25
4779:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
 9021               		.loc 1 4779 0
 9022 001e 9EE3      		ldi r25,lo8(62)
 9023 0020 91B9      		out 0x1,r25
4780:WTPA.c        **** 
4781:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
 9024               		.loc 1 4781 0
 9025 0022 C4B9      		out 0x4,r28
4782:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
 9026               		.loc 1 4782 0
 9027 0024 85B9      		out 0x5,r24
4783:WTPA.c        **** 
4784:WTPA.c        **** 	// Set the DAC to midscale to avoid pops on the first interrupt call.
4785:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
 9028               		.loc 1 4785 0
 9029 0026 129A      		sbi 0x2,2
4786:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 9030               		.loc 1 4786 0
 9031 0028 C4B9      		out 0x4,r28
4787:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
 9032               		.loc 1 4787 0
 9033 002a 159A      		sbi 0x2,5
4788:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 9034               		.loc 1 4788 0
 9035 002c 1598      		cbi 0x2,5
4789:WTPA.c        **** 
4790:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
 9036               		.loc 1 4790 0
 9037 002e 0E94 0000 		call InitSdInterface
 9038               	.LVL355:
 9039               	.LBB314:
 9040               	.LBB315:
1580:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
 9041               		.loc 1 1580 0
 9042 0032 66E2      		ldi r22,lo8(38)
 9043 0034 70E0      		ldi r23,0
 9044 0036 81E0      		ldi r24,lo8(1)
 9045 0038 0E94 0000 		call SetTimer
 9046               	.LVL356:
1582:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
 9047               		.loc 1 1582 0
 9048 003c 3D98      		cbi 0x7,5
1583:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
 9049               		.loc 1 1583 0
 9050 003e 459A      		sbi 0x8,5
 9051               	.LBE315:
 9052               	.LBE314:
 9053               	.LBB316:
 9054               	.LBB317:
1653:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
 9055               		.loc 1 1653 0
 9056 0040 80B1      		in r24,0
 9057 0042 807C      		andi r24,lo8(-64)
 9058 0044 8093 0000 		sts encoderState,r24
1654:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
 9059               		.loc 1 1654 0
 9060 0048 1092 0000 		sts encoderValue,__zero_reg__
 9061               	.LBE317:
 9062               	.LBE316:
 9063               	.LBB318:
 9064               	.LBB319:
1567:WTPA.c        **** 	ledOnOffMask=0;
 9065               		.loc 1 1567 0
 9066 004c 1092 0000 		sts ledOnOffMask,__zero_reg__
1568:WTPA.c        **** 	ledBlinkMask=0;
 9067               		.loc 1 1568 0
 9068 0050 1092 0000 		sts ledBlinkMask,__zero_reg__
1569:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
 9069               		.loc 1 1569 0
 9070 0054 80E0      		ldi r24,0
 9071 0056 0E94 0000 		call WriteLedLatch
 9072               	.LVL357:
 9073               	.LBE319:
 9074               	.LBE318:
4791:WTPA.c        **** 	InitSwitches();
4792:WTPA.c        **** 	InitEncoder();
4793:WTPA.c        **** 	InitLeds();
4794:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
 9075               		.loc 1 4794 0
 9076 005a 0E94 0000 		call InitMidi
 9077               	.LVL358:
4795:WTPA.c        **** 	InitUart0();
 9078               		.loc 1 4795 0
 9079 005e 0E94 0000 		call InitUart0
 9080               	.LVL359:
 9081               	.LBB320:
 9082               	.LBB321:
1754:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
 9083               		.loc 1 1754 0
 9084 0062 8091 6400 		lds r24,100
 9085 0066 8E7F      		andi r24,lo8(-2)
 9086 0068 8093 6400 		sts 100,r24
1755:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
 9087               		.loc 1 1755 0
 9088 006c 80E6      		ldi r24,lo8(96)
 9089 006e 8093 7C00 		sts 124,r24
1756:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
 9090               		.loc 1 1756 0
 9091 0072 81E0      		ldi r24,lo8(1)
 9092 0074 8093 7E00 		sts 126,r24
1757:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
 9093               		.loc 1 1757 0
 9094 0078 85E9      		ldi r24,lo8(-107)
 9095 007a 8093 7A00 		sts 122,r24
1759:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
 9096               		.loc 1 1759 0
 9097 007e 8091 7A00 		lds r24,122
 9098 0082 8064      		ori r24,lo8(64)
 9099 0084 8093 7A00 		sts 122,r24
 9100               	.LBE321:
 9101               	.LBE320:
 9102               	.LBB322:
 9103               	.LBB323:
1457:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
 9104               		.loc 1 1457 0
 9105 0088 8091 6400 		lds r24,100
 9106 008c 8F7D      		andi r24,lo8(-33)
 9107 008e 8093 6400 		sts 100,r24
1458:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
 9108               		.loc 1 1458 0
 9109 0092 1092 6E00 		sts 110,__zero_reg__
1459:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
 9110               		.loc 1 1459 0
 9111 0096 14BC      		out 0x24,__zero_reg__
1460:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
 9112               		.loc 1 1460 0
 9113 0098 16BC      		out 0x26,__zero_reg__
1461:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 9114               		.loc 1 1461 0
 9115 009a C5BB      		out 0x15,r28
1462:WTPA.c        **** 	systemTicks=0;
 9116               		.loc 1 1462 0
 9117 009c 1092 0000 		sts systemTicks+1,__zero_reg__
 9118 00a0 1092 0000 		sts systemTicks,__zero_reg__
1464:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 9119               		.loc 1 1464 0
 9120 00a4 83E0      		ldi r24,lo8(3)
 9121 00a6 85BD      		out 0x25,r24
 9122               	.LBE323:
 9123               	.LBE322:
 9124               	.LBB324:
 9125               	.LBB325:
2013:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
 9126               		.loc 1 2013 0
 9127 00a8 8091 6400 		lds r24,100
 9128 00ac 877F      		andi r24,lo8(-9)
 9129 00ae 8093 6400 		sts 100,r24
2014:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
 9130               		.loc 1 2014 0
 9131 00b2 1092 6F00 		sts 111,__zero_reg__
2015:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
 9132               		.loc 1 2015 0
 9133 00b6 8FEF      		ldi r24,lo8(-1)
 9134 00b8 9FEF      		ldi r25,lo8(-1)
 9135 00ba 9093 8900 		sts 136+1,r25
 9136 00be 8093 8800 		sts 136,r24
2016:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
 9137               		.loc 1 2016 0
 9138 00c2 9093 8B00 		sts 138+1,r25
 9139 00c6 8093 8A00 		sts 138,r24
2017:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
 9140               		.loc 1 2017 0
 9141 00ca 1092 8000 		sts 128,__zero_reg__
2018:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
 9142               		.loc 1 2018 0
 9143 00ce 1092 8100 		sts 129,__zero_reg__
2019:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
 9144               		.loc 1 2019 0
 9145 00d2 1092 8500 		sts 132+1,__zero_reg__
 9146 00d6 1092 8400 		sts 132,__zero_reg__
2020:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
 9147               		.loc 1 2020 0
 9148 00da C6BB      		out 0x16,r28
 9149               	.LBE325:
 9150               	.LBE324:
4796:WTPA.c        **** //	InitUart1();
4797:WTPA.c        **** 	InitAdc();
4798:WTPA.c        **** 	InitSoftclock();
4799:WTPA.c        **** //	InitRandom();
4800:WTPA.c        **** 	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.
4801:WTPA.c        **** 
4802:WTPA.c        **** 	newKeys=0;
 9151               		.loc 1 4802 0
 9152 00dc 1092 0000 		sts newKeys,__zero_reg__
4803:WTPA.c        **** 	keyState=0;
 9153               		.loc 1 4803 0
 9154 00e0 1092 0000 		sts keyState,__zero_reg__
4804:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
 9155               		.loc 1 4804 0
 9156 00e4 1092 0000 		sts cardState,__zero_reg__
4805:WTPA.c        **** 	cardDetect=false;
 9157               		.loc 1 4805 0
 9158 00e8 1092 0000 		sts cardDetect,__zero_reg__
4806:WTPA.c        **** 
4807:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
 9159               		.loc 1 4807 0
 9160               	/* #APP */
 9161               	 ;  4807 "WTPA.c" 1
 9162 00ec 7894      		sei
 9163               	 ;  0 "" 2
 9164               	.LVL360:
 9165               	/* #NOAPP */
 9166               	.LBB326:
 9167               	.LBB327:
1426:WTPA.c        **** 	State=newState;
 9168               		.loc 1 1426 0
 9169 00ee 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 9170 00f0 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 9171 00f2 9093 0000 		sts State+1,r25
 9172 00f6 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 9173               		.loc 1 1427 0
 9174 00fa 1092 0000 		sts subState,__zero_reg__
 9175               	.LBE327:
 9176               	.LBE326:
 9177               	.LBB328:
 9178               	.LBB329:
1601:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9179               		.loc 1 1601 0
 9180 00fe CC24      		clr r12
 9181 0100 CA94      		dec r12
 9182               	.LBE329:
 9183               	.LBE328:
 9184               	.LBB332:
 9185               	.LBB333:
1549:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9186               		.loc 1 1549 0
 9187 0102 EE24      		clr r14
 9188 0104 E394      		inc r14
 9189 0106 F12C      		mov r15,__zero_reg__
 9190               	.LBE333:
 9191               	.LBE332:
 9192               	.LBB335:
 9193               	.LBB336:
2592:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 9194               		.loc 1 2592 0
 9195 0108 C0E0      		ldi r28,0
 9196 010a D2E0      		ldi r29,lo8(2)
2602:WTPA.c        **** 				bytesLeftInBlock-=4;
 9197               		.loc 1 2602 0
 9198 010c 6CE0      		ldi r22,lo8(12)
 9199 010e 362E      		mov r3,r22
2617:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 9200               		.loc 1 2617 0
 9201 0110 77E0      		ldi r23,lo8(7)
 9202 0112 972E      		mov r9,r23
2794:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 9203               		.loc 1 2794 0
 9204 0114 EBE0      		ldi r30,lo8(11)
 9205 0116 8E2E      		mov r8,r30
2800:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
 9206               		.loc 1 2800 0
 9207 0118 FEE0      		ldi r31,lo8(14)
 9208 011a DF2E      		mov r13,r31
2746:WTPA.c        **** 				cardState=SD_READ_ABORT;
 9209               		.loc 1 2746 0
 9210 011c ADE0      		ldi r26,lo8(13)
 9211 011e BA2E      		mov r11,r26
2833:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 9212               		.loc 1 2833 0
 9213 0120 B4E0      		ldi r27,lo8(4)
 9214 0122 2B2E      		mov r2,r27
2852:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 9215               		.loc 1 2852 0
 9216 0124 1AE0      		ldi r17,lo8(10)
 9217 0126 A12E      		mov r10,r17
 9218               	.L763:
 9219               	.LBE336:
 9220               	.LBE335:
 9221               	.LBB353:
 9222               	.LBB330:
1596:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
 9223               		.loc 1 1596 0
 9224 0128 81E0      		ldi r24,lo8(1)
 9225 012a 0E94 0000 		call CheckTimer
 9226               	.LVL361:
 9227 012e 8823      		tst r24
 9228 0130 01F0      		breq .L658
1599:WTPA.c        **** 		sreg=SREG;
 9229               		.loc 1 1599 0
 9230 0132 9FB7      		in r25,__SREG__
 9231               	.LVL362:
1600:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
 9232               		.loc 1 1600 0
 9233               	/* #APP */
 9234               	 ;  1600 "WTPA.c" 1
 9235 0134 F894      		cli
 9236               	 ;  0 "" 2
1601:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9237               		.loc 1 1601 0
 9238               	/* #NOAPP */
 9239 0136 C5B8      		out 0x5,r12
1602:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 9240               		.loc 1 1602 0
 9241 0138 14B8      		out 0x4,__zero_reg__
1603:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 9242               		.loc 1 1603 0
 9243 013a 4398      		cbi 0x8,3
1604:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
 9244               		.loc 1 1604 0
 9245               	/* #APP */
 9246               	 ;  1604 "WTPA.c" 1
 9247 013c 0000      		nop
 9248               	 ;  0 "" 2
1605:WTPA.c        **** 		asm volatile("nop"::);
 9249               		.loc 1 1605 0
 9250               	 ;  1605 "WTPA.c" 1
 9251 013e 0000      		nop
 9252               	 ;  0 "" 2
1606:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 9253               		.loc 1 1606 0
 9254               	/* #NOAPP */
 9255 0140 83B1      		in r24,0x3
 9256 0142 8095      		com r24
 9257 0144 8093 0000 		sts keyState,r24
1607:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 9258               		.loc 1 1607 0
 9259 0148 439A      		sbi 0x8,3
1608:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 9260               		.loc 1 1608 0
 9261 014a C4B8      		out 0x4,r12
1609:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
 9262               		.loc 1 1609 0
 9263 014c 9FBF      		out __SREG__,r25
1611:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
 9264               		.loc 1 1611 0
 9265 014e 3599      		sbic 0x6,5
 9266 0150 00C0      		rjmp .L659
1613:WTPA.c        **** 			cardDetect=true;
 9267               		.loc 1 1613 0
 9268 0152 81E0      		ldi r24,lo8(1)
 9269 0154 8093 0000 		sts cardDetect,r24
 9270 0158 00C0      		rjmp .L660
 9271               	.L659:
1617:WTPA.c        **** 			cardDetect=false;
 9272               		.loc 1 1617 0
 9273 015a 1092 0000 		sts cardDetect,__zero_reg__
 9274               	.L660:
1620:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
 9275               		.loc 1 1620 0
 9276 015e 66E2      		ldi r22,lo8(38)
 9277 0160 70E0      		ldi r23,0
 9278 0162 81E0      		ldi r24,lo8(1)
 9279 0164 0E94 0000 		call SetTimer
 9280               	.LVL363:
 9281               	.L658:
1623:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
 9282               		.loc 1 1623 0
 9283 0168 9091 0000 		lds r25,keyState
 9284 016c 8091 0000 		lds r24,lastKeyState.1891
 9285 0170 8095      		com r24
 9286 0172 8923      		and r24,r25
 9287 0174 8093 0000 		sts newKeys,r24
1624:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
 9288               		.loc 1 1624 0
 9289 0178 8095      		com r24
 9290               	.LBE330:
 9291 017a 8923      		and r24,r25
 9292               	.LBB331:
 9293 017c 8093 0000 		sts keysHeld,r24
1625:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
 9294               		.loc 1 1625 0
 9295 0180 9093 0000 		sts lastKeyState.1891,r25
 9296               	.LBE331:
 9297               	.LBE353:
 9298               	.LBB354:
 9299               	.LBB355:
1666:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
 9300               		.loc 1 1666 0
 9301 0184 2091 0000 		lds r18,systemTicks
 9302 0188 3091 0000 		lds r19,systemTicks+1
 9303 018c 8091 0000 		lds r24,lastEncTime.1900
 9304 0190 9091 0000 		lds r25,lastEncTime.1900+1
 9305 0194 2817      		cp r18,r24
 9306 0196 3907      		cpc r19,r25
 9307 0198 01F0      		breq .L662
1668:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
 9308               		.loc 1 1668 0
 9309 019a 8091 0000 		lds r24,systemTicks
 9310 019e 9091 0000 		lds r25,systemTicks+1
 9311 01a2 9093 0000 		sts lastEncTime.1900+1,r25
 9312 01a6 8093 0000 		sts lastEncTime.1900,r24
1669:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
 9313               		.loc 1 1669 0
 9314 01aa 80B1      		in r24,0
 9315 01ac 807C      		andi r24,lo8(-64)
 9316 01ae 8093 0000 		sts encoderState,r24
1671:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
 9317               		.loc 1 1671 0
 9318 01b2 9091 0000 		lds r25,lastEncoderState.1899
 9319 01b6 8917      		cp r24,r25
 9320 01b8 01F0      		breq .L662
1673:WTPA.c        **** 			if(encoderState==ENC_POS_A)
 9321               		.loc 1 1673 0
 9322 01ba 8111      		cpse r24,__zero_reg__
 9323 01bc 00C0      		rjmp .L664
1675:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
 9324               		.loc 1 1675 0
 9325 01be 9038      		cpi r25,lo8(-128)
 9326 01c0 01F4      		brne .L665
 9327 01c2 00C0      		rjmp .L853
 9328               	.L665:
1680:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
 9329               		.loc 1 1680 0
 9330 01c4 9034      		cpi r25,lo8(64)
 9331 01c6 01F4      		brne .L666
 9332 01c8 00C0      		rjmp .L849
 9333               	.L664:
1686:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
 9334               		.loc 1 1686 0
 9335 01ca 8034      		cpi r24,lo8(64)
 9336 01cc 01F4      		brne .L667
1688:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
 9337               		.loc 1 1688 0
 9338 01ce 9111      		cpse r25,__zero_reg__
 9339 01d0 00C0      		rjmp .L668
 9340 01d2 00C0      		rjmp .L853
 9341               	.L668:
1693:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
 9342               		.loc 1 1693 0
 9343 01d4 903C      		cpi r25,lo8(-64)
 9344 01d6 01F4      		brne .L666
 9345 01d8 00C0      		rjmp .L849
 9346               	.L667:
1699:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
 9347               		.loc 1 1699 0
 9348 01da 803C      		cpi r24,lo8(-64)
 9349 01dc 01F4      		brne .L669
1701:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
 9350               		.loc 1 1701 0
 9351 01de 9034      		cpi r25,lo8(64)
 9352 01e0 01F4      		brne .L670
 9353 01e2 00C0      		rjmp .L853
 9354               	.L670:
1706:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
 9355               		.loc 1 1706 0
 9356 01e4 9038      		cpi r25,lo8(-128)
 9357 01e6 01F4      		brne .L666
 9358 01e8 00C0      		rjmp .L849
 9359               	.L669:
1712:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
 9360               		.loc 1 1712 0
 9361 01ea 8038      		cpi r24,lo8(-128)
 9362 01ec 01F4      		brne .L666
1714:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
 9363               		.loc 1 1714 0
 9364 01ee 903C      		cpi r25,lo8(-64)
 9365 01f0 01F4      		brne .L671
 9366               	.L853:
1717:WTPA.c        **** 					encoderValue--;
 9367               		.loc 1 1717 0
 9368 01f2 9091 0000 		lds r25,encoderValue
 9369 01f6 9150      		subi r25,lo8(-(-1))
 9370 01f8 00C0      		rjmp .L848
 9371               	.L671:
1719:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
 9372               		.loc 1 1719 0
 9373 01fa 9111      		cpse r25,__zero_reg__
 9374 01fc 00C0      		rjmp .L666
 9375               	.L849:
1722:WTPA.c        **** 					encoderValue++;
 9376               		.loc 1 1722 0
 9377 01fe 9091 0000 		lds r25,encoderValue
 9378 0202 9F5F      		subi r25,lo8(-(1))
 9379               	.L848:
 9380 0204 9093 0000 		sts encoderValue,r25
 9381               	.L666:
1726:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
 9382               		.loc 1 1726 0
 9383 0208 8093 0000 		sts lastEncoderState.1899,r24
 9384               	.L662:
 9385               	.LBE355:
 9386               	.LBE354:
4808:WTPA.c        **** 
4809:WTPA.c        **** 	SetState(DoFruitcakeIntro);	// Get gay.
4810:WTPA.c        **** //	SetState(DoStartupSelect);
4811:WTPA.c        **** 
4812:WTPA.c        **** 	while(1)
4813:WTPA.c        **** 	{
4814:WTPA.c        **** 		HandleSwitches();		// Flag newKeys.
4815:WTPA.c        **** 		HandleEncoder();		// Keep track of encoder states and increment values.
4816:WTPA.c        **** 		HandleSoftclock();		// Keep the timer timing.
 9387               		.loc 1 4816 0
 9388 020c 0E94 0000 		call HandleSoftclock
 9389               	.LVL364:
 9390               	.LBB356:
 9391               	.LBB334:
1537:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
 9392               		.loc 1 1537 0
 9393 0210 8091 0000 		lds r24,ledBlinkMask
 9394 0214 8823      		tst r24
 9395 0216 01F0      		breq .L672
 9396 0218 82E0      		ldi r24,lo8(2)
 9397 021a 0E94 0000 		call CheckTimer
 9398               	.LVL365:
 9399 021e 8823      		tst r24
 9400 0220 01F0      		breq .L672
1541:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9401               		.loc 1 1541 0
 9402 0222 2091 0000 		lds r18,ledBlinkMask
 9403 0226 30E0      		ldi r19,0
1543:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9404               		.loc 1 1543 0
 9405 0228 F091 0000 		lds r31,toggle.1877
 9406 022c E091 0000 		lds r30,ledOnOffMask
 9407 0230 80E0      		ldi r24,0
 9408 0232 90E0      		ldi r25,0
 9409               	.L675:
1541:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9410               		.loc 1 1541 0
 9411 0234 B901      		movw r22,r18
 9412 0236 082E      		mov r0,r24
 9413 0238 00C0      		rjmp 2f
 9414               		1:
 9415 023a 7595      		asr r23
 9416 023c 6795      		ror r22
 9417               		2:
 9418 023e 0A94      		dec r0
 9419 0240 02F4      		brpl 1b
 9420 0242 60FF      		sbrs r22,0
 9421 0244 00C0      		rjmp .L673
1545:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9422               		.loc 1 1545 0
 9423 0246 B701      		movw r22,r14
 9424 0248 082E      		mov r0,r24
 9425 024a 00C0      		rjmp 2f
 9426               		1:
 9427 024c 660F      		lsl r22
 9428 024e 771F      		rol r23
 9429               		2:
 9430 0250 0A94      		dec r0
 9431 0252 02F4      		brpl 1b
 9432 0254 AB01      		movw r20,r22
1543:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9433               		.loc 1 1543 0
 9434 0256 FF23      		tst r31
 9435 0258 01F0      		breq .L674
1545:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9436               		.loc 1 1545 0
 9437 025a E62B      		or r30,r22
 9438 025c 00C0      		rjmp .L673
 9439               	.L674:
1549:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9440               		.loc 1 1549 0
 9441 025e 4095      		com r20
 9442 0260 E423      		and r30,r20
 9443               	.L673:
 9444               	.LVL366:
 9445 0262 0196      		adiw r24,1
1539:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
 9446               		.loc 1 1539 0
 9447 0264 8830      		cpi r24,8
 9448 0266 9105      		cpc r25,__zero_reg__
 9449 0268 01F4      		brne .L675
 9450 026a E093 0000 		sts ledOnOffMask,r30
1554:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
 9451               		.loc 1 1554 0
 9452 026e 81E0      		ldi r24,lo8(1)
 9453 0270 9091 0000 		lds r25,toggle.1877
 9454 0274 9111      		cpse r25,__zero_reg__
 9455 0276 80E0      		ldi r24,0
 9456               	.L676:
 9457 0278 8093 0000 		sts toggle.1877,r24
1555:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
 9458               		.loc 1 1555 0
 9459 027c 68E9      		ldi r22,lo8(-104)
 9460 027e 70E0      		ldi r23,0
 9461 0280 82E0      		ldi r24,lo8(2)
 9462 0282 0E94 0000 		call SetTimer
 9463               	.LVL367:
1556:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
 9464               		.loc 1 1556 0
 9465 0286 8091 0000 		lds r24,ledOnOffMask
 9466 028a 0E94 0000 		call WriteLedLatch
 9467               	.LVL368:
 9468 028e 00C0      		rjmp .L677
 9469               	.L672:
1558:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
 9470               		.loc 1 1558 0
 9471 0290 1091 0000 		lds r17,ledOnOffMask
 9472 0294 8091 0000 		lds r24,lastLedMask.1878
 9473 0298 8117      		cp r24,r17
 9474 029a 01F0      		breq .L677
1560:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
 9475               		.loc 1 1560 0
 9476 029c 812F      		mov r24,r17
 9477 029e 0E94 0000 		call WriteLedLatch
 9478               	.LVL369:
1561:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
 9479               		.loc 1 1561 0
 9480 02a2 1093 0000 		sts lastLedMask.1878,r17
 9481               	.L677:
 9482               	.LBE334:
 9483               	.LBE356:
 9484               	.LBB357:
 9485               	.LBB351:
2368:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
 9486               		.loc 1 2368 0
 9487 02a6 9091 0000 		lds r25,cardDetect
 9488 02aa 8091 0000 		lds r24,cardState
 9489 02ae 9111      		cpse r25,__zero_reg__
 9490 02b0 00C0      		rjmp .L678
2370:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 9491               		.loc 1 2370 0
 9492 02b2 8823      		tst r24
 9493 02b4 01F4      		brne .+2
 9494 02b6 00C0      		rjmp .L680
 9495               	.L679:
2372:WTPA.c        **** 			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
 9496               		.loc 1 2372 0
 9497 02b8 0E94 0000 		call ResetSdCard
 9498               	.LVL370:
 9499 02bc 00C0      		rjmp .L680
 9500               	.L678:
2377:WTPA.c        **** 		switch(cardState)
 9501               		.loc 1 2377 0
 9502 02be 8630      		cpi r24,lo8(6)
 9503 02c0 01F4      		brne .+2
 9504 02c2 00C0      		rjmp .L687
 9505 02c4 00F4      		brsh .L695
 9506 02c6 8230      		cpi r24,lo8(2)
 9507 02c8 01F4      		brne .+2
 9508 02ca 00C0      		rjmp .L683
 9509 02cc 00F4      		brsh .L696
 9510 02ce 8823      		tst r24
 9511 02d0 01F0      		breq .L681
 9512 02d2 8130      		cpi r24,lo8(1)
 9513 02d4 01F0      		breq .+2
 9514 02d6 00C0      		rjmp .L680
 9515 02d8 00C0      		rjmp .L682
 9516               	.L696:
 9517 02da 8430      		cpi r24,lo8(4)
 9518 02dc 01F4      		brne .+2
 9519 02de 00C0      		rjmp .L685
 9520 02e0 00F0      		brlo .+2
 9521 02e2 00C0      		rjmp .L686
 9522 02e4 00C0      		rjmp .L844
 9523               	.L695:
 9524 02e6 8A30      		cpi r24,lo8(10)
 9525 02e8 01F4      		brne .+2
 9526 02ea 00C0      		rjmp .L691
 9527 02ec 00F4      		brsh .L697
 9528 02ee 8830      		cpi r24,lo8(8)
 9529 02f0 01F4      		brne .+2
 9530 02f2 00C0      		rjmp .L689
 9531 02f4 00F0      		brlo .+2
 9532 02f6 00C0      		rjmp .L690
 9533 02f8 00C0      		rjmp .L845
 9534               	.L697:
 9535 02fa 8C30      		cpi r24,lo8(12)
 9536 02fc 01F4      		brne .+2
 9537 02fe 00C0      		rjmp .L693
 9538 0300 00F4      		brsh .+2
 9539 0302 00C0      		rjmp .L692
 9540 0304 8D30      		cpi r24,lo8(13)
 9541 0306 01F0      		breq .+2
 9542 0308 00C0      		rjmp .L680
 9543 030a 00C0      		rjmp .L694
 9544               	.L681:
2385:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
 9545               		.loc 1 2385 0
 9546 030c 81E0      		ldi r24,lo8(1)
 9547 030e 8093 0000 		sts cardState,r24
2386:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
 9548               		.loc 1 2386 0
 9549 0312 64EC      		ldi r22,lo8(-60)
 9550 0314 74E0      		ldi r23,lo8(4)
 9551 0316 83E0      		ldi r24,lo8(3)
 9552 0318 0E94 0000 		call SetTimer
 9553               	.LVL371:
 9554 031c 00C0      		rjmp .L680
 9555               	.L682:
2390:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
 9556               		.loc 1 2390 0
 9557 031e 83E0      		ldi r24,lo8(3)
 9558 0320 0E94 0000 		call CheckTimer
 9559               	.LVL372:
 9560 0324 8823      		tst r24
 9561 0326 01F4      		brne .+2
 9562 0328 00C0      		rjmp .L680
2392:WTPA.c        **** 				sdPlaybackQueued=false;
 9563               		.loc 1 2392 0
 9564 032a 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2393:WTPA.c        **** 				sdAbortRead=false;
 9565               		.loc 1 2393 0
 9566 032e 1092 0000 		sts sdAbortRead,__zero_reg__
2395:WTPA.c        **** 				if(SdHandshake()==true)	// Give it a shot...
 9567               		.loc 1 2395 0
 9568 0332 0E94 0000 		call SdHandshake
 9569               	.LVL373:
 9570 0336 8130      		cpi r24,lo8(1)
 9571 0338 01F0      		breq .+2
 9572 033a 00C0      		rjmp .L699
 9573               	.LVL374:
 9574               	.LBB337:
 9575               	.LBB338:
2130:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
 9576               		.loc 1 2130 0
 9577 033c 60E0      		ldi r22,0
 9578 033e 70E0      		ldi r23,0
 9579 0340 CB01      		movw r24,r22
 9580 0342 0E94 0000 		call SdBeginSingleBlockRead
 9581               	.LVL375:
 9582 0346 8130      		cpi r24,lo8(1)
 9583 0348 01F0      		breq .+2
 9584 034a 00C0      		rjmp .L764
2139:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
 9585               		.loc 1 2139 0
 9586 034c 6AE7      		ldi r22,lo8(122)
 9587 034e 70E0      		ldi r23,0
 9588 0350 83E0      		ldi r24,lo8(3)
 9589 0352 0E94 0000 		call SetTimer
 9590               	.LVL376:
 9591 0356 00C0      		rjmp .L701
 9592               	.L705:
2143:WTPA.c        **** 			HandleSoftclock();	// Kludgy
 9593               		.loc 1 2143 0
 9594 0358 0E94 0000 		call HandleSoftclock
 9595               	.LVL377:
 9596               	.L701:
2141:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 9597               		.loc 1 2141 0
 9598 035c 83E0      		ldi r24,lo8(3)
 9599 035e 0E94 0000 		call CheckTimer
 9600               	.LVL378:
 9601 0362 8823      		tst r24
 9602 0364 01F0      		breq .L702
 9603               	.L706:
2147:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9604               		.loc 1 2147 0
 9605 0366 8FEF      		ldi r24,lo8(-1)
 9606 0368 0E94 0000 		call TransferSdByte
 9607               	.LVL379:
 9608 036c 182F      		mov r17,r24
 9609               	.LVL380:
2153:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9610               		.loc 1 2153 0
 9611 036e 8FEF      		ldi r24,lo8(-1)
 9612 0370 0E94 0000 		call TransferSdByte
 9613               	.LVL381:
2154:WTPA.c        **** 		if(theByte!='T')
 9614               		.loc 1 2154 0
 9615 0374 8435      		cpi r24,lo8(84)
 9616 0376 01F4      		brne .L765
 9617 0378 00C0      		rjmp .L846
 9618               	.LVL382:
 9619               	.L702:
2141:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 9620               		.loc 1 2141 0
 9621 037a 8FEF      		ldi r24,lo8(-1)
 9622 037c 0E94 0000 		call TransferSdByte
 9623               	.LVL383:
 9624 0380 8E3F      		cpi r24,lo8(-2)
 9625 0382 01F4      		brne .L705
 9626 0384 00C0      		rjmp .L706
 9627               	.LVL384:
 9628               	.L846:
2148:WTPA.c        **** 		if(theByte!='W')
 9629               		.loc 1 2148 0
 9630 0386 6624      		clr r6
 9631 0388 6394      		inc r6
 9632 038a 1735      		cpi r17,lo8(87)
 9633 038c 01F0      		breq .L703
 9634               	.L765:
2156:WTPA.c        **** 			filesystemGood=false;
 9635               		.loc 1 2156 0
 9636 038e 612C      		mov r6,__zero_reg__
 9637               	.L703:
 9638               	.LVL385:
2159:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9639               		.loc 1 2159 0
 9640 0390 8FEF      		ldi r24,lo8(-1)
 9641               	.LVL386:
 9642 0392 0E94 0000 		call TransferSdByte
 9643               	.LVL387:
2160:WTPA.c        **** 		if(theByte!='P')
 9644               		.loc 1 2160 0
 9645 0396 8035      		cpi r24,lo8(80)
 9646 0398 01F0      		breq .L708
2162:WTPA.c        **** 			filesystemGood=false;
 9647               		.loc 1 2162 0
 9648 039a 612C      		mov r6,__zero_reg__
 9649               	.LVL388:
 9650               	.L708:
2165:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9651               		.loc 1 2165 0
 9652 039c 8FEF      		ldi r24,lo8(-1)
 9653               	.LVL389:
 9654 039e 0E94 0000 		call TransferSdByte
 9655               	.LVL390:
2166:WTPA.c        **** 		if(theByte!='A')
 9656               		.loc 1 2166 0
 9657 03a2 8134      		cpi r24,lo8(65)
 9658 03a4 01F0      		breq .L709
2168:WTPA.c        **** 			filesystemGood=false;
 9659               		.loc 1 2168 0
 9660 03a6 612C      		mov r6,__zero_reg__
 9661               	.LVL391:
 9662               	.L709:
 9663 03a8 0CE0      		ldi r16,lo8(12)
 9664 03aa 10E0      		ldi r17,0
 9665               	.LVL392:
 9666               	.L710:
2176:WTPA.c        **** 			TransferSdByte(0xFF);
 9667               		.loc 1 2176 0
 9668 03ac 8FEF      		ldi r24,lo8(-1)
 9669 03ae 0E94 0000 		call TransferSdByte
 9670               	.LVL393:
 9671 03b2 0150      		subi r16,1
 9672 03b4 1109      		sbc r17,__zero_reg__
2174:WTPA.c        **** 		for(i=0;i<12;i++)					// 12 don't care bytes
 9673               		.loc 1 2174 0
 9674 03b6 01F4      		brne .L710
2179:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
 9675               		.loc 1 2179 0
 9676 03b8 71E0      		ldi r23,lo8(1)
 9677 03ba 6712      		cpse r6,r23
 9678 03bc 00C0      		rjmp .L768
 9679 03be 00E0      		ldi r16,lo8(sampleToc)
 9680 03c0 10E0      		ldi r17,hi8(sampleToc)
 9681               	.L712:
2183:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
 9682               		.loc 1 2183 0
 9683 03c2 8FEF      		ldi r24,lo8(-1)
 9684 03c4 0E94 0000 		call TransferSdByte
 9685               	.LVL394:
 9686 03c8 F801      		movw r30,r16
 9687 03ca 8193      		st Z+,r24
 9688 03cc 8F01      		movw r16,r30
2181:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
 9689               		.loc 1 2181 0
 9690 03ce F0E0      		ldi r31,hi8(sampleToc+64)
 9691 03d0 0030      		cpi r16,lo8(sampleToc+64)
 9692 03d2 1F07      		cpc r17,r31
 9693 03d4 01F4      		brne .L712
 9694               	.L714:
 9695               	.LVL395:
2179:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
 9696               		.loc 1 2179 0
 9697 03d6 02EB      		ldi r16,lo8(-78)
 9698 03d8 11E0      		ldi r17,lo8(1)
 9699 03da 00C0      		rjmp .L713
 9700               	.LVL396:
 9701               	.L768:
 9702 03dc 00E4      		ldi r16,lo8(64)
 9703 03de 10E0      		ldi r17,0
 9704               	.L711:
2190:WTPA.c        **** 				TransferSdByte(0xFF);
 9705               		.loc 1 2190 0
 9706 03e0 8FEF      		ldi r24,lo8(-1)
 9707 03e2 0E94 0000 		call TransferSdByte
 9708               	.LVL397:
 9709 03e6 0150      		subi r16,1
 9710 03e8 1109      		sbc r17,__zero_reg__
2188:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
 9711               		.loc 1 2188 0
 9712 03ea 01F4      		brne .L711
 9713 03ec 00C0      		rjmp .L714
 9714               	.L713:
2196:WTPA.c        **** 			TransferSdByte(0xFF);
 9715               		.loc 1 2196 0
 9716 03ee 8FEF      		ldi r24,lo8(-1)
 9717 03f0 0E94 0000 		call TransferSdByte
 9718               	.LVL398:
 9719 03f4 0150      		subi r16,1
 9720 03f6 1109      		sbc r17,__zero_reg__
2194:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
 9721               		.loc 1 2194 0
 9722 03f8 01F4      		brne .L713
 9723 03fa 00C0      		rjmp .L806
 9724               	.LVL399:
 9725               	.L764:
2201:WTPA.c        **** 		filesystemGood=false;	// Error issuing read command
 9726               		.loc 1 2201 0
 9727 03fc 612C      		mov r6,__zero_reg__
 9728               	.LVL400:
 9729               	.L806:
2203:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 9730               		.loc 1 2203 0
 9731 03fe 8091 C800 		lds r24,200
 9732 0402 86FF      		sbrs r24,6
 9733 0404 00C0      		rjmp .L806
2206:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
 9734               		.loc 1 2206 0
 9735 0406 0E94 0000 		call EndSdTransfer
 9736               	.LVL401:
2207:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 9737               		.loc 1 2207 0
 9738 040a 8FEF      		ldi r24,lo8(-1)
 9739 040c 0E94 0000 		call TransferSdByte
 9740               	.LVL402:
 9741               	.LBE338:
 9742               	.LBE337:
2397:WTPA.c        **** 					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct file
 9743               		.loc 1 2397 0
 9744 0410 21E0      		ldi r18,lo8(1)
 9745 0412 6212      		cpse r6,r18
 9746 0414 00C0      		rjmp .L716
2399:WTPA.c        **** 						cardState=SD_IDLE;		// Card is legit and ready to go.
 9747               		.loc 1 2399 0
 9748 0416 D092 0000 		sts cardState,r13
 9749               	.LBB339:
 9750               	.LBB340:
2943:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 9751               		.loc 1 2943 0
 9752 041a 8091 6400 		lds r24,100
 9753 041e 8F7B      		andi r24,lo8(-65)
 9754 0420 8093 6400 		sts 100,r24
2945:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 9755               		.loc 1 2945 0
 9756 0424 82E0      		ldi r24,lo8(2)
 9757 0426 8093 B000 		sts 176,r24
2946:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
 9758               		.loc 1 2946 0
 9759 042a 1092 B100 		sts 177,__zero_reg__
2947:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 9760               		.loc 1 2947 0
 9761 042e 1092 B200 		sts 178,__zero_reg__
2948:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 9762               		.loc 1 2948 0
 9763 0432 81E7      		ldi r24,lo8(113)
 9764 0434 8093 B300 		sts 179,r24
2949:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 9765               		.loc 1 2949 0
 9766 0438 C7BA      		out 0x17,r12
2950:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
 9767               		.loc 1 2950 0
 9768 043a 1092 7000 		sts 112,__zero_reg__
2952:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
 9769               		.loc 1 2952 0
 9770 043e 1092 0000 		sts sdIsrState,__zero_reg__
2953:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
 9771               		.loc 1 2953 0
 9772 0442 1092 0000 		sts sdStreamOutput,__zero_reg__
 9773 0446 00C0      		rjmp .L680
 9774               	.L716:
 9775               	.LBE340:
 9776               	.LBE339:
2404:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
 9777               		.loc 1 2404 0
 9778 0448 8FE0      		ldi r24,lo8(15)
 9779 044a 8093 0000 		sts cardState,r24
 9780               	.LVL403:
 9781 044e E0E0      		ldi r30,lo8(sampleToc)
 9782 0450 F0E0      		ldi r31,hi8(sampleToc)
 9783               	.LVL404:
 9784               	.L717:
 9785               	.LBB341:
 9786               	.LBB342:
2061:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 9787               		.loc 1 2061 0
 9788 0452 1192      		st Z+,__zero_reg__
2059:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 9789               		.loc 1 2059 0
 9790 0454 30E0      		ldi r19,hi8(sampleToc+64)
 9791 0456 E030      		cpi r30,lo8(sampleToc+64)
 9792 0458 F307      		cpc r31,r19
 9793 045a 01F4      		brne .L717
 9794               	.LVL405:
 9795               	.LBE342:
 9796               	.LBE341:
 9797               	.LBB343:
 9798               	.LBB344:
1426:WTPA.c        **** 	State=newState;
 9799               		.loc 1 1426 0
 9800 045c 80E0      		ldi r24,lo8(gs(DoFormatCard))
 9801 045e 90E0      		ldi r25,hi8(gs(DoFormatCard))
 9802 0460 9093 0000 		sts State+1,r25
 9803 0464 8093 0000 		sts State,r24
1427:WTPA.c        **** 	subState=SS_0;
 9804               		.loc 1 1427 0
 9805 0468 1092 0000 		sts subState,__zero_reg__
 9806 046c 00C0      		rjmp .L680
 9807               	.LVL406:
 9808               	.L699:
 9809               	.LBE344:
 9810               	.LBE343:
2411:WTPA.c        **** 					cardState=SD_INVALID;
 9811               		.loc 1 2411 0
 9812 046e 8FE0      		ldi r24,lo8(15)
 9813 0470 00C0      		rjmp .L851
 9814               	.L683:
2421:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 9815               		.loc 1 2421 0
 9816 0472 2FB7      		in r18,__SREG__
 9817               	.LVL407:
2422:WTPA.c        **** 			cli();
 9818               		.loc 1 2422 0
 9819               	/* #APP */
 9820               	 ;  2422 "WTPA.c" 1
 9821 0474 F894      		cli
 9822               	 ;  0 "" 2
2423:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 9823               		.loc 1 2423 0
 9824               	/* #NOAPP */
 9825 0476 8091 0000 		lds r24,sdBytesInFifo
 9826 047a 9091 0000 		lds r25,sdBytesInFifo+1
 9827 047e 8115      		cp r24,__zero_reg__
 9828 0480 9240      		sbci r25,2
 9829 0482 00F4      		brsh .L718
 9830 0484 8091 0000 		lds r24,sdBytesInFifo
 9831 0488 9091 0000 		lds r25,sdBytesInFifo+1
 9832 048c 4091 0000 		lds r20,sdCardSampleRemaining
 9833 0490 5091 0000 		lds r21,sdCardSampleRemaining+1
 9834 0494 6091 0000 		lds r22,sdCardSampleRemaining+2
 9835 0498 7091 0000 		lds r23,sdCardSampleRemaining+3
 9836 049c A0E0      		ldi r26,0
 9837 049e B0E0      		ldi r27,0
 9838 04a0 8417      		cp r24,r20
 9839 04a2 9507      		cpc r25,r21
 9840 04a4 A607      		cpc r26,r22
 9841 04a6 B707      		cpc r27,r23
 9842 04a8 00F4      		brsh .+2
 9843 04aa 00C0      		rjmp .L733
 9844               	.L718:
2425:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
 9845               		.loc 1 2425 0
 9846 04ac 2FBF      		out __SREG__,r18
2426:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
 9847               		.loc 1 2426 0
 9848 04ae 6091 0000 		lds r22,sdSampleStartBlock
 9849 04b2 7091 0000 		lds r23,sdSampleStartBlock+1
 9850 04b6 8091 0000 		lds r24,sdSampleStartBlock+2
 9851 04ba 9091 0000 		lds r25,sdSampleStartBlock+3
 9852 04be 0E94 0000 		call SdBeginSingleBlockWrite
 9853               	.LVL408:
 9854 04c2 8130      		cpi r24,lo8(1)
 9855 04c4 01F0      		breq .+2
 9856 04c6 00C0      		rjmp .L679
2428:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 9857               		.loc 1 2428 0
 9858 04c8 D093 0000 		sts bytesLeftInBlock.2007+1,r29
 9859 04cc C093 0000 		sts bytesLeftInBlock.2007,r28
2430:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
 9860               		.loc 1 2430 0
 9861 04d0 8FEF      		ldi r24,lo8(-1)
 9862 04d2 0E94 0000 		call TransferSdByte
 9863               	.LVL409:
2431:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
 9864               		.loc 1 2431 0
 9865 04d6 8FEF      		ldi r24,lo8(-1)
 9866 04d8 0E94 0000 		call TransferSdByte
 9867               	.LVL410:
2432:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
 9868               		.loc 1 2432 0
 9869 04dc 8EEF      		ldi r24,lo8(-2)
 9870 04de 0E94 0000 		call TransferSdByte
 9871               	.LVL411:
2433:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
 9872               		.loc 1 2433 0
 9873 04e2 8091 0000 		lds r24,sdCardSampleRemaining
 9874 04e6 9091 0000 		lds r25,sdCardSampleRemaining+1
 9875 04ea A091 0000 		lds r26,sdCardSampleRemaining+2
 9876 04ee B091 0000 		lds r27,sdCardSampleRemaining+3
 9877 04f2 8B2F      		mov r24,r27
 9878 04f4 0E94 0000 		call TransferSdByte
 9879               	.LVL412:
2434:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
 9880               		.loc 1 2434 0
 9881 04f8 6091 0000 		lds r22,sdCardSampleRemaining
 9882 04fc 7091 0000 		lds r23,sdCardSampleRemaining+1
 9883 0500 8091 0000 		lds r24,sdCardSampleRemaining+2
 9884 0504 9091 0000 		lds r25,sdCardSampleRemaining+3
 9885 0508 0E94 0000 		call TransferSdByte
 9886               	.LVL413:
2435:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
 9887               		.loc 1 2435 0
 9888 050c 8091 0000 		lds r24,sdCardSampleRemaining
 9889 0510 9091 0000 		lds r25,sdCardSampleRemaining+1
 9890 0514 A091 0000 		lds r26,sdCardSampleRemaining+2
 9891 0518 B091 0000 		lds r27,sdCardSampleRemaining+3
 9892 051c 892F      		mov r24,r25
 9893 051e 0E94 0000 		call TransferSdByte
 9894               	.LVL414:
2436:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
 9895               		.loc 1 2436 0
 9896 0522 8091 0000 		lds r24,sdCardSampleRemaining
 9897 0526 9091 0000 		lds r25,sdCardSampleRemaining+1
 9898 052a A091 0000 		lds r26,sdCardSampleRemaining+2
 9899 052e B091 0000 		lds r27,sdCardSampleRemaining+3
 9900 0532 0E94 0000 		call TransferSdByte
 9901               	.LVL415:
2438:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
 9902               		.loc 1 2438 0
 9903 0536 8091 0000 		lds r24,bytesLeftInBlock.2007
 9904 053a 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 9905 053e 0497      		sbiw r24,4
 9906 0540 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 9907 0544 8093 0000 		sts bytesLeftInBlock.2007,r24
 9908 0548 00C0      		rjmp .L852
 9909               	.L844:
 9910 054a 0091 0000 		lds r16,bytesLeftInBlock.2007
 9911 054e 1091 0000 		lds r17,bytesLeftInBlock.2007+1
 9912 0552 0134      		cpi r16,65
 9913 0554 1105      		cpc r17,__zero_reg__
 9914 0556 00F0      		brlo .L720
 9915 0558 00E4      		ldi r16,lo8(64)
 9916 055a 10E0      		ldi r17,0
 9917               	.L720:
 9918               	.LVL416:
2463:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 9919               		.loc 1 2463 0
 9920 055c 612C      		mov r6,__zero_reg__
 9921 055e 00C0      		rjmp .L721
 9922               	.LVL417:
 9923               	.L725:
2465:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
 9924               		.loc 1 2465 0
 9925 0560 8091 0000 		lds r24,sdCardSampleRemaining
 9926 0564 9091 0000 		lds r25,sdCardSampleRemaining+1
 9927 0568 A091 0000 		lds r26,sdCardSampleRemaining+2
 9928 056c B091 0000 		lds r27,sdCardSampleRemaining+3
 9929 0570 892B      		or r24,r25
 9930 0572 8A2B      		or r24,r26
 9931 0574 8B2B      		or r24,r27
 9932 0576 01F0      		breq .L722
2467:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
 9933               		.loc 1 2467 0
 9934 0578 E091 0000 		lds r30,sdFifoReadPointer
 9935 057c F091 0000 		lds r31,sdFifoReadPointer+1
 9936 0580 E050      		subi r30,lo8(-(sdFifo))
 9937 0582 F040      		sbci r31,hi8(-(sdFifo))
 9938 0584 8081      		ld r24,Z
 9939 0586 0E94 0000 		call TransferSdByte
 9940               	.LVL418:
2468:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
 9941               		.loc 1 2468 0
 9942 058a 8091 0000 		lds r24,sdCardSampleRemaining
 9943 058e 9091 0000 		lds r25,sdCardSampleRemaining+1
 9944 0592 A091 0000 		lds r26,sdCardSampleRemaining+2
 9945 0596 B091 0000 		lds r27,sdCardSampleRemaining+3
 9946 059a 0197      		sbiw r24,1
 9947 059c A109      		sbc r26,__zero_reg__
 9948 059e B109      		sbc r27,__zero_reg__
 9949 05a0 8093 0000 		sts sdCardSampleRemaining,r24
 9950 05a4 9093 0000 		sts sdCardSampleRemaining+1,r25
 9951 05a8 A093 0000 		sts sdCardSampleRemaining+2,r26
 9952 05ac B093 0000 		sts sdCardSampleRemaining+3,r27
2470:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
 9953               		.loc 1 2470 0
 9954 05b0 8091 0000 		lds r24,sdFifoReadPointer
 9955 05b4 9091 0000 		lds r25,sdFifoReadPointer+1
 9956 05b8 0196      		adiw r24,1
 9957 05ba 9093 0000 		sts sdFifoReadPointer+1,r25
 9958 05be 8093 0000 		sts sdFifoReadPointer,r24
2472:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 9959               		.loc 1 2472 0
 9960 05c2 8091 0000 		lds r24,sdFifoReadPointer
 9961 05c6 9091 0000 		lds r25,sdFifoReadPointer+1
 9962 05ca 8115      		cp r24,__zero_reg__
 9963 05cc 9340      		sbci r25,3
 9964 05ce 00F0      		brlo .L723
2474:WTPA.c        **** 						sdFifoReadPointer=0;
 9965               		.loc 1 2474 0
 9966 05d0 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 9967 05d4 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 9968               	.L723:
2477:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 9969               		.loc 1 2477 0
 9970 05d8 2FB7      		in r18,__SREG__
 9971               	.LVL419:
2478:WTPA.c        **** 					cli();
 9972               		.loc 1 2478 0
 9973               	/* #APP */
 9974               	 ;  2478 "WTPA.c" 1
 9975 05da F894      		cli
 9976               	 ;  0 "" 2
2479:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
 9977               		.loc 1 2479 0
 9978               	/* #NOAPP */
 9979 05dc 8091 0000 		lds r24,sdBytesInFifo
 9980 05e0 9091 0000 		lds r25,sdBytesInFifo+1
 9981 05e4 0197      		sbiw r24,1
 9982 05e6 9093 0000 		sts sdBytesInFifo+1,r25
 9983 05ea 8093 0000 		sts sdBytesInFifo,r24
2480:WTPA.c        **** 					SREG=sreg;
 9984               		.loc 1 2480 0
 9985 05ee 2FBF      		out __SREG__,r18
 9986 05f0 00C0      		rjmp .L724
 9987               	.LVL420:
 9988               	.L722:
2484:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
 9989               		.loc 1 2484 0
 9990 05f2 8FEF      		ldi r24,lo8(-1)
 9991 05f4 0E94 0000 		call TransferSdByte
 9992               	.LVL421:
 9993               	.L724:
2487:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
 9994               		.loc 1 2487 0
 9995 05f8 8091 0000 		lds r24,bytesLeftInBlock.2007
 9996 05fc 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 9997 0600 0197      		sbiw r24,1
 9998 0602 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 9999 0606 8093 0000 		sts bytesLeftInBlock.2007,r24
2463:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 10000               		.loc 1 2463 0
 10001 060a 6394      		inc r6
 10002               	.LVL422:
 10003               	.L721:
 10004 060c 862D      		mov r24,r6
 10005 060e 90E0      		ldi r25,0
 10006 0610 8017      		cp r24,r16
 10007 0612 9107      		cpc r25,r17
 10008 0614 00F4      		brsh .+2
 10009 0616 00C0      		rjmp .L725
2491:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
 10010               		.loc 1 2491 0
 10011 0618 8091 0000 		lds r24,bytesLeftInBlock.2007
 10012 061c 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10013 0620 892B      		or r24,r25
 10014 0622 01F0      		breq .+2
 10015 0624 00C0      		rjmp .L680
2493:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10016               		.loc 1 2493 0
 10017 0626 8FEF      		ldi r24,lo8(-1)
 10018 0628 0E94 0000 		call TransferSdByte
 10019               	.LVL423:
2494:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10020               		.loc 1 2494 0
 10021 062c 8FEF      		ldi r24,lo8(-1)
 10022 062e 0E94 0000 		call TransferSdByte
 10023               	.LVL424:
2495:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 10024               		.loc 1 2495 0
 10025 0632 8FEF      		ldi r24,lo8(-1)
 10026 0634 0E94 0000 		call TransferSdByte
 10027               	.LVL425:
 10028 0638 8F71      		andi r24,lo8(31)
 10029               	.LVL426:
2497:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 10030               		.loc 1 2497 0
 10031 063a 8530      		cpi r24,lo8(5)
 10032 063c 01F0      		breq .+2
 10033 063e 00C0      		rjmp .L679
2499:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 10034               		.loc 1 2499 0
 10035 0640 62E6      		ldi r22,lo8(98)
 10036 0642 72E0      		ldi r23,lo8(2)
 10037 0644 83E0      		ldi r24,lo8(3)
 10038               	.LVL427:
 10039 0646 0E94 0000 		call SetTimer
 10040               	.LVL428:
2500:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
 10041               		.loc 1 2500 0
 10042 064a 2092 0000 		sts cardState,r2
 10043 064e 00C0      		rjmp .L680
 10044               	.LVL429:
 10045               	.L685:
2510:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
 10046               		.loc 1 2510 0
 10047 0650 83E0      		ldi r24,lo8(3)
 10048 0652 0E94 0000 		call CheckTimer
 10049               	.LVL430:
 10050 0656 8111      		cpse r24,__zero_reg__
 10051 0658 00C0      		rjmp .L679
 10052 065a 14E0      		ldi r17,lo8(4)
 10053               	.L727:
2515:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10054               		.loc 1 2515 0
 10055 065c 8FEF      		ldi r24,lo8(-1)
 10056 065e 0E94 0000 		call TransferSdByte
 10057               	.LVL431:
2516:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 10058               		.loc 1 2516 0
 10059 0662 8F3F      		cpi r24,lo8(-1)
 10060 0664 01F4      		brne .+2
 10061 0666 00C0      		rjmp .L726
 10062               	.LVL432:
 10063 0668 1150      		subi r17,lo8(-(-1))
2513:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 10064               		.loc 1 2513 0
 10065 066a 01F4      		brne .L727
 10066 066c 00C0      		rjmp .L680
 10067               	.L728:
2530:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10068               		.loc 1 2530 0
 10069 066e 8091 C800 		lds r24,200
 10070 0672 86FF      		sbrs r24,6
 10071 0674 00C0      		rjmp .L728
2533:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
 10072               		.loc 1 2533 0
 10073 0676 8091 0000 		lds r24,sdCardSampleRemaining
 10074 067a 9091 0000 		lds r25,sdCardSampleRemaining+1
 10075 067e A091 0000 		lds r26,sdCardSampleRemaining+2
 10076 0682 B091 0000 		lds r27,sdCardSampleRemaining+3
 10077 0686 892B      		or r24,r25
 10078 0688 8A2B      		or r24,r26
 10079 068a 8B2B      		or r24,r27
 10080 068c 01F0      		breq .L729
2535:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
 10081               		.loc 1 2535 0
 10082 068e 85E0      		ldi r24,lo8(5)
 10083 0690 00C0      		rjmp .L851
 10084               	.L729:
2539:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
 10085               		.loc 1 2539 0
 10086 0692 2091 0000 		lds r18,sdCurrentSlot
 10087 0696 3091 0000 		lds r19,sdCurrentSlot+1
 10088               	.LVL433:
 10089               	.LBB345:
 10090               	.LBB346:
2073:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 10091               		.loc 1 2073 0
 10092 069a F901      		movw r30,r18
 10093 069c 43E0      		ldi r20,3
 10094               		1:
 10095 069e F695      		lsr r31
 10096 06a0 E795      		ror r30
 10097 06a2 4A95      		dec r20
 10098 06a4 01F4      		brne 1b
 10099               	.LBE346:
4817:WTPA.c        **** 		HandleLeds();			// Keep LEDs updated.
4818:WTPA.c        **** 		UpdateCard();			// Keep the SD card state machine running.
4819:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
4820:WTPA.c        **** 
4821:WTPA.c        **** //daNextJump=random31;
4822:WTPA.c        **** //daNextJumpPrime=(keyState+systemTicks);
4823:WTPA.c        **** 
4824:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
4825:WTPA.c        **** 		{
4826:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
4827:WTPA.c        **** 		}
4828:WTPA.c        **** 
4829:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
4830:WTPA.c        **** 		{
4831:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
4832:WTPA.c        **** 			{
4833:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
4834:WTPA.c        **** 			}
4835:WTPA.c        **** 		}
4836:WTPA.c        **** 
4837:WTPA.c        **** 		State();				// Execute the current program state.
4838:WTPA.c        **** 	}
4839:WTPA.c        **** 	return(0);
4840:WTPA.c        **** }
 10100               		.loc 1 4840 0
 10101 06a6 FF27      		clr r31
 10102               	.LBB347:
2076:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 10103               		.loc 1 2076 0
 10104 06a8 E050      		subi r30,lo8(-(sampleToc))
 10105 06aa F040      		sbci r31,hi8(-(sampleToc))
 10106 06ac 4081      		ld r20,Z
 10107               	.LBE347:
2074:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 10108               		.loc 1 2074 0
 10109 06ae 2770      		andi r18,7
 10110 06b0 3327      		clr r19
 10111               	.LVL434:
 10112               	.LBB348:
2076:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 10113               		.loc 1 2076 0
 10114 06b2 842F      		mov r24,r20
 10115 06b4 90E0      		ldi r25,0
 10116 06b6 022E      		mov r0,r18
 10117 06b8 00C0      		rjmp 2f
 10118               		1:
 10119 06ba 9595      		asr r25
 10120 06bc 8795      		ror r24
 10121               		2:
 10122 06be 0A94      		dec r0
 10123 06c0 02F4      		brpl 1b
 10124 06c2 80FF      		sbrs r24,0
 10125 06c4 00C0      		rjmp .L847
 10126 06c6 00C0      		rjmp .L730
 10127               	.LVL435:
 10128               	.L686:
 10129               	.LBE348:
 10130               	.LBE345:
2558:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
 10131               		.loc 1 2558 0
 10132 06c8 2FB7      		in r18,__SREG__
 10133               	.LVL436:
2559:WTPA.c        **** 			cli();
 10134               		.loc 1 2559 0
 10135               	/* #APP */
 10136               	 ;  2559 "WTPA.c" 1
 10137 06ca F894      		cli
 10138               	 ;  0 "" 2
2560:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 10139               		.loc 1 2560 0
 10140               	/* #NOAPP */
 10141 06cc 8091 0000 		lds r24,sdBytesInFifo
 10142 06d0 9091 0000 		lds r25,sdBytesInFifo+1
 10143 06d4 8115      		cp r24,__zero_reg__
 10144 06d6 9240      		sbci r25,2
 10145 06d8 00F4      		brsh .L732
 10146 06da 8091 0000 		lds r24,sdBytesInFifo
 10147 06de 9091 0000 		lds r25,sdBytesInFifo+1
 10148 06e2 4091 0000 		lds r20,sdCardSampleRemaining
 10149 06e6 5091 0000 		lds r21,sdCardSampleRemaining+1
 10150 06ea 6091 0000 		lds r22,sdCardSampleRemaining+2
 10151 06ee 7091 0000 		lds r23,sdCardSampleRemaining+3
 10152 06f2 A0E0      		ldi r26,0
 10153 06f4 B0E0      		ldi r27,0
 10154 06f6 8417      		cp r24,r20
 10155 06f8 9507      		cpc r25,r21
 10156 06fa A607      		cpc r26,r22
 10157 06fc B707      		cpc r27,r23
 10158 06fe 00F0      		brlo .L733
 10159               	.L732:
2562:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
 10160               		.loc 1 2562 0
 10161 0700 2FBF      		out __SREG__,r18
2563:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
 10162               		.loc 1 2563 0
 10163 0702 2091 0000 		lds r18,sdCurrentBlockOffset
 10164 0706 3091 0000 		lds r19,sdCurrentBlockOffset+1
 10165               	.LVL437:
 10166 070a 2F5F      		subi r18,-1
 10167 070c 3F4F      		sbci r19,-1
 10168 070e 3093 0000 		sts sdCurrentBlockOffset+1,r19
 10169 0712 2093 0000 		sts sdCurrentBlockOffset,r18
2565:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
 10170               		.loc 1 2565 0
 10171 0716 6091 0000 		lds r22,sdSampleStartBlock
 10172 071a 7091 0000 		lds r23,sdSampleStartBlock+1
 10173 071e 8091 0000 		lds r24,sdSampleStartBlock+2
 10174 0722 9091 0000 		lds r25,sdSampleStartBlock+3
 10175 0726 620F      		add r22,r18
 10176 0728 731F      		adc r23,r19
 10177 072a 811D      		adc r24,__zero_reg__
 10178 072c 911D      		adc r25,__zero_reg__
 10179 072e 0E94 0000 		call SdBeginSingleBlockWrite
 10180               	.LVL438:
 10181 0732 8130      		cpi r24,lo8(1)
 10182 0734 01F0      		breq .+2
 10183 0736 00C0      		rjmp .L679
2567:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 10184               		.loc 1 2567 0
 10185 0738 D093 0000 		sts bytesLeftInBlock.2007+1,r29
 10186 073c C093 0000 		sts bytesLeftInBlock.2007,r28
2569:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
 10187               		.loc 1 2569 0
 10188 0740 8FEF      		ldi r24,lo8(-1)
 10189 0742 0E94 0000 		call TransferSdByte
 10190               	.LVL439:
2570:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
 10191               		.loc 1 2570 0
 10192 0746 8FEF      		ldi r24,lo8(-1)
 10193 0748 0E94 0000 		call TransferSdByte
 10194               	.LVL440:
2571:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
 10195               		.loc 1 2571 0
 10196 074c 8EEF      		ldi r24,lo8(-2)
 10197 074e 0E94 0000 		call TransferSdByte
 10198               	.LVL441:
 10199               	.L852:
2572:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
 10200               		.loc 1 2572 0
 10201 0752 83E0      		ldi r24,lo8(3)
 10202 0754 00C0      		rjmp .L851
 10203               	.LVL442:
 10204               	.L733:
2581:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
 10205               		.loc 1 2581 0
 10206 0756 2FBF      		out __SREG__,r18
 10207 0758 00C0      		rjmp .L680
 10208               	.LVL443:
 10209               	.L687:
2590:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
 10210               		.loc 1 2590 0
 10211 075a 60E0      		ldi r22,0
 10212 075c 70E0      		ldi r23,0
 10213 075e CB01      		movw r24,r22
 10214 0760 0E94 0000 		call SdBeginSingleBlockWrite
 10215               	.LVL444:
 10216 0764 8130      		cpi r24,lo8(1)
 10217 0766 01F0      		breq .+2
 10218 0768 00C0      		rjmp .L679
2592:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 10219               		.loc 1 2592 0
 10220 076a D093 0000 		sts bytesLeftInBlock.2007+1,r29
 10221 076e C093 0000 		sts bytesLeftInBlock.2007,r28
2594:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10222               		.loc 1 2594 0
 10223 0772 8FEF      		ldi r24,lo8(-1)
 10224 0774 0E94 0000 		call TransferSdByte
 10225               	.LVL445:
2595:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
 10226               		.loc 1 2595 0
 10227 0778 8FEF      		ldi r24,lo8(-1)
 10228 077a 0E94 0000 		call TransferSdByte
 10229               	.LVL446:
2596:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
 10230               		.loc 1 2596 0
 10231 077e 8EEF      		ldi r24,lo8(-2)
 10232 0780 0E94 0000 		call TransferSdByte
 10233               	.LVL447:
2597:WTPA.c        **** 				TransferSdByte('W');				// Send flag that this is a WTPA card
 10234               		.loc 1 2597 0
 10235 0784 87E5      		ldi r24,lo8(87)
 10236 0786 0E94 0000 		call TransferSdByte
 10237               	.LVL448:
2598:WTPA.c        **** 				TransferSdByte('T');
 10238               		.loc 1 2598 0
 10239 078a 84E5      		ldi r24,lo8(84)
 10240 078c 0E94 0000 		call TransferSdByte
 10241               	.LVL449:
2599:WTPA.c        **** 				TransferSdByte('P');
 10242               		.loc 1 2599 0
 10243 0790 80E5      		ldi r24,lo8(80)
 10244 0792 0E94 0000 		call TransferSdByte
 10245               	.LVL450:
2600:WTPA.c        **** 				TransferSdByte('A');
 10246               		.loc 1 2600 0
 10247 0796 81E4      		ldi r24,lo8(65)
 10248 0798 0E94 0000 		call TransferSdByte
 10249               	.LVL451:
2602:WTPA.c        **** 				bytesLeftInBlock-=4;
 10250               		.loc 1 2602 0
 10251 079c 8091 0000 		lds r24,bytesLeftInBlock.2007
 10252 07a0 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10253 07a4 0497      		sbiw r24,4
 10254 07a6 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10255 07aa 8093 0000 		sts bytesLeftInBlock.2007,r24
 10256               	.LVL452:
 10257 07ae 1CE0      		ldi r17,lo8(12)
 10258               	.LVL453:
 10259               	.L734:
2606:WTPA.c        **** 					TransferSdByte('x');
 10260               		.loc 1 2606 0
 10261 07b0 88E7      		ldi r24,lo8(120)
 10262 07b2 0E94 0000 		call TransferSdByte
 10263               	.LVL454:
 10264 07b6 1150      		subi r17,lo8(-(-1))
2604:WTPA.c        **** 				for(i=0;i<12;i++)					// 12 don't care bytes
 10265               		.loc 1 2604 0
 10266 07b8 01F4      		brne .L734
2609:WTPA.c        **** 				bytesLeftInBlock-=12;
 10267               		.loc 1 2609 0
 10268 07ba 8091 0000 		lds r24,bytesLeftInBlock.2007
 10269 07be 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10270 07c2 0C97      		sbiw r24,12
 10271 07c4 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10272 07c8 8093 0000 		sts bytesLeftInBlock.2007,r24
 10273               	.LVL455:
 10274 07cc 00E0      		ldi r16,lo8(sampleToc)
 10275 07ce 10E0      		ldi r17,hi8(sampleToc)
 10276               	.LVL456:
 10277               	.L735:
2613:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
 10278               		.loc 1 2613 0
 10279 07d0 F801      		movw r30,r16
 10280 07d2 8191      		ld r24,Z+
 10281 07d4 8F01      		movw r16,r30
 10282 07d6 0E94 0000 		call TransferSdByte
 10283               	.LVL457:
2611:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
 10284               		.loc 1 2611 0
 10285 07da F0E0      		ldi r31,hi8(sampleToc+64)
 10286 07dc 0030      		cpi r16,lo8(sampleToc+64)
 10287 07de 1F07      		cpc r17,r31
 10288 07e0 01F4      		brne .L735
2616:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
 10289               		.loc 1 2616 0
 10290 07e2 8091 0000 		lds r24,bytesLeftInBlock.2007
 10291 07e6 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10292 07ea 8054      		subi r24,64
 10293 07ec 9109      		sbc r25,__zero_reg__
 10294 07ee 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10295 07f2 8093 0000 		sts bytesLeftInBlock.2007,r24
2617:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 10296               		.loc 1 2617 0
 10297 07f6 9092 0000 		sts cardState,r9
 10298 07fa 00C0      		rjmp .L680
 10299               	.L845:
 10300 07fc 0091 0000 		lds r16,bytesLeftInBlock.2007
 10301 0800 1091 0000 		lds r17,bytesLeftInBlock.2007+1
 10302 0804 0134      		cpi r16,65
 10303 0806 1105      		cpc r17,__zero_reg__
 10304 0808 00F0      		brlo .L736
 10305 080a 00E4      		ldi r16,lo8(64)
 10306 080c 10E0      		ldi r17,0
 10307               	.L736:
 10308               	.LVL458:
2635:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10309               		.loc 1 2635 0
 10310 080e 612C      		mov r6,__zero_reg__
 10311 0810 00C0      		rjmp .L737
 10312               	.LVL459:
 10313               	.L738:
2637:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10314               		.loc 1 2637 0
 10315 0812 8FEF      		ldi r24,lo8(-1)
 10316 0814 0E94 0000 		call TransferSdByte
 10317               	.LVL460:
2638:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
 10318               		.loc 1 2638 0
 10319 0818 8091 0000 		lds r24,bytesLeftInBlock.2007
 10320 081c 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10321 0820 0197      		sbiw r24,1
 10322 0822 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10323 0826 8093 0000 		sts bytesLeftInBlock.2007,r24
2635:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10324               		.loc 1 2635 0
 10325 082a 6394      		inc r6
 10326               	.LVL461:
 10327               	.L737:
 10328 082c 862D      		mov r24,r6
 10329 082e 90E0      		ldi r25,0
 10330 0830 8017      		cp r24,r16
 10331 0832 9107      		cpc r25,r17
 10332 0834 00F0      		brlo .L738
2641:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
 10333               		.loc 1 2641 0
 10334 0836 8091 0000 		lds r24,bytesLeftInBlock.2007
 10335 083a 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10336 083e 892B      		or r24,r25
 10337 0840 01F0      		breq .+2
 10338 0842 00C0      		rjmp .L680
2643:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10339               		.loc 1 2643 0
 10340 0844 8FEF      		ldi r24,lo8(-1)
 10341 0846 0E94 0000 		call TransferSdByte
 10342               	.LVL462:
2644:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10343               		.loc 1 2644 0
 10344 084a 8FEF      		ldi r24,lo8(-1)
 10345 084c 0E94 0000 		call TransferSdByte
 10346               	.LVL463:
2645:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 10347               		.loc 1 2645 0
 10348 0850 8FEF      		ldi r24,lo8(-1)
 10349 0852 0E94 0000 		call TransferSdByte
 10350               	.LVL464:
 10351 0856 8F71      		andi r24,lo8(31)
 10352               	.LVL465:
2647:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 10353               		.loc 1 2647 0
 10354 0858 8530      		cpi r24,lo8(5)
 10355 085a 01F0      		breq .+2
 10356 085c 00C0      		rjmp .L679
2649:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 10357               		.loc 1 2649 0
 10358 085e 62E6      		ldi r22,lo8(98)
 10359 0860 72E0      		ldi r23,lo8(2)
 10360 0862 83E0      		ldi r24,lo8(3)
 10361               	.LVL466:
 10362 0864 0E94 0000 		call SetTimer
 10363               	.LVL467:
2650:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
 10364               		.loc 1 2650 0
 10365 0868 88E0      		ldi r24,lo8(8)
 10366 086a 00C0      		rjmp .L851
 10367               	.LVL468:
 10368               	.L689:
2660:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10369               		.loc 1 2660 0
 10370 086c 83E0      		ldi r24,lo8(3)
 10371 086e 0E94 0000 		call CheckTimer
 10372               	.LVL469:
 10373 0872 8111      		cpse r24,__zero_reg__
 10374 0874 00C0      		rjmp .L679
 10375 0876 14E0      		ldi r17,lo8(4)
 10376               	.L740:
2665:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10377               		.loc 1 2665 0
 10378 0878 8FEF      		ldi r24,lo8(-1)
 10379 087a 0E94 0000 		call TransferSdByte
 10380               	.LVL470:
2666:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 10381               		.loc 1 2666 0
 10382 087e 8F3F      		cpi r24,lo8(-1)
 10383 0880 01F4      		brne .+2
 10384 0882 00C0      		rjmp .L739
 10385               	.LVL471:
 10386 0884 1150      		subi r17,lo8(-(-1))
2663:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 10387               		.loc 1 2663 0
 10388 0886 01F4      		brne .L740
 10389 0888 00C0      		rjmp .L680
 10390               	.L741:
2680:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10391               		.loc 1 2680 0
 10392 088a 8091 C800 		lds r24,200
 10393 088e 86FF      		sbrs r24,6
 10394 0890 00C0      		rjmp .L741
 10395 0892 00C0      		rjmp .L730
 10396               	.L690:
2696:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10397               		.loc 1 2696 0
 10398 0894 83E0      		ldi r24,lo8(3)
 10399 0896 0E94 0000 		call CheckTimer
 10400               	.LVL472:
 10401 089a 8111      		cpse r24,__zero_reg__
 10402 089c 00C0      		rjmp .L679
 10403 089e 14E0      		ldi r17,lo8(4)
 10404               	.L743:
2701:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10405               		.loc 1 2701 0
 10406 08a0 8FEF      		ldi r24,lo8(-1)
 10407 08a2 0E94 0000 		call TransferSdByte
 10408               	.LVL473:
2702:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 10409               		.loc 1 2702 0
 10410 08a6 8F3F      		cpi r24,lo8(-1)
 10411 08a8 01F4      		brne .L742
 10412               	.LVL474:
 10413 08aa 1150      		subi r17,lo8(-(-1))
2699:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 10414               		.loc 1 2699 0
 10415 08ac 01F4      		brne .L743
 10416 08ae 00C0      		rjmp .L680
 10417               	.LVL475:
 10418               	.L742:
2712:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 10419               		.loc 1 2712 0
 10420 08b0 8E3F      		cpi r24,lo8(-2)
 10421 08b2 01F0      		breq .+2
 10422 08b4 00C0      		rjmp .L679
2714:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
 10423               		.loc 1 2714 0
 10424 08b6 D093 0000 		sts bytesLeftInBlock.2007+1,r29
 10425 08ba C093 0000 		sts bytesLeftInBlock.2007,r28
2716:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
 10426               		.loc 1 2716 0
 10427 08be 8FEF      		ldi r24,lo8(-1)
 10428               	.LVL476:
 10429 08c0 0E94 0000 		call TransferSdByte
 10430               	.LVL477:
 10431 08c4 90E0      		ldi r25,0
 10432 08c6 A0E0      		ldi r26,0
 10433 08c8 B0E0      		ldi r27,0
 10434 08ca B82F      		mov r27,r24
 10435 08cc AA27      		clr r26
 10436 08ce 9927      		clr r25
 10437 08d0 8827      		clr r24
 10438 08d2 8093 0000 		sts sdCardSampleRemaining,r24
 10439 08d6 9093 0000 		sts sdCardSampleRemaining+1,r25
 10440 08da A093 0000 		sts sdCardSampleRemaining+2,r26
 10441 08de B093 0000 		sts sdCardSampleRemaining+3,r27
2717:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
 10442               		.loc 1 2717 0
 10443 08e2 4090 0000 		lds r4,sdCardSampleRemaining
 10444 08e6 5090 0000 		lds r5,sdCardSampleRemaining+1
 10445 08ea 6090 0000 		lds r6,sdCardSampleRemaining+2
 10446 08ee 7090 0000 		lds r7,sdCardSampleRemaining+3
 10447 08f2 8FEF      		ldi r24,lo8(-1)
 10448 08f4 0E94 0000 		call TransferSdByte
 10449               	.LVL478:
 10450 08f8 B301      		movw r22,r6
 10451 08fa A201      		movw r20,r4
 10452 08fc 682B      		or r22,r24
 10453 08fe 4093 0000 		sts sdCardSampleRemaining,r20
 10454 0902 5093 0000 		sts sdCardSampleRemaining+1,r21
 10455 0906 6093 0000 		sts sdCardSampleRemaining+2,r22
 10456 090a 7093 0000 		sts sdCardSampleRemaining+3,r23
2718:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
 10457               		.loc 1 2718 0
 10458 090e 4090 0000 		lds r4,sdCardSampleRemaining
 10459 0912 5090 0000 		lds r5,sdCardSampleRemaining+1
 10460 0916 6090 0000 		lds r6,sdCardSampleRemaining+2
 10461 091a 7090 0000 		lds r7,sdCardSampleRemaining+3
 10462 091e 8FEF      		ldi r24,lo8(-1)
 10463 0920 0E94 0000 		call TransferSdByte
 10464               	.LVL479:
 10465 0924 B301      		movw r22,r6
 10466 0926 A201      		movw r20,r4
 10467 0928 582B      		or r21,r24
 10468 092a 4093 0000 		sts sdCardSampleRemaining,r20
 10469 092e 5093 0000 		sts sdCardSampleRemaining+1,r21
 10470 0932 6093 0000 		sts sdCardSampleRemaining+2,r22
 10471 0936 7093 0000 		sts sdCardSampleRemaining+3,r23
2719:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
 10472               		.loc 1 2719 0
 10473 093a 4090 0000 		lds r4,sdCardSampleRemaining
 10474 093e 5090 0000 		lds r5,sdCardSampleRemaining+1
 10475 0942 6090 0000 		lds r6,sdCardSampleRemaining+2
 10476 0946 7090 0000 		lds r7,sdCardSampleRemaining+3
 10477 094a 8FEF      		ldi r24,lo8(-1)
 10478 094c 0E94 0000 		call TransferSdByte
 10479               	.LVL480:
 10480 0950 B301      		movw r22,r6
 10481 0952 A201      		movw r20,r4
 10482 0954 482B      		or r20,r24
 10483 0956 4093 0000 		sts sdCardSampleRemaining,r20
 10484 095a 5093 0000 		sts sdCardSampleRemaining+1,r21
 10485 095e 6093 0000 		sts sdCardSampleRemaining+2,r22
 10486 0962 7093 0000 		sts sdCardSampleRemaining+3,r23
2721:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
 10487               		.loc 1 2721 0
 10488 0966 8091 0000 		lds r24,sdCardSampleRemaining
 10489 096a 9091 0000 		lds r25,sdCardSampleRemaining+1
 10490 096e A091 0000 		lds r26,sdCardSampleRemaining+2
 10491 0972 B091 0000 		lds r27,sdCardSampleRemaining+3
 10492 0976 8093 0000 		sts sdRamSampleRemaining,r24
 10493 097a 9093 0000 		sts sdRamSampleRemaining+1,r25
 10494 097e A093 0000 		sts sdRamSampleRemaining+2,r26
 10495 0982 B093 0000 		sts sdRamSampleRemaining+3,r27
2723:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
 10496               		.loc 1 2723 0
 10497 0986 8091 0000 		lds r24,bytesLeftInBlock.2007
 10498 098a 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10499 098e 0497      		sbiw r24,4
 10500 0990 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10501 0994 8093 0000 		sts bytesLeftInBlock.2007,r24
 10502 0998 00C0      		rjmp .L855
 10503               	.L691:
2744:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
 10504               		.loc 1 2744 0
 10505 099a 8091 0000 		lds r24,sdAbortRead
 10506 099e 8130      		cpi r24,lo8(1)
 10507 09a0 01F4      		brne .L744
 10508 09a2 00C0      		rjmp .L850
 10509               	.L744:
 10510 09a4 0091 0000 		lds r16,bytesLeftInBlock.2007
 10511 09a8 1091 0000 		lds r17,bytesLeftInBlock.2007+1
 10512 09ac 0134      		cpi r16,65
 10513 09ae 1105      		cpc r17,__zero_reg__
 10514 09b0 00F0      		brlo .L745
 10515 09b2 00E4      		ldi r16,lo8(64)
 10516 09b4 10E0      		ldi r17,0
 10517               	.L745:
 10518               	.LVL481:
2760:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 10519               		.loc 1 2760 0
 10520 09b6 612C      		mov r6,__zero_reg__
 10521 09b8 00C0      		rjmp .L746
 10522               	.LVL482:
 10523               	.L749:
2762:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
 10524               		.loc 1 2762 0
 10525 09ba 8FEF      		ldi r24,lo8(-1)
 10526 09bc 0E94 0000 		call TransferSdByte
 10527               	.LVL483:
2763:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
 10528               		.loc 1 2763 0
 10529 09c0 2091 0000 		lds r18,bytesLeftInBlock.2007
 10530 09c4 3091 0000 		lds r19,bytesLeftInBlock.2007+1
 10531 09c8 2150      		subi r18,1
 10532 09ca 3109      		sbc r19,__zero_reg__
 10533 09cc 3093 0000 		sts bytesLeftInBlock.2007+1,r19
 10534 09d0 2093 0000 		sts bytesLeftInBlock.2007,r18
2765:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
 10535               		.loc 1 2765 0
 10536 09d4 4091 0000 		lds r20,sdCardSampleRemaining
 10537 09d8 5091 0000 		lds r21,sdCardSampleRemaining+1
 10538 09dc 6091 0000 		lds r22,sdCardSampleRemaining+2
 10539 09e0 7091 0000 		lds r23,sdCardSampleRemaining+3
 10540 09e4 452B      		or r20,r21
 10541 09e6 462B      		or r20,r22
 10542 09e8 472B      		or r20,r23
 10543 09ea 01F0      		breq .L747
2767:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
 10544               		.loc 1 2767 0
 10545 09ec 4091 0000 		lds r20,sdCardSampleRemaining
 10546 09f0 5091 0000 		lds r21,sdCardSampleRemaining+1
 10547 09f4 6091 0000 		lds r22,sdCardSampleRemaining+2
 10548 09f8 7091 0000 		lds r23,sdCardSampleRemaining+3
 10549 09fc 4150      		subi r20,1
 10550 09fe 5109      		sbc r21,__zero_reg__
 10551 0a00 6109      		sbc r22,__zero_reg__
 10552 0a02 7109      		sbc r23,__zero_reg__
 10553 0a04 4093 0000 		sts sdCardSampleRemaining,r20
 10554 0a08 5093 0000 		sts sdCardSampleRemaining+1,r21
 10555 0a0c 6093 0000 		sts sdCardSampleRemaining+2,r22
 10556 0a10 7093 0000 		sts sdCardSampleRemaining+3,r23
2769:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
 10557               		.loc 1 2769 0
 10558 0a14 E091 0000 		lds r30,sdFifoWritePointer
 10559 0a18 F091 0000 		lds r31,sdFifoWritePointer+1
 10560 0a1c E050      		subi r30,lo8(-(sdFifo))
 10561 0a1e F040      		sbci r31,hi8(-(sdFifo))
 10562 0a20 8083      		st Z,r24
2770:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
 10563               		.loc 1 2770 0
 10564 0a22 8091 0000 		lds r24,sdFifoWritePointer
 10565 0a26 9091 0000 		lds r25,sdFifoWritePointer+1
 10566               	.LVL484:
 10567 0a2a 0196      		adiw r24,1
 10568 0a2c 9093 0000 		sts sdFifoWritePointer+1,r25
 10569 0a30 8093 0000 		sts sdFifoWritePointer,r24
2772:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 10570               		.loc 1 2772 0
 10571 0a34 8091 0000 		lds r24,sdFifoWritePointer
 10572 0a38 9091 0000 		lds r25,sdFifoWritePointer+1
 10573 0a3c 8115      		cp r24,__zero_reg__
 10574 0a3e 9340      		sbci r25,3
 10575 0a40 00F0      		brlo .L748
2774:WTPA.c        **** 							sdFifoWritePointer=0;
 10576               		.loc 1 2774 0
 10577 0a42 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 10578 0a46 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 10579               	.L748:
2777:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 10580               		.loc 1 2777 0
 10581 0a4a 2FB7      		in r18,__SREG__
 10582               	.LVL485:
2778:WTPA.c        **** 						cli();
 10583               		.loc 1 2778 0
 10584               	/* #APP */
 10585               	 ;  2778 "WTPA.c" 1
 10586 0a4c F894      		cli
 10587               	 ;  0 "" 2
2779:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
 10588               		.loc 1 2779 0
 10589               	/* #NOAPP */
 10590 0a4e 8091 0000 		lds r24,sdBytesInFifo
 10591 0a52 9091 0000 		lds r25,sdBytesInFifo+1
 10592 0a56 0196      		adiw r24,1
 10593 0a58 9093 0000 		sts sdBytesInFifo+1,r25
 10594 0a5c 8093 0000 		sts sdBytesInFifo,r24
2780:WTPA.c        **** 						SREG=sreg;
 10595               		.loc 1 2780 0
 10596 0a60 2FBF      		out __SREG__,r18
 10597               	.LVL486:
 10598               	.L747:
2760:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 10599               		.loc 1 2760 0
 10600 0a62 6394      		inc r6
 10601               	.LVL487:
 10602               	.L746:
 10603 0a64 862D      		mov r24,r6
 10604 0a66 90E0      		ldi r25,0
 10605 0a68 8017      		cp r24,r16
 10606 0a6a 9107      		cpc r25,r17
 10607 0a6c 00F4      		brsh .+2
 10608 0a6e 00C0      		rjmp .L749
2785:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
 10609               		.loc 1 2785 0
 10610 0a70 8091 0000 		lds r24,bytesLeftInBlock.2007
 10611 0a74 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10612 0a78 892B      		or r24,r25
 10613 0a7a 01F0      		breq .+2
 10614 0a7c 00C0      		rjmp .L680
2787:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10615               		.loc 1 2787 0
 10616 0a7e 8FEF      		ldi r24,lo8(-1)
 10617 0a80 0E94 0000 		call TransferSdByte
 10618               	.LVL488:
2788:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10619               		.loc 1 2788 0
 10620 0a84 8FEF      		ldi r24,lo8(-1)
 10621 0a86 0E94 0000 		call TransferSdByte
 10622               	.LVL489:
 10623               	.L750:
2789:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10624               		.loc 1 2789 0
 10625 0a8a 8091 C800 		lds r24,200
 10626 0a8e 86FF      		sbrs r24,6
 10627 0a90 00C0      		rjmp .L750
2792:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10628               		.loc 1 2792 0
 10629 0a92 0E94 0000 		call EndSdTransfer
 10630               	.LVL490:
2793:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10631               		.loc 1 2793 0
 10632 0a96 8FEF      		ldi r24,lo8(-1)
 10633 0a98 0E94 0000 		call TransferSdByte
 10634               	.LVL491:
2794:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 10635               		.loc 1 2794 0
 10636 0a9c 8092 0000 		sts cardState,r8
2796:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
 10637               		.loc 1 2796 0
 10638 0aa0 8091 0000 		lds r24,sdCardSampleRemaining
 10639 0aa4 9091 0000 		lds r25,sdCardSampleRemaining+1
 10640 0aa8 A091 0000 		lds r26,sdCardSampleRemaining+2
 10641 0aac B091 0000 		lds r27,sdCardSampleRemaining+3
 10642 0ab0 892B      		or r24,r25
 10643 0ab2 8A2B      		or r24,r26
 10644 0ab4 8B2B      		or r24,r27
 10645 0ab6 01F0      		breq .+2
 10646 0ab8 00C0      		rjmp .L680
 10647               	.L805:
2798:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10648               		.loc 1 2798 0
 10649 0aba 8091 C800 		lds r24,200
 10650 0abe 86FF      		sbrs r24,6
 10651 0ac0 00C0      		rjmp .L805
 10652 0ac2 00C0      		rjmp .L730
 10653               	.LVL492:
 10654               	.L692:
2807:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 10655               		.loc 1 2807 0
 10656 0ac4 EFB7      		in r30,__SREG__
 10657               	.LVL493:
2808:WTPA.c        **** 			cli();
 10658               		.loc 1 2808 0
 10659               	/* #APP */
 10660               	 ;  2808 "WTPA.c" 1
 10661 0ac6 F894      		cli
 10662               	 ;  0 "" 2
2810:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
 10663               		.loc 1 2810 0
 10664               	/* #NOAPP */
 10665 0ac8 2091 0000 		lds r18,sdBytesInFifo
 10666 0acc 3091 0000 		lds r19,sdBytesInFifo+1
 10667 0ad0 80E0      		ldi r24,0
 10668 0ad2 93E0      		ldi r25,lo8(3)
 10669 0ad4 AC01      		movw r20,r24
 10670 0ad6 421B      		sub r20,r18
 10671 0ad8 530B      		sbc r21,r19
 10672 0ada 9A01      		movw r18,r20
 10673 0adc 2115      		cp r18,__zero_reg__
 10674 0ade 3240      		sbci r19,2
 10675 0ae0 00F4      		brsh .L752
 10676 0ae2 2091 0000 		lds r18,sdBytesInFifo
 10677 0ae6 3091 0000 		lds r19,sdBytesInFifo+1
 10678 0aea 4091 0000 		lds r20,sdCardSampleRemaining
 10679 0aee 5091 0000 		lds r21,sdCardSampleRemaining+1
 10680 0af2 6091 0000 		lds r22,sdCardSampleRemaining+2
 10681 0af6 7091 0000 		lds r23,sdCardSampleRemaining+3
 10682 0afa 821B      		sub r24,r18
 10683 0afc 930B      		sbc r25,r19
 10684 0afe A0E0      		ldi r26,0
 10685 0b00 B0E0      		ldi r27,0
 10686 0b02 8417      		cp r24,r20
 10687 0b04 9507      		cpc r25,r21
 10688 0b06 A607      		cpc r26,r22
 10689 0b08 B707      		cpc r27,r23
 10690 0b0a 00F0      		brlo .L753
 10691               	.L752:
2812:WTPA.c        **** 				SREG=sreg;				// ISR back on.
 10692               		.loc 1 2812 0
 10693 0b0c EFBF      		out __SREG__,r30
2813:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
 10694               		.loc 1 2813 0
 10695 0b0e 2091 0000 		lds r18,sdCurrentBlockOffset
 10696 0b12 3091 0000 		lds r19,sdCurrentBlockOffset+1
 10697 0b16 2F5F      		subi r18,-1
 10698 0b18 3F4F      		sbci r19,-1
 10699 0b1a 3093 0000 		sts sdCurrentBlockOffset+1,r19
 10700 0b1e 2093 0000 		sts sdCurrentBlockOffset,r18
2815:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
 10701               		.loc 1 2815 0
 10702 0b22 6091 0000 		lds r22,sdSampleStartBlock
 10703 0b26 7091 0000 		lds r23,sdSampleStartBlock+1
 10704 0b2a 8091 0000 		lds r24,sdSampleStartBlock+2
 10705 0b2e 9091 0000 		lds r25,sdSampleStartBlock+3
 10706 0b32 620F      		add r22,r18
 10707 0b34 731F      		adc r23,r19
 10708 0b36 811D      		adc r24,__zero_reg__
 10709 0b38 911D      		adc r25,__zero_reg__
 10710 0b3a 0E94 0000 		call SdBeginSingleBlockRead
 10711               	.LVL494:
 10712 0b3e 8130      		cpi r24,lo8(1)
 10713 0b40 01F0      		breq .+2
 10714 0b42 00C0      		rjmp .L679
2817:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 10715               		.loc 1 2817 0
 10716 0b44 6AE7      		ldi r22,lo8(122)
 10717 0b46 70E0      		ldi r23,0
 10718 0b48 83E0      		ldi r24,lo8(3)
 10719 0b4a 0E94 0000 		call SetTimer
 10720               	.LVL495:
2818:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
 10721               		.loc 1 2818 0
 10722 0b4e 3092 0000 		sts cardState,r3
 10723 0b52 00C0      		rjmp .L680
 10724               	.LVL496:
 10725               	.L753:
2827:WTPA.c        **** 				SREG=sreg;	// ISR back on.
 10726               		.loc 1 2827 0
 10727 0b54 EFBF      		out __SREG__,r30
 10728 0b56 00C0      		rjmp .L680
 10729               	.LVL497:
 10730               	.L693:
2833:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 10731               		.loc 1 2833 0
 10732 0b58 83E0      		ldi r24,lo8(3)
 10733 0b5a 0E94 0000 		call CheckTimer
 10734               	.LVL498:
 10735 0b5e 8111      		cpse r24,__zero_reg__
 10736 0b60 00C0      		rjmp .L679
 10737 0b62 14E0      		ldi r17,lo8(4)
 10738               	.L755:
2838:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10739               		.loc 1 2838 0
 10740 0b64 8FEF      		ldi r24,lo8(-1)
 10741 0b66 0E94 0000 		call TransferSdByte
 10742               	.LVL499:
2839:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 10743               		.loc 1 2839 0
 10744 0b6a 8F3F      		cpi r24,lo8(-1)
 10745 0b6c 01F4      		brne .L754
 10746               	.LVL500:
 10747 0b6e 1150      		subi r17,lo8(-(-1))
2836:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 10748               		.loc 1 2836 0
 10749 0b70 01F4      		brne .L755
 10750 0b72 00C0      		rjmp .L680
 10751               	.LVL501:
 10752               	.L754:
2848:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 10753               		.loc 1 2848 0
 10754 0b74 8E3F      		cpi r24,lo8(-2)
 10755 0b76 01F0      		breq .+2
 10756 0b78 00C0      		rjmp .L679
2850:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
 10757               		.loc 1 2850 0
 10758 0b7a D093 0000 		sts bytesLeftInBlock.2007+1,r29
 10759 0b7e C093 0000 		sts bytesLeftInBlock.2007,r28
 10760               	.LVL502:
 10761               	.L855:
2852:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 10762               		.loc 1 2852 0
 10763 0b82 A092 0000 		sts cardState,r10
2853:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
 10764               		.loc 1 2853 0
 10765 0b86 8091 0000 		lds r24,sdAbortRead
 10766 0b8a 8130      		cpi r24,lo8(1)
 10767 0b8c 01F0      		breq .+2
 10768 0b8e 00C0      		rjmp .L680
 10769               	.L850:
2855:WTPA.c        **** 						cardState=SD_READ_ABORT;
 10770               		.loc 1 2855 0
 10771 0b90 B092 0000 		sts cardState,r11
2856:WTPA.c        **** 						sdAbortRead=false;
 10772               		.loc 1 2856 0
 10773 0b94 1092 0000 		sts sdAbortRead,__zero_reg__
 10774 0b98 00C0      		rjmp .L680
 10775               	.L694:
 10776 0b9a 0091 0000 		lds r16,bytesLeftInBlock.2007
 10777 0b9e 1091 0000 		lds r17,bytesLeftInBlock.2007+1
 10778 0ba2 0134      		cpi r16,65
 10779 0ba4 1105      		cpc r17,__zero_reg__
 10780 0ba6 00F0      		brlo .L756
 10781 0ba8 00E4      		ldi r16,lo8(64)
 10782 0baa 10E0      		ldi r17,0
 10783               	.L756:
 10784               	.LVL503:
2880:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 10785               		.loc 1 2880 0
 10786 0bac 612C      		mov r6,__zero_reg__
 10787 0bae 00C0      		rjmp .L757
 10788               	.LVL504:
 10789               	.L758:
2882:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
 10790               		.loc 1 2882 0
 10791 0bb0 8FEF      		ldi r24,lo8(-1)
 10792 0bb2 0E94 0000 		call TransferSdByte
 10793               	.LVL505:
2883:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
 10794               		.loc 1 2883 0
 10795 0bb6 8091 0000 		lds r24,bytesLeftInBlock.2007
 10796 0bba 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10797 0bbe 0197      		sbiw r24,1
 10798 0bc0 9093 0000 		sts bytesLeftInBlock.2007+1,r25
 10799 0bc4 8093 0000 		sts bytesLeftInBlock.2007,r24
2880:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 10800               		.loc 1 2880 0
 10801 0bc8 6394      		inc r6
 10802               	.LVL506:
 10803               	.L757:
 10804 0bca 862D      		mov r24,r6
 10805 0bcc 90E0      		ldi r25,0
 10806 0bce 8017      		cp r24,r16
 10807 0bd0 9107      		cpc r25,r17
 10808 0bd2 00F0      		brlo .L758
2887:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
 10809               		.loc 1 2887 0
 10810 0bd4 8091 0000 		lds r24,bytesLeftInBlock.2007
 10811 0bd8 9091 0000 		lds r25,bytesLeftInBlock.2007+1
 10812 0bdc 892B      		or r24,r25
 10813 0bde 01F4      		brne .L680
2889:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10814               		.loc 1 2889 0
 10815 0be0 8FEF      		ldi r24,lo8(-1)
 10816 0be2 0E94 0000 		call TransferSdByte
 10817               	.LVL507:
2890:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10818               		.loc 1 2890 0
 10819 0be6 8FEF      		ldi r24,lo8(-1)
 10820 0be8 0E94 0000 		call TransferSdByte
 10821               	.LVL508:
 10822               	.L759:
2891:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10823               		.loc 1 2891 0
 10824 0bec 8091 C800 		lds r24,200
 10825 0bf0 86FF      		sbrs r24,6
 10826 0bf2 00C0      		rjmp .L759
2894:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
 10827               		.loc 1 2894 0
 10828 0bf4 0E94 0000 		call EndSdTransfer
 10829               	.LVL509:
2895:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
 10830               		.loc 1 2895 0
 10831 0bf8 8FEF      		ldi r24,lo8(-1)
 10832 0bfa 0E94 0000 		call TransferSdByte
 10833               	.LVL510:
 10834               	.L760:
2897:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10835               		.loc 1 2897 0
 10836 0bfe 8091 C800 		lds r24,200
 10837 0c02 86FF      		sbrs r24,6
 10838 0c04 00C0      		rjmp .L760
2899:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
 10839               		.loc 1 2899 0
 10840 0c06 D092 0000 		sts cardState,r13
2901:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
 10841               		.loc 1 2901 0
 10842 0c0a 8091 0000 		lds r24,sdPlaybackQueued
 10843 0c0e 8130      		cpi r24,lo8(1)
 10844 0c10 01F4      		brne .L680
2903:WTPA.c        **** 					sdPlaybackQueued=false;
 10845               		.loc 1 2903 0
 10846 0c12 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2905:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
 10847               		.loc 1 2905 0
 10848 0c16 8091 0000 		lds r24,sdQueuedSlot
 10849 0c1a 9091 0000 		lds r25,sdQueuedSlot+1
 10850 0c1e 0E94 0000 		call PlaySampleFromSd
 10851               	.LVL511:
 10852               	.L680:
 10853               	.LBE351:
 10854               	.LBE357:
4819:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
 10855               		.loc 1 4819 0
 10856 0c22 0E94 0000 		call GetRandomLongInt
 10857               	.LVL512:
4824:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
 10858               		.loc 1 4824 0
 10859 0c26 0E94 0000 		call Uart0GotByte
 10860               	.LVL513:
 10861 0c2a 8823      		tst r24
 10862 0c2c 01F0      		breq .L761
4826:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
 10863               		.loc 1 4826 0
 10864 0c2e 0E94 0000 		call Uart0GetByte
 10865               	.LVL514:
 10866 0c32 0E94 0000 		call HandleIncomingMidiByte
 10867               	.LVL515:
 10868               	.L761:
4829:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
 10869               		.loc 1 4829 0
 10870 0c36 0E94 0000 		call MidiTxBufferNotEmpty
 10871               	.LVL516:
 10872 0c3a 8823      		tst r24
 10873 0c3c 01F0      		breq .L762
4831:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
 10874               		.loc 1 4831 0
 10875 0c3e 8091 C000 		lds r24,192
 10876 0c42 85FF      		sbrs r24,5
 10877 0c44 00C0      		rjmp .L762
4833:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
 10878               		.loc 1 4833 0
 10879 0c46 0E94 0000 		call PopOutgoingMidiByte
 10880               	.LVL517:
 10881 0c4a 8093 C600 		sts 198,r24
 10882               	.L762:
4837:WTPA.c        **** 		State();				// Execute the current program state.
 10883               		.loc 1 4837 0
 10884 0c4e E091 0000 		lds r30,State
 10885 0c52 F091 0000 		lds r31,State+1
 10886 0c56 0995      		icall
 10887               	.LVL518:
4838:WTPA.c        **** 	}
 10888               		.loc 1 4838 0
 10889 0c58 00C0      		rjmp .L763
 10890               	.LVL519:
 10891               	.L847:
 10892               	.LBB358:
 10893               	.LBB352:
 10894               	.LBB349:
 10895               	.LBB350:
2096:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 10896               		.loc 1 2096 0
 10897 0c5a B701      		movw r22,r14
 10898 0c5c 00C0      		rjmp 2f
 10899               		1:
 10900 0c5e 660F      		lsl r22
 10901 0c60 771F      		rol r23
 10902               		2:
 10903 0c62 2A95      		dec r18
 10904 0c64 02F4      		brpl 1b
 10905 0c66 9B01      		movw r18,r22
 10906               	.LVL520:
 10907 0c68 242B      		or r18,r20
 10908 0c6a 2083      		st Z,r18
 10909               	.LBE350:
 10910               	.LBE349:
2542:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
 10911               		.loc 1 2542 0
 10912 0c6c 86E0      		ldi r24,lo8(6)
 10913               	.LVL521:
 10914               	.L851:
 10915 0c6e 8093 0000 		sts cardState,r24
 10916 0c72 00C0      		rjmp .L680
 10917               	.L730:
2546:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
 10918               		.loc 1 2546 0
 10919 0c74 D092 0000 		sts cardState,r13
 10920 0c78 00C0      		rjmp .L680
 10921               	.LVL522:
 10922               	.L726:
2528:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10923               		.loc 1 2528 0
 10924 0c7a 0E94 0000 		call EndSdTransfer
 10925               	.LVL523:
2529:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10926               		.loc 1 2529 0
 10927 0c7e 8FEF      		ldi r24,lo8(-1)
 10928 0c80 0E94 0000 		call TransferSdByte
 10929               	.LVL524:
 10930 0c84 00C0      		rjmp .L728
 10931               	.LVL525:
 10932               	.L739:
2678:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10933               		.loc 1 2678 0
 10934 0c86 0E94 0000 		call EndSdTransfer
 10935               	.LVL526:
2679:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10936               		.loc 1 2679 0
 10937 0c8a 8FEF      		ldi r24,lo8(-1)
 10938 0c8c 0E94 0000 		call TransferSdByte
 10939               	.LVL527:
 10940 0c90 00C0      		rjmp .L741
 10941               	.LBE352:
 10942               	.LBE358:
 10943               		.cfi_endproc
 10944               	.LFE73:
 10946               		.comm	UpdateOutput,2,1
 10947               		.local	sdCardSampleRemaining
 10948               		.comm	sdCardSampleRemaining,4,1
 10949               		.local	sdRamSampleRemaining
 10950               		.comm	sdRamSampleRemaining,4,1
 10951               		.local	sdBytesInFifo
 10952               		.comm	sdBytesInFifo,2,1
 10953               		.local	sdFifoWritePointer
 10954               		.comm	sdFifoWritePointer,2,1
 10955               		.local	sdFifoReadPointer
 10956               		.comm	sdFifoReadPointer,2,1
 10957               		.local	sdFifo
 10958               		.comm	sdFifo,768,1
 10959               		.local	adcByte
 10960               		.comm	adcByte,1,1
 10961               		.local	sliceRemaining
 10962               		.comm	sliceRemaining,8,1
 10963               		.local	sliceSize
 10964               		.comm	sliceSize,8,1
 10965               		.local	granularPositionArrayPointer
 10966               		.comm	granularPositionArrayPointer,2,1
 10967               		.local	outOfRam
 10968               		.comm	outOfRam,1,1
 10969               		.comm	State,2,1
 10970               		.local	ledPwm
 10971               		.comm	ledPwm,1,1
 10972               		.local	flipFlop.1807
 10973               		.comm	flipFlop.1807,1,1
 10974               		.local	extIsrOutputBank0
 10975               		.comm	extIsrOutputBank0,1,1
 10976               		.local	sawtooth.1751
 10977               		.comm	sawtooth.1751,1,1
 10978               		.local	granularPositionArray
 10979               		.comm	granularPositionArray,256,1
 10980               		.local	flipFlop.1813
 10981               		.comm	flipFlop.1813,1,1
 10982               		.local	extIsrOutputBank1
 10983               		.comm	extIsrOutputBank1,1,1
 10984               		.local	sawtooth.1763
 10985               		.comm	sawtooth.1763,1,1
 10986               		.local	flipFlop.1821
 10987               		.comm	flipFlop.1821,1,1
 10988               		.local	midiOutputBank0
 10989               		.comm	midiOutputBank0,1,1
 10990               		.data
 10993               	random31:
 10994 0000 EF        		.byte	-17
 10995 0001 BE        		.byte	-66
 10996 0002 00        		.byte	0
 10997 0003 00        		.byte	0
 10998               		.local	lastJitterValue.1820
 10999               		.comm	lastJitterValue.1820,2,1
 11000               		.local	flipFlop.1829
 11001               		.comm	flipFlop.1829,1,1
 11002               		.local	midiOutputBank1
 11003               		.comm	midiOutputBank1,1,1
 11004               		.local	lastJitterValue.1828
 11005               		.comm	lastJitterValue.1828,2,1
 11006               		.local	sdIsrState
 11007               		.comm	sdIsrState,1,1
 11008               		.local	sdRamAddress
 11009               		.comm	sdRamAddress,4,1
 11010               		.local	sdBank0
 11011               		.comm	sdBank0,1,1
 11012               		.local	sdStreamOutput
 11013               		.comm	sdStreamOutput,1,1
 11014               		.local	pwmCount.1841
 11015               		.comm	pwmCount.1841,1,1
 11016               		.local	newKeys
 11017               		.comm	newKeys,1,1
 11018               		.local	keyState
 11019               		.comm	keyState,1,1
 11020               		.local	cardState
 11021               		.comm	cardState,1,1
 11022               		.local	cardDetect
 11023               		.comm	cardDetect,1,1
 11024               		.local	subState
 11025               		.comm	subState,1,1
 11026               		.local	i.2256
 11027               		.comm	i.2256,1,1
 11028               		.local	ledOnOffMask
 11029               		.comm	ledOnOffMask,1,1
 11030               		.local	realtimeOn.2211
 11031               		.comm	realtimeOn.2211,2,1
 11032               		.local	theMidiRecordRate
 11033               		.comm	theMidiRecordRate,4,1
 11034               		.local	currentBank
 11035               		.comm	currentBank,1,1
 11036               		.local	currentMidiMessage.2209
 11037               		.comm	currentMidiMessage.2209,4,1
 11040               	currentNoteOn.2210:
 11041 0004 3C        		.byte	60
 11042 0005 3C        		.byte	60
 11043               		.local	lastDacByte
 11044               		.comm	lastDacByte,1,1
 11045               		.section	.rodata
 11048               	OctaveZeroCompareMatches:
 11049 0000 FFFF      		.word	-1
 11050 0002 A1F1      		.word	-3679
 11051 0004 11E4      		.word	-7151
 11052 0006 44D7      		.word	-10428
 11053 0008 2FCB      		.word	-13521
 11054 000a C8BF      		.word	-16440
 11055 000c 04B5      		.word	-19196
 11056 000e DBAA      		.word	-21797
 11057 0010 44A1      		.word	-24252
 11058 0012 3798      		.word	-26569
 11059 0014 AC8F      		.word	-28756
 11060 0016 9C87      		.word	-30820
 11061               		.local	keysHeld
 11062               		.comm	keysHeld,1,1
 11063               		.local	encoderValue
 11064               		.comm	encoderValue,1,1
 11065               		.local	lastEncoderValue.2198
 11066               		.comm	lastEncoderValue.2198,1,1
 11067               		.local	scaledEncoderValue
 11068               		.comm	scaledEncoderValue,1,1
 11069               		.local	sdCurrentSlot
 11070               		.comm	sdCurrentSlot,2,1
 11071               		.local	sdSampleStartBlock
 11072               		.comm	sdSampleStartBlock,4,1
 11073               		.local	sdCurrentBlockOffset
 11074               		.comm	sdCurrentBlockOffset,2,1
 11075               		.local	sdAbortRead
 11076               		.comm	sdAbortRead,1,1
 11077               		.local	sdQueuedSlot
 11078               		.comm	sdQueuedSlot,2,1
 11079               		.local	sdPlaybackQueued
 11080               		.comm	sdPlaybackQueued,1,1
 11081               		.local	ledBlinkMask
 11082               		.comm	ledBlinkMask,1,1
 11083               		.local	lastShuttleRead.2246
 11084               		.comm	lastShuttleRead.2246,1,1
 11085               		.local	encoderState
 11086               		.comm	encoderState,1,1
 11087               		.local	lastKeyState.1891
 11088               		.comm	lastKeyState.1891,1,1
 11089               		.local	lastEncTime.1900
 11090               		.comm	lastEncTime.1900,2,1
 11091               		.local	lastEncoderState.1899
 11092               		.comm	lastEncoderState.1899,1,1
 11093               		.local	toggle.1877
 11094               		.comm	toggle.1877,1,1
 11095               		.local	lastLedMask.1878
 11096               		.comm	lastLedMask.1878,1,1
 11097               		.local	bytesLeftInBlock.2007
 11098               		.comm	bytesLeftInBlock.2007,2,1
 11099               		.local	sampleToc
 11100               		.comm	sampleToc,64,1
 11101               		.text
 11102               	.Letext0:
 11103               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 11104               		.file 3 "defines.h"
 11105               		.file 4 "globals.h"
 11106               		.file 5 "midi.h"
 11107               		.file 6 "microSD.h"
 11108               		.file 7 "softclock.h"
 11109               		.file 8 "eeprom.h"
 11110               		.file 9 "uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 WTPA.c
     /tmp/cclvTgNo.s:2      *ABS*:0000003e __SP_H__
     /tmp/cclvTgNo.s:3      *ABS*:0000003d __SP_L__
     /tmp/cclvTgNo.s:4      *ABS*:0000003f __SREG__
     /tmp/cclvTgNo.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cclvTgNo.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cclvTgNo.s:11     .text:00000000 UpdateAudioChannel0
     /tmp/cclvTgNo.s:10975  .bss:00000325 sawtooth.1751
     /tmp/cclvTgNo.s:10958  .bss:0000030e adcByte
     /tmp/cclvTgNo.s:10966  .bss:00000321 outOfRam
     /tmp/cclvTgNo.s:10960  .bss:0000030f sliceRemaining
     /tmp/cclvTgNo.s:10962  .bss:00000317 sliceSize
     /tmp/cclvTgNo.s:10964  .bss:0000031f granularPositionArrayPointer
     /tmp/cclvTgNo.s:10977  .bss:00000326 granularPositionArray
     /tmp/cclvTgNo.s:821    .text:0000075c UpdateAudioChannel1
     /tmp/cclvTgNo.s:10983  .bss:00000428 sawtooth.1763
     /tmp/cclvTgNo.s:1657   .text:00000ee0 OutputMultiplyBanks
     /tmp/cclvTgNo.s:10973  .bss:00000324 extIsrOutputBank0
     /tmp/cclvTgNo.s:10987  .bss:0000042a midiOutputBank0
     /tmp/cclvTgNo.s:10981  .bss:00000427 extIsrOutputBank1
     /tmp/cclvTgNo.s:11001  .bss:0000042e midiOutputBank1
     /tmp/cclvTgNo.s:11037  .bss:0000044b lastDacByte
     /tmp/cclvTgNo.s:1761   .text:00000f78 OutputAddBanks
     /tmp/cclvTgNo.s:11011  .bss:00000437 sdStreamOutput
     /tmp/cclvTgNo.s:1834   .text:00000fe4 OutputXorBanks
     /tmp/cclvTgNo.s:1920   .text:0000105e OutputAndBanks
     /tmp/cclvTgNo.s:2006   .text:000010d8 WriteLedLatch
     /tmp/cclvTgNo.s:2041   .text:000010ea SdIsrStartStreamingAudio
     /tmp/cclvTgNo.s:11005  .bss:00000431 sdIsrState
     /tmp/cclvTgNo.s:2085   .text:00001116 GetRandomLongInt
     /tmp/cclvTgNo.s:10993  .data:00000000 random31
     /tmp/cclvTgNo.s:2133   .text:00001168 MakeNewGranularArray
     /tmp/cclvTgNo.s:2470   .text:00001362 UpdateAdjustedSampleAddresses
     /tmp/cclvTgNo.s:3303   .text:00001b6a RevertSampleToUnadjusted
     /tmp/cclvTgNo.s:3358   .text:00001ba4 BlinkLeds
     /tmp/cclvTgNo.s:11080  .bss:0000045c ledBlinkMask
     /tmp/cclvTgNo.s:11027  .bss:0000043f ledOnOffMask
     /tmp/cclvTgNo.s:3424   .text:00001bf8 KillLeds
     /tmp/cclvTgNo.s:3443   .text:00001c04 DoFruitcakeIntro
     /tmp/cclvTgNo.s:11023  .bss:0000043d subState
     /tmp/cclvTgNo.s:11019  .bss:0000043b cardState
     /tmp/cclvTgNo.s:11025  .bss:0000043e i.2256
     /tmp/cclvTgNo.s:10968  .bss:00000322 ledPwm
     /tmp/cclvTgNo.s:4591   .text:000021ba DoStartupSelect
                            *COM*:00000002 State
     /tmp/cclvTgNo.s:3676   .text:00001d6a ResetSdCard
     /tmp/cclvTgNo.s:11098  .bss:00000467 sampleToc
     /tmp/cclvTgNo.s:10954  .bss:0000000c sdFifoReadPointer
     /tmp/cclvTgNo.s:10952  .bss:0000000a sdFifoWritePointer
     /tmp/cclvTgNo.s:10950  .bss:00000008 sdBytesInFifo
     /tmp/cclvTgNo.s:3750   .text:00001dbe SdStartSampleRead
     /tmp/cclvTgNo.s:11070  .bss:00000452 sdSampleStartBlock
     /tmp/cclvTgNo.s:11072  .bss:00000456 sdCurrentBlockOffset
     /tmp/cclvTgNo.s:3856   .text:00001e42 SetSampleClock.part.0
     /tmp/cclvTgNo.s:3883   .text:00001e5a SetSampleClock
     /tmp/cclvTgNo.s:3970   .text:00001ed6 StartPlayback
     /tmp/cclvTgNo.s:4098   .text:00001f6c ContinuePlayback
     /tmp/cclvTgNo.s:4177   .text:00001fbc StartRecording
     /tmp/cclvTgNo.s:4323   .text:00002078 StartOverdub
     /tmp/cclvTgNo.s:4418   .text:000020e4 StartRealtime
     /tmp/cclvTgNo.s:4480   .text:00002120 DoFormatCard
     /tmp/cclvTgNo.s:11017  .bss:0000043a keyState
     /tmp/cclvTgNo.s:11015  .bss:00000439 newKeys
     /tmp/cclvTgNo.s:4781   .text:0000228a DoSawtooth
     /tmp/cclvTgNo.s:4972   .text:00002394 SetMidiChannels
     /tmp/cclvTgNo.s:5138   .text:00002460 DoSampler
     /tmp/cclvTgNo.s:4670   .text:00002206 PlaySampleFromSd
     /tmp/cclvTgNo.s:10948  .bss:00000004 sdRamSampleRemaining
     /tmp/cclvTgNo.s:11074  .bss:00000458 sdAbortRead
     /tmp/cclvTgNo.s:11076  .bss:00000459 sdQueuedSlot
     /tmp/cclvTgNo.s:11078  .bss:0000045b sdPlaybackQueued
                            *COM*:00000002 UpdateOutput
     /tmp/cclvTgNo.s:11062  .bss:0000044d encoderValue
     /tmp/cclvTgNo.s:11082  .bss:0000045d lastShuttleRead.2246
     /tmp/cclvTgNo.s:11029  .bss:00000440 realtimeOn.2211
     /tmp/cclvTgNo.s:11031  .bss:00000442 theMidiRecordRate
     /tmp/cclvTgNo.s:11048  .rodata:00000000 OctaveZeroCompareMatches
     /tmp/cclvTgNo.s:11033  .bss:00000446 currentBank
     /tmp/cclvTgNo.s:11044  .bss:0000044c keysHeld
     /tmp/cclvTgNo.s:11068  .bss:00000450 sdCurrentSlot
                             .bss:00000000 sdCardSampleRemaining
     /tmp/cclvTgNo.s:11009  .bss:00000436 sdBank0
     /tmp/cclvTgNo.s:11007  .bss:00000432 sdRamAddress
     /tmp/cclvTgNo.s:11064  .bss:0000044e lastEncoderValue.2198
     /tmp/cclvTgNo.s:11066  .bss:0000044f scaledEncoderValue
     /tmp/cclvTgNo.s:11035  .bss:00000447 currentMidiMessage.2209
     /tmp/cclvTgNo.s:11040  .data:00000004 currentNoteOn.2210
     /tmp/cclvTgNo.s:7709   .text:0000337e __vector_12
     /tmp/cclvTgNo.s:10971  .bss:00000323 flipFlop.1807
     /tmp/cclvTgNo.s:7837   .text:0000340c __vector_6
     /tmp/cclvTgNo.s:10979  .bss:00000426 flipFlop.1813
     /tmp/cclvTgNo.s:7967   .text:0000349c __vector_13
     /tmp/cclvTgNo.s:10985  .bss:00000429 flipFlop.1821
     /tmp/cclvTgNo.s:10989  .bss:0000042b lastJitterValue.1820
     /tmp/cclvTgNo.s:8173   .text:000035c6 __vector_14
     /tmp/cclvTgNo.s:10999  .bss:0000042d flipFlop.1829
     /tmp/cclvTgNo.s:11003  .bss:0000042f lastJitterValue.1828
     /tmp/cclvTgNo.s:8379   .text:000036f0 __vector_10
     /tmp/cclvTgNo.s:10956  .bss:0000000e sdFifo
     /tmp/cclvTgNo.s:8870   .text:00003ab2 __vector_9
     /tmp/cclvTgNo.s:11013  .bss:00000438 pwmCount.1841
     /tmp/cclvTgNo.s:8927   .text:00003ae8 __vector_default
     /tmp/cclvTgNo.s:8958   .text:00003afc HandleSoftclock
     /tmp/cclvTgNo.s:8992   .text.startup:00000000 main
     /tmp/cclvTgNo.s:11084  .bss:0000045e encoderState
     /tmp/cclvTgNo.s:11021  .bss:0000043c cardDetect
     /tmp/cclvTgNo.s:11086  .bss:0000045f lastKeyState.1891
     /tmp/cclvTgNo.s:11088  .bss:00000460 lastEncTime.1900
     /tmp/cclvTgNo.s:11090  .bss:00000462 lastEncoderState.1899
     /tmp/cclvTgNo.s:11092  .bss:00000463 toggle.1877
     /tmp/cclvTgNo.s:11094  .bss:00000464 lastLedMask.1878
     /tmp/cclvTgNo.s:11096  .bss:00000465 bytesLeftInBlock.2007

UNDEFINED SYMBOLS
bankStates
__muluhisi3
__udivmodsi4
SetTimer
CheckTimer
EndSdTransfer
InitSdInterface
SdBeginSingleBlockRead
EepromRead
midiChannelNumberA
midiChannelNumberB
EepromWrite
__udivmodqi4
PutMidiMessageInOutgoingFifo
midiMessagesInIncomingFifo
GetMidiMessageFromIncomingFifo
__tablejump2__
__umulhisi3
systemTicks
InitMidi
InitUart0
SdHandshake
TransferSdByte
SdBeginSingleBlockWrite
Uart0GotByte
Uart0GetByte
HandleIncomingMidiByte
MidiTxBufferNotEmpty
PopOutgoingMidiByte
__do_copy_data
__do_clear_bss
