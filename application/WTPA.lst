   1               		.file	"WTPA.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	UpdateAudioChannel0:
  12               	.LFB1:
  13               		.file 1 "WTPA.c"
   1:WTPA.c        **** // Where's the Party At?
   2:WTPA.c        **** // VERSION 2 DA EMPIRE STRIKES BLACK
   3:WTPA.c        **** // ==================================
   4:WTPA.c        **** // Todd Michael Bailey
   5:WTPA.c        **** // todd@narrat1ve.com
   6:WTPA.c        **** // Tue Jul  6 19:36:23 EDT 2010
   7:WTPA.c        **** 
   8:WTPA.c        **** #include	"includes.h"
   9:WTPA.c        **** #define		CURRENT_FIRMWARE_VERSION	0x12		// Starts at 0x10 for WTPA2.  0x11, messing around from 201
  10:WTPA.c        **** 
  11:WTPA.c        **** //=============================
  12:WTPA.c        **** // HOLLER-WARE LICENSE:
  13:WTPA.c        **** // Todd Bailey wrote this.  Do whatever you want with this code, but holler at me if you like it, u
  14:WTPA.c        **** // xoxoxo
  15:WTPA.c        **** // bai1ey.tm@gmail.com
  16:WTPA.c        **** //
  17:WTPA.c        **** // Todd Bailey would like to take this opportunity to shout out to:
  18:WTPA.c        **** //
  19:WTPA.c        **** // Todd Squires, who continues to be wholly intolerant of my bad programming habits and whose TB4 O
  20:WTPA.c        **** // Andrew Reitano for the Nintendo sample playback code,
  21:WTPA.c        **** // Olivier Gillet for the code review, some great ISR speed suggestions, harping on me about remova
  22:WTPA.c        **** // Nick Read, Daniel Fishkin, and Charlie Spears for slangin solder and et cet,
  23:WTPA.c        **** // ChaN for the awesome page on SD interfacing,
  24:WTPA.c        **** // Limor Fried and Phil Torrone, for staying on my ass about making kits,
  25:WTPA.c        **** // Glitched, Dan Nigrin, Altitude, Rodrigo, Sealion, and everybody else on the Narrat1ve forum for 
  26:WTPA.c        **** // BMT Toys and everybody there for putting me through the embedded-systems wringer for all those y
  27:WTPA.c        **** // Jim Williams, Paul Horowitz, Winfield Hill, and all the other people who've forgotten more than 
  28:WTPA.c        **** // and most importantly,
  29:WTPA.c        **** // You, the Customer.
  30:WTPA.c        **** //=============================
  31:WTPA.c        **** 
  32:WTPA.c        **** //=============================
  33:WTPA.c        **** // Atmel AVR Atmega644p MCU, 5v operation.
  34:WTPA.c        **** // 20MHz Crystal Oscillator.
  35:WTPA.c        **** // Originally built with:
  36:WTPA.c        **** // AVR-Binutils 2.19,
  37:WTPA.c        **** // AVR-GCC 4.3.2,
  38:WTPA.c        **** // AVR-libc 1.6.4
  39:WTPA.c        **** //==============================
  40:WTPA.c        **** 
  41:WTPA.c        **** /*
  42:WTPA.c        **** Description:
  43:WTPA.c        **** ==============================================================================
  44:WTPA.c        **** Just rock out, you know?
  45:WTPA.c        **** The real description for lots of this sampler is in the manuals.
  46:WTPA.c        **** 
  47:WTPA.c        **** Technical descriptions of just about everything can be found by grepping through the code comments.
  48:WTPA.c        **** It might be worth your time to check out the original WTPA code as well as the WTPA2 code.
  49:WTPA.c        **** 
  50:WTPA.c        **** 
  51:WTPA.c        **** Changelog:
  52:WTPA.c        **** ==============================================================================
  53:WTPA.c        **** ==============================================================================
  54:WTPA.c        **** Made a CHANGELOG file in this directory.  Only valid for WTPA2 changes once releases start.  You'll
  55:WTPA.c        **** 
  56:WTPA.c        **** */
  57:WTPA.c        **** 
  58:WTPA.c        **** // I hate Prototypes:
  59:WTPA.c        **** static void DoFruitcakeIntro(void);
  60:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  61:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  62:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot);
  63:WTPA.c        **** static void InitSdIsr(void);
  64:WTPA.c        **** static void DoSampler(void);
  65:WTPA.c        **** 
  66:WTPA.c        **** //-----------------------------------------------------------------------
  67:WTPA.c        **** //-----------------------------------------------------------------------
  68:WTPA.c        **** // Lists:
  69:WTPA.c        **** //-----------------------------------------------------------------------
  70:WTPA.c        **** //-----------------------------------------------------------------------
  71:WTPA.c        **** 
  72:WTPA.c        **** // Audio ISR States -- these are the different things we can do in the audio related ISR.
  73:WTPA.c        **** //---------------------------------------------------------------------------------------
  74:WTPA.c        **** 
  75:WTPA.c        **** enum
  76:WTPA.c        **** 	{
  77:WTPA.c        **** 		AUDIO_IDLE=0,
  78:WTPA.c        **** 		AUDIO_SAWTOOTH,
  79:WTPA.c        **** 		AUDIO_REALTIME,
  80:WTPA.c        **** 		AUDIO_RECORD,
  81:WTPA.c        **** 		AUDIO_PLAYBACK,
  82:WTPA.c        **** 		AUDIO_OVERDUB,
  83:WTPA.c        **** 		NUM_AUDIO_FUNCTIONS,
  84:WTPA.c        **** 	};
  85:WTPA.c        **** 
  86:WTPA.c        **** 
  87:WTPA.c        **** // LEDs.
  88:WTPA.c        **** //-----------------------------------------------------------------------
  89:WTPA.c        **** enum					// LED enum used for keeping track of our LED masks.
  90:WTPA.c        **** 	{
  91:WTPA.c        **** 		LED_0=0,
  92:WTPA.c        **** 		LED_1,
  93:WTPA.c        **** 		LED_2,
  94:WTPA.c        **** 		LED_3,
  95:WTPA.c        **** 		LED_4,
  96:WTPA.c        **** 		LED_5,
  97:WTPA.c        **** 		LED_6,
  98:WTPA.c        **** 		LED_7,
  99:WTPA.c        **** 		NUM_LEDS,
 100:WTPA.c        **** 	};
 101:WTPA.c        **** 
 102:WTPA.c        **** // WTPA has gotten to the point where each LED pretty much corresponds to an indicator of something
 103:WTPA.c        **** // To reflect this, the masks here arrange LEDs by FUNCTION, to make code easier to read.
 104:WTPA.c        **** 
 105:WTPA.c        **** #define	Om_LED_REC			(1<<LED_0)
 106:WTPA.c        **** #define	Om_LED_ODUB			(1<<LED_1)
 107:WTPA.c        **** #define	Om_LED_PLAY			(1<<LED_2)
 108:WTPA.c        **** #define	Om_LED_OUT_OF_MEM	(1<<LED_3)	// @@@ lose this guy.
 109:WTPA.c        **** #define	Om_LED_BANK			(1<<LED_4)
 110:WTPA.c        **** #define	Om_LED_FX2			(1<<LED_5)
 111:WTPA.c        **** #define	Om_LED_FX1			(1<<LED_6)
 112:WTPA.c        **** #define	Om_LED_FX0			(1<<LED_7)
 113:WTPA.c        **** 
 114:WTPA.c        **** static unsigned char
 115:WTPA.c        **** 	ledOnOffMask,		// What leds are on and off now?
 116:WTPA.c        **** 	ledBlinkMask;		// What leds are blinking right now?
 117:WTPA.c        **** 
 118:WTPA.c        **** static volatile unsigned char
 119:WTPA.c        **** 	ledPwm;				// Used for our benighted intro.
 120:WTPA.c        **** 
 121:WTPA.c        **** //-----------------------------------------------------------------------
 122:WTPA.c        **** //-----------------------------------------------------------------------
 123:WTPA.c        **** // Application Globals:
 124:WTPA.c        **** //-----------------------------------------------------------------------
 125:WTPA.c        **** //-----------------------------------------------------------------------
 126:WTPA.c        **** 
 127:WTPA.c        **** // Keys and switch variables
 128:WTPA.c        **** //-----------------------------------------------------------------------
 129:WTPA.c        **** static unsigned char
 130:WTPA.c        **** 	keyState,
 131:WTPA.c        **** 	newKeys,
 132:WTPA.c        **** 	keysHeld;
 133:WTPA.c        **** 
 134:WTPA.c        **** static bool
 135:WTPA.c        **** 	cardDetect;		// Is SD card physically in the slot?
 136:WTPA.c        **** 
 137:WTPA.c        **** // Application flags and housekeeping.
 138:WTPA.c        **** //-----------------------------------------------------------------------
 139:WTPA.c        **** STATE_FUNC				//  Creates a pointer called State to an instance of STATE_FUNC().
 140:WTPA.c        **** 	*State;
 141:WTPA.c        **** static unsigned char
 142:WTPA.c        **** 	subState;			//  Keeps track of the minor states (sub states) the device can be in.
 143:WTPA.c        **** 
 144:WTPA.c        **** static volatile bool
 145:WTPA.c        **** 	outOfRam;				// Goes true in the ISR if we run out of RAM.
 146:WTPA.c        **** 
 147:WTPA.c        **** static bool
 148:WTPA.c        **** 	newEncoder,				// Has the encoder moved this loop?
 149:WTPA.c        **** 	encoderCw,				// Goes true for one loop if the encoder has turned clockwise or counterclockwise.  
 150:WTPA.c        **** 	encoderCcw;
 151:WTPA.c        **** 
 152:WTPA.c        **** static unsigned char
 153:WTPA.c        **** 	encoderState,			// What the encoder switches look like.
 154:WTPA.c        **** 	encoderValue,			// Incremental ticks on the encoder.
 155:WTPA.c        **** 	scaledEncoderValue;		// The number that we display on the LEDs and use to select different effects
 156:WTPA.c        **** 
 157:WTPA.c        **** // Granular stuff
 158:WTPA.c        **** //-----------------------------------------------------------------------
 159:WTPA.c        **** 
 160:WTPA.c        **** #define	JITTER_VALUE_MAX	127
 161:WTPA.c        **** #define MAX_SLICES			128
 162:WTPA.c        **** 
 163:WTPA.c        **** static unsigned long
 164:WTPA.c        **** //	random31 __attribute__((section(".noinit")));	//32 bit random number, seeded from noinit sram (s
 165:WTPA.c        **** 	random31=0xBEEF;								// No chance to come up zero because we threw out init code.
 166:WTPA.c        **** 
 167:WTPA.c        **** static volatile unsigned char
 168:WTPA.c        **** 	granularPositionArrayPointer[NUM_BANKS];	// Where are we in the array right now?
 169:WTPA.c        **** 
 170:WTPA.c        **** static volatile unsigned long
 171:WTPA.c        **** 	sliceSize[NUM_BANKS],						// How big are our slices of memory?
 172:WTPA.c        **** 	sliceRemaining[NUM_BANKS];					// How far are we into our slice of memory?
 173:WTPA.c        **** 
 174:WTPA.c        **** static unsigned char
 175:WTPA.c        **** 	granularPositionArray[NUM_BANKS][MAX_SLICES];
 176:WTPA.c        **** 
 177:WTPA.c        **** enum	// Flags we use to determine what to set our clock source to when setting up an audio interrup
 178:WTPA.c        **** {
 179:WTPA.c        **** 	CLK_NONE=0,
 180:WTPA.c        **** 	CLK_EXTERNAL,
 181:WTPA.c        **** 	CLK_INTERNAL,
 182:WTPA.c        **** };
 183:WTPA.c        **** 
 184:WTPA.c        **** 
 185:WTPA.c        **** // ADC globals:
 186:WTPA.c        **** //-----------------------------------------------------------------------
 187:WTPA.c        **** static volatile signed char
 188:WTPA.c        **** 	adcByte;			// The current reading from the ADC.
 189:WTPA.c        **** 
 190:WTPA.c        **** // SD Card Globals:
 191:WTPA.c        **** //-----------------------------------------------------------------------
 192:WTPA.c        **** 
 193:WTPA.c        **** #define SD_WARMUP_TIME							(SECOND)		// SPEC is 250mS but why not be safe.
 194:WTPA.c        **** #define	SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER		(64)			// We leave our SD card open while reading bloc
 195:WTPA.c        **** #define	SD_FIFO_SIZE							(SD_BLOCK_LENGTH+(SD_BLOCK_LENGTH/2))	// AVR's RAM fifo for reads and wr
 196:WTPA.c        **** 
 197:WTPA.c        **** static unsigned char
 198:WTPA.c        **** 	cardState;					// Keeps track of what's going on with the SD Card -- reading, writing, not present
 199:WTPA.c        **** static unsigned char
 200:WTPA.c        **** 	sampleToc[64];				// Local RAM copy of the card's table of contents (where the samples are stored)
 201:WTPA.c        **** static volatile signed char
 202:WTPA.c        **** 	sdFifo[SD_FIFO_SIZE];		// Rolling buffer for getting bytes in and out of the SD card with the stat
 203:WTPA.c        **** 
 204:WTPA.c        **** static volatile unsigned int		// FIFO pointers for the SD card read/write buffer.
 205:WTPA.c        **** 	sdFifoReadPointer,
 206:WTPA.c        **** 	sdFifoWritePointer,
 207:WTPA.c        **** 	sdBytesInFifo;
 208:WTPA.c        **** 
 209:WTPA.c        **** // The below are variables used by the SD state machine and functions:
 210:WTPA.c        **** //static unsigned char
 211:WTPA.c        **** //	sdQueuedBank;		// Bank to play pending stream from SD card on
 212:WTPA.c        **** static unsigned int
 213:WTPA.c        **** 	sdQueuedSlot;		// Pending sample to play once the current stream is closed
 214:WTPA.c        **** static bool
 215:WTPA.c        **** 	sdPlaybackQueued,	// Is there a playback we need to immediately start once the current SD abort fi
 216:WTPA.c        **** 	sdAbortRead;		// Should the SD state machine abort a read in progress?
 217:WTPA.c        **** 
 218:WTPA.c        **** static unsigned long
 219:WTPA.c        **** 	sdSampleStartBlock;
 220:WTPA.c        **** static volatile unsigned long
 221:WTPA.c        **** 	sdRamSampleRemaining,		// Decrements as we write/read samples to/from RAM until we're done.
 222:WTPA.c        **** 	sdCardSampleRemaining;		// Decrements as we write/read samples to/from the sd card until we're don
 223:WTPA.c        **** 
 224:WTPA.c        **** static unsigned int
 225:WTPA.c        **** 	sdCurrentSlot,
 226:WTPA.c        **** 	sdCurrentBlockOffset;
 227:WTPA.c        **** 
 228:WTPA.c        **** enum					// All the things the micro sd card state machine can be doing
 229:WTPA.c        **** 	{
 230:WTPA.c        **** 		SD_NOT_PRESENT=0,
 231:WTPA.c        **** 		SD_WARMUP,
 232:WTPA.c        **** 		SD_WRITE_START,
 233:WTPA.c        **** 		SD_WRITING_BLOCK,
 234:WTPA.c        **** 		SD_WRITE_CARD_WAIT,
 235:WTPA.c        **** 		SD_WRITE_FIFO_WAIT,
 236:WTPA.c        **** 		SD_TOC_WRITE_START,
 237:WTPA.c        **** 		SD_TOC_WRITE_CONTINUE,
 238:WTPA.c        **** 		SD_TOC_WRITE_FINISH,
 239:WTPA.c        **** 		SD_READ_START,
 240:WTPA.c        **** 		SD_READING_BLOCK,
 241:WTPA.c        **** 		SD_READ_FIFO_WAIT,
 242:WTPA.c        **** 		SD_READ_TOKEN_WAIT,
 243:WTPA.c        **** 		SD_READ_ABORT,
 244:WTPA.c        **** 		SD_IDLE,
 245:WTPA.c        **** 		SD_INVALID,
 246:WTPA.c        **** 	};
 247:WTPA.c        **** 
 248:WTPA.c        **** // Variables which handle the SD card's ISR.  These generally keep track of the on-chip buffer for 
 249:WTPA.c        **** 
 250:WTPA.c        **** static unsigned char
 251:WTPA.c        **** 	sdIsrState;					// Keeps track of what the IRQ that deals with data coming off / going to the SD c
 252:WTPA.c        **** static unsigned long
 253:WTPA.c        **** 	sdRamAddress;				// Used to point to the spot in RAM where the data from the sd card is coming or 
 254:WTPA.c        **** static bool
 255:WTPA.c        **** 	sdBank0;					// Tells us whether the SD buffer is messing with the RAM in sample bank 0 or 1.
 256:WTPA.c        **** 
 257:WTPA.c        **** enum					// All the things the micro sd card's interrupt can be doing
 258:WTPA.c        **** 	{
 259:WTPA.c        **** 		SD_ISR_IDLE=0,
 260:WTPA.c        **** 		SD_ISR_LOADING_RAM,
 261:WTPA.c        **** 		SD_ISR_READING_RAM,
 262:WTPA.c        **** 		SD_ISR_STREAMING_PLAYBACK,
 263:WTPA.c        **** 	};
 264:WTPA.c        **** 
 265:WTPA.c        **** //-----------------------------------------------------------------------
 266:WTPA.c        **** 
 267:WTPA.c        **** 
 268:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 269:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 270:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 271:WTPA.c        **** // Da Code:
 272:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 273:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 274:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 275:WTPA.c        **** 
 276:WTPA.c        **** //-----------------------------------------------------------------------
 277:WTPA.c        **** //-----------------------------------------------------------------------
 278:WTPA.c        **** 
 279:WTPA.c        **** // Sun Sep 19 13:38:34 EDT 2010
 280:WTPA.c        **** // Audio Channel Update Code for each bank:
 281:WTPA.c        **** 
 282:WTPA.c        **** //-----------------------------------------------------------------------
 283:WTPA.c        **** //-----------------------------------------------------------------------
 284:WTPA.c        **** // This is where all the audio business happens in this program.
 285:WTPA.c        **** // Variables messed with in the ISRs AND mainline code should be declared volatile.
 286:WTPA.c        **** // The functions declared up here should _ONLY_ ever be called from an interrupt.
 287:WTPA.c        **** 
 288:WTPA.c        **** static unsigned char UpdateAudioChannel0(void)
 289:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 290:WTPA.c        **** // These channel update routines basically handle getting data into or out of RAM based on what the
 291:WTPA.c        **** // Each channel may write something to RAM, and will pass out a byte based on what (if anything) it
 292:WTPA.c        **** {
  14               		.loc 1 292 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
 293:WTPA.c        **** 	signed int
 294:WTPA.c        **** 		sum;			// For doing saturated adds.
 295:WTPA.c        **** 	signed char
 296:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 297:WTPA.c        **** 	static unsigned char
 298:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 299:WTPA.c        **** 
 300:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 301:WTPA.c        **** 
 302:WTPA.c        **** 	switch(bankStates[BANK_0].audioFunction)
  21               		.loc 1 302 0
  22 0000 8091 0000 		lds r24,bankStates
  23 0004 8330      		cpi r24,lo8(3)
  24 0006 01F0      		breq .L5
  25 0008 00F4      		brsh .L8
  26 000a 8130      		cpi r24,lo8(1)
  27 000c 01F0      		breq .L3
  28 000e 8230      		cpi r24,lo8(2)
  29 0010 01F0      		breq .+2
  30 0012 00C0      		rjmp .L35
  31 0014 00C0      		rjmp .L4
  32               	.L8:
  33 0016 8430      		cpi r24,lo8(4)
  34 0018 01F4      		brne .+2
  35 001a 00C0      		rjmp .L6
  36 001c 8530      		cpi r24,lo8(5)
  37 001e 01F0      		breq .+2
  38 0020 00C0      		rjmp .L35
  39 0022 00C0      		rjmp .L7
  40               	.L3:
 303:WTPA.c        **** 	{
 304:WTPA.c        **** 
 305:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 306:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 307:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
  41               		.loc 1 307 0
  42 0024 8091 0000 		lds r24,sawtooth.1757
  43               	.LVL1:
  44 0028 982F      		mov r25,r24
  45 002a 9F5F      		subi r25,lo8(-(1))
  46 002c 9093 0000 		sts sawtooth.1757,r25
 308:WTPA.c        **** 		break;
  47               		.loc 1 308 0
  48 0030 0895      		ret
  49               	.LVL2:
  50               	.L4:
 309:WTPA.c        **** 
 310:WTPA.c        **** 		case AUDIO_REALTIME:
 311:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 312:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
  51               		.loc 1 312 0
  52 0032 8091 0000 		lds r24,adcByte
  53               	.LVL3:
  54 0036 00C0      		rjmp .L51
  55               	.LVL4:
  56               	.L5:
 313:WTPA.c        **** 
 314:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 315:WTPA.c        **** 		{
 316:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 317:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 318:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 319:WTPA.c        **** 		}
 320:WTPA.c        **** 		break;
 321:WTPA.c        **** 
 322:WTPA.c        **** 		case AUDIO_RECORD:
 323:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 324:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
  57               		.loc 1 324 0
  58 0038 8FEF      		ldi r24,lo8(-1)
  59 003a 84B9      		out 0x4,r24
 325:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
  60               		.loc 1 325 0
  61 003c 8091 0000 		lds r24,bankStates+32
  62 0040 9091 0000 		lds r25,bankStates+32+1
  63 0044 A091 0000 		lds r26,bankStates+32+2
  64 0048 B091 0000 		lds r27,bankStates+32+3
  65 004c 85B9      		out 0x5,r24
 326:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
  66               		.loc 1 326 0
  67 004e 139A      		sbi 0x2,3
 327:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
  68               		.loc 1 327 0
  69 0050 1398      		cbi 0x2,3
 328:WTPA.c        **** 
 329:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
  70               		.loc 1 329 0
  71 0052 8091 0000 		lds r24,bankStates+32
  72 0056 9091 0000 		lds r25,bankStates+32+1
  73 005a A091 0000 		lds r26,bankStates+32+2
  74 005e B091 0000 		lds r27,bankStates+32+3
  75 0062 892F      		mov r24,r25
  76 0064 9A2F      		mov r25,r26
  77 0066 AB2F      		mov r26,r27
  78 0068 BB27      		clr r27
  79 006a 85B9      		out 0x5,r24
 330:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
  80               		.loc 1 330 0
  81 006c 149A      		sbi 0x2,4
 331:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
  82               		.loc 1 331 0
  83 006e 1498      		cbi 0x2,4
 332:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
  84               		.loc 1 332 0
  85 0070 8091 0000 		lds r24,bankStates+32
  86 0074 9091 0000 		lds r25,bankStates+32+1
  87 0078 A091 0000 		lds r26,bankStates+32+2
  88 007c B091 0000 		lds r27,bankStates+32+3
  89 0080 CD01      		movw r24,r26
  90 0082 AA27      		clr r26
  91 0084 BB27      		clr r27
  92 0086 8770      		andi r24,7
  93 0088 9927      		clr r25
  94 008a AA27      		clr r26
  95 008c BB27      		clr r27
  96 008e 8868      		ori r24,136
  97 0090 88B9      		out 0x8,r24
 333:WTPA.c        **** 
 334:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
  98               		.loc 1 334 0
  99 0092 8091 0000 		lds r24,adcByte
 100 0096 85B9      		out 0x5,r24
 335:WTPA.c        **** 		// Compute address while bus settles.
 336:WTPA.c        **** 
 337:WTPA.c        **** 		bankStates[BANK_0].currentAddress++;										// Next address please.
 101               		.loc 1 337 0
 102 0098 8091 0000 		lds r24,bankStates+32
 103 009c 9091 0000 		lds r25,bankStates+32+1
 104 00a0 A091 0000 		lds r26,bankStates+32+2
 105 00a4 B091 0000 		lds r27,bankStates+32+3
 106 00a8 0196      		adiw r24,1
 107 00aa A11D      		adc r26,__zero_reg__
 108 00ac B11D      		adc r27,__zero_reg__
 109 00ae 8093 0000 		sts bankStates+32,r24
 110 00b2 9093 0000 		sts bankStates+32+1,r25
 111 00b6 A093 0000 		sts bankStates+32+2,r26
 112 00ba B093 0000 		sts bankStates+32+3,r27
 338:WTPA.c        **** 		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the
 113               		.loc 1 338 0
 114 00be 8091 0000 		lds r24,bankStates+32
 115 00c2 9091 0000 		lds r25,bankStates+32+1
 116 00c6 A091 0000 		lds r26,bankStates+32+2
 117 00ca B091 0000 		lds r27,bankStates+32+3
 118 00ce 8093 0000 		sts bankStates+13,r24
 119 00d2 9093 0000 		sts bankStates+13+1,r25
 120 00d6 A093 0000 		sts bankStates+13+2,r26
 121 00da B093 0000 		sts bankStates+13+3,r27
 339:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address 
 122               		.loc 1 339 0
 123 00de 8091 0000 		lds r24,bankStates+32
 124 00e2 9091 0000 		lds r25,bankStates+32+1
 125 00e6 A091 0000 		lds r26,bankStates+32+2
 126 00ea B091 0000 		lds r27,bankStates+32+3
 127 00ee 8093 0000 		sts bankStates+21,r24
 128 00f2 9093 0000 		sts bankStates+21+1,r25
 129 00f6 A093 0000 		sts bankStates+21+2,r26
 130 00fa B093 0000 		sts bankStates+21+3,r27
 340:WTPA.c        **** 
 341:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 131               		.loc 1 341 0
 132 00fe 4091 0000 		lds r20,bankStates+13
 133 0102 5091 0000 		lds r21,bankStates+13+1
 134 0106 6091 0000 		lds r22,bankStates+13+2
 135 010a 7091 0000 		lds r23,bankStates+13+3
 136 010e 8091 0000 		lds r24,bankStates+49
 137 0112 9091 0000 		lds r25,bankStates+49+1
 138 0116 A091 0000 		lds r26,bankStates+49+2
 139 011a B091 0000 		lds r27,bankStates+49+3
 140 011e 4817      		cp r20,r24
 141 0120 5907      		cpc r21,r25
 142 0122 6A07      		cpc r22,r26
 143 0124 7B07      		cpc r23,r27
 144 0126 00F0      		brlo .L9
 342:WTPA.c        **** 		{
 343:WTPA.c        **** 			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 145               		.loc 1 343 0
 146 0128 1092 0000 		sts bankStates,__zero_reg__
 344:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 147               		.loc 1 344 0
 148 012c 81E0      		ldi r24,lo8(1)
 149 012e 8093 0000 		sts outOfRam,r24
 150               	.L9:
 345:WTPA.c        **** 		}
 346:WTPA.c        **** 
 347:WTPA.c        **** 		// Finish writing to RAM.
 348:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 151               		.loc 1 348 0
 152 0132 1198      		cbi 0x2,1
 349:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 153               		.loc 1 349 0
 154 0134 119A      		sbi 0x2,1
 155 0136 00C0      		rjmp .L35
 156               	.L6:
 350:WTPA.c        **** 		break;
 351:WTPA.c        **** 
 352:WTPA.c        **** 		case AUDIO_PLAYBACK:
 353:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 354:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 355:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 356:WTPA.c        **** 
 357:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 358:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 157               		.loc 1 358 0
 158 0138 8091 0000 		lds r24,bankStates+32
 159 013c 9091 0000 		lds r25,bankStates+32+1
 160 0140 A091 0000 		lds r26,bankStates+32+2
 161 0144 B091 0000 		lds r27,bankStates+32+3
 162 0148 85B9      		out 0x5,r24
 359:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 163               		.loc 1 359 0
 164 014a 139A      		sbi 0x2,3
 360:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 165               		.loc 1 360 0
 166 014c 1398      		cbi 0x2,3
 361:WTPA.c        **** 
 362:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 167               		.loc 1 362 0
 168 014e 8091 0000 		lds r24,bankStates+32
 169 0152 9091 0000 		lds r25,bankStates+32+1
 170 0156 A091 0000 		lds r26,bankStates+32+2
 171 015a B091 0000 		lds r27,bankStates+32+3
 172 015e 892F      		mov r24,r25
 173 0160 9A2F      		mov r25,r26
 174 0162 AB2F      		mov r26,r27
 175 0164 BB27      		clr r27
 176 0166 85B9      		out 0x5,r24
 363:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 177               		.loc 1 363 0
 178 0168 149A      		sbi 0x2,4
 364:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 179               		.loc 1 364 0
 180 016a 1498      		cbi 0x2,4
 365:WTPA.c        **** 
 366:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 181               		.loc 1 366 0
 182 016c 8091 0000 		lds r24,bankStates+32
 183 0170 9091 0000 		lds r25,bankStates+32+1
 184 0174 A091 0000 		lds r26,bankStates+32+2
 185 0178 B091 0000 		lds r27,bankStates+32+3
 186 017c CD01      		movw r24,r26
 187 017e AA27      		clr r26
 188 0180 BB27      		clr r27
 189 0182 8770      		andi r24,7
 190 0184 9927      		clr r25
 191 0186 AA27      		clr r26
 192 0188 BB27      		clr r27
 193 018a 8868      		ori r24,136
 194 018c 88B9      		out 0x8,r24
 367:WTPA.c        **** 
 368:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 195               		.loc 1 368 0
 196 018e 14B8      		out 0x4,__zero_reg__
 369:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 197               		.loc 1 369 0
 198 0190 1298      		cbi 0x2,2
 370:WTPA.c        **** 
 371:WTPA.c        **** 		// Calculate new addy while data bus settles
 372:WTPA.c        **** 
 373:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 199               		.loc 1 373 0
 200 0192 8091 0000 		lds r24,bankStates+7
 201 0196 8823      		tst r24
 202 0198 01F4      		brne .+2
 203 019a 00C0      		rjmp .L10
 374:WTPA.c        **** 		{
 375:WTPA.c        **** 			// Slice first, only worry about forward ###
 376:WTPA.c        **** 
 377:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 204               		.loc 1 377 0
 205 019c 8091 0000 		lds r24,sliceRemaining
 206 01a0 9091 0000 		lds r25,sliceRemaining+1
 207 01a4 A091 0000 		lds r26,sliceRemaining+2
 208 01a8 B091 0000 		lds r27,sliceRemaining+3
 209 01ac 892B      		or r24,r25
 210 01ae 8A2B      		or r24,r26
 211 01b0 8B2B      		or r24,r27
 212 01b2 01F0      		breq .L11
 378:WTPA.c        **** 			{
 379:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 213               		.loc 1 379 0
 214 01b4 8091 0000 		lds r24,bankStates+32
 215 01b8 9091 0000 		lds r25,bankStates+32+1
 216 01bc A091 0000 		lds r26,bankStates+32+2
 217 01c0 B091 0000 		lds r27,bankStates+32+3
 218 01c4 0196      		adiw r24,1
 219 01c6 A11D      		adc r26,__zero_reg__
 220 01c8 B11D      		adc r27,__zero_reg__
 221 01ca 8093 0000 		sts bankStates+32,r24
 222 01ce 9093 0000 		sts bankStates+32+1,r25
 223 01d2 A093 0000 		sts bankStates+32+2,r26
 224 01d6 B093 0000 		sts bankStates+32+3,r27
 380:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 225               		.loc 1 380 0
 226 01da 8091 0000 		lds r24,sliceRemaining
 227 01de 9091 0000 		lds r25,sliceRemaining+1
 228 01e2 A091 0000 		lds r26,sliceRemaining+2
 229 01e6 B091 0000 		lds r27,sliceRemaining+3
 230 01ea 0197      		sbiw r24,1
 231 01ec A109      		sbc r26,__zero_reg__
 232 01ee B109      		sbc r27,__zero_reg__
 233 01f0 8093 0000 		sts sliceRemaining,r24
 234 01f4 9093 0000 		sts sliceRemaining+1,r25
 235 01f8 A093 0000 		sts sliceRemaining+2,r26
 236 01fc B093 0000 		sts sliceRemaining+3,r27
 237 0200 00C0      		rjmp .L12
 238               	.L11:
 381:WTPA.c        **** 			}
 382:WTPA.c        **** 			else	// Slice done, jump to new slice.
 383:WTPA.c        **** 			{
 384:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 239               		.loc 1 384 0
 240 0202 8091 0000 		lds r24,sliceSize
 241 0206 9091 0000 		lds r25,sliceSize+1
 242 020a A091 0000 		lds r26,sliceSize+2
 243 020e B091 0000 		lds r27,sliceSize+3
 244 0212 8093 0000 		sts sliceRemaining,r24
 245 0216 9093 0000 		sts sliceRemaining+1,r25
 246 021a A093 0000 		sts sliceRemaining+2,r26
 247 021e B093 0000 		sts sliceRemaining+3,r27
 385:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 248               		.loc 1 385 0
 249 0222 8091 0000 		lds r24,granularPositionArrayPointer
 250 0226 8F5F      		subi r24,lo8(-(1))
 251 0228 8093 0000 		sts granularPositionArrayPointer,r24
 386:WTPA.c        **** 
 387:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 252               		.loc 1 387 0
 253 022c 9091 0000 		lds r25,granularPositionArrayPointer
 254 0230 8091 0000 		lds r24,bankStates+7
 255 0234 9813      		cpse r25,r24
 256 0236 00C0      		rjmp .L13
 388:WTPA.c        **** 				{
 389:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 257               		.loc 1 389 0
 258 0238 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 259               	.L13:
 390:WTPA.c        **** 				}
 391:WTPA.c        **** 
 392:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 260               		.loc 1 392 0
 261 023c E091 0000 		lds r30,granularPositionArrayPointer
 262 0240 2091 0000 		lds r18,sliceSize
 263 0244 3091 0000 		lds r19,sliceSize+1
 264 0248 4091 0000 		lds r20,sliceSize+2
 265 024c 5091 0000 		lds r21,sliceSize+3
 266 0250 F0E0      		ldi r31,0
 267 0252 E050      		subi r30,lo8(-(granularPositionArray))
 268 0254 F040      		sbci r31,hi8(-(granularPositionArray))
 269 0256 A081      		ld r26,Z
 270 0258 B0E0      		ldi r27,0
 271 025a 0E94 0000 		call __muluhisi3
 272 025e 6093 0000 		sts bankStates+32,r22
 273 0262 7093 0000 		sts bankStates+32+1,r23
 274 0266 8093 0000 		sts bankStates+32+2,r24
 275 026a 9093 0000 		sts bankStates+32+3,r25
 276 026e 00C0      		rjmp .L12
 277               	.L10:
 393:WTPA.c        **** 			}
 394:WTPA.c        **** 		}
 395:WTPA.c        **** 		else
 396:WTPA.c        **** 		{
 397:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 278               		.loc 1 397 0
 279 0270 8091 0000 		lds r24,bankStates+4
 398:WTPA.c        **** 			{
 399:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 280               		.loc 1 399 0
 281 0274 4091 0000 		lds r20,bankStates+32
 282 0278 5091 0000 		lds r21,bankStates+32+1
 283 027c 6091 0000 		lds r22,bankStates+32+2
 284 0280 7091 0000 		lds r23,bankStates+32+3
 397:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 285               		.loc 1 397 0
 286 0284 8111      		cpse r24,__zero_reg__
 287 0286 00C0      		rjmp .L14
 288               		.loc 1 399 0
 289 0288 8091 0000 		lds r24,bankStates+25
 290 028c 9091 0000 		lds r25,bankStates+25+1
 291 0290 A091 0000 		lds r26,bankStates+25+2
 292 0294 B091 0000 		lds r27,bankStates+25+3
 293 0298 4817      		cp r20,r24
 294 029a 5907      		cpc r21,r25
 295 029c 6A07      		cpc r22,r26
 296 029e 7B07      		cpc r23,r27
 297 02a0 01F4      		brne .L15
 298               		.loc 1 399 0 is_stmt 0 discriminator 1
 299 02a2 8091 0000 		lds r24,bankStates+1
 300 02a6 8130      		cpi r24,lo8(1)
 301 02a8 01F4      		brne .L15
 302 02aa 00C0      		rjmp .L45
 303               	.L15:
 400:WTPA.c        **** 				{
 401:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 402:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 403:WTPA.c        **** 				}
 404:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 304               		.loc 1 404 0 is_stmt 1
 305 02ac 4091 0000 		lds r20,bankStates+32
 306 02b0 5091 0000 		lds r21,bankStates+32+1
 307 02b4 6091 0000 		lds r22,bankStates+32+2
 308 02b8 7091 0000 		lds r23,bankStates+32+3
 309 02bc 8091 0000 		lds r24,bankStates+25
 310 02c0 9091 0000 		lds r25,bankStates+25+1
 311 02c4 A091 0000 		lds r26,bankStates+25+2
 312 02c8 B091 0000 		lds r27,bankStates+25+3
 313 02cc 4817      		cp r20,r24
 314 02ce 5907      		cpc r21,r25
 315 02d0 6A07      		cpc r22,r26
 316 02d2 7B07      		cpc r23,r27
 317 02d4 01F4      		brne .L16
 405:WTPA.c        **** 				{
 406:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 318               		.loc 1 406 0
 319 02d6 8091 0000 		lds r24,bankStates+21
 320 02da 9091 0000 		lds r25,bankStates+21+1
 321 02de A091 0000 		lds r26,bankStates+21+2
 322 02e2 B091 0000 		lds r27,bankStates+21+3
 323 02e6 00C0      		rjmp .L46
 324               	.L16:
 407:WTPA.c        **** 				}
 408:WTPA.c        **** 				else
 409:WTPA.c        **** 				{
 410:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 325               		.loc 1 410 0
 326 02e8 4091 0000 		lds r20,bankStates+32
 327 02ec 5091 0000 		lds r21,bankStates+32+1
 328 02f0 6091 0000 		lds r22,bankStates+32+2
 329 02f4 7091 0000 		lds r23,bankStates+32+3
 330 02f8 8091 0000 		lds r24,bankStates+17
 331 02fc 9091 0000 		lds r25,bankStates+17+1
 332 0300 A091 0000 		lds r26,bankStates+17+2
 333 0304 B091 0000 		lds r27,bankStates+17+3
 334 0308 4817      		cp r20,r24
 335 030a 5907      		cpc r21,r25
 336 030c 6A07      		cpc r22,r26
 337 030e 7B07      		cpc r23,r27
 338 0310 01F4      		brne .L17
 411:WTPA.c        **** 					{
 412:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 339               		.loc 1 412 0
 340 0312 8091 0000 		lds r24,bankStates+13
 341 0316 9091 0000 		lds r25,bankStates+13+1
 342 031a A091 0000 		lds r26,bankStates+13+2
 343 031e B091 0000 		lds r27,bankStates+13+3
 344 0322 00C0      		rjmp .L46
 345               	.L17:
 413:WTPA.c        **** 					}
 414:WTPA.c        **** 					else
 415:WTPA.c        **** 					{
 416:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 346               		.loc 1 416 0
 347 0324 8091 0000 		lds r24,bankStates+32
 348 0328 9091 0000 		lds r25,bankStates+32+1
 349 032c A091 0000 		lds r26,bankStates+32+2
 350 0330 B091 0000 		lds r27,bankStates+32+3
 351 0334 0197      		sbiw r24,1
 352 0336 A109      		sbc r26,__zero_reg__
 353 0338 B109      		sbc r27,__zero_reg__
 354 033a 00C0      		rjmp .L46
 355               	.L14:
 417:WTPA.c        **** 					}
 418:WTPA.c        **** 				}
 419:WTPA.c        **** 			}
 420:WTPA.c        **** 			else	// Going forward through the sample.
 421:WTPA.c        **** 			{
 422:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 356               		.loc 1 422 0
 357 033c 8091 0000 		lds r24,bankStates+21
 358 0340 9091 0000 		lds r25,bankStates+21+1
 359 0344 A091 0000 		lds r26,bankStates+21+2
 360 0348 B091 0000 		lds r27,bankStates+21+3
 361 034c 4817      		cp r20,r24
 362 034e 5907      		cpc r21,r25
 363 0350 6A07      		cpc r22,r26
 364 0352 7B07      		cpc r23,r27
 365 0354 01F4      		brne .L18
 366               		.loc 1 422 0 is_stmt 0 discriminator 1
 367 0356 8091 0000 		lds r24,bankStates+1
 368 035a 8130      		cpi r24,lo8(1)
 369 035c 01F4      		brne .L18
 370               	.L45:
 423:WTPA.c        **** 				{
 424:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 371               		.loc 1 424 0 is_stmt 1
 372 035e 1092 0000 		sts bankStates,__zero_reg__
 425:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 373               		.loc 1 425 0
 374 0362 1092 0000 		sts bankStates+10,__zero_reg__
 375 0366 00C0      		rjmp .L12
 376               	.L18:
 426:WTPA.c        **** 				}
 427:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 377               		.loc 1 427 0
 378 0368 4091 0000 		lds r20,bankStates+32
 379 036c 5091 0000 		lds r21,bankStates+32+1
 380 0370 6091 0000 		lds r22,bankStates+32+2
 381 0374 7091 0000 		lds r23,bankStates+32+3
 382 0378 8091 0000 		lds r24,bankStates+21
 383 037c 9091 0000 		lds r25,bankStates+21+1
 384 0380 A091 0000 		lds r26,bankStates+21+2
 385 0384 B091 0000 		lds r27,bankStates+21+3
 386 0388 4817      		cp r20,r24
 387 038a 5907      		cpc r21,r25
 388 038c 6A07      		cpc r22,r26
 389 038e 7B07      		cpc r23,r27
 390 0390 01F4      		brne .L19
 428:WTPA.c        **** 				{
 429:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 391               		.loc 1 429 0
 392 0392 8091 0000 		lds r24,bankStates+25
 393 0396 9091 0000 		lds r25,bankStates+25+1
 394 039a A091 0000 		lds r26,bankStates+25+2
 395 039e B091 0000 		lds r27,bankStates+25+3
 396 03a2 00C0      		rjmp .L46
 397               	.L19:
 430:WTPA.c        **** 				}
 431:WTPA.c        **** 				else
 432:WTPA.c        **** 				{
 433:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 398               		.loc 1 433 0
 399 03a4 4091 0000 		lds r20,bankStates+32
 400 03a8 5091 0000 		lds r21,bankStates+32+1
 401 03ac 6091 0000 		lds r22,bankStates+32+2
 402 03b0 7091 0000 		lds r23,bankStates+32+3
 403 03b4 8091 0000 		lds r24,bankStates+13
 404 03b8 9091 0000 		lds r25,bankStates+13+1
 405 03bc A091 0000 		lds r26,bankStates+13+2
 406 03c0 B091 0000 		lds r27,bankStates+13+3
 407 03c4 4817      		cp r20,r24
 408 03c6 5907      		cpc r21,r25
 409 03c8 6A07      		cpc r22,r26
 410 03ca 7B07      		cpc r23,r27
 411 03cc 01F4      		brne .L20
 434:WTPA.c        **** 					{
 435:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 412               		.loc 1 435 0
 413 03ce 8091 0000 		lds r24,bankStates+17
 414 03d2 9091 0000 		lds r25,bankStates+17+1
 415 03d6 A091 0000 		lds r26,bankStates+17+2
 416 03da B091 0000 		lds r27,bankStates+17+3
 417 03de 00C0      		rjmp .L46
 418               	.L20:
 436:WTPA.c        **** 					}
 437:WTPA.c        **** 					else
 438:WTPA.c        **** 					{
 439:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 419               		.loc 1 439 0
 420 03e0 8091 0000 		lds r24,bankStates+32
 421 03e4 9091 0000 		lds r25,bankStates+32+1
 422 03e8 A091 0000 		lds r26,bankStates+32+2
 423 03ec B091 0000 		lds r27,bankStates+32+3
 424 03f0 0196      		adiw r24,1
 425 03f2 A11D      		adc r26,__zero_reg__
 426 03f4 B11D      		adc r27,__zero_reg__
 427               	.L46:
 428 03f6 8093 0000 		sts bankStates+32,r24
 429 03fa 9093 0000 		sts bankStates+32+1,r25
 430 03fe A093 0000 		sts bankStates+32+2,r26
 431 0402 B093 0000 		sts bankStates+32+3,r27
 432               	.L12:
 440:WTPA.c        **** 					}
 441:WTPA.c        **** 				}
 442:WTPA.c        **** 			}
 443:WTPA.c        **** 		}
 444:WTPA.c        **** /*
 445:WTPA.c        **** // @@@ Isr speed test hooey
 446:WTPA.c        **** 		if(bankStates[BANK_0].currentAddress==daNextJump)
 447:WTPA.c        **** 		{
 448:WTPA.c        **** 			bankStates[BANK_0].currentAddress=daNextJumpPrime;
 449:WTPA.c        **** 		}
 450:WTPA.c        **** 		else
 451:WTPA.c        **** 		{
 452:WTPA.c        **** 			bankStates[BANK_0].currentAddress++;
 453:WTPA.c        **** 		}
 454:WTPA.c        **** 
 455:WTPA.c        **** 		if(bankStates[BANK_0].sampleDirection==false)
 456:WTPA.c        **** 		{
 457:WTPA.c        **** 			bankStates[BANK_0].currentAddress-=2;
 458:WTPA.c        **** 		}
 459:WTPA.c        **** 
 460:WTPA.c        **** */
 461:WTPA.c        **** 		// Finish getting the byte from RAM.
 462:WTPA.c        **** 
 463:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 433               		.loc 1 463 0
 434 0406 83B1      		in r24,0x3
 435               	.LVL5:
 464:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 436               		.loc 1 464 0
 437 0408 129A      		sbi 0x2,2
 465:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 438               		.loc 1 465 0
 439 040a 9FEF      		ldi r25,lo8(-1)
 440 040c 94B9      		out 0x4,r25
 441               	.L51:
 466:WTPA.c        **** 
 467:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 442               		.loc 1 467 0
 443 040e 9091 0000 		lds r25,bankStates+9
 444 0412 9923      		tst r25
 445 0414 01F4      		brne .+2
 446 0416 00C0      		rjmp .L2
 468:WTPA.c        **** 		{
 469:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 447               		.loc 1 469 0
 448 0418 8058      		subi r24,lo8(-(-128))
 449               	.LVL6:
 470:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 450               		.loc 1 470 0
 451 041a 9091 0000 		lds r25,bankStates+9
 452 041e 2FEF      		ldi r18,lo8(-1)
 453 0420 30E0      		ldi r19,0
 454 0422 092E      		mov r0,r25
 455 0424 00C0      		rjmp 2f
 456               		1:
 457 0426 220F      		lsl r18
 458               		2:
 459 0428 0A94      		dec r0
 460 042a 02F4      		brpl 1b
 461 042c 8223      		and r24,r18
 462               	.LVL7:
 471:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 463               		.loc 1 471 0
 464 042e 8058      		subi r24,lo8(-(-128))
 465               	.LVL8:
 466 0430 0895      		ret
 467               	.LVL9:
 468               	.L7:
 472:WTPA.c        **** 		}
 473:WTPA.c        **** 		break;
 474:WTPA.c        **** 
 475:WTPA.c        **** 		case AUDIO_OVERDUB:
 476:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 477:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 478:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 469               		.loc 1 478 0
 470 0432 8091 0000 		lds r24,bankStates+32
 471 0436 9091 0000 		lds r25,bankStates+32+1
 472 043a A091 0000 		lds r26,bankStates+32+2
 473 043e B091 0000 		lds r27,bankStates+32+3
 474 0442 85B9      		out 0x5,r24
 479:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 475               		.loc 1 479 0
 476 0444 139A      		sbi 0x2,3
 480:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 477               		.loc 1 480 0
 478 0446 1398      		cbi 0x2,3
 481:WTPA.c        **** 
 482:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 479               		.loc 1 482 0
 480 0448 8091 0000 		lds r24,bankStates+32
 481 044c 9091 0000 		lds r25,bankStates+32+1
 482 0450 A091 0000 		lds r26,bankStates+32+2
 483 0454 B091 0000 		lds r27,bankStates+32+3
 484 0458 892F      		mov r24,r25
 485 045a 9A2F      		mov r25,r26
 486 045c AB2F      		mov r26,r27
 487 045e BB27      		clr r27
 488 0460 85B9      		out 0x5,r24
 483:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 489               		.loc 1 483 0
 490 0462 149A      		sbi 0x2,4
 484:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 491               		.loc 1 484 0
 492 0464 1498      		cbi 0x2,4
 485:WTPA.c        **** 
 486:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 493               		.loc 1 486 0
 494 0466 8091 0000 		lds r24,bankStates+32
 495 046a 9091 0000 		lds r25,bankStates+32+1
 496 046e A091 0000 		lds r26,bankStates+32+2
 497 0472 B091 0000 		lds r27,bankStates+32+3
 498 0476 CD01      		movw r24,r26
 499 0478 AA27      		clr r26
 500 047a BB27      		clr r27
 501 047c 8770      		andi r24,7
 502 047e 9927      		clr r25
 503 0480 AA27      		clr r26
 504 0482 BB27      		clr r27
 505 0484 8868      		ori r24,136
 506 0486 88B9      		out 0x8,r24
 487:WTPA.c        **** 
 488:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 507               		.loc 1 488 0
 508 0488 14B8      		out 0x4,__zero_reg__
 489:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 509               		.loc 1 489 0
 510 048a 1298      		cbi 0x2,2
 490:WTPA.c        **** 
 491:WTPA.c        **** 		// Calculate new address while bus settles (were nops in here)
 492:WTPA.c        **** 
 493:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 511               		.loc 1 493 0
 512 048c 8091 0000 		lds r24,bankStates+7
 513 0490 8823      		tst r24
 514 0492 01F4      		brne .+2
 515 0494 00C0      		rjmp .L21
 494:WTPA.c        **** 		{
 495:WTPA.c        **** 			// Slice first, only worry about forward ###
 496:WTPA.c        **** 
 497:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 516               		.loc 1 497 0
 517 0496 8091 0000 		lds r24,sliceRemaining
 518 049a 9091 0000 		lds r25,sliceRemaining+1
 519 049e A091 0000 		lds r26,sliceRemaining+2
 520 04a2 B091 0000 		lds r27,sliceRemaining+3
 521 04a6 892B      		or r24,r25
 522 04a8 8A2B      		or r24,r26
 523 04aa 8B2B      		or r24,r27
 524 04ac 01F0      		breq .L22
 498:WTPA.c        **** 			{
 499:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 525               		.loc 1 499 0
 526 04ae 8091 0000 		lds r24,bankStates+32
 527 04b2 9091 0000 		lds r25,bankStates+32+1
 528 04b6 A091 0000 		lds r26,bankStates+32+2
 529 04ba B091 0000 		lds r27,bankStates+32+3
 530 04be 0196      		adiw r24,1
 531 04c0 A11D      		adc r26,__zero_reg__
 532 04c2 B11D      		adc r27,__zero_reg__
 533 04c4 8093 0000 		sts bankStates+32,r24
 534 04c8 9093 0000 		sts bankStates+32+1,r25
 535 04cc A093 0000 		sts bankStates+32+2,r26
 536 04d0 B093 0000 		sts bankStates+32+3,r27
 500:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 537               		.loc 1 500 0
 538 04d4 8091 0000 		lds r24,sliceRemaining
 539 04d8 9091 0000 		lds r25,sliceRemaining+1
 540 04dc A091 0000 		lds r26,sliceRemaining+2
 541 04e0 B091 0000 		lds r27,sliceRemaining+3
 542 04e4 0197      		sbiw r24,1
 543 04e6 A109      		sbc r26,__zero_reg__
 544 04e8 B109      		sbc r27,__zero_reg__
 545 04ea 8093 0000 		sts sliceRemaining,r24
 546 04ee 9093 0000 		sts sliceRemaining+1,r25
 547 04f2 A093 0000 		sts sliceRemaining+2,r26
 548 04f6 B093 0000 		sts sliceRemaining+3,r27
 549 04fa 00C0      		rjmp .L23
 550               	.L22:
 501:WTPA.c        **** 			}
 502:WTPA.c        **** 			else	// Slice done, jump to new slice.
 503:WTPA.c        **** 			{
 504:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 551               		.loc 1 504 0
 552 04fc 8091 0000 		lds r24,sliceSize
 553 0500 9091 0000 		lds r25,sliceSize+1
 554 0504 A091 0000 		lds r26,sliceSize+2
 555 0508 B091 0000 		lds r27,sliceSize+3
 556 050c 8093 0000 		sts sliceRemaining,r24
 557 0510 9093 0000 		sts sliceRemaining+1,r25
 558 0514 A093 0000 		sts sliceRemaining+2,r26
 559 0518 B093 0000 		sts sliceRemaining+3,r27
 505:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 560               		.loc 1 505 0
 561 051c 8091 0000 		lds r24,granularPositionArrayPointer
 562 0520 8F5F      		subi r24,lo8(-(1))
 563 0522 8093 0000 		sts granularPositionArrayPointer,r24
 506:WTPA.c        **** 
 507:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 564               		.loc 1 507 0
 565 0526 9091 0000 		lds r25,granularPositionArrayPointer
 566 052a 8091 0000 		lds r24,bankStates+7
 567 052e 9813      		cpse r25,r24
 568 0530 00C0      		rjmp .L24
 508:WTPA.c        **** 				{
 509:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 569               		.loc 1 509 0
 570 0532 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 571               	.L24:
 510:WTPA.c        **** 				}
 511:WTPA.c        **** 
 512:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 572               		.loc 1 512 0
 573 0536 E091 0000 		lds r30,granularPositionArrayPointer
 574 053a 2091 0000 		lds r18,sliceSize
 575 053e 3091 0000 		lds r19,sliceSize+1
 576 0542 4091 0000 		lds r20,sliceSize+2
 577 0546 5091 0000 		lds r21,sliceSize+3
 578 054a F0E0      		ldi r31,0
 579 054c E050      		subi r30,lo8(-(granularPositionArray))
 580 054e F040      		sbci r31,hi8(-(granularPositionArray))
 581 0550 A081      		ld r26,Z
 582 0552 B0E0      		ldi r27,0
 583 0554 0E94 0000 		call __muluhisi3
 584 0558 6093 0000 		sts bankStates+32,r22
 585 055c 7093 0000 		sts bankStates+32+1,r23
 586 0560 8093 0000 		sts bankStates+32+2,r24
 587 0564 9093 0000 		sts bankStates+32+3,r25
 588 0568 00C0      		rjmp .L23
 589               	.L21:
 513:WTPA.c        **** 			}
 514:WTPA.c        **** 		}
 515:WTPA.c        **** 		else
 516:WTPA.c        **** 		{
 517:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 590               		.loc 1 517 0
 591 056a 8091 0000 		lds r24,bankStates+4
 518:WTPA.c        **** 			{
 519:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 592               		.loc 1 519 0
 593 056e 4091 0000 		lds r20,bankStates+32
 594 0572 5091 0000 		lds r21,bankStates+32+1
 595 0576 6091 0000 		lds r22,bankStates+32+2
 596 057a 7091 0000 		lds r23,bankStates+32+3
 517:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 597               		.loc 1 517 0
 598 057e 8111      		cpse r24,__zero_reg__
 599 0580 00C0      		rjmp .L25
 600               		.loc 1 519 0
 601 0582 8091 0000 		lds r24,bankStates+25
 602 0586 9091 0000 		lds r25,bankStates+25+1
 603 058a A091 0000 		lds r26,bankStates+25+2
 604 058e B091 0000 		lds r27,bankStates+25+3
 605 0592 4817      		cp r20,r24
 606 0594 5907      		cpc r21,r25
 607 0596 6A07      		cpc r22,r26
 608 0598 7B07      		cpc r23,r27
 609 059a 01F4      		brne .L26
 610               		.loc 1 519 0 is_stmt 0 discriminator 1
 611 059c 8091 0000 		lds r24,bankStates+1
 612 05a0 8130      		cpi r24,lo8(1)
 613 05a2 01F4      		brne .L26
 614 05a4 00C0      		rjmp .L47
 615               	.L26:
 520:WTPA.c        **** 				{
 521:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 522:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 523:WTPA.c        **** 				}
 524:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 616               		.loc 1 524 0 is_stmt 1
 617 05a6 4091 0000 		lds r20,bankStates+32
 618 05aa 5091 0000 		lds r21,bankStates+32+1
 619 05ae 6091 0000 		lds r22,bankStates+32+2
 620 05b2 7091 0000 		lds r23,bankStates+32+3
 621 05b6 8091 0000 		lds r24,bankStates+25
 622 05ba 9091 0000 		lds r25,bankStates+25+1
 623 05be A091 0000 		lds r26,bankStates+25+2
 624 05c2 B091 0000 		lds r27,bankStates+25+3
 625 05c6 4817      		cp r20,r24
 626 05c8 5907      		cpc r21,r25
 627 05ca 6A07      		cpc r22,r26
 628 05cc 7B07      		cpc r23,r27
 629 05ce 01F4      		brne .L27
 525:WTPA.c        **** 				{
 526:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 630               		.loc 1 526 0
 631 05d0 8091 0000 		lds r24,bankStates+21
 632 05d4 9091 0000 		lds r25,bankStates+21+1
 633 05d8 A091 0000 		lds r26,bankStates+21+2
 634 05dc B091 0000 		lds r27,bankStates+21+3
 635 05e0 00C0      		rjmp .L48
 636               	.L27:
 527:WTPA.c        **** 				}
 528:WTPA.c        **** 				else
 529:WTPA.c        **** 				{
 530:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 637               		.loc 1 530 0
 638 05e2 4091 0000 		lds r20,bankStates+32
 639 05e6 5091 0000 		lds r21,bankStates+32+1
 640 05ea 6091 0000 		lds r22,bankStates+32+2
 641 05ee 7091 0000 		lds r23,bankStates+32+3
 642 05f2 8091 0000 		lds r24,bankStates+17
 643 05f6 9091 0000 		lds r25,bankStates+17+1
 644 05fa A091 0000 		lds r26,bankStates+17+2
 645 05fe B091 0000 		lds r27,bankStates+17+3
 646 0602 4817      		cp r20,r24
 647 0604 5907      		cpc r21,r25
 648 0606 6A07      		cpc r22,r26
 649 0608 7B07      		cpc r23,r27
 650 060a 01F4      		brne .L28
 531:WTPA.c        **** 					{
 532:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 651               		.loc 1 532 0
 652 060c 8091 0000 		lds r24,bankStates+13
 653 0610 9091 0000 		lds r25,bankStates+13+1
 654 0614 A091 0000 		lds r26,bankStates+13+2
 655 0618 B091 0000 		lds r27,bankStates+13+3
 656 061c 00C0      		rjmp .L48
 657               	.L28:
 533:WTPA.c        **** 					}
 534:WTPA.c        **** 					else
 535:WTPA.c        **** 					{
 536:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 658               		.loc 1 536 0
 659 061e 8091 0000 		lds r24,bankStates+32
 660 0622 9091 0000 		lds r25,bankStates+32+1
 661 0626 A091 0000 		lds r26,bankStates+32+2
 662 062a B091 0000 		lds r27,bankStates+32+3
 663 062e 0197      		sbiw r24,1
 664 0630 A109      		sbc r26,__zero_reg__
 665 0632 B109      		sbc r27,__zero_reg__
 666 0634 00C0      		rjmp .L48
 667               	.L25:
 537:WTPA.c        **** 					}
 538:WTPA.c        **** 				}
 539:WTPA.c        **** 			}
 540:WTPA.c        **** 			else	// Going forward through the sample.
 541:WTPA.c        **** 			{
 542:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 668               		.loc 1 542 0
 669 0636 8091 0000 		lds r24,bankStates+21
 670 063a 9091 0000 		lds r25,bankStates+21+1
 671 063e A091 0000 		lds r26,bankStates+21+2
 672 0642 B091 0000 		lds r27,bankStates+21+3
 673 0646 4817      		cp r20,r24
 674 0648 5907      		cpc r21,r25
 675 064a 6A07      		cpc r22,r26
 676 064c 7B07      		cpc r23,r27
 677 064e 01F4      		brne .L29
 678               		.loc 1 542 0 is_stmt 0 discriminator 1
 679 0650 8091 0000 		lds r24,bankStates+1
 680 0654 8130      		cpi r24,lo8(1)
 681 0656 01F4      		brne .L29
 682               	.L47:
 543:WTPA.c        **** 				{
 544:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 683               		.loc 1 544 0 is_stmt 1
 684 0658 1092 0000 		sts bankStates,__zero_reg__
 545:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 685               		.loc 1 545 0
 686 065c 1092 0000 		sts bankStates+10,__zero_reg__
 687 0660 00C0      		rjmp .L23
 688               	.L29:
 546:WTPA.c        **** 				}
 547:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 689               		.loc 1 547 0
 690 0662 4091 0000 		lds r20,bankStates+32
 691 0666 5091 0000 		lds r21,bankStates+32+1
 692 066a 6091 0000 		lds r22,bankStates+32+2
 693 066e 7091 0000 		lds r23,bankStates+32+3
 694 0672 8091 0000 		lds r24,bankStates+21
 695 0676 9091 0000 		lds r25,bankStates+21+1
 696 067a A091 0000 		lds r26,bankStates+21+2
 697 067e B091 0000 		lds r27,bankStates+21+3
 698 0682 4817      		cp r20,r24
 699 0684 5907      		cpc r21,r25
 700 0686 6A07      		cpc r22,r26
 701 0688 7B07      		cpc r23,r27
 702 068a 01F4      		brne .L30
 548:WTPA.c        **** 				{
 549:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 703               		.loc 1 549 0
 704 068c 8091 0000 		lds r24,bankStates+25
 705 0690 9091 0000 		lds r25,bankStates+25+1
 706 0694 A091 0000 		lds r26,bankStates+25+2
 707 0698 B091 0000 		lds r27,bankStates+25+3
 708 069c 00C0      		rjmp .L48
 709               	.L30:
 550:WTPA.c        **** 				}
 551:WTPA.c        **** 				else
 552:WTPA.c        **** 				{
 553:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 710               		.loc 1 553 0
 711 069e 4091 0000 		lds r20,bankStates+32
 712 06a2 5091 0000 		lds r21,bankStates+32+1
 713 06a6 6091 0000 		lds r22,bankStates+32+2
 714 06aa 7091 0000 		lds r23,bankStates+32+3
 715 06ae 8091 0000 		lds r24,bankStates+13
 716 06b2 9091 0000 		lds r25,bankStates+13+1
 717 06b6 A091 0000 		lds r26,bankStates+13+2
 718 06ba B091 0000 		lds r27,bankStates+13+3
 719 06be 4817      		cp r20,r24
 720 06c0 5907      		cpc r21,r25
 721 06c2 6A07      		cpc r22,r26
 722 06c4 7B07      		cpc r23,r27
 723 06c6 01F4      		brne .L31
 554:WTPA.c        **** 					{
 555:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 724               		.loc 1 555 0
 725 06c8 8091 0000 		lds r24,bankStates+17
 726 06cc 9091 0000 		lds r25,bankStates+17+1
 727 06d0 A091 0000 		lds r26,bankStates+17+2
 728 06d4 B091 0000 		lds r27,bankStates+17+3
 729 06d8 00C0      		rjmp .L48
 730               	.L31:
 556:WTPA.c        **** 					}
 557:WTPA.c        **** 					else
 558:WTPA.c        **** 					{
 559:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 731               		.loc 1 559 0
 732 06da 8091 0000 		lds r24,bankStates+32
 733 06de 9091 0000 		lds r25,bankStates+32+1
 734 06e2 A091 0000 		lds r26,bankStates+32+2
 735 06e6 B091 0000 		lds r27,bankStates+32+3
 736 06ea 0196      		adiw r24,1
 737 06ec A11D      		adc r26,__zero_reg__
 738 06ee B11D      		adc r27,__zero_reg__
 739               	.L48:
 740 06f0 8093 0000 		sts bankStates+32,r24
 741 06f4 9093 0000 		sts bankStates+32+1,r25
 742 06f8 A093 0000 		sts bankStates+32+2,r26
 743 06fc B093 0000 		sts bankStates+32+3,r27
 744               	.L23:
 560:WTPA.c        **** 					}
 561:WTPA.c        **** 				}
 562:WTPA.c        **** 			}
 563:WTPA.c        **** 		}
 564:WTPA.c        **** 
 565:WTPA.c        **** 		// Finished calculating address, bus should be settled, so finish the exchange with RAM
 566:WTPA.c        **** 
 567:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 745               		.loc 1 567 0
 746 0700 83B1      		in r24,0x3
 747               	.LVL10:
 568:WTPA.c        **** 
 569:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 748               		.loc 1 569 0
 749 0702 129A      		sbi 0x2,2
 570:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 750               		.loc 1 570 0
 751 0704 9FEF      		ldi r25,lo8(-1)
 752 0706 94B9      		out 0x4,r25
 571:WTPA.c        **** 
 572:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 753               		.loc 1 572 0
 754 0708 9091 0000 		lds r25,bankStates+9
 755 070c 9923      		tst r25
 756 070e 01F0      		breq .L32
 573:WTPA.c        **** 		{
 574:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 757               		.loc 1 574 0
 758 0710 8058      		subi r24,lo8(-(-128))
 759               	.LVL11:
 575:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 760               		.loc 1 575 0
 761 0712 9091 0000 		lds r25,bankStates+9
 762 0716 2FEF      		ldi r18,lo8(-1)
 763 0718 30E0      		ldi r19,0
 764 071a 092E      		mov r0,r25
 765 071c 00C0      		rjmp 2f
 766               		1:
 767 071e 220F      		lsl r18
 768               		2:
 769 0720 0A94      		dec r0
 770 0722 02F4      		brpl 1b
 771 0724 8223      		and r24,r18
 772               	.LVL12:
 576:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 773               		.loc 1 576 0
 774 0726 8058      		subi r24,lo8(-(-128))
 775               	.LVL13:
 776               	.L32:
 577:WTPA.c        **** 		}
 578:WTPA.c        **** 
 579:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 777               		.loc 1 579 0
 778 0728 2091 0000 		lds r18,adcByte
 779 072c 3327      		clr r19
 780 072e 27FD      		sbrc r18,7
 781 0730 3095      		com r19
 782 0732 280F      		add r18,r24
 783 0734 311D      		adc r19,__zero_reg__
 784 0736 87FD      		sbrc r24,7
 785 0738 3A95      		dec r19
 786 073a 2038      		cpi r18,-128
 787 073c 9FEF      		ldi r25,-1
 788 073e 3907      		cpc r19,r25
 789 0740 04F4      		brge .L33
 790 0742 20E8      		ldi r18,lo8(-128)
 791 0744 3FEF      		ldi r19,lo8(-1)
 792               	.L33:
 793               	.LVL14:
 580:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 581:WTPA.c        **** 		{
 582:WTPA.c        **** 			sum=127;
 583:WTPA.c        **** 		}
 584:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 585:WTPA.c        **** 		{
 586:WTPA.c        **** 			sum=-128;
 587:WTPA.c        **** 		}
 588:WTPA.c        **** 
 589:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 794               		.loc 1 589 0
 795 0746 2038      		cpi r18,-128
 796 0748 3105      		cpc r19,__zero_reg__
 797 074a 04F0      		brlt .L34
 798 074c 2FE7      		ldi r18,lo8(127)
 799 074e 30E0      		ldi r19,0
 800               	.LVL15:
 801               	.L34:
 802 0750 25B9      		out 0x5,r18
 590:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 803               		.loc 1 590 0
 804 0752 1198      		cbi 0x2,1
 591:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 805               		.loc 1 591 0
 806 0754 119A      		sbi 0x2,1
 592:WTPA.c        **** 		break;
 807               		.loc 1 592 0
 808 0756 0895      		ret
 809               	.LVL16:
 810               	.L35:
 300:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 811               		.loc 1 300 0
 812 0758 80E0      		ldi r24,0
 813               	.LVL17:
 814               	.L2:
 593:WTPA.c        **** 	}
 594:WTPA.c        **** 
 595:WTPA.c        **** 	return(outputByte);
 596:WTPA.c        **** }
 815               		.loc 1 596 0
 816 075a 0895      		ret
 817               		.cfi_endproc
 818               	.LFE1:
 821               	UpdateAudioChannel1:
 822               	.LFB2:
 597:WTPA.c        **** 
 598:WTPA.c        **** static unsigned char UpdateAudioChannel1(void)
 599:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 600:WTPA.c        **** {
 823               		.loc 1 600 0
 824               		.cfi_startproc
 825 075c 0F93      		push r16
 826               	.LCFI0:
 827               		.cfi_def_cfa_offset 3
 828               		.cfi_offset 16, -2
 829 075e 1F93      		push r17
 830               	.LCFI1:
 831               		.cfi_def_cfa_offset 4
 832               		.cfi_offset 17, -3
 833               	/* prologue: function */
 834               	/* frame size = 0 */
 835               	/* stack size = 2 */
 836               	.L__stack_usage = 2
 837               	.LVL18:
 601:WTPA.c        **** 	signed int
 602:WTPA.c        **** 		sum;			// For doing saturated adds.
 603:WTPA.c        **** 	signed char
 604:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 605:WTPA.c        **** 	static unsigned char
 606:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 607:WTPA.c        **** 
 608:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 609:WTPA.c        **** 
 610:WTPA.c        **** 	switch(bankStates[BANK_1].audioFunction)
 838               		.loc 1 610 0
 839 0760 8091 0000 		lds r24,bankStates+36
 840 0764 8330      		cpi r24,lo8(3)
 841 0766 01F0      		breq .L56
 842 0768 00F4      		brsh .L59
 843 076a 8130      		cpi r24,lo8(1)
 844 076c 01F0      		breq .L54
 845 076e 8230      		cpi r24,lo8(2)
 846 0770 01F0      		breq .+2
 847 0772 00C0      		rjmp .L86
 848 0774 00C0      		rjmp .L55
 849               	.L59:
 850 0776 8430      		cpi r24,lo8(4)
 851 0778 01F4      		brne .+2
 852 077a 00C0      		rjmp .L57
 853 077c 8530      		cpi r24,lo8(5)
 854 077e 01F0      		breq .+2
 855 0780 00C0      		rjmp .L86
 856 0782 00C0      		rjmp .L58
 857               	.L54:
 611:WTPA.c        **** 	{
 612:WTPA.c        **** 
 613:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 614:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 615:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 858               		.loc 1 615 0
 859 0784 8091 0000 		lds r24,sawtooth.1769
 860               	.LVL19:
 861 0788 982F      		mov r25,r24
 862 078a 9F5F      		subi r25,lo8(-(1))
 863 078c 9093 0000 		sts sawtooth.1769,r25
 616:WTPA.c        **** 		break;
 864               		.loc 1 616 0
 865 0790 00C0      		rjmp .L53
 866               	.LVL20:
 867               	.L55:
 617:WTPA.c        **** 
 618:WTPA.c        **** 		case AUDIO_REALTIME:
 619:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 620:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 868               		.loc 1 620 0
 869 0792 8091 0000 		lds r24,adcByte
 870               	.LVL21:
 871 0796 00C0      		rjmp .L102
 872               	.LVL22:
 873               	.L56:
 621:WTPA.c        **** 
 622:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 623:WTPA.c        **** 		{
 624:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 625:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 626:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 627:WTPA.c        **** 		}
 628:WTPA.c        **** 		break;
 629:WTPA.c        **** 
 630:WTPA.c        **** 		case AUDIO_RECORD:
 631:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 632:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 874               		.loc 1 632 0
 875 0798 8FEF      		ldi r24,lo8(-1)
 876 079a 84B9      		out 0x4,r24
 633:WTPA.c        **** 
 634:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 877               		.loc 1 634 0
 878 079c 8091 0000 		lds r24,bankStates+68
 879 07a0 9091 0000 		lds r25,bankStates+68+1
 880 07a4 A091 0000 		lds r26,bankStates+68+2
 881 07a8 B091 0000 		lds r27,bankStates+68+3
 882 07ac 85B9      		out 0x5,r24
 635:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 883               		.loc 1 635 0
 884 07ae 139A      		sbi 0x2,3
 636:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 885               		.loc 1 636 0
 886 07b0 1398      		cbi 0x2,3
 637:WTPA.c        **** 
 638:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 887               		.loc 1 638 0
 888 07b2 8091 0000 		lds r24,bankStates+68
 889 07b6 9091 0000 		lds r25,bankStates+68+1
 890 07ba A091 0000 		lds r26,bankStates+68+2
 891 07be B091 0000 		lds r27,bankStates+68+3
 892 07c2 892F      		mov r24,r25
 893 07c4 9A2F      		mov r25,r26
 894 07c6 AB2F      		mov r26,r27
 895 07c8 BB27      		clr r27
 896 07ca 85B9      		out 0x5,r24
 639:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 897               		.loc 1 639 0
 898 07cc 149A      		sbi 0x2,4
 640:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 899               		.loc 1 640 0
 900 07ce 1498      		cbi 0x2,4
 641:WTPA.c        **** 
 642:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 901               		.loc 1 642 0
 902 07d0 8091 0000 		lds r24,bankStates+68
 903 07d4 9091 0000 		lds r25,bankStates+68+1
 904 07d8 A091 0000 		lds r26,bankStates+68+2
 905 07dc B091 0000 		lds r27,bankStates+68+3
 906 07e0 CD01      		movw r24,r26
 907 07e2 AA27      		clr r26
 908 07e4 BB27      		clr r27
 909 07e6 8770      		andi r24,7
 910 07e8 9927      		clr r25
 911 07ea AA27      		clr r26
 912 07ec BB27      		clr r27
 913 07ee 8868      		ori r24,136
 914 07f0 88B9      		out 0x8,r24
 643:WTPA.c        **** 
 644:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 915               		.loc 1 644 0
 916 07f2 8091 0000 		lds r24,adcByte
 917 07f6 85B9      		out 0x5,r24
 645:WTPA.c        **** 
 646:WTPA.c        **** 		// Compute address while bus settles.
 647:WTPA.c        **** 
 648:WTPA.c        **** 		bankStates[BANK_1].currentAddress--;									// Next address please.
 918               		.loc 1 648 0
 919 07f8 8091 0000 		lds r24,bankStates+68
 920 07fc 9091 0000 		lds r25,bankStates+68+1
 921 0800 A091 0000 		lds r26,bankStates+68+2
 922 0804 B091 0000 		lds r27,bankStates+68+3
 923 0808 0197      		sbiw r24,1
 924 080a A109      		sbc r26,__zero_reg__
 925 080c B109      		sbc r27,__zero_reg__
 926 080e 8093 0000 		sts bankStates+68,r24
 927 0812 9093 0000 		sts bankStates+68+1,r25
 928 0816 A093 0000 		sts bankStates+68+2,r26
 929 081a B093 0000 		sts bankStates+68+3,r27
 649:WTPA.c        **** 		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the
 930               		.loc 1 649 0
 931 081e 8091 0000 		lds r24,bankStates+68
 932 0822 9091 0000 		lds r25,bankStates+68+1
 933 0826 A091 0000 		lds r26,bankStates+68+2
 934 082a B091 0000 		lds r27,bankStates+68+3
 935 082e 8093 0000 		sts bankStates+49,r24
 936 0832 9093 0000 		sts bankStates+49+1,r25
 937 0836 A093 0000 		sts bankStates+49+2,r26
 938 083a B093 0000 		sts bankStates+49+3,r27
 650:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address 
 939               		.loc 1 650 0
 940 083e 8091 0000 		lds r24,bankStates+68
 941 0842 9091 0000 		lds r25,bankStates+68+1
 942 0846 A091 0000 		lds r26,bankStates+68+2
 943 084a B091 0000 		lds r27,bankStates+68+3
 944 084e 8093 0000 		sts bankStates+57,r24
 945 0852 9093 0000 		sts bankStates+57+1,r25
 946 0856 A093 0000 		sts bankStates+57+2,r26
 947 085a B093 0000 		sts bankStates+57+3,r27
 651:WTPA.c        **** 
 652:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 948               		.loc 1 652 0
 949 085e 4091 0000 		lds r20,bankStates+13
 950 0862 5091 0000 		lds r21,bankStates+13+1
 951 0866 6091 0000 		lds r22,bankStates+13+2
 952 086a 7091 0000 		lds r23,bankStates+13+3
 953 086e 8091 0000 		lds r24,bankStates+49
 954 0872 9091 0000 		lds r25,bankStates+49+1
 955 0876 A091 0000 		lds r26,bankStates+49+2
 956 087a B091 0000 		lds r27,bankStates+49+3
 957 087e 4817      		cp r20,r24
 958 0880 5907      		cpc r21,r25
 959 0882 6A07      		cpc r22,r26
 960 0884 7B07      		cpc r23,r27
 961 0886 00F0      		brlo .L60
 653:WTPA.c        **** 		{
 654:WTPA.c        **** 			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 962               		.loc 1 654 0
 963 0888 1092 0000 		sts bankStates+36,__zero_reg__
 655:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 964               		.loc 1 655 0
 965 088c 81E0      		ldi r24,lo8(1)
 966 088e 8093 0000 		sts outOfRam,r24
 967               	.L60:
 656:WTPA.c        **** 		}
 657:WTPA.c        **** 
 658:WTPA.c        **** 		// Put data into RAM.
 659:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 968               		.loc 1 659 0
 969 0892 1198      		cbi 0x2,1
 660:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 970               		.loc 1 660 0
 971 0894 119A      		sbi 0x2,1
 972 0896 00C0      		rjmp .L86
 973               	.L57:
 661:WTPA.c        **** 		break;
 662:WTPA.c        **** 
 663:WTPA.c        **** 		case AUDIO_PLAYBACK:
 664:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 665:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 666:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 667:WTPA.c        **** 
 668:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 669:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 974               		.loc 1 669 0
 975 0898 8091 0000 		lds r24,bankStates+68
 976 089c 9091 0000 		lds r25,bankStates+68+1
 977 08a0 A091 0000 		lds r26,bankStates+68+2
 978 08a4 B091 0000 		lds r27,bankStates+68+3
 979 08a8 85B9      		out 0x5,r24
 670:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 980               		.loc 1 670 0
 981 08aa 139A      		sbi 0x2,3
 671:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 982               		.loc 1 671 0
 983 08ac 1398      		cbi 0x2,3
 672:WTPA.c        **** 
 673:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 984               		.loc 1 673 0
 985 08ae 8091 0000 		lds r24,bankStates+68
 986 08b2 9091 0000 		lds r25,bankStates+68+1
 987 08b6 A091 0000 		lds r26,bankStates+68+2
 988 08ba B091 0000 		lds r27,bankStates+68+3
 989 08be 892F      		mov r24,r25
 990 08c0 9A2F      		mov r25,r26
 991 08c2 AB2F      		mov r26,r27
 992 08c4 BB27      		clr r27
 993 08c6 85B9      		out 0x5,r24
 674:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 994               		.loc 1 674 0
 995 08c8 149A      		sbi 0x2,4
 675:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 996               		.loc 1 675 0
 997 08ca 1498      		cbi 0x2,4
 676:WTPA.c        **** 
 677:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 998               		.loc 1 677 0
 999 08cc 8091 0000 		lds r24,bankStates+68
 1000 08d0 9091 0000 		lds r25,bankStates+68+1
 1001 08d4 A091 0000 		lds r26,bankStates+68+2
 1002 08d8 B091 0000 		lds r27,bankStates+68+3
 1003 08dc CD01      		movw r24,r26
 1004 08de AA27      		clr r26
 1005 08e0 BB27      		clr r27
 1006 08e2 8770      		andi r24,7
 1007 08e4 9927      		clr r25
 1008 08e6 AA27      		clr r26
 1009 08e8 BB27      		clr r27
 1010 08ea 8868      		ori r24,136
 1011 08ec 88B9      		out 0x8,r24
 678:WTPA.c        **** 
 679:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1012               		.loc 1 679 0
 1013 08ee 14B8      		out 0x4,__zero_reg__
 680:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1014               		.loc 1 680 0
 1015 08f0 1298      		cbi 0x2,2
 681:WTPA.c        **** 
 682:WTPA.c        **** 		// Calculate addy while bus settles (used to be nops here)
 683:WTPA.c        **** 
 684:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1016               		.loc 1 684 0
 1017 08f2 8091 0000 		lds r24,bankStates+43
 1018 08f6 8823      		tst r24
 1019 08f8 01F4      		brne .+2
 1020 08fa 00C0      		rjmp .L61
 685:WTPA.c        **** 		{
 686:WTPA.c        **** 			// Slice first, only worry about forward ###
 687:WTPA.c        **** 
 688:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1021               		.loc 1 688 0
 1022 08fc 8091 0000 		lds r24,sliceRemaining+4
 1023 0900 9091 0000 		lds r25,sliceRemaining+4+1
 1024 0904 A091 0000 		lds r26,sliceRemaining+4+2
 1025 0908 B091 0000 		lds r27,sliceRemaining+4+3
 1026 090c 892B      		or r24,r25
 1027 090e 8A2B      		or r24,r26
 1028 0910 8B2B      		or r24,r27
 1029 0912 01F0      		breq .L62
 689:WTPA.c        **** 			{
 690:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1030               		.loc 1 690 0
 1031 0914 8091 0000 		lds r24,bankStates+68
 1032 0918 9091 0000 		lds r25,bankStates+68+1
 1033 091c A091 0000 		lds r26,bankStates+68+2
 1034 0920 B091 0000 		lds r27,bankStates+68+3
 1035 0924 0197      		sbiw r24,1
 1036 0926 A109      		sbc r26,__zero_reg__
 1037 0928 B109      		sbc r27,__zero_reg__
 1038 092a 8093 0000 		sts bankStates+68,r24
 1039 092e 9093 0000 		sts bankStates+68+1,r25
 1040 0932 A093 0000 		sts bankStates+68+2,r26
 1041 0936 B093 0000 		sts bankStates+68+3,r27
 691:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1042               		.loc 1 691 0
 1043 093a 8091 0000 		lds r24,sliceRemaining+4
 1044 093e 9091 0000 		lds r25,sliceRemaining+4+1
 1045 0942 A091 0000 		lds r26,sliceRemaining+4+2
 1046 0946 B091 0000 		lds r27,sliceRemaining+4+3
 1047 094a 0197      		sbiw r24,1
 1048 094c A109      		sbc r26,__zero_reg__
 1049 094e B109      		sbc r27,__zero_reg__
 1050 0950 8093 0000 		sts sliceRemaining+4,r24
 1051 0954 9093 0000 		sts sliceRemaining+4+1,r25
 1052 0958 A093 0000 		sts sliceRemaining+4+2,r26
 1053 095c B093 0000 		sts sliceRemaining+4+3,r27
 1054 0960 00C0      		rjmp .L63
 1055               	.L62:
 692:WTPA.c        **** 			}
 693:WTPA.c        **** 			else	// Slice done, jump to new slice.
 694:WTPA.c        **** 			{
 695:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1056               		.loc 1 695 0
 1057 0962 8091 0000 		lds r24,sliceSize+4
 1058 0966 9091 0000 		lds r25,sliceSize+4+1
 1059 096a A091 0000 		lds r26,sliceSize+4+2
 1060 096e B091 0000 		lds r27,sliceSize+4+3
 1061 0972 8093 0000 		sts sliceRemaining+4,r24
 1062 0976 9093 0000 		sts sliceRemaining+4+1,r25
 1063 097a A093 0000 		sts sliceRemaining+4+2,r26
 1064 097e B093 0000 		sts sliceRemaining+4+3,r27
 696:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1065               		.loc 1 696 0
 1066 0982 8091 0000 		lds r24,granularPositionArrayPointer+1
 1067 0986 8F5F      		subi r24,lo8(-(1))
 1068 0988 8093 0000 		sts granularPositionArrayPointer+1,r24
 697:WTPA.c        **** 
 698:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1069               		.loc 1 698 0
 1070 098c 9091 0000 		lds r25,granularPositionArrayPointer+1
 1071 0990 8091 0000 		lds r24,bankStates+43
 1072 0994 9813      		cpse r25,r24
 1073 0996 00C0      		rjmp .L64
 699:WTPA.c        **** 				{
 700:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1074               		.loc 1 700 0
 1075 0998 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1076               	.L64:
 701:WTPA.c        **** 				}
 702:WTPA.c        **** 
 703:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1077               		.loc 1 703 0
 1078 099c E091 0000 		lds r30,granularPositionArrayPointer+1
 1079 09a0 2091 0000 		lds r18,sliceSize+4
 1080 09a4 3091 0000 		lds r19,sliceSize+4+1
 1081 09a8 4091 0000 		lds r20,sliceSize+4+2
 1082 09ac 5091 0000 		lds r21,sliceSize+4+3
 1083 09b0 F0E0      		ldi r31,0
 1084 09b2 E050      		subi r30,lo8(-(granularPositionArray+128))
 1085 09b4 F040      		sbci r31,hi8(-(granularPositionArray+128))
 1086 09b6 A081      		ld r26,Z
 1087 09b8 B0E0      		ldi r27,0
 1088 09ba 0E94 0000 		call __muluhisi3
 1089 09be 0FEF      		ldi r16,lo8(-1)
 1090 09c0 1FEF      		ldi r17,lo8(-1)
 1091 09c2 27E0      		ldi r18,lo8(7)
 1092 09c4 30E0      		ldi r19,0
 1093 09c6 061B      		sub r16,r22
 1094 09c8 170B      		sbc r17,r23
 1095 09ca 280B      		sbc r18,r24
 1096 09cc 390B      		sbc r19,r25
 1097 09ce 0093 0000 		sts bankStates+68,r16
 1098 09d2 1093 0000 		sts bankStates+68+1,r17
 1099 09d6 2093 0000 		sts bankStates+68+2,r18
 1100 09da 3093 0000 		sts bankStates+68+3,r19
 1101 09de 00C0      		rjmp .L63
 1102               	.L61:
 704:WTPA.c        **** 			}
 705:WTPA.c        **** 		}
 706:WTPA.c        **** 		else
 707:WTPA.c        **** 		{
 708:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1103               		.loc 1 708 0
 1104 09e0 8091 0000 		lds r24,bankStates+40
 709:WTPA.c        **** 			{
 710:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1105               		.loc 1 710 0
 1106 09e4 4091 0000 		lds r20,bankStates+68
 1107 09e8 5091 0000 		lds r21,bankStates+68+1
 1108 09ec 6091 0000 		lds r22,bankStates+68+2
 1109 09f0 7091 0000 		lds r23,bankStates+68+3
 708:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1110               		.loc 1 708 0
 1111 09f4 8111      		cpse r24,__zero_reg__
 1112 09f6 00C0      		rjmp .L65
 1113               		.loc 1 710 0
 1114 09f8 8091 0000 		lds r24,bankStates+61
 1115 09fc 9091 0000 		lds r25,bankStates+61+1
 1116 0a00 A091 0000 		lds r26,bankStates+61+2
 1117 0a04 B091 0000 		lds r27,bankStates+61+3
 1118 0a08 4817      		cp r20,r24
 1119 0a0a 5907      		cpc r21,r25
 1120 0a0c 6A07      		cpc r22,r26
 1121 0a0e 7B07      		cpc r23,r27
 1122 0a10 01F4      		brne .L66
 1123               		.loc 1 710 0 is_stmt 0 discriminator 1
 1124 0a12 8091 0000 		lds r24,bankStates+37
 1125 0a16 8130      		cpi r24,lo8(1)
 1126 0a18 01F4      		brne .L66
 1127 0a1a 00C0      		rjmp .L96
 1128               	.L66:
 711:WTPA.c        **** 				{
 712:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 713:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 714:WTPA.c        **** 				}
 715:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1129               		.loc 1 715 0 is_stmt 1
 1130 0a1c 4091 0000 		lds r20,bankStates+68
 1131 0a20 5091 0000 		lds r21,bankStates+68+1
 1132 0a24 6091 0000 		lds r22,bankStates+68+2
 1133 0a28 7091 0000 		lds r23,bankStates+68+3
 1134 0a2c 8091 0000 		lds r24,bankStates+61
 1135 0a30 9091 0000 		lds r25,bankStates+61+1
 1136 0a34 A091 0000 		lds r26,bankStates+61+2
 1137 0a38 B091 0000 		lds r27,bankStates+61+3
 1138 0a3c 4817      		cp r20,r24
 1139 0a3e 5907      		cpc r21,r25
 1140 0a40 6A07      		cpc r22,r26
 1141 0a42 7B07      		cpc r23,r27
 1142 0a44 01F4      		brne .L67
 716:WTPA.c        **** 				{
 717:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1143               		.loc 1 717 0
 1144 0a46 8091 0000 		lds r24,bankStates+57
 1145 0a4a 9091 0000 		lds r25,bankStates+57+1
 1146 0a4e A091 0000 		lds r26,bankStates+57+2
 1147 0a52 B091 0000 		lds r27,bankStates+57+3
 1148 0a56 00C0      		rjmp .L97
 1149               	.L67:
 718:WTPA.c        **** 				}
 719:WTPA.c        **** 				else
 720:WTPA.c        **** 				{
 721:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1150               		.loc 1 721 0
 1151 0a58 4091 0000 		lds r20,bankStates+68
 1152 0a5c 5091 0000 		lds r21,bankStates+68+1
 1153 0a60 6091 0000 		lds r22,bankStates+68+2
 1154 0a64 7091 0000 		lds r23,bankStates+68+3
 1155 0a68 8091 0000 		lds r24,bankStates+53
 1156 0a6c 9091 0000 		lds r25,bankStates+53+1
 1157 0a70 A091 0000 		lds r26,bankStates+53+2
 1158 0a74 B091 0000 		lds r27,bankStates+53+3
 1159 0a78 4817      		cp r20,r24
 1160 0a7a 5907      		cpc r21,r25
 1161 0a7c 6A07      		cpc r22,r26
 1162 0a7e 7B07      		cpc r23,r27
 1163 0a80 01F4      		brne .L68
 722:WTPA.c        **** 					{
 723:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1164               		.loc 1 723 0
 1165 0a82 8091 0000 		lds r24,bankStates+49
 1166 0a86 9091 0000 		lds r25,bankStates+49+1
 1167 0a8a A091 0000 		lds r26,bankStates+49+2
 1168 0a8e B091 0000 		lds r27,bankStates+49+3
 1169 0a92 00C0      		rjmp .L97
 1170               	.L68:
 724:WTPA.c        **** 					}
 725:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 726:WTPA.c        **** 					{
 727:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1171               		.loc 1 727 0
 1172 0a94 8091 0000 		lds r24,bankStates+68
 1173 0a98 9091 0000 		lds r25,bankStates+68+1
 1174 0a9c A091 0000 		lds r26,bankStates+68+2
 1175 0aa0 B091 0000 		lds r27,bankStates+68+3
 1176 0aa4 0196      		adiw r24,1
 1177 0aa6 A11D      		adc r26,__zero_reg__
 1178 0aa8 B11D      		adc r27,__zero_reg__
 1179 0aaa 00C0      		rjmp .L97
 1180               	.L65:
 728:WTPA.c        **** 					}
 729:WTPA.c        **** 				}
 730:WTPA.c        **** 			}
 731:WTPA.c        **** 			else	// Going forward through the sample.
 732:WTPA.c        **** 			{
 733:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1181               		.loc 1 733 0
 1182 0aac 8091 0000 		lds r24,bankStates+57
 1183 0ab0 9091 0000 		lds r25,bankStates+57+1
 1184 0ab4 A091 0000 		lds r26,bankStates+57+2
 1185 0ab8 B091 0000 		lds r27,bankStates+57+3
 1186 0abc 4817      		cp r20,r24
 1187 0abe 5907      		cpc r21,r25
 1188 0ac0 6A07      		cpc r22,r26
 1189 0ac2 7B07      		cpc r23,r27
 1190 0ac4 01F4      		brne .L69
 1191               		.loc 1 733 0 is_stmt 0 discriminator 1
 1192 0ac6 8091 0000 		lds r24,bankStates+37
 1193 0aca 8130      		cpi r24,lo8(1)
 1194 0acc 01F4      		brne .L69
 1195               	.L96:
 734:WTPA.c        **** 				{
 735:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1196               		.loc 1 735 0 is_stmt 1
 1197 0ace 1092 0000 		sts bankStates+36,__zero_reg__
 736:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1198               		.loc 1 736 0
 1199 0ad2 1092 0000 		sts bankStates+46,__zero_reg__
 1200 0ad6 00C0      		rjmp .L63
 1201               	.L69:
 737:WTPA.c        **** 				}
 738:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1202               		.loc 1 738 0
 1203 0ad8 4091 0000 		lds r20,bankStates+68
 1204 0adc 5091 0000 		lds r21,bankStates+68+1
 1205 0ae0 6091 0000 		lds r22,bankStates+68+2
 1206 0ae4 7091 0000 		lds r23,bankStates+68+3
 1207 0ae8 8091 0000 		lds r24,bankStates+57
 1208 0aec 9091 0000 		lds r25,bankStates+57+1
 1209 0af0 A091 0000 		lds r26,bankStates+57+2
 1210 0af4 B091 0000 		lds r27,bankStates+57+3
 1211 0af8 4817      		cp r20,r24
 1212 0afa 5907      		cpc r21,r25
 1213 0afc 6A07      		cpc r22,r26
 1214 0afe 7B07      		cpc r23,r27
 1215 0b00 01F4      		brne .L70
 739:WTPA.c        **** 				{
 740:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1216               		.loc 1 740 0
 1217 0b02 8091 0000 		lds r24,bankStates+61
 1218 0b06 9091 0000 		lds r25,bankStates+61+1
 1219 0b0a A091 0000 		lds r26,bankStates+61+2
 1220 0b0e B091 0000 		lds r27,bankStates+61+3
 1221 0b12 00C0      		rjmp .L97
 1222               	.L70:
 741:WTPA.c        **** 				}
 742:WTPA.c        **** 				else
 743:WTPA.c        **** 				{
 744:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1223               		.loc 1 744 0
 1224 0b14 4091 0000 		lds r20,bankStates+68
 1225 0b18 5091 0000 		lds r21,bankStates+68+1
 1226 0b1c 6091 0000 		lds r22,bankStates+68+2
 1227 0b20 7091 0000 		lds r23,bankStates+68+3
 1228 0b24 8091 0000 		lds r24,bankStates+49
 1229 0b28 9091 0000 		lds r25,bankStates+49+1
 1230 0b2c A091 0000 		lds r26,bankStates+49+2
 1231 0b30 B091 0000 		lds r27,bankStates+49+3
 1232 0b34 4817      		cp r20,r24
 1233 0b36 5907      		cpc r21,r25
 1234 0b38 6A07      		cpc r22,r26
 1235 0b3a 7B07      		cpc r23,r27
 1236 0b3c 01F4      		brne .L71
 745:WTPA.c        **** 					{
 746:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1237               		.loc 1 746 0
 1238 0b3e 8091 0000 		lds r24,bankStates+53
 1239 0b42 9091 0000 		lds r25,bankStates+53+1
 1240 0b46 A091 0000 		lds r26,bankStates+53+2
 1241 0b4a B091 0000 		lds r27,bankStates+53+3
 1242 0b4e 00C0      		rjmp .L97
 1243               	.L71:
 747:WTPA.c        **** 					}
 748:WTPA.c        **** 					else
 749:WTPA.c        **** 					{
 750:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1244               		.loc 1 750 0
 1245 0b50 8091 0000 		lds r24,bankStates+68
 1246 0b54 9091 0000 		lds r25,bankStates+68+1
 1247 0b58 A091 0000 		lds r26,bankStates+68+2
 1248 0b5c B091 0000 		lds r27,bankStates+68+3
 1249 0b60 0197      		sbiw r24,1
 1250 0b62 A109      		sbc r26,__zero_reg__
 1251 0b64 B109      		sbc r27,__zero_reg__
 1252               	.L97:
 1253 0b66 8093 0000 		sts bankStates+68,r24
 1254 0b6a 9093 0000 		sts bankStates+68+1,r25
 1255 0b6e A093 0000 		sts bankStates+68+2,r26
 1256 0b72 B093 0000 		sts bankStates+68+3,r27
 1257               	.L63:
 751:WTPA.c        **** 					}
 752:WTPA.c        **** 				}
 753:WTPA.c        **** 			}
 754:WTPA.c        **** 		}
 755:WTPA.c        **** 
 756:WTPA.c        **** 		// Done with addy, read RAM.
 757:WTPA.c        **** 
 758:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 1258               		.loc 1 758 0
 1259 0b76 83B1      		in r24,0x3
 1260               	.LVL23:
 759:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1261               		.loc 1 759 0
 1262 0b78 129A      		sbi 0x2,2
 760:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1263               		.loc 1 760 0
 1264 0b7a 9FEF      		ldi r25,lo8(-1)
 1265 0b7c 94B9      		out 0x4,r25
 1266               	.L102:
 761:WTPA.c        **** 
 762:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1267               		.loc 1 762 0
 1268 0b7e 9091 0000 		lds r25,bankStates+45
 1269 0b82 9923      		tst r25
 1270 0b84 01F4      		brne .+2
 1271 0b86 00C0      		rjmp .L53
 763:WTPA.c        **** 		{
 764:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1272               		.loc 1 764 0
 1273 0b88 8058      		subi r24,lo8(-(-128))
 1274               	.LVL24:
 765:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1275               		.loc 1 765 0
 1276 0b8a 9091 0000 		lds r25,bankStates+45
 1277 0b8e 2FEF      		ldi r18,lo8(-1)
 1278 0b90 30E0      		ldi r19,0
 1279 0b92 092E      		mov r0,r25
 1280 0b94 00C0      		rjmp 2f
 1281               		1:
 1282 0b96 220F      		lsl r18
 1283               		2:
 1284 0b98 0A94      		dec r0
 1285 0b9a 02F4      		brpl 1b
 1286 0b9c 8223      		and r24,r18
 1287               	.LVL25:
 766:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1288               		.loc 1 766 0
 1289 0b9e 8058      		subi r24,lo8(-(-128))
 1290               	.LVL26:
 1291 0ba0 00C0      		rjmp .L53
 1292               	.LVL27:
 1293               	.L58:
 767:WTPA.c        **** 		}
 768:WTPA.c        **** 		break;
 769:WTPA.c        **** 
 770:WTPA.c        **** 		case AUDIO_OVERDUB:
 771:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 772:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 773:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 1294               		.loc 1 773 0
 1295 0ba2 8091 0000 		lds r24,bankStates+68
 1296 0ba6 9091 0000 		lds r25,bankStates+68+1
 1297 0baa A091 0000 		lds r26,bankStates+68+2
 1298 0bae B091 0000 		lds r27,bankStates+68+3
 1299 0bb2 85B9      		out 0x5,r24
 774:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 1300               		.loc 1 774 0
 1301 0bb4 139A      		sbi 0x2,3
 775:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 1302               		.loc 1 775 0
 1303 0bb6 1398      		cbi 0x2,3
 776:WTPA.c        **** 
 777:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 1304               		.loc 1 777 0
 1305 0bb8 8091 0000 		lds r24,bankStates+68
 1306 0bbc 9091 0000 		lds r25,bankStates+68+1
 1307 0bc0 A091 0000 		lds r26,bankStates+68+2
 1308 0bc4 B091 0000 		lds r27,bankStates+68+3
 1309 0bc8 892F      		mov r24,r25
 1310 0bca 9A2F      		mov r25,r26
 1311 0bcc AB2F      		mov r26,r27
 1312 0bce BB27      		clr r27
 1313 0bd0 85B9      		out 0x5,r24
 778:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 1314               		.loc 1 778 0
 1315 0bd2 149A      		sbi 0x2,4
 779:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 1316               		.loc 1 779 0
 1317 0bd4 1498      		cbi 0x2,4
 780:WTPA.c        **** 
 781:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 1318               		.loc 1 781 0
 1319 0bd6 8091 0000 		lds r24,bankStates+68
 1320 0bda 9091 0000 		lds r25,bankStates+68+1
 1321 0bde A091 0000 		lds r26,bankStates+68+2
 1322 0be2 B091 0000 		lds r27,bankStates+68+3
 1323 0be6 CD01      		movw r24,r26
 1324 0be8 AA27      		clr r26
 1325 0bea BB27      		clr r27
 1326 0bec 8770      		andi r24,7
 1327 0bee 9927      		clr r25
 1328 0bf0 AA27      		clr r26
 1329 0bf2 BB27      		clr r27
 1330 0bf4 8868      		ori r24,136
 1331 0bf6 88B9      		out 0x8,r24
 782:WTPA.c        **** 
 783:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1332               		.loc 1 783 0
 1333 0bf8 14B8      		out 0x4,__zero_reg__
 784:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1334               		.loc 1 784 0
 1335 0bfa 1298      		cbi 0x2,2
 785:WTPA.c        **** 
 786:WTPA.c        **** 		// Do some operations while we wait for the data bus to settle from turnaround.
 787:WTPA.c        **** 
 788:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1336               		.loc 1 788 0
 1337 0bfc 8091 0000 		lds r24,bankStates+43
 1338 0c00 8823      		tst r24
 1339 0c02 01F4      		brne .+2
 1340 0c04 00C0      		rjmp .L72
 789:WTPA.c        **** 		{
 790:WTPA.c        **** 			// Slice first, only worry about forward ###
 791:WTPA.c        **** 
 792:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1341               		.loc 1 792 0
 1342 0c06 8091 0000 		lds r24,sliceRemaining+4
 1343 0c0a 9091 0000 		lds r25,sliceRemaining+4+1
 1344 0c0e A091 0000 		lds r26,sliceRemaining+4+2
 1345 0c12 B091 0000 		lds r27,sliceRemaining+4+3
 1346 0c16 892B      		or r24,r25
 1347 0c18 8A2B      		or r24,r26
 1348 0c1a 8B2B      		or r24,r27
 1349 0c1c 01F0      		breq .L73
 793:WTPA.c        **** 			{
 794:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1350               		.loc 1 794 0
 1351 0c1e 8091 0000 		lds r24,bankStates+68
 1352 0c22 9091 0000 		lds r25,bankStates+68+1
 1353 0c26 A091 0000 		lds r26,bankStates+68+2
 1354 0c2a B091 0000 		lds r27,bankStates+68+3
 1355 0c2e 0197      		sbiw r24,1
 1356 0c30 A109      		sbc r26,__zero_reg__
 1357 0c32 B109      		sbc r27,__zero_reg__
 1358 0c34 8093 0000 		sts bankStates+68,r24
 1359 0c38 9093 0000 		sts bankStates+68+1,r25
 1360 0c3c A093 0000 		sts bankStates+68+2,r26
 1361 0c40 B093 0000 		sts bankStates+68+3,r27
 795:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1362               		.loc 1 795 0
 1363 0c44 8091 0000 		lds r24,sliceRemaining+4
 1364 0c48 9091 0000 		lds r25,sliceRemaining+4+1
 1365 0c4c A091 0000 		lds r26,sliceRemaining+4+2
 1366 0c50 B091 0000 		lds r27,sliceRemaining+4+3
 1367 0c54 0197      		sbiw r24,1
 1368 0c56 A109      		sbc r26,__zero_reg__
 1369 0c58 B109      		sbc r27,__zero_reg__
 1370 0c5a 8093 0000 		sts sliceRemaining+4,r24
 1371 0c5e 9093 0000 		sts sliceRemaining+4+1,r25
 1372 0c62 A093 0000 		sts sliceRemaining+4+2,r26
 1373 0c66 B093 0000 		sts sliceRemaining+4+3,r27
 1374 0c6a 00C0      		rjmp .L74
 1375               	.L73:
 796:WTPA.c        **** 			}
 797:WTPA.c        **** 			else	// Slice done, jump to new slice.
 798:WTPA.c        **** 			{
 799:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1376               		.loc 1 799 0
 1377 0c6c 8091 0000 		lds r24,sliceSize+4
 1378 0c70 9091 0000 		lds r25,sliceSize+4+1
 1379 0c74 A091 0000 		lds r26,sliceSize+4+2
 1380 0c78 B091 0000 		lds r27,sliceSize+4+3
 1381 0c7c 8093 0000 		sts sliceRemaining+4,r24
 1382 0c80 9093 0000 		sts sliceRemaining+4+1,r25
 1383 0c84 A093 0000 		sts sliceRemaining+4+2,r26
 1384 0c88 B093 0000 		sts sliceRemaining+4+3,r27
 800:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1385               		.loc 1 800 0
 1386 0c8c 8091 0000 		lds r24,granularPositionArrayPointer+1
 1387 0c90 8F5F      		subi r24,lo8(-(1))
 1388 0c92 8093 0000 		sts granularPositionArrayPointer+1,r24
 801:WTPA.c        **** 
 802:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1389               		.loc 1 802 0
 1390 0c96 9091 0000 		lds r25,granularPositionArrayPointer+1
 1391 0c9a 8091 0000 		lds r24,bankStates+43
 1392 0c9e 9813      		cpse r25,r24
 1393 0ca0 00C0      		rjmp .L75
 803:WTPA.c        **** 				{
 804:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1394               		.loc 1 804 0
 1395 0ca2 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1396               	.L75:
 805:WTPA.c        **** 				}
 806:WTPA.c        **** 
 807:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1397               		.loc 1 807 0
 1398 0ca6 E091 0000 		lds r30,granularPositionArrayPointer+1
 1399 0caa 2091 0000 		lds r18,sliceSize+4
 1400 0cae 3091 0000 		lds r19,sliceSize+4+1
 1401 0cb2 4091 0000 		lds r20,sliceSize+4+2
 1402 0cb6 5091 0000 		lds r21,sliceSize+4+3
 1403 0cba F0E0      		ldi r31,0
 1404 0cbc E050      		subi r30,lo8(-(granularPositionArray+128))
 1405 0cbe F040      		sbci r31,hi8(-(granularPositionArray+128))
 1406 0cc0 A081      		ld r26,Z
 1407 0cc2 B0E0      		ldi r27,0
 1408 0cc4 0E94 0000 		call __muluhisi3
 1409 0cc8 0FEF      		ldi r16,lo8(-1)
 1410 0cca 1FEF      		ldi r17,lo8(-1)
 1411 0ccc 27E0      		ldi r18,lo8(7)
 1412 0cce 30E0      		ldi r19,0
 1413 0cd0 061B      		sub r16,r22
 1414 0cd2 170B      		sbc r17,r23
 1415 0cd4 280B      		sbc r18,r24
 1416 0cd6 390B      		sbc r19,r25
 1417 0cd8 0093 0000 		sts bankStates+68,r16
 1418 0cdc 1093 0000 		sts bankStates+68+1,r17
 1419 0ce0 2093 0000 		sts bankStates+68+2,r18
 1420 0ce4 3093 0000 		sts bankStates+68+3,r19
 1421 0ce8 00C0      		rjmp .L74
 1422               	.L72:
 808:WTPA.c        **** 			}
 809:WTPA.c        **** 		}
 810:WTPA.c        **** 		else
 811:WTPA.c        **** 		{
 812:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1423               		.loc 1 812 0
 1424 0cea 8091 0000 		lds r24,bankStates+40
 813:WTPA.c        **** 			{
 814:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1425               		.loc 1 814 0
 1426 0cee 4091 0000 		lds r20,bankStates+68
 1427 0cf2 5091 0000 		lds r21,bankStates+68+1
 1428 0cf6 6091 0000 		lds r22,bankStates+68+2
 1429 0cfa 7091 0000 		lds r23,bankStates+68+3
 812:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1430               		.loc 1 812 0
 1431 0cfe 8111      		cpse r24,__zero_reg__
 1432 0d00 00C0      		rjmp .L76
 1433               		.loc 1 814 0
 1434 0d02 8091 0000 		lds r24,bankStates+61
 1435 0d06 9091 0000 		lds r25,bankStates+61+1
 1436 0d0a A091 0000 		lds r26,bankStates+61+2
 1437 0d0e B091 0000 		lds r27,bankStates+61+3
 1438 0d12 4817      		cp r20,r24
 1439 0d14 5907      		cpc r21,r25
 1440 0d16 6A07      		cpc r22,r26
 1441 0d18 7B07      		cpc r23,r27
 1442 0d1a 01F4      		brne .L77
 1443               		.loc 1 814 0 is_stmt 0 discriminator 1
 1444 0d1c 8091 0000 		lds r24,bankStates+37
 1445 0d20 8130      		cpi r24,lo8(1)
 1446 0d22 01F4      		brne .L77
 1447 0d24 00C0      		rjmp .L98
 1448               	.L77:
 815:WTPA.c        **** 				{
 816:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 817:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 818:WTPA.c        **** 				}
 819:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1449               		.loc 1 819 0 is_stmt 1
 1450 0d26 4091 0000 		lds r20,bankStates+68
 1451 0d2a 5091 0000 		lds r21,bankStates+68+1
 1452 0d2e 6091 0000 		lds r22,bankStates+68+2
 1453 0d32 7091 0000 		lds r23,bankStates+68+3
 1454 0d36 8091 0000 		lds r24,bankStates+61
 1455 0d3a 9091 0000 		lds r25,bankStates+61+1
 1456 0d3e A091 0000 		lds r26,bankStates+61+2
 1457 0d42 B091 0000 		lds r27,bankStates+61+3
 1458 0d46 4817      		cp r20,r24
 1459 0d48 5907      		cpc r21,r25
 1460 0d4a 6A07      		cpc r22,r26
 1461 0d4c 7B07      		cpc r23,r27
 1462 0d4e 01F4      		brne .L78
 820:WTPA.c        **** 				{
 821:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1463               		.loc 1 821 0
 1464 0d50 8091 0000 		lds r24,bankStates+57
 1465 0d54 9091 0000 		lds r25,bankStates+57+1
 1466 0d58 A091 0000 		lds r26,bankStates+57+2
 1467 0d5c B091 0000 		lds r27,bankStates+57+3
 1468 0d60 00C0      		rjmp .L99
 1469               	.L78:
 822:WTPA.c        **** 				}
 823:WTPA.c        **** 				else
 824:WTPA.c        **** 				{
 825:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1470               		.loc 1 825 0
 1471 0d62 4091 0000 		lds r20,bankStates+68
 1472 0d66 5091 0000 		lds r21,bankStates+68+1
 1473 0d6a 6091 0000 		lds r22,bankStates+68+2
 1474 0d6e 7091 0000 		lds r23,bankStates+68+3
 1475 0d72 8091 0000 		lds r24,bankStates+53
 1476 0d76 9091 0000 		lds r25,bankStates+53+1
 1477 0d7a A091 0000 		lds r26,bankStates+53+2
 1478 0d7e B091 0000 		lds r27,bankStates+53+3
 1479 0d82 4817      		cp r20,r24
 1480 0d84 5907      		cpc r21,r25
 1481 0d86 6A07      		cpc r22,r26
 1482 0d88 7B07      		cpc r23,r27
 1483 0d8a 01F4      		brne .L79
 826:WTPA.c        **** 					{
 827:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1484               		.loc 1 827 0
 1485 0d8c 8091 0000 		lds r24,bankStates+49
 1486 0d90 9091 0000 		lds r25,bankStates+49+1
 1487 0d94 A091 0000 		lds r26,bankStates+49+2
 1488 0d98 B091 0000 		lds r27,bankStates+49+3
 1489 0d9c 00C0      		rjmp .L99
 1490               	.L79:
 828:WTPA.c        **** 					}
 829:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 830:WTPA.c        **** 					{
 831:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1491               		.loc 1 831 0
 1492 0d9e 8091 0000 		lds r24,bankStates+68
 1493 0da2 9091 0000 		lds r25,bankStates+68+1
 1494 0da6 A091 0000 		lds r26,bankStates+68+2
 1495 0daa B091 0000 		lds r27,bankStates+68+3
 1496 0dae 0196      		adiw r24,1
 1497 0db0 A11D      		adc r26,__zero_reg__
 1498 0db2 B11D      		adc r27,__zero_reg__
 1499 0db4 00C0      		rjmp .L99
 1500               	.L76:
 832:WTPA.c        **** 					}
 833:WTPA.c        **** 				}
 834:WTPA.c        **** 			}
 835:WTPA.c        **** 			else	// Going forward through the sample.
 836:WTPA.c        **** 			{
 837:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1501               		.loc 1 837 0
 1502 0db6 8091 0000 		lds r24,bankStates+57
 1503 0dba 9091 0000 		lds r25,bankStates+57+1
 1504 0dbe A091 0000 		lds r26,bankStates+57+2
 1505 0dc2 B091 0000 		lds r27,bankStates+57+3
 1506 0dc6 4817      		cp r20,r24
 1507 0dc8 5907      		cpc r21,r25
 1508 0dca 6A07      		cpc r22,r26
 1509 0dcc 7B07      		cpc r23,r27
 1510 0dce 01F4      		brne .L80
 1511               		.loc 1 837 0 is_stmt 0 discriminator 1
 1512 0dd0 8091 0000 		lds r24,bankStates+37
 1513 0dd4 8130      		cpi r24,lo8(1)
 1514 0dd6 01F4      		brne .L80
 1515               	.L98:
 838:WTPA.c        **** 				{
 839:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1516               		.loc 1 839 0 is_stmt 1
 1517 0dd8 1092 0000 		sts bankStates+36,__zero_reg__
 840:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1518               		.loc 1 840 0
 1519 0ddc 1092 0000 		sts bankStates+46,__zero_reg__
 1520 0de0 00C0      		rjmp .L74
 1521               	.L80:
 841:WTPA.c        **** 				}
 842:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1522               		.loc 1 842 0
 1523 0de2 4091 0000 		lds r20,bankStates+68
 1524 0de6 5091 0000 		lds r21,bankStates+68+1
 1525 0dea 6091 0000 		lds r22,bankStates+68+2
 1526 0dee 7091 0000 		lds r23,bankStates+68+3
 1527 0df2 8091 0000 		lds r24,bankStates+57
 1528 0df6 9091 0000 		lds r25,bankStates+57+1
 1529 0dfa A091 0000 		lds r26,bankStates+57+2
 1530 0dfe B091 0000 		lds r27,bankStates+57+3
 1531 0e02 4817      		cp r20,r24
 1532 0e04 5907      		cpc r21,r25
 1533 0e06 6A07      		cpc r22,r26
 1534 0e08 7B07      		cpc r23,r27
 1535 0e0a 01F4      		brne .L81
 843:WTPA.c        **** 				{
 844:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1536               		.loc 1 844 0
 1537 0e0c 8091 0000 		lds r24,bankStates+61
 1538 0e10 9091 0000 		lds r25,bankStates+61+1
 1539 0e14 A091 0000 		lds r26,bankStates+61+2
 1540 0e18 B091 0000 		lds r27,bankStates+61+3
 1541 0e1c 00C0      		rjmp .L99
 1542               	.L81:
 845:WTPA.c        **** 				}
 846:WTPA.c        **** 				else
 847:WTPA.c        **** 				{
 848:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1543               		.loc 1 848 0
 1544 0e1e 4091 0000 		lds r20,bankStates+68
 1545 0e22 5091 0000 		lds r21,bankStates+68+1
 1546 0e26 6091 0000 		lds r22,bankStates+68+2
 1547 0e2a 7091 0000 		lds r23,bankStates+68+3
 1548 0e2e 8091 0000 		lds r24,bankStates+49
 1549 0e32 9091 0000 		lds r25,bankStates+49+1
 1550 0e36 A091 0000 		lds r26,bankStates+49+2
 1551 0e3a B091 0000 		lds r27,bankStates+49+3
 1552 0e3e 4817      		cp r20,r24
 1553 0e40 5907      		cpc r21,r25
 1554 0e42 6A07      		cpc r22,r26
 1555 0e44 7B07      		cpc r23,r27
 1556 0e46 01F4      		brne .L82
 849:WTPA.c        **** 					{
 850:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1557               		.loc 1 850 0
 1558 0e48 8091 0000 		lds r24,bankStates+53
 1559 0e4c 9091 0000 		lds r25,bankStates+53+1
 1560 0e50 A091 0000 		lds r26,bankStates+53+2
 1561 0e54 B091 0000 		lds r27,bankStates+53+3
 1562 0e58 00C0      		rjmp .L99
 1563               	.L82:
 851:WTPA.c        **** 					}
 852:WTPA.c        **** 					else
 853:WTPA.c        **** 					{
 854:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1564               		.loc 1 854 0
 1565 0e5a 8091 0000 		lds r24,bankStates+68
 1566 0e5e 9091 0000 		lds r25,bankStates+68+1
 1567 0e62 A091 0000 		lds r26,bankStates+68+2
 1568 0e66 B091 0000 		lds r27,bankStates+68+3
 1569 0e6a 0197      		sbiw r24,1
 1570 0e6c A109      		sbc r26,__zero_reg__
 1571 0e6e B109      		sbc r27,__zero_reg__
 1572               	.L99:
 1573 0e70 8093 0000 		sts bankStates+68,r24
 1574 0e74 9093 0000 		sts bankStates+68+1,r25
 1575 0e78 A093 0000 		sts bankStates+68+2,r26
 1576 0e7c B093 0000 		sts bankStates+68+3,r27
 1577               	.L74:
 855:WTPA.c        **** 					}
 856:WTPA.c        **** 				}
 857:WTPA.c        **** 			}
 858:WTPA.c        **** 		}
 859:WTPA.c        **** 
 860:WTPA.c        **** 		// Finished with addy stuff, now finish data transfer
 861:WTPA.c        **** 
 862:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 1578               		.loc 1 862 0
 1579 0e80 83B1      		in r24,0x3
 1580               	.LVL28:
 863:WTPA.c        **** 
 864:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1581               		.loc 1 864 0
 1582 0e82 129A      		sbi 0x2,2
 865:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1583               		.loc 1 865 0
 1584 0e84 9FEF      		ldi r25,lo8(-1)
 1585 0e86 94B9      		out 0x4,r25
 866:WTPA.c        **** 
 867:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1586               		.loc 1 867 0
 1587 0e88 9091 0000 		lds r25,bankStates+45
 1588 0e8c 9923      		tst r25
 1589 0e8e 01F0      		breq .L83
 868:WTPA.c        **** 		{
 869:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1590               		.loc 1 869 0
 1591 0e90 8058      		subi r24,lo8(-(-128))
 1592               	.LVL29:
 870:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1593               		.loc 1 870 0
 1594 0e92 9091 0000 		lds r25,bankStates+45
 1595 0e96 2FEF      		ldi r18,lo8(-1)
 1596 0e98 30E0      		ldi r19,0
 1597 0e9a 092E      		mov r0,r25
 1598 0e9c 00C0      		rjmp 2f
 1599               		1:
 1600 0e9e 220F      		lsl r18
 1601               		2:
 1602 0ea0 0A94      		dec r0
 1603 0ea2 02F4      		brpl 1b
 1604 0ea4 8223      		and r24,r18
 1605               	.LVL30:
 871:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1606               		.loc 1 871 0
 1607 0ea6 8058      		subi r24,lo8(-(-128))
 1608               	.LVL31:
 1609               	.L83:
 872:WTPA.c        **** 		}
 873:WTPA.c        **** 
 874:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 1610               		.loc 1 874 0
 1611 0ea8 2091 0000 		lds r18,adcByte
 1612 0eac 3327      		clr r19
 1613 0eae 27FD      		sbrc r18,7
 1614 0eb0 3095      		com r19
 1615 0eb2 280F      		add r18,r24
 1616 0eb4 311D      		adc r19,__zero_reg__
 1617 0eb6 87FD      		sbrc r24,7
 1618 0eb8 3A95      		dec r19
 1619 0eba 2038      		cpi r18,-128
 1620 0ebc 9FEF      		ldi r25,-1
 1621 0ebe 3907      		cpc r19,r25
 1622 0ec0 04F4      		brge .L84
 1623 0ec2 20E8      		ldi r18,lo8(-128)
 1624 0ec4 3FEF      		ldi r19,lo8(-1)
 1625               	.L84:
 1626               	.LVL32:
 875:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 876:WTPA.c        **** 		{
 877:WTPA.c        **** 			sum=127;
 878:WTPA.c        **** 		}
 879:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 880:WTPA.c        **** 		{
 881:WTPA.c        **** 			sum=-128;
 882:WTPA.c        **** 		}
 883:WTPA.c        **** 
 884:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 1627               		.loc 1 884 0
 1628 0ec6 2038      		cpi r18,-128
 1629 0ec8 3105      		cpc r19,__zero_reg__
 1630 0eca 04F0      		brlt .L85
 1631 0ecc 2FE7      		ldi r18,lo8(127)
 1632 0ece 30E0      		ldi r19,0
 1633               	.LVL33:
 1634               	.L85:
 1635 0ed0 25B9      		out 0x5,r18
 885:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 1636               		.loc 1 885 0
 1637 0ed2 1198      		cbi 0x2,1
 886:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 1638               		.loc 1 886 0
 1639 0ed4 119A      		sbi 0x2,1
 887:WTPA.c        **** 		break;
 1640               		.loc 1 887 0
 1641 0ed6 00C0      		rjmp .L53
 1642               	.LVL34:
 1643               	.L86:
 608:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 1644               		.loc 1 608 0
 1645 0ed8 80E0      		ldi r24,0
 1646               	.LVL35:
 1647               	.L53:
 1648               	/* epilogue start */
 888:WTPA.c        **** 	}
 889:WTPA.c        **** 
 890:WTPA.c        **** 	return(outputByte);
 891:WTPA.c        **** }
 1649               		.loc 1 891 0
 1650 0eda 1F91      		pop r17
 1651 0edc 0F91      		pop r16
 1652 0ede 0895      		ret
 1653               		.cfi_endproc
 1654               	.LFE2:
 1657               	OutputMultiplyBanks:
 1658               	.LFB3:
 892:WTPA.c        **** 
 893:WTPA.c        **** //-----------------------------------------------------------------------------
 894:WTPA.c        **** //-----------------------------------------------------------------------------
 895:WTPA.c        **** // DAC output handling and sample combination functions:
 896:WTPA.c        **** // These functions are called (via pointer) everytime a bank updates.
 897:WTPA.c        **** // They worry about summing (or whatever) the different audio sources and spitting them out on the 
 898:WTPA.c        **** //-----------------------------------------------------------------------------
 899:WTPA.c        **** //-----------------------------------------------------------------------------
 900:WTPA.c        **** 
 901:WTPA.c        **** // Globals used in the audio and output update functions.
 902:WTPA.c        **** 
 903:WTPA.c        **** typedef void OUTPUT_FUNCTION(void);	// Creates a datatype -- a void function called OUTPUT_FUNCTION
 904:WTPA.c        **** 
 905:WTPA.c        **** OUTPUT_FUNCTION					// Assigns a pointer called UpdateOutput to an instance of OUTPUT_FUNCTION()
 906:WTPA.c        **** 	*UpdateOutput;
 907:WTPA.c        **** 
 908:WTPA.c        **** static signed char
 909:WTPA.c        **** 	extIsrOutputBank0,
 910:WTPA.c        **** 	extIsrOutputBank1,
 911:WTPA.c        **** 	midiOutputBank0,
 912:WTPA.c        **** 	midiOutputBank1,
 913:WTPA.c        **** 	sdStreamOutput;		// Contribution to DAC coming directly off the SD card
 914:WTPA.c        **** 
 915:WTPA.c        **** static unsigned char
 916:WTPA.c        **** 	lastDacByte;	// Very possible we haven't changed output values since last time (like for instance 
 917:WTPA.c        **** 
 918:WTPA.c        **** static void OutputMultiplyBanks(void)
 919:WTPA.c        **** // Multiply the audio output of banks0 and 1 and spit it out
 920:WTPA.c        **** {
 1659               		.loc 1 920 0
 1660               		.cfi_startproc
 1661               	/* prologue: function */
 1662               	/* frame size = 0 */
 1663               	/* stack size = 0 */
 1664               	.L__stack_usage = 0
 921:WTPA.c        **** 	signed int
 922:WTPA.c        **** 		sum0,			// Temporary variables for saturated adds, multiplies, other math.
 923:WTPA.c        **** 		sum1;
 924:WTPA.c        **** 
 925:WTPA.c        **** 	unsigned char
 926:WTPA.c        **** 		output;			// What to put on the DAC
 927:WTPA.c        **** 
 928:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1665               		.loc 1 928 0
 1666 0ee0 8091 0000 		lds r24,extIsrOutputBank0
 1667 0ee4 2091 0000 		lds r18,midiOutputBank0
 1668 0ee8 3327      		clr r19
 1669 0eea 27FD      		sbrc r18,7
 1670 0eec 3095      		com r19
 1671 0eee 280F      		add r18,r24
 1672 0ef0 311D      		adc r19,__zero_reg__
 1673 0ef2 87FD      		sbrc r24,7
 1674 0ef4 3A95      		dec r19
 1675 0ef6 2038      		cpi r18,-128
 1676 0ef8 4FEF      		ldi r20,-1
 1677 0efa 3407      		cpc r19,r20
 1678 0efc 04F4      		brge .L104
 1679 0efe 20E8      		ldi r18,lo8(-128)
 1680 0f00 3FEF      		ldi r19,lo8(-1)
 1681               	.L104:
 1682               	.LVL36:
 929:WTPA.c        **** 	if(sum0>127)		// Pin high.
 930:WTPA.c        **** 	{
 931:WTPA.c        **** 		sum0=127;
 932:WTPA.c        **** 	}
 933:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
 934:WTPA.c        **** 	{
 935:WTPA.c        **** 		sum0=-128;
 936:WTPA.c        **** 	}
 937:WTPA.c        **** 
 938:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1683               		.loc 1 938 0
 1684 0f02 4091 0000 		lds r20,extIsrOutputBank1
 1685 0f06 8091 0000 		lds r24,midiOutputBank1
 1686 0f0a 9927      		clr r25
 1687 0f0c 87FD      		sbrc r24,7
 1688 0f0e 9095      		com r25
 1689 0f10 840F      		add r24,r20
 1690 0f12 911D      		adc r25,__zero_reg__
 1691 0f14 47FD      		sbrc r20,7
 1692 0f16 9A95      		dec r25
 1693 0f18 8138      		cpi r24,-127
 1694 0f1a 4FEF      		ldi r20,-1
 1695 0f1c 9407      		cpc r25,r20
 1696 0f1e 04F4      		brge .L105
 1697 0f20 81E8      		ldi r24,lo8(-127)
 1698 0f22 9FEF      		ldi r25,lo8(-1)
 1699               	.L105:
 1700               	.LVL37:
 939:WTPA.c        **** 	if(sum1>127)		// Pin high.
 940:WTPA.c        **** 	{
 941:WTPA.c        **** 		sum1=127;
 942:WTPA.c        **** 	}
 943:WTPA.c        **** 	else if(sum1<-127)		// Pin low.  (was pegged to -128)
 944:WTPA.c        **** 	{
 945:WTPA.c        **** 		sum1=-127;
 946:WTPA.c        **** 	}
 947:WTPA.c        **** 
 948:WTPA.c        **** 	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale ou
 1701               		.loc 1 948 0
 1702 0f24 2038      		cpi r18,-128
 1703 0f26 3105      		cpc r19,__zero_reg__
 1704 0f28 04F0      		brlt .L106
 1705 0f2a 2FE7      		ldi r18,lo8(127)
 1706 0f2c 30E0      		ldi r19,0
 1707               	.LVL38:
 1708               	.L106:
 1709 0f2e 8038      		cpi r24,-128
 1710 0f30 9105      		cpc r25,__zero_reg__
 1711 0f32 04F0      		brlt .L107
 1712 0f34 8FE7      		ldi r24,lo8(127)
 1713 0f36 90E0      		ldi r25,0
 1714               	.LVL39:
 1715               	.L107:
 1716 0f38 289F      		mul r18,r24
 1717 0f3a A001      		movw r20,r0
 1718 0f3c 299F      		mul r18,r25
 1719 0f3e 500D      		add r21,r0
 1720 0f40 389F      		mul r19,r24
 1721 0f42 500D      		add r21,r0
 1722 0f44 1124      		clr r1
 1723 0f46 57FF      		sbrs r21,7
 1724 0f48 00C0      		rjmp .L108
 1725 0f4a 415C      		subi r20,-63
 1726 0f4c 5F4F      		sbci r21,-1
 1727               	.L108:
 1728 0f4e CA01      		movw r24,r20
 1729 0f50 46E0      		ldi r20,6
 1730               		1:
 1731 0f52 9595      		asr r25
 1732 0f54 8795      		ror r24
 1733 0f56 4A95      		dec r20
 1734 0f58 01F4      		brne 1b
 949:WTPA.c        **** 
 950:WTPA.c        **** //@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the re
 951:WTPA.c        **** //@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide 
 952:WTPA.c        **** 
 953:WTPA.c        **** 	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
 1735               		.loc 1 953 0
 1736 0f5a 8058      		subi r24,128
 1737 0f5c 9095      		com r25
 1738 0f5e 282F      		mov r18,r24
 1739               	.LVL40:
 954:WTPA.c        **** 
 955:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1740               		.loc 1 955 0
 1741 0f60 3091 0000 		lds r19,lastDacByte
 1742 0f64 8317      		cp r24,r19
 1743 0f66 01F0      		breq .L109
 956:WTPA.c        **** 	{
 957:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1744               		.loc 1 957 0
 1745 0f68 9FEF      		ldi r25,lo8(-1)
 1746 0f6a 94B9      		out 0x4,r25
 958:WTPA.c        **** 
 959:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1747               		.loc 1 959 0
 1748 0f6c 85B9      		out 0x5,r24
 960:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1749               		.loc 1 960 0
 1750 0f6e 159A      		sbi 0x2,5
 961:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1751               		.loc 1 961 0
 1752 0f70 1598      		cbi 0x2,5
 1753               	.L109:
 962:WTPA.c        **** 	}
 963:WTPA.c        **** 
 964:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1754               		.loc 1 964 0
 1755 0f72 2093 0000 		sts lastDacByte,r18
 1756 0f76 0895      		ret
 1757               		.cfi_endproc
 1758               	.LFE3:
 1761               	OutputAddBanks:
 1762               	.LFB4:
 965:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
 966:WTPA.c        **** }
 967:WTPA.c        **** 
 968:WTPA.c        **** static void OutputAddBanks(void)
 969:WTPA.c        **** // Add audio from the two banks and spit it out (normally what we do)
 970:WTPA.c        **** {
 1763               		.loc 1 970 0
 1764               		.cfi_startproc
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 0 */
 1768               	.L__stack_usage = 0
 971:WTPA.c        **** 	signed int
 972:WTPA.c        **** 		sum0;				// Temporary variables for saturated adds, multiplies, other math.
 973:WTPA.c        **** 
 974:WTPA.c        **** 	unsigned char
 975:WTPA.c        **** 		output;			// What to put on the DAC
 976:WTPA.c        **** 
 977:WTPA.c        **** //	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everythi
 978:WTPA.c        **** 	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum e
 1769               		.loc 1 978 0
 1770 0f78 2091 0000 		lds r18,extIsrOutputBank0
 1771 0f7c 8091 0000 		lds r24,extIsrOutputBank1
 1772 0f80 9927      		clr r25
 1773 0f82 87FD      		sbrc r24,7
 1774 0f84 9095      		com r25
 1775 0f86 820F      		add r24,r18
 1776 0f88 911D      		adc r25,__zero_reg__
 1777 0f8a 27FD      		sbrc r18,7
 1778 0f8c 9A95      		dec r25
 1779 0f8e 2091 0000 		lds r18,midiOutputBank0
 1780 0f92 820F      		add r24,r18
 1781 0f94 911D      		adc r25,__zero_reg__
 1782 0f96 27FD      		sbrc r18,7
 1783 0f98 9A95      		dec r25
 1784 0f9a 2091 0000 		lds r18,midiOutputBank1
 1785 0f9e 820F      		add r24,r18
 1786 0fa0 911D      		adc r25,__zero_reg__
 1787 0fa2 27FD      		sbrc r18,7
 1788 0fa4 9A95      		dec r25
 1789 0fa6 2091 0000 		lds r18,sdStreamOutput
 1790 0faa 820F      		add r24,r18
 1791 0fac 911D      		adc r25,__zero_reg__
 1792 0fae 27FD      		sbrc r18,7
 1793 0fb0 9A95      		dec r25
 1794 0fb2 8038      		cpi r24,-128
 1795 0fb4 2FEF      		ldi r18,-1
 1796 0fb6 9207      		cpc r25,r18
 1797 0fb8 04F4      		brge .L111
 1798 0fba 80E8      		ldi r24,lo8(-128)
 1799 0fbc 9FEF      		ldi r25,lo8(-1)
 1800               	.L111:
 1801               	.LVL41:
 979:WTPA.c        **** 	if(sum0>127)		// Pin high.
 980:WTPA.c        **** 	{
 981:WTPA.c        **** 		sum0=127;
 982:WTPA.c        **** 	}
 983:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
 984:WTPA.c        **** 	{
 985:WTPA.c        **** 		sum0=-128;
 986:WTPA.c        **** 	}
 987:WTPA.c        **** 	output=(signed char)sum0;		// Cast back to 8 bits.
 988:WTPA.c        **** 	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
 1802               		.loc 1 988 0
 1803 0fbe 8038      		cpi r24,-128
 1804 0fc0 9105      		cpc r25,__zero_reg__
 1805 0fc2 04F0      		brlt .L112
 1806 0fc4 8FE7      		ldi r24,lo8(127)
 1807 0fc6 90E0      		ldi r25,0
 1808               	.LVL42:
 1809               	.L112:
 1810 0fc8 8058      		subi r24,128
 1811 0fca 282F      		mov r18,r24
 1812               	.LVL43:
 989:WTPA.c        **** 
 990:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1813               		.loc 1 990 0
 1814 0fcc 3091 0000 		lds r19,lastDacByte
 1815 0fd0 8317      		cp r24,r19
 1816 0fd2 01F0      		breq .L113
 991:WTPA.c        **** 	{
 992:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1817               		.loc 1 992 0
 1818 0fd4 9FEF      		ldi r25,lo8(-1)
 1819 0fd6 94B9      		out 0x4,r25
 993:WTPA.c        **** 
 994:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1820               		.loc 1 994 0
 1821 0fd8 85B9      		out 0x5,r24
 995:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1822               		.loc 1 995 0
 1823 0fda 159A      		sbi 0x2,5
 996:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1824               		.loc 1 996 0
 1825 0fdc 1598      		cbi 0x2,5
 1826               	.L113:
 997:WTPA.c        **** 	}
 998:WTPA.c        **** 
 999:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1827               		.loc 1 999 0
 1828 0fde 2093 0000 		sts lastDacByte,r18
 1829 0fe2 0895      		ret
 1830               		.cfi_endproc
 1831               	.LFE4:
 1834               	OutputXorBanks:
 1835               	.LFB5:
1000:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1001:WTPA.c        **** }
1002:WTPA.c        **** 
1003:WTPA.c        **** static void OutputXorBanks(void)
1004:WTPA.c        **** // Performs a bitwise XOR and spits out the result
1005:WTPA.c        **** {
 1836               		.loc 1 1005 0
 1837               		.cfi_startproc
 1838               	/* prologue: function */
 1839               	/* frame size = 0 */
 1840               	/* stack size = 0 */
 1841               	.L__stack_usage = 0
1006:WTPA.c        **** 	signed int
1007:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1008:WTPA.c        **** 		sum1;
1009:WTPA.c        **** 
1010:WTPA.c        **** 	unsigned char
1011:WTPA.c        **** 		output;			// What to put on the DAC
1012:WTPA.c        **** 
1013:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1842               		.loc 1 1013 0
 1843 0fe4 2091 0000 		lds r18,extIsrOutputBank0
 1844 0fe8 8091 0000 		lds r24,midiOutputBank0
 1845 0fec 9927      		clr r25
 1846 0fee 87FD      		sbrc r24,7
 1847 0ff0 9095      		com r25
 1848 0ff2 820F      		add r24,r18
 1849 0ff4 911D      		adc r25,__zero_reg__
 1850 0ff6 27FD      		sbrc r18,7
 1851 0ff8 9A95      		dec r25
 1852 0ffa 8038      		cpi r24,-128
 1853 0ffc 2FEF      		ldi r18,-1
 1854 0ffe 9207      		cpc r25,r18
 1855 1000 04F4      		brge .L115
 1856 1002 80E8      		ldi r24,lo8(-128)
 1857 1004 9FEF      		ldi r25,lo8(-1)
 1858               	.L115:
 1859               	.LVL44:
1014:WTPA.c        **** 	if(sum0>127)		// Pin high.
1015:WTPA.c        **** 	{
1016:WTPA.c        **** 		sum0=127;
1017:WTPA.c        **** 	}
1018:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1019:WTPA.c        **** 	{
1020:WTPA.c        **** 		sum0=-128;
1021:WTPA.c        **** 	}
1022:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1860               		.loc 1 1022 0
 1861 1006 4091 0000 		lds r20,extIsrOutputBank1
 1862 100a 2091 0000 		lds r18,midiOutputBank1
 1863 100e 3327      		clr r19
 1864 1010 27FD      		sbrc r18,7
 1865 1012 3095      		com r19
 1866 1014 240F      		add r18,r20
 1867 1016 311D      		adc r19,__zero_reg__
 1868 1018 47FD      		sbrc r20,7
 1869 101a 3A95      		dec r19
 1870 101c 2038      		cpi r18,-128
 1871 101e 4FEF      		ldi r20,-1
 1872 1020 3407      		cpc r19,r20
 1873 1022 04F4      		brge .L116
 1874 1024 20E8      		ldi r18,lo8(-128)
 1875 1026 3FEF      		ldi r19,lo8(-1)
 1876               	.L116:
 1877               	.LVL45:
1023:WTPA.c        **** 	if(sum1>127)		// Pin high.
1024:WTPA.c        **** 	{
1025:WTPA.c        **** 		sum1=127;
1026:WTPA.c        **** 	}
1027:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1028:WTPA.c        **** 	{
1029:WTPA.c        **** 		sum1=-128;
1030:WTPA.c        **** 	}
1031:WTPA.c        **** 	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1878               		.loc 1 1031 0
 1879 1028 2038      		cpi r18,-128
 1880 102a 3105      		cpc r19,__zero_reg__
 1881 102c 04F0      		brlt .L117
 1882 102e 2FE7      		ldi r18,lo8(127)
 1883 1030 30E0      		ldi r19,0
 1884               	.LVL46:
 1885               	.L117:
 1886 1032 2058      		subi r18,128
 1887 1034 3095      		com r19
 1888 1036 8038      		cpi r24,-128
 1889 1038 9105      		cpc r25,__zero_reg__
 1890 103a 04F0      		brlt .L118
 1891 103c 8FE7      		ldi r24,lo8(127)
 1892 103e 90E0      		ldi r25,0
 1893               	.LVL47:
 1894               	.L118:
 1895 1040 8058      		subi r24,128
 1896 1042 9095      		com r25
 1897 1044 8227      		eor r24,r18
 1898               	.LVL48:
1032:WTPA.c        **** 
1033:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1899               		.loc 1 1033 0
 1900 1046 9091 0000 		lds r25,lastDacByte
 1901 104a 8917      		cp r24,r25
 1902 104c 01F0      		breq .L119
1034:WTPA.c        **** 	{
1035:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1903               		.loc 1 1035 0
 1904 104e 9FEF      		ldi r25,lo8(-1)
 1905 1050 94B9      		out 0x4,r25
1036:WTPA.c        **** 
1037:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1906               		.loc 1 1037 0
 1907 1052 85B9      		out 0x5,r24
1038:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1908               		.loc 1 1038 0
 1909 1054 159A      		sbi 0x2,5
1039:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1910               		.loc 1 1039 0
 1911 1056 1598      		cbi 0x2,5
 1912               	.L119:
1040:WTPA.c        **** 	}
1041:WTPA.c        **** 
1042:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1913               		.loc 1 1042 0
 1914 1058 8093 0000 		sts lastDacByte,r24
 1915 105c 0895      		ret
 1916               		.cfi_endproc
 1917               	.LFE5:
 1920               	OutputAndBanks:
 1921               	.LFB6:
1043:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1044:WTPA.c        **** }
1045:WTPA.c        **** 
1046:WTPA.c        **** static void OutputAndBanks(void)
1047:WTPA.c        **** // Performs a bitwise AND and spits out the result
1048:WTPA.c        **** {
 1922               		.loc 1 1048 0
 1923               		.cfi_startproc
 1924               	/* prologue: function */
 1925               	/* frame size = 0 */
 1926               	/* stack size = 0 */
 1927               	.L__stack_usage = 0
1049:WTPA.c        **** 	signed int
1050:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1051:WTPA.c        **** 		sum1;
1052:WTPA.c        **** 
1053:WTPA.c        **** 	unsigned char
1054:WTPA.c        **** 		output;			// What to put on the DAC
1055:WTPA.c        **** 
1056:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1928               		.loc 1 1056 0
 1929 105e 2091 0000 		lds r18,extIsrOutputBank0
 1930 1062 8091 0000 		lds r24,midiOutputBank0
 1931 1066 9927      		clr r25
 1932 1068 87FD      		sbrc r24,7
 1933 106a 9095      		com r25
 1934 106c 820F      		add r24,r18
 1935 106e 911D      		adc r25,__zero_reg__
 1936 1070 27FD      		sbrc r18,7
 1937 1072 9A95      		dec r25
 1938 1074 8038      		cpi r24,-128
 1939 1076 2FEF      		ldi r18,-1
 1940 1078 9207      		cpc r25,r18
 1941 107a 04F4      		brge .L121
 1942 107c 80E8      		ldi r24,lo8(-128)
 1943 107e 9FEF      		ldi r25,lo8(-1)
 1944               	.L121:
 1945               	.LVL49:
1057:WTPA.c        **** 	if(sum0>127)		// Pin high.
1058:WTPA.c        **** 	{
1059:WTPA.c        **** 		sum0=127;
1060:WTPA.c        **** 	}
1061:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1062:WTPA.c        **** 	{
1063:WTPA.c        **** 		sum0=-128;
1064:WTPA.c        **** 	}
1065:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1946               		.loc 1 1065 0
 1947 1080 4091 0000 		lds r20,extIsrOutputBank1
 1948 1084 2091 0000 		lds r18,midiOutputBank1
 1949 1088 3327      		clr r19
 1950 108a 27FD      		sbrc r18,7
 1951 108c 3095      		com r19
 1952 108e 240F      		add r18,r20
 1953 1090 311D      		adc r19,__zero_reg__
 1954 1092 47FD      		sbrc r20,7
 1955 1094 3A95      		dec r19
 1956 1096 2038      		cpi r18,-128
 1957 1098 4FEF      		ldi r20,-1
 1958 109a 3407      		cpc r19,r20
 1959 109c 04F4      		brge .L122
 1960 109e 20E8      		ldi r18,lo8(-128)
 1961 10a0 3FEF      		ldi r19,lo8(-1)
 1962               	.L122:
 1963               	.LVL50:
1066:WTPA.c        **** 	if(sum1>127)		// Pin high.
1067:WTPA.c        **** 	{
1068:WTPA.c        **** 		sum1=127;
1069:WTPA.c        **** 	}
1070:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1071:WTPA.c        **** 	{
1072:WTPA.c        **** 		sum1=-128;
1073:WTPA.c        **** 	}
1074:WTPA.c        **** 	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1964               		.loc 1 1074 0
 1965 10a2 2038      		cpi r18,-128
 1966 10a4 3105      		cpc r19,__zero_reg__
 1967 10a6 04F0      		brlt .L123
 1968 10a8 2FE7      		ldi r18,lo8(127)
 1969 10aa 30E0      		ldi r19,0
 1970               	.LVL51:
 1971               	.L123:
 1972 10ac 2058      		subi r18,128
 1973 10ae 3095      		com r19
 1974 10b0 8038      		cpi r24,-128
 1975 10b2 9105      		cpc r25,__zero_reg__
 1976 10b4 04F0      		brlt .L124
 1977 10b6 8FE7      		ldi r24,lo8(127)
 1978 10b8 90E0      		ldi r25,0
 1979               	.LVL52:
 1980               	.L124:
 1981 10ba 8058      		subi r24,128
 1982 10bc 9095      		com r25
 1983 10be 8223      		and r24,r18
 1984               	.LVL53:
1075:WTPA.c        **** 
1076:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1985               		.loc 1 1076 0
 1986 10c0 9091 0000 		lds r25,lastDacByte
 1987 10c4 8917      		cp r24,r25
 1988 10c6 01F0      		breq .L125
1077:WTPA.c        **** 	{
1078:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1989               		.loc 1 1078 0
 1990 10c8 9FEF      		ldi r25,lo8(-1)
 1991 10ca 94B9      		out 0x4,r25
1079:WTPA.c        **** 
1080:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1992               		.loc 1 1080 0
 1993 10cc 85B9      		out 0x5,r24
1081:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1994               		.loc 1 1081 0
 1995 10ce 159A      		sbi 0x2,5
1082:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1996               		.loc 1 1082 0
 1997 10d0 1598      		cbi 0x2,5
 1998               	.L125:
1083:WTPA.c        **** 	}
1084:WTPA.c        **** 
1085:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1999               		.loc 1 1085 0
 2000 10d2 8093 0000 		sts lastDacByte,r24
 2001 10d6 0895      		ret
 2002               		.cfi_endproc
 2003               	.LFE6:
 2006               	WriteLedLatch:
 2007               	.LFB20:
1086:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1087:WTPA.c        **** }
1088:WTPA.c        **** //-----------------------------------------------------------------------------
1089:WTPA.c        **** //-----------------------------------------------------------------------------
1090:WTPA.c        **** // Interrupt Vectors:
1091:WTPA.c        **** // These handle updating audio in the different banks (and the dumb LED intro)
1092:WTPA.c        **** //-----------------------------------------------------------------------------
1093:WTPA.c        **** //-----------------------------------------------------------------------------
1094:WTPA.c        **** 
1095:WTPA.c        **** ISR(TIMER1_CAPT_vect)
1096:WTPA.c        **** // The vector triggered by an external clock edge and associated with Bank0
1097:WTPA.c        **** {
1098:WTPA.c        **** 	static bool
1099:WTPA.c        **** 		flipFlop;		// Used for half-time
1100:WTPA.c        **** 
1101:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1102:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1103:WTPA.c        **** 	{
1104:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
1105:WTPA.c        **** 	}
1106:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1107:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1108:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1109:WTPA.c        **** 	{
1110:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1111:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1112:WTPA.c        **** 	}
1113:WTPA.c        **** }
1114:WTPA.c        **** 
1115:WTPA.c        **** ISR(PCINT2_vect)
1116:WTPA.c        **** // The vector triggered by a pin change and associated with Bank1
1117:WTPA.c        **** // It's on PC4
1118:WTPA.c        **** {
1119:WTPA.c        **** 	static bool
1120:WTPA.c        **** 		flipFlop;		// Used for half-time
1121:WTPA.c        **** 
1122:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1123:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1124:WTPA.c        **** 	{
1125:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
1126:WTPA.c        **** 	}
1127:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1128:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1129:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1130:WTPA.c        **** 	{
1131:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1132:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1133:WTPA.c        **** 	}
1134:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
1135:WTPA.c        **** 
1136:WTPA.c        **** // Mon May 23 16:06:37 EDT 2011
1137:WTPA.c        **** // With new hardware (relaxation osc and pulse shaper) we removed the level check above.  The clock
1138:WTPA.c        **** // However, we will need to clear the pin-change interrupt flag, since it may get set again about t
1139:WTPA.c        **** // Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and 
1140:WTPA.c        **** 
1141:WTPA.c        **** // Fri Jun 24 11:20:40 EDT 2011
1142:WTPA.c        **** // They're more like 5uS now, but still plenty short
1143:WTPA.c        **** }
1144:WTPA.c        **** 
1145:WTPA.c        **** ISR(TIMER1_COMPA_vect)
1146:WTPA.c        **** // The bank0 internal timer vectors here on an interrupt.
1147:WTPA.c        **** {
1148:WTPA.c        **** 	unsigned long
1149:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1150:WTPA.c        **** 	static unsigned int
1151:WTPA.c        **** 		lastJitterValue;
1152:WTPA.c        **** 	static bool
1153:WTPA.c        **** 		flipFlop;		// Used for half-time
1154:WTPA.c        **** 
1155:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1156:WTPA.c        **** 
1157:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1158:WTPA.c        **** 	{
1159:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
1160:WTPA.c        **** 	}
1161:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
1162:WTPA.c        **** 	{
1163:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
1164:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1165:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1166:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1167:WTPA.c        **** 	}
1168:WTPA.c        **** 	else
1169:WTPA.c        **** 	{
1170:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1171:WTPA.c        **** 	}
1172:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1173:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1174:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1175:WTPA.c        **** 	{
1176:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1177:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1178:WTPA.c        **** 	}
1179:WTPA.c        **** }
1180:WTPA.c        **** 
1181:WTPA.c        **** ISR(TIMER1_COMPB_vect)
1182:WTPA.c        **** // The interrupt associated with bank1 when it's using internal interrupts goes here.
1183:WTPA.c        **** {
1184:WTPA.c        **** 	unsigned long
1185:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1186:WTPA.c        **** 	static unsigned int
1187:WTPA.c        **** 		lastJitterValue;
1188:WTPA.c        **** 	static bool
1189:WTPA.c        **** 		flipFlop;		// Used for half-time
1190:WTPA.c        **** 
1191:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1192:WTPA.c        **** 
1193:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1194:WTPA.c        **** 	{
1195:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
1196:WTPA.c        **** 	}
1197:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
1198:WTPA.c        **** 	{
1199:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
1200:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1201:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1202:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1203:WTPA.c        **** 	}
1204:WTPA.c        **** 	else
1205:WTPA.c        **** 	{
1206:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1207:WTPA.c        **** 	}
1208:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1209:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1210:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1211:WTPA.c        **** 	{
1212:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1213:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1214:WTPA.c        **** 	}
1215:WTPA.c        **** }
1216:WTPA.c        **** 
1217:WTPA.c        **** ISR(TIMER2_COMPB_vect)
1218:WTPA.c        **** // This interrupt handles data in the SD buffer and doing what needs to be done with it.
1219:WTPA.c        **** // This includes direct playback from the SD card, writing SD data to the ram banks, and reading ra
1220:WTPA.c        **** // When writing/reading RAM, the bank in question should be locked against other RAM accesses.
1221:WTPA.c        **** {
1222:WTPA.c        **** 	unsigned char
1223:WTPA.c        **** 		theByte;
1224:WTPA.c        **** 
1225:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
1226:WTPA.c        **** 	{
1227:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1228:WTPA.c        **** 		{
1229:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1230:WTPA.c        **** 			{
1231:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1232:WTPA.c        **** 
1233:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1234:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1235:WTPA.c        **** 				{
1236:WTPA.c        **** 					sdFifoReadPointer=0;
1237:WTPA.c        **** 				}
1238:WTPA.c        **** 
1239:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1240:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1241:WTPA.c        **** 
1242:WTPA.c        **** 				// Now put this byte into the RAM bank in the correct address.
1243:WTPA.c        **** 
1244:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
1245:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
1246:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
1247:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
1248:WTPA.c        **** 
1249:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
1250:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
1251:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
1252:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
1253:WTPA.c        **** 
1254:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
1255:WTPA.c        **** 
1256:WTPA.c        **** 				// Compute address while bus settles.
1257:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
1258:WTPA.c        **** 				{
1259:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1260:WTPA.c        **** 				}
1261:WTPA.c        **** 				else
1262:WTPA.c        **** 				{
1263:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1264:WTPA.c        **** 				}
1265:WTPA.c        **** 
1266:WTPA.c        **** 				// Finish writing to RAM.
1267:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
1268:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
1269:WTPA.c        **** 
1270:WTPA.c        **** 			}
1271:WTPA.c        **** 		}
1272:WTPA.c        **** 		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current 
1273:WTPA.c        **** 		{
1274:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1275:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1276:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1277:WTPA.c        **** 
1278:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
1279:WTPA.c        **** 			{
1280:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
1281:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1282:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1283:WTPA.c        **** 			}
1284:WTPA.c        **** 			else
1285:WTPA.c        **** 			{
1286:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
1287:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1288:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1289:WTPA.c        **** 			}
1290:WTPA.c        **** 		}
1291:WTPA.c        **** 	}
1292:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
1293:WTPA.c        **** 	{
1294:WTPA.c        **** 		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pau
1295:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
1296:WTPA.c        **** 		{
1297:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
1298:WTPA.c        **** 			{
1299:WTPA.c        **** 				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
1300:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
1301:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
1302:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
1303:WTPA.c        **** 
1304:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
1305:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
1306:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
1307:WTPA.c        **** 
1308:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
1309:WTPA.c        **** 
1310:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
1311:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
1312:WTPA.c        **** 
1313:WTPA.c        **** 				// Calculate new addy while data bus settles
1314:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
1315:WTPA.c        **** 				{
1316:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1317:WTPA.c        **** 				}
1318:WTPA.c        **** 				else
1319:WTPA.c        **** 				{
1320:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1321:WTPA.c        **** 				}
1322:WTPA.c        **** 
1323:WTPA.c        **** 				// Finish getting the byte from RAM.
1324:WTPA.c        **** 
1325:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
1326:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
1327:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
1328:WTPA.c        **** 
1329:WTPA.c        **** 				// Now put this byte from RAM into the sd fifo
1330:WTPA.c        **** 
1331:WTPA.c        **** 
1332:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
1333:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
1334:WTPA.c        **** 
1335:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
1336:WTPA.c        **** 				{
1337:WTPA.c        **** 					sdFifoWritePointer=0;
1338:WTPA.c        **** 				}
1339:WTPA.c        **** 
1340:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
1341:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
1342:WTPA.c        **** 
1343:WTPA.c        **** 			}
1344:WTPA.c        **** 			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank fo
1345:WTPA.c        **** 			{
1346:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1347:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
1348:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1349:WTPA.c        **** 
1350:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
1351:WTPA.c        **** 				{
1352:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
1353:WTPA.c        **** 				}
1354:WTPA.c        **** 				else
1355:WTPA.c        **** 				{
1356:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
1357:WTPA.c        **** 				}
1358:WTPA.c        **** 			}
1359:WTPA.c        **** 		}
1360:WTPA.c        **** 	}
1361:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
1362:WTPA.c        **** 	{
1363:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1364:WTPA.c        **** 		{
1365:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1366:WTPA.c        **** 			{
1367:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1368:WTPA.c        **** 
1369:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1370:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1371:WTPA.c        **** 				{
1372:WTPA.c        **** 					sdFifoReadPointer=0;
1373:WTPA.c        **** 				}
1374:WTPA.c        **** 
1375:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1376:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1377:WTPA.c        **** 
1378:WTPA.c        **** 				// Now spit the byte out the DAC.
1379:WTPA.c        **** 
1380:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
1381:WTPA.c        **** 				UpdateOutput();				// Update the DAC
1382:WTPA.c        **** 			}
1383:WTPA.c        **** 		}
1384:WTPA.c        **** 		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
1385:WTPA.c        **** 		{
1386:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1387:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1388:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1389:WTPA.c        **** 
1390:WTPA.c        **** 			// Set this contribution to the DAC to midscale (this output source is now quiet)
1391:WTPA.c        **** 			sdStreamOutput=0;
1392:WTPA.c        **** 		}
1393:WTPA.c        **** 	}
1394:WTPA.c        **** }
1395:WTPA.c        **** 
1396:WTPA.c        **** ISR(TIMER2_COMPA_vect)
1397:WTPA.c        **** // Serves exclusively to make our gay intro happen
1398:WTPA.c        **** // As far as the PWM goes, this should happen as often as possible.
1399:WTPA.c        **** {
1400:WTPA.c        **** 	static unsigned char
1401:WTPA.c        **** 		pwmCount;
1402:WTPA.c        **** 
1403:WTPA.c        **** 	if(ledPwm>pwmCount)
1404:WTPA.c        **** 	{
1405:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
1406:WTPA.c        **** 	}
1407:WTPA.c        **** 	else
1408:WTPA.c        **** 	{
1409:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
1410:WTPA.c        **** 	}
1411:WTPA.c        **** 	pwmCount++;
1412:WTPA.c        **** }
1413:WTPA.c        **** 
1414:WTPA.c        **** ISR(__vector_default)
1415:WTPA.c        **** {
1416:WTPA.c        ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
1417:WTPA.c        **** 	//	printf("Buggy Interrupt Generated!  Flags = ");
1418:WTPA.c        **** 	//  printf("*****put interrupt register values here****");
1419:WTPA.c        **** }
1420:WTPA.c        **** 
1421:WTPA.c        **** //-----------------------------------------------------------------------
1422:WTPA.c        **** //-----------------------------------------------------------------------
1423:WTPA.c        **** // State Machine Functions.
1424:WTPA.c        **** //-----------------------------------------------------------------------
1425:WTPA.c        **** //-----------------------------------------------------------------------
1426:WTPA.c        **** 
1427:WTPA.c        **** static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should be
1428:WTPA.c        **** {
1429:WTPA.c        **** 	State=newState;
1430:WTPA.c        **** 	subState=SS_0;
1431:WTPA.c        **** }
1432:WTPA.c        **** 
1433:WTPA.c        **** //-----------------------------------------------------------------------
1434:WTPA.c        **** //-----------------------------------------------------------------------
1435:WTPA.c        **** // Local Software Clock stuff.
1436:WTPA.c        **** //-----------------------------------------------------------------------
1437:WTPA.c        **** //-----------------------------------------------------------------------
1438:WTPA.c        **** 
1439:WTPA.c        **** void HandleSoftclock(void)
1440:WTPA.c        **** // NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
1441:WTPA.c        **** // This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up
1442:WTPA.c        **** {
1443:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
1444:WTPA.c        **** 	{
1445:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
1446:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
1447:WTPA.c        **** 	}
1448:WTPA.c        **** }
1449:WTPA.c        **** 
1450:WTPA.c        **** static void InitSoftclock(void)
1451:WTPA.c        **** // Wed Dec  3 22:28:06 CST 2008
1452:WTPA.c        **** // I've changed the way the softclock works from the last rev.  It's no longer and interrupt based 
1453:WTPA.c        **** // Also, since hardware TIMR1 is needed for bigger and better things than keeping human-time, we're
1454:WTPA.c        **** // This means we don't steal cycles from any other ISRs, but it also means that if we write dumb co
1455:WTPA.c        **** // we might miss a systemTick.
1456:WTPA.c        **** // NOTE:  w/ TMR0 running at 1/256 prescale at 20MHz, our smallest time unit is 3.2768mSecs.
1457:WTPA.c        **** // NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.
1458:WTPA.c        **** 
1459:WTPA.c        **** // With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing e
1460:WTPA.c        **** 
1461:WTPA.c        **** {
1462:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
1463:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
1464:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
1465:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
1466:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
1467:WTPA.c        **** 	systemTicks=0;
1468:WTPA.c        **** //	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
1469:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
1470:WTPA.c        **** }
1471:WTPA.c        **** 
1472:WTPA.c        **** //-----------------------------------------------------------------------
1473:WTPA.c        **** // LED functions:
1474:WTPA.c        **** //-----------------------------------------------------------------------
1475:WTPA.c        **** 
1476:WTPA.c        **** // Thu Apr  1 13:08:08 EDT 2010
1477:WTPA.c        **** // Changed blinking mechanisms to be smaller and blink fixed times, and also use fewer timer fcns
1478:WTPA.c        **** 
1479:WTPA.c        **** #define		BLINK_TIME			(SECOND/8)
1480:WTPA.c        **** 
1481:WTPA.c        **** static void BlinkLeds(unsigned int theMask)
1482:WTPA.c        **** // Sets up the mask of leds to blink and their blink rate.
1483:WTPA.c        **** // NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from
1484:WTPA.c        **** // NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when w
1485:WTPA.c        **** {
1486:WTPA.c        **** 	unsigned char
1487:WTPA.c        **** 		i;
1488:WTPA.c        **** 
1489:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
1490:WTPA.c        **** 	{
1491:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
1492:WTPA.c        **** 		{
1493:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
1494:WTPA.c        **** 		}
1495:WTPA.c        **** 	}
1496:WTPA.c        **** 
1497:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
1498:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
1499:WTPA.c        **** }
1500:WTPA.c        **** 
1501:WTPA.c        **** static void StopBlinking(void)
1502:WTPA.c        **** // Stops all blinking LEDs.
1503:WTPA.c        **** {
1504:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1505:WTPA.c        **** }
1506:WTPA.c        **** 
1507:WTPA.c        **** static void KillLeds(void)
1508:WTPA.c        **** // Turns off all LEDs immediately.
1509:WTPA.c        **** {
1510:WTPA.c        **** 	ledOnOffMask=0;
1511:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1512:WTPA.c        **** }
1513:WTPA.c        **** 
1514:WTPA.c        **** static void WriteLedLatch(unsigned char theMask)
1515:WTPA.c        **** // Take the current on/off LED mask and put it onto the LED output latch.
1516:WTPA.c        **** // This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
1517:WTPA.c        **** {
 2008               		.loc 1 1517 0
 2009               		.cfi_startproc
 2010               	.LVL54:
 2011               	/* prologue: function */
 2012               	/* frame size = 0 */
 2013               	/* stack size = 0 */
 2014               	.L__stack_usage = 0
1518:WTPA.c        **** 	unsigned char
1519:WTPA.c        **** 		sreg;
1520:WTPA.c        **** 
1521:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 2015               		.loc 1 1521 0
 2016 10d8 9FB7      		in r25,__SREG__
 2017               	.LVL55:
1522:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 2018               		.loc 1 1522 0
 2019               	/* #APP */
 2020               	 ;  1522 "WTPA.c" 1
 2021 10da F894      		cli
 2022               	 ;  0 "" 2
1523:WTPA.c        **** 
1524:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 2023               		.loc 1 1524 0
 2024               	/* #NOAPP */
 2025 10dc 85B9      		out 0x5,r24
1525:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 2026               		.loc 1 1525 0
 2027 10de 8FEF      		ldi r24,lo8(-1)
 2028               	.LVL56:
 2029 10e0 84B9      		out 0x4,r24
1526:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 2030               		.loc 1 1526 0
 2031 10e2 5F9A      		sbi 0xb,7
1527:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 2032               		.loc 1 1527 0
 2033 10e4 5F98      		cbi 0xb,7
1528:WTPA.c        **** 
1529:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 2034               		.loc 1 1529 0
 2035 10e6 9FBF      		out __SREG__,r25
 2036 10e8 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE20:
 2041               	CheckSdSlotFull:
 2042               	.LFB36:
1530:WTPA.c        **** }
1531:WTPA.c        **** 
1532:WTPA.c        **** static void HandleLeds(void)
1533:WTPA.c        **** // Runs in the main loop updating the state of the LEDs.  Only messes with the databus when there's
1534:WTPA.c        **** {
1535:WTPA.c        **** 	unsigned char
1536:WTPA.c        **** 		i;
1537:WTPA.c        **** 	static bool
1538:WTPA.c        **** 		toggle;				// Flip flop for blinking.
1539:WTPA.c        **** 	static unsigned char
1540:WTPA.c        **** 		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.
1541:WTPA.c        **** 
1542:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
1543:WTPA.c        **** 	{
1544:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
1545:WTPA.c        **** 		{
1546:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
1547:WTPA.c        **** 			{
1548:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
1549:WTPA.c        **** 				{
1550:WTPA.c        **** 					ledOnOffMask|=(1<<i);
1551:WTPA.c        **** 				}
1552:WTPA.c        **** 				else
1553:WTPA.c        **** 				{
1554:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
1555:WTPA.c        **** 				}
1556:WTPA.c        **** 			}
1557:WTPA.c        **** 		}
1558:WTPA.c        **** 
1559:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
1560:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
1561:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
1562:WTPA.c        **** 	}
1563:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
1564:WTPA.c        **** 	{
1565:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
1566:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
1567:WTPA.c        **** 	}
1568:WTPA.c        **** }
1569:WTPA.c        **** 
1570:WTPA.c        **** static void InitLeds(void)
1571:WTPA.c        **** {
1572:WTPA.c        **** 	ledOnOffMask=0;
1573:WTPA.c        **** 	ledBlinkMask=0;
1574:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
1575:WTPA.c        **** }
1576:WTPA.c        **** 
1577:WTPA.c        **** //-----------------------------------------------------------------------
1578:WTPA.c        **** //-----------------------------------------------------------------------
1579:WTPA.c        **** // Switch functions:
1580:WTPA.c        **** //-----------------------------------------------------------------------
1581:WTPA.c        **** //-----------------------------------------------------------------------
1582:WTPA.c        **** 
1583:WTPA.c        **** static void InitSwitches(void)
1584:WTPA.c        **** {
1585:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
1586:WTPA.c        **** 
1587:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
1588:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
1589:WTPA.c        **** 
1590:WTPA.c        **** }
1591:WTPA.c        **** 
1592:WTPA.c        **** static void HandleSwitches(void)
1593:WTPA.c        **** // Read input pins, debounce, make keypresses positive-true, and flag newly-appeared keys.
1594:WTPA.c        **** // Make sure we've allowed enough time to turn the bus around.  The old RAM took a couple cycles be
1595:WTPA.c        **** {
1596:WTPA.c        **** 	static unsigned char
1597:WTPA.c        **** 		lastKeyState;
1598:WTPA.c        **** 	unsigned char
1599:WTPA.c        **** 		sreg;
1600:WTPA.c        **** 
1601:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
1602:WTPA.c        **** 	{
1603:WTPA.c        **** 		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
1604:WTPA.c        **** 		sreg=SREG;
1605:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
1606:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
1607:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
1608:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
1609:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
1610:WTPA.c        **** 		asm volatile("nop"::);
1611:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
1612:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
1613:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
1614:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
1615:WTPA.c        **** 
1616:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
1617:WTPA.c        **** 		{
1618:WTPA.c        **** 			cardDetect=true;
1619:WTPA.c        **** 		}
1620:WTPA.c        **** 		else
1621:WTPA.c        **** 		{
1622:WTPA.c        **** 			cardDetect=false;
1623:WTPA.c        **** 		}
1624:WTPA.c        **** 
1625:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
1626:WTPA.c        **** 	}
1627:WTPA.c        **** 
1628:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
1629:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
1630:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
1631:WTPA.c        **** }
1632:WTPA.c        **** 
1633:WTPA.c        **** //-----------------------------------------------------------------------
1634:WTPA.c        **** //-----------------------------------------------------------------------
1635:WTPA.c        **** // Encoder functions:
1636:WTPA.c        **** //-----------------------------------------------------------------------
1637:WTPA.c        **** //-----------------------------------------------------------------------
1638:WTPA.c        **** // The encoders I set this up with are 24 pulses per revolution.
1639:WTPA.c        **** // They are Bourns 652-PEC124230F-N0024, from Mouser.
1640:WTPA.c        **** // From the DS:  5mSec max bounce at 15RPM (waaay faster than we'll go) with "standard noise reduct
1641:WTPA.c        **** // This encoder (like most others) puts out 2 bit Gray code (where only one switch changes at a tim
1642:WTPA.c        **** 
1643:WTPA.c        **** // Thu Sep  2 15:04:47 EDT 2010
1644:WTPA.c        **** // OK.  More monkeying with reading the encoder shows us that a "pulse" is actually a transition of
1645:WTPA.c        **** // This is good (it means more resolution -- there are 4*24 readable transitions per revolution) bu
1646:WTPA.c        **** // Did this -- the encoder is really sensitive.  We still either miss reads or are getting switch b
1647:WTPA.c        **** 
1648:WTPA.c        **** // Thu Sep  2 16:39:43 EDT 2010 -- Added hardware filter from the panasonic datasheet.  Works a dre
1649:WTPA.c        **** 
1650:WTPA.c        **** // Encoder bit masks (dependent on port position)
1651:WTPA.c        **** #define	ENC_POS_A	0x00
1652:WTPA.c        **** #define	ENC_POS_B	0x40
1653:WTPA.c        **** #define	ENC_POS_C	0xC0
1654:WTPA.c        **** #define	ENC_POS_D	0x80
1655:WTPA.c        **** 
1656:WTPA.c        **** static void InitEncoder(void)
1657:WTPA.c        **** {
1658:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
1659:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
1660:WTPA.c        **** 	newEncoder=false;
1661:WTPA.c        **** 	encoderCw=false;
1662:WTPA.c        **** 	encoderCcw=false;
1663:WTPA.c        **** }
1664:WTPA.c        **** 
1665:WTPA.c        **** static void HandleEncoder(void)
1666:WTPA.c        **** // Fri Jun 24 11:29:53 EDT 2011
1667:WTPA.c        **** // Steps backwards from earlier prototype for some reason
1668:WTPA.c        **** {
1669:WTPA.c        **** 	static unsigned char
1670:WTPA.c        **** 		lastEncoderState=0;
1671:WTPA.c        **** 	static unsigned int
1672:WTPA.c        **** 		lastEncTime=0;
1673:WTPA.c        **** 
1674:WTPA.c        **** 	newEncoder=false;	// Clear variables which indicate changes in encoder readings
1675:WTPA.c        **** 	encoderCw=false;
1676:WTPA.c        **** 	encoderCcw=false;
1677:WTPA.c        **** 
1678:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
1679:WTPA.c        **** 	{
1680:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
1681:WTPA.c        **** 
1682:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
1683:WTPA.c        **** 
1684:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
1685:WTPA.c        **** 		{
1686:WTPA.c        **** 			if(encoderState==ENC_POS_A)
1687:WTPA.c        **** 			{
1688:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
1689:WTPA.c        **** 				{
1690:WTPA.c        **** //					encoderValue++;
1691:WTPA.c        **** 					encoderValue--;
1692:WTPA.c        **** 					encoderCcw=true;
1693:WTPA.c        **** 					newEncoder=true;
1694:WTPA.c        **** 				}
1695:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
1696:WTPA.c        **** 				{
1697:WTPA.c        **** //					encoderValue--;
1698:WTPA.c        **** 					encoderValue++;
1699:WTPA.c        **** 					encoderCw=true;
1700:WTPA.c        **** 					newEncoder=true;
1701:WTPA.c        **** 				}
1702:WTPA.c        **** 			}
1703:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
1704:WTPA.c        **** 			{
1705:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
1706:WTPA.c        **** 				{
1707:WTPA.c        **** //					encoderValue++;
1708:WTPA.c        **** 					encoderValue--;
1709:WTPA.c        **** 					encoderCcw=true;
1710:WTPA.c        **** 					newEncoder=true;
1711:WTPA.c        **** 				}
1712:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
1713:WTPA.c        **** 				{
1714:WTPA.c        **** //					encoderValue--;
1715:WTPA.c        **** 					encoderValue++;
1716:WTPA.c        **** 					encoderCw=true;
1717:WTPA.c        **** 					newEncoder=true;
1718:WTPA.c        **** 				}
1719:WTPA.c        **** 			}
1720:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
1721:WTPA.c        **** 			{
1722:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
1723:WTPA.c        **** 				{
1724:WTPA.c        **** //					encoderValue++;
1725:WTPA.c        **** 					encoderValue--;
1726:WTPA.c        **** 					encoderCcw=true;
1727:WTPA.c        **** 					newEncoder=true;
1728:WTPA.c        **** 				}
1729:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
1730:WTPA.c        **** 				{
1731:WTPA.c        **** //					encoderValue--;
1732:WTPA.c        **** 					encoderValue++;
1733:WTPA.c        **** 					encoderCw=true;
1734:WTPA.c        **** 					newEncoder=true;
1735:WTPA.c        **** 				}
1736:WTPA.c        **** 			}
1737:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
1738:WTPA.c        **** 			{
1739:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
1740:WTPA.c        **** 				{
1741:WTPA.c        **** //					encoderValue++;
1742:WTPA.c        **** 					encoderValue--;
1743:WTPA.c        **** 					encoderCcw=true;
1744:WTPA.c        **** 					newEncoder=true;
1745:WTPA.c        **** 				}
1746:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
1747:WTPA.c        **** 				{
1748:WTPA.c        **** //					encoderValue--;
1749:WTPA.c        **** 					encoderValue++;
1750:WTPA.c        **** 					encoderCw=true;
1751:WTPA.c        **** 					newEncoder=true;
1752:WTPA.c        **** 				}
1753:WTPA.c        **** 			}
1754:WTPA.c        **** 
1755:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
1756:WTPA.c        **** 		}
1757:WTPA.c        **** 	}
1758:WTPA.c        **** }
1759:WTPA.c        **** 
1760:WTPA.c        **** //-----------------------------------------------------------------------
1761:WTPA.c        **** //-----------------------------------------------------------------------
1762:WTPA.c        **** // A/D Control Functions:
1763:WTPA.c        **** //-----------------------------------------------------------------------
1764:WTPA.c        **** //-----------------------------------------------------------------------
1765:WTPA.c        **** // WTPA2 uses only one analog input (ADC0).  It's used to sample the audio input.  In old versions 
1766:WTPA.c        **** // The best resolution we can get from this hardware is 10 bits, +/- 2 lsbs.
1767:WTPA.c        **** // The max sampling rate we can pull at full resolution is 15kHz.  We always use the ADC single end
1768:WTPA.c        **** // work in differential mode with the PDIP package.  A conversion takes 13 ADC clocks normally, or 
1769:WTPA.c        **** // The datasheet is unclear how much resolution is lost above 15kHz.  Guess we'll find out!
1770:WTPA.c        **** // NOTE:  Since the RAM can only store 8 bits per sample, we're only using 8 bits of the conversion
1771:WTPA.c        **** 
1772:WTPA.c        **** /*
1773:WTPA.c        **** static void UnInitAdc(void)
1774:WTPA.c        **** {
1775:WTPA.c        **** 	ADCSRA&=~(1<<ADEN);		// Disable ADC.
1776:WTPA.c        **** 	PRR|=(1<<PRADC);		// Power down the ADC.
1777:WTPA.c        **** }
1778:WTPA.c        **** */
1779:WTPA.c        **** 
1780:WTPA.c        **** static void InitAdc(void)
1781:WTPA.c        **** // Note, we don't set up the Adc to trigger on anything right away.
1782:WTPA.c        **** {
1783:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
1784:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
1785:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
1786:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
1787:WTPA.c        **** //	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the A
1788:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
1789:WTPA.c        **** 	// ADCSRB controls auto-triggering, which we aren't using right now.
1790:WTPA.c        **** }
1791:WTPA.c        **** 
1792:WTPA.c        **** //-----------------------------------------------------------------------
1793:WTPA.c        **** // RAM / DAC functions:
1794:WTPA.c        **** //-----------------------------------------------------------------------
1795:WTPA.c        **** 
1796:WTPA.c        **** // Fri Jun 17 19:11:18 EDT 2011
1797:WTPA.c        **** // As of WTPA2 these are all inlined where they need to go.  The notes below are for posterity
1798:WTPA.c        **** 
1799:WTPA.c        **** // Will be totally different than the oldschool serial biz.....
1800:WTPA.c        **** // Should probably all be inlined in the ISR.
1801:WTPA.c        **** // Just so you remember, Parallel SRAM pretty much always works like this:
1802:WTPA.c        **** 
1803:WTPA.c        **** // The chip is always enabled (CS is always low).  The other two control pins are active low also -
1804:WTPA.c        **** // When WE is low, the value on the DATA pins is latched into the address on the ADDRESS pins.  Ass
1805:WTPA.c        **** // When WE is high, the byte stored at the ADDRESS on pins A0-A18 is latched out on the DATA pins, 
1806:WTPA.c        **** // If OE is high, the DATA port will be high impedance no matter what.
1807:WTPA.c        **** // The ADDRESS pins can always be outputs as far as the MCU is concerned.
1808:WTPA.c        **** 
1809:WTPA.c        **** // A typical write might look like:
1810:WTPA.c        **** // 1.)  OE and WE are high.
1811:WTPA.c        **** // 2.)  The address is set and the data latches on the MCU are made into outputs. The correct value
1812:WTPA.c        **** // 3.)  WE is brought low and the data is latched in.
1813:WTPA.c        **** // 4.)  WE is brought high.  The address and data lines can now be changed without messing up data 
1814:WTPA.c        **** 
1815:WTPA.c        **** // A typical read might look like this:
1816:WTPA.c        **** // 1.)  OE and WE are high.
1817:WTPA.c        **** // 2.)  The address is set correctly and the DATA PORT on the MCU is made high impedance.
1818:WTPA.c        **** // 3.)  OE is brought low, and the data to be read shows up on the DATA lines.
1819:WTPA.c        **** // 4.)  The MCU reads the DATA lines.
1820:WTPA.c        **** // 5.)  OE can be brought high again or left low -- it only needs to change if we're going to write
1821:WTPA.c        **** 
1822:WTPA.c        **** // On 373 Parallel Latches:
1823:WTPA.c        **** // These guys are pretty simple.  In this circuit, their OE is tied low (enabled).
1824:WTPA.c        **** // While LE (Latch Enable) is High, the Latch is transparent from input port to output port.
1825:WTPA.c        **** // When LE is brought low, the current state of the inputs will be latched, and the outputs will th
1826:WTPA.c        **** // So, we will will probably just leave LE low most of the time on the latches and strobe it high w
1827:WTPA.c        **** 
1828:WTPA.c        **** 
1829:WTPA.c        **** 
1830:WTPA.c        **** //-----------------------------------------------------------------------
1831:WTPA.c        **** //-----------------------------------------------------------------------
1832:WTPA.c        **** // General Sampler/ISR Functions:
1833:WTPA.c        **** //-----------------------------------------------------------------------
1834:WTPA.c        **** //-----------------------------------------------------------------------
1835:WTPA.c        **** // We've changed these to use both OCR1x interrupts and the "normal" waveform generation mode (from
1836:WTPA.c        **** // 	This allows us to generate different pitches for the two banks using TIMER1.  We do this by rea
1837:WTPA.c        **** // 	that interrupt occurs.  The OCR value will keep rolling like this, the timer will never be rese
1838:WTPA.c        **** //  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrup
1839:WTPA.c        **** 
1840:WTPA.c        **** // Tue Aug 23 18:25:06 EDT 2011
1841:WTPA.c        **** // Updated these functions to clear the sdUsingBank(x) flags when these are called so the interrupt
1842:WTPA.c        **** 
1843:WTPA.c        **** // Thu Nov 24 19:22:24 CST 2011
1844:WTPA.c        **** // Updated to account for locking banks (removed above).  Necessary now because we can be screwing 
1845:WTPA.c        **** 
1846:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1847:WTPA.c        **** // This code is common to all the requests to start different audio modes (record, playback, overdu
1848:WTPA.c        **** // Timer interrupts should be disabled when you call this!
1849:WTPA.c        **** {
1850:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
1851:WTPA.c        **** 
1852:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
1853:WTPA.c        **** 	{
1854:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
1855:WTPA.c        **** 
1856:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
1857:WTPA.c        **** 		{
1858:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1859:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
1860:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
1861:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1862:WTPA.c        **** 		}
1863:WTPA.c        **** 		else					// Bank 1 is associated with OCR1B
1864:WTPA.c        **** 		{
1865:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1866:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
1867:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
1868:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1869:WTPA.c        **** 		}
1870:WTPA.c        **** 	}
1871:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
1872:WTPA.c        **** 	{
1873:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
1874:WTPA.c        **** 		{
1875:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
1876:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
1877:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
1878:WTPA.c        **** 		}
1879:WTPA.c        **** 		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC in
1880:WTPA.c        **** 		{
1881:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
1882:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
1883:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
1884:WTPA.c        **** 		}
1885:WTPA.c        **** 	}
1886:WTPA.c        **** }
1887:WTPA.c        **** 
1888:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1889:WTPA.c        **** // Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the re
1890:WTPA.c        **** // If we're using the internal clock, set the rate.
1891:WTPA.c        **** // Sat Apr 11 13:49:31 CDT 2009  --  ?
1892:WTPA.c        **** // Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow th
1893:WTPA.c        **** {
1894:WTPA.c        **** 
1895:WTPA.c        **** 	unsigned char
1896:WTPA.c        **** 		sreg;
1897:WTPA.c        **** 
1898:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1899:WTPA.c        **** 	{
1900:WTPA.c        **** 
1901:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1902:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1903:WTPA.c        **** 
1904:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
1905:WTPA.c        **** 
1906:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
1907:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
1908:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
1909:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
1910:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
1911:WTPA.c        **** 
1912:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
1913:WTPA.c        **** 
1914:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1915:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1916:WTPA.c        **** 
1917:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1918:WTPA.c        **** 
1919:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1920:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1921:WTPA.c        **** 		{
1922:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1923:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1924:WTPA.c        **** 		}
1925:WTPA.c        **** 	}
1926:WTPA.c        **** }
1927:WTPA.c        **** 
1928:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1929:WTPA.c        **** // Point to the beginning of the sample, select the clock source, and get the interrupts going.
1930:WTPA.c        **** // Set the clock rate if we're using the internal clock.
1931:WTPA.c        **** // Mon Jul  6 19:05:04 CDT 2009
1932:WTPA.c        **** // We've made it clear that the beginning of the sample is relative, in the sense that if we're pla
1933:WTPA.c        **** {
1934:WTPA.c        **** 	unsigned char
1935:WTPA.c        **** 		sreg;
1936:WTPA.c        **** 
1937:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1938:WTPA.c        **** 	{
1939:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1940:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1941:WTPA.c        **** 
1942:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
1943:WTPA.c        **** 
1944:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
1945:WTPA.c        **** 		{
1946:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
1947:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
1948:WTPA.c        **** 		}
1949:WTPA.c        **** 		else
1950:WTPA.c        **** 		{
1951:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
1952:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
1953:WTPA.c        **** 		}
1954:WTPA.c        **** 
1955:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1956:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1957:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1958:WTPA.c        **** 	}
1959:WTPA.c        **** }
1960:WTPA.c        **** 
1961:WTPA.c        **** static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1962:WTPA.c        **** // Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
1963:WTPA.c        **** // Used if we pause playback and want to continue where we left off, or stop overdubbing and jump r
1964:WTPA.c        **** {
1965:WTPA.c        **** 	unsigned char
1966:WTPA.c        **** 		sreg;
1967:WTPA.c        **** 
1968:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1969:WTPA.c        **** 	{
1970:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1971:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1972:WTPA.c        **** 
1973:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
1974:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1975:WTPA.c        **** 
1976:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1977:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1978:WTPA.c        **** 	}
1979:WTPA.c        **** }
1980:WTPA.c        **** 
1981:WTPA.c        **** static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1982:WTPA.c        **** // Begin recording to ram at the current RAM address.
1983:WTPA.c        **** // Continue playing back from that address, too.
1984:WTPA.c        **** {
1985:WTPA.c        **** 	unsigned char
1986:WTPA.c        **** 		sreg;
1987:WTPA.c        **** 
1988:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1989:WTPA.c        **** 	{
1990:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1991:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1992:WTPA.c        **** 
1993:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
1994:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1995:WTPA.c        **** 
1996:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1997:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1998:WTPA.c        **** 
1999:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
2000:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
2001:WTPA.c        **** 		{
2002:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
2003:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
2004:WTPA.c        **** 		}
2005:WTPA.c        **** 	}
2006:WTPA.c        **** }
2007:WTPA.c        **** 
2008:WTPA.c        **** static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2009:WTPA.c        **** // Begins processing audio in realtime on the passed channel using the passed clock source.
2010:WTPA.c        **** // Thu Nov 24 19:40:21 CST 2011
2011:WTPA.c        **** // OK to do realtime even when banks are locked since we don't use the RAM
2012:WTPA.c        **** {
2013:WTPA.c        **** 	unsigned char
2014:WTPA.c        **** 		sreg;
2015:WTPA.c        **** 
2016:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
2017:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
2018:WTPA.c        **** 
2019:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
2020:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
2021:WTPA.c        **** 
2022:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
2023:WTPA.c        **** 
2024:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
2025:WTPA.c        **** 	{
2026:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
2027:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
2028:WTPA.c        **** 	}
2029:WTPA.c        **** }
2030:WTPA.c        **** 
2031:WTPA.c        **** /*
2032:WTPA.c        **** static void UnInitSampleClock(void)
2033:WTPA.c        **** {
2034:WTPA.c        **** 	PRR|=(1<<PRTIM1);	// Turn the TMR1 power off.
2035:WTPA.c        **** }
2036:WTPA.c        **** */
2037:WTPA.c        **** 
2038:WTPA.c        **** static void InitSampleClock(void)
2039:WTPA.c        **** // Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
2040:WTPA.c        **** // Or just turn it on so we can use the Input Capture pin to generate interrupts for the external c
2041:WTPA.c        **** {
2042:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
2043:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
2044:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
2045:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
2046:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
2047:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
2048:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
2049:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
2050:WTPA.c        **** }
2051:WTPA.c        **** 
2052:WTPA.c        **** 
2053:WTPA.c        **** //-----------------------------------------------------------------------
2054:WTPA.c        **** // SD Memory/Filesystem handling:
2055:WTPA.c        **** //-----------------------------------------------------------------------
2056:WTPA.c        **** // Fri Jun 17 19:13:12 EDT 2011
2057:WTPA.c        **** // Update the state of the uSD card.  Detect and initialize it when it needs that kind of thing.
2058:WTPA.c        **** // Keep track of card validity and when the card is being accessed, etc etc
2059:WTPA.c        **** // WTPA2 TOC:
2060:WTPA.c        **** // ====================
2061:WTPA.c        **** // Block 0:
2062:WTPA.c        **** // 4 	chars 		"WTPA"
2063:WTPA.c        **** // 4	chars		Extended descriptor ("SAMP", "BOOT", "DPCM" -- indicates the type of data on the card)
2064:WTPA.c        **** // 8 	bytes 		don't care
2065:WTPA.c        **** // 64	bytes		Full/Empty sample slot info (512 bits which tell whether a sample is present or not in
2066:WTPA.c        **** // 432	bytes 		don't care
2067:WTPA.c        **** 
2068:WTPA.c        **** // Samples in SD-land:
2069:WTPA.c        **** // --------------------
2070:WTPA.c        **** // WTPA has a fifo in RAM which is 768 bytes long (1.5 blocks).
2071:WTPA.c        **** // Reading, we fill it a block (512 bytes) at a time.  When there is room for 512 bytes in the FIFO
2072:WTPA.c        **** // In order to not hang our state machine for two long, a fraction of a block is read at a time.  T
2073:WTPA.c        **** // Storing parameters works by storing the sample exactly as it is written to the DAC, meaning if t
2074:WTPA.c        **** // Likewise, reducing bit depth or editing a sample will mean the sample is permanently stored that
2075:WTPA.c        **** 
2076:WTPA.c        **** // Sample Format:
2077:WTPA.c        **** // ---------------
2078:WTPA.c        **** // Sample format is currently:
2079:WTPA.c        **** // 4 bytes 	==	sample length
2080:WTPA.c        **** // n bytes	==	sample
2081:WTPA.c        **** // NOTE -- we handle the case where a sample + the four byte addy is bigger than a sample slot (512
2082:WTPA.c        **** 
2083:WTPA.c        **** static void	ClearSampleToc(void)
2084:WTPA.c        **** // Empties the TOC of samples in local ram.
2085:WTPA.c        **** {
2086:WTPA.c        **** 	unsigned char
2087:WTPA.c        **** 		i;
2088:WTPA.c        **** 
2089:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
2090:WTPA.c        **** 	{
2091:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
2092:WTPA.c        **** 	}
2093:WTPA.c        **** }
2094:WTPA.c        **** 
2095:WTPA.c        **** static bool CheckSdSlotFull(unsigned int theSlot)
2096:WTPA.c        **** // Return true if the corresponding bit in the TOC is a 1.
2097:WTPA.c        **** // This is 64 bytes of 8 bits and we want to isolate the bit in question
2098:WTPA.c        **** {
 2043               		.loc 1 2098 0
 2044               		.cfi_startproc
 2045               	.LVL57:
 2046               	/* prologue: function */
 2047               	/* frame size = 0 */
 2048               	/* stack size = 0 */
 2049               	.L__stack_usage = 0
2099:WTPA.c        **** 	unsigned char
2100:WTPA.c        **** 		theByte,
2101:WTPA.c        **** 		theBit;
2102:WTPA.c        **** 
2103:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 2050               		.loc 1 2103 0
 2051 10ea FC01      		movw r30,r24
 2052 10ec 53E0      		ldi r21,3
 2053               		1:
 2054 10ee F695      		lsr r31
 2055 10f0 E795      		ror r30
 2056 10f2 5A95      		dec r21
 2057 10f4 01F4      		brne 1b
2104:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2105:WTPA.c        **** 
2106:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
2107:WTPA.c        **** 	{
2108:WTPA.c        **** 		return(true);
2109:WTPA.c        **** 	}
2110:WTPA.c        **** 	else
2111:WTPA.c        **** 	{
2112:WTPA.c        **** 		return(false);
2113:WTPA.c        **** 	}
2114:WTPA.c        **** }
2115:WTPA.c        **** 
2116:WTPA.c        **** static void MarkSdSlotFull(unsigned int theSlot)
2117:WTPA.c        **** // Changes a bit in the TOC to a 1 to mark it full.
2118:WTPA.c        **** {
2119:WTPA.c        **** 	unsigned char
2120:WTPA.c        **** 		theByte,
2121:WTPA.c        **** 		theBit;
2122:WTPA.c        **** 
2123:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2124:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2125:WTPA.c        **** 
2126:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
2127:WTPA.c        **** }
2128:WTPA.c        **** 
2129:WTPA.c        **** static void MarkSdSlotEmpty(unsigned int theSlot)
2130:WTPA.c        **** // Changes a bit in the TOC to a 0 to mark it empty.
2131:WTPA.c        **** {
2132:WTPA.c        **** 	unsigned char
2133:WTPA.c        **** 		theByte,
2134:WTPA.c        **** 		theBit;
2135:WTPA.c        **** 
2136:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2137:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2138:WTPA.c        **** 
2139:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
2140:WTPA.c        **** }
2141:WTPA.c        **** 
2142:WTPA.c        **** enum							// The things we can recognize a card to be from it's header
2143:WTPA.c        **** 	{
2144:WTPA.c        **** 		SD_TYPE_UNFORMATTED=0,
2145:WTPA.c        **** 		SD_TYPE_SAMPLES,
2146:WTPA.c        **** 		SD_TYPE_DPCM,
2147:WTPA.c        **** 		SD_TYPE_BOOT,
2148:WTPA.c        **** 	};
2149:WTPA.c        **** 
2150:WTPA.c        **** static unsigned char GetCardFilesystem(void)
2151:WTPA.c        **** // Look for the tell tale signs of the party on this card.  If they are there, read in the TOC and 
2152:WTPA.c        **** {
2153:WTPA.c        **** 	unsigned char
2154:WTPA.c        **** 		filesystemType;
2155:WTPA.c        **** 	unsigned char
2156:WTPA.c        **** 		sdTypeBuffer[8];
2157:WTPA.c        **** 	unsigned int
2158:WTPA.c        **** 		i;
2159:WTPA.c        **** 
2160:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
2161:WTPA.c        **** 
2162:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
2163:WTPA.c        **** 	{
2164:WTPA.c        **** 		// Wait for a data packet from the card.
2165:WTPA.c        **** 		// EITHER read in the first four bytes then pull CS high  -- SD SPEC specifies that the SD card A
2166:WTPA.c        ****  		// Tue Jun 21 17:11:28 EDT 2011
2167:WTPA.c        ****  		// @@@ this appears to be bad news.  Tends to leave DO low.
2168:WTPA.c        **** 		// So --
2169:WTPA.c        **** 		// Read the first four bytes and test them, then read the remainder of the block and checksum and
2170:WTPA.c        **** 
2171:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
2172:WTPA.c        **** 
2173:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
2174:WTPA.c        **** 		{
2175:WTPA.c        **** 			HandleSoftclock();	// Kludgy
2176:WTPA.c        **** 		}
2177:WTPA.c        **** 
2178:WTPA.c        **** 		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
2179:WTPA.c        **** 		{
2180:WTPA.c        **** 			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
2181:WTPA.c        **** 		}
2182:WTPA.c        **** 
2183:WTPA.c        **** 		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A')
2184:WTPA.c        **** 		{
2185:WTPA.c        **** 			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'
2186:WTPA.c        **** 			{
2187:WTPA.c        **** 				filesystemType=SD_TYPE_SAMPLES;
2188:WTPA.c        **** 			}
2189:WTPA.c        **** 			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]
2190:WTPA.c        **** 			{
2191:WTPA.c        **** 				filesystemType=SD_TYPE_DPCM;			
2192:WTPA.c        **** 			}
2193:WTPA.c        **** 			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]
2194:WTPA.c        **** 			{
2195:WTPA.c        **** 				filesystemType=SD_TYPE_BOOT;						
2196:WTPA.c        **** 			}
2197:WTPA.c        **** 		}
2198:WTPA.c        **** 
2199:WTPA.c        **** 		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a stri
2200:WTPA.c        **** 		{
2201:WTPA.c        **** 			TransferSdByte(0xFF);
2202:WTPA.c        **** 		}
2203:WTPA.c        **** 
2204:WTPA.c        **** 		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
2205:WTPA.c        **** 		{
2206:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
2207:WTPA.c        **** 			{
2208:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
2209:WTPA.c        **** 			}
2210:WTPA.c        **** 		}
2211:WTPA.c        **** 		else
2212:WTPA.c        **** 		{
2213:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
2214:WTPA.c        **** 			{
2215:WTPA.c        **** 				TransferSdByte(0xFF);
2216:WTPA.c        **** 			}
2217:WTPA.c        **** 
2218:WTPA.c        **** 		}
2219:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
2220:WTPA.c        **** 		{
2221:WTPA.c        **** 			TransferSdByte(0xFF);
2222:WTPA.c        **** 		}
2223:WTPA.c        **** 	}
2224:WTPA.c        **** 
2225:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
2226:WTPA.c        **** 		;
2227:WTPA.c        **** 
2228:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
2229:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
2230:WTPA.c        **** 
2231:WTPA.c        **** 	return(filesystemType);
2232:WTPA.c        **** }
2233:WTPA.c        **** 
2234:WTPA.c        **** static void DoFormatCard(void)
2235:WTPA.c        **** // We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
2236:WTPA.c        **** // Give the user the option to purge the card of its evil ways, and do so and reboot.
2237:WTPA.c        **** {
2238:WTPA.c        **** 	if(subState==SS_0)
2239:WTPA.c        **** 	{
2240:WTPA.c        **** 		KillLeds();		// Turn off LEDs
2241:WTPA.c        **** 
2242:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
2243:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
2244:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
2245:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
2246:WTPA.c        **** 
2247:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
2248:WTPA.c        **** 		subState=SS_1;
2249:WTPA.c        **** 	}
2250:WTPA.c        **** 	else if(subState==SS_1)
2251:WTPA.c        **** 	{
2252:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
2253:WTPA.c        **** 		{
2254:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
2255:WTPA.c        **** 			KillLeds();
2256:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
2257:WTPA.c        **** 			subState=SS_2;
2258:WTPA.c        **** 		}
2259:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
2260:WTPA.c        **** 		{
2261:WTPA.c        **** 			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
2262:WTPA.c        **** 		}
2263:WTPA.c        **** 	}
2264:WTPA.c        **** 	else if(subState==SS_2)
2265:WTPA.c        **** 	{
2266:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
2267:WTPA.c        **** 		{
2268:WTPA.c        **** 			KillLeds();
2269:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
2270:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
2271:WTPA.c        **** 			{
2272:WTPA.c        **** 				SetState(DoFruitcakeIntro);	// Start sampler over again.
2273:WTPA.c        **** 			}
2274:WTPA.c        **** 		}
2275:WTPA.c        **** 	}
2276:WTPA.c        **** }
2277:WTPA.c        **** 
2278:WTPA.c        **** static bool SdStartSampleRead(unsigned int sampleSlot)
2279:WTPA.c        **** // Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
2280:WTPA.c        **** // Begins a sample read in the correct spot.
2281:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2282:WTPA.c        **** {
2283:WTPA.c        **** 	unsigned char
2284:WTPA.c        **** 		sreg;
2285:WTPA.c        **** 
2286:WTPA.c        **** 	sreg=SREG;
2287:WTPA.c        **** 	cli();		// Pause ISR
2288:WTPA.c        **** 
2289:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
2290:WTPA.c        **** 	{
2291:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
2292:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
2293:WTPA.c        **** 
2294:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
2295:WTPA.c        **** 		sdFifoWritePointer=0;
2296:WTPA.c        **** 		sdBytesInFifo=0;
2297:WTPA.c        **** 
2298:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2299:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
2300:WTPA.c        **** 
2301:WTPA.c        **** 		SREG=sreg;	// Resume ISR
2302:WTPA.c        **** 
2303:WTPA.c        **** 		return(true);
2304:WTPA.c        **** 	}
2305:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2306:WTPA.c        **** 	return(false);
2307:WTPA.c        **** }
2308:WTPA.c        **** 
2309:WTPA.c        **** static void SdStartSampleWrite(unsigned int sampleSlot, unsigned long sampleLength)
2310:WTPA.c        **** // Initializes the state machine and FIFOs for writing a sample to the SD card
2311:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2312:WTPA.c        **** // Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
2313:WTPA.c        **** {
2314:WTPA.c        **** 	unsigned char
2315:WTPA.c        **** 		sreg;
2316:WTPA.c        **** 
2317:WTPA.c        **** 	sreg=SREG;
2318:WTPA.c        **** 	cli();		// Pause ISR
2319:WTPA.c        **** 
2320:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
2321:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
2322:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
2323:WTPA.c        **** 
2324:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2325:WTPA.c        **** 	sdFifoWritePointer=0;
2326:WTPA.c        **** 	sdBytesInFifo=0;
2327:WTPA.c        **** 
2328:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
2329:WTPA.c        **** 	{
2330:WTPA.c        **** 		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get fr
2331:WTPA.c        **** 	}
2332:WTPA.c        **** 	else
2333:WTPA.c        **** 	{
2334:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
2335:WTPA.c        **** 	}
2336:WTPA.c        **** 
2337:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
2338:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
2339:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2340:WTPA.c        **** }
2341:WTPA.c        **** 
2342:WTPA.c        **** static void ResetSdCard(void)
2343:WTPA.c        **** // If we unceremoniously pull a card, do this.
2344:WTPA.c        **** {
2345:WTPA.c        **** 	unsigned char
2346:WTPA.c        **** 		sreg;
2347:WTPA.c        **** 
2348:WTPA.c        **** 	sreg=SREG;
2349:WTPA.c        **** 	cli();
2350:WTPA.c        **** 	
2351:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
2352:WTPA.c        **** 	ClearSampleToc();
2353:WTPA.c        **** 	
2354:WTPA.c        **** 	// Stop SD card ISR
2355:WTPA.c        **** 
2356:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
2357:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
2358:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
2359:WTPA.c        **** 
2360:WTPA.c        **** 	// Set this contribution to the DAC to midscale (this output source is now quiet)
2361:WTPA.c        **** 	sdStreamOutput=0;
2362:WTPA.c        **** 
2363:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2364:WTPA.c        **** 	sdFifoWritePointer=0;
2365:WTPA.c        **** 	sdBytesInFifo=0;
2366:WTPA.c        **** 
2367:WTPA.c        **** 	InitSdInterface();
2368:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
2369:WTPA.c        **** 
2370:WTPA.c        **** 	SREG=sreg;
2371:WTPA.c        **** }
2372:WTPA.c        **** 
2373:WTPA.c        **** static void UpdateCard(void)
2374:WTPA.c        **** // Updates the state machine which keeps the card reads/writes/inits going like they should.
2375:WTPA.c        **** {
2376:WTPA.c        **** 	unsigned char
2377:WTPA.c        **** 		theByte,
2378:WTPA.c        **** 		sreg,
2379:WTPA.c        **** 		i;
2380:WTPA.c        **** 
2381:WTPA.c        **** 	signed char
2382:WTPA.c        **** 		tempSample;		// Must be signed or we can get bit errors (will hold ADC data most of the time)
2383:WTPA.c        **** 
2384:WTPA.c        **** 	unsigned int
2385:WTPA.c        **** 		numTransferBytes;
2386:WTPA.c        **** 
2387:WTPA.c        **** 	static unsigned int
2388:WTPA.c        **** 		bytesLeftInBlock;	// How many bytes left in the given block
2389:WTPA.c        **** 
2390:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
2391:WTPA.c        **** 	{
2392:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
2393:WTPA.c        **** 		{
2394:WTPA.c        **** 			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2395:WTPA.c        **** 		}
2396:WTPA.c        **** 	}
2397:WTPA.c        **** 	else	// Yup, got a card
2398:WTPA.c        **** 	{
2399:WTPA.c        **** 		switch(cardState)
2400:WTPA.c        **** 		{
2401:WTPA.c        **** 
2402:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2403:WTPA.c        **** // Warmup / Init	----------------------------------------------------------------------------------
2404:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2405:WTPA.c        **** 
2406:WTPA.c        **** 			case SD_NOT_PRESENT:	// Card just inserted
2407:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
2408:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
2409:WTPA.c        **** 			break;
2410:WTPA.c        **** 
2411:WTPA.c        **** 			case SD_WARMUP:				// Card inserted, timer has been started.
2412:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
2413:WTPA.c        **** 			{
2414:WTPA.c        **** 				sdPlaybackQueued=false;
2415:WTPA.c        **** 				sdAbortRead=false;
2416:WTPA.c        **** 
2417:WTPA.c        **** 				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk
2418:WTPA.c        **** 				{
2419:WTPA.c        **** 					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that migh
2420:WTPA.c        **** 
2421:WTPA.c        **** 					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
2422:WTPA.c        **** 					{
2423:WTPA.c        **** 						cardState=SD_IDLE;			// Card is legit and ready to go.
2424:WTPA.c        **** 						InitSdIsr();				// Enable the timers necessary to give the SD card its own IRQ
2425:WTPA.c        **** 					}
2426:WTPA.c        **** 					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler
2427:WTPA.c        **** 					{
2428:WTPA.c        **** 						// @@@ Load up DPCM stuff
2429:WTPA.c        **** 					}
2430:WTPA.c        **** 
2431:WTPA.c        **** 					else	// Valid card, but either invalid filesystem or BOOT card.  Vector to "are you sure" stat
2432:WTPA.c        **** 					{
2433:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
2434:WTPA.c        **** 						ClearSampleToc();		// Write toc to zero
2435:WTPA.c        **** 						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to m
2436:WTPA.c        **** 					}
2437:WTPA.c        **** 				}
2438:WTPA.c        **** 				else	// Not a valid handshake.  Get on with our lives.
2439:WTPA.c        **** 				{
2440:WTPA.c        **** 					cardState=SD_INVALID;
2441:WTPA.c        **** 				}
2442:WTPA.c        **** 			}
2443:WTPA.c        **** 			break;
2444:WTPA.c        **** 
2445:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2446:WTPA.c        **** // Writing Samples to the Card	--------------------------------------------------------------------
2447:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2448:WTPA.c        **** 
2449:WTPA.c        **** 			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with th
2450:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2451:WTPA.c        **** 			cli();
2452:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2453:WTPA.c        **** 			{
2454:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
2455:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
2456:WTPA.c        **** 				{
2457:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2458:WTPA.c        **** 
2459:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
2460:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
2461:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
2462:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
2463:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
2464:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
2465:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
2466:WTPA.c        **** 
2467:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
2468:WTPA.c        **** 
2469:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing o
2470:WTPA.c        **** 				}
2471:WTPA.c        **** 				else // Couldn't open card for write
2472:WTPA.c        **** 				{
2473:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2474:WTPA.c        **** 				}
2475:WTPA.c        **** 			}
2476:WTPA.c        **** 			else	// Fifo not ready yet
2477:WTPA.c        **** 			{
2478:WTPA.c        **** 				SREG=sreg;	// Turn ISR back on
2479:WTPA.c        **** 			}
2480:WTPA.c        **** 			break;
2481:WTPA.c        **** 
2482:WTPA.c        **** 			case SD_WRITING_BLOCK:										// The SD card is open and we're currently writing a block.
2483:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2484:WTPA.c        **** 			{
2485:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2486:WTPA.c        **** 			}
2487:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2488:WTPA.c        **** 			{
2489:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2490:WTPA.c        **** 			}
2491:WTPA.c        **** 
2492:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
2493:WTPA.c        **** 			{
2494:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
2495:WTPA.c        **** 				{
2496:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
2497:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
2498:WTPA.c        **** 
2499:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
2500:WTPA.c        **** 
2501:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2502:WTPA.c        **** 					{
2503:WTPA.c        **** 						sdFifoReadPointer=0;
2504:WTPA.c        **** 					}
2505:WTPA.c        **** 
2506:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2507:WTPA.c        **** 					cli();
2508:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
2509:WTPA.c        **** 					SREG=sreg;
2510:WTPA.c        **** 				}
2511:WTPA.c        **** 				else	// If sample has been loaded already
2512:WTPA.c        **** 				{
2513:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
2514:WTPA.c        **** 				}
2515:WTPA.c        **** 
2516:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
2517:WTPA.c        **** 			}
2518:WTPA.c        **** 
2519:WTPA.c        **** 			// Have we written an entire block?
2520:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
2521:WTPA.c        **** 			{
2522:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2523:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2524:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2525:WTPA.c        **** 
2526:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2527:WTPA.c        **** 				{
2528:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2529:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
2530:WTPA.c        **** 				}
2531:WTPA.c        **** 				else	// Something wrong with the write.
2532:WTPA.c        **** 				{
2533:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2534:WTPA.c        **** 				}
2535:WTPA.c        **** 			}
2536:WTPA.c        **** 			break;
2537:WTPA.c        **** 
2538:WTPA.c        **** 			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writi
2539:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
2540:WTPA.c        **** 			{
2541:WTPA.c        **** 				i=0;
2542:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2543:WTPA.c        **** 				{
2544:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2545:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2546:WTPA.c        **** 					{
2547:WTPA.c        **** 						i++;	// Try again.
2548:WTPA.c        **** 					}
2549:WTPA.c        **** 					else
2550:WTPA.c        **** 					{
2551:WTPA.c        **** 						i=4;	// Got a result, stop polling
2552:WTPA.c        **** 					}
2553:WTPA.c        **** 				}
2554:WTPA.c        **** 
2555:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
2556:WTPA.c        **** 				{
2557:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2558:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2559:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2560:WTPA.c        **** 						;
2561:WTPA.c        **** 
2562:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
2563:WTPA.c        **** 					{
2564:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
2565:WTPA.c        **** 					}
2566:WTPA.c        **** 					else	// We've written the entire sample to the SD card, and the SD card block write is done.  
2567:WTPA.c        **** 					{
2568:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
2569:WTPA.c        **** 						{
2570:WTPA.c        **** 							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been fille
2571:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
2572:WTPA.c        **** 						}
2573:WTPA.c        **** 						else
2574:WTPA.c        **** 						{
2575:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
2576:WTPA.c        **** 						}
2577:WTPA.c        **** 					}
2578:WTPA.c        **** 				}
2579:WTPA.c        **** 			}
2580:WTPA.c        **** 			else	// Timed out waiting for block to write.
2581:WTPA.c        **** 			{
2582:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2583:WTPA.c        **** 			}
2584:WTPA.c        **** 			break;
2585:WTPA.c        **** 
2586:WTPA.c        **** 			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full
2587:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
2588:WTPA.c        **** 			cli();
2589:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2590:WTPA.c        **** 			{
2591:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
2592:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
2593:WTPA.c        **** 
2594:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
2595:WTPA.c        **** 				{
2596:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2597:WTPA.c        **** 
2598:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
2599:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
2600:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
2601:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
2602:WTPA.c        **** 				}
2603:WTPA.c        **** 				else	// Couldn't successfully open block to write
2604:WTPA.c        **** 				{
2605:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2606:WTPA.c        **** 				}
2607:WTPA.c        **** 			}
2608:WTPA.c        **** 			else	// Bytes remaining in sample, but not enough in the fifo yet
2609:WTPA.c        **** 			{
2610:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
2611:WTPA.c        **** 			}
2612:WTPA.c        **** 			break;
2613:WTPA.c        **** 
2614:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2615:WTPA.c        **** // Writing TOC to the Card	------------------------------------------------------------------------
2616:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2617:WTPA.c        **** 
2618:WTPA.c        **** 			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via n
2619:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
2620:WTPA.c        **** 			{
2621:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
2622:WTPA.c        **** 
2623:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2624:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
2625:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
2626:WTPA.c        **** 				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
2627:WTPA.c        **** 				TransferSdByte('T');
2628:WTPA.c        **** 				TransferSdByte('P');
2629:WTPA.c        **** 				TransferSdByte('A');
2630:WTPA.c        **** 				TransferSdByte('S');				// These four characters indicate this card holds sample data (as oppos
2631:WTPA.c        **** 				TransferSdByte('A');
2632:WTPA.c        **** 				TransferSdByte('M');
2633:WTPA.c        **** 				TransferSdByte('P');
2634:WTPA.c        **** 
2635:WTPA.c        **** 				bytesLeftInBlock-=8;
2636:WTPA.c        **** 
2637:WTPA.c        **** 				for(i=0;i<8;i++)					// 8 don't care bytes
2638:WTPA.c        **** 				{
2639:WTPA.c        **** 					TransferSdByte('x');
2640:WTPA.c        **** 				}
2641:WTPA.c        **** 
2642:WTPA.c        **** 				bytesLeftInBlock-=8;
2643:WTPA.c        **** 
2644:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
2645:WTPA.c        **** 				{
2646:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
2647:WTPA.c        **** 				}
2648:WTPA.c        **** 
2649:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
2650:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
2651:WTPA.c        **** 			}
2652:WTPA.c        **** 			else	// Block write failed
2653:WTPA.c        **** 			{
2654:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2655:WTPA.c        **** 			}
2656:WTPA.c        **** 			break;
2657:WTPA.c        **** 
2658:WTPA.c        **** 			case SD_TOC_WRITE_CONTINUE:				// Keep writing don't cares to the block until we're done.
2659:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2660:WTPA.c        **** 			{
2661:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2662:WTPA.c        **** 			}
2663:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2664:WTPA.c        **** 			{
2665:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2666:WTPA.c        **** 			}
2667:WTPA.c        **** 
2668:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
2669:WTPA.c        **** 			{
2670:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2671:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
2672:WTPA.c        **** 			}
2673:WTPA.c        **** 
2674:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
2675:WTPA.c        **** 			{
2676:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2677:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2678:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2679:WTPA.c        **** 
2680:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2681:WTPA.c        **** 				{
2682:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2683:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
2684:WTPA.c        **** 				}
2685:WTPA.c        **** 				else	// Something wrong with the write.
2686:WTPA.c        **** 				{
2687:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2688:WTPA.c        **** 				}
2689:WTPA.c        **** 			}
2690:WTPA.c        **** 			break;
2691:WTPA.c        **** 
2692:WTPA.c        **** 			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
2693:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2694:WTPA.c        **** 			{
2695:WTPA.c        **** 				i=0;
2696:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2697:WTPA.c        **** 				{
2698:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2699:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2700:WTPA.c        **** 					{
2701:WTPA.c        **** 						i++;	// Try again.
2702:WTPA.c        **** 					}
2703:WTPA.c        **** 					else
2704:WTPA.c        **** 					{
2705:WTPA.c        **** 						i=4;	// Got a result, stop polling
2706:WTPA.c        **** 					}
2707:WTPA.c        **** 				}
2708:WTPA.c        **** 
2709:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
2710:WTPA.c        **** 				{
2711:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2712:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2713:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2714:WTPA.c        **** 						;
2715:WTPA.c        **** 					cardState=SD_IDLE;				// DONE!
2716:WTPA.c        **** 				}
2717:WTPA.c        **** 			}
2718:WTPA.c        **** 			else	// Timed out waiting for block to write.
2719:WTPA.c        **** 			{
2720:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2721:WTPA.c        **** 			}
2722:WTPA.c        **** 			break;
2723:WTPA.c        **** 
2724:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2725:WTPA.c        **** // Reading Samples from the Card ------------------------------------------------------------------
2726:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2727:WTPA.c        **** 
2728:WTPA.c        **** 			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token t
2729:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2730:WTPA.c        **** 			{
2731:WTPA.c        **** 				i=0;
2732:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2733:WTPA.c        **** 				{
2734:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2735:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2736:WTPA.c        **** 					{
2737:WTPA.c        **** 						i++;	// Try again.
2738:WTPA.c        **** 					}
2739:WTPA.c        **** 					else
2740:WTPA.c        **** 					{
2741:WTPA.c        **** 						i=4;	// Got a result, stop polling
2742:WTPA.c        **** 					}
2743:WTPA.c        **** 				}
2744:WTPA.c        **** 
2745:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2746:WTPA.c        **** 				{
2747:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
2748:WTPA.c        **** 
2749:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
2750:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
2751:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
2752:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
2753:WTPA.c        **** 
2754:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
2755:WTPA.c        **** 
2756:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
2757:WTPA.c        **** 					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handl
2758:WTPA.c        **** 
2759:WTPA.c        **** 					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abor
2760:WTPA.c        **** 					{
2761:WTPA.c        **** 						cardState=SD_READ_ABORT;
2762:WTPA.c        **** 						sdAbortRead=false;
2763:WTPA.c        **** 					}
2764:WTPA.c        **** 				}
2765:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2766:WTPA.c        **** 				{
2767:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2768:WTPA.c        **** 				}
2769:WTPA.c        **** 			}
2770:WTPA.c        **** 			else	// Timed out starting read.
2771:WTPA.c        **** 			{
2772:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2773:WTPA.c        **** 			}
2774:WTPA.c        **** 			break;
2775:WTPA.c        **** 
2776:WTPA.c        **** 			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes 
2777:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
2778:WTPA.c        **** 			{
2779:WTPA.c        **** 				cardState=SD_READ_ABORT;
2780:WTPA.c        **** 				sdAbortRead=false;
2781:WTPA.c        **** 			}
2782:WTPA.c        **** 			else
2783:WTPA.c        **** 			{
2784:WTPA.c        **** 				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block
2785:WTPA.c        **** 				{
2786:WTPA.c        **** 					numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2787:WTPA.c        **** 				}
2788:WTPA.c        **** 				else	// Less than a chunk left in the block, read the rest of the block.
2789:WTPA.c        **** 				{
2790:WTPA.c        **** 					numTransferBytes=bytesLeftInBlock;
2791:WTPA.c        **** 				}
2792:WTPA.c        **** 
2793:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
2794:WTPA.c        **** 				{
2795:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
2796:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
2797:WTPA.c        **** 
2798:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
2799:WTPA.c        **** 					{
2800:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
2801:WTPA.c        **** 
2802:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
2803:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
2804:WTPA.c        **** 
2805:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2806:WTPA.c        **** 						{
2807:WTPA.c        **** 							sdFifoWritePointer=0;
2808:WTPA.c        **** 						}
2809:WTPA.c        **** 
2810:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2811:WTPA.c        **** 						cli();
2812:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
2813:WTPA.c        **** 						SREG=sreg;
2814:WTPA.c        **** 					}
2815:WTPA.c        **** 				}
2816:WTPA.c        **** 
2817:WTPA.c        **** 				// Check done-ness of block read:
2818:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
2819:WTPA.c        **** 				{
2820:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2821:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2822:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2823:WTPA.c        **** 						;
2824:WTPA.c        **** 
2825:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2826:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2827:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
2828:WTPA.c        **** 
2829:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
2830:WTPA.c        **** 					{
2831:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2832:WTPA.c        **** 							;
2833:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
2834:WTPA.c        **** 					}
2835:WTPA.c        **** 				}
2836:WTPA.c        **** 			}
2837:WTPA.c        **** 			break;
2838:WTPA.c        **** 
2839:WTPA.c        **** 			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through e
2840:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2841:WTPA.c        **** 			cli();
2842:WTPA.c        **** 
2843:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
2844:WTPA.c        **** 			{
2845:WTPA.c        **** 				SREG=sreg;				// ISR back on.
2846:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
2847:WTPA.c        **** 
2848:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
2849:WTPA.c        **** 				{
2850:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2851:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
2852:WTPA.c        **** 				}
2853:WTPA.c        **** 				else	// Read failed!
2854:WTPA.c        **** 				{
2855:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2856:WTPA.c        **** 				}
2857:WTPA.c        **** 			}
2858:WTPA.c        **** 			else	// ISR has not cleared enough of the sample out of the FIFO yet.
2859:WTPA.c        **** 			{
2860:WTPA.c        **** 				SREG=sreg;	// ISR back on.
2861:WTPA.c        **** 			}
2862:WTPA.c        **** 			break;
2863:WTPA.c        **** 
2864:WTPA.c        **** 
2865:WTPA.c        **** 			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token 
2866:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
2867:WTPA.c        **** 			{
2868:WTPA.c        **** 				i=0;
2869:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2870:WTPA.c        **** 				{
2871:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2872:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2873:WTPA.c        **** 					{
2874:WTPA.c        **** 						i++;	// Try again.
2875:WTPA.c        **** 					}
2876:WTPA.c        **** 					else
2877:WTPA.c        **** 					{
2878:WTPA.c        **** 						i=4;	// Got a result, stop polling
2879:WTPA.c        **** 					}
2880:WTPA.c        **** 				}
2881:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2882:WTPA.c        **** 				{
2883:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
2884:WTPA.c        **** 
2885:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
2886:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
2887:WTPA.c        **** 					{
2888:WTPA.c        **** 						cardState=SD_READ_ABORT;
2889:WTPA.c        **** 						sdAbortRead=false;
2890:WTPA.c        **** 					}
2891:WTPA.c        **** 				}
2892:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2893:WTPA.c        **** 				{
2894:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2895:WTPA.c        **** 				}
2896:WTPA.c        **** 			}
2897:WTPA.c        **** 			else	// Timed out starting read.
2898:WTPA.c        **** 			{
2899:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2900:WTPA.c        **** 			}
2901:WTPA.c        **** 			break;
2902:WTPA.c        **** 
2903:WTPA.c        **** 			case SD_READ_ABORT:				// We've been asked to start a new playback stream from the SD while a bl
2904:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2905:WTPA.c        **** 			{
2906:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2907:WTPA.c        **** 			}
2908:WTPA.c        **** 			else	// Less than a chunk left in the block, read the rest of the block.
2909:WTPA.c        **** 			{
2910:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2911:WTPA.c        **** 			}
2912:WTPA.c        **** 
2913:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
2914:WTPA.c        **** 			{
2915:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
2916:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
2917:WTPA.c        **** 			}
2918:WTPA.c        **** 
2919:WTPA.c        **** 			// Check done-ness of block read:
2920:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
2921:WTPA.c        **** 			{
2922:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2923:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2924:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2925:WTPA.c        **** 					;
2926:WTPA.c        **** 
2927:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
2928:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
2929:WTPA.c        **** 
2930:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2931:WTPA.c        **** 					;
2932:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
2933:WTPA.c        **** 
2934:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
2935:WTPA.c        **** 				{
2936:WTPA.c        **** 					sdPlaybackQueued=false;
2937:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
2938:WTPA.c        **** 				}
2939:WTPA.c        **** 			}
2940:WTPA.c        **** 			break;
2941:WTPA.c        **** 
2942:WTPA.c        **** 			case SD_IDLE:		// Do nothing if IDLE.
2943:WTPA.c        **** 			case SD_INVALID:	// If we're invalid, fall through and do nothing.
2944:WTPA.c        **** 			default:
2945:WTPA.c        **** 			break;
2946:WTPA.c        **** 		}
2947:WTPA.c        **** 	}
2948:WTPA.c        **** }
2949:WTPA.c        **** 
2950:WTPA.c        **** 
2951:WTPA.c        **** //-----------------------------------------------------------------------
2952:WTPA.c        **** //-----------------------------------------------------------------------
2953:WTPA.c        **** // SD Sample Read and Write Functions:
2954:WTPA.c        **** //-----------------------------------------------------------------------
2955:WTPA.c        **** //-----------------------------------------------------------------------
2956:WTPA.c        **** // The functions the main loop calls to get and put samples on the SD card.
2957:WTPA.c        **** // Sat Sep 24 19:08:17 EDT 2011
2958:WTPA.c        **** // This includes both the SD card state machine stuff (run from the main loop) and any ISRs needed 
2959:WTPA.c        **** 
2960:WTPA.c        **** 
2961:WTPA.c        **** static void InitSdIsr(void)
2962:WTPA.c        **** // Prepare a timer interrupt to handle filling and emptying the SD card's buffer
2963:WTPA.c        **** // This can fill the SRAM with data from the SD card, fill the SD card with data from the SRAM, or 
2964:WTPA.c        **** // NOTE -- we are using compare match B on timer 2 for this.  Compare match A is already used for t
2965:WTPA.c        **** // NOTE -- This means we have to call this after we finish the PWM business or the timer will be re
2966:WTPA.c        **** // Sat Sep 24 19:07:57 EDT 2011
2967:WTPA.c        **** // In our old code, we were reading and writing every 780 cycles (~25kHz) and playing back every 90
2968:WTPA.c        **** // In the new code we need to use 907/8 or 113 -- this gives a playback rate of about 22124, or an 
2969:WTPA.c        **** // We COULD go back and forth between 113 and 114, which gives us an average of 0.1% (1.73 cents) w
2970:WTPA.c        **** // Listening to some tests on the internet I can't tell the difference, so we do this the easy way 
2971:WTPA.c        **** // (Reading and writing don't matter, since we don't hear them and a small percentage difference wo
2972:WTPA.c        **** {
2973:WTPA.c        **** 	// Set up timer 2 OC2B to make SD buffer interrupts
2974:WTPA.c        **** 
2975:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
2976:WTPA.c        **** 
2977:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
2978:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
2979:WTPA.c        **** 	TCNT2=0;			// Init counter reg
2980:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
2981:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
2982:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
2983:WTPA.c        **** 
2984:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
2985:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
2986:WTPA.c        **** }
2987:WTPA.c        **** 
2988:WTPA.c        **** static void SdIsrStartReadingRam(unsigned char theBank)
2989:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
2990:WTPA.c        **** // Tell it to collect bytes from the passed bank and fill the buffer.
2991:WTPA.c        **** {
2992:WTPA.c        **** 	unsigned char
2993:WTPA.c        **** 		sreg;
2994:WTPA.c        **** 
2995:WTPA.c        **** 	sreg=SREG;
2996:WTPA.c        **** 	cli();		// Pause ISRs
2997:WTPA.c        **** 
2998:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
2999:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
3000:WTPA.c        **** 
3001:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
3002:WTPA.c        **** 	{
3003:WTPA.c        **** 		sdBank0=true;
3004:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
3005:WTPA.c        **** 	}
3006:WTPA.c        **** 	else
3007:WTPA.c        **** 	{
3008:WTPA.c        **** 		sdBank0=false;
3009:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3010:WTPA.c        **** 	}
3011:WTPA.c        **** 
3012:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3013:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3014:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3015:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3016:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3017:WTPA.c        **** 
3018:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3019:WTPA.c        **** }
3020:WTPA.c        **** 
3021:WTPA.c        **** static void SdIsrStartWritingRam(unsigned char theBank)
3022:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3023:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
3024:WTPA.c        **** {
3025:WTPA.c        **** 	unsigned char
3026:WTPA.c        **** 		sreg;
3027:WTPA.c        **** 
3028:WTPA.c        **** 	sreg=SREG;
3029:WTPA.c        **** 	cli();		// Pause ISRs
3030:WTPA.c        **** 
3031:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
3032:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
3033:WTPA.c        **** 
3034:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
3035:WTPA.c        **** 	{
3036:WTPA.c        **** 		sdBank0=true;
3037:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
3038:WTPA.c        **** 	}
3039:WTPA.c        **** 	else
3040:WTPA.c        **** 	{
3041:WTPA.c        **** 		sdBank0=false;
3042:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3043:WTPA.c        **** 	}
3044:WTPA.c        **** 
3045:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3046:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3047:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3048:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3049:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3050:WTPA.c        **** 
3051:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3052:WTPA.c        **** }
3053:WTPA.c        **** 
3054:WTPA.c        **** static void SdIsrStartStreamingAudio(void)
3055:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3056:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM.
3057:WTPA.c        **** {
3058:WTPA.c        **** 	unsigned char
3059:WTPA.c        **** 		sreg;
3060:WTPA.c        **** 
3061:WTPA.c        **** 	sreg=SREG;
3062:WTPA.c        **** 	cli();		// Pause ISRs
3063:WTPA.c        **** 
3064:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
3065:WTPA.c        **** 
3066:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3067:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
3068:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3069:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3070:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3071:WTPA.c        **** 
3072:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3073:WTPA.c        **** }
3074:WTPA.c        **** 
3075:WTPA.c        **** static unsigned long GetLengthOfSample(unsigned char theBank)
3076:WTPA.c        **** // Returns the length of the sample, handles my laziness.
3077:WTPA.c        **** {
3078:WTPA.c        **** 	unsigned long
3079:WTPA.c        **** 		theLength;
3080:WTPA.c        **** 
3081:WTPA.c        **** 	if(theBank==BANK_0)
3082:WTPA.c        **** 	{
3083:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3084:WTPA.c        **** 		{
3085:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
3086:WTPA.c        **** 		}
3087:WTPA.c        **** 		else
3088:WTPA.c        **** 		{
3089:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
3090:WTPA.c        **** 		}
3091:WTPA.c        **** 	}
3092:WTPA.c        **** 	else
3093:WTPA.c        **** 	{
3094:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3095:WTPA.c        **** 		{
3096:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
3097:WTPA.c        **** 		}
3098:WTPA.c        **** 		else
3099:WTPA.c        **** 		{
3100:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
3101:WTPA.c        **** 		}
3102:WTPA.c        **** 	}
3103:WTPA.c        **** 
3104:WTPA.c        **** 	return(theLength);
3105:WTPA.c        **** }
3106:WTPA.c        **** 
3107:WTPA.c        **** //------------------------------------------------------------------------------------------
3108:WTPA.c        **** // Below are the SD functions that we call from the mainline code to write, read and stream
3109:WTPA.c        **** //------------------------------------------------------------------------------------------
3110:WTPA.c        **** 
3111:WTPA.c        **** static void WriteSampleToSd(unsigned char theBank, unsigned int theSlot)
3112:WTPA.c        **** // Takes the sample currently in the passed bank, with any audio effects applied, and puts it in th
3113:WTPA.c        **** // Makes sure the SD card has been properly groomed first.
3114:WTPA.c        **** // NOTE: SD state machine will shut down the write process itself
3115:WTPA.c        **** {
3116:WTPA.c        **** 	unsigned long
3117:WTPA.c        **** 		theLength;
3118:WTPA.c        **** 	unsigned char
3119:WTPA.c        **** 		sreg;
3120:WTPA.c        **** 
3121:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3122:WTPA.c        **** 	{
3123:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3124:WTPA.c        **** 		{
3125:WTPA.c        **** 			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank
3126:WTPA.c        **** 
3127:WTPA.c        **** 			sreg=SREG;
3128:WTPA.c        **** 			cli();		// Pause ISR
3129:WTPA.c        **** 
3130:WTPA.c        **** 			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and 
3131:WTPA.c        **** 			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3132:WTPA.c        **** 
3133:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3134:WTPA.c        **** 		}
3135:WTPA.c        **** 	}
3136:WTPA.c        **** }
3137:WTPA.c        **** 
3138:WTPA.c        **** static void ReadSampleFromSd(unsigned char theBank, unsigned int theSlot)
3139:WTPA.c        **** // Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card 
3140:WTPA.c        **** {
3141:WTPA.c        **** 	unsigned char
3142:WTPA.c        **** 		sreg;
3143:WTPA.c        **** 
3144:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3145:WTPA.c        **** 	{
3146:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3147:WTPA.c        **** 		{
3148:WTPA.c        **** 			sreg=SREG;
3149:WTPA.c        **** 			cli();		// Pause ISR
3150:WTPA.c        **** 
3151:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
3152:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
3153:WTPA.c        **** 			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3154:WTPA.c        **** 
3155:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3156:WTPA.c        **** 		}
3157:WTPA.c        **** 	}
3158:WTPA.c        **** }
3159:WTPA.c        **** 
3160:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot)
3161:WTPA.c        **** // Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample i
3162:WTPA.c        **** {
3163:WTPA.c        **** 	unsigned char
3164:WTPA.c        **** 		sreg;
3165:WTPA.c        **** 
3166:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3167:WTPA.c        **** 	{
3168:WTPA.c        **** 		sreg=SREG;	 // Pause ISRs
3169:WTPA.c        **** 		cli();
3170:WTPA.c        **** 
3171:WTPA.c        **** 		SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3172:WTPA.c        **** 		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byte
3173:WTPA.c        **** 		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3174:WTPA.c        **** 
3175:WTPA.c        **** 		SREG=sreg;	// resume isr
3176:WTPA.c        **** 	}
3177:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
3178:WTPA.c        **** 	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck u
3179:WTPA.c        **** 	{
3180:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
3181:WTPA.c        **** 		{
3182:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
3183:WTPA.c        **** 			cli();
3184:WTPA.c        **** 
3185:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3186:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
3187:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3188:WTPA.c        **** 
3189:WTPA.c        **** 			SREG=sreg;	// resume isr
3190:WTPA.c        **** 		}
3191:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
3192:WTPA.c        **** 		{
3193:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3194:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3195:WTPA.c        **** 		}
3196:WTPA.c        **** 		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and
3197:WTPA.c        **** 		{
3198:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3199:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3200:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
3201:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
3202:WTPA.c        **** 
3203:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
3204:WTPA.c        **** 			cli();
3205:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
3206:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
3207:WTPA.c        **** 			SREG=sreg;
3208:WTPA.c        **** 		}
3209:WTPA.c        **** 	}
3210:WTPA.c        **** }
3211:WTPA.c        **** 
3212:WTPA.c        **** 
3213:WTPA.c        **** //static void CleanupSdPlayback(void)
3214:WTPA.c        **** // Runs in the main loop and makes sure that the SD state machine closes any blocks opened during S
3215:WTPA.c        **** // This happens if the user tells the sampler to do a different playback/record function and the IS
3216:WTPA.c        **** // NOTE -- the SD will not read from or write to RAM if the card is not idle, so we only need to wo
3217:WTPA.c        **** // Sun Nov 13 20:03:28 EST 2011
3218:WTPA.c        **** // Do we need to check for abort conditions anymore?  I kinda think not, since SD playback no longe
3219:WTPA.c        **** //{
3220:WTPA.c        **** //	if(sdIsrState==SD_ISR_IDLE)
3221:WTPA.c        **** //	{
3222:WTPA.c        **** //		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR 
3223:WTPA.c        **** //	}
3224:WTPA.c        **** 
3225:WTPA.c        **** /*
3226:WTPA.c        **** 	if(bankStates[BANK_0].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_0].audioFunction!=AUDIO_READ_
3227:WTPA.c        **** 	{
3228:WTPA.c        **** 		if(bankStates[BANK_1].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_1].audioFunction!=AUDIO_READ
3229:WTPA.c        **** 		{
3230:WTPA.c        **** 			if(cardState==SD_READ_START||cardState==SD_READING_BLOCK||cardState==SD_READ_FIFO_WAIT||cardStat
3231:WTPA.c        **** 			{
3232:WTPA.c        **** 				if(cardState==SD_READ_FIFO_WAIT)	// If we're waiting for the FIFO, we can just abort; there isn
3233:WTPA.c        **** 				{
3234:WTPA.c        **** 						cardState=SD_IDLE;	// Just end it.
3235:WTPA.c        **** 				}
3236:WTPA.c        **** 				else
3237:WTPA.c        **** 				{
3238:WTPA.c        **** 						sdAbortRead=true;	// We're in mid-read.  Let the state machine know to abort the read when it
3239:WTPA.c        **** 				}
3240:WTPA.c        **** 			}
3241:WTPA.c        **** 		}
3242:WTPA.c        **** 	}
3243:WTPA.c        **** */
3244:WTPA.c        **** //}
3245:WTPA.c        **** 
3246:WTPA.c        **** //--------------------------------------
3247:WTPA.c        **** //--------------------------------------
3248:WTPA.c        **** // MIDI Functions
3249:WTPA.c        **** //--------------------------------------
3250:WTPA.c        **** //--------------------------------------
3251:WTPA.c        **** // Control Changes messages are what tells the midi state machine what to do next.
3252:WTPA.c        **** 
3253:WTPA.c        **** /*
3254:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>5)		// About 9.6k -- This is MIDI N
3255:WTPA.c        **** #define		MIDI_GENERIC_NOTE		60											// We use this to pass our midi out note when the sampler 
3256:WTPA.c        **** */
3257:WTPA.c        **** 
3258:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>4)		// 4.8k -- This is MIDI Note 48
3259:WTPA.c        **** #define		MIDI_GENERIC_NOTE		48											// We use this to pass our midi out note when the sampler 
3260:WTPA.c        **** 
3261:WTPA.c        **** static unsigned int
3262:WTPA.c        **** 	theMidiRecordRate[NUM_BANKS];		// Make this from out EEPROM data.
3263:WTPA.c        **** 
3264:WTPA.c        **** // Control Change messages:
3265:WTPA.c        **** // The messages which control binary effects (like Half Speed, or backwards masking) are just inter
3266:WTPA.c        **** 
3267:WTPA.c        **** // Fri Mar 26 22:02:22 EDT 2010
3268:WTPA.c        **** // Renumbered to undefined CCs
3269:WTPA.c        **** 
3270:WTPA.c        **** #define		MIDI_RECORDING				3
3271:WTPA.c        **** #define		MIDI_OVERDUB				9
3272:WTPA.c        **** #define		MIDI_REALTIME				14
3273:WTPA.c        **** #define		MIDI_LOOP					15
3274:WTPA.c        **** #define		MIDI_HALF_SPEED				16
3275:WTPA.c        **** #define		MIDI_PLAY_BACKWARDS			17
3276:WTPA.c        **** #define		MIDI_CANCEL_EFFECTS			18
3277:WTPA.c        **** #define		MIDI_BIT_REDUCTION			19		// Crustiness quotient.
3278:WTPA.c        **** #define 	MIDI_GRANULARITY			20		// Beatbox.
3279:WTPA.c        **** #define 	MIDI_JITTER					21		// Hisssss
3280:WTPA.c        **** #define 	MIDI_OUTPUT_COMBINATION		22		// Set the output (SUM, XOR, AND, MULT) with this message.
3281:WTPA.c        **** #define 	MIDI_STORE_RECORD_NOTE		23		// Makes the next NOTE_ON into the record rate we'll use from 
3282:WTPA.c        **** 
3283:WTPA.c        **** // Editing functions:
3284:WTPA.c        **** 
3285:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_RESOLUTE	24
3286:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_RESOLUTE		25
3287:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE	26
3288:WTPA.c        **** #define 	MIDI_REVERT_SAMPLE_TO_FULL			27
3289:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_WIDE		28
3290:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_WIDE			29
3291:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_WIDE		30
3292:WTPA.c        **** 
3293:WTPA.c        **** static const unsigned int OctaveZeroCompareMatches[]=
3294:WTPA.c        **** // This table corresponds to a musical octave (the lowest octave we can generate with a 16-bit comp
3295:WTPA.c        **** {
3296:WTPA.c        **** 	65535,		// This is 300 Hz. (Followed by 600, 1.2k, 2.4k, 4.8k, 9.6k, 19.2k shifted over by 1 to 6 
3297:WTPA.c        **** 	61857,
3298:WTPA.c        **** 	58385,
3299:WTPA.c        **** 	55108,
3300:WTPA.c        **** 	52015,
3301:WTPA.c        **** 	49096,
3302:WTPA.c        **** 	46340,
3303:WTPA.c        **** 	43739,
3304:WTPA.c        **** 	41284,
3305:WTPA.c        **** 	38967,
3306:WTPA.c        **** 	36780,
3307:WTPA.c        **** 	34716,
3308:WTPA.c        **** };
3309:WTPA.c        **** 
3310:WTPA.c        **** enum	// Note names for lookups.
3311:WTPA.c        **** {
3312:WTPA.c        **** 	C_NOTE=0,
3313:WTPA.c        **** 	D_FLAT_NOTE,
3314:WTPA.c        **** 	D_NOTE,
3315:WTPA.c        **** 	E_FLAT_NOTE,
3316:WTPA.c        **** 	E_NOTE,
3317:WTPA.c        **** 	F_NOTE,
3318:WTPA.c        **** 	G_FLAT_NOTE,
3319:WTPA.c        **** 	G_NOTE,
3320:WTPA.c        **** 	A_FLAT_NOTE,
3321:WTPA.c        **** 	A_NOTE,
3322:WTPA.c        **** 	B_FLAT_NOTE,
3323:WTPA.c        **** 	B_NOTE,
3324:WTPA.c        **** };
3325:WTPA.c        **** 
3326:WTPA.c        **** static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
3327:WTPA.c        **** // Here we take a midi note number and turn it into the timer one compare match interrupt value.
3328:WTPA.c        **** {
3329:WTPA.c        **** 	unsigned char
3330:WTPA.c        **** 		theIndex,
3331:WTPA.c        **** 		theOctave;
3332:WTPA.c        **** 
3333:WTPA.c        **** 	theOctave=(theNote/12);	// Which octave?
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
3335:WTPA.c        **** 
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
3337:WTPA.c        **** 
3338:WTPA.c        **** }
3339:WTPA.c        **** 
3340:WTPA.c        **** //--------------------------------------
3341:WTPA.c        **** //--------------------------------------
3342:WTPA.c        **** // General Interface Functions
3343:WTPA.c        **** //--------------------------------------
3344:WTPA.c        **** //--------------------------------------
3345:WTPA.c        **** 
3346:WTPA.c        **** //==============================================
3347:WTPA.c        **** // Display update stuff, housekeeping:
3348:WTPA.c        **** 
3349:WTPA.c        **** static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
3350:WTPA.c        **** // We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for t
3351:WTPA.c        **** {
3352:WTPA.c        **** 	if(theBank==BANK_0)
3353:WTPA.c        **** 	{
3354:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
3355:WTPA.c        **** 	}
3356:WTPA.c        **** 	else if(theBank==BANK_1)
3357:WTPA.c        **** 	{
3358:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
3359:WTPA.c        **** 	}
3360:WTPA.c        **** }
3361:WTPA.c        **** 
3362:WTPA.c        **** static unsigned char GetMidiRecordNote(unsigned char theBank)
3363:WTPA.c        **** // Get the note we stored in EEPROM.
3364:WTPA.c        **** {
3365:WTPA.c        **** 	unsigned char
3366:WTPA.c        **** 		x;
3367:WTPA.c        **** 
3368:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3369:WTPA.c        **** 
3370:WTPA.c        **** 	if(theBank==BANK_0)
3371:WTPA.c        **** 	{
3372:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
3373:WTPA.c        **** 	}
3374:WTPA.c        **** 	else if(theBank==BANK_1)
3375:WTPA.c        **** 	{
3376:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
3377:WTPA.c        **** 	}
3378:WTPA.c        **** 
3379:WTPA.c        **** 	if(x<90)					// Legit number?
3380:WTPA.c        **** 	{
3381:WTPA.c        **** 		return(x);
3382:WTPA.c        **** 	}
3383:WTPA.c        **** 	else
3384:WTPA.c        **** 	{
3385:WTPA.c        **** 		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or 
3386:WTPA.c        **** 		return(x);
3387:WTPA.c        **** 	}
3388:WTPA.c        **** }
3389:WTPA.c        **** 
3390:WTPA.c        **** 
3391:WTPA.c        **** static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
3392:WTPA.c        **** // We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This
3393:WTPA.c        **** {
3394:WTPA.c        **** 	if(theBank==BANK_0)
3395:WTPA.c        **** 	{
3396:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
3397:WTPA.c        **** 	}
3398:WTPA.c        **** 	else if(theBank==BANK_1)
3399:WTPA.c        **** 	{
3400:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
3401:WTPA.c        **** 	}
3402:WTPA.c        **** }
3403:WTPA.c        **** 
3404:WTPA.c        **** 
3405:WTPA.c        **** static unsigned char GetMidiChannel(unsigned char theBank)
3406:WTPA.c        **** // Get the midi channel we stored in EEPROM.
3407:WTPA.c        **** {
3408:WTPA.c        **** 	unsigned char
3409:WTPA.c        **** 		x;
3410:WTPA.c        **** 
3411:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3412:WTPA.c        **** 
3413:WTPA.c        **** 	if(theBank==BANK_0)
3414:WTPA.c        **** 	{
3415:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
3416:WTPA.c        **** 	}
3417:WTPA.c        **** 	else if(theBank==BANK_1)
3418:WTPA.c        **** 	{
3419:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
3420:WTPA.c        **** 	}
3421:WTPA.c        **** 
3422:WTPA.c        **** 	if(x<16)					// Legit number?
3423:WTPA.c        **** 	{
3424:WTPA.c        **** 		return(x);
3425:WTPA.c        **** 	}
3426:WTPA.c        **** 	else
3427:WTPA.c        **** 	{
3428:WTPA.c        **** 		if(theBank==BANK_0)
3429:WTPA.c        **** 		{
3430:WTPA.c        **** 			x=0;			// If we've got poo poo in EEPROM or a bad address then default to the first midi channel
3431:WTPA.c        **** 		}
3432:WTPA.c        **** 		else
3433:WTPA.c        **** 		{
3434:WTPA.c        **** 			x=1;			// Return midi channel 2 if we're screwing up the second bank.
3435:WTPA.c        **** 		}
3436:WTPA.c        **** 		return(x);
3437:WTPA.c        **** 	}
3438:WTPA.c        **** }
3439:WTPA.c        **** 
3440:WTPA.c        **** static void BankStatesToLeds(unsigned char theBank)
3441:WTPA.c        **** // Looks at the current bank and decides how to set the LEDs.
3442:WTPA.c        **** {
3443:WTPA.c        **** 	unsigned char
3444:WTPA.c        **** 		temp;
3445:WTPA.c        **** 
3446:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
3447:WTPA.c        **** 
3448:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
3449:WTPA.c        **** 	{
3450:WTPA.c        **** 		temp|=Om_LED_REC;
3451:WTPA.c        **** 	}
3452:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
3453:WTPA.c        **** 	{
3454:WTPA.c        **** 		temp|=Om_LED_PLAY;
3455:WTPA.c        **** 	}
3456:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
3457:WTPA.c        **** 	{
3458:WTPA.c        **** 		temp|=Om_LED_ODUB;
3459:WTPA.c        **** 	}
3460:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
3461:WTPA.c        **** 	{
3462:WTPA.c        **** 		temp|=Om_LED_REC;
3463:WTPA.c        **** 		temp|=Om_LED_PLAY;
3464:WTPA.c        **** 		temp|=Om_LED_ODUB;
3465:WTPA.c        **** 	}
3466:WTPA.c        **** 
3467:WTPA.c        **** 	if(outOfRam==true)
3468:WTPA.c        **** 	{
3469:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
3470:WTPA.c        **** 	}
3471:WTPA.c        **** 	if(theBank==BANK_1)
3472:WTPA.c        **** 	{
3473:WTPA.c        **** 		temp|=Om_LED_BANK;
3474:WTPA.c        **** 	}
3475:WTPA.c        **** 
3476:WTPA.c        **** 	ledOnOffMask=temp;
3477:WTPA.c        **** 
3478:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
3479:WTPA.c        **** 	{
3480:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
3481:WTPA.c        **** 		{
3482:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
3483:WTPA.c        **** 		}
3484:WTPA.c        **** 	}
3485:WTPA.c        **** 	else
3486:WTPA.c        **** 	{
3487:WTPA.c        **** 		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we 
3488:WTPA.c        **** 	}
3489:WTPA.c        **** }
3490:WTPA.c        **** 
3491:WTPA.c        **** static void EncoderReadingToLeds(void)
3492:WTPA.c        **** // Take the value on our analog input, scale it, and display it on the LEDs.
3493:WTPA.c        **** // @@@ Note, this is a badly named function since it both generates the scaled global pot value AND
3494:WTPA.c        **** {
3495:WTPA.c        **** 	unsigned char
3496:WTPA.c        **** 		temp;
3497:WTPA.c        **** 
3498:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
3499:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
3500:WTPA.c        **** 
3501:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
3502:WTPA.c        **** 	{
3503:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
3504:WTPA.c        **** 	}
3505:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
3506:WTPA.c        **** 	{
3507:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
3508:WTPA.c        **** 	}
3509:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
3510:WTPA.c        **** 	{
3511:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
3512:WTPA.c        **** 	}
3513:WTPA.c        **** 
3514:WTPA.c        **** 	ledOnOffMask=temp;		// Update the leds.
3515:WTPA.c        **** }
3516:WTPA.c        **** 
3517:WTPA.c        **** static void CleanupAudioSources(void)
3518:WTPA.c        **** // Look through all the banks, and if none are using a given interrupt source, disable that interru
3519:WTPA.c        **** // Also voids the contributions those interrupts have to the audio output.
3520:WTPA.c        **** {
3521:WTPA.c        **** 	// If we aren't streaming from the SD, void contribution to the DAC
3522:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
3523:WTPA.c        **** 	{
3524:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
3525:WTPA.c        **** 	}
3526:WTPA.c        **** 
3527:WTPA.c        **** 	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
3528:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
3529:WTPA.c        **** 	{
3530:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
3531:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
3532:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
3533:WTPA.c        **** 	}
3534:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
3535:WTPA.c        **** 	{
3536:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
3537:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
3538:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
3539:WTPA.c        **** 	}
3540:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
3541:WTPA.c        **** 	{
3542:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
3543:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
3544:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
3545:WTPA.c        **** 	}
3546:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
3547:WTPA.c        **** 	{
3548:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
3549:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
3550:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
3551:WTPA.c        **** 	}
3552:WTPA.c        **** 
3553:WTPA.c        **** 	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop
3554:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
3555:WTPA.c        **** 	{
3556:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
3557:WTPA.c        **** 		{
3558:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
3559:WTPA.c        **** 		}
3560:WTPA.c        **** 	}
3561:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
3562:WTPA.c        **** 	{
3563:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
3564:WTPA.c        **** 		{
3565:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
3566:WTPA.c        **** 		}
3567:WTPA.c        **** 	}
3568:WTPA.c        **** }
3569:WTPA.c        **** 
3570:WTPA.c        **** //--------------------------------------
3571:WTPA.c        **** //--------------------------------------
3572:WTPA.c        **** // Granularizing Functions:
3573:WTPA.c        **** //--------------------------------------
3574:WTPA.c        **** //--------------------------------------
3575:WTPA.c        **** 
3576:WTPA.c        **** static unsigned long GetRandomLongInt(void)
3577:WTPA.c        **** {
3578:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
3579:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
3580:WTPA.c        **** 	{
3581:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3582:WTPA.c        **** 	}
3583:WTPA.c        **** 	return(random31);
3584:WTPA.c        **** }
3585:WTPA.c        **** 
3586:WTPA.c        **** /*
3587:WTPA.c        **** static void InitRandom(void)
3588:WTPA.c        **** // Maximal (?) LSFR implementation complements of "curtvm" on AVRFreaks.  Thanks!
3589:WTPA.c        **** // Not sure where his tap numbers came from, but we'll see how they work out.
3590:WTPA.c        **** // This LFSR is initialized here from the poo-poo (undef'd) area of RAM and checked against zero.  
3591:WTPA.c        **** {
3592:WTPA.c        **** 	if(random31==0)	 			// If init sram happens to be 0
3593:WTPA.c        **** 	{
3594:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3595:WTPA.c        **** 	}
3596:WTPA.c        **** }
3597:WTPA.c        **** */
3598:WTPA.c        **** 
3599:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
3600:WTPA.c        **** // Make a new random order of slices as big as the user wants, up to MAX_SLICES.
3601:WTPA.c        **** // We will first fill an array with incrementing numbers up to the number of slices we care about, 
3602:WTPA.c        **** // Leave this function having updated the number of slices our sample will be divided into and the 
3603:WTPA.c        **** // Further, point to the first random slice in the randomized array, and point the sample address t
3604:WTPA.c        **** {
3605:WTPA.c        **** 	unsigned char
3606:WTPA.c        **** 		sreg,
3607:WTPA.c        **** 		i,
3608:WTPA.c        **** 		origContents,
3609:WTPA.c        **** 		randIndex,
3610:WTPA.c        **** 		randContents;
3611:WTPA.c        **** 
3612:WTPA.c        **** 	if(numSlices>1)		// Enough slices to do something?
3613:WTPA.c        **** 	{
3614:WTPA.c        **** 		sreg=SREG;
3615:WTPA.c        **** 		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
3616:WTPA.c        **** 
3617:WTPA.c        **** 		if(numSlices>MAX_SLICES)
3618:WTPA.c        **** 		{
3619:WTPA.c        **** 			numSlices=MAX_SLICES;
3620:WTPA.c        **** 		}
3621:WTPA.c        **** 
3622:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
3623:WTPA.c        **** 		{
3624:WTPA.c        **** 			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwa
3625:WTPA.c        **** 		}
3626:WTPA.c        **** 
3627:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
3628:WTPA.c        **** 		{
3629:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
3630:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
3631:WTPA.c        **** 			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery ad
3632:WTPA.c        **** 			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the
3633:WTPA.c        **** 			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original reg
3634:WTPA.c        **** 		}
3635:WTPA.c        **** 
3636:WTPA.c        **** 		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
3637:WTPA.c        **** 		{
3638:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
3639:WTPA.c        **** 		}
3640:WTPA.c        **** 		else					// Otherwise assume banks grow down.
3641:WTPA.c        **** 		{
3642:WTPA.c        **** 			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
3643:WTPA.c        **** 		}
3644:WTPA.c        **** 
3645:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
3646:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
3647:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
3648:WTPA.c        **** 
3649:WTPA.c        **** 		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the fir
3650:WTPA.c        **** 		{
3651:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
3652:WTPA.c        **** 		}
3653:WTPA.c        **** 		else
3654:WTPA.c        **** 		{
3655:WTPA.c        **** 			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceS
3656:WTPA.c        **** 		}
3657:WTPA.c        **** 
3658:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
3659:WTPA.c        **** 	}
3660:WTPA.c        **** 	else
3661:WTPA.c        **** 	{
3662:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
3663:WTPA.c        **** 	}
3664:WTPA.c        **** }
3665:WTPA.c        **** 
3666:WTPA.c        **** //--------------------------------------
3667:WTPA.c        **** //--------------------------------------
3668:WTPA.c        **** // Shuttle / Loop Size Adjust Functions:
3669:WTPA.c        **** //--------------------------------------
3670:WTPA.c        **** //--------------------------------------
3671:WTPA.c        **** // These functions are called to bump the beginning of a sample forward or backward by an amount di
3672:WTPA.c        **** // The resolution of these functions is dependent on the absolute number of individual samples curr
3673:WTPA.c        **** // 	we divide the entire sample by 256 to find our "chunk size" and then shuttle the sample start /
3674:WTPA.c        **** // NOTE:  It is possible with these commands to position the sample's working boundaries such that 
3675:WTPA.c        **** // NOTE:  It is possible to move a sample's adjusted end come BEFORE its adjusted beginning.  We mu
3676:WTPA.c        **** // NOTE:  It is possible to have the sample roll around the end address.  Account for this.
3677:WTPA.c        **** 
3678:WTPA.c        **** // We will need to update the ISR so that playback rolls through the end address.
3679:WTPA.c        **** // Mon Nov  9 22:32:16 EST 2009 -- Think I got it.
3680:WTPA.c        **** 
3681:WTPA.c        **** // Thu Mar 25 21:44:28 EDT 2010
3682:WTPA.c        **** // Window problems.  When the window wraps around the absolute address of the sample, bad shit goes
3683:WTPA.c        **** // Fri Mar 26 14:46:06 EDT 2010
3684:WTPA.c        **** // Fixed.  I made some dumb changes to the ISR address wrapping and also didn't accout for the fact
3685:WTPA.c        **** 
3686:WTPA.c        **** // Fri Mar 26 18:55:07 EDT 2010
3687:WTPA.c        **** // Changed the way the whole sampler thinks about "direction" in playback.  The user sets the backw
3688:WTPA.c        **** // The variable read by the interrupt is "sampleDirection" which actually tells us which way to go 
3689:WTPA.c        **** // This system lets us arbitrarily set the way we want the sample to go, and then reverse it when t
3690:WTPA.c        **** 
3691:WTPA.c        **** static void UpdateAdjustedSampleAddresses(unsigned char theBank)
3692:WTPA.c        **** // Using window, start, and stop info, this routine sets the beginning and end point within a sampl
3693:WTPA.c        **** // We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of th
3694:WTPA.c        **** // Wed Jun 22 13:50:04 EDT 2011
3695:WTPA.c        **** // Now that we use an encoder we could adjust this more finely if we wanted to.
3696:WTPA.c        **** {
3697:WTPA.c        **** 	unsigned char
3698:WTPA.c        **** 		sreg;
3699:WTPA.c        **** 	unsigned long
3700:WTPA.c        **** 		chunkSize;
3701:WTPA.c        **** 
3702:WTPA.c        **** 	sreg=SREG;
3703:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
3704:WTPA.c        **** 
3705:WTPA.c        **** 	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
3706:WTPA.c        **** 	{
3707:WTPA.c        **** 		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of
3708:WTPA.c        **** 
3709:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3710:WTPA.c        **** 
3711:WTPA.c        **** 		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sam
3712:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_
3713:WTPA.c        **** 
3714:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3715:WTPA.c        **** 
3716:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse play
3717:WTPA.c        **** 		{
3718:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
3719:WTPA.c        **** 			{
3720:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
3721:WTPA.c        **** 			}
3722:WTPA.c        **** 			else
3723:WTPA.c        **** 			{
3724:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
3725:WTPA.c        **** 			}
3726:WTPA.c        **** 
3727:WTPA.c        **** 			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
3728:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to st
3729:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
3730:WTPA.c        **** 		}
3731:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3732:WTPA.c        **** 		{
3733:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
3734:WTPA.c        **** 			{
3735:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
3736:WTPA.c        **** 			}
3737:WTPA.c        **** 			else
3738:WTPA.c        **** 			{
3739:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
3740:WTPA.c        **** 			}
3741:WTPA.c        **** 		}
3742:WTPA.c        **** 
3743:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3744:WTPA.c        **** 
3745:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the e
3746:WTPA.c        **** 		{
3747:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK
3748:WTPA.c        **** 		}
3749:WTPA.c        **** 		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
3750:WTPA.c        **** 		{
3751:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].
3752:WTPA.c        **** 
3753:WTPA.c        **** 			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wra
3754:WTPA.c        **** 			{
3755:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
3756:WTPA.c        **** 			}
3757:WTPA.c        **** 		}
3758:WTPA.c        **** 
3759:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3760:WTPA.c        **** 
3761:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapp
3762:WTPA.c        **** 		{
3763:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
3764:WTPA.c        **** 			{
3765:WTPA.c        **** 				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BAN
3766:WTPA.c        **** 				{
3767:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;	// Round to the sta
3768:WTPA.c        **** 				}
3769:WTPA.c        **** 				else
3770:WTPA.c        **** 				{
3771:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;	// Round to the end.
3772:WTPA.c        **** 				}
3773:WTPA.c        **** 			}
3774:WTPA.c        **** 		}
3775:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is before the end).
3776:WTPA.c        **** 		{
3777:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
3778:WTPA.c        **** 			{
3779:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the 
3780:WTPA.c        **** 			}
3781:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
3782:WTPA.c        **** 			{
3783:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
3784:WTPA.c        **** 			}
3785:WTPA.c        **** 		}
3786:WTPA.c        **** 	}
3787:WTPA.c        **** 	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
3788:WTPA.c        **** 	{
3789:WTPA.c        **** 		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
3790:WTPA.c        **** 		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of 
3791:WTPA.c        **** 
3792:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3793:WTPA.c        **** 
3794:WTPA.c        **** 		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sam
3795:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_
3796:WTPA.c        **** 
3797:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3798:WTPA.c        **** 
3799:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse play
3800:WTPA.c        **** 		{
3801:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
3802:WTPA.c        **** 			{
3803:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
3804:WTPA.c        **** 			}
3805:WTPA.c        **** 			else
3806:WTPA.c        **** 			{
3807:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
3808:WTPA.c        **** 			}
3809:WTPA.c        **** 
3810:WTPA.c        **** 			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
3811:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to st
3812:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
3813:WTPA.c        **** 		}
3814:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3815:WTPA.c        **** 		{
3816:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
3817:WTPA.c        **** 			{
3818:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
3819:WTPA.c        **** 			}
3820:WTPA.c        **** 			else
3821:WTPA.c        **** 			{
3822:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
3823:WTPA.c        **** 			}
3824:WTPA.c        **** 		}
3825:WTPA.c        **** 
3826:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3827:WTPA.c        **** 
3828:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the e
3829:WTPA.c        **** 		{
3830:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bank
3831:WTPA.c        **** 		}
3832:WTPA.c        **** 		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
3833:WTPA.c        **** 		{
3834:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankSt
3835:WTPA.c        **** 
3836:WTPA.c        **** 			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wra
3837:WTPA.c        **** 			{
3838:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
3839:WTPA.c        **** 			}
3840:WTPA.c        **** 		}
3841:WTPA.c        **** 
3842:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3843:WTPA.c        **** 
3844:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapp
3845:WTPA.c        **** 		{
3846:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
3847:WTPA.c        **** 			{
3848:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BAN
3849:WTPA.c        **** 				{
3850:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;	// Round to the sta
3851:WTPA.c        **** 				}
3852:WTPA.c        **** 				else
3853:WTPA.c        **** 				{
3854:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;	// Round to the end.
3855:WTPA.c        **** 				}
3856:WTPA.c        **** 			}
3857:WTPA.c        **** 		}
3858:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is xxx the end).
3859:WTPA.c        **** 		{
3860:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
3861:WTPA.c        **** 			{
3862:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the 
3863:WTPA.c        **** 			}
3864:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
3865:WTPA.c        **** 			{
3866:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
3867:WTPA.c        **** 			}
3868:WTPA.c        **** 		}
3869:WTPA.c        **** 	}
3870:WTPA.c        **** 
3871:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
3872:WTPA.c        **** }
3873:WTPA.c        **** 
3874:WTPA.c        **** static void RevertSampleToUnadjusted(unsigned char theBank)
3875:WTPA.c        **** // Removes user adjustments to sample and returns it to maximum size.
3876:WTPA.c        **** // @@@ Since the current sample address must be within these bounds, there is no need to adjust it.
3877:WTPA.c        **** // @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
3878:WTPA.c        **** {
3879:WTPA.c        **** 	unsigned char
3880:WTPA.c        **** 		sreg;
3881:WTPA.c        **** 
3882:WTPA.c        **** 	sreg=SREG;
3883:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
3884:WTPA.c        **** 
3885:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
3886:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
3887:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
3888:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
3889:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
3890:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
3891:WTPA.c        **** }
3892:WTPA.c        **** 
3893:WTPA.c        **** static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
3894:WTPA.c        **** // Moves the memory location where the sample begins (or loops) playback farther into the sample.
3895:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3896:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3897:WTPA.c        **** {
3898:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
3899:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3900:WTPA.c        **** }
3901:WTPA.c        **** 
3902:WTPA.c        **** static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
3903:WTPA.c        **** // Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
3904:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3905:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3906:WTPA.c        **** {
3907:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
3908:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3909:WTPA.c        **** }
3910:WTPA.c        **** 
3911:WTPA.c        **** static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
3912:WTPA.c        **** // Shuttles the entire adjusted sample window farther into the sample.
3913:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3914:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3915:WTPA.c        **** {
3916:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
3917:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3918:WTPA.c        **** }
3919:WTPA.c        **** 
3920:WTPA.c        **** //--------------------------------------
3921:WTPA.c        **** //--------------------------------------
3922:WTPA.c        **** // SAMPLER Main Loop!
3923:WTPA.c        **** //--------------------------------------
3924:WTPA.c        **** //--------------------------------------
3925:WTPA.c        **** 
3926:WTPA.c        **** static unsigned char
3927:WTPA.c        **** 	currentBank;					// Keeps track of the bank we're thinking about.
3928:WTPA.c        **** 
3929:WTPA.c        **** static void SdCardMenu(void)
3930:WTPA.c        **** // Give the user a manual interface for managing samples stored on the SD card.
3931:WTPA.c        **** // LED_7 will blink if there is a sample in the currently selected slot.
3932:WTPA.c        **** // The index of the currently selected sample slot will be indicated on LEDs 0-6, and are scrolled 
3933:WTPA.c        **** // Below is the button map.
3934:WTPA.c        **** // NOTE:  Load and Save functions apply to the bank currently selected.
3935:WTPA.c        **** 
3936:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
3937:WTPA.c        **** // ------------------------------------------------------------------------------------------------
3938:WTPA.c        **** // No Shift:	Play		Load		Save		Delete		Exit		Exit		Exit		Exit
3939:WTPA.c        **** {
3940:WTPA.c        **** 	if(subState==SS_0)		// Initialize LEDs and slots
3941:WTPA.c        **** 	{		
3942:WTPA.c        **** 		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
3943:WTPA.c        **** 		{
3944:WTPA.c        **** 			sdCurrentSlot=127;
3945:WTPA.c        **** 		}		
3946:WTPA.c        **** 
3947:WTPA.c        **** 		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently lookin
3948:WTPA.c        **** 		StopBlinking();					// Make sure nothing is errantly blinking
3949:WTPA.c        **** 
3950:WTPA.c        **** 		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
3951:WTPA.c        **** 		{
3952:WTPA.c        **** 			BlinkLeds(1<<LED_7);
3953:WTPA.c        **** 		}	
3954:WTPA.c        **** 
3955:WTPA.c        **** 		subState=SS_1;
3956:WTPA.c        **** 	}
3957:WTPA.c        **** 	else
3958:WTPA.c        **** 	{
3959:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
3960:WTPA.c        **** 		{
3961:WTPA.c        **** 			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
3962:WTPA.c        **** 			{
3963:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
3964:WTPA.c        **** 			}
3965:WTPA.c        **** 
3966:WTPA.c        **** 			KillLeds();				// Exit menu
3967:WTPA.c        **** 			SetState(DoSampler);
3968:WTPA.c        **** 		}
3969:WTPA.c        **** 		else
3970:WTPA.c        **** 		{
3971:WTPA.c        **** 			if(newEncoder)		// Increment or decrement card slot if encoder moves
3972:WTPA.c        **** 			{
3973:WTPA.c        **** 				if(encoderCw)
3974:WTPA.c        **** 				{
3975:WTPA.c        **** 					sdCurrentSlot++;
3976:WTPA.c        **** 					if(sdCurrentSlot>127)
3977:WTPA.c        **** 					{
3978:WTPA.c        **** 						sdCurrentSlot=0;
3979:WTPA.c        **** 					}
3980:WTPA.c        **** 				}
3981:WTPA.c        **** 				else if(encoderCcw)
3982:WTPA.c        **** 				{
3983:WTPA.c        **** 					if(sdCurrentSlot==0)
3984:WTPA.c        **** 					{
3985:WTPA.c        **** 						sdCurrentSlot=127;
3986:WTPA.c        **** 					}
3987:WTPA.c        **** 					else
3988:WTPA.c        **** 					{
3989:WTPA.c        **** 						sdCurrentSlot--;
3990:WTPA.c        **** 					}
3991:WTPA.c        **** 				}
3992:WTPA.c        **** 
3993:WTPA.c        **** 				ledOnOffMask=sdCurrentSlot;		
3994:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
3995:WTPA.c        **** 				{
3996:WTPA.c        **** 					BlinkLeds(1<<LED_7);
3997:WTPA.c        **** 				}	
3998:WTPA.c        **** 				else
3999:WTPA.c        **** 				{
4000:WTPA.c        **** 					StopBlinking();
4001:WTPA.c        **** 					ledOnOffMask&=~(1<<LED_7);
4002:WTPA.c        **** 				}
4003:WTPA.c        **** 			}
4004:WTPA.c        **** 
4005:WTPA.c        **** 			if(newKeys&Im_SWITCH_0)		// Stream sample
4006:WTPA.c        **** 			{
4007:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4008:WTPA.c        **** 				{		
4009:WTPA.c        **** 					PlaySampleFromSd(sdCurrentSlot);
4010:WTPA.c        **** 				}
4011:WTPA.c        **** 			}		
4012:WTPA.c        **** 			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
4013:WTPA.c        **** 			{
4014:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4015:WTPA.c        **** 				{		
4016:WTPA.c        **** 					ReadSampleFromSd(currentBank,sdCurrentSlot);
4017:WTPA.c        **** 				}
4018:WTPA.c        **** 			}		
4019:WTPA.c        **** 			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
4020:WTPA.c        **** 			{
4021:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4022:WTPA.c        **** 				{
4023:WTPA.c        **** 					WriteSampleToSd(currentBank,sdCurrentSlot);
4024:WTPA.c        **** 					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
4025:WTPA.c        **** 				}
4026:WTPA.c        **** 			}		
4027:WTPA.c        **** 			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like 
4028:WTPA.c        **** 			{
4029:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4030:WTPA.c        **** 				{		
4031:WTPA.c        **** 					if(cardState==SD_IDLE)	// Got what we wanted?
4032:WTPA.c        **** 					{
4033:WTPA.c        **** 						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
4034:WTPA.c        **** 						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
4035:WTPA.c        **** 						StopBlinking();					// Update LED to reflect that this is now full
4036:WTPA.c        **** 						ledOnOffMask&=~(1<<LED_7);
4037:WTPA.c        **** 					}
4038:WTPA.c        **** 				}
4039:WTPA.c        **** 			}		
4040:WTPA.c        **** 			
4041:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
4042:WTPA.c        **** 			{
4043:WTPA.c        **** 				KillLeds();
4044:WTPA.c        **** 				SetState(DoSampler);
4045:WTPA.c        **** 			}
4046:WTPA.c        **** 		}
4047:WTPA.c        **** 	}
4048:WTPA.c        **** }
4049:WTPA.c        **** 
4050:WTPA.c        **** static void UpdateUserSwitches(void)
4051:WTPA.c        **** // Take the button-mashings of the player and translate them into something useful.
4052:WTPA.c        **** // There are two "shift" keys on WTPA2 (switch 6 and 7).
4053:WTPA.c        **** // Button functions are relative to how many shift keys are being held down: 0, one, or two.
4054:WTPA.c        **** 
4055:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
4056:WTPA.c        **** // ------------------------------------------------------------------------------------------------
4057:WTPA.c        **** // No Shift:	Rec			Odub		Restart		Single		Pause		Bank		Shift1		Shift2
4058:WTPA.c        **** // Shift 1:		BitDepth	Halftime	Realtime	Granular	SumMode		Backwards	(pressed)	(not pressed)
4059:WTPA.c        **** // Shift 2:		Edit Start	Edit End	Edit Wind	Play SD		Jitter		?			(not press)	(pressed)
4060:WTPA.c        **** // Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
4061:WTPA.c        **** {
4062:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4063:WTPA.c        **** 	// Two shift keys:
4064:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4065:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
4066:WTPA.c        **** 	{
4067:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
4068:WTPA.c        **** 		{
4069:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
4070:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
4071:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
4072:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
4073:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
4074:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
4075:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
4076:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
4077:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
4078:WTPA.c        **** 			bankStates[currentBank].realtimeOn=false;
4079:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
4080:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
4081:WTPA.c        **** 		}
4082:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
4083:WTPA.c        **** 		{
4084:WTPA.c        **** 			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
4085:WTPA.c        **** 			{
4086:WTPA.c        **** 				SetState(SdCardMenu);
4087:WTPA.c        **** 			}
4088:WTPA.c        **** 		}
4089:WTPA.c        **** 	}
4090:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4091:WTPA.c        **** 	// Shift 1:
4092:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4093:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
4094:WTPA.c        **** 	{
4095:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
4096:WTPA.c        **** 		{
4097:WTPA.c        **** 			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just
4098:WTPA.c        **** 			{
4099:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
4100:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
4101:WTPA.c        **** 			}
4102:WTPA.c        **** 		}
4103:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
4104:WTPA.c        **** 		{
4105:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
4106:WTPA.c        **** 			{
4107:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
4108:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
4109:WTPA.c        **** 			}
4110:WTPA.c        **** 			else
4111:WTPA.c        **** 			{
4112:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
4113:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
4114:WTPA.c        **** 			}
4115:WTPA.c        **** 		}
4116:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
4117:WTPA.c        **** 		{
4118:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
4119:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
4120:WTPA.c        **** 		}
4121:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- res
4122:WTPA.c        **** 		{
4123:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
4124:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
4125:WTPA.c        **** 		}
4126:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
4127:WTPA.c        **** 		{
4128:WTPA.c        **** 			if(newEncoder)	// Only change to new values
4129:WTPA.c        **** 			{
4130:WTPA.c        **** 				switch(scaledEncoderValue)
4131:WTPA.c        **** 				{
4132:WTPA.c        **** 					case 0:
4133:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4134:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4135:WTPA.c        **** 					break;
4136:WTPA.c        **** 
4137:WTPA.c        **** 					case 1:
4138:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
4139:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4140:WTPA.c        **** 					break;
4141:WTPA.c        **** 
4142:WTPA.c        **** 					case 2:
4143:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
4144:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4145:WTPA.c        **** 					break;
4146:WTPA.c        **** 
4147:WTPA.c        **** 					case 3:
4148:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
4149:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4150:WTPA.c        **** 					break;
4151:WTPA.c        **** 
4152:WTPA.c        **** 					default:
4153:WTPA.c        **** 					break;
4154:WTPA.c        **** 				}
4155:WTPA.c        **** 			}
4156:WTPA.c        **** 		}
4157:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
4158:WTPA.c        **** 		{
4159:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
4160:WTPA.c        **** 			{
4161:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
4162:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
4163:WTPA.c        **** 			}
4164:WTPA.c        **** 			else
4165:WTPA.c        **** 			{
4166:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
4167:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
4168:WTPA.c        **** 			}
4169:WTPA.c        **** 
4170:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
4171:WTPA.c        **** 		}
4172:WTPA.c        **** 	}
4173:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4174:WTPA.c        **** 	// Shift 2:
4175:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4176:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
4177:WTPA.c        **** 	{
4178:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
4179:WTPA.c        **** 		{
4180:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
4181:WTPA.c        **** 			{
4182:WTPA.c        **** 				AdjustSampleStart(currentBank,encoderValue);
4183:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
4184:WTPA.c        **** 			}
4185:WTPA.c        **** 		}
4186:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
4187:WTPA.c        **** 		{
4188:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
4189:WTPA.c        **** 			{
4190:WTPA.c        **** 				AdjustSampleEnd(currentBank,encoderValue);
4191:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
4192:WTPA.c        **** 			}
4193:WTPA.c        **** 		}
4194:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
4195:WTPA.c        **** 		{
4196:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
4197:WTPA.c        **** 			{
4198:WTPA.c        **** 				AdjustSampleWindow(currentBank,encoderValue);
4199:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
4200:WTPA.c        **** 			}
4201:WTPA.c        **** 		}
4202:WTPA.c        **** 
4203:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
4204:WTPA.c        **** 		{
4205:WTPA.c        **** 			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
4206:WTPA.c        **** 
4207:WTPA.c        **** 		}
4208:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)		// Update Jitter
4209:WTPA.c        **** 		{
4210:WTPA.c        **** 			//	bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;		// 
4211:WTPA.c        **** 		}
4212:WTPA.c        **** 	}
4213:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4214:WTPA.c        **** 	// No shift keys pressed:
4215:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4216:WTPA.c        **** 	else	// User isn't holding shift keys, look for single key presses
4217:WTPA.c        **** 	{
4218:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
4219:WTPA.c        **** 		{
4220:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
4221:WTPA.c        **** 			{
4222:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4223:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4224:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4225:WTPA.c        **** 			}
4226:WTPA.c        **** 			else											// We're not recording right now, so start doing it.
4227:WTPA.c        **** 			{
4228:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
4229:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
4230:WTPA.c        **** 			}
4231:WTPA.c        **** 		}
4232:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
4233:WTPA.c        **** 		{
4234:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
4235:WTPA.c        **** 			{
4236:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
4237:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4238:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
4239:WTPA.c        **** 			}
4240:WTPA.c        **** 			else							// We're not recording right now, so start doing it.
4241:WTPA.c        **** 			{
4242:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
4243:WTPA.c        **** 				{
4244:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
4245:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
4246:WTPA.c        **** 				}
4247:WTPA.c        **** 			}
4248:WTPA.c        **** 		}
4249:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
4250:WTPA.c        **** 		{
4251:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4252:WTPA.c        **** 			{
4253:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4254:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4255:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4256:WTPA.c        **** 			}
4257:WTPA.c        **** 		}
4258:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
4259:WTPA.c        **** 		{
4260:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4261:WTPA.c        **** 			{
4262:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
4263:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
4264:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4265:WTPA.c        **** 			}
4266:WTPA.c        **** 		}
4267:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
4268:WTPA.c        **** 		{
4269:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
4270:WTPA.c        **** 			{
4271:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4272:WTPA.c        **** 				{
4273:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
4274:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
4275:WTPA.c        **** 				}
4276:WTPA.c        **** 			}
4277:WTPA.c        **** 			else		// Pause whatever we were doing.
4278:WTPA.c        **** 			{
4279:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
4280:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
4281:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
4282:WTPA.c        **** 			}
4283:WTPA.c        **** 
4284:WTPA.c        **** 		}
4285:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
4286:WTPA.c        **** 		{
4287:WTPA.c        **** 			currentBank++;
4288:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
4289:WTPA.c        **** 			{
4290:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
4291:WTPA.c        **** 			}
4292:WTPA.c        **** 		}
4293:WTPA.c        **** 	}
4294:WTPA.c        **** }
4295:WTPA.c        **** 
4296:WTPA.c        **** static void DoSampler(void)
4297:WTPA.c        **** // Sampler main loop.  This handles getting switch inputs and MIDI and calling all the functions ne
4298:WTPA.c        **** // If we want to enter a "menu" we should leave this state and return when it's time to run normall
4299:WTPA.c        **** // An old note:
4300:WTPA.c        **** // Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do somethi
4301:WTPA.c        **** // power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be 
4302:WTPA.c        **** {
4303:WTPA.c        **** 	unsigned char
4304:WTPA.c        **** 		sreg;
4305:WTPA.c        **** 
4306:WTPA.c        **** 	static MIDI_MESSAGE
4307:WTPA.c        **** 		currentMidiMessage;				// Used to point to incoming midi messages.
4308:WTPA.c        **** 
4309:WTPA.c        **** 	static unsigned char
4310:WTPA.c        **** 		currentNoteOn[NUM_BANKS]=		// Used to keep track of what notes we've got on in MIDI.
4311:WTPA.c        **** 		{
4312:WTPA.c        **** 			60,							// In case we record, then overdub immediately without playing anything, we'll need a 
4313:WTPA.c        **** 			60,
4314:WTPA.c        **** 		};
4315:WTPA.c        **** 
4316:WTPA.c        **** 	unsigned int
4317:WTPA.c        **** 		pitchWheelValue;				// Figures out what to do with the pitchbend data.
4318:WTPA.c        **** 
4319:WTPA.c        **** 	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sam
4320:WTPA.c        **** 	{
4321:WTPA.c        **** 		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI
4322:WTPA.c        **** 
4323:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
4324:WTPA.c        **** 		{
4325:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
4326:WTPA.c        **** 
4327:WTPA.c        **** //			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
4328:WTPA.c        **** //			{
4329:WTPA.c        **** //				// Do this here.
4330:WTPA.c        **** //			}
4331:WTPA.c        **** 
4332:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
4333:WTPA.c        **** 			{
4334:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
4335:WTPA.c        **** 				{
4336:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
4337:WTPA.c        **** 					{
4338:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
4339:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
4340:WTPA.c        **** 					}
4341:WTPA.c        **** 				}
4342:WTPA.c        **** 			}
4343:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
4344:WTPA.c        **** 			{
4345:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
4346:WTPA.c        **** 
4347:WTPA.c        **** 				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
4348:WTPA.c        **** 				{
4349:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
4350:WTPA.c        **** 				}
4351:WTPA.c        **** 				else
4352:WTPA.c        **** 				{
4353:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
4354:WTPA.c        **** 					{
4355:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
4356:WTPA.c        **** 					}
4357:WTPA.c        **** 				}
4358:WTPA.c        **** 			}
4359:WTPA.c        **** 
4360:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
4361:WTPA.c        **** 			{
4362:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
4363:WTPA.c        **** 				{
4364:WTPA.c        **** 					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
4365:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4366:WTPA.c        **** 					{
4367:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
4368:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll defa
4369:WTPA.c        **** 					}
4370:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
4371:WTPA.c        **** 					{
4372:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4373:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4374:WTPA.c        **** 					}
4375:WTPA.c        **** 					break;
4376:WTPA.c        **** 
4377:WTPA.c        **** 					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
4378:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4379:WTPA.c        **** 					{
4380:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
4381:WTPA.c        **** 						{
4382:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
4383:WTPA.c        **** 							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll defaul
4384:WTPA.c        **** 						}
4385:WTPA.c        **** 					}
4386:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
4387:WTPA.c        **** 					{
4388:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
4389:WTPA.c        **** 					}
4390:WTPA.c        **** 					break;
4391:WTPA.c        **** 
4392:WTPA.c        **** 					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
4393:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4394:WTPA.c        **** 					{
4395:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
4396:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so th
4397:WTPA.c        **** 					}
4398:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
4399:WTPA.c        **** 					{
4400:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4401:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4402:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playba
4403:WTPA.c        **** 					}
4404:WTPA.c        **** 
4405:WTPA.c        **** 					break;
4406:WTPA.c        **** 
4407:WTPA.c        **** 					case MIDI_LOOP:							// Keep playing samples over again until note off.
4408:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4409:WTPA.c        **** 					{
4410:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4411:WTPA.c        **** 					}
4412:WTPA.c        **** 					else
4413:WTPA.c        **** 					{
4414:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
4415:WTPA.c        **** 					}
4416:WTPA.c        **** 					break;
4417:WTPA.c        **** 
4418:WTPA.c        **** 					case MIDI_HALF_SPEED:							// Skrew and chop.
4419:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4420:WTPA.c        **** 					{
4421:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
4422:WTPA.c        **** 					}
4423:WTPA.c        **** 					else
4424:WTPA.c        **** 					{
4425:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4426:WTPA.c        **** 					}
4427:WTPA.c        **** 					break;
4428:WTPA.c        **** 
4429:WTPA.c        **** 					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
4430:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4431:WTPA.c        **** 					{
4432:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
4433:WTPA.c        **** 					}
4434:WTPA.c        **** 					else
4435:WTPA.c        **** 					{
4436:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4437:WTPA.c        **** 					}
4438:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
4439:WTPA.c        **** 					break;
4440:WTPA.c        **** 
4441:WTPA.c        **** 					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
4442:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4443:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
4444:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
4445:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
4446:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4447:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4448:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4449:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4450:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
4451:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4452:WTPA.c        **** 					break;
4453:WTPA.c        **** 
4454:WTPA.c        **** 					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
4455:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
4456:WTPA.c        **** 					{
4457:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
4458:WTPA.c        **** 					}
4459:WTPA.c        **** 					break;
4460:WTPA.c        **** 
4461:WTPA.c        **** 					case MIDI_GRANULARITY:						// Beatbox.
4462:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4463:WTPA.c        **** 					break;
4464:WTPA.c        **** 
4465:WTPA.c        **** 					case MIDI_JITTER:							// Hisssss
4466:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
4467:WTPA.c        **** 					break;
4468:WTPA.c        **** 
4469:WTPA.c        **** 					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
4470:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
4471:WTPA.c        **** 					{
4472:WTPA.c        **** 						case 0:
4473:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
4474:WTPA.c        **** 						break;
4475:WTPA.c        **** 
4476:WTPA.c        **** 						case 1:
4477:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
4478:WTPA.c        **** 						break;
4479:WTPA.c        **** 
4480:WTPA.c        **** 						case 2:
4481:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
4482:WTPA.c        **** 						break;
4483:WTPA.c        **** 
4484:WTPA.c        **** 						case 3:
4485:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
4486:WTPA.c        **** 						break;
4487:WTPA.c        **** 
4488:WTPA.c        **** 						default:
4489:WTPA.c        **** 						break;
4490:WTPA.c        **** 					}
4491:WTPA.c        **** 					break;
4492:WTPA.c        **** 
4493:WTPA.c        **** 					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
4494:WTPA.c        **** 					sreg=SREG;
4495:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
4496:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
4497:WTPA.c        **** 					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelN
4498:WTPA.c        **** 					SREG=sreg;		// Re-enable interrupts.
4499:WTPA.c        **** 					break;
4500:WTPA.c        **** 
4501:WTPA.c        **** //	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-siz
4502:WTPA.c        **** 
4503:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
4504:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4505:WTPA.c        **** 					break;
4506:WTPA.c        **** 
4507:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
4508:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4509:WTPA.c        **** 					break;
4510:WTPA.c        **** 
4511:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
4512:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4513:WTPA.c        **** 					break;
4514:WTPA.c        **** 
4515:WTPA.c        **** 					case MIDI_REVERT_SAMPLE_TO_FULL:
4516:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
4517:WTPA.c        **** 					break;
4518:WTPA.c        **** 
4519:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_WIDE:
4520:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4521:WTPA.c        **** 					break;
4522:WTPA.c        **** 
4523:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_WIDE:
4524:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4525:WTPA.c        **** 					break;
4526:WTPA.c        **** 
4527:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
4528:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4529:WTPA.c        **** 					break;
4530:WTPA.c        **** 
4531:WTPA.c        **** 					default:
4532:WTPA.c        **** 					break;
4533:WTPA.c        **** 				}
4534:WTPA.c        **** 			}
4535:WTPA.c        **** 
4536:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
4537:WTPA.c        **** 			{
4538:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
4539:WTPA.c        **** 
4540:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
4541:WTPA.c        **** 				{
4542:WTPA.c        **** 					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This
4543:WTPA.c        **** 					{
4544:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4545:WTPA.c        **** 					}
4546:WTPA.c        **** 					else						// Pitch the note by some amount (add value to the OCR1A).
4547:WTPA.c        **** 					{
4548:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4549:WTPA.c        **** 					}
4550:WTPA.c        **** 				}
4551:WTPA.c        **** 				else
4552:WTPA.c        **** 				{
4553:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
4554:WTPA.c        **** 				}
4555:WTPA.c        **** 			}
4556:WTPA.c        **** 		}
4557:WTPA.c        **** 	}
4558:WTPA.c        **** 
4559:WTPA.c        **** //	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle clo
4560:WTPA.c        **** 	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Voi
4561:WTPA.c        **** 	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
4562:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
4563:WTPA.c        **** }
4564:WTPA.c        **** 
4565:WTPA.c        **** static void InitSampler(void)
4566:WTPA.c        **** // Gets all variables and data structures read and set when the sampler starts up.
4567:WTPA.c        **** {
4568:WTPA.c        **** 	unsigned char
4569:WTPA.c        **** 		i;
4570:WTPA.c        **** 
4571:WTPA.c        **** 	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
4572:WTPA.c        **** 	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
4573:WTPA.c        **** 	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcod
4574:WTPA.c        **** 	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcod
4575:WTPA.c        **** 
4576:WTPA.c        **** 	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
4577:WTPA.c        **** 	{
4578:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
4579:WTPA.c        **** 		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
4580:WTPA.c        **** 		bankStates[i].loopOnce=false;
4581:WTPA.c        **** 		bankStates[i].bitReduction=0;				// No crusties yet.
4582:WTPA.c        **** 		bankStates[i].jitterValue=0;				// No hissies yet.
4583:WTPA.c        **** 		bankStates[i].granularSlices=0;				// No remix yet.
4584:WTPA.c        **** 		bankStates[i].halfSpeed=false;
4585:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
4586:WTPA.c        **** 		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
4587:WTPA.c        **** 		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the begi
4588:WTPA.c        **** 		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sam
4589:WTPA.c        **** 		bankStates[i].realtimeOn=false;						// We'll default to playback.
4590:WTPA.c        **** 		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
4591:WTPA.c        **** 
4592:WTPA.c        **** 		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
4593:WTPA.c        **** 
4594:WTPA.c        **** 		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
4595:WTPA.c        **** 		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful numb
4596:WTPA.c        **** 	}
4597:WTPA.c        **** 
4598:WTPA.c        **** 	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4599:WTPA.c        **** 
4600:WTPA.c        **** 	currentBank=BANK_0;			// Point at the first bank until we change banks.
4601:WTPA.c        **** 	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
4602:WTPA.c        **** 
4603:WTPA.c        **** 	KillLeds();					// All leds off, and no blinking.
4604:WTPA.c        **** 	SetState(DoSampler);		// Get to sampling
4605:WTPA.c        **** }
4606:WTPA.c        **** 
4607:WTPA.c        **** //--------------------------------------
4608:WTPA.c        **** //--------------------------------------
4609:WTPA.c        **** // DAC Testing.
4610:WTPA.c        **** //--------------------------------------
4611:WTPA.c        **** //--------------------------------------
4612:WTPA.c        **** 
4613:WTPA.c        **** static void DoSawtooth(void)
4614:WTPA.c        **** // See if we can get some audio out.  And look good doing it.
4615:WTPA.c        **** // Also test to see if our flash is present and working.
4616:WTPA.c        **** {
4617:WTPA.c        **** 	if(subState==SS_0)
4618:WTPA.c        **** 	{
4619:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
4620:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
4621:WTPA.c        **** 		subState=SS_1;
4622:WTPA.c        **** 	}
4623:WTPA.c        **** 	else if(subState==SS_1)
4624:WTPA.c        **** 	{
4625:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4626:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
4627:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
4628:WTPA.c        **** 		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
4629:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4630:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4631:WTPA.c        **** 
4632:WTPA.c        **** 		subState=SS_2;					// And wait forever.
4633:WTPA.c        **** 	}
4634:WTPA.c        **** 	else if(subState==SS_2)
4635:WTPA.c        **** 	{
4636:WTPA.c        **** 
4637:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4638:WTPA.c        **** 		{
4639:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
4640:WTPA.c        **** 		}
4641:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4642:WTPA.c        **** 		{
4643:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
4644:WTPA.c        **** 		}
4645:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
4646:WTPA.c        **** 		{
4647:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
4648:WTPA.c        **** 		}
4649:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
4650:WTPA.c        **** 		{
4651:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
4652:WTPA.c        **** 		}
4653:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
4654:WTPA.c        **** 		{
4655:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
4656:WTPA.c        **** 		}
4657:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
4658:WTPA.c        **** 		{
4659:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
4660:WTPA.c        **** 		}
4661:WTPA.c        **** 
4662:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
4663:WTPA.c        **** 		{
4664:WTPA.c        **** 			StopBlinking();
4665:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
4666:WTPA.c        **** 		}
4667:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
4668:WTPA.c        **** 		{
4669:WTPA.c        **** 			StopBlinking();
4670:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
4671:WTPA.c        **** 		}
4672:WTPA.c        **** 		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
4673:WTPA.c        **** 		{
4674:WTPA.c        **** 			StopBlinking();
4675:WTPA.c        **** 			ledOnOffMask=encoderValue;
4676:WTPA.c        **** 		}
4677:WTPA.c        **** 	}
4678:WTPA.c        **** }
4679:WTPA.c        **** 
4680:WTPA.c        **** /*
4681:WTPA.c        **** static void MidiOutputTestBinnis(void)
4682:WTPA.c        **** {
4683:WTPA.c        **** 	if(subState==SS_0)
4684:WTPA.c        **** 	{
4685:WTPA.c        **** 		midiChannelNumberA=0x01;			// @@@ Hardcoded midi channel for now.
4686:WTPA.c        **** 		midiChannelNumberB=0x02;			// @@@ Hardcoded midi channel for now.
4687:WTPA.c        **** 		StopReadingPot();				// Make sure this silly business is gone (for now)
4688:WTPA.c        **** 		KillLeds();						// All leds off, and no blinking.
4689:WTPA.c        **** 		subState=SS_1;
4690:WTPA.c        **** 	}
4691:WTPA.c        **** 	else
4692:WTPA.c        **** 	{
4693:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4694:WTPA.c        **** 		{
4695:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_0));	// Toggle the LED.
4696:WTPA.c        **** 			// Hardcoded Note On, middle C, Velocity 64, Midi channel 1.
4697:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4698:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4699:WTPA.c        **** 			Uart0SendByte(64);			// @@@
4700:WTPA.c        **** 
4701:WTPA.c        **** 		}
4702:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4703:WTPA.c        **** 		{
4704:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_1));	// Toggle the LED.
4705:WTPA.c        **** 			// Hardcoded Note Off, middle C, Velocity 0, Midi channel 1.
4706:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4707:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4708:WTPA.c        **** 			Uart0SendByte(0);			// @@@
4709:WTPA.c        **** 		}
4710:WTPA.c        **** 	}
4711:WTPA.c        **** }
4712:WTPA.c        **** */
4713:WTPA.c        **** 
4714:WTPA.c        **** 
4715:WTPA.c        **** static void SetMidiChannels(void)
4716:WTPA.c        **** // This is a state the user can enter at startup where they set and store desired midi channels usi
4717:WTPA.c        **** {
4718:WTPA.c        **** 	if(subState==SS_0)
4719:WTPA.c        **** 	{
4720:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
4721:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
4722:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
4723:WTPA.c        **** 		subState=SS_1;
4724:WTPA.c        **** 	}
4725:WTPA.c        **** 	else
4726:WTPA.c        **** 	{
4727:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4728:WTPA.c        **** 		{
4729:WTPA.c        **** 			midiChannelNumberA++;
4730:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
4731:WTPA.c        **** 			{
4732:WTPA.c        **** 				midiChannelNumberA=0;
4733:WTPA.c        **** 			}
4734:WTPA.c        **** 
4735:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
4736:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
4737:WTPA.c        **** 		}
4738:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4739:WTPA.c        **** 		{
4740:WTPA.c        **** 			midiChannelNumberB++;
4741:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
4742:WTPA.c        **** 			{
4743:WTPA.c        **** 				midiChannelNumberB=0;
4744:WTPA.c        **** 			}
4745:WTPA.c        **** 
4746:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
4747:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
4748:WTPA.c        **** 		}
4749:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
4750:WTPA.c        **** 		{
4751:WTPA.c        **** 			StoreMidiChannel(BANK_0,midiChannelNumberA);
4752:WTPA.c        **** 			StoreMidiChannel(BANK_1,midiChannelNumberB);
4753:WTPA.c        **** 			SetState(InitSampler);
4754:WTPA.c        **** 		}
4755:WTPA.c        **** 	}
4756:WTPA.c        **** }
4757:WTPA.c        **** 
4758:WTPA.c        **** static void DoStartupSelect(void)
4759:WTPA.c        **** // Make all our initial state decisions.
4760:WTPA.c        **** // Give switches time to settle.
4761:WTPA.c        **** {
4762:WTPA.c        **** 	if(subState==SS_0)
4763:WTPA.c        **** 	{
4764:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
4765:WTPA.c        **** 		subState=SS_1;
4766:WTPA.c        **** 	}
4767:WTPA.c        **** 	else
4768:WTPA.c        **** 	{
4769:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4770:WTPA.c        **** 		{
4771:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
4772:WTPA.c        **** 			{
4773:WTPA.c        **** 				SetState(DoSawtooth);
4774:WTPA.c        **** 			}
4775:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
4776:WTPA.c        **** 			{
4777:WTPA.c        **** 				SetState(SetMidiChannels);
4778:WTPA.c        **** 			}
4779:WTPA.c        **** 			else
4780:WTPA.c        **** 			{
4781:WTPA.c        **** 				SetState(InitSampler);
4782:WTPA.c        **** 			}
4783:WTPA.c        **** 		}
4784:WTPA.c        **** 	}
4785:WTPA.c        **** }
4786:WTPA.c        **** 
4787:WTPA.c        **** static void DoFruitcakeIntro(void)
4788:WTPA.c        **** // Oh god why.
4789:WTPA.c        **** {
4790:WTPA.c        **** 	static unsigned char
4791:WTPA.c        **** 		i;
4792:WTPA.c        **** 
4793:WTPA.c        **** 	if(subState==SS_0)
4794:WTPA.c        **** 	{
4795:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4796:WTPA.c        **** 
4797:WTPA.c        **** 		KillLeds();
4798:WTPA.c        **** 		i=0;
4799:WTPA.c        **** 		ledOnOffMask=0;
4800:WTPA.c        **** 		subState=SS_1;
4801:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
4802:WTPA.c        **** 	}
4803:WTPA.c        **** 	else if(subState==SS_1)
4804:WTPA.c        **** 	{
4805:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4806:WTPA.c        **** 		{
4807:WTPA.c        **** 			subState=SS_2;
4808:WTPA.c        **** 		}
4809:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4810:WTPA.c        **** 	}
4811:WTPA.c        **** 
4812:WTPA.c        **** 	else if(subState==SS_2)
4813:WTPA.c        **** 	{
4814:WTPA.c        **** 		if(i<NUM_LEDS)
4815:WTPA.c        **** 		{
4816:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4817:WTPA.c        **** 			{
4818:WTPA.c        **** 				ledOnOffMask|=(1<<i);
4819:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
4820:WTPA.c        **** 				i++;
4821:WTPA.c        **** 			}
4822:WTPA.c        **** 		}
4823:WTPA.c        **** 		else
4824:WTPA.c        **** 		{
4825:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4826:WTPA.c        **** 			{
4827:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
4828:WTPA.c        **** 				ledPwm=255;
4829:WTPA.c        **** 				// Grudgingly enable pwm hackery.
4830:WTPA.c        **** 
4831:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
4832:WTPA.c        **** 
4833:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
4834:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
4835:WTPA.c        **** 				TCNT2=0;			// Init counter reg
4836:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
4837:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
4838:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
4839:WTPA.c        **** 
4840:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
4841:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
4842:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
4843:WTPA.c        **** 
4844:WTPA.c        **** 				subState=SS_3;
4845:WTPA.c        **** 			}
4846:WTPA.c        **** 		}
4847:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4848:WTPA.c        **** 	}
4849:WTPA.c        **** 	else if(subState==SS_3)
4850:WTPA.c        **** 	{
4851:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4852:WTPA.c        **** 		{
4853:WTPA.c        **** 			if(ledPwm>1)
4854:WTPA.c        **** 			{
4855:WTPA.c        **** 				ledPwm-=2;
4856:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
4857:WTPA.c        **** 			}
4858:WTPA.c        **** 			else
4859:WTPA.c        **** 			{
4860:WTPA.c        **** 				// Gleefully disable PWM.
4861:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
4862:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
4863:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
4864:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
4865:WTPA.c        **** 
4866:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
4867:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
4868:WTPA.c        **** 
4869:WTPA.c        **** 				KillLeds();				// App knows leds are off.
4870:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
4871:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
4872:WTPA.c        **** 				subState=SS_4;
4873:WTPA.c        **** 			}
4874:WTPA.c        **** 		}
4875:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4876:WTPA.c        **** 	}
4877:WTPA.c        **** 	else if(subState==SS_4)
4878:WTPA.c        **** 	{
4879:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4880:WTPA.c        **** 		{
4881:WTPA.c        **** 			KillLeds();
4882:WTPA.c        **** 			SetState(DoStartupSelect);		// Get crackin.
4883:WTPA.c        **** 		}
4884:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4885:WTPA.c        **** 	}
4886:WTPA.c        **** }
4887:WTPA.c        **** 
4888:WTPA.c        **** 
4889:WTPA.c        **** //-----------------------------------------------------------------------
4890:WTPA.c        **** //-----------------------------------------------------------------------
4891:WTPA.c        **** // Program main loop.
4892:WTPA.c        **** //-----------------------------------------------------------------------
4893:WTPA.c        **** //-----------------------------------------------------------------------
4894:WTPA.c        **** 
4895:WTPA.c        **** int main(void)
4896:WTPA.c        **** // Initialize this mess.
4897:WTPA.c        **** {
4898:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
4899:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
4900:WTPA.c        **** 
4901:WTPA.c        **** 	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initia
4902:WTPA.c        **** 
4903:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
4904:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
4905:WTPA.c        **** 
4906:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
4907:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
4908:WTPA.c        **** 
4909:WTPA.c        **** //	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pi
4910:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
4911:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
4912:WTPA.c        **** 
4913:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
4914:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
4915:WTPA.c        **** 
4916:WTPA.c        **** 	// Set the DAC to midscale to avoid pops on the first interrupt call.
4917:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
4918:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
4919:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
4920:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
4921:WTPA.c        **** 
4922:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
4923:WTPA.c        **** 	InitSwitches();
4924:WTPA.c        **** 	InitEncoder();
4925:WTPA.c        **** 	InitLeds();
4926:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
4927:WTPA.c        **** 	InitUart0();
4928:WTPA.c        **** //	InitUart1();
4929:WTPA.c        **** 	InitAdc();
4930:WTPA.c        **** 	InitSoftclock();
4931:WTPA.c        **** //	InitRandom();
4932:WTPA.c        **** 	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.
4933:WTPA.c        **** 
4934:WTPA.c        **** 	newKeys=0;
4935:WTPA.c        **** 	keyState=0;
4936:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
4937:WTPA.c        **** 	cardDetect=false;
4938:WTPA.c        **** 
4939:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
4940:WTPA.c        **** 
4941:WTPA.c        **** 	SetState(DoFruitcakeIntro);	// Get gay.
4942:WTPA.c        **** //	SetState(DoStartupSelect);
4943:WTPA.c        **** 
4944:WTPA.c        **** 	while(1)
4945:WTPA.c        **** 	{
4946:WTPA.c        **** 		HandleSwitches();		// Flag newKeys.
4947:WTPA.c        **** 		HandleEncoder();		// Keep track of encoder states and increment values.
4948:WTPA.c        **** 		HandleSoftclock();		// Keep the timer timing.
4949:WTPA.c        **** 		HandleLeds();			// Keep LEDs updated.
4950:WTPA.c        **** 		UpdateCard();			// Keep the SD card state machine running.
4951:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
4952:WTPA.c        **** 
4953:WTPA.c        **** //daNextJump=random31;
4954:WTPA.c        **** //daNextJumpPrime=(keyState+systemTicks);
4955:WTPA.c        **** 
4956:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
4957:WTPA.c        **** 		{
4958:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
4959:WTPA.c        **** 		}
4960:WTPA.c        **** 
4961:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
4962:WTPA.c        **** 		{
4963:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
4964:WTPA.c        **** 			{
4965:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
4966:WTPA.c        **** 			}
4967:WTPA.c        **** 		}
4968:WTPA.c        **** 
4969:WTPA.c        **** 		State();				// Execute the current program state.
4970:WTPA.c        **** 	}
4971:WTPA.c        **** 	return(0);
4972:WTPA.c        **** }
 2058               		.loc 1 4972 0
 2059 10f6 FF27      		clr r31
2106:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 2060               		.loc 1 2106 0
 2061 10f8 E050      		subi r30,lo8(-(sampleToc))
 2062 10fa F040      		sbci r31,hi8(-(sampleToc))
 2063 10fc 2081      		ld r18,Z
 2064 10fe 30E0      		ldi r19,0
2104:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 2065               		.loc 1 2104 0
 2066 1100 8770      		andi r24,7
 2067 1102 9927      		clr r25
 2068               	.LVL58:
2106:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 2069               		.loc 1 2106 0
 2070 1104 00C0      		rjmp 2f
 2071               		1:
 2072 1106 3595      		asr r19
 2073 1108 2795      		ror r18
 2074               		2:
 2075 110a 8A95      		dec r24
 2076 110c 02F4      		brpl 1b
2114:WTPA.c        **** }
 2077               		.loc 1 2114 0
 2078 110e 822F      		mov r24,r18
 2079 1110 8170      		andi r24,lo8(1)
 2080 1112 0895      		ret
 2081               		.cfi_endproc
 2082               	.LFE36:
 2085               	SdIsrStartStreamingAudio:
 2086               	.LFB48:
3057:WTPA.c        **** {
 2087               		.loc 1 3057 0
 2088               		.cfi_startproc
 2089               	/* prologue: function */
 2090               	/* frame size = 0 */
 2091               	/* stack size = 0 */
 2092               	.L__stack_usage = 0
3061:WTPA.c        **** 	sreg=SREG;
 2093               		.loc 1 3061 0
 2094 1114 9FB7      		in r25,__SREG__
 2095               	.LVL59:
3062:WTPA.c        **** 	cli();		// Pause ISRs
 2096               		.loc 1 3062 0
 2097               	/* #APP */
 2098               	 ;  3062 "WTPA.c" 1
 2099 1116 F894      		cli
 2100               	 ;  0 "" 2
3064:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
 2101               		.loc 1 3064 0
 2102               	/* #NOAPP */
 2103 1118 83E0      		ldi r24,lo8(3)
 2104 111a 8093 0000 		sts sdIsrState,r24
3066:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 2105               		.loc 1 3066 0
 2106 111e 1092 B200 		sts 178,__zero_reg__
3067:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 2107               		.loc 1 3067 0
 2108 1122 81E7      		ldi r24,lo8(113)
 2109 1124 8093 B300 		sts 179,r24
3068:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 2110               		.loc 1 3068 0
 2111 1128 8FEF      		ldi r24,lo8(-1)
 2112 112a 87BB      		out 0x17,r24
3069:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 2113               		.loc 1 3069 0
 2114 112c E0E7      		ldi r30,lo8(112)
 2115 112e F0E0      		ldi r31,0
 2116 1130 8081      		ld r24,Z
 2117 1132 8460      		ori r24,lo8(4)
 2118 1134 8083      		st Z,r24
3070:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 2119               		.loc 1 3070 0
 2120 1136 82E0      		ldi r24,lo8(2)
 2121 1138 8093 B100 		sts 177,r24
3072:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 2122               		.loc 1 3072 0
 2123 113c 9FBF      		out __SREG__,r25
 2124 113e 0895      		ret
 2125               		.cfi_endproc
 2126               	.LFE48:
 2129               	GetRandomLongInt:
 2130               	.LFB61:
3577:WTPA.c        **** {
 2131               		.loc 1 3577 0
 2132               		.cfi_startproc
 2133               	/* prologue: function */
 2134               	/* frame size = 0 */
 2135               	/* stack size = 0 */
 2136               	.L__stack_usage = 0
3578:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
 2137               		.loc 1 3578 0
 2138 1140 4091 0000 		lds r20,random31
 2139 1144 5091 0000 		lds r21,random31+1
 2140 1148 6091 0000 		lds r22,random31+2
 2141 114c 7091 0000 		lds r23,random31+3
3579:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
 2142               		.loc 1 3579 0
 2143 1150 DB01      		movw r26,r22
 2144 1152 CA01      		movw r24,r20
 2145 1154 880F      		lsl r24
 2146 1156 991F      		rol r25
 2147 1158 AA1F      		rol r26
 2148 115a BB1F      		rol r27
 2149 115c 76FF      		sbrs r23,6
 2150 115e 00C0      		rjmp .L132
 2151               	.L130:
3581:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 2152               		.loc 1 3581 0
 2153 1160 25EB      		ldi r18,181
 2154 1162 8227      		eor r24,r18
 2155 1164 25E9      		ldi r18,149
 2156 1166 9227      		eor r25,r18
 2157 1168 2AEA      		ldi r18,170
 2158 116a A227      		eor r26,r18
 2159 116c 20E2      		ldi r18,32
 2160 116e B227      		eor r27,r18
 2161               	.L132:
 2162 1170 8093 0000 		sts random31,r24
 2163 1174 9093 0000 		sts random31+1,r25
 2164 1178 A093 0000 		sts random31+2,r26
 2165 117c B093 0000 		sts random31+3,r27
3583:WTPA.c        **** 	return(random31);
 2166               		.loc 1 3583 0
 2167 1180 6091 0000 		lds r22,random31
 2168 1184 7091 0000 		lds r23,random31+1
3584:WTPA.c        **** }
 2169               		.loc 1 3584 0
 2170 1188 8091 0000 		lds r24,random31+2
 2171 118c 9091 0000 		lds r25,random31+3
 2172 1190 0895      		ret
 2173               		.cfi_endproc
 2174               	.LFE61:
 2177               	MakeNewGranularArray:
 2178               	.LFB62:
3604:WTPA.c        **** {
 2179               		.loc 1 3604 0
 2180               		.cfi_startproc
 2181               	.LVL60:
 2182 1192 2F92      		push r2
 2183               	.LCFI2:
 2184               		.cfi_def_cfa_offset 3
 2185               		.cfi_offset 2, -2
 2186 1194 3F92      		push r3
 2187               	.LCFI3:
 2188               		.cfi_def_cfa_offset 4
 2189               		.cfi_offset 3, -3
 2190 1196 4F92      		push r4
 2191               	.LCFI4:
 2192               		.cfi_def_cfa_offset 5
 2193               		.cfi_offset 4, -4
 2194 1198 5F92      		push r5
 2195               	.LCFI5:
 2196               		.cfi_def_cfa_offset 6
 2197               		.cfi_offset 5, -5
 2198 119a 6F92      		push r6
 2199               	.LCFI6:
 2200               		.cfi_def_cfa_offset 7
 2201               		.cfi_offset 6, -6
 2202 119c 7F92      		push r7
 2203               	.LCFI7:
 2204               		.cfi_def_cfa_offset 8
 2205               		.cfi_offset 7, -7
 2206 119e 8F92      		push r8
 2207               	.LCFI8:
 2208               		.cfi_def_cfa_offset 9
 2209               		.cfi_offset 8, -8
 2210 11a0 9F92      		push r9
 2211               	.LCFI9:
 2212               		.cfi_def_cfa_offset 10
 2213               		.cfi_offset 9, -9
 2214 11a2 AF92      		push r10
 2215               	.LCFI10:
 2216               		.cfi_def_cfa_offset 11
 2217               		.cfi_offset 10, -10
 2218 11a4 BF92      		push r11
 2219               	.LCFI11:
 2220               		.cfi_def_cfa_offset 12
 2221               		.cfi_offset 11, -11
 2222 11a6 CF92      		push r12
 2223               	.LCFI12:
 2224               		.cfi_def_cfa_offset 13
 2225               		.cfi_offset 12, -12
 2226 11a8 DF92      		push r13
 2227               	.LCFI13:
 2228               		.cfi_def_cfa_offset 14
 2229               		.cfi_offset 13, -13
 2230 11aa EF92      		push r14
 2231               	.LCFI14:
 2232               		.cfi_def_cfa_offset 15
 2233               		.cfi_offset 14, -14
 2234 11ac FF92      		push r15
 2235               	.LCFI15:
 2236               		.cfi_def_cfa_offset 16
 2237               		.cfi_offset 15, -15
 2238 11ae 0F93      		push r16
 2239               	.LCFI16:
 2240               		.cfi_def_cfa_offset 17
 2241               		.cfi_offset 16, -16
 2242 11b0 1F93      		push r17
 2243               	.LCFI17:
 2244               		.cfi_def_cfa_offset 18
 2245               		.cfi_offset 17, -17
 2246 11b2 CF93      		push r28
 2247               	.LCFI18:
 2248               		.cfi_def_cfa_offset 19
 2249               		.cfi_offset 28, -18
 2250 11b4 DF93      		push r29
 2251               	.LCFI19:
 2252               		.cfi_def_cfa_offset 20
 2253               		.cfi_offset 29, -19
 2254               	/* prologue: function */
 2255               	/* frame size = 0 */
 2256               	/* stack size = 18 */
 2257               	.L__stack_usage = 18
 2258 11b6 382E      		mov r3,r24
3612:WTPA.c        **** 	if(numSlices>1)		// Enough slices to do something?
 2259               		.loc 1 3612 0
 2260 11b8 6230      		cpi r22,lo8(2)
 2261 11ba 00F4      		brsh .+2
 2262 11bc 00C0      		rjmp .L134
3614:WTPA.c        **** 		sreg=SREG;
 2263               		.loc 1 3614 0
 2264 11be 9FB6      		in r9,__SREG__
 2265               	.LVL61:
3615:WTPA.c        **** 		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
 2266               		.loc 1 3615 0
 2267               	/* #APP */
 2268               	 ;  3615 "WTPA.c" 1
 2269 11c0 F894      		cli
 2270               	 ;  0 "" 2
 2271               	/* #NOAPP */
 2272 11c2 862E      		mov r8,r22
 2273 11c4 80E8      		ldi r24,lo8(-128)
 2274               	.LVL62:
 2275 11c6 8617      		cp r24,r22
 2276 11c8 00F4      		brsh .L135
 2277 11ca 00E8      		ldi r16,lo8(-128)
 2278 11cc 802E      		mov r8,r16
 2279               	.L135:
 2280               	.LVL63:
3599:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2281               		.loc 1 3599 0
 2282 11ce C32D      		mov r28,r3
 2283 11d0 D0E0      		ldi r29,0
 2284 11d2 9E01      		movw r18,r28
 2285 11d4 3695      		lsr r19
 2286 11d6 322F      		mov r19,r18
 2287 11d8 2227      		clr r18
 2288 11da 3795      		ror r19
 2289 11dc 2795      		ror r18
 2290 11de 2050      		subi r18,lo8(-(granularPositionArray))
 2291 11e0 3040      		sbci r19,hi8(-(granularPositionArray))
 2292 11e2 80E0      		ldi r24,0
 2293 11e4 90E0      		ldi r25,0
 2294               	.LVL64:
 2295               	.L136:
3599:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2296               		.loc 1 3599 0 is_stmt 0 discriminator 2
 2297 11e6 F901      		movw r30,r18
 2298 11e8 E80F      		add r30,r24
 2299 11ea F91F      		adc r31,r25
3624:WTPA.c        **** 			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwa
 2300               		.loc 1 3624 0 is_stmt 1 discriminator 2
 2301 11ec 8083      		st Z,r24
 2302               	.LVL65:
 2303 11ee 0196      		adiw r24,1
 2304               	.LVL66:
3622:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2305               		.loc 1 3622 0 discriminator 2
 2306 11f0 8815      		cp r24,r8
 2307 11f2 00F0      		brlo .L136
3599:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2308               		.loc 1 3599 0
 2309 11f4 6E01      		movw r12,r28
 2310 11f6 D694      		lsr r13
 2311 11f8 DC2C      		mov r13,r12
 2312 11fa CC24      		clr r12
 2313 11fc D794      		ror r13
 2314 11fe C794      		ror r12
 2315 1200 B0E0      		ldi r27,lo8(granularPositionArray)
 2316 1202 AB2E      		mov r10,r27
 2317 1204 B0E0      		ldi r27,hi8(granularPositionArray)
 2318 1206 BB2E      		mov r11,r27
 2319 1208 AC0C      		add r10,r12
 2320 120a BD1C      		adc r11,r13
 2321 120c 00E0      		ldi r16,0
 2322 120e 10E0      		ldi r17,0
3630:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
 2323               		.loc 1 3630 0
 2324 1210 482C      		mov r4,r8
 2325 1212 512C      		mov r5,__zero_reg__
 2326 1214 612C      		mov r6,__zero_reg__
 2327 1216 712C      		mov r7,__zero_reg__
 2328               	.LVL67:
 2329               	.L137:
3599:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2330               		.loc 1 3599 0 discriminator 2
 2331 1218 7501      		movw r14,r10
 2332 121a E00E      		add r14,r16
 2333 121c F11E      		adc r15,r17
3629:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
 2334               		.loc 1 3629 0 discriminator 2
 2335 121e D701      		movw r26,r14
 2336 1220 2C90      		ld r2,X
 2337               	.LVL68:
3630:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
 2338               		.loc 1 3630 0 discriminator 2
 2339 1222 0E94 0000 		call GetRandomLongInt
 2340               	.LVL69:
 2341 1226 A301      		movw r20,r6
 2342 1228 9201      		movw r18,r4
 2343 122a 0E94 0000 		call __udivmodsi4
 2344               	.LVL70:
3631:WTPA.c        **** 			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery ad
 2345               		.loc 1 3631 0 discriminator 2
 2346 122e FB01      		movw r30,r22
 2347 1230 EC0D      		add r30,r12
 2348 1232 FD1D      		adc r31,r13
 2349 1234 E050      		subi r30,lo8(-(granularPositionArray))
 2350 1236 F040      		sbci r31,hi8(-(granularPositionArray))
 2351 1238 8081      		ld r24,Z
 2352               	.LVL71:
3632:WTPA.c        **** 			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the
 2353               		.loc 1 3632 0 discriminator 2
 2354 123a D701      		movw r26,r14
 2355 123c 8C93      		st X,r24
3633:WTPA.c        **** 			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original reg
 2356               		.loc 1 3633 0 discriminator 2
 2357 123e 2082      		st Z,r2
 2358 1240 0F5F      		subi r16,-1
 2359 1242 1F4F      		sbci r17,-1
3627:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
 2360               		.loc 1 3627 0 discriminator 2
 2361 1244 0815      		cp r16,r8
 2362 1246 00F0      		brlo .L137
3636:WTPA.c        **** 		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
 2363               		.loc 1 3636 0
 2364 1248 3110      		cpse r3,__zero_reg__
 2365 124a 00C0      		rjmp .L138
3638:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
 2366               		.loc 1 3638 0
 2367 124c 6091 0000 		lds r22,bankStates+13
 2368 1250 7091 0000 		lds r23,bankStates+13+1
 2369 1254 8091 0000 		lds r24,bankStates+13+2
 2370 1258 9091 0000 		lds r25,bankStates+13+3
 2371 125c A301      		movw r20,r6
 2372 125e 9201      		movw r18,r4
 2373 1260 0E94 0000 		call __udivmodsi4
 2374 1264 2093 0000 		sts sliceSize,r18
 2375 1268 3093 0000 		sts sliceSize+1,r19
 2376 126c 4093 0000 		sts sliceSize+2,r20
 2377 1270 5093 0000 		sts sliceSize+3,r21
 2378 1274 00C0      		rjmp .L139
 2379               	.L138:
3642:WTPA.c        **** 			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
 2380               		.loc 1 3642 0
 2381 1276 0091 0000 		lds r16,bankStates+49
 2382 127a 1091 0000 		lds r17,bankStates+49+1
 2383 127e 2091 0000 		lds r18,bankStates+49+2
 2384 1282 3091 0000 		lds r19,bankStates+49+3
 2385 1286 6FEF      		ldi r22,lo8(-1)
 2386 1288 7FEF      		ldi r23,lo8(-1)
 2387 128a 87E0      		ldi r24,lo8(7)
 2388 128c 90E0      		ldi r25,0
 2389 128e 601B      		sub r22,r16
 2390 1290 710B      		sbc r23,r17
 2391 1292 820B      		sbc r24,r18
 2392 1294 930B      		sbc r25,r19
 2393 1296 A301      		movw r20,r6
 2394 1298 9201      		movw r18,r4
 2395 129a 0E94 0000 		call __udivmodsi4
 2396 129e 2093 0000 		sts sliceSize+4,r18
 2397 12a2 3093 0000 		sts sliceSize+4+1,r19
 2398 12a6 4093 0000 		sts sliceSize+4+2,r20
 2399 12aa 5093 0000 		sts sliceSize+4+3,r21
 2400               	.L139:
3645:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
 2401               		.loc 1 3645 0
 2402 12ae 84E2      		ldi r24,lo8(36)
 2403               	.LVL72:
 2404 12b0 8C9F      		mul r24,r28
 2405 12b2 F001      		movw r30,r0
 2406 12b4 8D9F      		mul r24,r29
 2407 12b6 F00D      		add r31,r0
 2408 12b8 1124      		clr __zero_reg__
 2409 12ba E050      		subi r30,lo8(-(bankStates))
 2410 12bc F040      		sbci r31,hi8(-(bankStates))
 2411 12be 8782      		std Z+7,r8
3646:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
 2412               		.loc 1 3646 0
 2413 12c0 FE01      		movw r30,r28
 2414 12c2 E050      		subi r30,lo8(-(granularPositionArrayPointer))
 2415 12c4 F040      		sbci r31,hi8(-(granularPositionArrayPointer))
 2416 12c6 1082      		st Z,__zero_reg__
3647:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
 2417               		.loc 1 3647 0
 2418 12c8 CC0F      		lsl r28
 2419 12ca DD1F      		rol r29
 2420 12cc CC0F      		lsl r28
 2421 12ce DD1F      		rol r29
 2422 12d0 FE01      		movw r30,r28
 2423 12d2 E050      		subi r30,lo8(-(sliceSize))
 2424 12d4 F040      		sbci r31,hi8(-(sliceSize))
 2425 12d6 8081      		ld r24,Z
 2426 12d8 9181      		ldd r25,Z+1
 2427 12da A281      		ldd r26,Z+2
 2428 12dc B381      		ldd r27,Z+3
 2429 12de C050      		subi r28,lo8(-(sliceRemaining))
 2430 12e0 D040      		sbci r29,hi8(-(sliceRemaining))
 2431 12e2 8883      		st Y,r24
 2432 12e4 9983      		std Y+1,r25
 2433 12e6 AA83      		std Y+2,r26
 2434 12e8 BB83      		std Y+3,r27
3649:WTPA.c        **** 		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the fir
 2435               		.loc 1 3649 0
 2436 12ea 3110      		cpse r3,__zero_reg__
 2437 12ec 00C0      		rjmp .L140
3651:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
 2438               		.loc 1 3651 0
 2439 12ee 2091 0000 		lds r18,sliceSize
 2440 12f2 3091 0000 		lds r19,sliceSize+1
 2441 12f6 4091 0000 		lds r20,sliceSize+2
 2442 12fa 5091 0000 		lds r21,sliceSize+3
 2443 12fe A091 0000 		lds r26,granularPositionArray
 2444 1302 B0E0      		ldi r27,0
 2445 1304 0E94 0000 		call __muluhisi3
 2446 1308 6093 0000 		sts bankStates+32,r22
 2447 130c 7093 0000 		sts bankStates+32+1,r23
 2448 1310 8093 0000 		sts bankStates+32+2,r24
 2449 1314 9093 0000 		sts bankStates+32+3,r25
 2450 1318 00C0      		rjmp .L141
 2451               	.L140:
3655:WTPA.c        **** 			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceS
 2452               		.loc 1 3655 0
 2453 131a 2091 0000 		lds r18,sliceSize+4
 2454 131e 3091 0000 		lds r19,sliceSize+4+1
 2455 1322 4091 0000 		lds r20,sliceSize+4+2
 2456 1326 5091 0000 		lds r21,sliceSize+4+3
 2457 132a A091 0000 		lds r26,granularPositionArray+128
 2458 132e B0E0      		ldi r27,0
 2459 1330 0E94 0000 		call __muluhisi3
 2460 1334 0FEF      		ldi r16,lo8(-1)
 2461 1336 1FEF      		ldi r17,lo8(-1)
 2462 1338 27E0      		ldi r18,lo8(7)
 2463 133a 30E0      		ldi r19,0
 2464 133c 061B      		sub r16,r22
 2465 133e 170B      		sbc r17,r23
 2466 1340 280B      		sbc r18,r24
 2467 1342 390B      		sbc r19,r25
 2468 1344 0093 0000 		sts bankStates+68,r16
 2469 1348 1093 0000 		sts bankStates+68+1,r17
 2470 134c 2093 0000 		sts bankStates+68+2,r18
 2471 1350 3093 0000 		sts bankStates+68+3,r19
 2472               	.L141:
3658:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 2473               		.loc 1 3658 0
 2474 1354 9FBE      		out __SREG__,r9
 2475 1356 00C0      		rjmp .L133
 2476               	.LVL73:
 2477               	.L134:
3662:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
 2478               		.loc 1 3662 0
 2479 1358 B4E2      		ldi r27,lo8(36)
 2480 135a 8B9F      		mul r24,r27
 2481 135c F001      		movw r30,r0
 2482 135e 1124      		clr __zero_reg__
 2483 1360 E050      		subi r30,lo8(-(bankStates))
 2484 1362 F040      		sbci r31,hi8(-(bankStates))
 2485 1364 1782      		std Z+7,__zero_reg__
 2486               	.LVL74:
 2487               	.L133:
 2488               	/* epilogue start */
3664:WTPA.c        **** }
 2489               		.loc 1 3664 0
 2490 1366 DF91      		pop r29
 2491 1368 CF91      		pop r28
 2492 136a 1F91      		pop r17
 2493 136c 0F91      		pop r16
 2494 136e FF90      		pop r15
 2495 1370 EF90      		pop r14
 2496 1372 DF90      		pop r13
 2497 1374 CF90      		pop r12
 2498 1376 BF90      		pop r11
 2499 1378 AF90      		pop r10
 2500 137a 9F90      		pop r9
 2501 137c 8F90      		pop r8
 2502 137e 7F90      		pop r7
 2503 1380 6F90      		pop r6
 2504 1382 5F90      		pop r5
 2505 1384 4F90      		pop r4
 2506 1386 3F90      		pop r3
 2507               	.LVL75:
 2508 1388 2F90      		pop r2
 2509 138a 0895      		ret
 2510               		.cfi_endproc
 2511               	.LFE62:
 2514               	UpdateAdjustedSampleAddresses:
 2515               	.LFB63:
3696:WTPA.c        **** {
 2516               		.loc 1 3696 0
 2517               		.cfi_startproc
 2518               	.LVL76:
 2519 138c 4F92      		push r4
 2520               	.LCFI20:
 2521               		.cfi_def_cfa_offset 3
 2522               		.cfi_offset 4, -2
 2523 138e 5F92      		push r5
 2524               	.LCFI21:
 2525               		.cfi_def_cfa_offset 4
 2526               		.cfi_offset 5, -3
 2527 1390 6F92      		push r6
 2528               	.LCFI22:
 2529               		.cfi_def_cfa_offset 5
 2530               		.cfi_offset 6, -4
 2531 1392 7F92      		push r7
 2532               	.LCFI23:
 2533               		.cfi_def_cfa_offset 6
 2534               		.cfi_offset 7, -5
 2535 1394 8F92      		push r8
 2536               	.LCFI24:
 2537               		.cfi_def_cfa_offset 7
 2538               		.cfi_offset 8, -6
 2539 1396 9F92      		push r9
 2540               	.LCFI25:
 2541               		.cfi_def_cfa_offset 8
 2542               		.cfi_offset 9, -7
 2543 1398 AF92      		push r10
 2544               	.LCFI26:
 2545               		.cfi_def_cfa_offset 9
 2546               		.cfi_offset 10, -8
 2547 139a BF92      		push r11
 2548               	.LCFI27:
 2549               		.cfi_def_cfa_offset 10
 2550               		.cfi_offset 11, -9
 2551 139c CF92      		push r12
 2552               	.LCFI28:
 2553               		.cfi_def_cfa_offset 11
 2554               		.cfi_offset 12, -10
 2555 139e DF92      		push r13
 2556               	.LCFI29:
 2557               		.cfi_def_cfa_offset 12
 2558               		.cfi_offset 13, -11
 2559 13a0 EF92      		push r14
 2560               	.LCFI30:
 2561               		.cfi_def_cfa_offset 13
 2562               		.cfi_offset 14, -12
 2563 13a2 FF92      		push r15
 2564               	.LCFI31:
 2565               		.cfi_def_cfa_offset 14
 2566               		.cfi_offset 15, -13
 2567               	/* prologue: function */
 2568               	/* frame size = 0 */
 2569               	/* stack size = 12 */
 2570               	.L__stack_usage = 12
3702:WTPA.c        **** 	sreg=SREG;
 2571               		.loc 1 3702 0
 2572 13a4 EFB7      		in r30,__SREG__
 2573               	.LVL77:
3703:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 2574               		.loc 1 3703 0
 2575               	/* #APP */
 2576               	 ;  3703 "WTPA.c" 1
 2577 13a6 F894      		cli
 2578               	 ;  0 "" 2
3705:WTPA.c        **** 	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
 2579               		.loc 1 3705 0
 2580               	/* #NOAPP */
 2581 13a8 8111      		cpse r24,__zero_reg__
 2582 13aa 00C0      		rjmp .L146
3707:WTPA.c        **** 		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of
 2583               		.loc 1 3707 0
 2584 13ac 8090 0000 		lds r8,bankStates+13
 2585 13b0 9090 0000 		lds r9,bankStates+13+1
 2586 13b4 A090 0000 		lds r10,bankStates+13+2
 2587 13b8 B090 0000 		lds r11,bankStates+13+3
 2588 13bc 83E0      		ldi r24,3
 2589               		1:
 2590 13be 880C      		lsl r8
 2591 13c0 991C      		rol r9
 2592 13c2 AA1C      		rol r10
 2593 13c4 BB1C      		rol r11
 2594 13c6 8A95      		dec r24
 2595 13c8 01F4      		brne 1b
 2596               	.LVL78:
 2597 13ca 892C      		mov r8,r9
 2598 13cc 9A2C      		mov r9,r10
 2599 13ce AB2C      		mov r10,r11
 2600 13d0 BB24      		clr r11
 2601               	.LVL79:
3711:WTPA.c        **** 		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sam
 2602               		.loc 1 3711 0
 2603 13d2 A091 0000 		lds r26,bankStates+29
 2604 13d6 8091 0000 		lds r24,bankStates+31
 2605 13da B0E0      		ldi r27,0
 2606 13dc A80F      		add r26,r24
 2607 13de B11D      		adc r27,__zero_reg__
 2608 13e0 A501      		movw r20,r10
 2609 13e2 9401      		movw r18,r8
 2610 13e4 0E94 0000 		call __muluhisi3
 2611 13e8 F3E0      		ldi r31,3
 2612               		1:
 2613 13ea 9695      		lsr r25
 2614 13ec 8795      		ror r24
 2615 13ee 7795      		ror r23
 2616 13f0 6795      		ror r22
 2617 13f2 FA95      		dec r31
 2618 13f4 01F4      		brne 1b
 2619 13f6 6093 0000 		sts bankStates+25,r22
 2620 13fa 7093 0000 		sts bankStates+25+1,r23
 2621 13fe 8093 0000 		sts bankStates+25+2,r24
 2622 1402 9093 0000 		sts bankStates+25+3,r25
3712:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_
 2623               		.loc 1 3712 0
 2624 1406 4090 0000 		lds r4,bankStates+13
 2625 140a 5090 0000 		lds r5,bankStates+13+1
 2626 140e 6090 0000 		lds r6,bankStates+13+2
 2627 1412 7090 0000 		lds r7,bankStates+13+3
 2628 1416 F091 0000 		lds r31,bankStates+30
 2629 141a A091 0000 		lds r26,bankStates+31
 2630 141e B0E0      		ldi r27,0
 2631 1420 0E94 0000 		call __muluhisi3
 2632 1424 6B01      		movw r12,r22
 2633 1426 7C01      		movw r14,r24
 2634 1428 A3E0      		ldi r26,3
 2635               		1:
 2636 142a F694      		lsr r15
 2637 142c E794      		ror r14
 2638 142e D794      		ror r13
 2639 1430 C794      		ror r12
 2640 1432 AA95      		dec r26
 2641 1434 01F4      		brne 1b
 2642 1436 C40C      		add r12,r4
 2643 1438 D51C      		adc r13,r5
 2644 143a E61C      		adc r14,r6
 2645 143c F71C      		adc r15,r7
 2646 143e AF2F      		mov r26,r31
 2647 1440 B0E0      		ldi r27,0
 2648 1442 0E94 0000 		call __muluhisi3
 2649 1446 B3E0      		ldi r27,3
 2650               		1:
 2651 1448 9695      		lsr r25
 2652 144a 8795      		ror r24
 2653 144c 7795      		ror r23
 2654 144e 6795      		ror r22
 2655 1450 BA95      		dec r27
 2656 1452 01F4      		brne 1b
 2657 1454 C61A      		sub r12,r22
 2658 1456 D70A      		sbc r13,r23
 2659 1458 E80A      		sbc r14,r24
 2660 145a F90A      		sbc r15,r25
 2661 145c C092 0000 		sts bankStates+21,r12
 2662 1460 D092 0000 		sts bankStates+21+1,r13
 2663 1464 E092 0000 		sts bankStates+21+2,r14
 2664 1468 F092 0000 		sts bankStates+21+3,r15
3716:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse play
 2665               		.loc 1 3716 0
 2666 146c 4091 0000 		lds r20,bankStates+25
 2667 1470 5091 0000 		lds r21,bankStates+25+1
 2668 1474 6091 0000 		lds r22,bankStates+25+2
 2669 1478 7091 0000 		lds r23,bankStates+25+3
 2670 147c 8091 0000 		lds r24,bankStates+21
 2671 1480 9091 0000 		lds r25,bankStates+21+1
 2672 1484 A091 0000 		lds r26,bankStates+21+2
 2673 1488 B091 0000 		lds r27,bankStates+21+3
 2674 148c 8417      		cp r24,r20
 2675 148e 9507      		cpc r25,r21
 2676 1490 A607      		cpc r26,r22
 2677 1492 B707      		cpc r27,r23
 2678 1494 00F4      		brsh .L147
3718:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 2679               		.loc 1 3718 0
 2680 1496 8091 0000 		lds r24,bankStates+3
 2681 149a 8130      		cpi r24,lo8(1)
 2682 149c 01F4      		brne .L148
3720:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2683               		.loc 1 3720 0
 2684 149e 8093 0000 		sts bankStates+4,r24
 2685 14a2 00C0      		rjmp .L149
 2686               	.L148:
3724:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2687               		.loc 1 3724 0
 2688 14a4 1092 0000 		sts bankStates+4,__zero_reg__
 2689               	.L149:
3727:WTPA.c        **** 			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
 2690               		.loc 1 3727 0
 2691 14a8 8091 0000 		lds r24,bankStates+25
 2692 14ac 9091 0000 		lds r25,bankStates+25+1
 2693 14b0 A091 0000 		lds r26,bankStates+25+2
 2694 14b4 B091 0000 		lds r27,bankStates+25+3
 2695               	.LVL80:
3728:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to st
 2696               		.loc 1 3728 0
 2697 14b8 4091 0000 		lds r20,bankStates+21
 2698 14bc 5091 0000 		lds r21,bankStates+21+1
 2699 14c0 6091 0000 		lds r22,bankStates+21+2
 2700 14c4 7091 0000 		lds r23,bankStates+21+3
 2701 14c8 4093 0000 		sts bankStates+25,r20
 2702 14cc 5093 0000 		sts bankStates+25+1,r21
 2703 14d0 6093 0000 		sts bankStates+25+2,r22
 2704 14d4 7093 0000 		sts bankStates+25+3,r23
3729:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
 2705               		.loc 1 3729 0
 2706 14d8 8093 0000 		sts bankStates+21,r24
 2707 14dc 9093 0000 		sts bankStates+21+1,r25
 2708 14e0 A093 0000 		sts bankStates+21+2,r26
 2709 14e4 B093 0000 		sts bankStates+21+3,r27
 2710 14e8 00C0      		rjmp .L150
 2711               	.LVL81:
 2712               	.L147:
3733:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
 2713               		.loc 1 3733 0
 2714 14ea 8091 0000 		lds r24,bankStates+3
 2715 14ee 8130      		cpi r24,lo8(1)
 2716 14f0 01F4      		brne .L151
3735:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2717               		.loc 1 3735 0
 2718 14f2 1092 0000 		sts bankStates+4,__zero_reg__
 2719 14f6 00C0      		rjmp .L150
 2720               	.L151:
3739:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2721               		.loc 1 3739 0
 2722 14f8 81E0      		ldi r24,lo8(1)
 2723 14fa 8093 0000 		sts bankStates+4,r24
 2724               	.LVL82:
 2725               	.L150:
3745:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the e
 2726               		.loc 1 3745 0
 2727 14fe 4091 0000 		lds r20,bankStates+25
 2728 1502 5091 0000 		lds r21,bankStates+25+1
 2729 1506 6091 0000 		lds r22,bankStates+25+2
 2730 150a 7091 0000 		lds r23,bankStates+25+3
 2731 150e 8091 0000 		lds r24,bankStates+13
 2732 1512 9091 0000 		lds r25,bankStates+13+1
 2733 1516 A091 0000 		lds r26,bankStates+13+2
 2734 151a B091 0000 		lds r27,bankStates+13+3
 2735 151e 8417      		cp r24,r20
 2736 1520 9507      		cpc r25,r21
 2737 1522 A607      		cpc r26,r22
 2738 1524 B707      		cpc r27,r23
 2739 1526 00F4      		brsh .L152
3747:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK
 2740               		.loc 1 3747 0
 2741 1528 8091 0000 		lds r24,bankStates+25
 2742 152c 9091 0000 		lds r25,bankStates+25+1
 2743 1530 A091 0000 		lds r26,bankStates+25+2
 2744 1534 B091 0000 		lds r27,bankStates+25+3
 2745 1538 4091 0000 		lds r20,bankStates+13
 2746 153c 5091 0000 		lds r21,bankStates+13+1
 2747 1540 6091 0000 		lds r22,bankStates+13+2
 2748 1544 7091 0000 		lds r23,bankStates+13+3
 2749 1548 841B      		sub r24,r20
 2750 154a 950B      		sbc r25,r21
 2751 154c A60B      		sbc r26,r22
 2752 154e B70B      		sbc r27,r23
 2753 1550 8093 0000 		sts bankStates+25,r24
 2754 1554 9093 0000 		sts bankStates+25+1,r25
 2755 1558 A093 0000 		sts bankStates+25+2,r26
 2756 155c B093 0000 		sts bankStates+25+3,r27
 2757               	.L152:
3749:WTPA.c        **** 		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
 2758               		.loc 1 3749 0
 2759 1560 4091 0000 		lds r20,bankStates+21
 2760 1564 5091 0000 		lds r21,bankStates+21+1
 2761 1568 6091 0000 		lds r22,bankStates+21+2
 2762 156c 7091 0000 		lds r23,bankStates+21+3
 2763 1570 8091 0000 		lds r24,bankStates+13
 2764 1574 9091 0000 		lds r25,bankStates+13+1
 2765 1578 A091 0000 		lds r26,bankStates+13+2
 2766 157c B091 0000 		lds r27,bankStates+13+3
 2767 1580 8417      		cp r24,r20
 2768 1582 9507      		cpc r25,r21
 2769 1584 A607      		cpc r26,r22
 2770 1586 B707      		cpc r27,r23
 2771 1588 00F0      		brlo .+2
 2772 158a 00C0      		rjmp .L154
3751:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].
 2773               		.loc 1 3751 0
 2774 158c 8091 0000 		lds r24,bankStates+21
 2775 1590 9091 0000 		lds r25,bankStates+21+1
 2776 1594 A091 0000 		lds r26,bankStates+21+2
 2777 1598 B091 0000 		lds r27,bankStates+21+3
 2778 159c 4091 0000 		lds r20,bankStates+13
 2779 15a0 5091 0000 		lds r21,bankStates+13+1
 2780 15a4 6091 0000 		lds r22,bankStates+13+2
 2781 15a8 7091 0000 		lds r23,bankStates+13+3
 2782 15ac 841B      		sub r24,r20
 2783 15ae 950B      		sbc r25,r21
 2784 15b0 A60B      		sbc r26,r22
 2785 15b2 B70B      		sbc r27,r23
 2786 15b4 8093 0000 		sts bankStates+21,r24
 2787 15b8 9093 0000 		sts bankStates+21+1,r25
 2788 15bc A093 0000 		sts bankStates+21+2,r26
 2789 15c0 B093 0000 		sts bankStates+21+3,r27
3753:WTPA.c        **** 			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wra
 2790               		.loc 1 3753 0
 2791 15c4 4091 0000 		lds r20,bankStates+21
 2792 15c8 5091 0000 		lds r21,bankStates+21+1
 2793 15cc 6091 0000 		lds r22,bankStates+21+2
 2794 15d0 7091 0000 		lds r23,bankStates+21+3
 2795 15d4 8091 0000 		lds r24,bankStates+25
 2796 15d8 9091 0000 		lds r25,bankStates+25+1
 2797 15dc A091 0000 		lds r26,bankStates+25+2
 2798 15e0 B091 0000 		lds r27,bankStates+25+3
 2799 15e4 4817      		cp r20,r24
 2800 15e6 5907      		cpc r21,r25
 2801 15e8 6A07      		cpc r22,r26
 2802 15ea 7B07      		cpc r23,r27
 2803 15ec 01F4      		brne .L154
3755:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
 2804               		.loc 1 3755 0
 2805 15ee 8091 0000 		lds r24,bankStates+21
 2806 15f2 9091 0000 		lds r25,bankStates+21+1
 2807 15f6 A091 0000 		lds r26,bankStates+21+2
 2808 15fa B091 0000 		lds r27,bankStates+21+3
 2809 15fe 0197      		sbiw r24,1
 2810 1600 A109      		sbc r26,__zero_reg__
 2811 1602 B109      		sbc r27,__zero_reg__
 2812 1604 8093 0000 		sts bankStates+21,r24
 2813 1608 9093 0000 		sts bankStates+21+1,r25
 2814 160c A093 0000 		sts bankStates+21+2,r26
 2815 1610 B093 0000 		sts bankStates+21+3,r27
 2816               	.L154:
3761:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapp
 2817               		.loc 1 3761 0
 2818 1614 4091 0000 		lds r20,bankStates+25
 2819 1618 5091 0000 		lds r21,bankStates+25+1
 2820 161c 6091 0000 		lds r22,bankStates+25+2
 2821 1620 7091 0000 		lds r23,bankStates+25+3
 2822 1624 8091 0000 		lds r24,bankStates+21
 2823 1628 9091 0000 		lds r25,bankStates+21+1
 2824 162c A091 0000 		lds r26,bankStates+21+2
 2825 1630 B091 0000 		lds r27,bankStates+21+3
 2826 1634 8417      		cp r24,r20
 2827 1636 9507      		cpc r25,r21
 2828 1638 A607      		cpc r26,r22
 2829 163a B707      		cpc r27,r23
 2830 163c 00F0      		brlo .+2
 2831 163e 00C0      		rjmp .L156
3763:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
 2832               		.loc 1 3763 0
 2833 1640 4091 0000 		lds r20,bankStates+32
 2834 1644 5091 0000 		lds r21,bankStates+32+1
 2835 1648 6091 0000 		lds r22,bankStates+32+2
 2836 164c 7091 0000 		lds r23,bankStates+32+3
 2837 1650 8091 0000 		lds r24,bankStates+25
 2838 1654 9091 0000 		lds r25,bankStates+25+1
 2839 1658 A091 0000 		lds r26,bankStates+25+2
 2840 165c B091 0000 		lds r27,bankStates+25+3
 2841 1660 4817      		cp r20,r24
 2842 1662 5907      		cpc r21,r25
 2843 1664 6A07      		cpc r22,r26
 2844 1666 7B07      		cpc r23,r27
 2845 1668 00F0      		brlo .+2
 2846 166a 00C0      		rjmp .L158
3763:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
 2847               		.loc 1 3763 0 is_stmt 0 discriminator 1
 2848 166c 4091 0000 		lds r20,bankStates+32
 2849 1670 5091 0000 		lds r21,bankStates+32+1
 2850 1674 6091 0000 		lds r22,bankStates+32+2
 2851 1678 7091 0000 		lds r23,bankStates+32+3
 2852 167c 8091 0000 		lds r24,bankStates+21
 2853 1680 9091 0000 		lds r25,bankStates+21+1
 2854 1684 A091 0000 		lds r26,bankStates+21+2
 2855 1688 B091 0000 		lds r27,bankStates+21+3
 2856 168c 8417      		cp r24,r20
 2857 168e 9507      		cpc r25,r21
 2858 1690 A607      		cpc r26,r22
 2859 1692 B707      		cpc r27,r23
 2860 1694 00F0      		brlo .+2
 2861 1696 00C0      		rjmp .L158
3765:WTPA.c        **** 				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BAN
 2862               		.loc 1 3765 0 is_stmt 1
 2863 1698 4091 0000 		lds r20,bankStates+25
 2864 169c 5091 0000 		lds r21,bankStates+25+1
 2865 16a0 6091 0000 		lds r22,bankStates+25+2
 2866 16a4 7091 0000 		lds r23,bankStates+25+3
 2867 16a8 8090 0000 		lds r8,bankStates+32
 2868 16ac 9090 0000 		lds r9,bankStates+32+1
 2869 16b0 A090 0000 		lds r10,bankStates+32+2
 2870 16b4 B090 0000 		lds r11,bankStates+32+3
 2871 16b8 8091 0000 		lds r24,bankStates+32
 2872 16bc 9091 0000 		lds r25,bankStates+32+1
 2873 16c0 A091 0000 		lds r26,bankStates+32+2
 2874 16c4 B091 0000 		lds r27,bankStates+32+3
 2875 16c8 C090 0000 		lds r12,bankStates+21
 2876 16cc D090 0000 		lds r13,bankStates+21+1
 2877 16d0 E090 0000 		lds r14,bankStates+21+2
 2878 16d4 F090 0000 		lds r15,bankStates+21+3
 2879 16d8 4819      		sub r20,r8
 2880 16da 5909      		sbc r21,r9
 2881 16dc 6A09      		sbc r22,r10
 2882 16de 7B09      		sbc r23,r11
 2883 16e0 8C19      		sub r24,r12
 2884 16e2 9D09      		sbc r25,r13
 2885 16e4 AE09      		sbc r26,r14
 2886 16e6 BF09      		sbc r27,r15
 2887 16e8 4817      		cp r20,r24
 2888 16ea 5907      		cpc r21,r25
 2889 16ec 6A07      		cpc r22,r26
 2890 16ee 7B07      		cpc r23,r27
 2891 16f0 00F0      		brlo .L178
 2892 16f2 00C0      		rjmp .L177
 2893               	.L156:
3777:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
 2894               		.loc 1 3777 0
 2895 16f4 4091 0000 		lds r20,bankStates+32
 2896 16f8 5091 0000 		lds r21,bankStates+32+1
 2897 16fc 6091 0000 		lds r22,bankStates+32+2
 2898 1700 7091 0000 		lds r23,bankStates+32+3
 2899 1704 8091 0000 		lds r24,bankStates+25
 2900 1708 9091 0000 		lds r25,bankStates+25+1
 2901 170c A091 0000 		lds r26,bankStates+25+2
 2902 1710 B091 0000 		lds r27,bankStates+25+3
 2903 1714 4817      		cp r20,r24
 2904 1716 5907      		cpc r21,r25
 2905 1718 6A07      		cpc r22,r26
 2906 171a 7B07      		cpc r23,r27
 2907 171c 00F4      		brsh .L161
 2908               	.L177:
3779:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the 
 2909               		.loc 1 3779 0
 2910 171e 8091 0000 		lds r24,bankStates+25
 2911 1722 9091 0000 		lds r25,bankStates+25+1
 2912 1726 A091 0000 		lds r26,bankStates+25+2
 2913 172a B091 0000 		lds r27,bankStates+25+3
 2914               	.L174:
 2915 172e 8093 0000 		sts bankStates+32,r24
 2916 1732 9093 0000 		sts bankStates+32+1,r25
 2917 1736 A093 0000 		sts bankStates+32+2,r26
 2918 173a B093 0000 		sts bankStates+32+3,r27
 2919 173e 00C0      		rjmp .L158
 2920               	.L161:
3781:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
 2921               		.loc 1 3781 0
 2922 1740 4091 0000 		lds r20,bankStates+32
 2923 1744 5091 0000 		lds r21,bankStates+32+1
 2924 1748 6091 0000 		lds r22,bankStates+32+2
 2925 174c 7091 0000 		lds r23,bankStates+32+3
 2926 1750 8091 0000 		lds r24,bankStates+21
 2927 1754 9091 0000 		lds r25,bankStates+21+1
 2928 1758 A091 0000 		lds r26,bankStates+21+2
 2929 175c B091 0000 		lds r27,bankStates+21+3
 2930 1760 8417      		cp r24,r20
 2931 1762 9507      		cpc r25,r21
 2932 1764 A607      		cpc r26,r22
 2933 1766 B707      		cpc r27,r23
 2934 1768 00F0      		brlo .+2
 2935 176a 00C0      		rjmp .L158
 2936               	.L178:
3783:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
 2937               		.loc 1 3783 0
 2938 176c 8091 0000 		lds r24,bankStates+21
 2939 1770 9091 0000 		lds r25,bankStates+21+1
 2940 1774 A091 0000 		lds r26,bankStates+21+2
 2941 1778 B091 0000 		lds r27,bankStates+21+3
 2942 177c 00C0      		rjmp .L174
 2943               	.LVL83:
 2944               	.L146:
3790:WTPA.c        **** 		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of 
 2945               		.loc 1 3790 0
 2946 177e 8091 0000 		lds r24,bankStates+49
 2947 1782 9091 0000 		lds r25,bankStates+49+1
 2948 1786 A091 0000 		lds r26,bankStates+49+2
 2949 178a B091 0000 		lds r27,bankStates+49+3
 2950               	.LVL84:
 2951 178e CC24      		clr r12
 2952 1790 CA94      		dec r12
 2953 1792 DC2C      		mov r13,r12
 2954 1794 27E0      		ldi r18,lo8(7)
 2955 1796 E22E      		mov r14,r18
 2956 1798 F12C      		mov r15,__zero_reg__
 2957 179a 4601      		movw r8,r12
 2958 179c 5701      		movw r10,r14
 2959 179e 881A      		sub r8,r24
 2960 17a0 990A      		sbc r9,r25
 2961 17a2 AA0A      		sbc r10,r26
 2962 17a4 BB0A      		sbc r11,r27
 2963 17a6 33E0      		ldi r19,3
 2964               		1:
 2965 17a8 880C      		lsl r8
 2966 17aa 991C      		rol r9
 2967 17ac AA1C      		rol r10
 2968 17ae BB1C      		rol r11
 2969 17b0 3A95      		dec r19
 2970 17b2 01F4      		brne 1b
 2971 17b4 892C      		mov r8,r9
 2972 17b6 9A2C      		mov r9,r10
 2973 17b8 AB2C      		mov r10,r11
 2974 17ba BB24      		clr r11
 2975               	.LVL85:
3794:WTPA.c        **** 		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sam
 2976               		.loc 1 3794 0
 2977 17bc A091 0000 		lds r26,bankStates+65
 2978 17c0 8091 0000 		lds r24,bankStates+67
 2979 17c4 B0E0      		ldi r27,0
 2980 17c6 A80F      		add r26,r24
 2981 17c8 B11D      		adc r27,__zero_reg__
 2982 17ca A501      		movw r20,r10
 2983 17cc 9401      		movw r18,r8
 2984 17ce 0E94 0000 		call __muluhisi3
 2985 17d2 F3E0      		ldi r31,3
 2986               		1:
 2987 17d4 9695      		lsr r25
 2988 17d6 8795      		ror r24
 2989 17d8 7795      		ror r23
 2990 17da 6795      		ror r22
 2991 17dc FA95      		dec r31
 2992 17de 01F4      		brne 1b
 2993 17e0 C61A      		sub r12,r22
 2994 17e2 D70A      		sbc r13,r23
 2995 17e4 E80A      		sbc r14,r24
 2996 17e6 F90A      		sbc r15,r25
 2997 17e8 C092 0000 		sts bankStates+61,r12
 2998 17ec D092 0000 		sts bankStates+61+1,r13
 2999 17f0 E092 0000 		sts bankStates+61+2,r14
 3000 17f4 F092 0000 		sts bankStates+61+3,r15
3795:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_
 3001               		.loc 1 3795 0
 3002 17f8 4090 0000 		lds r4,bankStates+49
 3003 17fc 5090 0000 		lds r5,bankStates+49+1
 3004 1800 6090 0000 		lds r6,bankStates+49+2
 3005 1804 7090 0000 		lds r7,bankStates+49+3
 3006 1808 A091 0000 		lds r26,bankStates+66
 3007 180c F091 0000 		lds r31,bankStates+67
 3008 1810 B0E0      		ldi r27,0
 3009 1812 0E94 0000 		call __muluhisi3
 3010 1816 6B01      		movw r12,r22
 3011 1818 7C01      		movw r14,r24
 3012 181a A3E0      		ldi r26,3
 3013               		1:
 3014 181c F694      		lsr r15
 3015 181e E794      		ror r14
 3016 1820 D794      		ror r13
 3017 1822 C794      		ror r12
 3018 1824 AA95      		dec r26
 3019 1826 01F4      		brne 1b
 3020 1828 C40C      		add r12,r4
 3021 182a D51C      		adc r13,r5
 3022 182c E61C      		adc r14,r6
 3023 182e F71C      		adc r15,r7
 3024 1830 AF2F      		mov r26,r31
 3025 1832 B0E0      		ldi r27,0
 3026 1834 0E94 0000 		call __muluhisi3
 3027 1838 B3E0      		ldi r27,3
 3028               		1:
 3029 183a 9695      		lsr r25
 3030 183c 8795      		ror r24
 3031 183e 7795      		ror r23
 3032 1840 6795      		ror r22
 3033 1842 BA95      		dec r27
 3034 1844 01F4      		brne 1b
 3035 1846 C61A      		sub r12,r22
 3036 1848 D70A      		sbc r13,r23
 3037 184a E80A      		sbc r14,r24
 3038 184c F90A      		sbc r15,r25
 3039 184e C092 0000 		sts bankStates+57,r12
 3040 1852 D092 0000 		sts bankStates+57+1,r13
 3041 1856 E092 0000 		sts bankStates+57+2,r14
 3042 185a F092 0000 		sts bankStates+57+3,r15
3799:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse play
 3043               		.loc 1 3799 0
 3044 185e 4091 0000 		lds r20,bankStates+61
 3045 1862 5091 0000 		lds r21,bankStates+61+1
 3046 1866 6091 0000 		lds r22,bankStates+61+2
 3047 186a 7091 0000 		lds r23,bankStates+61+3
 3048 186e 8091 0000 		lds r24,bankStates+57
 3049 1872 9091 0000 		lds r25,bankStates+57+1
 3050 1876 A091 0000 		lds r26,bankStates+57+2
 3051 187a B091 0000 		lds r27,bankStates+57+3
 3052 187e 4817      		cp r20,r24
 3053 1880 5907      		cpc r21,r25
 3054 1882 6A07      		cpc r22,r26
 3055 1884 7B07      		cpc r23,r27
 3056 1886 00F4      		brsh .L162
3801:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 3057               		.loc 1 3801 0
 3058 1888 8091 0000 		lds r24,bankStates+39
 3059 188c 8130      		cpi r24,lo8(1)
 3060 188e 01F4      		brne .L163
3803:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3061               		.loc 1 3803 0
 3062 1890 8093 0000 		sts bankStates+40,r24
 3063 1894 00C0      		rjmp .L164
 3064               	.L163:
3807:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3065               		.loc 1 3807 0
 3066 1896 1092 0000 		sts bankStates+40,__zero_reg__
 3067               	.L164:
3810:WTPA.c        **** 			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
 3068               		.loc 1 3810 0
 3069 189a 8091 0000 		lds r24,bankStates+61
 3070 189e 9091 0000 		lds r25,bankStates+61+1
 3071 18a2 A091 0000 		lds r26,bankStates+61+2
 3072 18a6 B091 0000 		lds r27,bankStates+61+3
 3073               	.LVL86:
3811:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to st
 3074               		.loc 1 3811 0
 3075 18aa 4091 0000 		lds r20,bankStates+57
 3076 18ae 5091 0000 		lds r21,bankStates+57+1
 3077 18b2 6091 0000 		lds r22,bankStates+57+2
 3078 18b6 7091 0000 		lds r23,bankStates+57+3
 3079 18ba 4093 0000 		sts bankStates+61,r20
 3080 18be 5093 0000 		sts bankStates+61+1,r21
 3081 18c2 6093 0000 		sts bankStates+61+2,r22
 3082 18c6 7093 0000 		sts bankStates+61+3,r23
3812:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
 3083               		.loc 1 3812 0
 3084 18ca 8093 0000 		sts bankStates+57,r24
 3085 18ce 9093 0000 		sts bankStates+57+1,r25
 3086 18d2 A093 0000 		sts bankStates+57+2,r26
 3087 18d6 B093 0000 		sts bankStates+57+3,r27
 3088 18da 00C0      		rjmp .L165
 3089               	.LVL87:
 3090               	.L162:
3816:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
 3091               		.loc 1 3816 0
 3092 18dc 8091 0000 		lds r24,bankStates+39
 3093 18e0 8130      		cpi r24,lo8(1)
 3094 18e2 01F4      		brne .L166
3818:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3095               		.loc 1 3818 0
 3096 18e4 1092 0000 		sts bankStates+40,__zero_reg__
 3097 18e8 00C0      		rjmp .L165
 3098               	.L166:
3822:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3099               		.loc 1 3822 0
 3100 18ea 81E0      		ldi r24,lo8(1)
 3101 18ec 8093 0000 		sts bankStates+40,r24
 3102               	.LVL88:
 3103               	.L165:
3828:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the e
 3104               		.loc 1 3828 0
 3105 18f0 4091 0000 		lds r20,bankStates+61
 3106 18f4 5091 0000 		lds r21,bankStates+61+1
 3107 18f8 6091 0000 		lds r22,bankStates+61+2
 3108 18fc 7091 0000 		lds r23,bankStates+61+3
 3109 1900 8091 0000 		lds r24,bankStates+49
 3110 1904 9091 0000 		lds r25,bankStates+49+1
 3111 1908 A091 0000 		lds r26,bankStates+49+2
 3112 190c B091 0000 		lds r27,bankStates+49+3
 3113 1910 4817      		cp r20,r24
 3114 1912 5907      		cpc r21,r25
 3115 1914 6A07      		cpc r22,r26
 3116 1916 7B07      		cpc r23,r27
 3117 1918 00F4      		brsh .L167
3830:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bank
 3118               		.loc 1 3830 0
 3119 191a 8091 0000 		lds r24,bankStates+61
 3120 191e 9091 0000 		lds r25,bankStates+61+1
 3121 1922 A091 0000 		lds r26,bankStates+61+2
 3122 1926 B091 0000 		lds r27,bankStates+61+3
 3123 192a 4091 0000 		lds r20,bankStates+49
 3124 192e 5091 0000 		lds r21,bankStates+49+1
 3125 1932 6091 0000 		lds r22,bankStates+49+2
 3126 1936 7091 0000 		lds r23,bankStates+49+3
 3127 193a 0197      		sbiw r24,1
 3128 193c A84F      		sbci r26,-8
 3129 193e BF4F      		sbci r27,-1
 3130 1940 841B      		sub r24,r20
 3131 1942 950B      		sbc r25,r21
 3132 1944 A60B      		sbc r26,r22
 3133 1946 B70B      		sbc r27,r23
 3134 1948 8093 0000 		sts bankStates+61,r24
 3135 194c 9093 0000 		sts bankStates+61+1,r25
 3136 1950 A093 0000 		sts bankStates+61+2,r26
 3137 1954 B093 0000 		sts bankStates+61+3,r27
 3138               	.L167:
3832:WTPA.c        **** 		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
 3139               		.loc 1 3832 0
 3140 1958 4091 0000 		lds r20,bankStates+57
 3141 195c 5091 0000 		lds r21,bankStates+57+1
 3142 1960 6091 0000 		lds r22,bankStates+57+2
 3143 1964 7091 0000 		lds r23,bankStates+57+3
 3144 1968 8091 0000 		lds r24,bankStates+49
 3145 196c 9091 0000 		lds r25,bankStates+49+1
 3146 1970 A091 0000 		lds r26,bankStates+49+2
 3147 1974 B091 0000 		lds r27,bankStates+49+3
 3148 1978 4817      		cp r20,r24
 3149 197a 5907      		cpc r21,r25
 3150 197c 6A07      		cpc r22,r26
 3151 197e 7B07      		cpc r23,r27
 3152 1980 00F0      		brlo .+2
 3153 1982 00C0      		rjmp .L169
3834:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankSt
 3154               		.loc 1 3834 0
 3155 1984 8091 0000 		lds r24,bankStates+57
 3156 1988 9091 0000 		lds r25,bankStates+57+1
 3157 198c A091 0000 		lds r26,bankStates+57+2
 3158 1990 B091 0000 		lds r27,bankStates+57+3
 3159 1994 4091 0000 		lds r20,bankStates+49
 3160 1998 5091 0000 		lds r21,bankStates+49+1
 3161 199c 6091 0000 		lds r22,bankStates+49+2
 3162 19a0 7091 0000 		lds r23,bankStates+49+3
 3163 19a4 0197      		sbiw r24,1
 3164 19a6 A84F      		sbci r26,-8
 3165 19a8 BF4F      		sbci r27,-1
 3166 19aa 841B      		sub r24,r20
 3167 19ac 950B      		sbc r25,r21
 3168 19ae A60B      		sbc r26,r22
 3169 19b0 B70B      		sbc r27,r23
 3170 19b2 8093 0000 		sts bankStates+57,r24
 3171 19b6 9093 0000 		sts bankStates+57+1,r25
 3172 19ba A093 0000 		sts bankStates+57+2,r26
 3173 19be B093 0000 		sts bankStates+57+3,r27
3836:WTPA.c        **** 			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wra
 3174               		.loc 1 3836 0
 3175 19c2 4091 0000 		lds r20,bankStates+57
 3176 19c6 5091 0000 		lds r21,bankStates+57+1
 3177 19ca 6091 0000 		lds r22,bankStates+57+2
 3178 19ce 7091 0000 		lds r23,bankStates+57+3
 3179 19d2 8091 0000 		lds r24,bankStates+61
 3180 19d6 9091 0000 		lds r25,bankStates+61+1
 3181 19da A091 0000 		lds r26,bankStates+61+2
 3182 19de B091 0000 		lds r27,bankStates+61+3
 3183 19e2 4817      		cp r20,r24
 3184 19e4 5907      		cpc r21,r25
 3185 19e6 6A07      		cpc r22,r26
 3186 19e8 7B07      		cpc r23,r27
 3187 19ea 01F4      		brne .L169
3838:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
 3188               		.loc 1 3838 0
 3189 19ec 8091 0000 		lds r24,bankStates+57
 3190 19f0 9091 0000 		lds r25,bankStates+57+1
 3191 19f4 A091 0000 		lds r26,bankStates+57+2
 3192 19f8 B091 0000 		lds r27,bankStates+57+3
 3193 19fc 0196      		adiw r24,1
 3194 19fe A11D      		adc r26,__zero_reg__
 3195 1a00 B11D      		adc r27,__zero_reg__
 3196 1a02 8093 0000 		sts bankStates+57,r24
 3197 1a06 9093 0000 		sts bankStates+57+1,r25
 3198 1a0a A093 0000 		sts bankStates+57+2,r26
 3199 1a0e B093 0000 		sts bankStates+57+3,r27
 3200               	.L169:
3844:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapp
 3201               		.loc 1 3844 0
 3202 1a12 4091 0000 		lds r20,bankStates+61
 3203 1a16 5091 0000 		lds r21,bankStates+61+1
 3204 1a1a 6091 0000 		lds r22,bankStates+61+2
 3205 1a1e 7091 0000 		lds r23,bankStates+61+3
 3206 1a22 8091 0000 		lds r24,bankStates+57
 3207 1a26 9091 0000 		lds r25,bankStates+57+1
 3208 1a2a A091 0000 		lds r26,bankStates+57+2
 3209 1a2e B091 0000 		lds r27,bankStates+57+3
 3210 1a32 4817      		cp r20,r24
 3211 1a34 5907      		cpc r21,r25
 3212 1a36 6A07      		cpc r22,r26
 3213 1a38 7B07      		cpc r23,r27
 3214 1a3a 00F0      		brlo .+2
 3215 1a3c 00C0      		rjmp .L171
3846:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
 3216               		.loc 1 3846 0
 3217 1a3e 4091 0000 		lds r20,bankStates+68
 3218 1a42 5091 0000 		lds r21,bankStates+68+1
 3219 1a46 6091 0000 		lds r22,bankStates+68+2
 3220 1a4a 7091 0000 		lds r23,bankStates+68+3
 3221 1a4e 8091 0000 		lds r24,bankStates+61
 3222 1a52 9091 0000 		lds r25,bankStates+61+1
 3223 1a56 A091 0000 		lds r26,bankStates+61+2
 3224 1a5a B091 0000 		lds r27,bankStates+61+3
 3225 1a5e 8417      		cp r24,r20
 3226 1a60 9507      		cpc r25,r21
 3227 1a62 A607      		cpc r26,r22
 3228 1a64 B707      		cpc r27,r23
 3229 1a66 00F0      		brlo .+2
 3230 1a68 00C0      		rjmp .L158
3846:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
 3231               		.loc 1 3846 0 is_stmt 0 discriminator 1
 3232 1a6a 4091 0000 		lds r20,bankStates+68
 3233 1a6e 5091 0000 		lds r21,bankStates+68+1
 3234 1a72 6091 0000 		lds r22,bankStates+68+2
 3235 1a76 7091 0000 		lds r23,bankStates+68+3
 3236 1a7a 8091 0000 		lds r24,bankStates+57
 3237 1a7e 9091 0000 		lds r25,bankStates+57+1
 3238 1a82 A091 0000 		lds r26,bankStates+57+2
 3239 1a86 B091 0000 		lds r27,bankStates+57+3
 3240 1a8a 4817      		cp r20,r24
 3241 1a8c 5907      		cpc r21,r25
 3242 1a8e 6A07      		cpc r22,r26
 3243 1a90 7B07      		cpc r23,r27
 3244 1a92 00F0      		brlo .+2
 3245 1a94 00C0      		rjmp .L158
3848:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BAN
 3246               		.loc 1 3848 0 is_stmt 1
 3247 1a96 4091 0000 		lds r20,bankStates+68
 3248 1a9a 5091 0000 		lds r21,bankStates+68+1
 3249 1a9e 6091 0000 		lds r22,bankStates+68+2
 3250 1aa2 7091 0000 		lds r23,bankStates+68+3
 3251 1aa6 8090 0000 		lds r8,bankStates+61
 3252 1aaa 9090 0000 		lds r9,bankStates+61+1
 3253 1aae A090 0000 		lds r10,bankStates+61+2
 3254 1ab2 B090 0000 		lds r11,bankStates+61+3
 3255 1ab6 8091 0000 		lds r24,bankStates+57
 3256 1aba 9091 0000 		lds r25,bankStates+57+1
 3257 1abe A091 0000 		lds r26,bankStates+57+2
 3258 1ac2 B091 0000 		lds r27,bankStates+57+3
 3259 1ac6 C090 0000 		lds r12,bankStates+68
 3260 1aca D090 0000 		lds r13,bankStates+68+1
 3261 1ace E090 0000 		lds r14,bankStates+68+2
 3262 1ad2 F090 0000 		lds r15,bankStates+68+3
 3263 1ad6 4819      		sub r20,r8
 3264 1ad8 5909      		sbc r21,r9
 3265 1ada 6A09      		sbc r22,r10
 3266 1adc 7B09      		sbc r23,r11
 3267 1ade 8C19      		sub r24,r12
 3268 1ae0 9D09      		sbc r25,r13
 3269 1ae2 AE09      		sbc r26,r14
 3270 1ae4 BF09      		sbc r27,r15
 3271 1ae6 8417      		cp r24,r20
 3272 1ae8 9507      		cpc r25,r21
 3273 1aea A607      		cpc r26,r22
 3274 1aec B707      		cpc r27,r23
 3275 1aee 00F0      		brlo .L176
 3276 1af0 00C0      		rjmp .L179
 3277               	.L171:
3860:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
 3278               		.loc 1 3860 0
 3279 1af2 4091 0000 		lds r20,bankStates+68
 3280 1af6 5091 0000 		lds r21,bankStates+68+1
 3281 1afa 6091 0000 		lds r22,bankStates+68+2
 3282 1afe 7091 0000 		lds r23,bankStates+68+3
 3283 1b02 8091 0000 		lds r24,bankStates+61
 3284 1b06 9091 0000 		lds r25,bankStates+61+1
 3285 1b0a A091 0000 		lds r26,bankStates+61+2
 3286 1b0e B091 0000 		lds r27,bankStates+61+3
 3287 1b12 8417      		cp r24,r20
 3288 1b14 9507      		cpc r25,r21
 3289 1b16 A607      		cpc r26,r22
 3290 1b18 B707      		cpc r27,r23
 3291 1b1a 00F4      		brsh .L173
 3292               	.L179:
3862:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the 
 3293               		.loc 1 3862 0
 3294 1b1c 8091 0000 		lds r24,bankStates+61
 3295 1b20 9091 0000 		lds r25,bankStates+61+1
 3296 1b24 A091 0000 		lds r26,bankStates+61+2
 3297 1b28 B091 0000 		lds r27,bankStates+61+3
 3298 1b2c 00C0      		rjmp .L175
 3299               	.L173:
3864:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
 3300               		.loc 1 3864 0
 3301 1b2e 4091 0000 		lds r20,bankStates+68
 3302 1b32 5091 0000 		lds r21,bankStates+68+1
 3303 1b36 6091 0000 		lds r22,bankStates+68+2
 3304 1b3a 7091 0000 		lds r23,bankStates+68+3
 3305 1b3e 8091 0000 		lds r24,bankStates+57
 3306 1b42 9091 0000 		lds r25,bankStates+57+1
 3307 1b46 A091 0000 		lds r26,bankStates+57+2
 3308 1b4a B091 0000 		lds r27,bankStates+57+3
 3309 1b4e 4817      		cp r20,r24
 3310 1b50 5907      		cpc r21,r25
 3311 1b52 6A07      		cpc r22,r26
 3312 1b54 7B07      		cpc r23,r27
 3313 1b56 00F4      		brsh .L158
 3314               	.L176:
3866:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
 3315               		.loc 1 3866 0
 3316 1b58 8091 0000 		lds r24,bankStates+57
 3317 1b5c 9091 0000 		lds r25,bankStates+57+1
 3318 1b60 A091 0000 		lds r26,bankStates+57+2
 3319 1b64 B091 0000 		lds r27,bankStates+57+3
 3320               	.L175:
 3321 1b68 8093 0000 		sts bankStates+68,r24
 3322 1b6c 9093 0000 		sts bankStates+68+1,r25
 3323 1b70 A093 0000 		sts bankStates+68+2,r26
 3324 1b74 B093 0000 		sts bankStates+68+3,r27
 3325               	.L158:
3871:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3326               		.loc 1 3871 0
 3327 1b78 EFBF      		out __SREG__,r30
 3328               	/* epilogue start */
3872:WTPA.c        **** }
 3329               		.loc 1 3872 0
 3330 1b7a FF90      		pop r15
 3331 1b7c EF90      		pop r14
 3332 1b7e DF90      		pop r13
 3333 1b80 CF90      		pop r12
 3334 1b82 BF90      		pop r11
 3335 1b84 AF90      		pop r10
 3336 1b86 9F90      		pop r9
 3337 1b88 8F90      		pop r8
 3338 1b8a 7F90      		pop r7
 3339 1b8c 6F90      		pop r6
 3340 1b8e 5F90      		pop r5
 3341 1b90 4F90      		pop r4
 3342 1b92 0895      		ret
 3343               		.cfi_endproc
 3344               	.LFE63:
 3347               	RevertSampleToUnadjusted:
 3348               	.LFB64:
3878:WTPA.c        **** {
 3349               		.loc 1 3878 0
 3350               		.cfi_startproc
 3351               	.LVL89:
 3352               	/* prologue: function */
 3353               	/* frame size = 0 */
 3354               	/* stack size = 0 */
 3355               	.L__stack_usage = 0
3882:WTPA.c        **** 	sreg=SREG;
 3356               		.loc 1 3882 0
 3357 1b94 9FB7      		in r25,__SREG__
 3358               	.LVL90:
3883:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 3359               		.loc 1 3883 0
 3360               	/* #APP */
 3361               	 ;  3883 "WTPA.c" 1
 3362 1b96 F894      		cli
 3363               	 ;  0 "" 2
3885:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 3364               		.loc 1 3885 0
 3365               	/* #NOAPP */
 3366 1b98 24E2      		ldi r18,lo8(36)
 3367 1b9a 829F      		mul r24,r18
 3368 1b9c F001      		movw r30,r0
 3369 1b9e 1124      		clr __zero_reg__
 3370 1ba0 E050      		subi r30,lo8(-(bankStates))
 3371 1ba2 F040      		sbci r31,hi8(-(bankStates))
 3372 1ba4 4189      		ldd r20,Z+17
 3373 1ba6 5289      		ldd r21,Z+18
 3374 1ba8 6389      		ldd r22,Z+19
 3375 1baa 7489      		ldd r23,Z+20
 3376 1bac 418F      		std Z+25,r20
 3377 1bae 528F      		std Z+26,r21
 3378 1bb0 638F      		std Z+27,r22
 3379 1bb2 748F      		std Z+28,r23
3886:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 3380               		.loc 1 3886 0
 3381 1bb4 4585      		ldd r20,Z+13
 3382 1bb6 5685      		ldd r21,Z+14
 3383 1bb8 6785      		ldd r22,Z+15
 3384 1bba 7089      		ldd r23,Z+16
 3385 1bbc 458B      		std Z+21,r20
 3386 1bbe 568B      		std Z+22,r21
 3387 1bc0 678B      		std Z+23,r22
 3388 1bc2 708F      		std Z+24,r23
3887:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 3389               		.loc 1 3887 0
 3390 1bc4 158E      		std Z+29,__zero_reg__
3888:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 3391               		.loc 1 3888 0
 3392 1bc6 168E      		std Z+30,__zero_reg__
3889:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 3393               		.loc 1 3889 0
 3394 1bc8 178E      		std Z+31,__zero_reg__
3890:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3395               		.loc 1 3890 0
 3396 1bca 9FBF      		out __SREG__,r25
 3397 1bcc 0895      		ret
 3398               		.cfi_endproc
 3399               	.LFE64:
 3402               	BlinkLeds:
 3403               	.LFB17:
1485:WTPA.c        **** {
 3404               		.loc 1 1485 0
 3405               		.cfi_startproc
 3406               	.LVL91:
 3407               	/* prologue: function */
 3408               	/* frame size = 0 */
 3409               	/* stack size = 0 */
 3410               	.L__stack_usage = 0
1491:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3411               		.loc 1 1491 0
 3412 1bce 4091 0000 		lds r20,ledBlinkMask
 3413 1bd2 50E0      		ldi r21,0
 3414 1bd4 9091 0000 		lds r25,ledOnOffMask
 3415 1bd8 20E0      		ldi r18,0
 3416 1bda 30E0      		ldi r19,0
1493:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3417               		.loc 1 1493 0
 3418 1bdc 61E0      		ldi r22,lo8(1)
 3419 1bde 70E0      		ldi r23,0
 3420               	.LVL92:
 3421               	.L183:
1491:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3422               		.loc 1 1491 0
 3423 1be0 DA01      		movw r26,r20
 3424 1be2 022E      		mov r0,r18
 3425 1be4 00C0      		rjmp 2f
 3426               		1:
 3427 1be6 B595      		asr r27
 3428 1be8 A795      		ror r26
 3429               		2:
 3430 1bea 0A94      		dec r0
 3431 1bec 02F4      		brpl 1b
 3432 1bee A0FF      		sbrs r26,0
 3433 1bf0 00C0      		rjmp .L182
1493:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3434               		.loc 1 1493 0
 3435 1bf2 DB01      		movw r26,r22
 3436 1bf4 022E      		mov r0,r18
 3437 1bf6 00C0      		rjmp 2f
 3438               		1:
 3439 1bf8 AA0F      		lsl r26
 3440 1bfa BB1F      		rol r27
 3441               		2:
 3442 1bfc 0A94      		dec r0
 3443 1bfe 02F4      		brpl 1b
 3444 1c00 FD01      		movw r30,r26
 3445 1c02 E095      		com r30
 3446 1c04 9E23      		and r25,r30
 3447               	.L182:
 3448 1c06 2F5F      		subi r18,-1
 3449 1c08 3F4F      		sbci r19,-1
1489:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
 3450               		.loc 1 1489 0
 3451 1c0a 2830      		cpi r18,8
 3452 1c0c 3105      		cpc r19,__zero_reg__
 3453 1c0e 01F4      		brne .L183
 3454 1c10 9093 0000 		sts ledOnOffMask,r25
1497:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 3455               		.loc 1 1497 0
 3456 1c14 8093 0000 		sts ledBlinkMask,r24
1498:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 3457               		.loc 1 1498 0
 3458 1c18 68E9      		ldi r22,lo8(-104)
 3459 1c1a 70E0      		ldi r23,0
 3460 1c1c 82E0      		ldi r24,lo8(2)
 3461               	.LVL93:
 3462 1c1e 0C94 0000 		jmp SetTimer
 3463               	.LVL94:
 3464               		.cfi_endproc
 3465               	.LFE17:
 3468               	KillLeds:
 3469               	.LFB19:
1509:WTPA.c        **** {
 3470               		.loc 1 1509 0
 3471               		.cfi_startproc
 3472               	/* prologue: function */
 3473               	/* frame size = 0 */
 3474               	/* stack size = 0 */
 3475               	.L__stack_usage = 0
1510:WTPA.c        **** 	ledOnOffMask=0;
 3476               		.loc 1 1510 0
 3477 1c22 1092 0000 		sts ledOnOffMask,__zero_reg__
1511:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 3478               		.loc 1 1511 0
 3479 1c26 80E0      		ldi r24,0
 3480 1c28 90E0      		ldi r25,0
 3481 1c2a 0C94 0000 		jmp BlinkLeds
 3482               	.LVL95:
 3483               		.cfi_endproc
 3484               	.LFE19:
 3487               	StopBlinking:
 3488               	.LFB18:
1503:WTPA.c        **** {
 3489               		.loc 1 1503 0
 3490               		.cfi_startproc
 3491               	/* prologue: function */
 3492               	/* frame size = 0 */
 3493               	/* stack size = 0 */
 3494               	.L__stack_usage = 0
1504:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 3495               		.loc 1 1504 0
 3496 1c2e 80E0      		ldi r24,0
 3497 1c30 90E0      		ldi r25,0
 3498 1c32 0C94 0000 		jmp BlinkLeds
 3499               	.LVL96:
 3500               		.cfi_endproc
 3501               	.LFE18:
 3504               	DoFruitcakeIntro:
 3505               	.LFB75:
4789:WTPA.c        **** {
 3506               		.loc 1 4789 0
 3507               		.cfi_startproc
 3508 1c36 CF93      		push r28
 3509               	.LCFI32:
 3510               		.cfi_def_cfa_offset 3
 3511               		.cfi_offset 28, -2
 3512               	/* prologue: function */
 3513               	/* frame size = 0 */
 3514               	/* stack size = 1 */
 3515               	.L__stack_usage = 1
4793:WTPA.c        **** 	if(subState==SS_0)
 3516               		.loc 1 4793 0
 3517 1c38 C091 0000 		lds r28,subState
 3518 1c3c C111      		cpse r28,__zero_reg__
 3519 1c3e 00C0      		rjmp .L191
4795:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 3520               		.loc 1 4795 0
 3521 1c40 1092 0000 		sts cardState,__zero_reg__
4797:WTPA.c        **** 		KillLeds();
 3522               		.loc 1 4797 0
 3523 1c44 0E94 0000 		call KillLeds
 3524               	.LVL97:
4798:WTPA.c        **** 		i=0;
 3525               		.loc 1 4798 0
 3526 1c48 1092 0000 		sts i.2279,__zero_reg__
4799:WTPA.c        **** 		ledOnOffMask=0;
 3527               		.loc 1 4799 0
 3528 1c4c 1092 0000 		sts ledOnOffMask,__zero_reg__
4800:WTPA.c        **** 		subState=SS_1;
 3529               		.loc 1 4800 0
 3530 1c50 81E0      		ldi r24,lo8(1)
 3531 1c52 8093 0000 		sts subState,r24
4801:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 3532               		.loc 1 4801 0
 3533 1c56 61E3      		ldi r22,lo8(49)
 3534 1c58 71E0      		ldi r23,lo8(1)
 3535 1c5a 80E0      		ldi r24,0
 3536               	/* epilogue start */
4886:WTPA.c        **** }
 3537               		.loc 1 4886 0
 3538 1c5c CF91      		pop r28
4801:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 3539               		.loc 1 4801 0
 3540 1c5e 0C94 0000 		jmp SetTimer
 3541               	.LVL98:
 3542               	.L191:
4803:WTPA.c        **** 	else if(subState==SS_1)
 3543               		.loc 1 4803 0
 3544 1c62 C130      		cpi r28,lo8(1)
 3545 1c64 01F4      		brne .L192
4805:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3546               		.loc 1 4805 0
 3547 1c66 80E0      		ldi r24,0
 3548 1c68 0E94 0000 		call CheckTimer
 3549               	.LVL99:
 3550 1c6c 8823      		tst r24
 3551 1c6e 01F4      		brne .+2
 3552 1c70 00C0      		rjmp .L203
4807:WTPA.c        **** 			subState=SS_2;
 3553               		.loc 1 4807 0
 3554 1c72 82E0      		ldi r24,lo8(2)
 3555 1c74 00C0      		rjmp .L216
 3556               	.L192:
4812:WTPA.c        **** 	else if(subState==SS_2)
 3557               		.loc 1 4812 0
 3558 1c76 C230      		cpi r28,lo8(2)
 3559 1c78 01F0      		breq .+2
 3560 1c7a 00C0      		rjmp .L195
4814:WTPA.c        **** 		if(i<NUM_LEDS)
 3561               		.loc 1 4814 0
 3562 1c7c 8091 0000 		lds r24,i.2279
 3563 1c80 8830      		cpi r24,lo8(8)
 3564 1c82 00F4      		brsh .L196
4816:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3565               		.loc 1 4816 0
 3566 1c84 80E0      		ldi r24,0
 3567 1c86 0E94 0000 		call CheckTimer
 3568               	.LVL100:
 3569 1c8a 8823      		tst r24
 3570 1c8c 01F4      		brne .+2
 3571 1c8e 00C0      		rjmp .L203
4818:WTPA.c        **** 				ledOnOffMask|=(1<<i);
 3572               		.loc 1 4818 0
 3573 1c90 81E0      		ldi r24,lo8(1)
 3574 1c92 90E0      		ldi r25,0
 3575 1c94 0090 0000 		lds r0,i.2279
 3576 1c98 00C0      		rjmp 2f
 3577               		1:
 3578 1c9a 880F      		lsl r24
 3579 1c9c 991F      		rol r25
 3580               		2:
 3581 1c9e 0A94      		dec r0
 3582 1ca0 02F4      		brpl 1b
 3583 1ca2 9091 0000 		lds r25,ledOnOffMask
 3584 1ca6 982B      		or r25,r24
 3585 1ca8 9093 0000 		sts ledOnOffMask,r25
4819:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
 3586               		.loc 1 4819 0
 3587 1cac 6DE3      		ldi r22,lo8(61)
 3588 1cae 70E0      		ldi r23,0
 3589 1cb0 80E0      		ldi r24,0
 3590 1cb2 0E94 0000 		call SetTimer
 3591               	.LVL101:
4820:WTPA.c        **** 				i++;
 3592               		.loc 1 4820 0
 3593 1cb6 8091 0000 		lds r24,i.2279
 3594 1cba 8F5F      		subi r24,lo8(-(1))
 3595 1cbc 8093 0000 		sts i.2279,r24
 3596 1cc0 00C0      		rjmp .L203
 3597               	.L196:
4825:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3598               		.loc 1 4825 0
 3599 1cc2 80E0      		ldi r24,0
 3600 1cc4 0E94 0000 		call CheckTimer
 3601               	.LVL102:
 3602 1cc8 8823      		tst r24
 3603 1cca 01F4      		brne .+2
 3604 1ccc 00C0      		rjmp .L203
4827:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
 3605               		.loc 1 4827 0
 3606 1cce 68E9      		ldi r22,lo8(-104)
 3607 1cd0 70E0      		ldi r23,0
 3608 1cd2 80E0      		ldi r24,0
 3609 1cd4 0E94 0000 		call SetTimer
 3610               	.LVL103:
4828:WTPA.c        **** 				ledPwm=255;
 3611               		.loc 1 4828 0
 3612 1cd8 8FEF      		ldi r24,lo8(-1)
 3613 1cda 8093 0000 		sts ledPwm,r24
4831:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 3614               		.loc 1 4831 0
 3615 1cde 9091 6400 		lds r25,100
 3616 1ce2 9F7B      		andi r25,lo8(-65)
 3617 1ce4 9093 6400 		sts 100,r25
4833:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 3618               		.loc 1 4833 0
 3619 1ce8 C093 B000 		sts 176,r28
4834:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
 3620               		.loc 1 4834 0
 3621 1cec 91E0      		ldi r25,lo8(1)
 3622 1cee 9093 B100 		sts 177,r25
4835:WTPA.c        **** 				TCNT2=0;			// Init counter reg
 3623               		.loc 1 4835 0
 3624 1cf2 1092 B200 		sts 178,__zero_reg__
4836:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
 3625               		.loc 1 4836 0
 3626 1cf6 90E8      		ldi r25,lo8(-128)
 3627 1cf8 9093 B300 		sts 179,r25
4837:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 3628               		.loc 1 4837 0
 3629 1cfc 87BB      		out 0x17,r24
4838:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
 3630               		.loc 1 4838 0
 3631 1cfe C093 7000 		sts 112,r28
4840:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
 3632               		.loc 1 4840 0
 3633 1d02 92B1      		in r25,0x2
 3634 1d04 9660      		ori r25,lo8(6)
 3635 1d06 92B9      		out 0x2,r25
4841:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
 3636               		.loc 1 4841 0
 3637 1d08 84B9      		out 0x4,r24
4842:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
 3638               		.loc 1 4842 0
 3639 1d0a 5F9A      		sbi 0xb,7
4844:WTPA.c        **** 				subState=SS_3;
 3640               		.loc 1 4844 0
 3641 1d0c 83E0      		ldi r24,lo8(3)
 3642 1d0e 00C0      		rjmp .L216
 3643               	.L195:
4849:WTPA.c        **** 	else if(subState==SS_3)
 3644               		.loc 1 4849 0
 3645 1d10 C330      		cpi r28,lo8(3)
 3646 1d12 01F4      		brne .L200
4851:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3647               		.loc 1 4851 0
 3648 1d14 80E0      		ldi r24,0
 3649 1d16 0E94 0000 		call CheckTimer
 3650               	.LVL104:
 3651 1d1a 8823      		tst r24
 3652 1d1c 01F0      		breq .L203
4853:WTPA.c        **** 			if(ledPwm>1)
 3653               		.loc 1 4853 0
 3654 1d1e 8091 0000 		lds r24,ledPwm
 3655 1d22 8230      		cpi r24,lo8(2)
 3656 1d24 00F0      		brlo .L202
4855:WTPA.c        **** 				ledPwm-=2;
 3657               		.loc 1 4855 0
 3658 1d26 8091 0000 		lds r24,ledPwm
 3659 1d2a 8250      		subi r24,lo8(-(-2))
 3660 1d2c 8093 0000 		sts ledPwm,r24
4856:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
 3661               		.loc 1 4856 0
 3662 1d30 64E0      		ldi r22,lo8(4)
 3663 1d32 70E0      		ldi r23,0
 3664 1d34 80E0      		ldi r24,0
 3665 1d36 0E94 0000 		call SetTimer
 3666               	.LVL105:
 3667 1d3a 00C0      		rjmp .L203
 3668               	.L202:
4861:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
 3669               		.loc 1 4861 0
 3670 1d3c 1092 7000 		sts 112,__zero_reg__
4862:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
 3671               		.loc 1 4862 0
 3672 1d40 1092 B000 		sts 176,__zero_reg__
4863:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
 3673               		.loc 1 4863 0
 3674 1d44 1092 B100 		sts 177,__zero_reg__
4864:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
 3675               		.loc 1 4864 0
 3676 1d48 8091 6400 		lds r24,100
 3677 1d4c 8064      		ori r24,lo8(64)
 3678 1d4e 8093 6400 		sts 100,r24
4866:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
 3679               		.loc 1 4866 0
 3680 1d52 15B8      		out 0x5,__zero_reg__
4867:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
 3681               		.loc 1 4867 0
 3682 1d54 5F98      		cbi 0xb,7
4869:WTPA.c        **** 				KillLeds();				// App knows leds are off.
 3683               		.loc 1 4869 0
 3684 1d56 0E94 0000 		call KillLeds
 3685               	.LVL106:
4870:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
 3686               		.loc 1 4870 0
 3687 1d5a 82E1      		ldi r24,lo8(18)
 3688 1d5c 8093 0000 		sts ledOnOffMask,r24
4871:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
 3689               		.loc 1 4871 0
 3690 1d60 62E6      		ldi r22,lo8(98)
 3691 1d62 72E0      		ldi r23,lo8(2)
 3692 1d64 80E0      		ldi r24,0
 3693 1d66 0E94 0000 		call SetTimer
 3694               	.LVL107:
4872:WTPA.c        **** 				subState=SS_4;
 3695               		.loc 1 4872 0
 3696 1d6a 84E0      		ldi r24,lo8(4)
 3697               	.L216:
 3698 1d6c 8093 0000 		sts subState,r24
 3699 1d70 00C0      		rjmp .L203
 3700               	.L200:
4877:WTPA.c        **** 	else if(subState==SS_4)
 3701               		.loc 1 4877 0
 3702 1d72 C430      		cpi r28,lo8(4)
 3703 1d74 01F4      		brne .L190
4879:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3704               		.loc 1 4879 0
 3705 1d76 80E0      		ldi r24,0
 3706 1d78 0E94 0000 		call CheckTimer
 3707               	.LVL108:
 3708 1d7c 8823      		tst r24
 3709 1d7e 01F0      		breq .L203
4881:WTPA.c        **** 			KillLeds();
 3710               		.loc 1 4881 0
 3711 1d80 0E94 0000 		call KillLeds
 3712               	.LVL109:
 3713               	.LBB60:
 3714               	.LBB61:
1429:WTPA.c        **** 	State=newState;
 3715               		.loc 1 1429 0
 3716 1d84 80E0      		ldi r24,lo8(gs(DoStartupSelect))
 3717 1d86 90E0      		ldi r25,hi8(gs(DoStartupSelect))
 3718 1d88 9093 0000 		sts State+1,r25
 3719 1d8c 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 3720               		.loc 1 1430 0
 3721 1d90 1092 0000 		sts subState,__zero_reg__
 3722               	.LVL110:
 3723               	.L203:
 3724               	.LBE61:
 3725               	.LBE60:
4884:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 3726               		.loc 1 4884 0
 3727 1d94 1092 0000 		sts cardState,__zero_reg__
 3728               	.L190:
 3729               	/* epilogue start */
4886:WTPA.c        **** }
 3730               		.loc 1 4886 0
 3731 1d98 CF91      		pop r28
 3732 1d9a 0895      		ret
 3733               		.cfi_endproc
 3734               	.LFE75:
 3737               	ResetSdCard:
 3738               	.LFB43:
2344:WTPA.c        **** {
 3739               		.loc 1 2344 0
 3740               		.cfi_startproc
 3741 1d9c CF93      		push r28
 3742               	.LCFI33:
 3743               		.cfi_def_cfa_offset 3
 3744               		.cfi_offset 28, -2
 3745               	/* prologue: function */
 3746               	/* frame size = 0 */
 3747               	/* stack size = 1 */
 3748               	.L__stack_usage = 1
2348:WTPA.c        **** 	sreg=SREG;
 3749               		.loc 1 2348 0
 3750 1d9e CFB7      		in r28,__SREG__
 3751               	.LVL111:
2349:WTPA.c        **** 	cli();
 3752               		.loc 1 2349 0
 3753               	/* #APP */
 3754               	 ;  2349 "WTPA.c" 1
 3755 1da0 F894      		cli
 3756               	 ;  0 "" 2
2351:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 3757               		.loc 1 2351 0
 3758               	/* #NOAPP */
 3759 1da2 0E94 0000 		call EndSdTransfer
 3760               	.LVL112:
 3761 1da6 E0E0      		ldi r30,lo8(sampleToc)
 3762 1da8 F0E0      		ldi r31,hi8(sampleToc)
 3763               	.LVL113:
 3764               	.L218:
 3765               	.LBB64:
 3766               	.LBB65:
2091:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 3767               		.loc 1 2091 0
 3768 1daa 1192      		st Z+,__zero_reg__
2089:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 3769               		.loc 1 2089 0
 3770 1dac 80E0      		ldi r24,hi8(sampleToc+64)
 3771 1dae E030      		cpi r30,lo8(sampleToc+64)
 3772 1db0 F807      		cpc r31,r24
 3773 1db2 01F4      		brne .L218
 3774               	.LBE65:
 3775               	.LBE64:
2356:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 3776               		.loc 1 2356 0
 3777 1db4 1092 0000 		sts sdIsrState,__zero_reg__
2357:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
 3778               		.loc 1 2357 0
 3779 1db8 1092 B100 		sts 177,__zero_reg__
2358:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 3780               		.loc 1 2358 0
 3781 1dbc 8091 7000 		lds r24,112
 3782 1dc0 8B7F      		andi r24,lo8(-5)
 3783 1dc2 8093 7000 		sts 112,r24
2361:WTPA.c        **** 	sdStreamOutput=0;
 3784               		.loc 1 2361 0
 3785 1dc6 1092 0000 		sts sdStreamOutput,__zero_reg__
2363:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 3786               		.loc 1 2363 0
 3787 1dca 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 3788 1dce 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2364:WTPA.c        **** 	sdFifoWritePointer=0;
 3789               		.loc 1 2364 0
 3790 1dd2 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 3791 1dd6 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2365:WTPA.c        **** 	sdBytesInFifo=0;
 3792               		.loc 1 2365 0
 3793 1dda 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 3794 1dde 1092 0000 		sts sdBytesInFifo,__zero_reg__
2367:WTPA.c        **** 	InitSdInterface();
 3795               		.loc 1 2367 0
 3796 1de2 0E94 0000 		call InitSdInterface
 3797               	.LVL114:
2368:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
 3798               		.loc 1 2368 0
 3799 1de6 1092 0000 		sts cardState,__zero_reg__
2370:WTPA.c        **** 	SREG=sreg;
 3800               		.loc 1 2370 0
 3801 1dea CFBF      		out __SREG__,r28
 3802               	/* epilogue start */
2371:WTPA.c        **** }
 3803               		.loc 1 2371 0
 3804 1dec CF91      		pop r28
 3805               	.LVL115:
 3806 1dee 0895      		ret
 3807               		.cfi_endproc
 3808               	.LFE43:
 3811               	SdStartSampleRead:
 3812               	.LFB41:
2282:WTPA.c        **** {
 3813               		.loc 1 2282 0
 3814               		.cfi_startproc
 3815               	.LVL116:
 3816 1df0 CF92      		push r12
 3817               	.LCFI34:
 3818               		.cfi_def_cfa_offset 3
 3819               		.cfi_offset 12, -2
 3820 1df2 DF92      		push r13
 3821               	.LCFI35:
 3822               		.cfi_def_cfa_offset 4
 3823               		.cfi_offset 13, -3
 3824 1df4 EF92      		push r14
 3825               	.LCFI36:
 3826               		.cfi_def_cfa_offset 5
 3827               		.cfi_offset 14, -4
 3828 1df6 FF92      		push r15
 3829               	.LCFI37:
 3830               		.cfi_def_cfa_offset 6
 3831               		.cfi_offset 15, -5
 3832 1df8 CF93      		push r28
 3833               	.LCFI38:
 3834               		.cfi_def_cfa_offset 7
 3835               		.cfi_offset 28, -6
 3836               	/* prologue: function */
 3837               	/* frame size = 0 */
 3838               	/* stack size = 5 */
 3839               	.L__stack_usage = 5
2286:WTPA.c        **** 	sreg=SREG;
 3840               		.loc 1 2286 0
 3841 1dfa CFB7      		in r28,__SREG__
 3842               	.LVL117:
2287:WTPA.c        **** 	cli();		// Pause ISR
 3843               		.loc 1 2287 0
 3844               	/* #APP */
 3845               	 ;  2287 "WTPA.c" 1
 3846 1dfc F894      		cli
 3847               	 ;  0 "" 2
2289:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
 3848               		.loc 1 2289 0
 3849               	/* #NOAPP */
 3850 1dfe 382F      		mov r19,r24
 3851 1e00 330F      		lsl r19
 3852 1e02 330F      		lsl r19
 3853 1e04 20E0      		ldi r18,0
 3854 1e06 6901      		movw r12,r18
 3855 1e08 8FEF      		ldi r24,-1
 3856 1e0a C81A      		sub r12,r24
 3857 1e0c D80A      		sbc r13,r24
 3858               	.LVL118:
 3859 1e0e E12C      		mov r14,__zero_reg__
 3860 1e10 F12C      		mov r15,__zero_reg__
 3861 1e12 C701      		movw r24,r14
 3862 1e14 B601      		movw r22,r12
 3863 1e16 0E94 0000 		call SdBeginSingleBlockRead
 3864               	.LVL119:
 3865 1e1a 8130      		cpi r24,lo8(1)
 3866 1e1c 01F4      		brne .L221
2291:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
 3867               		.loc 1 2291 0
 3868 1e1e C092 0000 		sts sdSampleStartBlock,r12
 3869 1e22 D092 0000 		sts sdSampleStartBlock+1,r13
 3870 1e26 E092 0000 		sts sdSampleStartBlock+2,r14
 3871 1e2a F092 0000 		sts sdSampleStartBlock+3,r15
2292:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
 3872               		.loc 1 2292 0
 3873 1e2e 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 3874 1e32 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2294:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
 3875               		.loc 1 2294 0
 3876 1e36 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 3877 1e3a 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2295:WTPA.c        **** 		sdFifoWritePointer=0;
 3878               		.loc 1 2295 0
 3879 1e3e 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 3880 1e42 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2296:WTPA.c        **** 		sdBytesInFifo=0;
 3881               		.loc 1 2296 0
 3882 1e46 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 3883 1e4a 1092 0000 		sts sdBytesInFifo,__zero_reg__
2298:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 3884               		.loc 1 2298 0
 3885 1e4e 6AE7      		ldi r22,lo8(122)
 3886 1e50 70E0      		ldi r23,0
 3887 1e52 83E0      		ldi r24,lo8(3)
 3888 1e54 0E94 0000 		call SetTimer
 3889               	.LVL120:
2299:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
 3890               		.loc 1 2299 0
 3891 1e58 89E0      		ldi r24,lo8(9)
 3892 1e5a 8093 0000 		sts cardState,r24
2301:WTPA.c        **** 		SREG=sreg;	// Resume ISR
 3893               		.loc 1 2301 0
 3894 1e5e CFBF      		out __SREG__,r28
2303:WTPA.c        **** 		return(true);
 3895               		.loc 1 2303 0
 3896 1e60 81E0      		ldi r24,lo8(1)
 3897 1e62 00C0      		rjmp .L222
 3898               	.L221:
2305:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 3899               		.loc 1 2305 0
 3900 1e64 CFBF      		out __SREG__,r28
2306:WTPA.c        **** 	return(false);
 3901               		.loc 1 2306 0
 3902 1e66 80E0      		ldi r24,0
 3903               	.L222:
 3904               	/* epilogue start */
2307:WTPA.c        **** }
 3905               		.loc 1 2307 0
 3906 1e68 CF91      		pop r28
 3907               	.LVL121:
 3908 1e6a FF90      		pop r15
 3909 1e6c EF90      		pop r14
 3910 1e6e DF90      		pop r13
 3911 1e70 CF90      		pop r12
 3912 1e72 0895      		ret
 3913               		.cfi_endproc
 3914               	.LFE41:
 3917               	SetSampleClock.part.0:
 3918               	.LFB77:
1846:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
 3919               		.loc 1 1846 0
 3920               		.cfi_startproc
 3921               	/* prologue: function */
 3922               	/* frame size = 0 */
 3923               	/* stack size = 0 */
 3924               	.L__stack_usage = 0
1875:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 3925               		.loc 1 1875 0
 3926 1e74 E1E8      		ldi r30,lo8(-127)
 3927 1e76 F0E0      		ldi r31,0
 3928 1e78 8081      		ld r24,Z
 3929 1e7a 8064      		ori r24,lo8(64)
 3930 1e7c 8083      		st Z,r24
1876:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 3931               		.loc 1 1876 0
 3932 1e7e B59A      		sbi 0x16,5
1877:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 3933               		.loc 1 1877 0
 3934 1e80 EFE6      		ldi r30,lo8(111)
 3935 1e82 F0E0      		ldi r31,0
 3936 1e84 8081      		ld r24,Z
 3937 1e86 8062      		ori r24,lo8(32)
 3938 1e88 8083      		st Z,r24
 3939 1e8a 0895      		ret
 3940               		.cfi_endproc
 3941               	.LFE77:
 3944               	SetSampleClock:
 3945               	.LFB28:
1849:WTPA.c        **** {
 3946               		.loc 1 1849 0
 3947               		.cfi_startproc
 3948               	.LVL122:
 3949               	/* prologue: function */
 3950               	/* frame size = 0 */
 3951               	/* stack size = 0 */
 3952               	.L__stack_usage = 0
1850:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 3953               		.loc 1 1850 0
 3954 1e8c 94E2      		ldi r25,lo8(36)
 3955 1e8e 899F      		mul r24,r25
 3956 1e90 F001      		movw r30,r0
 3957 1e92 1124      		clr __zero_reg__
 3958 1e94 E050      		subi r30,lo8(-(bankStates))
 3959 1e96 F040      		sbci r31,hi8(-(bankStates))
 3960 1e98 6287      		std Z+10,r22
1852:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
 3961               		.loc 1 1852 0
 3962 1e9a 6230      		cpi r22,lo8(2)
 3963 1e9c 01F4      		brne .L225
1854:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 3964               		.loc 1 1854 0
 3965 1e9e 5487      		std Z+12,r21
 3966 1ea0 4387      		std Z+11,r20
1856:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 3967               		.loc 1 1856 0
 3968 1ea2 8111      		cpse r24,__zero_reg__
 3969 1ea4 00C0      		rjmp .L226
1858:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3970               		.loc 1 1858 0
 3971 1ea6 8091 8400 		lds r24,132
 3972 1eaa 9091 8500 		lds r25,132+1
 3973               	.LVL123:
 3974 1eae 840F      		add r24,r20
 3975 1eb0 951F      		adc r25,r21
 3976 1eb2 9093 8900 		sts 136+1,r25
 3977 1eb6 8093 8800 		sts 136,r24
1859:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 3978               		.loc 1 1859 0
 3979 1eba B19A      		sbi 0x16,1
1860:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 3980               		.loc 1 1860 0
 3981 1ebc 8091 6F00 		lds r24,111
 3982 1ec0 8260      		ori r24,lo8(2)
 3983 1ec2 00C0      		rjmp .L229
 3984               	.LVL124:
 3985               	.L226:
1865:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3986               		.loc 1 1865 0
 3987 1ec4 8091 8400 		lds r24,132
 3988 1ec8 9091 8500 		lds r25,132+1
 3989               	.LVL125:
 3990 1ecc 840F      		add r24,r20
 3991 1ece 951F      		adc r25,r21
 3992 1ed0 9093 8B00 		sts 138+1,r25
 3993 1ed4 8093 8A00 		sts 138,r24
1866:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 3994               		.loc 1 1866 0
 3995 1ed8 B29A      		sbi 0x16,2
1867:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 3996               		.loc 1 1867 0
 3997 1eda 8091 6F00 		lds r24,111
 3998 1ede 8460      		ori r24,lo8(4)
 3999               	.L229:
 4000 1ee0 8093 6F00 		sts 111,r24
1868:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 4001               		.loc 1 1868 0
 4002 1ee4 81E0      		ldi r24,lo8(1)
 4003 1ee6 8093 8100 		sts 129,r24
 4004 1eea 0895      		ret
 4005               	.LVL126:
 4006               	.L225:
1871:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
 4007               		.loc 1 1871 0
 4008 1eec 6130      		cpi r22,lo8(1)
 4009 1eee 01F4      		brne .L224
1873:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 4010               		.loc 1 1873 0
 4011 1ef0 8111      		cpse r24,__zero_reg__
 4012 1ef2 00C0      		rjmp .L228
 4013 1ef4 0C94 0000 		jmp SetSampleClock.part.0
 4014               	.LVL127:
 4015               	.L228:
1881:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 4016               		.loc 1 1881 0
 4017 1ef8 DA9A      		sbi 0x1b,2
1882:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 4018               		.loc 1 1882 0
 4019 1efa 84E0      		ldi r24,lo8(4)
 4020               	.LVL128:
 4021 1efc 8093 6800 		sts 104,r24
1883:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 4022               		.loc 1 1883 0
 4023 1f00 80E1      		ldi r24,lo8(16)
 4024 1f02 8093 6D00 		sts 109,r24
 4025               	.L224:
 4026 1f06 0895      		ret
 4027               		.cfi_endproc
 4028               	.LFE28:
 4031               	StartPlayback:
 4032               	.LFB30:
1933:WTPA.c        **** {
 4033               		.loc 1 1933 0
 4034               		.cfi_startproc
 4035               	.LVL129:
 4036 1f08 FF92      		push r15
 4037               	.LCFI39:
 4038               		.cfi_def_cfa_offset 3
 4039               		.cfi_offset 15, -2
 4040 1f0a 0F93      		push r16
 4041               	.LCFI40:
 4042               		.cfi_def_cfa_offset 4
 4043               		.cfi_offset 16, -3
 4044 1f0c 1F93      		push r17
 4045               	.LCFI41:
 4046               		.cfi_def_cfa_offset 5
 4047               		.cfi_offset 17, -4
 4048 1f0e CF93      		push r28
 4049               	.LCFI42:
 4050               		.cfi_def_cfa_offset 6
 4051               		.cfi_offset 28, -5
 4052 1f10 DF93      		push r29
 4053               	.LCFI43:
 4054               		.cfi_def_cfa_offset 7
 4055               		.cfi_offset 29, -6
 4056               	/* prologue: function */
 4057               	/* frame size = 0 */
 4058               	/* stack size = 5 */
 4059               	.L__stack_usage = 5
1937:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4060               		.loc 1 1937 0
 4061 1f12 C82F      		mov r28,r24
 4062 1f14 D0E0      		ldi r29,0
 4063 1f16 94E2      		ldi r25,lo8(36)
 4064 1f18 899F      		mul r24,r25
 4065 1f1a F001      		movw r30,r0
 4066 1f1c 1124      		clr __zero_reg__
 4067 1f1e E050      		subi r30,lo8(-(bankStates))
 4068 1f20 F040      		sbci r31,hi8(-(bankStates))
 4069 1f22 9581      		ldd r25,Z+5
 4070 1f24 9923      		tst r25
 4071 1f26 01F0      		breq .L231
1937:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4072               		.loc 1 1937 0 is_stmt 0 discriminator 1
 4073 1f28 9091 0000 		lds r25,sdIsrState
 4074 1f2c 9150      		subi r25,lo8(-(-1))
 4075 1f2e 9230      		cpi r25,lo8(2)
 4076 1f30 00F0      		brlo .L230
 4077               	.L231:
1939:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4078               		.loc 1 1939 0 is_stmt 1
 4079 1f32 FFB6      		in r15,__SREG__
 4080               	.LVL130:
1940:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4081               		.loc 1 1940 0
 4082               	/* #APP */
 4083               	 ;  1940 "WTPA.c" 1
 4084 1f34 F894      		cli
 4085               	 ;  0 "" 2
1942:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 4086               		.loc 1 1942 0
 4087               	/* #NOAPP */
 4088 1f36 94E2      		ldi r25,lo8(36)
 4089 1f38 9C9F      		mul r25,r28
 4090 1f3a F001      		movw r30,r0
 4091 1f3c 9D9F      		mul r25,r29
 4092 1f3e F00D      		add r31,r0
 4093 1f40 1124      		clr __zero_reg__
 4094 1f42 E050      		subi r30,lo8(-(bankStates))
 4095 1f44 F040      		sbci r31,hi8(-(bankStates))
 4096 1f46 94E0      		ldi r25,lo8(4)
 4097 1f48 9083      		st Z,r25
1944:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 4098               		.loc 1 1944 0
 4099 1f4a 9381      		ldd r25,Z+3
 4100 1f4c 9923      		tst r25
 4101 1f4e 01F0      		breq .L233
1946:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 4102               		.loc 1 1946 0
 4103 1f50 0589      		ldd r16,Z+21
 4104 1f52 1689      		ldd r17,Z+22
 4105 1f54 2789      		ldd r18,Z+23
 4106 1f56 308D      		ldd r19,Z+24
 4107 1f58 00A3      		std Z+32,r16
 4108 1f5a 11A3      		std Z+33,r17
 4109 1f5c 22A3      		std Z+34,r18
 4110 1f5e 33A3      		std Z+35,r19
1947:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 4111               		.loc 1 1947 0
 4112 1f60 1482      		std Z+4,__zero_reg__
 4113 1f62 00C0      		rjmp .L234
 4114               	.L233:
1951:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 4115               		.loc 1 1951 0
 4116 1f64 018D      		ldd r16,Z+25
 4117 1f66 128D      		ldd r17,Z+26
 4118 1f68 238D      		ldd r18,Z+27
 4119 1f6a 348D      		ldd r19,Z+28
 4120 1f6c 00A3      		std Z+32,r16
 4121 1f6e 11A3      		std Z+33,r17
 4122 1f70 22A3      		std Z+34,r18
 4123 1f72 33A3      		std Z+35,r19
1952:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 4124               		.loc 1 1952 0
 4125 1f74 91E0      		ldi r25,lo8(1)
 4126 1f76 9483      		std Z+4,r25
 4127               	.L234:
1955:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 4128               		.loc 1 1955 0
 4129 1f78 0E94 0000 		call SetSampleClock
 4130               	.LVL131:
1956:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4131               		.loc 1 1956 0
 4132 1f7c 84E2      		ldi r24,lo8(36)
 4133 1f7e 8C9F      		mul r24,r28
 4134 1f80 F001      		movw r30,r0
 4135 1f82 8D9F      		mul r24,r29
 4136 1f84 F00D      		add r31,r0
 4137 1f86 1124      		clr __zero_reg__
 4138 1f88 E050      		subi r30,lo8(-(bankStates))
 4139 1f8a F040      		sbci r31,hi8(-(bankStates))
 4140 1f8c 81E0      		ldi r24,lo8(1)
 4141 1f8e 8583      		std Z+5,r24
1957:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4142               		.loc 1 1957 0
 4143 1f90 FFBE      		out __SREG__,r15
 4144               	.LVL132:
 4145               	.L230:
 4146               	/* epilogue start */
1959:WTPA.c        **** }
 4147               		.loc 1 1959 0
 4148 1f92 DF91      		pop r29
 4149 1f94 CF91      		pop r28
 4150               	.LVL133:
 4151 1f96 1F91      		pop r17
 4152 1f98 0F91      		pop r16
 4153 1f9a FF90      		pop r15
 4154 1f9c 0895      		ret
 4155               		.cfi_endproc
 4156               	.LFE30:
 4159               	ContinuePlayback:
 4160               	.LFB31:
1964:WTPA.c        **** {
 4161               		.loc 1 1964 0
 4162               		.cfi_startproc
 4163               	.LVL134:
 4164 1f9e 1F93      		push r17
 4165               	.LCFI44:
 4166               		.cfi_def_cfa_offset 3
 4167               		.cfi_offset 17, -2
 4168 1fa0 CF93      		push r28
 4169               	.LCFI45:
 4170               		.cfi_def_cfa_offset 4
 4171               		.cfi_offset 28, -3
 4172 1fa2 DF93      		push r29
 4173               	.LCFI46:
 4174               		.cfi_def_cfa_offset 5
 4175               		.cfi_offset 29, -4
 4176               	/* prologue: function */
 4177               	/* frame size = 0 */
 4178               	/* stack size = 3 */
 4179               	.L__stack_usage = 3
1968:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4180               		.loc 1 1968 0
 4181 1fa4 282F      		mov r18,r24
 4182 1fa6 30E0      		ldi r19,0
 4183 1fa8 94E2      		ldi r25,lo8(36)
 4184 1faa 899F      		mul r24,r25
 4185 1fac F001      		movw r30,r0
 4186 1fae 1124      		clr __zero_reg__
 4187 1fb0 E050      		subi r30,lo8(-(bankStates))
 4188 1fb2 F040      		sbci r31,hi8(-(bankStates))
 4189 1fb4 9581      		ldd r25,Z+5
 4190 1fb6 9923      		tst r25
 4191 1fb8 01F0      		breq .L239
1968:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4192               		.loc 1 1968 0 is_stmt 0 discriminator 1
 4193 1fba 9091 0000 		lds r25,sdIsrState
 4194 1fbe 9150      		subi r25,lo8(-(-1))
 4195 1fc0 9230      		cpi r25,lo8(2)
 4196 1fc2 00F0      		brlo .L238
 4197               	.L239:
1970:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4198               		.loc 1 1970 0 is_stmt 1
 4199 1fc4 1FB7      		in r17,__SREG__
 4200               	.LVL135:
1971:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4201               		.loc 1 1971 0
 4202               	/* #APP */
 4203               	 ;  1971 "WTPA.c" 1
 4204 1fc6 F894      		cli
 4205               	 ;  0 "" 2
1973:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 4206               		.loc 1 1973 0
 4207               	/* #NOAPP */
 4208 1fc8 94E2      		ldi r25,lo8(36)
 4209 1fca 929F      		mul r25,r18
 4210 1fcc E001      		movw r28,r0
 4211 1fce 939F      		mul r25,r19
 4212 1fd0 D00D      		add r29,r0
 4213 1fd2 1124      		clr __zero_reg__
 4214 1fd4 C050      		subi r28,lo8(-(bankStates))
 4215 1fd6 D040      		sbci r29,hi8(-(bankStates))
 4216 1fd8 94E0      		ldi r25,lo8(4)
 4217 1fda 9883      		st Y,r25
1974:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4218               		.loc 1 1974 0
 4219 1fdc 0E94 0000 		call SetSampleClock
 4220               	.LVL136:
1976:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4221               		.loc 1 1976 0
 4222 1fe0 81E0      		ldi r24,lo8(1)
 4223 1fe2 8D83      		std Y+5,r24
1977:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4224               		.loc 1 1977 0
 4225 1fe4 1FBF      		out __SREG__,r17
 4226               	.LVL137:
 4227               	.L238:
 4228               	/* epilogue start */
1979:WTPA.c        **** }
 4229               		.loc 1 1979 0
 4230 1fe6 DF91      		pop r29
 4231 1fe8 CF91      		pop r28
 4232 1fea 1F91      		pop r17
 4233 1fec 0895      		ret
 4234               		.cfi_endproc
 4235               	.LFE31:
 4238               	StartRecording:
 4239               	.LFB29:
1893:WTPA.c        **** {
 4240               		.loc 1 1893 0
 4241               		.cfi_startproc
 4242               	.LVL138:
 4243 1fee FF92      		push r15
 4244               	.LCFI47:
 4245               		.cfi_def_cfa_offset 3
 4246               		.cfi_offset 15, -2
 4247 1ff0 0F93      		push r16
 4248               	.LCFI48:
 4249               		.cfi_def_cfa_offset 4
 4250               		.cfi_offset 16, -3
 4251 1ff2 1F93      		push r17
 4252               	.LCFI49:
 4253               		.cfi_def_cfa_offset 5
 4254               		.cfi_offset 17, -4
 4255 1ff4 CF93      		push r28
 4256               	.LCFI50:
 4257               		.cfi_def_cfa_offset 6
 4258               		.cfi_offset 28, -5
 4259 1ff6 DF93      		push r29
 4260               	.LCFI51:
 4261               		.cfi_def_cfa_offset 7
 4262               		.cfi_offset 29, -6
 4263               	/* prologue: function */
 4264               	/* frame size = 0 */
 4265               	/* stack size = 5 */
 4266               	.L__stack_usage = 5
1898:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4267               		.loc 1 1898 0
 4268 1ff8 282F      		mov r18,r24
 4269 1ffa 30E0      		ldi r19,0
 4270 1ffc 94E2      		ldi r25,lo8(36)
 4271 1ffe 899F      		mul r24,r25
 4272 2000 F001      		movw r30,r0
 4273 2002 1124      		clr __zero_reg__
 4274 2004 E050      		subi r30,lo8(-(bankStates))
 4275 2006 F040      		sbci r31,hi8(-(bankStates))
 4276 2008 9581      		ldd r25,Z+5
 4277 200a 9923      		tst r25
 4278 200c 01F0      		breq .L245
1898:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4279               		.loc 1 1898 0 is_stmt 0 discriminator 1
 4280 200e 9091 0000 		lds r25,sdIsrState
 4281 2012 9150      		subi r25,lo8(-(-1))
 4282 2014 9230      		cpi r25,lo8(2)
 4283 2016 00F4      		brsh .+2
 4284 2018 00C0      		rjmp .L244
 4285               	.L245:
1901:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4286               		.loc 1 1901 0 is_stmt 1
 4287 201a FFB6      		in r15,__SREG__
 4288               	.LVL139:
1902:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4289               		.loc 1 1902 0
 4290               	/* #APP */
 4291               	 ;  1902 "WTPA.c" 1
 4292 201c F894      		cli
 4293               	 ;  0 "" 2
1904:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
 4294               		.loc 1 1904 0
 4295               	/* #NOAPP */
 4296 201e 94E2      		ldi r25,lo8(36)
 4297 2020 929F      		mul r25,r18
 4298 2022 E001      		movw r28,r0
 4299 2024 939F      		mul r25,r19
 4300 2026 D00D      		add r29,r0
 4301 2028 1124      		clr __zero_reg__
 4302 202a C050      		subi r28,lo8(-(bankStates))
 4303 202c D040      		sbci r29,hi8(-(bankStates))
 4304 202e 93E0      		ldi r25,lo8(3)
 4305 2030 9883      		st Y,r25
1906:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
 4306               		.loc 1 1906 0
 4307 2032 0989      		ldd r16,Y+17
 4308 2034 1A89      		ldd r17,Y+18
 4309 2036 2B89      		ldd r18,Y+19
 4310 2038 3C89      		ldd r19,Y+20
 4311 203a 08A3      		std Y+32,r16
 4312 203c 19A3      		std Y+33,r17
 4313 203e 2AA3      		std Y+34,r18
 4314 2040 3BA3      		std Y+35,r19
1907:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
 4315               		.loc 1 1907 0
 4316 2042 0989      		ldd r16,Y+17
 4317 2044 1A89      		ldd r17,Y+18
 4318 2046 2B89      		ldd r18,Y+19
 4319 2048 3C89      		ldd r19,Y+20
 4320 204a 0D87      		std Y+13,r16
 4321 204c 1E87      		std Y+14,r17
 4322 204e 2F87      		std Y+15,r18
 4323 2050 388B      		std Y+16,r19
1908:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
 4324               		.loc 1 1908 0
 4325 2052 0989      		ldd r16,Y+17
 4326 2054 1A89      		ldd r17,Y+18
 4327 2056 2B89      		ldd r18,Y+19
 4328 2058 3C89      		ldd r19,Y+20
 4329 205a 098F      		std Y+25,r16
 4330 205c 1A8F      		std Y+26,r17
 4331 205e 2B8F      		std Y+27,r18
 4332 2060 3C8F      		std Y+28,r19
1909:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
 4333               		.loc 1 1909 0
 4334 2062 0989      		ldd r16,Y+17
 4335 2064 1A89      		ldd r17,Y+18
 4336 2066 2B89      		ldd r18,Y+19
 4337 2068 3C89      		ldd r19,Y+20
 4338 206a 0D8B      		std Y+21,r16
 4339 206c 1E8B      		std Y+22,r17
 4340 206e 2F8B      		std Y+23,r18
 4341 2070 388F      		std Y+24,r19
1910:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
 4342               		.loc 1 1910 0
 4343 2072 1F8E      		std Y+31,__zero_reg__
1912:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
 4344               		.loc 1 1912 0
 4345 2074 1092 0000 		sts outOfRam,__zero_reg__
1914:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 4346               		.loc 1 1914 0
 4347 2078 0E94 0000 		call SetSampleClock
 4348               	.LVL140:
1915:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4349               		.loc 1 1915 0
 4350 207c 81E0      		ldi r24,lo8(1)
 4351 207e 8D83      		std Y+5,r24
1917:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4352               		.loc 1 1917 0
 4353 2080 FFBE      		out __SREG__,r15
1920:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4354               		.loc 1 1920 0
 4355 2082 8091 7A00 		lds r24,122
 4356 2086 86FD      		sbrc r24,6
 4357 2088 00C0      		rjmp .L244
 4358               	.LBB68:
 4359               	.LBB69:
1922:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4360               		.loc 1 1922 0
 4361 208a 8091 7900 		lds r24,121
 4362 208e 8058      		subi r24,lo8(-(-128))
 4363 2090 8093 0000 		sts adcByte,r24
1923:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4364               		.loc 1 1923 0
 4365 2094 8091 7A00 		lds r24,122
 4366 2098 8064      		ori r24,lo8(64)
 4367 209a 8093 7A00 		sts 122,r24
 4368               	.LVL141:
 4369               	.L244:
 4370               	/* epilogue start */
 4371               	.LBE69:
 4372               	.LBE68:
1926:WTPA.c        **** }
 4373               		.loc 1 1926 0
 4374 209e DF91      		pop r29
 4375 20a0 CF91      		pop r28
 4376 20a2 1F91      		pop r17
 4377 20a4 0F91      		pop r16
 4378 20a6 FF90      		pop r15
 4379 20a8 0895      		ret
 4380               		.cfi_endproc
 4381               	.LFE29:
 4384               	StartOverdub:
 4385               	.LFB32:
1984:WTPA.c        **** {
 4386               		.loc 1 1984 0
 4387               		.cfi_startproc
 4388               	.LVL142:
 4389 20aa 1F93      		push r17
 4390               	.LCFI52:
 4391               		.cfi_def_cfa_offset 3
 4392               		.cfi_offset 17, -2
 4393 20ac CF93      		push r28
 4394               	.LCFI53:
 4395               		.cfi_def_cfa_offset 4
 4396               		.cfi_offset 28, -3
 4397 20ae DF93      		push r29
 4398               	.LCFI54:
 4399               		.cfi_def_cfa_offset 5
 4400               		.cfi_offset 29, -4
 4401               	/* prologue: function */
 4402               	/* frame size = 0 */
 4403               	/* stack size = 3 */
 4404               	.L__stack_usage = 3
1988:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4405               		.loc 1 1988 0
 4406 20b0 282F      		mov r18,r24
 4407 20b2 30E0      		ldi r19,0
 4408 20b4 94E2      		ldi r25,lo8(36)
 4409 20b6 899F      		mul r24,r25
 4410 20b8 F001      		movw r30,r0
 4411 20ba 1124      		clr __zero_reg__
 4412 20bc E050      		subi r30,lo8(-(bankStates))
 4413 20be F040      		sbci r31,hi8(-(bankStates))
 4414 20c0 9581      		ldd r25,Z+5
 4415 20c2 9923      		tst r25
 4416 20c4 01F0      		breq .L252
1988:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4417               		.loc 1 1988 0 is_stmt 0 discriminator 1
 4418 20c6 9091 0000 		lds r25,sdIsrState
 4419 20ca 9150      		subi r25,lo8(-(-1))
 4420 20cc 9230      		cpi r25,lo8(2)
 4421 20ce 00F0      		brlo .L251
 4422               	.L252:
1990:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4423               		.loc 1 1990 0 is_stmt 1
 4424 20d0 1FB7      		in r17,__SREG__
 4425               	.LVL143:
1991:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4426               		.loc 1 1991 0
 4427               	/* #APP */
 4428               	 ;  1991 "WTPA.c" 1
 4429 20d2 F894      		cli
 4430               	 ;  0 "" 2
1993:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
 4431               		.loc 1 1993 0
 4432               	/* #NOAPP */
 4433 20d4 94E2      		ldi r25,lo8(36)
 4434 20d6 929F      		mul r25,r18
 4435 20d8 E001      		movw r28,r0
 4436 20da 939F      		mul r25,r19
 4437 20dc D00D      		add r29,r0
 4438 20de 1124      		clr __zero_reg__
 4439 20e0 C050      		subi r28,lo8(-(bankStates))
 4440 20e2 D040      		sbci r29,hi8(-(bankStates))
 4441 20e4 95E0      		ldi r25,lo8(5)
 4442 20e6 9883      		st Y,r25
1994:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4443               		.loc 1 1994 0
 4444 20e8 0E94 0000 		call SetSampleClock
 4445               	.LVL144:
1996:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4446               		.loc 1 1996 0
 4447 20ec 81E0      		ldi r24,lo8(1)
 4448 20ee 8D83      		std Y+5,r24
1997:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4449               		.loc 1 1997 0
 4450 20f0 1FBF      		out __SREG__,r17
2000:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4451               		.loc 1 2000 0
 4452 20f2 8091 7A00 		lds r24,122
 4453 20f6 86FD      		sbrc r24,6
 4454 20f8 00C0      		rjmp .L251
 4455               	.LBB72:
 4456               	.LBB73:
2002:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4457               		.loc 1 2002 0
 4458 20fa 8091 7900 		lds r24,121
 4459 20fe 8058      		subi r24,lo8(-(-128))
 4460 2100 8093 0000 		sts adcByte,r24
2003:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4461               		.loc 1 2003 0
 4462 2104 8091 7A00 		lds r24,122
 4463 2108 8064      		ori r24,lo8(64)
 4464 210a 8093 7A00 		sts 122,r24
 4465               	.LVL145:
 4466               	.L251:
 4467               	/* epilogue start */
 4468               	.LBE73:
 4469               	.LBE72:
2006:WTPA.c        **** }
 4470               		.loc 1 2006 0
 4471 210e DF91      		pop r29
 4472 2110 CF91      		pop r28
 4473 2112 1F91      		pop r17
 4474 2114 0895      		ret
 4475               		.cfi_endproc
 4476               	.LFE32:
 4479               	StartRealtime:
 4480               	.LFB33:
2012:WTPA.c        **** {
 4481               		.loc 1 2012 0
 4482               		.cfi_startproc
 4483               	.LVL146:
 4484 2116 CF93      		push r28
 4485               	.LCFI55:
 4486               		.cfi_def_cfa_offset 3
 4487               		.cfi_offset 28, -2
 4488               	/* prologue: function */
 4489               	/* frame size = 0 */
 4490               	/* stack size = 1 */
 4491               	.L__stack_usage = 1
2016:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 4492               		.loc 1 2016 0
 4493 2118 CFB7      		in r28,__SREG__
 4494               	.LVL147:
2017:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 4495               		.loc 1 2017 0
 4496               	/* #APP */
 4497               	 ;  2017 "WTPA.c" 1
 4498 211a F894      		cli
 4499               	 ;  0 "" 2
2019:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 4500               		.loc 1 2019 0
 4501               	/* #NOAPP */
 4502 211c 94E2      		ldi r25,lo8(36)
 4503 211e 899F      		mul r24,r25
 4504 2120 F001      		movw r30,r0
 4505 2122 1124      		clr __zero_reg__
 4506 2124 E050      		subi r30,lo8(-(bankStates))
 4507 2126 F040      		sbci r31,hi8(-(bankStates))
 4508 2128 92E0      		ldi r25,lo8(2)
 4509 212a 9083      		st Z,r25
2020:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
 4510               		.loc 1 2020 0
 4511 212c 0E94 0000 		call SetSampleClock
 4512               	.LVL148:
2022:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 4513               		.loc 1 2022 0
 4514 2130 CFBF      		out __SREG__,r28
2024:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 4515               		.loc 1 2024 0
 4516 2132 8091 7A00 		lds r24,122
 4517 2136 86FD      		sbrc r24,6
 4518 2138 00C0      		rjmp .L258
 4519               	.LBB76:
 4520               	.LBB77:
2026:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 4521               		.loc 1 2026 0
 4522 213a 8091 7900 		lds r24,121
 4523 213e 8058      		subi r24,lo8(-(-128))
 4524 2140 8093 0000 		sts adcByte,r24
2027:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4525               		.loc 1 2027 0
 4526 2144 8091 7A00 		lds r24,122
 4527 2148 8064      		ori r24,lo8(64)
 4528 214a 8093 7A00 		sts 122,r24
 4529               	.L258:
 4530               	/* epilogue start */
 4531               	.LBE77:
 4532               	.LBE76:
2029:WTPA.c        **** }
 4533               		.loc 1 2029 0
 4534 214e CF91      		pop r28
 4535               	.LVL149:
 4536 2150 0895      		ret
 4537               		.cfi_endproc
 4538               	.LFE33:
 4541               	DoFormatCard:
 4542               	.LFB40:
2237:WTPA.c        **** {
 4543               		.loc 1 2237 0
 4544               		.cfi_startproc
 4545               	/* prologue: function */
 4546               	/* frame size = 0 */
 4547               	/* stack size = 0 */
 4548               	.L__stack_usage = 0
2238:WTPA.c        **** 	if(subState==SS_0)
 4549               		.loc 1 2238 0
 4550 2152 8091 0000 		lds r24,subState
 4551 2156 8111      		cpse r24,__zero_reg__
 4552 2158 00C0      		rjmp .L261
2240:WTPA.c        **** 		KillLeds();		// Turn off LEDs
 4553               		.loc 1 2240 0
 4554 215a 0E94 0000 		call KillLeds
 4555               	.LVL150:
2242:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
 4556               		.loc 1 2242 0
 4557 215e 1092 0000 		sts bankStates,__zero_reg__
2243:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
 4558               		.loc 1 2243 0
 4559 2162 1092 0000 		sts bankStates+10,__zero_reg__
2244:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 4560               		.loc 1 2244 0
 4561 2166 1092 0000 		sts bankStates+36,__zero_reg__
2245:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
 4562               		.loc 1 2245 0
 4563 216a 1092 0000 		sts bankStates+46,__zero_reg__
2247:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
 4564               		.loc 1 2247 0
 4565 216e 81E8      		ldi r24,lo8(-127)
 4566 2170 90E0      		ldi r25,0
 4567 2172 0E94 0000 		call BlinkLeds
 4568               	.LVL151:
2248:WTPA.c        **** 		subState=SS_1;
 4569               		.loc 1 2248 0
 4570 2176 81E0      		ldi r24,lo8(1)
 4571 2178 00C0      		rjmp .L277
 4572               	.L261:
2250:WTPA.c        **** 	else if(subState==SS_1)
 4573               		.loc 1 2250 0
 4574 217a 8130      		cpi r24,lo8(1)
 4575 217c 01F4      		brne .L263
2252:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4576               		.loc 1 2252 0
 4577 217e 8091 0000 		lds r24,keyState
 4578 2182 80FF      		sbrs r24,0
 4579 2184 00C0      		rjmp .L264
2252:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4580               		.loc 1 2252 0 is_stmt 0 discriminator 1
 4581 2186 87FF      		sbrs r24,7
 4582 2188 00C0      		rjmp .L264
2254:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
 4583               		.loc 1 2254 0 is_stmt 1
 4584 218a 86E0      		ldi r24,lo8(6)
 4585 218c 8093 0000 		sts cardState,r24
2255:WTPA.c        **** 			KillLeds();
 4586               		.loc 1 2255 0
 4587 2190 0E94 0000 		call KillLeds
 4588               	.LVL152:
2256:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
 4589               		.loc 1 2256 0
 4590 2194 8091 0000 		lds r24,ledOnOffMask
 4591 2198 8168      		ori r24,lo8(-127)
 4592 219a 8093 0000 		sts ledOnOffMask,r24
2257:WTPA.c        **** 			subState=SS_2;
 4593               		.loc 1 2257 0
 4594 219e 82E0      		ldi r24,lo8(2)
 4595               	.L277:
 4596 21a0 8093 0000 		sts subState,r24
 4597 21a4 0895      		ret
 4598               	.L264:
2259:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
 4599               		.loc 1 2259 0
 4600 21a6 8091 0000 		lds r24,cardState
 4601 21aa 8111      		cpse r24,__zero_reg__
 4602 21ac 00C0      		rjmp .L260
 4603               	.LVL153:
 4604 21ae 00C0      		rjmp .L267
 4605               	.LVL154:
 4606               	.L263:
2264:WTPA.c        **** 	else if(subState==SS_2)
 4607               		.loc 1 2264 0
 4608 21b0 8230      		cpi r24,lo8(2)
 4609 21b2 01F4      		brne .L260
2266:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
 4610               		.loc 1 2266 0
 4611 21b4 8091 0000 		lds r24,cardState
 4612 21b8 8E30      		cpi r24,lo8(14)
 4613 21ba 01F4      		brne .L260
 4614               	.LBB86:
 4615               	.LBB87:
2268:WTPA.c        **** 			KillLeds();
 4616               		.loc 1 2268 0
 4617 21bc 0E94 0000 		call KillLeds
 4618               	.LVL155:
2269:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
 4619               		.loc 1 2269 0
 4620 21c0 8091 0000 		lds r24,ledOnOffMask
 4621 21c4 8260      		ori r24,lo8(2)
 4622 21c6 8093 0000 		sts ledOnOffMask,r24
2270:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
 4623               		.loc 1 2270 0
 4624 21ca 8091 0000 		lds r24,cardState
 4625 21ce 8823      		tst r24
 4626 21d0 01F0      		breq .L267
 4627 21d2 8091 0000 		lds r24,newKeys
 4628 21d6 8823      		tst r24
 4629 21d8 01F0      		breq .L260
 4630               	.L267:
 4631               	.LVL156:
 4632               	.LBB88:
 4633               	.LBB89:
1429:WTPA.c        **** 	State=newState;
 4634               		.loc 1 1429 0
 4635 21da 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 4636 21dc 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 4637 21de 9093 0000 		sts State+1,r25
 4638 21e2 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 4639               		.loc 1 1430 0
 4640 21e6 1092 0000 		sts subState,__zero_reg__
 4641               	.LVL157:
 4642               	.L260:
 4643 21ea 0895      		ret
 4644               	.LBE89:
 4645               	.LBE88:
 4646               	.LBE87:
 4647               	.LBE86:
 4648               		.cfi_endproc
 4649               	.LFE40:
 4652               	DoStartupSelect:
 4653               	.LFB74:
4761:WTPA.c        **** {
 4654               		.loc 1 4761 0
 4655               		.cfi_startproc
 4656               	/* prologue: function */
 4657               	/* frame size = 0 */
 4658               	/* stack size = 0 */
 4659               	.L__stack_usage = 0
4762:WTPA.c        **** 	if(subState==SS_0)
 4660               		.loc 1 4762 0
 4661 21ec 8091 0000 		lds r24,subState
 4662 21f0 8111      		cpse r24,__zero_reg__
 4663 21f2 00C0      		rjmp .L279
4764:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
 4664               		.loc 1 4764 0
 4665 21f4 68E9      		ldi r22,lo8(-104)
 4666 21f6 70E0      		ldi r23,0
 4667 21f8 0E94 0000 		call SetTimer
 4668               	.LVL158:
4765:WTPA.c        **** 		subState=SS_1;
 4669               		.loc 1 4765 0
 4670 21fc 81E0      		ldi r24,lo8(1)
 4671 21fe 8093 0000 		sts subState,r24
 4672 2202 0895      		ret
 4673               	.L279:
4769:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4674               		.loc 1 4769 0
 4675 2204 80E0      		ldi r24,0
 4676 2206 0E94 0000 		call CheckTimer
 4677               	.LVL159:
 4678 220a 8823      		tst r24
 4679 220c 01F0      		breq .L278
 4680               	.LBB98:
 4681               	.LBB99:
4771:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
 4682               		.loc 1 4771 0
 4683 220e 8091 0000 		lds r24,keyState
 4684 2212 80FF      		sbrs r24,0
 4685 2214 00C0      		rjmp .L281
 4686               	.LVL160:
 4687               	.LBB100:
 4688               	.LBB101:
1429:WTPA.c        **** 	State=newState;
 4689               		.loc 1 1429 0
 4690 2216 80E0      		ldi r24,lo8(gs(DoSawtooth))
 4691 2218 90E0      		ldi r25,hi8(gs(DoSawtooth))
 4692 221a 00C0      		rjmp .L286
 4693               	.LVL161:
 4694               	.L281:
 4695               	.LBE101:
 4696               	.LBE100:
4775:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
 4697               		.loc 1 4775 0
 4698 221c 85FF      		sbrs r24,5
 4699 221e 00C0      		rjmp .L282
 4700               	.LVL162:
 4701               	.LBB102:
 4702               	.LBB103:
1429:WTPA.c        **** 	State=newState;
 4703               		.loc 1 1429 0
 4704 2220 80E0      		ldi r24,lo8(gs(SetMidiChannels))
 4705 2222 90E0      		ldi r25,hi8(gs(SetMidiChannels))
 4706 2224 00C0      		rjmp .L286
 4707               	.LVL163:
 4708               	.L282:
 4709               	.LBE103:
 4710               	.LBE102:
 4711               	.LBB104:
 4712               	.LBB105:
 4713 2226 80E0      		ldi r24,lo8(gs(InitSampler))
 4714 2228 90E0      		ldi r25,hi8(gs(InitSampler))
 4715               	.LVL164:
 4716               	.L286:
 4717 222a 9093 0000 		sts State+1,r25
 4718 222e 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 4719               		.loc 1 1430 0
 4720 2232 1092 0000 		sts subState,__zero_reg__
 4721               	.L278:
 4722 2236 0895      		ret
 4723               	.LBE105:
 4724               	.LBE104:
 4725               	.LBE99:
 4726               	.LBE98:
 4727               		.cfi_endproc
 4728               	.LFE74:
 4731               	PlaySampleFromSd:
 4732               	.LFB52:
3162:WTPA.c        **** {
 4733               		.loc 1 3162 0
 4734               		.cfi_startproc
 4735               	.LVL165:
 4736 2238 CF93      		push r28
 4737               	.LCFI56:
 4738               		.cfi_def_cfa_offset 3
 4739               		.cfi_offset 28, -2
 4740               	/* prologue: function */
 4741               	/* frame size = 0 */
 4742               	/* stack size = 1 */
 4743               	.L__stack_usage = 1
3166:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 4744               		.loc 1 3166 0
 4745 223a 2091 0000 		lds r18,cardState
 4746 223e 2E30      		cpi r18,lo8(14)
 4747 2240 01F4      		brne .L288
 4748 2242 00C0      		rjmp .L296
 4749               	.L288:
3177:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
 4750               		.loc 1 3177 0
 4751 2244 3091 0000 		lds r19,sdIsrState
 4752 2248 3330      		cpi r19,lo8(3)
 4753 224a 01F4      		brne .L287
3180:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
 4754               		.loc 1 3180 0
 4755 224c 2B30      		cpi r18,lo8(11)
 4756 224e 01F4      		brne .L290
 4757               	.L296:
 4758               	.LVL166:
 4759               	.LBB108:
 4760               	.LBB109:
3182:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
 4761               		.loc 1 3182 0
 4762 2250 CFB7      		in r28,__SREG__
 4763               	.LVL167:
3183:WTPA.c        **** 			cli();
 4764               		.loc 1 3183 0
 4765               	/* #APP */
 4766               	 ;  3183 "WTPA.c" 1
 4767 2252 F894      		cli
 4768               	 ;  0 "" 2
3185:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
 4769               		.loc 1 3185 0
 4770               	/* #NOAPP */
 4771 2254 0E94 0000 		call SdStartSampleRead
 4772               	.LVL168:
3186:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
 4773               		.loc 1 3186 0
 4774 2258 81E0      		ldi r24,lo8(1)
 4775 225a 90E0      		ldi r25,0
 4776 225c A0E0      		ldi r26,0
 4777 225e B0E0      		ldi r27,0
 4778 2260 8093 0000 		sts sdRamSampleRemaining,r24
 4779 2264 9093 0000 		sts sdRamSampleRemaining+1,r25
 4780 2268 A093 0000 		sts sdRamSampleRemaining+2,r26
 4781 226c B093 0000 		sts sdRamSampleRemaining+3,r27
3187:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
 4782               		.loc 1 3187 0
 4783 2270 0E94 0000 		call SdIsrStartStreamingAudio
 4784               	.LVL169:
3189:WTPA.c        **** 			SREG=sreg;	// resume isr
 4785               		.loc 1 3189 0
 4786 2274 CFBF      		out __SREG__,r28
 4787 2276 00C0      		rjmp .L287
 4788               	.LVL170:
 4789               	.L290:
 4790               	.LBE109:
 4791               	.LBE108:
3191:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4792               		.loc 1 3191 0
 4793 2278 2D30      		cpi r18,lo8(13)
 4794 227a 01F0      		breq .L291
3191:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4795               		.loc 1 3191 0 is_stmt 0 discriminator 1
 4796 227c 2091 0000 		lds r18,sdAbortRead
 4797 2280 2130      		cpi r18,lo8(1)
 4798 2282 01F4      		brne .L292
 4799               	.L291:
3194:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4800               		.loc 1 3194 0 is_stmt 1
 4801 2284 9093 0000 		sts sdQueuedSlot+1,r25
 4802 2288 8093 0000 		sts sdQueuedSlot,r24
 4803 228c 00C0      		rjmp .L287
 4804               	.L292:
3199:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4805               		.loc 1 3199 0
 4806 228e 9093 0000 		sts sdQueuedSlot+1,r25
 4807 2292 8093 0000 		sts sdQueuedSlot,r24
3200:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
 4808               		.loc 1 3200 0
 4809 2296 81E0      		ldi r24,lo8(1)
 4810               	.LVL171:
 4811 2298 8093 0000 		sts sdPlaybackQueued,r24
3201:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
 4812               		.loc 1 3201 0
 4813 229c 8093 0000 		sts sdAbortRead,r24
3203:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
 4814               		.loc 1 3203 0
 4815 22a0 9FB7      		in r25,__SREG__
 4816               	.LVL172:
3204:WTPA.c        **** 			cli();
 4817               		.loc 1 3204 0
 4818               	/* #APP */
 4819               	 ;  3204 "WTPA.c" 1
 4820 22a2 F894      		cli
 4821               	 ;  0 "" 2
3205:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
 4822               		.loc 1 3205 0
 4823               	/* #NOAPP */
 4824 22a4 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 4825 22a8 1092 0000 		sts sdBytesInFifo,__zero_reg__
3206:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
 4826               		.loc 1 3206 0
 4827 22ac 8091 7000 		lds r24,112
 4828 22b0 8B7F      		andi r24,lo8(-5)
 4829 22b2 8093 7000 		sts 112,r24
3207:WTPA.c        **** 			SREG=sreg;
 4830               		.loc 1 3207 0
 4831 22b6 9FBF      		out __SREG__,r25
 4832               	.LVL173:
 4833               	.L287:
 4834               	/* epilogue start */
3210:WTPA.c        **** }
 4835               		.loc 1 3210 0
 4836 22b8 CF91      		pop r28
 4837 22ba 0895      		ret
 4838               		.cfi_endproc
 4839               	.LFE52:
 4842               	SdCardMenu:
 4843               	.LFB68:
3939:WTPA.c        **** {
 4844               		.loc 1 3939 0
 4845               		.cfi_startproc
 4846 22bc EF92      		push r14
 4847               	.LCFI57:
 4848               		.cfi_def_cfa_offset 3
 4849               		.cfi_offset 14, -2
 4850 22be FF92      		push r15
 4851               	.LCFI58:
 4852               		.cfi_def_cfa_offset 4
 4853               		.cfi_offset 15, -3
 4854 22c0 0F93      		push r16
 4855               	.LCFI59:
 4856               		.cfi_def_cfa_offset 5
 4857               		.cfi_offset 16, -4
 4858 22c2 1F93      		push r17
 4859               	.LCFI60:
 4860               		.cfi_def_cfa_offset 6
 4861               		.cfi_offset 17, -5
 4862 22c4 CF93      		push r28
 4863               	.LCFI61:
 4864               		.cfi_def_cfa_offset 7
 4865               		.cfi_offset 28, -6
 4866 22c6 DF93      		push r29
 4867               	.LCFI62:
 4868               		.cfi_def_cfa_offset 8
 4869               		.cfi_offset 29, -7
 4870               	/* prologue: function */
 4871               	/* frame size = 0 */
 4872               	/* stack size = 6 */
 4873               	.L__stack_usage = 6
3940:WTPA.c        **** 	if(subState==SS_0)		// Initialize LEDs and slots
 4874               		.loc 1 3940 0
 4875 22c8 8091 0000 		lds r24,subState
 4876 22cc 8111      		cpse r24,__zero_reg__
 4877 22ce 00C0      		rjmp .L298
3942:WTPA.c        **** 		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
 4878               		.loc 1 3942 0
 4879 22d0 8091 0000 		lds r24,sdCurrentSlot
 4880 22d4 9091 0000 		lds r25,sdCurrentSlot+1
 4881 22d8 8038      		cpi r24,-128
 4882 22da 9105      		cpc r25,__zero_reg__
 4883 22dc 00F0      		brlo .L299
3944:WTPA.c        **** 			sdCurrentSlot=127;
 4884               		.loc 1 3944 0
 4885 22de 8FE7      		ldi r24,lo8(127)
 4886 22e0 90E0      		ldi r25,0
 4887 22e2 9093 0000 		sts sdCurrentSlot+1,r25
 4888 22e6 8093 0000 		sts sdCurrentSlot,r24
 4889               	.L299:
3947:WTPA.c        **** 		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently lookin
 4890               		.loc 1 3947 0
 4891 22ea 8091 0000 		lds r24,sdCurrentSlot
 4892 22ee 8093 0000 		sts ledOnOffMask,r24
3948:WTPA.c        **** 		StopBlinking();					// Make sure nothing is errantly blinking
 4893               		.loc 1 3948 0
 4894 22f2 0E94 0000 		call StopBlinking
 4895               	.LVL174:
3950:WTPA.c        **** 		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
 4896               		.loc 1 3950 0
 4897 22f6 8091 0000 		lds r24,sdCurrentSlot
 4898 22fa 9091 0000 		lds r25,sdCurrentSlot+1
 4899 22fe 0E94 0000 		call CheckSdSlotFull
 4900               	.LVL175:
 4901 2302 8823      		tst r24
 4902 2304 01F0      		breq .L300
3952:WTPA.c        **** 			BlinkLeds(1<<LED_7);
 4903               		.loc 1 3952 0
 4904 2306 80E8      		ldi r24,lo8(-128)
 4905 2308 90E0      		ldi r25,0
 4906 230a 0E94 0000 		call BlinkLeds
 4907               	.LVL176:
 4908               	.L300:
3955:WTPA.c        **** 		subState=SS_1;
 4909               		.loc 1 3955 0
 4910 230e 81E0      		ldi r24,lo8(1)
 4911 2310 8093 0000 		sts subState,r24
 4912 2314 00C0      		rjmp .L297
 4913               	.L298:
3959:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
 4914               		.loc 1 3959 0
 4915 2316 9091 0000 		lds r25,cardDetect
 4916 231a 8091 0000 		lds r24,cardState
 4917 231e 9923      		tst r25
 4918 2320 01F0      		breq .L302
3959:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
 4919               		.loc 1 3959 0 is_stmt 0 discriminator 1
 4920 2322 8F30      		cpi r24,lo8(15)
 4921 2324 01F4      		brne .L303
 4922 2326 00C0      		rjmp .L363
 4923               	.L302:
3961:WTPA.c        **** 			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 4924               		.loc 1 3961 0 is_stmt 1
 4925 2328 8823      		tst r24
 4926 232a 01F4      		brne .+2
 4927 232c 00C0      		rjmp .L327
 4928               	.L363:
3963:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
 4929               		.loc 1 3963 0
 4930 232e 0E94 0000 		call ResetSdCard
 4931               	.LVL177:
 4932 2332 00C0      		rjmp .L327
 4933               	.L303:
 4934               	.LBB132:
 4935               	.LBB133:
3971:WTPA.c        **** 			if(newEncoder)		// Increment or decrement card slot if encoder moves
 4936               		.loc 1 3971 0
 4937 2334 8091 0000 		lds r24,newEncoder
 4938 2338 8823      		tst r24
 4939 233a 01F0      		breq .L305
3973:WTPA.c        **** 				if(encoderCw)
 4940               		.loc 1 3973 0
 4941 233c 8091 0000 		lds r24,encoderCw
 4942 2340 8823      		tst r24
 4943 2342 01F0      		breq .L306
3975:WTPA.c        **** 					sdCurrentSlot++;
 4944               		.loc 1 3975 0
 4945 2344 8091 0000 		lds r24,sdCurrentSlot
 4946 2348 9091 0000 		lds r25,sdCurrentSlot+1
 4947 234c 0196      		adiw r24,1
 4948 234e 9093 0000 		sts sdCurrentSlot+1,r25
 4949 2352 8093 0000 		sts sdCurrentSlot,r24
3976:WTPA.c        **** 					if(sdCurrentSlot>127)
 4950               		.loc 1 3976 0
 4951 2356 8038      		cpi r24,-128
 4952 2358 9105      		cpc r25,__zero_reg__
 4953 235a 00F0      		brlo .L308
3978:WTPA.c        **** 						sdCurrentSlot=0;
 4954               		.loc 1 3978 0
 4955 235c 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 4956 2360 1092 0000 		sts sdCurrentSlot,__zero_reg__
 4957 2364 00C0      		rjmp .L308
 4958               	.L306:
3981:WTPA.c        **** 				else if(encoderCcw)
 4959               		.loc 1 3981 0
 4960 2366 8091 0000 		lds r24,encoderCcw
 4961 236a 8823      		tst r24
 4962 236c 01F0      		breq .L308
3983:WTPA.c        **** 					if(sdCurrentSlot==0)
 4963               		.loc 1 3983 0
 4964 236e 8091 0000 		lds r24,sdCurrentSlot
 4965 2372 9091 0000 		lds r25,sdCurrentSlot+1
 4966 2376 0097      		sbiw r24,0
 4967 2378 01F4      		brne .L310
3985:WTPA.c        **** 						sdCurrentSlot=127;
 4968               		.loc 1 3985 0
 4969 237a 8FE7      		ldi r24,lo8(127)
 4970 237c 90E0      		ldi r25,0
 4971 237e 00C0      		rjmp .L364
 4972               	.L310:
3989:WTPA.c        **** 						sdCurrentSlot--;
 4973               		.loc 1 3989 0
 4974 2380 0197      		sbiw r24,1
 4975               	.L364:
 4976 2382 9093 0000 		sts sdCurrentSlot+1,r25
 4977 2386 8093 0000 		sts sdCurrentSlot,r24
 4978               	.L308:
3993:WTPA.c        **** 				ledOnOffMask=sdCurrentSlot;		
 4979               		.loc 1 3993 0
 4980 238a 8091 0000 		lds r24,sdCurrentSlot
 4981 238e 9091 0000 		lds r25,sdCurrentSlot+1
 4982 2392 8093 0000 		sts ledOnOffMask,r24
3994:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
 4983               		.loc 1 3994 0
 4984 2396 0E94 0000 		call CheckSdSlotFull
 4985               	.LVL178:
 4986 239a 8823      		tst r24
 4987 239c 01F0      		breq .L311
3996:WTPA.c        **** 					BlinkLeds(1<<LED_7);
 4988               		.loc 1 3996 0
 4989 239e 80E8      		ldi r24,lo8(-128)
 4990 23a0 90E0      		ldi r25,0
 4991 23a2 0E94 0000 		call BlinkLeds
 4992               	.LVL179:
 4993 23a6 00C0      		rjmp .L305
 4994               	.L311:
4000:WTPA.c        **** 					StopBlinking();
 4995               		.loc 1 4000 0
 4996 23a8 0E94 0000 		call StopBlinking
 4997               	.LVL180:
4001:WTPA.c        **** 					ledOnOffMask&=~(1<<LED_7);
 4998               		.loc 1 4001 0
 4999 23ac 8091 0000 		lds r24,ledOnOffMask
 5000 23b0 8F77      		andi r24,lo8(127)
 5001 23b2 8093 0000 		sts ledOnOffMask,r24
 5002               	.L305:
 5003               	.LBE133:
4005:WTPA.c        **** 			if(newKeys&Im_SWITCH_0)		// Stream sample
 5004               		.loc 1 4005 0
 5005 23b6 8091 0000 		lds r24,newKeys
 5006               	.LBB152:
 5007 23ba 80FF      		sbrs r24,0
 5008 23bc 00C0      		rjmp .L312
4007:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 5009               		.loc 1 4007 0
 5010 23be C091 0000 		lds r28,sdCurrentSlot
 5011 23c2 D091 0000 		lds r29,sdCurrentSlot+1
 5012 23c6 CE01      		movw r24,r28
 5013 23c8 0E94 0000 		call CheckSdSlotFull
 5014               	.LVL181:
 5015 23cc 8823      		tst r24
 5016 23ce 01F0      		breq .L312
4009:WTPA.c        **** 					PlaySampleFromSd(sdCurrentSlot);
 5017               		.loc 1 4009 0
 5018 23d0 CE01      		movw r24,r28
 5019 23d2 0E94 0000 		call PlaySampleFromSd
 5020               	.LVL182:
 5021               	.L312:
 5022               	.LBE152:
4012:WTPA.c        **** 			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
 5023               		.loc 1 4012 0
 5024 23d6 8091 0000 		lds r24,newKeys
 5025               	.LBB153:
 5026 23da 81FF      		sbrs r24,1
 5027 23dc 00C0      		rjmp .L313
4014:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 5028               		.loc 1 4014 0
 5029 23de 0091 0000 		lds r16,sdCurrentSlot
 5030 23e2 1091 0000 		lds r17,sdCurrentSlot+1
 5031 23e6 C801      		movw r24,r16
 5032 23e8 0E94 0000 		call CheckSdSlotFull
 5033               	.LVL183:
 5034 23ec 8823      		tst r24
 5035 23ee 01F4      		brne .+2
 5036 23f0 00C0      		rjmp .L313
4016:WTPA.c        **** 					ReadSampleFromSd(currentBank,sdCurrentSlot);
 5037               		.loc 1 4016 0
 5038 23f2 F090 0000 		lds r15,currentBank
 5039               	.LVL184:
 5040               	.LBB134:
 5041               	.LBB135:
3144:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5042               		.loc 1 3144 0
 5043 23f6 8091 0000 		lds r24,cardState
 5044 23fa 8E30      		cpi r24,lo8(14)
 5045 23fc 01F0      		breq .+2
 5046 23fe 00C0      		rjmp .L313
3146:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5047               		.loc 1 3146 0
 5048 2400 24E2      		ldi r18,lo8(36)
 5049 2402 F29E      		mul r15,r18
 5050 2404 E001      		movw r28,r0
 5051 2406 1124      		clr __zero_reg__
 5052 2408 C050      		subi r28,lo8(-(bankStates))
 5053 240a D040      		sbci r29,hi8(-(bankStates))
 5054 240c 8D81      		ldd r24,Y+5
 5055 240e 8111      		cpse r24,__zero_reg__
 5056 2410 00C0      		rjmp .L313
3148:WTPA.c        **** 			sreg=SREG;
 5057               		.loc 1 3148 0
 5058 2412 EFB6      		in r14,__SREG__
 5059               	.LVL185:
3149:WTPA.c        **** 			cli();		// Pause ISR
 5060               		.loc 1 3149 0
 5061               	/* #APP */
 5062               	 ;  3149 "WTPA.c" 1
 5063 2414 F894      		cli
 5064               	 ;  0 "" 2
3151:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
 5065               		.loc 1 3151 0
 5066               	/* #NOAPP */
 5067 2416 C801      		movw r24,r16
 5068 2418 0E94 0000 		call SdStartSampleRead
 5069               	.LVL186:
3152:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
 5070               		.loc 1 3152 0
 5071 241c 81E0      		ldi r24,lo8(1)
 5072 241e 90E0      		ldi r25,0
 5073 2420 A0E0      		ldi r26,0
 5074 2422 B0E0      		ldi r27,0
 5075 2424 8093 0000 		sts sdRamSampleRemaining,r24
 5076 2428 9093 0000 		sts sdRamSampleRemaining+1,r25
 5077 242c A093 0000 		sts sdRamSampleRemaining+2,r26
 5078 2430 B093 0000 		sts sdRamSampleRemaining+3,r27
 5079               	.LVL187:
 5080               	.LBB136:
 5081               	.LBB137:
3028:WTPA.c        **** 	sreg=SREG;
 5082               		.loc 1 3028 0
 5083 2434 2FB7      		in r18,__SREG__
 5084               	.LVL188:
3029:WTPA.c        **** 	cli();		// Pause ISRs
 5085               		.loc 1 3029 0
 5086               	/* #APP */
 5087               	 ;  3029 "WTPA.c" 1
 5088 2436 F894      		cli
 5089               	 ;  0 "" 2
3031:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
 5090               		.loc 1 3031 0
 5091               	/* #NOAPP */
 5092 2438 81E0      		ldi r24,lo8(1)
 5093 243a 8093 0000 		sts sdIsrState,r24
3032:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5094               		.loc 1 3032 0
 5095 243e 8D83      		std Y+5,r24
3034:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5096               		.loc 1 3034 0
 5097 2440 F110      		cpse r15,__zero_reg__
 5098 2442 00C0      		rjmp .L314
3036:WTPA.c        **** 		sdBank0=true;
 5099               		.loc 1 3036 0
 5100 2444 8093 0000 		sts sdBank0,r24
3037:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5101               		.loc 1 3037 0
 5102 2448 1092 0000 		sts sdRamAddress,__zero_reg__
 5103 244c 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5104 2450 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5105 2454 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5106 2458 00C0      		rjmp .L315
 5107               	.L314:
3041:WTPA.c        **** 		sdBank0=false;
 5108               		.loc 1 3041 0
 5109 245a 1092 0000 		sts sdBank0,__zero_reg__
3042:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5110               		.loc 1 3042 0
 5111 245e 8FEF      		ldi r24,lo8(-1)
 5112 2460 9FEF      		ldi r25,lo8(-1)
 5113 2462 A7E0      		ldi r26,lo8(7)
 5114 2464 B0E0      		ldi r27,0
 5115 2466 8093 0000 		sts sdRamAddress,r24
 5116 246a 9093 0000 		sts sdRamAddress+1,r25
 5117 246e A093 0000 		sts sdRamAddress+2,r26
 5118 2472 B093 0000 		sts sdRamAddress+3,r27
 5119               	.L315:
3045:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5120               		.loc 1 3045 0
 5121 2476 1092 B200 		sts 178,__zero_reg__
3046:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5122               		.loc 1 3046 0
 5123 247a 81E6      		ldi r24,lo8(97)
 5124 247c 8093 B300 		sts 179,r24
3047:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5125               		.loc 1 3047 0
 5126 2480 8FEF      		ldi r24,lo8(-1)
 5127 2482 87BB      		out 0x17,r24
3048:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5128               		.loc 1 3048 0
 5129 2484 8091 7000 		lds r24,112
 5130 2488 8460      		ori r24,lo8(4)
 5131 248a 8093 7000 		sts 112,r24
3049:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5132               		.loc 1 3049 0
 5133 248e 82E0      		ldi r24,lo8(2)
 5134 2490 8093 B100 		sts 177,r24
3051:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5135               		.loc 1 3051 0
 5136 2494 2FBF      		out __SREG__,r18
 5137               	.LBE137:
 5138               	.LBE136:
3155:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5139               		.loc 1 3155 0
 5140 2496 EFBE      		out __SREG__,r14
 5141               	.LVL189:
 5142               	.L313:
 5143               	.LBE135:
 5144               	.LBE134:
 5145               	.LBE153:
4019:WTPA.c        **** 			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
 5146               		.loc 1 4019 0
 5147 2498 8091 0000 		lds r24,newKeys
 5148               	.LBB154:
 5149 249c 82FF      		sbrs r24,2
 5150 249e 00C0      		rjmp .L316
4021:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 5151               		.loc 1 4021 0
 5152 24a0 E091 0000 		lds r30,currentBank
 5153 24a4 2E2F      		mov r18,r30
 5154 24a6 30E0      		ldi r19,0
 5155 24a8 44E2      		ldi r20,lo8(36)
 5156 24aa E49F      		mul r30,r20
 5157 24ac E001      		movw r28,r0
 5158 24ae 1124      		clr __zero_reg__
 5159 24b0 C050      		subi r28,lo8(-(bankStates))
 5160 24b2 D040      		sbci r29,hi8(-(bankStates))
 5161 24b4 4989      		ldd r20,Y+17
 5162 24b6 5A89      		ldd r21,Y+18
 5163 24b8 6B89      		ldd r22,Y+19
 5164 24ba 7C89      		ldd r23,Y+20
 5165 24bc 8D85      		ldd r24,Y+13
 5166 24be 9E85      		ldd r25,Y+14
 5167 24c0 AF85      		ldd r26,Y+15
 5168 24c2 B889      		ldd r27,Y+16
 5169 24c4 4817      		cp r20,r24
 5170 24c6 5907      		cpc r21,r25
 5171 24c8 6A07      		cpc r22,r26
 5172 24ca 7B07      		cpc r23,r27
 5173 24cc 01F4      		brne .+2
 5174 24ce 00C0      		rjmp .L316
4023:WTPA.c        **** 					WriteSampleToSd(currentBank,sdCurrentSlot);
 5175               		.loc 1 4023 0
 5176 24d0 1091 0000 		lds r17,sdCurrentSlot
 5177 24d4 0091 0000 		lds r16,sdCurrentSlot+1
 5178               	.LVL190:
 5179               	.LBB138:
 5180               	.LBB139:
3121:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5181               		.loc 1 3121 0
 5182 24d8 8091 0000 		lds r24,cardState
 5183 24dc 8E30      		cpi r24,lo8(14)
 5184 24de 01F0      		breq .+2
 5185 24e0 00C0      		rjmp .L317
3123:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5186               		.loc 1 3123 0
 5187 24e2 8D81      		ldd r24,Y+5
 5188 24e4 8111      		cpse r24,__zero_reg__
 5189 24e6 00C0      		rjmp .L317
 5190               	.LVL191:
 5191               	.LBB140:
 5192               	.LBB141:
3083:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5193               		.loc 1 3083 0
 5194 24e8 8F81      		ldd r24,Y+7
3081:WTPA.c        **** 	if(theBank==BANK_0)
 5195               		.loc 1 3081 0
 5196 24ea E111      		cpse r30,__zero_reg__
 5197 24ec 00C0      		rjmp .L318
3083:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5198               		.loc 1 3083 0
 5199 24ee 8111      		cpse r24,__zero_reg__
 5200 24f0 00C0      		rjmp .L319
3085:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
 5201               		.loc 1 3085 0
 5202 24f2 8D89      		ldd r24,Y+21
 5203 24f4 9E89      		ldd r25,Y+22
 5204 24f6 AF89      		ldd r26,Y+23
 5205 24f8 B88D      		ldd r27,Y+24
 5206 24fa 498D      		ldd r20,Y+25
 5207 24fc 5A8D      		ldd r21,Y+26
 5208 24fe 6B8D      		ldd r22,Y+27
 5209 2500 7C8D      		ldd r23,Y+28
 5210 2502 00C0      		rjmp .L367
 5211               	.L319:
3089:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
 5212               		.loc 1 3089 0
 5213 2504 8D85      		ldd r24,Y+13
 5214 2506 9E85      		ldd r25,Y+14
 5215 2508 AF85      		ldd r26,Y+15
 5216 250a B889      		ldd r27,Y+16
 5217               	.LVL192:
 5218 250c 00C0      		rjmp .L320
 5219               	.LVL193:
 5220               	.L318:
3094:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5221               		.loc 1 3094 0
 5222 250e 8111      		cpse r24,__zero_reg__
 5223 2510 00C0      		rjmp .L321
3096:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
 5224               		.loc 1 3096 0
 5225 2512 898D      		ldd r24,Y+25
 5226 2514 9A8D      		ldd r25,Y+26
 5227 2516 AB8D      		ldd r26,Y+27
 5228 2518 BC8D      		ldd r27,Y+28
 5229 251a 4D89      		ldd r20,Y+21
 5230 251c 5E89      		ldd r21,Y+22
 5231 251e 6F89      		ldd r22,Y+23
 5232 2520 788D      		ldd r23,Y+24
 5233               	.L367:
 5234 2522 0196      		adiw r24,1
 5235 2524 A11D      		adc r26,__zero_reg__
 5236 2526 B11D      		adc r27,__zero_reg__
 5237 2528 00C0      		rjmp .L365
 5238               	.L321:
3100:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
 5239               		.loc 1 3100 0
 5240 252a 8989      		ldd r24,Y+17
 5241 252c 9A89      		ldd r25,Y+18
 5242 252e AB89      		ldd r26,Y+19
 5243 2530 BC89      		ldd r27,Y+20
 5244 2532 4D85      		ldd r20,Y+13
 5245 2534 5E85      		ldd r21,Y+14
 5246 2536 6F85      		ldd r22,Y+15
 5247 2538 7889      		ldd r23,Y+16
 5248               	.L365:
 5249 253a 841B      		sub r24,r20
 5250 253c 950B      		sbc r25,r21
 5251 253e A60B      		sbc r26,r22
 5252 2540 B70B      		sbc r27,r23
 5253               	.LVL194:
 5254               	.L320:
 5255               	.LBE141:
 5256               	.LBE140:
3127:WTPA.c        **** 			sreg=SREG;
 5257               		.loc 1 3127 0
 5258 2542 FFB7      		in r31,__SREG__
 5259               	.LVL195:
3128:WTPA.c        **** 			cli();		// Pause ISR
 5260               		.loc 1 3128 0
 5261               	/* #APP */
 5262               	 ;  3128 "WTPA.c" 1
 5263 2544 F894      		cli
 5264               	 ;  0 "" 2
 5265               	.LVL196:
 5266               	/* #NOAPP */
 5267               	.LBB142:
 5268               	.LBB143:
2317:WTPA.c        **** 	sreg=SREG;
 5269               		.loc 1 2317 0
 5270 2546 CFB7      		in r28,__SREG__
 5271               	.LVL197:
2318:WTPA.c        **** 	cli();		// Pause ISR
 5272               		.loc 1 2318 0
 5273               	/* #APP */
 5274               	 ;  2318 "WTPA.c" 1
 5275 2548 F894      		cli
 5276               	 ;  0 "" 2
2320:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
 5277               		.loc 1 2320 0
 5278               	/* #NOAPP */
 5279 254a 1093 0000 		sts sdCurrentSlot,r17
 5280 254e 0093 0000 		sts sdCurrentSlot+1,r16
2321:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
 5281               		.loc 1 2321 0
 5282 2552 712F      		mov r23,r17
 5283 2554 770F      		lsl r23
 5284 2556 770F      		lsl r23
 5285 2558 60E0      		ldi r22,0
 5286 255a AB01      		movw r20,r22
 5287 255c 4F5F      		subi r20,-1
 5288 255e 5F4F      		sbci r21,-1
 5289 2560 60E0      		ldi r22,0
 5290 2562 70E0      		ldi r23,0
 5291 2564 4093 0000 		sts sdSampleStartBlock,r20
 5292 2568 5093 0000 		sts sdSampleStartBlock+1,r21
 5293 256c 6093 0000 		sts sdSampleStartBlock+2,r22
 5294 2570 7093 0000 		sts sdSampleStartBlock+3,r23
2322:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
 5295               		.loc 1 2322 0
 5296 2574 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 5297 2578 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2324:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 5298               		.loc 1 2324 0
 5299 257c 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 5300 2580 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2325:WTPA.c        **** 	sdFifoWritePointer=0;
 5301               		.loc 1 2325 0
 5302 2584 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 5303 2588 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2326:WTPA.c        **** 	sdBytesInFifo=0;
 5304               		.loc 1 2326 0
 5305 258c 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 5306 2590 1092 0000 		sts sdBytesInFifo,__zero_reg__
2328:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
 5307               		.loc 1 2328 0
 5308 2594 8D3F      		cpi r24,-3
 5309 2596 4FEF      		ldi r20,-1
 5310 2598 9407      		cpc r25,r20
 5311 259a 47E0      		ldi r20,7
 5312 259c A407      		cpc r26,r20
 5313 259e B105      		cpc r27,__zero_reg__
 5314 25a0 00F4      		brsh .L322
 5315 25a2 00C0      		rjmp .L366
 5316               	.L322:
2334:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
 5317               		.loc 1 2334 0
 5318 25a4 8CEF      		ldi r24,lo8(-4)
 5319 25a6 9FEF      		ldi r25,lo8(-1)
 5320 25a8 A7E0      		ldi r26,lo8(7)
 5321 25aa B0E0      		ldi r27,0
 5322               	.LVL198:
 5323               	.L366:
 5324 25ac 8093 0000 		sts sdRamSampleRemaining,r24
 5325 25b0 9093 0000 		sts sdRamSampleRemaining+1,r25
 5326 25b4 A093 0000 		sts sdRamSampleRemaining+2,r26
 5327 25b8 B093 0000 		sts sdRamSampleRemaining+3,r27
2337:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
 5328               		.loc 1 2337 0
 5329 25bc 8091 0000 		lds r24,sdRamSampleRemaining
 5330 25c0 9091 0000 		lds r25,sdRamSampleRemaining+1
 5331 25c4 A091 0000 		lds r26,sdRamSampleRemaining+2
 5332 25c8 B091 0000 		lds r27,sdRamSampleRemaining+3
 5333 25cc 8093 0000 		sts sdCardSampleRemaining,r24
 5334 25d0 9093 0000 		sts sdCardSampleRemaining+1,r25
 5335 25d4 A093 0000 		sts sdCardSampleRemaining+2,r26
 5336 25d8 B093 0000 		sts sdCardSampleRemaining+3,r27
2338:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
 5337               		.loc 1 2338 0
 5338 25dc 82E0      		ldi r24,lo8(2)
 5339 25de 8093 0000 		sts cardState,r24
2339:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 5340               		.loc 1 2339 0
 5341 25e2 CFBF      		out __SREG__,r28
 5342               	.LVL199:
 5343               	.LBE143:
 5344               	.LBE142:
 5345               	.LBB144:
 5346               	.LBB145:
2995:WTPA.c        **** 	sreg=SREG;
 5347               		.loc 1 2995 0
 5348 25e4 4FB7      		in r20,__SREG__
 5349               	.LVL200:
2996:WTPA.c        **** 	cli();		// Pause ISRs
 5350               		.loc 1 2996 0
 5351               	/* #APP */
 5352               	 ;  2996 "WTPA.c" 1
 5353 25e6 F894      		cli
 5354               	 ;  0 "" 2
2998:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
 5355               		.loc 1 2998 0
 5356               	/* #NOAPP */
 5357 25e8 8093 0000 		sts sdIsrState,r24
2999:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5358               		.loc 1 2999 0
 5359 25ec 84E2      		ldi r24,lo8(36)
 5360 25ee 829F      		mul r24,r18
 5361 25f0 D001      		movw r26,r0
 5362 25f2 839F      		mul r24,r19
 5363 25f4 B00D      		add r27,r0
 5364 25f6 1124      		clr __zero_reg__
 5365 25f8 A050      		subi r26,lo8(-(bankStates))
 5366 25fa B040      		sbci r27,hi8(-(bankStates))
 5367 25fc 81E0      		ldi r24,lo8(1)
 5368 25fe 1596      		adiw r26,5
 5369 2600 8C93      		st X,r24
3001:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5370               		.loc 1 3001 0
 5371 2602 E111      		cpse r30,__zero_reg__
 5372 2604 00C0      		rjmp .L324
3003:WTPA.c        **** 		sdBank0=true;
 5373               		.loc 1 3003 0
 5374 2606 8093 0000 		sts sdBank0,r24
3004:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5375               		.loc 1 3004 0
 5376 260a 1092 0000 		sts sdRamAddress,__zero_reg__
 5377 260e 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5378 2612 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5379 2616 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5380 261a 00C0      		rjmp .L325
 5381               	.L324:
3008:WTPA.c        **** 		sdBank0=false;
 5382               		.loc 1 3008 0
 5383 261c 1092 0000 		sts sdBank0,__zero_reg__
3009:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5384               		.loc 1 3009 0
 5385 2620 8FEF      		ldi r24,lo8(-1)
 5386 2622 9FEF      		ldi r25,lo8(-1)
 5387 2624 A7E0      		ldi r26,lo8(7)
 5388 2626 B0E0      		ldi r27,0
 5389 2628 8093 0000 		sts sdRamAddress,r24
 5390 262c 9093 0000 		sts sdRamAddress+1,r25
 5391 2630 A093 0000 		sts sdRamAddress+2,r26
 5392 2634 B093 0000 		sts sdRamAddress+3,r27
 5393               	.L325:
3012:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5394               		.loc 1 3012 0
 5395 2638 1092 B200 		sts 178,__zero_reg__
3013:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5396               		.loc 1 3013 0
 5397 263c 81E6      		ldi r24,lo8(97)
 5398 263e 8093 B300 		sts 179,r24
3014:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5399               		.loc 1 3014 0
 5400 2642 8FEF      		ldi r24,lo8(-1)
 5401 2644 87BB      		out 0x17,r24
3015:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5402               		.loc 1 3015 0
 5403 2646 8091 7000 		lds r24,112
 5404 264a 8460      		ori r24,lo8(4)
 5405 264c 8093 7000 		sts 112,r24
3016:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5406               		.loc 1 3016 0
 5407 2650 82E0      		ldi r24,lo8(2)
 5408 2652 8093 B100 		sts 177,r24
3018:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5409               		.loc 1 3018 0
 5410 2656 4FBF      		out __SREG__,r20
 5411               	.LBE145:
 5412               	.LBE144:
3133:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5413               		.loc 1 3133 0
 5414 2658 FFBF      		out __SREG__,r31
 5415               	.LVL201:
 5416               	.L317:
 5417               	.LBE139:
 5418               	.LBE138:
4024:WTPA.c        **** 					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
 5419               		.loc 1 4024 0
 5420 265a 80E8      		ldi r24,lo8(-128)
 5421 265c 90E0      		ldi r25,0
 5422 265e 0E94 0000 		call BlinkLeds
 5423               	.LVL202:
 5424               	.L316:
 5425               	.LBE154:
4027:WTPA.c        **** 			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like 
 5426               		.loc 1 4027 0
 5427 2662 8091 0000 		lds r24,newKeys
 5428               	.LBB155:
 5429 2666 83FF      		sbrs r24,3
 5430 2668 00C0      		rjmp .L326
4029:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 5431               		.loc 1 4029 0
 5432 266a C091 0000 		lds r28,sdCurrentSlot
 5433 266e D091 0000 		lds r29,sdCurrentSlot+1
 5434 2672 CE01      		movw r24,r28
 5435 2674 0E94 0000 		call CheckSdSlotFull
 5436               	.LVL203:
 5437 2678 8823      		tst r24
 5438 267a 01F0      		breq .L326
4031:WTPA.c        **** 					if(cardState==SD_IDLE)	// Got what we wanted?
 5439               		.loc 1 4031 0
 5440 267c 8091 0000 		lds r24,cardState
 5441 2680 8E30      		cpi r24,lo8(14)
 5442 2682 01F4      		brne .L326
 5443               	.LVL204:
 5444               	.LBB146:
 5445               	.LBB147:
2136:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 5446               		.loc 1 2136 0
 5447 2684 FE01      		movw r30,r28
 5448 2686 13E0      		ldi r17,3
 5449               		1:
 5450 2688 F695      		lsr r31
 5451 268a E795      		ror r30
 5452 268c 1A95      		dec r17
 5453 268e 01F4      		brne 1b
 5454               	.LBE147:
 5455               		.loc 1 4972 0
 5456 2690 FF27      		clr r31
 5457               	.LBB148:
2139:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
 5458               		.loc 1 2139 0
 5459 2692 E050      		subi r30,lo8(-(sampleToc))
 5460 2694 F040      		sbci r31,hi8(-(sampleToc))
 5461               	.LBE148:
2137:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 5462               		.loc 1 2137 0
 5463 2696 C770      		andi r28,7
 5464 2698 DD27      		clr r29
 5465               	.LVL205:
 5466               	.LBB149:
2139:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
 5467               		.loc 1 2139 0
 5468 269a 81E0      		ldi r24,lo8(1)
 5469 269c 90E0      		ldi r25,0
 5470 269e 0C2E      		mov r0,r28
 5471 26a0 00C0      		rjmp 2f
 5472               		1:
 5473 26a2 880F      		lsl r24
 5474               		2:
 5475 26a4 0A94      		dec r0
 5476 26a6 02F4      		brpl 1b
 5477 26a8 8095      		com r24
 5478 26aa 9081      		ld r25,Z
 5479 26ac 8923      		and r24,r25
 5480 26ae 8083      		st Z,r24
 5481               	.LBE149:
 5482               	.LBE146:
4034:WTPA.c        **** 						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
 5483               		.loc 1 4034 0
 5484 26b0 86E0      		ldi r24,lo8(6)
 5485 26b2 8093 0000 		sts cardState,r24
4035:WTPA.c        **** 						StopBlinking();					// Update LED to reflect that this is now full
 5486               		.loc 1 4035 0
 5487 26b6 0E94 0000 		call StopBlinking
 5488               	.LVL206:
4036:WTPA.c        **** 						ledOnOffMask&=~(1<<LED_7);
 5489               		.loc 1 4036 0
 5490 26ba 8091 0000 		lds r24,ledOnOffMask
 5491 26be 8F77      		andi r24,lo8(127)
 5492 26c0 8093 0000 		sts ledOnOffMask,r24
 5493               	.L326:
4041:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
 5494               		.loc 1 4041 0
 5495 26c4 8091 0000 		lds r24,newKeys
 5496 26c8 84FD      		sbrc r24,4
 5497 26ca 00C0      		rjmp .L327
3929:WTPA.c        **** static void SdCardMenu(void)
 5498               		.loc 1 3929 0
 5499 26cc 982F      		mov r25,r24
 5500 26ce 9076      		andi r25,lo8(96)
4041:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
 5501               		.loc 1 4041 0
 5502 26d0 01F4      		brne .L327
 5503 26d2 87FF      		sbrs r24,7
 5504 26d4 00C0      		rjmp .L297
 5505               	.L327:
4043:WTPA.c        **** 				KillLeds();
 5506               		.loc 1 4043 0
 5507 26d6 0E94 0000 		call KillLeds
 5508               	.LVL207:
 5509               	.LBB150:
 5510               	.LBB151:
1429:WTPA.c        **** 	State=newState;
 5511               		.loc 1 1429 0
 5512 26da 80E0      		ldi r24,lo8(gs(DoSampler))
 5513 26dc 90E0      		ldi r25,hi8(gs(DoSampler))
 5514 26de 9093 0000 		sts State+1,r25
 5515 26e2 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 5516               		.loc 1 1430 0
 5517 26e6 1092 0000 		sts subState,__zero_reg__
 5518               	.LVL208:
 5519               	.L297:
 5520               	/* epilogue start */
 5521               	.LBE151:
 5522               	.LBE150:
 5523               	.LBE155:
 5524               	.LBE132:
4048:WTPA.c        **** }
 5525               		.loc 1 4048 0
 5526 26ea DF91      		pop r29
 5527 26ec CF91      		pop r28
 5528 26ee 1F91      		pop r17
 5529 26f0 0F91      		pop r16
 5530 26f2 FF90      		pop r15
 5531 26f4 EF90      		pop r14
 5532 26f6 0895      		ret
 5533               		.cfi_endproc
 5534               	.LFE68:
 5537               	DoSawtooth:
 5538               	.LFB72:
4616:WTPA.c        **** {
 5539               		.loc 1 4616 0
 5540               		.cfi_startproc
 5541               	/* prologue: function */
 5542               	/* frame size = 0 */
 5543               	/* stack size = 0 */
 5544               	.L__stack_usage = 0
4617:WTPA.c        **** 	if(subState==SS_0)
 5545               		.loc 1 4617 0
 5546 26f8 8091 0000 		lds r24,subState
 5547 26fc 8111      		cpse r24,__zero_reg__
 5548 26fe 00C0      		rjmp .L369
4619:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
 5549               		.loc 1 4619 0
 5550 2700 0E94 0000 		call KillLeds
 5551               	.LVL209:
4620:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
 5552               		.loc 1 4620 0
 5553 2704 80EC      		ldi r24,lo8(-64)
 5554 2706 90E0      		ldi r25,0
 5555 2708 0E94 0000 		call BlinkLeds
 5556               	.LVL210:
4621:WTPA.c        **** 		subState=SS_1;
 5557               		.loc 1 4621 0
 5558 270c 81E0      		ldi r24,lo8(1)
 5559 270e 00C0      		rjmp .L406
 5560               	.L369:
4623:WTPA.c        **** 	else if(subState==SS_1)
 5561               		.loc 1 4623 0
 5562 2710 8130      		cpi r24,lo8(1)
 5563 2712 01F4      		brne .L371
4625:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 5564               		.loc 1 4625 0
 5565               	/* #APP */
 5566               	 ;  4625 "WTPA.c" 1
 5567 2714 F894      		cli
 5568               	 ;  0 "" 2
4626:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
 5569               		.loc 1 4626 0
 5570               	/* #NOAPP */
 5571 2716 8093 0000 		sts bankStates,r24
4627:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
 5572               		.loc 1 4627 0
 5573 271a 8093 0000 		sts bankStates+10,r24
 5574               	.LVL211:
 5575               	.LBB160:
 5576               	.LBB161:
1850:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 5577               		.loc 1 1850 0
 5578 271e 8093 0000 		sts bankStates+10,r24
 5579 2722 0E94 0000 		call SetSampleClock.part.0
 5580               	.LVL212:
 5581               	.LBE161:
 5582               	.LBE160:
4629:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 5583               		.loc 1 4629 0
 5584 2726 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5585 2728 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5586 272a 9093 0000 		sts UpdateOutput+1,r25
 5587 272e 8093 0000 		sts UpdateOutput,r24
4630:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 5588               		.loc 1 4630 0
 5589               	/* #APP */
 5590               	 ;  4630 "WTPA.c" 1
 5591 2732 7894      		sei
 5592               	 ;  0 "" 2
4632:WTPA.c        **** 		subState=SS_2;					// And wait forever.
 5593               		.loc 1 4632 0
 5594               	/* #NOAPP */
 5595 2734 82E0      		ldi r24,lo8(2)
 5596               	.LVL213:
 5597               	.L406:
 5598 2736 8093 0000 		sts subState,r24
 5599 273a 0895      		ret
 5600               	.L371:
4634:WTPA.c        **** 	else if(subState==SS_2)
 5601               		.loc 1 4634 0
 5602 273c 8230      		cpi r24,lo8(2)
 5603 273e 01F0      		breq .+2
 5604 2740 00C0      		rjmp .L368
 5605               	.LBB162:
 5606               	.LBB163:
4637:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 5607               		.loc 1 4637 0
 5608 2742 8091 0000 		lds r24,newKeys
 5609 2746 80FF      		sbrs r24,0
 5610 2748 00C0      		rjmp .L373
4639:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
 5611               		.loc 1 4639 0
 5612 274a 9091 0000 		lds r25,ledOnOffMask
 5613 274e 21E0      		ldi r18,lo8(1)
 5614 2750 9227      		eor r25,r18
 5615 2752 9093 0000 		sts ledOnOffMask,r25
 5616               	.L373:
4641:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 5617               		.loc 1 4641 0
 5618 2756 81FF      		sbrs r24,1
 5619 2758 00C0      		rjmp .L374
4643:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
 5620               		.loc 1 4643 0
 5621 275a 9091 0000 		lds r25,ledOnOffMask
 5622 275e 22E0      		ldi r18,lo8(2)
 5623 2760 9227      		eor r25,r18
 5624 2762 9093 0000 		sts ledOnOffMask,r25
 5625               	.L374:
4645:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
 5626               		.loc 1 4645 0
 5627 2766 82FF      		sbrs r24,2
 5628 2768 00C0      		rjmp .L375
4647:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
 5629               		.loc 1 4647 0
 5630 276a 9091 0000 		lds r25,ledOnOffMask
 5631 276e 24E0      		ldi r18,lo8(4)
 5632 2770 9227      		eor r25,r18
 5633 2772 9093 0000 		sts ledOnOffMask,r25
 5634               	.L375:
4649:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
 5635               		.loc 1 4649 0
 5636 2776 83FF      		sbrs r24,3
 5637 2778 00C0      		rjmp .L376
4651:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
 5638               		.loc 1 4651 0
 5639 277a 9091 0000 		lds r25,ledOnOffMask
 5640 277e 28E0      		ldi r18,lo8(8)
 5641 2780 9227      		eor r25,r18
 5642 2782 9093 0000 		sts ledOnOffMask,r25
 5643               	.L376:
4653:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
 5644               		.loc 1 4653 0
 5645 2786 84FF      		sbrs r24,4
 5646 2788 00C0      		rjmp .L377
4655:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
 5647               		.loc 1 4655 0
 5648 278a 9091 0000 		lds r25,ledOnOffMask
 5649 278e 20E1      		ldi r18,lo8(16)
 5650 2790 9227      		eor r25,r18
 5651 2792 9093 0000 		sts ledOnOffMask,r25
 5652               	.L377:
4657:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
 5653               		.loc 1 4657 0
 5654 2796 85FF      		sbrs r24,5
 5655 2798 00C0      		rjmp .L378
4659:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
 5656               		.loc 1 4659 0
 5657 279a 9091 0000 		lds r25,ledOnOffMask
 5658 279e 20E2      		ldi r18,lo8(32)
 5659 27a0 9227      		eor r25,r18
 5660 27a2 9093 0000 		sts ledOnOffMask,r25
 5661               	.L378:
4662:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
 5662               		.loc 1 4662 0
 5663 27a6 86FF      		sbrs r24,6
 5664 27a8 00C0      		rjmp .L379
4664:WTPA.c        **** 			StopBlinking();
 5665               		.loc 1 4664 0
 5666 27aa 0E94 0000 		call StopBlinking
 5667               	.LVL214:
4665:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
 5668               		.loc 1 4665 0
 5669 27ae 8091 0000 		lds r24,ledOnOffMask
 5670 27b2 90E4      		ldi r25,lo8(64)
 5671 27b4 8927      		eor r24,r25
 5672 27b6 8093 0000 		sts ledOnOffMask,r24
 5673               	.L379:
4667:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
 5674               		.loc 1 4667 0
 5675 27ba 8091 0000 		lds r24,newKeys
 5676 27be 87FF      		sbrs r24,7
 5677 27c0 00C0      		rjmp .L380
4669:WTPA.c        **** 			StopBlinking();
 5678               		.loc 1 4669 0
 5679 27c2 0E94 0000 		call StopBlinking
 5680               	.LVL215:
4670:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
 5681               		.loc 1 4670 0
 5682 27c6 8091 0000 		lds r24,ledOnOffMask
 5683 27ca 8058      		subi r24,lo8(-(-128))
 5684 27cc 8093 0000 		sts ledOnOffMask,r24
 5685               	.L380:
4672:WTPA.c        **** 		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
 5686               		.loc 1 4672 0
 5687 27d0 8091 0000 		lds r24,newEncoder
 5688 27d4 8823      		tst r24
 5689 27d6 01F0      		breq .L368
4674:WTPA.c        **** 			StopBlinking();
 5690               		.loc 1 4674 0
 5691 27d8 0E94 0000 		call StopBlinking
 5692               	.LVL216:
4675:WTPA.c        **** 			ledOnOffMask=encoderValue;
 5693               		.loc 1 4675 0
 5694 27dc 8091 0000 		lds r24,encoderValue
 5695 27e0 8093 0000 		sts ledOnOffMask,r24
 5696               	.L368:
 5697 27e4 0895      		ret
 5698               	.LBE163:
 5699               	.LBE162:
 5700               		.cfi_endproc
 5701               	.LFE72:
 5704               	InitSampler:
 5705               	.LFB71:
4567:WTPA.c        **** {
 5706               		.loc 1 4567 0
 5707               		.cfi_startproc
 5708 27e6 CF92      		push r12
 5709               	.LCFI63:
 5710               		.cfi_def_cfa_offset 3
 5711               		.cfi_offset 12, -2
 5712 27e8 DF92      		push r13
 5713               	.LCFI64:
 5714               		.cfi_def_cfa_offset 4
 5715               		.cfi_offset 13, -3
 5716 27ea EF92      		push r14
 5717               	.LCFI65:
 5718               		.cfi_def_cfa_offset 5
 5719               		.cfi_offset 14, -4
 5720 27ec FF92      		push r15
 5721               	.LCFI66:
 5722               		.cfi_def_cfa_offset 6
 5723               		.cfi_offset 15, -5
 5724 27ee 0F93      		push r16
 5725               	.LCFI67:
 5726               		.cfi_def_cfa_offset 7
 5727               		.cfi_offset 16, -6
 5728 27f0 1F93      		push r17
 5729               	.LCFI68:
 5730               		.cfi_def_cfa_offset 8
 5731               		.cfi_offset 17, -7
 5732 27f2 CF93      		push r28
 5733               	.LCFI69:
 5734               		.cfi_def_cfa_offset 9
 5735               		.cfi_offset 28, -8
 5736 27f4 DF93      		push r29
 5737               	.LCFI70:
 5738               		.cfi_def_cfa_offset 10
 5739               		.cfi_offset 29, -9
 5740               	/* prologue: function */
 5741               	/* frame size = 0 */
 5742               	/* stack size = 8 */
 5743               	.L__stack_usage = 8
 5744               	.LVL217:
 5745               	.LBB174:
 5746               	.LBB175:
3415:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 5747               		.loc 1 3415 0
 5748 27f6 84E0      		ldi r24,lo8(4)
 5749 27f8 0E94 0000 		call EepromRead
 5750               	.LVL218:
3422:WTPA.c        **** 	if(x<16)					// Legit number?
 5751               		.loc 1 3422 0
 5752 27fc 8031      		cpi r24,lo8(16)
 5753 27fe 00F0      		brlo .L408
3436:WTPA.c        **** 		return(x);
 5754               		.loc 1 3436 0
 5755 2800 80E0      		ldi r24,0
 5756               	.LVL219:
 5757               	.L408:
 5758               	.LBE175:
 5759               	.LBE174:
4571:WTPA.c        **** 	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
 5760               		.loc 1 4571 0
 5761 2802 8093 0000 		sts midiChannelNumberA,r24
 5762               	.LVL220:
 5763               	.LBB176:
 5764               	.LBB177:
3419:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 5765               		.loc 1 3419 0
 5766 2806 88E0      		ldi r24,lo8(8)
 5767 2808 0E94 0000 		call EepromRead
 5768               	.LVL221:
3422:WTPA.c        **** 	if(x<16)					// Legit number?
 5769               		.loc 1 3422 0
 5770 280c 8031      		cpi r24,lo8(16)
 5771 280e 00F0      		brlo .L409
3436:WTPA.c        **** 		return(x);
 5772               		.loc 1 3436 0
 5773 2810 81E0      		ldi r24,lo8(1)
 5774               	.LVL222:
 5775               	.L409:
 5776               	.LBE177:
 5777               	.LBE176:
4572:WTPA.c        **** 	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
 5778               		.loc 1 4572 0
 5779 2812 8093 0000 		sts midiChannelNumberB,r24
4573:WTPA.c        **** 	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcod
 5780               		.loc 1 4573 0
 5781 2816 1092 0000 		sts bankStates+17,__zero_reg__
 5782 281a 1092 0000 		sts bankStates+17+1,__zero_reg__
 5783 281e 1092 0000 		sts bankStates+17+2,__zero_reg__
 5784 2822 1092 0000 		sts bankStates+17+3,__zero_reg__
4574:WTPA.c        **** 	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcod
 5785               		.loc 1 4574 0
 5786 2826 8FEF      		ldi r24,lo8(-1)
 5787 2828 9FEF      		ldi r25,lo8(-1)
 5788 282a A7E0      		ldi r26,lo8(7)
 5789 282c B0E0      		ldi r27,0
 5790 282e 8093 0000 		sts bankStates+53,r24
 5791 2832 9093 0000 		sts bankStates+53+1,r25
 5792 2836 A093 0000 		sts bankStates+53+2,r26
 5793 283a B093 0000 		sts bankStates+53+3,r27
 5794               	.LVL223:
 5795 283e 00E0      		ldi r16,lo8(theMidiRecordRate)
 5796 2840 10E0      		ldi r17,hi8(theMidiRecordRate)
 5797 2842 C0E0      		ldi r28,0
 5798 2844 D0E0      		ldi r29,0
4578:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5799               		.loc 1 4578 0
 5800 2846 24E2      		ldi r18,lo8(36)
 5801 2848 E22E      		mov r14,r18
4585:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
 5802               		.loc 1 4585 0
 5803 284a DD24      		clr r13
 5804 284c D394      		inc r13
 5805               	.LBB178:
 5806               	.LBB179:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5807               		.loc 1 3334 0
 5808 284e 3CE0      		ldi r19,lo8(12)
 5809 2850 F32E      		mov r15,r19
 5810               	.LVL224:
 5811               	.L413:
 5812               	.LBE179:
 5813               	.LBE178:
4578:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5814               		.loc 1 4578 0 discriminator 2
 5815 2852 EC9E      		mul r14,r28
 5816 2854 F001      		movw r30,r0
 5817 2856 ED9E      		mul r14,r29
 5818 2858 F00D      		add r31,r0
 5819 285a 1124      		clr __zero_reg__
 5820 285c E050      		subi r30,lo8(-(bankStates))
 5821 285e F040      		sbci r31,hi8(-(bankStates))
 5822 2860 1082      		st Z,__zero_reg__
4579:WTPA.c        **** 		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
 5823               		.loc 1 4579 0 discriminator 2
 5824 2862 1286      		std Z+10,__zero_reg__
4580:WTPA.c        **** 		bankStates[i].loopOnce=false;
 5825               		.loc 1 4580 0 discriminator 2
 5826 2864 1182      		std Z+1,__zero_reg__
4581:WTPA.c        **** 		bankStates[i].bitReduction=0;				// No crusties yet.
 5827               		.loc 1 4581 0 discriminator 2
 5828 2866 1186      		std Z+9,__zero_reg__
4582:WTPA.c        **** 		bankStates[i].jitterValue=0;				// No hissies yet.
 5829               		.loc 1 4582 0 discriminator 2
 5830 2868 1086      		std Z+8,__zero_reg__
4583:WTPA.c        **** 		bankStates[i].granularSlices=0;				// No remix yet.
 5831               		.loc 1 4583 0 discriminator 2
 5832 286a 1782      		std Z+7,__zero_reg__
4584:WTPA.c        **** 		bankStates[i].halfSpeed=false;
 5833               		.loc 1 4584 0 discriminator 2
 5834 286c 1282      		std Z+2,__zero_reg__
4585:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
 5835               		.loc 1 4585 0 discriminator 2
 5836 286e D482      		std Z+4,r13
4586:WTPA.c        **** 		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
 5837               		.loc 1 4586 0 discriminator 2
 5838 2870 1382      		std Z+3,__zero_reg__
4587:WTPA.c        **** 		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the begi
 5839               		.loc 1 4587 0 discriminator 2
 5840 2872 8189      		ldd r24,Z+17
 5841 2874 9289      		ldd r25,Z+18
 5842 2876 A389      		ldd r26,Z+19
 5843 2878 B489      		ldd r27,Z+20
 5844 287a 80A3      		std Z+32,r24
 5845 287c 91A3      		std Z+33,r25
 5846 287e A2A3      		std Z+34,r26
 5847 2880 B3A3      		std Z+35,r27
4588:WTPA.c        **** 		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sam
 5848               		.loc 1 4588 0 discriminator 2
 5849 2882 8189      		ldd r24,Z+17
 5850 2884 9289      		ldd r25,Z+18
 5851 2886 A389      		ldd r26,Z+19
 5852 2888 B489      		ldd r27,Z+20
 5853 288a 8587      		std Z+13,r24
 5854 288c 9687      		std Z+14,r25
 5855 288e A787      		std Z+15,r26
 5856 2890 B08B      		std Z+16,r27
4589:WTPA.c        **** 		bankStates[i].realtimeOn=false;						// We'll default to playback.
 5857               		.loc 1 4589 0 discriminator 2
 5858 2892 1682      		std Z+6,__zero_reg__
4590:WTPA.c        **** 		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
 5859               		.loc 1 4590 0 discriminator 2
 5860 2894 1582      		std Z+5,__zero_reg__
4592:WTPA.c        **** 		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
 5861               		.loc 1 4592 0 discriminator 2
 5862 2896 8C2F      		mov r24,r28
 5863 2898 0E94 0000 		call RevertSampleToUnadjusted
 5864               	.LVL225:
 5865               	.LBB181:
 5866               	.LBB182:
3370:WTPA.c        **** 	if(theBank==BANK_0)
 5867               		.loc 1 3370 0 discriminator 2
 5868 289c C111      		cpse r28,__zero_reg__
 5869 289e 00C0      		rjmp .L410
3372:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
 5870               		.loc 1 3372 0
 5871 28a0 87E0      		ldi r24,lo8(7)
 5872 28a2 00C0      		rjmp .L417
 5873               	.L410:
3376:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
 5874               		.loc 1 3376 0
 5875 28a4 8BE0      		ldi r24,lo8(11)
 5876               	.L417:
 5877 28a6 0E94 0000 		call EepromRead
 5878               	.LVL226:
3379:WTPA.c        **** 	if(x<90)					// Legit number?
 5879               		.loc 1 3379 0
 5880 28aa 8A35      		cpi r24,lo8(90)
 5881 28ac 00F0      		brlo .L412
3386:WTPA.c        **** 		return(x);
 5882               		.loc 1 3386 0
 5883 28ae 80E3      		ldi r24,lo8(48)
 5884               	.LVL227:
 5885               	.L412:
 5886               	.LBE182:
 5887               	.LBE181:
 5888               	.LBB183:
 5889               	.LBB180:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5890               		.loc 1 3334 0
 5891 28b0 6F2D      		mov r22,r15
 5892 28b2 0E94 0000 		call __udivmodqi4
 5893               	.LVL228:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 5894               		.loc 1 3336 0
 5895 28b6 E92F      		mov r30,r25
 5896 28b8 F0E0      		ldi r31,0
 5897 28ba EE0F      		lsl r30
 5898 28bc FF1F      		rol r31
 5899 28be E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 5900 28c0 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 5901 28c2 2081      		ld r18,Z
 5902 28c4 3181      		ldd r19,Z+1
 5903 28c6 00C0      		rjmp 2f
 5904               		1:
 5905 28c8 3695      		lsr r19
 5906 28ca 2795      		ror r18
 5907               		2:
 5908 28cc 8A95      		dec r24
 5909 28ce 02F4      		brpl 1b
 5910               	.LBE180:
 5911               	.LBE183:
4595:WTPA.c        **** 		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful numb
 5912               		.loc 1 4595 0
 5913 28d0 F801      		movw r30,r16
 5914 28d2 2193      		st Z+,r18
 5915 28d4 3193      		st Z+,r19
 5916 28d6 8F01      		movw r16,r30
 5917 28d8 2196      		adiw r28,1
 5918               	.LVL229:
4576:WTPA.c        **** 	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
 5919               		.loc 1 4576 0
 5920 28da C230      		cpi r28,2
 5921 28dc D105      		cpc r29,__zero_reg__
 5922 28de 01F0      		breq .+2
 5923 28e0 00C0      		rjmp .L413
4598:WTPA.c        **** 	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 5924               		.loc 1 4598 0
 5925 28e2 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5926 28e4 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5927 28e6 9093 0000 		sts UpdateOutput+1,r25
 5928 28ea 8093 0000 		sts UpdateOutput,r24
4600:WTPA.c        **** 	currentBank=BANK_0;			// Point at the first bank until we change banks.
 5929               		.loc 1 4600 0
 5930 28ee 1092 0000 		sts currentBank,__zero_reg__
4601:WTPA.c        **** 	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
 5931               		.loc 1 4601 0
 5932 28f2 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 5933 28f6 1092 0000 		sts sdCurrentSlot,__zero_reg__
4603:WTPA.c        **** 	KillLeds();					// All leds off, and no blinking.
 5934               		.loc 1 4603 0
 5935 28fa 0E94 0000 		call KillLeds
 5936               	.LVL230:
 5937               	.LBB184:
 5938               	.LBB185:
1429:WTPA.c        **** 	State=newState;
 5939               		.loc 1 1429 0
 5940 28fe 80E0      		ldi r24,lo8(gs(DoSampler))
 5941 2900 90E0      		ldi r25,hi8(gs(DoSampler))
 5942 2902 9093 0000 		sts State+1,r25
 5943 2906 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 5944               		.loc 1 1430 0
 5945 290a 1092 0000 		sts subState,__zero_reg__
 5946               	/* epilogue start */
 5947               	.LBE185:
 5948               	.LBE184:
4605:WTPA.c        **** }
 5949               		.loc 1 4605 0
 5950 290e DF91      		pop r29
 5951 2910 CF91      		pop r28
 5952 2912 1F91      		pop r17
 5953 2914 0F91      		pop r16
 5954 2916 FF90      		pop r15
 5955 2918 EF90      		pop r14
 5956 291a DF90      		pop r13
 5957 291c CF90      		pop r12
 5958 291e 0895      		ret
 5959               		.cfi_endproc
 5960               	.LFE71:
 5963               	SetMidiChannels:
 5964               	.LFB73:
4717:WTPA.c        **** {
 5965               		.loc 1 4717 0
 5966               		.cfi_startproc
 5967               	/* prologue: function */
 5968               	/* frame size = 0 */
 5969               	/* stack size = 0 */
 5970               	.L__stack_usage = 0
4718:WTPA.c        **** 	if(subState==SS_0)
 5971               		.loc 1 4718 0
 5972 2920 8091 0000 		lds r24,subState
 5973 2924 8111      		cpse r24,__zero_reg__
 5974 2926 00C0      		rjmp .L419
 5975               	.LVL231:
 5976               	.LBB196:
 5977               	.LBB197:
3415:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 5978               		.loc 1 3415 0
 5979 2928 84E0      		ldi r24,lo8(4)
 5980 292a 0E94 0000 		call EepromRead
 5981               	.LVL232:
3422:WTPA.c        **** 	if(x<16)					// Legit number?
 5982               		.loc 1 3422 0
 5983 292e 8031      		cpi r24,lo8(16)
 5984 2930 00F0      		brlo .L420
3436:WTPA.c        **** 		return(x);
 5985               		.loc 1 3436 0
 5986 2932 80E0      		ldi r24,0
 5987               	.LVL233:
 5988               	.L420:
 5989               	.LBE197:
 5990               	.LBE196:
4720:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
 5991               		.loc 1 4720 0
 5992 2934 8093 0000 		sts midiChannelNumberA,r24
 5993               	.LVL234:
 5994               	.LBB198:
 5995               	.LBB199:
3419:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 5996               		.loc 1 3419 0
 5997 2938 88E0      		ldi r24,lo8(8)
 5998 293a 0E94 0000 		call EepromRead
 5999               	.LVL235:
3422:WTPA.c        **** 	if(x<16)					// Legit number?
 6000               		.loc 1 3422 0
 6001 293e 8031      		cpi r24,lo8(16)
 6002 2940 00F0      		brlo .L421
3436:WTPA.c        **** 		return(x);
 6003               		.loc 1 3436 0
 6004 2942 81E0      		ldi r24,lo8(1)
 6005               	.LVL236:
 6006               	.L421:
 6007               	.LBE199:
 6008               	.LBE198:
4721:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
 6009               		.loc 1 4721 0
 6010 2944 8093 0000 		sts midiChannelNumberB,r24
4722:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
 6011               		.loc 1 4722 0
 6012 2948 20E1      		ldi r18,lo8(16)
 6013 294a 829F      		mul r24,r18
 6014 294c C001      		movw r24,r0
 6015 294e 1124      		clr __zero_reg__
 6016 2950 9091 0000 		lds r25,midiChannelNumberA
 6017 2954 982B      		or r25,r24
 6018 2956 9093 0000 		sts ledOnOffMask,r25
4723:WTPA.c        **** 		subState=SS_1;
 6019               		.loc 1 4723 0
 6020 295a 81E0      		ldi r24,lo8(1)
 6021 295c 8093 0000 		sts subState,r24
 6022 2960 0895      		ret
 6023               	.LVL237:
 6024               	.L419:
4727:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 6025               		.loc 1 4727 0
 6026 2962 2091 0000 		lds r18,newKeys
 6027 2966 20FF      		sbrs r18,0
 6028 2968 00C0      		rjmp .L423
4729:WTPA.c        **** 			midiChannelNumberA++;
 6029               		.loc 1 4729 0
 6030 296a 8091 0000 		lds r24,midiChannelNumberA
 6031               	.LVL238:
 6032 296e 8F5F      		subi r24,lo8(-(1))
 6033               	.LVL239:
4730:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
 6034               		.loc 1 4730 0
 6035 2970 8031      		cpi r24,lo8(16)
 6036               	.LVL240:
 6037 2972 00F4      		brsh .L424
4729:WTPA.c        **** 			midiChannelNumberA++;
 6038               		.loc 1 4729 0
 6039 2974 8093 0000 		sts midiChannelNumberA,r24
 6040 2978 00C0      		rjmp .L425
 6041               	.L424:
4732:WTPA.c        **** 				midiChannelNumberA=0;
 6042               		.loc 1 4732 0
 6043 297a 1092 0000 		sts midiChannelNumberA,__zero_reg__
 6044               	.L425:
4735:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
 6045               		.loc 1 4735 0
 6046 297e 8091 0000 		lds r24,ledOnOffMask
 6047               	.LVL241:
 6048 2982 807F      		andi r24,lo8(-16)
4736:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
 6049               		.loc 1 4736 0
 6050 2984 9091 0000 		lds r25,midiChannelNumberA
 6051 2988 892B      		or r24,r25
 6052 298a 8093 0000 		sts ledOnOffMask,r24
 6053               	.L423:
4738:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 6054               		.loc 1 4738 0
 6055 298e 21FF      		sbrs r18,1
 6056 2990 00C0      		rjmp .L426
4740:WTPA.c        **** 			midiChannelNumberB++;
 6057               		.loc 1 4740 0
 6058 2992 8091 0000 		lds r24,midiChannelNumberB
 6059               	.LVL242:
 6060 2996 8F5F      		subi r24,lo8(-(1))
 6061               	.LVL243:
4741:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
 6062               		.loc 1 4741 0
 6063 2998 8031      		cpi r24,lo8(16)
 6064               	.LVL244:
 6065 299a 00F4      		brsh .L427
4740:WTPA.c        **** 			midiChannelNumberB++;
 6066               		.loc 1 4740 0
 6067 299c 8093 0000 		sts midiChannelNumberB,r24
 6068 29a0 00C0      		rjmp .L428
 6069               	.L427:
4743:WTPA.c        **** 				midiChannelNumberB=0;
 6070               		.loc 1 4743 0
 6071 29a2 1092 0000 		sts midiChannelNumberB,__zero_reg__
 6072               	.L428:
4747:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 6073               		.loc 1 4747 0
 6074 29a6 8091 0000 		lds r24,midiChannelNumberB
 6075               	.LVL245:
 6076 29aa 30E1      		ldi r19,lo8(16)
 6077 29ac 839F      		mul r24,r19
 6078 29ae C001      		movw r24,r0
 6079 29b0 1124      		clr __zero_reg__
4746:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
 6080               		.loc 1 4746 0
 6081 29b2 9091 0000 		lds r25,ledOnOffMask
 6082 29b6 9F70      		andi r25,lo8(15)
4747:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 6083               		.loc 1 4747 0
 6084 29b8 982B      		or r25,r24
 6085 29ba 9093 0000 		sts ledOnOffMask,r25
 6086               	.L426:
4749:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
 6087               		.loc 1 4749 0
 6088 29be 22FF      		sbrs r18,2
 6089 29c0 00C0      		rjmp .L418
 6090               	.LVL246:
 6091               	.LBB200:
 6092               	.LBB201:
3396:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
 6093               		.loc 1 3396 0
 6094 29c2 6091 0000 		lds r22,midiChannelNumberA
 6095 29c6 84E0      		ldi r24,lo8(4)
 6096 29c8 90E0      		ldi r25,0
 6097 29ca 0E94 0000 		call EepromWrite
 6098               	.LVL247:
 6099               	.LBE201:
 6100               	.LBE200:
 6101               	.LBB202:
 6102               	.LBB203:
3400:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
 6103               		.loc 1 3400 0
 6104 29ce 6091 0000 		lds r22,midiChannelNumberB
 6105 29d2 88E0      		ldi r24,lo8(8)
 6106 29d4 90E0      		ldi r25,0
 6107 29d6 0E94 0000 		call EepromWrite
 6108               	.LVL248:
 6109               	.LBE203:
 6110               	.LBE202:
 6111               	.LBB204:
 6112               	.LBB205:
1429:WTPA.c        **** 	State=newState;
 6113               		.loc 1 1429 0
 6114 29da 80E0      		ldi r24,lo8(gs(InitSampler))
 6115 29dc 90E0      		ldi r25,hi8(gs(InitSampler))
 6116 29de 9093 0000 		sts State+1,r25
 6117 29e2 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 6118               		.loc 1 1430 0
 6119 29e6 1092 0000 		sts subState,__zero_reg__
 6120               	.LVL249:
 6121               	.L418:
 6122 29ea 0895      		ret
 6123               	.LBE205:
 6124               	.LBE204:
 6125               		.cfi_endproc
 6126               	.LFE73:
 6129               	DoSampler:
 6130               	.LFB70:
4302:WTPA.c        **** {
 6131               		.loc 1 4302 0
 6132               		.cfi_startproc
 6133 29ec CF92      		push r12
 6134               	.LCFI71:
 6135               		.cfi_def_cfa_offset 3
 6136               		.cfi_offset 12, -2
 6137 29ee DF92      		push r13
 6138               	.LCFI72:
 6139               		.cfi_def_cfa_offset 4
 6140               		.cfi_offset 13, -3
 6141 29f0 FF92      		push r15
 6142               	.LCFI73:
 6143               		.cfi_def_cfa_offset 5
 6144               		.cfi_offset 15, -4
 6145 29f2 0F93      		push r16
 6146               	.LCFI74:
 6147               		.cfi_def_cfa_offset 6
 6148               		.cfi_offset 16, -5
 6149 29f4 1F93      		push r17
 6150               	.LCFI75:
 6151               		.cfi_def_cfa_offset 7
 6152               		.cfi_offset 17, -6
 6153 29f6 CF93      		push r28
 6154               	.LCFI76:
 6155               		.cfi_def_cfa_offset 8
 6156               		.cfi_offset 28, -7
 6157 29f8 DF93      		push r29
 6158               	.LCFI77:
 6159               		.cfi_def_cfa_offset 9
 6160               		.cfi_offset 29, -8
 6161 29fa 1F92      		push __zero_reg__
 6162               	.LCFI78:
 6163               		.cfi_def_cfa_offset 10
 6164 29fc CDB7      		in r28,__SP_L__
 6165 29fe DEB7      		in r29,__SP_H__
 6166               	.LCFI79:
 6167               		.cfi_def_cfa_register 28
 6168               	/* prologue: function */
 6169               	/* frame size = 1 */
 6170               	/* stack size = 8 */
 6171               	.L__stack_usage = 8
4319:WTPA.c        **** 	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sam
 6172               		.loc 1 4319 0
 6173 2a00 8091 0000 		lds r24,subState
 6174 2a04 8111      		cpse r24,__zero_reg__
 6175 2a06 00C0      		rjmp .L442
 6176               	.LBB248:
 6177               	.LBB249:
4065:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
 6178               		.loc 1 4065 0
 6179 2a08 8091 0000 		lds r24,keysHeld
 6180 2a0c 86FF      		sbrs r24,6
 6181 2a0e 00C0      		rjmp .L443
 6182 2a10 87FF      		sbrs r24,7
 6183 2a12 00C0      		rjmp .L444
4067:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
 6184               		.loc 1 4067 0
 6185 2a14 8091 0000 		lds r24,newKeys
 6186 2a18 85FF      		sbrs r24,5
 6187 2a1a 00C0      		rjmp .L445
4069:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
 6188               		.loc 1 4069 0
 6189 2a1c 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6190 2a1e 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6191 2a20 9093 0000 		sts UpdateOutput+1,r25
 6192 2a24 8093 0000 		sts UpdateOutput,r24
4070:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
 6193               		.loc 1 4070 0
 6194 2a28 1091 0000 		lds r17,currentBank
 6195 2a2c 812F      		mov r24,r17
 6196 2a2e 0E94 0000 		call RevertSampleToUnadjusted
 6197               	.LVL250:
4071:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
 6198               		.loc 1 4071 0
 6199 2a32 24E2      		ldi r18,lo8(36)
 6200 2a34 129F      		mul r17,r18
 6201 2a36 F001      		movw r30,r0
 6202 2a38 1124      		clr __zero_reg__
 6203 2a3a E050      		subi r30,lo8(-(bankStates))
 6204 2a3c F040      		sbci r31,hi8(-(bankStates))
 6205 2a3e 1186      		std Z+9,__zero_reg__
4072:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
 6206               		.loc 1 4072 0
 6207 2a40 1086      		std Z+8,__zero_reg__
4073:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
 6208               		.loc 1 4073 0
 6209 2a42 1782      		std Z+7,__zero_reg__
4074:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
 6210               		.loc 1 4074 0
 6211 2a44 1282      		std Z+2,__zero_reg__
4075:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
 6212               		.loc 1 4075 0
 6213 2a46 1382      		std Z+3,__zero_reg__
4076:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
 6214               		.loc 1 4076 0
 6215 2a48 81E0      		ldi r24,lo8(1)
 6216 2a4a 8483      		std Z+4,r24
4077:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
 6217               		.loc 1 4077 0
 6218 2a4c 1182      		std Z+1,__zero_reg__
4078:WTPA.c        **** 			bankStates[currentBank].realtimeOn=false;
 6219               		.loc 1 4078 0
 6220 2a4e 1682      		std Z+6,__zero_reg__
4079:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
 6221               		.loc 1 4079 0
 6222 2a50 20E0      		ldi r18,0
 6223 2a52 42E1      		ldi r20,lo8(18)
 6224 2a54 64E0      		ldi r22,lo8(4)
 6225 2a56 812F      		mov r24,r17
 6226 2a58 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6227               	.LVL251:
4080:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
 6228               		.loc 1 4080 0
 6229 2a5c 20E0      		ldi r18,0
 6230 2a5e 4BE1      		ldi r20,lo8(27)
 6231 2a60 64E0      		ldi r22,lo8(4)
 6232 2a62 8091 0000 		lds r24,currentBank
 6233 2a66 00C0      		rjmp .L619
 6234               	.L445:
4082:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
 6235               		.loc 1 4082 0
 6236 2a68 80FF      		sbrs r24,0
 6237 2a6a 00C0      		rjmp .L446
4084:WTPA.c        **** 			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
 6238               		.loc 1 4084 0
 6239 2a6c 8091 0000 		lds r24,cardState
 6240 2a70 8E30      		cpi r24,lo8(14)
 6241 2a72 01F0      		breq .+2
 6242 2a74 00C0      		rjmp .L446
 6243               	.LVL252:
 6244               	.LBB250:
 6245               	.LBB251:
1429:WTPA.c        **** 	State=newState;
 6246               		.loc 1 1429 0
 6247 2a76 80E0      		ldi r24,lo8(gs(SdCardMenu))
 6248 2a78 90E0      		ldi r25,hi8(gs(SdCardMenu))
 6249 2a7a 9093 0000 		sts State+1,r25
 6250 2a7e 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 6251               		.loc 1 1430 0
 6252 2a82 1092 0000 		sts subState,__zero_reg__
 6253 2a86 00C0      		rjmp .L446
 6254               	.LVL253:
 6255               	.L444:
 6256               	.LBE251:
 6257               	.LBE250:
 6258               	.LBE249:
4095:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
 6259               		.loc 1 4095 0
 6260 2a88 8091 0000 		lds r24,keyState
 6261               	.LBB258:
 6262 2a8c 80FF      		sbrs r24,0
 6263 2a8e 00C0      		rjmp .L449
4097:WTPA.c        **** 			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just
 6264               		.loc 1 4097 0
 6265 2a90 8091 0000 		lds r24,newEncoder
 6266 2a94 8111      		cpse r24,__zero_reg__
 6267 2a96 00C0      		rjmp .L450
 6268               	.LBE258:
 6269 2a98 8091 0000 		lds r24,newKeys
 6270               	.LBB259:
 6271 2a9c 80FF      		sbrs r24,0
 6272 2a9e 00C0      		rjmp .L449
 6273               	.L450:
4099:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
 6274               		.loc 1 4099 0
 6275 2aa0 8091 0000 		lds r24,currentBank
 6276 2aa4 2091 0000 		lds r18,scaledEncoderValue
 6277 2aa8 44E2      		ldi r20,lo8(36)
 6278 2aaa 849F      		mul r24,r20
 6279 2aac F001      		movw r30,r0
 6280 2aae 1124      		clr __zero_reg__
 6281 2ab0 E050      		subi r30,lo8(-(bankStates))
 6282 2ab2 F040      		sbci r31,hi8(-(bankStates))
 6283 2ab4 2187      		std Z+9,r18
4100:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
 6284               		.loc 1 4100 0
 6285 2ab6 43E1      		ldi r20,lo8(19)
 6286 2ab8 64E0      		ldi r22,lo8(4)
 6287 2aba 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6288               	.LVL254:
 6289               	.L449:
 6290               	.LBE259:
4103:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
 6291               		.loc 1 4103 0
 6292 2abe 8091 0000 		lds r24,newKeys
 6293               	.LBB260:
 6294 2ac2 81FF      		sbrs r24,1
 6295 2ac4 00C0      		rjmp .L451
4105:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
 6296               		.loc 1 4105 0
 6297 2ac6 8091 0000 		lds r24,currentBank
 6298 2aca 94E2      		ldi r25,lo8(36)
 6299 2acc 899F      		mul r24,r25
 6300 2ace F001      		movw r30,r0
 6301 2ad0 1124      		clr __zero_reg__
 6302 2ad2 E050      		subi r30,lo8(-(bankStates))
 6303 2ad4 F040      		sbci r31,hi8(-(bankStates))
 6304 2ad6 9281      		ldd r25,Z+2
 6305 2ad8 9111      		cpse r25,__zero_reg__
 6306 2ada 00C0      		rjmp .L452
4107:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
 6307               		.loc 1 4107 0
 6308 2adc 91E0      		ldi r25,lo8(1)
 6309 2ade 9283      		std Z+2,r25
4108:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
 6310               		.loc 1 4108 0
 6311 2ae0 20E4      		ldi r18,lo8(64)
 6312 2ae2 00C0      		rjmp .L615
 6313               	.L452:
4112:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
 6314               		.loc 1 4112 0
 6315 2ae4 1282      		std Z+2,__zero_reg__
4113:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
 6316               		.loc 1 4113 0
 6317 2ae6 20E0      		ldi r18,0
 6318               	.L615:
 6319 2ae8 40E1      		ldi r20,lo8(16)
 6320 2aea 64E0      		ldi r22,lo8(4)
 6321 2aec 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6322               	.LVL255:
 6323               	.L451:
 6324               	.LBE260:
4116:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
 6325               		.loc 1 4116 0
 6326 2af0 8091 0000 		lds r24,newKeys
 6327               	.LBB261:
 6328 2af4 82FF      		sbrs r24,2
 6329 2af6 00C0      		rjmp .L453
4118:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
 6330               		.loc 1 4118 0
 6331 2af8 1091 0000 		lds r17,currentBank
 6332 2afc 40E0      		ldi r20,0
 6333 2afe 50E0      		ldi r21,0
 6334 2b00 61E0      		ldi r22,lo8(1)
 6335 2b02 812F      		mov r24,r17
 6336 2b04 0E94 0000 		call StartRealtime
 6337               	.LVL256:
4119:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
 6338               		.loc 1 4119 0
 6339 2b08 20E3      		ldi r18,lo8(48)
 6340 2b0a 4EE0      		ldi r20,lo8(14)
 6341 2b0c 64E0      		ldi r22,lo8(4)
 6342 2b0e 812F      		mov r24,r17
 6343 2b10 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6344               	.LVL257:
 6345               	.L453:
 6346               	.LBE261:
4121:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- res
 6347               		.loc 1 4121 0
 6348 2b14 8091 0000 		lds r24,keyState
 6349               	.LBB262:
 6350 2b18 83FF      		sbrs r24,3
 6351 2b1a 00C0      		rjmp .L454
 6352 2b1c 8091 0000 		lds r24,newEncoder
 6353 2b20 8111      		cpse r24,__zero_reg__
 6354 2b22 00C0      		rjmp .L455
 6355               	.L454:
 6356               	.LBE262:
 6357 2b24 8091 0000 		lds r24,newKeys
 6358               	.LBB263:
 6359 2b28 83FF      		sbrs r24,3
 6360 2b2a 00C0      		rjmp .L456
 6361               	.L455:
4123:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
 6362               		.loc 1 4123 0
 6363 2b2c 2091 0000 		lds r18,encoderValue
 6364 2b30 2695      		lsr r18
 6365 2b32 1091 0000 		lds r17,currentBank
 6366 2b36 622F      		mov r22,r18
 6367 2b38 812F      		mov r24,r17
 6368 2b3a 2983      		std Y+1,r18
 6369 2b3c 0E94 0000 		call MakeNewGranularArray
 6370               	.LVL258:
4124:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
 6371               		.loc 1 4124 0
 6372 2b40 2981      		ldd r18,Y+1
 6373 2b42 44E1      		ldi r20,lo8(20)
 6374 2b44 64E0      		ldi r22,lo8(4)
 6375 2b46 812F      		mov r24,r17
 6376 2b48 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6377               	.LVL259:
 6378               	.L456:
 6379               	.LBE263:
4126:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
 6380               		.loc 1 4126 0
 6381 2b4c 8091 0000 		lds r24,keyState
 6382               	.LBB264:
 6383 2b50 84FF      		sbrs r24,4
 6384 2b52 00C0      		rjmp .L457
4128:WTPA.c        **** 			if(newEncoder)	// Only change to new values
 6385               		.loc 1 4128 0
 6386 2b54 8091 0000 		lds r24,newEncoder
 6387 2b58 8823      		tst r24
 6388 2b5a 01F0      		breq .L457
4130:WTPA.c        **** 				switch(scaledEncoderValue)
 6389               		.loc 1 4130 0
 6390 2b5c 8091 0000 		lds r24,scaledEncoderValue
 6391 2b60 8130      		cpi r24,lo8(1)
 6392 2b62 01F0      		breq .L459
 6393 2b64 00F0      		brlo .L458
 6394 2b66 8230      		cpi r24,lo8(2)
 6395 2b68 01F0      		breq .L460
 6396 2b6a 8330      		cpi r24,lo8(3)
 6397 2b6c 01F4      		brne .L457
 6398 2b6e 00C0      		rjmp .L461
 6399               	.L458:
4133:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
 6400               		.loc 1 4133 0
 6401 2b70 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6402 2b72 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6403 2b74 9093 0000 		sts UpdateOutput+1,r25
 6404 2b78 8093 0000 		sts UpdateOutput,r24
4134:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6405               		.loc 1 4134 0
 6406 2b7c 20E0      		ldi r18,0
 6407 2b7e 00C0      		rjmp .L616
 6408               	.L459:
4138:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
 6409               		.loc 1 4138 0
 6410 2b80 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 6411 2b82 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 6412 2b84 9093 0000 		sts UpdateOutput+1,r25
 6413 2b88 8093 0000 		sts UpdateOutput,r24
4139:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6414               		.loc 1 4139 0
 6415 2b8c 21E0      		ldi r18,lo8(1)
 6416 2b8e 00C0      		rjmp .L616
 6417               	.L460:
4143:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
 6418               		.loc 1 4143 0
 6419 2b90 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 6420 2b92 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 6421 2b94 9093 0000 		sts UpdateOutput+1,r25
 6422 2b98 8093 0000 		sts UpdateOutput,r24
4144:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6423               		.loc 1 4144 0
 6424 2b9c 22E0      		ldi r18,lo8(2)
 6425 2b9e 00C0      		rjmp .L616
 6426               	.L461:
4148:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
 6427               		.loc 1 4148 0
 6428 2ba0 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 6429 2ba2 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 6430 2ba4 9093 0000 		sts UpdateOutput+1,r25
 6431 2ba8 8093 0000 		sts UpdateOutput,r24
4149:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 6432               		.loc 1 4149 0
 6433 2bac 23E0      		ldi r18,lo8(3)
 6434               	.L616:
 6435 2bae 46E1      		ldi r20,lo8(22)
 6436 2bb0 64E0      		ldi r22,lo8(4)
 6437 2bb2 8091 0000 		lds r24,currentBank
 6438 2bb6 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6439               	.LVL260:
 6440               	.L457:
 6441               	.LBE264:
4157:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
 6442               		.loc 1 4157 0
 6443 2bba 8091 0000 		lds r24,newKeys
 6444               	.LBB265:
 6445 2bbe 85FF      		sbrs r24,5
 6446 2bc0 00C0      		rjmp .L446
4159:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
 6447               		.loc 1 4159 0
 6448 2bc2 8091 0000 		lds r24,currentBank
 6449 2bc6 24E2      		ldi r18,lo8(36)
 6450 2bc8 829F      		mul r24,r18
 6451 2bca F001      		movw r30,r0
 6452 2bcc 1124      		clr __zero_reg__
 6453 2bce E050      		subi r30,lo8(-(bankStates))
 6454 2bd0 F040      		sbci r31,hi8(-(bankStates))
 6455 2bd2 9381      		ldd r25,Z+3
 6456 2bd4 9111      		cpse r25,__zero_reg__
 6457 2bd6 00C0      		rjmp .L462
4161:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
 6458               		.loc 1 4161 0
 6459 2bd8 91E0      		ldi r25,lo8(1)
 6460 2bda 9383      		std Z+3,r25
4162:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
 6461               		.loc 1 4162 0
 6462 2bdc 20E4      		ldi r18,lo8(64)
 6463 2bde 00C0      		rjmp .L617
 6464               	.L462:
4166:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
 6465               		.loc 1 4166 0
 6466 2be0 1382      		std Z+3,__zero_reg__
4167:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
 6467               		.loc 1 4167 0
 6468 2be2 20E0      		ldi r18,0
 6469               	.L617:
 6470 2be4 41E1      		ldi r20,lo8(17)
 6471 2be6 64E0      		ldi r22,lo8(4)
 6472 2be8 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6473               	.LVL261:
4170:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
 6474               		.loc 1 4170 0
 6475 2bec 8091 0000 		lds r24,currentBank
 6476 2bf0 0E94 0000 		call UpdateAdjustedSampleAddresses
 6477               	.LVL262:
 6478 2bf4 00C0      		rjmp .L446
 6479               	.L443:
4176:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
 6480               		.loc 1 4176 0
 6481 2bf6 87FF      		sbrs r24,7
 6482 2bf8 00C0      		rjmp .L464
4178:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
 6483               		.loc 1 4178 0
 6484 2bfa 8091 0000 		lds r24,keyState
 6485 2bfe 80FF      		sbrs r24,0
 6486 2c00 00C0      		rjmp .L465
4180:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
 6487               		.loc 1 4180 0
 6488 2c02 1091 0000 		lds r17,currentBank
 6489 2c06 44E2      		ldi r20,lo8(36)
 6490 2c08 149F      		mul r17,r20
 6491 2c0a F001      		movw r30,r0
 6492 2c0c 1124      		clr __zero_reg__
 6493 2c0e E050      		subi r30,lo8(-(bankStates))
 6494 2c10 F040      		sbci r31,hi8(-(bankStates))
 6495 2c12 858D      		ldd r24,Z+29
 6496 2c14 0091 0000 		lds r16,encoderValue
 6497 2c18 8017      		cp r24,r16
 6498 2c1a 01F0      		breq .L466
 6499               	.LVL263:
 6500               	.LBB252:
 6501               	.LBB253:
3898:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6502               		.loc 1 3898 0
 6503 2c1c 058F      		std Z+29,r16
3899:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6504               		.loc 1 3899 0
 6505 2c1e 812F      		mov r24,r17
 6506 2c20 0E94 0000 		call UpdateAdjustedSampleAddresses
 6507               	.LVL264:
 6508               	.LBE253:
 6509               	.LBE252:
4183:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
 6510               		.loc 1 4183 0
 6511 2c24 202F      		mov r18,r16
 6512 2c26 2695      		lsr r18
 6513 2c28 4CE1      		ldi r20,lo8(28)
 6514 2c2a 00C0      		rjmp .L618
 6515               	.LVL265:
 6516               	.L465:
4186:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
 6517               		.loc 1 4186 0
 6518 2c2c 81FF      		sbrs r24,1
 6519 2c2e 00C0      		rjmp .L467
4188:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
 6520               		.loc 1 4188 0
 6521 2c30 1091 0000 		lds r17,currentBank
 6522 2c34 84E2      		ldi r24,lo8(36)
 6523 2c36 189F      		mul r17,r24
 6524 2c38 F001      		movw r30,r0
 6525 2c3a 1124      		clr __zero_reg__
 6526 2c3c E050      		subi r30,lo8(-(bankStates))
 6527 2c3e F040      		sbci r31,hi8(-(bankStates))
 6528 2c40 868D      		ldd r24,Z+30
 6529 2c42 0091 0000 		lds r16,encoderValue
 6530 2c46 8017      		cp r24,r16
 6531 2c48 01F0      		breq .L466
 6532               	.LVL266:
 6533               	.LBB254:
 6534               	.LBB255:
3907:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6535               		.loc 1 3907 0
 6536 2c4a 068F      		std Z+30,r16
3908:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6537               		.loc 1 3908 0
 6538 2c4c 812F      		mov r24,r17
 6539 2c4e 0E94 0000 		call UpdateAdjustedSampleAddresses
 6540               	.LVL267:
 6541               	.LBE255:
 6542               	.LBE254:
4191:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
 6543               		.loc 1 4191 0
 6544 2c52 202F      		mov r18,r16
 6545 2c54 2695      		lsr r18
 6546 2c56 4DE1      		ldi r20,lo8(29)
 6547 2c58 00C0      		rjmp .L618
 6548               	.LVL268:
 6549               	.L467:
4194:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
 6550               		.loc 1 4194 0
 6551 2c5a 82FF      		sbrs r24,2
 6552 2c5c 00C0      		rjmp .L466
4196:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
 6553               		.loc 1 4196 0
 6554 2c5e 1091 0000 		lds r17,currentBank
 6555 2c62 94E2      		ldi r25,lo8(36)
 6556 2c64 199F      		mul r17,r25
 6557 2c66 F001      		movw r30,r0
 6558 2c68 1124      		clr __zero_reg__
 6559 2c6a E050      		subi r30,lo8(-(bankStates))
 6560 2c6c F040      		sbci r31,hi8(-(bankStates))
 6561 2c6e 878D      		ldd r24,Z+31
 6562 2c70 0091 0000 		lds r16,encoderValue
 6563 2c74 8017      		cp r24,r16
 6564 2c76 01F0      		breq .L466
 6565               	.LVL269:
 6566               	.LBB256:
 6567               	.LBB257:
3916:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 6568               		.loc 1 3916 0
 6569 2c78 078F      		std Z+31,r16
3917:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6570               		.loc 1 3917 0
 6571 2c7a 812F      		mov r24,r17
 6572 2c7c 0E94 0000 		call UpdateAdjustedSampleAddresses
 6573               	.LVL270:
 6574               	.LBE257:
 6575               	.LBE256:
4199:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
 6576               		.loc 1 4199 0
 6577 2c80 202F      		mov r18,r16
 6578 2c82 2695      		lsr r18
 6579 2c84 4EE1      		ldi r20,lo8(30)
 6580               	.LVL271:
 6581               	.L618:
 6582 2c86 64E0      		ldi r22,lo8(4)
 6583 2c88 812F      		mov r24,r17
 6584 2c8a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6585               	.LVL272:
 6586               	.L466:
 6587               	.LBE265:
4203:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
 6588               		.loc 1 4203 0
 6589 2c8e 8091 0000 		lds r24,newKeys
 6590               	.LBB266:
 6591 2c92 83FF      		sbrs r24,3
 6592 2c94 00C0      		rjmp .L446
4205:WTPA.c        **** 			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
 6593               		.loc 1 4205 0
 6594 2c96 8091 0000 		lds r24,sdCurrentSlot
 6595 2c9a 9091 0000 		lds r25,sdCurrentSlot+1
 6596 2c9e 0E94 0000 		call PlaySampleFromSd
 6597               	.LVL273:
 6598 2ca2 00C0      		rjmp .L446
 6599               	.L464:
4218:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
 6600               		.loc 1 4218 0
 6601 2ca4 8091 0000 		lds r24,newKeys
 6602 2ca8 80FF      		sbrs r24,0
 6603 2caa 00C0      		rjmp .L468
4220:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6604               		.loc 1 4220 0
 6605 2cac 1091 0000 		lds r17,currentBank
 6606 2cb0 E4E2      		ldi r30,lo8(36)
 6607 2cb2 1E9F      		mul r17,r30
 6608 2cb4 6001      		movw r12,r0
 6609 2cb6 1124      		clr __zero_reg__
 6610 2cb8 80E0      		ldi r24,lo8(bankStates)
 6611 2cba 90E0      		ldi r25,hi8(bankStates)
 6612 2cbc C80E      		add r12,r24
 6613 2cbe D91E      		adc r13,r25
 6614 2cc0 F601      		movw r30,r12
 6615 2cc2 8081      		ld r24,Z
4222:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6616               		.loc 1 4222 0
 6617 2cc4 40E0      		ldi r20,0
 6618 2cc6 50E0      		ldi r21,0
 6619 2cc8 61E0      		ldi r22,lo8(1)
4220:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6620               		.loc 1 4220 0
 6621 2cca 8330      		cpi r24,lo8(3)
 6622 2ccc 01F4      		brne .L469
4222:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6623               		.loc 1 4222 0
 6624 2cce 812F      		mov r24,r17
 6625 2cd0 0E94 0000 		call StartPlayback
 6626               	.LVL274:
4223:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6627               		.loc 1 4223 0
 6628 2cd4 F601      		movw r30,r12
 6629 2cd6 1182      		std Z+1,__zero_reg__
4224:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6630               		.loc 1 4224 0
 6631 2cd8 20E4      		ldi r18,lo8(64)
 6632 2cda 40E3      		ldi r20,lo8(48)
 6633 2cdc 61E0      		ldi r22,lo8(1)
 6634 2cde 00C0      		rjmp .L629
 6635               	.L469:
4228:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
 6636               		.loc 1 4228 0
 6637 2ce0 812F      		mov r24,r17
 6638 2ce2 0E94 0000 		call StartRecording
 6639               	.LVL275:
4229:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
 6640               		.loc 1 4229 0
 6641 2ce6 20E3      		ldi r18,lo8(48)
 6642 2ce8 43E0      		ldi r20,lo8(3)
 6643 2cea 64E0      		ldi r22,lo8(4)
 6644               	.L629:
 6645 2cec 812F      		mov r24,r17
 6646 2cee 00C0      		rjmp .L619
 6647               	.L468:
4232:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
 6648               		.loc 1 4232 0
 6649 2cf0 81FF      		sbrs r24,1
 6650 2cf2 00C0      		rjmp .L470
4234:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
 6651               		.loc 1 4234 0
 6652 2cf4 F090 0000 		lds r15,currentBank
 6653 2cf8 F4E2      		ldi r31,lo8(36)
 6654 2cfa FF9E      		mul r15,r31
 6655 2cfc 6001      		movw r12,r0
 6656 2cfe 1124      		clr __zero_reg__
 6657 2d00 80E0      		ldi r24,lo8(bankStates)
 6658 2d02 90E0      		ldi r25,hi8(bankStates)
 6659 2d04 C80E      		add r12,r24
 6660 2d06 D91E      		adc r13,r25
 6661 2d08 F601      		movw r30,r12
 6662 2d0a 8081      		ld r24,Z
 6663 2d0c 8530      		cpi r24,lo8(5)
 6664 2d0e 01F4      		brne .L471
4236:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
 6665               		.loc 1 4236 0
 6666 2d10 40E0      		ldi r20,0
 6667 2d12 50E0      		ldi r21,0
 6668 2d14 61E0      		ldi r22,lo8(1)
 6669 2d16 8F2D      		mov r24,r15
 6670 2d18 0E94 0000 		call ContinuePlayback
 6671               	.LVL276:
4237:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6672               		.loc 1 4237 0
 6673 2d1c F601      		movw r30,r12
 6674 2d1e 1182      		std Z+1,__zero_reg__
4238:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
 6675               		.loc 1 4238 0
 6676 2d20 20E0      		ldi r18,0
 6677 2d22 00C0      		rjmp .L628
 6678               	.L471:
4242:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
 6679               		.loc 1 4242 0
 6680 2d24 F601      		movw r30,r12
 6681 2d26 0189      		ldd r16,Z+17
 6682 2d28 1289      		ldd r17,Z+18
 6683 2d2a 2389      		ldd r18,Z+19
 6684 2d2c 3489      		ldd r19,Z+20
 6685 2d2e 4585      		ldd r20,Z+13
 6686 2d30 5685      		ldd r21,Z+14
 6687 2d32 6785      		ldd r22,Z+15
 6688 2d34 7089      		ldd r23,Z+16
 6689 2d36 0417      		cp r16,r20
 6690 2d38 1507      		cpc r17,r21
 6691 2d3a 2607      		cpc r18,r22
 6692 2d3c 3707      		cpc r19,r23
 6693 2d3e 01F4      		brne .+2
 6694 2d40 00C0      		rjmp .L446
4244:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
 6695               		.loc 1 4244 0
 6696 2d42 40E0      		ldi r20,0
 6697 2d44 50E0      		ldi r21,0
 6698 2d46 61E0      		ldi r22,lo8(1)
 6699 2d48 8F2D      		mov r24,r15
 6700 2d4a 0E94 0000 		call StartOverdub
 6701               	.LVL277:
4245:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
 6702               		.loc 1 4245 0
 6703 2d4e 20E3      		ldi r18,lo8(48)
 6704               	.L628:
 6705 2d50 49E0      		ldi r20,lo8(9)
 6706 2d52 64E0      		ldi r22,lo8(4)
 6707 2d54 00C0      		rjmp .L620
 6708               	.L470:
4249:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
 6709               		.loc 1 4249 0
 6710 2d56 82FF      		sbrs r24,2
 6711 2d58 00C0      		rjmp .L472
4251:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6712               		.loc 1 4251 0
 6713 2d5a F090 0000 		lds r15,currentBank
 6714 2d5e F4E2      		ldi r31,lo8(36)
 6715 2d60 FF9E      		mul r15,r31
 6716 2d62 6001      		movw r12,r0
 6717 2d64 1124      		clr __zero_reg__
 6718 2d66 80E0      		ldi r24,lo8(bankStates)
 6719 2d68 90E0      		ldi r25,hi8(bankStates)
 6720 2d6a C80E      		add r12,r24
 6721 2d6c D91E      		adc r13,r25
 6722 2d6e F601      		movw r30,r12
 6723 2d70 0189      		ldd r16,Z+17
 6724 2d72 1289      		ldd r17,Z+18
 6725 2d74 2389      		ldd r18,Z+19
 6726 2d76 3489      		ldd r19,Z+20
 6727 2d78 4585      		ldd r20,Z+13
 6728 2d7a 5685      		ldd r21,Z+14
 6729 2d7c 6785      		ldd r22,Z+15
 6730 2d7e 7089      		ldd r23,Z+16
 6731 2d80 0417      		cp r16,r20
 6732 2d82 1507      		cpc r17,r21
 6733 2d84 2607      		cpc r18,r22
 6734 2d86 3707      		cpc r19,r23
 6735 2d88 01F4      		brne .+2
 6736 2d8a 00C0      		rjmp .L446
4253:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6737               		.loc 1 4253 0
 6738 2d8c 40E0      		ldi r20,0
 6739 2d8e 50E0      		ldi r21,0
 6740 2d90 61E0      		ldi r22,lo8(1)
 6741 2d92 8F2D      		mov r24,r15
 6742 2d94 0E94 0000 		call StartPlayback
 6743               	.LVL278:
4254:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6744               		.loc 1 4254 0
 6745 2d98 F601      		movw r30,r12
 6746 2d9a 1182      		std Z+1,__zero_reg__
 6747 2d9c 00C0      		rjmp .L621
 6748               	.L472:
4258:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
 6749               		.loc 1 4258 0
 6750 2d9e 83FF      		sbrs r24,3
 6751 2da0 00C0      		rjmp .L473
4260:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6752               		.loc 1 4260 0
 6753 2da2 F090 0000 		lds r15,currentBank
 6754 2da6 F4E2      		ldi r31,lo8(36)
 6755 2da8 FF9E      		mul r15,r31
 6756 2daa 6001      		movw r12,r0
 6757 2dac 1124      		clr __zero_reg__
 6758 2dae 80E0      		ldi r24,lo8(bankStates)
 6759 2db0 90E0      		ldi r25,hi8(bankStates)
 6760 2db2 C80E      		add r12,r24
 6761 2db4 D91E      		adc r13,r25
 6762 2db6 F601      		movw r30,r12
 6763 2db8 0189      		ldd r16,Z+17
 6764 2dba 1289      		ldd r17,Z+18
 6765 2dbc 2389      		ldd r18,Z+19
 6766 2dbe 3489      		ldd r19,Z+20
 6767 2dc0 4585      		ldd r20,Z+13
 6768 2dc2 5685      		ldd r21,Z+14
 6769 2dc4 6785      		ldd r22,Z+15
 6770 2dc6 7089      		ldd r23,Z+16
 6771 2dc8 0417      		cp r16,r20
 6772 2dca 1507      		cpc r17,r21
 6773 2dcc 2607      		cpc r18,r22
 6774 2dce 3707      		cpc r19,r23
 6775 2dd0 01F4      		brne .+2
 6776 2dd2 00C0      		rjmp .L446
4262:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
 6777               		.loc 1 4262 0
 6778 2dd4 40E0      		ldi r20,0
 6779 2dd6 50E0      		ldi r21,0
 6780 2dd8 61E0      		ldi r22,lo8(1)
 6781 2dda 8F2D      		mov r24,r15
 6782 2ddc 0E94 0000 		call StartPlayback
 6783               	.LVL279:
4263:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
 6784               		.loc 1 4263 0
 6785 2de0 81E0      		ldi r24,lo8(1)
 6786 2de2 F601      		movw r30,r12
 6787 2de4 8183      		std Z+1,r24
 6788 2de6 00C0      		rjmp .L621
 6789               	.L473:
4267:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
 6790               		.loc 1 4267 0
 6791 2de8 84FF      		sbrs r24,4
 6792 2dea 00C0      		rjmp .L474
4269:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
 6793               		.loc 1 4269 0
 6794 2dec F090 0000 		lds r15,currentBank
 6795 2df0 24E2      		ldi r18,lo8(36)
 6796 2df2 F29E      		mul r15,r18
 6797 2df4 F001      		movw r30,r0
 6798 2df6 1124      		clr __zero_reg__
 6799 2df8 E050      		subi r30,lo8(-(bankStates))
 6800 2dfa F040      		sbci r31,hi8(-(bankStates))
 6801 2dfc 8081      		ld r24,Z
 6802 2dfe 8111      		cpse r24,__zero_reg__
 6803 2e00 00C0      		rjmp .L475
4271:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 6804               		.loc 1 4271 0
 6805 2e02 0189      		ldd r16,Z+17
 6806 2e04 1289      		ldd r17,Z+18
 6807 2e06 2389      		ldd r18,Z+19
 6808 2e08 3489      		ldd r19,Z+20
 6809 2e0a 4585      		ldd r20,Z+13
 6810 2e0c 5685      		ldd r21,Z+14
 6811 2e0e 6785      		ldd r22,Z+15
 6812 2e10 7089      		ldd r23,Z+16
 6813 2e12 0417      		cp r16,r20
 6814 2e14 1507      		cpc r17,r21
 6815 2e16 2607      		cpc r18,r22
 6816 2e18 3707      		cpc r19,r23
 6817 2e1a 01F0      		breq .L446
4273:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
 6818               		.loc 1 4273 0
 6819 2e1c 40E0      		ldi r20,0
 6820 2e1e 50E0      		ldi r21,0
 6821 2e20 61E0      		ldi r22,lo8(1)
 6822 2e22 8F2D      		mov r24,r15
 6823 2e24 0E94 0000 		call ContinuePlayback
 6824               	.LVL280:
 6825               	.L621:
4274:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
 6826               		.loc 1 4274 0
 6827 2e28 20E4      		ldi r18,lo8(64)
 6828 2e2a 40E3      		ldi r20,lo8(48)
 6829 2e2c 61E0      		ldi r22,lo8(1)
 6830               	.L620:
 6831 2e2e 8F2D      		mov r24,r15
 6832               	.L619:
 6833 2e30 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6834               	.LVL281:
 6835 2e34 00C0      		rjmp .L446
 6836               	.L475:
4279:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
 6837               		.loc 1 4279 0
 6838 2e36 1082      		st Z,__zero_reg__
4280:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
 6839               		.loc 1 4280 0
 6840 2e38 1286      		std Z+10,__zero_reg__
4281:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
 6841               		.loc 1 4281 0
 6842 2e3a 20E0      		ldi r18,0
 6843 2e3c 40E3      		ldi r20,lo8(48)
 6844 2e3e 62E0      		ldi r22,lo8(2)
 6845 2e40 00C0      		rjmp .L620
 6846               	.L474:
4285:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
 6847               		.loc 1 4285 0
 6848 2e42 85FF      		sbrs r24,5
 6849 2e44 00C0      		rjmp .L446
4287:WTPA.c        **** 			currentBank++;
 6850               		.loc 1 4287 0
 6851 2e46 8091 0000 		lds r24,currentBank
 6852 2e4a 8F5F      		subi r24,lo8(-(1))
 6853 2e4c 8093 0000 		sts currentBank,r24
4288:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
 6854               		.loc 1 4288 0
 6855 2e50 8230      		cpi r24,lo8(2)
 6856 2e52 00F0      		brlo .L446
4290:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
 6857               		.loc 1 4290 0
 6858 2e54 1092 0000 		sts currentBank,__zero_reg__
 6859               	.L446:
 6860               	.LBE266:
 6861               	.LBE248:
4323:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
 6862               		.loc 1 4323 0
 6863 2e58 8091 0000 		lds r24,midiMessagesInIncomingFifo
 6864 2e5c 8823      		tst r24
 6865 2e5e 01F4      		brne .+2
 6866 2e60 00C0      		rjmp .L442
4325:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
 6867               		.loc 1 4325 0
 6868 2e62 80E0      		ldi r24,lo8(currentMidiMessage.2230)
 6869 2e64 90E0      		ldi r25,hi8(currentMidiMessage.2230)
 6870 2e66 0E94 0000 		call GetMidiMessageFromIncomingFifo
 6871               	.LVL282:
4332:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
 6872               		.loc 1 4332 0
 6873 2e6a 8091 0000 		lds r24,currentMidiMessage.2230+1
 6874 2e6e 8230      		cpi r24,lo8(2)
 6875 2e70 01F4      		brne .L477
4334:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6876               		.loc 1 4334 0
 6877 2e72 E091 0000 		lds r30,currentMidiMessage.2230
 6878 2e76 8E2F      		mov r24,r30
 6879 2e78 90E0      		ldi r25,0
 6880 2e7a 44E2      		ldi r20,lo8(36)
 6881 2e7c E49F      		mul r30,r20
 6882 2e7e F001      		movw r30,r0
 6883 2e80 1124      		clr __zero_reg__
 6884 2e82 E050      		subi r30,lo8(-(bankStates))
 6885 2e84 F040      		sbci r31,hi8(-(bankStates))
 6886 2e86 2081      		ld r18,Z
 6887 2e88 2430      		cpi r18,lo8(4)
 6888 2e8a 01F0      		breq .L478
4334:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6889               		.loc 1 4334 0 is_stmt 0 discriminator 1
 6890 2e8c 2081      		ld r18,Z
 6891 2e8e 2230      		cpi r18,lo8(2)
 6892 2e90 01F0      		breq .+2
 6893 2e92 00C0      		rjmp .L442
 6894               	.L478:
4336:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
 6895               		.loc 1 4336 0 is_stmt 1
 6896 2e94 FC01      		movw r30,r24
 6897 2e96 E050      		subi r30,lo8(-(currentNoteOn.2231))
 6898 2e98 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 6899 2e9a 3091 0000 		lds r19,currentMidiMessage.2230+2
 6900 2e9e 2081      		ld r18,Z
 6901 2ea0 3213      		cpse r19,r18
 6902 2ea2 00C0      		rjmp .L442
4338:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
 6903               		.loc 1 4338 0
 6904 2ea4 24E2      		ldi r18,lo8(36)
 6905 2ea6 289F      		mul r18,r24
 6906 2ea8 F001      		movw r30,r0
 6907 2eaa 299F      		mul r18,r25
 6908 2eac F00D      		add r31,r0
 6909 2eae 1124      		clr __zero_reg__
 6910 2eb0 E050      		subi r30,lo8(-(bankStates))
 6911 2eb2 F040      		sbci r31,hi8(-(bankStates))
 6912 2eb4 00C0      		rjmp .L624
 6913               	.L477:
4343:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
 6914               		.loc 1 4343 0
 6915 2eb6 8130      		cpi r24,lo8(1)
 6916 2eb8 01F0      		breq .+2
 6917 2eba 00C0      		rjmp .L479
4345:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
 6918               		.loc 1 4345 0
 6919 2ebc A091 0000 		lds r26,currentMidiMessage.2230
 6920 2ec0 2A2F      		mov r18,r26
 6921 2ec2 30E0      		ldi r19,0
 6922 2ec4 8091 0000 		lds r24,currentMidiMessage.2230+2
 6923 2ec8 F901      		movw r30,r18
 6924 2eca E050      		subi r30,lo8(-(currentNoteOn.2231))
 6925 2ecc F040      		sbci r31,hi8(-(currentNoteOn.2231))
 6926 2ece 8083      		st Z,r24
4347:WTPA.c        **** 				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
 6927               		.loc 1 4347 0
 6928 2ed0 94E2      		ldi r25,lo8(36)
 6929 2ed2 929F      		mul r25,r18
 6930 2ed4 F001      		movw r30,r0
 6931 2ed6 939F      		mul r25,r19
 6932 2ed8 F00D      		add r31,r0
 6933 2eda 1124      		clr __zero_reg__
 6934 2edc E050      		subi r30,lo8(-(bankStates))
 6935 2ede F040      		sbci r31,hi8(-(bankStates))
 6936 2ee0 9681      		ldd r25,Z+6
 6937 2ee2 9923      		tst r25
 6938 2ee4 01F0      		breq .L480
 6939               	.LVL283:
 6940               	.LBB267:
 6941               	.LBB268:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6942               		.loc 1 3334 0
 6943 2ee6 6CE0      		ldi r22,lo8(12)
 6944 2ee8 0E94 0000 		call __udivmodqi4
 6945               	.LVL284:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6946               		.loc 1 3336 0
 6947 2eec E92F      		mov r30,r25
 6948 2eee F0E0      		ldi r31,0
 6949 2ef0 EE0F      		lsl r30
 6950 2ef2 FF1F      		rol r31
 6951 2ef4 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6952 2ef6 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6953 2ef8 4081      		ld r20,Z
 6954 2efa 5181      		ldd r21,Z+1
 6955 2efc 00C0      		rjmp 2f
 6956               		1:
 6957 2efe 5695      		lsr r21
 6958 2f00 4795      		ror r20
 6959               		2:
 6960 2f02 8A95      		dec r24
 6961 2f04 02F4      		brpl 1b
 6962               	.LBE268:
 6963               	.LBE267:
4349:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
 6964               		.loc 1 4349 0
 6965 2f06 62E0      		ldi r22,lo8(2)
 6966 2f08 8A2F      		mov r24,r26
 6967               	.LVL285:
 6968 2f0a 0E94 0000 		call StartRealtime
 6969               	.LVL286:
 6970 2f0e 00C0      		rjmp .L442
 6971               	.L480:
4353:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
 6972               		.loc 1 4353 0
 6973 2f10 0189      		ldd r16,Z+17
 6974 2f12 1289      		ldd r17,Z+18
 6975 2f14 2389      		ldd r18,Z+19
 6976 2f16 3489      		ldd r19,Z+20
 6977 2f18 4585      		ldd r20,Z+13
 6978 2f1a 5685      		ldd r21,Z+14
 6979 2f1c 6785      		ldd r22,Z+15
 6980 2f1e 7089      		ldd r23,Z+16
 6981 2f20 0417      		cp r16,r20
 6982 2f22 1507      		cpc r17,r21
 6983 2f24 2607      		cpc r18,r22
 6984 2f26 3707      		cpc r19,r23
 6985 2f28 01F4      		brne .+2
 6986 2f2a 00C0      		rjmp .L442
 6987               	.LVL287:
 6988               	.LBB269:
 6989               	.LBB270:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6990               		.loc 1 3334 0
 6991 2f2c 6CE0      		ldi r22,lo8(12)
 6992 2f2e 0E94 0000 		call __udivmodqi4
 6993               	.LVL288:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6994               		.loc 1 3336 0
 6995 2f32 E92F      		mov r30,r25
 6996 2f34 F0E0      		ldi r31,0
 6997 2f36 EE0F      		lsl r30
 6998 2f38 FF1F      		rol r31
 6999 2f3a E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7000 2f3c F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7001 2f3e 4081      		ld r20,Z
 7002 2f40 5181      		ldd r21,Z+1
 7003 2f42 00C0      		rjmp 2f
 7004               		1:
 7005 2f44 5695      		lsr r21
 7006 2f46 4795      		ror r20
 7007               		2:
 7008 2f48 8A95      		dec r24
 7009 2f4a 02F4      		brpl 1b
 7010               	.LBE270:
 7011               	.LBE269:
4355:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
 7012               		.loc 1 4355 0
 7013 2f4c 62E0      		ldi r22,lo8(2)
 7014 2f4e 8A2F      		mov r24,r26
 7015               	.LVL289:
 7016 2f50 0E94 0000 		call StartPlayback
 7017               	.LVL290:
 7018 2f54 00C0      		rjmp .L442
 7019               	.L479:
4360:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
 7020               		.loc 1 4360 0
 7021 2f56 8430      		cpi r24,lo8(4)
 7022 2f58 01F0      		breq .+2
 7023 2f5a 00C0      		rjmp .L481
4362:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
 7024               		.loc 1 4362 0
 7025 2f5c 8091 0000 		lds r24,currentMidiMessage.2230+2
 7026 2f60 90E0      		ldi r25,0
 7027 2f62 FC01      		movw r30,r24
 7028 2f64 3397      		sbiw r30,3
 7029 2f66 EC31      		cpi r30,28
 7030 2f68 F105      		cpc r31,__zero_reg__
 7031 2f6a 00F0      		brlo .+2
 7032 2f6c 00C0      		rjmp .L442
 7033 2f6e E050      		subi r30,lo8(-(gs(.L501)))
 7034 2f70 F040      		sbci r31,hi8(-(gs(.L501)))
 7035 2f72 0C94 0000 		jmp __tablejump2__
 7036               		.section	.progmem.gcc_sw_table,"a",@progbits
 7037               		.p2align	1
 7038               	.L501:
 7039 0000 0000      		.word gs(.L482)
 7040 0002 0000      		.word gs(.L442)
 7041 0004 0000      		.word gs(.L442)
 7042 0006 0000      		.word gs(.L442)
 7043 0008 0000      		.word gs(.L442)
 7044 000a 0000      		.word gs(.L442)
 7045 000c 0000      		.word gs(.L483)
 7046 000e 0000      		.word gs(.L442)
 7047 0010 0000      		.word gs(.L442)
 7048 0012 0000      		.word gs(.L442)
 7049 0014 0000      		.word gs(.L442)
 7050 0016 0000      		.word gs(.L484)
 7051 0018 0000      		.word gs(.L485)
 7052 001a 0000      		.word gs(.L486)
 7053 001c 0000      		.word gs(.L487)
 7054 001e 0000      		.word gs(.L488)
 7055 0020 0000      		.word gs(.L489)
 7056 0022 0000      		.word gs(.L490)
 7057 0024 0000      		.word gs(.L491)
 7058 0026 0000      		.word gs(.L492)
 7059 0028 0000      		.word gs(.L493)
 7060 002a 0000      		.word gs(.L494)
 7061 002c 0000      		.word gs(.L495)
 7062 002e 0000      		.word gs(.L496)
 7063 0030 0000      		.word gs(.L497)
 7064 0032 0000      		.word gs(.L498)
 7065 0034 0000      		.word gs(.L499)
 7066 0036 0000      		.word gs(.L500)
 7067               		.text
 7068               	.L482:
4365:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7069               		.loc 1 4365 0
 7070 2f76 9091 0000 		lds r25,currentMidiMessage.2230+3
 7071 2f7a 8091 0000 		lds r24,currentMidiMessage.2230
 7072 2f7e 9923      		tst r25
 7073 2f80 01F0      		breq .L502
4367:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
 7074               		.loc 1 4367 0
 7075 2f82 A82F      		mov r26,r24
 7076 2f84 B0E0      		ldi r27,0
 7077 2f86 AA0F      		lsl r26
 7078 2f88 BB1F      		rol r27
 7079 2f8a A050      		subi r26,lo8(-(theMidiRecordRate))
 7080 2f8c B040      		sbci r27,hi8(-(theMidiRecordRate))
 7081 2f8e 4D91      		ld r20,X+
 7082 2f90 5C91      		ld r21,X
 7083 2f92 62E0      		ldi r22,lo8(2)
 7084 2f94 0E94 0000 		call StartRecording
 7085               	.LVL291:
4368:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll defa
 7086               		.loc 1 4368 0
 7087 2f98 E091 0000 		lds r30,currentMidiMessage.2230
 7088 2f9c 84E2      		ldi r24,lo8(36)
 7089 2f9e E89F      		mul r30,r24
 7090 2fa0 F001      		movw r30,r0
 7091 2fa2 1124      		clr __zero_reg__
 7092 2fa4 00C0      		rjmp .L630
 7093               	.L502:
4370:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
 7094               		.loc 1 4370 0
 7095 2fa6 94E2      		ldi r25,lo8(36)
 7096 2fa8 899F      		mul r24,r25
 7097 2faa F001      		movw r30,r0
 7098 2fac 1124      		clr __zero_reg__
 7099 2fae E050      		subi r30,lo8(-(bankStates))
 7100 2fb0 F040      		sbci r31,hi8(-(bankStates))
 7101 2fb2 8081      		ld r24,Z
 7102 2fb4 8330      		cpi r24,lo8(3)
 7103 2fb6 01F0      		breq .+2
 7104 2fb8 00C0      		rjmp .L442
 7105               	.L624:
4372:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 7106               		.loc 1 4372 0
 7107 2fba 1082      		st Z,__zero_reg__
4373:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 7108               		.loc 1 4373 0
 7109 2fbc 1286      		std Z+10,__zero_reg__
 7110 2fbe 00C0      		rjmp .L442
 7111               	.L483:
4378:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7112               		.loc 1 4378 0
 7113 2fc0 9091 0000 		lds r25,currentMidiMessage.2230+3
 7114 2fc4 8091 0000 		lds r24,currentMidiMessage.2230
 7115 2fc8 9923      		tst r25
 7116 2fca 01F0      		breq .L503
4380:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
 7117               		.loc 1 4380 0
 7118 2fcc A82F      		mov r26,r24
 7119 2fce B0E0      		ldi r27,0
 7120 2fd0 24E2      		ldi r18,lo8(36)
 7121 2fd2 F22E      		mov r15,r18
 7122 2fd4 FA9E      		mul r15,r26
 7123 2fd6 F001      		movw r30,r0
 7124 2fd8 FB9E      		mul r15,r27
 7125 2fda F00D      		add r31,r0
 7126 2fdc 1124      		clr __zero_reg__
 7127 2fde E050      		subi r30,lo8(-(bankStates))
 7128 2fe0 F040      		sbci r31,hi8(-(bankStates))
 7129 2fe2 0189      		ldd r16,Z+17
 7130 2fe4 1289      		ldd r17,Z+18
 7131 2fe6 2389      		ldd r18,Z+19
 7132 2fe8 3489      		ldd r19,Z+20
 7133 2fea 4585      		ldd r20,Z+13
 7134 2fec 5685      		ldd r21,Z+14
 7135 2fee 6785      		ldd r22,Z+15
 7136 2ff0 7089      		ldd r23,Z+16
 7137 2ff2 0417      		cp r16,r20
 7138 2ff4 1507      		cpc r17,r21
 7139 2ff6 2607      		cpc r18,r22
 7140 2ff8 3707      		cpc r19,r23
 7141 2ffa 01F4      		brne .+2
 7142 2ffc 00C0      		rjmp .L442
4382:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
 7143               		.loc 1 4382 0
 7144 2ffe A050      		subi r26,lo8(-(currentNoteOn.2231))
 7145 3000 B040      		sbci r27,hi8(-(currentNoteOn.2231))
 7146 3002 4C91      		ld r20,X
 7147 3004 50E0      		ldi r21,0
 7148 3006 62E0      		ldi r22,lo8(2)
 7149 3008 0E94 0000 		call StartOverdub
 7150               	.LVL292:
4383:WTPA.c        **** 							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll defaul
 7151               		.loc 1 4383 0
 7152 300c E091 0000 		lds r30,currentMidiMessage.2230
 7153 3010 FE9E      		mul r15,r30
 7154 3012 F001      		movw r30,r0
 7155 3014 1124      		clr __zero_reg__
 7156               	.L630:
 7157 3016 E050      		subi r30,lo8(-(bankStates))
 7158 3018 F040      		sbci r31,hi8(-(bankStates))
 7159 301a 00C0      		rjmp .L625
 7160               	.L503:
4386:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
 7161               		.loc 1 4386 0
 7162 301c 282F      		mov r18,r24
 7163 301e 30E0      		ldi r19,0
 7164 3020 44E2      		ldi r20,lo8(36)
 7165 3022 849F      		mul r24,r20
 7166 3024 F001      		movw r30,r0
 7167 3026 1124      		clr __zero_reg__
 7168 3028 E050      		subi r30,lo8(-(bankStates))
 7169 302a F040      		sbci r31,hi8(-(bankStates))
 7170 302c 9081      		ld r25,Z
 7171 302e 9530      		cpi r25,lo8(5)
 7172 3030 01F0      		breq .+2
 7173 3032 00C0      		rjmp .L442
4388:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
 7174               		.loc 1 4388 0
 7175 3034 F901      		movw r30,r18
 7176 3036 E050      		subi r30,lo8(-(currentNoteOn.2231))
 7177 3038 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 7178 303a 4081      		ld r20,Z
 7179 303c 50E0      		ldi r21,0
 7180 303e 62E0      		ldi r22,lo8(2)
 7181 3040 0E94 0000 		call ContinuePlayback
 7182               	.LVL293:
 7183 3044 00C0      		rjmp .L442
 7184               	.L484:
4393:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7185               		.loc 1 4393 0
 7186 3046 9091 0000 		lds r25,currentMidiMessage.2230+3
 7187 304a 8091 0000 		lds r24,currentMidiMessage.2230
 7188 304e 9923      		tst r25
 7189 3050 01F0      		breq .L504
4395:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
 7190               		.loc 1 4395 0
 7191 3052 A82F      		mov r26,r24
 7192 3054 B0E0      		ldi r27,0
 7193 3056 AA0F      		lsl r26
 7194 3058 BB1F      		rol r27
 7195 305a A050      		subi r26,lo8(-(theMidiRecordRate))
 7196 305c B040      		sbci r27,hi8(-(theMidiRecordRate))
 7197 305e 4D91      		ld r20,X+
 7198 3060 5C91      		ld r21,X
 7199 3062 62E0      		ldi r22,lo8(2)
 7200 3064 0E94 0000 		call StartRealtime
 7201               	.LVL294:
4396:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so th
 7202               		.loc 1 4396 0
 7203 3068 E091 0000 		lds r30,currentMidiMessage.2230
 7204 306c 84E2      		ldi r24,lo8(36)
 7205 306e E89F      		mul r30,r24
 7206 3070 F001      		movw r30,r0
 7207 3072 1124      		clr __zero_reg__
 7208 3074 E050      		subi r30,lo8(-(bankStates))
 7209 3076 F040      		sbci r31,hi8(-(bankStates))
 7210 3078 81E0      		ldi r24,lo8(1)
 7211 307a 8683      		std Z+6,r24
 7212 307c 00C0      		rjmp .L442
 7213               	.L504:
4398:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
 7214               		.loc 1 4398 0
 7215 307e 94E2      		ldi r25,lo8(36)
 7216 3080 899F      		mul r24,r25
 7217 3082 F001      		movw r30,r0
 7218 3084 1124      		clr __zero_reg__
 7219 3086 E050      		subi r30,lo8(-(bankStates))
 7220 3088 F040      		sbci r31,hi8(-(bankStates))
 7221 308a 8081      		ld r24,Z
 7222 308c 8230      		cpi r24,lo8(2)
 7223 308e 01F0      		breq .+2
 7224 3090 00C0      		rjmp .L442
4400:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 7225               		.loc 1 4400 0
 7226 3092 1082      		st Z,__zero_reg__
4401:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 7227               		.loc 1 4401 0
 7228 3094 1286      		std Z+10,__zero_reg__
 7229               	.L625:
4402:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playba
 7230               		.loc 1 4402 0
 7231 3096 1682      		std Z+6,__zero_reg__
 7232 3098 00C0      		rjmp .L442
 7233               	.L485:
4408:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7234               		.loc 1 4408 0
 7235 309a 8091 0000 		lds r24,currentMidiMessage.2230+3
 7236 309e E091 0000 		lds r30,currentMidiMessage.2230
 7237 30a2 8823      		tst r24
 7238 30a4 01F0      		breq .L505
4410:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 7239               		.loc 1 4410 0
 7240 30a6 24E2      		ldi r18,lo8(36)
 7241 30a8 E29F      		mul r30,r18
 7242 30aa F001      		movw r30,r0
 7243 30ac 1124      		clr __zero_reg__
 7244 30ae E050      		subi r30,lo8(-(bankStates))
 7245 30b0 F040      		sbci r31,hi8(-(bankStates))
 7246 30b2 1182      		std Z+1,__zero_reg__
 7247 30b4 00C0      		rjmp .L442
 7248               	.L505:
4414:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
 7249               		.loc 1 4414 0
 7250 30b6 44E2      		ldi r20,lo8(36)
 7251 30b8 E49F      		mul r30,r20
 7252 30ba F001      		movw r30,r0
 7253 30bc 1124      		clr __zero_reg__
 7254 30be E050      		subi r30,lo8(-(bankStates))
 7255 30c0 F040      		sbci r31,hi8(-(bankStates))
 7256 30c2 81E0      		ldi r24,lo8(1)
 7257 30c4 8183      		std Z+1,r24
 7258 30c6 00C0      		rjmp .L442
 7259               	.L486:
4419:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7260               		.loc 1 4419 0
 7261 30c8 8091 0000 		lds r24,currentMidiMessage.2230+3
 7262 30cc E091 0000 		lds r30,currentMidiMessage.2230
 7263 30d0 8823      		tst r24
 7264 30d2 01F0      		breq .L506
4421:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
 7265               		.loc 1 4421 0
 7266 30d4 84E2      		ldi r24,lo8(36)
 7267 30d6 E89F      		mul r30,r24
 7268 30d8 F001      		movw r30,r0
 7269 30da 1124      		clr __zero_reg__
 7270 30dc E050      		subi r30,lo8(-(bankStates))
 7271 30de F040      		sbci r31,hi8(-(bankStates))
 7272 30e0 81E0      		ldi r24,lo8(1)
 7273 30e2 8283      		std Z+2,r24
 7274 30e4 00C0      		rjmp .L442
 7275               	.L506:
4425:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 7276               		.loc 1 4425 0
 7277 30e6 94E2      		ldi r25,lo8(36)
 7278 30e8 E99F      		mul r30,r25
 7279 30ea F001      		movw r30,r0
 7280 30ec 1124      		clr __zero_reg__
 7281 30ee E050      		subi r30,lo8(-(bankStates))
 7282 30f0 F040      		sbci r31,hi8(-(bankStates))
 7283 30f2 1282      		std Z+2,__zero_reg__
 7284 30f4 00C0      		rjmp .L442
 7285               	.L487:
4430:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7286               		.loc 1 4430 0
 7287 30f6 8091 0000 		lds r24,currentMidiMessage.2230+3
 7288 30fa E091 0000 		lds r30,currentMidiMessage.2230
 7289 30fe 8823      		tst r24
 7290 3100 01F0      		breq .L507
4432:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
 7291               		.loc 1 4432 0
 7292 3102 24E2      		ldi r18,lo8(36)
 7293 3104 E29F      		mul r30,r18
 7294 3106 F001      		movw r30,r0
 7295 3108 1124      		clr __zero_reg__
 7296 310a E050      		subi r30,lo8(-(bankStates))
 7297 310c F040      		sbci r31,hi8(-(bankStates))
 7298 310e 81E0      		ldi r24,lo8(1)
 7299 3110 8383      		std Z+3,r24
 7300 3112 00C0      		rjmp .L508
 7301               	.L507:
4436:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 7302               		.loc 1 4436 0
 7303 3114 44E2      		ldi r20,lo8(36)
 7304 3116 E49F      		mul r30,r20
 7305 3118 F001      		movw r30,r0
 7306 311a 1124      		clr __zero_reg__
 7307 311c E050      		subi r30,lo8(-(bankStates))
 7308 311e F040      		sbci r31,hi8(-(bankStates))
 7309 3120 1382      		std Z+3,__zero_reg__
 7310               	.L508:
4438:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
 7311               		.loc 1 4438 0
 7312 3122 8091 0000 		lds r24,currentMidiMessage.2230
 7313 3126 00C0      		rjmp .L626
 7314               	.L488:
4442:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 7315               		.loc 1 4442 0
 7316 3128 E091 0000 		lds r30,currentMidiMessage.2230
 7317 312c 84E2      		ldi r24,lo8(36)
 7318 312e E89F      		mul r30,r24
 7319 3130 F001      		movw r30,r0
 7320 3132 1124      		clr __zero_reg__
 7321 3134 E050      		subi r30,lo8(-(bankStates))
 7322 3136 F040      		sbci r31,hi8(-(bankStates))
 7323 3138 1182      		std Z+1,__zero_reg__
4443:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
 7324               		.loc 1 4443 0
 7325 313a 1186      		std Z+9,__zero_reg__
4444:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
 7326               		.loc 1 4444 0
 7327 313c 1086      		std Z+8,__zero_reg__
4445:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
 7328               		.loc 1 4445 0
 7329 313e 1782      		std Z+7,__zero_reg__
4446:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 7330               		.loc 1 4446 0
 7331 3140 1282      		std Z+2,__zero_reg__
4447:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 7332               		.loc 1 4447 0
 7333 3142 81E0      		ldi r24,lo8(1)
 7334 3144 8483      		std Z+4,r24
4448:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 7335               		.loc 1 4448 0
 7336 3146 1382      		std Z+3,__zero_reg__
4449:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 7337               		.loc 1 4449 0
 7338 3148 8483      		std Z+4,r24
4450:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
 7339               		.loc 1 4450 0
 7340 314a 1682      		std Z+6,__zero_reg__
 7341 314c 00C0      		rjmp .L509
 7342               	.L489:
4455:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
 7343               		.loc 1 4455 0
 7344 314e 8091 0000 		lds r24,currentMidiMessage.2230+3
 7345 3152 8830      		cpi r24,lo8(8)
 7346 3154 00F0      		brlo .+2
 7347 3156 00C0      		rjmp .L442
4457:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
 7348               		.loc 1 4457 0
 7349 3158 E091 0000 		lds r30,currentMidiMessage.2230
 7350 315c 94E2      		ldi r25,lo8(36)
 7351 315e E99F      		mul r30,r25
 7352 3160 F001      		movw r30,r0
 7353 3162 1124      		clr __zero_reg__
 7354 3164 E050      		subi r30,lo8(-(bankStates))
 7355 3166 F040      		sbci r31,hi8(-(bankStates))
 7356 3168 8187      		std Z+9,r24
 7357 316a 00C0      		rjmp .L442
 7358               	.L490:
4462:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7359               		.loc 1 4462 0
 7360 316c 6091 0000 		lds r22,currentMidiMessage.2230+3
 7361 3170 8091 0000 		lds r24,currentMidiMessage.2230
 7362 3174 0E94 0000 		call MakeNewGranularArray
 7363               	.LVL295:
4463:WTPA.c        **** 					break;
 7364               		.loc 1 4463 0
 7365 3178 00C0      		rjmp .L442
 7366               	.L491:
4466:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
 7367               		.loc 1 4466 0
 7368 317a E091 0000 		lds r30,currentMidiMessage.2230
 7369 317e 8091 0000 		lds r24,currentMidiMessage.2230+3
 7370 3182 24E2      		ldi r18,lo8(36)
 7371 3184 E29F      		mul r30,r18
 7372 3186 F001      		movw r30,r0
 7373 3188 1124      		clr __zero_reg__
 7374 318a E050      		subi r30,lo8(-(bankStates))
 7375 318c F040      		sbci r31,hi8(-(bankStates))
 7376 318e 8087      		std Z+8,r24
4467:WTPA.c        **** 					break;
 7377               		.loc 1 4467 0
 7378 3190 00C0      		rjmp .L442
 7379               	.L492:
4470:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
 7380               		.loc 1 4470 0
 7381 3192 8091 0000 		lds r24,currentMidiMessage.2230+3
 7382 3196 8130      		cpi r24,lo8(1)
 7383 3198 01F0      		breq .L510
 7384 319a 00F0      		brlo .L509
 7385 319c 8230      		cpi r24,lo8(2)
 7386 319e 01F0      		breq .L511
 7387 31a0 8330      		cpi r24,lo8(3)
 7388 31a2 01F0      		breq .+2
 7389 31a4 00C0      		rjmp .L442
 7390 31a6 00C0      		rjmp .L512
 7391               	.L509:
4473:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
 7392               		.loc 1 4473 0
 7393 31a8 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 7394 31aa 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 7395 31ac 00C0      		rjmp .L623
 7396               	.L510:
4477:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
 7397               		.loc 1 4477 0
 7398 31ae 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 7399 31b0 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 7400               	.L623:
 7401 31b2 9093 0000 		sts UpdateOutput+1,r25
 7402 31b6 8093 0000 		sts UpdateOutput,r24
4478:WTPA.c        **** 						break;
 7403               		.loc 1 4478 0
 7404 31ba 00C0      		rjmp .L442
 7405               	.L511:
4481:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
 7406               		.loc 1 4481 0
 7407 31bc 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 7408 31be 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 7409 31c0 00C0      		rjmp .L623
 7410               	.L512:
4485:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
 7411               		.loc 1 4485 0
 7412 31c2 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 7413 31c4 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 7414 31c6 00C0      		rjmp .L623
 7415               	.L493:
4494:WTPA.c        **** 					sreg=SREG;
 7416               		.loc 1 4494 0
 7417 31c8 1FB7      		in r17,__SREG__
 7418               	.LVL296:
4495:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
 7419               		.loc 1 4495 0
 7420               	/* #APP */
 7421               	 ;  4495 "WTPA.c" 1
 7422 31ca F894      		cli
 7423               	 ;  0 "" 2
4496:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 7424               		.loc 1 4496 0
 7425               	/* #NOAPP */
 7426 31cc 5091 0000 		lds r21,currentMidiMessage.2230
 7427 31d0 A52F      		mov r26,r21
 7428 31d2 B0E0      		ldi r27,0
 7429 31d4 FD01      		movw r30,r26
 7430 31d6 E050      		subi r30,lo8(-(currentNoteOn.2231))
 7431 31d8 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 7432 31da 4081      		ld r20,Z
 7433               	.LVL297:
 7434 31dc AA0F      		lsl r26
 7435 31de BB1F      		rol r27
 7436 31e0 A050      		subi r26,lo8(-(theMidiRecordRate))
 7437 31e2 B040      		sbci r27,hi8(-(theMidiRecordRate))
 7438               	.LBB271:
 7439               	.LBB272:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7440               		.loc 1 3334 0
 7441 31e4 842F      		mov r24,r20
 7442 31e6 6CE0      		ldi r22,lo8(12)
 7443 31e8 0E94 0000 		call __udivmodqi4
 7444               	.LVL298:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7445               		.loc 1 3336 0
 7446 31ec E92F      		mov r30,r25
 7447 31ee F0E0      		ldi r31,0
 7448 31f0 EE0F      		lsl r30
 7449 31f2 FF1F      		rol r31
 7450 31f4 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7451 31f6 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7452 31f8 2081      		ld r18,Z
 7453 31fa 3181      		ldd r19,Z+1
 7454 31fc 00C0      		rjmp 2f
 7455               		1:
 7456 31fe 3695      		lsr r19
 7457 3200 2795      		ror r18
 7458               		2:
 7459 3202 8A95      		dec r24
 7460 3204 02F4      		brpl 1b
 7461               	.LBE272:
 7462               	.LBE271:
4496:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 7463               		.loc 1 4496 0
 7464 3206 2D93      		st X+,r18
 7465 3208 3C93      		st X,r19
 7466               	.LVL299:
 7467               	.LBB273:
 7468               	.LBB274:
3352:WTPA.c        **** 	if(theBank==BANK_0)
 7469               		.loc 1 3352 0
 7470 320a 5111      		cpse r21,__zero_reg__
 7471 320c 00C0      		rjmp .L513
3354:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
 7472               		.loc 1 3354 0
 7473 320e 642F      		mov r22,r20
 7474 3210 87E0      		ldi r24,lo8(7)
 7475 3212 90E0      		ldi r25,0
 7476               	.LVL300:
 7477 3214 00C0      		rjmp .L622
 7478               	.LVL301:
 7479               	.L513:
3356:WTPA.c        **** 	else if(theBank==BANK_1)
 7480               		.loc 1 3356 0
 7481 3216 5130      		cpi r21,lo8(1)
 7482 3218 01F4      		brne .L514
3358:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
 7483               		.loc 1 3358 0
 7484 321a 642F      		mov r22,r20
 7485 321c 8BE0      		ldi r24,lo8(11)
 7486 321e 90E0      		ldi r25,0
 7487               	.LVL302:
 7488               	.L622:
 7489 3220 0E94 0000 		call EepromWrite
 7490               	.LVL303:
 7491               	.L514:
 7492               	.LBE274:
 7493               	.LBE273:
4498:WTPA.c        **** 					SREG=sreg;		// Re-enable interrupts.
 7494               		.loc 1 4498 0
 7495 3224 1FBF      		out __SREG__,r17
4499:WTPA.c        **** 					break;
 7496               		.loc 1 4499 0
 7497 3226 00C0      		rjmp .L442
 7498               	.LVL304:
 7499               	.L494:
4504:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7500               		.loc 1 4504 0
 7501 3228 9091 0000 		lds r25,currentMidiMessage.2230+3
 7502 322c 8091 0000 		lds r24,currentMidiMessage.2230
 7503               	.LVL305:
 7504               	.LBB275:
 7505               	.LBB276:
3898:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7506               		.loc 1 3898 0
 7507 3230 44E2      		ldi r20,lo8(36)
 7508 3232 849F      		mul r24,r20
 7509 3234 F001      		movw r30,r0
 7510 3236 1124      		clr __zero_reg__
 7511 3238 00C0      		rjmp .L632
 7512               	.LVL306:
 7513               	.L495:
 7514               	.LBE276:
 7515               	.LBE275:
4508:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7516               		.loc 1 4508 0
 7517 323a 9091 0000 		lds r25,currentMidiMessage.2230+3
 7518 323e 8091 0000 		lds r24,currentMidiMessage.2230
 7519               	.LVL307:
 7520               	.LBB277:
 7521               	.LBB278:
3907:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7522               		.loc 1 3907 0
 7523 3242 24E2      		ldi r18,lo8(36)
 7524 3244 829F      		mul r24,r18
 7525 3246 F001      		movw r30,r0
 7526 3248 1124      		clr __zero_reg__
 7527 324a 00C0      		rjmp .L631
 7528               	.LVL308:
 7529               	.L496:
 7530               	.LBE278:
 7531               	.LBE277:
4512:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7532               		.loc 1 4512 0
 7533 324c 9091 0000 		lds r25,currentMidiMessage.2230+3
 7534 3250 8091 0000 		lds r24,currentMidiMessage.2230
 7535               	.LVL309:
 7536               	.LBB279:
 7537               	.LBB280:
3916:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7538               		.loc 1 3916 0
 7539 3254 44E2      		ldi r20,lo8(36)
 7540 3256 849F      		mul r24,r20
 7541 3258 F001      		movw r30,r0
 7542 325a 1124      		clr __zero_reg__
 7543 325c 00C0      		rjmp .L627
 7544               	.LVL310:
 7545               	.L497:
 7546               	.LBE280:
 7547               	.LBE279:
4516:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
 7548               		.loc 1 4516 0
 7549 325e 8091 0000 		lds r24,currentMidiMessage.2230
 7550 3262 0E94 0000 		call RevertSampleToUnadjusted
 7551               	.LVL311:
4517:WTPA.c        **** 					break;
 7552               		.loc 1 4517 0
 7553 3266 00C0      		rjmp .L442
 7554               	.L498:
4520:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7555               		.loc 1 4520 0
 7556 3268 9091 0000 		lds r25,currentMidiMessage.2230+3
 7557 326c 990F      		lsl r25
 7558 326e 8091 0000 		lds r24,currentMidiMessage.2230
 7559               	.LVL312:
 7560               	.LBB281:
 7561               	.LBB282:
3898:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7562               		.loc 1 3898 0
 7563 3272 24E2      		ldi r18,lo8(36)
 7564 3274 829F      		mul r24,r18
 7565 3276 F001      		movw r30,r0
 7566 3278 1124      		clr __zero_reg__
 7567               	.LVL313:
 7568               	.L632:
 7569 327a E050      		subi r30,lo8(-(bankStates))
 7570 327c F040      		sbci r31,hi8(-(bankStates))
 7571 327e 958F      		std Z+29,r25
 7572 3280 00C0      		rjmp .L626
 7573               	.L499:
 7574               	.LBE282:
 7575               	.LBE281:
4524:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7576               		.loc 1 4524 0
 7577 3282 9091 0000 		lds r25,currentMidiMessage.2230+3
 7578 3286 990F      		lsl r25
 7579 3288 8091 0000 		lds r24,currentMidiMessage.2230
 7580               	.LVL314:
 7581               	.LBB283:
 7582               	.LBB284:
3907:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7583               		.loc 1 3907 0
 7584 328c 44E2      		ldi r20,lo8(36)
 7585 328e 849F      		mul r24,r20
 7586 3290 F001      		movw r30,r0
 7587 3292 1124      		clr __zero_reg__
 7588               	.LVL315:
 7589               	.L631:
 7590 3294 E050      		subi r30,lo8(-(bankStates))
 7591 3296 F040      		sbci r31,hi8(-(bankStates))
 7592 3298 968F      		std Z+30,r25
 7593 329a 00C0      		rjmp .L626
 7594               	.L500:
 7595               	.LBE284:
 7596               	.LBE283:
4528:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7597               		.loc 1 4528 0
 7598 329c 9091 0000 		lds r25,currentMidiMessage.2230+3
 7599 32a0 990F      		lsl r25
 7600 32a2 8091 0000 		lds r24,currentMidiMessage.2230
 7601               	.LVL316:
 7602               	.LBB285:
 7603               	.LBB286:
3916:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7604               		.loc 1 3916 0
 7605 32a6 24E2      		ldi r18,lo8(36)
 7606 32a8 829F      		mul r24,r18
 7607 32aa F001      		movw r30,r0
 7608 32ac 1124      		clr __zero_reg__
 7609               	.LVL317:
 7610               	.L627:
 7611 32ae E050      		subi r30,lo8(-(bankStates))
 7612 32b0 F040      		sbci r31,hi8(-(bankStates))
 7613 32b2 978F      		std Z+31,r25
 7614               	.L626:
3917:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 7615               		.loc 1 3917 0
 7616 32b4 0E94 0000 		call UpdateAdjustedSampleAddresses
 7617               	.LVL318:
 7618 32b8 00C0      		rjmp .L442
 7619               	.L481:
 7620               	.LBE286:
 7621               	.LBE285:
4536:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
 7622               		.loc 1 4536 0
 7623 32ba 8730      		cpi r24,lo8(7)
 7624 32bc 01F0      		breq .+2
 7625 32be 00C0      		rjmp .L442
4538:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
 7626               		.loc 1 4538 0
 7627 32c0 8091 0000 		lds r24,currentMidiMessage.2230+3
 7628 32c4 2091 0000 		lds r18,currentMidiMessage.2230+2
 7629 32c8 30E0      		ldi r19,0
 7630 32ca 40E8      		ldi r20,lo8(-128)
 7631 32cc 849F      		mul r24,r20
 7632 32ce 200D      		add r18,r0
 7633 32d0 311D      		adc r19,r1
 7634 32d2 1124      		clr __zero_reg__
 7635               	.LVL319:
 7636 32d4 A091 0000 		lds r26,currentMidiMessage.2230
4540:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
 7637               		.loc 1 4540 0
 7638 32d8 2115      		cp r18,__zero_reg__
 7639 32da 80E2      		ldi r24,32
 7640 32dc 3807      		cpc r19,r24
 7641 32de 01F0      		breq .L515
4544:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7642               		.loc 1 4544 0
 7643 32e0 B0E0      		ldi r27,0
 7644 32e2 FD01      		movw r30,r26
 7645 32e4 E050      		subi r30,lo8(-(currentNoteOn.2231))
 7646 32e6 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 7647 32e8 8081      		ld r24,Z
 7648               	.LVL320:
 7649 32ea 40E0      		ldi r20,0
 7650 32ec 50E2      		ldi r21,lo8(32)
 7651 32ee 421B      		sub r20,r18
 7652 32f0 530B      		sbc r21,r19
 7653               	.LBB287:
 7654               	.LBB288:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7655               		.loc 1 3334 0
 7656 32f2 6CE0      		ldi r22,lo8(12)
 7657 32f4 0E94 0000 		call __udivmodqi4
 7658               	.LVL321:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7659               		.loc 1 3336 0
 7660 32f8 E92F      		mov r30,r25
 7661               	.LVL322:
 7662 32fa F0E0      		ldi r31,0
 7663 32fc EE0F      		lsl r30
 7664 32fe FF1F      		rol r31
 7665 3300 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7666 3302 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7667               	.LBE288:
 7668               	.LBE287:
 7669               	.LBB289:
 7670               	.LBB290:
 7671 3304 2081      		ld r18,Z
 7672 3306 3181      		ldd r19,Z+1
 7673               	.LVL323:
 7674 3308 00C0      		rjmp 2f
 7675               		1:
 7676 330a 3695      		lsr r19
 7677 330c 2795      		ror r18
 7678               		2:
 7679 330e 8A95      		dec r24
 7680 3310 02F4      		brpl 1b
 7681               	.LBE290:
 7682               	.LBE289:
4548:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7683               		.loc 1 4548 0
 7684 3312 420F      		add r20,r18
 7685 3314 531F      		adc r21,r19
 7686 3316 84E2      		ldi r24,lo8(36)
 7687               	.LVL324:
 7688 3318 8A9F      		mul r24,r26
 7689 331a F001      		movw r30,r0
 7690 331c 8B9F      		mul r24,r27
 7691 331e F00D      		add r31,r0
 7692 3320 1124      		clr __zero_reg__
 7693 3322 E050      		subi r30,lo8(-(bankStates))
 7694 3324 F040      		sbci r31,hi8(-(bankStates))
 7695 3326 5487      		std Z+12,r21
 7696 3328 4387      		std Z+11,r20
 7697 332a 00C0      		rjmp .L442
 7698               	.LVL325:
 7699               	.L515:
4553:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7700               		.loc 1 4553 0
 7701 332c 4A2F      		mov r20,r26
 7702 332e 50E0      		ldi r21,0
 7703 3330 FA01      		movw r30,r20
 7704 3332 E050      		subi r30,lo8(-(currentNoteOn.2231))
 7705 3334 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 7706 3336 8081      		ld r24,Z
 7707               	.LVL326:
 7708               	.LBB291:
 7709               	.LBB292:
3334:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7710               		.loc 1 3334 0
 7711 3338 6CE0      		ldi r22,lo8(12)
 7712 333a 0E94 0000 		call __udivmodqi4
 7713               	.LVL327:
3336:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7714               		.loc 1 3336 0
 7715 333e E92F      		mov r30,r25
 7716               	.LVL328:
 7717 3340 F0E0      		ldi r31,0
 7718 3342 EE0F      		lsl r30
 7719 3344 FF1F      		rol r31
 7720 3346 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7721 3348 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7722 334a 2081      		ld r18,Z
 7723 334c 3181      		ldd r19,Z+1
 7724               	.LVL329:
 7725 334e 00C0      		rjmp 2f
 7726               		1:
 7727 3350 3695      		lsr r19
 7728 3352 2795      		ror r18
 7729               		2:
 7730 3354 8A95      		dec r24
 7731 3356 02F4      		brpl 1b
 7732               	.LBE292:
 7733               	.LBE291:
4553:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7734               		.loc 1 4553 0
 7735 3358 84E2      		ldi r24,lo8(36)
 7736               	.LVL330:
 7737 335a 849F      		mul r24,r20
 7738 335c F001      		movw r30,r0
 7739 335e 859F      		mul r24,r21
 7740 3360 F00D      		add r31,r0
 7741 3362 1124      		clr __zero_reg__
 7742 3364 E050      		subi r30,lo8(-(bankStates))
 7743 3366 F040      		sbci r31,hi8(-(bankStates))
 7744 3368 3487      		std Z+12,r19
 7745 336a 2387      		std Z+11,r18
 7746               	.LVL331:
 7747               	.L442:
 7748               	.LBB293:
 7749               	.LBB294:
3522:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
 7750               		.loc 1 3522 0
 7751 336c 8091 0000 		lds r24,sdIsrState
 7752 3370 8330      		cpi r24,lo8(3)
 7753 3372 01F0      		breq .L517
3524:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
 7754               		.loc 1 3524 0
 7755 3374 1092 0000 		sts sdStreamOutput,__zero_reg__
 7756               	.L517:
3528:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
 7757               		.loc 1 3528 0
 7758 3378 8091 0000 		lds r24,bankStates+10
 7759 337c 8130      		cpi r24,lo8(1)
 7760 337e 01F0      		breq .L518
3530:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7761               		.loc 1 3530 0
 7762 3380 1092 0000 		sts extIsrOutputBank0,__zero_reg__
3531:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7763               		.loc 1 3531 0
 7764 3384 8091 6F00 		lds r24,111
 7765 3388 8F7D      		andi r24,lo8(-33)
 7766 338a 8093 6F00 		sts 111,r24
3532:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
 7767               		.loc 1 3532 0
 7768 338e B59A      		sbi 0x16,5
 7769               	.L518:
3534:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
 7770               		.loc 1 3534 0
 7771 3390 8091 0000 		lds r24,bankStates+46
 7772 3394 8130      		cpi r24,lo8(1)
 7773 3396 01F0      		breq .L519
3536:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
 7774               		.loc 1 3536 0
 7775 3398 1092 0000 		sts extIsrOutputBank1,__zero_reg__
3537:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
 7776               		.loc 1 3537 0
 7777 339c 1092 6800 		sts 104,__zero_reg__
3538:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
 7778               		.loc 1 3538 0
 7779 33a0 1092 6D00 		sts 109,__zero_reg__
 7780               	.L519:
3540:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
 7781               		.loc 1 3540 0
 7782 33a4 8091 0000 		lds r24,bankStates+10
 7783 33a8 8230      		cpi r24,lo8(2)
 7784 33aa 01F0      		breq .L520
3542:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7785               		.loc 1 3542 0
 7786 33ac 1092 0000 		sts midiOutputBank0,__zero_reg__
3543:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
 7787               		.loc 1 3543 0
 7788 33b0 8091 6F00 		lds r24,111
 7789 33b4 8D7F      		andi r24,lo8(-3)
 7790 33b6 8093 6F00 		sts 111,r24
3544:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
 7791               		.loc 1 3544 0
 7792 33ba B19A      		sbi 0x16,1
 7793               	.L520:
3546:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
 7794               		.loc 1 3546 0
 7795 33bc 8091 0000 		lds r24,bankStates+46
 7796 33c0 8230      		cpi r24,lo8(2)
 7797 33c2 01F0      		breq .L521
3548:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
 7798               		.loc 1 3548 0
 7799 33c4 1092 0000 		sts midiOutputBank1,__zero_reg__
3549:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
 7800               		.loc 1 3549 0
 7801 33c8 8091 6F00 		lds r24,111
 7802 33cc 8B7F      		andi r24,lo8(-5)
 7803 33ce 8093 6F00 		sts 111,r24
3550:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
 7804               		.loc 1 3550 0
 7805 33d2 B29A      		sbi 0x16,2
 7806               	.L521:
3554:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7807               		.loc 1 3554 0
 7808 33d4 8091 0000 		lds r24,bankStates+10
 7809 33d8 8111      		cpse r24,__zero_reg__
 7810 33da 00C0      		rjmp .L522
3556:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
 7811               		.loc 1 3556 0
 7812 33dc 8091 0000 		lds r24,sdIsrState
 7813 33e0 8823      		tst r24
 7814 33e2 01F0      		breq .L523
 7815 33e4 8330      		cpi r24,lo8(3)
 7816 33e6 01F0      		breq .L523
 7817 33e8 8091 0000 		lds r24,sdBank0
 7818 33ec 8111      		cpse r24,__zero_reg__
 7819 33ee 00C0      		rjmp .L522
 7820               	.L523:
3558:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
 7821               		.loc 1 3558 0
 7822 33f0 1092 0000 		sts bankStates+5,__zero_reg__
 7823               	.L522:
3561:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7824               		.loc 1 3561 0
 7825 33f4 8091 0000 		lds r24,bankStates+46
 7826 33f8 8111      		cpse r24,__zero_reg__
 7827 33fa 00C0      		rjmp .L524
3563:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
 7828               		.loc 1 3563 0
 7829 33fc 8091 0000 		lds r24,sdIsrState
 7830 3400 8823      		tst r24
 7831 3402 01F0      		breq .L525
 7832 3404 8330      		cpi r24,lo8(3)
 7833 3406 01F0      		breq .L525
 7834 3408 8091 0000 		lds r24,sdBank0
 7835 340c 8130      		cpi r24,lo8(1)
 7836 340e 01F4      		brne .L524
 7837               	.L525:
3565:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
 7838               		.loc 1 3565 0
 7839 3410 1092 0000 		sts bankStates+41,__zero_reg__
 7840               	.L524:
 7841               	.LBE294:
 7842               	.LBE293:
 7843               	.LBB295:
 7844               	.LBB296:
3498:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
 7845               		.loc 1 3498 0
 7846 3414 8091 0000 		lds r24,encoderValue
 7847 3418 8295      		swap r24
 7848 341a 8695      		lsr r24
 7849 341c 8770      		andi r24,lo8(7)
 7850 341e 8093 0000 		sts scaledEncoderValue,r24
3499:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
 7851               		.loc 1 3499 0
 7852 3422 2091 0000 		lds r18,ledOnOffMask
 7853 3426 2F71      		andi r18,lo8(31)
 7854               	.LVL332:
3501:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
 7855               		.loc 1 3501 0
 7856 3428 80FD      		sbrc r24,0
3503:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
 7857               		.loc 1 3503 0
 7858 342a 2068      		ori r18,lo8(-128)
 7859               	.LVL333:
 7860               	.L526:
3505:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
 7861               		.loc 1 3505 0
 7862 342c 81FD      		sbrc r24,1
3507:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
 7863               		.loc 1 3507 0
 7864 342e 2064      		ori r18,lo8(64)
 7865               	.LVL334:
 7866               	.L527:
 7867               	.LBE296:
3509:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
 7868               		.loc 1 3509 0
 7869 3430 8470      		andi r24,lo8(4)
 7870               	.LBB297:
 7871 3432 01F0      		breq .L528
3511:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
 7872               		.loc 1 3511 0
 7873 3434 2062      		ori r18,lo8(32)
 7874               	.LVL335:
 7875               	.L528:
 7876               	.LBE297:
 7877               	.LBE295:
4562:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
 7878               		.loc 1 4562 0
 7879 3436 3091 0000 		lds r19,currentBank
 7880               	.LVL336:
 7881               	.LBB298:
 7882               	.LBB299:
3446:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
 7883               		.loc 1 3446 0
 7884 343a 207E      		andi r18,lo8(-32)
 7885               	.LVL337:
3448:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
 7886               		.loc 1 3448 0
 7887 343c 832F      		mov r24,r19
 7888 343e 90E0      		ldi r25,0
 7889 3440 44E2      		ldi r20,lo8(36)
 7890 3442 349F      		mul r19,r20
 7891 3444 F001      		movw r30,r0
 7892 3446 1124      		clr __zero_reg__
 7893 3448 E050      		subi r30,lo8(-(bankStates))
 7894 344a F040      		sbci r31,hi8(-(bankStates))
 7895 344c 4081      		ld r20,Z
 7896 344e 4330      		cpi r20,lo8(3)
 7897 3450 01F4      		brne .L529
3450:WTPA.c        **** 		temp|=Om_LED_REC;
 7898               		.loc 1 3450 0
 7899 3452 2160      		ori r18,lo8(1)
 7900               	.LVL338:
 7901               	.L529:
3452:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
 7902               		.loc 1 3452 0
 7903 3454 44E2      		ldi r20,lo8(36)
 7904 3456 489F      		mul r20,r24
 7905 3458 F001      		movw r30,r0
 7906 345a 499F      		mul r20,r25
 7907 345c F00D      		add r31,r0
 7908 345e 1124      		clr __zero_reg__
 7909 3460 E050      		subi r30,lo8(-(bankStates))
 7910 3462 F040      		sbci r31,hi8(-(bankStates))
 7911 3464 4081      		ld r20,Z
 7912 3466 4430      		cpi r20,lo8(4)
 7913 3468 01F4      		brne .L530
3454:WTPA.c        **** 		temp|=Om_LED_PLAY;
 7914               		.loc 1 3454 0
 7915 346a 2460      		ori r18,lo8(4)
 7916               	.LVL339:
 7917               	.L530:
3456:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
 7918               		.loc 1 3456 0
 7919 346c 44E2      		ldi r20,lo8(36)
 7920 346e 489F      		mul r20,r24
 7921 3470 F001      		movw r30,r0
 7922 3472 499F      		mul r20,r25
 7923 3474 F00D      		add r31,r0
 7924 3476 1124      		clr __zero_reg__
 7925 3478 E050      		subi r30,lo8(-(bankStates))
 7926 347a F040      		sbci r31,hi8(-(bankStates))
 7927 347c 4081      		ld r20,Z
 7928 347e 4530      		cpi r20,lo8(5)
 7929 3480 01F4      		brne .L531
3458:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7930               		.loc 1 3458 0
 7931 3482 2260      		ori r18,lo8(2)
 7932               	.LVL340:
 7933               	.L531:
3460:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
 7934               		.loc 1 3460 0
 7935 3484 44E2      		ldi r20,lo8(36)
 7936 3486 489F      		mul r20,r24
 7937 3488 F001      		movw r30,r0
 7938 348a 499F      		mul r20,r25
 7939 348c F00D      		add r31,r0
 7940 348e 1124      		clr __zero_reg__
 7941 3490 E050      		subi r30,lo8(-(bankStates))
 7942 3492 F040      		sbci r31,hi8(-(bankStates))
 7943 3494 4081      		ld r20,Z
 7944 3496 4230      		cpi r20,lo8(2)
 7945 3498 01F4      		brne .L532
 7946               	.LVL341:
3464:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7947               		.loc 1 3464 0
 7948 349a 2760      		ori r18,lo8(7)
 7949               	.LVL342:
 7950               	.L532:
3467:WTPA.c        **** 	if(outOfRam==true)
 7951               		.loc 1 3467 0
 7952 349c 4091 0000 		lds r20,outOfRam
 7953 34a0 4130      		cpi r20,lo8(1)
 7954 34a2 01F4      		brne .L533
3469:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
 7955               		.loc 1 3469 0
 7956 34a4 2860      		ori r18,lo8(8)
 7957               	.LVL343:
 7958               	.L533:
3471:WTPA.c        **** 	if(theBank==BANK_1)
 7959               		.loc 1 3471 0
 7960 34a6 3130      		cpi r19,lo8(1)
 7961 34a8 01F4      		brne .L534
3473:WTPA.c        **** 		temp|=Om_LED_BANK;
 7962               		.loc 1 3473 0
 7963 34aa 2061      		ori r18,lo8(16)
 7964               	.LVL344:
 7965               	.L534:
3476:WTPA.c        **** 	ledOnOffMask=temp;
 7966               		.loc 1 3476 0
 7967 34ac 2093 0000 		sts ledOnOffMask,r18
3478:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
 7968               		.loc 1 3478 0
 7969 34b0 24E2      		ldi r18,lo8(36)
 7970               	.LVL345:
 7971 34b2 289F      		mul r18,r24
 7972 34b4 F001      		movw r30,r0
 7973 34b6 299F      		mul r18,r25
 7974 34b8 F00D      		add r31,r0
 7975 34ba 1124      		clr __zero_reg__
 7976 34bc E050      		subi r30,lo8(-(bankStates))
 7977 34be F040      		sbci r31,hi8(-(bankStates))
 7978 34c0 4189      		ldd r20,Z+17
 7979 34c2 5289      		ldd r21,Z+18
 7980 34c4 6389      		ldd r22,Z+19
 7981 34c6 7489      		ldd r23,Z+20
 7982 34c8 8585      		ldd r24,Z+13
 7983 34ca 9685      		ldd r25,Z+14
 7984 34cc A785      		ldd r26,Z+15
 7985 34ce B089      		ldd r27,Z+16
 7986 34d0 4817      		cp r20,r24
 7987 34d2 5907      		cpc r21,r25
 7988 34d4 6A07      		cpc r22,r26
 7989 34d6 7B07      		cpc r23,r27
 7990 34d8 01F4      		brne .L535
 7991               	.LBE299:
3480:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
 7992               		.loc 1 3480 0
 7993 34da 8091 0000 		lds r24,ledBlinkMask
 7994               	.LBB300:
 7995 34de 82FD      		sbrc r24,2
 7996 34e0 00C0      		rjmp .L440
3482:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
 7997               		.loc 1 3482 0
 7998 34e2 84E0      		ldi r24,lo8(4)
 7999 34e4 90E0      		ldi r25,0
 8000               	/* epilogue start */
 8001               	.LBE300:
 8002               	.LBE298:
4563:WTPA.c        **** }
 8003               		.loc 1 4563 0
 8004 34e6 0F90      		pop __tmp_reg__
 8005 34e8 DF91      		pop r29
 8006 34ea CF91      		pop r28
 8007 34ec 1F91      		pop r17
 8008 34ee 0F91      		pop r16
 8009 34f0 FF90      		pop r15
 8010 34f2 DF90      		pop r13
 8011 34f4 CF90      		pop r12
 8012               	.LBB303:
 8013               	.LBB301:
3482:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
 8014               		.loc 1 3482 0
 8015 34f6 0C94 0000 		jmp BlinkLeds
 8016               	.LVL346:
 8017               	.L535:
 8018               	/* epilogue start */
 8019               	.LBE301:
 8020               	.LBE303:
4563:WTPA.c        **** }
 8021               		.loc 1 4563 0
 8022 34fa 0F90      		pop __tmp_reg__
 8023 34fc DF91      		pop r29
 8024 34fe CF91      		pop r28
 8025 3500 1F91      		pop r17
 8026 3502 0F91      		pop r16
 8027 3504 FF90      		pop r15
 8028 3506 DF90      		pop r13
 8029 3508 CF90      		pop r12
 8030               	.LBB304:
 8031               	.LBB302:
3487:WTPA.c        **** 		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we 
 8032               		.loc 1 3487 0
 8033 350a 0C94 0000 		jmp StopBlinking
 8034               	.LVL347:
 8035               	.L440:
 8036               	/* epilogue start */
 8037               	.LBE302:
 8038               	.LBE304:
4563:WTPA.c        **** }
 8039               		.loc 1 4563 0
 8040 350e 0F90      		pop __tmp_reg__
 8041 3510 DF91      		pop r29
 8042 3512 CF91      		pop r28
 8043 3514 1F91      		pop r17
 8044 3516 0F91      		pop r16
 8045 3518 FF90      		pop r15
 8046 351a DF90      		pop r13
 8047 351c CF90      		pop r12
 8048 351e 0895      		ret
 8049               		.cfi_endproc
 8050               	.LFE70:
 8052               	.global	__vector_12
 8054               	__vector_12:
 8055               	.LFB7:
1097:WTPA.c        **** {
 8056               		.loc 1 1097 0
 8057               		.cfi_startproc
 8058 3520 1F92      		push r1
 8059               	.LCFI80:
 8060               		.cfi_def_cfa_offset 3
 8061               		.cfi_offset 1, -2
 8062 3522 0F92      		push r0
 8063               	.LCFI81:
 8064               		.cfi_def_cfa_offset 4
 8065               		.cfi_offset 0, -3
 8066 3524 0FB6      		in r0,__SREG__
 8067 3526 0F92      		push r0
 8068 3528 1124      		clr __zero_reg__
 8069 352a 2F93      		push r18
 8070               	.LCFI82:
 8071               		.cfi_def_cfa_offset 5
 8072               		.cfi_offset 18, -4
 8073 352c 3F93      		push r19
 8074               	.LCFI83:
 8075               		.cfi_def_cfa_offset 6
 8076               		.cfi_offset 19, -5
 8077 352e 4F93      		push r20
 8078               	.LCFI84:
 8079               		.cfi_def_cfa_offset 7
 8080               		.cfi_offset 20, -6
 8081 3530 5F93      		push r21
 8082               	.LCFI85:
 8083               		.cfi_def_cfa_offset 8
 8084               		.cfi_offset 21, -7
 8085 3532 6F93      		push r22
 8086               	.LCFI86:
 8087               		.cfi_def_cfa_offset 9
 8088               		.cfi_offset 22, -8
 8089 3534 7F93      		push r23
 8090               	.LCFI87:
 8091               		.cfi_def_cfa_offset 10
 8092               		.cfi_offset 23, -9
 8093 3536 8F93      		push r24
 8094               	.LCFI88:
 8095               		.cfi_def_cfa_offset 11
 8096               		.cfi_offset 24, -10
 8097 3538 9F93      		push r25
 8098               	.LCFI89:
 8099               		.cfi_def_cfa_offset 12
 8100               		.cfi_offset 25, -11
 8101 353a AF93      		push r26
 8102               	.LCFI90:
 8103               		.cfi_def_cfa_offset 13
 8104               		.cfi_offset 26, -12
 8105 353c BF93      		push r27
 8106               	.LCFI91:
 8107               		.cfi_def_cfa_offset 14
 8108               		.cfi_offset 27, -13
 8109 353e EF93      		push r30
 8110               	.LCFI92:
 8111               		.cfi_def_cfa_offset 15
 8112               		.cfi_offset 30, -14
 8113 3540 FF93      		push r31
 8114               	.LCFI93:
 8115               		.cfi_def_cfa_offset 16
 8116               		.cfi_offset 31, -15
 8117               	/* prologue: Signal */
 8118               	/* frame size = 0 */
 8119               	/* stack size = 15 */
 8120               	.L__stack_usage = 15
1102:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8121               		.loc 1 1102 0
 8122 3542 8091 0000 		lds r24,bankStates+2
 8123 3546 8823      		tst r24
 8124 3548 01F0      		breq .L634
1102:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8125               		.loc 1 1102 0 is_stmt 0 discriminator 1
 8126 354a 8091 0000 		lds r24,bankStates+2
 8127 354e 8823      		tst r24
 8128 3550 01F0      		breq .L635
 8129 3552 8091 0000 		lds r24,flipFlop.1813
 8130 3556 8823      		tst r24
 8131 3558 01F0      		breq .L635
 8132               	.L634:
1104:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
 8133               		.loc 1 1104 0 is_stmt 1
 8134 355a 0E94 0000 		call UpdateAudioChannel0
 8135               	.LVL348:
 8136 355e 8093 0000 		sts extIsrOutputBank0,r24
 8137               	.L635:
1106:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8138               		.loc 1 1106 0
 8139 3562 1092 0000 		sts flipFlop.1813,__zero_reg__
1107:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8140               		.loc 1 1107 0
 8141 3566 E091 0000 		lds r30,UpdateOutput
 8142 356a F091 0000 		lds r31,UpdateOutput+1
 8143 356e 0995      		icall
 8144               	.LVL349:
1108:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8145               		.loc 1 1108 0
 8146 3570 8091 7A00 		lds r24,122
 8147 3574 86FD      		sbrc r24,6
 8148 3576 00C0      		rjmp .L633
1110:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8149               		.loc 1 1110 0
 8150 3578 8091 7900 		lds r24,121
 8151 357c 8058      		subi r24,lo8(-(-128))
 8152 357e 8093 0000 		sts adcByte,r24
1111:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8153               		.loc 1 1111 0
 8154 3582 8091 7A00 		lds r24,122
 8155 3586 8064      		ori r24,lo8(64)
 8156 3588 8093 7A00 		sts 122,r24
 8157               	.L633:
 8158               	/* epilogue start */
1113:WTPA.c        **** }
 8159               		.loc 1 1113 0
 8160 358c FF91      		pop r31
 8161 358e EF91      		pop r30
 8162 3590 BF91      		pop r27
 8163 3592 AF91      		pop r26
 8164 3594 9F91      		pop r25
 8165 3596 8F91      		pop r24
 8166 3598 7F91      		pop r23
 8167 359a 6F91      		pop r22
 8168 359c 5F91      		pop r21
 8169 359e 4F91      		pop r20
 8170 35a0 3F91      		pop r19
 8171 35a2 2F91      		pop r18
 8172 35a4 0F90      		pop r0
 8173 35a6 0FBE      		out __SREG__,r0
 8174 35a8 0F90      		pop r0
 8175 35aa 1F90      		pop r1
 8176 35ac 1895      		reti
 8177               		.cfi_endproc
 8178               	.LFE7:
 8180               	.global	__vector_6
 8182               	__vector_6:
 8183               	.LFB8:
1118:WTPA.c        **** {
 8184               		.loc 1 1118 0
 8185               		.cfi_startproc
 8186 35ae 1F92      		push r1
 8187               	.LCFI94:
 8188               		.cfi_def_cfa_offset 3
 8189               		.cfi_offset 1, -2
 8190 35b0 0F92      		push r0
 8191               	.LCFI95:
 8192               		.cfi_def_cfa_offset 4
 8193               		.cfi_offset 0, -3
 8194 35b2 0FB6      		in r0,__SREG__
 8195 35b4 0F92      		push r0
 8196 35b6 1124      		clr __zero_reg__
 8197 35b8 2F93      		push r18
 8198               	.LCFI96:
 8199               		.cfi_def_cfa_offset 5
 8200               		.cfi_offset 18, -4
 8201 35ba 3F93      		push r19
 8202               	.LCFI97:
 8203               		.cfi_def_cfa_offset 6
 8204               		.cfi_offset 19, -5
 8205 35bc 4F93      		push r20
 8206               	.LCFI98:
 8207               		.cfi_def_cfa_offset 7
 8208               		.cfi_offset 20, -6
 8209 35be 5F93      		push r21
 8210               	.LCFI99:
 8211               		.cfi_def_cfa_offset 8
 8212               		.cfi_offset 21, -7
 8213 35c0 6F93      		push r22
 8214               	.LCFI100:
 8215               		.cfi_def_cfa_offset 9
 8216               		.cfi_offset 22, -8
 8217 35c2 7F93      		push r23
 8218               	.LCFI101:
 8219               		.cfi_def_cfa_offset 10
 8220               		.cfi_offset 23, -9
 8221 35c4 8F93      		push r24
 8222               	.LCFI102:
 8223               		.cfi_def_cfa_offset 11
 8224               		.cfi_offset 24, -10
 8225 35c6 9F93      		push r25
 8226               	.LCFI103:
 8227               		.cfi_def_cfa_offset 12
 8228               		.cfi_offset 25, -11
 8229 35c8 AF93      		push r26
 8230               	.LCFI104:
 8231               		.cfi_def_cfa_offset 13
 8232               		.cfi_offset 26, -12
 8233 35ca BF93      		push r27
 8234               	.LCFI105:
 8235               		.cfi_def_cfa_offset 14
 8236               		.cfi_offset 27, -13
 8237 35cc EF93      		push r30
 8238               	.LCFI106:
 8239               		.cfi_def_cfa_offset 15
 8240               		.cfi_offset 30, -14
 8241 35ce FF93      		push r31
 8242               	.LCFI107:
 8243               		.cfi_def_cfa_offset 16
 8244               		.cfi_offset 31, -15
 8245               	/* prologue: Signal */
 8246               	/* frame size = 0 */
 8247               	/* stack size = 15 */
 8248               	.L__stack_usage = 15
1123:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8249               		.loc 1 1123 0
 8250 35d0 8091 0000 		lds r24,bankStates+38
 8251 35d4 8823      		tst r24
 8252 35d6 01F0      		breq .L647
1123:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8253               		.loc 1 1123 0 is_stmt 0 discriminator 1
 8254 35d8 8091 0000 		lds r24,bankStates+38
 8255 35dc 8823      		tst r24
 8256 35de 01F0      		breq .L648
 8257 35e0 8091 0000 		lds r24,flipFlop.1819
 8258 35e4 8823      		tst r24
 8259 35e6 01F0      		breq .L648
 8260               	.L647:
1125:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
 8261               		.loc 1 1125 0 is_stmt 1
 8262 35e8 0E94 0000 		call UpdateAudioChannel1
 8263               	.LVL350:
 8264 35ec 8093 0000 		sts extIsrOutputBank1,r24
 8265               	.L648:
1127:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8266               		.loc 1 1127 0
 8267 35f0 1092 0000 		sts flipFlop.1819,__zero_reg__
1128:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8268               		.loc 1 1128 0
 8269 35f4 E091 0000 		lds r30,UpdateOutput
 8270 35f8 F091 0000 		lds r31,UpdateOutput+1
 8271 35fc 0995      		icall
 8272               	.LVL351:
1129:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8273               		.loc 1 1129 0
 8274 35fe 8091 7A00 		lds r24,122
 8275 3602 86FD      		sbrc r24,6
 8276 3604 00C0      		rjmp .L649
1131:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8277               		.loc 1 1131 0
 8278 3606 8091 7900 		lds r24,121
 8279 360a 8058      		subi r24,lo8(-(-128))
 8280 360c 8093 0000 		sts adcByte,r24
1132:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8281               		.loc 1 1132 0
 8282 3610 8091 7A00 		lds r24,122
 8283 3614 8064      		ori r24,lo8(64)
 8284 3616 8093 7A00 		sts 122,r24
 8285               	.L649:
1134:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
 8286               		.loc 1 1134 0
 8287 361a DA9A      		sbi 0x1b,2
 8288               	/* epilogue start */
1143:WTPA.c        **** }
 8289               		.loc 1 1143 0
 8290 361c FF91      		pop r31
 8291 361e EF91      		pop r30
 8292 3620 BF91      		pop r27
 8293 3622 AF91      		pop r26
 8294 3624 9F91      		pop r25
 8295 3626 8F91      		pop r24
 8296 3628 7F91      		pop r23
 8297 362a 6F91      		pop r22
 8298 362c 5F91      		pop r21
 8299 362e 4F91      		pop r20
 8300 3630 3F91      		pop r19
 8301 3632 2F91      		pop r18
 8302 3634 0F90      		pop r0
 8303 3636 0FBE      		out __SREG__,r0
 8304 3638 0F90      		pop r0
 8305 363a 1F90      		pop r1
 8306 363c 1895      		reti
 8307               		.cfi_endproc
 8308               	.LFE8:
 8310               	.global	__vector_13
 8312               	__vector_13:
 8313               	.LFB9:
1147:WTPA.c        **** {
 8314               		.loc 1 1147 0
 8315               		.cfi_startproc
 8316 363e 1F92      		push r1
 8317               	.LCFI108:
 8318               		.cfi_def_cfa_offset 3
 8319               		.cfi_offset 1, -2
 8320 3640 0F92      		push r0
 8321               	.LCFI109:
 8322               		.cfi_def_cfa_offset 4
 8323               		.cfi_offset 0, -3
 8324 3642 0FB6      		in r0,__SREG__
 8325 3644 0F92      		push r0
 8326 3646 1124      		clr __zero_reg__
 8327 3648 0F93      		push r16
 8328               	.LCFI110:
 8329               		.cfi_def_cfa_offset 5
 8330               		.cfi_offset 16, -4
 8331 364a 1F93      		push r17
 8332               	.LCFI111:
 8333               		.cfi_def_cfa_offset 6
 8334               		.cfi_offset 17, -5
 8335 364c 2F93      		push r18
 8336               	.LCFI112:
 8337               		.cfi_def_cfa_offset 7
 8338               		.cfi_offset 18, -6
 8339 364e 3F93      		push r19
 8340               	.LCFI113:
 8341               		.cfi_def_cfa_offset 8
 8342               		.cfi_offset 19, -7
 8343 3650 4F93      		push r20
 8344               	.LCFI114:
 8345               		.cfi_def_cfa_offset 9
 8346               		.cfi_offset 20, -8
 8347 3652 5F93      		push r21
 8348               	.LCFI115:
 8349               		.cfi_def_cfa_offset 10
 8350               		.cfi_offset 21, -9
 8351 3654 6F93      		push r22
 8352               	.LCFI116:
 8353               		.cfi_def_cfa_offset 11
 8354               		.cfi_offset 22, -10
 8355 3656 7F93      		push r23
 8356               	.LCFI117:
 8357               		.cfi_def_cfa_offset 12
 8358               		.cfi_offset 23, -11
 8359 3658 8F93      		push r24
 8360               	.LCFI118:
 8361               		.cfi_def_cfa_offset 13
 8362               		.cfi_offset 24, -12
 8363 365a 9F93      		push r25
 8364               	.LCFI119:
 8365               		.cfi_def_cfa_offset 14
 8366               		.cfi_offset 25, -13
 8367 365c AF93      		push r26
 8368               	.LCFI120:
 8369               		.cfi_def_cfa_offset 15
 8370               		.cfi_offset 26, -14
 8371 365e BF93      		push r27
 8372               	.LCFI121:
 8373               		.cfi_def_cfa_offset 16
 8374               		.cfi_offset 27, -15
 8375 3660 CF93      		push r28
 8376               	.LCFI122:
 8377               		.cfi_def_cfa_offset 17
 8378               		.cfi_offset 28, -16
 8379 3662 DF93      		push r29
 8380               	.LCFI123:
 8381               		.cfi_def_cfa_offset 18
 8382               		.cfi_offset 29, -17
 8383 3664 EF93      		push r30
 8384               	.LCFI124:
 8385               		.cfi_def_cfa_offset 19
 8386               		.cfi_offset 30, -18
 8387 3666 FF93      		push r31
 8388               	.LCFI125:
 8389               		.cfi_def_cfa_offset 20
 8390               		.cfi_offset 31, -19
 8391               	/* prologue: Signal */
 8392               	/* frame size = 0 */
 8393               	/* stack size = 19 */
 8394               	.L__stack_usage = 19
1157:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8395               		.loc 1 1157 0
 8396 3668 8091 0000 		lds r24,bankStates+2
 8397 366c 8823      		tst r24
 8398 366e 01F0      		breq .L660
1157:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 8399               		.loc 1 1157 0 is_stmt 0 discriminator 1
 8400 3670 8091 0000 		lds r24,bankStates+2
 8401 3674 8823      		tst r24
 8402 3676 01F0      		breq .L661
 8403 3678 8091 0000 		lds r24,flipFlop.1827
 8404 367c 8823      		tst r24
 8405 367e 01F0      		breq .L661
 8406               	.L660:
1159:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
 8407               		.loc 1 1159 0 is_stmt 1
 8408 3680 0E94 0000 		call UpdateAudioChannel0
 8409               	.LVL352:
 8410 3684 8093 0000 		sts midiOutputBank0,r24
 8411               	.L661:
1161:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
 8412               		.loc 1 1161 0
 8413 3688 8091 0000 		lds r24,bankStates+8
 8414 368c 8823      		tst r24
 8415 368e 01F0      		breq .L662
1163:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
 8416               		.loc 1 1163 0
 8417 3690 A091 0000 		lds r26,bankStates+8
 8418 3694 2091 0000 		lds r18,bankStates+11
 8419 3698 3091 0000 		lds r19,bankStates+11+1
 8420               	.LVL353:
 8421 369c B0E0      		ldi r27,0
 8422 369e 0E94 0000 		call __umulhisi3
1164:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8423               		.loc 1 1164 0
 8424 36a2 2FE7      		ldi r18,lo8(127)
 8425 36a4 30E0      		ldi r19,0
 8426 36a6 40E0      		ldi r20,0
 8427 36a8 50E0      		ldi r21,0
 8428               	.LVL354:
 8429 36aa 0E94 0000 		call __udivmodsi4
 8430               	.LVL355:
1165:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8431               		.loc 1 1165 0
 8432 36ae 0091 8800 		lds r16,136
 8433 36b2 1091 8900 		lds r17,136+1
 8434 36b6 C091 0000 		lds r28,bankStates+11
 8435 36ba D091 0000 		lds r29,bankStates+11+1
1164:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8436               		.loc 1 1164 0
 8437 36be 6091 0000 		lds r22,random31
 8438 36c2 7091 0000 		lds r23,random31+1
 8439 36c6 8091 0000 		lds r24,random31+2
 8440 36ca 9091 0000 		lds r25,random31+3
 8441 36ce 0E94 0000 		call __udivmodsi4
 8442               	.LVL356:
1165:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8443               		.loc 1 1165 0
 8444 36d2 C00F      		add r28,r16
 8445 36d4 D11F      		adc r29,r17
 8446 36d6 4091 0000 		lds r20,lastJitterValue.1826
 8447 36da 5091 0000 		lds r21,lastJitterValue.1826+1
 8448 36de C40F      		add r28,r20
 8449 36e0 D51F      		adc r29,r21
 8450 36e2 C61B      		sub r28,r22
 8451 36e4 D70B      		sbc r29,r23
 8452 36e6 D093 8900 		sts 136+1,r29
 8453 36ea C093 8800 		sts 136,r28
1166:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8454               		.loc 1 1166 0
 8455 36ee 7093 0000 		sts lastJitterValue.1826+1,r23
 8456 36f2 6093 0000 		sts lastJitterValue.1826,r22
 8457 36f6 00C0      		rjmp .L663
 8458               	.LVL357:
 8459               	.L662:
1170:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8460               		.loc 1 1170 0
 8461 36f8 2091 8800 		lds r18,136
 8462 36fc 3091 8900 		lds r19,136+1
 8463 3700 8091 0000 		lds r24,bankStates+11
 8464 3704 9091 0000 		lds r25,bankStates+11+1
 8465 3708 820F      		add r24,r18
 8466 370a 931F      		adc r25,r19
 8467 370c 9093 8900 		sts 136+1,r25
 8468 3710 8093 8800 		sts 136,r24
 8469               	.L663:
1172:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8470               		.loc 1 1172 0
 8471 3714 1092 0000 		sts flipFlop.1827,__zero_reg__
1173:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8472               		.loc 1 1173 0
 8473 3718 E091 0000 		lds r30,UpdateOutput
 8474 371c F091 0000 		lds r31,UpdateOutput+1
 8475 3720 0995      		icall
 8476               	.LVL358:
1174:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8477               		.loc 1 1174 0
 8478 3722 8091 7A00 		lds r24,122
 8479 3726 86FD      		sbrc r24,6
 8480 3728 00C0      		rjmp .L659
1176:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8481               		.loc 1 1176 0
 8482 372a 8091 7900 		lds r24,121
 8483 372e 8058      		subi r24,lo8(-(-128))
 8484 3730 8093 0000 		sts adcByte,r24
1177:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8485               		.loc 1 1177 0
 8486 3734 8091 7A00 		lds r24,122
 8487 3738 8064      		ori r24,lo8(64)
 8488 373a 8093 7A00 		sts 122,r24
 8489               	.L659:
 8490               	/* epilogue start */
1179:WTPA.c        **** }
 8491               		.loc 1 1179 0
 8492 373e FF91      		pop r31
 8493 3740 EF91      		pop r30
 8494 3742 DF91      		pop r29
 8495 3744 CF91      		pop r28
 8496 3746 BF91      		pop r27
 8497 3748 AF91      		pop r26
 8498 374a 9F91      		pop r25
 8499 374c 8F91      		pop r24
 8500 374e 7F91      		pop r23
 8501 3750 6F91      		pop r22
 8502 3752 5F91      		pop r21
 8503 3754 4F91      		pop r20
 8504 3756 3F91      		pop r19
 8505 3758 2F91      		pop r18
 8506 375a 1F91      		pop r17
 8507 375c 0F91      		pop r16
 8508 375e 0F90      		pop r0
 8509 3760 0FBE      		out __SREG__,r0
 8510 3762 0F90      		pop r0
 8511 3764 1F90      		pop r1
 8512 3766 1895      		reti
 8513               		.cfi_endproc
 8514               	.LFE9:
 8516               	.global	__vector_14
 8518               	__vector_14:
 8519               	.LFB10:
1183:WTPA.c        **** {
 8520               		.loc 1 1183 0
 8521               		.cfi_startproc
 8522 3768 1F92      		push r1
 8523               	.LCFI126:
 8524               		.cfi_def_cfa_offset 3
 8525               		.cfi_offset 1, -2
 8526 376a 0F92      		push r0
 8527               	.LCFI127:
 8528               		.cfi_def_cfa_offset 4
 8529               		.cfi_offset 0, -3
 8530 376c 0FB6      		in r0,__SREG__
 8531 376e 0F92      		push r0
 8532 3770 1124      		clr __zero_reg__
 8533 3772 0F93      		push r16
 8534               	.LCFI128:
 8535               		.cfi_def_cfa_offset 5
 8536               		.cfi_offset 16, -4
 8537 3774 1F93      		push r17
 8538               	.LCFI129:
 8539               		.cfi_def_cfa_offset 6
 8540               		.cfi_offset 17, -5
 8541 3776 2F93      		push r18
 8542               	.LCFI130:
 8543               		.cfi_def_cfa_offset 7
 8544               		.cfi_offset 18, -6
 8545 3778 3F93      		push r19
 8546               	.LCFI131:
 8547               		.cfi_def_cfa_offset 8
 8548               		.cfi_offset 19, -7
 8549 377a 4F93      		push r20
 8550               	.LCFI132:
 8551               		.cfi_def_cfa_offset 9
 8552               		.cfi_offset 20, -8
 8553 377c 5F93      		push r21
 8554               	.LCFI133:
 8555               		.cfi_def_cfa_offset 10
 8556               		.cfi_offset 21, -9
 8557 377e 6F93      		push r22
 8558               	.LCFI134:
 8559               		.cfi_def_cfa_offset 11
 8560               		.cfi_offset 22, -10
 8561 3780 7F93      		push r23
 8562               	.LCFI135:
 8563               		.cfi_def_cfa_offset 12
 8564               		.cfi_offset 23, -11
 8565 3782 8F93      		push r24
 8566               	.LCFI136:
 8567               		.cfi_def_cfa_offset 13
 8568               		.cfi_offset 24, -12
 8569 3784 9F93      		push r25
 8570               	.LCFI137:
 8571               		.cfi_def_cfa_offset 14
 8572               		.cfi_offset 25, -13
 8573 3786 AF93      		push r26
 8574               	.LCFI138:
 8575               		.cfi_def_cfa_offset 15
 8576               		.cfi_offset 26, -14
 8577 3788 BF93      		push r27
 8578               	.LCFI139:
 8579               		.cfi_def_cfa_offset 16
 8580               		.cfi_offset 27, -15
 8581 378a CF93      		push r28
 8582               	.LCFI140:
 8583               		.cfi_def_cfa_offset 17
 8584               		.cfi_offset 28, -16
 8585 378c DF93      		push r29
 8586               	.LCFI141:
 8587               		.cfi_def_cfa_offset 18
 8588               		.cfi_offset 29, -17
 8589 378e EF93      		push r30
 8590               	.LCFI142:
 8591               		.cfi_def_cfa_offset 19
 8592               		.cfi_offset 30, -18
 8593 3790 FF93      		push r31
 8594               	.LCFI143:
 8595               		.cfi_def_cfa_offset 20
 8596               		.cfi_offset 31, -19
 8597               	/* prologue: Signal */
 8598               	/* frame size = 0 */
 8599               	/* stack size = 19 */
 8600               	.L__stack_usage = 19
1193:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8601               		.loc 1 1193 0
 8602 3792 8091 0000 		lds r24,bankStates+38
 8603 3796 8823      		tst r24
 8604 3798 01F0      		breq .L675
1193:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8605               		.loc 1 1193 0 is_stmt 0 discriminator 1
 8606 379a 8091 0000 		lds r24,bankStates+38
 8607 379e 8823      		tst r24
 8608 37a0 01F0      		breq .L676
 8609 37a2 8091 0000 		lds r24,flipFlop.1835
 8610 37a6 8823      		tst r24
 8611 37a8 01F0      		breq .L676
 8612               	.L675:
1195:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
 8613               		.loc 1 1195 0 is_stmt 1
 8614 37aa 0E94 0000 		call UpdateAudioChannel1
 8615               	.LVL359:
 8616 37ae 8093 0000 		sts midiOutputBank1,r24
 8617               	.L676:
1197:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
 8618               		.loc 1 1197 0
 8619 37b2 8091 0000 		lds r24,bankStates+44
 8620 37b6 8823      		tst r24
 8621 37b8 01F0      		breq .L677
1199:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
 8622               		.loc 1 1199 0
 8623 37ba A091 0000 		lds r26,bankStates+44
 8624 37be 2091 0000 		lds r18,bankStates+47
 8625 37c2 3091 0000 		lds r19,bankStates+47+1
 8626               	.LVL360:
 8627 37c6 B0E0      		ldi r27,0
 8628 37c8 0E94 0000 		call __umulhisi3
1200:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8629               		.loc 1 1200 0
 8630 37cc 2FE7      		ldi r18,lo8(127)
 8631 37ce 30E0      		ldi r19,0
 8632 37d0 40E0      		ldi r20,0
 8633 37d2 50E0      		ldi r21,0
 8634               	.LVL361:
 8635 37d4 0E94 0000 		call __udivmodsi4
 8636               	.LVL362:
1201:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8637               		.loc 1 1201 0
 8638 37d8 0091 8A00 		lds r16,138
 8639 37dc 1091 8B00 		lds r17,138+1
 8640 37e0 C091 0000 		lds r28,bankStates+47
 8641 37e4 D091 0000 		lds r29,bankStates+47+1
1200:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8642               		.loc 1 1200 0
 8643 37e8 6091 0000 		lds r22,random31
 8644 37ec 7091 0000 		lds r23,random31+1
 8645 37f0 8091 0000 		lds r24,random31+2
 8646 37f4 9091 0000 		lds r25,random31+3
 8647 37f8 0E94 0000 		call __udivmodsi4
 8648               	.LVL363:
1201:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8649               		.loc 1 1201 0
 8650 37fc C00F      		add r28,r16
 8651 37fe D11F      		adc r29,r17
 8652 3800 4091 0000 		lds r20,lastJitterValue.1834
 8653 3804 5091 0000 		lds r21,lastJitterValue.1834+1
 8654 3808 C40F      		add r28,r20
 8655 380a D51F      		adc r29,r21
 8656 380c C61B      		sub r28,r22
 8657 380e D70B      		sbc r29,r23
 8658 3810 D093 8B00 		sts 138+1,r29
 8659 3814 C093 8A00 		sts 138,r28
1202:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8660               		.loc 1 1202 0
 8661 3818 7093 0000 		sts lastJitterValue.1834+1,r23
 8662 381c 6093 0000 		sts lastJitterValue.1834,r22
 8663 3820 00C0      		rjmp .L678
 8664               	.LVL364:
 8665               	.L677:
1206:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8666               		.loc 1 1206 0
 8667 3822 2091 8A00 		lds r18,138
 8668 3826 3091 8B00 		lds r19,138+1
 8669 382a 8091 0000 		lds r24,bankStates+47
 8670 382e 9091 0000 		lds r25,bankStates+47+1
 8671 3832 820F      		add r24,r18
 8672 3834 931F      		adc r25,r19
 8673 3836 9093 8B00 		sts 138+1,r25
 8674 383a 8093 8A00 		sts 138,r24
 8675               	.L678:
1208:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8676               		.loc 1 1208 0
 8677 383e 1092 0000 		sts flipFlop.1835,__zero_reg__
1209:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8678               		.loc 1 1209 0
 8679 3842 E091 0000 		lds r30,UpdateOutput
 8680 3846 F091 0000 		lds r31,UpdateOutput+1
 8681 384a 0995      		icall
 8682               	.LVL365:
1210:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8683               		.loc 1 1210 0
 8684 384c 8091 7A00 		lds r24,122
 8685 3850 86FD      		sbrc r24,6
 8686 3852 00C0      		rjmp .L674
1212:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8687               		.loc 1 1212 0
 8688 3854 8091 7900 		lds r24,121
 8689 3858 8058      		subi r24,lo8(-(-128))
 8690 385a 8093 0000 		sts adcByte,r24
1213:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8691               		.loc 1 1213 0
 8692 385e 8091 7A00 		lds r24,122
 8693 3862 8064      		ori r24,lo8(64)
 8694 3864 8093 7A00 		sts 122,r24
 8695               	.L674:
 8696               	/* epilogue start */
1215:WTPA.c        **** }
 8697               		.loc 1 1215 0
 8698 3868 FF91      		pop r31
 8699 386a EF91      		pop r30
 8700 386c DF91      		pop r29
 8701 386e CF91      		pop r28
 8702 3870 BF91      		pop r27
 8703 3872 AF91      		pop r26
 8704 3874 9F91      		pop r25
 8705 3876 8F91      		pop r24
 8706 3878 7F91      		pop r23
 8707 387a 6F91      		pop r22
 8708 387c 5F91      		pop r21
 8709 387e 4F91      		pop r20
 8710 3880 3F91      		pop r19
 8711 3882 2F91      		pop r18
 8712 3884 1F91      		pop r17
 8713 3886 0F91      		pop r16
 8714 3888 0F90      		pop r0
 8715 388a 0FBE      		out __SREG__,r0
 8716 388c 0F90      		pop r0
 8717 388e 1F90      		pop r1
 8718 3890 1895      		reti
 8719               		.cfi_endproc
 8720               	.LFE10:
 8722               	.global	__vector_10
 8724               	__vector_10:
 8725               	.LFB11:
1221:WTPA.c        **** {
 8726               		.loc 1 1221 0
 8727               		.cfi_startproc
 8728 3892 1F92      		push r1
 8729               	.LCFI144:
 8730               		.cfi_def_cfa_offset 3
 8731               		.cfi_offset 1, -2
 8732 3894 0F92      		push r0
 8733               	.LCFI145:
 8734               		.cfi_def_cfa_offset 4
 8735               		.cfi_offset 0, -3
 8736 3896 0FB6      		in r0,__SREG__
 8737 3898 0F92      		push r0
 8738 389a 1124      		clr __zero_reg__
 8739 389c 2F93      		push r18
 8740               	.LCFI146:
 8741               		.cfi_def_cfa_offset 5
 8742               		.cfi_offset 18, -4
 8743 389e 3F93      		push r19
 8744               	.LCFI147:
 8745               		.cfi_def_cfa_offset 6
 8746               		.cfi_offset 19, -5
 8747 38a0 4F93      		push r20
 8748               	.LCFI148:
 8749               		.cfi_def_cfa_offset 7
 8750               		.cfi_offset 20, -6
 8751 38a2 5F93      		push r21
 8752               	.LCFI149:
 8753               		.cfi_def_cfa_offset 8
 8754               		.cfi_offset 21, -7
 8755 38a4 6F93      		push r22
 8756               	.LCFI150:
 8757               		.cfi_def_cfa_offset 9
 8758               		.cfi_offset 22, -8
 8759 38a6 7F93      		push r23
 8760               	.LCFI151:
 8761               		.cfi_def_cfa_offset 10
 8762               		.cfi_offset 23, -9
 8763 38a8 8F93      		push r24
 8764               	.LCFI152:
 8765               		.cfi_def_cfa_offset 11
 8766               		.cfi_offset 24, -10
 8767 38aa 9F93      		push r25
 8768               	.LCFI153:
 8769               		.cfi_def_cfa_offset 12
 8770               		.cfi_offset 25, -11
 8771 38ac AF93      		push r26
 8772               	.LCFI154:
 8773               		.cfi_def_cfa_offset 13
 8774               		.cfi_offset 26, -12
 8775 38ae BF93      		push r27
 8776               	.LCFI155:
 8777               		.cfi_def_cfa_offset 14
 8778               		.cfi_offset 27, -13
 8779 38b0 EF93      		push r30
 8780               	.LCFI156:
 8781               		.cfi_def_cfa_offset 15
 8782               		.cfi_offset 30, -14
 8783 38b2 FF93      		push r31
 8784               	.LCFI157:
 8785               		.cfi_def_cfa_offset 16
 8786               		.cfi_offset 31, -15
 8787               	/* prologue: Signal */
 8788               	/* frame size = 0 */
 8789               	/* stack size = 15 */
 8790               	.L__stack_usage = 15
1225:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
 8791               		.loc 1 1225 0
 8792 38b4 8091 0000 		lds r24,sdIsrState
 8793 38b8 8130      		cpi r24,lo8(1)
 8794 38ba 01F0      		breq .+2
 8795 38bc 00C0      		rjmp .L690
1227:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 8796               		.loc 1 1227 0
 8797 38be 8091 0000 		lds r24,sdRamSampleRemaining
 8798 38c2 9091 0000 		lds r25,sdRamSampleRemaining+1
 8799 38c6 A091 0000 		lds r26,sdRamSampleRemaining+2
 8800 38ca B091 0000 		lds r27,sdRamSampleRemaining+3
 8801 38ce 892B      		or r24,r25
 8802 38d0 8A2B      		or r24,r26
 8803 38d2 8B2B      		or r24,r27
 8804 38d4 01F4      		brne .+2
 8805 38d6 00C0      		rjmp .L691
1229:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 8806               		.loc 1 1229 0
 8807 38d8 8091 0000 		lds r24,sdBytesInFifo
 8808 38dc 9091 0000 		lds r25,sdBytesInFifo+1
 8809 38e0 892B      		or r24,r25
 8810 38e2 01F4      		brne .+2
 8811 38e4 00C0      		rjmp .L689
1231:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 8812               		.loc 1 1231 0
 8813 38e6 E091 0000 		lds r30,sdFifoReadPointer
 8814 38ea F091 0000 		lds r31,sdFifoReadPointer+1
 8815 38ee E050      		subi r30,lo8(-(sdFifo))
 8816 38f0 F040      		sbci r31,hi8(-(sdFifo))
 8817 38f2 2081      		ld r18,Z
 8818               	.LVL366:
1233:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 8819               		.loc 1 1233 0
 8820 38f4 8091 0000 		lds r24,sdFifoReadPointer
 8821 38f8 9091 0000 		lds r25,sdFifoReadPointer+1
 8822 38fc 0196      		adiw r24,1
 8823 38fe 9093 0000 		sts sdFifoReadPointer+1,r25
 8824 3902 8093 0000 		sts sdFifoReadPointer,r24
1234:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 8825               		.loc 1 1234 0
 8826 3906 8091 0000 		lds r24,sdFifoReadPointer
 8827 390a 9091 0000 		lds r25,sdFifoReadPointer+1
 8828 390e 8115      		cp r24,__zero_reg__
 8829 3910 9340      		sbci r25,3
 8830 3912 00F0      		brlo .L693
1236:WTPA.c        **** 					sdFifoReadPointer=0;
 8831               		.loc 1 1236 0
 8832 3914 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 8833 3918 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 8834               	.L693:
1239:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 8835               		.loc 1 1239 0
 8836 391c 8091 0000 		lds r24,sdBytesInFifo
 8837 3920 9091 0000 		lds r25,sdBytesInFifo+1
 8838 3924 0197      		sbiw r24,1
 8839 3926 9093 0000 		sts sdBytesInFifo+1,r25
 8840 392a 8093 0000 		sts sdBytesInFifo,r24
1240:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 8841               		.loc 1 1240 0
 8842 392e 8091 0000 		lds r24,sdRamSampleRemaining
 8843 3932 9091 0000 		lds r25,sdRamSampleRemaining+1
 8844 3936 A091 0000 		lds r26,sdRamSampleRemaining+2
 8845 393a B091 0000 		lds r27,sdRamSampleRemaining+3
 8846 393e 0197      		sbiw r24,1
 8847 3940 A109      		sbc r26,__zero_reg__
 8848 3942 B109      		sbc r27,__zero_reg__
 8849 3944 8093 0000 		sts sdRamSampleRemaining,r24
 8850 3948 9093 0000 		sts sdRamSampleRemaining+1,r25
 8851 394c A093 0000 		sts sdRamSampleRemaining+2,r26
 8852 3950 B093 0000 		sts sdRamSampleRemaining+3,r27
1244:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
 8853               		.loc 1 1244 0
 8854 3954 8FEF      		ldi r24,lo8(-1)
 8855 3956 84B9      		out 0x4,r24
1245:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
 8856               		.loc 1 1245 0
 8857 3958 8091 0000 		lds r24,sdRamAddress
 8858 395c 85B9      		out 0x5,r24
1246:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
 8859               		.loc 1 1246 0
 8860 395e 139A      		sbi 0x2,3
1247:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
 8861               		.loc 1 1247 0
 8862 3960 1398      		cbi 0x2,3
1249:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
 8863               		.loc 1 1249 0
 8864 3962 4091 0000 		lds r20,sdRamAddress
 8865 3966 5091 0000 		lds r21,sdRamAddress+1
 8866 396a 6091 0000 		lds r22,sdRamAddress+2
 8867 396e 7091 0000 		lds r23,sdRamAddress+3
 8868 3972 BB27      		clr r27
 8869 3974 A72F      		mov r26,r23
 8870 3976 962F      		mov r25,r22
 8871 3978 852F      		mov r24,r21
 8872 397a 85B9      		out 0x5,r24
1250:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
 8873               		.loc 1 1250 0
 8874 397c 149A      		sbi 0x2,4
1251:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
 8875               		.loc 1 1251 0
 8876 397e 1498      		cbi 0x2,4
1252:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
 8877               		.loc 1 1252 0
 8878 3980 CB01      		movw r24,r22
 8879 3982 AA27      		clr r26
 8880 3984 BB27      		clr r27
 8881 3986 8770      		andi r24,7
 8882 3988 9927      		clr r25
 8883 398a AA27      		clr r26
 8884 398c BB27      		clr r27
 8885 398e 8868      		ori r24,136
 8886 3990 88B9      		out 0x8,r24
1254:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
 8887               		.loc 1 1254 0
 8888 3992 25B9      		out 0x5,r18
1257:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
 8889               		.loc 1 1257 0
 8890 3994 8091 0000 		lds r24,sdBank0
 8891 3998 8130      		cpi r24,lo8(1)
 8892 399a 01F4      		brne .L694
1259:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 8893               		.loc 1 1259 0
 8894 399c 4F5F      		subi r20,-1
 8895 399e 5F4F      		sbci r21,-1
 8896 39a0 6F4F      		sbci r22,-1
 8897 39a2 7F4F      		sbci r23,-1
 8898 39a4 00C0      		rjmp .L711
 8899               	.L694:
1263:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 8900               		.loc 1 1263 0
 8901 39a6 4150      		subi r20,1
 8902 39a8 5109      		sbc r21,__zero_reg__
 8903 39aa 6109      		sbc r22,__zero_reg__
 8904 39ac 7109      		sbc r23,__zero_reg__
 8905               	.L711:
 8906 39ae 4093 0000 		sts sdRamAddress,r20
 8907 39b2 5093 0000 		sts sdRamAddress+1,r21
 8908 39b6 6093 0000 		sts sdRamAddress+2,r22
 8909 39ba 7093 0000 		sts sdRamAddress+3,r23
1267:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 8910               		.loc 1 1267 0
 8911 39be 1198      		cbi 0x2,1
1268:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
 8912               		.loc 1 1268 0
 8913 39c0 119A      		sbi 0x2,1
 8914 39c2 00C0      		rjmp .L689
 8915               	.LVL367:
 8916               	.L691:
1274:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8917               		.loc 1 1274 0
 8918 39c4 1092 0000 		sts sdIsrState,__zero_reg__
1275:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 8919               		.loc 1 1275 0
 8920 39c8 1092 B100 		sts 177,__zero_reg__
1276:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8921               		.loc 1 1276 0
 8922 39cc 8091 7000 		lds r24,112
 8923 39d0 8B7F      		andi r24,lo8(-5)
 8924 39d2 8093 7000 		sts 112,r24
1278:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
 8925               		.loc 1 1278 0
 8926 39d6 2091 0000 		lds r18,sdBank0
 8927 39da 8091 0000 		lds r24,sdRamAddress
 8928 39de 9091 0000 		lds r25,sdRamAddress+1
 8929 39e2 A091 0000 		lds r26,sdRamAddress+2
 8930 39e6 B091 0000 		lds r27,sdRamAddress+3
 8931 39ea 2130      		cpi r18,lo8(1)
 8932 39ec 01F4      		brne .L696
1280:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
 8933               		.loc 1 1280 0
 8934 39ee 1092 0000 		sts bankStates+5,__zero_reg__
1281:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8935               		.loc 1 1281 0
 8936 39f2 8093 0000 		sts bankStates+13,r24
 8937 39f6 9093 0000 		sts bankStates+13+1,r25
 8938 39fa A093 0000 		sts bankStates+13+2,r26
 8939 39fe B093 0000 		sts bankStates+13+3,r27
1282:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8940               		.loc 1 1282 0
 8941 3a02 8093 0000 		sts bankStates+21,r24
 8942 3a06 9093 0000 		sts bankStates+21+1,r25
 8943 3a0a A093 0000 		sts bankStates+21+2,r26
 8944 3a0e B093 0000 		sts bankStates+21+3,r27
 8945 3a12 00C0      		rjmp .L689
 8946               	.L696:
1286:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
 8947               		.loc 1 1286 0
 8948 3a14 1092 0000 		sts bankStates+41,__zero_reg__
1287:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8949               		.loc 1 1287 0
 8950 3a18 8093 0000 		sts bankStates+49,r24
 8951 3a1c 9093 0000 		sts bankStates+49+1,r25
 8952 3a20 A093 0000 		sts bankStates+49+2,r26
 8953 3a24 B093 0000 		sts bankStates+49+3,r27
1288:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8954               		.loc 1 1288 0
 8955 3a28 8093 0000 		sts bankStates+57,r24
 8956 3a2c 9093 0000 		sts bankStates+57+1,r25
 8957 3a30 A093 0000 		sts bankStates+57+2,r26
 8958 3a34 B093 0000 		sts bankStates+57+3,r27
 8959 3a38 00C0      		rjmp .L689
 8960               	.L690:
1292:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
 8961               		.loc 1 1292 0
 8962 3a3a 8230      		cpi r24,lo8(2)
 8963 3a3c 01F0      		breq .+2
 8964 3a3e 00C0      		rjmp .L697
1295:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
 8965               		.loc 1 1295 0
 8966 3a40 8091 0000 		lds r24,sdBytesInFifo
 8967 3a44 9091 0000 		lds r25,sdBytesInFifo+1
 8968 3a48 8115      		cp r24,__zero_reg__
 8969 3a4a 9340      		sbci r25,3
 8970 3a4c 00F0      		brlo .+2
 8971 3a4e 00C0      		rjmp .L689
1297:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
 8972               		.loc 1 1297 0
 8973 3a50 8091 0000 		lds r24,sdRamSampleRemaining
 8974 3a54 9091 0000 		lds r25,sdRamSampleRemaining+1
 8975 3a58 A091 0000 		lds r26,sdRamSampleRemaining+2
 8976 3a5c B091 0000 		lds r27,sdRamSampleRemaining+3
 8977 3a60 892B      		or r24,r25
 8978 3a62 8A2B      		or r24,r26
 8979 3a64 8B2B      		or r24,r27
 8980 3a66 01F4      		brne .+2
 8981 3a68 00C0      		rjmp .L698
1300:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
 8982               		.loc 1 1300 0
 8983 3a6a 8091 0000 		lds r24,sdRamAddress
 8984 3a6e 85B9      		out 0x5,r24
1301:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
 8985               		.loc 1 1301 0
 8986 3a70 139A      		sbi 0x2,3
1302:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
 8987               		.loc 1 1302 0
 8988 3a72 1398      		cbi 0x2,3
1304:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
 8989               		.loc 1 1304 0
 8990 3a74 4091 0000 		lds r20,sdRamAddress
 8991 3a78 5091 0000 		lds r21,sdRamAddress+1
 8992 3a7c 6091 0000 		lds r22,sdRamAddress+2
 8993 3a80 7091 0000 		lds r23,sdRamAddress+3
 8994 3a84 BB27      		clr r27
 8995 3a86 A72F      		mov r26,r23
 8996 3a88 962F      		mov r25,r22
 8997 3a8a 852F      		mov r24,r21
 8998 3a8c 85B9      		out 0x5,r24
1305:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
 8999               		.loc 1 1305 0
 9000 3a8e 149A      		sbi 0x2,4
1306:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
 9001               		.loc 1 1306 0
 9002 3a90 1498      		cbi 0x2,4
1308:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
 9003               		.loc 1 1308 0
 9004 3a92 CB01      		movw r24,r22
 9005 3a94 AA27      		clr r26
 9006 3a96 BB27      		clr r27
 9007 3a98 8770      		andi r24,7
 9008 3a9a 9927      		clr r25
 9009 3a9c AA27      		clr r26
 9010 3a9e BB27      		clr r27
 9011 3aa0 8868      		ori r24,136
 9012 3aa2 88B9      		out 0x8,r24
1310:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 9013               		.loc 1 1310 0
 9014 3aa4 14B8      		out 0x4,__zero_reg__
1311:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 9015               		.loc 1 1311 0
 9016 3aa6 1298      		cbi 0x2,2
1314:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
 9017               		.loc 1 1314 0
 9018 3aa8 8091 0000 		lds r24,sdBank0
 9019 3aac 8130      		cpi r24,lo8(1)
 9020 3aae 01F4      		brne .L699
1316:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 9021               		.loc 1 1316 0
 9022 3ab0 4F5F      		subi r20,-1
 9023 3ab2 5F4F      		sbci r21,-1
 9024 3ab4 6F4F      		sbci r22,-1
 9025 3ab6 7F4F      		sbci r23,-1
 9026 3ab8 00C0      		rjmp .L712
 9027               	.L699:
1320:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 9028               		.loc 1 1320 0
 9029 3aba 4150      		subi r20,1
 9030 3abc 5109      		sbc r21,__zero_reg__
 9031 3abe 6109      		sbc r22,__zero_reg__
 9032 3ac0 7109      		sbc r23,__zero_reg__
 9033               	.L712:
 9034 3ac2 4093 0000 		sts sdRamAddress,r20
 9035 3ac6 5093 0000 		sts sdRamAddress+1,r21
 9036 3aca 6093 0000 		sts sdRamAddress+2,r22
 9037 3ace 7093 0000 		sts sdRamAddress+3,r23
1325:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 9038               		.loc 1 1325 0
 9039 3ad2 83B1      		in r24,0x3
 9040               	.LVL368:
1326:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 9041               		.loc 1 1326 0
 9042 3ad4 129A      		sbi 0x2,2
1327:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 9043               		.loc 1 1327 0
 9044 3ad6 9FEF      		ldi r25,lo8(-1)
 9045 3ad8 94B9      		out 0x4,r25
1332:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
 9046               		.loc 1 1332 0
 9047 3ada E091 0000 		lds r30,sdFifoWritePointer
 9048 3ade F091 0000 		lds r31,sdFifoWritePointer+1
 9049 3ae2 E050      		subi r30,lo8(-(sdFifo))
 9050 3ae4 F040      		sbci r31,hi8(-(sdFifo))
 9051 3ae6 8083      		st Z,r24
1333:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
 9052               		.loc 1 1333 0
 9053 3ae8 8091 0000 		lds r24,sdFifoWritePointer
 9054 3aec 9091 0000 		lds r25,sdFifoWritePointer+1
 9055               	.LVL369:
 9056 3af0 0196      		adiw r24,1
 9057 3af2 9093 0000 		sts sdFifoWritePointer+1,r25
 9058 3af6 8093 0000 		sts sdFifoWritePointer,r24
1335:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
 9059               		.loc 1 1335 0
 9060 3afa 8091 0000 		lds r24,sdFifoWritePointer
 9061 3afe 9091 0000 		lds r25,sdFifoWritePointer+1
 9062 3b02 8115      		cp r24,__zero_reg__
 9063 3b04 9340      		sbci r25,3
 9064 3b06 00F0      		brlo .L701
1337:WTPA.c        **** 					sdFifoWritePointer=0;
 9065               		.loc 1 1337 0
 9066 3b08 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 9067 3b0c 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 9068               	.L701:
1340:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
 9069               		.loc 1 1340 0
 9070 3b10 8091 0000 		lds r24,sdBytesInFifo
 9071 3b14 9091 0000 		lds r25,sdBytesInFifo+1
 9072 3b18 0196      		adiw r24,1
 9073 3b1a 9093 0000 		sts sdBytesInFifo+1,r25
 9074 3b1e 8093 0000 		sts sdBytesInFifo,r24
1341:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
 9075               		.loc 1 1341 0
 9076 3b22 8091 0000 		lds r24,sdRamSampleRemaining
 9077 3b26 9091 0000 		lds r25,sdRamSampleRemaining+1
 9078 3b2a A091 0000 		lds r26,sdRamSampleRemaining+2
 9079 3b2e B091 0000 		lds r27,sdRamSampleRemaining+3
 9080 3b32 0197      		sbiw r24,1
 9081 3b34 A109      		sbc r26,__zero_reg__
 9082 3b36 B109      		sbc r27,__zero_reg__
 9083 3b38 8093 0000 		sts sdRamSampleRemaining,r24
 9084 3b3c 9093 0000 		sts sdRamSampleRemaining+1,r25
 9085 3b40 A093 0000 		sts sdRamSampleRemaining+2,r26
 9086 3b44 B093 0000 		sts sdRamSampleRemaining+3,r27
 9087 3b48 00C0      		rjmp .L689
 9088               	.LVL370:
 9089               	.L698:
1346:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 9090               		.loc 1 1346 0
 9091 3b4a 1092 0000 		sts sdIsrState,__zero_reg__
1347:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
 9092               		.loc 1 1347 0
 9093 3b4e 1092 B100 		sts 177,__zero_reg__
1348:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 9094               		.loc 1 1348 0
 9095 3b52 8091 7000 		lds r24,112
 9096 3b56 8B7F      		andi r24,lo8(-5)
 9097 3b58 8093 7000 		sts 112,r24
1350:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
 9098               		.loc 1 1350 0
 9099 3b5c 8091 0000 		lds r24,sdBank0
 9100 3b60 8130      		cpi r24,lo8(1)
 9101 3b62 01F4      		brne .L702
1352:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
 9102               		.loc 1 1352 0
 9103 3b64 1092 0000 		sts bankStates+5,__zero_reg__
 9104 3b68 00C0      		rjmp .L689
 9105               	.L702:
1356:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
 9106               		.loc 1 1356 0
 9107 3b6a 1092 0000 		sts bankStates+41,__zero_reg__
 9108 3b6e 00C0      		rjmp .L689
 9109               	.L697:
1361:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
 9110               		.loc 1 1361 0
 9111 3b70 8330      		cpi r24,lo8(3)
 9112 3b72 01F0      		breq .+2
 9113 3b74 00C0      		rjmp .L689
1363:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 9114               		.loc 1 1363 0
 9115 3b76 8091 0000 		lds r24,sdRamSampleRemaining
 9116 3b7a 9091 0000 		lds r25,sdRamSampleRemaining+1
 9117 3b7e A091 0000 		lds r26,sdRamSampleRemaining+2
 9118 3b82 B091 0000 		lds r27,sdRamSampleRemaining+3
 9119 3b86 892B      		or r24,r25
 9120 3b88 8A2B      		or r24,r26
 9121 3b8a 8B2B      		or r24,r27
 9122 3b8c 01F4      		brne .+2
 9123 3b8e 00C0      		rjmp .L703
1365:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 9124               		.loc 1 1365 0
 9125 3b90 8091 0000 		lds r24,sdBytesInFifo
 9126 3b94 9091 0000 		lds r25,sdBytesInFifo+1
 9127 3b98 892B      		or r24,r25
 9128 3b9a 01F4      		brne .+2
 9129 3b9c 00C0      		rjmp .L689
1367:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 9130               		.loc 1 1367 0
 9131 3b9e E091 0000 		lds r30,sdFifoReadPointer
 9132 3ba2 F091 0000 		lds r31,sdFifoReadPointer+1
 9133 3ba6 E050      		subi r30,lo8(-(sdFifo))
 9134 3ba8 F040      		sbci r31,hi8(-(sdFifo))
 9135 3baa 2081      		ld r18,Z
 9136               	.LVL371:
1369:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 9137               		.loc 1 1369 0
 9138 3bac 8091 0000 		lds r24,sdFifoReadPointer
 9139 3bb0 9091 0000 		lds r25,sdFifoReadPointer+1
 9140 3bb4 0196      		adiw r24,1
 9141 3bb6 9093 0000 		sts sdFifoReadPointer+1,r25
 9142 3bba 8093 0000 		sts sdFifoReadPointer,r24
1370:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 9143               		.loc 1 1370 0
 9144 3bbe 8091 0000 		lds r24,sdFifoReadPointer
 9145 3bc2 9091 0000 		lds r25,sdFifoReadPointer+1
 9146 3bc6 8115      		cp r24,__zero_reg__
 9147 3bc8 9340      		sbci r25,3
 9148 3bca 00F0      		brlo .L704
1372:WTPA.c        **** 					sdFifoReadPointer=0;
 9149               		.loc 1 1372 0
 9150 3bcc 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 9151 3bd0 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 9152               	.L704:
1375:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 9153               		.loc 1 1375 0
 9154 3bd4 8091 0000 		lds r24,sdBytesInFifo
 9155 3bd8 9091 0000 		lds r25,sdBytesInFifo+1
 9156 3bdc 0197      		sbiw r24,1
 9157 3bde 9093 0000 		sts sdBytesInFifo+1,r25
 9158 3be2 8093 0000 		sts sdBytesInFifo,r24
1376:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 9159               		.loc 1 1376 0
 9160 3be6 8091 0000 		lds r24,sdRamSampleRemaining
 9161 3bea 9091 0000 		lds r25,sdRamSampleRemaining+1
 9162 3bee A091 0000 		lds r26,sdRamSampleRemaining+2
 9163 3bf2 B091 0000 		lds r27,sdRamSampleRemaining+3
 9164 3bf6 0197      		sbiw r24,1
 9165 3bf8 A109      		sbc r26,__zero_reg__
 9166 3bfa B109      		sbc r27,__zero_reg__
 9167 3bfc 8093 0000 		sts sdRamSampleRemaining,r24
 9168 3c00 9093 0000 		sts sdRamSampleRemaining+1,r25
 9169 3c04 A093 0000 		sts sdRamSampleRemaining+2,r26
 9170 3c08 B093 0000 		sts sdRamSampleRemaining+3,r27
1380:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
 9171               		.loc 1 1380 0
 9172 3c0c 2093 0000 		sts sdStreamOutput,r18
1381:WTPA.c        **** 				UpdateOutput();				// Update the DAC
 9173               		.loc 1 1381 0
 9174 3c10 E091 0000 		lds r30,UpdateOutput
 9175 3c14 F091 0000 		lds r31,UpdateOutput+1
 9176 3c18 0995      		icall
 9177               	.LVL372:
 9178 3c1a 00C0      		rjmp .L689
 9179               	.L703:
1386:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 9180               		.loc 1 1386 0
 9181 3c1c 1092 0000 		sts sdIsrState,__zero_reg__
1387:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 9182               		.loc 1 1387 0
 9183 3c20 1092 B100 		sts 177,__zero_reg__
1388:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 9184               		.loc 1 1388 0
 9185 3c24 8091 7000 		lds r24,112
 9186 3c28 8B7F      		andi r24,lo8(-5)
 9187 3c2a 8093 7000 		sts 112,r24
1391:WTPA.c        **** 			sdStreamOutput=0;
 9188               		.loc 1 1391 0
 9189 3c2e 1092 0000 		sts sdStreamOutput,__zero_reg__
 9190               	.L689:
 9191               	/* epilogue start */
1394:WTPA.c        **** }
 9192               		.loc 1 1394 0
 9193 3c32 FF91      		pop r31
 9194 3c34 EF91      		pop r30
 9195 3c36 BF91      		pop r27
 9196 3c38 AF91      		pop r26
 9197 3c3a 9F91      		pop r25
 9198 3c3c 8F91      		pop r24
 9199 3c3e 7F91      		pop r23
 9200 3c40 6F91      		pop r22
 9201 3c42 5F91      		pop r21
 9202 3c44 4F91      		pop r20
 9203 3c46 3F91      		pop r19
 9204 3c48 2F91      		pop r18
 9205 3c4a 0F90      		pop r0
 9206 3c4c 0FBE      		out __SREG__,r0
 9207 3c4e 0F90      		pop r0
 9208 3c50 1F90      		pop r1
 9209 3c52 1895      		reti
 9210               		.cfi_endproc
 9211               	.LFE11:
 9213               	.global	__vector_9
 9215               	__vector_9:
 9216               	.LFB12:
1399:WTPA.c        **** {
 9217               		.loc 1 1399 0
 9218               		.cfi_startproc
 9219 3c54 1F92      		push r1
 9220               	.LCFI158:
 9221               		.cfi_def_cfa_offset 3
 9222               		.cfi_offset 1, -2
 9223 3c56 0F92      		push r0
 9224               	.LCFI159:
 9225               		.cfi_def_cfa_offset 4
 9226               		.cfi_offset 0, -3
 9227 3c58 0FB6      		in r0,__SREG__
 9228 3c5a 0F92      		push r0
 9229 3c5c 1124      		clr __zero_reg__
 9230 3c5e 8F93      		push r24
 9231               	.LCFI160:
 9232               		.cfi_def_cfa_offset 5
 9233               		.cfi_offset 24, -4
 9234 3c60 9F93      		push r25
 9235               	.LCFI161:
 9236               		.cfi_def_cfa_offset 6
 9237               		.cfi_offset 25, -5
 9238               	/* prologue: Signal */
 9239               	/* frame size = 0 */
 9240               	/* stack size = 5 */
 9241               	.L__stack_usage = 5
1403:WTPA.c        **** 	if(ledPwm>pwmCount)
 9242               		.loc 1 1403 0
 9243 3c62 9091 0000 		lds r25,ledPwm
 9244 3c66 8091 0000 		lds r24,pwmCount.1847
 9245 3c6a 8917      		cp r24,r25
 9246 3c6c 00F4      		brsh .L714
1405:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
 9247               		.loc 1 1405 0
 9248 3c6e 9FEF      		ldi r25,lo8(-1)
 9249 3c70 95B9      		out 0x5,r25
 9250 3c72 00C0      		rjmp .L715
 9251               	.L714:
1409:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
 9252               		.loc 1 1409 0
 9253 3c74 15B8      		out 0x5,__zero_reg__
 9254               	.L715:
1411:WTPA.c        **** 	pwmCount++;
 9255               		.loc 1 1411 0
 9256 3c76 8F5F      		subi r24,lo8(-(1))
 9257 3c78 8093 0000 		sts pwmCount.1847,r24
 9258               	/* epilogue start */
1412:WTPA.c        **** }
 9259               		.loc 1 1412 0
 9260 3c7c 9F91      		pop r25
 9261 3c7e 8F91      		pop r24
 9262 3c80 0F90      		pop r0
 9263 3c82 0FBE      		out __SREG__,r0
 9264 3c84 0F90      		pop r0
 9265 3c86 1F90      		pop r1
 9266 3c88 1895      		reti
 9267               		.cfi_endproc
 9268               	.LFE12:
 9270               	.global	__vector_default
 9272               	__vector_default:
 9273               	.LFB13:
1415:WTPA.c        **** {
 9274               		.loc 1 1415 0
 9275               		.cfi_startproc
 9276 3c8a 1F92      		push r1
 9277               	.LCFI162:
 9278               		.cfi_def_cfa_offset 3
 9279               		.cfi_offset 1, -2
 9280 3c8c 0F92      		push r0
 9281               	.LCFI163:
 9282               		.cfi_def_cfa_offset 4
 9283               		.cfi_offset 0, -3
 9284 3c8e 0FB6      		in r0,__SREG__
 9285 3c90 0F92      		push r0
 9286 3c92 1124      		clr __zero_reg__
 9287               	/* prologue: Signal */
 9288               	/* frame size = 0 */
 9289               	/* stack size = 3 */
 9290               	.L__stack_usage = 3
 9291               	/* epilogue start */
1419:WTPA.c        **** }
 9292               		.loc 1 1419 0
 9293 3c94 0F90      		pop r0
 9294 3c96 0FBE      		out __SREG__,r0
 9295 3c98 0F90      		pop r0
 9296 3c9a 1F90      		pop r1
 9297 3c9c 1895      		reti
 9298               		.cfi_endproc
 9299               	.LFE13:
 9301               	.global	HandleSoftclock
 9303               	HandleSoftclock:
 9304               	.LFB15:
1442:WTPA.c        **** {
 9305               		.loc 1 1442 0
 9306               		.cfi_startproc
 9307               	/* prologue: function */
 9308               	/* frame size = 0 */
 9309               	/* stack size = 0 */
 9310               	.L__stack_usage = 0
1443:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 9311               		.loc 1 1443 0
 9312 3c9e A89B      		sbis 0x15,0
 9313 3ca0 00C0      		rjmp .L717
 9314               	.LBB307:
 9315               	.LBB308:
1445:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 9316               		.loc 1 1445 0
 9317 3ca2 A89A      		sbi 0x15,0
1446:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 9318               		.loc 1 1446 0
 9319 3ca4 8091 0000 		lds r24,systemTicks
 9320 3ca8 9091 0000 		lds r25,systemTicks+1
 9321               	.LVL373:
 9322 3cac 0196      		adiw r24,1
 9323               	.LVL374:
 9324 3cae 9093 0000 		sts systemTicks+1,r25
 9325 3cb2 8093 0000 		sts systemTicks,r24
 9326               	.LVL375:
 9327               	.L717:
 9328 3cb6 0895      		ret
 9329               	.LBE308:
 9330               	.LBE307:
 9331               		.cfi_endproc
 9332               	.LFE15:
 9334               		.section	.text.startup,"ax",@progbits
 9335               	.global	main
 9337               	main:
 9338               	.LFB76:
4897:WTPA.c        **** {
 9339               		.loc 1 4897 0
 9340               		.cfi_startproc
 9341 0000 CF93      		push r28
 9342               	.LCFI164:
 9343               		.cfi_def_cfa_offset 3
 9344               		.cfi_offset 28, -2
 9345 0002 DF93      		push r29
 9346               	.LCFI165:
 9347               		.cfi_def_cfa_offset 4
 9348               		.cfi_offset 29, -3
 9349 0004 CDB7      		in r28,__SP_L__
 9350 0006 DEB7      		in r29,__SP_H__
 9351               	.LCFI166:
 9352               		.cfi_def_cfa_register 28
 9353 0008 2897      		sbiw r28,8
 9354               	.LCFI167:
 9355               		.cfi_def_cfa_offset 12
 9356 000a 0FB6      		in __tmp_reg__,__SREG__
 9357 000c F894      		cli
 9358 000e DEBF      		out __SP_H__,r29
 9359 0010 0FBE      		out __SREG__,__tmp_reg__
 9360 0012 CDBF      		out __SP_L__,r28
 9361               	/* prologue: function */
 9362               	/* frame size = 8 */
 9363               	/* stack size = 10 */
 9364               	.L__stack_usage = 10
4898:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
 9365               		.loc 1 4898 0
 9366 0014 1FEF      		ldi r17,lo8(-1)
 9367 0016 1093 6400 		sts 100,r17
4899:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
 9368               		.loc 1 4899 0
 9369 001a 85B7      		in r24,0x35
 9370 001c 8F7E      		andi r24,lo8(-17)
 9371 001e 85BF      		out 0x35,r24
4903:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
 9372               		.loc 1 4903 0
 9373 0020 8FEE      		ldi r24,lo8(-17)
 9374 0022 87B9      		out 0x7,r24
4904:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
 9375               		.loc 1 4904 0
 9376 0024 88E0      		ldi r24,lo8(8)
 9377 0026 88B9      		out 0x8,r24
4906:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
 9378               		.loc 1 4906 0
 9379 0028 80E8      		ldi r24,lo8(-128)
 9380 002a 8AB9      		out 0xa,r24
4907:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
 9381               		.loc 1 4907 0
 9382 002c 1BB8      		out 0xb,__zero_reg__
4910:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
 9383               		.loc 1 4910 0
 9384 002e 96E0      		ldi r25,lo8(6)
 9385 0030 92B9      		out 0x2,r25
4911:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
 9386               		.loc 1 4911 0
 9387 0032 9EE3      		ldi r25,lo8(62)
 9388 0034 91B9      		out 0x1,r25
4913:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
 9389               		.loc 1 4913 0
 9390 0036 14B9      		out 0x4,r17
4914:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
 9391               		.loc 1 4914 0
 9392 0038 85B9      		out 0x5,r24
4917:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
 9393               		.loc 1 4917 0
 9394 003a 129A      		sbi 0x2,2
4918:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 9395               		.loc 1 4918 0
 9396 003c 14B9      		out 0x4,r17
4919:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
 9397               		.loc 1 4919 0
 9398 003e 159A      		sbi 0x2,5
4920:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 9399               		.loc 1 4920 0
 9400 0040 1598      		cbi 0x2,5
4922:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
 9401               		.loc 1 4922 0
 9402 0042 0E94 0000 		call InitSdInterface
 9403               	.LVL376:
 9404               	.LBB341:
 9405               	.LBB342:
1585:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
 9406               		.loc 1 1585 0
 9407 0046 66E2      		ldi r22,lo8(38)
 9408 0048 70E0      		ldi r23,0
 9409 004a 81E0      		ldi r24,lo8(1)
 9410 004c 0E94 0000 		call SetTimer
 9411               	.LVL377:
1587:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
 9412               		.loc 1 1587 0
 9413 0050 3D98      		cbi 0x7,5
1588:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
 9414               		.loc 1 1588 0
 9415 0052 459A      		sbi 0x8,5
 9416               	.LBE342:
 9417               	.LBE341:
 9418               	.LBB343:
 9419               	.LBB344:
1658:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
 9420               		.loc 1 1658 0
 9421 0054 80B1      		in r24,0
 9422 0056 807C      		andi r24,lo8(-64)
 9423 0058 8093 0000 		sts encoderState,r24
1659:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
 9424               		.loc 1 1659 0
 9425 005c 1092 0000 		sts encoderValue,__zero_reg__
1660:WTPA.c        **** 	newEncoder=false;
 9426               		.loc 1 1660 0
 9427 0060 1092 0000 		sts newEncoder,__zero_reg__
1661:WTPA.c        **** 	encoderCw=false;
 9428               		.loc 1 1661 0
 9429 0064 1092 0000 		sts encoderCw,__zero_reg__
1662:WTPA.c        **** 	encoderCcw=false;
 9430               		.loc 1 1662 0
 9431 0068 1092 0000 		sts encoderCcw,__zero_reg__
 9432               	.LBE344:
 9433               	.LBE343:
 9434               	.LBB345:
 9435               	.LBB346:
1572:WTPA.c        **** 	ledOnOffMask=0;
 9436               		.loc 1 1572 0
 9437 006c 1092 0000 		sts ledOnOffMask,__zero_reg__
1573:WTPA.c        **** 	ledBlinkMask=0;
 9438               		.loc 1 1573 0
 9439 0070 1092 0000 		sts ledBlinkMask,__zero_reg__
1574:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
 9440               		.loc 1 1574 0
 9441 0074 80E0      		ldi r24,0
 9442 0076 0E94 0000 		call WriteLedLatch
 9443               	.LVL378:
 9444               	.LBE346:
 9445               	.LBE345:
4926:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
 9446               		.loc 1 4926 0
 9447 007a 0E94 0000 		call InitMidi
 9448               	.LVL379:
4927:WTPA.c        **** 	InitUart0();
 9449               		.loc 1 4927 0
 9450 007e 0E94 0000 		call InitUart0
 9451               	.LVL380:
 9452               	.LBB347:
 9453               	.LBB348:
1783:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
 9454               		.loc 1 1783 0
 9455 0082 8091 6400 		lds r24,100
 9456 0086 8E7F      		andi r24,lo8(-2)
 9457 0088 8093 6400 		sts 100,r24
1784:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
 9458               		.loc 1 1784 0
 9459 008c 80E6      		ldi r24,lo8(96)
 9460 008e 8093 7C00 		sts 124,r24
1785:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
 9461               		.loc 1 1785 0
 9462 0092 81E0      		ldi r24,lo8(1)
 9463 0094 8093 7E00 		sts 126,r24
1786:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
 9464               		.loc 1 1786 0
 9465 0098 85E9      		ldi r24,lo8(-107)
 9466 009a 8093 7A00 		sts 122,r24
1788:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
 9467               		.loc 1 1788 0
 9468 009e 8091 7A00 		lds r24,122
 9469 00a2 8064      		ori r24,lo8(64)
 9470 00a4 8093 7A00 		sts 122,r24
 9471               	.LBE348:
 9472               	.LBE347:
 9473               	.LBB349:
 9474               	.LBB350:
1462:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
 9475               		.loc 1 1462 0
 9476 00a8 8091 6400 		lds r24,100
 9477 00ac 8F7D      		andi r24,lo8(-33)
 9478 00ae 8093 6400 		sts 100,r24
1463:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
 9479               		.loc 1 1463 0
 9480 00b2 1092 6E00 		sts 110,__zero_reg__
1464:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
 9481               		.loc 1 1464 0
 9482 00b6 14BC      		out 0x24,__zero_reg__
1465:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
 9483               		.loc 1 1465 0
 9484 00b8 16BC      		out 0x26,__zero_reg__
1466:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 9485               		.loc 1 1466 0
 9486 00ba 15BB      		out 0x15,r17
1467:WTPA.c        **** 	systemTicks=0;
 9487               		.loc 1 1467 0
 9488 00bc 1092 0000 		sts systemTicks+1,__zero_reg__
 9489 00c0 1092 0000 		sts systemTicks,__zero_reg__
1469:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 9490               		.loc 1 1469 0
 9491 00c4 83E0      		ldi r24,lo8(3)
 9492 00c6 85BD      		out 0x25,r24
 9493               	.LBE350:
 9494               	.LBE349:
 9495               	.LBB351:
 9496               	.LBB352:
2042:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
 9497               		.loc 1 2042 0
 9498 00c8 8091 6400 		lds r24,100
 9499 00cc 877F      		andi r24,lo8(-9)
 9500 00ce 8093 6400 		sts 100,r24
2043:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
 9501               		.loc 1 2043 0
 9502 00d2 1092 6F00 		sts 111,__zero_reg__
2044:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
 9503               		.loc 1 2044 0
 9504 00d6 8FEF      		ldi r24,lo8(-1)
 9505 00d8 9FEF      		ldi r25,lo8(-1)
 9506 00da 9093 8900 		sts 136+1,r25
 9507 00de 8093 8800 		sts 136,r24
2045:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
 9508               		.loc 1 2045 0
 9509 00e2 9093 8B00 		sts 138+1,r25
 9510 00e6 8093 8A00 		sts 138,r24
2046:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
 9511               		.loc 1 2046 0
 9512 00ea 1092 8000 		sts 128,__zero_reg__
2047:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
 9513               		.loc 1 2047 0
 9514 00ee 1092 8100 		sts 129,__zero_reg__
2048:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
 9515               		.loc 1 2048 0
 9516 00f2 1092 8500 		sts 132+1,__zero_reg__
 9517 00f6 1092 8400 		sts 132,__zero_reg__
2049:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
 9518               		.loc 1 2049 0
 9519 00fa 16BB      		out 0x16,r17
 9520               	.LBE352:
 9521               	.LBE351:
4934:WTPA.c        **** 	newKeys=0;
 9522               		.loc 1 4934 0
 9523 00fc 1092 0000 		sts newKeys,__zero_reg__
4935:WTPA.c        **** 	keyState=0;
 9524               		.loc 1 4935 0
 9525 0100 1092 0000 		sts keyState,__zero_reg__
4936:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
 9526               		.loc 1 4936 0
 9527 0104 1092 0000 		sts cardState,__zero_reg__
4937:WTPA.c        **** 	cardDetect=false;
 9528               		.loc 1 4937 0
 9529 0108 1092 0000 		sts cardDetect,__zero_reg__
4939:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
 9530               		.loc 1 4939 0
 9531               	/* #APP */
 9532               	 ;  4939 "WTPA.c" 1
 9533 010c 7894      		sei
 9534               	 ;  0 "" 2
 9535               	.LVL381:
 9536               	/* #NOAPP */
 9537               	.LBB353:
 9538               	.LBB354:
1429:WTPA.c        **** 	State=newState;
 9539               		.loc 1 1429 0
 9540 010e 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 9541 0110 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 9542 0112 9093 0000 		sts State+1,r25
 9543 0116 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 9544               		.loc 1 1430 0
 9545 011a 1092 0000 		sts subState,__zero_reg__
 9546               	.LBE354:
 9547               	.LBE353:
 9548               	.LBB355:
 9549               	.LBB356:
1606:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9550               		.loc 1 1606 0
 9551 011e AA24      		clr r10
 9552 0120 AA94      		dec r10
 9553               	.LBE356:
 9554               	.LBE355:
 9555               	.LBB359:
 9556               	.LBB360:
1554:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9557               		.loc 1 1554 0
 9558 0122 EE24      		clr r14
 9559 0124 E394      		inc r14
 9560 0126 F12C      		mov r15,__zero_reg__
 9561               	.LBE360:
 9562               	.LBE359:
 9563               	.LBB362:
 9564               	.LBB363:
2621:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 9565               		.loc 1 2621 0
 9566 0128 00E0      		ldi r16,0
 9567 012a 12E0      		ldi r17,lo8(2)
2635:WTPA.c        **** 				bytesLeftInBlock-=8;
 9568               		.loc 1 2635 0
 9569 012c F8E0      		ldi r31,lo8(8)
 9570 012e 8F2E      		mov r8,r31
2650:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 9571               		.loc 1 2650 0
 9572 0130 A7E0      		ldi r26,lo8(7)
 9573 0132 7A2E      		mov r7,r26
2827:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 9574               		.loc 1 2827 0
 9575 0134 BBE0      		ldi r27,lo8(11)
 9576 0136 6B2E      		mov r6,r27
2833:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
 9577               		.loc 1 2833 0
 9578 0138 8EE0      		ldi r24,lo8(14)
 9579 013a B82E      		mov r11,r24
2779:WTPA.c        **** 				cardState=SD_READ_ABORT;
 9580               		.loc 1 2779 0
 9581 013c 9DE0      		ldi r25,lo8(13)
 9582 013e 992E      		mov r9,r25
 9583               	.LBB364:
 9584               	.LBB365:
4895:WTPA.c        **** int main(void)
 9585               		.loc 1 4895 0
 9586 0140 6E01      		movw r12,r28
 9587 0142 29E0      		ldi r18,9
 9588 0144 C20E      		add r12,r18
 9589 0146 D11C      		adc r13,__zero_reg__
 9590               	.L829:
 9591               	.LBE365:
 9592               	.LBE364:
 9593               	.LBE363:
 9594               	.LBE362:
 9595               	.LBB380:
 9596               	.LBB357:
1601:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
 9597               		.loc 1 1601 0
 9598 0148 81E0      		ldi r24,lo8(1)
 9599 014a 0E94 0000 		call CheckTimer
 9600               	.LVL382:
 9601 014e 8823      		tst r24
 9602 0150 01F0      		breq .L723
1604:WTPA.c        **** 		sreg=SREG;
 9603               		.loc 1 1604 0
 9604 0152 9FB7      		in r25,__SREG__
 9605               	.LVL383:
1605:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
 9606               		.loc 1 1605 0
 9607               	/* #APP */
 9608               	 ;  1605 "WTPA.c" 1
 9609 0154 F894      		cli
 9610               	 ;  0 "" 2
1606:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9611               		.loc 1 1606 0
 9612               	/* #NOAPP */
 9613 0156 A5B8      		out 0x5,r10
1607:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 9614               		.loc 1 1607 0
 9615 0158 14B8      		out 0x4,__zero_reg__
1608:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 9616               		.loc 1 1608 0
 9617 015a 4398      		cbi 0x8,3
1609:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
 9618               		.loc 1 1609 0
 9619               	/* #APP */
 9620               	 ;  1609 "WTPA.c" 1
 9621 015c 0000      		nop
 9622               	 ;  0 "" 2
1610:WTPA.c        **** 		asm volatile("nop"::);
 9623               		.loc 1 1610 0
 9624               	 ;  1610 "WTPA.c" 1
 9625 015e 0000      		nop
 9626               	 ;  0 "" 2
1611:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 9627               		.loc 1 1611 0
 9628               	/* #NOAPP */
 9629 0160 83B1      		in r24,0x3
 9630 0162 8095      		com r24
 9631 0164 8093 0000 		sts keyState,r24
1612:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 9632               		.loc 1 1612 0
 9633 0168 439A      		sbi 0x8,3
1613:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 9634               		.loc 1 1613 0
 9635 016a A4B8      		out 0x4,r10
1614:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
 9636               		.loc 1 1614 0
 9637 016c 9FBF      		out __SREG__,r25
1616:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
 9638               		.loc 1 1616 0
 9639 016e 3599      		sbic 0x6,5
 9640 0170 00C0      		rjmp .L724
1618:WTPA.c        **** 			cardDetect=true;
 9641               		.loc 1 1618 0
 9642 0172 81E0      		ldi r24,lo8(1)
 9643 0174 8093 0000 		sts cardDetect,r24
 9644 0178 00C0      		rjmp .L725
 9645               	.L724:
1622:WTPA.c        **** 			cardDetect=false;
 9646               		.loc 1 1622 0
 9647 017a 1092 0000 		sts cardDetect,__zero_reg__
 9648               	.L725:
1625:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
 9649               		.loc 1 1625 0
 9650 017e 66E2      		ldi r22,lo8(38)
 9651 0180 70E0      		ldi r23,0
 9652 0182 81E0      		ldi r24,lo8(1)
 9653 0184 0E94 0000 		call SetTimer
 9654               	.LVL384:
 9655               	.L723:
1628:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
 9656               		.loc 1 1628 0
 9657 0188 9091 0000 		lds r25,keyState
 9658 018c 8091 0000 		lds r24,lastKeyState.1897
 9659 0190 8095      		com r24
 9660 0192 8923      		and r24,r25
 9661 0194 8093 0000 		sts newKeys,r24
1629:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
 9662               		.loc 1 1629 0
 9663 0198 8095      		com r24
 9664               	.LBE357:
 9665 019a 8923      		and r24,r25
 9666               	.LBB358:
 9667 019c 8093 0000 		sts keysHeld,r24
1630:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
 9668               		.loc 1 1630 0
 9669 01a0 9093 0000 		sts lastKeyState.1897,r25
 9670               	.LBE358:
 9671               	.LBE380:
 9672               	.LBB381:
 9673               	.LBB382:
1674:WTPA.c        **** 	newEncoder=false;	// Clear variables which indicate changes in encoder readings
 9674               		.loc 1 1674 0
 9675 01a4 1092 0000 		sts newEncoder,__zero_reg__
1675:WTPA.c        **** 	encoderCw=false;
 9676               		.loc 1 1675 0
 9677 01a8 1092 0000 		sts encoderCw,__zero_reg__
1676:WTPA.c        **** 	encoderCcw=false;
 9678               		.loc 1 1676 0
 9679 01ac 1092 0000 		sts encoderCcw,__zero_reg__
1678:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
 9680               		.loc 1 1678 0
 9681 01b0 2091 0000 		lds r18,systemTicks
 9682 01b4 3091 0000 		lds r19,systemTicks+1
 9683 01b8 8091 0000 		lds r24,lastEncTime.1906
 9684 01bc 9091 0000 		lds r25,lastEncTime.1906+1
 9685 01c0 2817      		cp r18,r24
 9686 01c2 3907      		cpc r19,r25
 9687 01c4 01F4      		brne .+2
 9688 01c6 00C0      		rjmp .L727
1680:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
 9689               		.loc 1 1680 0
 9690 01c8 8091 0000 		lds r24,systemTicks
 9691 01cc 9091 0000 		lds r25,systemTicks+1
 9692 01d0 9093 0000 		sts lastEncTime.1906+1,r25
 9693 01d4 8093 0000 		sts lastEncTime.1906,r24
1682:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
 9694               		.loc 1 1682 0
 9695 01d8 80B1      		in r24,0
 9696 01da 807C      		andi r24,lo8(-64)
 9697 01dc 8093 0000 		sts encoderState,r24
1684:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
 9698               		.loc 1 1684 0
 9699 01e0 9091 0000 		lds r25,lastEncoderState.1905
 9700 01e4 8917      		cp r24,r25
 9701 01e6 01F0      		breq .L727
1686:WTPA.c        **** 			if(encoderState==ENC_POS_A)
 9702               		.loc 1 1686 0
 9703 01e8 8111      		cpse r24,__zero_reg__
 9704 01ea 00C0      		rjmp .L729
1688:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
 9705               		.loc 1 1688 0
 9706 01ec 9038      		cpi r25,lo8(-128)
 9707 01ee 01F4      		brne .L730
 9708 01f0 00C0      		rjmp .L923
 9709               	.L730:
1695:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
 9710               		.loc 1 1695 0
 9711 01f2 9034      		cpi r25,lo8(64)
 9712 01f4 01F4      		brne .L731
 9713 01f6 00C0      		rjmp .L919
 9714               	.L729:
1703:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
 9715               		.loc 1 1703 0
 9716 01f8 8034      		cpi r24,lo8(64)
 9717 01fa 01F4      		brne .L732
1705:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
 9718               		.loc 1 1705 0
 9719 01fc 9111      		cpse r25,__zero_reg__
 9720 01fe 00C0      		rjmp .L733
 9721 0200 00C0      		rjmp .L923
 9722               	.L733:
1712:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
 9723               		.loc 1 1712 0
 9724 0202 903C      		cpi r25,lo8(-64)
 9725 0204 01F4      		brne .L731
 9726 0206 00C0      		rjmp .L919
 9727               	.L732:
1720:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
 9728               		.loc 1 1720 0
 9729 0208 803C      		cpi r24,lo8(-64)
 9730 020a 01F4      		brne .L734
1722:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
 9731               		.loc 1 1722 0
 9732 020c 9034      		cpi r25,lo8(64)
 9733 020e 01F4      		brne .L735
 9734 0210 00C0      		rjmp .L923
 9735               	.L735:
1729:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
 9736               		.loc 1 1729 0
 9737 0212 9038      		cpi r25,lo8(-128)
 9738 0214 01F4      		brne .L731
 9739 0216 00C0      		rjmp .L919
 9740               	.L734:
1737:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
 9741               		.loc 1 1737 0
 9742 0218 8038      		cpi r24,lo8(-128)
 9743 021a 01F4      		brne .L731
1739:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
 9744               		.loc 1 1739 0
 9745 021c 903C      		cpi r25,lo8(-64)
 9746 021e 01F4      		brne .L736
 9747               	.L923:
1742:WTPA.c        **** 					encoderValue--;
 9748               		.loc 1 1742 0
 9749 0220 9091 0000 		lds r25,encoderValue
 9750 0224 9150      		subi r25,lo8(-(-1))
 9751 0226 9093 0000 		sts encoderValue,r25
1743:WTPA.c        **** 					encoderCcw=true;
 9752               		.loc 1 1743 0
 9753 022a 91E0      		ldi r25,lo8(1)
 9754 022c 9093 0000 		sts encoderCcw,r25
 9755 0230 00C0      		rjmp .L918
 9756               	.L736:
1746:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
 9757               		.loc 1 1746 0
 9758 0232 9111      		cpse r25,__zero_reg__
 9759 0234 00C0      		rjmp .L731
 9760               	.L919:
1749:WTPA.c        **** 					encoderValue++;
 9761               		.loc 1 1749 0
 9762 0236 9091 0000 		lds r25,encoderValue
 9763 023a 9F5F      		subi r25,lo8(-(1))
 9764 023c 9093 0000 		sts encoderValue,r25
1750:WTPA.c        **** 					encoderCw=true;
 9765               		.loc 1 1750 0
 9766 0240 91E0      		ldi r25,lo8(1)
 9767 0242 9093 0000 		sts encoderCw,r25
 9768               	.L918:
1751:WTPA.c        **** 					newEncoder=true;
 9769               		.loc 1 1751 0
 9770 0246 9093 0000 		sts newEncoder,r25
 9771               	.L731:
1755:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
 9772               		.loc 1 1755 0
 9773 024a 8093 0000 		sts lastEncoderState.1905,r24
 9774               	.L727:
 9775               	.LBE382:
 9776               	.LBE381:
4948:WTPA.c        **** 		HandleSoftclock();		// Keep the timer timing.
 9777               		.loc 1 4948 0
 9778 024e 0E94 0000 		call HandleSoftclock
 9779               	.LVL385:
 9780               	.LBB383:
 9781               	.LBB361:
1542:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
 9782               		.loc 1 1542 0
 9783 0252 8091 0000 		lds r24,ledBlinkMask
 9784 0256 8823      		tst r24
 9785 0258 01F0      		breq .L737
 9786 025a 82E0      		ldi r24,lo8(2)
 9787 025c 0E94 0000 		call CheckTimer
 9788               	.LVL386:
 9789 0260 8823      		tst r24
 9790 0262 01F0      		breq .L737
1546:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9791               		.loc 1 1546 0
 9792 0264 2091 0000 		lds r18,ledBlinkMask
 9793 0268 30E0      		ldi r19,0
1548:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9794               		.loc 1 1548 0
 9795 026a F091 0000 		lds r31,toggle.1883
 9796 026e E091 0000 		lds r30,ledOnOffMask
 9797 0272 80E0      		ldi r24,0
 9798 0274 90E0      		ldi r25,0
 9799               	.L740:
1546:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9800               		.loc 1 1546 0
 9801 0276 B901      		movw r22,r18
 9802 0278 082E      		mov r0,r24
 9803 027a 00C0      		rjmp 2f
 9804               		1:
 9805 027c 7595      		asr r23
 9806 027e 6795      		ror r22
 9807               		2:
 9808 0280 0A94      		dec r0
 9809 0282 02F4      		brpl 1b
 9810 0284 60FF      		sbrs r22,0
 9811 0286 00C0      		rjmp .L738
1550:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9812               		.loc 1 1550 0
 9813 0288 B701      		movw r22,r14
 9814 028a 082E      		mov r0,r24
 9815 028c 00C0      		rjmp 2f
 9816               		1:
 9817 028e 660F      		lsl r22
 9818 0290 771F      		rol r23
 9819               		2:
 9820 0292 0A94      		dec r0
 9821 0294 02F4      		brpl 1b
 9822 0296 AB01      		movw r20,r22
1548:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9823               		.loc 1 1548 0
 9824 0298 FF23      		tst r31
 9825 029a 01F0      		breq .L739
1550:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9826               		.loc 1 1550 0
 9827 029c E62B      		or r30,r22
 9828 029e 00C0      		rjmp .L738
 9829               	.L739:
1554:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9830               		.loc 1 1554 0
 9831 02a0 4095      		com r20
 9832 02a2 E423      		and r30,r20
 9833               	.L738:
 9834               	.LVL387:
 9835 02a4 0196      		adiw r24,1
1544:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
 9836               		.loc 1 1544 0
 9837 02a6 8830      		cpi r24,8
 9838 02a8 9105      		cpc r25,__zero_reg__
 9839 02aa 01F4      		brne .L740
 9840 02ac E093 0000 		sts ledOnOffMask,r30
1559:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
 9841               		.loc 1 1559 0
 9842 02b0 81E0      		ldi r24,lo8(1)
 9843 02b2 9091 0000 		lds r25,toggle.1883
 9844 02b6 9111      		cpse r25,__zero_reg__
 9845 02b8 80E0      		ldi r24,0
 9846               	.L741:
 9847 02ba 8093 0000 		sts toggle.1883,r24
1560:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
 9848               		.loc 1 1560 0
 9849 02be 68E9      		ldi r22,lo8(-104)
 9850 02c0 70E0      		ldi r23,0
 9851 02c2 82E0      		ldi r24,lo8(2)
 9852 02c4 0E94 0000 		call SetTimer
 9853               	.LVL388:
1561:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
 9854               		.loc 1 1561 0
 9855 02c8 8091 0000 		lds r24,ledOnOffMask
 9856 02cc 0E94 0000 		call WriteLedLatch
 9857               	.LVL389:
 9858 02d0 00C0      		rjmp .L742
 9859               	.L737:
1563:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
 9860               		.loc 1 1563 0
 9861 02d2 5090 0000 		lds r5,ledOnOffMask
 9862 02d6 8091 0000 		lds r24,lastLedMask.1884
 9863 02da 8515      		cp r24,r5
 9864 02dc 01F0      		breq .L742
1565:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
 9865               		.loc 1 1565 0
 9866 02de 852D      		mov r24,r5
 9867 02e0 0E94 0000 		call WriteLedLatch
 9868               	.LVL390:
1566:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
 9869               		.loc 1 1566 0
 9870 02e4 5092 0000 		sts lastLedMask.1884,r5
 9871               	.L742:
 9872               	.LBE361:
 9873               	.LBE383:
 9874               	.LBB384:
 9875               	.LBB378:
2390:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
 9876               		.loc 1 2390 0
 9877 02e8 9091 0000 		lds r25,cardDetect
 9878 02ec 8091 0000 		lds r24,cardState
 9879 02f0 9111      		cpse r25,__zero_reg__
 9880 02f2 00C0      		rjmp .L743
2392:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 9881               		.loc 1 2392 0
 9882 02f4 8823      		tst r24
 9883 02f6 01F4      		brne .+2
 9884 02f8 00C0      		rjmp .L745
 9885               	.L744:
2394:WTPA.c        **** 			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
 9886               		.loc 1 2394 0
 9887 02fa 0E94 0000 		call ResetSdCard
 9888               	.LVL391:
 9889 02fe 00C0      		rjmp .L745
 9890               	.L743:
2399:WTPA.c        **** 		switch(cardState)
 9891               		.loc 1 2399 0
 9892 0300 8630      		cpi r24,lo8(6)
 9893 0302 01F4      		brne .+2
 9894 0304 00C0      		rjmp .L752
 9895 0306 00F4      		brsh .L760
 9896 0308 8230      		cpi r24,lo8(2)
 9897 030a 01F4      		brne .+2
 9898 030c 00C0      		rjmp .L748
 9899 030e 00F4      		brsh .L761
 9900 0310 8823      		tst r24
 9901 0312 01F0      		breq .L746
 9902 0314 8130      		cpi r24,lo8(1)
 9903 0316 01F0      		breq .+2
 9904 0318 00C0      		rjmp .L745
 9905 031a 00C0      		rjmp .L747
 9906               	.L761:
 9907 031c 8430      		cpi r24,lo8(4)
 9908 031e 01F4      		brne .+2
 9909 0320 00C0      		rjmp .L750
 9910 0322 00F0      		brlo .+2
 9911 0324 00C0      		rjmp .L751
 9912 0326 00C0      		rjmp .L916
 9913               	.L760:
 9914 0328 8A30      		cpi r24,lo8(10)
 9915 032a 01F4      		brne .+2
 9916 032c 00C0      		rjmp .L756
 9917 032e 00F4      		brsh .L762
 9918 0330 8830      		cpi r24,lo8(8)
 9919 0332 01F4      		brne .+2
 9920 0334 00C0      		rjmp .L754
 9921 0336 00F0      		brlo .+2
 9922 0338 00C0      		rjmp .L755
 9923 033a 00C0      		rjmp .L917
 9924               	.L762:
 9925 033c 8C30      		cpi r24,lo8(12)
 9926 033e 01F4      		brne .+2
 9927 0340 00C0      		rjmp .L758
 9928 0342 00F4      		brsh .+2
 9929 0344 00C0      		rjmp .L757
 9930 0346 8D30      		cpi r24,lo8(13)
 9931 0348 01F0      		breq .+2
 9932 034a 00C0      		rjmp .L745
 9933 034c 00C0      		rjmp .L759
 9934               	.L746:
2407:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
 9935               		.loc 1 2407 0
 9936 034e 81E0      		ldi r24,lo8(1)
 9937 0350 8093 0000 		sts cardState,r24
2408:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
 9938               		.loc 1 2408 0
 9939 0354 64EC      		ldi r22,lo8(-60)
 9940 0356 74E0      		ldi r23,lo8(4)
 9941 0358 83E0      		ldi r24,lo8(3)
 9942 035a 0E94 0000 		call SetTimer
 9943               	.LVL392:
 9944 035e 00C0      		rjmp .L745
 9945               	.L747:
2412:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
 9946               		.loc 1 2412 0
 9947 0360 83E0      		ldi r24,lo8(3)
 9948 0362 0E94 0000 		call CheckTimer
 9949               	.LVL393:
 9950 0366 8823      		tst r24
 9951 0368 01F4      		brne .+2
 9952 036a 00C0      		rjmp .L745
2414:WTPA.c        **** 				sdPlaybackQueued=false;
 9953               		.loc 1 2414 0
 9954 036c 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2415:WTPA.c        **** 				sdAbortRead=false;
 9955               		.loc 1 2415 0
 9956 0370 1092 0000 		sts sdAbortRead,__zero_reg__
2417:WTPA.c        **** 				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk
 9957               		.loc 1 2417 0
 9958 0374 0E94 0000 		call SdHandshake
 9959               	.LVL394:
 9960 0378 8130      		cpi r24,lo8(1)
 9961 037a 01F0      		breq .+2
 9962 037c 00C0      		rjmp .L764
 9963               	.LVL395:
 9964               	.LBB367:
 9965               	.LBB366:
2162:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
 9966               		.loc 1 2162 0
 9967 037e 60E0      		ldi r22,0
 9968 0380 70E0      		ldi r23,0
 9969 0382 CB01      		movw r24,r22
 9970 0384 0E94 0000 		call SdBeginSingleBlockRead
 9971               	.LVL396:
 9972 0388 8130      		cpi r24,lo8(1)
 9973 038a 01F0      		breq .+2
 9974 038c 00C0      		rjmp .L830
2171:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
 9975               		.loc 1 2171 0
 9976 038e 6AE7      		ldi r22,lo8(122)
 9977 0390 70E0      		ldi r23,0
 9978 0392 83E0      		ldi r24,lo8(3)
 9979 0394 0E94 0000 		call SetTimer
 9980               	.LVL397:
 9981 0398 00C0      		rjmp .L766
 9982               	.L769:
2175:WTPA.c        **** 			HandleSoftclock();	// Kludgy
 9983               		.loc 1 2175 0
 9984 039a 0E94 0000 		call HandleSoftclock
 9985               	.LVL398:
 9986               	.L766:
2173:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 9987               		.loc 1 2173 0
 9988 039e 83E0      		ldi r24,lo8(3)
 9989 03a0 0E94 0000 		call CheckTimer
 9990               	.LVL399:
 9991 03a4 8823      		tst r24
 9992 03a6 01F0      		breq .L767
 9993               	.L770:
 9994               	.LVL400:
 9995 03a8 4424      		clr r4
 9996 03aa 4394      		inc r4
 9997 03ac 512C      		mov r5,__zero_reg__
 9998 03ae 4C0E      		add r4,r28
 9999 03b0 5D1E      		adc r5,r29
 10000 03b2 00C0      		rjmp .L768
 10001               	.LVL401:
 10002               	.L767:
 10003 03b4 8FEF      		ldi r24,lo8(-1)
 10004 03b6 0E94 0000 		call TransferSdByte
 10005               	.LVL402:
 10006 03ba 8E3F      		cpi r24,lo8(-2)
 10007 03bc 01F4      		brne .L769
 10008 03be 00C0      		rjmp .L770
 10009               	.L768:
2180:WTPA.c        **** 			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
 10010               		.loc 1 2180 0
 10011 03c0 8FEF      		ldi r24,lo8(-1)
 10012 03c2 0E94 0000 		call TransferSdByte
 10013               	.LVL403:
 10014 03c6 F201      		movw r30,r4
 10015 03c8 8193      		st Z+,r24
 10016 03ca 2F01      		movw r4,r30
2178:WTPA.c        **** 		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
 10017               		.loc 1 2178 0
 10018 03cc EC15      		cp r30,r12
 10019 03ce FD05      		cpc r31,r13
 10020 03d0 01F4      		brne .L768
2183:WTPA.c        **** 		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A')
 10021               		.loc 1 2183 0
 10022 03d2 8981      		ldd r24,Y+1
 10023 03d4 8735      		cpi r24,lo8(87)
 10024 03d6 01F0      		breq .L771
 10025 03d8 00C0      		rjmp .L835
 10026               	.L771:
 10027 03da 8A81      		ldd r24,Y+2
 10028 03dc 8435      		cpi r24,lo8(84)
 10029 03de 01F4      		brne .L835
 10030 03e0 8B81      		ldd r24,Y+3
 10031 03e2 8035      		cpi r24,lo8(80)
 10032 03e4 01F4      		brne .L835
 10033 03e6 8C81      		ldd r24,Y+4
 10034 03e8 8134      		cpi r24,lo8(65)
 10035 03ea 01F4      		brne .L835
2185:WTPA.c        **** 			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'
 10036               		.loc 1 2185 0
 10037 03ec 8D81      		ldd r24,Y+5
 10038 03ee 8335      		cpi r24,lo8(83)
 10039 03f0 01F4      		brne .L774
 10040 03f2 8E81      		ldd r24,Y+6
 10041 03f4 8134      		cpi r24,lo8(65)
 10042 03f6 01F4      		brne .L835
 10043 03f8 8F81      		ldd r24,Y+7
 10044 03fa 8D34      		cpi r24,lo8(77)
 10045 03fc 01F4      		brne .L835
 10046 03fe 3324      		clr r3
 10047 0400 3394      		inc r3
 10048 0402 8885      		ldd r24,Y+8
 10049 0404 8035      		cpi r24,lo8(80)
 10050 0406 01F0      		breq .L772
 10051 0408 00C0      		rjmp .L835
 10052               	.L774:
2189:WTPA.c        **** 			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]
 10053               		.loc 1 2189 0
 10054 040a 8434      		cpi r24,lo8(68)
 10055 040c 01F4      		brne .L776
 10056 040e 8E81      		ldd r24,Y+6
 10057 0410 8035      		cpi r24,lo8(80)
 10058 0412 01F4      		brne .L835
 10059 0414 8F81      		ldd r24,Y+7
 10060 0416 8334      		cpi r24,lo8(67)
 10061 0418 01F4      		brne .L835
 10062 041a 8885      		ldd r24,Y+8
 10063 041c 8D34      		cpi r24,lo8(77)
 10064 041e 01F4      		brne .L835
2191:WTPA.c        **** 				filesystemType=SD_TYPE_DPCM;			
 10065               		.loc 1 2191 0
 10066 0420 62E0      		ldi r22,lo8(2)
 10067 0422 362E      		mov r3,r22
 10068 0424 00C0      		rjmp .L772
 10069               	.L776:
2193:WTPA.c        **** 			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]
 10070               		.loc 1 2193 0
 10071 0426 8234      		cpi r24,lo8(66)
 10072 0428 01F4      		brne .L835
 10073 042a 8E81      		ldd r24,Y+6
 10074 042c 8F34      		cpi r24,lo8(79)
 10075 042e 01F4      		brne .L835
 10076 0430 8F81      		ldd r24,Y+7
 10077 0432 8F34      		cpi r24,lo8(79)
 10078 0434 01F4      		brne .L835
 10079 0436 8885      		ldd r24,Y+8
 10080 0438 8435      		cpi r24,lo8(84)
 10081 043a 01F4      		brne .L835
2195:WTPA.c        **** 				filesystemType=SD_TYPE_BOOT;						
 10082               		.loc 1 2195 0
 10083 043c 53E0      		ldi r21,lo8(3)
 10084 043e 352E      		mov r3,r21
 10085 0440 00C0      		rjmp .L772
 10086               	.L835:
2160:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
 10087               		.loc 1 2160 0
 10088 0442 312C      		mov r3,__zero_reg__
 10089               	.L772:
 10090               	.LVL404:
 10091 0444 48E0      		ldi r20,lo8(8)
 10092 0446 442E      		mov r4,r20
 10093 0448 512C      		mov r5,__zero_reg__
 10094               	.LVL405:
 10095               	.L777:
2201:WTPA.c        **** 			TransferSdByte(0xFF);
 10096               		.loc 1 2201 0
 10097 044a 8FEF      		ldi r24,lo8(-1)
 10098 044c 0E94 0000 		call TransferSdByte
 10099               	.LVL406:
 10100 0450 F1E0      		ldi r31,1
 10101 0452 4F1A      		sub r4,r31
 10102 0454 5108      		sbc r5,__zero_reg__
2199:WTPA.c        **** 		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a stri
 10103               		.loc 1 2199 0
 10104 0456 01F4      		brne .L777
2204:WTPA.c        **** 		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
 10105               		.loc 1 2204 0
 10106 0458 21E0      		ldi r18,lo8(1)
 10107 045a 3212      		cpse r3,r18
 10108 045c 00C0      		rjmp .L836
 10109 045e 30E0      		ldi r19,lo8(sampleToc)
 10110 0460 432E      		mov r4,r19
 10111 0462 30E0      		ldi r19,hi8(sampleToc)
 10112 0464 532E      		mov r5,r19
 10113               	.L779:
2208:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
 10114               		.loc 1 2208 0
 10115 0466 8FEF      		ldi r24,lo8(-1)
 10116 0468 0E94 0000 		call TransferSdByte
 10117               	.LVL407:
 10118 046c F201      		movw r30,r4
 10119 046e 8193      		st Z+,r24
 10120 0470 2F01      		movw r4,r30
2206:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
 10121               		.loc 1 2206 0
 10122 0472 F0E0      		ldi r31,lo8(sampleToc+64)
 10123 0474 4F16      		cp r4,r31
 10124 0476 F0E0      		ldi r31,hi8(sampleToc+64)
 10125 0478 5F06      		cpc r5,r31
 10126 047a 01F4      		brne .L779
 10127               	.L781:
 10128               	.LVL408:
2204:WTPA.c        **** 		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
 10129               		.loc 1 2204 0
 10130 047c 22EB      		ldi r18,lo8(-78)
 10131 047e 422E      		mov r4,r18
 10132 0480 5524      		clr r5
 10133 0482 5394      		inc r5
 10134 0484 00C0      		rjmp .L780
 10135               	.LVL409:
 10136               	.L836:
 10137 0486 90E4      		ldi r25,lo8(64)
 10138 0488 492E      		mov r4,r25
 10139 048a 512C      		mov r5,__zero_reg__
 10140               	.L778:
2215:WTPA.c        **** 				TransferSdByte(0xFF);
 10141               		.loc 1 2215 0
 10142 048c 8FEF      		ldi r24,lo8(-1)
 10143 048e 0E94 0000 		call TransferSdByte
 10144               	.LVL410:
 10145 0492 21E0      		ldi r18,1
 10146 0494 421A      		sub r4,r18
 10147 0496 5108      		sbc r5,__zero_reg__
2213:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
 10148               		.loc 1 2213 0
 10149 0498 01F4      		brne .L778
 10150 049a 00C0      		rjmp .L781
 10151               	.L780:
2221:WTPA.c        **** 			TransferSdByte(0xFF);
 10152               		.loc 1 2221 0
 10153 049c 8FEF      		ldi r24,lo8(-1)
 10154 049e 0E94 0000 		call TransferSdByte
 10155               	.LVL411:
 10156 04a2 31E0      		ldi r19,1
 10157 04a4 431A      		sub r4,r19
 10158 04a6 5108      		sbc r5,__zero_reg__
2219:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
 10159               		.loc 1 2219 0
 10160 04a8 01F4      		brne .L780
 10161 04aa 00C0      		rjmp .L876
 10162               	.LVL412:
 10163               	.L830:
2160:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
 10164               		.loc 1 2160 0
 10165 04ac 312C      		mov r3,__zero_reg__
 10166               	.LVL413:
 10167               	.L876:
2225:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 10168               		.loc 1 2225 0
 10169 04ae 8091 C800 		lds r24,200
 10170 04b2 86FF      		sbrs r24,6
 10171 04b4 00C0      		rjmp .L876
2228:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
 10172               		.loc 1 2228 0
 10173 04b6 0E94 0000 		call EndSdTransfer
 10174               	.LVL414:
2229:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 10175               		.loc 1 2229 0
 10176 04ba 8FEF      		ldi r24,lo8(-1)
 10177 04bc 0E94 0000 		call TransferSdByte
 10178               	.LVL415:
 10179               	.LBE366:
 10180               	.LBE367:
2421:WTPA.c        **** 					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
 10181               		.loc 1 2421 0
 10182 04c0 41E0      		ldi r20,lo8(1)
 10183 04c2 3412      		cpse r3,r20
 10184 04c4 00C0      		rjmp .L783
2423:WTPA.c        **** 						cardState=SD_IDLE;			// Card is legit and ready to go.
 10185               		.loc 1 2423 0
 10186 04c6 B092 0000 		sts cardState,r11
 10187               	.LBB368:
 10188               	.LBB369:
2975:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 10189               		.loc 1 2975 0
 10190 04ca 8091 6400 		lds r24,100
 10191 04ce 8F7B      		andi r24,lo8(-65)
 10192 04d0 8093 6400 		sts 100,r24
2977:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 10193               		.loc 1 2977 0
 10194 04d4 82E0      		ldi r24,lo8(2)
 10195 04d6 8093 B000 		sts 176,r24
2978:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
 10196               		.loc 1 2978 0
 10197 04da 1092 B100 		sts 177,__zero_reg__
2979:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 10198               		.loc 1 2979 0
 10199 04de 1092 B200 		sts 178,__zero_reg__
2980:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 10200               		.loc 1 2980 0
 10201 04e2 81E7      		ldi r24,lo8(113)
 10202 04e4 8093 B300 		sts 179,r24
2981:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 10203               		.loc 1 2981 0
 10204 04e8 A7BA      		out 0x17,r10
2982:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
 10205               		.loc 1 2982 0
 10206 04ea 1092 7000 		sts 112,__zero_reg__
2984:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
 10207               		.loc 1 2984 0
 10208 04ee 1092 0000 		sts sdIsrState,__zero_reg__
2985:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
 10209               		.loc 1 2985 0
 10210 04f2 1092 0000 		sts sdStreamOutput,__zero_reg__
 10211 04f6 00C0      		rjmp .L745
 10212               	.L783:
 10213               	.LBE369:
 10214               	.LBE368:
2426:WTPA.c        **** 					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler
 10215               		.loc 1 2426 0
 10216 04f8 52E0      		ldi r21,lo8(2)
 10217 04fa 3516      		cp r3,r21
 10218 04fc 01F4      		brne .+2
 10219 04fe 00C0      		rjmp .L745
2433:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
 10220               		.loc 1 2433 0
 10221 0500 8FE0      		ldi r24,lo8(15)
 10222 0502 8093 0000 		sts cardState,r24
 10223               	.LVL416:
 10224 0506 E0E0      		ldi r30,lo8(sampleToc)
 10225 0508 F0E0      		ldi r31,hi8(sampleToc)
 10226               	.LVL417:
 10227               	.L784:
 10228               	.LBB370:
 10229               	.LBB371:
2091:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 10230               		.loc 1 2091 0
 10231 050a 1192      		st Z+,__zero_reg__
2089:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 10232               		.loc 1 2089 0
 10233 050c 60E0      		ldi r22,hi8(sampleToc+64)
 10234 050e E030      		cpi r30,lo8(sampleToc+64)
 10235 0510 F607      		cpc r31,r22
 10236 0512 01F4      		brne .L784
 10237               	.LVL418:
 10238               	.LBE371:
 10239               	.LBE370:
 10240               	.LBB372:
 10241               	.LBB373:
1429:WTPA.c        **** 	State=newState;
 10242               		.loc 1 1429 0
 10243 0514 80E0      		ldi r24,lo8(gs(DoFormatCard))
 10244 0516 90E0      		ldi r25,hi8(gs(DoFormatCard))
 10245 0518 9093 0000 		sts State+1,r25
 10246 051c 8093 0000 		sts State,r24
1430:WTPA.c        **** 	subState=SS_0;
 10247               		.loc 1 1430 0
 10248 0520 1092 0000 		sts subState,__zero_reg__
 10249 0524 00C0      		rjmp .L745
 10250               	.LVL419:
 10251               	.L764:
 10252               	.LBE373:
 10253               	.LBE372:
2440:WTPA.c        **** 					cardState=SD_INVALID;
 10254               		.loc 1 2440 0
 10255 0526 8FE0      		ldi r24,lo8(15)
 10256 0528 00C0      		rjmp .L920
 10257               	.L748:
2450:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 10258               		.loc 1 2450 0
 10259 052a 2FB7      		in r18,__SREG__
 10260               	.LVL420:
2451:WTPA.c        **** 			cli();
 10261               		.loc 1 2451 0
 10262               	/* #APP */
 10263               	 ;  2451 "WTPA.c" 1
 10264 052c F894      		cli
 10265               	 ;  0 "" 2
2452:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 10266               		.loc 1 2452 0
 10267               	/* #NOAPP */
 10268 052e 8091 0000 		lds r24,sdBytesInFifo
 10269 0532 9091 0000 		lds r25,sdBytesInFifo+1
 10270 0536 8115      		cp r24,__zero_reg__
 10271 0538 9240      		sbci r25,2
 10272 053a 00F4      		brsh .L785
 10273 053c 8091 0000 		lds r24,sdBytesInFifo
 10274 0540 9091 0000 		lds r25,sdBytesInFifo+1
 10275 0544 4091 0000 		lds r20,sdCardSampleRemaining
 10276 0548 5091 0000 		lds r21,sdCardSampleRemaining+1
 10277 054c 6091 0000 		lds r22,sdCardSampleRemaining+2
 10278 0550 7091 0000 		lds r23,sdCardSampleRemaining+3
 10279 0554 A0E0      		ldi r26,0
 10280 0556 B0E0      		ldi r27,0
 10281 0558 8417      		cp r24,r20
 10282 055a 9507      		cpc r25,r21
 10283 055c A607      		cpc r26,r22
 10284 055e B707      		cpc r27,r23
 10285 0560 00F4      		brsh .+2
 10286 0562 00C0      		rjmp .L799
 10287               	.L785:
2454:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
 10288               		.loc 1 2454 0
 10289 0564 2FBF      		out __SREG__,r18
2455:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
 10290               		.loc 1 2455 0
 10291 0566 6091 0000 		lds r22,sdSampleStartBlock
 10292 056a 7091 0000 		lds r23,sdSampleStartBlock+1
 10293 056e 8091 0000 		lds r24,sdSampleStartBlock+2
 10294 0572 9091 0000 		lds r25,sdSampleStartBlock+3
 10295 0576 0E94 0000 		call SdBeginSingleBlockWrite
 10296               	.LVL421:
 10297 057a 8130      		cpi r24,lo8(1)
 10298 057c 01F0      		breq .+2
 10299 057e 00C0      		rjmp .L744
2457:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 10300               		.loc 1 2457 0
 10301 0580 1093 0000 		sts bytesLeftInBlock.2026+1,r17
 10302 0584 0093 0000 		sts bytesLeftInBlock.2026,r16
2459:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
 10303               		.loc 1 2459 0
 10304 0588 8FEF      		ldi r24,lo8(-1)
 10305 058a 0E94 0000 		call TransferSdByte
 10306               	.LVL422:
2460:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
 10307               		.loc 1 2460 0
 10308 058e 8FEF      		ldi r24,lo8(-1)
 10309 0590 0E94 0000 		call TransferSdByte
 10310               	.LVL423:
2461:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
 10311               		.loc 1 2461 0
 10312 0594 8EEF      		ldi r24,lo8(-2)
 10313 0596 0E94 0000 		call TransferSdByte
 10314               	.LVL424:
2462:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
 10315               		.loc 1 2462 0
 10316 059a 8091 0000 		lds r24,sdCardSampleRemaining
 10317 059e 9091 0000 		lds r25,sdCardSampleRemaining+1
 10318 05a2 A091 0000 		lds r26,sdCardSampleRemaining+2
 10319 05a6 B091 0000 		lds r27,sdCardSampleRemaining+3
 10320 05aa 8B2F      		mov r24,r27
 10321 05ac 0E94 0000 		call TransferSdByte
 10322               	.LVL425:
2463:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
 10323               		.loc 1 2463 0
 10324 05b0 6091 0000 		lds r22,sdCardSampleRemaining
 10325 05b4 7091 0000 		lds r23,sdCardSampleRemaining+1
 10326 05b8 8091 0000 		lds r24,sdCardSampleRemaining+2
 10327 05bc 9091 0000 		lds r25,sdCardSampleRemaining+3
 10328 05c0 0E94 0000 		call TransferSdByte
 10329               	.LVL426:
2464:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
 10330               		.loc 1 2464 0
 10331 05c4 8091 0000 		lds r24,sdCardSampleRemaining
 10332 05c8 9091 0000 		lds r25,sdCardSampleRemaining+1
 10333 05cc A091 0000 		lds r26,sdCardSampleRemaining+2
 10334 05d0 B091 0000 		lds r27,sdCardSampleRemaining+3
 10335 05d4 892F      		mov r24,r25
 10336 05d6 0E94 0000 		call TransferSdByte
 10337               	.LVL427:
2465:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
 10338               		.loc 1 2465 0
 10339 05da 8091 0000 		lds r24,sdCardSampleRemaining
 10340 05de 9091 0000 		lds r25,sdCardSampleRemaining+1
 10341 05e2 A091 0000 		lds r26,sdCardSampleRemaining+2
 10342 05e6 B091 0000 		lds r27,sdCardSampleRemaining+3
 10343 05ea 0E94 0000 		call TransferSdByte
 10344               	.LVL428:
2467:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
 10345               		.loc 1 2467 0
 10346 05ee 8091 0000 		lds r24,bytesLeftInBlock.2026
 10347 05f2 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10348 05f6 0497      		sbiw r24,4
 10349 05f8 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10350 05fc 8093 0000 		sts bytesLeftInBlock.2026,r24
 10351 0600 00C0      		rjmp .L924
 10352               	.L916:
 10353 0602 4090 0000 		lds r4,bytesLeftInBlock.2026
 10354 0606 5090 0000 		lds r5,bytesLeftInBlock.2026+1
 10355 060a 81E4      		ldi r24,65
 10356 060c 4816      		cp r4,r24
 10357 060e 5104      		cpc r5,__zero_reg__
 10358 0610 00F0      		brlo .L787
 10359 0612 80E4      		ldi r24,lo8(64)
 10360 0614 482E      		mov r4,r24
 10361 0616 512C      		mov r5,__zero_reg__
 10362               	.L787:
 10363               	.LVL429:
2492:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 10364               		.loc 1 2492 0
 10365 0618 312C      		mov r3,__zero_reg__
 10366 061a 00C0      		rjmp .L788
 10367               	.LVL430:
 10368               	.L792:
2494:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
 10369               		.loc 1 2494 0
 10370 061c 8091 0000 		lds r24,sdCardSampleRemaining
 10371 0620 9091 0000 		lds r25,sdCardSampleRemaining+1
 10372 0624 A091 0000 		lds r26,sdCardSampleRemaining+2
 10373 0628 B091 0000 		lds r27,sdCardSampleRemaining+3
 10374 062c 892B      		or r24,r25
 10375 062e 8A2B      		or r24,r26
 10376 0630 8B2B      		or r24,r27
 10377 0632 01F0      		breq .L789
2496:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
 10378               		.loc 1 2496 0
 10379 0634 E091 0000 		lds r30,sdFifoReadPointer
 10380 0638 F091 0000 		lds r31,sdFifoReadPointer+1
 10381 063c E050      		subi r30,lo8(-(sdFifo))
 10382 063e F040      		sbci r31,hi8(-(sdFifo))
 10383 0640 8081      		ld r24,Z
 10384 0642 0E94 0000 		call TransferSdByte
 10385               	.LVL431:
2497:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
 10386               		.loc 1 2497 0
 10387 0646 8091 0000 		lds r24,sdCardSampleRemaining
 10388 064a 9091 0000 		lds r25,sdCardSampleRemaining+1
 10389 064e A091 0000 		lds r26,sdCardSampleRemaining+2
 10390 0652 B091 0000 		lds r27,sdCardSampleRemaining+3
 10391 0656 0197      		sbiw r24,1
 10392 0658 A109      		sbc r26,__zero_reg__
 10393 065a B109      		sbc r27,__zero_reg__
 10394 065c 8093 0000 		sts sdCardSampleRemaining,r24
 10395 0660 9093 0000 		sts sdCardSampleRemaining+1,r25
 10396 0664 A093 0000 		sts sdCardSampleRemaining+2,r26
 10397 0668 B093 0000 		sts sdCardSampleRemaining+3,r27
2499:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
 10398               		.loc 1 2499 0
 10399 066c 8091 0000 		lds r24,sdFifoReadPointer
 10400 0670 9091 0000 		lds r25,sdFifoReadPointer+1
 10401 0674 0196      		adiw r24,1
 10402 0676 9093 0000 		sts sdFifoReadPointer+1,r25
 10403 067a 8093 0000 		sts sdFifoReadPointer,r24
2501:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 10404               		.loc 1 2501 0
 10405 067e 8091 0000 		lds r24,sdFifoReadPointer
 10406 0682 9091 0000 		lds r25,sdFifoReadPointer+1
 10407 0686 8115      		cp r24,__zero_reg__
 10408 0688 9340      		sbci r25,3
 10409 068a 00F0      		brlo .L790
2503:WTPA.c        **** 						sdFifoReadPointer=0;
 10410               		.loc 1 2503 0
 10411 068c 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 10412 0690 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 10413               	.L790:
2506:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 10414               		.loc 1 2506 0
 10415 0694 2FB7      		in r18,__SREG__
 10416               	.LVL432:
2507:WTPA.c        **** 					cli();
 10417               		.loc 1 2507 0
 10418               	/* #APP */
 10419               	 ;  2507 "WTPA.c" 1
 10420 0696 F894      		cli
 10421               	 ;  0 "" 2
2508:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
 10422               		.loc 1 2508 0
 10423               	/* #NOAPP */
 10424 0698 8091 0000 		lds r24,sdBytesInFifo
 10425 069c 9091 0000 		lds r25,sdBytesInFifo+1
 10426 06a0 0197      		sbiw r24,1
 10427 06a2 9093 0000 		sts sdBytesInFifo+1,r25
 10428 06a6 8093 0000 		sts sdBytesInFifo,r24
2509:WTPA.c        **** 					SREG=sreg;
 10429               		.loc 1 2509 0
 10430 06aa 2FBF      		out __SREG__,r18
 10431 06ac 00C0      		rjmp .L791
 10432               	.LVL433:
 10433               	.L789:
2513:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
 10434               		.loc 1 2513 0
 10435 06ae 8FEF      		ldi r24,lo8(-1)
 10436 06b0 0E94 0000 		call TransferSdByte
 10437               	.LVL434:
 10438               	.L791:
2516:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
 10439               		.loc 1 2516 0
 10440 06b4 8091 0000 		lds r24,bytesLeftInBlock.2026
 10441 06b8 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10442 06bc 0197      		sbiw r24,1
 10443 06be 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10444 06c2 8093 0000 		sts bytesLeftInBlock.2026,r24
2492:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 10445               		.loc 1 2492 0
 10446 06c6 3394      		inc r3
 10447               	.LVL435:
 10448               	.L788:
 10449 06c8 832D      		mov r24,r3
 10450 06ca 90E0      		ldi r25,0
 10451 06cc 8415      		cp r24,r4
 10452 06ce 9505      		cpc r25,r5
 10453 06d0 00F4      		brsh .+2
 10454 06d2 00C0      		rjmp .L792
2520:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
 10455               		.loc 1 2520 0
 10456 06d4 8091 0000 		lds r24,bytesLeftInBlock.2026
 10457 06d8 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10458 06dc 892B      		or r24,r25
 10459 06de 01F0      		breq .+2
 10460 06e0 00C0      		rjmp .L745
2522:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10461               		.loc 1 2522 0
 10462 06e2 8FEF      		ldi r24,lo8(-1)
 10463 06e4 0E94 0000 		call TransferSdByte
 10464               	.LVL436:
2523:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10465               		.loc 1 2523 0
 10466 06e8 8FEF      		ldi r24,lo8(-1)
 10467 06ea 0E94 0000 		call TransferSdByte
 10468               	.LVL437:
2524:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 10469               		.loc 1 2524 0
 10470 06ee 8FEF      		ldi r24,lo8(-1)
 10471 06f0 0E94 0000 		call TransferSdByte
 10472               	.LVL438:
 10473 06f4 8F71      		andi r24,lo8(31)
 10474               	.LVL439:
2526:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 10475               		.loc 1 2526 0
 10476 06f6 8530      		cpi r24,lo8(5)
 10477 06f8 01F0      		breq .+2
 10478 06fa 00C0      		rjmp .L744
2528:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 10479               		.loc 1 2528 0
 10480 06fc 62E6      		ldi r22,lo8(98)
 10481 06fe 72E0      		ldi r23,lo8(2)
 10482 0700 83E0      		ldi r24,lo8(3)
 10483               	.LVL440:
 10484 0702 0E94 0000 		call SetTimer
 10485               	.LVL441:
2529:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
 10486               		.loc 1 2529 0
 10487 0706 84E0      		ldi r24,lo8(4)
 10488 0708 00C0      		rjmp .L920
 10489               	.LVL442:
 10490               	.L750:
2539:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
 10491               		.loc 1 2539 0
 10492 070a 83E0      		ldi r24,lo8(3)
 10493 070c 0E94 0000 		call CheckTimer
 10494               	.LVL443:
 10495 0710 8111      		cpse r24,__zero_reg__
 10496 0712 00C0      		rjmp .L744
 10497 0714 B4E0      		ldi r27,lo8(4)
 10498 0716 5B2E      		mov r5,r27
 10499               	.L794:
2544:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10500               		.loc 1 2544 0
 10501 0718 8FEF      		ldi r24,lo8(-1)
 10502 071a 0E94 0000 		call TransferSdByte
 10503               	.LVL444:
2545:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 10504               		.loc 1 2545 0
 10505 071e 8F3F      		cpi r24,lo8(-1)
 10506 0720 01F4      		brne .+2
 10507 0722 00C0      		rjmp .L793
 10508               	.LVL445:
 10509 0724 5A94      		dec r5
2542:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 10510               		.loc 1 2542 0
 10511 0726 01F4      		brne .L794
 10512 0728 00C0      		rjmp .L745
 10513               	.L795:
2559:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10514               		.loc 1 2559 0
 10515 072a 8091 C800 		lds r24,200
 10516 072e 86FF      		sbrs r24,6
 10517 0730 00C0      		rjmp .L795
2562:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
 10518               		.loc 1 2562 0
 10519 0732 8091 0000 		lds r24,sdCardSampleRemaining
 10520 0736 9091 0000 		lds r25,sdCardSampleRemaining+1
 10521 073a A091 0000 		lds r26,sdCardSampleRemaining+2
 10522 073e B091 0000 		lds r27,sdCardSampleRemaining+3
 10523 0742 892B      		or r24,r25
 10524 0744 8A2B      		or r24,r26
 10525 0746 8B2B      		or r24,r27
 10526 0748 01F0      		breq .L796
2564:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
 10527               		.loc 1 2564 0
 10528 074a 85E0      		ldi r24,lo8(5)
 10529 074c 00C0      		rjmp .L920
 10530               	.L796:
2568:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
 10531               		.loc 1 2568 0
 10532 074e 4090 0000 		lds r4,sdCurrentSlot
 10533 0752 5090 0000 		lds r5,sdCurrentSlot+1
 10534 0756 C201      		movw r24,r4
 10535 0758 0E94 0000 		call CheckSdSlotFull
 10536               	.LVL446:
 10537 075c 8111      		cpse r24,__zero_reg__
 10538 075e 00C0      		rjmp .L922
 10539               	.LVL447:
 10540               	.LBB374:
 10541               	.LBB375:
2123:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 10542               		.loc 1 2123 0
 10543 0760 F201      		movw r30,r4
 10544 0762 A3E0      		ldi r26,3
 10545               		1:
 10546 0764 F695      		lsr r31
 10547 0766 E795      		ror r30
 10548 0768 AA95      		dec r26
 10549 076a 01F4      		brne 1b
 10550               	.LBE375:
 10551               		.loc 1 4972 0
 10552 076c FF27      		clr r31
 10553               	.LBB376:
2126:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 10554               		.loc 1 2126 0
 10555 076e E050      		subi r30,lo8(-(sampleToc))
 10556 0770 F040      		sbci r31,hi8(-(sampleToc))
 10557               	.LBE376:
2124:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 10558               		.loc 1 2124 0
 10559 0772 27E0      		ldi r18,7
 10560 0774 4222      		and r4,r18
 10561 0776 5524      		clr r5
 10562               	.LVL448:
 10563               	.LBB377:
2126:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 10564               		.loc 1 2126 0
 10565 0778 A701      		movw r20,r14
 10566 077a 00C0      		rjmp 2f
 10567               		1:
 10568 077c 440F      		lsl r20
 10569 077e 551F      		rol r21
 10570               		2:
 10571 0780 4A94      		dec r4
 10572 0782 02F4      		brpl 1b
 10573 0784 8081      		ld r24,Z
 10574 0786 842B      		or r24,r20
 10575 0788 8083      		st Z,r24
 10576               	.LBE377:
 10577               	.LBE374:
2571:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
 10578               		.loc 1 2571 0
 10579 078a 86E0      		ldi r24,lo8(6)
 10580 078c 00C0      		rjmp .L920
 10581               	.L751:
2587:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
 10582               		.loc 1 2587 0
 10583 078e 2FB7      		in r18,__SREG__
 10584               	.LVL449:
2588:WTPA.c        **** 			cli();
 10585               		.loc 1 2588 0
 10586               	/* #APP */
 10587               	 ;  2588 "WTPA.c" 1
 10588 0790 F894      		cli
 10589               	 ;  0 "" 2
2589:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 10590               		.loc 1 2589 0
 10591               	/* #NOAPP */
 10592 0792 8091 0000 		lds r24,sdBytesInFifo
 10593 0796 9091 0000 		lds r25,sdBytesInFifo+1
 10594 079a 8115      		cp r24,__zero_reg__
 10595 079c 9240      		sbci r25,2
 10596 079e 00F4      		brsh .L798
 10597 07a0 8091 0000 		lds r24,sdBytesInFifo
 10598 07a4 9091 0000 		lds r25,sdBytesInFifo+1
 10599 07a8 4091 0000 		lds r20,sdCardSampleRemaining
 10600 07ac 5091 0000 		lds r21,sdCardSampleRemaining+1
 10601 07b0 6091 0000 		lds r22,sdCardSampleRemaining+2
 10602 07b4 7091 0000 		lds r23,sdCardSampleRemaining+3
 10603 07b8 A0E0      		ldi r26,0
 10604 07ba B0E0      		ldi r27,0
 10605 07bc 8417      		cp r24,r20
 10606 07be 9507      		cpc r25,r21
 10607 07c0 A607      		cpc r26,r22
 10608 07c2 B707      		cpc r27,r23
 10609 07c4 00F0      		brlo .L799
 10610               	.L798:
2591:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
 10611               		.loc 1 2591 0
 10612 07c6 2FBF      		out __SREG__,r18
2592:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
 10613               		.loc 1 2592 0
 10614 07c8 2091 0000 		lds r18,sdCurrentBlockOffset
 10615 07cc 3091 0000 		lds r19,sdCurrentBlockOffset+1
 10616               	.LVL450:
 10617 07d0 2F5F      		subi r18,-1
 10618 07d2 3F4F      		sbci r19,-1
 10619 07d4 3093 0000 		sts sdCurrentBlockOffset+1,r19
 10620 07d8 2093 0000 		sts sdCurrentBlockOffset,r18
2594:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
 10621               		.loc 1 2594 0
 10622 07dc 6091 0000 		lds r22,sdSampleStartBlock
 10623 07e0 7091 0000 		lds r23,sdSampleStartBlock+1
 10624 07e4 8091 0000 		lds r24,sdSampleStartBlock+2
 10625 07e8 9091 0000 		lds r25,sdSampleStartBlock+3
 10626 07ec 620F      		add r22,r18
 10627 07ee 731F      		adc r23,r19
 10628 07f0 811D      		adc r24,__zero_reg__
 10629 07f2 911D      		adc r25,__zero_reg__
 10630 07f4 0E94 0000 		call SdBeginSingleBlockWrite
 10631               	.LVL451:
 10632 07f8 8130      		cpi r24,lo8(1)
 10633 07fa 01F0      		breq .+2
 10634 07fc 00C0      		rjmp .L744
2596:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 10635               		.loc 1 2596 0
 10636 07fe 1093 0000 		sts bytesLeftInBlock.2026+1,r17
 10637 0802 0093 0000 		sts bytesLeftInBlock.2026,r16
2598:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
 10638               		.loc 1 2598 0
 10639 0806 8FEF      		ldi r24,lo8(-1)
 10640 0808 0E94 0000 		call TransferSdByte
 10641               	.LVL452:
2599:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
 10642               		.loc 1 2599 0
 10643 080c 8FEF      		ldi r24,lo8(-1)
 10644 080e 0E94 0000 		call TransferSdByte
 10645               	.LVL453:
2600:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
 10646               		.loc 1 2600 0
 10647 0812 8EEF      		ldi r24,lo8(-2)
 10648 0814 0E94 0000 		call TransferSdByte
 10649               	.LVL454:
 10650               	.L924:
2601:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
 10651               		.loc 1 2601 0
 10652 0818 83E0      		ldi r24,lo8(3)
 10653 081a 00C0      		rjmp .L920
 10654               	.LVL455:
 10655               	.L799:
2610:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
 10656               		.loc 1 2610 0
 10657 081c 2FBF      		out __SREG__,r18
 10658 081e 00C0      		rjmp .L745
 10659               	.LVL456:
 10660               	.L752:
2619:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
 10661               		.loc 1 2619 0
 10662 0820 60E0      		ldi r22,0
 10663 0822 70E0      		ldi r23,0
 10664 0824 CB01      		movw r24,r22
 10665 0826 0E94 0000 		call SdBeginSingleBlockWrite
 10666               	.LVL457:
 10667 082a 8130      		cpi r24,lo8(1)
 10668 082c 01F0      		breq .+2
 10669 082e 00C0      		rjmp .L744
2621:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 10670               		.loc 1 2621 0
 10671 0830 1093 0000 		sts bytesLeftInBlock.2026+1,r17
 10672 0834 0093 0000 		sts bytesLeftInBlock.2026,r16
2623:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10673               		.loc 1 2623 0
 10674 0838 8FEF      		ldi r24,lo8(-1)
 10675 083a 0E94 0000 		call TransferSdByte
 10676               	.LVL458:
2624:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
 10677               		.loc 1 2624 0
 10678 083e 8FEF      		ldi r24,lo8(-1)
 10679 0840 0E94 0000 		call TransferSdByte
 10680               	.LVL459:
2625:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
 10681               		.loc 1 2625 0
 10682 0844 8EEF      		ldi r24,lo8(-2)
 10683 0846 0E94 0000 		call TransferSdByte
 10684               	.LVL460:
2626:WTPA.c        **** 				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
 10685               		.loc 1 2626 0
 10686 084a 87E5      		ldi r24,lo8(87)
 10687 084c 0E94 0000 		call TransferSdByte
 10688               	.LVL461:
2627:WTPA.c        **** 				TransferSdByte('T');
 10689               		.loc 1 2627 0
 10690 0850 84E5      		ldi r24,lo8(84)
 10691 0852 0E94 0000 		call TransferSdByte
 10692               	.LVL462:
2628:WTPA.c        **** 				TransferSdByte('P');
 10693               		.loc 1 2628 0
 10694 0856 80E5      		ldi r24,lo8(80)
 10695 0858 0E94 0000 		call TransferSdByte
 10696               	.LVL463:
2629:WTPA.c        **** 				TransferSdByte('A');
 10697               		.loc 1 2629 0
 10698 085c 81E4      		ldi r24,lo8(65)
 10699 085e 0E94 0000 		call TransferSdByte
 10700               	.LVL464:
2630:WTPA.c        **** 				TransferSdByte('S');				// These four characters indicate this card holds sample data (as oppos
 10701               		.loc 1 2630 0
 10702 0862 83E5      		ldi r24,lo8(83)
 10703 0864 0E94 0000 		call TransferSdByte
 10704               	.LVL465:
2631:WTPA.c        **** 				TransferSdByte('A');
 10705               		.loc 1 2631 0
 10706 0868 81E4      		ldi r24,lo8(65)
 10707 086a 0E94 0000 		call TransferSdByte
 10708               	.LVL466:
2632:WTPA.c        **** 				TransferSdByte('M');
 10709               		.loc 1 2632 0
 10710 086e 8DE4      		ldi r24,lo8(77)
 10711 0870 0E94 0000 		call TransferSdByte
 10712               	.LVL467:
2633:WTPA.c        **** 				TransferSdByte('P');
 10713               		.loc 1 2633 0
 10714 0874 80E5      		ldi r24,lo8(80)
 10715 0876 0E94 0000 		call TransferSdByte
 10716               	.LVL468:
2635:WTPA.c        **** 				bytesLeftInBlock-=8;
 10717               		.loc 1 2635 0
 10718 087a 8091 0000 		lds r24,bytesLeftInBlock.2026
 10719 087e 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10720 0882 0897      		sbiw r24,8
 10721 0884 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10722 0888 8093 0000 		sts bytesLeftInBlock.2026,r24
 10723               	.LVL469:
 10724 088c E8E0      		ldi r30,lo8(8)
 10725 088e 5E2E      		mov r5,r30
 10726               	.LVL470:
 10727               	.L800:
2639:WTPA.c        **** 					TransferSdByte('x');
 10728               		.loc 1 2639 0
 10729 0890 88E7      		ldi r24,lo8(120)
 10730 0892 0E94 0000 		call TransferSdByte
 10731               	.LVL471:
 10732 0896 5A94      		dec r5
2637:WTPA.c        **** 				for(i=0;i<8;i++)					// 8 don't care bytes
 10733               		.loc 1 2637 0
 10734 0898 01F4      		brne .L800
2642:WTPA.c        **** 				bytesLeftInBlock-=8;
 10735               		.loc 1 2642 0
 10736 089a 8091 0000 		lds r24,bytesLeftInBlock.2026
 10737 089e 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10738 08a2 0897      		sbiw r24,8
 10739 08a4 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10740 08a8 8093 0000 		sts bytesLeftInBlock.2026,r24
 10741               	.LVL472:
 10742 08ac 70E0      		ldi r23,lo8(sampleToc)
 10743 08ae 472E      		mov r4,r23
 10744 08b0 70E0      		ldi r23,hi8(sampleToc)
 10745 08b2 572E      		mov r5,r23
 10746               	.LVL473:
 10747               	.L801:
2646:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
 10748               		.loc 1 2646 0
 10749 08b4 F201      		movw r30,r4
 10750 08b6 8191      		ld r24,Z+
 10751 08b8 2F01      		movw r4,r30
 10752 08ba 0E94 0000 		call TransferSdByte
 10753               	.LVL474:
2644:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
 10754               		.loc 1 2644 0
 10755 08be F0E0      		ldi r31,lo8(sampleToc+64)
 10756 08c0 4F16      		cp r4,r31
 10757 08c2 F0E0      		ldi r31,hi8(sampleToc+64)
 10758 08c4 5F06      		cpc r5,r31
 10759 08c6 01F4      		brne .L801
2649:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
 10760               		.loc 1 2649 0
 10761 08c8 8091 0000 		lds r24,bytesLeftInBlock.2026
 10762 08cc 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10763 08d0 8054      		subi r24,64
 10764 08d2 9109      		sbc r25,__zero_reg__
 10765 08d4 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10766 08d8 8093 0000 		sts bytesLeftInBlock.2026,r24
2650:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 10767               		.loc 1 2650 0
 10768 08dc 7092 0000 		sts cardState,r7
 10769 08e0 00C0      		rjmp .L745
 10770               	.L917:
 10771 08e2 4090 0000 		lds r4,bytesLeftInBlock.2026
 10772 08e6 5090 0000 		lds r5,bytesLeftInBlock.2026+1
 10773 08ea 21E4      		ldi r18,65
 10774 08ec 4216      		cp r4,r18
 10775 08ee 5104      		cpc r5,__zero_reg__
 10776 08f0 00F0      		brlo .L802
 10777 08f2 60E4      		ldi r22,lo8(64)
 10778 08f4 462E      		mov r4,r22
 10779 08f6 512C      		mov r5,__zero_reg__
 10780               	.L802:
 10781               	.LVL475:
2668:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10782               		.loc 1 2668 0
 10783 08f8 312C      		mov r3,__zero_reg__
 10784 08fa 00C0      		rjmp .L803
 10785               	.LVL476:
 10786               	.L804:
2670:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10787               		.loc 1 2670 0
 10788 08fc 8FEF      		ldi r24,lo8(-1)
 10789 08fe 0E94 0000 		call TransferSdByte
 10790               	.LVL477:
2671:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
 10791               		.loc 1 2671 0
 10792 0902 8091 0000 		lds r24,bytesLeftInBlock.2026
 10793 0906 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10794 090a 0197      		sbiw r24,1
 10795 090c 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10796 0910 8093 0000 		sts bytesLeftInBlock.2026,r24
2668:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10797               		.loc 1 2668 0
 10798 0914 3394      		inc r3
 10799               	.LVL478:
 10800               	.L803:
 10801 0916 832D      		mov r24,r3
 10802 0918 90E0      		ldi r25,0
 10803 091a 8415      		cp r24,r4
 10804 091c 9505      		cpc r25,r5
 10805 091e 00F0      		brlo .L804
2674:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
 10806               		.loc 1 2674 0
 10807 0920 8091 0000 		lds r24,bytesLeftInBlock.2026
 10808 0924 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10809 0928 892B      		or r24,r25
 10810 092a 01F0      		breq .+2
 10811 092c 00C0      		rjmp .L745
2676:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10812               		.loc 1 2676 0
 10813 092e 8FEF      		ldi r24,lo8(-1)
 10814 0930 0E94 0000 		call TransferSdByte
 10815               	.LVL479:
2677:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10816               		.loc 1 2677 0
 10817 0934 8FEF      		ldi r24,lo8(-1)
 10818 0936 0E94 0000 		call TransferSdByte
 10819               	.LVL480:
2678:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 10820               		.loc 1 2678 0
 10821 093a 8FEF      		ldi r24,lo8(-1)
 10822 093c 0E94 0000 		call TransferSdByte
 10823               	.LVL481:
 10824 0940 8F71      		andi r24,lo8(31)
 10825               	.LVL482:
2680:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 10826               		.loc 1 2680 0
 10827 0942 8530      		cpi r24,lo8(5)
 10828 0944 01F0      		breq .+2
 10829 0946 00C0      		rjmp .L744
2682:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 10830               		.loc 1 2682 0
 10831 0948 62E6      		ldi r22,lo8(98)
 10832 094a 72E0      		ldi r23,lo8(2)
 10833 094c 83E0      		ldi r24,lo8(3)
 10834               	.LVL483:
 10835 094e 0E94 0000 		call SetTimer
 10836               	.LVL484:
2683:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
 10837               		.loc 1 2683 0
 10838 0952 8092 0000 		sts cardState,r8
 10839 0956 00C0      		rjmp .L745
 10840               	.LVL485:
 10841               	.L754:
2693:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10842               		.loc 1 2693 0
 10843 0958 83E0      		ldi r24,lo8(3)
 10844 095a 0E94 0000 		call CheckTimer
 10845               	.LVL486:
 10846 095e 8111      		cpse r24,__zero_reg__
 10847 0960 00C0      		rjmp .L744
 10848 0962 54E0      		ldi r21,lo8(4)
 10849 0964 552E      		mov r5,r21
 10850               	.L806:
2698:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10851               		.loc 1 2698 0
 10852 0966 8FEF      		ldi r24,lo8(-1)
 10853 0968 0E94 0000 		call TransferSdByte
 10854               	.LVL487:
2699:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 10855               		.loc 1 2699 0
 10856 096c 8F3F      		cpi r24,lo8(-1)
 10857 096e 01F4      		brne .+2
 10858 0970 00C0      		rjmp .L805
 10859               	.LVL488:
 10860 0972 5A94      		dec r5
2696:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 10861               		.loc 1 2696 0
 10862 0974 01F4      		brne .L806
 10863 0976 00C0      		rjmp .L745
 10864               	.L807:
2713:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10865               		.loc 1 2713 0
 10866 0978 8091 C800 		lds r24,200
 10867 097c 86FF      		sbrs r24,6
 10868 097e 00C0      		rjmp .L807
 10869 0980 00C0      		rjmp .L922
 10870               	.L755:
2729:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10871               		.loc 1 2729 0
 10872 0982 83E0      		ldi r24,lo8(3)
 10873 0984 0E94 0000 		call CheckTimer
 10874               	.LVL489:
 10875 0988 8111      		cpse r24,__zero_reg__
 10876 098a 00C0      		rjmp .L744
 10877 098c 44E0      		ldi r20,lo8(4)
 10878 098e 542E      		mov r5,r20
 10879               	.L809:
2734:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10880               		.loc 1 2734 0
 10881 0990 8FEF      		ldi r24,lo8(-1)
 10882 0992 0E94 0000 		call TransferSdByte
 10883               	.LVL490:
2735:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 10884               		.loc 1 2735 0
 10885 0996 8F3F      		cpi r24,lo8(-1)
 10886 0998 01F4      		brne .L808
 10887               	.LVL491:
 10888 099a 5A94      		dec r5
2732:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 10889               		.loc 1 2732 0
 10890 099c 01F4      		brne .L809
 10891 099e 00C0      		rjmp .L745
 10892               	.LVL492:
 10893               	.L808:
2745:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 10894               		.loc 1 2745 0
 10895 09a0 8E3F      		cpi r24,lo8(-2)
 10896 09a2 01F0      		breq .+2
 10897 09a4 00C0      		rjmp .L744
2747:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
 10898               		.loc 1 2747 0
 10899 09a6 1093 0000 		sts bytesLeftInBlock.2026+1,r17
 10900 09aa 0093 0000 		sts bytesLeftInBlock.2026,r16
2749:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
 10901               		.loc 1 2749 0
 10902 09ae 8FEF      		ldi r24,lo8(-1)
 10903               	.LVL493:
 10904 09b0 0E94 0000 		call TransferSdByte
 10905               	.LVL494:
 10906 09b4 90E0      		ldi r25,0
 10907 09b6 A0E0      		ldi r26,0
 10908 09b8 B0E0      		ldi r27,0
 10909 09ba B82F      		mov r27,r24
 10910 09bc AA27      		clr r26
 10911 09be 9927      		clr r25
 10912 09c0 8827      		clr r24
 10913 09c2 8093 0000 		sts sdCardSampleRemaining,r24
 10914 09c6 9093 0000 		sts sdCardSampleRemaining+1,r25
 10915 09ca A093 0000 		sts sdCardSampleRemaining+2,r26
 10916 09ce B093 0000 		sts sdCardSampleRemaining+3,r27
2750:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
 10917               		.loc 1 2750 0
 10918 09d2 2090 0000 		lds r2,sdCardSampleRemaining
 10919 09d6 3090 0000 		lds r3,sdCardSampleRemaining+1
 10920 09da 4090 0000 		lds r4,sdCardSampleRemaining+2
 10921 09de 5090 0000 		lds r5,sdCardSampleRemaining+3
 10922 09e2 8FEF      		ldi r24,lo8(-1)
 10923 09e4 0E94 0000 		call TransferSdByte
 10924               	.LVL495:
 10925 09e8 B201      		movw r22,r4
 10926 09ea A101      		movw r20,r2
 10927 09ec 682B      		or r22,r24
 10928 09ee 4093 0000 		sts sdCardSampleRemaining,r20
 10929 09f2 5093 0000 		sts sdCardSampleRemaining+1,r21
 10930 09f6 6093 0000 		sts sdCardSampleRemaining+2,r22
 10931 09fa 7093 0000 		sts sdCardSampleRemaining+3,r23
2751:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
 10932               		.loc 1 2751 0
 10933 09fe 2090 0000 		lds r2,sdCardSampleRemaining
 10934 0a02 3090 0000 		lds r3,sdCardSampleRemaining+1
 10935 0a06 4090 0000 		lds r4,sdCardSampleRemaining+2
 10936 0a0a 5090 0000 		lds r5,sdCardSampleRemaining+3
 10937 0a0e 8FEF      		ldi r24,lo8(-1)
 10938 0a10 0E94 0000 		call TransferSdByte
 10939               	.LVL496:
 10940 0a14 A201      		movw r20,r4
 10941 0a16 9101      		movw r18,r2
 10942 0a18 382B      		or r19,r24
 10943 0a1a 2093 0000 		sts sdCardSampleRemaining,r18
 10944 0a1e 3093 0000 		sts sdCardSampleRemaining+1,r19
 10945 0a22 4093 0000 		sts sdCardSampleRemaining+2,r20
 10946 0a26 5093 0000 		sts sdCardSampleRemaining+3,r21
2752:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
 10947               		.loc 1 2752 0
 10948 0a2a 2090 0000 		lds r2,sdCardSampleRemaining
 10949 0a2e 3090 0000 		lds r3,sdCardSampleRemaining+1
 10950 0a32 4090 0000 		lds r4,sdCardSampleRemaining+2
 10951 0a36 5090 0000 		lds r5,sdCardSampleRemaining+3
 10952 0a3a 8FEF      		ldi r24,lo8(-1)
 10953 0a3c 0E94 0000 		call TransferSdByte
 10954               	.LVL497:
 10955 0a40 B201      		movw r22,r4
 10956 0a42 A101      		movw r20,r2
 10957 0a44 482B      		or r20,r24
 10958 0a46 DB01      		movw r26,r22
 10959 0a48 CA01      		movw r24,r20
 10960 0a4a 8093 0000 		sts sdCardSampleRemaining,r24
 10961 0a4e 9093 0000 		sts sdCardSampleRemaining+1,r25
 10962 0a52 A093 0000 		sts sdCardSampleRemaining+2,r26
 10963 0a56 B093 0000 		sts sdCardSampleRemaining+3,r27
2754:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
 10964               		.loc 1 2754 0
 10965 0a5a 8091 0000 		lds r24,sdCardSampleRemaining
 10966 0a5e 9091 0000 		lds r25,sdCardSampleRemaining+1
 10967 0a62 A091 0000 		lds r26,sdCardSampleRemaining+2
 10968 0a66 B091 0000 		lds r27,sdCardSampleRemaining+3
 10969 0a6a 8093 0000 		sts sdRamSampleRemaining,r24
 10970 0a6e 9093 0000 		sts sdRamSampleRemaining+1,r25
 10971 0a72 A093 0000 		sts sdRamSampleRemaining+2,r26
 10972 0a76 B093 0000 		sts sdRamSampleRemaining+3,r27
2756:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
 10973               		.loc 1 2756 0
 10974 0a7a 8091 0000 		lds r24,bytesLeftInBlock.2026
 10975 0a7e 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 10976 0a82 0497      		sbiw r24,4
 10977 0a84 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 10978 0a88 8093 0000 		sts bytesLeftInBlock.2026,r24
 10979 0a8c 00C0      		rjmp .L926
 10980               	.L756:
2777:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
 10981               		.loc 1 2777 0
 10982 0a8e 8091 0000 		lds r24,sdAbortRead
 10983 0a92 8130      		cpi r24,lo8(1)
 10984 0a94 01F4      		brne .L810
 10985 0a96 00C0      		rjmp .L921
 10986               	.L810:
 10987 0a98 4090 0000 		lds r4,bytesLeftInBlock.2026
 10988 0a9c 5090 0000 		lds r5,bytesLeftInBlock.2026+1
 10989 0aa0 51E4      		ldi r21,65
 10990 0aa2 4516      		cp r4,r21
 10991 0aa4 5104      		cpc r5,__zero_reg__
 10992 0aa6 00F0      		brlo .L811
 10993 0aa8 20E4      		ldi r18,lo8(64)
 10994 0aaa 422E      		mov r4,r18
 10995 0aac 512C      		mov r5,__zero_reg__
 10996               	.L811:
 10997               	.LVL498:
2793:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 10998               		.loc 1 2793 0
 10999 0aae 312C      		mov r3,__zero_reg__
 11000 0ab0 00C0      		rjmp .L812
 11001               	.LVL499:
 11002               	.L815:
2795:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
 11003               		.loc 1 2795 0
 11004 0ab2 8FEF      		ldi r24,lo8(-1)
 11005 0ab4 0E94 0000 		call TransferSdByte
 11006               	.LVL500:
2796:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
 11007               		.loc 1 2796 0
 11008 0ab8 2091 0000 		lds r18,bytesLeftInBlock.2026
 11009 0abc 3091 0000 		lds r19,bytesLeftInBlock.2026+1
 11010 0ac0 2150      		subi r18,1
 11011 0ac2 3109      		sbc r19,__zero_reg__
 11012 0ac4 3093 0000 		sts bytesLeftInBlock.2026+1,r19
 11013 0ac8 2093 0000 		sts bytesLeftInBlock.2026,r18
2798:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
 11014               		.loc 1 2798 0
 11015 0acc 4091 0000 		lds r20,sdCardSampleRemaining
 11016 0ad0 5091 0000 		lds r21,sdCardSampleRemaining+1
 11017 0ad4 6091 0000 		lds r22,sdCardSampleRemaining+2
 11018 0ad8 7091 0000 		lds r23,sdCardSampleRemaining+3
 11019 0adc 452B      		or r20,r21
 11020 0ade 462B      		or r20,r22
 11021 0ae0 472B      		or r20,r23
 11022 0ae2 01F0      		breq .L813
2800:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
 11023               		.loc 1 2800 0
 11024 0ae4 4091 0000 		lds r20,sdCardSampleRemaining
 11025 0ae8 5091 0000 		lds r21,sdCardSampleRemaining+1
 11026 0aec 6091 0000 		lds r22,sdCardSampleRemaining+2
 11027 0af0 7091 0000 		lds r23,sdCardSampleRemaining+3
 11028 0af4 4150      		subi r20,1
 11029 0af6 5109      		sbc r21,__zero_reg__
 11030 0af8 6109      		sbc r22,__zero_reg__
 11031 0afa 7109      		sbc r23,__zero_reg__
 11032 0afc 4093 0000 		sts sdCardSampleRemaining,r20
 11033 0b00 5093 0000 		sts sdCardSampleRemaining+1,r21
 11034 0b04 6093 0000 		sts sdCardSampleRemaining+2,r22
 11035 0b08 7093 0000 		sts sdCardSampleRemaining+3,r23
2802:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
 11036               		.loc 1 2802 0
 11037 0b0c E091 0000 		lds r30,sdFifoWritePointer
 11038 0b10 F091 0000 		lds r31,sdFifoWritePointer+1
 11039 0b14 E050      		subi r30,lo8(-(sdFifo))
 11040 0b16 F040      		sbci r31,hi8(-(sdFifo))
 11041 0b18 8083      		st Z,r24
2803:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
 11042               		.loc 1 2803 0
 11043 0b1a 8091 0000 		lds r24,sdFifoWritePointer
 11044 0b1e 9091 0000 		lds r25,sdFifoWritePointer+1
 11045               	.LVL501:
 11046 0b22 0196      		adiw r24,1
 11047 0b24 9093 0000 		sts sdFifoWritePointer+1,r25
 11048 0b28 8093 0000 		sts sdFifoWritePointer,r24
2805:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 11049               		.loc 1 2805 0
 11050 0b2c 8091 0000 		lds r24,sdFifoWritePointer
 11051 0b30 9091 0000 		lds r25,sdFifoWritePointer+1
 11052 0b34 8115      		cp r24,__zero_reg__
 11053 0b36 9340      		sbci r25,3
 11054 0b38 00F0      		brlo .L814
2807:WTPA.c        **** 							sdFifoWritePointer=0;
 11055               		.loc 1 2807 0
 11056 0b3a 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 11057 0b3e 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 11058               	.L814:
2810:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 11059               		.loc 1 2810 0
 11060 0b42 2FB7      		in r18,__SREG__
 11061               	.LVL502:
2811:WTPA.c        **** 						cli();
 11062               		.loc 1 2811 0
 11063               	/* #APP */
 11064               	 ;  2811 "WTPA.c" 1
 11065 0b44 F894      		cli
 11066               	 ;  0 "" 2
2812:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
 11067               		.loc 1 2812 0
 11068               	/* #NOAPP */
 11069 0b46 8091 0000 		lds r24,sdBytesInFifo
 11070 0b4a 9091 0000 		lds r25,sdBytesInFifo+1
 11071 0b4e 0196      		adiw r24,1
 11072 0b50 9093 0000 		sts sdBytesInFifo+1,r25
 11073 0b54 8093 0000 		sts sdBytesInFifo,r24
2813:WTPA.c        **** 						SREG=sreg;
 11074               		.loc 1 2813 0
 11075 0b58 2FBF      		out __SREG__,r18
 11076               	.LVL503:
 11077               	.L813:
2793:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 11078               		.loc 1 2793 0
 11079 0b5a 3394      		inc r3
 11080               	.LVL504:
 11081               	.L812:
 11082 0b5c 832D      		mov r24,r3
 11083 0b5e 90E0      		ldi r25,0
 11084 0b60 8415      		cp r24,r4
 11085 0b62 9505      		cpc r25,r5
 11086 0b64 00F4      		brsh .+2
 11087 0b66 00C0      		rjmp .L815
2818:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
 11088               		.loc 1 2818 0
 11089 0b68 8091 0000 		lds r24,bytesLeftInBlock.2026
 11090 0b6c 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 11091 0b70 892B      		or r24,r25
 11092 0b72 01F0      		breq .+2
 11093 0b74 00C0      		rjmp .L745
2820:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 11094               		.loc 1 2820 0
 11095 0b76 8FEF      		ldi r24,lo8(-1)
 11096 0b78 0E94 0000 		call TransferSdByte
 11097               	.LVL505:
2821:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 11098               		.loc 1 2821 0
 11099 0b7c 8FEF      		ldi r24,lo8(-1)
 11100 0b7e 0E94 0000 		call TransferSdByte
 11101               	.LVL506:
 11102               	.L816:
2822:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 11103               		.loc 1 2822 0
 11104 0b82 8091 C800 		lds r24,200
 11105 0b86 86FF      		sbrs r24,6
 11106 0b88 00C0      		rjmp .L816
2825:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 11107               		.loc 1 2825 0
 11108 0b8a 0E94 0000 		call EndSdTransfer
 11109               	.LVL507:
2826:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 11110               		.loc 1 2826 0
 11111 0b8e 8FEF      		ldi r24,lo8(-1)
 11112 0b90 0E94 0000 		call TransferSdByte
 11113               	.LVL508:
2827:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 11114               		.loc 1 2827 0
 11115 0b94 6092 0000 		sts cardState,r6
2829:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
 11116               		.loc 1 2829 0
 11117 0b98 8091 0000 		lds r24,sdCardSampleRemaining
 11118 0b9c 9091 0000 		lds r25,sdCardSampleRemaining+1
 11119 0ba0 A091 0000 		lds r26,sdCardSampleRemaining+2
 11120 0ba4 B091 0000 		lds r27,sdCardSampleRemaining+3
 11121 0ba8 892B      		or r24,r25
 11122 0baa 8A2B      		or r24,r26
 11123 0bac 8B2B      		or r24,r27
 11124 0bae 01F0      		breq .+2
 11125 0bb0 00C0      		rjmp .L745
 11126               	.L875:
2831:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 11127               		.loc 1 2831 0
 11128 0bb2 8091 C800 		lds r24,200
 11129 0bb6 86FF      		sbrs r24,6
 11130 0bb8 00C0      		rjmp .L875
 11131               	.LVL509:
 11132               	.L922:
2833:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
 11133               		.loc 1 2833 0
 11134 0bba B092 0000 		sts cardState,r11
 11135 0bbe 00C0      		rjmp .L745
 11136               	.L757:
2840:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 11137               		.loc 1 2840 0
 11138 0bc0 EFB7      		in r30,__SREG__
 11139               	.LVL510:
2841:WTPA.c        **** 			cli();
 11140               		.loc 1 2841 0
 11141               	/* #APP */
 11142               	 ;  2841 "WTPA.c" 1
 11143 0bc2 F894      		cli
 11144               	 ;  0 "" 2
2843:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
 11145               		.loc 1 2843 0
 11146               	/* #NOAPP */
 11147 0bc4 2091 0000 		lds r18,sdBytesInFifo
 11148 0bc8 3091 0000 		lds r19,sdBytesInFifo+1
 11149 0bcc 80E0      		ldi r24,0
 11150 0bce 93E0      		ldi r25,lo8(3)
 11151 0bd0 AC01      		movw r20,r24
 11152 0bd2 421B      		sub r20,r18
 11153 0bd4 530B      		sbc r21,r19
 11154 0bd6 9A01      		movw r18,r20
 11155 0bd8 2115      		cp r18,__zero_reg__
 11156 0bda 3240      		sbci r19,2
 11157 0bdc 00F4      		brsh .L818
 11158 0bde 2091 0000 		lds r18,sdBytesInFifo
 11159 0be2 3091 0000 		lds r19,sdBytesInFifo+1
 11160 0be6 4091 0000 		lds r20,sdCardSampleRemaining
 11161 0bea 5091 0000 		lds r21,sdCardSampleRemaining+1
 11162 0bee 6091 0000 		lds r22,sdCardSampleRemaining+2
 11163 0bf2 7091 0000 		lds r23,sdCardSampleRemaining+3
 11164 0bf6 821B      		sub r24,r18
 11165 0bf8 930B      		sbc r25,r19
 11166 0bfa A0E0      		ldi r26,0
 11167 0bfc B0E0      		ldi r27,0
 11168 0bfe 8417      		cp r24,r20
 11169 0c00 9507      		cpc r25,r21
 11170 0c02 A607      		cpc r26,r22
 11171 0c04 B707      		cpc r27,r23
 11172 0c06 00F0      		brlo .L819
 11173               	.L818:
2845:WTPA.c        **** 				SREG=sreg;				// ISR back on.
 11174               		.loc 1 2845 0
 11175 0c08 EFBF      		out __SREG__,r30
2846:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
 11176               		.loc 1 2846 0
 11177 0c0a 2091 0000 		lds r18,sdCurrentBlockOffset
 11178 0c0e 3091 0000 		lds r19,sdCurrentBlockOffset+1
 11179 0c12 2F5F      		subi r18,-1
 11180 0c14 3F4F      		sbci r19,-1
 11181 0c16 3093 0000 		sts sdCurrentBlockOffset+1,r19
 11182 0c1a 2093 0000 		sts sdCurrentBlockOffset,r18
2848:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
 11183               		.loc 1 2848 0
 11184 0c1e 6091 0000 		lds r22,sdSampleStartBlock
 11185 0c22 7091 0000 		lds r23,sdSampleStartBlock+1
 11186 0c26 8091 0000 		lds r24,sdSampleStartBlock+2
 11187 0c2a 9091 0000 		lds r25,sdSampleStartBlock+3
 11188 0c2e 620F      		add r22,r18
 11189 0c30 731F      		adc r23,r19
 11190 0c32 811D      		adc r24,__zero_reg__
 11191 0c34 911D      		adc r25,__zero_reg__
 11192 0c36 0E94 0000 		call SdBeginSingleBlockRead
 11193               	.LVL511:
 11194 0c3a 8130      		cpi r24,lo8(1)
 11195 0c3c 01F0      		breq .+2
 11196 0c3e 00C0      		rjmp .L744
2850:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 11197               		.loc 1 2850 0
 11198 0c40 6AE7      		ldi r22,lo8(122)
 11199 0c42 70E0      		ldi r23,0
 11200 0c44 83E0      		ldi r24,lo8(3)
 11201 0c46 0E94 0000 		call SetTimer
 11202               	.LVL512:
2851:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
 11203               		.loc 1 2851 0
 11204 0c4a 8CE0      		ldi r24,lo8(12)
 11205               	.L920:
 11206 0c4c 8093 0000 		sts cardState,r24
 11207 0c50 00C0      		rjmp .L745
 11208               	.LVL513:
 11209               	.L819:
2860:WTPA.c        **** 				SREG=sreg;	// ISR back on.
 11210               		.loc 1 2860 0
 11211 0c52 EFBF      		out __SREG__,r30
 11212 0c54 00C0      		rjmp .L745
 11213               	.LVL514:
 11214               	.L758:
2866:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 11215               		.loc 1 2866 0
 11216 0c56 83E0      		ldi r24,lo8(3)
 11217 0c58 0E94 0000 		call CheckTimer
 11218               	.LVL515:
 11219 0c5c 8111      		cpse r24,__zero_reg__
 11220 0c5e 00C0      		rjmp .L744
 11221 0c60 94E0      		ldi r25,lo8(4)
 11222 0c62 592E      		mov r5,r25
 11223               	.L821:
2871:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 11224               		.loc 1 2871 0
 11225 0c64 8FEF      		ldi r24,lo8(-1)
 11226 0c66 0E94 0000 		call TransferSdByte
 11227               	.LVL516:
2872:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 11228               		.loc 1 2872 0
 11229 0c6a 8F3F      		cpi r24,lo8(-1)
 11230 0c6c 01F4      		brne .L820
 11231               	.LVL517:
 11232 0c6e 5A94      		dec r5
2869:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 11233               		.loc 1 2869 0
 11234 0c70 01F4      		brne .L821
 11235 0c72 00C0      		rjmp .L745
 11236               	.LVL518:
 11237               	.L820:
2881:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 11238               		.loc 1 2881 0
 11239 0c74 8E3F      		cpi r24,lo8(-2)
 11240 0c76 01F0      		breq .+2
 11241 0c78 00C0      		rjmp .L744
2883:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
 11242               		.loc 1 2883 0
 11243 0c7a 1093 0000 		sts bytesLeftInBlock.2026+1,r17
 11244 0c7e 0093 0000 		sts bytesLeftInBlock.2026,r16
 11245               	.LVL519:
 11246               	.L926:
2885:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 11247               		.loc 1 2885 0
 11248 0c82 8AE0      		ldi r24,lo8(10)
 11249 0c84 8093 0000 		sts cardState,r24
2886:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
 11250               		.loc 1 2886 0
 11251 0c88 8091 0000 		lds r24,sdAbortRead
 11252 0c8c 8130      		cpi r24,lo8(1)
 11253 0c8e 01F0      		breq .+2
 11254 0c90 00C0      		rjmp .L745
 11255               	.L921:
2888:WTPA.c        **** 						cardState=SD_READ_ABORT;
 11256               		.loc 1 2888 0
 11257 0c92 9092 0000 		sts cardState,r9
2889:WTPA.c        **** 						sdAbortRead=false;
 11258               		.loc 1 2889 0
 11259 0c96 1092 0000 		sts sdAbortRead,__zero_reg__
 11260 0c9a 00C0      		rjmp .L745
 11261               	.L759:
 11262 0c9c 4090 0000 		lds r4,bytesLeftInBlock.2026
 11263 0ca0 5090 0000 		lds r5,bytesLeftInBlock.2026+1
 11264 0ca4 61E4      		ldi r22,65
 11265 0ca6 4616      		cp r4,r22
 11266 0ca8 5104      		cpc r5,__zero_reg__
 11267 0caa 00F0      		brlo .L822
 11268 0cac 80E4      		ldi r24,lo8(64)
 11269 0cae 482E      		mov r4,r24
 11270 0cb0 512C      		mov r5,__zero_reg__
 11271               	.L822:
 11272               	.LVL520:
2913:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 11273               		.loc 1 2913 0
 11274 0cb2 312C      		mov r3,__zero_reg__
 11275 0cb4 00C0      		rjmp .L823
 11276               	.LVL521:
 11277               	.L824:
2915:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
 11278               		.loc 1 2915 0
 11279 0cb6 8FEF      		ldi r24,lo8(-1)
 11280 0cb8 0E94 0000 		call TransferSdByte
 11281               	.LVL522:
2916:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
 11282               		.loc 1 2916 0
 11283 0cbc 8091 0000 		lds r24,bytesLeftInBlock.2026
 11284 0cc0 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 11285 0cc4 0197      		sbiw r24,1
 11286 0cc6 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 11287 0cca 8093 0000 		sts bytesLeftInBlock.2026,r24
2913:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 11288               		.loc 1 2913 0
 11289 0cce 3394      		inc r3
 11290               	.LVL523:
 11291               	.L823:
 11292 0cd0 832D      		mov r24,r3
 11293 0cd2 90E0      		ldi r25,0
 11294 0cd4 8415      		cp r24,r4
 11295 0cd6 9505      		cpc r25,r5
 11296 0cd8 00F0      		brlo .L824
2920:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
 11297               		.loc 1 2920 0
 11298 0cda 8091 0000 		lds r24,bytesLeftInBlock.2026
 11299 0cde 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 11300 0ce2 892B      		or r24,r25
 11301 0ce4 01F4      		brne .L745
2922:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 11302               		.loc 1 2922 0
 11303 0ce6 8FEF      		ldi r24,lo8(-1)
 11304 0ce8 0E94 0000 		call TransferSdByte
 11305               	.LVL524:
2923:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 11306               		.loc 1 2923 0
 11307 0cec 8FEF      		ldi r24,lo8(-1)
 11308 0cee 0E94 0000 		call TransferSdByte
 11309               	.LVL525:
 11310               	.L825:
2924:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 11311               		.loc 1 2924 0
 11312 0cf2 8091 C800 		lds r24,200
 11313 0cf6 86FF      		sbrs r24,6
 11314 0cf8 00C0      		rjmp .L825
2927:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
 11315               		.loc 1 2927 0
 11316 0cfa 0E94 0000 		call EndSdTransfer
 11317               	.LVL526:
2928:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
 11318               		.loc 1 2928 0
 11319 0cfe 8FEF      		ldi r24,lo8(-1)
 11320 0d00 0E94 0000 		call TransferSdByte
 11321               	.LVL527:
 11322               	.L826:
2930:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 11323               		.loc 1 2930 0
 11324 0d04 8091 C800 		lds r24,200
 11325 0d08 86FF      		sbrs r24,6
 11326 0d0a 00C0      		rjmp .L826
2932:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
 11327               		.loc 1 2932 0
 11328 0d0c B092 0000 		sts cardState,r11
2934:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
 11329               		.loc 1 2934 0
 11330 0d10 8091 0000 		lds r24,sdPlaybackQueued
 11331 0d14 8130      		cpi r24,lo8(1)
 11332 0d16 01F4      		brne .L745
2936:WTPA.c        **** 					sdPlaybackQueued=false;
 11333               		.loc 1 2936 0
 11334 0d18 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2937:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
 11335               		.loc 1 2937 0
 11336 0d1c 8091 0000 		lds r24,sdQueuedSlot
 11337 0d20 9091 0000 		lds r25,sdQueuedSlot+1
 11338 0d24 0E94 0000 		call PlaySampleFromSd
 11339               	.LVL528:
 11340               	.L745:
 11341               	.LBE378:
 11342               	.LBE384:
4951:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
 11343               		.loc 1 4951 0
 11344 0d28 0E94 0000 		call GetRandomLongInt
 11345               	.LVL529:
4956:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
 11346               		.loc 1 4956 0
 11347 0d2c 0E94 0000 		call Uart0GotByte
 11348               	.LVL530:
 11349 0d30 8823      		tst r24
 11350 0d32 01F0      		breq .L827
4958:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
 11351               		.loc 1 4958 0
 11352 0d34 0E94 0000 		call Uart0GetByte
 11353               	.LVL531:
 11354 0d38 0E94 0000 		call HandleIncomingMidiByte
 11355               	.LVL532:
 11356               	.L827:
4961:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
 11357               		.loc 1 4961 0
 11358 0d3c 0E94 0000 		call MidiTxBufferNotEmpty
 11359               	.LVL533:
 11360 0d40 8823      		tst r24
 11361 0d42 01F0      		breq .L828
4963:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
 11362               		.loc 1 4963 0
 11363 0d44 8091 C000 		lds r24,192
 11364 0d48 85FF      		sbrs r24,5
 11365 0d4a 00C0      		rjmp .L828
4965:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
 11366               		.loc 1 4965 0
 11367 0d4c 0E94 0000 		call PopOutgoingMidiByte
 11368               	.LVL534:
 11369 0d50 8093 C600 		sts 198,r24
 11370               	.L828:
4969:WTPA.c        **** 		State();				// Execute the current program state.
 11371               		.loc 1 4969 0
 11372 0d54 E091 0000 		lds r30,State
 11373 0d58 F091 0000 		lds r31,State+1
 11374 0d5c 0995      		icall
 11375               	.LVL535:
4970:WTPA.c        **** 	}
 11376               		.loc 1 4970 0
 11377 0d5e 00C0      		rjmp .L829
 11378               	.LVL536:
 11379               	.L793:
 11380               	.LBB385:
 11381               	.LBB379:
2557:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 11382               		.loc 1 2557 0
 11383 0d60 0E94 0000 		call EndSdTransfer
 11384               	.LVL537:
2558:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 11385               		.loc 1 2558 0
 11386 0d64 8FEF      		ldi r24,lo8(-1)
 11387 0d66 0E94 0000 		call TransferSdByte
 11388               	.LVL538:
 11389 0d6a 00C0      		rjmp .L795
 11390               	.LVL539:
 11391               	.L805:
2711:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 11392               		.loc 1 2711 0
 11393 0d6c 0E94 0000 		call EndSdTransfer
 11394               	.LVL540:
2712:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 11395               		.loc 1 2712 0
 11396 0d70 8FEF      		ldi r24,lo8(-1)
 11397 0d72 0E94 0000 		call TransferSdByte
 11398               	.LVL541:
 11399 0d76 00C0      		rjmp .L807
 11400               	.LBE379:
 11401               	.LBE385:
 11402               		.cfi_endproc
 11403               	.LFE76:
 11405               		.comm	UpdateOutput,2,1
 11406               		.local	sdCardSampleRemaining
 11407               		.comm	sdCardSampleRemaining,4,1
 11408               		.local	sdRamSampleRemaining
 11409               		.comm	sdRamSampleRemaining,4,1
 11410               		.local	sdBytesInFifo
 11411               		.comm	sdBytesInFifo,2,1
 11412               		.local	sdFifoWritePointer
 11413               		.comm	sdFifoWritePointer,2,1
 11414               		.local	sdFifoReadPointer
 11415               		.comm	sdFifoReadPointer,2,1
 11416               		.local	sdFifo
 11417               		.comm	sdFifo,768,1
 11418               		.local	adcByte
 11419               		.comm	adcByte,1,1
 11420               		.local	sliceRemaining
 11421               		.comm	sliceRemaining,8,1
 11422               		.local	sliceSize
 11423               		.comm	sliceSize,8,1
 11424               		.local	granularPositionArrayPointer
 11425               		.comm	granularPositionArrayPointer,2,1
 11426               		.local	outOfRam
 11427               		.comm	outOfRam,1,1
 11428               		.comm	State,2,1
 11429               		.local	ledPwm
 11430               		.comm	ledPwm,1,1
 11431               		.local	flipFlop.1813
 11432               		.comm	flipFlop.1813,1,1
 11433               		.local	extIsrOutputBank0
 11434               		.comm	extIsrOutputBank0,1,1
 11435               		.local	sawtooth.1757
 11436               		.comm	sawtooth.1757,1,1
 11437               		.local	granularPositionArray
 11438               		.comm	granularPositionArray,256,1
 11439               		.local	flipFlop.1819
 11440               		.comm	flipFlop.1819,1,1
 11441               		.local	extIsrOutputBank1
 11442               		.comm	extIsrOutputBank1,1,1
 11443               		.local	sawtooth.1769
 11444               		.comm	sawtooth.1769,1,1
 11445               		.local	flipFlop.1827
 11446               		.comm	flipFlop.1827,1,1
 11447               		.local	midiOutputBank0
 11448               		.comm	midiOutputBank0,1,1
 11449               		.data
 11452               	random31:
 11453 0000 EF        		.byte	-17
 11454 0001 BE        		.byte	-66
 11455 0002 00        		.byte	0
 11456 0003 00        		.byte	0
 11457               		.local	lastJitterValue.1826
 11458               		.comm	lastJitterValue.1826,2,1
 11459               		.local	flipFlop.1835
 11460               		.comm	flipFlop.1835,1,1
 11461               		.local	midiOutputBank1
 11462               		.comm	midiOutputBank1,1,1
 11463               		.local	lastJitterValue.1834
 11464               		.comm	lastJitterValue.1834,2,1
 11465               		.local	sdIsrState
 11466               		.comm	sdIsrState,1,1
 11467               		.local	sdRamAddress
 11468               		.comm	sdRamAddress,4,1
 11469               		.local	sdBank0
 11470               		.comm	sdBank0,1,1
 11471               		.local	sdStreamOutput
 11472               		.comm	sdStreamOutput,1,1
 11473               		.local	pwmCount.1847
 11474               		.comm	pwmCount.1847,1,1
 11475               		.local	newKeys
 11476               		.comm	newKeys,1,1
 11477               		.local	keyState
 11478               		.comm	keyState,1,1
 11479               		.local	cardState
 11480               		.comm	cardState,1,1
 11481               		.local	cardDetect
 11482               		.comm	cardDetect,1,1
 11483               		.local	subState
 11484               		.comm	subState,1,1
 11485               		.local	i.2279
 11486               		.comm	i.2279,1,1
 11487               		.local	ledOnOffMask
 11488               		.comm	ledOnOffMask,1,1
 11489               		.local	theMidiRecordRate
 11490               		.comm	theMidiRecordRate,4,1
 11491               		.local	currentBank
 11492               		.comm	currentBank,1,1
 11493               		.local	sdCurrentSlot
 11494               		.comm	sdCurrentSlot,2,1
 11495               		.local	currentMidiMessage.2230
 11496               		.comm	currentMidiMessage.2230,4,1
 11499               	currentNoteOn.2231:
 11500 0004 3C        		.byte	60
 11501 0005 3C        		.byte	60
 11502               		.local	lastDacByte
 11503               		.comm	lastDacByte,1,1
 11504               		.local	keysHeld
 11505               		.comm	keysHeld,1,1
 11506               		.local	newEncoder
 11507               		.comm	newEncoder,1,1
 11508               		.local	scaledEncoderValue
 11509               		.comm	scaledEncoderValue,1,1
 11510               		.local	encoderValue
 11511               		.comm	encoderValue,1,1
 11512               		.local	sampleToc
 11513               		.comm	sampleToc,64,1
 11514               		.local	ledBlinkMask
 11515               		.comm	ledBlinkMask,1,1
 11516               		.local	encoderCw
 11517               		.comm	encoderCw,1,1
 11518               		.local	encoderCcw
 11519               		.comm	encoderCcw,1,1
 11520               		.local	sdSampleStartBlock
 11521               		.comm	sdSampleStartBlock,4,1
 11522               		.local	sdCurrentBlockOffset
 11523               		.comm	sdCurrentBlockOffset,2,1
 11524               		.local	sdAbortRead
 11525               		.comm	sdAbortRead,1,1
 11526               		.local	sdQueuedSlot
 11527               		.comm	sdQueuedSlot,2,1
 11528               		.local	sdPlaybackQueued
 11529               		.comm	sdPlaybackQueued,1,1
 11530               		.section	.rodata
 11533               	OctaveZeroCompareMatches:
 11534 0000 FFFF      		.word	-1
 11535 0002 A1F1      		.word	-3679
 11536 0004 11E4      		.word	-7151
 11537 0006 44D7      		.word	-10428
 11538 0008 2FCB      		.word	-13521
 11539 000a C8BF      		.word	-16440
 11540 000c 04B5      		.word	-19196
 11541 000e DBAA      		.word	-21797
 11542 0010 44A1      		.word	-24252
 11543 0012 3798      		.word	-26569
 11544 0014 AC8F      		.word	-28756
 11545 0016 9C87      		.word	-30820
 11546               		.local	encoderState
 11547               		.comm	encoderState,1,1
 11548               		.local	lastKeyState.1897
 11549               		.comm	lastKeyState.1897,1,1
 11550               		.local	lastEncTime.1906
 11551               		.comm	lastEncTime.1906,2,1
 11552               		.local	lastEncoderState.1905
 11553               		.comm	lastEncoderState.1905,1,1
 11554               		.local	toggle.1883
 11555               		.comm	toggle.1883,1,1
 11556               		.local	lastLedMask.1884
 11557               		.comm	lastLedMask.1884,1,1
 11558               		.local	bytesLeftInBlock.2026
 11559               		.comm	bytesLeftInBlock.2026,2,1
 11560               		.text
 11561               	.Letext0:
 11562               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 11563               		.file 3 "defines.h"
 11564               		.file 4 "globals.h"
 11565               		.file 5 "midi.h"
 11566               		.file 6 "microSD.h"
 11567               		.file 7 "softclock.h"
 11568               		.file 8 "eeprom.h"
 11569               		.file 9 "uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 WTPA.c
     /tmp/ccuDZzHg.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccuDZzHg.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccuDZzHg.s:4      *ABS*:0000003f __SREG__
     /tmp/ccuDZzHg.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccuDZzHg.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccuDZzHg.s:11     .text:00000000 UpdateAudioChannel0
     /tmp/ccuDZzHg.s:11434  .bss:00000325 sawtooth.1757
     /tmp/ccuDZzHg.s:11417  .bss:0000030e adcByte
     /tmp/ccuDZzHg.s:11425  .bss:00000321 outOfRam
     /tmp/ccuDZzHg.s:11419  .bss:0000030f sliceRemaining
     /tmp/ccuDZzHg.s:11421  .bss:00000317 sliceSize
     /tmp/ccuDZzHg.s:11423  .bss:0000031f granularPositionArrayPointer
     /tmp/ccuDZzHg.s:11436  .bss:00000326 granularPositionArray
     /tmp/ccuDZzHg.s:821    .text:0000075c UpdateAudioChannel1
     /tmp/ccuDZzHg.s:11442  .bss:00000428 sawtooth.1769
     /tmp/ccuDZzHg.s:1657   .text:00000ee0 OutputMultiplyBanks
     /tmp/ccuDZzHg.s:11432  .bss:00000324 extIsrOutputBank0
     /tmp/ccuDZzHg.s:11446  .bss:0000042a midiOutputBank0
     /tmp/ccuDZzHg.s:11440  .bss:00000427 extIsrOutputBank1
     /tmp/ccuDZzHg.s:11460  .bss:0000042e midiOutputBank1
     /tmp/ccuDZzHg.s:11496  .bss:0000044b lastDacByte
     /tmp/ccuDZzHg.s:1761   .text:00000f78 OutputAddBanks
     /tmp/ccuDZzHg.s:11470  .bss:00000437 sdStreamOutput
     /tmp/ccuDZzHg.s:1834   .text:00000fe4 OutputXorBanks
     /tmp/ccuDZzHg.s:1920   .text:0000105e OutputAndBanks
     /tmp/ccuDZzHg.s:2006   .text:000010d8 WriteLedLatch
     /tmp/ccuDZzHg.s:2041   .text:000010ea CheckSdSlotFull
     /tmp/ccuDZzHg.s:11511  .bss:00000450 sampleToc
     /tmp/ccuDZzHg.s:2085   .text:00001114 SdIsrStartStreamingAudio
     /tmp/ccuDZzHg.s:11464  .bss:00000431 sdIsrState
     /tmp/ccuDZzHg.s:2129   .text:00001140 GetRandomLongInt
     /tmp/ccuDZzHg.s:11452  .data:00000000 random31
     /tmp/ccuDZzHg.s:2177   .text:00001192 MakeNewGranularArray
     /tmp/ccuDZzHg.s:2514   .text:0000138c UpdateAdjustedSampleAddresses
     /tmp/ccuDZzHg.s:3347   .text:00001b94 RevertSampleToUnadjusted
     /tmp/ccuDZzHg.s:3402   .text:00001bce BlinkLeds
     /tmp/ccuDZzHg.s:11513  .bss:00000490 ledBlinkMask
     /tmp/ccuDZzHg.s:11486  .bss:0000043f ledOnOffMask
     /tmp/ccuDZzHg.s:3468   .text:00001c22 KillLeds
     /tmp/ccuDZzHg.s:3487   .text:00001c2e StopBlinking
     /tmp/ccuDZzHg.s:3504   .text:00001c36 DoFruitcakeIntro
     /tmp/ccuDZzHg.s:11482  .bss:0000043d subState
     /tmp/ccuDZzHg.s:11478  .bss:0000043b cardState
     /tmp/ccuDZzHg.s:11484  .bss:0000043e i.2279
     /tmp/ccuDZzHg.s:11427  .bss:00000322 ledPwm
     /tmp/ccuDZzHg.s:4652   .text:000021ec DoStartupSelect
                            *COM*:00000002 State
     /tmp/ccuDZzHg.s:3737   .text:00001d9c ResetSdCard
     /tmp/ccuDZzHg.s:11413  .bss:0000000c sdFifoReadPointer
     /tmp/ccuDZzHg.s:11411  .bss:0000000a sdFifoWritePointer
     /tmp/ccuDZzHg.s:11409  .bss:00000008 sdBytesInFifo
     /tmp/ccuDZzHg.s:3811   .text:00001df0 SdStartSampleRead
     /tmp/ccuDZzHg.s:11519  .bss:00000493 sdSampleStartBlock
     /tmp/ccuDZzHg.s:11521  .bss:00000497 sdCurrentBlockOffset
     /tmp/ccuDZzHg.s:3917   .text:00001e74 SetSampleClock.part.0
     /tmp/ccuDZzHg.s:3944   .text:00001e8c SetSampleClock
     /tmp/ccuDZzHg.s:4031   .text:00001f08 StartPlayback
     /tmp/ccuDZzHg.s:4159   .text:00001f9e ContinuePlayback
     /tmp/ccuDZzHg.s:4238   .text:00001fee StartRecording
     /tmp/ccuDZzHg.s:4384   .text:000020aa StartOverdub
     /tmp/ccuDZzHg.s:4479   .text:00002116 StartRealtime
     /tmp/ccuDZzHg.s:4541   .text:00002152 DoFormatCard
     /tmp/ccuDZzHg.s:11476  .bss:0000043a keyState
     /tmp/ccuDZzHg.s:11474  .bss:00000439 newKeys
     /tmp/ccuDZzHg.s:5537   .text:000026f8 DoSawtooth
     /tmp/ccuDZzHg.s:5963   .text:00002920 SetMidiChannels
     /tmp/ccuDZzHg.s:5704   .text:000027e6 InitSampler
     /tmp/ccuDZzHg.s:4731   .text:00002238 PlaySampleFromSd
     /tmp/ccuDZzHg.s:11407  .bss:00000004 sdRamSampleRemaining
     /tmp/ccuDZzHg.s:11523  .bss:00000499 sdAbortRead
     /tmp/ccuDZzHg.s:11525  .bss:0000049a sdQueuedSlot
     /tmp/ccuDZzHg.s:11527  .bss:0000049c sdPlaybackQueued
     /tmp/ccuDZzHg.s:4842   .text:000022bc SdCardMenu
     /tmp/ccuDZzHg.s:11492  .bss:00000445 sdCurrentSlot
     /tmp/ccuDZzHg.s:11480  .bss:0000043c cardDetect
     /tmp/ccuDZzHg.s:11505  .bss:0000044d newEncoder
     /tmp/ccuDZzHg.s:11515  .bss:00000491 encoderCw
     /tmp/ccuDZzHg.s:11517  .bss:00000492 encoderCcw
     /tmp/ccuDZzHg.s:11490  .bss:00000444 currentBank
     /tmp/ccuDZzHg.s:11468  .bss:00000436 sdBank0
     /tmp/ccuDZzHg.s:11466  .bss:00000432 sdRamAddress
                             .bss:00000000 sdCardSampleRemaining
     /tmp/ccuDZzHg.s:6129   .text:000029ec DoSampler
                            *COM*:00000002 UpdateOutput
     /tmp/ccuDZzHg.s:11509  .bss:0000044f encoderValue
     /tmp/ccuDZzHg.s:11488  .bss:00000440 theMidiRecordRate
     /tmp/ccuDZzHg.s:11533  .rodata:00000000 OctaveZeroCompareMatches
     /tmp/ccuDZzHg.s:11503  .bss:0000044c keysHeld
     /tmp/ccuDZzHg.s:11507  .bss:0000044e scaledEncoderValue
     /tmp/ccuDZzHg.s:11494  .bss:00000447 currentMidiMessage.2230
     /tmp/ccuDZzHg.s:11499  .data:00000004 currentNoteOn.2231
     /tmp/ccuDZzHg.s:8054   .text:00003520 __vector_12
     /tmp/ccuDZzHg.s:11430  .bss:00000323 flipFlop.1813
     /tmp/ccuDZzHg.s:8182   .text:000035ae __vector_6
     /tmp/ccuDZzHg.s:11438  .bss:00000426 flipFlop.1819
     /tmp/ccuDZzHg.s:8312   .text:0000363e __vector_13
     /tmp/ccuDZzHg.s:11444  .bss:00000429 flipFlop.1827
     /tmp/ccuDZzHg.s:11448  .bss:0000042b lastJitterValue.1826
     /tmp/ccuDZzHg.s:8518   .text:00003768 __vector_14
     /tmp/ccuDZzHg.s:11458  .bss:0000042d flipFlop.1835
     /tmp/ccuDZzHg.s:11462  .bss:0000042f lastJitterValue.1834
     /tmp/ccuDZzHg.s:8724   .text:00003892 __vector_10
     /tmp/ccuDZzHg.s:11415  .bss:0000000e sdFifo
     /tmp/ccuDZzHg.s:9215   .text:00003c54 __vector_9
     /tmp/ccuDZzHg.s:11472  .bss:00000438 pwmCount.1847
     /tmp/ccuDZzHg.s:9272   .text:00003c8a __vector_default
     /tmp/ccuDZzHg.s:9303   .text:00003c9e HandleSoftclock
     /tmp/ccuDZzHg.s:9337   .text.startup:00000000 main
     /tmp/ccuDZzHg.s:11529  .bss:0000049d encoderState
     /tmp/ccuDZzHg.s:11547  .bss:0000049e lastKeyState.1897
     /tmp/ccuDZzHg.s:11549  .bss:0000049f lastEncTime.1906
     /tmp/ccuDZzHg.s:11551  .bss:000004a1 lastEncoderState.1905
     /tmp/ccuDZzHg.s:11553  .bss:000004a2 toggle.1883
     /tmp/ccuDZzHg.s:11555  .bss:000004a3 lastLedMask.1884
     /tmp/ccuDZzHg.s:11557  .bss:000004a4 bytesLeftInBlock.2026

UNDEFINED SYMBOLS
bankStates
__muluhisi3
__udivmodsi4
SetTimer
CheckTimer
EndSdTransfer
InitSdInterface
SdBeginSingleBlockRead
EepromRead
midiChannelNumberA
midiChannelNumberB
__udivmodqi4
EepromWrite
PutMidiMessageInOutgoingFifo
midiMessagesInIncomingFifo
GetMidiMessageFromIncomingFifo
__tablejump2__
__umulhisi3
systemTicks
InitMidi
InitUart0
SdHandshake
TransferSdByte
SdBeginSingleBlockWrite
Uart0GotByte
Uart0GetByte
HandleIncomingMidiByte
MidiTxBufferNotEmpty
PopOutgoingMidiByte
__do_copy_data
__do_clear_bss
