   1               		.file	"WTPA.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	UpdateAudioChannel0:
  12               	.LFB1:
  13               		.file 1 "WTPA.c"
   1:WTPA.c        **** // Where's the Party At?
   2:WTPA.c        **** // VERSION 2 DA EMPIRE STRIKES BLACK
   3:WTPA.c        **** // ==================================
   4:WTPA.c        **** // Todd Michael Bailey
   5:WTPA.c        **** // todd@narrat1ve.com
   6:WTPA.c        **** // Tue Jul  6 19:36:23 EDT 2010
   7:WTPA.c        **** 
   8:WTPA.c        **** #include	"includes.h"
   9:WTPA.c        **** #define		CURRENT_FIRMWARE_VERSION	0x12		// Starts at 0x10 for WTPA2.  0x11, messing around from 201
  10:WTPA.c        **** 
  11:WTPA.c        **** //=============================
  12:WTPA.c        **** // HOLLER-WARE LICENSE:
  13:WTPA.c        **** // Todd Bailey wrote this.  Do whatever you want with this code, but holler at me if you like it, u
  14:WTPA.c        **** // xoxoxo
  15:WTPA.c        **** // bai1ey.tm@gmail.com
  16:WTPA.c        **** //
  17:WTPA.c        **** // Todd Bailey would like to take this opportunity to shout out to:
  18:WTPA.c        **** //
  19:WTPA.c        **** // Todd Squires, who continues to be wholly intolerant of my bad programming habits and whose TB4 O
  20:WTPA.c        **** // Andrew Reitano for the Nintendo sample playback code,
  21:WTPA.c        **** // Olivier Gillet for the code review, some great ISR speed suggestions, harping on me about remova
  22:WTPA.c        **** // Nick Read, Daniel Fishkin, and Charlie Spears for slangin solder and et cet,
  23:WTPA.c        **** // ChaN for the awesome page on SD interfacing,
  24:WTPA.c        **** // Limor Fried and Phil Torrone, for staying on my ass about making kits,
  25:WTPA.c        **** // Glitched, Dan Nigrin, Altitude, Rodrigo, Sealion, and everybody else on the Narrat1ve forum for 
  26:WTPA.c        **** // BMT Toys and everybody there for putting me through the embedded-systems wringer for all those y
  27:WTPA.c        **** // Jim Williams, Paul Horowitz, Winfield Hill, and all the other people who've forgotten more than 
  28:WTPA.c        **** // and most importantly,
  29:WTPA.c        **** // You, the Customer.
  30:WTPA.c        **** //=============================
  31:WTPA.c        **** 
  32:WTPA.c        **** //=============================
  33:WTPA.c        **** // Atmel AVR Atmega644p MCU, 5v operation.
  34:WTPA.c        **** // 20MHz Crystal Oscillator.
  35:WTPA.c        **** // Originally built with:
  36:WTPA.c        **** // AVR-Binutils 2.19,
  37:WTPA.c        **** // AVR-GCC 4.3.2,
  38:WTPA.c        **** // AVR-libc 1.6.4
  39:WTPA.c        **** //==============================
  40:WTPA.c        **** 
  41:WTPA.c        **** /*
  42:WTPA.c        **** Description:
  43:WTPA.c        **** ==============================================================================
  44:WTPA.c        **** Just rock out, you know?
  45:WTPA.c        **** The real description for lots of this sampler is in the manuals.
  46:WTPA.c        **** 
  47:WTPA.c        **** Technical descriptions of just about everything can be found by grepping through the code comments.
  48:WTPA.c        **** It might be worth your time to check out the original WTPA code as well as the WTPA2 code.
  49:WTPA.c        **** 
  50:WTPA.c        **** 
  51:WTPA.c        **** Changelog:
  52:WTPA.c        **** ==============================================================================
  53:WTPA.c        **** ==============================================================================
  54:WTPA.c        **** Made a CHANGELOG file in this directory.  Only valid for WTPA2 changes once releases start.  You'll
  55:WTPA.c        **** 
  56:WTPA.c        **** 
  57:WTPA.c        **** Nuts / Volts:
  58:WTPA.c        **** ==============================================================================
  59:WTPA.c        **** Fuse bits:
  60:WTPA.c        **** 
  61:WTPA.c        **** EByte:  Don't change.
  62:WTPA.c        **** HByte:  0xD9	-- turn off JTAG.
  63:WTPA.c        **** LByte:  CKSEL=0111  SUT=11  CKDIV=1  CKOUT=1  so  1111 0111 or 0xF7
  64:WTPA.c        **** 
  65:WTPA.c        **** The device will then start at 20MHz.
  66:WTPA.c        **** I use:
  67:WTPA.c        **** avrdude -p m164p -c stk500v2 -u -t
  68:WTPA.c        **** r lfuse (should be 62)
  69:WTPA.c        **** w lfuse 0 0xF7
  70:WTPA.c        **** r hfuse (99 is default)
  71:WTPA.c        **** w hfuse 0 0xD9
  72:WTPA.c        **** 
  73:WTPA.c        **** Thu Apr 16 03:13:24 CDT 2009
  74:WTPA.c        **** Ebyte contains the brownout fuse bits.  We want that in this app, so change Ebyte to 0xFC.
  75:WTPA.c        **** 
  76:WTPA.c        **** Command line:
  77:WTPA.c        **** avrdude -p m164p -c stk500v2 -u -U efuse:w:0xFC:m -U hfuse:w:0xD9:m -U lfuse:w:0xF7:m
  78:WTPA.c        **** */
  79:WTPA.c        **** 
  80:WTPA.c        **** 
  81:WTPA.c        **** // I hate Prototypes:
  82:WTPA.c        **** static void DoFruitcakeIntro(void);
  83:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  84:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  85:WTPA.c        **** //static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot);
  86:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot);
  87:WTPA.c        **** static void InitSdIsr(void);
  88:WTPA.c        **** 
  89:WTPA.c        **** //-----------------------------------------------------------------------
  90:WTPA.c        **** //-----------------------------------------------------------------------
  91:WTPA.c        **** // Lists:
  92:WTPA.c        **** //-----------------------------------------------------------------------
  93:WTPA.c        **** //-----------------------------------------------------------------------
  94:WTPA.c        **** 
  95:WTPA.c        **** // Audio ISR States -- these are the different things we can do in the audio related ISR.
  96:WTPA.c        **** //---------------------------------------------------------------------------------------
  97:WTPA.c        **** 
  98:WTPA.c        **** enum
  99:WTPA.c        **** 	{
 100:WTPA.c        **** 		AUDIO_IDLE=0,
 101:WTPA.c        **** 		AUDIO_SAWTOOTH,
 102:WTPA.c        **** 		AUDIO_REALTIME,
 103:WTPA.c        **** 		AUDIO_RECORD,
 104:WTPA.c        **** 		AUDIO_PLAYBACK,
 105:WTPA.c        **** 		AUDIO_OVERDUB,
 106:WTPA.c        **** 		NUM_AUDIO_FUNCTIONS,
 107:WTPA.c        **** 	};
 108:WTPA.c        **** 
 109:WTPA.c        **** 
 110:WTPA.c        **** // LEDs.
 111:WTPA.c        **** //-----------------------------------------------------------------------
 112:WTPA.c        **** enum					// LED enum used for keeping track of our LED masks.
 113:WTPA.c        **** 	{
 114:WTPA.c        **** 		LED_0=0,
 115:WTPA.c        **** 		LED_1,
 116:WTPA.c        **** 		LED_2,
 117:WTPA.c        **** 		LED_3,
 118:WTPA.c        **** 		LED_4,
 119:WTPA.c        **** 		LED_5,
 120:WTPA.c        **** 		LED_6,
 121:WTPA.c        **** 		LED_7,
 122:WTPA.c        **** 		NUM_LEDS,
 123:WTPA.c        **** 	};
 124:WTPA.c        **** 
 125:WTPA.c        **** // WTPA has gotten to the point where each LED pretty much corresponds to an indicator of something
 126:WTPA.c        **** // To reflect this, the masks here arrange LEDs by FUNCTION, to make code easier to read.
 127:WTPA.c        **** 
 128:WTPA.c        **** #define	Om_LED_REC			(1<<LED_0)
 129:WTPA.c        **** #define	Om_LED_ODUB			(1<<LED_1)
 130:WTPA.c        **** #define	Om_LED_PLAY			(1<<LED_2)
 131:WTPA.c        **** #define	Om_LED_OUT_OF_MEM	(1<<LED_3)	// @@@ lose this guy.
 132:WTPA.c        **** #define	Om_LED_BANK			(1<<LED_4)
 133:WTPA.c        **** #define	Om_LED_FX2			(1<<LED_5)
 134:WTPA.c        **** #define	Om_LED_FX1			(1<<LED_6)
 135:WTPA.c        **** #define	Om_LED_FX0			(1<<LED_7)
 136:WTPA.c        **** 
 137:WTPA.c        **** static unsigned char
 138:WTPA.c        **** 	ledOnOffMask,		// What leds are on and off now?
 139:WTPA.c        **** 	ledBlinkMask;		// What leds are blinking right now?
 140:WTPA.c        **** 
 141:WTPA.c        **** static volatile unsigned char
 142:WTPA.c        **** 	ledPwm;				// Used for our benighted intro.
 143:WTPA.c        **** 
 144:WTPA.c        **** //-----------------------------------------------------------------------
 145:WTPA.c        **** //-----------------------------------------------------------------------
 146:WTPA.c        **** // Application Globals:
 147:WTPA.c        **** //-----------------------------------------------------------------------
 148:WTPA.c        **** //-----------------------------------------------------------------------
 149:WTPA.c        **** 
 150:WTPA.c        **** // Keys and switch variables
 151:WTPA.c        **** //-----------------------------------------------------------------------
 152:WTPA.c        **** static unsigned char
 153:WTPA.c        **** 	keyState,
 154:WTPA.c        **** 	newKeys,
 155:WTPA.c        **** 	keysHeld;
 156:WTPA.c        **** 
 157:WTPA.c        **** static bool
 158:WTPA.c        **** 	cardDetect;		// Is SD card physically in the slot?
 159:WTPA.c        **** 
 160:WTPA.c        **** // Application flags and housekeeping.
 161:WTPA.c        **** //-----------------------------------------------------------------------
 162:WTPA.c        **** STATE_FUNC				//  Creates a pointer called State to an instance of STATE_FUNC().
 163:WTPA.c        **** 	*State;
 164:WTPA.c        **** static unsigned char
 165:WTPA.c        **** 	subState;			//  Keeps track of the minor states (sub states) the device can be in.
 166:WTPA.c        **** 
 167:WTPA.c        **** static volatile bool
 168:WTPA.c        **** 	outOfRam;				// Goes true in the ISR if we run out of RAM.
 169:WTPA.c        **** 
 170:WTPA.c        **** static unsigned char
 171:WTPA.c        **** 	encoderState,			// What the encoder switches look like.
 172:WTPA.c        **** 	encoderValue,			// Incremental ticks on the encoder.
 173:WTPA.c        **** 	scaledEncoderValue;		// The number that we display on the LEDs and use to select different effects
 174:WTPA.c        **** 
 175:WTPA.c        **** // Granular stuff
 176:WTPA.c        **** //-----------------------------------------------------------------------
 177:WTPA.c        **** 
 178:WTPA.c        **** #define	JITTER_VALUE_MAX	127
 179:WTPA.c        **** #define MAX_SLICES			128
 180:WTPA.c        **** 
 181:WTPA.c        **** static unsigned long
 182:WTPA.c        **** //	random31 __attribute__((section(".noinit")));	//32 bit random number, seeded from noinit sram (s
 183:WTPA.c        **** 	random31=0xBEEF;								// No chance to come up zero because we threw out init code.
 184:WTPA.c        **** 
 185:WTPA.c        **** static volatile unsigned char
 186:WTPA.c        **** 	granularPositionArrayPointer[NUM_BANKS];	// Where are we in the array right now?
 187:WTPA.c        **** 
 188:WTPA.c        **** static volatile unsigned long
 189:WTPA.c        **** 	sliceSize[NUM_BANKS],						// How big are our slices of memory?
 190:WTPA.c        **** 	sliceRemaining[NUM_BANKS];					// How far are we into our slice of memory?
 191:WTPA.c        **** 
 192:WTPA.c        **** static unsigned char
 193:WTPA.c        **** 	granularPositionArray[NUM_BANKS][MAX_SLICES];
 194:WTPA.c        **** 
 195:WTPA.c        **** enum	// Flags we use to determine what to set our clock source to when setting up an audio interrup
 196:WTPA.c        **** {
 197:WTPA.c        **** 	CLK_NONE=0,
 198:WTPA.c        **** 	CLK_EXTERNAL,
 199:WTPA.c        **** 	CLK_INTERNAL,
 200:WTPA.c        **** };
 201:WTPA.c        **** 
 202:WTPA.c        **** 
 203:WTPA.c        **** // ADC globals:
 204:WTPA.c        **** //-----------------------------------------------------------------------
 205:WTPA.c        **** static volatile signed char
 206:WTPA.c        **** 	adcByte;			// The current reading from the ADC.
 207:WTPA.c        **** 
 208:WTPA.c        **** // SD Card Globals:
 209:WTPA.c        **** //-----------------------------------------------------------------------
 210:WTPA.c        **** 
 211:WTPA.c        **** #define SD_WARMUP_TIME							(SECOND)		// SPEC is 250mS but why not be safe.
 212:WTPA.c        **** #define	SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER		(64)			// We leave our SD card open while reading bloc
 213:WTPA.c        **** #define	SD_FIFO_SIZE							(SD_BLOCK_LENGTH+(SD_BLOCK_LENGTH/2))	// AVR's RAM fifo for reads and wr
 214:WTPA.c        **** 
 215:WTPA.c        **** static unsigned char
 216:WTPA.c        **** 	cardState;					// Keeps track of what's going on with the SD Card -- reading, writing, not present
 217:WTPA.c        **** static unsigned char
 218:WTPA.c        **** 	sampleToc[64];				// Local RAM copy of the card's table of contents (where the samples are stored)
 219:WTPA.c        **** static volatile signed char
 220:WTPA.c        **** 	sdFifo[SD_FIFO_SIZE];		// Rolling buffer for getting bytes in and out of the SD card with the stat
 221:WTPA.c        **** 
 222:WTPA.c        **** static volatile unsigned int		// FIFO pointers for the SD card read/write buffer.
 223:WTPA.c        **** 	sdFifoReadPointer,
 224:WTPA.c        **** 	sdFifoWritePointer,
 225:WTPA.c        **** 	sdBytesInFifo;
 226:WTPA.c        **** 
 227:WTPA.c        **** // The below are variables used by the SD state machine and functions:
 228:WTPA.c        **** //static unsigned char
 229:WTPA.c        **** //	sdQueuedBank;		// Bank to play pending stream from SD card on
 230:WTPA.c        **** static unsigned int
 231:WTPA.c        **** 	sdQueuedSlot;		// Pending sample to play once the current stream is closed
 232:WTPA.c        **** static bool
 233:WTPA.c        **** 	sdPlaybackQueued,	// Is there a playback we need to immediately start once the current SD abort fi
 234:WTPA.c        **** 	sdAbortRead;		// Should the SD state machine abort a read in progress?
 235:WTPA.c        **** 
 236:WTPA.c        **** static unsigned long
 237:WTPA.c        **** 	sdSampleStartBlock;
 238:WTPA.c        **** static volatile unsigned long
 239:WTPA.c        **** 	sdRamSampleRemaining,		// Decrements as we write/read samples to/from RAM until we're done.
 240:WTPA.c        **** 	sdCardSampleRemaining;		// Decrements as we write/read samples to/from the sd card until we're don
 241:WTPA.c        **** 
 242:WTPA.c        **** static unsigned int
 243:WTPA.c        **** 	sdCurrentSlot,
 244:WTPA.c        **** 	sdCurrentBlockOffset;
 245:WTPA.c        **** 
 246:WTPA.c        **** enum					// All the things the micro sd card state machine can be doing
 247:WTPA.c        **** 	{
 248:WTPA.c        **** 		SD_NOT_PRESENT=0,
 249:WTPA.c        **** 		SD_WARMUP,
 250:WTPA.c        **** 		SD_WRITE_START,
 251:WTPA.c        **** 		SD_WRITING_BLOCK,
 252:WTPA.c        **** 		SD_WRITE_CARD_WAIT,
 253:WTPA.c        **** 		SD_WRITE_FIFO_WAIT,
 254:WTPA.c        **** 		SD_TOC_WRITE_START,
 255:WTPA.c        **** 		SD_TOC_WRITE_CONTINUE,
 256:WTPA.c        **** 		SD_TOC_WRITE_FINISH,
 257:WTPA.c        **** 		SD_READ_START,
 258:WTPA.c        **** 		SD_READING_BLOCK,
 259:WTPA.c        **** 		SD_READ_FIFO_WAIT,
 260:WTPA.c        **** 		SD_READ_TOKEN_WAIT,
 261:WTPA.c        **** 		SD_READ_ABORT,
 262:WTPA.c        **** 		SD_IDLE,
 263:WTPA.c        **** 		SD_INVALID,
 264:WTPA.c        **** 	};
 265:WTPA.c        **** 
 266:WTPA.c        **** // Variables which handle the SD card's ISR.  These generally keep track of the on-chip buffer for 
 267:WTPA.c        **** 
 268:WTPA.c        **** static unsigned char
 269:WTPA.c        **** 	sdIsrState;					// Keeps track of what the IRQ that deals with data coming off / going to the SD c
 270:WTPA.c        **** static unsigned long
 271:WTPA.c        **** 	sdRamAddress;				// Used to point to the spot in RAM where the data from the sd card is coming or 
 272:WTPA.c        **** static bool
 273:WTPA.c        **** 	sdBank0;					// Tells us whether the SD buffer is messing with the RAM in sample bank 0 or 1.
 274:WTPA.c        **** 
 275:WTPA.c        **** enum					// All the things the micro sd card's interrupt can be doing
 276:WTPA.c        **** 	{
 277:WTPA.c        **** 		SD_ISR_IDLE=0,
 278:WTPA.c        **** 		SD_ISR_LOADING_RAM,
 279:WTPA.c        **** 		SD_ISR_READING_RAM,
 280:WTPA.c        **** 		SD_ISR_STREAMING_PLAYBACK,
 281:WTPA.c        **** 	};
 282:WTPA.c        **** 
 283:WTPA.c        **** //-----------------------------------------------------------------------
 284:WTPA.c        **** 
 285:WTPA.c        **** 
 286:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 287:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 288:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 289:WTPA.c        **** // Da Code:
 290:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 291:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 292:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 293:WTPA.c        **** 
 294:WTPA.c        **** //-----------------------------------------------------------------------
 295:WTPA.c        **** //-----------------------------------------------------------------------
 296:WTPA.c        **** 
 297:WTPA.c        **** // Sun Sep 19 13:38:34 EDT 2010
 298:WTPA.c        **** // Audio Channel Update Code for each bank:
 299:WTPA.c        **** 
 300:WTPA.c        **** //-----------------------------------------------------------------------
 301:WTPA.c        **** //-----------------------------------------------------------------------
 302:WTPA.c        **** // This is where all the audio business happens in this program.
 303:WTPA.c        **** // Variables messed with in the ISRs AND mainline code should be declared volatile.
 304:WTPA.c        **** // The functions declared up here should _ONLY_ ever be called from an interrupt.
 305:WTPA.c        **** 
 306:WTPA.c        **** static unsigned char UpdateAudioChannel0(void)
 307:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 308:WTPA.c        **** // These channel update routines basically handle getting data into or out of RAM based on what the
 309:WTPA.c        **** // Each channel may write something to RAM, and will pass out a byte based on what (if anything) it
 310:WTPA.c        **** {
  14               		.loc 1 310 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
 311:WTPA.c        **** 	signed int
 312:WTPA.c        **** 		sum;			// For doing saturated adds.
 313:WTPA.c        **** 	signed char
 314:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 315:WTPA.c        **** 	static unsigned char
 316:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 317:WTPA.c        **** 
 318:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 319:WTPA.c        **** 
 320:WTPA.c        **** 	switch(bankStates[BANK_0].audioFunction)
  21               		.loc 1 320 0
  22 0000 8091 0000 		lds r24,bankStates
  23 0004 8330      		cpi r24,lo8(3)
  24 0006 01F0      		breq .L5
  25 0008 00F4      		brsh .L8
  26 000a 8130      		cpi r24,lo8(1)
  27 000c 01F0      		breq .L3
  28 000e 8230      		cpi r24,lo8(2)
  29 0010 01F0      		breq .+2
  30 0012 00C0      		rjmp .L35
  31 0014 00C0      		rjmp .L4
  32               	.L8:
  33 0016 8430      		cpi r24,lo8(4)
  34 0018 01F4      		brne .+2
  35 001a 00C0      		rjmp .L6
  36 001c 8530      		cpi r24,lo8(5)
  37 001e 01F0      		breq .+2
  38 0020 00C0      		rjmp .L35
  39 0022 00C0      		rjmp .L7
  40               	.L3:
 321:WTPA.c        **** 	{
 322:WTPA.c        **** 
 323:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 324:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 325:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
  41               		.loc 1 325 0
  42 0024 8091 0000 		lds r24,sawtooth.1751
  43               	.LVL1:
  44 0028 982F      		mov r25,r24
  45 002a 9F5F      		subi r25,lo8(-(1))
  46 002c 9093 0000 		sts sawtooth.1751,r25
 326:WTPA.c        **** 		break;
  47               		.loc 1 326 0
  48 0030 0895      		ret
  49               	.LVL2:
  50               	.L4:
 327:WTPA.c        **** 
 328:WTPA.c        **** 		case AUDIO_REALTIME:
 329:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 330:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
  51               		.loc 1 330 0
  52 0032 8091 0000 		lds r24,adcByte
  53               	.LVL3:
  54 0036 00C0      		rjmp .L51
  55               	.LVL4:
  56               	.L5:
 331:WTPA.c        **** 
 332:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 333:WTPA.c        **** 		{
 334:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 335:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 336:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 337:WTPA.c        **** 		}
 338:WTPA.c        **** 		break;
 339:WTPA.c        **** 
 340:WTPA.c        **** 		case AUDIO_RECORD:
 341:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 342:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
  57               		.loc 1 342 0
  58 0038 8FEF      		ldi r24,lo8(-1)
  59 003a 84B9      		out 0x4,r24
 343:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
  60               		.loc 1 343 0
  61 003c 8091 0000 		lds r24,bankStates+31
  62 0040 9091 0000 		lds r25,bankStates+31+1
  63 0044 A091 0000 		lds r26,bankStates+31+2
  64 0048 B091 0000 		lds r27,bankStates+31+3
  65 004c 85B9      		out 0x5,r24
 344:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
  66               		.loc 1 344 0
  67 004e 139A      		sbi 0x2,3
 345:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
  68               		.loc 1 345 0
  69 0050 1398      		cbi 0x2,3
 346:WTPA.c        **** 
 347:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
  70               		.loc 1 347 0
  71 0052 8091 0000 		lds r24,bankStates+31
  72 0056 9091 0000 		lds r25,bankStates+31+1
  73 005a A091 0000 		lds r26,bankStates+31+2
  74 005e B091 0000 		lds r27,bankStates+31+3
  75 0062 892F      		mov r24,r25
  76 0064 9A2F      		mov r25,r26
  77 0066 AB2F      		mov r26,r27
  78 0068 BB27      		clr r27
  79 006a 85B9      		out 0x5,r24
 348:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
  80               		.loc 1 348 0
  81 006c 149A      		sbi 0x2,4
 349:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
  82               		.loc 1 349 0
  83 006e 1498      		cbi 0x2,4
 350:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
  84               		.loc 1 350 0
  85 0070 8091 0000 		lds r24,bankStates+31
  86 0074 9091 0000 		lds r25,bankStates+31+1
  87 0078 A091 0000 		lds r26,bankStates+31+2
  88 007c B091 0000 		lds r27,bankStates+31+3
  89 0080 CD01      		movw r24,r26
  90 0082 AA27      		clr r26
  91 0084 BB27      		clr r27
  92 0086 8770      		andi r24,7
  93 0088 9927      		clr r25
  94 008a AA27      		clr r26
  95 008c BB27      		clr r27
  96 008e 8868      		ori r24,136
  97 0090 88B9      		out 0x8,r24
 351:WTPA.c        **** 
 352:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
  98               		.loc 1 352 0
  99 0092 8091 0000 		lds r24,adcByte
 100 0096 85B9      		out 0x5,r24
 353:WTPA.c        **** 		// Compute address while bus settles.
 354:WTPA.c        **** 
 355:WTPA.c        **** 		bankStates[BANK_0].currentAddress++;										// Next address please.
 101               		.loc 1 355 0
 102 0098 8091 0000 		lds r24,bankStates+31
 103 009c 9091 0000 		lds r25,bankStates+31+1
 104 00a0 A091 0000 		lds r26,bankStates+31+2
 105 00a4 B091 0000 		lds r27,bankStates+31+3
 106 00a8 0196      		adiw r24,1
 107 00aa A11D      		adc r26,__zero_reg__
 108 00ac B11D      		adc r27,__zero_reg__
 109 00ae 8093 0000 		sts bankStates+31,r24
 110 00b2 9093 0000 		sts bankStates+31+1,r25
 111 00b6 A093 0000 		sts bankStates+31+2,r26
 112 00ba B093 0000 		sts bankStates+31+3,r27
 356:WTPA.c        **** 		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the
 113               		.loc 1 356 0
 114 00be 8091 0000 		lds r24,bankStates+31
 115 00c2 9091 0000 		lds r25,bankStates+31+1
 116 00c6 A091 0000 		lds r26,bankStates+31+2
 117 00ca B091 0000 		lds r27,bankStates+31+3
 118 00ce 8093 0000 		sts bankStates+12,r24
 119 00d2 9093 0000 		sts bankStates+12+1,r25
 120 00d6 A093 0000 		sts bankStates+12+2,r26
 121 00da B093 0000 		sts bankStates+12+3,r27
 357:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address 
 122               		.loc 1 357 0
 123 00de 8091 0000 		lds r24,bankStates+31
 124 00e2 9091 0000 		lds r25,bankStates+31+1
 125 00e6 A091 0000 		lds r26,bankStates+31+2
 126 00ea B091 0000 		lds r27,bankStates+31+3
 127 00ee 8093 0000 		sts bankStates+20,r24
 128 00f2 9093 0000 		sts bankStates+20+1,r25
 129 00f6 A093 0000 		sts bankStates+20+2,r26
 130 00fa B093 0000 		sts bankStates+20+3,r27
 358:WTPA.c        **** 
 359:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 131               		.loc 1 359 0
 132 00fe 4091 0000 		lds r20,bankStates+12
 133 0102 5091 0000 		lds r21,bankStates+12+1
 134 0106 6091 0000 		lds r22,bankStates+12+2
 135 010a 7091 0000 		lds r23,bankStates+12+3
 136 010e 8091 0000 		lds r24,bankStates+47
 137 0112 9091 0000 		lds r25,bankStates+47+1
 138 0116 A091 0000 		lds r26,bankStates+47+2
 139 011a B091 0000 		lds r27,bankStates+47+3
 140 011e 4817      		cp r20,r24
 141 0120 5907      		cpc r21,r25
 142 0122 6A07      		cpc r22,r26
 143 0124 7B07      		cpc r23,r27
 144 0126 00F0      		brlo .L9
 360:WTPA.c        **** 		{
 361:WTPA.c        **** 			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 145               		.loc 1 361 0
 146 0128 1092 0000 		sts bankStates,__zero_reg__
 362:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 147               		.loc 1 362 0
 148 012c 81E0      		ldi r24,lo8(1)
 149 012e 8093 0000 		sts outOfRam,r24
 150               	.L9:
 363:WTPA.c        **** 		}
 364:WTPA.c        **** 
 365:WTPA.c        **** 		// Finish writing to RAM.
 366:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 151               		.loc 1 366 0
 152 0132 1198      		cbi 0x2,1
 367:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 153               		.loc 1 367 0
 154 0134 119A      		sbi 0x2,1
 155 0136 00C0      		rjmp .L35
 156               	.L6:
 368:WTPA.c        **** 		break;
 369:WTPA.c        **** 
 370:WTPA.c        **** 		case AUDIO_PLAYBACK:
 371:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 372:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 373:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 374:WTPA.c        **** 
 375:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 376:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 157               		.loc 1 376 0
 158 0138 8091 0000 		lds r24,bankStates+31
 159 013c 9091 0000 		lds r25,bankStates+31+1
 160 0140 A091 0000 		lds r26,bankStates+31+2
 161 0144 B091 0000 		lds r27,bankStates+31+3
 162 0148 85B9      		out 0x5,r24
 377:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 163               		.loc 1 377 0
 164 014a 139A      		sbi 0x2,3
 378:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 165               		.loc 1 378 0
 166 014c 1398      		cbi 0x2,3
 379:WTPA.c        **** 
 380:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 167               		.loc 1 380 0
 168 014e 8091 0000 		lds r24,bankStates+31
 169 0152 9091 0000 		lds r25,bankStates+31+1
 170 0156 A091 0000 		lds r26,bankStates+31+2
 171 015a B091 0000 		lds r27,bankStates+31+3
 172 015e 892F      		mov r24,r25
 173 0160 9A2F      		mov r25,r26
 174 0162 AB2F      		mov r26,r27
 175 0164 BB27      		clr r27
 176 0166 85B9      		out 0x5,r24
 381:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 177               		.loc 1 381 0
 178 0168 149A      		sbi 0x2,4
 382:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 179               		.loc 1 382 0
 180 016a 1498      		cbi 0x2,4
 383:WTPA.c        **** 
 384:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 181               		.loc 1 384 0
 182 016c 8091 0000 		lds r24,bankStates+31
 183 0170 9091 0000 		lds r25,bankStates+31+1
 184 0174 A091 0000 		lds r26,bankStates+31+2
 185 0178 B091 0000 		lds r27,bankStates+31+3
 186 017c CD01      		movw r24,r26
 187 017e AA27      		clr r26
 188 0180 BB27      		clr r27
 189 0182 8770      		andi r24,7
 190 0184 9927      		clr r25
 191 0186 AA27      		clr r26
 192 0188 BB27      		clr r27
 193 018a 8868      		ori r24,136
 194 018c 88B9      		out 0x8,r24
 385:WTPA.c        **** 
 386:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 195               		.loc 1 386 0
 196 018e 14B8      		out 0x4,__zero_reg__
 387:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 197               		.loc 1 387 0
 198 0190 1298      		cbi 0x2,2
 388:WTPA.c        **** 
 389:WTPA.c        **** 		// Calculate new addy while data bus settles
 390:WTPA.c        **** 
 391:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 199               		.loc 1 391 0
 200 0192 8091 0000 		lds r24,bankStates+6
 201 0196 8823      		tst r24
 202 0198 01F4      		brne .+2
 203 019a 00C0      		rjmp .L10
 392:WTPA.c        **** 		{
 393:WTPA.c        **** 			// Slice first, only worry about forward ###
 394:WTPA.c        **** 
 395:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 204               		.loc 1 395 0
 205 019c 8091 0000 		lds r24,sliceRemaining
 206 01a0 9091 0000 		lds r25,sliceRemaining+1
 207 01a4 A091 0000 		lds r26,sliceRemaining+2
 208 01a8 B091 0000 		lds r27,sliceRemaining+3
 209 01ac 892B      		or r24,r25
 210 01ae 8A2B      		or r24,r26
 211 01b0 8B2B      		or r24,r27
 212 01b2 01F0      		breq .L11
 396:WTPA.c        **** 			{
 397:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 213               		.loc 1 397 0
 214 01b4 8091 0000 		lds r24,bankStates+31
 215 01b8 9091 0000 		lds r25,bankStates+31+1
 216 01bc A091 0000 		lds r26,bankStates+31+2
 217 01c0 B091 0000 		lds r27,bankStates+31+3
 218 01c4 0196      		adiw r24,1
 219 01c6 A11D      		adc r26,__zero_reg__
 220 01c8 B11D      		adc r27,__zero_reg__
 221 01ca 8093 0000 		sts bankStates+31,r24
 222 01ce 9093 0000 		sts bankStates+31+1,r25
 223 01d2 A093 0000 		sts bankStates+31+2,r26
 224 01d6 B093 0000 		sts bankStates+31+3,r27
 398:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 225               		.loc 1 398 0
 226 01da 8091 0000 		lds r24,sliceRemaining
 227 01de 9091 0000 		lds r25,sliceRemaining+1
 228 01e2 A091 0000 		lds r26,sliceRemaining+2
 229 01e6 B091 0000 		lds r27,sliceRemaining+3
 230 01ea 0197      		sbiw r24,1
 231 01ec A109      		sbc r26,__zero_reg__
 232 01ee B109      		sbc r27,__zero_reg__
 233 01f0 8093 0000 		sts sliceRemaining,r24
 234 01f4 9093 0000 		sts sliceRemaining+1,r25
 235 01f8 A093 0000 		sts sliceRemaining+2,r26
 236 01fc B093 0000 		sts sliceRemaining+3,r27
 237 0200 00C0      		rjmp .L12
 238               	.L11:
 399:WTPA.c        **** 			}
 400:WTPA.c        **** 			else	// Slice done, jump to new slice.
 401:WTPA.c        **** 			{
 402:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 239               		.loc 1 402 0
 240 0202 8091 0000 		lds r24,sliceSize
 241 0206 9091 0000 		lds r25,sliceSize+1
 242 020a A091 0000 		lds r26,sliceSize+2
 243 020e B091 0000 		lds r27,sliceSize+3
 244 0212 8093 0000 		sts sliceRemaining,r24
 245 0216 9093 0000 		sts sliceRemaining+1,r25
 246 021a A093 0000 		sts sliceRemaining+2,r26
 247 021e B093 0000 		sts sliceRemaining+3,r27
 403:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 248               		.loc 1 403 0
 249 0222 8091 0000 		lds r24,granularPositionArrayPointer
 250 0226 8F5F      		subi r24,lo8(-(1))
 251 0228 8093 0000 		sts granularPositionArrayPointer,r24
 404:WTPA.c        **** 
 405:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 252               		.loc 1 405 0
 253 022c 9091 0000 		lds r25,granularPositionArrayPointer
 254 0230 8091 0000 		lds r24,bankStates+6
 255 0234 9813      		cpse r25,r24
 256 0236 00C0      		rjmp .L13
 406:WTPA.c        **** 				{
 407:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 257               		.loc 1 407 0
 258 0238 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 259               	.L13:
 408:WTPA.c        **** 				}
 409:WTPA.c        **** 
 410:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 260               		.loc 1 410 0
 261 023c E091 0000 		lds r30,granularPositionArrayPointer
 262 0240 2091 0000 		lds r18,sliceSize
 263 0244 3091 0000 		lds r19,sliceSize+1
 264 0248 4091 0000 		lds r20,sliceSize+2
 265 024c 5091 0000 		lds r21,sliceSize+3
 266 0250 F0E0      		ldi r31,0
 267 0252 E050      		subi r30,lo8(-(granularPositionArray))
 268 0254 F040      		sbci r31,hi8(-(granularPositionArray))
 269 0256 A081      		ld r26,Z
 270 0258 B0E0      		ldi r27,0
 271 025a 0E94 0000 		call __muluhisi3
 272 025e 6093 0000 		sts bankStates+31,r22
 273 0262 7093 0000 		sts bankStates+31+1,r23
 274 0266 8093 0000 		sts bankStates+31+2,r24
 275 026a 9093 0000 		sts bankStates+31+3,r25
 276 026e 00C0      		rjmp .L12
 277               	.L10:
 411:WTPA.c        **** 			}
 412:WTPA.c        **** 		}
 413:WTPA.c        **** 		else
 414:WTPA.c        **** 		{
 415:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 278               		.loc 1 415 0
 279 0270 8091 0000 		lds r24,bankStates+4
 416:WTPA.c        **** 			{
 417:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 280               		.loc 1 417 0
 281 0274 4091 0000 		lds r20,bankStates+31
 282 0278 5091 0000 		lds r21,bankStates+31+1
 283 027c 6091 0000 		lds r22,bankStates+31+2
 284 0280 7091 0000 		lds r23,bankStates+31+3
 415:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 285               		.loc 1 415 0
 286 0284 8111      		cpse r24,__zero_reg__
 287 0286 00C0      		rjmp .L14
 288               		.loc 1 417 0
 289 0288 8091 0000 		lds r24,bankStates+24
 290 028c 9091 0000 		lds r25,bankStates+24+1
 291 0290 A091 0000 		lds r26,bankStates+24+2
 292 0294 B091 0000 		lds r27,bankStates+24+3
 293 0298 4817      		cp r20,r24
 294 029a 5907      		cpc r21,r25
 295 029c 6A07      		cpc r22,r26
 296 029e 7B07      		cpc r23,r27
 297 02a0 01F4      		brne .L15
 298               		.loc 1 417 0 is_stmt 0 discriminator 1
 299 02a2 8091 0000 		lds r24,bankStates+1
 300 02a6 8130      		cpi r24,lo8(1)
 301 02a8 01F4      		brne .L15
 302 02aa 00C0      		rjmp .L45
 303               	.L15:
 418:WTPA.c        **** 				{
 419:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 420:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 421:WTPA.c        **** 				}
 422:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 304               		.loc 1 422 0 is_stmt 1
 305 02ac 4091 0000 		lds r20,bankStates+31
 306 02b0 5091 0000 		lds r21,bankStates+31+1
 307 02b4 6091 0000 		lds r22,bankStates+31+2
 308 02b8 7091 0000 		lds r23,bankStates+31+3
 309 02bc 8091 0000 		lds r24,bankStates+24
 310 02c0 9091 0000 		lds r25,bankStates+24+1
 311 02c4 A091 0000 		lds r26,bankStates+24+2
 312 02c8 B091 0000 		lds r27,bankStates+24+3
 313 02cc 4817      		cp r20,r24
 314 02ce 5907      		cpc r21,r25
 315 02d0 6A07      		cpc r22,r26
 316 02d2 7B07      		cpc r23,r27
 317 02d4 01F4      		brne .L16
 423:WTPA.c        **** 				{
 424:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 318               		.loc 1 424 0
 319 02d6 8091 0000 		lds r24,bankStates+20
 320 02da 9091 0000 		lds r25,bankStates+20+1
 321 02de A091 0000 		lds r26,bankStates+20+2
 322 02e2 B091 0000 		lds r27,bankStates+20+3
 323 02e6 00C0      		rjmp .L46
 324               	.L16:
 425:WTPA.c        **** 				}
 426:WTPA.c        **** 				else
 427:WTPA.c        **** 				{
 428:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 325               		.loc 1 428 0
 326 02e8 4091 0000 		lds r20,bankStates+31
 327 02ec 5091 0000 		lds r21,bankStates+31+1
 328 02f0 6091 0000 		lds r22,bankStates+31+2
 329 02f4 7091 0000 		lds r23,bankStates+31+3
 330 02f8 8091 0000 		lds r24,bankStates+16
 331 02fc 9091 0000 		lds r25,bankStates+16+1
 332 0300 A091 0000 		lds r26,bankStates+16+2
 333 0304 B091 0000 		lds r27,bankStates+16+3
 334 0308 4817      		cp r20,r24
 335 030a 5907      		cpc r21,r25
 336 030c 6A07      		cpc r22,r26
 337 030e 7B07      		cpc r23,r27
 338 0310 01F4      		brne .L17
 429:WTPA.c        **** 					{
 430:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 339               		.loc 1 430 0
 340 0312 8091 0000 		lds r24,bankStates+12
 341 0316 9091 0000 		lds r25,bankStates+12+1
 342 031a A091 0000 		lds r26,bankStates+12+2
 343 031e B091 0000 		lds r27,bankStates+12+3
 344 0322 00C0      		rjmp .L46
 345               	.L17:
 431:WTPA.c        **** 					}
 432:WTPA.c        **** 					else
 433:WTPA.c        **** 					{
 434:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 346               		.loc 1 434 0
 347 0324 8091 0000 		lds r24,bankStates+31
 348 0328 9091 0000 		lds r25,bankStates+31+1
 349 032c A091 0000 		lds r26,bankStates+31+2
 350 0330 B091 0000 		lds r27,bankStates+31+3
 351 0334 0197      		sbiw r24,1
 352 0336 A109      		sbc r26,__zero_reg__
 353 0338 B109      		sbc r27,__zero_reg__
 354 033a 00C0      		rjmp .L46
 355               	.L14:
 435:WTPA.c        **** 					}
 436:WTPA.c        **** 				}
 437:WTPA.c        **** 			}
 438:WTPA.c        **** 			else	// Going forward through the sample.
 439:WTPA.c        **** 			{
 440:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 356               		.loc 1 440 0
 357 033c 8091 0000 		lds r24,bankStates+20
 358 0340 9091 0000 		lds r25,bankStates+20+1
 359 0344 A091 0000 		lds r26,bankStates+20+2
 360 0348 B091 0000 		lds r27,bankStates+20+3
 361 034c 4817      		cp r20,r24
 362 034e 5907      		cpc r21,r25
 363 0350 6A07      		cpc r22,r26
 364 0352 7B07      		cpc r23,r27
 365 0354 01F4      		brne .L18
 366               		.loc 1 440 0 is_stmt 0 discriminator 1
 367 0356 8091 0000 		lds r24,bankStates+1
 368 035a 8130      		cpi r24,lo8(1)
 369 035c 01F4      		brne .L18
 370               	.L45:
 441:WTPA.c        **** 				{
 442:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 371               		.loc 1 442 0 is_stmt 1
 372 035e 1092 0000 		sts bankStates,__zero_reg__
 443:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 373               		.loc 1 443 0
 374 0362 1092 0000 		sts bankStates+9,__zero_reg__
 375 0366 00C0      		rjmp .L12
 376               	.L18:
 444:WTPA.c        **** 				}
 445:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 377               		.loc 1 445 0
 378 0368 4091 0000 		lds r20,bankStates+31
 379 036c 5091 0000 		lds r21,bankStates+31+1
 380 0370 6091 0000 		lds r22,bankStates+31+2
 381 0374 7091 0000 		lds r23,bankStates+31+3
 382 0378 8091 0000 		lds r24,bankStates+20
 383 037c 9091 0000 		lds r25,bankStates+20+1
 384 0380 A091 0000 		lds r26,bankStates+20+2
 385 0384 B091 0000 		lds r27,bankStates+20+3
 386 0388 4817      		cp r20,r24
 387 038a 5907      		cpc r21,r25
 388 038c 6A07      		cpc r22,r26
 389 038e 7B07      		cpc r23,r27
 390 0390 01F4      		brne .L19
 446:WTPA.c        **** 				{
 447:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 391               		.loc 1 447 0
 392 0392 8091 0000 		lds r24,bankStates+24
 393 0396 9091 0000 		lds r25,bankStates+24+1
 394 039a A091 0000 		lds r26,bankStates+24+2
 395 039e B091 0000 		lds r27,bankStates+24+3
 396 03a2 00C0      		rjmp .L46
 397               	.L19:
 448:WTPA.c        **** 				}
 449:WTPA.c        **** 				else
 450:WTPA.c        **** 				{
 451:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 398               		.loc 1 451 0
 399 03a4 4091 0000 		lds r20,bankStates+31
 400 03a8 5091 0000 		lds r21,bankStates+31+1
 401 03ac 6091 0000 		lds r22,bankStates+31+2
 402 03b0 7091 0000 		lds r23,bankStates+31+3
 403 03b4 8091 0000 		lds r24,bankStates+12
 404 03b8 9091 0000 		lds r25,bankStates+12+1
 405 03bc A091 0000 		lds r26,bankStates+12+2
 406 03c0 B091 0000 		lds r27,bankStates+12+3
 407 03c4 4817      		cp r20,r24
 408 03c6 5907      		cpc r21,r25
 409 03c8 6A07      		cpc r22,r26
 410 03ca 7B07      		cpc r23,r27
 411 03cc 01F4      		brne .L20
 452:WTPA.c        **** 					{
 453:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 412               		.loc 1 453 0
 413 03ce 8091 0000 		lds r24,bankStates+16
 414 03d2 9091 0000 		lds r25,bankStates+16+1
 415 03d6 A091 0000 		lds r26,bankStates+16+2
 416 03da B091 0000 		lds r27,bankStates+16+3
 417 03de 00C0      		rjmp .L46
 418               	.L20:
 454:WTPA.c        **** 					}
 455:WTPA.c        **** 					else
 456:WTPA.c        **** 					{
 457:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 419               		.loc 1 457 0
 420 03e0 8091 0000 		lds r24,bankStates+31
 421 03e4 9091 0000 		lds r25,bankStates+31+1
 422 03e8 A091 0000 		lds r26,bankStates+31+2
 423 03ec B091 0000 		lds r27,bankStates+31+3
 424 03f0 0196      		adiw r24,1
 425 03f2 A11D      		adc r26,__zero_reg__
 426 03f4 B11D      		adc r27,__zero_reg__
 427               	.L46:
 428 03f6 8093 0000 		sts bankStates+31,r24
 429 03fa 9093 0000 		sts bankStates+31+1,r25
 430 03fe A093 0000 		sts bankStates+31+2,r26
 431 0402 B093 0000 		sts bankStates+31+3,r27
 432               	.L12:
 458:WTPA.c        **** 					}
 459:WTPA.c        **** 				}
 460:WTPA.c        **** 			}
 461:WTPA.c        **** 		}
 462:WTPA.c        **** /*
 463:WTPA.c        **** // @@@ Isr speed test hooey
 464:WTPA.c        **** 		if(bankStates[BANK_0].currentAddress==daNextJump)
 465:WTPA.c        **** 		{
 466:WTPA.c        **** 			bankStates[BANK_0].currentAddress=daNextJumpPrime;
 467:WTPA.c        **** 		}
 468:WTPA.c        **** 		else
 469:WTPA.c        **** 		{
 470:WTPA.c        **** 			bankStates[BANK_0].currentAddress++;
 471:WTPA.c        **** 		}
 472:WTPA.c        **** 
 473:WTPA.c        **** 		if(bankStates[BANK_0].sampleDirection==false)
 474:WTPA.c        **** 		{
 475:WTPA.c        **** 			bankStates[BANK_0].currentAddress-=2;
 476:WTPA.c        **** 		}
 477:WTPA.c        **** 
 478:WTPA.c        **** */
 479:WTPA.c        **** 		// Finish getting the byte from RAM.
 480:WTPA.c        **** 
 481:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 433               		.loc 1 481 0
 434 0406 83B1      		in r24,0x3
 435               	.LVL5:
 482:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 436               		.loc 1 482 0
 437 0408 129A      		sbi 0x2,2
 483:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 438               		.loc 1 483 0
 439 040a 9FEF      		ldi r25,lo8(-1)
 440 040c 94B9      		out 0x4,r25
 441               	.L51:
 484:WTPA.c        **** 
 485:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 442               		.loc 1 485 0
 443 040e 9091 0000 		lds r25,bankStates+8
 444 0412 9923      		tst r25
 445 0414 01F4      		brne .+2
 446 0416 00C0      		rjmp .L2
 486:WTPA.c        **** 		{
 487:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 447               		.loc 1 487 0
 448 0418 8058      		subi r24,lo8(-(-128))
 449               	.LVL6:
 488:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 450               		.loc 1 488 0
 451 041a 9091 0000 		lds r25,bankStates+8
 452 041e 2FEF      		ldi r18,lo8(-1)
 453 0420 30E0      		ldi r19,0
 454 0422 092E      		mov r0,r25
 455 0424 00C0      		rjmp 2f
 456               		1:
 457 0426 220F      		lsl r18
 458               		2:
 459 0428 0A94      		dec r0
 460 042a 02F4      		brpl 1b
 461 042c 8223      		and r24,r18
 462               	.LVL7:
 489:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 463               		.loc 1 489 0
 464 042e 8058      		subi r24,lo8(-(-128))
 465               	.LVL8:
 466 0430 0895      		ret
 467               	.LVL9:
 468               	.L7:
 490:WTPA.c        **** 		}
 491:WTPA.c        **** 		break;
 492:WTPA.c        **** 
 493:WTPA.c        **** 		case AUDIO_OVERDUB:
 494:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 495:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 496:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 469               		.loc 1 496 0
 470 0432 8091 0000 		lds r24,bankStates+31
 471 0436 9091 0000 		lds r25,bankStates+31+1
 472 043a A091 0000 		lds r26,bankStates+31+2
 473 043e B091 0000 		lds r27,bankStates+31+3
 474 0442 85B9      		out 0x5,r24
 497:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 475               		.loc 1 497 0
 476 0444 139A      		sbi 0x2,3
 498:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 477               		.loc 1 498 0
 478 0446 1398      		cbi 0x2,3
 499:WTPA.c        **** 
 500:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 479               		.loc 1 500 0
 480 0448 8091 0000 		lds r24,bankStates+31
 481 044c 9091 0000 		lds r25,bankStates+31+1
 482 0450 A091 0000 		lds r26,bankStates+31+2
 483 0454 B091 0000 		lds r27,bankStates+31+3
 484 0458 892F      		mov r24,r25
 485 045a 9A2F      		mov r25,r26
 486 045c AB2F      		mov r26,r27
 487 045e BB27      		clr r27
 488 0460 85B9      		out 0x5,r24
 501:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 489               		.loc 1 501 0
 490 0462 149A      		sbi 0x2,4
 502:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 491               		.loc 1 502 0
 492 0464 1498      		cbi 0x2,4
 503:WTPA.c        **** 
 504:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 493               		.loc 1 504 0
 494 0466 8091 0000 		lds r24,bankStates+31
 495 046a 9091 0000 		lds r25,bankStates+31+1
 496 046e A091 0000 		lds r26,bankStates+31+2
 497 0472 B091 0000 		lds r27,bankStates+31+3
 498 0476 CD01      		movw r24,r26
 499 0478 AA27      		clr r26
 500 047a BB27      		clr r27
 501 047c 8770      		andi r24,7
 502 047e 9927      		clr r25
 503 0480 AA27      		clr r26
 504 0482 BB27      		clr r27
 505 0484 8868      		ori r24,136
 506 0486 88B9      		out 0x8,r24
 505:WTPA.c        **** 
 506:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 507               		.loc 1 506 0
 508 0488 14B8      		out 0x4,__zero_reg__
 507:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 509               		.loc 1 507 0
 510 048a 1298      		cbi 0x2,2
 508:WTPA.c        **** 
 509:WTPA.c        **** 		// Calculate new address while bus settles (were nops in here)
 510:WTPA.c        **** 
 511:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 511               		.loc 1 511 0
 512 048c 8091 0000 		lds r24,bankStates+6
 513 0490 8823      		tst r24
 514 0492 01F4      		brne .+2
 515 0494 00C0      		rjmp .L21
 512:WTPA.c        **** 		{
 513:WTPA.c        **** 			// Slice first, only worry about forward ###
 514:WTPA.c        **** 
 515:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 516               		.loc 1 515 0
 517 0496 8091 0000 		lds r24,sliceRemaining
 518 049a 9091 0000 		lds r25,sliceRemaining+1
 519 049e A091 0000 		lds r26,sliceRemaining+2
 520 04a2 B091 0000 		lds r27,sliceRemaining+3
 521 04a6 892B      		or r24,r25
 522 04a8 8A2B      		or r24,r26
 523 04aa 8B2B      		or r24,r27
 524 04ac 01F0      		breq .L22
 516:WTPA.c        **** 			{
 517:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 525               		.loc 1 517 0
 526 04ae 8091 0000 		lds r24,bankStates+31
 527 04b2 9091 0000 		lds r25,bankStates+31+1
 528 04b6 A091 0000 		lds r26,bankStates+31+2
 529 04ba B091 0000 		lds r27,bankStates+31+3
 530 04be 0196      		adiw r24,1
 531 04c0 A11D      		adc r26,__zero_reg__
 532 04c2 B11D      		adc r27,__zero_reg__
 533 04c4 8093 0000 		sts bankStates+31,r24
 534 04c8 9093 0000 		sts bankStates+31+1,r25
 535 04cc A093 0000 		sts bankStates+31+2,r26
 536 04d0 B093 0000 		sts bankStates+31+3,r27
 518:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 537               		.loc 1 518 0
 538 04d4 8091 0000 		lds r24,sliceRemaining
 539 04d8 9091 0000 		lds r25,sliceRemaining+1
 540 04dc A091 0000 		lds r26,sliceRemaining+2
 541 04e0 B091 0000 		lds r27,sliceRemaining+3
 542 04e4 0197      		sbiw r24,1
 543 04e6 A109      		sbc r26,__zero_reg__
 544 04e8 B109      		sbc r27,__zero_reg__
 545 04ea 8093 0000 		sts sliceRemaining,r24
 546 04ee 9093 0000 		sts sliceRemaining+1,r25
 547 04f2 A093 0000 		sts sliceRemaining+2,r26
 548 04f6 B093 0000 		sts sliceRemaining+3,r27
 549 04fa 00C0      		rjmp .L23
 550               	.L22:
 519:WTPA.c        **** 			}
 520:WTPA.c        **** 			else	// Slice done, jump to new slice.
 521:WTPA.c        **** 			{
 522:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 551               		.loc 1 522 0
 552 04fc 8091 0000 		lds r24,sliceSize
 553 0500 9091 0000 		lds r25,sliceSize+1
 554 0504 A091 0000 		lds r26,sliceSize+2
 555 0508 B091 0000 		lds r27,sliceSize+3
 556 050c 8093 0000 		sts sliceRemaining,r24
 557 0510 9093 0000 		sts sliceRemaining+1,r25
 558 0514 A093 0000 		sts sliceRemaining+2,r26
 559 0518 B093 0000 		sts sliceRemaining+3,r27
 523:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 560               		.loc 1 523 0
 561 051c 8091 0000 		lds r24,granularPositionArrayPointer
 562 0520 8F5F      		subi r24,lo8(-(1))
 563 0522 8093 0000 		sts granularPositionArrayPointer,r24
 524:WTPA.c        **** 
 525:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 564               		.loc 1 525 0
 565 0526 9091 0000 		lds r25,granularPositionArrayPointer
 566 052a 8091 0000 		lds r24,bankStates+6
 567 052e 9813      		cpse r25,r24
 568 0530 00C0      		rjmp .L24
 526:WTPA.c        **** 				{
 527:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 569               		.loc 1 527 0
 570 0532 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 571               	.L24:
 528:WTPA.c        **** 				}
 529:WTPA.c        **** 
 530:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 572               		.loc 1 530 0
 573 0536 E091 0000 		lds r30,granularPositionArrayPointer
 574 053a 2091 0000 		lds r18,sliceSize
 575 053e 3091 0000 		lds r19,sliceSize+1
 576 0542 4091 0000 		lds r20,sliceSize+2
 577 0546 5091 0000 		lds r21,sliceSize+3
 578 054a F0E0      		ldi r31,0
 579 054c E050      		subi r30,lo8(-(granularPositionArray))
 580 054e F040      		sbci r31,hi8(-(granularPositionArray))
 581 0550 A081      		ld r26,Z
 582 0552 B0E0      		ldi r27,0
 583 0554 0E94 0000 		call __muluhisi3
 584 0558 6093 0000 		sts bankStates+31,r22
 585 055c 7093 0000 		sts bankStates+31+1,r23
 586 0560 8093 0000 		sts bankStates+31+2,r24
 587 0564 9093 0000 		sts bankStates+31+3,r25
 588 0568 00C0      		rjmp .L23
 589               	.L21:
 531:WTPA.c        **** 			}
 532:WTPA.c        **** 		}
 533:WTPA.c        **** 		else
 534:WTPA.c        **** 		{
 535:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 590               		.loc 1 535 0
 591 056a 8091 0000 		lds r24,bankStates+4
 536:WTPA.c        **** 			{
 537:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 592               		.loc 1 537 0
 593 056e 4091 0000 		lds r20,bankStates+31
 594 0572 5091 0000 		lds r21,bankStates+31+1
 595 0576 6091 0000 		lds r22,bankStates+31+2
 596 057a 7091 0000 		lds r23,bankStates+31+3
 535:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 597               		.loc 1 535 0
 598 057e 8111      		cpse r24,__zero_reg__
 599 0580 00C0      		rjmp .L25
 600               		.loc 1 537 0
 601 0582 8091 0000 		lds r24,bankStates+24
 602 0586 9091 0000 		lds r25,bankStates+24+1
 603 058a A091 0000 		lds r26,bankStates+24+2
 604 058e B091 0000 		lds r27,bankStates+24+3
 605 0592 4817      		cp r20,r24
 606 0594 5907      		cpc r21,r25
 607 0596 6A07      		cpc r22,r26
 608 0598 7B07      		cpc r23,r27
 609 059a 01F4      		brne .L26
 610               		.loc 1 537 0 is_stmt 0 discriminator 1
 611 059c 8091 0000 		lds r24,bankStates+1
 612 05a0 8130      		cpi r24,lo8(1)
 613 05a2 01F4      		brne .L26
 614 05a4 00C0      		rjmp .L47
 615               	.L26:
 538:WTPA.c        **** 				{
 539:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 540:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 541:WTPA.c        **** 				}
 542:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 616               		.loc 1 542 0 is_stmt 1
 617 05a6 4091 0000 		lds r20,bankStates+31
 618 05aa 5091 0000 		lds r21,bankStates+31+1
 619 05ae 6091 0000 		lds r22,bankStates+31+2
 620 05b2 7091 0000 		lds r23,bankStates+31+3
 621 05b6 8091 0000 		lds r24,bankStates+24
 622 05ba 9091 0000 		lds r25,bankStates+24+1
 623 05be A091 0000 		lds r26,bankStates+24+2
 624 05c2 B091 0000 		lds r27,bankStates+24+3
 625 05c6 4817      		cp r20,r24
 626 05c8 5907      		cpc r21,r25
 627 05ca 6A07      		cpc r22,r26
 628 05cc 7B07      		cpc r23,r27
 629 05ce 01F4      		brne .L27
 543:WTPA.c        **** 				{
 544:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 630               		.loc 1 544 0
 631 05d0 8091 0000 		lds r24,bankStates+20
 632 05d4 9091 0000 		lds r25,bankStates+20+1
 633 05d8 A091 0000 		lds r26,bankStates+20+2
 634 05dc B091 0000 		lds r27,bankStates+20+3
 635 05e0 00C0      		rjmp .L48
 636               	.L27:
 545:WTPA.c        **** 				}
 546:WTPA.c        **** 				else
 547:WTPA.c        **** 				{
 548:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 637               		.loc 1 548 0
 638 05e2 4091 0000 		lds r20,bankStates+31
 639 05e6 5091 0000 		lds r21,bankStates+31+1
 640 05ea 6091 0000 		lds r22,bankStates+31+2
 641 05ee 7091 0000 		lds r23,bankStates+31+3
 642 05f2 8091 0000 		lds r24,bankStates+16
 643 05f6 9091 0000 		lds r25,bankStates+16+1
 644 05fa A091 0000 		lds r26,bankStates+16+2
 645 05fe B091 0000 		lds r27,bankStates+16+3
 646 0602 4817      		cp r20,r24
 647 0604 5907      		cpc r21,r25
 648 0606 6A07      		cpc r22,r26
 649 0608 7B07      		cpc r23,r27
 650 060a 01F4      		brne .L28
 549:WTPA.c        **** 					{
 550:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 651               		.loc 1 550 0
 652 060c 8091 0000 		lds r24,bankStates+12
 653 0610 9091 0000 		lds r25,bankStates+12+1
 654 0614 A091 0000 		lds r26,bankStates+12+2
 655 0618 B091 0000 		lds r27,bankStates+12+3
 656 061c 00C0      		rjmp .L48
 657               	.L28:
 551:WTPA.c        **** 					}
 552:WTPA.c        **** 					else
 553:WTPA.c        **** 					{
 554:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 658               		.loc 1 554 0
 659 061e 8091 0000 		lds r24,bankStates+31
 660 0622 9091 0000 		lds r25,bankStates+31+1
 661 0626 A091 0000 		lds r26,bankStates+31+2
 662 062a B091 0000 		lds r27,bankStates+31+3
 663 062e 0197      		sbiw r24,1
 664 0630 A109      		sbc r26,__zero_reg__
 665 0632 B109      		sbc r27,__zero_reg__
 666 0634 00C0      		rjmp .L48
 667               	.L25:
 555:WTPA.c        **** 					}
 556:WTPA.c        **** 				}
 557:WTPA.c        **** 			}
 558:WTPA.c        **** 			else	// Going forward through the sample.
 559:WTPA.c        **** 			{
 560:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 668               		.loc 1 560 0
 669 0636 8091 0000 		lds r24,bankStates+20
 670 063a 9091 0000 		lds r25,bankStates+20+1
 671 063e A091 0000 		lds r26,bankStates+20+2
 672 0642 B091 0000 		lds r27,bankStates+20+3
 673 0646 4817      		cp r20,r24
 674 0648 5907      		cpc r21,r25
 675 064a 6A07      		cpc r22,r26
 676 064c 7B07      		cpc r23,r27
 677 064e 01F4      		brne .L29
 678               		.loc 1 560 0 is_stmt 0 discriminator 1
 679 0650 8091 0000 		lds r24,bankStates+1
 680 0654 8130      		cpi r24,lo8(1)
 681 0656 01F4      		brne .L29
 682               	.L47:
 561:WTPA.c        **** 				{
 562:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 683               		.loc 1 562 0 is_stmt 1
 684 0658 1092 0000 		sts bankStates,__zero_reg__
 563:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 685               		.loc 1 563 0
 686 065c 1092 0000 		sts bankStates+9,__zero_reg__
 687 0660 00C0      		rjmp .L23
 688               	.L29:
 564:WTPA.c        **** 				}
 565:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 689               		.loc 1 565 0
 690 0662 4091 0000 		lds r20,bankStates+31
 691 0666 5091 0000 		lds r21,bankStates+31+1
 692 066a 6091 0000 		lds r22,bankStates+31+2
 693 066e 7091 0000 		lds r23,bankStates+31+3
 694 0672 8091 0000 		lds r24,bankStates+20
 695 0676 9091 0000 		lds r25,bankStates+20+1
 696 067a A091 0000 		lds r26,bankStates+20+2
 697 067e B091 0000 		lds r27,bankStates+20+3
 698 0682 4817      		cp r20,r24
 699 0684 5907      		cpc r21,r25
 700 0686 6A07      		cpc r22,r26
 701 0688 7B07      		cpc r23,r27
 702 068a 01F4      		brne .L30
 566:WTPA.c        **** 				{
 567:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 703               		.loc 1 567 0
 704 068c 8091 0000 		lds r24,bankStates+24
 705 0690 9091 0000 		lds r25,bankStates+24+1
 706 0694 A091 0000 		lds r26,bankStates+24+2
 707 0698 B091 0000 		lds r27,bankStates+24+3
 708 069c 00C0      		rjmp .L48
 709               	.L30:
 568:WTPA.c        **** 				}
 569:WTPA.c        **** 				else
 570:WTPA.c        **** 				{
 571:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 710               		.loc 1 571 0
 711 069e 4091 0000 		lds r20,bankStates+31
 712 06a2 5091 0000 		lds r21,bankStates+31+1
 713 06a6 6091 0000 		lds r22,bankStates+31+2
 714 06aa 7091 0000 		lds r23,bankStates+31+3
 715 06ae 8091 0000 		lds r24,bankStates+12
 716 06b2 9091 0000 		lds r25,bankStates+12+1
 717 06b6 A091 0000 		lds r26,bankStates+12+2
 718 06ba B091 0000 		lds r27,bankStates+12+3
 719 06be 4817      		cp r20,r24
 720 06c0 5907      		cpc r21,r25
 721 06c2 6A07      		cpc r22,r26
 722 06c4 7B07      		cpc r23,r27
 723 06c6 01F4      		brne .L31
 572:WTPA.c        **** 					{
 573:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 724               		.loc 1 573 0
 725 06c8 8091 0000 		lds r24,bankStates+16
 726 06cc 9091 0000 		lds r25,bankStates+16+1
 727 06d0 A091 0000 		lds r26,bankStates+16+2
 728 06d4 B091 0000 		lds r27,bankStates+16+3
 729 06d8 00C0      		rjmp .L48
 730               	.L31:
 574:WTPA.c        **** 					}
 575:WTPA.c        **** 					else
 576:WTPA.c        **** 					{
 577:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 731               		.loc 1 577 0
 732 06da 8091 0000 		lds r24,bankStates+31
 733 06de 9091 0000 		lds r25,bankStates+31+1
 734 06e2 A091 0000 		lds r26,bankStates+31+2
 735 06e6 B091 0000 		lds r27,bankStates+31+3
 736 06ea 0196      		adiw r24,1
 737 06ec A11D      		adc r26,__zero_reg__
 738 06ee B11D      		adc r27,__zero_reg__
 739               	.L48:
 740 06f0 8093 0000 		sts bankStates+31,r24
 741 06f4 9093 0000 		sts bankStates+31+1,r25
 742 06f8 A093 0000 		sts bankStates+31+2,r26
 743 06fc B093 0000 		sts bankStates+31+3,r27
 744               	.L23:
 578:WTPA.c        **** 					}
 579:WTPA.c        **** 				}
 580:WTPA.c        **** 			}
 581:WTPA.c        **** 		}
 582:WTPA.c        **** 
 583:WTPA.c        **** 		// Finished calculating address, bus should be settled, so finish the exchange with RAM
 584:WTPA.c        **** 
 585:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 745               		.loc 1 585 0
 746 0700 83B1      		in r24,0x3
 747               	.LVL10:
 586:WTPA.c        **** 
 587:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 748               		.loc 1 587 0
 749 0702 129A      		sbi 0x2,2
 588:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 750               		.loc 1 588 0
 751 0704 9FEF      		ldi r25,lo8(-1)
 752 0706 94B9      		out 0x4,r25
 589:WTPA.c        **** 
 590:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 753               		.loc 1 590 0
 754 0708 9091 0000 		lds r25,bankStates+8
 755 070c 9923      		tst r25
 756 070e 01F0      		breq .L32
 591:WTPA.c        **** 		{
 592:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 757               		.loc 1 592 0
 758 0710 8058      		subi r24,lo8(-(-128))
 759               	.LVL11:
 593:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 760               		.loc 1 593 0
 761 0712 9091 0000 		lds r25,bankStates+8
 762 0716 2FEF      		ldi r18,lo8(-1)
 763 0718 30E0      		ldi r19,0
 764 071a 092E      		mov r0,r25
 765 071c 00C0      		rjmp 2f
 766               		1:
 767 071e 220F      		lsl r18
 768               		2:
 769 0720 0A94      		dec r0
 770 0722 02F4      		brpl 1b
 771 0724 8223      		and r24,r18
 772               	.LVL12:
 594:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 773               		.loc 1 594 0
 774 0726 8058      		subi r24,lo8(-(-128))
 775               	.LVL13:
 776               	.L32:
 595:WTPA.c        **** 		}
 596:WTPA.c        **** 
 597:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 777               		.loc 1 597 0
 778 0728 2091 0000 		lds r18,adcByte
 779 072c 3327      		clr r19
 780 072e 27FD      		sbrc r18,7
 781 0730 3095      		com r19
 782 0732 280F      		add r18,r24
 783 0734 311D      		adc r19,__zero_reg__
 784 0736 87FD      		sbrc r24,7
 785 0738 3A95      		dec r19
 786 073a 2038      		cpi r18,-128
 787 073c 9FEF      		ldi r25,-1
 788 073e 3907      		cpc r19,r25
 789 0740 04F4      		brge .L33
 790 0742 20E8      		ldi r18,lo8(-128)
 791 0744 3FEF      		ldi r19,lo8(-1)
 792               	.L33:
 793               	.LVL14:
 598:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 599:WTPA.c        **** 		{
 600:WTPA.c        **** 			sum=127;
 601:WTPA.c        **** 		}
 602:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 603:WTPA.c        **** 		{
 604:WTPA.c        **** 			sum=-128;
 605:WTPA.c        **** 		}
 606:WTPA.c        **** 
 607:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 794               		.loc 1 607 0
 795 0746 2038      		cpi r18,-128
 796 0748 3105      		cpc r19,__zero_reg__
 797 074a 04F0      		brlt .L34
 798 074c 2FE7      		ldi r18,lo8(127)
 799 074e 30E0      		ldi r19,0
 800               	.LVL15:
 801               	.L34:
 802 0750 25B9      		out 0x5,r18
 608:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 803               		.loc 1 608 0
 804 0752 1198      		cbi 0x2,1
 609:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 805               		.loc 1 609 0
 806 0754 119A      		sbi 0x2,1
 610:WTPA.c        **** 		break;
 807               		.loc 1 610 0
 808 0756 0895      		ret
 809               	.LVL16:
 810               	.L35:
 318:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 811               		.loc 1 318 0
 812 0758 80E0      		ldi r24,0
 813               	.LVL17:
 814               	.L2:
 611:WTPA.c        **** 	}
 612:WTPA.c        **** 
 613:WTPA.c        **** 	return(outputByte);
 614:WTPA.c        **** }
 815               		.loc 1 614 0
 816 075a 0895      		ret
 817               		.cfi_endproc
 818               	.LFE1:
 821               	UpdateAudioChannel1:
 822               	.LFB2:
 615:WTPA.c        **** 
 616:WTPA.c        **** static unsigned char UpdateAudioChannel1(void)
 617:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 618:WTPA.c        **** {
 823               		.loc 1 618 0
 824               		.cfi_startproc
 825 075c 0F93      		push r16
 826               	.LCFI0:
 827               		.cfi_def_cfa_offset 3
 828               		.cfi_offset 16, -2
 829 075e 1F93      		push r17
 830               	.LCFI1:
 831               		.cfi_def_cfa_offset 4
 832               		.cfi_offset 17, -3
 833               	/* prologue: function */
 834               	/* frame size = 0 */
 835               	/* stack size = 2 */
 836               	.L__stack_usage = 2
 837               	.LVL18:
 619:WTPA.c        **** 	signed int
 620:WTPA.c        **** 		sum;			// For doing saturated adds.
 621:WTPA.c        **** 	signed char
 622:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 623:WTPA.c        **** 	static unsigned char
 624:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 625:WTPA.c        **** 
 626:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 627:WTPA.c        **** 
 628:WTPA.c        **** 	switch(bankStates[BANK_1].audioFunction)
 838               		.loc 1 628 0
 839 0760 8091 0000 		lds r24,bankStates+35
 840 0764 8330      		cpi r24,lo8(3)
 841 0766 01F0      		breq .L56
 842 0768 00F4      		brsh .L59
 843 076a 8130      		cpi r24,lo8(1)
 844 076c 01F0      		breq .L54
 845 076e 8230      		cpi r24,lo8(2)
 846 0770 01F0      		breq .+2
 847 0772 00C0      		rjmp .L86
 848 0774 00C0      		rjmp .L55
 849               	.L59:
 850 0776 8430      		cpi r24,lo8(4)
 851 0778 01F4      		brne .+2
 852 077a 00C0      		rjmp .L57
 853 077c 8530      		cpi r24,lo8(5)
 854 077e 01F0      		breq .+2
 855 0780 00C0      		rjmp .L86
 856 0782 00C0      		rjmp .L58
 857               	.L54:
 629:WTPA.c        **** 	{
 630:WTPA.c        **** 
 631:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 632:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 633:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 858               		.loc 1 633 0
 859 0784 8091 0000 		lds r24,sawtooth.1763
 860               	.LVL19:
 861 0788 982F      		mov r25,r24
 862 078a 9F5F      		subi r25,lo8(-(1))
 863 078c 9093 0000 		sts sawtooth.1763,r25
 634:WTPA.c        **** 		break;
 864               		.loc 1 634 0
 865 0790 00C0      		rjmp .L53
 866               	.LVL20:
 867               	.L55:
 635:WTPA.c        **** 
 636:WTPA.c        **** 		case AUDIO_REALTIME:
 637:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 638:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 868               		.loc 1 638 0
 869 0792 8091 0000 		lds r24,adcByte
 870               	.LVL21:
 871 0796 00C0      		rjmp .L102
 872               	.LVL22:
 873               	.L56:
 639:WTPA.c        **** 
 640:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 641:WTPA.c        **** 		{
 642:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 643:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 644:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 645:WTPA.c        **** 		}
 646:WTPA.c        **** 		break;
 647:WTPA.c        **** 
 648:WTPA.c        **** 		case AUDIO_RECORD:
 649:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 650:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 874               		.loc 1 650 0
 875 0798 8FEF      		ldi r24,lo8(-1)
 876 079a 84B9      		out 0x4,r24
 651:WTPA.c        **** 
 652:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 877               		.loc 1 652 0
 878 079c 8091 0000 		lds r24,bankStates+66
 879 07a0 9091 0000 		lds r25,bankStates+66+1
 880 07a4 A091 0000 		lds r26,bankStates+66+2
 881 07a8 B091 0000 		lds r27,bankStates+66+3
 882 07ac 85B9      		out 0x5,r24
 653:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 883               		.loc 1 653 0
 884 07ae 139A      		sbi 0x2,3
 654:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 885               		.loc 1 654 0
 886 07b0 1398      		cbi 0x2,3
 655:WTPA.c        **** 
 656:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 887               		.loc 1 656 0
 888 07b2 8091 0000 		lds r24,bankStates+66
 889 07b6 9091 0000 		lds r25,bankStates+66+1
 890 07ba A091 0000 		lds r26,bankStates+66+2
 891 07be B091 0000 		lds r27,bankStates+66+3
 892 07c2 892F      		mov r24,r25
 893 07c4 9A2F      		mov r25,r26
 894 07c6 AB2F      		mov r26,r27
 895 07c8 BB27      		clr r27
 896 07ca 85B9      		out 0x5,r24
 657:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 897               		.loc 1 657 0
 898 07cc 149A      		sbi 0x2,4
 658:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 899               		.loc 1 658 0
 900 07ce 1498      		cbi 0x2,4
 659:WTPA.c        **** 
 660:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 901               		.loc 1 660 0
 902 07d0 8091 0000 		lds r24,bankStates+66
 903 07d4 9091 0000 		lds r25,bankStates+66+1
 904 07d8 A091 0000 		lds r26,bankStates+66+2
 905 07dc B091 0000 		lds r27,bankStates+66+3
 906 07e0 CD01      		movw r24,r26
 907 07e2 AA27      		clr r26
 908 07e4 BB27      		clr r27
 909 07e6 8770      		andi r24,7
 910 07e8 9927      		clr r25
 911 07ea AA27      		clr r26
 912 07ec BB27      		clr r27
 913 07ee 8868      		ori r24,136
 914 07f0 88B9      		out 0x8,r24
 661:WTPA.c        **** 
 662:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 915               		.loc 1 662 0
 916 07f2 8091 0000 		lds r24,adcByte
 917 07f6 85B9      		out 0x5,r24
 663:WTPA.c        **** 
 664:WTPA.c        **** 		// Compute address while bus settles.
 665:WTPA.c        **** 
 666:WTPA.c        **** 		bankStates[BANK_1].currentAddress--;									// Next address please.
 918               		.loc 1 666 0
 919 07f8 8091 0000 		lds r24,bankStates+66
 920 07fc 9091 0000 		lds r25,bankStates+66+1
 921 0800 A091 0000 		lds r26,bankStates+66+2
 922 0804 B091 0000 		lds r27,bankStates+66+3
 923 0808 0197      		sbiw r24,1
 924 080a A109      		sbc r26,__zero_reg__
 925 080c B109      		sbc r27,__zero_reg__
 926 080e 8093 0000 		sts bankStates+66,r24
 927 0812 9093 0000 		sts bankStates+66+1,r25
 928 0816 A093 0000 		sts bankStates+66+2,r26
 929 081a B093 0000 		sts bankStates+66+3,r27
 667:WTPA.c        **** 		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the
 930               		.loc 1 667 0
 931 081e 8091 0000 		lds r24,bankStates+66
 932 0822 9091 0000 		lds r25,bankStates+66+1
 933 0826 A091 0000 		lds r26,bankStates+66+2
 934 082a B091 0000 		lds r27,bankStates+66+3
 935 082e 8093 0000 		sts bankStates+47,r24
 936 0832 9093 0000 		sts bankStates+47+1,r25
 937 0836 A093 0000 		sts bankStates+47+2,r26
 938 083a B093 0000 		sts bankStates+47+3,r27
 668:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address 
 939               		.loc 1 668 0
 940 083e 8091 0000 		lds r24,bankStates+66
 941 0842 9091 0000 		lds r25,bankStates+66+1
 942 0846 A091 0000 		lds r26,bankStates+66+2
 943 084a B091 0000 		lds r27,bankStates+66+3
 944 084e 8093 0000 		sts bankStates+55,r24
 945 0852 9093 0000 		sts bankStates+55+1,r25
 946 0856 A093 0000 		sts bankStates+55+2,r26
 947 085a B093 0000 		sts bankStates+55+3,r27
 669:WTPA.c        **** 
 670:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 948               		.loc 1 670 0
 949 085e 4091 0000 		lds r20,bankStates+12
 950 0862 5091 0000 		lds r21,bankStates+12+1
 951 0866 6091 0000 		lds r22,bankStates+12+2
 952 086a 7091 0000 		lds r23,bankStates+12+3
 953 086e 8091 0000 		lds r24,bankStates+47
 954 0872 9091 0000 		lds r25,bankStates+47+1
 955 0876 A091 0000 		lds r26,bankStates+47+2
 956 087a B091 0000 		lds r27,bankStates+47+3
 957 087e 4817      		cp r20,r24
 958 0880 5907      		cpc r21,r25
 959 0882 6A07      		cpc r22,r26
 960 0884 7B07      		cpc r23,r27
 961 0886 00F0      		brlo .L60
 671:WTPA.c        **** 		{
 672:WTPA.c        **** 			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 962               		.loc 1 672 0
 963 0888 1092 0000 		sts bankStates+35,__zero_reg__
 673:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 964               		.loc 1 673 0
 965 088c 81E0      		ldi r24,lo8(1)
 966 088e 8093 0000 		sts outOfRam,r24
 967               	.L60:
 674:WTPA.c        **** 		}
 675:WTPA.c        **** 
 676:WTPA.c        **** 		// Put data into RAM.
 677:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 968               		.loc 1 677 0
 969 0892 1198      		cbi 0x2,1
 678:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 970               		.loc 1 678 0
 971 0894 119A      		sbi 0x2,1
 972 0896 00C0      		rjmp .L86
 973               	.L57:
 679:WTPA.c        **** 		break;
 680:WTPA.c        **** 
 681:WTPA.c        **** 		case AUDIO_PLAYBACK:
 682:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 683:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 684:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 685:WTPA.c        **** 
 686:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 687:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 974               		.loc 1 687 0
 975 0898 8091 0000 		lds r24,bankStates+66
 976 089c 9091 0000 		lds r25,bankStates+66+1
 977 08a0 A091 0000 		lds r26,bankStates+66+2
 978 08a4 B091 0000 		lds r27,bankStates+66+3
 979 08a8 85B9      		out 0x5,r24
 688:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 980               		.loc 1 688 0
 981 08aa 139A      		sbi 0x2,3
 689:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 982               		.loc 1 689 0
 983 08ac 1398      		cbi 0x2,3
 690:WTPA.c        **** 
 691:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 984               		.loc 1 691 0
 985 08ae 8091 0000 		lds r24,bankStates+66
 986 08b2 9091 0000 		lds r25,bankStates+66+1
 987 08b6 A091 0000 		lds r26,bankStates+66+2
 988 08ba B091 0000 		lds r27,bankStates+66+3
 989 08be 892F      		mov r24,r25
 990 08c0 9A2F      		mov r25,r26
 991 08c2 AB2F      		mov r26,r27
 992 08c4 BB27      		clr r27
 993 08c6 85B9      		out 0x5,r24
 692:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 994               		.loc 1 692 0
 995 08c8 149A      		sbi 0x2,4
 693:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 996               		.loc 1 693 0
 997 08ca 1498      		cbi 0x2,4
 694:WTPA.c        **** 
 695:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 998               		.loc 1 695 0
 999 08cc 8091 0000 		lds r24,bankStates+66
 1000 08d0 9091 0000 		lds r25,bankStates+66+1
 1001 08d4 A091 0000 		lds r26,bankStates+66+2
 1002 08d8 B091 0000 		lds r27,bankStates+66+3
 1003 08dc CD01      		movw r24,r26
 1004 08de AA27      		clr r26
 1005 08e0 BB27      		clr r27
 1006 08e2 8770      		andi r24,7
 1007 08e4 9927      		clr r25
 1008 08e6 AA27      		clr r26
 1009 08e8 BB27      		clr r27
 1010 08ea 8868      		ori r24,136
 1011 08ec 88B9      		out 0x8,r24
 696:WTPA.c        **** 
 697:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1012               		.loc 1 697 0
 1013 08ee 14B8      		out 0x4,__zero_reg__
 698:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1014               		.loc 1 698 0
 1015 08f0 1298      		cbi 0x2,2
 699:WTPA.c        **** 
 700:WTPA.c        **** 		// Calculate addy while bus settles (used to be nops here)
 701:WTPA.c        **** 
 702:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1016               		.loc 1 702 0
 1017 08f2 8091 0000 		lds r24,bankStates+41
 1018 08f6 8823      		tst r24
 1019 08f8 01F4      		brne .+2
 1020 08fa 00C0      		rjmp .L61
 703:WTPA.c        **** 		{
 704:WTPA.c        **** 			// Slice first, only worry about forward ###
 705:WTPA.c        **** 
 706:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1021               		.loc 1 706 0
 1022 08fc 8091 0000 		lds r24,sliceRemaining+4
 1023 0900 9091 0000 		lds r25,sliceRemaining+4+1
 1024 0904 A091 0000 		lds r26,sliceRemaining+4+2
 1025 0908 B091 0000 		lds r27,sliceRemaining+4+3
 1026 090c 892B      		or r24,r25
 1027 090e 8A2B      		or r24,r26
 1028 0910 8B2B      		or r24,r27
 1029 0912 01F0      		breq .L62
 707:WTPA.c        **** 			{
 708:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1030               		.loc 1 708 0
 1031 0914 8091 0000 		lds r24,bankStates+66
 1032 0918 9091 0000 		lds r25,bankStates+66+1
 1033 091c A091 0000 		lds r26,bankStates+66+2
 1034 0920 B091 0000 		lds r27,bankStates+66+3
 1035 0924 0197      		sbiw r24,1
 1036 0926 A109      		sbc r26,__zero_reg__
 1037 0928 B109      		sbc r27,__zero_reg__
 1038 092a 8093 0000 		sts bankStates+66,r24
 1039 092e 9093 0000 		sts bankStates+66+1,r25
 1040 0932 A093 0000 		sts bankStates+66+2,r26
 1041 0936 B093 0000 		sts bankStates+66+3,r27
 709:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1042               		.loc 1 709 0
 1043 093a 8091 0000 		lds r24,sliceRemaining+4
 1044 093e 9091 0000 		lds r25,sliceRemaining+4+1
 1045 0942 A091 0000 		lds r26,sliceRemaining+4+2
 1046 0946 B091 0000 		lds r27,sliceRemaining+4+3
 1047 094a 0197      		sbiw r24,1
 1048 094c A109      		sbc r26,__zero_reg__
 1049 094e B109      		sbc r27,__zero_reg__
 1050 0950 8093 0000 		sts sliceRemaining+4,r24
 1051 0954 9093 0000 		sts sliceRemaining+4+1,r25
 1052 0958 A093 0000 		sts sliceRemaining+4+2,r26
 1053 095c B093 0000 		sts sliceRemaining+4+3,r27
 1054 0960 00C0      		rjmp .L63
 1055               	.L62:
 710:WTPA.c        **** 			}
 711:WTPA.c        **** 			else	// Slice done, jump to new slice.
 712:WTPA.c        **** 			{
 713:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1056               		.loc 1 713 0
 1057 0962 8091 0000 		lds r24,sliceSize+4
 1058 0966 9091 0000 		lds r25,sliceSize+4+1
 1059 096a A091 0000 		lds r26,sliceSize+4+2
 1060 096e B091 0000 		lds r27,sliceSize+4+3
 1061 0972 8093 0000 		sts sliceRemaining+4,r24
 1062 0976 9093 0000 		sts sliceRemaining+4+1,r25
 1063 097a A093 0000 		sts sliceRemaining+4+2,r26
 1064 097e B093 0000 		sts sliceRemaining+4+3,r27
 714:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1065               		.loc 1 714 0
 1066 0982 8091 0000 		lds r24,granularPositionArrayPointer+1
 1067 0986 8F5F      		subi r24,lo8(-(1))
 1068 0988 8093 0000 		sts granularPositionArrayPointer+1,r24
 715:WTPA.c        **** 
 716:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1069               		.loc 1 716 0
 1070 098c 9091 0000 		lds r25,granularPositionArrayPointer+1
 1071 0990 8091 0000 		lds r24,bankStates+41
 1072 0994 9813      		cpse r25,r24
 1073 0996 00C0      		rjmp .L64
 717:WTPA.c        **** 				{
 718:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1074               		.loc 1 718 0
 1075 0998 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1076               	.L64:
 719:WTPA.c        **** 				}
 720:WTPA.c        **** 
 721:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1077               		.loc 1 721 0
 1078 099c E091 0000 		lds r30,granularPositionArrayPointer+1
 1079 09a0 2091 0000 		lds r18,sliceSize+4
 1080 09a4 3091 0000 		lds r19,sliceSize+4+1
 1081 09a8 4091 0000 		lds r20,sliceSize+4+2
 1082 09ac 5091 0000 		lds r21,sliceSize+4+3
 1083 09b0 F0E0      		ldi r31,0
 1084 09b2 E050      		subi r30,lo8(-(granularPositionArray+128))
 1085 09b4 F040      		sbci r31,hi8(-(granularPositionArray+128))
 1086 09b6 A081      		ld r26,Z
 1087 09b8 B0E0      		ldi r27,0
 1088 09ba 0E94 0000 		call __muluhisi3
 1089 09be 0FEF      		ldi r16,lo8(-1)
 1090 09c0 1FEF      		ldi r17,lo8(-1)
 1091 09c2 27E0      		ldi r18,lo8(7)
 1092 09c4 30E0      		ldi r19,0
 1093 09c6 061B      		sub r16,r22
 1094 09c8 170B      		sbc r17,r23
 1095 09ca 280B      		sbc r18,r24
 1096 09cc 390B      		sbc r19,r25
 1097 09ce 0093 0000 		sts bankStates+66,r16
 1098 09d2 1093 0000 		sts bankStates+66+1,r17
 1099 09d6 2093 0000 		sts bankStates+66+2,r18
 1100 09da 3093 0000 		sts bankStates+66+3,r19
 1101 09de 00C0      		rjmp .L63
 1102               	.L61:
 722:WTPA.c        **** 			}
 723:WTPA.c        **** 		}
 724:WTPA.c        **** 		else
 725:WTPA.c        **** 		{
 726:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1103               		.loc 1 726 0
 1104 09e0 8091 0000 		lds r24,bankStates+39
 727:WTPA.c        **** 			{
 728:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1105               		.loc 1 728 0
 1106 09e4 4091 0000 		lds r20,bankStates+66
 1107 09e8 5091 0000 		lds r21,bankStates+66+1
 1108 09ec 6091 0000 		lds r22,bankStates+66+2
 1109 09f0 7091 0000 		lds r23,bankStates+66+3
 726:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1110               		.loc 1 726 0
 1111 09f4 8111      		cpse r24,__zero_reg__
 1112 09f6 00C0      		rjmp .L65
 1113               		.loc 1 728 0
 1114 09f8 8091 0000 		lds r24,bankStates+59
 1115 09fc 9091 0000 		lds r25,bankStates+59+1
 1116 0a00 A091 0000 		lds r26,bankStates+59+2
 1117 0a04 B091 0000 		lds r27,bankStates+59+3
 1118 0a08 4817      		cp r20,r24
 1119 0a0a 5907      		cpc r21,r25
 1120 0a0c 6A07      		cpc r22,r26
 1121 0a0e 7B07      		cpc r23,r27
 1122 0a10 01F4      		brne .L66
 1123               		.loc 1 728 0 is_stmt 0 discriminator 1
 1124 0a12 8091 0000 		lds r24,bankStates+36
 1125 0a16 8130      		cpi r24,lo8(1)
 1126 0a18 01F4      		brne .L66
 1127 0a1a 00C0      		rjmp .L96
 1128               	.L66:
 729:WTPA.c        **** 				{
 730:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 731:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 732:WTPA.c        **** 				}
 733:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1129               		.loc 1 733 0 is_stmt 1
 1130 0a1c 4091 0000 		lds r20,bankStates+66
 1131 0a20 5091 0000 		lds r21,bankStates+66+1
 1132 0a24 6091 0000 		lds r22,bankStates+66+2
 1133 0a28 7091 0000 		lds r23,bankStates+66+3
 1134 0a2c 8091 0000 		lds r24,bankStates+59
 1135 0a30 9091 0000 		lds r25,bankStates+59+1
 1136 0a34 A091 0000 		lds r26,bankStates+59+2
 1137 0a38 B091 0000 		lds r27,bankStates+59+3
 1138 0a3c 4817      		cp r20,r24
 1139 0a3e 5907      		cpc r21,r25
 1140 0a40 6A07      		cpc r22,r26
 1141 0a42 7B07      		cpc r23,r27
 1142 0a44 01F4      		brne .L67
 734:WTPA.c        **** 				{
 735:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1143               		.loc 1 735 0
 1144 0a46 8091 0000 		lds r24,bankStates+55
 1145 0a4a 9091 0000 		lds r25,bankStates+55+1
 1146 0a4e A091 0000 		lds r26,bankStates+55+2
 1147 0a52 B091 0000 		lds r27,bankStates+55+3
 1148 0a56 00C0      		rjmp .L97
 1149               	.L67:
 736:WTPA.c        **** 				}
 737:WTPA.c        **** 				else
 738:WTPA.c        **** 				{
 739:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1150               		.loc 1 739 0
 1151 0a58 4091 0000 		lds r20,bankStates+66
 1152 0a5c 5091 0000 		lds r21,bankStates+66+1
 1153 0a60 6091 0000 		lds r22,bankStates+66+2
 1154 0a64 7091 0000 		lds r23,bankStates+66+3
 1155 0a68 8091 0000 		lds r24,bankStates+51
 1156 0a6c 9091 0000 		lds r25,bankStates+51+1
 1157 0a70 A091 0000 		lds r26,bankStates+51+2
 1158 0a74 B091 0000 		lds r27,bankStates+51+3
 1159 0a78 4817      		cp r20,r24
 1160 0a7a 5907      		cpc r21,r25
 1161 0a7c 6A07      		cpc r22,r26
 1162 0a7e 7B07      		cpc r23,r27
 1163 0a80 01F4      		brne .L68
 740:WTPA.c        **** 					{
 741:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1164               		.loc 1 741 0
 1165 0a82 8091 0000 		lds r24,bankStates+47
 1166 0a86 9091 0000 		lds r25,bankStates+47+1
 1167 0a8a A091 0000 		lds r26,bankStates+47+2
 1168 0a8e B091 0000 		lds r27,bankStates+47+3
 1169 0a92 00C0      		rjmp .L97
 1170               	.L68:
 742:WTPA.c        **** 					}
 743:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 744:WTPA.c        **** 					{
 745:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1171               		.loc 1 745 0
 1172 0a94 8091 0000 		lds r24,bankStates+66
 1173 0a98 9091 0000 		lds r25,bankStates+66+1
 1174 0a9c A091 0000 		lds r26,bankStates+66+2
 1175 0aa0 B091 0000 		lds r27,bankStates+66+3
 1176 0aa4 0196      		adiw r24,1
 1177 0aa6 A11D      		adc r26,__zero_reg__
 1178 0aa8 B11D      		adc r27,__zero_reg__
 1179 0aaa 00C0      		rjmp .L97
 1180               	.L65:
 746:WTPA.c        **** 					}
 747:WTPA.c        **** 				}
 748:WTPA.c        **** 			}
 749:WTPA.c        **** 			else	// Going forward through the sample.
 750:WTPA.c        **** 			{
 751:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1181               		.loc 1 751 0
 1182 0aac 8091 0000 		lds r24,bankStates+55
 1183 0ab0 9091 0000 		lds r25,bankStates+55+1
 1184 0ab4 A091 0000 		lds r26,bankStates+55+2
 1185 0ab8 B091 0000 		lds r27,bankStates+55+3
 1186 0abc 4817      		cp r20,r24
 1187 0abe 5907      		cpc r21,r25
 1188 0ac0 6A07      		cpc r22,r26
 1189 0ac2 7B07      		cpc r23,r27
 1190 0ac4 01F4      		brne .L69
 1191               		.loc 1 751 0 is_stmt 0 discriminator 1
 1192 0ac6 8091 0000 		lds r24,bankStates+36
 1193 0aca 8130      		cpi r24,lo8(1)
 1194 0acc 01F4      		brne .L69
 1195               	.L96:
 752:WTPA.c        **** 				{
 753:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1196               		.loc 1 753 0 is_stmt 1
 1197 0ace 1092 0000 		sts bankStates+35,__zero_reg__
 754:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1198               		.loc 1 754 0
 1199 0ad2 1092 0000 		sts bankStates+44,__zero_reg__
 1200 0ad6 00C0      		rjmp .L63
 1201               	.L69:
 755:WTPA.c        **** 				}
 756:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1202               		.loc 1 756 0
 1203 0ad8 4091 0000 		lds r20,bankStates+66
 1204 0adc 5091 0000 		lds r21,bankStates+66+1
 1205 0ae0 6091 0000 		lds r22,bankStates+66+2
 1206 0ae4 7091 0000 		lds r23,bankStates+66+3
 1207 0ae8 8091 0000 		lds r24,bankStates+55
 1208 0aec 9091 0000 		lds r25,bankStates+55+1
 1209 0af0 A091 0000 		lds r26,bankStates+55+2
 1210 0af4 B091 0000 		lds r27,bankStates+55+3
 1211 0af8 4817      		cp r20,r24
 1212 0afa 5907      		cpc r21,r25
 1213 0afc 6A07      		cpc r22,r26
 1214 0afe 7B07      		cpc r23,r27
 1215 0b00 01F4      		brne .L70
 757:WTPA.c        **** 				{
 758:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1216               		.loc 1 758 0
 1217 0b02 8091 0000 		lds r24,bankStates+59
 1218 0b06 9091 0000 		lds r25,bankStates+59+1
 1219 0b0a A091 0000 		lds r26,bankStates+59+2
 1220 0b0e B091 0000 		lds r27,bankStates+59+3
 1221 0b12 00C0      		rjmp .L97
 1222               	.L70:
 759:WTPA.c        **** 				}
 760:WTPA.c        **** 				else
 761:WTPA.c        **** 				{
 762:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1223               		.loc 1 762 0
 1224 0b14 4091 0000 		lds r20,bankStates+66
 1225 0b18 5091 0000 		lds r21,bankStates+66+1
 1226 0b1c 6091 0000 		lds r22,bankStates+66+2
 1227 0b20 7091 0000 		lds r23,bankStates+66+3
 1228 0b24 8091 0000 		lds r24,bankStates+47
 1229 0b28 9091 0000 		lds r25,bankStates+47+1
 1230 0b2c A091 0000 		lds r26,bankStates+47+2
 1231 0b30 B091 0000 		lds r27,bankStates+47+3
 1232 0b34 4817      		cp r20,r24
 1233 0b36 5907      		cpc r21,r25
 1234 0b38 6A07      		cpc r22,r26
 1235 0b3a 7B07      		cpc r23,r27
 1236 0b3c 01F4      		brne .L71
 763:WTPA.c        **** 					{
 764:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1237               		.loc 1 764 0
 1238 0b3e 8091 0000 		lds r24,bankStates+51
 1239 0b42 9091 0000 		lds r25,bankStates+51+1
 1240 0b46 A091 0000 		lds r26,bankStates+51+2
 1241 0b4a B091 0000 		lds r27,bankStates+51+3
 1242 0b4e 00C0      		rjmp .L97
 1243               	.L71:
 765:WTPA.c        **** 					}
 766:WTPA.c        **** 					else
 767:WTPA.c        **** 					{
 768:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1244               		.loc 1 768 0
 1245 0b50 8091 0000 		lds r24,bankStates+66
 1246 0b54 9091 0000 		lds r25,bankStates+66+1
 1247 0b58 A091 0000 		lds r26,bankStates+66+2
 1248 0b5c B091 0000 		lds r27,bankStates+66+3
 1249 0b60 0197      		sbiw r24,1
 1250 0b62 A109      		sbc r26,__zero_reg__
 1251 0b64 B109      		sbc r27,__zero_reg__
 1252               	.L97:
 1253 0b66 8093 0000 		sts bankStates+66,r24
 1254 0b6a 9093 0000 		sts bankStates+66+1,r25
 1255 0b6e A093 0000 		sts bankStates+66+2,r26
 1256 0b72 B093 0000 		sts bankStates+66+3,r27
 1257               	.L63:
 769:WTPA.c        **** 					}
 770:WTPA.c        **** 				}
 771:WTPA.c        **** 			}
 772:WTPA.c        **** 		}
 773:WTPA.c        **** 
 774:WTPA.c        **** 		// Done with addy, read RAM.
 775:WTPA.c        **** 
 776:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 1258               		.loc 1 776 0
 1259 0b76 83B1      		in r24,0x3
 1260               	.LVL23:
 777:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1261               		.loc 1 777 0
 1262 0b78 129A      		sbi 0x2,2
 778:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1263               		.loc 1 778 0
 1264 0b7a 9FEF      		ldi r25,lo8(-1)
 1265 0b7c 94B9      		out 0x4,r25
 1266               	.L102:
 779:WTPA.c        **** 
 780:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1267               		.loc 1 780 0
 1268 0b7e 9091 0000 		lds r25,bankStates+43
 1269 0b82 9923      		tst r25
 1270 0b84 01F4      		brne .+2
 1271 0b86 00C0      		rjmp .L53
 781:WTPA.c        **** 		{
 782:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1272               		.loc 1 782 0
 1273 0b88 8058      		subi r24,lo8(-(-128))
 1274               	.LVL24:
 783:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1275               		.loc 1 783 0
 1276 0b8a 9091 0000 		lds r25,bankStates+43
 1277 0b8e 2FEF      		ldi r18,lo8(-1)
 1278 0b90 30E0      		ldi r19,0
 1279 0b92 092E      		mov r0,r25
 1280 0b94 00C0      		rjmp 2f
 1281               		1:
 1282 0b96 220F      		lsl r18
 1283               		2:
 1284 0b98 0A94      		dec r0
 1285 0b9a 02F4      		brpl 1b
 1286 0b9c 8223      		and r24,r18
 1287               	.LVL25:
 784:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1288               		.loc 1 784 0
 1289 0b9e 8058      		subi r24,lo8(-(-128))
 1290               	.LVL26:
 1291 0ba0 00C0      		rjmp .L53
 1292               	.LVL27:
 1293               	.L58:
 785:WTPA.c        **** 		}
 786:WTPA.c        **** 		break;
 787:WTPA.c        **** 
 788:WTPA.c        **** 		case AUDIO_OVERDUB:
 789:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 790:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 791:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 1294               		.loc 1 791 0
 1295 0ba2 8091 0000 		lds r24,bankStates+66
 1296 0ba6 9091 0000 		lds r25,bankStates+66+1
 1297 0baa A091 0000 		lds r26,bankStates+66+2
 1298 0bae B091 0000 		lds r27,bankStates+66+3
 1299 0bb2 85B9      		out 0x5,r24
 792:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 1300               		.loc 1 792 0
 1301 0bb4 139A      		sbi 0x2,3
 793:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 1302               		.loc 1 793 0
 1303 0bb6 1398      		cbi 0x2,3
 794:WTPA.c        **** 
 795:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 1304               		.loc 1 795 0
 1305 0bb8 8091 0000 		lds r24,bankStates+66
 1306 0bbc 9091 0000 		lds r25,bankStates+66+1
 1307 0bc0 A091 0000 		lds r26,bankStates+66+2
 1308 0bc4 B091 0000 		lds r27,bankStates+66+3
 1309 0bc8 892F      		mov r24,r25
 1310 0bca 9A2F      		mov r25,r26
 1311 0bcc AB2F      		mov r26,r27
 1312 0bce BB27      		clr r27
 1313 0bd0 85B9      		out 0x5,r24
 796:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 1314               		.loc 1 796 0
 1315 0bd2 149A      		sbi 0x2,4
 797:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 1316               		.loc 1 797 0
 1317 0bd4 1498      		cbi 0x2,4
 798:WTPA.c        **** 
 799:WTPA.c        **** 		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 1318               		.loc 1 799 0
 1319 0bd6 8091 0000 		lds r24,bankStates+66
 1320 0bda 9091 0000 		lds r25,bankStates+66+1
 1321 0bde A091 0000 		lds r26,bankStates+66+2
 1322 0be2 B091 0000 		lds r27,bankStates+66+3
 1323 0be6 CD01      		movw r24,r26
 1324 0be8 AA27      		clr r26
 1325 0bea BB27      		clr r27
 1326 0bec 8770      		andi r24,7
 1327 0bee 9927      		clr r25
 1328 0bf0 AA27      		clr r26
 1329 0bf2 BB27      		clr r27
 1330 0bf4 8868      		ori r24,136
 1331 0bf6 88B9      		out 0x8,r24
 800:WTPA.c        **** 
 801:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1332               		.loc 1 801 0
 1333 0bf8 14B8      		out 0x4,__zero_reg__
 802:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1334               		.loc 1 802 0
 1335 0bfa 1298      		cbi 0x2,2
 803:WTPA.c        **** 
 804:WTPA.c        **** 		// Do some operations while we wait for the data bus to settle from turnaround.
 805:WTPA.c        **** 
 806:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1336               		.loc 1 806 0
 1337 0bfc 8091 0000 		lds r24,bankStates+41
 1338 0c00 8823      		tst r24
 1339 0c02 01F4      		brne .+2
 1340 0c04 00C0      		rjmp .L72
 807:WTPA.c        **** 		{
 808:WTPA.c        **** 			// Slice first, only worry about forward ###
 809:WTPA.c        **** 
 810:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1341               		.loc 1 810 0
 1342 0c06 8091 0000 		lds r24,sliceRemaining+4
 1343 0c0a 9091 0000 		lds r25,sliceRemaining+4+1
 1344 0c0e A091 0000 		lds r26,sliceRemaining+4+2
 1345 0c12 B091 0000 		lds r27,sliceRemaining+4+3
 1346 0c16 892B      		or r24,r25
 1347 0c18 8A2B      		or r24,r26
 1348 0c1a 8B2B      		or r24,r27
 1349 0c1c 01F0      		breq .L73
 811:WTPA.c        **** 			{
 812:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1350               		.loc 1 812 0
 1351 0c1e 8091 0000 		lds r24,bankStates+66
 1352 0c22 9091 0000 		lds r25,bankStates+66+1
 1353 0c26 A091 0000 		lds r26,bankStates+66+2
 1354 0c2a B091 0000 		lds r27,bankStates+66+3
 1355 0c2e 0197      		sbiw r24,1
 1356 0c30 A109      		sbc r26,__zero_reg__
 1357 0c32 B109      		sbc r27,__zero_reg__
 1358 0c34 8093 0000 		sts bankStates+66,r24
 1359 0c38 9093 0000 		sts bankStates+66+1,r25
 1360 0c3c A093 0000 		sts bankStates+66+2,r26
 1361 0c40 B093 0000 		sts bankStates+66+3,r27
 813:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1362               		.loc 1 813 0
 1363 0c44 8091 0000 		lds r24,sliceRemaining+4
 1364 0c48 9091 0000 		lds r25,sliceRemaining+4+1
 1365 0c4c A091 0000 		lds r26,sliceRemaining+4+2
 1366 0c50 B091 0000 		lds r27,sliceRemaining+4+3
 1367 0c54 0197      		sbiw r24,1
 1368 0c56 A109      		sbc r26,__zero_reg__
 1369 0c58 B109      		sbc r27,__zero_reg__
 1370 0c5a 8093 0000 		sts sliceRemaining+4,r24
 1371 0c5e 9093 0000 		sts sliceRemaining+4+1,r25
 1372 0c62 A093 0000 		sts sliceRemaining+4+2,r26
 1373 0c66 B093 0000 		sts sliceRemaining+4+3,r27
 1374 0c6a 00C0      		rjmp .L74
 1375               	.L73:
 814:WTPA.c        **** 			}
 815:WTPA.c        **** 			else	// Slice done, jump to new slice.
 816:WTPA.c        **** 			{
 817:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1376               		.loc 1 817 0
 1377 0c6c 8091 0000 		lds r24,sliceSize+4
 1378 0c70 9091 0000 		lds r25,sliceSize+4+1
 1379 0c74 A091 0000 		lds r26,sliceSize+4+2
 1380 0c78 B091 0000 		lds r27,sliceSize+4+3
 1381 0c7c 8093 0000 		sts sliceRemaining+4,r24
 1382 0c80 9093 0000 		sts sliceRemaining+4+1,r25
 1383 0c84 A093 0000 		sts sliceRemaining+4+2,r26
 1384 0c88 B093 0000 		sts sliceRemaining+4+3,r27
 818:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1385               		.loc 1 818 0
 1386 0c8c 8091 0000 		lds r24,granularPositionArrayPointer+1
 1387 0c90 8F5F      		subi r24,lo8(-(1))
 1388 0c92 8093 0000 		sts granularPositionArrayPointer+1,r24
 819:WTPA.c        **** 
 820:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1389               		.loc 1 820 0
 1390 0c96 9091 0000 		lds r25,granularPositionArrayPointer+1
 1391 0c9a 8091 0000 		lds r24,bankStates+41
 1392 0c9e 9813      		cpse r25,r24
 1393 0ca0 00C0      		rjmp .L75
 821:WTPA.c        **** 				{
 822:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1394               		.loc 1 822 0
 1395 0ca2 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1396               	.L75:
 823:WTPA.c        **** 				}
 824:WTPA.c        **** 
 825:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1397               		.loc 1 825 0
 1398 0ca6 E091 0000 		lds r30,granularPositionArrayPointer+1
 1399 0caa 2091 0000 		lds r18,sliceSize+4
 1400 0cae 3091 0000 		lds r19,sliceSize+4+1
 1401 0cb2 4091 0000 		lds r20,sliceSize+4+2
 1402 0cb6 5091 0000 		lds r21,sliceSize+4+3
 1403 0cba F0E0      		ldi r31,0
 1404 0cbc E050      		subi r30,lo8(-(granularPositionArray+128))
 1405 0cbe F040      		sbci r31,hi8(-(granularPositionArray+128))
 1406 0cc0 A081      		ld r26,Z
 1407 0cc2 B0E0      		ldi r27,0
 1408 0cc4 0E94 0000 		call __muluhisi3
 1409 0cc8 0FEF      		ldi r16,lo8(-1)
 1410 0cca 1FEF      		ldi r17,lo8(-1)
 1411 0ccc 27E0      		ldi r18,lo8(7)
 1412 0cce 30E0      		ldi r19,0
 1413 0cd0 061B      		sub r16,r22
 1414 0cd2 170B      		sbc r17,r23
 1415 0cd4 280B      		sbc r18,r24
 1416 0cd6 390B      		sbc r19,r25
 1417 0cd8 0093 0000 		sts bankStates+66,r16
 1418 0cdc 1093 0000 		sts bankStates+66+1,r17
 1419 0ce0 2093 0000 		sts bankStates+66+2,r18
 1420 0ce4 3093 0000 		sts bankStates+66+3,r19
 1421 0ce8 00C0      		rjmp .L74
 1422               	.L72:
 826:WTPA.c        **** 			}
 827:WTPA.c        **** 		}
 828:WTPA.c        **** 		else
 829:WTPA.c        **** 		{
 830:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1423               		.loc 1 830 0
 1424 0cea 8091 0000 		lds r24,bankStates+39
 831:WTPA.c        **** 			{
 832:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1425               		.loc 1 832 0
 1426 0cee 4091 0000 		lds r20,bankStates+66
 1427 0cf2 5091 0000 		lds r21,bankStates+66+1
 1428 0cf6 6091 0000 		lds r22,bankStates+66+2
 1429 0cfa 7091 0000 		lds r23,bankStates+66+3
 830:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1430               		.loc 1 830 0
 1431 0cfe 8111      		cpse r24,__zero_reg__
 1432 0d00 00C0      		rjmp .L76
 1433               		.loc 1 832 0
 1434 0d02 8091 0000 		lds r24,bankStates+59
 1435 0d06 9091 0000 		lds r25,bankStates+59+1
 1436 0d0a A091 0000 		lds r26,bankStates+59+2
 1437 0d0e B091 0000 		lds r27,bankStates+59+3
 1438 0d12 4817      		cp r20,r24
 1439 0d14 5907      		cpc r21,r25
 1440 0d16 6A07      		cpc r22,r26
 1441 0d18 7B07      		cpc r23,r27
 1442 0d1a 01F4      		brne .L77
 1443               		.loc 1 832 0 is_stmt 0 discriminator 1
 1444 0d1c 8091 0000 		lds r24,bankStates+36
 1445 0d20 8130      		cpi r24,lo8(1)
 1446 0d22 01F4      		brne .L77
 1447 0d24 00C0      		rjmp .L98
 1448               	.L77:
 833:WTPA.c        **** 				{
 834:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 835:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 836:WTPA.c        **** 				}
 837:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1449               		.loc 1 837 0 is_stmt 1
 1450 0d26 4091 0000 		lds r20,bankStates+66
 1451 0d2a 5091 0000 		lds r21,bankStates+66+1
 1452 0d2e 6091 0000 		lds r22,bankStates+66+2
 1453 0d32 7091 0000 		lds r23,bankStates+66+3
 1454 0d36 8091 0000 		lds r24,bankStates+59
 1455 0d3a 9091 0000 		lds r25,bankStates+59+1
 1456 0d3e A091 0000 		lds r26,bankStates+59+2
 1457 0d42 B091 0000 		lds r27,bankStates+59+3
 1458 0d46 4817      		cp r20,r24
 1459 0d48 5907      		cpc r21,r25
 1460 0d4a 6A07      		cpc r22,r26
 1461 0d4c 7B07      		cpc r23,r27
 1462 0d4e 01F4      		brne .L78
 838:WTPA.c        **** 				{
 839:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1463               		.loc 1 839 0
 1464 0d50 8091 0000 		lds r24,bankStates+55
 1465 0d54 9091 0000 		lds r25,bankStates+55+1
 1466 0d58 A091 0000 		lds r26,bankStates+55+2
 1467 0d5c B091 0000 		lds r27,bankStates+55+3
 1468 0d60 00C0      		rjmp .L99
 1469               	.L78:
 840:WTPA.c        **** 				}
 841:WTPA.c        **** 				else
 842:WTPA.c        **** 				{
 843:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1470               		.loc 1 843 0
 1471 0d62 4091 0000 		lds r20,bankStates+66
 1472 0d66 5091 0000 		lds r21,bankStates+66+1
 1473 0d6a 6091 0000 		lds r22,bankStates+66+2
 1474 0d6e 7091 0000 		lds r23,bankStates+66+3
 1475 0d72 8091 0000 		lds r24,bankStates+51
 1476 0d76 9091 0000 		lds r25,bankStates+51+1
 1477 0d7a A091 0000 		lds r26,bankStates+51+2
 1478 0d7e B091 0000 		lds r27,bankStates+51+3
 1479 0d82 4817      		cp r20,r24
 1480 0d84 5907      		cpc r21,r25
 1481 0d86 6A07      		cpc r22,r26
 1482 0d88 7B07      		cpc r23,r27
 1483 0d8a 01F4      		brne .L79
 844:WTPA.c        **** 					{
 845:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1484               		.loc 1 845 0
 1485 0d8c 8091 0000 		lds r24,bankStates+47
 1486 0d90 9091 0000 		lds r25,bankStates+47+1
 1487 0d94 A091 0000 		lds r26,bankStates+47+2
 1488 0d98 B091 0000 		lds r27,bankStates+47+3
 1489 0d9c 00C0      		rjmp .L99
 1490               	.L79:
 846:WTPA.c        **** 					}
 847:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 848:WTPA.c        **** 					{
 849:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1491               		.loc 1 849 0
 1492 0d9e 8091 0000 		lds r24,bankStates+66
 1493 0da2 9091 0000 		lds r25,bankStates+66+1
 1494 0da6 A091 0000 		lds r26,bankStates+66+2
 1495 0daa B091 0000 		lds r27,bankStates+66+3
 1496 0dae 0196      		adiw r24,1
 1497 0db0 A11D      		adc r26,__zero_reg__
 1498 0db2 B11D      		adc r27,__zero_reg__
 1499 0db4 00C0      		rjmp .L99
 1500               	.L76:
 850:WTPA.c        **** 					}
 851:WTPA.c        **** 				}
 852:WTPA.c        **** 			}
 853:WTPA.c        **** 			else	// Going forward through the sample.
 854:WTPA.c        **** 			{
 855:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1501               		.loc 1 855 0
 1502 0db6 8091 0000 		lds r24,bankStates+55
 1503 0dba 9091 0000 		lds r25,bankStates+55+1
 1504 0dbe A091 0000 		lds r26,bankStates+55+2
 1505 0dc2 B091 0000 		lds r27,bankStates+55+3
 1506 0dc6 4817      		cp r20,r24
 1507 0dc8 5907      		cpc r21,r25
 1508 0dca 6A07      		cpc r22,r26
 1509 0dcc 7B07      		cpc r23,r27
 1510 0dce 01F4      		brne .L80
 1511               		.loc 1 855 0 is_stmt 0 discriminator 1
 1512 0dd0 8091 0000 		lds r24,bankStates+36
 1513 0dd4 8130      		cpi r24,lo8(1)
 1514 0dd6 01F4      		brne .L80
 1515               	.L98:
 856:WTPA.c        **** 				{
 857:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1516               		.loc 1 857 0 is_stmt 1
 1517 0dd8 1092 0000 		sts bankStates+35,__zero_reg__
 858:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1518               		.loc 1 858 0
 1519 0ddc 1092 0000 		sts bankStates+44,__zero_reg__
 1520 0de0 00C0      		rjmp .L74
 1521               	.L80:
 859:WTPA.c        **** 				}
 860:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1522               		.loc 1 860 0
 1523 0de2 4091 0000 		lds r20,bankStates+66
 1524 0de6 5091 0000 		lds r21,bankStates+66+1
 1525 0dea 6091 0000 		lds r22,bankStates+66+2
 1526 0dee 7091 0000 		lds r23,bankStates+66+3
 1527 0df2 8091 0000 		lds r24,bankStates+55
 1528 0df6 9091 0000 		lds r25,bankStates+55+1
 1529 0dfa A091 0000 		lds r26,bankStates+55+2
 1530 0dfe B091 0000 		lds r27,bankStates+55+3
 1531 0e02 4817      		cp r20,r24
 1532 0e04 5907      		cpc r21,r25
 1533 0e06 6A07      		cpc r22,r26
 1534 0e08 7B07      		cpc r23,r27
 1535 0e0a 01F4      		brne .L81
 861:WTPA.c        **** 				{
 862:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1536               		.loc 1 862 0
 1537 0e0c 8091 0000 		lds r24,bankStates+59
 1538 0e10 9091 0000 		lds r25,bankStates+59+1
 1539 0e14 A091 0000 		lds r26,bankStates+59+2
 1540 0e18 B091 0000 		lds r27,bankStates+59+3
 1541 0e1c 00C0      		rjmp .L99
 1542               	.L81:
 863:WTPA.c        **** 				}
 864:WTPA.c        **** 				else
 865:WTPA.c        **** 				{
 866:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1543               		.loc 1 866 0
 1544 0e1e 4091 0000 		lds r20,bankStates+66
 1545 0e22 5091 0000 		lds r21,bankStates+66+1
 1546 0e26 6091 0000 		lds r22,bankStates+66+2
 1547 0e2a 7091 0000 		lds r23,bankStates+66+3
 1548 0e2e 8091 0000 		lds r24,bankStates+47
 1549 0e32 9091 0000 		lds r25,bankStates+47+1
 1550 0e36 A091 0000 		lds r26,bankStates+47+2
 1551 0e3a B091 0000 		lds r27,bankStates+47+3
 1552 0e3e 4817      		cp r20,r24
 1553 0e40 5907      		cpc r21,r25
 1554 0e42 6A07      		cpc r22,r26
 1555 0e44 7B07      		cpc r23,r27
 1556 0e46 01F4      		brne .L82
 867:WTPA.c        **** 					{
 868:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1557               		.loc 1 868 0
 1558 0e48 8091 0000 		lds r24,bankStates+51
 1559 0e4c 9091 0000 		lds r25,bankStates+51+1
 1560 0e50 A091 0000 		lds r26,bankStates+51+2
 1561 0e54 B091 0000 		lds r27,bankStates+51+3
 1562 0e58 00C0      		rjmp .L99
 1563               	.L82:
 869:WTPA.c        **** 					}
 870:WTPA.c        **** 					else
 871:WTPA.c        **** 					{
 872:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1564               		.loc 1 872 0
 1565 0e5a 8091 0000 		lds r24,bankStates+66
 1566 0e5e 9091 0000 		lds r25,bankStates+66+1
 1567 0e62 A091 0000 		lds r26,bankStates+66+2
 1568 0e66 B091 0000 		lds r27,bankStates+66+3
 1569 0e6a 0197      		sbiw r24,1
 1570 0e6c A109      		sbc r26,__zero_reg__
 1571 0e6e B109      		sbc r27,__zero_reg__
 1572               	.L99:
 1573 0e70 8093 0000 		sts bankStates+66,r24
 1574 0e74 9093 0000 		sts bankStates+66+1,r25
 1575 0e78 A093 0000 		sts bankStates+66+2,r26
 1576 0e7c B093 0000 		sts bankStates+66+3,r27
 1577               	.L74:
 873:WTPA.c        **** 					}
 874:WTPA.c        **** 				}
 875:WTPA.c        **** 			}
 876:WTPA.c        **** 		}
 877:WTPA.c        **** 
 878:WTPA.c        **** 		// Finished with addy stuff, now finish data transfer
 879:WTPA.c        **** 
 880:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 1578               		.loc 1 880 0
 1579 0e80 83B1      		in r24,0x3
 1580               	.LVL28:
 881:WTPA.c        **** 
 882:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1581               		.loc 1 882 0
 1582 0e82 129A      		sbi 0x2,2
 883:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1583               		.loc 1 883 0
 1584 0e84 9FEF      		ldi r25,lo8(-1)
 1585 0e86 94B9      		out 0x4,r25
 884:WTPA.c        **** 
 885:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1586               		.loc 1 885 0
 1587 0e88 9091 0000 		lds r25,bankStates+43
 1588 0e8c 9923      		tst r25
 1589 0e8e 01F0      		breq .L83
 886:WTPA.c        **** 		{
 887:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1590               		.loc 1 887 0
 1591 0e90 8058      		subi r24,lo8(-(-128))
 1592               	.LVL29:
 888:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1593               		.loc 1 888 0
 1594 0e92 9091 0000 		lds r25,bankStates+43
 1595 0e96 2FEF      		ldi r18,lo8(-1)
 1596 0e98 30E0      		ldi r19,0
 1597 0e9a 092E      		mov r0,r25
 1598 0e9c 00C0      		rjmp 2f
 1599               		1:
 1600 0e9e 220F      		lsl r18
 1601               		2:
 1602 0ea0 0A94      		dec r0
 1603 0ea2 02F4      		brpl 1b
 1604 0ea4 8223      		and r24,r18
 1605               	.LVL30:
 889:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1606               		.loc 1 889 0
 1607 0ea6 8058      		subi r24,lo8(-(-128))
 1608               	.LVL31:
 1609               	.L83:
 890:WTPA.c        **** 		}
 891:WTPA.c        **** 
 892:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 1610               		.loc 1 892 0
 1611 0ea8 2091 0000 		lds r18,adcByte
 1612 0eac 3327      		clr r19
 1613 0eae 27FD      		sbrc r18,7
 1614 0eb0 3095      		com r19
 1615 0eb2 280F      		add r18,r24
 1616 0eb4 311D      		adc r19,__zero_reg__
 1617 0eb6 87FD      		sbrc r24,7
 1618 0eb8 3A95      		dec r19
 1619 0eba 2038      		cpi r18,-128
 1620 0ebc 9FEF      		ldi r25,-1
 1621 0ebe 3907      		cpc r19,r25
 1622 0ec0 04F4      		brge .L84
 1623 0ec2 20E8      		ldi r18,lo8(-128)
 1624 0ec4 3FEF      		ldi r19,lo8(-1)
 1625               	.L84:
 1626               	.LVL32:
 893:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 894:WTPA.c        **** 		{
 895:WTPA.c        **** 			sum=127;
 896:WTPA.c        **** 		}
 897:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 898:WTPA.c        **** 		{
 899:WTPA.c        **** 			sum=-128;
 900:WTPA.c        **** 		}
 901:WTPA.c        **** 
 902:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 1627               		.loc 1 902 0
 1628 0ec6 2038      		cpi r18,-128
 1629 0ec8 3105      		cpc r19,__zero_reg__
 1630 0eca 04F0      		brlt .L85
 1631 0ecc 2FE7      		ldi r18,lo8(127)
 1632 0ece 30E0      		ldi r19,0
 1633               	.LVL33:
 1634               	.L85:
 1635 0ed0 25B9      		out 0x5,r18
 903:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 1636               		.loc 1 903 0
 1637 0ed2 1198      		cbi 0x2,1
 904:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 1638               		.loc 1 904 0
 1639 0ed4 119A      		sbi 0x2,1
 905:WTPA.c        **** 		break;
 1640               		.loc 1 905 0
 1641 0ed6 00C0      		rjmp .L53
 1642               	.LVL34:
 1643               	.L86:
 626:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 1644               		.loc 1 626 0
 1645 0ed8 80E0      		ldi r24,0
 1646               	.LVL35:
 1647               	.L53:
 1648               	/* epilogue start */
 906:WTPA.c        **** 	}
 907:WTPA.c        **** 
 908:WTPA.c        **** 	return(outputByte);
 909:WTPA.c        **** }
 1649               		.loc 1 909 0
 1650 0eda 1F91      		pop r17
 1651 0edc 0F91      		pop r16
 1652 0ede 0895      		ret
 1653               		.cfi_endproc
 1654               	.LFE2:
 1657               	OutputMultiplyBanks:
 1658               	.LFB3:
 910:WTPA.c        **** 
 911:WTPA.c        **** //-----------------------------------------------------------------------------
 912:WTPA.c        **** //-----------------------------------------------------------------------------
 913:WTPA.c        **** // DAC output handling and sample combination functions:
 914:WTPA.c        **** // These functions are called (via pointer) everytime a bank updates.
 915:WTPA.c        **** // They worry about summing (or whatever) the different audio sources and spitting them out on the 
 916:WTPA.c        **** //-----------------------------------------------------------------------------
 917:WTPA.c        **** //-----------------------------------------------------------------------------
 918:WTPA.c        **** 
 919:WTPA.c        **** // Globals used in the audio and output update functions.
 920:WTPA.c        **** 
 921:WTPA.c        **** typedef void OUTPUT_FUNCTION(void);	// Creates a datatype -- a void function called OUTPUT_FUNCTION
 922:WTPA.c        **** 
 923:WTPA.c        **** OUTPUT_FUNCTION					// Assigns a pointer called UpdateOutput to an instance of OUTPUT_FUNCTION()
 924:WTPA.c        **** 	*UpdateOutput;
 925:WTPA.c        **** 
 926:WTPA.c        **** static signed char
 927:WTPA.c        **** 	extIsrOutputBank0,
 928:WTPA.c        **** 	extIsrOutputBank1,
 929:WTPA.c        **** 	midiOutputBank0,
 930:WTPA.c        **** 	midiOutputBank1,
 931:WTPA.c        **** 	sdStreamOutput;		// Contribution to DAC coming directly off the SD card
 932:WTPA.c        **** 
 933:WTPA.c        **** static unsigned char
 934:WTPA.c        **** 	lastDacByte;	// Very possible we haven't changed output values since last time (like for instance 
 935:WTPA.c        **** 
 936:WTPA.c        **** static void OutputMultiplyBanks(void)
 937:WTPA.c        **** // Multiply the audio output of banks0 and 1 and spit it out
 938:WTPA.c        **** {
 1659               		.loc 1 938 0
 1660               		.cfi_startproc
 1661               	/* prologue: function */
 1662               	/* frame size = 0 */
 1663               	/* stack size = 0 */
 1664               	.L__stack_usage = 0
 939:WTPA.c        **** 	signed int
 940:WTPA.c        **** 		sum0,			// Temporary variables for saturated adds, multiplies, other math.
 941:WTPA.c        **** 		sum1;
 942:WTPA.c        **** 
 943:WTPA.c        **** 	unsigned char
 944:WTPA.c        **** 		output;			// What to put on the DAC
 945:WTPA.c        **** 
 946:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1665               		.loc 1 946 0
 1666 0ee0 8091 0000 		lds r24,extIsrOutputBank0
 1667 0ee4 2091 0000 		lds r18,midiOutputBank0
 1668 0ee8 3327      		clr r19
 1669 0eea 27FD      		sbrc r18,7
 1670 0eec 3095      		com r19
 1671 0eee 280F      		add r18,r24
 1672 0ef0 311D      		adc r19,__zero_reg__
 1673 0ef2 87FD      		sbrc r24,7
 1674 0ef4 3A95      		dec r19
 1675 0ef6 2038      		cpi r18,-128
 1676 0ef8 4FEF      		ldi r20,-1
 1677 0efa 3407      		cpc r19,r20
 1678 0efc 04F4      		brge .L104
 1679 0efe 20E8      		ldi r18,lo8(-128)
 1680 0f00 3FEF      		ldi r19,lo8(-1)
 1681               	.L104:
 1682               	.LVL36:
 947:WTPA.c        **** 	if(sum0>127)		// Pin high.
 948:WTPA.c        **** 	{
 949:WTPA.c        **** 		sum0=127;
 950:WTPA.c        **** 	}
 951:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
 952:WTPA.c        **** 	{
 953:WTPA.c        **** 		sum0=-128;
 954:WTPA.c        **** 	}
 955:WTPA.c        **** 
 956:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1683               		.loc 1 956 0
 1684 0f02 4091 0000 		lds r20,extIsrOutputBank1
 1685 0f06 8091 0000 		lds r24,midiOutputBank1
 1686 0f0a 9927      		clr r25
 1687 0f0c 87FD      		sbrc r24,7
 1688 0f0e 9095      		com r25
 1689 0f10 840F      		add r24,r20
 1690 0f12 911D      		adc r25,__zero_reg__
 1691 0f14 47FD      		sbrc r20,7
 1692 0f16 9A95      		dec r25
 1693 0f18 8138      		cpi r24,-127
 1694 0f1a 4FEF      		ldi r20,-1
 1695 0f1c 9407      		cpc r25,r20
 1696 0f1e 04F4      		brge .L105
 1697 0f20 81E8      		ldi r24,lo8(-127)
 1698 0f22 9FEF      		ldi r25,lo8(-1)
 1699               	.L105:
 1700               	.LVL37:
 957:WTPA.c        **** 	if(sum1>127)		// Pin high.
 958:WTPA.c        **** 	{
 959:WTPA.c        **** 		sum1=127;
 960:WTPA.c        **** 	}
 961:WTPA.c        **** 	else if(sum1<-127)		// Pin low.  (was pegged to -128)
 962:WTPA.c        **** 	{
 963:WTPA.c        **** 		sum1=-127;
 964:WTPA.c        **** 	}
 965:WTPA.c        **** 
 966:WTPA.c        **** 	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale ou
 1701               		.loc 1 966 0
 1702 0f24 2038      		cpi r18,-128
 1703 0f26 3105      		cpc r19,__zero_reg__
 1704 0f28 04F0      		brlt .L106
 1705 0f2a 2FE7      		ldi r18,lo8(127)
 1706 0f2c 30E0      		ldi r19,0
 1707               	.LVL38:
 1708               	.L106:
 1709 0f2e 8038      		cpi r24,-128
 1710 0f30 9105      		cpc r25,__zero_reg__
 1711 0f32 04F0      		brlt .L107
 1712 0f34 8FE7      		ldi r24,lo8(127)
 1713 0f36 90E0      		ldi r25,0
 1714               	.LVL39:
 1715               	.L107:
 1716 0f38 289F      		mul r18,r24
 1717 0f3a A001      		movw r20,r0
 1718 0f3c 299F      		mul r18,r25
 1719 0f3e 500D      		add r21,r0
 1720 0f40 389F      		mul r19,r24
 1721 0f42 500D      		add r21,r0
 1722 0f44 1124      		clr r1
 1723 0f46 57FF      		sbrs r21,7
 1724 0f48 00C0      		rjmp .L108
 1725 0f4a 415C      		subi r20,-63
 1726 0f4c 5F4F      		sbci r21,-1
 1727               	.L108:
 1728 0f4e CA01      		movw r24,r20
 1729 0f50 46E0      		ldi r20,6
 1730               		1:
 1731 0f52 9595      		asr r25
 1732 0f54 8795      		ror r24
 1733 0f56 4A95      		dec r20
 1734 0f58 01F4      		brne 1b
 967:WTPA.c        **** 
 968:WTPA.c        **** //@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the re
 969:WTPA.c        **** //@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide 
 970:WTPA.c        **** 
 971:WTPA.c        **** 	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
 1735               		.loc 1 971 0
 1736 0f5a 8058      		subi r24,128
 1737 0f5c 9095      		com r25
 1738 0f5e 282F      		mov r18,r24
 1739               	.LVL40:
 972:WTPA.c        **** 
 973:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1740               		.loc 1 973 0
 1741 0f60 3091 0000 		lds r19,lastDacByte
 1742 0f64 8317      		cp r24,r19
 1743 0f66 01F0      		breq .L109
 974:WTPA.c        **** 	{
 975:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1744               		.loc 1 975 0
 1745 0f68 9FEF      		ldi r25,lo8(-1)
 1746 0f6a 94B9      		out 0x4,r25
 976:WTPA.c        **** 
 977:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1747               		.loc 1 977 0
 1748 0f6c 85B9      		out 0x5,r24
 978:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1749               		.loc 1 978 0
 1750 0f6e 159A      		sbi 0x2,5
 979:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1751               		.loc 1 979 0
 1752 0f70 1598      		cbi 0x2,5
 1753               	.L109:
 980:WTPA.c        **** 	}
 981:WTPA.c        **** 
 982:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1754               		.loc 1 982 0
 1755 0f72 2093 0000 		sts lastDacByte,r18
 1756 0f76 0895      		ret
 1757               		.cfi_endproc
 1758               	.LFE3:
 1761               	OutputAddBanks:
 1762               	.LFB4:
 983:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
 984:WTPA.c        **** }
 985:WTPA.c        **** 
 986:WTPA.c        **** static void OutputAddBanks(void)
 987:WTPA.c        **** // Add audio from the two banks and spit it out (normally what we do)
 988:WTPA.c        **** {
 1763               		.loc 1 988 0
 1764               		.cfi_startproc
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 0 */
 1768               	.L__stack_usage = 0
 989:WTPA.c        **** 	signed int
 990:WTPA.c        **** 		sum0;				// Temporary variables for saturated adds, multiplies, other math.
 991:WTPA.c        **** 
 992:WTPA.c        **** 	unsigned char
 993:WTPA.c        **** 		output;			// What to put on the DAC
 994:WTPA.c        **** 
 995:WTPA.c        **** //	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everythi
 996:WTPA.c        **** 	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum e
 1769               		.loc 1 996 0
 1770 0f78 2091 0000 		lds r18,extIsrOutputBank0
 1771 0f7c 8091 0000 		lds r24,extIsrOutputBank1
 1772 0f80 9927      		clr r25
 1773 0f82 87FD      		sbrc r24,7
 1774 0f84 9095      		com r25
 1775 0f86 820F      		add r24,r18
 1776 0f88 911D      		adc r25,__zero_reg__
 1777 0f8a 27FD      		sbrc r18,7
 1778 0f8c 9A95      		dec r25
 1779 0f8e 2091 0000 		lds r18,midiOutputBank0
 1780 0f92 820F      		add r24,r18
 1781 0f94 911D      		adc r25,__zero_reg__
 1782 0f96 27FD      		sbrc r18,7
 1783 0f98 9A95      		dec r25
 1784 0f9a 2091 0000 		lds r18,midiOutputBank1
 1785 0f9e 820F      		add r24,r18
 1786 0fa0 911D      		adc r25,__zero_reg__
 1787 0fa2 27FD      		sbrc r18,7
 1788 0fa4 9A95      		dec r25
 1789 0fa6 2091 0000 		lds r18,sdStreamOutput
 1790 0faa 820F      		add r24,r18
 1791 0fac 911D      		adc r25,__zero_reg__
 1792 0fae 27FD      		sbrc r18,7
 1793 0fb0 9A95      		dec r25
 1794 0fb2 8038      		cpi r24,-128
 1795 0fb4 2FEF      		ldi r18,-1
 1796 0fb6 9207      		cpc r25,r18
 1797 0fb8 04F4      		brge .L111
 1798 0fba 80E8      		ldi r24,lo8(-128)
 1799 0fbc 9FEF      		ldi r25,lo8(-1)
 1800               	.L111:
 1801               	.LVL41:
 997:WTPA.c        **** 	if(sum0>127)		// Pin high.
 998:WTPA.c        **** 	{
 999:WTPA.c        **** 		sum0=127;
1000:WTPA.c        **** 	}
1001:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1002:WTPA.c        **** 	{
1003:WTPA.c        **** 		sum0=-128;
1004:WTPA.c        **** 	}
1005:WTPA.c        **** 	output=(signed char)sum0;		// Cast back to 8 bits.
1006:WTPA.c        **** 	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
 1802               		.loc 1 1006 0
 1803 0fbe 8038      		cpi r24,-128
 1804 0fc0 9105      		cpc r25,__zero_reg__
 1805 0fc2 04F0      		brlt .L112
 1806 0fc4 8FE7      		ldi r24,lo8(127)
 1807 0fc6 90E0      		ldi r25,0
 1808               	.LVL42:
 1809               	.L112:
 1810 0fc8 8058      		subi r24,128
 1811 0fca 282F      		mov r18,r24
 1812               	.LVL43:
1007:WTPA.c        **** 
1008:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1813               		.loc 1 1008 0
 1814 0fcc 3091 0000 		lds r19,lastDacByte
 1815 0fd0 8317      		cp r24,r19
 1816 0fd2 01F0      		breq .L113
1009:WTPA.c        **** 	{
1010:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1817               		.loc 1 1010 0
 1818 0fd4 9FEF      		ldi r25,lo8(-1)
 1819 0fd6 94B9      		out 0x4,r25
1011:WTPA.c        **** 
1012:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1820               		.loc 1 1012 0
 1821 0fd8 85B9      		out 0x5,r24
1013:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1822               		.loc 1 1013 0
 1823 0fda 159A      		sbi 0x2,5
1014:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1824               		.loc 1 1014 0
 1825 0fdc 1598      		cbi 0x2,5
 1826               	.L113:
1015:WTPA.c        **** 	}
1016:WTPA.c        **** 
1017:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1827               		.loc 1 1017 0
 1828 0fde 2093 0000 		sts lastDacByte,r18
 1829 0fe2 0895      		ret
 1830               		.cfi_endproc
 1831               	.LFE4:
 1834               	OutputXorBanks:
 1835               	.LFB5:
1018:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1019:WTPA.c        **** }
1020:WTPA.c        **** 
1021:WTPA.c        **** static void OutputXorBanks(void)
1022:WTPA.c        **** // Performs a bitwise XOR and spits out the result
1023:WTPA.c        **** {
 1836               		.loc 1 1023 0
 1837               		.cfi_startproc
 1838               	/* prologue: function */
 1839               	/* frame size = 0 */
 1840               	/* stack size = 0 */
 1841               	.L__stack_usage = 0
1024:WTPA.c        **** 	signed int
1025:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1026:WTPA.c        **** 		sum1;
1027:WTPA.c        **** 
1028:WTPA.c        **** 	unsigned char
1029:WTPA.c        **** 		output;			// What to put on the DAC
1030:WTPA.c        **** 
1031:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1842               		.loc 1 1031 0
 1843 0fe4 2091 0000 		lds r18,extIsrOutputBank0
 1844 0fe8 8091 0000 		lds r24,midiOutputBank0
 1845 0fec 9927      		clr r25
 1846 0fee 87FD      		sbrc r24,7
 1847 0ff0 9095      		com r25
 1848 0ff2 820F      		add r24,r18
 1849 0ff4 911D      		adc r25,__zero_reg__
 1850 0ff6 27FD      		sbrc r18,7
 1851 0ff8 9A95      		dec r25
 1852 0ffa 8038      		cpi r24,-128
 1853 0ffc 2FEF      		ldi r18,-1
 1854 0ffe 9207      		cpc r25,r18
 1855 1000 04F4      		brge .L115
 1856 1002 80E8      		ldi r24,lo8(-128)
 1857 1004 9FEF      		ldi r25,lo8(-1)
 1858               	.L115:
 1859               	.LVL44:
1032:WTPA.c        **** 	if(sum0>127)		// Pin high.
1033:WTPA.c        **** 	{
1034:WTPA.c        **** 		sum0=127;
1035:WTPA.c        **** 	}
1036:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1037:WTPA.c        **** 	{
1038:WTPA.c        **** 		sum0=-128;
1039:WTPA.c        **** 	}
1040:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1860               		.loc 1 1040 0
 1861 1006 4091 0000 		lds r20,extIsrOutputBank1
 1862 100a 2091 0000 		lds r18,midiOutputBank1
 1863 100e 3327      		clr r19
 1864 1010 27FD      		sbrc r18,7
 1865 1012 3095      		com r19
 1866 1014 240F      		add r18,r20
 1867 1016 311D      		adc r19,__zero_reg__
 1868 1018 47FD      		sbrc r20,7
 1869 101a 3A95      		dec r19
 1870 101c 2038      		cpi r18,-128
 1871 101e 4FEF      		ldi r20,-1
 1872 1020 3407      		cpc r19,r20
 1873 1022 04F4      		brge .L116
 1874 1024 20E8      		ldi r18,lo8(-128)
 1875 1026 3FEF      		ldi r19,lo8(-1)
 1876               	.L116:
 1877               	.LVL45:
1041:WTPA.c        **** 	if(sum1>127)		// Pin high.
1042:WTPA.c        **** 	{
1043:WTPA.c        **** 		sum1=127;
1044:WTPA.c        **** 	}
1045:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1046:WTPA.c        **** 	{
1047:WTPA.c        **** 		sum1=-128;
1048:WTPA.c        **** 	}
1049:WTPA.c        **** 	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1878               		.loc 1 1049 0
 1879 1028 2038      		cpi r18,-128
 1880 102a 3105      		cpc r19,__zero_reg__
 1881 102c 04F0      		brlt .L117
 1882 102e 2FE7      		ldi r18,lo8(127)
 1883 1030 30E0      		ldi r19,0
 1884               	.LVL46:
 1885               	.L117:
 1886 1032 2058      		subi r18,128
 1887 1034 3095      		com r19
 1888 1036 8038      		cpi r24,-128
 1889 1038 9105      		cpc r25,__zero_reg__
 1890 103a 04F0      		brlt .L118
 1891 103c 8FE7      		ldi r24,lo8(127)
 1892 103e 90E0      		ldi r25,0
 1893               	.LVL47:
 1894               	.L118:
 1895 1040 8058      		subi r24,128
 1896 1042 9095      		com r25
 1897 1044 8227      		eor r24,r18
 1898               	.LVL48:
1050:WTPA.c        **** 
1051:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1899               		.loc 1 1051 0
 1900 1046 9091 0000 		lds r25,lastDacByte
 1901 104a 8917      		cp r24,r25
 1902 104c 01F0      		breq .L119
1052:WTPA.c        **** 	{
1053:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1903               		.loc 1 1053 0
 1904 104e 9FEF      		ldi r25,lo8(-1)
 1905 1050 94B9      		out 0x4,r25
1054:WTPA.c        **** 
1055:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1906               		.loc 1 1055 0
 1907 1052 85B9      		out 0x5,r24
1056:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1908               		.loc 1 1056 0
 1909 1054 159A      		sbi 0x2,5
1057:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1910               		.loc 1 1057 0
 1911 1056 1598      		cbi 0x2,5
 1912               	.L119:
1058:WTPA.c        **** 	}
1059:WTPA.c        **** 
1060:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1913               		.loc 1 1060 0
 1914 1058 8093 0000 		sts lastDacByte,r24
 1915 105c 0895      		ret
 1916               		.cfi_endproc
 1917               	.LFE5:
 1920               	OutputAndBanks:
 1921               	.LFB6:
1061:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1062:WTPA.c        **** }
1063:WTPA.c        **** 
1064:WTPA.c        **** static void OutputAndBanks(void)
1065:WTPA.c        **** // Performs a bitwise AND and spits out the result
1066:WTPA.c        **** {
 1922               		.loc 1 1066 0
 1923               		.cfi_startproc
 1924               	/* prologue: function */
 1925               	/* frame size = 0 */
 1926               	/* stack size = 0 */
 1927               	.L__stack_usage = 0
1067:WTPA.c        **** 	signed int
1068:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1069:WTPA.c        **** 		sum1;
1070:WTPA.c        **** 
1071:WTPA.c        **** 	unsigned char
1072:WTPA.c        **** 		output;			// What to put on the DAC
1073:WTPA.c        **** 
1074:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1928               		.loc 1 1074 0
 1929 105e 2091 0000 		lds r18,extIsrOutputBank0
 1930 1062 8091 0000 		lds r24,midiOutputBank0
 1931 1066 9927      		clr r25
 1932 1068 87FD      		sbrc r24,7
 1933 106a 9095      		com r25
 1934 106c 820F      		add r24,r18
 1935 106e 911D      		adc r25,__zero_reg__
 1936 1070 27FD      		sbrc r18,7
 1937 1072 9A95      		dec r25
 1938 1074 8038      		cpi r24,-128
 1939 1076 2FEF      		ldi r18,-1
 1940 1078 9207      		cpc r25,r18
 1941 107a 04F4      		brge .L121
 1942 107c 80E8      		ldi r24,lo8(-128)
 1943 107e 9FEF      		ldi r25,lo8(-1)
 1944               	.L121:
 1945               	.LVL49:
1075:WTPA.c        **** 	if(sum0>127)		// Pin high.
1076:WTPA.c        **** 	{
1077:WTPA.c        **** 		sum0=127;
1078:WTPA.c        **** 	}
1079:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1080:WTPA.c        **** 	{
1081:WTPA.c        **** 		sum0=-128;
1082:WTPA.c        **** 	}
1083:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1946               		.loc 1 1083 0
 1947 1080 4091 0000 		lds r20,extIsrOutputBank1
 1948 1084 2091 0000 		lds r18,midiOutputBank1
 1949 1088 3327      		clr r19
 1950 108a 27FD      		sbrc r18,7
 1951 108c 3095      		com r19
 1952 108e 240F      		add r18,r20
 1953 1090 311D      		adc r19,__zero_reg__
 1954 1092 47FD      		sbrc r20,7
 1955 1094 3A95      		dec r19
 1956 1096 2038      		cpi r18,-128
 1957 1098 4FEF      		ldi r20,-1
 1958 109a 3407      		cpc r19,r20
 1959 109c 04F4      		brge .L122
 1960 109e 20E8      		ldi r18,lo8(-128)
 1961 10a0 3FEF      		ldi r19,lo8(-1)
 1962               	.L122:
 1963               	.LVL50:
1084:WTPA.c        **** 	if(sum1>127)		// Pin high.
1085:WTPA.c        **** 	{
1086:WTPA.c        **** 		sum1=127;
1087:WTPA.c        **** 	}
1088:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1089:WTPA.c        **** 	{
1090:WTPA.c        **** 		sum1=-128;
1091:WTPA.c        **** 	}
1092:WTPA.c        **** 	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 1964               		.loc 1 1092 0
 1965 10a2 2038      		cpi r18,-128
 1966 10a4 3105      		cpc r19,__zero_reg__
 1967 10a6 04F0      		brlt .L123
 1968 10a8 2FE7      		ldi r18,lo8(127)
 1969 10aa 30E0      		ldi r19,0
 1970               	.LVL51:
 1971               	.L123:
 1972 10ac 2058      		subi r18,128
 1973 10ae 3095      		com r19
 1974 10b0 8038      		cpi r24,-128
 1975 10b2 9105      		cpc r25,__zero_reg__
 1976 10b4 04F0      		brlt .L124
 1977 10b6 8FE7      		ldi r24,lo8(127)
 1978 10b8 90E0      		ldi r25,0
 1979               	.LVL52:
 1980               	.L124:
 1981 10ba 8058      		subi r24,128
 1982 10bc 9095      		com r25
 1983 10be 8223      		and r24,r18
 1984               	.LVL53:
1093:WTPA.c        **** 
1094:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1985               		.loc 1 1094 0
 1986 10c0 9091 0000 		lds r25,lastDacByte
 1987 10c4 8917      		cp r24,r25
 1988 10c6 01F0      		breq .L125
1095:WTPA.c        **** 	{
1096:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1989               		.loc 1 1096 0
 1990 10c8 9FEF      		ldi r25,lo8(-1)
 1991 10ca 94B9      		out 0x4,r25
1097:WTPA.c        **** 
1098:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1992               		.loc 1 1098 0
 1993 10cc 85B9      		out 0x5,r24
1099:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1994               		.loc 1 1099 0
 1995 10ce 159A      		sbi 0x2,5
1100:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1996               		.loc 1 1100 0
 1997 10d0 1598      		cbi 0x2,5
 1998               	.L125:
1101:WTPA.c        **** 	}
1102:WTPA.c        **** 
1103:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1999               		.loc 1 1103 0
 2000 10d2 8093 0000 		sts lastDacByte,r24
 2001 10d6 0895      		ret
 2002               		.cfi_endproc
 2003               	.LFE6:
 2006               	WriteLedLatch:
 2007               	.LFB20:
1104:WTPA.c        **** //	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
1105:WTPA.c        **** }
1106:WTPA.c        **** //-----------------------------------------------------------------------------
1107:WTPA.c        **** //-----------------------------------------------------------------------------
1108:WTPA.c        **** // Interrupt Vectors:
1109:WTPA.c        **** // These handle updating audio in the different banks (and the dumb LED intro)
1110:WTPA.c        **** //-----------------------------------------------------------------------------
1111:WTPA.c        **** //-----------------------------------------------------------------------------
1112:WTPA.c        **** 
1113:WTPA.c        **** ISR(TIMER1_CAPT_vect)
1114:WTPA.c        **** // The vector triggered by an external clock edge and associated with Bank0
1115:WTPA.c        **** {
1116:WTPA.c        **** 	static bool
1117:WTPA.c        **** 		flipFlop;		// Used for half-time
1118:WTPA.c        **** 
1119:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1120:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1121:WTPA.c        **** 	{
1122:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
1123:WTPA.c        **** 	}
1124:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1125:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1126:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1127:WTPA.c        **** 	{
1128:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1129:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1130:WTPA.c        **** 	}
1131:WTPA.c        **** }
1132:WTPA.c        **** 
1133:WTPA.c        **** ISR(PCINT2_vect)
1134:WTPA.c        **** // The vector triggered by a pin change and associated with Bank1
1135:WTPA.c        **** // It's on PC4
1136:WTPA.c        **** {
1137:WTPA.c        **** 	static bool
1138:WTPA.c        **** 		flipFlop;		// Used for half-time
1139:WTPA.c        **** 
1140:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1141:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1142:WTPA.c        **** 	{
1143:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
1144:WTPA.c        **** 	}
1145:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1146:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1147:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1148:WTPA.c        **** 	{
1149:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1150:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1151:WTPA.c        **** 	}
1152:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
1153:WTPA.c        **** 
1154:WTPA.c        **** // Mon May 23 16:06:37 EDT 2011
1155:WTPA.c        **** // With new hardware (relaxation osc and pulse shaper) we removed the level check above.  The clock
1156:WTPA.c        **** // However, we will need to clear the pin-change interrupt flag, since it may get set again about t
1157:WTPA.c        **** // Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and 
1158:WTPA.c        **** 
1159:WTPA.c        **** // Fri Jun 24 11:20:40 EDT 2011
1160:WTPA.c        **** // They're more like 5uS now, but still plenty short
1161:WTPA.c        **** }
1162:WTPA.c        **** 
1163:WTPA.c        **** ISR(TIMER1_COMPA_vect)
1164:WTPA.c        **** // The bank0 internal timer vectors here on an interrupt.
1165:WTPA.c        **** {
1166:WTPA.c        **** 	unsigned long
1167:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1168:WTPA.c        **** 	static unsigned int
1169:WTPA.c        **** 		lastJitterValue;
1170:WTPA.c        **** 	static bool
1171:WTPA.c        **** 		flipFlop;		// Used for half-time
1172:WTPA.c        **** 
1173:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1174:WTPA.c        **** 
1175:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1176:WTPA.c        **** 	{
1177:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
1178:WTPA.c        **** 	}
1179:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
1180:WTPA.c        **** 	{
1181:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
1182:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1183:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1184:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1185:WTPA.c        **** 	}
1186:WTPA.c        **** 	else
1187:WTPA.c        **** 	{
1188:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1189:WTPA.c        **** 	}
1190:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1191:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1192:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1193:WTPA.c        **** 	{
1194:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1195:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1196:WTPA.c        **** 	}
1197:WTPA.c        **** }
1198:WTPA.c        **** 
1199:WTPA.c        **** ISR(TIMER1_COMPB_vect)
1200:WTPA.c        **** // The interrupt associated with bank1 when it's using internal interrupts goes here.
1201:WTPA.c        **** {
1202:WTPA.c        **** 	unsigned long
1203:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1204:WTPA.c        **** 	static unsigned int
1205:WTPA.c        **** 		lastJitterValue;
1206:WTPA.c        **** 	static bool
1207:WTPA.c        **** 		flipFlop;		// Used for half-time
1208:WTPA.c        **** 
1209:WTPA.c        **** //	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
1210:WTPA.c        **** 
1211:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1212:WTPA.c        **** 	{
1213:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
1214:WTPA.c        **** 	}
1215:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
1216:WTPA.c        **** 	{
1217:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
1218:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1219:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1220:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1221:WTPA.c        **** 	}
1222:WTPA.c        **** 	else
1223:WTPA.c        **** 	{
1224:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1225:WTPA.c        **** 	}
1226:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1227:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1228:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1229:WTPA.c        **** 	{
1230:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1231:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1232:WTPA.c        **** 	}
1233:WTPA.c        **** }
1234:WTPA.c        **** 
1235:WTPA.c        **** ISR(TIMER2_COMPB_vect)
1236:WTPA.c        **** // This interrupt handles data in the SD buffer and doing what needs to be done with it.
1237:WTPA.c        **** // This includes direct playback from the SD card, writing SD data to the ram banks, and reading ra
1238:WTPA.c        **** // When writing/reading RAM, the bank in question should be locked against other RAM accesses.
1239:WTPA.c        **** {
1240:WTPA.c        **** 	unsigned char
1241:WTPA.c        **** 		theByte;
1242:WTPA.c        **** 
1243:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
1244:WTPA.c        **** 	{
1245:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1246:WTPA.c        **** 		{
1247:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1248:WTPA.c        **** 			{
1249:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1250:WTPA.c        **** 
1251:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1252:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1253:WTPA.c        **** 				{
1254:WTPA.c        **** 					sdFifoReadPointer=0;
1255:WTPA.c        **** 				}
1256:WTPA.c        **** 
1257:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1258:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1259:WTPA.c        **** 
1260:WTPA.c        **** 				// Now put this byte into the RAM bank in the correct address.
1261:WTPA.c        **** 
1262:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
1263:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
1264:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
1265:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
1266:WTPA.c        **** 
1267:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
1268:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
1269:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
1270:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
1271:WTPA.c        **** 
1272:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
1273:WTPA.c        **** 
1274:WTPA.c        **** 				// Compute address while bus settles.
1275:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
1276:WTPA.c        **** 				{
1277:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1278:WTPA.c        **** 				}
1279:WTPA.c        **** 				else
1280:WTPA.c        **** 				{
1281:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1282:WTPA.c        **** 				}
1283:WTPA.c        **** 
1284:WTPA.c        **** 				// Finish writing to RAM.
1285:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
1286:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
1287:WTPA.c        **** 
1288:WTPA.c        **** 			}
1289:WTPA.c        **** 		}
1290:WTPA.c        **** 		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current 
1291:WTPA.c        **** 		{
1292:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1293:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1294:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1295:WTPA.c        **** 
1296:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
1297:WTPA.c        **** 			{
1298:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
1299:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1300:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1301:WTPA.c        **** 			}
1302:WTPA.c        **** 			else
1303:WTPA.c        **** 			{
1304:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
1305:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1306:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1307:WTPA.c        **** 			}
1308:WTPA.c        **** 		}
1309:WTPA.c        **** 	}
1310:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
1311:WTPA.c        **** 	{
1312:WTPA.c        **** 		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pau
1313:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
1314:WTPA.c        **** 		{
1315:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
1316:WTPA.c        **** 			{
1317:WTPA.c        **** 				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
1318:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
1319:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
1320:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
1321:WTPA.c        **** 
1322:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
1323:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
1324:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
1325:WTPA.c        **** 
1326:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
1327:WTPA.c        **** 
1328:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
1329:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
1330:WTPA.c        **** 
1331:WTPA.c        **** 				// Calculate new addy while data bus settles
1332:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
1333:WTPA.c        **** 				{
1334:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1335:WTPA.c        **** 				}
1336:WTPA.c        **** 				else
1337:WTPA.c        **** 				{
1338:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1339:WTPA.c        **** 				}
1340:WTPA.c        **** 
1341:WTPA.c        **** 				// Finish getting the byte from RAM.
1342:WTPA.c        **** 
1343:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
1344:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
1345:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
1346:WTPA.c        **** 
1347:WTPA.c        **** 				// Now put this byte from RAM into the sd fifo
1348:WTPA.c        **** 
1349:WTPA.c        **** 
1350:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
1351:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
1352:WTPA.c        **** 
1353:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
1354:WTPA.c        **** 				{
1355:WTPA.c        **** 					sdFifoWritePointer=0;
1356:WTPA.c        **** 				}
1357:WTPA.c        **** 
1358:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
1359:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
1360:WTPA.c        **** 
1361:WTPA.c        **** 			}
1362:WTPA.c        **** 			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank fo
1363:WTPA.c        **** 			{
1364:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1365:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
1366:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1367:WTPA.c        **** 
1368:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
1369:WTPA.c        **** 				{
1370:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
1371:WTPA.c        **** 				}
1372:WTPA.c        **** 				else
1373:WTPA.c        **** 				{
1374:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
1375:WTPA.c        **** 				}
1376:WTPA.c        **** 			}
1377:WTPA.c        **** 		}
1378:WTPA.c        **** 	}
1379:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
1380:WTPA.c        **** 	{
1381:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1382:WTPA.c        **** 		{
1383:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1384:WTPA.c        **** 			{
1385:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1386:WTPA.c        **** 
1387:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1388:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1389:WTPA.c        **** 				{
1390:WTPA.c        **** 					sdFifoReadPointer=0;
1391:WTPA.c        **** 				}
1392:WTPA.c        **** 
1393:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1394:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1395:WTPA.c        **** 
1396:WTPA.c        **** 				// Now spit the byte out the DAC.
1397:WTPA.c        **** 
1398:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
1399:WTPA.c        **** 				UpdateOutput();				// Update the DAC
1400:WTPA.c        **** 			}
1401:WTPA.c        **** 		}
1402:WTPA.c        **** 		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
1403:WTPA.c        **** 		{
1404:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1405:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1406:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1407:WTPA.c        **** 
1408:WTPA.c        **** 			// Set this contribution to the DAC to midscale (this output source is now quiet)
1409:WTPA.c        **** 			sdStreamOutput=0;
1410:WTPA.c        **** 		}
1411:WTPA.c        **** 	}
1412:WTPA.c        **** }
1413:WTPA.c        **** 
1414:WTPA.c        **** ISR(TIMER2_COMPA_vect)
1415:WTPA.c        **** // Serves exclusively to make our gay intro happen
1416:WTPA.c        **** // As far as the PWM goes, this should happen as often as possible.
1417:WTPA.c        **** {
1418:WTPA.c        **** 	static unsigned char
1419:WTPA.c        **** 		pwmCount;
1420:WTPA.c        **** 
1421:WTPA.c        **** 	if(ledPwm>pwmCount)
1422:WTPA.c        **** 	{
1423:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
1424:WTPA.c        **** 	}
1425:WTPA.c        **** 	else
1426:WTPA.c        **** 	{
1427:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
1428:WTPA.c        **** 	}
1429:WTPA.c        **** 	pwmCount++;
1430:WTPA.c        **** }
1431:WTPA.c        **** 
1432:WTPA.c        **** ISR(__vector_default)
1433:WTPA.c        **** {
1434:WTPA.c        ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
1435:WTPA.c        **** 	//	printf("Buggy Interrupt Generated!  Flags = ");
1436:WTPA.c        **** 	//  printf("*****put interrupt register values here****");
1437:WTPA.c        **** }
1438:WTPA.c        **** 
1439:WTPA.c        **** //-----------------------------------------------------------------------
1440:WTPA.c        **** //-----------------------------------------------------------------------
1441:WTPA.c        **** // State Machine Functions.
1442:WTPA.c        **** //-----------------------------------------------------------------------
1443:WTPA.c        **** //-----------------------------------------------------------------------
1444:WTPA.c        **** 
1445:WTPA.c        **** static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should be
1446:WTPA.c        **** {
1447:WTPA.c        **** 	State=newState;
1448:WTPA.c        **** 	subState=SS_0;
1449:WTPA.c        **** }
1450:WTPA.c        **** 
1451:WTPA.c        **** //-----------------------------------------------------------------------
1452:WTPA.c        **** //-----------------------------------------------------------------------
1453:WTPA.c        **** // Local Software Clock stuff.
1454:WTPA.c        **** //-----------------------------------------------------------------------
1455:WTPA.c        **** //-----------------------------------------------------------------------
1456:WTPA.c        **** 
1457:WTPA.c        **** void HandleSoftclock(void)
1458:WTPA.c        **** {
1459:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
1460:WTPA.c        **** 	{
1461:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
1462:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
1463:WTPA.c        **** 	}
1464:WTPA.c        **** }
1465:WTPA.c        **** 
1466:WTPA.c        **** static void InitSoftclock(void)
1467:WTPA.c        **** // Wed Dec  3 22:28:06 CST 2008
1468:WTPA.c        **** // I've changed the way the softclock works from the last rev.  It's no longer and interrupt based 
1469:WTPA.c        **** // Also, since hardware TIMR1 is needed for bigger and better things than keeping human-time, we're
1470:WTPA.c        **** // This means we don't steal cycles from any other ISRs, but it also means that if we write dumb co
1471:WTPA.c        **** // we might miss a systemTick.
1472:WTPA.c        **** // NOTE:  w/ TMR0 running at 1/256 prescale at 20MHz, our smallest time unit is 3.2768mSecs.
1473:WTPA.c        **** // NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.
1474:WTPA.c        **** 
1475:WTPA.c        **** // With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing e
1476:WTPA.c        **** 
1477:WTPA.c        **** {
1478:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
1479:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
1480:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
1481:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
1482:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
1483:WTPA.c        **** 	systemTicks=0;
1484:WTPA.c        **** //	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
1485:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
1486:WTPA.c        **** }
1487:WTPA.c        **** 
1488:WTPA.c        **** //-----------------------------------------------------------------------
1489:WTPA.c        **** // LED functions:
1490:WTPA.c        **** //-----------------------------------------------------------------------
1491:WTPA.c        **** 
1492:WTPA.c        **** // Thu Apr  1 13:08:08 EDT 2010
1493:WTPA.c        **** // Changed blinking mechanisms to be smaller and blink fixed times, and also use fewer timer fcns
1494:WTPA.c        **** 
1495:WTPA.c        **** #define		BLINK_TIME			(SECOND/8)
1496:WTPA.c        **** 
1497:WTPA.c        **** static void BlinkLeds(unsigned int theMask)
1498:WTPA.c        **** // Sets up the mask of leds to blink and their blink rate.
1499:WTPA.c        **** // NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from
1500:WTPA.c        **** // NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when w
1501:WTPA.c        **** {
1502:WTPA.c        **** 	unsigned char
1503:WTPA.c        **** 		i;
1504:WTPA.c        **** 
1505:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
1506:WTPA.c        **** 	{
1507:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
1508:WTPA.c        **** 		{
1509:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
1510:WTPA.c        **** 		}
1511:WTPA.c        **** 	}
1512:WTPA.c        **** 
1513:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
1514:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
1515:WTPA.c        **** }
1516:WTPA.c        **** 
1517:WTPA.c        **** static void StopBlinking(void)
1518:WTPA.c        **** // Stops all blinking LEDs.
1519:WTPA.c        **** {
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1521:WTPA.c        **** }
1522:WTPA.c        **** 
1523:WTPA.c        **** static void KillLeds(void)
1524:WTPA.c        **** // Turns off all LEDs immediately.
1525:WTPA.c        **** {
1526:WTPA.c        **** 	ledOnOffMask=0;
1527:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1528:WTPA.c        **** }
1529:WTPA.c        **** 
1530:WTPA.c        **** static void WriteLedLatch(unsigned char theMask)
1531:WTPA.c        **** // Take the current on/off LED mask and put it onto the LED output latch.
1532:WTPA.c        **** // This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
1533:WTPA.c        **** {
 2008               		.loc 1 1533 0
 2009               		.cfi_startproc
 2010               	.LVL54:
 2011               	/* prologue: function */
 2012               	/* frame size = 0 */
 2013               	/* stack size = 0 */
 2014               	.L__stack_usage = 0
1534:WTPA.c        **** 	unsigned char
1535:WTPA.c        **** 		sreg;
1536:WTPA.c        **** 
1537:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 2015               		.loc 1 1537 0
 2016 10d8 9FB7      		in r25,__SREG__
 2017               	.LVL55:
1538:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 2018               		.loc 1 1538 0
 2019               	/* #APP */
 2020               	 ;  1538 "WTPA.c" 1
 2021 10da F894      		cli
 2022               	 ;  0 "" 2
1539:WTPA.c        **** 
1540:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 2023               		.loc 1 1540 0
 2024               	/* #NOAPP */
 2025 10dc 85B9      		out 0x5,r24
1541:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 2026               		.loc 1 1541 0
 2027 10de 8FEF      		ldi r24,lo8(-1)
 2028               	.LVL56:
 2029 10e0 84B9      		out 0x4,r24
1542:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 2030               		.loc 1 1542 0
 2031 10e2 5F9A      		sbi 0xb,7
1543:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 2032               		.loc 1 1543 0
 2033 10e4 5F98      		cbi 0xb,7
1544:WTPA.c        **** 
1545:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 2034               		.loc 1 1545 0
 2035 10e6 9FBF      		out __SREG__,r25
 2036 10e8 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE20:
 2041               	SdIsrStartStreamingAudio:
 2042               	.LFB46:
1546:WTPA.c        **** }
1547:WTPA.c        **** 
1548:WTPA.c        **** static void HandleLeds(void)
1549:WTPA.c        **** // Runs in the main loop updating the state of the LEDs.  Only messes with the databus when there's
1550:WTPA.c        **** {
1551:WTPA.c        **** 	unsigned char
1552:WTPA.c        **** 		i;
1553:WTPA.c        **** 	static bool
1554:WTPA.c        **** 		toggle;				// Flip flop for blinking.
1555:WTPA.c        **** 	static unsigned char
1556:WTPA.c        **** 		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.
1557:WTPA.c        **** 
1558:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
1559:WTPA.c        **** 	{
1560:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
1561:WTPA.c        **** 		{
1562:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
1563:WTPA.c        **** 			{
1564:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
1565:WTPA.c        **** 				{
1566:WTPA.c        **** 					ledOnOffMask|=(1<<i);
1567:WTPA.c        **** 				}
1568:WTPA.c        **** 				else
1569:WTPA.c        **** 				{
1570:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
1571:WTPA.c        **** 				}
1572:WTPA.c        **** 			}
1573:WTPA.c        **** 		}
1574:WTPA.c        **** 
1575:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
1576:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
1577:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
1578:WTPA.c        **** 	}
1579:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
1580:WTPA.c        **** 	{
1581:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
1582:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
1583:WTPA.c        **** 	}
1584:WTPA.c        **** }
1585:WTPA.c        **** 
1586:WTPA.c        **** static void InitLeds(void)
1587:WTPA.c        **** {
1588:WTPA.c        **** 	ledOnOffMask=0;
1589:WTPA.c        **** 	ledBlinkMask=0;
1590:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
1591:WTPA.c        **** }
1592:WTPA.c        **** 
1593:WTPA.c        **** //-----------------------------------------------------------------------
1594:WTPA.c        **** //-----------------------------------------------------------------------
1595:WTPA.c        **** // Switch functions:
1596:WTPA.c        **** //-----------------------------------------------------------------------
1597:WTPA.c        **** //-----------------------------------------------------------------------
1598:WTPA.c        **** 
1599:WTPA.c        **** static void InitSwitches(void)
1600:WTPA.c        **** {
1601:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
1602:WTPA.c        **** 
1603:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
1604:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
1605:WTPA.c        **** 
1606:WTPA.c        **** }
1607:WTPA.c        **** 
1608:WTPA.c        **** static void HandleSwitches(void)
1609:WTPA.c        **** // Read input pins, debounce, make keypresses positive-true, and flag newly-appeared keys.
1610:WTPA.c        **** // Make sure we've allowed enough time to turn the bus around.  The old RAM took a couple cycles be
1611:WTPA.c        **** {
1612:WTPA.c        **** 	static unsigned char
1613:WTPA.c        **** 		lastKeyState;
1614:WTPA.c        **** 	unsigned char
1615:WTPA.c        **** 		sreg;
1616:WTPA.c        **** 
1617:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
1618:WTPA.c        **** 	{
1619:WTPA.c        **** 		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
1620:WTPA.c        **** 		sreg=SREG;
1621:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
1622:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
1623:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
1624:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
1625:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
1626:WTPA.c        **** 		asm volatile("nop"::);
1627:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
1628:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
1629:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
1630:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
1631:WTPA.c        **** 
1632:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
1633:WTPA.c        **** 		{
1634:WTPA.c        **** 			cardDetect=true;
1635:WTPA.c        **** 		}
1636:WTPA.c        **** 		else
1637:WTPA.c        **** 		{
1638:WTPA.c        **** 			cardDetect=false;
1639:WTPA.c        **** 		}
1640:WTPA.c        **** 
1641:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
1642:WTPA.c        **** 	}
1643:WTPA.c        **** 
1644:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
1645:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
1646:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
1647:WTPA.c        **** }
1648:WTPA.c        **** 
1649:WTPA.c        **** //-----------------------------------------------------------------------
1650:WTPA.c        **** //-----------------------------------------------------------------------
1651:WTPA.c        **** // Encoder functions:
1652:WTPA.c        **** //-----------------------------------------------------------------------
1653:WTPA.c        **** //-----------------------------------------------------------------------
1654:WTPA.c        **** // The encoders I set this up with are 24 pulses per revolution.
1655:WTPA.c        **** // They are Bourns 652-PEC124230F-N0024, from Mouser.
1656:WTPA.c        **** // From the DS:  5mSec max bounce at 15RPM (waaay faster than we'll go) with "standard noise reduct
1657:WTPA.c        **** // This encoder (like most others) puts out 2 bit Gray code (where only one switch changes at a tim
1658:WTPA.c        **** 
1659:WTPA.c        **** // Thu Sep  2 15:04:47 EDT 2010
1660:WTPA.c        **** // OK.  More monkeying with reading the encoder shows us that a "pulse" is actually a transition of
1661:WTPA.c        **** // This is good (it means more resolution -- there are 4*24 readable transitions per revolution) bu
1662:WTPA.c        **** // Did this -- the encoder is really sensitive.  We still either miss reads or are getting switch b
1663:WTPA.c        **** 
1664:WTPA.c        **** // Thu Sep  2 16:39:43 EDT 2010 -- Added hardware filter from the panasonic datasheet.  Works a dre
1665:WTPA.c        **** 
1666:WTPA.c        **** // Encoder bit masks (dependent on port position)
1667:WTPA.c        **** #define	ENC_POS_A	0x00
1668:WTPA.c        **** #define	ENC_POS_B	0x40
1669:WTPA.c        **** #define	ENC_POS_C	0xC0
1670:WTPA.c        **** #define	ENC_POS_D	0x80
1671:WTPA.c        **** 
1672:WTPA.c        **** static void InitEncoder(void)
1673:WTPA.c        **** {
1674:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
1675:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
1676:WTPA.c        **** }
1677:WTPA.c        **** 
1678:WTPA.c        **** static void HandleEncoder(void)
1679:WTPA.c        **** // Fri Jun 24 11:29:53 EDT 2011
1680:WTPA.c        **** // Steps backwards from earlier prototype for some reason
1681:WTPA.c        **** {
1682:WTPA.c        **** 	static unsigned char
1683:WTPA.c        **** 		lastEncoderState=0;
1684:WTPA.c        **** 	static unsigned int
1685:WTPA.c        **** 		lastEncTime=0;
1686:WTPA.c        **** 
1687:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
1688:WTPA.c        **** 	{
1689:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
1690:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
1691:WTPA.c        **** 
1692:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
1693:WTPA.c        **** 		{
1694:WTPA.c        **** 			if(encoderState==ENC_POS_A)
1695:WTPA.c        **** 			{
1696:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
1697:WTPA.c        **** 				{
1698:WTPA.c        **** //					encoderValue++;
1699:WTPA.c        **** 					encoderValue--;
1700:WTPA.c        **** 				}
1701:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
1702:WTPA.c        **** 				{
1703:WTPA.c        **** //					encoderValue--;
1704:WTPA.c        **** 					encoderValue++;
1705:WTPA.c        **** 				}
1706:WTPA.c        **** 			}
1707:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
1708:WTPA.c        **** 			{
1709:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
1710:WTPA.c        **** 				{
1711:WTPA.c        **** //					encoderValue++;
1712:WTPA.c        **** 					encoderValue--;
1713:WTPA.c        **** 				}
1714:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
1715:WTPA.c        **** 				{
1716:WTPA.c        **** //					encoderValue--;
1717:WTPA.c        **** 					encoderValue++;
1718:WTPA.c        **** 				}
1719:WTPA.c        **** 			}
1720:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
1721:WTPA.c        **** 			{
1722:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
1723:WTPA.c        **** 				{
1724:WTPA.c        **** //					encoderValue++;
1725:WTPA.c        **** 					encoderValue--;
1726:WTPA.c        **** 				}
1727:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
1728:WTPA.c        **** 				{
1729:WTPA.c        **** //					encoderValue--;
1730:WTPA.c        **** 					encoderValue++;
1731:WTPA.c        **** 				}
1732:WTPA.c        **** 			}
1733:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
1734:WTPA.c        **** 			{
1735:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
1736:WTPA.c        **** 				{
1737:WTPA.c        **** //					encoderValue++;
1738:WTPA.c        **** 					encoderValue--;
1739:WTPA.c        **** 				}
1740:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
1741:WTPA.c        **** 				{
1742:WTPA.c        **** //					encoderValue--;
1743:WTPA.c        **** 					encoderValue++;
1744:WTPA.c        **** 				}
1745:WTPA.c        **** 			}
1746:WTPA.c        **** 
1747:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
1748:WTPA.c        **** 		}
1749:WTPA.c        **** 	}
1750:WTPA.c        **** }
1751:WTPA.c        **** 
1752:WTPA.c        **** //-----------------------------------------------------------------------
1753:WTPA.c        **** //-----------------------------------------------------------------------
1754:WTPA.c        **** // A/D Control Functions:
1755:WTPA.c        **** //-----------------------------------------------------------------------
1756:WTPA.c        **** //-----------------------------------------------------------------------
1757:WTPA.c        **** // WTPA2 uses only one analog input (ADC0).  It's used to sample the audio input.  In old versions 
1758:WTPA.c        **** // The best resolution we can get from this hardware is 10 bits, +/- 2 lsbs.
1759:WTPA.c        **** // The max sampling rate we can pull at full resolution is 15kHz.  We always use the ADC single end
1760:WTPA.c        **** // work in differential mode with the PDIP package.  A conversion takes 13 ADC clocks normally, or 
1761:WTPA.c        **** // The datasheet is unclear how much resolution is lost above 15kHz.  Guess we'll find out!
1762:WTPA.c        **** // NOTE:  Since the RAM can only store 8 bits per sample, we're only using 8 bits of the conversion
1763:WTPA.c        **** 
1764:WTPA.c        **** /*
1765:WTPA.c        **** static void UnInitAdc(void)
1766:WTPA.c        **** {
1767:WTPA.c        **** 	ADCSRA&=~(1<<ADEN);		// Disable ADC.
1768:WTPA.c        **** 	PRR|=(1<<PRADC);		// Power down the ADC.
1769:WTPA.c        **** }
1770:WTPA.c        **** */
1771:WTPA.c        **** 
1772:WTPA.c        **** static void InitAdc(void)
1773:WTPA.c        **** // Note, we don't set up the Adc to trigger on anything right away.
1774:WTPA.c        **** {
1775:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
1776:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
1777:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
1778:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
1779:WTPA.c        **** //	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the A
1780:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
1781:WTPA.c        **** 	// ADCSRB controls auto-triggering, which we aren't using right now.
1782:WTPA.c        **** }
1783:WTPA.c        **** 
1784:WTPA.c        **** //-----------------------------------------------------------------------
1785:WTPA.c        **** // RAM / DAC functions:
1786:WTPA.c        **** //-----------------------------------------------------------------------
1787:WTPA.c        **** 
1788:WTPA.c        **** // Fri Jun 17 19:11:18 EDT 2011
1789:WTPA.c        **** // As of WTPA2 these are all inlined where they need to go.  The notes below are for posterity
1790:WTPA.c        **** 
1791:WTPA.c        **** // Will be totally different than the oldschool serial biz.....
1792:WTPA.c        **** // Should probably all be inlined in the ISR.
1793:WTPA.c        **** // Just so you remember, Parallel SRAM pretty much always works like this:
1794:WTPA.c        **** 
1795:WTPA.c        **** // The chip is always enabled (CS is always low).  The other two control pins are active low also -
1796:WTPA.c        **** // When WE is low, the value on the DATA pins is latched into the address on the ADDRESS pins.  Ass
1797:WTPA.c        **** // When WE is high, the byte stored at the ADDRESS on pins A0-A18 is latched out on the DATA pins, 
1798:WTPA.c        **** // If OE is high, the DATA port will be high impedance no matter what.
1799:WTPA.c        **** // The ADDRESS pins can always be outputs as far as the MCU is concerned.
1800:WTPA.c        **** 
1801:WTPA.c        **** // A typical write might look like:
1802:WTPA.c        **** // 1.)  OE and WE are high.
1803:WTPA.c        **** // 2.)  The address is set and the data latches on the MCU are made into outputs. The correct value
1804:WTPA.c        **** // 3.)  WE is brought low and the data is latched in.
1805:WTPA.c        **** // 4.)  WE is brought high.  The address and data lines can now be changed without messing up data 
1806:WTPA.c        **** 
1807:WTPA.c        **** // A typical read might look like this:
1808:WTPA.c        **** // 1.)  OE and WE are high.
1809:WTPA.c        **** // 2.)  The address is set correctly and the DATA PORT on the MCU is made high impedance.
1810:WTPA.c        **** // 3.)  OE is brought low, and the data to be read shows up on the DATA lines.
1811:WTPA.c        **** // 4.)  The MCU reads the DATA lines.
1812:WTPA.c        **** // 5.)  OE can be brought high again or left low -- it only needs to change if we're going to write
1813:WTPA.c        **** 
1814:WTPA.c        **** // On 373 Parallel Latches:
1815:WTPA.c        **** // These guys are pretty simple.  In this circuit, their OE is tied low (enabled).
1816:WTPA.c        **** // While LE (Latch Enable) is High, the Latch is transparent from input port to output port.
1817:WTPA.c        **** // When LE is brought low, the current state of the inputs will be latched, and the outputs will th
1818:WTPA.c        **** // So, we will will probably just leave LE low most of the time on the latches and strobe it high w
1819:WTPA.c        **** 
1820:WTPA.c        **** 
1821:WTPA.c        **** 
1822:WTPA.c        **** //-----------------------------------------------------------------------
1823:WTPA.c        **** //-----------------------------------------------------------------------
1824:WTPA.c        **** // General Sampler/ISR Functions:
1825:WTPA.c        **** //-----------------------------------------------------------------------
1826:WTPA.c        **** //-----------------------------------------------------------------------
1827:WTPA.c        **** // We've changed these to use both OCR1x interrupts and the "normal" waveform generation mode (from
1828:WTPA.c        **** // 	This allows us to generate different pitches for the two banks using TIMER1.  We do this by rea
1829:WTPA.c        **** // 	that interrupt occurs.  The OCR value will keep rolling like this, the timer will never be rese
1830:WTPA.c        **** //  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrup
1831:WTPA.c        **** 
1832:WTPA.c        **** // Tue Aug 23 18:25:06 EDT 2011
1833:WTPA.c        **** // Updated these functions to clear the sdUsingBank(x) flags when these are called so the interrupt
1834:WTPA.c        **** 
1835:WTPA.c        **** // Thu Nov 24 19:22:24 CST 2011
1836:WTPA.c        **** // Updated to account for locking banks (removed above).  Necessary now because we can be screwing 
1837:WTPA.c        **** 
1838:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1839:WTPA.c        **** // This code is common to all the requests to start different audio modes (record, playback, overdu
1840:WTPA.c        **** // Timer interrupts should be disabled when you call this!
1841:WTPA.c        **** {
1842:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
1843:WTPA.c        **** 
1844:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
1845:WTPA.c        **** 	{
1846:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
1847:WTPA.c        **** 
1848:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
1849:WTPA.c        **** 		{
1850:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1851:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
1852:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
1853:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1854:WTPA.c        **** 		}
1855:WTPA.c        **** 		else					// Bank 1 is associated with OCR1B
1856:WTPA.c        **** 		{
1857:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1858:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
1859:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
1860:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1861:WTPA.c        **** 		}
1862:WTPA.c        **** 	}
1863:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
1864:WTPA.c        **** 	{
1865:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
1866:WTPA.c        **** 		{
1867:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
1868:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
1869:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
1870:WTPA.c        **** 		}
1871:WTPA.c        **** 		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC in
1872:WTPA.c        **** 		{
1873:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
1874:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
1875:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
1876:WTPA.c        **** 		}
1877:WTPA.c        **** 	}
1878:WTPA.c        **** }
1879:WTPA.c        **** 
1880:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1881:WTPA.c        **** // Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the re
1882:WTPA.c        **** // If we're using the internal clock, set the rate.
1883:WTPA.c        **** // Sat Apr 11 13:49:31 CDT 2009  --  ?
1884:WTPA.c        **** // Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow th
1885:WTPA.c        **** {
1886:WTPA.c        **** 
1887:WTPA.c        **** 	unsigned char
1888:WTPA.c        **** 		sreg;
1889:WTPA.c        **** 
1890:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1891:WTPA.c        **** 	{
1892:WTPA.c        **** 
1893:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1894:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1895:WTPA.c        **** 
1896:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
1897:WTPA.c        **** 
1898:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
1899:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
1900:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
1901:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
1902:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
1903:WTPA.c        **** 
1904:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
1905:WTPA.c        **** 
1906:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1907:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1908:WTPA.c        **** 
1909:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1910:WTPA.c        **** 
1911:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1912:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1913:WTPA.c        **** 		{
1914:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1915:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1916:WTPA.c        **** 		}
1917:WTPA.c        **** 	}
1918:WTPA.c        **** }
1919:WTPA.c        **** 
1920:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1921:WTPA.c        **** // Point to the beginning of the sample, select the clock source, and get the interrupts going.
1922:WTPA.c        **** // Set the clock rate if we're using the internal clock.
1923:WTPA.c        **** // Mon Jul  6 19:05:04 CDT 2009
1924:WTPA.c        **** // We've made it clear that the beginning of the sample is relative, in the sense that if we're pla
1925:WTPA.c        **** {
1926:WTPA.c        **** 	unsigned char
1927:WTPA.c        **** 		sreg;
1928:WTPA.c        **** 
1929:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1930:WTPA.c        **** 	{
1931:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1932:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1933:WTPA.c        **** 
1934:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
1935:WTPA.c        **** 
1936:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
1937:WTPA.c        **** 		{
1938:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
1939:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
1940:WTPA.c        **** 		}
1941:WTPA.c        **** 		else
1942:WTPA.c        **** 		{
1943:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
1944:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
1945:WTPA.c        **** 		}
1946:WTPA.c        **** 
1947:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1948:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1949:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1950:WTPA.c        **** 	}
1951:WTPA.c        **** }
1952:WTPA.c        **** 
1953:WTPA.c        **** static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1954:WTPA.c        **** // Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
1955:WTPA.c        **** // Used if we pause playback and want to continue where we left off, or stop overdubbing and jump r
1956:WTPA.c        **** {
1957:WTPA.c        **** 	unsigned char
1958:WTPA.c        **** 		sreg;
1959:WTPA.c        **** 
1960:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1961:WTPA.c        **** 	{
1962:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1963:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1964:WTPA.c        **** 
1965:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
1966:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1967:WTPA.c        **** 
1968:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1969:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1970:WTPA.c        **** 	}
1971:WTPA.c        **** }
1972:WTPA.c        **** 
1973:WTPA.c        **** static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1974:WTPA.c        **** // Begin recording to ram at the current RAM address.
1975:WTPA.c        **** // Continue playing back from that address, too.
1976:WTPA.c        **** {
1977:WTPA.c        **** 	unsigned char
1978:WTPA.c        **** 		sreg;
1979:WTPA.c        **** 
1980:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1981:WTPA.c        **** 	{
1982:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1983:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1984:WTPA.c        **** 
1985:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
1986:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
1987:WTPA.c        **** 
1988:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1989:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1990:WTPA.c        **** 
1991:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1992:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1993:WTPA.c        **** 		{
1994:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1995:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1996:WTPA.c        **** 		}
1997:WTPA.c        **** 	}
1998:WTPA.c        **** }
1999:WTPA.c        **** 
2000:WTPA.c        **** static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2001:WTPA.c        **** // Begins processing audio in realtime on the passed channel using the passed clock source.
2002:WTPA.c        **** // Thu Nov 24 19:40:21 CST 2011
2003:WTPA.c        **** // OK to do realtime even when banks are locked since we don't use the RAM
2004:WTPA.c        **** {
2005:WTPA.c        **** 	unsigned char
2006:WTPA.c        **** 		sreg;
2007:WTPA.c        **** 
2008:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
2009:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
2010:WTPA.c        **** 
2011:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
2012:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
2013:WTPA.c        **** 
2014:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
2015:WTPA.c        **** 
2016:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
2017:WTPA.c        **** 	{
2018:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
2019:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
2020:WTPA.c        **** 	}
2021:WTPA.c        **** }
2022:WTPA.c        **** 
2023:WTPA.c        **** /*
2024:WTPA.c        **** static void UnInitSampleClock(void)
2025:WTPA.c        **** {
2026:WTPA.c        **** 	PRR|=(1<<PRTIM1);	// Turn the TMR1 power off.
2027:WTPA.c        **** }
2028:WTPA.c        **** */
2029:WTPA.c        **** 
2030:WTPA.c        **** static void InitSampleClock(void)
2031:WTPA.c        **** // Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
2032:WTPA.c        **** // Or just turn it on so we can use the Input Capture pin to generate interrupts for the external c
2033:WTPA.c        **** {
2034:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
2035:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
2036:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
2037:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
2038:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
2039:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
2040:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
2041:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
2042:WTPA.c        **** }
2043:WTPA.c        **** 
2044:WTPA.c        **** 
2045:WTPA.c        **** //-----------------------------------------------------------------------
2046:WTPA.c        **** // SD Memory/Filesystem handling:
2047:WTPA.c        **** //-----------------------------------------------------------------------
2048:WTPA.c        **** // Fri Jun 17 19:13:12 EDT 2011
2049:WTPA.c        **** // Update the state of the uSD card.  Detect and initialize it when it needs that kind of thing.
2050:WTPA.c        **** // Keep track of card validity and when the card is being accessed, etc etc
2051:WTPA.c        **** // WTPA2 TOC:
2052:WTPA.c        **** // ====================
2053:WTPA.c        **** // Block 0:
2054:WTPA.c        **** // 4 	chars 		"WTPA"
2055:WTPA.c        **** // 12 	bytes 		don't care
2056:WTPA.c        **** // 64	bytes		Full/Empty sample slot info (512 bits which tell whether a sample is present or not in
2057:WTPA.c        **** // 432	bytes 		don't care
2058:WTPA.c        **** 
2059:WTPA.c        **** // Samples in SD-land:
2060:WTPA.c        **** // --------------------
2061:WTPA.c        **** // WTPA has a fifo in RAM which is 768 bytes long (1.5 blocks).
2062:WTPA.c        **** // Reading, we fill it a block (512 bytes) at a time.  When there is room for 512 bytes in the FIFO
2063:WTPA.c        **** // In order to not hang our state machine for two long, a fraction of a block is read at a time.  T
2064:WTPA.c        **** // Storing parameters works by storing the sample exactly as it is written to the DAC, meaning if t
2065:WTPA.c        **** // Likewise, reducing bit depth or editing a sample will mean the sample is permanently stored that
2066:WTPA.c        **** 
2067:WTPA.c        **** // Sample Format:
2068:WTPA.c        **** // ---------------
2069:WTPA.c        **** // Sample format is currently:
2070:WTPA.c        **** // 4 bytes 	==	sample length
2071:WTPA.c        **** // n bytes	==	sample
2072:WTPA.c        **** // NOTE -- we handle the case where a sample + the four byte addy is bigger than a sample slot (512
2073:WTPA.c        **** 
2074:WTPA.c        **** static void	ClearSampleToc(void)
2075:WTPA.c        **** // Empties the TOC of samples in local ram.
2076:WTPA.c        **** {
2077:WTPA.c        **** 	unsigned char
2078:WTPA.c        **** 		i;
2079:WTPA.c        **** 
2080:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
2081:WTPA.c        **** 	{
2082:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
2083:WTPA.c        **** 	}
2084:WTPA.c        **** }
2085:WTPA.c        **** 
2086:WTPA.c        **** static bool CheckSdSlotFull(unsigned int theSlot)
2087:WTPA.c        **** // Return true if the corresponding bit in the TOC is a 1.
2088:WTPA.c        **** // This is 64 bytes of 8 bits and we want to isolate the bit in question
2089:WTPA.c        **** {
2090:WTPA.c        **** 	unsigned char
2091:WTPA.c        **** 		theByte,
2092:WTPA.c        **** 		theBit;
2093:WTPA.c        **** 
2094:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2095:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2096:WTPA.c        **** 
2097:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
2098:WTPA.c        **** 	{
2099:WTPA.c        **** 		return(true);
2100:WTPA.c        **** 	}
2101:WTPA.c        **** 	else
2102:WTPA.c        **** 	{
2103:WTPA.c        **** 		return(false);
2104:WTPA.c        **** 	}
2105:WTPA.c        **** }
2106:WTPA.c        **** 
2107:WTPA.c        **** static void MarkSdSlotFull(unsigned int theSlot)
2108:WTPA.c        **** // Changes a bit in the TOC to a 1 to mark it full.
2109:WTPA.c        **** {
2110:WTPA.c        **** 	unsigned char
2111:WTPA.c        **** 		theByte,
2112:WTPA.c        **** 		theBit;
2113:WTPA.c        **** 
2114:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2115:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2116:WTPA.c        **** 
2117:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
2118:WTPA.c        **** }
2119:WTPA.c        **** 
2120:WTPA.c        **** /*
2121:WTPA.c        **** static void MarkSdSlotEmpty(unsigned int theSlot)
2122:WTPA.c        **** // Changes a bit in the TOC to a 0 to mark it empty.
2123:WTPA.c        **** {
2124:WTPA.c        **** 	unsigned char
2125:WTPA.c        **** 		theByte,
2126:WTPA.c        **** 		theBit;
2127:WTPA.c        **** 
2128:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2129:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2130:WTPA.c        **** 
2131:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
2132:WTPA.c        **** }
2133:WTPA.c        **** */
2134:WTPA.c        **** 
2135:WTPA.c        **** static bool GetCardFilesystem(void)
2136:WTPA.c        **** // Look for the tell tale signs of the party on this card.  If they are there, read in the TOC and 
2137:WTPA.c        **** {
2138:WTPA.c        **** 	bool
2139:WTPA.c        **** 		filesystemGood;
2140:WTPA.c        **** 	unsigned int
2141:WTPA.c        **** 		i;
2142:WTPA.c        **** 	char
2143:WTPA.c        **** 		theByte;
2144:WTPA.c        **** 
2145:WTPA.c        **** 	// Start reading the card at the very beginning.
2146:WTPA.c        **** 	// Are the first 4 chars WTPA?
2147:WTPA.c        **** 	// Stop reading, return true or false based on answer.
2148:WTPA.c        **** 
2149:WTPA.c        **** 	filesystemGood=true;					// Start assuming a good filesystem
2150:WTPA.c        **** 
2151:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
2152:WTPA.c        **** 	{
2153:WTPA.c        **** 		// Wait for a data packet from the card.
2154:WTPA.c        **** 		// EITHER read in the first four bytes then pull CS high  -- SD SPEC specifies that the SD card A
2155:WTPA.c        ****  		// Tue Jun 21 17:11:28 EDT 2011
2156:WTPA.c        ****  		// @@@ this appears to be bad news.  Tends to leave DO low.
2157:WTPA.c        **** 		// So --
2158:WTPA.c        **** 		// Read the first four bytes and test them, then read the remainder of the block and checksum and
2159:WTPA.c        **** 
2160:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
2161:WTPA.c        **** 
2162:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
2163:WTPA.c        **** 		{
2164:WTPA.c        **** 			HandleSoftclock();	// Kludgy
2165:WTPA.c        **** 		}
2166:WTPA.c        **** 
2167:WTPA.c        **** 		// Check the first 4 characters
2168:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2169:WTPA.c        **** 		if(theByte!='W')
2170:WTPA.c        **** 		{
2171:WTPA.c        **** 			filesystemGood=false;
2172:WTPA.c        **** 		}
2173:WTPA.c        **** 
2174:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2175:WTPA.c        **** 		if(theByte!='T')
2176:WTPA.c        **** 		{
2177:WTPA.c        **** 			filesystemGood=false;
2178:WTPA.c        **** 		}
2179:WTPA.c        **** 
2180:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2181:WTPA.c        **** 		if(theByte!='P')
2182:WTPA.c        **** 		{
2183:WTPA.c        **** 			filesystemGood=false;
2184:WTPA.c        **** 		}
2185:WTPA.c        **** 
2186:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
2187:WTPA.c        **** 		if(theByte!='A')
2188:WTPA.c        **** 		{
2189:WTPA.c        **** 			filesystemGood=false;
2190:WTPA.c        **** 		}
2191:WTPA.c        **** 
2192:WTPA.c        **** // Sat Nov 12 16:38:20 EST 2011
2193:WTPA.c        **** // Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, 
2194:WTPA.c        **** 
2195:WTPA.c        **** 		for(i=0;i<12;i++)					// 12 don't care bytes
2196:WTPA.c        **** 		{
2197:WTPA.c        **** 			TransferSdByte(0xFF);
2198:WTPA.c        **** 		}
2199:WTPA.c        **** 
2200:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
2201:WTPA.c        **** 		{
2202:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
2203:WTPA.c        **** 			{
2204:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
2205:WTPA.c        **** 			}
2206:WTPA.c        **** 		}
2207:WTPA.c        **** 		else
2208:WTPA.c        **** 		{
2209:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
2210:WTPA.c        **** 			{
2211:WTPA.c        **** 				TransferSdByte(0xFF);
2212:WTPA.c        **** 			}
2213:WTPA.c        **** 
2214:WTPA.c        **** 		}
2215:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
2216:WTPA.c        **** 		{
2217:WTPA.c        **** 			TransferSdByte(0xFF);
2218:WTPA.c        **** 		}
2219:WTPA.c        **** 	}
2220:WTPA.c        **** 	else
2221:WTPA.c        **** 	{
2222:WTPA.c        **** 		filesystemGood=false;	// Error issuing read command
2223:WTPA.c        **** 	}
2224:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
2225:WTPA.c        **** 		;
2226:WTPA.c        **** 
2227:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
2228:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
2229:WTPA.c        **** 
2230:WTPA.c        **** 	return(filesystemGood);
2231:WTPA.c        **** }
2232:WTPA.c        **** 
2233:WTPA.c        **** static void DoFormatCard(void)
2234:WTPA.c        **** // We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
2235:WTPA.c        **** // Give the user the option to purge the card of its evil ways, and do so and reboot.
2236:WTPA.c        **** {
2237:WTPA.c        **** 	if(subState==SS_0)
2238:WTPA.c        **** 	{
2239:WTPA.c        **** 		KillLeds();		// Turn off LEDs
2240:WTPA.c        **** 
2241:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
2242:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
2243:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
2244:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
2245:WTPA.c        **** 
2246:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
2247:WTPA.c        **** 		subState=SS_1;
2248:WTPA.c        **** 	}
2249:WTPA.c        **** 	else if(subState==SS_1)
2250:WTPA.c        **** 	{
2251:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
2252:WTPA.c        **** 		{
2253:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
2254:WTPA.c        **** 			KillLeds();
2255:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
2256:WTPA.c        **** 			subState=SS_2;
2257:WTPA.c        **** 		}
2258:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
2259:WTPA.c        **** 		{
2260:WTPA.c        **** 			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
2261:WTPA.c        **** 		}
2262:WTPA.c        **** 	}
2263:WTPA.c        **** 	else if(subState==SS_2)
2264:WTPA.c        **** 	{
2265:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
2266:WTPA.c        **** 		{
2267:WTPA.c        **** 			KillLeds();
2268:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
2269:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
2270:WTPA.c        **** 			{
2271:WTPA.c        **** 				SetState(DoFruitcakeIntro);	// Start sampler over again.
2272:WTPA.c        **** 			}
2273:WTPA.c        **** 		}
2274:WTPA.c        **** 	}
2275:WTPA.c        **** }
2276:WTPA.c        **** 
2277:WTPA.c        **** static bool SdStartSampleRead(unsigned int sampleSlot)
2278:WTPA.c        **** // Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
2279:WTPA.c        **** // Begins a sample read in the correct spot.
2280:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2281:WTPA.c        **** {
2282:WTPA.c        **** 	unsigned char
2283:WTPA.c        **** 		sreg;
2284:WTPA.c        **** 
2285:WTPA.c        **** 	sreg=SREG;
2286:WTPA.c        **** 	cli();		// Pause ISR
2287:WTPA.c        **** 
2288:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
2289:WTPA.c        **** 	{
2290:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
2291:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
2292:WTPA.c        **** 
2293:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
2294:WTPA.c        **** 		sdFifoWritePointer=0;
2295:WTPA.c        **** 		sdBytesInFifo=0;
2296:WTPA.c        **** 
2297:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2298:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
2299:WTPA.c        **** 
2300:WTPA.c        **** 		SREG=sreg;	// Resume ISR
2301:WTPA.c        **** 
2302:WTPA.c        **** 		return(true);
2303:WTPA.c        **** 	}
2304:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2305:WTPA.c        **** 	return(false);
2306:WTPA.c        **** }
2307:WTPA.c        **** 
2308:WTPA.c        **** static void SdStartSampleWrite(unsigned int sampleSlot, unsigned long sampleLength)
2309:WTPA.c        **** // Initializes the state machine and FIFOs for writing a sample to the SD card
2310:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2311:WTPA.c        **** // Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
2312:WTPA.c        **** {
2313:WTPA.c        **** 	unsigned char
2314:WTPA.c        **** 		sreg;
2315:WTPA.c        **** 
2316:WTPA.c        **** 	sreg=SREG;
2317:WTPA.c        **** 	cli();		// Pause ISR
2318:WTPA.c        **** 
2319:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
2320:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
2321:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
2322:WTPA.c        **** 
2323:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2324:WTPA.c        **** 	sdFifoWritePointer=0;
2325:WTPA.c        **** 	sdBytesInFifo=0;
2326:WTPA.c        **** 
2327:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
2328:WTPA.c        **** 	{
2329:WTPA.c        **** 		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get fr
2330:WTPA.c        **** 	}
2331:WTPA.c        **** 	else
2332:WTPA.c        **** 	{
2333:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
2334:WTPA.c        **** 	}
2335:WTPA.c        **** 
2336:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
2337:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
2338:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2339:WTPA.c        **** }
2340:WTPA.c        **** 
2341:WTPA.c        **** static void UpdateCard(void)
2342:WTPA.c        **** // Updates the state machine which keeps the card reads/writes/inits going like they should.
2343:WTPA.c        **** {
2344:WTPA.c        **** 	unsigned char
2345:WTPA.c        **** 		theByte,
2346:WTPA.c        **** 		sreg,
2347:WTPA.c        **** 		i;
2348:WTPA.c        **** 
2349:WTPA.c        **** 	signed char
2350:WTPA.c        **** 		tempSample;		// Must be signed or we can get bit errors (will hold ADC data most of the time)
2351:WTPA.c        **** 
2352:WTPA.c        **** 	unsigned int
2353:WTPA.c        **** 		numTransferBytes;
2354:WTPA.c        **** 
2355:WTPA.c        **** 	static unsigned int
2356:WTPA.c        **** 		bytesLeftInBlock;	// How many bytes left in the given block
2357:WTPA.c        **** 
2358:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
2359:WTPA.c        **** 	{
2360:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
2361:WTPA.c        **** 		{
2362:WTPA.c        **** 			// Uninit any filesystem shizz, stop any transfers in progress gracefully
2363:WTPA.c        **** 			cardState=SD_NOT_PRESENT;		// Mark the card as st elsewhere
2364:WTPA.c        **** 		}
2365:WTPA.c        **** 	}
2366:WTPA.c        **** 	else	// Yup, got a card
2367:WTPA.c        **** 	{
2368:WTPA.c        **** 		switch(cardState)
2369:WTPA.c        **** 		{
2370:WTPA.c        **** 
2371:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2372:WTPA.c        **** // Warmup / Init	----------------------------------------------------------------------------------
2373:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2374:WTPA.c        **** 
2375:WTPA.c        **** 			case SD_NOT_PRESENT:	// Card just inserted
2376:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
2377:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
2378:WTPA.c        **** 			break;
2379:WTPA.c        **** 
2380:WTPA.c        **** 			case SD_WARMUP:				// Card inserted, timer has been started.
2381:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
2382:WTPA.c        **** 			{
2383:WTPA.c        **** 				sdPlaybackQueued=false;
2384:WTPA.c        **** 				sdAbortRead=false;
2385:WTPA.c        **** 
2386:WTPA.c        **** 				if(SdHandshake()==true)	// Give it a shot...
2387:WTPA.c        **** 				{
2388:WTPA.c        **** 					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct file
2389:WTPA.c        **** 					{
2390:WTPA.c        **** 						cardState=SD_IDLE;		// Card is legit and ready to go.
2391:WTPA.c        **** 						InitSdIsr();			// Enable the timers necessary to give the SD card its own IRQ
2392:WTPA.c        **** 					}
2393:WTPA.c        **** 					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the 
2394:WTPA.c        **** 					{
2395:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
2396:WTPA.c        **** 						ClearSampleToc();		// Write toc to zero
2397:WTPA.c        **** 						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to m
2398:WTPA.c        **** 					}
2399:WTPA.c        **** 				}
2400:WTPA.c        **** 				else	// Not a valid handshake.  Get on with our lives.
2401:WTPA.c        **** 				{
2402:WTPA.c        **** 					cardState=SD_INVALID;
2403:WTPA.c        **** 				}
2404:WTPA.c        **** 			}
2405:WTPA.c        **** 			break;
2406:WTPA.c        **** 
2407:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2408:WTPA.c        **** // Writing Samples to the Card	--------------------------------------------------------------------
2409:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2410:WTPA.c        **** 
2411:WTPA.c        **** 			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with th
2412:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2413:WTPA.c        **** 			cli();
2414:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2415:WTPA.c        **** 			{
2416:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
2417:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
2418:WTPA.c        **** 				{
2419:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2420:WTPA.c        **** 
2421:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
2422:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
2423:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
2424:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
2425:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
2426:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
2427:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
2428:WTPA.c        **** 
2429:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
2430:WTPA.c        **** 
2431:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing o
2432:WTPA.c        **** 				}
2433:WTPA.c        **** 				else // Couldn't open card for write
2434:WTPA.c        **** 				{
2435:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2436:WTPA.c        **** 				}
2437:WTPA.c        **** 			}
2438:WTPA.c        **** 			else	// Fifo not ready yet
2439:WTPA.c        **** 			{
2440:WTPA.c        **** 				SREG=sreg;	// Turn ISR back on
2441:WTPA.c        **** 			}
2442:WTPA.c        **** 			break;
2443:WTPA.c        **** 
2444:WTPA.c        **** 			case SD_WRITING_BLOCK:										// The SD card is open and we're currently writing a block.
2445:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2446:WTPA.c        **** 			{
2447:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2448:WTPA.c        **** 			}
2449:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2450:WTPA.c        **** 			{
2451:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2452:WTPA.c        **** 			}
2453:WTPA.c        **** 
2454:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
2455:WTPA.c        **** 			{
2456:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
2457:WTPA.c        **** 				{
2458:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
2459:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
2460:WTPA.c        **** 
2461:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
2462:WTPA.c        **** 
2463:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2464:WTPA.c        **** 					{
2465:WTPA.c        **** 						sdFifoReadPointer=0;
2466:WTPA.c        **** 					}
2467:WTPA.c        **** 
2468:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2469:WTPA.c        **** 					cli();
2470:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
2471:WTPA.c        **** 					SREG=sreg;
2472:WTPA.c        **** 				}
2473:WTPA.c        **** 				else	// If sample has been loaded already
2474:WTPA.c        **** 				{
2475:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
2476:WTPA.c        **** 				}
2477:WTPA.c        **** 
2478:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
2479:WTPA.c        **** 			}
2480:WTPA.c        **** 
2481:WTPA.c        **** 			// Have we written an entire block?
2482:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
2483:WTPA.c        **** 			{
2484:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2485:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2486:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2487:WTPA.c        **** 
2488:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2489:WTPA.c        **** 				{
2490:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2491:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
2492:WTPA.c        **** 				}
2493:WTPA.c        **** 				else	// Something wrong with the write.
2494:WTPA.c        **** 				{
2495:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2496:WTPA.c        **** 				}
2497:WTPA.c        **** 			}
2498:WTPA.c        **** 			break;
2499:WTPA.c        **** 
2500:WTPA.c        **** 			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writi
2501:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
2502:WTPA.c        **** 			{
2503:WTPA.c        **** 				i=0;
2504:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2505:WTPA.c        **** 				{
2506:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2507:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2508:WTPA.c        **** 					{
2509:WTPA.c        **** 						i++;	// Try again.
2510:WTPA.c        **** 					}
2511:WTPA.c        **** 					else
2512:WTPA.c        **** 					{
2513:WTPA.c        **** 						i=4;	// Got a result, stop polling
2514:WTPA.c        **** 					}
2515:WTPA.c        **** 				}
2516:WTPA.c        **** 
2517:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
2518:WTPA.c        **** 				{
2519:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2520:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2521:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2522:WTPA.c        **** 						;
2523:WTPA.c        **** 
2524:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
2525:WTPA.c        **** 					{
2526:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
2527:WTPA.c        **** 					}
2528:WTPA.c        **** 					else	// We've written the entire sample to the SD card, and the SD card block write is done.  
2529:WTPA.c        **** 					{
2530:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
2531:WTPA.c        **** 						{
2532:WTPA.c        **** 							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been fille
2533:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
2534:WTPA.c        **** 						}
2535:WTPA.c        **** 						else
2536:WTPA.c        **** 						{
2537:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
2538:WTPA.c        **** 						}
2539:WTPA.c        **** 					}
2540:WTPA.c        **** 				}
2541:WTPA.c        **** 			}
2542:WTPA.c        **** 			else	// Timed out waiting for block to write.
2543:WTPA.c        **** 			{
2544:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2545:WTPA.c        **** 			}
2546:WTPA.c        **** 			break;
2547:WTPA.c        **** 
2548:WTPA.c        **** 			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full
2549:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
2550:WTPA.c        **** 			cli();
2551:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2552:WTPA.c        **** 			{
2553:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
2554:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
2555:WTPA.c        **** 
2556:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
2557:WTPA.c        **** 				{
2558:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2559:WTPA.c        **** 
2560:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
2561:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
2562:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
2563:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
2564:WTPA.c        **** 				}
2565:WTPA.c        **** 				else	// Couldn't successfully open block to write
2566:WTPA.c        **** 				{
2567:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2568:WTPA.c        **** 				}
2569:WTPA.c        **** 			}
2570:WTPA.c        **** 			else	// Bytes remaining in sample, but not enough in the fifo yet
2571:WTPA.c        **** 			{
2572:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
2573:WTPA.c        **** 			}
2574:WTPA.c        **** 			break;
2575:WTPA.c        **** 
2576:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2577:WTPA.c        **** // Writing TOC to the Card	------------------------------------------------------------------------
2578:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2579:WTPA.c        **** 
2580:WTPA.c        **** 			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via n
2581:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
2582:WTPA.c        **** 			{
2583:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
2584:WTPA.c        **** 
2585:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2586:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
2587:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
2588:WTPA.c        **** 				TransferSdByte('W');				// Send flag that this is a WTPA card
2589:WTPA.c        **** 				TransferSdByte('T');
2590:WTPA.c        **** 				TransferSdByte('P');
2591:WTPA.c        **** 				TransferSdByte('A');
2592:WTPA.c        **** 
2593:WTPA.c        **** 				bytesLeftInBlock-=4;
2594:WTPA.c        **** 
2595:WTPA.c        **** 				for(i=0;i<12;i++)					// 12 don't care bytes
2596:WTPA.c        **** 				{
2597:WTPA.c        **** 					TransferSdByte('x');
2598:WTPA.c        **** 				}
2599:WTPA.c        **** 
2600:WTPA.c        **** 				bytesLeftInBlock-=12;
2601:WTPA.c        **** 
2602:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
2603:WTPA.c        **** 				{
2604:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
2605:WTPA.c        **** 				}
2606:WTPA.c        **** 
2607:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
2608:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
2609:WTPA.c        **** 			}
2610:WTPA.c        **** 			else	// Block write failed
2611:WTPA.c        **** 			{
2612:WTPA.c        **** 				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2613:WTPA.c        **** 			}
2614:WTPA.c        **** 			break;
2615:WTPA.c        **** 
2616:WTPA.c        **** 			case SD_TOC_WRITE_CONTINUE:				// Keep writing don't cares to the block until we're done.
2617:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2618:WTPA.c        **** 			{
2619:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2620:WTPA.c        **** 			}
2621:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2622:WTPA.c        **** 			{
2623:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2624:WTPA.c        **** 			}
2625:WTPA.c        **** 
2626:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
2627:WTPA.c        **** 			{
2628:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2629:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
2630:WTPA.c        **** 			}
2631:WTPA.c        **** 
2632:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
2633:WTPA.c        **** 			{
2634:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2635:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2636:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2637:WTPA.c        **** 
2638:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2639:WTPA.c        **** 				{
2640:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2641:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
2642:WTPA.c        **** 				}
2643:WTPA.c        **** 				else	// Something wrong with the write.
2644:WTPA.c        **** 				{
2645:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2646:WTPA.c        **** 				}
2647:WTPA.c        **** 			}
2648:WTPA.c        **** 			break;
2649:WTPA.c        **** 
2650:WTPA.c        **** 			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
2651:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2652:WTPA.c        **** 			{
2653:WTPA.c        **** 				i=0;
2654:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2655:WTPA.c        **** 				{
2656:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2657:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2658:WTPA.c        **** 					{
2659:WTPA.c        **** 						i++;	// Try again.
2660:WTPA.c        **** 					}
2661:WTPA.c        **** 					else
2662:WTPA.c        **** 					{
2663:WTPA.c        **** 						i=4;	// Got a result, stop polling
2664:WTPA.c        **** 					}
2665:WTPA.c        **** 				}
2666:WTPA.c        **** 
2667:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
2668:WTPA.c        **** 				{
2669:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2670:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2671:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2672:WTPA.c        **** 						;
2673:WTPA.c        **** 					cardState=SD_IDLE;				// DONE!
2674:WTPA.c        **** 				}
2675:WTPA.c        **** 			}
2676:WTPA.c        **** 			else	// Timed out waiting for block to write.
2677:WTPA.c        **** 			{
2678:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2679:WTPA.c        **** 			}
2680:WTPA.c        **** 			break;
2681:WTPA.c        **** 
2682:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2683:WTPA.c        **** // Reading Samples from the Card ------------------------------------------------------------------
2684:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2685:WTPA.c        **** 
2686:WTPA.c        **** 			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token t
2687:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2688:WTPA.c        **** 			{
2689:WTPA.c        **** 				i=0;
2690:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2691:WTPA.c        **** 				{
2692:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2693:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2694:WTPA.c        **** 					{
2695:WTPA.c        **** 						i++;	// Try again.
2696:WTPA.c        **** 					}
2697:WTPA.c        **** 					else
2698:WTPA.c        **** 					{
2699:WTPA.c        **** 						i=4;	// Got a result, stop polling
2700:WTPA.c        **** 					}
2701:WTPA.c        **** 				}
2702:WTPA.c        **** 
2703:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2704:WTPA.c        **** 				{
2705:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
2706:WTPA.c        **** 
2707:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
2708:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
2709:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
2710:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
2711:WTPA.c        **** 
2712:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
2713:WTPA.c        **** 
2714:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
2715:WTPA.c        **** 					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handl
2716:WTPA.c        **** 
2717:WTPA.c        **** 					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abor
2718:WTPA.c        **** 					{
2719:WTPA.c        **** 						cardState=SD_READ_ABORT;
2720:WTPA.c        **** 						sdAbortRead=false;
2721:WTPA.c        **** 					}
2722:WTPA.c        **** 				}
2723:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2724:WTPA.c        **** 				{
2725:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2726:WTPA.c        **** 				}
2727:WTPA.c        **** 			}
2728:WTPA.c        **** 			else	// Timed out starting read.
2729:WTPA.c        **** 			{
2730:WTPA.c        **** 				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2731:WTPA.c        **** 			}
2732:WTPA.c        **** 			break;
2733:WTPA.c        **** 
2734:WTPA.c        **** 			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes 
2735:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
2736:WTPA.c        **** 			{
2737:WTPA.c        **** 				cardState=SD_READ_ABORT;
2738:WTPA.c        **** 				sdAbortRead=false;
2739:WTPA.c        **** 			}
2740:WTPA.c        **** 			else
2741:WTPA.c        **** 			{
2742:WTPA.c        **** 				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block
2743:WTPA.c        **** 				{
2744:WTPA.c        **** 					numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2745:WTPA.c        **** 				}
2746:WTPA.c        **** 				else	// Less than a chunk left in the block, read the rest of the block.
2747:WTPA.c        **** 				{
2748:WTPA.c        **** 					numTransferBytes=bytesLeftInBlock;
2749:WTPA.c        **** 				}
2750:WTPA.c        **** 
2751:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
2752:WTPA.c        **** 				{
2753:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
2754:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
2755:WTPA.c        **** 
2756:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
2757:WTPA.c        **** 					{
2758:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
2759:WTPA.c        **** 
2760:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
2761:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
2762:WTPA.c        **** 
2763:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2764:WTPA.c        **** 						{
2765:WTPA.c        **** 							sdFifoWritePointer=0;
2766:WTPA.c        **** 						}
2767:WTPA.c        **** 
2768:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2769:WTPA.c        **** 						cli();
2770:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
2771:WTPA.c        **** 						SREG=sreg;
2772:WTPA.c        **** 					}
2773:WTPA.c        **** 				}
2774:WTPA.c        **** 
2775:WTPA.c        **** 				// Check done-ness of block read:
2776:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
2777:WTPA.c        **** 				{
2778:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2779:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2780:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2781:WTPA.c        **** 						;
2782:WTPA.c        **** 
2783:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2784:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2785:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
2786:WTPA.c        **** 
2787:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
2788:WTPA.c        **** 					{
2789:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2790:WTPA.c        **** 							;
2791:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
2792:WTPA.c        **** 					}
2793:WTPA.c        **** 				}
2794:WTPA.c        **** 			}
2795:WTPA.c        **** 			break;
2796:WTPA.c        **** 
2797:WTPA.c        **** 			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through e
2798:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2799:WTPA.c        **** 			cli();
2800:WTPA.c        **** 
2801:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
2802:WTPA.c        **** 			{
2803:WTPA.c        **** 				SREG=sreg;				// ISR back on.
2804:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
2805:WTPA.c        **** 
2806:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
2807:WTPA.c        **** 				{
2808:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2809:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
2810:WTPA.c        **** 				}
2811:WTPA.c        **** 				else	// Read failed!
2812:WTPA.c        **** 				{
2813:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2814:WTPA.c        **** 				}
2815:WTPA.c        **** 			}
2816:WTPA.c        **** 			else	// ISR has not cleared enough of the sample out of the FIFO yet.
2817:WTPA.c        **** 			{
2818:WTPA.c        **** 				SREG=sreg;	// ISR back on.
2819:WTPA.c        **** 			}
2820:WTPA.c        **** 			break;
2821:WTPA.c        **** 
2822:WTPA.c        **** 
2823:WTPA.c        **** 			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token 
2824:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
2825:WTPA.c        **** 			{
2826:WTPA.c        **** 				i=0;
2827:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2828:WTPA.c        **** 				{
2829:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2830:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2831:WTPA.c        **** 					{
2832:WTPA.c        **** 						i++;	// Try again.
2833:WTPA.c        **** 					}
2834:WTPA.c        **** 					else
2835:WTPA.c        **** 					{
2836:WTPA.c        **** 						i=4;	// Got a result, stop polling
2837:WTPA.c        **** 					}
2838:WTPA.c        **** 				}
2839:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2840:WTPA.c        **** 				{
2841:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
2842:WTPA.c        **** 
2843:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
2844:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
2845:WTPA.c        **** 					{
2846:WTPA.c        **** 						cardState=SD_READ_ABORT;
2847:WTPA.c        **** 						sdAbortRead=false;
2848:WTPA.c        **** 					}
2849:WTPA.c        **** 				}
2850:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2851:WTPA.c        **** 				{
2852:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2853:WTPA.c        **** 				}
2854:WTPA.c        **** 			}
2855:WTPA.c        **** 			else	// Timed out starting read.
2856:WTPA.c        **** 			{
2857:WTPA.c        **** 				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
2858:WTPA.c        **** 			}
2859:WTPA.c        **** 			break;
2860:WTPA.c        **** 
2861:WTPA.c        **** 			case SD_READ_ABORT:				// We've been asked to start a new playback stream from the SD while a bl
2862:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2863:WTPA.c        **** 			{
2864:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2865:WTPA.c        **** 			}
2866:WTPA.c        **** 			else	// Less than a chunk left in the block, read the rest of the block.
2867:WTPA.c        **** 			{
2868:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2869:WTPA.c        **** 			}
2870:WTPA.c        **** 
2871:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
2872:WTPA.c        **** 			{
2873:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
2874:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
2875:WTPA.c        **** 			}
2876:WTPA.c        **** 
2877:WTPA.c        **** 			// Check done-ness of block read:
2878:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
2879:WTPA.c        **** 			{
2880:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2881:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2882:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2883:WTPA.c        **** 					;
2884:WTPA.c        **** 
2885:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
2886:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
2887:WTPA.c        **** 
2888:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2889:WTPA.c        **** 					;
2890:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
2891:WTPA.c        **** 
2892:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
2893:WTPA.c        **** 				{
2894:WTPA.c        **** 					sdPlaybackQueued=false;
2895:WTPA.c        **** //					PlaySampleFromSd(sdQueuedBank,sdQueuedSlot);	// Trigger the next stream immediately
2896:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
2897:WTPA.c        **** 				}
2898:WTPA.c        **** 			}
2899:WTPA.c        **** 			break;
2900:WTPA.c        **** 
2901:WTPA.c        **** 			case SD_IDLE:		// Do nothing if IDLE.
2902:WTPA.c        **** 			case SD_INVALID:	// If we're invalid, fall through and do nothing.
2903:WTPA.c        **** 			default:
2904:WTPA.c        **** 			break;
2905:WTPA.c        **** 		}
2906:WTPA.c        **** 	}
2907:WTPA.c        **** }
2908:WTPA.c        **** 
2909:WTPA.c        **** 
2910:WTPA.c        **** //-----------------------------------------------------------------------
2911:WTPA.c        **** //-----------------------------------------------------------------------
2912:WTPA.c        **** // SD Sample Read and Write Functions:
2913:WTPA.c        **** //-----------------------------------------------------------------------
2914:WTPA.c        **** //-----------------------------------------------------------------------
2915:WTPA.c        **** // The functions the main loop calls to get and put samples on the SD card.
2916:WTPA.c        **** // Sat Sep 24 19:08:17 EDT 2011
2917:WTPA.c        **** // This includes both the SD card state machine stuff (run from the main loop) and any ISRs needed 
2918:WTPA.c        **** 
2919:WTPA.c        **** 
2920:WTPA.c        **** static void InitSdIsr(void)
2921:WTPA.c        **** // Prepare a timer interrupt to handle filling and emptying the SD card's buffer
2922:WTPA.c        **** // This can fill the SRAM with data from the SD card, fill the SD card with data from the SRAM, or 
2923:WTPA.c        **** // NOTE -- we are using compare match B on timer 2 for this.  Compare match A is already used for t
2924:WTPA.c        **** // NOTE -- This means we have to call this after we finish the PWM business or the timer will be re
2925:WTPA.c        **** // Sat Sep 24 19:07:57 EDT 2011
2926:WTPA.c        **** // In our old code, we were reading and writing every 780 cycles (~25kHz) and playing back every 90
2927:WTPA.c        **** // In the new code we need to use 907/8 or 113 -- this gives a playback rate of about 22124, or an 
2928:WTPA.c        **** // We COULD go back and forth between 113 and 114, which gives us an average of 0.1% (1.73 cents) w
2929:WTPA.c        **** // Listening to some tests on the internet I can't tell the difference, so we do this the easy way 
2930:WTPA.c        **** // (Reading and writing don't matter, since we don't hear them and a small percentage difference wo
2931:WTPA.c        **** {
2932:WTPA.c        **** 	// Set up timer 2 OC2B to make SD buffer interrupts
2933:WTPA.c        **** 
2934:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
2935:WTPA.c        **** 
2936:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
2937:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
2938:WTPA.c        **** 	TCNT2=0;			// Init counter reg
2939:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
2940:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
2941:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
2942:WTPA.c        **** 
2943:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
2944:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
2945:WTPA.c        **** }
2946:WTPA.c        **** 
2947:WTPA.c        **** static void SdIsrStartReadingRam(unsigned char theBank)
2948:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
2949:WTPA.c        **** // Tell it to collect bytes from the passed bank and fill the buffer.
2950:WTPA.c        **** {
2951:WTPA.c        **** 	unsigned char
2952:WTPA.c        **** 		sreg;
2953:WTPA.c        **** 
2954:WTPA.c        **** 	sreg=SREG;
2955:WTPA.c        **** 	cli();		// Pause ISRs
2956:WTPA.c        **** 
2957:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
2958:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
2959:WTPA.c        **** 
2960:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
2961:WTPA.c        **** 	{
2962:WTPA.c        **** 		sdBank0=true;
2963:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
2964:WTPA.c        **** 	}
2965:WTPA.c        **** 	else
2966:WTPA.c        **** 	{
2967:WTPA.c        **** 		sdBank0=false;
2968:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
2969:WTPA.c        **** 	}
2970:WTPA.c        **** 
2971:WTPA.c        **** 	TCNT2=0;			// Init counter reg
2972:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
2973:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
2974:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
2975:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
2976:WTPA.c        **** 
2977:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
2978:WTPA.c        **** }
2979:WTPA.c        **** 
2980:WTPA.c        **** static void SdIsrStartWritingRam(unsigned char theBank)
2981:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
2982:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
2983:WTPA.c        **** {
2984:WTPA.c        **** 	unsigned char
2985:WTPA.c        **** 		sreg;
2986:WTPA.c        **** 
2987:WTPA.c        **** 	sreg=SREG;
2988:WTPA.c        **** 	cli();		// Pause ISRs
2989:WTPA.c        **** 
2990:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
2991:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
2992:WTPA.c        **** 
2993:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
2994:WTPA.c        **** 	{
2995:WTPA.c        **** 		sdBank0=true;
2996:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
2997:WTPA.c        **** 	}
2998:WTPA.c        **** 	else
2999:WTPA.c        **** 	{
3000:WTPA.c        **** 		sdBank0=false;
3001:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3002:WTPA.c        **** 	}
3003:WTPA.c        **** 
3004:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3005:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3006:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3007:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3008:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3009:WTPA.c        **** 
3010:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3011:WTPA.c        **** }
3012:WTPA.c        **** 
3013:WTPA.c        **** static void SdIsrStartStreamingAudio(void)
3014:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3015:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM.
3016:WTPA.c        **** {
 2043               		.loc 1 3016 0
 2044               		.cfi_startproc
 2045               	/* prologue: function */
 2046               	/* frame size = 0 */
 2047               	/* stack size = 0 */
 2048               	.L__stack_usage = 0
3017:WTPA.c        **** 	unsigned char
3018:WTPA.c        **** 		sreg;
3019:WTPA.c        **** 
3020:WTPA.c        **** 	sreg=SREG;
 2049               		.loc 1 3020 0
 2050 10ea 9FB7      		in r25,__SREG__
 2051               	.LVL57:
3021:WTPA.c        **** 	cli();		// Pause ISRs
 2052               		.loc 1 3021 0
 2053               	/* #APP */
 2054               	 ;  3021 "WTPA.c" 1
 2055 10ec F894      		cli
 2056               	 ;  0 "" 2
3022:WTPA.c        **** 
3023:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
 2057               		.loc 1 3023 0
 2058               	/* #NOAPP */
 2059 10ee 83E0      		ldi r24,lo8(3)
 2060 10f0 8093 0000 		sts sdIsrState,r24
3024:WTPA.c        **** 
3025:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 2061               		.loc 1 3025 0
 2062 10f4 1092 B200 		sts 178,__zero_reg__
3026:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 2063               		.loc 1 3026 0
 2064 10f8 81E7      		ldi r24,lo8(113)
 2065 10fa 8093 B300 		sts 179,r24
3027:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 2066               		.loc 1 3027 0
 2067 10fe 8FEF      		ldi r24,lo8(-1)
 2068 1100 87BB      		out 0x17,r24
3028:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 2069               		.loc 1 3028 0
 2070 1102 E0E7      		ldi r30,lo8(112)
 2071 1104 F0E0      		ldi r31,0
 2072 1106 8081      		ld r24,Z
 2073 1108 8460      		ori r24,lo8(4)
 2074 110a 8083      		st Z,r24
3029:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 2075               		.loc 1 3029 0
 2076 110c 82E0      		ldi r24,lo8(2)
 2077 110e 8093 B100 		sts 177,r24
3030:WTPA.c        **** 
3031:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 2078               		.loc 1 3031 0
 2079 1112 9FBF      		out __SREG__,r25
 2080 1114 0895      		ret
 2081               		.cfi_endproc
 2082               	.LFE46:
 2085               	GetRandomLongInt:
 2086               	.LFB59:
3032:WTPA.c        **** }
3033:WTPA.c        **** 
3034:WTPA.c        **** static unsigned long GetLengthOfSample(unsigned char theBank)
3035:WTPA.c        **** // Returns the length of the sample, handles my laziness.
3036:WTPA.c        **** {
3037:WTPA.c        **** 	unsigned long
3038:WTPA.c        **** 		theLength;
3039:WTPA.c        **** 
3040:WTPA.c        **** 	if(theBank==BANK_0)
3041:WTPA.c        **** 	{
3042:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3043:WTPA.c        **** 		{
3044:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
3045:WTPA.c        **** 		}
3046:WTPA.c        **** 		else
3047:WTPA.c        **** 		{
3048:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
3049:WTPA.c        **** 		}
3050:WTPA.c        **** 	}
3051:WTPA.c        **** 	else
3052:WTPA.c        **** 	{
3053:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3054:WTPA.c        **** 		{
3055:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
3056:WTPA.c        **** 		}
3057:WTPA.c        **** 		else
3058:WTPA.c        **** 		{
3059:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
3060:WTPA.c        **** 		}
3061:WTPA.c        **** 	}
3062:WTPA.c        **** 
3063:WTPA.c        **** 	return(theLength);
3064:WTPA.c        **** }
3065:WTPA.c        **** 
3066:WTPA.c        **** //------------------------------------------------------------------------------------------
3067:WTPA.c        **** // Below are the SD functions that we call from the mainline code to write, read and stream
3068:WTPA.c        **** //------------------------------------------------------------------------------------------
3069:WTPA.c        **** 
3070:WTPA.c        **** static void WriteSampleToSd(unsigned char theBank, unsigned int theSlot)
3071:WTPA.c        **** // Takes the sample currently in the passed bank, with any audio effects applied, and puts it in th
3072:WTPA.c        **** // Makes sure the SD card has been properly groomed first.
3073:WTPA.c        **** // NOTE: SD state machine will shut down the write process itself
3074:WTPA.c        **** {
3075:WTPA.c        **** 	unsigned long
3076:WTPA.c        **** 		theLength;
3077:WTPA.c        **** 	unsigned char
3078:WTPA.c        **** 		sreg;
3079:WTPA.c        **** 
3080:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3081:WTPA.c        **** 	{
3082:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3083:WTPA.c        **** 		{
3084:WTPA.c        **** 			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank
3085:WTPA.c        **** 
3086:WTPA.c        **** 			sreg=SREG;
3087:WTPA.c        **** 			cli();		// Pause ISR
3088:WTPA.c        **** 
3089:WTPA.c        **** 			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and 
3090:WTPA.c        **** 			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3091:WTPA.c        **** 
3092:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3093:WTPA.c        **** 		}
3094:WTPA.c        **** 	}
3095:WTPA.c        **** }
3096:WTPA.c        **** 
3097:WTPA.c        **** static void ReadSampleFromSd(unsigned char theBank, unsigned int theSlot)
3098:WTPA.c        **** // Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card 
3099:WTPA.c        **** {
3100:WTPA.c        **** 	unsigned char
3101:WTPA.c        **** 		sreg;
3102:WTPA.c        **** 
3103:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3104:WTPA.c        **** 	{
3105:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3106:WTPA.c        **** 		{
3107:WTPA.c        **** 			sreg=SREG;
3108:WTPA.c        **** 			cli();		// Pause ISR
3109:WTPA.c        **** 
3110:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
3111:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
3112:WTPA.c        **** 			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3113:WTPA.c        **** 
3114:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3115:WTPA.c        **** 		}
3116:WTPA.c        **** 	}
3117:WTPA.c        **** }
3118:WTPA.c        **** 
3119:WTPA.c        **** //static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot)
3120:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot)
3121:WTPA.c        **** // Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample i
3122:WTPA.c        **** {
3123:WTPA.c        **** 	unsigned char
3124:WTPA.c        **** 		sreg;
3125:WTPA.c        **** 
3126:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3127:WTPA.c        **** 	{
3128:WTPA.c        **** 		sreg=SREG;	 // Pause ISRs
3129:WTPA.c        **** 		cli();
3130:WTPA.c        **** 
3131:WTPA.c        **** 		SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3132:WTPA.c        **** 		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byte
3133:WTPA.c        **** 		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3134:WTPA.c        **** 
3135:WTPA.c        **** 		SREG=sreg;	// resume isr
3136:WTPA.c        **** 	}
3137:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
3138:WTPA.c        **** 	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck u
3139:WTPA.c        **** 	{
3140:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
3141:WTPA.c        **** 		{
3142:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
3143:WTPA.c        **** 			cli();
3144:WTPA.c        **** 
3145:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3146:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
3147:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3148:WTPA.c        **** 
3149:WTPA.c        **** 			SREG=sreg;	// resume isr
3150:WTPA.c        **** 		}
3151:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
3152:WTPA.c        **** 		{
3153:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3154:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3155:WTPA.c        **** 		}
3156:WTPA.c        **** 		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and
3157:WTPA.c        **** 		{
3158:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3159:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3160:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
3161:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
3162:WTPA.c        **** 
3163:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
3164:WTPA.c        **** 			cli();
3165:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
3166:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
3167:WTPA.c        **** 			SREG=sreg;
3168:WTPA.c        **** 		}
3169:WTPA.c        **** 	}
3170:WTPA.c        **** }
3171:WTPA.c        **** 
3172:WTPA.c        **** 
3173:WTPA.c        **** //static void CleanupSdPlayback(void)
3174:WTPA.c        **** // Runs in the main loop and makes sure that the SD state machine closes any blocks opened during S
3175:WTPA.c        **** // This happens if the user tells the sampler to do a different playback/record function and the IS
3176:WTPA.c        **** // NOTE -- the SD will not read from or write to RAM if the card is not idle, so we only need to wo
3177:WTPA.c        **** // Sun Nov 13 20:03:28 EST 2011
3178:WTPA.c        **** // Do we need to check for abort conditions anymore?  I kinda think not, since SD playback no longe
3179:WTPA.c        **** //{
3180:WTPA.c        **** //	if(sdIsrState==SD_ISR_IDLE)
3181:WTPA.c        **** //	{
3182:WTPA.c        **** //		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR 
3183:WTPA.c        **** //	}
3184:WTPA.c        **** 
3185:WTPA.c        **** /*
3186:WTPA.c        **** 	if(bankStates[BANK_0].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_0].audioFunction!=AUDIO_READ_
3187:WTPA.c        **** 	{
3188:WTPA.c        **** 		if(bankStates[BANK_1].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_1].audioFunction!=AUDIO_READ
3189:WTPA.c        **** 		{
3190:WTPA.c        **** 			if(cardState==SD_READ_START||cardState==SD_READING_BLOCK||cardState==SD_READ_FIFO_WAIT||cardStat
3191:WTPA.c        **** 			{
3192:WTPA.c        **** 				if(cardState==SD_READ_FIFO_WAIT)	// If we're waiting for the FIFO, we can just abort; there isn
3193:WTPA.c        **** 				{
3194:WTPA.c        **** 						cardState=SD_IDLE;	// Just end it.
3195:WTPA.c        **** 				}
3196:WTPA.c        **** 				else
3197:WTPA.c        **** 				{
3198:WTPA.c        **** 						sdAbortRead=true;	// We're in mid-read.  Let the state machine know to abort the read when it
3199:WTPA.c        **** 				}
3200:WTPA.c        **** 			}
3201:WTPA.c        **** 		}
3202:WTPA.c        **** 	}
3203:WTPA.c        **** */
3204:WTPA.c        **** //}
3205:WTPA.c        **** 
3206:WTPA.c        **** //--------------------------------------
3207:WTPA.c        **** //--------------------------------------
3208:WTPA.c        **** // MIDI Functions
3209:WTPA.c        **** //--------------------------------------
3210:WTPA.c        **** //--------------------------------------
3211:WTPA.c        **** // Control Changes messages are what tells the midi state machine what to do next.
3212:WTPA.c        **** 
3213:WTPA.c        **** /*
3214:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>5)		// About 9.6k -- This is MIDI N
3215:WTPA.c        **** #define		MIDI_GENERIC_NOTE		60											// We use this to pass our midi out note when the sampler 
3216:WTPA.c        **** */
3217:WTPA.c        **** 
3218:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>4)		// 4.8k -- This is MIDI Note 48
3219:WTPA.c        **** #define		MIDI_GENERIC_NOTE		48											// We use this to pass our midi out note when the sampler 
3220:WTPA.c        **** 
3221:WTPA.c        **** static unsigned int
3222:WTPA.c        **** 	theMidiRecordRate[NUM_BANKS];		// Make this from out EEPROM data.
3223:WTPA.c        **** 
3224:WTPA.c        **** // Control Change messages:
3225:WTPA.c        **** // The messages which control binary effects (like Half Speed, or backwards masking) are just inter
3226:WTPA.c        **** 
3227:WTPA.c        **** // Fri Mar 26 22:02:22 EDT 2010
3228:WTPA.c        **** // Renumbered to undefined CCs
3229:WTPA.c        **** 
3230:WTPA.c        **** #define		MIDI_RECORDING				3
3231:WTPA.c        **** #define		MIDI_OVERDUB				9
3232:WTPA.c        **** #define		MIDI_REALTIME				14
3233:WTPA.c        **** #define		MIDI_LOOP					15
3234:WTPA.c        **** #define		MIDI_HALF_SPEED				16
3235:WTPA.c        **** #define		MIDI_PLAY_BACKWARDS			17
3236:WTPA.c        **** #define		MIDI_CANCEL_EFFECTS			18
3237:WTPA.c        **** #define		MIDI_BIT_REDUCTION			19		// Crustiness quotient.
3238:WTPA.c        **** #define 	MIDI_GRANULARITY			20		// Beatbox.
3239:WTPA.c        **** #define 	MIDI_JITTER					21		// Hisssss
3240:WTPA.c        **** #define 	MIDI_OUTPUT_COMBINATION		22		// Set the output (SUM, XOR, AND, MULT) with this message.
3241:WTPA.c        **** #define 	MIDI_STORE_RECORD_NOTE		23		// Makes the next NOTE_ON into the record rate we'll use from 
3242:WTPA.c        **** 
3243:WTPA.c        **** // Editing functions:
3244:WTPA.c        **** 
3245:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_RESOLUTE	24
3246:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_RESOLUTE		25
3247:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE	26
3248:WTPA.c        **** #define 	MIDI_REVERT_SAMPLE_TO_FULL			27
3249:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_WIDE		28
3250:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_WIDE			29
3251:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_WIDE		30
3252:WTPA.c        **** 
3253:WTPA.c        **** static const unsigned int OctaveZeroCompareMatches[]=
3254:WTPA.c        **** // This table corresponds to a musical octave (the lowest octave we can generate with a 16-bit comp
3255:WTPA.c        **** {
3256:WTPA.c        **** 	65535,		// This is 300 Hz. (Followed by 600, 1.2k, 2.4k, 4.8k, 9.6k, 19.2k shifted over by 1 to 6 
3257:WTPA.c        **** 	61857,
3258:WTPA.c        **** 	58385,
3259:WTPA.c        **** 	55108,
3260:WTPA.c        **** 	52015,
3261:WTPA.c        **** 	49096,
3262:WTPA.c        **** 	46340,
3263:WTPA.c        **** 	43739,
3264:WTPA.c        **** 	41284,
3265:WTPA.c        **** 	38967,
3266:WTPA.c        **** 	36780,
3267:WTPA.c        **** 	34716,
3268:WTPA.c        **** };
3269:WTPA.c        **** 
3270:WTPA.c        **** enum	// Note names for lookups.
3271:WTPA.c        **** {
3272:WTPA.c        **** 	C_NOTE=0,
3273:WTPA.c        **** 	D_FLAT_NOTE,
3274:WTPA.c        **** 	D_NOTE,
3275:WTPA.c        **** 	E_FLAT_NOTE,
3276:WTPA.c        **** 	E_NOTE,
3277:WTPA.c        **** 	F_NOTE,
3278:WTPA.c        **** 	G_FLAT_NOTE,
3279:WTPA.c        **** 	G_NOTE,
3280:WTPA.c        **** 	A_FLAT_NOTE,
3281:WTPA.c        **** 	A_NOTE,
3282:WTPA.c        **** 	B_FLAT_NOTE,
3283:WTPA.c        **** 	B_NOTE,
3284:WTPA.c        **** };
3285:WTPA.c        **** 
3286:WTPA.c        **** static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
3287:WTPA.c        **** // Here we take a midi note number and turn it into the timer one compare match interrupt value.
3288:WTPA.c        **** {
3289:WTPA.c        **** 	unsigned char
3290:WTPA.c        **** 		theIndex,
3291:WTPA.c        **** 		theOctave;
3292:WTPA.c        **** 
3293:WTPA.c        **** 	theOctave=(theNote/12);	// Which octave?
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
3295:WTPA.c        **** 
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
3297:WTPA.c        **** 
3298:WTPA.c        **** }
3299:WTPA.c        **** 
3300:WTPA.c        **** //--------------------------------------
3301:WTPA.c        **** //--------------------------------------
3302:WTPA.c        **** // General Interface Functions
3303:WTPA.c        **** //--------------------------------------
3304:WTPA.c        **** //--------------------------------------
3305:WTPA.c        **** 
3306:WTPA.c        **** //==============================================
3307:WTPA.c        **** // Display update stuff, housekeeping:
3308:WTPA.c        **** 
3309:WTPA.c        **** static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
3310:WTPA.c        **** // We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for t
3311:WTPA.c        **** {
3312:WTPA.c        **** 	if(theBank==BANK_0)
3313:WTPA.c        **** 	{
3314:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
3315:WTPA.c        **** 	}
3316:WTPA.c        **** 	else if(theBank==BANK_1)
3317:WTPA.c        **** 	{
3318:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
3319:WTPA.c        **** 	}
3320:WTPA.c        **** }
3321:WTPA.c        **** 
3322:WTPA.c        **** static unsigned char GetMidiRecordNote(unsigned char theBank)
3323:WTPA.c        **** // Get the note we stored in EEPROM.
3324:WTPA.c        **** {
3325:WTPA.c        **** 	unsigned char
3326:WTPA.c        **** 		x;
3327:WTPA.c        **** 
3328:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3329:WTPA.c        **** 
3330:WTPA.c        **** 	if(theBank==BANK_0)
3331:WTPA.c        **** 	{
3332:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
3333:WTPA.c        **** 	}
3334:WTPA.c        **** 	else if(theBank==BANK_1)
3335:WTPA.c        **** 	{
3336:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
3337:WTPA.c        **** 	}
3338:WTPA.c        **** 
3339:WTPA.c        **** 	if(x<90)					// Legit number?
3340:WTPA.c        **** 	{
3341:WTPA.c        **** 		return(x);
3342:WTPA.c        **** 	}
3343:WTPA.c        **** 	else
3344:WTPA.c        **** 	{
3345:WTPA.c        **** 		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or 
3346:WTPA.c        **** 		return(x);
3347:WTPA.c        **** 	}
3348:WTPA.c        **** }
3349:WTPA.c        **** 
3350:WTPA.c        **** 
3351:WTPA.c        **** static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
3352:WTPA.c        **** // We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This
3353:WTPA.c        **** {
3354:WTPA.c        **** 	if(theBank==BANK_0)
3355:WTPA.c        **** 	{
3356:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
3357:WTPA.c        **** 	}
3358:WTPA.c        **** 	else if(theBank==BANK_1)
3359:WTPA.c        **** 	{
3360:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
3361:WTPA.c        **** 	}
3362:WTPA.c        **** }
3363:WTPA.c        **** 
3364:WTPA.c        **** 
3365:WTPA.c        **** static unsigned char GetMidiChannel(unsigned char theBank)
3366:WTPA.c        **** // Get the midi channel we stored in EEPROM.
3367:WTPA.c        **** {
3368:WTPA.c        **** 	unsigned char
3369:WTPA.c        **** 		x;
3370:WTPA.c        **** 
3371:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3372:WTPA.c        **** 
3373:WTPA.c        **** 	if(theBank==BANK_0)
3374:WTPA.c        **** 	{
3375:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
3376:WTPA.c        **** 	}
3377:WTPA.c        **** 	else if(theBank==BANK_1)
3378:WTPA.c        **** 	{
3379:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
3380:WTPA.c        **** 	}
3381:WTPA.c        **** 
3382:WTPA.c        **** 	if(x<16)					// Legit number?
3383:WTPA.c        **** 	{
3384:WTPA.c        **** 		return(x);
3385:WTPA.c        **** 	}
3386:WTPA.c        **** 	else
3387:WTPA.c        **** 	{
3388:WTPA.c        **** 		if(theBank==BANK_0)
3389:WTPA.c        **** 		{
3390:WTPA.c        **** 			x=0;			// If we've got poo poo in EEPROM or a bad address then default to the first midi channel
3391:WTPA.c        **** 		}
3392:WTPA.c        **** 		else
3393:WTPA.c        **** 		{
3394:WTPA.c        **** 			x=1;			// Return midi channel 2 if we're screwing up the second bank.
3395:WTPA.c        **** 		}
3396:WTPA.c        **** 		return(x);
3397:WTPA.c        **** 	}
3398:WTPA.c        **** }
3399:WTPA.c        **** 
3400:WTPA.c        **** static void BankStatesToLeds(unsigned char theBank)
3401:WTPA.c        **** // Looks at the current bank and decides how to set the LEDs.
3402:WTPA.c        **** {
3403:WTPA.c        **** 	unsigned char
3404:WTPA.c        **** 		temp;
3405:WTPA.c        **** 
3406:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
3407:WTPA.c        **** 
3408:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
3409:WTPA.c        **** 	{
3410:WTPA.c        **** 		temp|=Om_LED_REC;
3411:WTPA.c        **** 	}
3412:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
3413:WTPA.c        **** 	{
3414:WTPA.c        **** 		temp|=Om_LED_PLAY;
3415:WTPA.c        **** 	}
3416:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
3417:WTPA.c        **** 	{
3418:WTPA.c        **** 		temp|=Om_LED_ODUB;
3419:WTPA.c        **** 	}
3420:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
3421:WTPA.c        **** 	{
3422:WTPA.c        **** 		temp|=Om_LED_REC;
3423:WTPA.c        **** 		temp|=Om_LED_PLAY;
3424:WTPA.c        **** 		temp|=Om_LED_ODUB;
3425:WTPA.c        **** 	}
3426:WTPA.c        **** 
3427:WTPA.c        **** 	if(outOfRam==true)
3428:WTPA.c        **** 	{
3429:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
3430:WTPA.c        **** 	}
3431:WTPA.c        **** 	if(theBank==BANK_1)
3432:WTPA.c        **** 	{
3433:WTPA.c        **** 		temp|=Om_LED_BANK;
3434:WTPA.c        **** 	}
3435:WTPA.c        **** 
3436:WTPA.c        **** 	ledOnOffMask=temp;
3437:WTPA.c        **** 
3438:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
3439:WTPA.c        **** 	{
3440:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
3441:WTPA.c        **** 		{
3442:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
3443:WTPA.c        **** 		}
3444:WTPA.c        **** 	}
3445:WTPA.c        **** 	else
3446:WTPA.c        **** 	{
3447:WTPA.c        **** 		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we 
3448:WTPA.c        **** 	}
3449:WTPA.c        **** }
3450:WTPA.c        **** 
3451:WTPA.c        **** static void EncoderReadingToLeds(void)
3452:WTPA.c        **** // Take the value on our analog input, scale it, and display it on the LEDs.
3453:WTPA.c        **** // @@@ Note, this is a badly named function since it both generates the scaled global pot value AND
3454:WTPA.c        **** {
3455:WTPA.c        **** 	unsigned char
3456:WTPA.c        **** 		temp;
3457:WTPA.c        **** 
3458:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
3459:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
3460:WTPA.c        **** 
3461:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
3462:WTPA.c        **** 	{
3463:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
3464:WTPA.c        **** 	}
3465:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
3466:WTPA.c        **** 	{
3467:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
3468:WTPA.c        **** 	}
3469:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
3470:WTPA.c        **** 	{
3471:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
3472:WTPA.c        **** 	}
3473:WTPA.c        **** 
3474:WTPA.c        **** 	ledOnOffMask=temp;		// Update the leds.
3475:WTPA.c        **** }
3476:WTPA.c        **** 
3477:WTPA.c        **** static void CleanupAudioSources(void)
3478:WTPA.c        **** // Look through all the banks, and if none are using a given interrupt source, disable that interru
3479:WTPA.c        **** // Also voids the contributions those interrupts have to the audio output.
3480:WTPA.c        **** {
3481:WTPA.c        **** 	// If we aren't streaming from the SD, void contribution to the DAC
3482:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
3483:WTPA.c        **** 	{
3484:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
3485:WTPA.c        **** 	}
3486:WTPA.c        **** 
3487:WTPA.c        **** 	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
3488:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
3489:WTPA.c        **** 	{
3490:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
3491:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
3492:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
3493:WTPA.c        **** 	}
3494:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
3495:WTPA.c        **** 	{
3496:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
3497:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
3498:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
3499:WTPA.c        **** 	}
3500:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
3501:WTPA.c        **** 	{
3502:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
3503:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
3504:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
3505:WTPA.c        **** 	}
3506:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
3507:WTPA.c        **** 	{
3508:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
3509:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
3510:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
3511:WTPA.c        **** 	}
3512:WTPA.c        **** 
3513:WTPA.c        **** 	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop
3514:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
3515:WTPA.c        **** 	{
3516:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
3517:WTPA.c        **** 		{
3518:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
3519:WTPA.c        **** 		}
3520:WTPA.c        **** 	}
3521:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
3522:WTPA.c        **** 	{
3523:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
3524:WTPA.c        **** 		{
3525:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
3526:WTPA.c        **** 		}
3527:WTPA.c        **** 	}
3528:WTPA.c        **** }
3529:WTPA.c        **** 
3530:WTPA.c        **** //--------------------------------------
3531:WTPA.c        **** //--------------------------------------
3532:WTPA.c        **** // Granularizing Functions:
3533:WTPA.c        **** //--------------------------------------
3534:WTPA.c        **** //--------------------------------------
3535:WTPA.c        **** 
3536:WTPA.c        **** static unsigned long GetRandomLongInt(void)
3537:WTPA.c        **** {
 2087               		.loc 1 3537 0
 2088               		.cfi_startproc
 2089               	/* prologue: function */
 2090               	/* frame size = 0 */
 2091               	/* stack size = 0 */
 2092               	.L__stack_usage = 0
3538:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
 2093               		.loc 1 3538 0
 2094 1116 4091 0000 		lds r20,random31
 2095 111a 5091 0000 		lds r21,random31+1
 2096 111e 6091 0000 		lds r22,random31+2
 2097 1122 7091 0000 		lds r23,random31+3
3539:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
 2098               		.loc 1 3539 0
 2099 1126 DB01      		movw r26,r22
 2100 1128 CA01      		movw r24,r20
 2101 112a 880F      		lsl r24
 2102 112c 991F      		rol r25
 2103 112e AA1F      		rol r26
 2104 1130 BB1F      		rol r27
 2105 1132 76FF      		sbrs r23,6
 2106 1134 00C0      		rjmp .L131
 2107               	.L129:
3540:WTPA.c        **** 	{
3541:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 2108               		.loc 1 3541 0
 2109 1136 25EB      		ldi r18,181
 2110 1138 8227      		eor r24,r18
 2111 113a 25E9      		ldi r18,149
 2112 113c 9227      		eor r25,r18
 2113 113e 2AEA      		ldi r18,170
 2114 1140 A227      		eor r26,r18
 2115 1142 20E2      		ldi r18,32
 2116 1144 B227      		eor r27,r18
 2117               	.L131:
 2118 1146 8093 0000 		sts random31,r24
 2119 114a 9093 0000 		sts random31+1,r25
 2120 114e A093 0000 		sts random31+2,r26
 2121 1152 B093 0000 		sts random31+3,r27
3542:WTPA.c        **** 	}
3543:WTPA.c        **** 	return(random31);
 2122               		.loc 1 3543 0
 2123 1156 6091 0000 		lds r22,random31
 2124 115a 7091 0000 		lds r23,random31+1
3544:WTPA.c        **** }
 2125               		.loc 1 3544 0
 2126 115e 8091 0000 		lds r24,random31+2
 2127 1162 9091 0000 		lds r25,random31+3
 2128 1166 0895      		ret
 2129               		.cfi_endproc
 2130               	.LFE59:
 2133               	MakeNewGranularArray:
 2134               	.LFB60:
3545:WTPA.c        **** 
3546:WTPA.c        **** /*
3547:WTPA.c        **** static void InitRandom(void)
3548:WTPA.c        **** // Maximal (?) LSFR implementation complements of "curtvm" on AVRFreaks.  Thanks!
3549:WTPA.c        **** // Not sure where his tap numbers came from, but we'll see how they work out.
3550:WTPA.c        **** // This LFSR is initialized here from the poo-poo (undef'd) area of RAM and checked against zero.  
3551:WTPA.c        **** {
3552:WTPA.c        **** 	if(random31==0)	 			// If init sram happens to be 0
3553:WTPA.c        **** 	{
3554:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3555:WTPA.c        **** 	}
3556:WTPA.c        **** }
3557:WTPA.c        **** */
3558:WTPA.c        **** 
3559:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
3560:WTPA.c        **** // Make a new random order of slices as big as the user wants, up to MAX_SLICES.
3561:WTPA.c        **** // We will first fill an array with incrementing numbers up to the number of slices we care about, 
3562:WTPA.c        **** // Leave this function having updated the number of slices our sample will be divided into and the 
3563:WTPA.c        **** // Further, point to the first random slice in the randomized array, and point the sample address t
3564:WTPA.c        **** {
 2135               		.loc 1 3564 0
 2136               		.cfi_startproc
 2137               	.LVL58:
 2138 1168 2F92      		push r2
 2139               	.LCFI2:
 2140               		.cfi_def_cfa_offset 3
 2141               		.cfi_offset 2, -2
 2142 116a 3F92      		push r3
 2143               	.LCFI3:
 2144               		.cfi_def_cfa_offset 4
 2145               		.cfi_offset 3, -3
 2146 116c 4F92      		push r4
 2147               	.LCFI4:
 2148               		.cfi_def_cfa_offset 5
 2149               		.cfi_offset 4, -4
 2150 116e 5F92      		push r5
 2151               	.LCFI5:
 2152               		.cfi_def_cfa_offset 6
 2153               		.cfi_offset 5, -5
 2154 1170 6F92      		push r6
 2155               	.LCFI6:
 2156               		.cfi_def_cfa_offset 7
 2157               		.cfi_offset 6, -6
 2158 1172 7F92      		push r7
 2159               	.LCFI7:
 2160               		.cfi_def_cfa_offset 8
 2161               		.cfi_offset 7, -7
 2162 1174 8F92      		push r8
 2163               	.LCFI8:
 2164               		.cfi_def_cfa_offset 9
 2165               		.cfi_offset 8, -8
 2166 1176 9F92      		push r9
 2167               	.LCFI9:
 2168               		.cfi_def_cfa_offset 10
 2169               		.cfi_offset 9, -9
 2170 1178 AF92      		push r10
 2171               	.LCFI10:
 2172               		.cfi_def_cfa_offset 11
 2173               		.cfi_offset 10, -10
 2174 117a BF92      		push r11
 2175               	.LCFI11:
 2176               		.cfi_def_cfa_offset 12
 2177               		.cfi_offset 11, -11
 2178 117c CF92      		push r12
 2179               	.LCFI12:
 2180               		.cfi_def_cfa_offset 13
 2181               		.cfi_offset 12, -12
 2182 117e DF92      		push r13
 2183               	.LCFI13:
 2184               		.cfi_def_cfa_offset 14
 2185               		.cfi_offset 13, -13
 2186 1180 EF92      		push r14
 2187               	.LCFI14:
 2188               		.cfi_def_cfa_offset 15
 2189               		.cfi_offset 14, -14
 2190 1182 FF92      		push r15
 2191               	.LCFI15:
 2192               		.cfi_def_cfa_offset 16
 2193               		.cfi_offset 15, -15
 2194 1184 0F93      		push r16
 2195               	.LCFI16:
 2196               		.cfi_def_cfa_offset 17
 2197               		.cfi_offset 16, -16
 2198 1186 1F93      		push r17
 2199               	.LCFI17:
 2200               		.cfi_def_cfa_offset 18
 2201               		.cfi_offset 17, -17
 2202 1188 CF93      		push r28
 2203               	.LCFI18:
 2204               		.cfi_def_cfa_offset 19
 2205               		.cfi_offset 28, -18
 2206 118a DF93      		push r29
 2207               	.LCFI19:
 2208               		.cfi_def_cfa_offset 20
 2209               		.cfi_offset 29, -19
 2210               	/* prologue: function */
 2211               	/* frame size = 0 */
 2212               	/* stack size = 18 */
 2213               	.L__stack_usage = 18
 2214 118c 382E      		mov r3,r24
3565:WTPA.c        **** 	unsigned char
3566:WTPA.c        **** 		sreg,
3567:WTPA.c        **** 		i,
3568:WTPA.c        **** 		origContents,
3569:WTPA.c        **** 		randIndex,
3570:WTPA.c        **** 		randContents;
3571:WTPA.c        **** 
3572:WTPA.c        **** 	if(numSlices>1)		// Enough slices to do something?
 2215               		.loc 1 3572 0
 2216 118e 6230      		cpi r22,lo8(2)
 2217 1190 00F4      		brsh .+2
 2218 1192 00C0      		rjmp .L133
3573:WTPA.c        **** 	{
3574:WTPA.c        **** 		sreg=SREG;
 2219               		.loc 1 3574 0
 2220 1194 9FB6      		in r9,__SREG__
 2221               	.LVL59:
3575:WTPA.c        **** 		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
 2222               		.loc 1 3575 0
 2223               	/* #APP */
 2224               	 ;  3575 "WTPA.c" 1
 2225 1196 F894      		cli
 2226               	 ;  0 "" 2
 2227               	/* #NOAPP */
 2228 1198 862E      		mov r8,r22
 2229 119a 80E8      		ldi r24,lo8(-128)
 2230               	.LVL60:
 2231 119c 8617      		cp r24,r22
 2232 119e 00F4      		brsh .L134
 2233 11a0 00E8      		ldi r16,lo8(-128)
 2234 11a2 802E      		mov r8,r16
 2235               	.L134:
 2236               	.LVL61:
3559:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2237               		.loc 1 3559 0
 2238 11a4 C32D      		mov r28,r3
 2239 11a6 D0E0      		ldi r29,0
 2240 11a8 9E01      		movw r18,r28
 2241 11aa 3695      		lsr r19
 2242 11ac 322F      		mov r19,r18
 2243 11ae 2227      		clr r18
 2244 11b0 3795      		ror r19
 2245 11b2 2795      		ror r18
 2246 11b4 2050      		subi r18,lo8(-(granularPositionArray))
 2247 11b6 3040      		sbci r19,hi8(-(granularPositionArray))
 2248 11b8 80E0      		ldi r24,0
 2249 11ba 90E0      		ldi r25,0
 2250               	.LVL62:
 2251               	.L135:
3559:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2252               		.loc 1 3559 0 is_stmt 0 discriminator 2
 2253 11bc F901      		movw r30,r18
 2254 11be E80F      		add r30,r24
 2255 11c0 F91F      		adc r31,r25
3576:WTPA.c        **** 
3577:WTPA.c        **** 		if(numSlices>MAX_SLICES)
3578:WTPA.c        **** 		{
3579:WTPA.c        **** 			numSlices=MAX_SLICES;
3580:WTPA.c        **** 		}
3581:WTPA.c        **** 
3582:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
3583:WTPA.c        **** 		{
3584:WTPA.c        **** 			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwa
 2256               		.loc 1 3584 0 is_stmt 1 discriminator 2
 2257 11c2 8083      		st Z,r24
 2258               	.LVL63:
 2259 11c4 0196      		adiw r24,1
 2260               	.LVL64:
3582:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2261               		.loc 1 3582 0 discriminator 2
 2262 11c6 8815      		cp r24,r8
 2263 11c8 00F0      		brlo .L135
3559:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2264               		.loc 1 3559 0
 2265 11ca 6E01      		movw r12,r28
 2266 11cc D694      		lsr r13
 2267 11ce DC2C      		mov r13,r12
 2268 11d0 CC24      		clr r12
 2269 11d2 D794      		ror r13
 2270 11d4 C794      		ror r12
 2271 11d6 B0E0      		ldi r27,lo8(granularPositionArray)
 2272 11d8 AB2E      		mov r10,r27
 2273 11da B0E0      		ldi r27,hi8(granularPositionArray)
 2274 11dc BB2E      		mov r11,r27
 2275 11de AC0C      		add r10,r12
 2276 11e0 BD1C      		adc r11,r13
 2277 11e2 00E0      		ldi r16,0
 2278 11e4 10E0      		ldi r17,0
3585:WTPA.c        **** 		}
3586:WTPA.c        **** 
3587:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
3588:WTPA.c        **** 		{
3589:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
3590:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
 2279               		.loc 1 3590 0
 2280 11e6 482C      		mov r4,r8
 2281 11e8 512C      		mov r5,__zero_reg__
 2282 11ea 612C      		mov r6,__zero_reg__
 2283 11ec 712C      		mov r7,__zero_reg__
 2284               	.LVL65:
 2285               	.L136:
3559:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2286               		.loc 1 3559 0 discriminator 2
 2287 11ee 7501      		movw r14,r10
 2288 11f0 E00E      		add r14,r16
 2289 11f2 F11E      		adc r15,r17
3589:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
 2290               		.loc 1 3589 0 discriminator 2
 2291 11f4 D701      		movw r26,r14
 2292 11f6 2C90      		ld r2,X
 2293               	.LVL66:
 2294               		.loc 1 3590 0 discriminator 2
 2295 11f8 0E94 0000 		call GetRandomLongInt
 2296               	.LVL67:
 2297 11fc A301      		movw r20,r6
 2298 11fe 9201      		movw r18,r4
 2299 1200 0E94 0000 		call __udivmodsi4
 2300               	.LVL68:
3591:WTPA.c        **** 			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery ad
 2301               		.loc 1 3591 0 discriminator 2
 2302 1204 FB01      		movw r30,r22
 2303 1206 EC0D      		add r30,r12
 2304 1208 FD1D      		adc r31,r13
 2305 120a E050      		subi r30,lo8(-(granularPositionArray))
 2306 120c F040      		sbci r31,hi8(-(granularPositionArray))
 2307 120e 8081      		ld r24,Z
 2308               	.LVL69:
3592:WTPA.c        **** 			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the
 2309               		.loc 1 3592 0 discriminator 2
 2310 1210 D701      		movw r26,r14
 2311 1212 8C93      		st X,r24
3593:WTPA.c        **** 			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original reg
 2312               		.loc 1 3593 0 discriminator 2
 2313 1214 2082      		st Z,r2
 2314 1216 0F5F      		subi r16,-1
 2315 1218 1F4F      		sbci r17,-1
3587:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
 2316               		.loc 1 3587 0 discriminator 2
 2317 121a 0815      		cp r16,r8
 2318 121c 00F0      		brlo .L136
3594:WTPA.c        **** 		}
3595:WTPA.c        **** 
3596:WTPA.c        **** 		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
 2319               		.loc 1 3596 0
 2320 121e 3110      		cpse r3,__zero_reg__
 2321 1220 00C0      		rjmp .L137
3597:WTPA.c        **** 		{
3598:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
 2322               		.loc 1 3598 0
 2323 1222 6091 0000 		lds r22,bankStates+12
 2324 1226 7091 0000 		lds r23,bankStates+12+1
 2325 122a 8091 0000 		lds r24,bankStates+12+2
 2326 122e 9091 0000 		lds r25,bankStates+12+3
 2327 1232 A301      		movw r20,r6
 2328 1234 9201      		movw r18,r4
 2329 1236 0E94 0000 		call __udivmodsi4
 2330 123a 2093 0000 		sts sliceSize,r18
 2331 123e 3093 0000 		sts sliceSize+1,r19
 2332 1242 4093 0000 		sts sliceSize+2,r20
 2333 1246 5093 0000 		sts sliceSize+3,r21
 2334 124a 00C0      		rjmp .L138
 2335               	.L137:
3599:WTPA.c        **** 		}
3600:WTPA.c        **** 		else					// Otherwise assume banks grow down.
3601:WTPA.c        **** 		{
3602:WTPA.c        **** 			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
 2336               		.loc 1 3602 0
 2337 124c 0091 0000 		lds r16,bankStates+47
 2338 1250 1091 0000 		lds r17,bankStates+47+1
 2339 1254 2091 0000 		lds r18,bankStates+47+2
 2340 1258 3091 0000 		lds r19,bankStates+47+3
 2341 125c 6FEF      		ldi r22,lo8(-1)
 2342 125e 7FEF      		ldi r23,lo8(-1)
 2343 1260 87E0      		ldi r24,lo8(7)
 2344 1262 90E0      		ldi r25,0
 2345 1264 601B      		sub r22,r16
 2346 1266 710B      		sbc r23,r17
 2347 1268 820B      		sbc r24,r18
 2348 126a 930B      		sbc r25,r19
 2349 126c A301      		movw r20,r6
 2350 126e 9201      		movw r18,r4
 2351 1270 0E94 0000 		call __udivmodsi4
 2352 1274 2093 0000 		sts sliceSize+4,r18
 2353 1278 3093 0000 		sts sliceSize+4+1,r19
 2354 127c 4093 0000 		sts sliceSize+4+2,r20
 2355 1280 5093 0000 		sts sliceSize+4+3,r21
 2356               	.L138:
3603:WTPA.c        **** 		}
3604:WTPA.c        **** 
3605:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
 2357               		.loc 1 3605 0
 2358 1284 83E2      		ldi r24,lo8(35)
 2359               	.LVL70:
 2360 1286 8C9F      		mul r24,r28
 2361 1288 F001      		movw r30,r0
 2362 128a 8D9F      		mul r24,r29
 2363 128c F00D      		add r31,r0
 2364 128e 1124      		clr __zero_reg__
 2365 1290 E050      		subi r30,lo8(-(bankStates))
 2366 1292 F040      		sbci r31,hi8(-(bankStates))
 2367 1294 8682      		std Z+6,r8
3606:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
 2368               		.loc 1 3606 0
 2369 1296 FE01      		movw r30,r28
 2370 1298 E050      		subi r30,lo8(-(granularPositionArrayPointer))
 2371 129a F040      		sbci r31,hi8(-(granularPositionArrayPointer))
 2372 129c 1082      		st Z,__zero_reg__
3607:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
 2373               		.loc 1 3607 0
 2374 129e CC0F      		lsl r28
 2375 12a0 DD1F      		rol r29
 2376 12a2 CC0F      		lsl r28
 2377 12a4 DD1F      		rol r29
 2378 12a6 FE01      		movw r30,r28
 2379 12a8 E050      		subi r30,lo8(-(sliceSize))
 2380 12aa F040      		sbci r31,hi8(-(sliceSize))
 2381 12ac 8081      		ld r24,Z
 2382 12ae 9181      		ldd r25,Z+1
 2383 12b0 A281      		ldd r26,Z+2
 2384 12b2 B381      		ldd r27,Z+3
 2385 12b4 C050      		subi r28,lo8(-(sliceRemaining))
 2386 12b6 D040      		sbci r29,hi8(-(sliceRemaining))
 2387 12b8 8883      		st Y,r24
 2388 12ba 9983      		std Y+1,r25
 2389 12bc AA83      		std Y+2,r26
 2390 12be BB83      		std Y+3,r27
3608:WTPA.c        **** 
3609:WTPA.c        **** 		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the fir
 2391               		.loc 1 3609 0
 2392 12c0 3110      		cpse r3,__zero_reg__
 2393 12c2 00C0      		rjmp .L139
3610:WTPA.c        **** 		{
3611:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
 2394               		.loc 1 3611 0
 2395 12c4 2091 0000 		lds r18,sliceSize
 2396 12c8 3091 0000 		lds r19,sliceSize+1
 2397 12cc 4091 0000 		lds r20,sliceSize+2
 2398 12d0 5091 0000 		lds r21,sliceSize+3
 2399 12d4 A091 0000 		lds r26,granularPositionArray
 2400 12d8 B0E0      		ldi r27,0
 2401 12da 0E94 0000 		call __muluhisi3
 2402 12de 6093 0000 		sts bankStates+31,r22
 2403 12e2 7093 0000 		sts bankStates+31+1,r23
 2404 12e6 8093 0000 		sts bankStates+31+2,r24
 2405 12ea 9093 0000 		sts bankStates+31+3,r25
 2406 12ee 00C0      		rjmp .L140
 2407               	.L139:
3612:WTPA.c        **** 		}
3613:WTPA.c        **** 		else
3614:WTPA.c        **** 		{
3615:WTPA.c        **** 			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceS
 2408               		.loc 1 3615 0
 2409 12f0 2091 0000 		lds r18,sliceSize+4
 2410 12f4 3091 0000 		lds r19,sliceSize+4+1
 2411 12f8 4091 0000 		lds r20,sliceSize+4+2
 2412 12fc 5091 0000 		lds r21,sliceSize+4+3
 2413 1300 A091 0000 		lds r26,granularPositionArray+128
 2414 1304 B0E0      		ldi r27,0
 2415 1306 0E94 0000 		call __muluhisi3
 2416 130a 0FEF      		ldi r16,lo8(-1)
 2417 130c 1FEF      		ldi r17,lo8(-1)
 2418 130e 27E0      		ldi r18,lo8(7)
 2419 1310 30E0      		ldi r19,0
 2420 1312 061B      		sub r16,r22
 2421 1314 170B      		sbc r17,r23
 2422 1316 280B      		sbc r18,r24
 2423 1318 390B      		sbc r19,r25
 2424 131a 0093 0000 		sts bankStates+66,r16
 2425 131e 1093 0000 		sts bankStates+66+1,r17
 2426 1322 2093 0000 		sts bankStates+66+2,r18
 2427 1326 3093 0000 		sts bankStates+66+3,r19
 2428               	.L140:
3616:WTPA.c        **** 		}
3617:WTPA.c        **** 
3618:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 2429               		.loc 1 3618 0
 2430 132a 9FBE      		out __SREG__,r9
 2431 132c 00C0      		rjmp .L132
 2432               	.LVL71:
 2433               	.L133:
3619:WTPA.c        **** 	}
3620:WTPA.c        **** 	else
3621:WTPA.c        **** 	{
3622:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
 2434               		.loc 1 3622 0
 2435 132e B3E2      		ldi r27,lo8(35)
 2436 1330 8B9F      		mul r24,r27
 2437 1332 F001      		movw r30,r0
 2438 1334 1124      		clr __zero_reg__
 2439 1336 E050      		subi r30,lo8(-(bankStates))
 2440 1338 F040      		sbci r31,hi8(-(bankStates))
 2441 133a 1682      		std Z+6,__zero_reg__
 2442               	.LVL72:
 2443               	.L132:
 2444               	/* epilogue start */
3623:WTPA.c        **** 	}
3624:WTPA.c        **** }
 2445               		.loc 1 3624 0
 2446 133c DF91      		pop r29
 2447 133e CF91      		pop r28
 2448 1340 1F91      		pop r17
 2449 1342 0F91      		pop r16
 2450 1344 FF90      		pop r15
 2451 1346 EF90      		pop r14
 2452 1348 DF90      		pop r13
 2453 134a CF90      		pop r12
 2454 134c BF90      		pop r11
 2455 134e AF90      		pop r10
 2456 1350 9F90      		pop r9
 2457 1352 8F90      		pop r8
 2458 1354 7F90      		pop r7
 2459 1356 6F90      		pop r6
 2460 1358 5F90      		pop r5
 2461 135a 4F90      		pop r4
 2462 135c 3F90      		pop r3
 2463               	.LVL73:
 2464 135e 2F90      		pop r2
 2465 1360 0895      		ret
 2466               		.cfi_endproc
 2467               	.LFE60:
 2470               	UpdateAdjustedSampleAddresses:
 2471               	.LFB61:
3625:WTPA.c        **** 
3626:WTPA.c        **** //--------------------------------------
3627:WTPA.c        **** //--------------------------------------
3628:WTPA.c        **** // Shuttle / Loop Size Adjust Functions:
3629:WTPA.c        **** //--------------------------------------
3630:WTPA.c        **** //--------------------------------------
3631:WTPA.c        **** // These functions are called to bump the beginning of a sample forward or backward by an amount di
3632:WTPA.c        **** // The resolution of these functions is dependent on the absolute number of individual samples curr
3633:WTPA.c        **** // 	we divide the entire sample by 256 to find our "chunk size" and then shuttle the sample start /
3634:WTPA.c        **** // NOTE:  It is possible with these commands to position the sample's working boundaries such that 
3635:WTPA.c        **** // NOTE:  It is possible to move a sample's adjusted end come BEFORE its adjusted beginning.  We mu
3636:WTPA.c        **** // NOTE:  It is possible to have the sample roll around the end address.  Account for this.
3637:WTPA.c        **** 
3638:WTPA.c        **** // We will need to update the ISR so that playback rolls through the end address.
3639:WTPA.c        **** // Mon Nov  9 22:32:16 EST 2009 -- Think I got it.
3640:WTPA.c        **** 
3641:WTPA.c        **** // Thu Mar 25 21:44:28 EDT 2010
3642:WTPA.c        **** // Window problems.  When the window wraps around the absolute address of the sample, bad shit goes
3643:WTPA.c        **** // Fri Mar 26 14:46:06 EDT 2010
3644:WTPA.c        **** // Fixed.  I made some dumb changes to the ISR address wrapping and also didn't accout for the fact
3645:WTPA.c        **** 
3646:WTPA.c        **** // Fri Mar 26 18:55:07 EDT 2010
3647:WTPA.c        **** // Changed the way the whole sampler thinks about "direction" in playback.  The user sets the backw
3648:WTPA.c        **** // The variable read by the interrupt is "sampleDirection" which actually tells us which way to go 
3649:WTPA.c        **** // This system lets us arbitrarily set the way we want the sample to go, and then reverse it when t
3650:WTPA.c        **** 
3651:WTPA.c        **** static void UpdateAdjustedSampleAddresses(unsigned char theBank)
3652:WTPA.c        **** // Using window, start, and stop info, this routine sets the beginning and end point within a sampl
3653:WTPA.c        **** // We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of th
3654:WTPA.c        **** // Wed Jun 22 13:50:04 EDT 2011
3655:WTPA.c        **** // Now that we use an encoder we could adjust this more finely if we wanted to.
3656:WTPA.c        **** {
 2472               		.loc 1 3656 0
 2473               		.cfi_startproc
 2474               	.LVL74:
 2475 1362 4F92      		push r4
 2476               	.LCFI20:
 2477               		.cfi_def_cfa_offset 3
 2478               		.cfi_offset 4, -2
 2479 1364 5F92      		push r5
 2480               	.LCFI21:
 2481               		.cfi_def_cfa_offset 4
 2482               		.cfi_offset 5, -3
 2483 1366 6F92      		push r6
 2484               	.LCFI22:
 2485               		.cfi_def_cfa_offset 5
 2486               		.cfi_offset 6, -4
 2487 1368 7F92      		push r7
 2488               	.LCFI23:
 2489               		.cfi_def_cfa_offset 6
 2490               		.cfi_offset 7, -5
 2491 136a 8F92      		push r8
 2492               	.LCFI24:
 2493               		.cfi_def_cfa_offset 7
 2494               		.cfi_offset 8, -6
 2495 136c 9F92      		push r9
 2496               	.LCFI25:
 2497               		.cfi_def_cfa_offset 8
 2498               		.cfi_offset 9, -7
 2499 136e AF92      		push r10
 2500               	.LCFI26:
 2501               		.cfi_def_cfa_offset 9
 2502               		.cfi_offset 10, -8
 2503 1370 BF92      		push r11
 2504               	.LCFI27:
 2505               		.cfi_def_cfa_offset 10
 2506               		.cfi_offset 11, -9
 2507 1372 CF92      		push r12
 2508               	.LCFI28:
 2509               		.cfi_def_cfa_offset 11
 2510               		.cfi_offset 12, -10
 2511 1374 DF92      		push r13
 2512               	.LCFI29:
 2513               		.cfi_def_cfa_offset 12
 2514               		.cfi_offset 13, -11
 2515 1376 EF92      		push r14
 2516               	.LCFI30:
 2517               		.cfi_def_cfa_offset 13
 2518               		.cfi_offset 14, -12
 2519 1378 FF92      		push r15
 2520               	.LCFI31:
 2521               		.cfi_def_cfa_offset 14
 2522               		.cfi_offset 15, -13
 2523               	/* prologue: function */
 2524               	/* frame size = 0 */
 2525               	/* stack size = 12 */
 2526               	.L__stack_usage = 12
3657:WTPA.c        **** 	unsigned char
3658:WTPA.c        **** 		sreg;
3659:WTPA.c        **** 	unsigned long
3660:WTPA.c        **** 		chunkSize;
3661:WTPA.c        **** 
3662:WTPA.c        **** 	sreg=SREG;
 2527               		.loc 1 3662 0
 2528 137a EFB7      		in r30,__SREG__
 2529               	.LVL75:
3663:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 2530               		.loc 1 3663 0
 2531               	/* #APP */
 2532               	 ;  3663 "WTPA.c" 1
 2533 137c F894      		cli
 2534               	 ;  0 "" 2
3664:WTPA.c        **** 
3665:WTPA.c        **** 	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
 2535               		.loc 1 3665 0
 2536               	/* #NOAPP */
 2537 137e 8111      		cpse r24,__zero_reg__
 2538 1380 00C0      		rjmp .L145
3666:WTPA.c        **** 	{
3667:WTPA.c        **** 		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of
 2539               		.loc 1 3667 0
 2540 1382 8090 0000 		lds r8,bankStates+12
 2541 1386 9090 0000 		lds r9,bankStates+12+1
 2542 138a A090 0000 		lds r10,bankStates+12+2
 2543 138e B090 0000 		lds r11,bankStates+12+3
 2544 1392 83E0      		ldi r24,3
 2545               		1:
 2546 1394 880C      		lsl r8
 2547 1396 991C      		rol r9
 2548 1398 AA1C      		rol r10
 2549 139a BB1C      		rol r11
 2550 139c 8A95      		dec r24
 2551 139e 01F4      		brne 1b
 2552               	.LVL76:
 2553 13a0 892C      		mov r8,r9
 2554 13a2 9A2C      		mov r9,r10
 2555 13a4 AB2C      		mov r10,r11
 2556 13a6 BB24      		clr r11
 2557               	.LVL77:
3668:WTPA.c        **** 
3669:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3670:WTPA.c        **** 
3671:WTPA.c        **** 		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sam
 2558               		.loc 1 3671 0
 2559 13a8 A091 0000 		lds r26,bankStates+28
 2560 13ac 8091 0000 		lds r24,bankStates+30
 2561 13b0 B0E0      		ldi r27,0
 2562 13b2 A80F      		add r26,r24
 2563 13b4 B11D      		adc r27,__zero_reg__
 2564 13b6 A501      		movw r20,r10
 2565 13b8 9401      		movw r18,r8
 2566 13ba 0E94 0000 		call __muluhisi3
 2567 13be F3E0      		ldi r31,3
 2568               		1:
 2569 13c0 9695      		lsr r25
 2570 13c2 8795      		ror r24
 2571 13c4 7795      		ror r23
 2572 13c6 6795      		ror r22
 2573 13c8 FA95      		dec r31
 2574 13ca 01F4      		brne 1b
 2575 13cc 6093 0000 		sts bankStates+24,r22
 2576 13d0 7093 0000 		sts bankStates+24+1,r23
 2577 13d4 8093 0000 		sts bankStates+24+2,r24
 2578 13d8 9093 0000 		sts bankStates+24+3,r25
3672:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_
 2579               		.loc 1 3672 0
 2580 13dc 4090 0000 		lds r4,bankStates+12
 2581 13e0 5090 0000 		lds r5,bankStates+12+1
 2582 13e4 6090 0000 		lds r6,bankStates+12+2
 2583 13e8 7090 0000 		lds r7,bankStates+12+3
 2584 13ec F091 0000 		lds r31,bankStates+29
 2585 13f0 A091 0000 		lds r26,bankStates+30
 2586 13f4 B0E0      		ldi r27,0
 2587 13f6 0E94 0000 		call __muluhisi3
 2588 13fa 6B01      		movw r12,r22
 2589 13fc 7C01      		movw r14,r24
 2590 13fe A3E0      		ldi r26,3
 2591               		1:
 2592 1400 F694      		lsr r15
 2593 1402 E794      		ror r14
 2594 1404 D794      		ror r13
 2595 1406 C794      		ror r12
 2596 1408 AA95      		dec r26
 2597 140a 01F4      		brne 1b
 2598 140c C40C      		add r12,r4
 2599 140e D51C      		adc r13,r5
 2600 1410 E61C      		adc r14,r6
 2601 1412 F71C      		adc r15,r7
 2602 1414 AF2F      		mov r26,r31
 2603 1416 B0E0      		ldi r27,0
 2604 1418 0E94 0000 		call __muluhisi3
 2605 141c B3E0      		ldi r27,3
 2606               		1:
 2607 141e 9695      		lsr r25
 2608 1420 8795      		ror r24
 2609 1422 7795      		ror r23
 2610 1424 6795      		ror r22
 2611 1426 BA95      		dec r27
 2612 1428 01F4      		brne 1b
 2613 142a C61A      		sub r12,r22
 2614 142c D70A      		sbc r13,r23
 2615 142e E80A      		sbc r14,r24
 2616 1430 F90A      		sbc r15,r25
 2617 1432 C092 0000 		sts bankStates+20,r12
 2618 1436 D092 0000 		sts bankStates+20+1,r13
 2619 143a E092 0000 		sts bankStates+20+2,r14
 2620 143e F092 0000 		sts bankStates+20+3,r15
3673:WTPA.c        **** 
3674:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3675:WTPA.c        **** 
3676:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse play
 2621               		.loc 1 3676 0
 2622 1442 4091 0000 		lds r20,bankStates+24
 2623 1446 5091 0000 		lds r21,bankStates+24+1
 2624 144a 6091 0000 		lds r22,bankStates+24+2
 2625 144e 7091 0000 		lds r23,bankStates+24+3
 2626 1452 8091 0000 		lds r24,bankStates+20
 2627 1456 9091 0000 		lds r25,bankStates+20+1
 2628 145a A091 0000 		lds r26,bankStates+20+2
 2629 145e B091 0000 		lds r27,bankStates+20+3
 2630 1462 8417      		cp r24,r20
 2631 1464 9507      		cpc r25,r21
 2632 1466 A607      		cpc r26,r22
 2633 1468 B707      		cpc r27,r23
 2634 146a 00F4      		brsh .L146
3677:WTPA.c        **** 		{
3678:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 2635               		.loc 1 3678 0
 2636 146c 8091 0000 		lds r24,bankStates+3
 2637 1470 8130      		cpi r24,lo8(1)
 2638 1472 01F4      		brne .L147
3679:WTPA.c        **** 			{
3680:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2639               		.loc 1 3680 0
 2640 1474 8093 0000 		sts bankStates+4,r24
 2641 1478 00C0      		rjmp .L148
 2642               	.L147:
3681:WTPA.c        **** 			}
3682:WTPA.c        **** 			else
3683:WTPA.c        **** 			{
3684:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2643               		.loc 1 3684 0
 2644 147a 1092 0000 		sts bankStates+4,__zero_reg__
 2645               	.L148:
3685:WTPA.c        **** 			}
3686:WTPA.c        **** 
3687:WTPA.c        **** 			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
 2646               		.loc 1 3687 0
 2647 147e 8091 0000 		lds r24,bankStates+24
 2648 1482 9091 0000 		lds r25,bankStates+24+1
 2649 1486 A091 0000 		lds r26,bankStates+24+2
 2650 148a B091 0000 		lds r27,bankStates+24+3
 2651               	.LVL78:
3688:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to st
 2652               		.loc 1 3688 0
 2653 148e 4091 0000 		lds r20,bankStates+20
 2654 1492 5091 0000 		lds r21,bankStates+20+1
 2655 1496 6091 0000 		lds r22,bankStates+20+2
 2656 149a 7091 0000 		lds r23,bankStates+20+3
 2657 149e 4093 0000 		sts bankStates+24,r20
 2658 14a2 5093 0000 		sts bankStates+24+1,r21
 2659 14a6 6093 0000 		sts bankStates+24+2,r22
 2660 14aa 7093 0000 		sts bankStates+24+3,r23
3689:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
 2661               		.loc 1 3689 0
 2662 14ae 8093 0000 		sts bankStates+20,r24
 2663 14b2 9093 0000 		sts bankStates+20+1,r25
 2664 14b6 A093 0000 		sts bankStates+20+2,r26
 2665 14ba B093 0000 		sts bankStates+20+3,r27
 2666 14be 00C0      		rjmp .L149
 2667               	.LVL79:
 2668               	.L146:
3690:WTPA.c        **** 		}
3691:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3692:WTPA.c        **** 		{
3693:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
 2669               		.loc 1 3693 0
 2670 14c0 8091 0000 		lds r24,bankStates+3
 2671 14c4 8130      		cpi r24,lo8(1)
 2672 14c6 01F4      		brne .L150
3694:WTPA.c        **** 			{
3695:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2673               		.loc 1 3695 0
 2674 14c8 1092 0000 		sts bankStates+4,__zero_reg__
 2675 14cc 00C0      		rjmp .L149
 2676               	.L150:
3696:WTPA.c        **** 			}
3697:WTPA.c        **** 			else
3698:WTPA.c        **** 			{
3699:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 2677               		.loc 1 3699 0
 2678 14ce 81E0      		ldi r24,lo8(1)
 2679 14d0 8093 0000 		sts bankStates+4,r24
 2680               	.LVL80:
 2681               	.L149:
3700:WTPA.c        **** 			}
3701:WTPA.c        **** 		}
3702:WTPA.c        **** 
3703:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3704:WTPA.c        **** 
3705:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the e
 2682               		.loc 1 3705 0
 2683 14d4 4091 0000 		lds r20,bankStates+24
 2684 14d8 5091 0000 		lds r21,bankStates+24+1
 2685 14dc 6091 0000 		lds r22,bankStates+24+2
 2686 14e0 7091 0000 		lds r23,bankStates+24+3
 2687 14e4 8091 0000 		lds r24,bankStates+12
 2688 14e8 9091 0000 		lds r25,bankStates+12+1
 2689 14ec A091 0000 		lds r26,bankStates+12+2
 2690 14f0 B091 0000 		lds r27,bankStates+12+3
 2691 14f4 8417      		cp r24,r20
 2692 14f6 9507      		cpc r25,r21
 2693 14f8 A607      		cpc r26,r22
 2694 14fa B707      		cpc r27,r23
 2695 14fc 00F4      		brsh .L151
3706:WTPA.c        **** 		{
3707:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK
 2696               		.loc 1 3707 0
 2697 14fe 8091 0000 		lds r24,bankStates+24
 2698 1502 9091 0000 		lds r25,bankStates+24+1
 2699 1506 A091 0000 		lds r26,bankStates+24+2
 2700 150a B091 0000 		lds r27,bankStates+24+3
 2701 150e 4091 0000 		lds r20,bankStates+12
 2702 1512 5091 0000 		lds r21,bankStates+12+1
 2703 1516 6091 0000 		lds r22,bankStates+12+2
 2704 151a 7091 0000 		lds r23,bankStates+12+3
 2705 151e 841B      		sub r24,r20
 2706 1520 950B      		sbc r25,r21
 2707 1522 A60B      		sbc r26,r22
 2708 1524 B70B      		sbc r27,r23
 2709 1526 8093 0000 		sts bankStates+24,r24
 2710 152a 9093 0000 		sts bankStates+24+1,r25
 2711 152e A093 0000 		sts bankStates+24+2,r26
 2712 1532 B093 0000 		sts bankStates+24+3,r27
 2713               	.L151:
3708:WTPA.c        **** 		}
3709:WTPA.c        **** 		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
 2714               		.loc 1 3709 0
 2715 1536 4091 0000 		lds r20,bankStates+20
 2716 153a 5091 0000 		lds r21,bankStates+20+1
 2717 153e 6091 0000 		lds r22,bankStates+20+2
 2718 1542 7091 0000 		lds r23,bankStates+20+3
 2719 1546 8091 0000 		lds r24,bankStates+12
 2720 154a 9091 0000 		lds r25,bankStates+12+1
 2721 154e A091 0000 		lds r26,bankStates+12+2
 2722 1552 B091 0000 		lds r27,bankStates+12+3
 2723 1556 8417      		cp r24,r20
 2724 1558 9507      		cpc r25,r21
 2725 155a A607      		cpc r26,r22
 2726 155c B707      		cpc r27,r23
 2727 155e 00F0      		brlo .+2
 2728 1560 00C0      		rjmp .L153
3710:WTPA.c        **** 		{
3711:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].
 2729               		.loc 1 3711 0
 2730 1562 8091 0000 		lds r24,bankStates+20
 2731 1566 9091 0000 		lds r25,bankStates+20+1
 2732 156a A091 0000 		lds r26,bankStates+20+2
 2733 156e B091 0000 		lds r27,bankStates+20+3
 2734 1572 4091 0000 		lds r20,bankStates+12
 2735 1576 5091 0000 		lds r21,bankStates+12+1
 2736 157a 6091 0000 		lds r22,bankStates+12+2
 2737 157e 7091 0000 		lds r23,bankStates+12+3
 2738 1582 841B      		sub r24,r20
 2739 1584 950B      		sbc r25,r21
 2740 1586 A60B      		sbc r26,r22
 2741 1588 B70B      		sbc r27,r23
 2742 158a 8093 0000 		sts bankStates+20,r24
 2743 158e 9093 0000 		sts bankStates+20+1,r25
 2744 1592 A093 0000 		sts bankStates+20+2,r26
 2745 1596 B093 0000 		sts bankStates+20+3,r27
3712:WTPA.c        **** 
3713:WTPA.c        **** 			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wra
 2746               		.loc 1 3713 0
 2747 159a 4091 0000 		lds r20,bankStates+20
 2748 159e 5091 0000 		lds r21,bankStates+20+1
 2749 15a2 6091 0000 		lds r22,bankStates+20+2
 2750 15a6 7091 0000 		lds r23,bankStates+20+3
 2751 15aa 8091 0000 		lds r24,bankStates+24
 2752 15ae 9091 0000 		lds r25,bankStates+24+1
 2753 15b2 A091 0000 		lds r26,bankStates+24+2
 2754 15b6 B091 0000 		lds r27,bankStates+24+3
 2755 15ba 4817      		cp r20,r24
 2756 15bc 5907      		cpc r21,r25
 2757 15be 6A07      		cpc r22,r26
 2758 15c0 7B07      		cpc r23,r27
 2759 15c2 01F4      		brne .L153
3714:WTPA.c        **** 			{
3715:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
 2760               		.loc 1 3715 0
 2761 15c4 8091 0000 		lds r24,bankStates+20
 2762 15c8 9091 0000 		lds r25,bankStates+20+1
 2763 15cc A091 0000 		lds r26,bankStates+20+2
 2764 15d0 B091 0000 		lds r27,bankStates+20+3
 2765 15d4 0197      		sbiw r24,1
 2766 15d6 A109      		sbc r26,__zero_reg__
 2767 15d8 B109      		sbc r27,__zero_reg__
 2768 15da 8093 0000 		sts bankStates+20,r24
 2769 15de 9093 0000 		sts bankStates+20+1,r25
 2770 15e2 A093 0000 		sts bankStates+20+2,r26
 2771 15e6 B093 0000 		sts bankStates+20+3,r27
 2772               	.L153:
3716:WTPA.c        **** 			}
3717:WTPA.c        **** 		}
3718:WTPA.c        **** 
3719:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3720:WTPA.c        **** 
3721:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapp
 2773               		.loc 1 3721 0
 2774 15ea 4091 0000 		lds r20,bankStates+24
 2775 15ee 5091 0000 		lds r21,bankStates+24+1
 2776 15f2 6091 0000 		lds r22,bankStates+24+2
 2777 15f6 7091 0000 		lds r23,bankStates+24+3
 2778 15fa 8091 0000 		lds r24,bankStates+20
 2779 15fe 9091 0000 		lds r25,bankStates+20+1
 2780 1602 A091 0000 		lds r26,bankStates+20+2
 2781 1606 B091 0000 		lds r27,bankStates+20+3
 2782 160a 8417      		cp r24,r20
 2783 160c 9507      		cpc r25,r21
 2784 160e A607      		cpc r26,r22
 2785 1610 B707      		cpc r27,r23
 2786 1612 00F0      		brlo .+2
 2787 1614 00C0      		rjmp .L155
3722:WTPA.c        **** 		{
3723:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
 2788               		.loc 1 3723 0
 2789 1616 4091 0000 		lds r20,bankStates+31
 2790 161a 5091 0000 		lds r21,bankStates+31+1
 2791 161e 6091 0000 		lds r22,bankStates+31+2
 2792 1622 7091 0000 		lds r23,bankStates+31+3
 2793 1626 8091 0000 		lds r24,bankStates+24
 2794 162a 9091 0000 		lds r25,bankStates+24+1
 2795 162e A091 0000 		lds r26,bankStates+24+2
 2796 1632 B091 0000 		lds r27,bankStates+24+3
 2797 1636 4817      		cp r20,r24
 2798 1638 5907      		cpc r21,r25
 2799 163a 6A07      		cpc r22,r26
 2800 163c 7B07      		cpc r23,r27
 2801 163e 00F0      		brlo .+2
 2802 1640 00C0      		rjmp .L157
 2803               		.loc 1 3723 0 is_stmt 0 discriminator 1
 2804 1642 4091 0000 		lds r20,bankStates+31
 2805 1646 5091 0000 		lds r21,bankStates+31+1
 2806 164a 6091 0000 		lds r22,bankStates+31+2
 2807 164e 7091 0000 		lds r23,bankStates+31+3
 2808 1652 8091 0000 		lds r24,bankStates+20
 2809 1656 9091 0000 		lds r25,bankStates+20+1
 2810 165a A091 0000 		lds r26,bankStates+20+2
 2811 165e B091 0000 		lds r27,bankStates+20+3
 2812 1662 8417      		cp r24,r20
 2813 1664 9507      		cpc r25,r21
 2814 1666 A607      		cpc r26,r22
 2815 1668 B707      		cpc r27,r23
 2816 166a 00F0      		brlo .+2
 2817 166c 00C0      		rjmp .L157
3724:WTPA.c        **** 			{
3725:WTPA.c        **** 				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BAN
 2818               		.loc 1 3725 0 is_stmt 1
 2819 166e 4091 0000 		lds r20,bankStates+24
 2820 1672 5091 0000 		lds r21,bankStates+24+1
 2821 1676 6091 0000 		lds r22,bankStates+24+2
 2822 167a 7091 0000 		lds r23,bankStates+24+3
 2823 167e 8090 0000 		lds r8,bankStates+31
 2824 1682 9090 0000 		lds r9,bankStates+31+1
 2825 1686 A090 0000 		lds r10,bankStates+31+2
 2826 168a B090 0000 		lds r11,bankStates+31+3
 2827 168e 8091 0000 		lds r24,bankStates+31
 2828 1692 9091 0000 		lds r25,bankStates+31+1
 2829 1696 A091 0000 		lds r26,bankStates+31+2
 2830 169a B091 0000 		lds r27,bankStates+31+3
 2831 169e C090 0000 		lds r12,bankStates+20
 2832 16a2 D090 0000 		lds r13,bankStates+20+1
 2833 16a6 E090 0000 		lds r14,bankStates+20+2
 2834 16aa F090 0000 		lds r15,bankStates+20+3
 2835 16ae 4819      		sub r20,r8
 2836 16b0 5909      		sbc r21,r9
 2837 16b2 6A09      		sbc r22,r10
 2838 16b4 7B09      		sbc r23,r11
 2839 16b6 8C19      		sub r24,r12
 2840 16b8 9D09      		sbc r25,r13
 2841 16ba AE09      		sbc r26,r14
 2842 16bc BF09      		sbc r27,r15
 2843 16be 4817      		cp r20,r24
 2844 16c0 5907      		cpc r21,r25
 2845 16c2 6A07      		cpc r22,r26
 2846 16c4 7B07      		cpc r23,r27
 2847 16c6 00F0      		brlo .L177
 2848 16c8 00C0      		rjmp .L176
 2849               	.L155:
3726:WTPA.c        **** 				{
3727:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;	// Round to the sta
3728:WTPA.c        **** 				}
3729:WTPA.c        **** 				else
3730:WTPA.c        **** 				{
3731:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;	// Round to the end.
3732:WTPA.c        **** 				}
3733:WTPA.c        **** 			}
3734:WTPA.c        **** 		}
3735:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is before the end).
3736:WTPA.c        **** 		{
3737:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
 2850               		.loc 1 3737 0
 2851 16ca 4091 0000 		lds r20,bankStates+31
 2852 16ce 5091 0000 		lds r21,bankStates+31+1
 2853 16d2 6091 0000 		lds r22,bankStates+31+2
 2854 16d6 7091 0000 		lds r23,bankStates+31+3
 2855 16da 8091 0000 		lds r24,bankStates+24
 2856 16de 9091 0000 		lds r25,bankStates+24+1
 2857 16e2 A091 0000 		lds r26,bankStates+24+2
 2858 16e6 B091 0000 		lds r27,bankStates+24+3
 2859 16ea 4817      		cp r20,r24
 2860 16ec 5907      		cpc r21,r25
 2861 16ee 6A07      		cpc r22,r26
 2862 16f0 7B07      		cpc r23,r27
 2863 16f2 00F4      		brsh .L160
 2864               	.L176:
3738:WTPA.c        **** 			{
3739:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the 
 2865               		.loc 1 3739 0
 2866 16f4 8091 0000 		lds r24,bankStates+24
 2867 16f8 9091 0000 		lds r25,bankStates+24+1
 2868 16fc A091 0000 		lds r26,bankStates+24+2
 2869 1700 B091 0000 		lds r27,bankStates+24+3
 2870               	.L173:
 2871 1704 8093 0000 		sts bankStates+31,r24
 2872 1708 9093 0000 		sts bankStates+31+1,r25
 2873 170c A093 0000 		sts bankStates+31+2,r26
 2874 1710 B093 0000 		sts bankStates+31+3,r27
 2875 1714 00C0      		rjmp .L157
 2876               	.L160:
3740:WTPA.c        **** 			}
3741:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
 2877               		.loc 1 3741 0
 2878 1716 4091 0000 		lds r20,bankStates+31
 2879 171a 5091 0000 		lds r21,bankStates+31+1
 2880 171e 6091 0000 		lds r22,bankStates+31+2
 2881 1722 7091 0000 		lds r23,bankStates+31+3
 2882 1726 8091 0000 		lds r24,bankStates+20
 2883 172a 9091 0000 		lds r25,bankStates+20+1
 2884 172e A091 0000 		lds r26,bankStates+20+2
 2885 1732 B091 0000 		lds r27,bankStates+20+3
 2886 1736 8417      		cp r24,r20
 2887 1738 9507      		cpc r25,r21
 2888 173a A607      		cpc r26,r22
 2889 173c B707      		cpc r27,r23
 2890 173e 00F0      		brlo .+2
 2891 1740 00C0      		rjmp .L157
 2892               	.L177:
3742:WTPA.c        **** 			{
3743:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
 2893               		.loc 1 3743 0
 2894 1742 8091 0000 		lds r24,bankStates+20
 2895 1746 9091 0000 		lds r25,bankStates+20+1
 2896 174a A091 0000 		lds r26,bankStates+20+2
 2897 174e B091 0000 		lds r27,bankStates+20+3
 2898 1752 00C0      		rjmp .L173
 2899               	.LVL81:
 2900               	.L145:
3744:WTPA.c        **** 			}
3745:WTPA.c        **** 		}
3746:WTPA.c        **** 	}
3747:WTPA.c        **** 	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
3748:WTPA.c        **** 	{
3749:WTPA.c        **** 		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
3750:WTPA.c        **** 		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of 
 2901               		.loc 1 3750 0
 2902 1754 8091 0000 		lds r24,bankStates+47
 2903 1758 9091 0000 		lds r25,bankStates+47+1
 2904 175c A091 0000 		lds r26,bankStates+47+2
 2905 1760 B091 0000 		lds r27,bankStates+47+3
 2906               	.LVL82:
 2907 1764 CC24      		clr r12
 2908 1766 CA94      		dec r12
 2909 1768 DC2C      		mov r13,r12
 2910 176a 27E0      		ldi r18,lo8(7)
 2911 176c E22E      		mov r14,r18
 2912 176e F12C      		mov r15,__zero_reg__
 2913 1770 4601      		movw r8,r12
 2914 1772 5701      		movw r10,r14
 2915 1774 881A      		sub r8,r24
 2916 1776 990A      		sbc r9,r25
 2917 1778 AA0A      		sbc r10,r26
 2918 177a BB0A      		sbc r11,r27
 2919 177c 33E0      		ldi r19,3
 2920               		1:
 2921 177e 880C      		lsl r8
 2922 1780 991C      		rol r9
 2923 1782 AA1C      		rol r10
 2924 1784 BB1C      		rol r11
 2925 1786 3A95      		dec r19
 2926 1788 01F4      		brne 1b
 2927 178a 892C      		mov r8,r9
 2928 178c 9A2C      		mov r9,r10
 2929 178e AB2C      		mov r10,r11
 2930 1790 BB24      		clr r11
 2931               	.LVL83:
3751:WTPA.c        **** 
3752:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3753:WTPA.c        **** 
3754:WTPA.c        **** 		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sam
 2932               		.loc 1 3754 0
 2933 1792 A091 0000 		lds r26,bankStates+63
 2934 1796 8091 0000 		lds r24,bankStates+65
 2935 179a B0E0      		ldi r27,0
 2936 179c A80F      		add r26,r24
 2937 179e B11D      		adc r27,__zero_reg__
 2938 17a0 A501      		movw r20,r10
 2939 17a2 9401      		movw r18,r8
 2940 17a4 0E94 0000 		call __muluhisi3
 2941 17a8 F3E0      		ldi r31,3
 2942               		1:
 2943 17aa 9695      		lsr r25
 2944 17ac 8795      		ror r24
 2945 17ae 7795      		ror r23
 2946 17b0 6795      		ror r22
 2947 17b2 FA95      		dec r31
 2948 17b4 01F4      		brne 1b
 2949 17b6 C61A      		sub r12,r22
 2950 17b8 D70A      		sbc r13,r23
 2951 17ba E80A      		sbc r14,r24
 2952 17bc F90A      		sbc r15,r25
 2953 17be C092 0000 		sts bankStates+59,r12
 2954 17c2 D092 0000 		sts bankStates+59+1,r13
 2955 17c6 E092 0000 		sts bankStates+59+2,r14
 2956 17ca F092 0000 		sts bankStates+59+3,r15
3755:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_
 2957               		.loc 1 3755 0
 2958 17ce 4090 0000 		lds r4,bankStates+47
 2959 17d2 5090 0000 		lds r5,bankStates+47+1
 2960 17d6 6090 0000 		lds r6,bankStates+47+2
 2961 17da 7090 0000 		lds r7,bankStates+47+3
 2962 17de A091 0000 		lds r26,bankStates+64
 2963 17e2 F091 0000 		lds r31,bankStates+65
 2964 17e6 B0E0      		ldi r27,0
 2965 17e8 0E94 0000 		call __muluhisi3
 2966 17ec 6B01      		movw r12,r22
 2967 17ee 7C01      		movw r14,r24
 2968 17f0 A3E0      		ldi r26,3
 2969               		1:
 2970 17f2 F694      		lsr r15
 2971 17f4 E794      		ror r14
 2972 17f6 D794      		ror r13
 2973 17f8 C794      		ror r12
 2974 17fa AA95      		dec r26
 2975 17fc 01F4      		brne 1b
 2976 17fe C40C      		add r12,r4
 2977 1800 D51C      		adc r13,r5
 2978 1802 E61C      		adc r14,r6
 2979 1804 F71C      		adc r15,r7
 2980 1806 AF2F      		mov r26,r31
 2981 1808 B0E0      		ldi r27,0
 2982 180a 0E94 0000 		call __muluhisi3
 2983 180e B3E0      		ldi r27,3
 2984               		1:
 2985 1810 9695      		lsr r25
 2986 1812 8795      		ror r24
 2987 1814 7795      		ror r23
 2988 1816 6795      		ror r22
 2989 1818 BA95      		dec r27
 2990 181a 01F4      		brne 1b
 2991 181c C61A      		sub r12,r22
 2992 181e D70A      		sbc r13,r23
 2993 1820 E80A      		sbc r14,r24
 2994 1822 F90A      		sbc r15,r25
 2995 1824 C092 0000 		sts bankStates+55,r12
 2996 1828 D092 0000 		sts bankStates+55+1,r13
 2997 182c E092 0000 		sts bankStates+55+2,r14
 2998 1830 F092 0000 		sts bankStates+55+3,r15
3756:WTPA.c        **** 
3757:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3758:WTPA.c        **** 
3759:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse play
 2999               		.loc 1 3759 0
 3000 1834 4091 0000 		lds r20,bankStates+59
 3001 1838 5091 0000 		lds r21,bankStates+59+1
 3002 183c 6091 0000 		lds r22,bankStates+59+2
 3003 1840 7091 0000 		lds r23,bankStates+59+3
 3004 1844 8091 0000 		lds r24,bankStates+55
 3005 1848 9091 0000 		lds r25,bankStates+55+1
 3006 184c A091 0000 		lds r26,bankStates+55+2
 3007 1850 B091 0000 		lds r27,bankStates+55+3
 3008 1854 4817      		cp r20,r24
 3009 1856 5907      		cpc r21,r25
 3010 1858 6A07      		cpc r22,r26
 3011 185a 7B07      		cpc r23,r27
 3012 185c 00F4      		brsh .L161
3760:WTPA.c        **** 		{
3761:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 3013               		.loc 1 3761 0
 3014 185e 8091 0000 		lds r24,bankStates+38
 3015 1862 8130      		cpi r24,lo8(1)
 3016 1864 01F4      		brne .L162
3762:WTPA.c        **** 			{
3763:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3017               		.loc 1 3763 0
 3018 1866 8093 0000 		sts bankStates+39,r24
 3019 186a 00C0      		rjmp .L163
 3020               	.L162:
3764:WTPA.c        **** 			}
3765:WTPA.c        **** 			else
3766:WTPA.c        **** 			{
3767:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3021               		.loc 1 3767 0
 3022 186c 1092 0000 		sts bankStates+39,__zero_reg__
 3023               	.L163:
3768:WTPA.c        **** 			}
3769:WTPA.c        **** 
3770:WTPA.c        **** 			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
 3024               		.loc 1 3770 0
 3025 1870 8091 0000 		lds r24,bankStates+59
 3026 1874 9091 0000 		lds r25,bankStates+59+1
 3027 1878 A091 0000 		lds r26,bankStates+59+2
 3028 187c B091 0000 		lds r27,bankStates+59+3
 3029               	.LVL84:
3771:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to st
 3030               		.loc 1 3771 0
 3031 1880 4091 0000 		lds r20,bankStates+55
 3032 1884 5091 0000 		lds r21,bankStates+55+1
 3033 1888 6091 0000 		lds r22,bankStates+55+2
 3034 188c 7091 0000 		lds r23,bankStates+55+3
 3035 1890 4093 0000 		sts bankStates+59,r20
 3036 1894 5093 0000 		sts bankStates+59+1,r21
 3037 1898 6093 0000 		sts bankStates+59+2,r22
 3038 189c 7093 0000 		sts bankStates+59+3,r23
3772:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
 3039               		.loc 1 3772 0
 3040 18a0 8093 0000 		sts bankStates+55,r24
 3041 18a4 9093 0000 		sts bankStates+55+1,r25
 3042 18a8 A093 0000 		sts bankStates+55+2,r26
 3043 18ac B093 0000 		sts bankStates+55+3,r27
 3044 18b0 00C0      		rjmp .L164
 3045               	.LVL85:
 3046               	.L161:
3773:WTPA.c        **** 		}
3774:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3775:WTPA.c        **** 		{
3776:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
 3047               		.loc 1 3776 0
 3048 18b2 8091 0000 		lds r24,bankStates+38
 3049 18b6 8130      		cpi r24,lo8(1)
 3050 18b8 01F4      		brne .L165
3777:WTPA.c        **** 			{
3778:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3051               		.loc 1 3778 0
 3052 18ba 1092 0000 		sts bankStates+39,__zero_reg__
 3053 18be 00C0      		rjmp .L164
 3054               	.L165:
3779:WTPA.c        **** 			}
3780:WTPA.c        **** 			else
3781:WTPA.c        **** 			{
3782:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3055               		.loc 1 3782 0
 3056 18c0 81E0      		ldi r24,lo8(1)
 3057 18c2 8093 0000 		sts bankStates+39,r24
 3058               	.LVL86:
 3059               	.L164:
3783:WTPA.c        **** 			}
3784:WTPA.c        **** 		}
3785:WTPA.c        **** 
3786:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3787:WTPA.c        **** 
3788:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the e
 3060               		.loc 1 3788 0
 3061 18c6 4091 0000 		lds r20,bankStates+59
 3062 18ca 5091 0000 		lds r21,bankStates+59+1
 3063 18ce 6091 0000 		lds r22,bankStates+59+2
 3064 18d2 7091 0000 		lds r23,bankStates+59+3
 3065 18d6 8091 0000 		lds r24,bankStates+47
 3066 18da 9091 0000 		lds r25,bankStates+47+1
 3067 18de A091 0000 		lds r26,bankStates+47+2
 3068 18e2 B091 0000 		lds r27,bankStates+47+3
 3069 18e6 4817      		cp r20,r24
 3070 18e8 5907      		cpc r21,r25
 3071 18ea 6A07      		cpc r22,r26
 3072 18ec 7B07      		cpc r23,r27
 3073 18ee 00F4      		brsh .L166
3789:WTPA.c        **** 		{
3790:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bank
 3074               		.loc 1 3790 0
 3075 18f0 8091 0000 		lds r24,bankStates+59
 3076 18f4 9091 0000 		lds r25,bankStates+59+1
 3077 18f8 A091 0000 		lds r26,bankStates+59+2
 3078 18fc B091 0000 		lds r27,bankStates+59+3
 3079 1900 4091 0000 		lds r20,bankStates+47
 3080 1904 5091 0000 		lds r21,bankStates+47+1
 3081 1908 6091 0000 		lds r22,bankStates+47+2
 3082 190c 7091 0000 		lds r23,bankStates+47+3
 3083 1910 0197      		sbiw r24,1
 3084 1912 A84F      		sbci r26,-8
 3085 1914 BF4F      		sbci r27,-1
 3086 1916 841B      		sub r24,r20
 3087 1918 950B      		sbc r25,r21
 3088 191a A60B      		sbc r26,r22
 3089 191c B70B      		sbc r27,r23
 3090 191e 8093 0000 		sts bankStates+59,r24
 3091 1922 9093 0000 		sts bankStates+59+1,r25
 3092 1926 A093 0000 		sts bankStates+59+2,r26
 3093 192a B093 0000 		sts bankStates+59+3,r27
 3094               	.L166:
3791:WTPA.c        **** 		}
3792:WTPA.c        **** 		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
 3095               		.loc 1 3792 0
 3096 192e 4091 0000 		lds r20,bankStates+55
 3097 1932 5091 0000 		lds r21,bankStates+55+1
 3098 1936 6091 0000 		lds r22,bankStates+55+2
 3099 193a 7091 0000 		lds r23,bankStates+55+3
 3100 193e 8091 0000 		lds r24,bankStates+47
 3101 1942 9091 0000 		lds r25,bankStates+47+1
 3102 1946 A091 0000 		lds r26,bankStates+47+2
 3103 194a B091 0000 		lds r27,bankStates+47+3
 3104 194e 4817      		cp r20,r24
 3105 1950 5907      		cpc r21,r25
 3106 1952 6A07      		cpc r22,r26
 3107 1954 7B07      		cpc r23,r27
 3108 1956 00F0      		brlo .+2
 3109 1958 00C0      		rjmp .L168
3793:WTPA.c        **** 		{
3794:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankSt
 3110               		.loc 1 3794 0
 3111 195a 8091 0000 		lds r24,bankStates+55
 3112 195e 9091 0000 		lds r25,bankStates+55+1
 3113 1962 A091 0000 		lds r26,bankStates+55+2
 3114 1966 B091 0000 		lds r27,bankStates+55+3
 3115 196a 4091 0000 		lds r20,bankStates+47
 3116 196e 5091 0000 		lds r21,bankStates+47+1
 3117 1972 6091 0000 		lds r22,bankStates+47+2
 3118 1976 7091 0000 		lds r23,bankStates+47+3
 3119 197a 0197      		sbiw r24,1
 3120 197c A84F      		sbci r26,-8
 3121 197e BF4F      		sbci r27,-1
 3122 1980 841B      		sub r24,r20
 3123 1982 950B      		sbc r25,r21
 3124 1984 A60B      		sbc r26,r22
 3125 1986 B70B      		sbc r27,r23
 3126 1988 8093 0000 		sts bankStates+55,r24
 3127 198c 9093 0000 		sts bankStates+55+1,r25
 3128 1990 A093 0000 		sts bankStates+55+2,r26
 3129 1994 B093 0000 		sts bankStates+55+3,r27
3795:WTPA.c        **** 
3796:WTPA.c        **** 			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wra
 3130               		.loc 1 3796 0
 3131 1998 4091 0000 		lds r20,bankStates+55
 3132 199c 5091 0000 		lds r21,bankStates+55+1
 3133 19a0 6091 0000 		lds r22,bankStates+55+2
 3134 19a4 7091 0000 		lds r23,bankStates+55+3
 3135 19a8 8091 0000 		lds r24,bankStates+59
 3136 19ac 9091 0000 		lds r25,bankStates+59+1
 3137 19b0 A091 0000 		lds r26,bankStates+59+2
 3138 19b4 B091 0000 		lds r27,bankStates+59+3
 3139 19b8 4817      		cp r20,r24
 3140 19ba 5907      		cpc r21,r25
 3141 19bc 6A07      		cpc r22,r26
 3142 19be 7B07      		cpc r23,r27
 3143 19c0 01F4      		brne .L168
3797:WTPA.c        **** 			{
3798:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
 3144               		.loc 1 3798 0
 3145 19c2 8091 0000 		lds r24,bankStates+55
 3146 19c6 9091 0000 		lds r25,bankStates+55+1
 3147 19ca A091 0000 		lds r26,bankStates+55+2
 3148 19ce B091 0000 		lds r27,bankStates+55+3
 3149 19d2 0196      		adiw r24,1
 3150 19d4 A11D      		adc r26,__zero_reg__
 3151 19d6 B11D      		adc r27,__zero_reg__
 3152 19d8 8093 0000 		sts bankStates+55,r24
 3153 19dc 9093 0000 		sts bankStates+55+1,r25
 3154 19e0 A093 0000 		sts bankStates+55+2,r26
 3155 19e4 B093 0000 		sts bankStates+55+3,r27
 3156               	.L168:
3799:WTPA.c        **** 			}
3800:WTPA.c        **** 		}
3801:WTPA.c        **** 
3802:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3803:WTPA.c        **** 
3804:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapp
 3157               		.loc 1 3804 0
 3158 19e8 4091 0000 		lds r20,bankStates+59
 3159 19ec 5091 0000 		lds r21,bankStates+59+1
 3160 19f0 6091 0000 		lds r22,bankStates+59+2
 3161 19f4 7091 0000 		lds r23,bankStates+59+3
 3162 19f8 8091 0000 		lds r24,bankStates+55
 3163 19fc 9091 0000 		lds r25,bankStates+55+1
 3164 1a00 A091 0000 		lds r26,bankStates+55+2
 3165 1a04 B091 0000 		lds r27,bankStates+55+3
 3166 1a08 4817      		cp r20,r24
 3167 1a0a 5907      		cpc r21,r25
 3168 1a0c 6A07      		cpc r22,r26
 3169 1a0e 7B07      		cpc r23,r27
 3170 1a10 00F0      		brlo .+2
 3171 1a12 00C0      		rjmp .L170
3805:WTPA.c        **** 		{
3806:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
 3172               		.loc 1 3806 0
 3173 1a14 4091 0000 		lds r20,bankStates+66
 3174 1a18 5091 0000 		lds r21,bankStates+66+1
 3175 1a1c 6091 0000 		lds r22,bankStates+66+2
 3176 1a20 7091 0000 		lds r23,bankStates+66+3
 3177 1a24 8091 0000 		lds r24,bankStates+59
 3178 1a28 9091 0000 		lds r25,bankStates+59+1
 3179 1a2c A091 0000 		lds r26,bankStates+59+2
 3180 1a30 B091 0000 		lds r27,bankStates+59+3
 3181 1a34 8417      		cp r24,r20
 3182 1a36 9507      		cpc r25,r21
 3183 1a38 A607      		cpc r26,r22
 3184 1a3a B707      		cpc r27,r23
 3185 1a3c 00F0      		brlo .+2
 3186 1a3e 00C0      		rjmp .L157
 3187               		.loc 1 3806 0 is_stmt 0 discriminator 1
 3188 1a40 4091 0000 		lds r20,bankStates+66
 3189 1a44 5091 0000 		lds r21,bankStates+66+1
 3190 1a48 6091 0000 		lds r22,bankStates+66+2
 3191 1a4c 7091 0000 		lds r23,bankStates+66+3
 3192 1a50 8091 0000 		lds r24,bankStates+55
 3193 1a54 9091 0000 		lds r25,bankStates+55+1
 3194 1a58 A091 0000 		lds r26,bankStates+55+2
 3195 1a5c B091 0000 		lds r27,bankStates+55+3
 3196 1a60 4817      		cp r20,r24
 3197 1a62 5907      		cpc r21,r25
 3198 1a64 6A07      		cpc r22,r26
 3199 1a66 7B07      		cpc r23,r27
 3200 1a68 00F0      		brlo .+2
 3201 1a6a 00C0      		rjmp .L157
3807:WTPA.c        **** 			{
3808:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BAN
 3202               		.loc 1 3808 0 is_stmt 1
 3203 1a6c 4091 0000 		lds r20,bankStates+66
 3204 1a70 5091 0000 		lds r21,bankStates+66+1
 3205 1a74 6091 0000 		lds r22,bankStates+66+2
 3206 1a78 7091 0000 		lds r23,bankStates+66+3
 3207 1a7c 8090 0000 		lds r8,bankStates+59
 3208 1a80 9090 0000 		lds r9,bankStates+59+1
 3209 1a84 A090 0000 		lds r10,bankStates+59+2
 3210 1a88 B090 0000 		lds r11,bankStates+59+3
 3211 1a8c 8091 0000 		lds r24,bankStates+55
 3212 1a90 9091 0000 		lds r25,bankStates+55+1
 3213 1a94 A091 0000 		lds r26,bankStates+55+2
 3214 1a98 B091 0000 		lds r27,bankStates+55+3
 3215 1a9c C090 0000 		lds r12,bankStates+66
 3216 1aa0 D090 0000 		lds r13,bankStates+66+1
 3217 1aa4 E090 0000 		lds r14,bankStates+66+2
 3218 1aa8 F090 0000 		lds r15,bankStates+66+3
 3219 1aac 4819      		sub r20,r8
 3220 1aae 5909      		sbc r21,r9
 3221 1ab0 6A09      		sbc r22,r10
 3222 1ab2 7B09      		sbc r23,r11
 3223 1ab4 8C19      		sub r24,r12
 3224 1ab6 9D09      		sbc r25,r13
 3225 1ab8 AE09      		sbc r26,r14
 3226 1aba BF09      		sbc r27,r15
 3227 1abc 8417      		cp r24,r20
 3228 1abe 9507      		cpc r25,r21
 3229 1ac0 A607      		cpc r26,r22
 3230 1ac2 B707      		cpc r27,r23
 3231 1ac4 00F0      		brlo .L175
 3232 1ac6 00C0      		rjmp .L178
 3233               	.L170:
3809:WTPA.c        **** 				{
3810:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;	// Round to the sta
3811:WTPA.c        **** 				}
3812:WTPA.c        **** 				else
3813:WTPA.c        **** 				{
3814:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;	// Round to the end.
3815:WTPA.c        **** 				}
3816:WTPA.c        **** 			}
3817:WTPA.c        **** 		}
3818:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is xxx the end).
3819:WTPA.c        **** 		{
3820:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
 3234               		.loc 1 3820 0
 3235 1ac8 4091 0000 		lds r20,bankStates+66
 3236 1acc 5091 0000 		lds r21,bankStates+66+1
 3237 1ad0 6091 0000 		lds r22,bankStates+66+2
 3238 1ad4 7091 0000 		lds r23,bankStates+66+3
 3239 1ad8 8091 0000 		lds r24,bankStates+59
 3240 1adc 9091 0000 		lds r25,bankStates+59+1
 3241 1ae0 A091 0000 		lds r26,bankStates+59+2
 3242 1ae4 B091 0000 		lds r27,bankStates+59+3
 3243 1ae8 8417      		cp r24,r20
 3244 1aea 9507      		cpc r25,r21
 3245 1aec A607      		cpc r26,r22
 3246 1aee B707      		cpc r27,r23
 3247 1af0 00F4      		brsh .L172
 3248               	.L178:
3821:WTPA.c        **** 			{
3822:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the 
 3249               		.loc 1 3822 0
 3250 1af2 8091 0000 		lds r24,bankStates+59
 3251 1af6 9091 0000 		lds r25,bankStates+59+1
 3252 1afa A091 0000 		lds r26,bankStates+59+2
 3253 1afe B091 0000 		lds r27,bankStates+59+3
 3254 1b02 00C0      		rjmp .L174
 3255               	.L172:
3823:WTPA.c        **** 			}
3824:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
 3256               		.loc 1 3824 0
 3257 1b04 4091 0000 		lds r20,bankStates+66
 3258 1b08 5091 0000 		lds r21,bankStates+66+1
 3259 1b0c 6091 0000 		lds r22,bankStates+66+2
 3260 1b10 7091 0000 		lds r23,bankStates+66+3
 3261 1b14 8091 0000 		lds r24,bankStates+55
 3262 1b18 9091 0000 		lds r25,bankStates+55+1
 3263 1b1c A091 0000 		lds r26,bankStates+55+2
 3264 1b20 B091 0000 		lds r27,bankStates+55+3
 3265 1b24 4817      		cp r20,r24
 3266 1b26 5907      		cpc r21,r25
 3267 1b28 6A07      		cpc r22,r26
 3268 1b2a 7B07      		cpc r23,r27
 3269 1b2c 00F4      		brsh .L157
 3270               	.L175:
3825:WTPA.c        **** 			{
3826:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
 3271               		.loc 1 3826 0
 3272 1b2e 8091 0000 		lds r24,bankStates+55
 3273 1b32 9091 0000 		lds r25,bankStates+55+1
 3274 1b36 A091 0000 		lds r26,bankStates+55+2
 3275 1b3a B091 0000 		lds r27,bankStates+55+3
 3276               	.L174:
 3277 1b3e 8093 0000 		sts bankStates+66,r24
 3278 1b42 9093 0000 		sts bankStates+66+1,r25
 3279 1b46 A093 0000 		sts bankStates+66+2,r26
 3280 1b4a B093 0000 		sts bankStates+66+3,r27
 3281               	.L157:
3827:WTPA.c        **** 			}
3828:WTPA.c        **** 		}
3829:WTPA.c        **** 	}
3830:WTPA.c        **** 
3831:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3282               		.loc 1 3831 0
 3283 1b4e EFBF      		out __SREG__,r30
 3284               	/* epilogue start */
3832:WTPA.c        **** }
 3285               		.loc 1 3832 0
 3286 1b50 FF90      		pop r15
 3287 1b52 EF90      		pop r14
 3288 1b54 DF90      		pop r13
 3289 1b56 CF90      		pop r12
 3290 1b58 BF90      		pop r11
 3291 1b5a AF90      		pop r10
 3292 1b5c 9F90      		pop r9
 3293 1b5e 8F90      		pop r8
 3294 1b60 7F90      		pop r7
 3295 1b62 6F90      		pop r6
 3296 1b64 5F90      		pop r5
 3297 1b66 4F90      		pop r4
 3298 1b68 0895      		ret
 3299               		.cfi_endproc
 3300               	.LFE61:
 3303               	RevertSampleToUnadjusted:
 3304               	.LFB62:
3833:WTPA.c        **** 
3834:WTPA.c        **** static void RevertSampleToUnadjusted(unsigned char theBank)
3835:WTPA.c        **** // Removes user adjustments to sample and returns it to maximum size.
3836:WTPA.c        **** // @@@ Since the current sample address must be within these bounds, there is no need to adjust it.
3837:WTPA.c        **** // @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
3838:WTPA.c        **** {
 3305               		.loc 1 3838 0
 3306               		.cfi_startproc
 3307               	.LVL87:
 3308               	/* prologue: function */
 3309               	/* frame size = 0 */
 3310               	/* stack size = 0 */
 3311               	.L__stack_usage = 0
3839:WTPA.c        **** 	unsigned char
3840:WTPA.c        **** 		sreg;
3841:WTPA.c        **** 
3842:WTPA.c        **** 	sreg=SREG;
 3312               		.loc 1 3842 0
 3313 1b6a 9FB7      		in r25,__SREG__
 3314               	.LVL88:
3843:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 3315               		.loc 1 3843 0
 3316               	/* #APP */
 3317               	 ;  3843 "WTPA.c" 1
 3318 1b6c F894      		cli
 3319               	 ;  0 "" 2
3844:WTPA.c        **** 
3845:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 3320               		.loc 1 3845 0
 3321               	/* #NOAPP */
 3322 1b6e 23E2      		ldi r18,lo8(35)
 3323 1b70 829F      		mul r24,r18
 3324 1b72 F001      		movw r30,r0
 3325 1b74 1124      		clr __zero_reg__
 3326 1b76 E050      		subi r30,lo8(-(bankStates))
 3327 1b78 F040      		sbci r31,hi8(-(bankStates))
 3328 1b7a 4089      		ldd r20,Z+16
 3329 1b7c 5189      		ldd r21,Z+17
 3330 1b7e 6289      		ldd r22,Z+18
 3331 1b80 7389      		ldd r23,Z+19
 3332 1b82 408F      		std Z+24,r20
 3333 1b84 518F      		std Z+25,r21
 3334 1b86 628F      		std Z+26,r22
 3335 1b88 738F      		std Z+27,r23
3846:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 3336               		.loc 1 3846 0
 3337 1b8a 4485      		ldd r20,Z+12
 3338 1b8c 5585      		ldd r21,Z+13
 3339 1b8e 6685      		ldd r22,Z+14
 3340 1b90 7785      		ldd r23,Z+15
 3341 1b92 448B      		std Z+20,r20
 3342 1b94 558B      		std Z+21,r21
 3343 1b96 668B      		std Z+22,r22
 3344 1b98 778B      		std Z+23,r23
3847:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 3345               		.loc 1 3847 0
 3346 1b9a 148E      		std Z+28,__zero_reg__
3848:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 3347               		.loc 1 3848 0
 3348 1b9c 158E      		std Z+29,__zero_reg__
3849:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 3349               		.loc 1 3849 0
 3350 1b9e 168E      		std Z+30,__zero_reg__
3850:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3351               		.loc 1 3850 0
 3352 1ba0 9FBF      		out __SREG__,r25
 3353 1ba2 0895      		ret
 3354               		.cfi_endproc
 3355               	.LFE62:
 3358               	BlinkLeds:
 3359               	.LFB17:
1501:WTPA.c        **** {
 3360               		.loc 1 1501 0
 3361               		.cfi_startproc
 3362               	.LVL89:
 3363               	/* prologue: function */
 3364               	/* frame size = 0 */
 3365               	/* stack size = 0 */
 3366               	.L__stack_usage = 0
1507:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3367               		.loc 1 1507 0
 3368 1ba4 4091 0000 		lds r20,ledBlinkMask
 3369 1ba8 50E0      		ldi r21,0
 3370 1baa 9091 0000 		lds r25,ledOnOffMask
 3371 1bae 20E0      		ldi r18,0
 3372 1bb0 30E0      		ldi r19,0
1509:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3373               		.loc 1 1509 0
 3374 1bb2 61E0      		ldi r22,lo8(1)
 3375 1bb4 70E0      		ldi r23,0
 3376               	.LVL90:
 3377               	.L182:
1507:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 3378               		.loc 1 1507 0
 3379 1bb6 DA01      		movw r26,r20
 3380 1bb8 022E      		mov r0,r18
 3381 1bba 00C0      		rjmp 2f
 3382               		1:
 3383 1bbc B595      		asr r27
 3384 1bbe A795      		ror r26
 3385               		2:
 3386 1bc0 0A94      		dec r0
 3387 1bc2 02F4      		brpl 1b
 3388 1bc4 A0FF      		sbrs r26,0
 3389 1bc6 00C0      		rjmp .L181
1509:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 3390               		.loc 1 1509 0
 3391 1bc8 DB01      		movw r26,r22
 3392 1bca 022E      		mov r0,r18
 3393 1bcc 00C0      		rjmp 2f
 3394               		1:
 3395 1bce AA0F      		lsl r26
 3396 1bd0 BB1F      		rol r27
 3397               		2:
 3398 1bd2 0A94      		dec r0
 3399 1bd4 02F4      		brpl 1b
 3400 1bd6 FD01      		movw r30,r26
 3401 1bd8 E095      		com r30
 3402 1bda 9E23      		and r25,r30
 3403               	.L181:
 3404 1bdc 2F5F      		subi r18,-1
 3405 1bde 3F4F      		sbci r19,-1
1505:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
 3406               		.loc 1 1505 0
 3407 1be0 2830      		cpi r18,8
 3408 1be2 3105      		cpc r19,__zero_reg__
 3409 1be4 01F4      		brne .L182
 3410 1be6 9093 0000 		sts ledOnOffMask,r25
1513:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 3411               		.loc 1 1513 0
 3412 1bea 8093 0000 		sts ledBlinkMask,r24
1514:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 3413               		.loc 1 1514 0
 3414 1bee 68E9      		ldi r22,lo8(-104)
 3415 1bf0 70E0      		ldi r23,0
 3416 1bf2 82E0      		ldi r24,lo8(2)
 3417               	.LVL91:
 3418 1bf4 0C94 0000 		jmp SetTimer
 3419               	.LVL92:
 3420               		.cfi_endproc
 3421               	.LFE17:
 3424               	KillLeds:
 3425               	.LFB19:
1525:WTPA.c        **** {
 3426               		.loc 1 1525 0
 3427               		.cfi_startproc
 3428               	/* prologue: function */
 3429               	/* frame size = 0 */
 3430               	/* stack size = 0 */
 3431               	.L__stack_usage = 0
1526:WTPA.c        **** 	ledOnOffMask=0;
 3432               		.loc 1 1526 0
 3433 1bf8 1092 0000 		sts ledOnOffMask,__zero_reg__
1527:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 3434               		.loc 1 1527 0
 3435 1bfc 80E0      		ldi r24,0
 3436 1bfe 90E0      		ldi r25,0
 3437 1c00 0C94 0000 		jmp BlinkLeds
 3438               	.LVL93:
 3439               		.cfi_endproc
 3440               	.LFE19:
 3443               	DoFruitcakeIntro:
 3444               	.LFB71:
3851:WTPA.c        **** }
3852:WTPA.c        **** 
3853:WTPA.c        **** static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
3854:WTPA.c        **** // Moves the memory location where the sample begins (or loops) playback farther into the sample.
3855:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3856:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3857:WTPA.c        **** {
3858:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
3859:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3860:WTPA.c        **** }
3861:WTPA.c        **** 
3862:WTPA.c        **** static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
3863:WTPA.c        **** // Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
3864:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3865:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3866:WTPA.c        **** {
3867:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
3868:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3869:WTPA.c        **** }
3870:WTPA.c        **** 
3871:WTPA.c        **** static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
3872:WTPA.c        **** // Shuttles the entire adjusted sample window farther into the sample.
3873:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3874:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3875:WTPA.c        **** {
3876:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
3877:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3878:WTPA.c        **** }
3879:WTPA.c        **** 
3880:WTPA.c        **** //--------------------------------------
3881:WTPA.c        **** //--------------------------------------
3882:WTPA.c        **** // SAMPLER Main Loop!
3883:WTPA.c        **** //--------------------------------------
3884:WTPA.c        **** //--------------------------------------
3885:WTPA.c        **** 
3886:WTPA.c        **** static unsigned char
3887:WTPA.c        **** 	currentBank;					// Keeps track of the bank we're thinking about.
3888:WTPA.c        **** 
3889:WTPA.c        **** static void UpdateUserSwitches(void)
3890:WTPA.c        **** // Take the button-mashings of the player and translate them into something useful.
3891:WTPA.c        **** // There are two "shift" keys on WTPA2 (switch 6 and 7).
3892:WTPA.c        **** // Button functions are relative to how many shift keys are being held down: 0, one, or two.
3893:WTPA.c        **** 
3894:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
3895:WTPA.c        **** // ------------------------------------------------------------------------------------------------
3896:WTPA.c        **** // No Shift:	Rec			Odub		Restart		Single		Pause		Bank		Shift1		Shift2
3897:WTPA.c        **** // Shift 1:		BitDepth	Halftime	Realtime	Granular	SumMode		Backwards	(pressed)	(not pressed)
3898:WTPA.c        **** // Shift 2:		Edit Start	Edit End	Edit Wind	Play SD		Jitter		?			(not press)	(pressed)
3899:WTPA.c        **** // Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
3900:WTPA.c        **** {
3901:WTPA.c        **** 	static unsigned char
3902:WTPA.c        **** 			lastEncoderValue;
3903:WTPA.c        **** 
3904:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3905:WTPA.c        **** 	// Two shift keys:
3906:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3907:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
3908:WTPA.c        **** 	{
3909:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
3910:WTPA.c        **** 		{
3911:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
3912:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
3913:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
3914:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
3915:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
3916:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
3917:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
3918:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
3919:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
3920:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
3921:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
3922:WTPA.c        **** 		}
3923:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)
3924:WTPA.c        **** 		{
3925:WTPA.c        **** 			// Enter SD card menu
3926:WTPA.c        **** 			WriteSampleToSd(currentBank,0);		// @@@ test
3927:WTPA.c        **** 		}
3928:WTPA.c        **** 		else if(newKeys&Im_SWITCH_1)
3929:WTPA.c        **** 		{
3930:WTPA.c        **** 			// Enter SD card menu
3931:WTPA.c        **** 			ReadSampleFromSd(currentBank,0);	// @@@ test
3932:WTPA.c        **** 		}
3933:WTPA.c        **** 	}
3934:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3935:WTPA.c        **** 	// Shift 1:
3936:WTPA.c        **** 	// -----------------------------------------------------------------------------------
3937:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
3938:WTPA.c        **** 	{
3939:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
3940:WTPA.c        **** 		{
3941:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pre
3942:WTPA.c        **** 			{
3943:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
3944:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
3945:WTPA.c        **** 			}
3946:WTPA.c        **** 		}
3947:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
3948:WTPA.c        **** 		{
3949:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
3950:WTPA.c        **** 			{
3951:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
3952:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
3953:WTPA.c        **** 			}
3954:WTPA.c        **** 			else
3955:WTPA.c        **** 			{
3956:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
3957:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
3958:WTPA.c        **** 			}
3959:WTPA.c        **** 		}
3960:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
3961:WTPA.c        **** 		{
3962:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
3963:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
3964:WTPA.c        **** 		}
3965:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granula
3966:WTPA.c        **** 		{
3967:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
3968:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
3969:WTPA.c        **** 		}
3970:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
3971:WTPA.c        **** 		{
3972:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only change to new values
3973:WTPA.c        **** 			{
3974:WTPA.c        **** 				switch(scaledEncoderValue)
3975:WTPA.c        **** 				{
3976:WTPA.c        **** 					case 0:
3977:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
3978:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3979:WTPA.c        **** 					break;
3980:WTPA.c        **** 
3981:WTPA.c        **** 					case 1:
3982:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
3983:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3984:WTPA.c        **** 					break;
3985:WTPA.c        **** 
3986:WTPA.c        **** 					case 2:
3987:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
3988:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3989:WTPA.c        **** 					break;
3990:WTPA.c        **** 
3991:WTPA.c        **** 					case 3:
3992:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
3993:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
3994:WTPA.c        **** 					break;
3995:WTPA.c        **** 
3996:WTPA.c        **** 					default:
3997:WTPA.c        **** 					break;
3998:WTPA.c        **** 				}
3999:WTPA.c        **** 			}
4000:WTPA.c        **** 		}
4001:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
4002:WTPA.c        **** 		{
4003:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
4004:WTPA.c        **** 			{
4005:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
4006:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
4007:WTPA.c        **** 			}
4008:WTPA.c        **** 			else
4009:WTPA.c        **** 			{
4010:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
4011:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
4012:WTPA.c        **** 			}
4013:WTPA.c        **** 
4014:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
4015:WTPA.c        **** 		}
4016:WTPA.c        **** 	}
4017:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4018:WTPA.c        **** 	// Shift 2:
4019:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4020:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
4021:WTPA.c        **** 	{
4022:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
4023:WTPA.c        **** 		{
4024:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
4025:WTPA.c        **** 			{
4026:WTPA.c        **** 				AdjustSampleStart(currentBank,encoderValue);
4027:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
4028:WTPA.c        **** 			}
4029:WTPA.c        **** 		}
4030:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
4031:WTPA.c        **** 		{
4032:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
4033:WTPA.c        **** 			{
4034:WTPA.c        **** 				AdjustSampleEnd(currentBank,encoderValue);
4035:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
4036:WTPA.c        **** 			}
4037:WTPA.c        **** 		}
4038:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
4039:WTPA.c        **** 		{
4040:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
4041:WTPA.c        **** 			{
4042:WTPA.c        **** 				AdjustSampleWindow(currentBank,encoderValue);
4043:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
4044:WTPA.c        **** 			}
4045:WTPA.c        **** 		}
4046:WTPA.c        **** 
4047:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
4048:WTPA.c        **** 		{
4049:WTPA.c        **** //			PlaySampleFromSd(BANK_0,0);		// @@@
4050:WTPA.c        **** 			PlaySampleFromSd(0);			// @@@ stream from slot 0
4051:WTPA.c        **** 
4052:WTPA.c        **** 		}
4053:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)		// Update Jitter
4054:WTPA.c        **** 		{
4055:WTPA.c        **** 			//	bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;		// 
4056:WTPA.c        **** 		}
4057:WTPA.c        **** 	}
4058:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4059:WTPA.c        **** 	// No shift keys pressed:
4060:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4061:WTPA.c        **** 	else	// User isn't holding shift keys, look for single key presses
4062:WTPA.c        **** 	{
4063:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
4064:WTPA.c        **** 		{
4065:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
4066:WTPA.c        **** 			{
4067:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4068:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4069:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4070:WTPA.c        **** 			}
4071:WTPA.c        **** 			else											// We're not recording right now, so start doing it.
4072:WTPA.c        **** 			{
4073:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
4074:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
4075:WTPA.c        **** 			}
4076:WTPA.c        **** 		}
4077:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
4078:WTPA.c        **** 		{
4079:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
4080:WTPA.c        **** 			{
4081:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
4082:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4083:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
4084:WTPA.c        **** 			}
4085:WTPA.c        **** 			else							// We're not recording right now, so start doing it.
4086:WTPA.c        **** 			{
4087:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
4088:WTPA.c        **** 				{
4089:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
4090:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
4091:WTPA.c        **** 				}
4092:WTPA.c        **** 			}
4093:WTPA.c        **** 		}
4094:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
4095:WTPA.c        **** 		{
4096:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4097:WTPA.c        **** 			{
4098:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4099:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4100:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4101:WTPA.c        **** 			}
4102:WTPA.c        **** 		}
4103:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
4104:WTPA.c        **** 		{
4105:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4106:WTPA.c        **** 			{
4107:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
4108:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
4109:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4110:WTPA.c        **** 			}
4111:WTPA.c        **** 		}
4112:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
4113:WTPA.c        **** 		{
4114:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
4115:WTPA.c        **** 			{
4116:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4117:WTPA.c        **** 				{
4118:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
4119:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
4120:WTPA.c        **** 				}
4121:WTPA.c        **** 			}
4122:WTPA.c        **** 			else		// Pause whatever we were doing.
4123:WTPA.c        **** 			{
4124:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
4125:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
4126:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
4127:WTPA.c        **** 			}
4128:WTPA.c        **** 
4129:WTPA.c        **** 		}
4130:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
4131:WTPA.c        **** 		{
4132:WTPA.c        **** 			currentBank++;
4133:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
4134:WTPA.c        **** 			{
4135:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
4136:WTPA.c        **** 			}
4137:WTPA.c        **** 		}
4138:WTPA.c        **** 	}
4139:WTPA.c        **** 
4140:WTPA.c        **** 	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
4141:WTPA.c        **** }
4142:WTPA.c        **** 
4143:WTPA.c        **** static void DoSampler(void)
4144:WTPA.c        **** // This state is the font from which all sampler bullshit flows.
4145:WTPA.c        **** // As WTPA stands now, the switches all basically retain the same functions regardless of what the 
4146:WTPA.c        **** // Same goes for the LEDs.  So we've gotten rid of a modal system and now just watch for commands v
4147:WTPA.c        **** // Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do somethi
4148:WTPA.c        **** // power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be 
4149:WTPA.c        **** 
4150:WTPA.c        **** // Wed Apr  8 11:42:07 CDT 2009
4151:WTPA.c        **** // This state is based on the idea that playing, recording, and overdubbing are all discrete things
4152:WTPA.c        **** {
4153:WTPA.c        **** 	unsigned char
4154:WTPA.c        **** 		i;
4155:WTPA.c        **** 
4156:WTPA.c        **** 	static MIDI_MESSAGE
4157:WTPA.c        **** 		currentMidiMessage;				// Used to point to incoming midi messages.
4158:WTPA.c        **** 
4159:WTPA.c        **** 	static unsigned char
4160:WTPA.c        **** 		currentNoteOn[NUM_BANKS]=		// Used to keep track of what notes we've got on in MIDI.
4161:WTPA.c        **** 		{
4162:WTPA.c        **** 			60,							// In case we record, then overdub immediately without playing anything, we'll need a 
4163:WTPA.c        **** 			60,
4164:WTPA.c        **** 		};
4165:WTPA.c        **** 
4166:WTPA.c        **** 	static bool
4167:WTPA.c        **** 		realtimeOn[NUM_BANKS];			// Used in MIDI to carry the realtime processing across a NOTE_OFF.
4168:WTPA.c        **** 
4169:WTPA.c        **** 	unsigned int
4170:WTPA.c        **** 		pitchWheelValue;				// Figures out what to do with the pitchbend data.
4171:WTPA.c        **** 
4172:WTPA.c        **** //	static bool
4173:WTPA.c        **** //		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we
4174:WTPA.c        **** 
4175:WTPA.c        **** 	if(subState==SS_0)
4176:WTPA.c        **** 	// Initialize everything.
4177:WTPA.c        **** 	{
4178:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
4179:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
4180:WTPA.c        **** 		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardco
4181:WTPA.c        **** 		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardco
4182:WTPA.c        **** 
4183:WTPA.c        **** 		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
4184:WTPA.c        **** 		{
4185:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
4186:WTPA.c        **** 			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet
4187:WTPA.c        **** 			bankStates[i].loopOnce=false;
4188:WTPA.c        **** 			bankStates[i].bitReduction=0;				// No crusties yet.
4189:WTPA.c        **** 			bankStates[i].jitterValue=0;				// No hissies yet.
4190:WTPA.c        **** 			bankStates[i].granularSlices=0;				// No remix yet.
4191:WTPA.c        **** 			bankStates[i].halfSpeed=false;
4192:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
4193:WTPA.c        **** 			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
4194:WTPA.c        **** 			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beg
4195:WTPA.c        **** 			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sa
4196:WTPA.c        **** 			realtimeOn[i]=false;								// We'll default to playback.
4197:WTPA.c        **** 			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
4198:WTPA.c        **** //			editModeEntered=false;
4199:WTPA.c        **** 
4200:WTPA.c        **** 			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
4201:WTPA.c        **** 
4202:WTPA.c        **** 			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
4203:WTPA.c        **** 			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful num
4204:WTPA.c        **** 		}
4205:WTPA.c        **** 
4206:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4207:WTPA.c        **** 
4208:WTPA.c        **** 		currentBank=BANK_0;			// Point at the first bank until we change banks.
4209:WTPA.c        **** 
4210:WTPA.c        **** 		KillLeds();					// All leds off, and no blinking.
4211:WTPA.c        **** 		subState=SS_1;
4212:WTPA.c        **** 	}
4213:WTPA.c        **** 
4214:WTPA.c        **** 	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different s
4215:WTPA.c        **** 	{
4216:WTPA.c        **** 		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI
4217:WTPA.c        **** 
4218:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
4219:WTPA.c        **** 		{
4220:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
4221:WTPA.c        **** /*
4222:WTPA.c        **** 			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
4223:WTPA.c        **** 			{
4224:WTPA.c        **** 				// Do this here.
4225:WTPA.c        **** 			}
4226:WTPA.c        **** */
4227:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
4228:WTPA.c        **** 			{
4229:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
4230:WTPA.c        **** 				{
4231:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
4232:WTPA.c        **** 					{
4233:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
4234:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
4235:WTPA.c        **** 					}
4236:WTPA.c        **** 				}
4237:WTPA.c        **** 			}
4238:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
4239:WTPA.c        **** 			{
4240:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
4241:WTPA.c        **** 
4242:WTPA.c        **** 				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
4243:WTPA.c        **** 				{
4244:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
4245:WTPA.c        **** 				}
4246:WTPA.c        **** 				else
4247:WTPA.c        **** 				{
4248:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
4249:WTPA.c        **** 					{
4250:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
4251:WTPA.c        **** 					}
4252:WTPA.c        **** 				}
4253:WTPA.c        **** 			}
4254:WTPA.c        **** 
4255:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
4256:WTPA.c        **** 			{
4257:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
4258:WTPA.c        **** 				{
4259:WTPA.c        **** 					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
4260:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4261:WTPA.c        **** 					{
4262:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
4263:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback 
4264:WTPA.c        **** 					}
4265:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
4266:WTPA.c        **** 					{
4267:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4268:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4269:WTPA.c        **** 					}
4270:WTPA.c        **** 					break;
4271:WTPA.c        **** 
4272:WTPA.c        **** 					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
4273:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4274:WTPA.c        **** 					{
4275:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
4276:WTPA.c        **** 						{
4277:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
4278:WTPA.c        **** 							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to pla
4279:WTPA.c        **** 						}
4280:WTPA.c        **** 					}
4281:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
4282:WTPA.c        **** 					{
4283:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
4284:WTPA.c        **** 					}
4285:WTPA.c        **** 					break;
4286:WTPA.c        **** 
4287:WTPA.c        **** 					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
4288:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4289:WTPA.c        **** 					{
4290:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
4291:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop 
4292:WTPA.c        **** 					}
4293:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
4294:WTPA.c        **** 					{
4295:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4296:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4297:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
4298:WTPA.c        **** 					}
4299:WTPA.c        **** 
4300:WTPA.c        **** 					break;
4301:WTPA.c        **** 
4302:WTPA.c        **** 					case MIDI_LOOP:							// Keep playing samples over again until note off.
4303:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4304:WTPA.c        **** 					{
4305:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4306:WTPA.c        **** 					}
4307:WTPA.c        **** 					else
4308:WTPA.c        **** 					{
4309:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
4310:WTPA.c        **** 					}
4311:WTPA.c        **** 					break;
4312:WTPA.c        **** 
4313:WTPA.c        **** 					case MIDI_HALF_SPEED:							// Skrew and chop.
4314:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4315:WTPA.c        **** 					{
4316:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
4317:WTPA.c        **** 					}
4318:WTPA.c        **** 					else
4319:WTPA.c        **** 					{
4320:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4321:WTPA.c        **** 					}
4322:WTPA.c        **** 					break;
4323:WTPA.c        **** 
4324:WTPA.c        **** 					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
4325:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4326:WTPA.c        **** 					{
4327:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
4328:WTPA.c        **** 					}
4329:WTPA.c        **** 					else
4330:WTPA.c        **** 					{
4331:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4332:WTPA.c        **** 					}
4333:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
4334:WTPA.c        **** 					break;
4335:WTPA.c        **** 
4336:WTPA.c        **** 					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
4337:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4338:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
4339:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
4340:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
4341:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4342:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4343:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4344:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4345:WTPA.c        **** 					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
4346:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4347:WTPA.c        **** 					break;
4348:WTPA.c        **** 
4349:WTPA.c        **** 					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
4350:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
4351:WTPA.c        **** 					{
4352:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
4353:WTPA.c        **** 					}
4354:WTPA.c        **** 					break;
4355:WTPA.c        **** 
4356:WTPA.c        **** 					case MIDI_GRANULARITY:						// Beatbox.
4357:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4358:WTPA.c        **** 					break;
4359:WTPA.c        **** 
4360:WTPA.c        **** 					case MIDI_JITTER:							// Hisssss
4361:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
4362:WTPA.c        **** 					break;
4363:WTPA.c        **** 
4364:WTPA.c        **** 					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
4365:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
4366:WTPA.c        **** 					{
4367:WTPA.c        **** 						case 0:
4368:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
4369:WTPA.c        **** 						break;
4370:WTPA.c        **** 
4371:WTPA.c        **** 						case 1:
4372:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
4373:WTPA.c        **** 						break;
4374:WTPA.c        **** 
4375:WTPA.c        **** 						case 2:
4376:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
4377:WTPA.c        **** 						break;
4378:WTPA.c        **** 
4379:WTPA.c        **** 						case 3:
4380:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
4381:WTPA.c        **** 						break;
4382:WTPA.c        **** 
4383:WTPA.c        **** 						default:
4384:WTPA.c        **** 						break;
4385:WTPA.c        **** 					}
4386:WTPA.c        **** 					break;
4387:WTPA.c        **** 
4388:WTPA.c        **** 					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
4389:WTPA.c        **** 					i=SREG;
4390:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
4391:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
4392:WTPA.c        **** 					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelN
4393:WTPA.c        **** 					SREG=i;		// Re-enable interrupts.
4394:WTPA.c        **** 					break;
4395:WTPA.c        **** 
4396:WTPA.c        **** //	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-siz
4397:WTPA.c        **** 
4398:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
4399:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4400:WTPA.c        **** 					break;
4401:WTPA.c        **** 
4402:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
4403:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4404:WTPA.c        **** 					break;
4405:WTPA.c        **** 
4406:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
4407:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4408:WTPA.c        **** 					break;
4409:WTPA.c        **** 
4410:WTPA.c        **** 					case MIDI_REVERT_SAMPLE_TO_FULL:
4411:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
4412:WTPA.c        **** 					break;
4413:WTPA.c        **** 
4414:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_WIDE:
4415:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4416:WTPA.c        **** 					break;
4417:WTPA.c        **** 
4418:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_WIDE:
4419:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4420:WTPA.c        **** 					break;
4421:WTPA.c        **** 
4422:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
4423:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4424:WTPA.c        **** 					break;
4425:WTPA.c        **** 
4426:WTPA.c        **** 					default:
4427:WTPA.c        **** 					break;
4428:WTPA.c        **** 				}
4429:WTPA.c        **** 			}
4430:WTPA.c        **** 
4431:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
4432:WTPA.c        **** 			{
4433:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
4434:WTPA.c        **** 
4435:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
4436:WTPA.c        **** 				{
4437:WTPA.c        **** 					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This
4438:WTPA.c        **** 					{
4439:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4440:WTPA.c        **** 					}
4441:WTPA.c        **** 					else						// Pitch the note by some amount (add value to the OCR1A).
4442:WTPA.c        **** 					{
4443:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4444:WTPA.c        **** 					}
4445:WTPA.c        **** 				}
4446:WTPA.c        **** 				else
4447:WTPA.c        **** 				{
4448:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
4449:WTPA.c        **** 				}
4450:WTPA.c        **** 			}
4451:WTPA.c        **** 		}
4452:WTPA.c        **** 	}
4453:WTPA.c        **** 
4454:WTPA.c        **** //	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle clo
4455:WTPA.c        **** 	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Voi
4456:WTPA.c        **** 	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
4457:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
4458:WTPA.c        **** }
4459:WTPA.c        **** 
4460:WTPA.c        **** //--------------------------------------
4461:WTPA.c        **** //--------------------------------------
4462:WTPA.c        **** // DAC Testing.
4463:WTPA.c        **** //--------------------------------------
4464:WTPA.c        **** //--------------------------------------
4465:WTPA.c        **** 
4466:WTPA.c        **** static void DoSawtooth(void)
4467:WTPA.c        **** // See if we can get some audio out.  And look good doing it.
4468:WTPA.c        **** // Also test to see if our flash is present and working.
4469:WTPA.c        **** {
4470:WTPA.c        **** 	static unsigned char
4471:WTPA.c        **** 		lastShuttleRead;
4472:WTPA.c        **** 
4473:WTPA.c        **** 	if(subState==SS_0)
4474:WTPA.c        **** 	{
4475:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
4476:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
4477:WTPA.c        **** 		subState=SS_1;
4478:WTPA.c        **** 	}
4479:WTPA.c        **** 	else if(subState==SS_1)
4480:WTPA.c        **** 	{
4481:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4482:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
4483:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
4484:WTPA.c        **** 		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
4485:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4486:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4487:WTPA.c        **** 
4488:WTPA.c        **** 		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the 
4489:WTPA.c        **** 
4490:WTPA.c        **** 		subState=SS_2;					// And wait forever.
4491:WTPA.c        **** 	}
4492:WTPA.c        **** 	else if(subState==SS_2)
4493:WTPA.c        **** 	{
4494:WTPA.c        **** 
4495:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4496:WTPA.c        **** 		{
4497:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
4498:WTPA.c        **** 		}
4499:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4500:WTPA.c        **** 		{
4501:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
4502:WTPA.c        **** 		}
4503:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
4504:WTPA.c        **** 		{
4505:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
4506:WTPA.c        **** 		}
4507:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
4508:WTPA.c        **** 		{
4509:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
4510:WTPA.c        **** 		}
4511:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
4512:WTPA.c        **** 		{
4513:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
4514:WTPA.c        **** 		}
4515:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
4516:WTPA.c        **** 		{
4517:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
4518:WTPA.c        **** 		}
4519:WTPA.c        **** 
4520:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
4521:WTPA.c        **** 		{
4522:WTPA.c        **** 			StopBlinking();
4523:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
4524:WTPA.c        **** 		}
4525:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
4526:WTPA.c        **** 		{
4527:WTPA.c        **** 			StopBlinking();
4528:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
4529:WTPA.c        **** 		}
4530:WTPA.c        **** 		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new v
4531:WTPA.c        **** 		{
4532:WTPA.c        **** 			StopBlinking();
4533:WTPA.c        **** 			ledOnOffMask=encoderValue;
4534:WTPA.c        **** 			lastShuttleRead=encoderValue;
4535:WTPA.c        **** 		}
4536:WTPA.c        **** 	}
4537:WTPA.c        **** }
4538:WTPA.c        **** 
4539:WTPA.c        **** /*
4540:WTPA.c        **** static void MidiOutputTestBinnis(void)
4541:WTPA.c        **** {
4542:WTPA.c        **** 	if(subState==SS_0)
4543:WTPA.c        **** 	{
4544:WTPA.c        **** 		midiChannelNumberA=0x01;			// @@@ Hardcoded midi channel for now.
4545:WTPA.c        **** 		midiChannelNumberB=0x02;			// @@@ Hardcoded midi channel for now.
4546:WTPA.c        **** 		StopReadingPot();				// Make sure this silly business is gone (for now)
4547:WTPA.c        **** 		KillLeds();						// All leds off, and no blinking.
4548:WTPA.c        **** 		subState=SS_1;
4549:WTPA.c        **** 	}
4550:WTPA.c        **** 	else
4551:WTPA.c        **** 	{
4552:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4553:WTPA.c        **** 		{
4554:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_0));	// Toggle the LED.
4555:WTPA.c        **** 			// Hardcoded Note On, middle C, Velocity 64, Midi channel 1.
4556:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4557:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4558:WTPA.c        **** 			Uart0SendByte(64);			// @@@
4559:WTPA.c        **** 
4560:WTPA.c        **** 		}
4561:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4562:WTPA.c        **** 		{
4563:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_1));	// Toggle the LED.
4564:WTPA.c        **** 			// Hardcoded Note Off, middle C, Velocity 0, Midi channel 1.
4565:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4566:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4567:WTPA.c        **** 			Uart0SendByte(0);			// @@@
4568:WTPA.c        **** 		}
4569:WTPA.c        **** 	}
4570:WTPA.c        **** }
4571:WTPA.c        **** */
4572:WTPA.c        **** 
4573:WTPA.c        **** 
4574:WTPA.c        **** static void SetMidiChannels(void)
4575:WTPA.c        **** // This is a state the user can enter at startup where they set and store desired midi channels usi
4576:WTPA.c        **** {
4577:WTPA.c        **** 	if(subState==SS_0)
4578:WTPA.c        **** 	{
4579:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
4580:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
4581:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
4582:WTPA.c        **** 		subState=SS_1;
4583:WTPA.c        **** 	}
4584:WTPA.c        **** 	else
4585:WTPA.c        **** 	{
4586:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4587:WTPA.c        **** 		{
4588:WTPA.c        **** 			midiChannelNumberA++;
4589:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
4590:WTPA.c        **** 			{
4591:WTPA.c        **** 				midiChannelNumberA=0;
4592:WTPA.c        **** 			}
4593:WTPA.c        **** 
4594:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
4595:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
4596:WTPA.c        **** 		}
4597:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4598:WTPA.c        **** 		{
4599:WTPA.c        **** 			midiChannelNumberB++;
4600:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
4601:WTPA.c        **** 			{
4602:WTPA.c        **** 				midiChannelNumberB=0;
4603:WTPA.c        **** 			}
4604:WTPA.c        **** 
4605:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
4606:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
4607:WTPA.c        **** 		}
4608:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
4609:WTPA.c        **** 		{
4610:WTPA.c        **** 			StoreMidiChannel(BANK_0,midiChannelNumberA);
4611:WTPA.c        **** 			StoreMidiChannel(BANK_1,midiChannelNumberB);
4612:WTPA.c        **** 			SetState(DoSampler);
4613:WTPA.c        **** 		}
4614:WTPA.c        **** 	}
4615:WTPA.c        **** }
4616:WTPA.c        **** 
4617:WTPA.c        **** static void DoStartupSelect(void)
4618:WTPA.c        **** // Make all our initial state decisions.
4619:WTPA.c        **** // Give switches time to settle.
4620:WTPA.c        **** {
4621:WTPA.c        **** 	if(subState==SS_0)
4622:WTPA.c        **** 	{
4623:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
4624:WTPA.c        **** 		subState=SS_1;
4625:WTPA.c        **** 	}
4626:WTPA.c        **** 	else
4627:WTPA.c        **** 	{
4628:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4629:WTPA.c        **** 		{
4630:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
4631:WTPA.c        **** 			{
4632:WTPA.c        **** 				SetState(DoSawtooth);
4633:WTPA.c        **** 			}
4634:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
4635:WTPA.c        **** 			{
4636:WTPA.c        **** 				SetState(SetMidiChannels);
4637:WTPA.c        **** 			}
4638:WTPA.c        **** 			else
4639:WTPA.c        **** 			{
4640:WTPA.c        **** 				SetState(DoSampler);
4641:WTPA.c        **** 			}
4642:WTPA.c        **** 		}
4643:WTPA.c        **** 	}
4644:WTPA.c        **** }
4645:WTPA.c        **** 
4646:WTPA.c        **** static void DoFruitcakeIntro(void)
4647:WTPA.c        **** // Oh god why.
4648:WTPA.c        **** {
 3445               		.loc 1 4648 0
 3446               		.cfi_startproc
 3447 1c04 CF93      		push r28
 3448               	.LCFI32:
 3449               		.cfi_def_cfa_offset 3
 3450               		.cfi_offset 28, -2
 3451               	/* prologue: function */
 3452               	/* frame size = 0 */
 3453               	/* stack size = 1 */
 3454               	.L__stack_usage = 1
4649:WTPA.c        **** 	static unsigned char
4650:WTPA.c        **** 		i;
4651:WTPA.c        **** 
4652:WTPA.c        **** 	if(subState==SS_0)
 3455               		.loc 1 4652 0
 3456 1c06 C091 0000 		lds r28,subState
 3457 1c0a C111      		cpse r28,__zero_reg__
 3458 1c0c 00C0      		rjmp .L189
4653:WTPA.c        **** 	{
4654:WTPA.c        **** 		KillLeds();
 3459               		.loc 1 4654 0
 3460 1c0e 0E94 0000 		call KillLeds
 3461               	.LVL94:
4655:WTPA.c        **** 		i=0;
 3462               		.loc 1 4655 0
 3463 1c12 1092 0000 		sts i.2252,__zero_reg__
4656:WTPA.c        **** 		ledOnOffMask=0;
 3464               		.loc 1 4656 0
 3465 1c16 1092 0000 		sts ledOnOffMask,__zero_reg__
4657:WTPA.c        **** 		subState=SS_1;
 3466               		.loc 1 4657 0
 3467 1c1a 81E0      		ldi r24,lo8(1)
 3468 1c1c 8093 0000 		sts subState,r24
4658:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 3469               		.loc 1 4658 0
 3470 1c20 61E3      		ldi r22,lo8(49)
 3471 1c22 71E0      		ldi r23,lo8(1)
 3472 1c24 00C0      		rjmp .L211
 3473               	.L189:
4659:WTPA.c        **** 	}
4660:WTPA.c        **** 	else if(subState==SS_1)
 3474               		.loc 1 4660 0
 3475 1c26 C130      		cpi r28,lo8(1)
 3476 1c28 01F4      		brne .L190
4661:WTPA.c        **** 	{
4662:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3477               		.loc 1 4662 0
 3478 1c2a 80E0      		ldi r24,0
 3479 1c2c 0E94 0000 		call CheckTimer
 3480               	.LVL95:
 3481 1c30 8823      		tst r24
 3482 1c32 01F4      		brne .+2
 3483 1c34 00C0      		rjmp .L188
4663:WTPA.c        **** 		{
4664:WTPA.c        **** 			subState=SS_2;
 3484               		.loc 1 4664 0
 3485 1c36 82E0      		ldi r24,lo8(2)
 3486 1c38 00C0      		rjmp .L210
 3487               	.L190:
4665:WTPA.c        **** 		}
4666:WTPA.c        **** 	}
4667:WTPA.c        **** 
4668:WTPA.c        **** 	else if(subState==SS_2)
 3488               		.loc 1 4668 0
 3489 1c3a C230      		cpi r28,lo8(2)
 3490 1c3c 01F0      		breq .+2
 3491 1c3e 00C0      		rjmp .L193
4669:WTPA.c        **** 	{
4670:WTPA.c        **** 		if(i<NUM_LEDS)
 3492               		.loc 1 4670 0
 3493 1c40 8091 0000 		lds r24,i.2252
 3494 1c44 8830      		cpi r24,lo8(8)
 3495 1c46 00F4      		brsh .L194
4671:WTPA.c        **** 		{
4672:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3496               		.loc 1 4672 0
 3497 1c48 80E0      		ldi r24,0
 3498 1c4a 0E94 0000 		call CheckTimer
 3499               	.LVL96:
 3500 1c4e 8823      		tst r24
 3501 1c50 01F4      		brne .+2
 3502 1c52 00C0      		rjmp .L188
4673:WTPA.c        **** 			{
4674:WTPA.c        **** 				ledOnOffMask|=(1<<i);
 3503               		.loc 1 4674 0
 3504 1c54 81E0      		ldi r24,lo8(1)
 3505 1c56 90E0      		ldi r25,0
 3506 1c58 0090 0000 		lds r0,i.2252
 3507 1c5c 00C0      		rjmp 2f
 3508               		1:
 3509 1c5e 880F      		lsl r24
 3510 1c60 991F      		rol r25
 3511               		2:
 3512 1c62 0A94      		dec r0
 3513 1c64 02F4      		brpl 1b
 3514 1c66 9091 0000 		lds r25,ledOnOffMask
 3515 1c6a 982B      		or r25,r24
 3516 1c6c 9093 0000 		sts ledOnOffMask,r25
4675:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
 3517               		.loc 1 4675 0
 3518 1c70 6DE3      		ldi r22,lo8(61)
 3519 1c72 70E0      		ldi r23,0
 3520 1c74 80E0      		ldi r24,0
 3521 1c76 0E94 0000 		call SetTimer
 3522               	.LVL97:
4676:WTPA.c        **** 				i++;
 3523               		.loc 1 4676 0
 3524 1c7a 8091 0000 		lds r24,i.2252
 3525 1c7e 8F5F      		subi r24,lo8(-(1))
 3526 1c80 8093 0000 		sts i.2252,r24
 3527 1c84 00C0      		rjmp .L188
 3528               	.L194:
4677:WTPA.c        **** 			}
4678:WTPA.c        **** 		}
4679:WTPA.c        **** 		else
4680:WTPA.c        **** 		{
4681:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 3529               		.loc 1 4681 0
 3530 1c86 80E0      		ldi r24,0
 3531 1c88 0E94 0000 		call CheckTimer
 3532               	.LVL98:
 3533 1c8c 8823      		tst r24
 3534 1c8e 01F4      		brne .+2
 3535 1c90 00C0      		rjmp .L188
4682:WTPA.c        **** 			{
4683:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
 3536               		.loc 1 4683 0
 3537 1c92 68E9      		ldi r22,lo8(-104)
 3538 1c94 70E0      		ldi r23,0
 3539 1c96 80E0      		ldi r24,0
 3540 1c98 0E94 0000 		call SetTimer
 3541               	.LVL99:
4684:WTPA.c        **** 				ledPwm=255;
 3542               		.loc 1 4684 0
 3543 1c9c 8FEF      		ldi r24,lo8(-1)
 3544 1c9e 8093 0000 		sts ledPwm,r24
4685:WTPA.c        **** 				// Grudgingly enable pwm hackery.
4686:WTPA.c        **** 
4687:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 3545               		.loc 1 4687 0
 3546 1ca2 9091 6400 		lds r25,100
 3547 1ca6 9F7B      		andi r25,lo8(-65)
 3548 1ca8 9093 6400 		sts 100,r25
4688:WTPA.c        **** 
4689:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 3549               		.loc 1 4689 0
 3550 1cac C093 B000 		sts 176,r28
4690:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
 3551               		.loc 1 4690 0
 3552 1cb0 91E0      		ldi r25,lo8(1)
 3553 1cb2 9093 B100 		sts 177,r25
4691:WTPA.c        **** 				TCNT2=0;			// Init counter reg
 3554               		.loc 1 4691 0
 3555 1cb6 1092 B200 		sts 178,__zero_reg__
4692:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
 3556               		.loc 1 4692 0
 3557 1cba 90E8      		ldi r25,lo8(-128)
 3558 1cbc 9093 B300 		sts 179,r25
4693:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 3559               		.loc 1 4693 0
 3560 1cc0 87BB      		out 0x17,r24
4694:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
 3561               		.loc 1 4694 0
 3562 1cc2 C093 7000 		sts 112,r28
4695:WTPA.c        **** 
4696:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
 3563               		.loc 1 4696 0
 3564 1cc6 92B1      		in r25,0x2
 3565 1cc8 9660      		ori r25,lo8(6)
 3566 1cca 92B9      		out 0x2,r25
4697:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
 3567               		.loc 1 4697 0
 3568 1ccc 84B9      		out 0x4,r24
4698:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
 3569               		.loc 1 4698 0
 3570 1cce 5F9A      		sbi 0xb,7
4699:WTPA.c        **** 
4700:WTPA.c        **** 				subState=SS_3;
 3571               		.loc 1 4700 0
 3572 1cd0 83E0      		ldi r24,lo8(3)
 3573               	.L210:
 3574 1cd2 8093 0000 		sts subState,r24
 3575 1cd6 00C0      		rjmp .L188
 3576               	.L193:
4701:WTPA.c        **** 			}
4702:WTPA.c        **** 		}
4703:WTPA.c        **** 	}
4704:WTPA.c        **** 	else if(subState==SS_3)
 3577               		.loc 1 4704 0
 3578 1cd8 C330      		cpi r28,lo8(3)
 3579 1cda 01F4      		brne .L196
4705:WTPA.c        **** 	{
4706:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3580               		.loc 1 4706 0
 3581 1cdc 80E0      		ldi r24,0
 3582 1cde 0E94 0000 		call CheckTimer
 3583               	.LVL100:
 3584 1ce2 8823      		tst r24
 3585 1ce4 01F0      		breq .L188
4707:WTPA.c        **** 		{
4708:WTPA.c        **** 			if(ledPwm>1)
 3586               		.loc 1 4708 0
 3587 1ce6 8091 0000 		lds r24,ledPwm
 3588 1cea 8230      		cpi r24,lo8(2)
 3589 1cec 00F0      		brlo .L197
4709:WTPA.c        **** 			{
4710:WTPA.c        **** 				ledPwm-=2;
 3590               		.loc 1 4710 0
 3591 1cee 8091 0000 		lds r24,ledPwm
 3592 1cf2 8250      		subi r24,lo8(-(-2))
 3593 1cf4 8093 0000 		sts ledPwm,r24
4711:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
 3594               		.loc 1 4711 0
 3595 1cf8 64E0      		ldi r22,lo8(4)
 3596 1cfa 70E0      		ldi r23,0
 3597               	.L211:
 3598 1cfc 80E0      		ldi r24,0
 3599               	/* epilogue start */
4712:WTPA.c        **** 			}
4713:WTPA.c        **** 			else
4714:WTPA.c        **** 			{
4715:WTPA.c        **** 				// Gleefully disable PWM.
4716:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
4717:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
4718:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
4719:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
4720:WTPA.c        **** 
4721:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
4722:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
4723:WTPA.c        **** 
4724:WTPA.c        **** 				KillLeds();				// App knows leds are off.
4725:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
4726:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
4727:WTPA.c        **** 				subState=SS_4;
4728:WTPA.c        **** 			}
4729:WTPA.c        **** 		}
4730:WTPA.c        **** 	}
4731:WTPA.c        **** 	else if(subState==SS_4)
4732:WTPA.c        **** 	{
4733:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4734:WTPA.c        **** 		{
4735:WTPA.c        **** 			KillLeds();
4736:WTPA.c        **** 			SetState(DoStartupSelect);		// Get crackin.
4737:WTPA.c        **** 		}
4738:WTPA.c        **** 	}
4739:WTPA.c        **** }
 3600               		.loc 1 4739 0
 3601 1cfe CF91      		pop r28
4711:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
 3602               		.loc 1 4711 0
 3603 1d00 0C94 0000 		jmp SetTimer
 3604               	.LVL101:
 3605               	.L197:
4716:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
 3606               		.loc 1 4716 0
 3607 1d04 1092 7000 		sts 112,__zero_reg__
4717:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
 3608               		.loc 1 4717 0
 3609 1d08 1092 B000 		sts 176,__zero_reg__
4718:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
 3610               		.loc 1 4718 0
 3611 1d0c 1092 B100 		sts 177,__zero_reg__
4719:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
 3612               		.loc 1 4719 0
 3613 1d10 8091 6400 		lds r24,100
 3614 1d14 8064      		ori r24,lo8(64)
 3615 1d16 8093 6400 		sts 100,r24
4721:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
 3616               		.loc 1 4721 0
 3617 1d1a 15B8      		out 0x5,__zero_reg__
4722:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
 3618               		.loc 1 4722 0
 3619 1d1c 5F98      		cbi 0xb,7
4724:WTPA.c        **** 				KillLeds();				// App knows leds are off.
 3620               		.loc 1 4724 0
 3621 1d1e 0E94 0000 		call KillLeds
 3622               	.LVL102:
4725:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
 3623               		.loc 1 4725 0
 3624 1d22 82E1      		ldi r24,lo8(18)
 3625 1d24 8093 0000 		sts ledOnOffMask,r24
4726:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
 3626               		.loc 1 4726 0
 3627 1d28 62E6      		ldi r22,lo8(98)
 3628 1d2a 72E0      		ldi r23,lo8(2)
 3629 1d2c 80E0      		ldi r24,0
 3630 1d2e 0E94 0000 		call SetTimer
 3631               	.LVL103:
4727:WTPA.c        **** 				subState=SS_4;
 3632               		.loc 1 4727 0
 3633 1d32 84E0      		ldi r24,lo8(4)
 3634 1d34 00C0      		rjmp .L210
 3635               	.L196:
4731:WTPA.c        **** 	else if(subState==SS_4)
 3636               		.loc 1 4731 0
 3637 1d36 C430      		cpi r28,lo8(4)
 3638 1d38 01F4      		brne .L188
4733:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3639               		.loc 1 4733 0
 3640 1d3a 80E0      		ldi r24,0
 3641 1d3c 0E94 0000 		call CheckTimer
 3642               	.LVL104:
 3643 1d40 8823      		tst r24
 3644 1d42 01F0      		breq .L188
4735:WTPA.c        **** 			KillLeds();
 3645               		.loc 1 4735 0
 3646 1d44 0E94 0000 		call KillLeds
 3647               	.LVL105:
 3648               	.LBB48:
 3649               	.LBB49:
1447:WTPA.c        **** 	State=newState;
 3650               		.loc 1 1447 0
 3651 1d48 80E0      		ldi r24,lo8(gs(DoStartupSelect))
 3652 1d4a 90E0      		ldi r25,hi8(gs(DoStartupSelect))
 3653 1d4c 9093 0000 		sts State+1,r25
 3654 1d50 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 3655               		.loc 1 1448 0
 3656 1d54 1092 0000 		sts subState,__zero_reg__
 3657               	.LVL106:
 3658               	.L188:
 3659               	/* epilogue start */
 3660               	.LBE49:
 3661               	.LBE48:
 3662               		.loc 1 4739 0
 3663 1d58 CF91      		pop r28
 3664 1d5a 0895      		ret
 3665               		.cfi_endproc
 3666               	.LFE71:
 3669               	SdStartSampleRead:
 3670               	.LFB40:
2281:WTPA.c        **** {
 3671               		.loc 1 2281 0
 3672               		.cfi_startproc
 3673               	.LVL107:
 3674 1d5c CF92      		push r12
 3675               	.LCFI33:
 3676               		.cfi_def_cfa_offset 3
 3677               		.cfi_offset 12, -2
 3678 1d5e DF92      		push r13
 3679               	.LCFI34:
 3680               		.cfi_def_cfa_offset 4
 3681               		.cfi_offset 13, -3
 3682 1d60 EF92      		push r14
 3683               	.LCFI35:
 3684               		.cfi_def_cfa_offset 5
 3685               		.cfi_offset 14, -4
 3686 1d62 FF92      		push r15
 3687               	.LCFI36:
 3688               		.cfi_def_cfa_offset 6
 3689               		.cfi_offset 15, -5
 3690 1d64 CF93      		push r28
 3691               	.LCFI37:
 3692               		.cfi_def_cfa_offset 7
 3693               		.cfi_offset 28, -6
 3694               	/* prologue: function */
 3695               	/* frame size = 0 */
 3696               	/* stack size = 5 */
 3697               	.L__stack_usage = 5
2285:WTPA.c        **** 	sreg=SREG;
 3698               		.loc 1 2285 0
 3699 1d66 CFB7      		in r28,__SREG__
 3700               	.LVL108:
2286:WTPA.c        **** 	cli();		// Pause ISR
 3701               		.loc 1 2286 0
 3702               	/* #APP */
 3703               	 ;  2286 "WTPA.c" 1
 3704 1d68 F894      		cli
 3705               	 ;  0 "" 2
2288:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
 3706               		.loc 1 2288 0
 3707               	/* #NOAPP */
 3708 1d6a 382F      		mov r19,r24
 3709 1d6c 330F      		lsl r19
 3710 1d6e 330F      		lsl r19
 3711 1d70 20E0      		ldi r18,0
 3712 1d72 6901      		movw r12,r18
 3713 1d74 8FEF      		ldi r24,-1
 3714 1d76 C81A      		sub r12,r24
 3715 1d78 D80A      		sbc r13,r24
 3716               	.LVL109:
 3717 1d7a E12C      		mov r14,__zero_reg__
 3718 1d7c F12C      		mov r15,__zero_reg__
 3719 1d7e C701      		movw r24,r14
 3720 1d80 B601      		movw r22,r12
 3721 1d82 0E94 0000 		call SdBeginSingleBlockRead
 3722               	.LVL110:
 3723 1d86 8130      		cpi r24,lo8(1)
 3724 1d88 01F4      		brne .L213
2290:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
 3725               		.loc 1 2290 0
 3726 1d8a C092 0000 		sts sdSampleStartBlock,r12
 3727 1d8e D092 0000 		sts sdSampleStartBlock+1,r13
 3728 1d92 E092 0000 		sts sdSampleStartBlock+2,r14
 3729 1d96 F092 0000 		sts sdSampleStartBlock+3,r15
2291:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
 3730               		.loc 1 2291 0
 3731 1d9a 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 3732 1d9e 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2293:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
 3733               		.loc 1 2293 0
 3734 1da2 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 3735 1da6 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2294:WTPA.c        **** 		sdFifoWritePointer=0;
 3736               		.loc 1 2294 0
 3737 1daa 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 3738 1dae 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2295:WTPA.c        **** 		sdBytesInFifo=0;
 3739               		.loc 1 2295 0
 3740 1db2 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 3741 1db6 1092 0000 		sts sdBytesInFifo,__zero_reg__
2297:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 3742               		.loc 1 2297 0
 3743 1dba 6AE7      		ldi r22,lo8(122)
 3744 1dbc 70E0      		ldi r23,0
 3745 1dbe 83E0      		ldi r24,lo8(3)
 3746 1dc0 0E94 0000 		call SetTimer
 3747               	.LVL111:
2298:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
 3748               		.loc 1 2298 0
 3749 1dc4 89E0      		ldi r24,lo8(9)
 3750 1dc6 8093 0000 		sts cardState,r24
2300:WTPA.c        **** 		SREG=sreg;	// Resume ISR
 3751               		.loc 1 2300 0
 3752 1dca CFBF      		out __SREG__,r28
2302:WTPA.c        **** 		return(true);
 3753               		.loc 1 2302 0
 3754 1dcc 81E0      		ldi r24,lo8(1)
 3755 1dce 00C0      		rjmp .L214
 3756               	.L213:
2304:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 3757               		.loc 1 2304 0
 3758 1dd0 CFBF      		out __SREG__,r28
2305:WTPA.c        **** 	return(false);
 3759               		.loc 1 2305 0
 3760 1dd2 80E0      		ldi r24,0
 3761               	.L214:
 3762               	/* epilogue start */
2306:WTPA.c        **** }
 3763               		.loc 1 2306 0
 3764 1dd4 CF91      		pop r28
 3765               	.LVL112:
 3766 1dd6 FF90      		pop r15
 3767 1dd8 EF90      		pop r14
 3768 1dda DF90      		pop r13
 3769 1ddc CF90      		pop r12
 3770 1dde 0895      		ret
 3771               		.cfi_endproc
 3772               	.LFE40:
 3775               	SetSampleClock.part.0:
 3776               	.LFB73:
1838:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
 3777               		.loc 1 1838 0
 3778               		.cfi_startproc
 3779               	/* prologue: function */
 3780               	/* frame size = 0 */
 3781               	/* stack size = 0 */
 3782               	.L__stack_usage = 0
1867:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 3783               		.loc 1 1867 0
 3784 1de0 E1E8      		ldi r30,lo8(-127)
 3785 1de2 F0E0      		ldi r31,0
 3786 1de4 8081      		ld r24,Z
 3787 1de6 8064      		ori r24,lo8(64)
 3788 1de8 8083      		st Z,r24
1868:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 3789               		.loc 1 1868 0
 3790 1dea B59A      		sbi 0x16,5
1869:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 3791               		.loc 1 1869 0
 3792 1dec EFE6      		ldi r30,lo8(111)
 3793 1dee F0E0      		ldi r31,0
 3794 1df0 8081      		ld r24,Z
 3795 1df2 8062      		ori r24,lo8(32)
 3796 1df4 8083      		st Z,r24
 3797 1df6 0895      		ret
 3798               		.cfi_endproc
 3799               	.LFE73:
 3802               	SetSampleClock:
 3803               	.LFB28:
1841:WTPA.c        **** {
 3804               		.loc 1 1841 0
 3805               		.cfi_startproc
 3806               	.LVL113:
 3807               	/* prologue: function */
 3808               	/* frame size = 0 */
 3809               	/* stack size = 0 */
 3810               	.L__stack_usage = 0
1842:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 3811               		.loc 1 1842 0
 3812 1df8 93E2      		ldi r25,lo8(35)
 3813 1dfa 899F      		mul r24,r25
 3814 1dfc F001      		movw r30,r0
 3815 1dfe 1124      		clr __zero_reg__
 3816 1e00 E050      		subi r30,lo8(-(bankStates))
 3817 1e02 F040      		sbci r31,hi8(-(bankStates))
 3818 1e04 6187      		std Z+9,r22
1844:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
 3819               		.loc 1 1844 0
 3820 1e06 6230      		cpi r22,lo8(2)
 3821 1e08 01F4      		brne .L217
1846:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 3822               		.loc 1 1846 0
 3823 1e0a 5387      		std Z+11,r21
 3824 1e0c 4287      		std Z+10,r20
1848:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 3825               		.loc 1 1848 0
 3826 1e0e 8111      		cpse r24,__zero_reg__
 3827 1e10 00C0      		rjmp .L218
1850:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3828               		.loc 1 1850 0
 3829 1e12 8091 8400 		lds r24,132
 3830 1e16 9091 8500 		lds r25,132+1
 3831               	.LVL114:
 3832 1e1a 840F      		add r24,r20
 3833 1e1c 951F      		adc r25,r21
 3834 1e1e 9093 8900 		sts 136+1,r25
 3835 1e22 8093 8800 		sts 136,r24
1851:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 3836               		.loc 1 1851 0
 3837 1e26 B19A      		sbi 0x16,1
1852:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 3838               		.loc 1 1852 0
 3839 1e28 8091 6F00 		lds r24,111
 3840 1e2c 8260      		ori r24,lo8(2)
 3841 1e2e 00C0      		rjmp .L221
 3842               	.LVL115:
 3843               	.L218:
1857:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3844               		.loc 1 1857 0
 3845 1e30 8091 8400 		lds r24,132
 3846 1e34 9091 8500 		lds r25,132+1
 3847               	.LVL116:
 3848 1e38 840F      		add r24,r20
 3849 1e3a 951F      		adc r25,r21
 3850 1e3c 9093 8B00 		sts 138+1,r25
 3851 1e40 8093 8A00 		sts 138,r24
1858:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 3852               		.loc 1 1858 0
 3853 1e44 B29A      		sbi 0x16,2
1859:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 3854               		.loc 1 1859 0
 3855 1e46 8091 6F00 		lds r24,111
 3856 1e4a 8460      		ori r24,lo8(4)
 3857               	.L221:
 3858 1e4c 8093 6F00 		sts 111,r24
1860:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 3859               		.loc 1 1860 0
 3860 1e50 81E0      		ldi r24,lo8(1)
 3861 1e52 8093 8100 		sts 129,r24
 3862 1e56 0895      		ret
 3863               	.LVL117:
 3864               	.L217:
1863:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
 3865               		.loc 1 1863 0
 3866 1e58 6130      		cpi r22,lo8(1)
 3867 1e5a 01F4      		brne .L216
1865:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 3868               		.loc 1 1865 0
 3869 1e5c 8111      		cpse r24,__zero_reg__
 3870 1e5e 00C0      		rjmp .L220
 3871 1e60 0C94 0000 		jmp SetSampleClock.part.0
 3872               	.LVL118:
 3873               	.L220:
1873:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 3874               		.loc 1 1873 0
 3875 1e64 DA9A      		sbi 0x1b,2
1874:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 3876               		.loc 1 1874 0
 3877 1e66 84E0      		ldi r24,lo8(4)
 3878               	.LVL119:
 3879 1e68 8093 6800 		sts 104,r24
1875:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 3880               		.loc 1 1875 0
 3881 1e6c 80E1      		ldi r24,lo8(16)
 3882 1e6e 8093 6D00 		sts 109,r24
 3883               	.L216:
 3884 1e72 0895      		ret
 3885               		.cfi_endproc
 3886               	.LFE28:
 3889               	StartPlayback:
 3890               	.LFB30:
1925:WTPA.c        **** {
 3891               		.loc 1 1925 0
 3892               		.cfi_startproc
 3893               	.LVL120:
 3894 1e74 FF92      		push r15
 3895               	.LCFI38:
 3896               		.cfi_def_cfa_offset 3
 3897               		.cfi_offset 15, -2
 3898 1e76 0F93      		push r16
 3899               	.LCFI39:
 3900               		.cfi_def_cfa_offset 4
 3901               		.cfi_offset 16, -3
 3902 1e78 1F93      		push r17
 3903               	.LCFI40:
 3904               		.cfi_def_cfa_offset 5
 3905               		.cfi_offset 17, -4
 3906 1e7a CF93      		push r28
 3907               	.LCFI41:
 3908               		.cfi_def_cfa_offset 6
 3909               		.cfi_offset 28, -5
 3910 1e7c DF93      		push r29
 3911               	.LCFI42:
 3912               		.cfi_def_cfa_offset 7
 3913               		.cfi_offset 29, -6
 3914               	/* prologue: function */
 3915               	/* frame size = 0 */
 3916               	/* stack size = 5 */
 3917               	.L__stack_usage = 5
1929:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 3918               		.loc 1 1929 0
 3919 1e7e C82F      		mov r28,r24
 3920 1e80 D0E0      		ldi r29,0
 3921 1e82 93E2      		ldi r25,lo8(35)
 3922 1e84 899F      		mul r24,r25
 3923 1e86 F001      		movw r30,r0
 3924 1e88 1124      		clr __zero_reg__
 3925 1e8a E050      		subi r30,lo8(-(bankStates))
 3926 1e8c F040      		sbci r31,hi8(-(bankStates))
 3927 1e8e 9581      		ldd r25,Z+5
 3928 1e90 9923      		tst r25
 3929 1e92 01F0      		breq .L223
1929:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 3930               		.loc 1 1929 0 is_stmt 0 discriminator 1
 3931 1e94 9091 0000 		lds r25,sdIsrState
 3932 1e98 9150      		subi r25,lo8(-(-1))
 3933 1e9a 9230      		cpi r25,lo8(2)
 3934 1e9c 00F0      		brlo .L222
 3935               	.L223:
1931:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 3936               		.loc 1 1931 0 is_stmt 1
 3937 1e9e FFB6      		in r15,__SREG__
 3938               	.LVL121:
1932:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 3939               		.loc 1 1932 0
 3940               	/* #APP */
 3941               	 ;  1932 "WTPA.c" 1
 3942 1ea0 F894      		cli
 3943               	 ;  0 "" 2
1934:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 3944               		.loc 1 1934 0
 3945               	/* #NOAPP */
 3946 1ea2 93E2      		ldi r25,lo8(35)
 3947 1ea4 9C9F      		mul r25,r28
 3948 1ea6 F001      		movw r30,r0
 3949 1ea8 9D9F      		mul r25,r29
 3950 1eaa F00D      		add r31,r0
 3951 1eac 1124      		clr __zero_reg__
 3952 1eae E050      		subi r30,lo8(-(bankStates))
 3953 1eb0 F040      		sbci r31,hi8(-(bankStates))
 3954 1eb2 94E0      		ldi r25,lo8(4)
 3955 1eb4 9083      		st Z,r25
1936:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 3956               		.loc 1 1936 0
 3957 1eb6 9381      		ldd r25,Z+3
 3958 1eb8 9923      		tst r25
 3959 1eba 01F0      		breq .L225
1938:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 3960               		.loc 1 1938 0
 3961 1ebc 0489      		ldd r16,Z+20
 3962 1ebe 1589      		ldd r17,Z+21
 3963 1ec0 2689      		ldd r18,Z+22
 3964 1ec2 3789      		ldd r19,Z+23
 3965 1ec4 078F      		std Z+31,r16
 3966 1ec6 10A3      		std Z+32,r17
 3967 1ec8 21A3      		std Z+33,r18
 3968 1eca 32A3      		std Z+34,r19
1939:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 3969               		.loc 1 1939 0
 3970 1ecc 1482      		std Z+4,__zero_reg__
 3971 1ece 00C0      		rjmp .L226
 3972               	.L225:
1943:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 3973               		.loc 1 1943 0
 3974 1ed0 008D      		ldd r16,Z+24
 3975 1ed2 118D      		ldd r17,Z+25
 3976 1ed4 228D      		ldd r18,Z+26
 3977 1ed6 338D      		ldd r19,Z+27
 3978 1ed8 078F      		std Z+31,r16
 3979 1eda 10A3      		std Z+32,r17
 3980 1edc 21A3      		std Z+33,r18
 3981 1ede 32A3      		std Z+34,r19
1944:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 3982               		.loc 1 1944 0
 3983 1ee0 91E0      		ldi r25,lo8(1)
 3984 1ee2 9483      		std Z+4,r25
 3985               	.L226:
1947:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 3986               		.loc 1 1947 0
 3987 1ee4 0E94 0000 		call SetSampleClock
 3988               	.LVL122:
1948:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 3989               		.loc 1 1948 0
 3990 1ee8 83E2      		ldi r24,lo8(35)
 3991 1eea 8C9F      		mul r24,r28
 3992 1eec F001      		movw r30,r0
 3993 1eee 8D9F      		mul r24,r29
 3994 1ef0 F00D      		add r31,r0
 3995 1ef2 1124      		clr __zero_reg__
 3996 1ef4 E050      		subi r30,lo8(-(bankStates))
 3997 1ef6 F040      		sbci r31,hi8(-(bankStates))
 3998 1ef8 81E0      		ldi r24,lo8(1)
 3999 1efa 8583      		std Z+5,r24
1949:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4000               		.loc 1 1949 0
 4001 1efc FFBE      		out __SREG__,r15
 4002               	.LVL123:
 4003               	.L222:
 4004               	/* epilogue start */
1951:WTPA.c        **** }
 4005               		.loc 1 1951 0
 4006 1efe DF91      		pop r29
 4007 1f00 CF91      		pop r28
 4008               	.LVL124:
 4009 1f02 1F91      		pop r17
 4010 1f04 0F91      		pop r16
 4011 1f06 FF90      		pop r15
 4012 1f08 0895      		ret
 4013               		.cfi_endproc
 4014               	.LFE30:
 4017               	ContinuePlayback:
 4018               	.LFB31:
1956:WTPA.c        **** {
 4019               		.loc 1 1956 0
 4020               		.cfi_startproc
 4021               	.LVL125:
 4022 1f0a 1F93      		push r17
 4023               	.LCFI43:
 4024               		.cfi_def_cfa_offset 3
 4025               		.cfi_offset 17, -2
 4026 1f0c CF93      		push r28
 4027               	.LCFI44:
 4028               		.cfi_def_cfa_offset 4
 4029               		.cfi_offset 28, -3
 4030 1f0e DF93      		push r29
 4031               	.LCFI45:
 4032               		.cfi_def_cfa_offset 5
 4033               		.cfi_offset 29, -4
 4034               	/* prologue: function */
 4035               	/* frame size = 0 */
 4036               	/* stack size = 3 */
 4037               	.L__stack_usage = 3
1960:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4038               		.loc 1 1960 0
 4039 1f10 282F      		mov r18,r24
 4040 1f12 30E0      		ldi r19,0
 4041 1f14 93E2      		ldi r25,lo8(35)
 4042 1f16 899F      		mul r24,r25
 4043 1f18 F001      		movw r30,r0
 4044 1f1a 1124      		clr __zero_reg__
 4045 1f1c E050      		subi r30,lo8(-(bankStates))
 4046 1f1e F040      		sbci r31,hi8(-(bankStates))
 4047 1f20 9581      		ldd r25,Z+5
 4048 1f22 9923      		tst r25
 4049 1f24 01F0      		breq .L231
1960:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4050               		.loc 1 1960 0 is_stmt 0 discriminator 1
 4051 1f26 9091 0000 		lds r25,sdIsrState
 4052 1f2a 9150      		subi r25,lo8(-(-1))
 4053 1f2c 9230      		cpi r25,lo8(2)
 4054 1f2e 00F0      		brlo .L230
 4055               	.L231:
1962:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4056               		.loc 1 1962 0 is_stmt 1
 4057 1f30 1FB7      		in r17,__SREG__
 4058               	.LVL126:
1963:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4059               		.loc 1 1963 0
 4060               	/* #APP */
 4061               	 ;  1963 "WTPA.c" 1
 4062 1f32 F894      		cli
 4063               	 ;  0 "" 2
1965:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 4064               		.loc 1 1965 0
 4065               	/* #NOAPP */
 4066 1f34 93E2      		ldi r25,lo8(35)
 4067 1f36 929F      		mul r25,r18
 4068 1f38 E001      		movw r28,r0
 4069 1f3a 939F      		mul r25,r19
 4070 1f3c D00D      		add r29,r0
 4071 1f3e 1124      		clr __zero_reg__
 4072 1f40 C050      		subi r28,lo8(-(bankStates))
 4073 1f42 D040      		sbci r29,hi8(-(bankStates))
 4074 1f44 94E0      		ldi r25,lo8(4)
 4075 1f46 9883      		st Y,r25
1966:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4076               		.loc 1 1966 0
 4077 1f48 0E94 0000 		call SetSampleClock
 4078               	.LVL127:
1968:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4079               		.loc 1 1968 0
 4080 1f4c 81E0      		ldi r24,lo8(1)
 4081 1f4e 8D83      		std Y+5,r24
1969:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4082               		.loc 1 1969 0
 4083 1f50 1FBF      		out __SREG__,r17
 4084               	.LVL128:
 4085               	.L230:
 4086               	/* epilogue start */
1971:WTPA.c        **** }
 4087               		.loc 1 1971 0
 4088 1f52 DF91      		pop r29
 4089 1f54 CF91      		pop r28
 4090 1f56 1F91      		pop r17
 4091 1f58 0895      		ret
 4092               		.cfi_endproc
 4093               	.LFE31:
 4096               	StartRecording:
 4097               	.LFB29:
1885:WTPA.c        **** {
 4098               		.loc 1 1885 0
 4099               		.cfi_startproc
 4100               	.LVL129:
 4101 1f5a FF92      		push r15
 4102               	.LCFI46:
 4103               		.cfi_def_cfa_offset 3
 4104               		.cfi_offset 15, -2
 4105 1f5c 0F93      		push r16
 4106               	.LCFI47:
 4107               		.cfi_def_cfa_offset 4
 4108               		.cfi_offset 16, -3
 4109 1f5e 1F93      		push r17
 4110               	.LCFI48:
 4111               		.cfi_def_cfa_offset 5
 4112               		.cfi_offset 17, -4
 4113 1f60 CF93      		push r28
 4114               	.LCFI49:
 4115               		.cfi_def_cfa_offset 6
 4116               		.cfi_offset 28, -5
 4117 1f62 DF93      		push r29
 4118               	.LCFI50:
 4119               		.cfi_def_cfa_offset 7
 4120               		.cfi_offset 29, -6
 4121               	/* prologue: function */
 4122               	/* frame size = 0 */
 4123               	/* stack size = 5 */
 4124               	.L__stack_usage = 5
1890:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4125               		.loc 1 1890 0
 4126 1f64 282F      		mov r18,r24
 4127 1f66 30E0      		ldi r19,0
 4128 1f68 93E2      		ldi r25,lo8(35)
 4129 1f6a 899F      		mul r24,r25
 4130 1f6c F001      		movw r30,r0
 4131 1f6e 1124      		clr __zero_reg__
 4132 1f70 E050      		subi r30,lo8(-(bankStates))
 4133 1f72 F040      		sbci r31,hi8(-(bankStates))
 4134 1f74 9581      		ldd r25,Z+5
 4135 1f76 9923      		tst r25
 4136 1f78 01F0      		breq .L237
1890:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4137               		.loc 1 1890 0 is_stmt 0 discriminator 1
 4138 1f7a 9091 0000 		lds r25,sdIsrState
 4139 1f7e 9150      		subi r25,lo8(-(-1))
 4140 1f80 9230      		cpi r25,lo8(2)
 4141 1f82 00F4      		brsh .+2
 4142 1f84 00C0      		rjmp .L236
 4143               	.L237:
1893:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4144               		.loc 1 1893 0 is_stmt 1
 4145 1f86 FFB6      		in r15,__SREG__
 4146               	.LVL130:
1894:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4147               		.loc 1 1894 0
 4148               	/* #APP */
 4149               	 ;  1894 "WTPA.c" 1
 4150 1f88 F894      		cli
 4151               	 ;  0 "" 2
1896:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
 4152               		.loc 1 1896 0
 4153               	/* #NOAPP */
 4154 1f8a 93E2      		ldi r25,lo8(35)
 4155 1f8c 929F      		mul r25,r18
 4156 1f8e E001      		movw r28,r0
 4157 1f90 939F      		mul r25,r19
 4158 1f92 D00D      		add r29,r0
 4159 1f94 1124      		clr __zero_reg__
 4160 1f96 C050      		subi r28,lo8(-(bankStates))
 4161 1f98 D040      		sbci r29,hi8(-(bankStates))
 4162 1f9a 93E0      		ldi r25,lo8(3)
 4163 1f9c 9883      		st Y,r25
1898:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
 4164               		.loc 1 1898 0
 4165 1f9e 0889      		ldd r16,Y+16
 4166 1fa0 1989      		ldd r17,Y+17
 4167 1fa2 2A89      		ldd r18,Y+18
 4168 1fa4 3B89      		ldd r19,Y+19
 4169 1fa6 0F8F      		std Y+31,r16
 4170 1fa8 18A3      		std Y+32,r17
 4171 1faa 29A3      		std Y+33,r18
 4172 1fac 3AA3      		std Y+34,r19
1899:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
 4173               		.loc 1 1899 0
 4174 1fae 0889      		ldd r16,Y+16
 4175 1fb0 1989      		ldd r17,Y+17
 4176 1fb2 2A89      		ldd r18,Y+18
 4177 1fb4 3B89      		ldd r19,Y+19
 4178 1fb6 0C87      		std Y+12,r16
 4179 1fb8 1D87      		std Y+13,r17
 4180 1fba 2E87      		std Y+14,r18
 4181 1fbc 3F87      		std Y+15,r19
1900:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
 4182               		.loc 1 1900 0
 4183 1fbe 0889      		ldd r16,Y+16
 4184 1fc0 1989      		ldd r17,Y+17
 4185 1fc2 2A89      		ldd r18,Y+18
 4186 1fc4 3B89      		ldd r19,Y+19
 4187 1fc6 088F      		std Y+24,r16
 4188 1fc8 198F      		std Y+25,r17
 4189 1fca 2A8F      		std Y+26,r18
 4190 1fcc 3B8F      		std Y+27,r19
1901:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
 4191               		.loc 1 1901 0
 4192 1fce 0889      		ldd r16,Y+16
 4193 1fd0 1989      		ldd r17,Y+17
 4194 1fd2 2A89      		ldd r18,Y+18
 4195 1fd4 3B89      		ldd r19,Y+19
 4196 1fd6 0C8B      		std Y+20,r16
 4197 1fd8 1D8B      		std Y+21,r17
 4198 1fda 2E8B      		std Y+22,r18
 4199 1fdc 3F8B      		std Y+23,r19
1902:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
 4200               		.loc 1 1902 0
 4201 1fde 1E8E      		std Y+30,__zero_reg__
1904:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
 4202               		.loc 1 1904 0
 4203 1fe0 1092 0000 		sts outOfRam,__zero_reg__
1906:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
 4204               		.loc 1 1906 0
 4205 1fe4 0E94 0000 		call SetSampleClock
 4206               	.LVL131:
1907:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4207               		.loc 1 1907 0
 4208 1fe8 81E0      		ldi r24,lo8(1)
 4209 1fea 8D83      		std Y+5,r24
1909:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4210               		.loc 1 1909 0
 4211 1fec FFBE      		out __SREG__,r15
1912:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4212               		.loc 1 1912 0
 4213 1fee 8091 7A00 		lds r24,122
 4214 1ff2 86FD      		sbrc r24,6
 4215 1ff4 00C0      		rjmp .L236
 4216               	.LBB52:
 4217               	.LBB53:
1914:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4218               		.loc 1 1914 0
 4219 1ff6 8091 7900 		lds r24,121
 4220 1ffa 8058      		subi r24,lo8(-(-128))
 4221 1ffc 8093 0000 		sts adcByte,r24
1915:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4222               		.loc 1 1915 0
 4223 2000 8091 7A00 		lds r24,122
 4224 2004 8064      		ori r24,lo8(64)
 4225 2006 8093 7A00 		sts 122,r24
 4226               	.LVL132:
 4227               	.L236:
 4228               	/* epilogue start */
 4229               	.LBE53:
 4230               	.LBE52:
1918:WTPA.c        **** }
 4231               		.loc 1 1918 0
 4232 200a DF91      		pop r29
 4233 200c CF91      		pop r28
 4234 200e 1F91      		pop r17
 4235 2010 0F91      		pop r16
 4236 2012 FF90      		pop r15
 4237 2014 0895      		ret
 4238               		.cfi_endproc
 4239               	.LFE29:
 4242               	StartOverdub:
 4243               	.LFB32:
1976:WTPA.c        **** {
 4244               		.loc 1 1976 0
 4245               		.cfi_startproc
 4246               	.LVL133:
 4247 2016 1F93      		push r17
 4248               	.LCFI51:
 4249               		.cfi_def_cfa_offset 3
 4250               		.cfi_offset 17, -2
 4251 2018 CF93      		push r28
 4252               	.LCFI52:
 4253               		.cfi_def_cfa_offset 4
 4254               		.cfi_offset 28, -3
 4255 201a DF93      		push r29
 4256               	.LCFI53:
 4257               		.cfi_def_cfa_offset 5
 4258               		.cfi_offset 29, -4
 4259               	/* prologue: function */
 4260               	/* frame size = 0 */
 4261               	/* stack size = 3 */
 4262               	.L__stack_usage = 3
1980:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4263               		.loc 1 1980 0
 4264 201c 282F      		mov r18,r24
 4265 201e 30E0      		ldi r19,0
 4266 2020 93E2      		ldi r25,lo8(35)
 4267 2022 899F      		mul r24,r25
 4268 2024 F001      		movw r30,r0
 4269 2026 1124      		clr __zero_reg__
 4270 2028 E050      		subi r30,lo8(-(bankStates))
 4271 202a F040      		sbci r31,hi8(-(bankStates))
 4272 202c 9581      		ldd r25,Z+5
 4273 202e 9923      		tst r25
 4274 2030 01F0      		breq .L244
1980:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 4275               		.loc 1 1980 0 is_stmt 0 discriminator 1
 4276 2032 9091 0000 		lds r25,sdIsrState
 4277 2036 9150      		subi r25,lo8(-(-1))
 4278 2038 9230      		cpi r25,lo8(2)
 4279 203a 00F0      		brlo .L243
 4280               	.L244:
1982:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 4281               		.loc 1 1982 0 is_stmt 1
 4282 203c 1FB7      		in r17,__SREG__
 4283               	.LVL134:
1983:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 4284               		.loc 1 1983 0
 4285               	/* #APP */
 4286               	 ;  1983 "WTPA.c" 1
 4287 203e F894      		cli
 4288               	 ;  0 "" 2
1985:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
 4289               		.loc 1 1985 0
 4290               	/* #NOAPP */
 4291 2040 93E2      		ldi r25,lo8(35)
 4292 2042 929F      		mul r25,r18
 4293 2044 E001      		movw r28,r0
 4294 2046 939F      		mul r25,r19
 4295 2048 D00D      		add r29,r0
 4296 204a 1124      		clr __zero_reg__
 4297 204c C050      		subi r28,lo8(-(bankStates))
 4298 204e D040      		sbci r29,hi8(-(bankStates))
 4299 2050 95E0      		ldi r25,lo8(5)
 4300 2052 9883      		st Y,r25
1986:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
 4301               		.loc 1 1986 0
 4302 2054 0E94 0000 		call SetSampleClock
 4303               	.LVL135:
1988:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 4304               		.loc 1 1988 0
 4305 2058 81E0      		ldi r24,lo8(1)
 4306 205a 8D83      		std Y+5,r24
1989:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 4307               		.loc 1 1989 0
 4308 205c 1FBF      		out __SREG__,r17
1992:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 4309               		.loc 1 1992 0
 4310 205e 8091 7A00 		lds r24,122
 4311 2062 86FD      		sbrc r24,6
 4312 2064 00C0      		rjmp .L243
 4313               	.LBB56:
 4314               	.LBB57:
1994:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 4315               		.loc 1 1994 0
 4316 2066 8091 7900 		lds r24,121
 4317 206a 8058      		subi r24,lo8(-(-128))
 4318 206c 8093 0000 		sts adcByte,r24
1995:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4319               		.loc 1 1995 0
 4320 2070 8091 7A00 		lds r24,122
 4321 2074 8064      		ori r24,lo8(64)
 4322 2076 8093 7A00 		sts 122,r24
 4323               	.LVL136:
 4324               	.L243:
 4325               	/* epilogue start */
 4326               	.LBE57:
 4327               	.LBE56:
1998:WTPA.c        **** }
 4328               		.loc 1 1998 0
 4329 207a DF91      		pop r29
 4330 207c CF91      		pop r28
 4331 207e 1F91      		pop r17
 4332 2080 0895      		ret
 4333               		.cfi_endproc
 4334               	.LFE32:
 4337               	StartRealtime:
 4338               	.LFB33:
2004:WTPA.c        **** {
 4339               		.loc 1 2004 0
 4340               		.cfi_startproc
 4341               	.LVL137:
 4342 2082 CF93      		push r28
 4343               	.LCFI54:
 4344               		.cfi_def_cfa_offset 3
 4345               		.cfi_offset 28, -2
 4346               	/* prologue: function */
 4347               	/* frame size = 0 */
 4348               	/* stack size = 1 */
 4349               	.L__stack_usage = 1
2008:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 4350               		.loc 1 2008 0
 4351 2084 CFB7      		in r28,__SREG__
 4352               	.LVL138:
2009:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 4353               		.loc 1 2009 0
 4354               	/* #APP */
 4355               	 ;  2009 "WTPA.c" 1
 4356 2086 F894      		cli
 4357               	 ;  0 "" 2
2011:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 4358               		.loc 1 2011 0
 4359               	/* #NOAPP */
 4360 2088 93E2      		ldi r25,lo8(35)
 4361 208a 899F      		mul r24,r25
 4362 208c F001      		movw r30,r0
 4363 208e 1124      		clr __zero_reg__
 4364 2090 E050      		subi r30,lo8(-(bankStates))
 4365 2092 F040      		sbci r31,hi8(-(bankStates))
 4366 2094 92E0      		ldi r25,lo8(2)
 4367 2096 9083      		st Z,r25
2012:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
 4368               		.loc 1 2012 0
 4369 2098 0E94 0000 		call SetSampleClock
 4370               	.LVL139:
2014:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 4371               		.loc 1 2014 0
 4372 209c CFBF      		out __SREG__,r28
2016:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 4373               		.loc 1 2016 0
 4374 209e 8091 7A00 		lds r24,122
 4375 20a2 86FD      		sbrc r24,6
 4376 20a4 00C0      		rjmp .L250
 4377               	.LBB60:
 4378               	.LBB61:
2018:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 4379               		.loc 1 2018 0
 4380 20a6 8091 7900 		lds r24,121
 4381 20aa 8058      		subi r24,lo8(-(-128))
 4382 20ac 8093 0000 		sts adcByte,r24
2019:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 4383               		.loc 1 2019 0
 4384 20b0 8091 7A00 		lds r24,122
 4385 20b4 8064      		ori r24,lo8(64)
 4386 20b6 8093 7A00 		sts 122,r24
 4387               	.L250:
 4388               	/* epilogue start */
 4389               	.LBE61:
 4390               	.LBE60:
2021:WTPA.c        **** }
 4391               		.loc 1 2021 0
 4392 20ba CF91      		pop r28
 4393               	.LVL140:
 4394 20bc 0895      		ret
 4395               		.cfi_endproc
 4396               	.LFE33:
 4399               	DoFormatCard:
 4400               	.LFB39:
2236:WTPA.c        **** {
 4401               		.loc 1 2236 0
 4402               		.cfi_startproc
 4403               	/* prologue: function */
 4404               	/* frame size = 0 */
 4405               	/* stack size = 0 */
 4406               	.L__stack_usage = 0
2237:WTPA.c        **** 	if(subState==SS_0)
 4407               		.loc 1 2237 0
 4408 20be 8091 0000 		lds r24,subState
 4409 20c2 8111      		cpse r24,__zero_reg__
 4410 20c4 00C0      		rjmp .L253
2239:WTPA.c        **** 		KillLeds();		// Turn off LEDs
 4411               		.loc 1 2239 0
 4412 20c6 0E94 0000 		call KillLeds
 4413               	.LVL141:
2241:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
 4414               		.loc 1 2241 0
 4415 20ca 1092 0000 		sts bankStates,__zero_reg__
2242:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
 4416               		.loc 1 2242 0
 4417 20ce 1092 0000 		sts bankStates+9,__zero_reg__
2243:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 4418               		.loc 1 2243 0
 4419 20d2 1092 0000 		sts bankStates+35,__zero_reg__
2244:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
 4420               		.loc 1 2244 0
 4421 20d6 1092 0000 		sts bankStates+44,__zero_reg__
2246:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
 4422               		.loc 1 2246 0
 4423 20da 81E8      		ldi r24,lo8(-127)
 4424 20dc 90E0      		ldi r25,0
 4425 20de 0E94 0000 		call BlinkLeds
 4426               	.LVL142:
2247:WTPA.c        **** 		subState=SS_1;
 4427               		.loc 1 2247 0
 4428 20e2 81E0      		ldi r24,lo8(1)
 4429 20e4 00C0      		rjmp .L269
 4430               	.L253:
2249:WTPA.c        **** 	else if(subState==SS_1)
 4431               		.loc 1 2249 0
 4432 20e6 8130      		cpi r24,lo8(1)
 4433 20e8 01F4      		brne .L255
2251:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4434               		.loc 1 2251 0
 4435 20ea 8091 0000 		lds r24,keyState
 4436 20ee 80FF      		sbrs r24,0
 4437 20f0 00C0      		rjmp .L256
2251:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 4438               		.loc 1 2251 0 is_stmt 0 discriminator 1
 4439 20f2 87FF      		sbrs r24,7
 4440 20f4 00C0      		rjmp .L256
2253:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
 4441               		.loc 1 2253 0 is_stmt 1
 4442 20f6 86E0      		ldi r24,lo8(6)
 4443 20f8 8093 0000 		sts cardState,r24
2254:WTPA.c        **** 			KillLeds();
 4444               		.loc 1 2254 0
 4445 20fc 0E94 0000 		call KillLeds
 4446               	.LVL143:
2255:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
 4447               		.loc 1 2255 0
 4448 2100 8091 0000 		lds r24,ledOnOffMask
 4449 2104 8168      		ori r24,lo8(-127)
 4450 2106 8093 0000 		sts ledOnOffMask,r24
2256:WTPA.c        **** 			subState=SS_2;
 4451               		.loc 1 2256 0
 4452 210a 82E0      		ldi r24,lo8(2)
 4453               	.L269:
 4454 210c 8093 0000 		sts subState,r24
 4455 2110 0895      		ret
 4456               	.L256:
2258:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
 4457               		.loc 1 2258 0
 4458 2112 8091 0000 		lds r24,cardState
 4459 2116 8111      		cpse r24,__zero_reg__
 4460 2118 00C0      		rjmp .L252
 4461               	.LVL144:
 4462 211a 00C0      		rjmp .L259
 4463               	.LVL145:
 4464               	.L255:
2263:WTPA.c        **** 	else if(subState==SS_2)
 4465               		.loc 1 2263 0
 4466 211c 8230      		cpi r24,lo8(2)
 4467 211e 01F4      		brne .L252
2265:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
 4468               		.loc 1 2265 0
 4469 2120 8091 0000 		lds r24,cardState
 4470 2124 8E30      		cpi r24,lo8(14)
 4471 2126 01F4      		brne .L252
 4472               	.LBB70:
 4473               	.LBB71:
2267:WTPA.c        **** 			KillLeds();
 4474               		.loc 1 2267 0
 4475 2128 0E94 0000 		call KillLeds
 4476               	.LVL146:
2268:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
 4477               		.loc 1 2268 0
 4478 212c 8091 0000 		lds r24,ledOnOffMask
 4479 2130 8260      		ori r24,lo8(2)
 4480 2132 8093 0000 		sts ledOnOffMask,r24
2269:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
 4481               		.loc 1 2269 0
 4482 2136 8091 0000 		lds r24,cardState
 4483 213a 8823      		tst r24
 4484 213c 01F0      		breq .L259
 4485 213e 8091 0000 		lds r24,newKeys
 4486 2142 8823      		tst r24
 4487 2144 01F0      		breq .L252
 4488               	.L259:
 4489               	.LVL147:
 4490               	.LBB72:
 4491               	.LBB73:
1447:WTPA.c        **** 	State=newState;
 4492               		.loc 1 1447 0
 4493 2146 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 4494 2148 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 4495 214a 9093 0000 		sts State+1,r25
 4496 214e 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 4497               		.loc 1 1448 0
 4498 2152 1092 0000 		sts subState,__zero_reg__
 4499               	.LVL148:
 4500               	.L252:
 4501 2156 0895      		ret
 4502               	.LBE73:
 4503               	.LBE72:
 4504               	.LBE71:
 4505               	.LBE70:
 4506               		.cfi_endproc
 4507               	.LFE39:
 4510               	DoStartupSelect:
 4511               	.LFB70:
4620:WTPA.c        **** {
 4512               		.loc 1 4620 0
 4513               		.cfi_startproc
 4514               	/* prologue: function */
 4515               	/* frame size = 0 */
 4516               	/* stack size = 0 */
 4517               	.L__stack_usage = 0
4621:WTPA.c        **** 	if(subState==SS_0)
 4518               		.loc 1 4621 0
 4519 2158 8091 0000 		lds r24,subState
 4520 215c 8111      		cpse r24,__zero_reg__
 4521 215e 00C0      		rjmp .L271
4623:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
 4522               		.loc 1 4623 0
 4523 2160 68E9      		ldi r22,lo8(-104)
 4524 2162 70E0      		ldi r23,0
 4525 2164 0E94 0000 		call SetTimer
 4526               	.LVL149:
4624:WTPA.c        **** 		subState=SS_1;
 4527               		.loc 1 4624 0
 4528 2168 81E0      		ldi r24,lo8(1)
 4529 216a 8093 0000 		sts subState,r24
 4530 216e 0895      		ret
 4531               	.L271:
4628:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4532               		.loc 1 4628 0
 4533 2170 80E0      		ldi r24,0
 4534 2172 0E94 0000 		call CheckTimer
 4535               	.LVL150:
 4536 2176 8823      		tst r24
 4537 2178 01F0      		breq .L270
 4538               	.LBB82:
 4539               	.LBB83:
4630:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
 4540               		.loc 1 4630 0
 4541 217a 8091 0000 		lds r24,keyState
 4542 217e 80FF      		sbrs r24,0
 4543 2180 00C0      		rjmp .L273
 4544               	.LVL151:
 4545               	.LBB84:
 4546               	.LBB85:
1447:WTPA.c        **** 	State=newState;
 4547               		.loc 1 1447 0
 4548 2182 80E0      		ldi r24,lo8(gs(DoSawtooth))
 4549 2184 90E0      		ldi r25,hi8(gs(DoSawtooth))
 4550 2186 00C0      		rjmp .L278
 4551               	.LVL152:
 4552               	.L273:
 4553               	.LBE85:
 4554               	.LBE84:
4634:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
 4555               		.loc 1 4634 0
 4556 2188 85FF      		sbrs r24,5
 4557 218a 00C0      		rjmp .L274
 4558               	.LVL153:
 4559               	.LBB86:
 4560               	.LBB87:
1447:WTPA.c        **** 	State=newState;
 4561               		.loc 1 1447 0
 4562 218c 80E0      		ldi r24,lo8(gs(SetMidiChannels))
 4563 218e 90E0      		ldi r25,hi8(gs(SetMidiChannels))
 4564 2190 00C0      		rjmp .L278
 4565               	.LVL154:
 4566               	.L274:
 4567               	.LBE87:
 4568               	.LBE86:
 4569               	.LBB88:
 4570               	.LBB89:
 4571 2192 80E0      		ldi r24,lo8(gs(DoSampler))
 4572 2194 90E0      		ldi r25,hi8(gs(DoSampler))
 4573               	.LVL155:
 4574               	.L278:
 4575 2196 9093 0000 		sts State+1,r25
 4576 219a 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 4577               		.loc 1 1448 0
 4578 219e 1092 0000 		sts subState,__zero_reg__
 4579               	.L270:
 4580 21a2 0895      		ret
 4581               	.LBE89:
 4582               	.LBE88:
 4583               	.LBE83:
 4584               	.LBE82:
 4585               		.cfi_endproc
 4586               	.LFE70:
 4589               	PlaySampleFromSd:
 4590               	.LFB50:
3122:WTPA.c        **** {
 4591               		.loc 1 3122 0
 4592               		.cfi_startproc
 4593               	.LVL156:
 4594 21a4 CF93      		push r28
 4595               	.LCFI55:
 4596               		.cfi_def_cfa_offset 3
 4597               		.cfi_offset 28, -2
 4598               	/* prologue: function */
 4599               	/* frame size = 0 */
 4600               	/* stack size = 1 */
 4601               	.L__stack_usage = 1
3126:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 4602               		.loc 1 3126 0
 4603 21a6 2091 0000 		lds r18,cardState
 4604 21aa 2E30      		cpi r18,lo8(14)
 4605 21ac 01F4      		brne .L280
 4606 21ae 00C0      		rjmp .L288
 4607               	.L280:
3137:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
 4608               		.loc 1 3137 0
 4609 21b0 3091 0000 		lds r19,sdIsrState
 4610 21b4 3330      		cpi r19,lo8(3)
 4611 21b6 01F4      		brne .L279
3140:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
 4612               		.loc 1 3140 0
 4613 21b8 2B30      		cpi r18,lo8(11)
 4614 21ba 01F4      		brne .L282
 4615               	.L288:
 4616               	.LVL157:
 4617               	.LBB92:
 4618               	.LBB93:
3142:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
 4619               		.loc 1 3142 0
 4620 21bc CFB7      		in r28,__SREG__
 4621               	.LVL158:
3143:WTPA.c        **** 			cli();
 4622               		.loc 1 3143 0
 4623               	/* #APP */
 4624               	 ;  3143 "WTPA.c" 1
 4625 21be F894      		cli
 4626               	 ;  0 "" 2
3145:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
 4627               		.loc 1 3145 0
 4628               	/* #NOAPP */
 4629 21c0 0E94 0000 		call SdStartSampleRead
 4630               	.LVL159:
3146:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
 4631               		.loc 1 3146 0
 4632 21c4 81E0      		ldi r24,lo8(1)
 4633 21c6 90E0      		ldi r25,0
 4634 21c8 A0E0      		ldi r26,0
 4635 21ca B0E0      		ldi r27,0
 4636 21cc 8093 0000 		sts sdRamSampleRemaining,r24
 4637 21d0 9093 0000 		sts sdRamSampleRemaining+1,r25
 4638 21d4 A093 0000 		sts sdRamSampleRemaining+2,r26
 4639 21d8 B093 0000 		sts sdRamSampleRemaining+3,r27
3147:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
 4640               		.loc 1 3147 0
 4641 21dc 0E94 0000 		call SdIsrStartStreamingAudio
 4642               	.LVL160:
3149:WTPA.c        **** 			SREG=sreg;	// resume isr
 4643               		.loc 1 3149 0
 4644 21e0 CFBF      		out __SREG__,r28
 4645 21e2 00C0      		rjmp .L279
 4646               	.LVL161:
 4647               	.L282:
 4648               	.LBE93:
 4649               	.LBE92:
3151:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4650               		.loc 1 3151 0
 4651 21e4 2D30      		cpi r18,lo8(13)
 4652 21e6 01F0      		breq .L283
3151:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4653               		.loc 1 3151 0 is_stmt 0 discriminator 1
 4654 21e8 2091 0000 		lds r18,sdAbortRead
 4655 21ec 2130      		cpi r18,lo8(1)
 4656 21ee 01F4      		brne .L284
 4657               	.L283:
3154:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4658               		.loc 1 3154 0 is_stmt 1
 4659 21f0 9093 0000 		sts sdQueuedSlot+1,r25
 4660 21f4 8093 0000 		sts sdQueuedSlot,r24
 4661 21f8 00C0      		rjmp .L279
 4662               	.L284:
3159:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4663               		.loc 1 3159 0
 4664 21fa 9093 0000 		sts sdQueuedSlot+1,r25
 4665 21fe 8093 0000 		sts sdQueuedSlot,r24
3160:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
 4666               		.loc 1 3160 0
 4667 2202 81E0      		ldi r24,lo8(1)
 4668               	.LVL162:
 4669 2204 8093 0000 		sts sdPlaybackQueued,r24
3161:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
 4670               		.loc 1 3161 0
 4671 2208 8093 0000 		sts sdAbortRead,r24
3163:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
 4672               		.loc 1 3163 0
 4673 220c 9FB7      		in r25,__SREG__
 4674               	.LVL163:
3164:WTPA.c        **** 			cli();
 4675               		.loc 1 3164 0
 4676               	/* #APP */
 4677               	 ;  3164 "WTPA.c" 1
 4678 220e F894      		cli
 4679               	 ;  0 "" 2
3165:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
 4680               		.loc 1 3165 0
 4681               	/* #NOAPP */
 4682 2210 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 4683 2214 1092 0000 		sts sdBytesInFifo,__zero_reg__
3166:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
 4684               		.loc 1 3166 0
 4685 2218 8091 7000 		lds r24,112
 4686 221c 8B7F      		andi r24,lo8(-5)
 4687 221e 8093 7000 		sts 112,r24
3167:WTPA.c        **** 			SREG=sreg;
 4688               		.loc 1 3167 0
 4689 2222 9FBF      		out __SREG__,r25
 4690               	.LVL164:
 4691               	.L279:
 4692               	/* epilogue start */
3170:WTPA.c        **** }
 4693               		.loc 1 3170 0
 4694 2224 CF91      		pop r28
 4695 2226 0895      		ret
 4696               		.cfi_endproc
 4697               	.LFE50:
 4700               	DoSawtooth:
 4701               	.LFB68:
4469:WTPA.c        **** {
 4702               		.loc 1 4469 0
 4703               		.cfi_startproc
 4704               	/* prologue: function */
 4705               	/* frame size = 0 */
 4706               	/* stack size = 0 */
 4707               	.L__stack_usage = 0
4473:WTPA.c        **** 	if(subState==SS_0)
 4708               		.loc 1 4473 0
 4709 2228 8091 0000 		lds r24,subState
 4710 222c 8111      		cpse r24,__zero_reg__
 4711 222e 00C0      		rjmp .L290
4475:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
 4712               		.loc 1 4475 0
 4713 2230 0E94 0000 		call KillLeds
 4714               	.LVL165:
4476:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
 4715               		.loc 1 4476 0
 4716 2234 80EC      		ldi r24,lo8(-64)
 4717 2236 90E0      		ldi r25,0
 4718 2238 0E94 0000 		call BlinkLeds
 4719               	.LVL166:
4477:WTPA.c        **** 		subState=SS_1;
 4720               		.loc 1 4477 0
 4721 223c 81E0      		ldi r24,lo8(1)
 4722 223e 00C0      		rjmp .L324
 4723               	.L290:
4479:WTPA.c        **** 	else if(subState==SS_1)
 4724               		.loc 1 4479 0
 4725 2240 8130      		cpi r24,lo8(1)
 4726 2242 01F4      		brne .L292
4481:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 4727               		.loc 1 4481 0
 4728               	/* #APP */
 4729               	 ;  4481 "WTPA.c" 1
 4730 2244 F894      		cli
 4731               	 ;  0 "" 2
4482:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
 4732               		.loc 1 4482 0
 4733               	/* #NOAPP */
 4734 2246 8093 0000 		sts bankStates,r24
4483:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
 4735               		.loc 1 4483 0
 4736 224a 8093 0000 		sts bankStates+9,r24
 4737               	.LVL167:
 4738               	.LBB104:
 4739               	.LBB105:
1842:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 4740               		.loc 1 1842 0
 4741 224e 8093 0000 		sts bankStates+9,r24
 4742 2252 0E94 0000 		call SetSampleClock.part.0
 4743               	.LVL168:
 4744               	.LBE105:
 4745               	.LBE104:
4485:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 4746               		.loc 1 4485 0
 4747 2256 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 4748 2258 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 4749 225a 9093 0000 		sts UpdateOutput+1,r25
 4750 225e 8093 0000 		sts UpdateOutput,r24
4486:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 4751               		.loc 1 4486 0
 4752               	/* #APP */
 4753               	 ;  4486 "WTPA.c" 1
 4754 2262 7894      		sei
 4755               	 ;  0 "" 2
4488:WTPA.c        **** 		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the 
 4756               		.loc 1 4488 0
 4757               	/* #NOAPP */
 4758 2264 8091 0000 		lds r24,encoderValue
 4759 2268 8093 0000 		sts lastShuttleRead.2242,r24
4490:WTPA.c        **** 		subState=SS_2;					// And wait forever.
 4760               		.loc 1 4490 0
 4761 226c 82E0      		ldi r24,lo8(2)
 4762               	.LVL169:
 4763               	.L324:
 4764 226e 8093 0000 		sts subState,r24
 4765 2272 0895      		ret
 4766               	.L292:
4492:WTPA.c        **** 	else if(subState==SS_2)
 4767               		.loc 1 4492 0
 4768 2274 8230      		cpi r24,lo8(2)
 4769 2276 01F0      		breq .+2
 4770 2278 00C0      		rjmp .L289
 4771               	.LBB106:
 4772               	.LBB107:
4495:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 4773               		.loc 1 4495 0
 4774 227a 8091 0000 		lds r24,newKeys
 4775 227e 80FF      		sbrs r24,0
 4776 2280 00C0      		rjmp .L294
4497:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
 4777               		.loc 1 4497 0
 4778 2282 9091 0000 		lds r25,ledOnOffMask
 4779 2286 21E0      		ldi r18,lo8(1)
 4780 2288 9227      		eor r25,r18
 4781 228a 9093 0000 		sts ledOnOffMask,r25
 4782               	.L294:
4499:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 4783               		.loc 1 4499 0
 4784 228e 81FF      		sbrs r24,1
 4785 2290 00C0      		rjmp .L295
4501:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
 4786               		.loc 1 4501 0
 4787 2292 9091 0000 		lds r25,ledOnOffMask
 4788 2296 22E0      		ldi r18,lo8(2)
 4789 2298 9227      		eor r25,r18
 4790 229a 9093 0000 		sts ledOnOffMask,r25
 4791               	.L295:
4503:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
 4792               		.loc 1 4503 0
 4793 229e 82FF      		sbrs r24,2
 4794 22a0 00C0      		rjmp .L296
4505:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
 4795               		.loc 1 4505 0
 4796 22a2 9091 0000 		lds r25,ledOnOffMask
 4797 22a6 24E0      		ldi r18,lo8(4)
 4798 22a8 9227      		eor r25,r18
 4799 22aa 9093 0000 		sts ledOnOffMask,r25
 4800               	.L296:
4507:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
 4801               		.loc 1 4507 0
 4802 22ae 83FF      		sbrs r24,3
 4803 22b0 00C0      		rjmp .L297
4509:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
 4804               		.loc 1 4509 0
 4805 22b2 9091 0000 		lds r25,ledOnOffMask
 4806 22b6 28E0      		ldi r18,lo8(8)
 4807 22b8 9227      		eor r25,r18
 4808 22ba 9093 0000 		sts ledOnOffMask,r25
 4809               	.L297:
4511:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
 4810               		.loc 1 4511 0
 4811 22be 84FF      		sbrs r24,4
 4812 22c0 00C0      		rjmp .L298
4513:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
 4813               		.loc 1 4513 0
 4814 22c2 9091 0000 		lds r25,ledOnOffMask
 4815 22c6 20E1      		ldi r18,lo8(16)
 4816 22c8 9227      		eor r25,r18
 4817 22ca 9093 0000 		sts ledOnOffMask,r25
 4818               	.L298:
4515:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
 4819               		.loc 1 4515 0
 4820 22ce 85FF      		sbrs r24,5
 4821 22d0 00C0      		rjmp .L299
4517:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
 4822               		.loc 1 4517 0
 4823 22d2 9091 0000 		lds r25,ledOnOffMask
 4824 22d6 20E2      		ldi r18,lo8(32)
 4825 22d8 9227      		eor r25,r18
 4826 22da 9093 0000 		sts ledOnOffMask,r25
 4827               	.L299:
4520:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
 4828               		.loc 1 4520 0
 4829 22de 86FF      		sbrs r24,6
 4830 22e0 00C0      		rjmp .L300
 4831               	.LBB108:
 4832               	.LBB109:
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4833               		.loc 1 1520 0
 4834 22e2 80E0      		ldi r24,0
 4835 22e4 90E0      		ldi r25,0
 4836 22e6 0E94 0000 		call BlinkLeds
 4837               	.LVL170:
 4838               	.LBE109:
 4839               	.LBE108:
4523:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
 4840               		.loc 1 4523 0
 4841 22ea 8091 0000 		lds r24,ledOnOffMask
 4842 22ee 90E4      		ldi r25,lo8(64)
 4843 22f0 8927      		eor r24,r25
 4844 22f2 8093 0000 		sts ledOnOffMask,r24
 4845               	.L300:
4525:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
 4846               		.loc 1 4525 0
 4847 22f6 8091 0000 		lds r24,newKeys
 4848 22fa 87FF      		sbrs r24,7
 4849 22fc 00C0      		rjmp .L301
 4850               	.LBB110:
 4851               	.LBB111:
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4852               		.loc 1 1520 0
 4853 22fe 80E0      		ldi r24,0
 4854 2300 90E0      		ldi r25,0
 4855 2302 0E94 0000 		call BlinkLeds
 4856               	.LVL171:
 4857               	.LBE111:
 4858               	.LBE110:
4528:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
 4859               		.loc 1 4528 0
 4860 2306 8091 0000 		lds r24,ledOnOffMask
 4861 230a 8058      		subi r24,lo8(-(-128))
 4862 230c 8093 0000 		sts ledOnOffMask,r24
 4863               	.L301:
4530:WTPA.c        **** 		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new v
 4864               		.loc 1 4530 0
 4865 2310 9091 0000 		lds r25,lastShuttleRead.2242
 4866 2314 8091 0000 		lds r24,encoderValue
 4867 2318 9817      		cp r25,r24
 4868 231a 01F0      		breq .L289
 4869               	.LBB112:
 4870               	.LBB113:
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 4871               		.loc 1 1520 0
 4872 231c 80E0      		ldi r24,0
 4873 231e 90E0      		ldi r25,0
 4874 2320 0E94 0000 		call BlinkLeds
 4875               	.LVL172:
 4876               	.LBE113:
 4877               	.LBE112:
4533:WTPA.c        **** 			ledOnOffMask=encoderValue;
 4878               		.loc 1 4533 0
 4879 2324 8091 0000 		lds r24,encoderValue
 4880 2328 8093 0000 		sts ledOnOffMask,r24
4534:WTPA.c        **** 			lastShuttleRead=encoderValue;
 4881               		.loc 1 4534 0
 4882 232c 8093 0000 		sts lastShuttleRead.2242,r24
 4883               	.L289:
 4884 2330 0895      		ret
 4885               	.LBE107:
 4886               	.LBE106:
 4887               		.cfi_endproc
 4888               	.LFE68:
 4891               	SetMidiChannels:
 4892               	.LFB69:
4576:WTPA.c        **** {
 4893               		.loc 1 4576 0
 4894               		.cfi_startproc
 4895               	/* prologue: function */
 4896               	/* frame size = 0 */
 4897               	/* stack size = 0 */
 4898               	.L__stack_usage = 0
4577:WTPA.c        **** 	if(subState==SS_0)
 4899               		.loc 1 4577 0
 4900 2332 8091 0000 		lds r24,subState
 4901 2336 8111      		cpse r24,__zero_reg__
 4902 2338 00C0      		rjmp .L326
 4903               	.LVL173:
 4904               	.LBB124:
 4905               	.LBB125:
3375:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 4906               		.loc 1 3375 0
 4907 233a 84E0      		ldi r24,lo8(4)
 4908 233c 0E94 0000 		call EepromRead
 4909               	.LVL174:
3382:WTPA.c        **** 	if(x<16)					// Legit number?
 4910               		.loc 1 3382 0
 4911 2340 8031      		cpi r24,lo8(16)
 4912 2342 00F0      		brlo .L327
3396:WTPA.c        **** 		return(x);
 4913               		.loc 1 3396 0
 4914 2344 80E0      		ldi r24,0
 4915               	.LVL175:
 4916               	.L327:
 4917               	.LBE125:
 4918               	.LBE124:
4579:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
 4919               		.loc 1 4579 0
 4920 2346 8093 0000 		sts midiChannelNumberA,r24
 4921               	.LVL176:
 4922               	.LBB126:
 4923               	.LBB127:
3379:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 4924               		.loc 1 3379 0
 4925 234a 88E0      		ldi r24,lo8(8)
 4926 234c 0E94 0000 		call EepromRead
 4927               	.LVL177:
3382:WTPA.c        **** 	if(x<16)					// Legit number?
 4928               		.loc 1 3382 0
 4929 2350 8031      		cpi r24,lo8(16)
 4930 2352 00F0      		brlo .L328
3396:WTPA.c        **** 		return(x);
 4931               		.loc 1 3396 0
 4932 2354 81E0      		ldi r24,lo8(1)
 4933               	.LVL178:
 4934               	.L328:
 4935               	.LBE127:
 4936               	.LBE126:
4580:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
 4937               		.loc 1 4580 0
 4938 2356 8093 0000 		sts midiChannelNumberB,r24
4581:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
 4939               		.loc 1 4581 0
 4940 235a 20E1      		ldi r18,lo8(16)
 4941 235c 829F      		mul r24,r18
 4942 235e C001      		movw r24,r0
 4943 2360 1124      		clr __zero_reg__
 4944 2362 9091 0000 		lds r25,midiChannelNumberA
 4945 2366 982B      		or r25,r24
 4946 2368 9093 0000 		sts ledOnOffMask,r25
4582:WTPA.c        **** 		subState=SS_1;
 4947               		.loc 1 4582 0
 4948 236c 81E0      		ldi r24,lo8(1)
 4949 236e 8093 0000 		sts subState,r24
 4950 2372 0895      		ret
 4951               	.LVL179:
 4952               	.L326:
4586:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 4953               		.loc 1 4586 0
 4954 2374 2091 0000 		lds r18,newKeys
 4955 2378 20FF      		sbrs r18,0
 4956 237a 00C0      		rjmp .L330
4588:WTPA.c        **** 			midiChannelNumberA++;
 4957               		.loc 1 4588 0
 4958 237c 8091 0000 		lds r24,midiChannelNumberA
 4959               	.LVL180:
 4960 2380 8F5F      		subi r24,lo8(-(1))
 4961               	.LVL181:
4589:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
 4962               		.loc 1 4589 0
 4963 2382 8031      		cpi r24,lo8(16)
 4964               	.LVL182:
 4965 2384 00F4      		brsh .L331
4588:WTPA.c        **** 			midiChannelNumberA++;
 4966               		.loc 1 4588 0
 4967 2386 8093 0000 		sts midiChannelNumberA,r24
 4968 238a 00C0      		rjmp .L332
 4969               	.L331:
4591:WTPA.c        **** 				midiChannelNumberA=0;
 4970               		.loc 1 4591 0
 4971 238c 1092 0000 		sts midiChannelNumberA,__zero_reg__
 4972               	.L332:
4594:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
 4973               		.loc 1 4594 0
 4974 2390 8091 0000 		lds r24,ledOnOffMask
 4975               	.LVL183:
 4976 2394 807F      		andi r24,lo8(-16)
4595:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
 4977               		.loc 1 4595 0
 4978 2396 9091 0000 		lds r25,midiChannelNumberA
 4979 239a 892B      		or r24,r25
 4980 239c 8093 0000 		sts ledOnOffMask,r24
 4981               	.L330:
4597:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 4982               		.loc 1 4597 0
 4983 23a0 21FF      		sbrs r18,1
 4984 23a2 00C0      		rjmp .L333
4599:WTPA.c        **** 			midiChannelNumberB++;
 4985               		.loc 1 4599 0
 4986 23a4 8091 0000 		lds r24,midiChannelNumberB
 4987               	.LVL184:
 4988 23a8 8F5F      		subi r24,lo8(-(1))
 4989               	.LVL185:
4600:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
 4990               		.loc 1 4600 0
 4991 23aa 8031      		cpi r24,lo8(16)
 4992               	.LVL186:
 4993 23ac 00F4      		brsh .L334
4599:WTPA.c        **** 			midiChannelNumberB++;
 4994               		.loc 1 4599 0
 4995 23ae 8093 0000 		sts midiChannelNumberB,r24
 4996 23b2 00C0      		rjmp .L335
 4997               	.L334:
4602:WTPA.c        **** 				midiChannelNumberB=0;
 4998               		.loc 1 4602 0
 4999 23b4 1092 0000 		sts midiChannelNumberB,__zero_reg__
 5000               	.L335:
4606:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 5001               		.loc 1 4606 0
 5002 23b8 8091 0000 		lds r24,midiChannelNumberB
 5003               	.LVL187:
 5004 23bc 30E1      		ldi r19,lo8(16)
 5005 23be 839F      		mul r24,r19
 5006 23c0 C001      		movw r24,r0
 5007 23c2 1124      		clr __zero_reg__
4605:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
 5008               		.loc 1 4605 0
 5009 23c4 9091 0000 		lds r25,ledOnOffMask
 5010 23c8 9F70      		andi r25,lo8(15)
4606:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 5011               		.loc 1 4606 0
 5012 23ca 982B      		or r25,r24
 5013 23cc 9093 0000 		sts ledOnOffMask,r25
 5014               	.L333:
4608:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
 5015               		.loc 1 4608 0
 5016 23d0 22FF      		sbrs r18,2
 5017 23d2 00C0      		rjmp .L325
 5018               	.LVL188:
 5019               	.LBB128:
 5020               	.LBB129:
3356:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
 5021               		.loc 1 3356 0
 5022 23d4 6091 0000 		lds r22,midiChannelNumberA
 5023 23d8 84E0      		ldi r24,lo8(4)
 5024 23da 90E0      		ldi r25,0
 5025 23dc 0E94 0000 		call EepromWrite
 5026               	.LVL189:
 5027               	.LBE129:
 5028               	.LBE128:
 5029               	.LBB130:
 5030               	.LBB131:
3360:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
 5031               		.loc 1 3360 0
 5032 23e0 6091 0000 		lds r22,midiChannelNumberB
 5033 23e4 88E0      		ldi r24,lo8(8)
 5034 23e6 90E0      		ldi r25,0
 5035 23e8 0E94 0000 		call EepromWrite
 5036               	.LVL190:
 5037               	.LBE131:
 5038               	.LBE130:
 5039               	.LBB132:
 5040               	.LBB133:
1447:WTPA.c        **** 	State=newState;
 5041               		.loc 1 1447 0
 5042 23ec 80E0      		ldi r24,lo8(gs(DoSampler))
 5043 23ee 90E0      		ldi r25,hi8(gs(DoSampler))
 5044 23f0 9093 0000 		sts State+1,r25
 5045 23f4 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 5046               		.loc 1 1448 0
 5047 23f8 1092 0000 		sts subState,__zero_reg__
 5048               	.LVL191:
 5049               	.L325:
 5050 23fc 0895      		ret
 5051               	.LBE133:
 5052               	.LBE132:
 5053               		.cfi_endproc
 5054               	.LFE69:
 5057               	DoSampler:
 5058               	.LFB67:
4152:WTPA.c        **** {
 5059               		.loc 1 4152 0
 5060               		.cfi_startproc
 5061 23fe 8F92      		push r8
 5062               	.LCFI56:
 5063               		.cfi_def_cfa_offset 3
 5064               		.cfi_offset 8, -2
 5065 2400 9F92      		push r9
 5066               	.LCFI57:
 5067               		.cfi_def_cfa_offset 4
 5068               		.cfi_offset 9, -3
 5069 2402 AF92      		push r10
 5070               	.LCFI58:
 5071               		.cfi_def_cfa_offset 5
 5072               		.cfi_offset 10, -4
 5073 2404 BF92      		push r11
 5074               	.LCFI59:
 5075               		.cfi_def_cfa_offset 6
 5076               		.cfi_offset 11, -5
 5077 2406 CF92      		push r12
 5078               	.LCFI60:
 5079               		.cfi_def_cfa_offset 7
 5080               		.cfi_offset 12, -6
 5081 2408 DF92      		push r13
 5082               	.LCFI61:
 5083               		.cfi_def_cfa_offset 8
 5084               		.cfi_offset 13, -7
 5085 240a EF92      		push r14
 5086               	.LCFI62:
 5087               		.cfi_def_cfa_offset 9
 5088               		.cfi_offset 14, -8
 5089 240c FF92      		push r15
 5090               	.LCFI63:
 5091               		.cfi_def_cfa_offset 10
 5092               		.cfi_offset 15, -9
 5093 240e 0F93      		push r16
 5094               	.LCFI64:
 5095               		.cfi_def_cfa_offset 11
 5096               		.cfi_offset 16, -10
 5097 2410 1F93      		push r17
 5098               	.LCFI65:
 5099               		.cfi_def_cfa_offset 12
 5100               		.cfi_offset 17, -11
 5101 2412 CF93      		push r28
 5102               	.LCFI66:
 5103               		.cfi_def_cfa_offset 13
 5104               		.cfi_offset 28, -12
 5105 2414 DF93      		push r29
 5106               	.LCFI67:
 5107               		.cfi_def_cfa_offset 14
 5108               		.cfi_offset 29, -13
 5109 2416 1F92      		push __zero_reg__
 5110               	.LCFI68:
 5111               		.cfi_def_cfa_offset 15
 5112 2418 CDB7      		in r28,__SP_L__
 5113 241a DEB7      		in r29,__SP_H__
 5114               	.LCFI69:
 5115               		.cfi_def_cfa_register 28
 5116               	/* prologue: function */
 5117               	/* frame size = 1 */
 5118               	/* stack size = 13 */
 5119               	.L__stack_usage = 13
4175:WTPA.c        **** 	if(subState==SS_0)
 5120               		.loc 1 4175 0
 5121 241c F090 0000 		lds r15,subState
 5122 2420 F110      		cpse r15,__zero_reg__
 5123 2422 00C0      		rjmp .L348
 5124               	.LVL192:
 5125               	.LBB196:
 5126               	.LBB197:
3375:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 5127               		.loc 1 3375 0
 5128 2424 84E0      		ldi r24,lo8(4)
 5129 2426 0E94 0000 		call EepromRead
 5130               	.LVL193:
3382:WTPA.c        **** 	if(x<16)					// Legit number?
 5131               		.loc 1 3382 0
 5132 242a 8031      		cpi r24,lo8(16)
 5133 242c 00F0      		brlo .L349
3396:WTPA.c        **** 		return(x);
 5134               		.loc 1 3396 0
 5135 242e 80E0      		ldi r24,0
 5136               	.LVL194:
 5137               	.L349:
 5138               	.LBE197:
 5139               	.LBE196:
4178:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
 5140               		.loc 1 4178 0
 5141 2430 8093 0000 		sts midiChannelNumberA,r24
 5142               	.LVL195:
 5143               	.LBB198:
 5144               	.LBB199:
3379:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 5145               		.loc 1 3379 0
 5146 2434 88E0      		ldi r24,lo8(8)
 5147 2436 0E94 0000 		call EepromRead
 5148               	.LVL196:
3382:WTPA.c        **** 	if(x<16)					// Legit number?
 5149               		.loc 1 3382 0
 5150 243a 8031      		cpi r24,lo8(16)
 5151 243c 00F0      		brlo .L350
3396:WTPA.c        **** 		return(x);
 5152               		.loc 1 3396 0
 5153 243e 81E0      		ldi r24,lo8(1)
 5154               	.LVL197:
 5155               	.L350:
 5156               	.LBE199:
 5157               	.LBE198:
4179:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
 5158               		.loc 1 4179 0
 5159 2440 8093 0000 		sts midiChannelNumberB,r24
4180:WTPA.c        **** 		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardco
 5160               		.loc 1 4180 0
 5161 2444 1092 0000 		sts bankStates+16,__zero_reg__
 5162 2448 1092 0000 		sts bankStates+16+1,__zero_reg__
 5163 244c 1092 0000 		sts bankStates+16+2,__zero_reg__
 5164 2450 1092 0000 		sts bankStates+16+3,__zero_reg__
4181:WTPA.c        **** 		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardco
 5165               		.loc 1 4181 0
 5166 2454 8FEF      		ldi r24,lo8(-1)
 5167 2456 9FEF      		ldi r25,lo8(-1)
 5168 2458 A7E0      		ldi r26,lo8(7)
 5169 245a B0E0      		ldi r27,0
 5170 245c 8093 0000 		sts bankStates+51,r24
 5171 2460 9093 0000 		sts bankStates+51+1,r25
 5172 2464 A093 0000 		sts bankStates+51+2,r26
 5173 2468 B093 0000 		sts bankStates+51+3,r27
 5174               	.LVL198:
 5175 246c 00E0      		ldi r16,lo8(realtimeOn.2207)
 5176 246e 10E0      		ldi r17,hi8(realtimeOn.2207)
 5177 2470 70E0      		ldi r23,lo8(theMidiRecordRate)
 5178 2472 872E      		mov r8,r23
 5179 2474 70E0      		ldi r23,hi8(theMidiRecordRate)
 5180 2476 972E      		mov r9,r23
 5181 2478 E12C      		mov r14,__zero_reg__
 5182 247a F12C      		mov r15,__zero_reg__
4185:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5183               		.loc 1 4185 0
 5184 247c E3E2      		ldi r30,lo8(35)
 5185 247e CE2E      		mov r12,r30
4192:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
 5186               		.loc 1 4192 0
 5187 2480 BB24      		clr r11
 5188 2482 B394      		inc r11
 5189               	.LBB200:
 5190               	.LBB201:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5191               		.loc 1 3294 0
 5192 2484 FCE0      		ldi r31,lo8(12)
 5193 2486 DF2E      		mov r13,r31
 5194               	.LVL199:
 5195               	.L354:
 5196               	.LBE201:
 5197               	.LBE200:
4185:WTPA.c        **** 			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 5198               		.loc 1 4185 0 discriminator 2
 5199 2488 CE9C      		mul r12,r14
 5200 248a F001      		movw r30,r0
 5201 248c CF9C      		mul r12,r15
 5202 248e F00D      		add r31,r0
 5203 2490 1124      		clr __zero_reg__
 5204 2492 E050      		subi r30,lo8(-(bankStates))
 5205 2494 F040      		sbci r31,hi8(-(bankStates))
 5206 2496 1082      		st Z,__zero_reg__
4186:WTPA.c        **** 			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet
 5207               		.loc 1 4186 0 discriminator 2
 5208 2498 1186      		std Z+9,__zero_reg__
4187:WTPA.c        **** 			bankStates[i].loopOnce=false;
 5209               		.loc 1 4187 0 discriminator 2
 5210 249a 1182      		std Z+1,__zero_reg__
4188:WTPA.c        **** 			bankStates[i].bitReduction=0;				// No crusties yet.
 5211               		.loc 1 4188 0 discriminator 2
 5212 249c 1086      		std Z+8,__zero_reg__
4189:WTPA.c        **** 			bankStates[i].jitterValue=0;				// No hissies yet.
 5213               		.loc 1 4189 0 discriminator 2
 5214 249e 1782      		std Z+7,__zero_reg__
4190:WTPA.c        **** 			bankStates[i].granularSlices=0;				// No remix yet.
 5215               		.loc 1 4190 0 discriminator 2
 5216 24a0 1682      		std Z+6,__zero_reg__
4191:WTPA.c        **** 			bankStates[i].halfSpeed=false;
 5217               		.loc 1 4191 0 discriminator 2
 5218 24a2 1282      		std Z+2,__zero_reg__
4192:WTPA.c        **** 			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet
 5219               		.loc 1 4192 0 discriminator 2
 5220 24a4 B482      		std Z+4,r11
4193:WTPA.c        **** 			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
 5221               		.loc 1 4193 0 discriminator 2
 5222 24a6 1382      		std Z+3,__zero_reg__
4194:WTPA.c        **** 			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beg
 5223               		.loc 1 4194 0 discriminator 2
 5224 24a8 8089      		ldd r24,Z+16
 5225 24aa 9189      		ldd r25,Z+17
 5226 24ac A289      		ldd r26,Z+18
 5227 24ae B389      		ldd r27,Z+19
 5228 24b0 878F      		std Z+31,r24
 5229 24b2 90A3      		std Z+32,r25
 5230 24b4 A1A3      		std Z+33,r26
 5231 24b6 B2A3      		std Z+34,r27
4195:WTPA.c        **** 			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sa
 5232               		.loc 1 4195 0 discriminator 2
 5233 24b8 8089      		ldd r24,Z+16
 5234 24ba 9189      		ldd r25,Z+17
 5235 24bc A289      		ldd r26,Z+18
 5236 24be B389      		ldd r27,Z+19
 5237 24c0 8487      		std Z+12,r24
 5238 24c2 9587      		std Z+13,r25
 5239 24c4 A687      		std Z+14,r26
 5240 24c6 B787      		std Z+15,r27
4196:WTPA.c        **** 			realtimeOn[i]=false;								// We'll default to playback.
 5241               		.loc 1 4196 0 discriminator 2
 5242 24c8 D801      		movw r26,r16
 5243 24ca 1D92      		st X+,__zero_reg__
 5244 24cc 8D01      		movw r16,r26
4197:WTPA.c        **** 			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
 5245               		.loc 1 4197 0 discriminator 2
 5246 24ce 1582      		std Z+5,__zero_reg__
4200:WTPA.c        **** 			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
 5247               		.loc 1 4200 0 discriminator 2
 5248 24d0 8E2D      		mov r24,r14
 5249 24d2 0E94 0000 		call RevertSampleToUnadjusted
 5250               	.LVL200:
 5251               	.LBB203:
 5252               	.LBB204:
3330:WTPA.c        **** 	if(theBank==BANK_0)
 5253               		.loc 1 3330 0 discriminator 2
 5254 24d6 E110      		cpse r14,__zero_reg__
 5255 24d8 00C0      		rjmp .L351
3332:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
 5256               		.loc 1 3332 0
 5257 24da 87E0      		ldi r24,lo8(7)
 5258 24dc 00C0      		rjmp .L539
 5259               	.L351:
3336:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
 5260               		.loc 1 3336 0
 5261 24de 8BE0      		ldi r24,lo8(11)
 5262               	.L539:
 5263 24e0 0E94 0000 		call EepromRead
 5264               	.LVL201:
3339:WTPA.c        **** 	if(x<90)					// Legit number?
 5265               		.loc 1 3339 0
 5266 24e4 8A35      		cpi r24,lo8(90)
 5267 24e6 00F0      		brlo .L353
3346:WTPA.c        **** 		return(x);
 5268               		.loc 1 3346 0
 5269 24e8 80E3      		ldi r24,lo8(48)
 5270               	.LVL202:
 5271               	.L353:
 5272               	.LBE204:
 5273               	.LBE203:
 5274               	.LBB205:
 5275               	.LBB202:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5276               		.loc 1 3294 0
 5277 24ea 6D2D      		mov r22,r13
 5278 24ec 0E94 0000 		call __udivmodqi4
 5279               	.LVL203:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 5280               		.loc 1 3296 0
 5281 24f0 E92F      		mov r30,r25
 5282 24f2 F0E0      		ldi r31,0
 5283 24f4 EE0F      		lsl r30
 5284 24f6 FF1F      		rol r31
 5285 24f8 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 5286 24fa F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 5287 24fc 2081      		ld r18,Z
 5288 24fe 3181      		ldd r19,Z+1
 5289 2500 00C0      		rjmp 2f
 5290               		1:
 5291 2502 3695      		lsr r19
 5292 2504 2795      		ror r18
 5293               		2:
 5294 2506 8A95      		dec r24
 5295 2508 02F4      		brpl 1b
 5296               	.LBE202:
 5297               	.LBE205:
4203:WTPA.c        **** 			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful num
 5298               		.loc 1 4203 0
 5299 250a F401      		movw r30,r8
 5300 250c 2193      		st Z+,r18
 5301 250e 3193      		st Z+,r19
 5302 2510 4F01      		movw r8,r30
 5303 2512 FFEF      		ldi r31,-1
 5304 2514 EF1A      		sub r14,r31
 5305 2516 FF0A      		sbc r15,r31
 5306               	.LVL204:
4183:WTPA.c        **** 		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
 5307               		.loc 1 4183 0
 5308 2518 22E0      		ldi r18,2
 5309 251a E216      		cp r14,r18
 5310 251c F104      		cpc r15,__zero_reg__
 5311 251e 01F0      		breq .+2
 5312 2520 00C0      		rjmp .L354
4206:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 5313               		.loc 1 4206 0
 5314 2522 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5315 2524 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5316 2526 9093 0000 		sts UpdateOutput+1,r25
 5317 252a 8093 0000 		sts UpdateOutput,r24
4208:WTPA.c        **** 		currentBank=BANK_0;			// Point at the first bank until we change banks.
 5318               		.loc 1 4208 0
 5319 252e 1092 0000 		sts currentBank,__zero_reg__
4210:WTPA.c        **** 		KillLeds();					// All leds off, and no blinking.
 5320               		.loc 1 4210 0
 5321 2532 0E94 0000 		call KillLeds
 5322               	.LVL205:
4211:WTPA.c        **** 		subState=SS_1;
 5323               		.loc 1 4211 0
 5324 2536 81E0      		ldi r24,lo8(1)
 5325 2538 8093 0000 		sts subState,r24
 5326 253c 00C0      		rjmp .L355
 5327               	.LVL206:
 5328               	.L348:
4214:WTPA.c        **** 	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different s
 5329               		.loc 1 4214 0
 5330 253e 41E0      		ldi r20,lo8(1)
 5331 2540 F412      		cpse r15,r20
 5332 2542 00C0      		rjmp .L355
 5333               	.LBB206:
 5334               	.LBB207:
3907:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
 5335               		.loc 1 3907 0
 5336 2544 8091 0000 		lds r24,keysHeld
 5337 2548 86FF      		sbrs r24,6
 5338 254a 00C0      		rjmp .L357
 5339 254c 87FF      		sbrs r24,7
 5340 254e 00C0      		rjmp .L358
3909:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
 5341               		.loc 1 3909 0
 5342 2550 8091 0000 		lds r24,newKeys
 5343 2554 85FF      		sbrs r24,5
 5344 2556 00C0      		rjmp .L359
3911:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
 5345               		.loc 1 3911 0
 5346 2558 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5347 255a 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5348 255c 9093 0000 		sts UpdateOutput+1,r25
 5349 2560 8093 0000 		sts UpdateOutput,r24
3912:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
 5350               		.loc 1 3912 0
 5351 2564 1091 0000 		lds r17,currentBank
 5352 2568 812F      		mov r24,r17
 5353 256a 0E94 0000 		call RevertSampleToUnadjusted
 5354               	.LVL207:
3913:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
 5355               		.loc 1 3913 0
 5356 256e 83E2      		ldi r24,lo8(35)
 5357 2570 189F      		mul r17,r24
 5358 2572 F001      		movw r30,r0
 5359 2574 1124      		clr __zero_reg__
 5360 2576 E050      		subi r30,lo8(-(bankStates))
 5361 2578 F040      		sbci r31,hi8(-(bankStates))
 5362 257a 1086      		std Z+8,__zero_reg__
3914:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
 5363               		.loc 1 3914 0
 5364 257c 1782      		std Z+7,__zero_reg__
3915:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
 5365               		.loc 1 3915 0
 5366 257e 1682      		std Z+6,__zero_reg__
3916:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
 5367               		.loc 1 3916 0
 5368 2580 1282      		std Z+2,__zero_reg__
3917:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
 5369               		.loc 1 3917 0
 5370 2582 1382      		std Z+3,__zero_reg__
3918:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
 5371               		.loc 1 3918 0
 5372 2584 F482      		std Z+4,r15
3919:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
 5373               		.loc 1 3919 0
 5374 2586 1182      		std Z+1,__zero_reg__
3920:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
 5375               		.loc 1 3920 0
 5376 2588 20E0      		ldi r18,0
 5377 258a 42E1      		ldi r20,lo8(18)
 5378 258c 64E0      		ldi r22,lo8(4)
 5379 258e 812F      		mov r24,r17
 5380 2590 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5381               	.LVL208:
3921:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
 5382               		.loc 1 3921 0
 5383 2594 20E0      		ldi r18,0
 5384 2596 4BE1      		ldi r20,lo8(27)
 5385 2598 64E0      		ldi r22,lo8(4)
 5386 259a 8091 0000 		lds r24,currentBank
 5387 259e 00C0      		rjmp .L546
 5388               	.L359:
3923:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)
 5389               		.loc 1 3923 0
 5390 25a0 80FF      		sbrs r24,0
 5391 25a2 00C0      		rjmp .L361
3926:WTPA.c        **** 			WriteSampleToSd(currentBank,0);		// @@@ test
 5392               		.loc 1 3926 0
 5393 25a4 1091 0000 		lds r17,currentBank
 5394               	.LVL209:
 5395               	.LBB208:
 5396               	.LBB209:
3080:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5397               		.loc 1 3080 0
 5398 25a8 8091 0000 		lds r24,cardState
 5399 25ac 8E30      		cpi r24,lo8(14)
 5400 25ae 01F0      		breq .+2
 5401 25b0 00C0      		rjmp .L360
3082:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5402               		.loc 1 3082 0
 5403 25b2 212F      		mov r18,r17
 5404 25b4 30E0      		ldi r19,0
 5405 25b6 93E2      		ldi r25,lo8(35)
 5406 25b8 199F      		mul r17,r25
 5407 25ba D001      		movw r26,r0
 5408 25bc 1124      		clr __zero_reg__
 5409 25be A050      		subi r26,lo8(-(bankStates))
 5410 25c0 B040      		sbci r27,hi8(-(bankStates))
 5411 25c2 1596      		adiw r26, 5
 5412 25c4 8C91      		ld r24,X
 5413 25c6 1597      		sbiw r26, 5
 5414 25c8 8111      		cpse r24,__zero_reg__
 5415 25ca 00C0      		rjmp .L360
 5416               	.LVL210:
 5417               	.LBB210:
 5418               	.LBB211:
3042:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5419               		.loc 1 3042 0
 5420 25cc 1696      		adiw r26, 6
 5421 25ce 8C91      		ld r24,X
3040:WTPA.c        **** 	if(theBank==BANK_0)
 5422               		.loc 1 3040 0
 5423 25d0 1111      		cpse r17,__zero_reg__
 5424 25d2 00C0      		rjmp .L364
3042:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5425               		.loc 1 3042 0
 5426 25d4 8111      		cpse r24,__zero_reg__
 5427 25d6 00C0      		rjmp .L365
3044:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
 5428               		.loc 1 3044 0
 5429 25d8 83E2      		ldi r24,lo8(35)
 5430 25da 829F      		mul r24,r18
 5431 25dc A001      		movw r20,r0
 5432 25de 839F      		mul r24,r19
 5433 25e0 500D      		add r21,r0
 5434 25e2 1124      		clr __zero_reg__
 5435 25e4 4050      		subi r20,lo8(-(bankStates))
 5436 25e6 5040      		sbci r21,hi8(-(bankStates))
 5437 25e8 FA01      		movw r30,r20
 5438 25ea 8489      		ldd r24,Z+20
 5439 25ec 9589      		ldd r25,Z+21
 5440 25ee A689      		ldd r26,Z+22
 5441 25f0 B789      		ldd r27,Z+23
 5442 25f2 408D      		ldd r20,Z+24
 5443 25f4 518D      		ldd r21,Z+25
 5444 25f6 628D      		ldd r22,Z+26
 5445 25f8 738D      		ldd r23,Z+27
 5446 25fa 00C0      		rjmp .L554
 5447               	.L365:
3048:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
 5448               		.loc 1 3048 0
 5449 25fc 83E2      		ldi r24,lo8(35)
 5450 25fe 829F      		mul r24,r18
 5451 2600 D001      		movw r26,r0
 5452 2602 839F      		mul r24,r19
 5453 2604 B00D      		add r27,r0
 5454 2606 1124      		clr __zero_reg__
 5455 2608 A050      		subi r26,lo8(-(bankStates))
 5456 260a B040      		sbci r27,hi8(-(bankStates))
 5457 260c 1C96      		adiw r26,12
 5458 260e 8D91      		ld r24,X+
 5459 2610 9D91      		ld r25,X+
 5460 2612 0D90      		ld __tmp_reg__,X+
 5461 2614 BC91      		ld r27,X
 5462 2616 A02D      		mov r26,__tmp_reg__
 5463               	.LVL211:
 5464 2618 00C0      		rjmp .L366
 5465               	.LVL212:
 5466               	.L364:
3053:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 5467               		.loc 1 3053 0
 5468 261a 8111      		cpse r24,__zero_reg__
 5469 261c 00C0      		rjmp .L367
3055:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
 5470               		.loc 1 3055 0
 5471 261e 83E2      		ldi r24,lo8(35)
 5472 2620 829F      		mul r24,r18
 5473 2622 A001      		movw r20,r0
 5474 2624 839F      		mul r24,r19
 5475 2626 500D      		add r21,r0
 5476 2628 1124      		clr __zero_reg__
 5477 262a 4050      		subi r20,lo8(-(bankStates))
 5478 262c 5040      		sbci r21,hi8(-(bankStates))
 5479 262e FA01      		movw r30,r20
 5480 2630 808D      		ldd r24,Z+24
 5481 2632 918D      		ldd r25,Z+25
 5482 2634 A28D      		ldd r26,Z+26
 5483 2636 B38D      		ldd r27,Z+27
 5484 2638 4489      		ldd r20,Z+20
 5485 263a 5589      		ldd r21,Z+21
 5486 263c 6689      		ldd r22,Z+22
 5487 263e 7789      		ldd r23,Z+23
 5488               	.L554:
 5489 2640 0196      		adiw r24,1
 5490 2642 A11D      		adc r26,__zero_reg__
 5491 2644 B11D      		adc r27,__zero_reg__
 5492 2646 00C0      		rjmp .L540
 5493               	.L367:
3059:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
 5494               		.loc 1 3059 0
 5495 2648 83E2      		ldi r24,lo8(35)
 5496 264a 829F      		mul r24,r18
 5497 264c A001      		movw r20,r0
 5498 264e 839F      		mul r24,r19
 5499 2650 500D      		add r21,r0
 5500 2652 1124      		clr __zero_reg__
 5501 2654 4050      		subi r20,lo8(-(bankStates))
 5502 2656 5040      		sbci r21,hi8(-(bankStates))
 5503 2658 FA01      		movw r30,r20
 5504 265a 8089      		ldd r24,Z+16
 5505 265c 9189      		ldd r25,Z+17
 5506 265e A289      		ldd r26,Z+18
 5507 2660 B389      		ldd r27,Z+19
 5508 2662 4485      		ldd r20,Z+12
 5509 2664 5585      		ldd r21,Z+13
 5510 2666 6685      		ldd r22,Z+14
 5511 2668 7785      		ldd r23,Z+15
 5512               	.L540:
 5513 266a 841B      		sub r24,r20
 5514 266c 950B      		sbc r25,r21
 5515 266e A60B      		sbc r26,r22
 5516 2670 B70B      		sbc r27,r23
 5517               	.LVL213:
 5518               	.L366:
 5519               	.LBE211:
 5520               	.LBE210:
3086:WTPA.c        **** 			sreg=SREG;
 5521               		.loc 1 3086 0
 5522 2672 FFB7      		in r31,__SREG__
 5523               	.LVL214:
3087:WTPA.c        **** 			cli();		// Pause ISR
 5524               		.loc 1 3087 0
 5525               	/* #APP */
 5526               	 ;  3087 "WTPA.c" 1
 5527 2674 F894      		cli
 5528               	 ;  0 "" 2
 5529               	.LVL215:
 5530               	/* #NOAPP */
 5531               	.LBB212:
 5532               	.LBB213:
2316:WTPA.c        **** 	sreg=SREG;
 5533               		.loc 1 2316 0
 5534 2676 EFB7      		in r30,__SREG__
 5535               	.LVL216:
2317:WTPA.c        **** 	cli();		// Pause ISR
 5536               		.loc 1 2317 0
 5537               	/* #APP */
 5538               	 ;  2317 "WTPA.c" 1
 5539 2678 F894      		cli
 5540               	 ;  0 "" 2
2319:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
 5541               		.loc 1 2319 0
 5542               	/* #NOAPP */
 5543 267a 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 5544 267e 1092 0000 		sts sdCurrentSlot,__zero_reg__
2320:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
 5545               		.loc 1 2320 0
 5546 2682 41E0      		ldi r20,lo8(1)
 5547 2684 50E0      		ldi r21,0
 5548 2686 60E0      		ldi r22,0
 5549 2688 70E0      		ldi r23,0
 5550 268a 4093 0000 		sts sdSampleStartBlock,r20
 5551 268e 5093 0000 		sts sdSampleStartBlock+1,r21
 5552 2692 6093 0000 		sts sdSampleStartBlock+2,r22
 5553 2696 7093 0000 		sts sdSampleStartBlock+3,r23
2321:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
 5554               		.loc 1 2321 0
 5555 269a 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 5556 269e 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2323:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 5557               		.loc 1 2323 0
 5558 26a2 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 5559 26a6 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2324:WTPA.c        **** 	sdFifoWritePointer=0;
 5560               		.loc 1 2324 0
 5561 26aa 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 5562 26ae 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2325:WTPA.c        **** 	sdBytesInFifo=0;
 5563               		.loc 1 2325 0
 5564 26b2 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 5565 26b6 1092 0000 		sts sdBytesInFifo,__zero_reg__
2327:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
 5566               		.loc 1 2327 0
 5567 26ba 8D3F      		cpi r24,-3
 5568 26bc 4FEF      		ldi r20,-1
 5569 26be 9407      		cpc r25,r20
 5570 26c0 47E0      		ldi r20,7
 5571 26c2 A407      		cpc r26,r20
 5572 26c4 B105      		cpc r27,__zero_reg__
 5573 26c6 00F4      		brsh .L368
 5574 26c8 00C0      		rjmp .L541
 5575               	.L368:
2333:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
 5576               		.loc 1 2333 0
 5577 26ca 8CEF      		ldi r24,lo8(-4)
 5578 26cc 9FEF      		ldi r25,lo8(-1)
 5579 26ce A7E0      		ldi r26,lo8(7)
 5580 26d0 B0E0      		ldi r27,0
 5581               	.LVL217:
 5582               	.L541:
 5583 26d2 8093 0000 		sts sdRamSampleRemaining,r24
 5584 26d6 9093 0000 		sts sdRamSampleRemaining+1,r25
 5585 26da A093 0000 		sts sdRamSampleRemaining+2,r26
 5586 26de B093 0000 		sts sdRamSampleRemaining+3,r27
2336:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
 5587               		.loc 1 2336 0
 5588 26e2 8091 0000 		lds r24,sdRamSampleRemaining
 5589 26e6 9091 0000 		lds r25,sdRamSampleRemaining+1
 5590 26ea A091 0000 		lds r26,sdRamSampleRemaining+2
 5591 26ee B091 0000 		lds r27,sdRamSampleRemaining+3
 5592 26f2 8093 0000 		sts sdCardSampleRemaining,r24
 5593 26f6 9093 0000 		sts sdCardSampleRemaining+1,r25
 5594 26fa A093 0000 		sts sdCardSampleRemaining+2,r26
 5595 26fe B093 0000 		sts sdCardSampleRemaining+3,r27
2337:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
 5596               		.loc 1 2337 0
 5597 2702 82E0      		ldi r24,lo8(2)
 5598 2704 8093 0000 		sts cardState,r24
2338:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 5599               		.loc 1 2338 0
 5600 2708 EFBF      		out __SREG__,r30
 5601               	.LVL218:
 5602               	.LBE213:
 5603               	.LBE212:
 5604               	.LBB214:
 5605               	.LBB215:
2954:WTPA.c        **** 	sreg=SREG;
 5606               		.loc 1 2954 0
 5607 270a 4FB7      		in r20,__SREG__
 5608               	.LVL219:
2955:WTPA.c        **** 	cli();		// Pause ISRs
 5609               		.loc 1 2955 0
 5610               	/* #APP */
 5611               	 ;  2955 "WTPA.c" 1
 5612 270c F894      		cli
 5613               	 ;  0 "" 2
2957:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
 5614               		.loc 1 2957 0
 5615               	/* #NOAPP */
 5616 270e 8093 0000 		sts sdIsrState,r24
2958:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5617               		.loc 1 2958 0
 5618 2712 83E2      		ldi r24,lo8(35)
 5619 2714 829F      		mul r24,r18
 5620 2716 D001      		movw r26,r0
 5621 2718 839F      		mul r24,r19
 5622 271a B00D      		add r27,r0
 5623 271c 1124      		clr __zero_reg__
 5624 271e A050      		subi r26,lo8(-(bankStates))
 5625 2720 B040      		sbci r27,hi8(-(bankStates))
 5626 2722 81E0      		ldi r24,lo8(1)
 5627 2724 1596      		adiw r26,5
 5628 2726 8C93      		st X,r24
2960:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5629               		.loc 1 2960 0
 5630 2728 1111      		cpse r17,__zero_reg__
 5631 272a 00C0      		rjmp .L370
2962:WTPA.c        **** 		sdBank0=true;
 5632               		.loc 1 2962 0
 5633 272c 8093 0000 		sts sdBank0,r24
2963:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5634               		.loc 1 2963 0
 5635 2730 1092 0000 		sts sdRamAddress,__zero_reg__
 5636 2734 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5637 2738 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5638 273c 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5639 2740 00C0      		rjmp .L371
 5640               	.L370:
2967:WTPA.c        **** 		sdBank0=false;
 5641               		.loc 1 2967 0
 5642 2742 1092 0000 		sts sdBank0,__zero_reg__
2968:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5643               		.loc 1 2968 0
 5644 2746 8FEF      		ldi r24,lo8(-1)
 5645 2748 9FEF      		ldi r25,lo8(-1)
 5646 274a A7E0      		ldi r26,lo8(7)
 5647 274c B0E0      		ldi r27,0
 5648 274e 8093 0000 		sts sdRamAddress,r24
 5649 2752 9093 0000 		sts sdRamAddress+1,r25
 5650 2756 A093 0000 		sts sdRamAddress+2,r26
 5651 275a B093 0000 		sts sdRamAddress+3,r27
 5652               	.L371:
2971:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5653               		.loc 1 2971 0
 5654 275e 1092 B200 		sts 178,__zero_reg__
2972:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5655               		.loc 1 2972 0
 5656 2762 81E6      		ldi r24,lo8(97)
 5657 2764 8093 B300 		sts 179,r24
2973:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5658               		.loc 1 2973 0
 5659 2768 8FEF      		ldi r24,lo8(-1)
 5660 276a 87BB      		out 0x17,r24
2974:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5661               		.loc 1 2974 0
 5662 276c 8091 7000 		lds r24,112
 5663 2770 8460      		ori r24,lo8(4)
 5664 2772 8093 7000 		sts 112,r24
2975:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5665               		.loc 1 2975 0
 5666 2776 82E0      		ldi r24,lo8(2)
 5667 2778 8093 B100 		sts 177,r24
2977:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5668               		.loc 1 2977 0
 5669 277c 4FBF      		out __SREG__,r20
 5670               	.LBE215:
 5671               	.LBE214:
3092:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5672               		.loc 1 3092 0
 5673 277e FFBF      		out __SREG__,r31
 5674 2780 00C0      		rjmp .L360
 5675               	.LVL220:
 5676               	.L361:
 5677               	.LBE209:
 5678               	.LBE208:
3928:WTPA.c        **** 		else if(newKeys&Im_SWITCH_1)
 5679               		.loc 1 3928 0
 5680 2782 81FF      		sbrs r24,1
 5681 2784 00C0      		rjmp .L360
3931:WTPA.c        **** 			ReadSampleFromSd(currentBank,0);	// @@@ test
 5682               		.loc 1 3931 0
 5683 2786 1091 0000 		lds r17,currentBank
 5684               	.LVL221:
 5685               	.LBB216:
 5686               	.LBB217:
3103:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 5687               		.loc 1 3103 0
 5688 278a 8091 0000 		lds r24,cardState
 5689 278e 8E30      		cpi r24,lo8(14)
 5690 2790 01F0      		breq .+2
 5691 2792 00C0      		rjmp .L360
3105:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 5692               		.loc 1 3105 0
 5693 2794 83E2      		ldi r24,lo8(35)
 5694 2796 189F      		mul r17,r24
 5695 2798 6001      		movw r12,r0
 5696 279a 1124      		clr __zero_reg__
 5697 279c A0E0      		ldi r26,lo8(bankStates)
 5698 279e B0E0      		ldi r27,hi8(bankStates)
 5699 27a0 CA0E      		add r12,r26
 5700 27a2 DB1E      		adc r13,r27
 5701 27a4 F601      		movw r30,r12
 5702 27a6 8581      		ldd r24,Z+5
 5703 27a8 8111      		cpse r24,__zero_reg__
 5704 27aa 00C0      		rjmp .L360
3107:WTPA.c        **** 			sreg=SREG;
 5705               		.loc 1 3107 0
 5706 27ac 0FB7      		in r16,__SREG__
 5707               	.LVL222:
3108:WTPA.c        **** 			cli();		// Pause ISR
 5708               		.loc 1 3108 0
 5709               	/* #APP */
 5710               	 ;  3108 "WTPA.c" 1
 5711 27ae F894      		cli
 5712               	 ;  0 "" 2
3110:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
 5713               		.loc 1 3110 0
 5714               	/* #NOAPP */
 5715 27b0 80E0      		ldi r24,0
 5716 27b2 90E0      		ldi r25,0
 5717 27b4 0E94 0000 		call SdStartSampleRead
 5718               	.LVL223:
3111:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
 5719               		.loc 1 3111 0
 5720 27b8 81E0      		ldi r24,lo8(1)
 5721 27ba 90E0      		ldi r25,0
 5722 27bc A0E0      		ldi r26,0
 5723 27be B0E0      		ldi r27,0
 5724 27c0 8093 0000 		sts sdRamSampleRemaining,r24
 5725 27c4 9093 0000 		sts sdRamSampleRemaining+1,r25
 5726 27c8 A093 0000 		sts sdRamSampleRemaining+2,r26
 5727 27cc B093 0000 		sts sdRamSampleRemaining+3,r27
 5728               	.LVL224:
 5729               	.LBB218:
 5730               	.LBB219:
2987:WTPA.c        **** 	sreg=SREG;
 5731               		.loc 1 2987 0
 5732 27d0 2FB7      		in r18,__SREG__
 5733               	.LVL225:
2988:WTPA.c        **** 	cli();		// Pause ISRs
 5734               		.loc 1 2988 0
 5735               	/* #APP */
 5736               	 ;  2988 "WTPA.c" 1
 5737 27d2 F894      		cli
 5738               	 ;  0 "" 2
2990:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
 5739               		.loc 1 2990 0
 5740               	/* #NOAPP */
 5741 27d4 F092 0000 		sts sdIsrState,r15
2991:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 5742               		.loc 1 2991 0
 5743 27d8 D601      		movw r26,r12
 5744 27da 1596      		adiw r26,5
 5745 27dc FC92      		st X,r15
2993:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 5746               		.loc 1 2993 0
 5747 27de 1111      		cpse r17,__zero_reg__
 5748 27e0 00C0      		rjmp .L372
2995:WTPA.c        **** 		sdBank0=true;
 5749               		.loc 1 2995 0
 5750 27e2 81E0      		ldi r24,lo8(1)
 5751 27e4 8093 0000 		sts sdBank0,r24
2996:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 5752               		.loc 1 2996 0
 5753 27e8 1092 0000 		sts sdRamAddress,__zero_reg__
 5754 27ec 1092 0000 		sts sdRamAddress+1,__zero_reg__
 5755 27f0 1092 0000 		sts sdRamAddress+2,__zero_reg__
 5756 27f4 1092 0000 		sts sdRamAddress+3,__zero_reg__
 5757 27f8 00C0      		rjmp .L373
 5758               	.L372:
3000:WTPA.c        **** 		sdBank0=false;
 5759               		.loc 1 3000 0
 5760 27fa 1092 0000 		sts sdBank0,__zero_reg__
3001:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 5761               		.loc 1 3001 0
 5762 27fe 8FEF      		ldi r24,lo8(-1)
 5763 2800 9FEF      		ldi r25,lo8(-1)
 5764 2802 A7E0      		ldi r26,lo8(7)
 5765 2804 B0E0      		ldi r27,0
 5766 2806 8093 0000 		sts sdRamAddress,r24
 5767 280a 9093 0000 		sts sdRamAddress+1,r25
 5768 280e A093 0000 		sts sdRamAddress+2,r26
 5769 2812 B093 0000 		sts sdRamAddress+3,r27
 5770               	.L373:
3004:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 5771               		.loc 1 3004 0
 5772 2816 1092 B200 		sts 178,__zero_reg__
3005:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 5773               		.loc 1 3005 0
 5774 281a 81E6      		ldi r24,lo8(97)
 5775 281c 8093 B300 		sts 179,r24
3006:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 5776               		.loc 1 3006 0
 5777 2820 8FEF      		ldi r24,lo8(-1)
 5778 2822 87BB      		out 0x17,r24
3007:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 5779               		.loc 1 3007 0
 5780 2824 8091 7000 		lds r24,112
 5781 2828 8460      		ori r24,lo8(4)
 5782 282a 8093 7000 		sts 112,r24
3008:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 5783               		.loc 1 3008 0
 5784 282e 82E0      		ldi r24,lo8(2)
 5785 2830 8093 B100 		sts 177,r24
3010:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 5786               		.loc 1 3010 0
 5787 2834 2FBF      		out __SREG__,r18
 5788               	.LBE219:
 5789               	.LBE218:
3114:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 5790               		.loc 1 3114 0
 5791 2836 0FBF      		out __SREG__,r16
 5792 2838 00C0      		rjmp .L360
 5793               	.LVL226:
 5794               	.L358:
 5795               	.LBE217:
 5796               	.LBE216:
 5797               	.LBE207:
3939:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
 5798               		.loc 1 3939 0
 5799 283a 8091 0000 		lds r24,keyState
 5800               	.LBB226:
 5801 283e 80FF      		sbrs r24,0
 5802 2840 00C0      		rjmp .L374
3941:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pre
 5803               		.loc 1 3941 0
 5804 2842 9091 0000 		lds r25,encoderValue
 5805 2846 8091 0000 		lds r24,lastEncoderValue.2194
 5806 284a 9817      		cp r25,r24
 5807 284c 01F0      		breq .L374
3943:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
 5808               		.loc 1 3943 0
 5809 284e 8091 0000 		lds r24,currentBank
 5810 2852 2091 0000 		lds r18,scaledEncoderValue
 5811 2856 B3E2      		ldi r27,lo8(35)
 5812 2858 8B9F      		mul r24,r27
 5813 285a F001      		movw r30,r0
 5814 285c 1124      		clr __zero_reg__
 5815 285e E050      		subi r30,lo8(-(bankStates))
 5816 2860 F040      		sbci r31,hi8(-(bankStates))
 5817 2862 2087      		std Z+8,r18
3944:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
 5818               		.loc 1 3944 0
 5819 2864 43E1      		ldi r20,lo8(19)
 5820 2866 64E0      		ldi r22,lo8(4)
 5821 2868 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5822               	.LVL227:
 5823               	.L374:
 5824               	.LBE226:
3947:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
 5825               		.loc 1 3947 0
 5826 286c 8091 0000 		lds r24,newKeys
 5827               	.LBB227:
 5828 2870 81FF      		sbrs r24,1
 5829 2872 00C0      		rjmp .L375
3949:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
 5830               		.loc 1 3949 0
 5831 2874 8091 0000 		lds r24,currentBank
 5832 2878 23E2      		ldi r18,lo8(35)
 5833 287a 829F      		mul r24,r18
 5834 287c F001      		movw r30,r0
 5835 287e 1124      		clr __zero_reg__
 5836 2880 E050      		subi r30,lo8(-(bankStates))
 5837 2882 F040      		sbci r31,hi8(-(bankStates))
 5838 2884 9281      		ldd r25,Z+2
 5839 2886 9111      		cpse r25,__zero_reg__
 5840 2888 00C0      		rjmp .L376
3951:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
 5841               		.loc 1 3951 0
 5842 288a 91E0      		ldi r25,lo8(1)
 5843 288c 9283      		std Z+2,r25
3952:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
 5844               		.loc 1 3952 0
 5845 288e 20E4      		ldi r18,lo8(64)
 5846 2890 00C0      		rjmp .L542
 5847               	.L376:
3956:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
 5848               		.loc 1 3956 0
 5849 2892 1282      		std Z+2,__zero_reg__
3957:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
 5850               		.loc 1 3957 0
 5851 2894 20E0      		ldi r18,0
 5852               	.L542:
 5853 2896 40E1      		ldi r20,lo8(16)
 5854 2898 64E0      		ldi r22,lo8(4)
 5855 289a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5856               	.LVL228:
 5857               	.L375:
 5858               	.LBE227:
3960:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
 5859               		.loc 1 3960 0
 5860 289e 8091 0000 		lds r24,newKeys
 5861               	.LBB228:
 5862 28a2 82FF      		sbrs r24,2
 5863 28a4 00C0      		rjmp .L377
3962:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
 5864               		.loc 1 3962 0
 5865 28a6 1091 0000 		lds r17,currentBank
 5866 28aa 40E0      		ldi r20,0
 5867 28ac 50E0      		ldi r21,0
 5868 28ae 61E0      		ldi r22,lo8(1)
 5869 28b0 812F      		mov r24,r17
 5870 28b2 0E94 0000 		call StartRealtime
 5871               	.LVL229:
3963:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
 5872               		.loc 1 3963 0
 5873 28b6 20E3      		ldi r18,lo8(48)
 5874 28b8 4EE0      		ldi r20,lo8(14)
 5875 28ba 64E0      		ldi r22,lo8(4)
 5876 28bc 812F      		mov r24,r17
 5877 28be 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5878               	.LVL230:
 5879               	.L377:
 5880               	.LBE228:
3965:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granula
 5881               		.loc 1 3965 0
 5882 28c2 8091 0000 		lds r24,keyState
 5883               	.LBB229:
 5884 28c6 83FF      		sbrs r24,3
 5885 28c8 00C0      		rjmp .L378
 5886 28ca 9091 0000 		lds r25,encoderValue
 5887 28ce 8091 0000 		lds r24,lastEncoderValue.2194
 5888 28d2 9813      		cpse r25,r24
 5889 28d4 00C0      		rjmp .L379
 5890               	.L378:
 5891               	.LBE229:
 5892 28d6 8091 0000 		lds r24,newKeys
 5893               	.LBB230:
 5894 28da 83FF      		sbrs r24,3
 5895 28dc 00C0      		rjmp .L380
 5896               	.L379:
3967:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
 5897               		.loc 1 3967 0
 5898 28de 2091 0000 		lds r18,encoderValue
 5899 28e2 2695      		lsr r18
 5900 28e4 1091 0000 		lds r17,currentBank
 5901 28e8 622F      		mov r22,r18
 5902 28ea 812F      		mov r24,r17
 5903 28ec 2983      		std Y+1,r18
 5904 28ee 0E94 0000 		call MakeNewGranularArray
 5905               	.LVL231:
3968:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
 5906               		.loc 1 3968 0
 5907 28f2 2981      		ldd r18,Y+1
 5908 28f4 44E1      		ldi r20,lo8(20)
 5909 28f6 64E0      		ldi r22,lo8(4)
 5910 28f8 812F      		mov r24,r17
 5911 28fa 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5912               	.LVL232:
 5913               	.L380:
 5914               	.LBE230:
3970:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
 5915               		.loc 1 3970 0
 5916 28fe 8091 0000 		lds r24,keyState
 5917               	.LBB231:
 5918 2902 84FF      		sbrs r24,4
 5919 2904 00C0      		rjmp .L381
3972:WTPA.c        **** 			if(encoderValue!=lastEncoderValue)	// Only change to new values
 5920               		.loc 1 3972 0
 5921 2906 9091 0000 		lds r25,encoderValue
 5922 290a 8091 0000 		lds r24,lastEncoderValue.2194
 5923 290e 9817      		cp r25,r24
 5924 2910 01F0      		breq .L381
3974:WTPA.c        **** 				switch(scaledEncoderValue)
 5925               		.loc 1 3974 0
 5926 2912 8091 0000 		lds r24,scaledEncoderValue
 5927 2916 8130      		cpi r24,lo8(1)
 5928 2918 01F0      		breq .L383
 5929 291a 00F0      		brlo .L382
 5930 291c 8230      		cpi r24,lo8(2)
 5931 291e 01F0      		breq .L384
 5932 2920 8330      		cpi r24,lo8(3)
 5933 2922 01F4      		brne .L381
 5934 2924 00C0      		rjmp .L385
 5935               	.L382:
3977:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
 5936               		.loc 1 3977 0
 5937 2926 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5938 2928 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5939 292a 9093 0000 		sts UpdateOutput+1,r25
 5940 292e 8093 0000 		sts UpdateOutput,r24
3978:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 5941               		.loc 1 3978 0
 5942 2932 20E0      		ldi r18,0
 5943 2934 00C0      		rjmp .L543
 5944               	.L383:
3982:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
 5945               		.loc 1 3982 0
 5946 2936 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 5947 2938 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 5948 293a 9093 0000 		sts UpdateOutput+1,r25
 5949 293e 8093 0000 		sts UpdateOutput,r24
3983:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 5950               		.loc 1 3983 0
 5951 2942 21E0      		ldi r18,lo8(1)
 5952 2944 00C0      		rjmp .L543
 5953               	.L384:
3987:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
 5954               		.loc 1 3987 0
 5955 2946 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 5956 2948 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 5957 294a 9093 0000 		sts UpdateOutput+1,r25
 5958 294e 8093 0000 		sts UpdateOutput,r24
3988:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 5959               		.loc 1 3988 0
 5960 2952 22E0      		ldi r18,lo8(2)
 5961 2954 00C0      		rjmp .L543
 5962               	.L385:
3992:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
 5963               		.loc 1 3992 0
 5964 2956 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 5965 2958 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 5966 295a 9093 0000 		sts UpdateOutput+1,r25
 5967 295e 8093 0000 		sts UpdateOutput,r24
3993:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 5968               		.loc 1 3993 0
 5969 2962 23E0      		ldi r18,lo8(3)
 5970               	.L543:
 5971 2964 46E1      		ldi r20,lo8(22)
 5972 2966 64E0      		ldi r22,lo8(4)
 5973 2968 8091 0000 		lds r24,currentBank
 5974 296c 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5975               	.LVL233:
 5976               	.L381:
 5977               	.LBE231:
4001:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
 5978               		.loc 1 4001 0
 5979 2970 8091 0000 		lds r24,newKeys
 5980               	.LBB232:
 5981 2974 85FF      		sbrs r24,5
 5982 2976 00C0      		rjmp .L360
4003:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
 5983               		.loc 1 4003 0
 5984 2978 8091 0000 		lds r24,currentBank
 5985 297c 43E2      		ldi r20,lo8(35)
 5986 297e 849F      		mul r24,r20
 5987 2980 F001      		movw r30,r0
 5988 2982 1124      		clr __zero_reg__
 5989 2984 E050      		subi r30,lo8(-(bankStates))
 5990 2986 F040      		sbci r31,hi8(-(bankStates))
 5991 2988 9381      		ldd r25,Z+3
 5992 298a 9111      		cpse r25,__zero_reg__
 5993 298c 00C0      		rjmp .L386
4005:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
 5994               		.loc 1 4005 0
 5995 298e 91E0      		ldi r25,lo8(1)
 5996 2990 9383      		std Z+3,r25
4006:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
 5997               		.loc 1 4006 0
 5998 2992 20E4      		ldi r18,lo8(64)
 5999 2994 00C0      		rjmp .L544
 6000               	.L386:
4010:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
 6001               		.loc 1 4010 0
 6002 2996 1382      		std Z+3,__zero_reg__
4011:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
 6003               		.loc 1 4011 0
 6004 2998 20E0      		ldi r18,0
 6005               	.L544:
 6006 299a 41E1      		ldi r20,lo8(17)
 6007 299c 64E0      		ldi r22,lo8(4)
 6008 299e 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6009               	.LVL234:
4014:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
 6010               		.loc 1 4014 0
 6011 29a2 8091 0000 		lds r24,currentBank
 6012 29a6 0E94 0000 		call UpdateAdjustedSampleAddresses
 6013               	.LVL235:
 6014 29aa 00C0      		rjmp .L360
 6015               	.L357:
4020:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
 6016               		.loc 1 4020 0
 6017 29ac 87FF      		sbrs r24,7
 6018 29ae 00C0      		rjmp .L388
4022:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
 6019               		.loc 1 4022 0
 6020 29b0 8091 0000 		lds r24,keyState
 6021 29b4 80FF      		sbrs r24,0
 6022 29b6 00C0      		rjmp .L389
4024:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
 6023               		.loc 1 4024 0
 6024 29b8 1091 0000 		lds r17,currentBank
 6025 29bc 83E2      		ldi r24,lo8(35)
 6026 29be 189F      		mul r17,r24
 6027 29c0 F001      		movw r30,r0
 6028 29c2 1124      		clr __zero_reg__
 6029 29c4 E050      		subi r30,lo8(-(bankStates))
 6030 29c6 F040      		sbci r31,hi8(-(bankStates))
 6031 29c8 848D      		ldd r24,Z+28
 6032 29ca 0091 0000 		lds r16,encoderValue
 6033 29ce 8017      		cp r24,r16
 6034 29d0 01F0      		breq .L390
 6035               	.LVL236:
 6036               	.LBB220:
 6037               	.LBB221:
3858:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6038               		.loc 1 3858 0
 6039 29d2 048F      		std Z+28,r16
3859:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6040               		.loc 1 3859 0
 6041 29d4 812F      		mov r24,r17
 6042 29d6 0E94 0000 		call UpdateAdjustedSampleAddresses
 6043               	.LVL237:
 6044               	.LBE221:
 6045               	.LBE220:
4027:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
 6046               		.loc 1 4027 0
 6047 29da 202F      		mov r18,r16
 6048 29dc 2695      		lsr r18
 6049 29de 4CE1      		ldi r20,lo8(28)
 6050 29e0 00C0      		rjmp .L545
 6051               	.LVL238:
 6052               	.L389:
4030:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
 6053               		.loc 1 4030 0
 6054 29e2 81FF      		sbrs r24,1
 6055 29e4 00C0      		rjmp .L391
4032:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
 6056               		.loc 1 4032 0
 6057 29e6 1091 0000 		lds r17,currentBank
 6058 29ea 93E2      		ldi r25,lo8(35)
 6059 29ec 199F      		mul r17,r25
 6060 29ee F001      		movw r30,r0
 6061 29f0 1124      		clr __zero_reg__
 6062 29f2 E050      		subi r30,lo8(-(bankStates))
 6063 29f4 F040      		sbci r31,hi8(-(bankStates))
 6064 29f6 858D      		ldd r24,Z+29
 6065 29f8 0091 0000 		lds r16,encoderValue
 6066 29fc 8017      		cp r24,r16
 6067 29fe 01F0      		breq .L390
 6068               	.LVL239:
 6069               	.LBB222:
 6070               	.LBB223:
3867:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6071               		.loc 1 3867 0
 6072 2a00 058F      		std Z+29,r16
3868:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6073               		.loc 1 3868 0
 6074 2a02 812F      		mov r24,r17
 6075 2a04 0E94 0000 		call UpdateAdjustedSampleAddresses
 6076               	.LVL240:
 6077               	.LBE223:
 6078               	.LBE222:
4035:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
 6079               		.loc 1 4035 0
 6080 2a08 202F      		mov r18,r16
 6081 2a0a 2695      		lsr r18
 6082 2a0c 4DE1      		ldi r20,lo8(29)
 6083 2a0e 00C0      		rjmp .L545
 6084               	.LVL241:
 6085               	.L391:
4038:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
 6086               		.loc 1 4038 0
 6087 2a10 82FF      		sbrs r24,2
 6088 2a12 00C0      		rjmp .L390
4040:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
 6089               		.loc 1 4040 0
 6090 2a14 1091 0000 		lds r17,currentBank
 6091 2a18 A3E2      		ldi r26,lo8(35)
 6092 2a1a 1A9F      		mul r17,r26
 6093 2a1c F001      		movw r30,r0
 6094 2a1e 1124      		clr __zero_reg__
 6095 2a20 E050      		subi r30,lo8(-(bankStates))
 6096 2a22 F040      		sbci r31,hi8(-(bankStates))
 6097 2a24 868D      		ldd r24,Z+30
 6098 2a26 0091 0000 		lds r16,encoderValue
 6099 2a2a 8017      		cp r24,r16
 6100 2a2c 01F0      		breq .L390
 6101               	.LVL242:
 6102               	.LBB224:
 6103               	.LBB225:
3876:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 6104               		.loc 1 3876 0
 6105 2a2e 068F      		std Z+30,r16
3877:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6106               		.loc 1 3877 0
 6107 2a30 812F      		mov r24,r17
 6108 2a32 0E94 0000 		call UpdateAdjustedSampleAddresses
 6109               	.LVL243:
 6110               	.LBE225:
 6111               	.LBE224:
4043:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
 6112               		.loc 1 4043 0
 6113 2a36 202F      		mov r18,r16
 6114 2a38 2695      		lsr r18
 6115 2a3a 4EE1      		ldi r20,lo8(30)
 6116               	.LVL244:
 6117               	.L545:
 6118 2a3c 64E0      		ldi r22,lo8(4)
 6119 2a3e 812F      		mov r24,r17
 6120 2a40 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6121               	.LVL245:
 6122               	.L390:
 6123               	.LBE232:
4047:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
 6124               		.loc 1 4047 0
 6125 2a44 8091 0000 		lds r24,newKeys
 6126               	.LBB233:
 6127 2a48 83FF      		sbrs r24,3
 6128 2a4a 00C0      		rjmp .L360
4050:WTPA.c        **** 			PlaySampleFromSd(0);			// @@@ stream from slot 0
 6129               		.loc 1 4050 0
 6130 2a4c 80E0      		ldi r24,0
 6131 2a4e 90E0      		ldi r25,0
 6132 2a50 0E94 0000 		call PlaySampleFromSd
 6133               	.LVL246:
 6134 2a54 00C0      		rjmp .L360
 6135               	.L388:
4063:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
 6136               		.loc 1 4063 0
 6137 2a56 8091 0000 		lds r24,newKeys
 6138 2a5a 80FF      		sbrs r24,0
 6139 2a5c 00C0      		rjmp .L392
4065:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6140               		.loc 1 4065 0
 6141 2a5e 1091 0000 		lds r17,currentBank
 6142 2a62 B3E2      		ldi r27,lo8(35)
 6143 2a64 1B9F      		mul r17,r27
 6144 2a66 7001      		movw r14,r0
 6145 2a68 1124      		clr __zero_reg__
 6146 2a6a E0E0      		ldi r30,lo8(bankStates)
 6147 2a6c F0E0      		ldi r31,hi8(bankStates)
 6148 2a6e EE0E      		add r14,r30
 6149 2a70 FF1E      		adc r15,r31
 6150 2a72 D701      		movw r26,r14
 6151 2a74 8C91      		ld r24,X
4067:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6152               		.loc 1 4067 0
 6153 2a76 40E0      		ldi r20,0
 6154 2a78 50E0      		ldi r21,0
 6155 2a7a 61E0      		ldi r22,lo8(1)
4065:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 6156               		.loc 1 4065 0
 6157 2a7c 8330      		cpi r24,lo8(3)
 6158 2a7e 01F4      		brne .L393
4067:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6159               		.loc 1 4067 0
 6160 2a80 812F      		mov r24,r17
 6161 2a82 0E94 0000 		call StartPlayback
 6162               	.LVL247:
4068:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6163               		.loc 1 4068 0
 6164 2a86 F701      		movw r30,r14
 6165 2a88 1182      		std Z+1,__zero_reg__
4069:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6166               		.loc 1 4069 0
 6167 2a8a 20E4      		ldi r18,lo8(64)
 6168 2a8c 40E3      		ldi r20,lo8(48)
 6169 2a8e 61E0      		ldi r22,lo8(1)
 6170 2a90 00C0      		rjmp .L555
 6171               	.L393:
4073:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
 6172               		.loc 1 4073 0
 6173 2a92 812F      		mov r24,r17
 6174 2a94 0E94 0000 		call StartRecording
 6175               	.LVL248:
4074:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
 6176               		.loc 1 4074 0
 6177 2a98 20E3      		ldi r18,lo8(48)
 6178 2a9a 43E0      		ldi r20,lo8(3)
 6179 2a9c 64E0      		ldi r22,lo8(4)
 6180               	.L555:
 6181 2a9e 812F      		mov r24,r17
 6182 2aa0 00C0      		rjmp .L546
 6183               	.L392:
4077:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
 6184               		.loc 1 4077 0
 6185 2aa2 81FF      		sbrs r24,1
 6186 2aa4 00C0      		rjmp .L394
4079:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
 6187               		.loc 1 4079 0
 6188 2aa6 F090 0000 		lds r15,currentBank
 6189 2aaa F3E2      		ldi r31,lo8(35)
 6190 2aac FF9E      		mul r15,r31
 6191 2aae 6001      		movw r12,r0
 6192 2ab0 1124      		clr __zero_reg__
 6193 2ab2 80E0      		ldi r24,lo8(bankStates)
 6194 2ab4 90E0      		ldi r25,hi8(bankStates)
 6195 2ab6 C80E      		add r12,r24
 6196 2ab8 D91E      		adc r13,r25
 6197 2aba D601      		movw r26,r12
 6198 2abc 8C91      		ld r24,X
 6199 2abe 8530      		cpi r24,lo8(5)
 6200 2ac0 01F4      		brne .L395
4081:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
 6201               		.loc 1 4081 0
 6202 2ac2 40E0      		ldi r20,0
 6203 2ac4 50E0      		ldi r21,0
 6204 2ac6 61E0      		ldi r22,lo8(1)
 6205 2ac8 8F2D      		mov r24,r15
 6206 2aca 0E94 0000 		call ContinuePlayback
 6207               	.LVL249:
4082:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6208               		.loc 1 4082 0
 6209 2ace F601      		movw r30,r12
 6210 2ad0 1182      		std Z+1,__zero_reg__
4083:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
 6211               		.loc 1 4083 0
 6212 2ad2 20E0      		ldi r18,0
 6213 2ad4 00C0      		rjmp .L557
 6214               	.L395:
4087:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
 6215               		.loc 1 4087 0
 6216 2ad6 D601      		movw r26,r12
 6217 2ad8 5096      		adiw r26,16
 6218 2ada 0D91      		ld r16,X+
 6219 2adc 1D91      		ld r17,X+
 6220 2ade 2D91      		ld r18,X+
 6221 2ae0 3C91      		ld r19,X
 6222 2ae2 5397      		sbiw r26,16+3
 6223 2ae4 1C96      		adiw r26,12
 6224 2ae6 4D91      		ld r20,X+
 6225 2ae8 5D91      		ld r21,X+
 6226 2aea 6D91      		ld r22,X+
 6227 2aec 7C91      		ld r23,X
 6228 2aee 1F97      		sbiw r26,12+3
 6229 2af0 0417      		cp r16,r20
 6230 2af2 1507      		cpc r17,r21
 6231 2af4 2607      		cpc r18,r22
 6232 2af6 3707      		cpc r19,r23
 6233 2af8 01F4      		brne .+2
 6234 2afa 00C0      		rjmp .L360
4089:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
 6235               		.loc 1 4089 0
 6236 2afc 40E0      		ldi r20,0
 6237 2afe 50E0      		ldi r21,0
 6238 2b00 61E0      		ldi r22,lo8(1)
 6239 2b02 8F2D      		mov r24,r15
 6240 2b04 0E94 0000 		call StartOverdub
 6241               	.LVL250:
4090:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
 6242               		.loc 1 4090 0
 6243 2b08 20E3      		ldi r18,lo8(48)
 6244               	.L557:
 6245 2b0a 49E0      		ldi r20,lo8(9)
 6246 2b0c 64E0      		ldi r22,lo8(4)
 6247 2b0e 00C0      		rjmp .L556
 6248               	.L394:
4094:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
 6249               		.loc 1 4094 0
 6250 2b10 82FF      		sbrs r24,2
 6251 2b12 00C0      		rjmp .L396
4096:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6252               		.loc 1 4096 0
 6253 2b14 F090 0000 		lds r15,currentBank
 6254 2b18 B3E2      		ldi r27,lo8(35)
 6255 2b1a FB9E      		mul r15,r27
 6256 2b1c 6001      		movw r12,r0
 6257 2b1e 1124      		clr __zero_reg__
 6258 2b20 E0E0      		ldi r30,lo8(bankStates)
 6259 2b22 F0E0      		ldi r31,hi8(bankStates)
 6260 2b24 CE0E      		add r12,r30
 6261 2b26 DF1E      		adc r13,r31
 6262 2b28 D601      		movw r26,r12
 6263 2b2a 5096      		adiw r26,16
 6264 2b2c 0D91      		ld r16,X+
 6265 2b2e 1D91      		ld r17,X+
 6266 2b30 2D91      		ld r18,X+
 6267 2b32 3C91      		ld r19,X
 6268 2b34 5397      		sbiw r26,16+3
 6269 2b36 1C96      		adiw r26,12
 6270 2b38 4D91      		ld r20,X+
 6271 2b3a 5D91      		ld r21,X+
 6272 2b3c 6D91      		ld r22,X+
 6273 2b3e 7C91      		ld r23,X
 6274 2b40 1F97      		sbiw r26,12+3
 6275 2b42 0417      		cp r16,r20
 6276 2b44 1507      		cpc r17,r21
 6277 2b46 2607      		cpc r18,r22
 6278 2b48 3707      		cpc r19,r23
 6279 2b4a 01F4      		brne .+2
 6280 2b4c 00C0      		rjmp .L360
4098:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
 6281               		.loc 1 4098 0
 6282 2b4e 40E0      		ldi r20,0
 6283 2b50 50E0      		ldi r21,0
 6284 2b52 61E0      		ldi r22,lo8(1)
 6285 2b54 8F2D      		mov r24,r15
 6286 2b56 0E94 0000 		call StartPlayback
 6287               	.LVL251:
4099:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6288               		.loc 1 4099 0
 6289 2b5a F601      		movw r30,r12
 6290 2b5c 1182      		std Z+1,__zero_reg__
 6291 2b5e 00C0      		rjmp .L558
 6292               	.L396:
4103:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
 6293               		.loc 1 4103 0
 6294 2b60 83FF      		sbrs r24,3
 6295 2b62 00C0      		rjmp .L397
4105:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 6296               		.loc 1 4105 0
 6297 2b64 E090 0000 		lds r14,currentBank
 6298 2b68 F3E2      		ldi r31,lo8(35)
 6299 2b6a EF9E      		mul r14,r31
 6300 2b6c 6001      		movw r12,r0
 6301 2b6e 1124      		clr __zero_reg__
 6302 2b70 80E0      		ldi r24,lo8(bankStates)
 6303 2b72 90E0      		ldi r25,hi8(bankStates)
 6304 2b74 C80E      		add r12,r24
 6305 2b76 D91E      		adc r13,r25
 6306 2b78 D601      		movw r26,r12
 6307 2b7a 5096      		adiw r26,16
 6308 2b7c 0D91      		ld r16,X+
 6309 2b7e 1D91      		ld r17,X+
 6310 2b80 2D91      		ld r18,X+
 6311 2b82 3C91      		ld r19,X
 6312 2b84 5397      		sbiw r26,16+3
 6313 2b86 1C96      		adiw r26,12
 6314 2b88 4D91      		ld r20,X+
 6315 2b8a 5D91      		ld r21,X+
 6316 2b8c 6D91      		ld r22,X+
 6317 2b8e 7C91      		ld r23,X
 6318 2b90 1F97      		sbiw r26,12+3
 6319 2b92 0417      		cp r16,r20
 6320 2b94 1507      		cpc r17,r21
 6321 2b96 2607      		cpc r18,r22
 6322 2b98 3707      		cpc r19,r23
 6323 2b9a 01F4      		brne .+2
 6324 2b9c 00C0      		rjmp .L360
4107:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
 6325               		.loc 1 4107 0
 6326 2b9e 40E0      		ldi r20,0
 6327 2ba0 50E0      		ldi r21,0
 6328 2ba2 61E0      		ldi r22,lo8(1)
 6329 2ba4 8E2D      		mov r24,r14
 6330 2ba6 0E94 0000 		call StartPlayback
 6331               	.LVL252:
4108:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
 6332               		.loc 1 4108 0
 6333 2baa F601      		movw r30,r12
 6334 2bac F182      		std Z+1,r15
4109:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6335               		.loc 1 4109 0
 6336 2bae 20E4      		ldi r18,lo8(64)
 6337 2bb0 40E3      		ldi r20,lo8(48)
 6338 2bb2 61E0      		ldi r22,lo8(1)
 6339 2bb4 8E2D      		mov r24,r14
 6340               	.L546:
 6341 2bb6 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6342               	.LVL253:
 6343 2bba 00C0      		rjmp .L360
 6344               	.L397:
4112:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
 6345               		.loc 1 4112 0
 6346 2bbc 84FF      		sbrs r24,4
 6347 2bbe 00C0      		rjmp .L398
4114:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
 6348               		.loc 1 4114 0
 6349 2bc0 F090 0000 		lds r15,currentBank
 6350 2bc4 2F2D      		mov r18,r15
 6351 2bc6 30E0      		ldi r19,0
 6352 2bc8 43E2      		ldi r20,lo8(35)
 6353 2bca F49E      		mul r15,r20
 6354 2bcc F001      		movw r30,r0
 6355 2bce 1124      		clr __zero_reg__
 6356 2bd0 E050      		subi r30,lo8(-(bankStates))
 6357 2bd2 F040      		sbci r31,hi8(-(bankStates))
 6358 2bd4 8081      		ld r24,Z
 6359 2bd6 8111      		cpse r24,__zero_reg__
 6360 2bd8 00C0      		rjmp .L399
4116:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 6361               		.loc 1 4116 0
 6362 2bda 83E2      		ldi r24,lo8(35)
 6363 2bdc 829F      		mul r24,r18
 6364 2bde F001      		movw r30,r0
 6365 2be0 839F      		mul r24,r19
 6366 2be2 F00D      		add r31,r0
 6367 2be4 1124      		clr __zero_reg__
 6368 2be6 E050      		subi r30,lo8(-(bankStates))
 6369 2be8 F040      		sbci r31,hi8(-(bankStates))
 6370 2bea 0089      		ldd r16,Z+16
 6371 2bec 1189      		ldd r17,Z+17
 6372 2bee 2289      		ldd r18,Z+18
 6373 2bf0 3389      		ldd r19,Z+19
 6374 2bf2 4485      		ldd r20,Z+12
 6375 2bf4 5585      		ldd r21,Z+13
 6376 2bf6 6685      		ldd r22,Z+14
 6377 2bf8 7785      		ldd r23,Z+15
 6378 2bfa 0417      		cp r16,r20
 6379 2bfc 1507      		cpc r17,r21
 6380 2bfe 2607      		cpc r18,r22
 6381 2c00 3707      		cpc r19,r23
 6382 2c02 01F0      		breq .L360
4118:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
 6383               		.loc 1 4118 0
 6384 2c04 40E0      		ldi r20,0
 6385 2c06 50E0      		ldi r21,0
 6386 2c08 61E0      		ldi r22,lo8(1)
 6387 2c0a 8F2D      		mov r24,r15
 6388 2c0c 0E94 0000 		call ContinuePlayback
 6389               	.LVL254:
 6390               	.L558:
4119:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
 6391               		.loc 1 4119 0
 6392 2c10 20E4      		ldi r18,lo8(64)
 6393 2c12 40E3      		ldi r20,lo8(48)
 6394 2c14 61E0      		ldi r22,lo8(1)
 6395 2c16 00C0      		rjmp .L556
 6396               	.L399:
4124:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
 6397               		.loc 1 4124 0
 6398 2c18 83E2      		ldi r24,lo8(35)
 6399 2c1a 829F      		mul r24,r18
 6400 2c1c F001      		movw r30,r0
 6401 2c1e 839F      		mul r24,r19
 6402 2c20 F00D      		add r31,r0
 6403 2c22 1124      		clr __zero_reg__
 6404 2c24 E050      		subi r30,lo8(-(bankStates))
 6405 2c26 F040      		sbci r31,hi8(-(bankStates))
 6406 2c28 1082      		st Z,__zero_reg__
4125:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
 6407               		.loc 1 4125 0
 6408 2c2a 1186      		std Z+9,__zero_reg__
4126:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
 6409               		.loc 1 4126 0
 6410 2c2c 20E0      		ldi r18,0
 6411 2c2e 40E3      		ldi r20,lo8(48)
 6412 2c30 62E0      		ldi r22,lo8(2)
 6413               	.L556:
 6414 2c32 8F2D      		mov r24,r15
 6415 2c34 00C0      		rjmp .L546
 6416               	.L398:
4130:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
 6417               		.loc 1 4130 0
 6418 2c36 85FF      		sbrs r24,5
 6419 2c38 00C0      		rjmp .L360
4132:WTPA.c        **** 			currentBank++;
 6420               		.loc 1 4132 0
 6421 2c3a 8091 0000 		lds r24,currentBank
 6422 2c3e 8F5F      		subi r24,lo8(-(1))
 6423 2c40 8093 0000 		sts currentBank,r24
4133:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
 6424               		.loc 1 4133 0
 6425 2c44 8230      		cpi r24,lo8(2)
 6426 2c46 00F0      		brlo .L360
4135:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
 6427               		.loc 1 4135 0
 6428 2c48 1092 0000 		sts currentBank,__zero_reg__
 6429               	.L360:
4140:WTPA.c        **** 	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
 6430               		.loc 1 4140 0
 6431 2c4c 8091 0000 		lds r24,encoderValue
 6432 2c50 8093 0000 		sts lastEncoderValue.2194,r24
 6433               	.LBE233:
 6434               	.LBE206:
4218:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
 6435               		.loc 1 4218 0
 6436 2c54 8091 0000 		lds r24,midiMessagesInIncomingFifo
 6437 2c58 8823      		tst r24
 6438 2c5a 01F4      		brne .+2
 6439 2c5c 00C0      		rjmp .L355
4220:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
 6440               		.loc 1 4220 0
 6441 2c5e 80E0      		ldi r24,lo8(currentMidiMessage.2205)
 6442 2c60 90E0      		ldi r25,hi8(currentMidiMessage.2205)
 6443 2c62 0E94 0000 		call GetMidiMessageFromIncomingFifo
 6444               	.LVL255:
4227:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
 6445               		.loc 1 4227 0
 6446 2c66 8091 0000 		lds r24,currentMidiMessage.2205+1
 6447 2c6a 8230      		cpi r24,lo8(2)
 6448 2c6c 01F4      		brne .L401
4229:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6449               		.loc 1 4229 0
 6450 2c6e E091 0000 		lds r30,currentMidiMessage.2205
 6451 2c72 8E2F      		mov r24,r30
 6452 2c74 90E0      		ldi r25,0
 6453 2c76 A3E2      		ldi r26,lo8(35)
 6454 2c78 EA9F      		mul r30,r26
 6455 2c7a F001      		movw r30,r0
 6456 2c7c 1124      		clr __zero_reg__
 6457 2c7e E050      		subi r30,lo8(-(bankStates))
 6458 2c80 F040      		sbci r31,hi8(-(bankStates))
 6459 2c82 2081      		ld r18,Z
 6460 2c84 2430      		cpi r18,lo8(4)
 6461 2c86 01F0      		breq .L402
4229:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6462               		.loc 1 4229 0 is_stmt 0 discriminator 1
 6463 2c88 2081      		ld r18,Z
 6464 2c8a 2230      		cpi r18,lo8(2)
 6465 2c8c 01F0      		breq .+2
 6466 2c8e 00C0      		rjmp .L355
 6467               	.L402:
4231:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
 6468               		.loc 1 4231 0 is_stmt 1
 6469 2c90 FC01      		movw r30,r24
 6470 2c92 E050      		subi r30,lo8(-(currentNoteOn.2206))
 6471 2c94 F040      		sbci r31,hi8(-(currentNoteOn.2206))
 6472 2c96 3091 0000 		lds r19,currentMidiMessage.2205+2
 6473 2c9a 2081      		ld r18,Z
 6474 2c9c 3213      		cpse r19,r18
 6475 2c9e 00C0      		rjmp .L355
4233:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
 6476               		.loc 1 4233 0
 6477 2ca0 23E2      		ldi r18,lo8(35)
 6478 2ca2 289F      		mul r18,r24
 6479 2ca4 F001      		movw r30,r0
 6480 2ca6 299F      		mul r18,r25
 6481 2ca8 F00D      		add r31,r0
 6482 2caa 1124      		clr __zero_reg__
 6483 2cac E050      		subi r30,lo8(-(bankStates))
 6484 2cae F040      		sbci r31,hi8(-(bankStates))
 6485 2cb0 00C0      		rjmp .L549
 6486               	.L401:
4238:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
 6487               		.loc 1 4238 0
 6488 2cb2 8130      		cpi r24,lo8(1)
 6489 2cb4 01F0      		breq .+2
 6490 2cb6 00C0      		rjmp .L403
4240:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
 6491               		.loc 1 4240 0
 6492 2cb8 A091 0000 		lds r26,currentMidiMessage.2205
 6493 2cbc 2A2F      		mov r18,r26
 6494 2cbe 30E0      		ldi r19,0
 6495 2cc0 8091 0000 		lds r24,currentMidiMessage.2205+2
 6496 2cc4 F901      		movw r30,r18
 6497 2cc6 E050      		subi r30,lo8(-(currentNoteOn.2206))
 6498 2cc8 F040      		sbci r31,hi8(-(currentNoteOn.2206))
 6499 2cca 8083      		st Z,r24
4242:WTPA.c        **** 				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
 6500               		.loc 1 4242 0
 6501 2ccc F901      		movw r30,r18
 6502 2cce E050      		subi r30,lo8(-(realtimeOn.2207))
 6503 2cd0 F040      		sbci r31,hi8(-(realtimeOn.2207))
 6504 2cd2 9081      		ld r25,Z
 6505 2cd4 9923      		tst r25
 6506 2cd6 01F0      		breq .L404
 6507               	.LVL256:
 6508               	.LBB234:
 6509               	.LBB235:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6510               		.loc 1 3294 0
 6511 2cd8 6CE0      		ldi r22,lo8(12)
 6512 2cda 0E94 0000 		call __udivmodqi4
 6513               	.LVL257:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6514               		.loc 1 3296 0
 6515 2cde E92F      		mov r30,r25
 6516 2ce0 F0E0      		ldi r31,0
 6517 2ce2 EE0F      		lsl r30
 6518 2ce4 FF1F      		rol r31
 6519 2ce6 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6520 2ce8 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6521 2cea 4081      		ld r20,Z
 6522 2cec 5181      		ldd r21,Z+1
 6523 2cee 00C0      		rjmp 2f
 6524               		1:
 6525 2cf0 5695      		lsr r21
 6526 2cf2 4795      		ror r20
 6527               		2:
 6528 2cf4 8A95      		dec r24
 6529 2cf6 02F4      		brpl 1b
 6530               	.LBE235:
 6531               	.LBE234:
4244:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
 6532               		.loc 1 4244 0
 6533 2cf8 62E0      		ldi r22,lo8(2)
 6534 2cfa 8A2F      		mov r24,r26
 6535               	.LVL258:
 6536 2cfc 0E94 0000 		call StartRealtime
 6537               	.LVL259:
 6538 2d00 00C0      		rjmp .L355
 6539               	.L404:
4248:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
 6540               		.loc 1 4248 0
 6541 2d02 93E2      		ldi r25,lo8(35)
 6542 2d04 929F      		mul r25,r18
 6543 2d06 F001      		movw r30,r0
 6544 2d08 939F      		mul r25,r19
 6545 2d0a F00D      		add r31,r0
 6546 2d0c 1124      		clr __zero_reg__
 6547 2d0e E050      		subi r30,lo8(-(bankStates))
 6548 2d10 F040      		sbci r31,hi8(-(bankStates))
 6549 2d12 0089      		ldd r16,Z+16
 6550 2d14 1189      		ldd r17,Z+17
 6551 2d16 2289      		ldd r18,Z+18
 6552 2d18 3389      		ldd r19,Z+19
 6553 2d1a 4485      		ldd r20,Z+12
 6554 2d1c 5585      		ldd r21,Z+13
 6555 2d1e 6685      		ldd r22,Z+14
 6556 2d20 7785      		ldd r23,Z+15
 6557 2d22 0417      		cp r16,r20
 6558 2d24 1507      		cpc r17,r21
 6559 2d26 2607      		cpc r18,r22
 6560 2d28 3707      		cpc r19,r23
 6561 2d2a 01F4      		brne .+2
 6562 2d2c 00C0      		rjmp .L355
 6563               	.LVL260:
 6564               	.LBB236:
 6565               	.LBB237:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6566               		.loc 1 3294 0
 6567 2d2e 6CE0      		ldi r22,lo8(12)
 6568 2d30 0E94 0000 		call __udivmodqi4
 6569               	.LVL261:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6570               		.loc 1 3296 0
 6571 2d34 E92F      		mov r30,r25
 6572 2d36 F0E0      		ldi r31,0
 6573 2d38 EE0F      		lsl r30
 6574 2d3a FF1F      		rol r31
 6575 2d3c E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6576 2d3e F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6577 2d40 4081      		ld r20,Z
 6578 2d42 5181      		ldd r21,Z+1
 6579 2d44 00C0      		rjmp 2f
 6580               		1:
 6581 2d46 5695      		lsr r21
 6582 2d48 4795      		ror r20
 6583               		2:
 6584 2d4a 8A95      		dec r24
 6585 2d4c 02F4      		brpl 1b
 6586               	.LBE237:
 6587               	.LBE236:
4250:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
 6588               		.loc 1 4250 0
 6589 2d4e 62E0      		ldi r22,lo8(2)
 6590 2d50 8A2F      		mov r24,r26
 6591               	.LVL262:
 6592 2d52 0E94 0000 		call StartPlayback
 6593               	.LVL263:
 6594 2d56 00C0      		rjmp .L355
 6595               	.L403:
4255:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
 6596               		.loc 1 4255 0
 6597 2d58 8430      		cpi r24,lo8(4)
 6598 2d5a 01F0      		breq .+2
 6599 2d5c 00C0      		rjmp .L405
4257:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
 6600               		.loc 1 4257 0
 6601 2d5e 8091 0000 		lds r24,currentMidiMessage.2205+2
 6602 2d62 90E0      		ldi r25,0
 6603 2d64 FC01      		movw r30,r24
 6604 2d66 3397      		sbiw r30,3
 6605 2d68 EC31      		cpi r30,28
 6606 2d6a F105      		cpc r31,__zero_reg__
 6607 2d6c 00F0      		brlo .+2
 6608 2d6e 00C0      		rjmp .L355
 6609 2d70 E050      		subi r30,lo8(-(gs(.L425)))
 6610 2d72 F040      		sbci r31,hi8(-(gs(.L425)))
 6611 2d74 0C94 0000 		jmp __tablejump2__
 6612               		.section	.progmem.gcc_sw_table,"a",@progbits
 6613               		.p2align	1
 6614               	.L425:
 6615 0000 0000      		.word gs(.L406)
 6616 0002 0000      		.word gs(.L355)
 6617 0004 0000      		.word gs(.L355)
 6618 0006 0000      		.word gs(.L355)
 6619 0008 0000      		.word gs(.L355)
 6620 000a 0000      		.word gs(.L355)
 6621 000c 0000      		.word gs(.L407)
 6622 000e 0000      		.word gs(.L355)
 6623 0010 0000      		.word gs(.L355)
 6624 0012 0000      		.word gs(.L355)
 6625 0014 0000      		.word gs(.L355)
 6626 0016 0000      		.word gs(.L408)
 6627 0018 0000      		.word gs(.L409)
 6628 001a 0000      		.word gs(.L410)
 6629 001c 0000      		.word gs(.L411)
 6630 001e 0000      		.word gs(.L412)
 6631 0020 0000      		.word gs(.L413)
 6632 0022 0000      		.word gs(.L414)
 6633 0024 0000      		.word gs(.L415)
 6634 0026 0000      		.word gs(.L416)
 6635 0028 0000      		.word gs(.L417)
 6636 002a 0000      		.word gs(.L418)
 6637 002c 0000      		.word gs(.L419)
 6638 002e 0000      		.word gs(.L420)
 6639 0030 0000      		.word gs(.L421)
 6640 0032 0000      		.word gs(.L422)
 6641 0034 0000      		.word gs(.L423)
 6642 0036 0000      		.word gs(.L424)
 6643               		.text
 6644               	.L406:
4260:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6645               		.loc 1 4260 0
 6646 2d78 9091 0000 		lds r25,currentMidiMessage.2205+3
 6647 2d7c 8091 0000 		lds r24,currentMidiMessage.2205
 6648 2d80 9923      		tst r25
 6649 2d82 01F0      		breq .L426
4262:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
 6650               		.loc 1 4262 0
 6651 2d84 A82F      		mov r26,r24
 6652 2d86 B0E0      		ldi r27,0
 6653 2d88 AA0F      		lsl r26
 6654 2d8a BB1F      		rol r27
 6655 2d8c A050      		subi r26,lo8(-(theMidiRecordRate))
 6656 2d8e B040      		sbci r27,hi8(-(theMidiRecordRate))
 6657 2d90 4D91      		ld r20,X+
 6658 2d92 5C91      		ld r21,X
 6659 2d94 62E0      		ldi r22,lo8(2)
 6660 2d96 0E94 0000 		call StartRecording
 6661               	.LVL264:
 6662 2d9a 00C0      		rjmp .L559
 6663               	.L426:
4265:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
 6664               		.loc 1 4265 0
 6665 2d9c B3E2      		ldi r27,lo8(35)
 6666 2d9e 8B9F      		mul r24,r27
 6667 2da0 F001      		movw r30,r0
 6668 2da2 1124      		clr __zero_reg__
 6669 2da4 E050      		subi r30,lo8(-(bankStates))
 6670 2da6 F040      		sbci r31,hi8(-(bankStates))
 6671 2da8 8081      		ld r24,Z
 6672 2daa 8330      		cpi r24,lo8(3)
 6673 2dac 01F0      		breq .+2
 6674 2dae 00C0      		rjmp .L355
 6675               	.L549:
4267:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 6676               		.loc 1 4267 0
 6677 2db0 1082      		st Z,__zero_reg__
4268:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 6678               		.loc 1 4268 0
 6679 2db2 1186      		std Z+9,__zero_reg__
 6680 2db4 00C0      		rjmp .L355
 6681               	.L407:
4273:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6682               		.loc 1 4273 0
 6683 2db6 9091 0000 		lds r25,currentMidiMessage.2205+3
 6684 2dba 8091 0000 		lds r24,currentMidiMessage.2205
 6685 2dbe 9923      		tst r25
 6686 2dc0 01F0      		breq .L427
4275:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
 6687               		.loc 1 4275 0
 6688 2dc2 A82F      		mov r26,r24
 6689 2dc4 B0E0      		ldi r27,0
 6690 2dc6 23E2      		ldi r18,lo8(35)
 6691 2dc8 829F      		mul r24,r18
 6692 2dca F001      		movw r30,r0
 6693 2dcc 1124      		clr __zero_reg__
 6694 2dce E050      		subi r30,lo8(-(bankStates))
 6695 2dd0 F040      		sbci r31,hi8(-(bankStates))
 6696 2dd2 0089      		ldd r16,Z+16
 6697 2dd4 1189      		ldd r17,Z+17
 6698 2dd6 2289      		ldd r18,Z+18
 6699 2dd8 3389      		ldd r19,Z+19
 6700 2dda 4485      		ldd r20,Z+12
 6701 2ddc 5585      		ldd r21,Z+13
 6702 2dde 6685      		ldd r22,Z+14
 6703 2de0 7785      		ldd r23,Z+15
 6704 2de2 0417      		cp r16,r20
 6705 2de4 1507      		cpc r17,r21
 6706 2de6 2607      		cpc r18,r22
 6707 2de8 3707      		cpc r19,r23
 6708 2dea 01F4      		brne .+2
 6709 2dec 00C0      		rjmp .L355
4277:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
 6710               		.loc 1 4277 0
 6711 2dee FD01      		movw r30,r26
 6712 2df0 E050      		subi r30,lo8(-(currentNoteOn.2206))
 6713 2df2 F040      		sbci r31,hi8(-(currentNoteOn.2206))
 6714 2df4 4081      		ld r20,Z
 6715 2df6 50E0      		ldi r21,0
 6716 2df8 62E0      		ldi r22,lo8(2)
 6717 2dfa 0E94 0000 		call StartOverdub
 6718               	.LVL265:
 6719               	.L559:
4278:WTPA.c        **** 							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to pla
 6720               		.loc 1 4278 0
 6721 2dfe E091 0000 		lds r30,currentMidiMessage.2205
 6722 2e02 F0E0      		ldi r31,0
 6723 2e04 00C0      		rjmp .L550
 6724               	.L427:
4281:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
 6725               		.loc 1 4281 0
 6726 2e06 282F      		mov r18,r24
 6727 2e08 30E0      		ldi r19,0
 6728 2e0a 43E2      		ldi r20,lo8(35)
 6729 2e0c 849F      		mul r24,r20
 6730 2e0e F001      		movw r30,r0
 6731 2e10 1124      		clr __zero_reg__
 6732 2e12 E050      		subi r30,lo8(-(bankStates))
 6733 2e14 F040      		sbci r31,hi8(-(bankStates))
 6734 2e16 9081      		ld r25,Z
 6735 2e18 9530      		cpi r25,lo8(5)
 6736 2e1a 01F0      		breq .+2
 6737 2e1c 00C0      		rjmp .L355
4283:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
 6738               		.loc 1 4283 0
 6739 2e1e F901      		movw r30,r18
 6740 2e20 E050      		subi r30,lo8(-(currentNoteOn.2206))
 6741 2e22 F040      		sbci r31,hi8(-(currentNoteOn.2206))
 6742 2e24 4081      		ld r20,Z
 6743 2e26 50E0      		ldi r21,0
 6744 2e28 62E0      		ldi r22,lo8(2)
 6745 2e2a 0E94 0000 		call ContinuePlayback
 6746               	.LVL266:
 6747 2e2e 00C0      		rjmp .L355
 6748               	.L408:
4288:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6749               		.loc 1 4288 0
 6750 2e30 9091 0000 		lds r25,currentMidiMessage.2205+3
 6751 2e34 8091 0000 		lds r24,currentMidiMessage.2205
 6752 2e38 9923      		tst r25
 6753 2e3a 01F0      		breq .L428
4290:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
 6754               		.loc 1 4290 0
 6755 2e3c A82F      		mov r26,r24
 6756 2e3e B0E0      		ldi r27,0
 6757 2e40 AA0F      		lsl r26
 6758 2e42 BB1F      		rol r27
 6759 2e44 A050      		subi r26,lo8(-(theMidiRecordRate))
 6760 2e46 B040      		sbci r27,hi8(-(theMidiRecordRate))
 6761 2e48 4D91      		ld r20,X+
 6762 2e4a 5C91      		ld r21,X
 6763 2e4c 62E0      		ldi r22,lo8(2)
 6764 2e4e 0E94 0000 		call StartRealtime
 6765               	.LVL267:
4291:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop 
 6766               		.loc 1 4291 0
 6767 2e52 E091 0000 		lds r30,currentMidiMessage.2205
 6768 2e56 F0E0      		ldi r31,0
 6769 2e58 E050      		subi r30,lo8(-(realtimeOn.2207))
 6770 2e5a F040      		sbci r31,hi8(-(realtimeOn.2207))
 6771 2e5c 81E0      		ldi r24,lo8(1)
 6772 2e5e 8083      		st Z,r24
 6773 2e60 00C0      		rjmp .L355
 6774               	.L428:
4293:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
 6775               		.loc 1 4293 0
 6776 2e62 282F      		mov r18,r24
 6777 2e64 30E0      		ldi r19,0
 6778 2e66 93E2      		ldi r25,lo8(35)
 6779 2e68 899F      		mul r24,r25
 6780 2e6a F001      		movw r30,r0
 6781 2e6c 1124      		clr __zero_reg__
 6782 2e6e E050      		subi r30,lo8(-(bankStates))
 6783 2e70 F040      		sbci r31,hi8(-(bankStates))
 6784 2e72 8081      		ld r24,Z
 6785 2e74 8230      		cpi r24,lo8(2)
 6786 2e76 01F0      		breq .+2
 6787 2e78 00C0      		rjmp .L355
4295:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 6788               		.loc 1 4295 0
 6789 2e7a 1082      		st Z,__zero_reg__
4296:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 6790               		.loc 1 4296 0
 6791 2e7c 1186      		std Z+9,__zero_reg__
4297:WTPA.c        **** 						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
 6792               		.loc 1 4297 0
 6793 2e7e F901      		movw r30,r18
 6794               	.L550:
 6795 2e80 E050      		subi r30,lo8(-(realtimeOn.2207))
 6796 2e82 F040      		sbci r31,hi8(-(realtimeOn.2207))
 6797 2e84 1082      		st Z,__zero_reg__
 6798 2e86 00C0      		rjmp .L355
 6799               	.L409:
4303:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6800               		.loc 1 4303 0
 6801 2e88 8091 0000 		lds r24,currentMidiMessage.2205+3
 6802 2e8c E091 0000 		lds r30,currentMidiMessage.2205
 6803 2e90 8823      		tst r24
 6804 2e92 01F0      		breq .L429
4305:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 6805               		.loc 1 4305 0
 6806 2e94 A3E2      		ldi r26,lo8(35)
 6807 2e96 EA9F      		mul r30,r26
 6808 2e98 F001      		movw r30,r0
 6809 2e9a 1124      		clr __zero_reg__
 6810 2e9c E050      		subi r30,lo8(-(bankStates))
 6811 2e9e F040      		sbci r31,hi8(-(bankStates))
 6812 2ea0 1182      		std Z+1,__zero_reg__
 6813 2ea2 00C0      		rjmp .L355
 6814               	.L429:
4309:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
 6815               		.loc 1 4309 0
 6816 2ea4 B3E2      		ldi r27,lo8(35)
 6817 2ea6 EB9F      		mul r30,r27
 6818 2ea8 F001      		movw r30,r0
 6819 2eaa 1124      		clr __zero_reg__
 6820 2eac E050      		subi r30,lo8(-(bankStates))
 6821 2eae F040      		sbci r31,hi8(-(bankStates))
 6822 2eb0 81E0      		ldi r24,lo8(1)
 6823 2eb2 8183      		std Z+1,r24
 6824 2eb4 00C0      		rjmp .L355
 6825               	.L410:
4314:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6826               		.loc 1 4314 0
 6827 2eb6 8091 0000 		lds r24,currentMidiMessage.2205+3
 6828 2eba E091 0000 		lds r30,currentMidiMessage.2205
 6829 2ebe 8823      		tst r24
 6830 2ec0 01F0      		breq .L430
4316:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
 6831               		.loc 1 4316 0
 6832 2ec2 23E2      		ldi r18,lo8(35)
 6833 2ec4 E29F      		mul r30,r18
 6834 2ec6 F001      		movw r30,r0
 6835 2ec8 1124      		clr __zero_reg__
 6836 2eca E050      		subi r30,lo8(-(bankStates))
 6837 2ecc F040      		sbci r31,hi8(-(bankStates))
 6838 2ece 81E0      		ldi r24,lo8(1)
 6839 2ed0 8283      		std Z+2,r24
 6840 2ed2 00C0      		rjmp .L355
 6841               	.L430:
4320:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 6842               		.loc 1 4320 0
 6843 2ed4 43E2      		ldi r20,lo8(35)
 6844 2ed6 E49F      		mul r30,r20
 6845 2ed8 F001      		movw r30,r0
 6846 2eda 1124      		clr __zero_reg__
 6847 2edc E050      		subi r30,lo8(-(bankStates))
 6848 2ede F040      		sbci r31,hi8(-(bankStates))
 6849 2ee0 1282      		std Z+2,__zero_reg__
 6850 2ee2 00C0      		rjmp .L355
 6851               	.L411:
4325:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 6852               		.loc 1 4325 0
 6853 2ee4 8091 0000 		lds r24,currentMidiMessage.2205+3
 6854 2ee8 E091 0000 		lds r30,currentMidiMessage.2205
 6855 2eec 8823      		tst r24
 6856 2eee 01F0      		breq .L431
4327:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
 6857               		.loc 1 4327 0
 6858 2ef0 83E2      		ldi r24,lo8(35)
 6859 2ef2 E89F      		mul r30,r24
 6860 2ef4 F001      		movw r30,r0
 6861 2ef6 1124      		clr __zero_reg__
 6862 2ef8 E050      		subi r30,lo8(-(bankStates))
 6863 2efa F040      		sbci r31,hi8(-(bankStates))
 6864 2efc 81E0      		ldi r24,lo8(1)
 6865 2efe 8383      		std Z+3,r24
 6866 2f00 00C0      		rjmp .L432
 6867               	.L431:
4331:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 6868               		.loc 1 4331 0
 6869 2f02 93E2      		ldi r25,lo8(35)
 6870 2f04 E99F      		mul r30,r25
 6871 2f06 F001      		movw r30,r0
 6872 2f08 1124      		clr __zero_reg__
 6873 2f0a E050      		subi r30,lo8(-(bankStates))
 6874 2f0c F040      		sbci r31,hi8(-(bankStates))
 6875 2f0e 1382      		std Z+3,__zero_reg__
 6876               	.L432:
4333:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
 6877               		.loc 1 4333 0
 6878 2f10 8091 0000 		lds r24,currentMidiMessage.2205
 6879 2f14 00C0      		rjmp .L551
 6880               	.L412:
4337:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 6881               		.loc 1 4337 0
 6882 2f16 E091 0000 		lds r30,currentMidiMessage.2205
 6883 2f1a AE2F      		mov r26,r30
 6884 2f1c B0E0      		ldi r27,0
 6885 2f1e 23E2      		ldi r18,lo8(35)
 6886 2f20 E29F      		mul r30,r18
 6887 2f22 F001      		movw r30,r0
 6888 2f24 1124      		clr __zero_reg__
 6889 2f26 E050      		subi r30,lo8(-(bankStates))
 6890 2f28 F040      		sbci r31,hi8(-(bankStates))
 6891 2f2a 1182      		std Z+1,__zero_reg__
4338:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
 6892               		.loc 1 4338 0
 6893 2f2c 1086      		std Z+8,__zero_reg__
4339:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
 6894               		.loc 1 4339 0
 6895 2f2e 1782      		std Z+7,__zero_reg__
4340:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
 6896               		.loc 1 4340 0
 6897 2f30 1682      		std Z+6,__zero_reg__
4341:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 6898               		.loc 1 4341 0
 6899 2f32 1282      		std Z+2,__zero_reg__
4342:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 6900               		.loc 1 4342 0
 6901 2f34 81E0      		ldi r24,lo8(1)
 6902 2f36 8483      		std Z+4,r24
4343:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 6903               		.loc 1 4343 0
 6904 2f38 1382      		std Z+3,__zero_reg__
4344:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 6905               		.loc 1 4344 0
 6906 2f3a 8483      		std Z+4,r24
4345:WTPA.c        **** 					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
 6907               		.loc 1 4345 0
 6908 2f3c A050      		subi r26,lo8(-(realtimeOn.2207))
 6909 2f3e B040      		sbci r27,hi8(-(realtimeOn.2207))
 6910 2f40 1C92      		st X,__zero_reg__
 6911 2f42 00C0      		rjmp .L433
 6912               	.L413:
4350:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
 6913               		.loc 1 4350 0
 6914 2f44 8091 0000 		lds r24,currentMidiMessage.2205+3
 6915 2f48 8830      		cpi r24,lo8(8)
 6916 2f4a 00F0      		brlo .+2
 6917 2f4c 00C0      		rjmp .L355
4352:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
 6918               		.loc 1 4352 0
 6919 2f4e E091 0000 		lds r30,currentMidiMessage.2205
 6920 2f52 43E2      		ldi r20,lo8(35)
 6921 2f54 E49F      		mul r30,r20
 6922 2f56 F001      		movw r30,r0
 6923 2f58 1124      		clr __zero_reg__
 6924 2f5a E050      		subi r30,lo8(-(bankStates))
 6925 2f5c F040      		sbci r31,hi8(-(bankStates))
 6926 2f5e 8087      		std Z+8,r24
 6927 2f60 00C0      		rjmp .L355
 6928               	.L414:
4357:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 6929               		.loc 1 4357 0
 6930 2f62 6091 0000 		lds r22,currentMidiMessage.2205+3
 6931 2f66 8091 0000 		lds r24,currentMidiMessage.2205
 6932 2f6a 0E94 0000 		call MakeNewGranularArray
 6933               	.LVL268:
4358:WTPA.c        **** 					break;
 6934               		.loc 1 4358 0
 6935 2f6e 00C0      		rjmp .L355
 6936               	.L415:
4361:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
 6937               		.loc 1 4361 0
 6938 2f70 E091 0000 		lds r30,currentMidiMessage.2205
 6939 2f74 8091 0000 		lds r24,currentMidiMessage.2205+3
 6940 2f78 93E2      		ldi r25,lo8(35)
 6941 2f7a E99F      		mul r30,r25
 6942 2f7c F001      		movw r30,r0
 6943 2f7e 1124      		clr __zero_reg__
 6944 2f80 E050      		subi r30,lo8(-(bankStates))
 6945 2f82 F040      		sbci r31,hi8(-(bankStates))
 6946 2f84 8783      		std Z+7,r24
4362:WTPA.c        **** 					break;
 6947               		.loc 1 4362 0
 6948 2f86 00C0      		rjmp .L355
 6949               	.L416:
4365:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
 6950               		.loc 1 4365 0
 6951 2f88 8091 0000 		lds r24,currentMidiMessage.2205+3
 6952 2f8c 8130      		cpi r24,lo8(1)
 6953 2f8e 01F0      		breq .L434
 6954 2f90 00F0      		brlo .L433
 6955 2f92 8230      		cpi r24,lo8(2)
 6956 2f94 01F0      		breq .L435
 6957 2f96 8330      		cpi r24,lo8(3)
 6958 2f98 01F0      		breq .+2
 6959 2f9a 00C0      		rjmp .L355
 6960 2f9c 00C0      		rjmp .L436
 6961               	.L433:
4368:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
 6962               		.loc 1 4368 0
 6963 2f9e 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6964 2fa0 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6965 2fa2 00C0      		rjmp .L548
 6966               	.L434:
4372:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
 6967               		.loc 1 4372 0
 6968 2fa4 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 6969 2fa6 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 6970               	.L548:
 6971 2fa8 9093 0000 		sts UpdateOutput+1,r25
 6972 2fac 8093 0000 		sts UpdateOutput,r24
4373:WTPA.c        **** 						break;
 6973               		.loc 1 4373 0
 6974 2fb0 00C0      		rjmp .L355
 6975               	.L435:
4376:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
 6976               		.loc 1 4376 0
 6977 2fb2 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 6978 2fb4 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 6979 2fb6 00C0      		rjmp .L548
 6980               	.L436:
4380:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
 6981               		.loc 1 4380 0
 6982 2fb8 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 6983 2fba 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 6984 2fbc 00C0      		rjmp .L548
 6985               	.L417:
4389:WTPA.c        **** 					i=SREG;
 6986               		.loc 1 4389 0
 6987 2fbe 1FB7      		in r17,__SREG__
 6988               	.LVL269:
4390:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
 6989               		.loc 1 4390 0
 6990               	/* #APP */
 6991               	 ;  4390 "WTPA.c" 1
 6992 2fc0 F894      		cli
 6993               	 ;  0 "" 2
4391:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 6994               		.loc 1 4391 0
 6995               	/* #NOAPP */
 6996 2fc2 5091 0000 		lds r21,currentMidiMessage.2205
 6997 2fc6 A52F      		mov r26,r21
 6998 2fc8 B0E0      		ldi r27,0
 6999 2fca FD01      		movw r30,r26
 7000 2fcc E050      		subi r30,lo8(-(currentNoteOn.2206))
 7001 2fce F040      		sbci r31,hi8(-(currentNoteOn.2206))
 7002 2fd0 4081      		ld r20,Z
 7003               	.LVL270:
 7004 2fd2 AA0F      		lsl r26
 7005 2fd4 BB1F      		rol r27
 7006 2fd6 A050      		subi r26,lo8(-(theMidiRecordRate))
 7007 2fd8 B040      		sbci r27,hi8(-(theMidiRecordRate))
 7008               	.LBB238:
 7009               	.LBB239:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7010               		.loc 1 3294 0
 7011 2fda 842F      		mov r24,r20
 7012 2fdc 6CE0      		ldi r22,lo8(12)
 7013 2fde 0E94 0000 		call __udivmodqi4
 7014               	.LVL271:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7015               		.loc 1 3296 0
 7016 2fe2 E92F      		mov r30,r25
 7017 2fe4 F0E0      		ldi r31,0
 7018 2fe6 EE0F      		lsl r30
 7019 2fe8 FF1F      		rol r31
 7020               	.LVL272:
 7021 2fea E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7022 2fec F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7023 2fee 2081      		ld r18,Z
 7024 2ff0 3181      		ldd r19,Z+1
 7025 2ff2 00C0      		rjmp 2f
 7026               		1:
 7027 2ff4 3695      		lsr r19
 7028 2ff6 2795      		ror r18
 7029               		2:
 7030 2ff8 8A95      		dec r24
 7031 2ffa 02F4      		brpl 1b
 7032               	.LBE239:
 7033               	.LBE238:
4391:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 7034               		.loc 1 4391 0
 7035 2ffc 2D93      		st X+,r18
 7036 2ffe 3C93      		st X,r19
 7037               	.LVL273:
 7038               	.LBB240:
 7039               	.LBB241:
3312:WTPA.c        **** 	if(theBank==BANK_0)
 7040               		.loc 1 3312 0
 7041 3000 5111      		cpse r21,__zero_reg__
 7042 3002 00C0      		rjmp .L437
3314:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
 7043               		.loc 1 3314 0
 7044 3004 642F      		mov r22,r20
 7045 3006 87E0      		ldi r24,lo8(7)
 7046 3008 90E0      		ldi r25,0
 7047               	.LVL274:
 7048 300a 00C0      		rjmp .L547
 7049               	.LVL275:
 7050               	.L437:
3316:WTPA.c        **** 	else if(theBank==BANK_1)
 7051               		.loc 1 3316 0
 7052 300c 5130      		cpi r21,lo8(1)
 7053 300e 01F4      		brne .L438
3318:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
 7054               		.loc 1 3318 0
 7055 3010 642F      		mov r22,r20
 7056 3012 8BE0      		ldi r24,lo8(11)
 7057 3014 90E0      		ldi r25,0
 7058               	.LVL276:
 7059               	.L547:
 7060 3016 0E94 0000 		call EepromWrite
 7061               	.LVL277:
 7062               	.L438:
 7063               	.LBE241:
 7064               	.LBE240:
4393:WTPA.c        **** 					SREG=i;		// Re-enable interrupts.
 7065               		.loc 1 4393 0
 7066 301a 1FBF      		out __SREG__,r17
4394:WTPA.c        **** 					break;
 7067               		.loc 1 4394 0
 7068 301c 00C0      		rjmp .L355
 7069               	.LVL278:
 7070               	.L418:
4399:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7071               		.loc 1 4399 0
 7072 301e 9091 0000 		lds r25,currentMidiMessage.2205+3
 7073 3022 8091 0000 		lds r24,currentMidiMessage.2205
 7074               	.LVL279:
 7075               	.LBB242:
 7076               	.LBB243:
3858:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7077               		.loc 1 3858 0
 7078 3026 A3E2      		ldi r26,lo8(35)
 7079 3028 8A9F      		mul r24,r26
 7080 302a F001      		movw r30,r0
 7081 302c 1124      		clr __zero_reg__
 7082 302e 00C0      		rjmp .L561
 7083               	.LVL280:
 7084               	.L419:
 7085               	.LBE243:
 7086               	.LBE242:
4403:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7087               		.loc 1 4403 0
 7088 3030 9091 0000 		lds r25,currentMidiMessage.2205+3
 7089 3034 8091 0000 		lds r24,currentMidiMessage.2205
 7090               	.LVL281:
 7091               	.LBB244:
 7092               	.LBB245:
3867:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7093               		.loc 1 3867 0
 7094 3038 B3E2      		ldi r27,lo8(35)
 7095 303a 8B9F      		mul r24,r27
 7096 303c F001      		movw r30,r0
 7097 303e 1124      		clr __zero_reg__
 7098 3040 00C0      		rjmp .L560
 7099               	.LVL282:
 7100               	.L420:
 7101               	.LBE245:
 7102               	.LBE244:
4407:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 7103               		.loc 1 4407 0
 7104 3042 9091 0000 		lds r25,currentMidiMessage.2205+3
 7105 3046 8091 0000 		lds r24,currentMidiMessage.2205
 7106               	.LVL283:
 7107               	.LBB246:
 7108               	.LBB247:
3876:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7109               		.loc 1 3876 0
 7110 304a 23E2      		ldi r18,lo8(35)
 7111 304c 829F      		mul r24,r18
 7112 304e F001      		movw r30,r0
 7113 3050 1124      		clr __zero_reg__
 7114 3052 00C0      		rjmp .L552
 7115               	.LVL284:
 7116               	.L421:
 7117               	.LBE247:
 7118               	.LBE246:
4411:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
 7119               		.loc 1 4411 0
 7120 3054 8091 0000 		lds r24,currentMidiMessage.2205
 7121 3058 0E94 0000 		call RevertSampleToUnadjusted
 7122               	.LVL285:
4412:WTPA.c        **** 					break;
 7123               		.loc 1 4412 0
 7124 305c 00C0      		rjmp .L355
 7125               	.L422:
4415:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7126               		.loc 1 4415 0
 7127 305e 9091 0000 		lds r25,currentMidiMessage.2205+3
 7128 3062 990F      		lsl r25
 7129 3064 8091 0000 		lds r24,currentMidiMessage.2205
 7130               	.LVL286:
 7131               	.LBB248:
 7132               	.LBB249:
3858:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 7133               		.loc 1 3858 0
 7134 3068 43E2      		ldi r20,lo8(35)
 7135 306a 849F      		mul r24,r20
 7136 306c F001      		movw r30,r0
 7137 306e 1124      		clr __zero_reg__
 7138               	.LVL287:
 7139               	.L561:
 7140 3070 E050      		subi r30,lo8(-(bankStates))
 7141 3072 F040      		sbci r31,hi8(-(bankStates))
 7142 3074 948F      		std Z+28,r25
 7143 3076 00C0      		rjmp .L551
 7144               	.L423:
 7145               	.LBE249:
 7146               	.LBE248:
4419:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7147               		.loc 1 4419 0
 7148 3078 9091 0000 		lds r25,currentMidiMessage.2205+3
 7149 307c 990F      		lsl r25
 7150 307e 8091 0000 		lds r24,currentMidiMessage.2205
 7151               	.LVL288:
 7152               	.LBB250:
 7153               	.LBB251:
3867:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 7154               		.loc 1 3867 0
 7155 3082 A3E2      		ldi r26,lo8(35)
 7156 3084 8A9F      		mul r24,r26
 7157 3086 F001      		movw r30,r0
 7158 3088 1124      		clr __zero_reg__
 7159               	.LVL289:
 7160               	.L560:
 7161 308a E050      		subi r30,lo8(-(bankStates))
 7162 308c F040      		sbci r31,hi8(-(bankStates))
 7163 308e 958F      		std Z+29,r25
 7164 3090 00C0      		rjmp .L551
 7165               	.L424:
 7166               	.LBE251:
 7167               	.LBE250:
4423:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 7168               		.loc 1 4423 0
 7169 3092 9091 0000 		lds r25,currentMidiMessage.2205+3
 7170 3096 990F      		lsl r25
 7171 3098 8091 0000 		lds r24,currentMidiMessage.2205
 7172               	.LVL290:
 7173               	.LBB252:
 7174               	.LBB253:
3876:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7175               		.loc 1 3876 0
 7176 309c B3E2      		ldi r27,lo8(35)
 7177 309e 8B9F      		mul r24,r27
 7178 30a0 F001      		movw r30,r0
 7179 30a2 1124      		clr __zero_reg__
 7180               	.LVL291:
 7181               	.L552:
 7182 30a4 E050      		subi r30,lo8(-(bankStates))
 7183 30a6 F040      		sbci r31,hi8(-(bankStates))
 7184 30a8 968F      		std Z+30,r25
 7185               	.L551:
3877:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 7186               		.loc 1 3877 0
 7187 30aa 0E94 0000 		call UpdateAdjustedSampleAddresses
 7188               	.LVL292:
 7189 30ae 00C0      		rjmp .L355
 7190               	.L405:
 7191               	.LBE253:
 7192               	.LBE252:
4431:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
 7193               		.loc 1 4431 0
 7194 30b0 8730      		cpi r24,lo8(7)
 7195 30b2 01F0      		breq .+2
 7196 30b4 00C0      		rjmp .L355
4433:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
 7197               		.loc 1 4433 0
 7198 30b6 8091 0000 		lds r24,currentMidiMessage.2205+3
 7199 30ba 2091 0000 		lds r18,currentMidiMessage.2205+2
 7200 30be 30E0      		ldi r19,0
 7201 30c0 E0E8      		ldi r30,lo8(-128)
 7202 30c2 8E9F      		mul r24,r30
 7203 30c4 200D      		add r18,r0
 7204 30c6 311D      		adc r19,r1
 7205 30c8 1124      		clr __zero_reg__
 7206               	.LVL293:
 7207 30ca A091 0000 		lds r26,currentMidiMessage.2205
4435:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
 7208               		.loc 1 4435 0
 7209 30ce 2115      		cp r18,__zero_reg__
 7210 30d0 F0E2      		ldi r31,32
 7211 30d2 3F07      		cpc r19,r31
 7212 30d4 01F0      		breq .L439
4439:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7213               		.loc 1 4439 0
 7214 30d6 B0E0      		ldi r27,0
 7215 30d8 FD01      		movw r30,r26
 7216 30da E050      		subi r30,lo8(-(currentNoteOn.2206))
 7217 30dc F040      		sbci r31,hi8(-(currentNoteOn.2206))
 7218 30de 8081      		ld r24,Z
 7219               	.LVL294:
4443:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7220               		.loc 1 4443 0
 7221 30e0 40E0      		ldi r20,0
 7222 30e2 50E2      		ldi r21,lo8(32)
 7223 30e4 421B      		sub r20,r18
 7224 30e6 530B      		sbc r21,r19
 7225               	.LBB254:
 7226               	.LBB255:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7227               		.loc 1 3294 0
 7228 30e8 6CE0      		ldi r22,lo8(12)
 7229 30ea 0E94 0000 		call __udivmodqi4
 7230               	.LVL295:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7231               		.loc 1 3296 0
 7232 30ee E92F      		mov r30,r25
 7233               	.LVL296:
 7234 30f0 F0E0      		ldi r31,0
 7235 30f2 EE0F      		lsl r30
 7236 30f4 FF1F      		rol r31
 7237 30f6 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7238 30f8 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7239 30fa 2081      		ld r18,Z
 7240 30fc 3181      		ldd r19,Z+1
 7241               	.LVL297:
 7242 30fe 00C0      		rjmp 2f
 7243               		1:
 7244 3100 3695      		lsr r19
 7245 3102 2795      		ror r18
 7246               		2:
 7247 3104 8A95      		dec r24
 7248 3106 02F4      		brpl 1b
 7249               	.LBE255:
 7250               	.LBE254:
4443:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 7251               		.loc 1 4443 0
 7252 3108 420F      		add r20,r18
 7253 310a 531F      		adc r21,r19
 7254 310c 83E2      		ldi r24,lo8(35)
 7255               	.LVL298:
 7256 310e 8A9F      		mul r24,r26
 7257 3110 F001      		movw r30,r0
 7258 3112 8B9F      		mul r24,r27
 7259 3114 F00D      		add r31,r0
 7260 3116 1124      		clr __zero_reg__
 7261 3118 E050      		subi r30,lo8(-(bankStates))
 7262 311a F040      		sbci r31,hi8(-(bankStates))
 7263 311c 5387      		std Z+11,r21
 7264 311e 4287      		std Z+10,r20
 7265 3120 00C0      		rjmp .L355
 7266               	.LVL299:
 7267               	.L439:
4448:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7268               		.loc 1 4448 0
 7269 3122 4A2F      		mov r20,r26
 7270 3124 50E0      		ldi r21,0
 7271 3126 FA01      		movw r30,r20
 7272 3128 E050      		subi r30,lo8(-(currentNoteOn.2206))
 7273 312a F040      		sbci r31,hi8(-(currentNoteOn.2206))
 7274 312c 8081      		ld r24,Z
 7275               	.LVL300:
 7276               	.LBB256:
 7277               	.LBB257:
3294:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7278               		.loc 1 3294 0
 7279 312e 6CE0      		ldi r22,lo8(12)
 7280 3130 0E94 0000 		call __udivmodqi4
 7281               	.LVL301:
3296:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7282               		.loc 1 3296 0
 7283 3134 E92F      		mov r30,r25
 7284               	.LVL302:
 7285 3136 F0E0      		ldi r31,0
 7286 3138 EE0F      		lsl r30
 7287 313a FF1F      		rol r31
 7288 313c E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7289 313e F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7290 3140 2081      		ld r18,Z
 7291 3142 3181      		ldd r19,Z+1
 7292               	.LVL303:
 7293 3144 00C0      		rjmp 2f
 7294               		1:
 7295 3146 3695      		lsr r19
 7296 3148 2795      		ror r18
 7297               		2:
 7298 314a 8A95      		dec r24
 7299 314c 02F4      		brpl 1b
 7300               	.LBE257:
 7301               	.LBE256:
4448:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7302               		.loc 1 4448 0
 7303 314e 83E2      		ldi r24,lo8(35)
 7304               	.LVL304:
 7305 3150 849F      		mul r24,r20
 7306 3152 F001      		movw r30,r0
 7307 3154 859F      		mul r24,r21
 7308 3156 F00D      		add r31,r0
 7309 3158 1124      		clr __zero_reg__
 7310 315a E050      		subi r30,lo8(-(bankStates))
 7311 315c F040      		sbci r31,hi8(-(bankStates))
 7312 315e 3387      		std Z+11,r19
 7313 3160 2287      		std Z+10,r18
 7314               	.LVL305:
 7315               	.L355:
 7316               	.LBB258:
 7317               	.LBB259:
3482:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
 7318               		.loc 1 3482 0
 7319 3162 8091 0000 		lds r24,sdIsrState
 7320 3166 8330      		cpi r24,lo8(3)
 7321 3168 01F0      		breq .L441
3484:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
 7322               		.loc 1 3484 0
 7323 316a 1092 0000 		sts sdStreamOutput,__zero_reg__
 7324               	.L441:
3488:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
 7325               		.loc 1 3488 0
 7326 316e 8091 0000 		lds r24,bankStates+9
 7327 3172 8130      		cpi r24,lo8(1)
 7328 3174 01F0      		breq .L442
3490:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7329               		.loc 1 3490 0
 7330 3176 1092 0000 		sts extIsrOutputBank0,__zero_reg__
3491:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7331               		.loc 1 3491 0
 7332 317a 8091 6F00 		lds r24,111
 7333 317e 8F7D      		andi r24,lo8(-33)
 7334 3180 8093 6F00 		sts 111,r24
3492:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
 7335               		.loc 1 3492 0
 7336 3184 B59A      		sbi 0x16,5
 7337               	.L442:
3494:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
 7338               		.loc 1 3494 0
 7339 3186 8091 0000 		lds r24,bankStates+44
 7340 318a 8130      		cpi r24,lo8(1)
 7341 318c 01F0      		breq .L443
3496:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
 7342               		.loc 1 3496 0
 7343 318e 1092 0000 		sts extIsrOutputBank1,__zero_reg__
3497:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
 7344               		.loc 1 3497 0
 7345 3192 1092 6800 		sts 104,__zero_reg__
3498:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
 7346               		.loc 1 3498 0
 7347 3196 1092 6D00 		sts 109,__zero_reg__
 7348               	.L443:
3500:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
 7349               		.loc 1 3500 0
 7350 319a 8091 0000 		lds r24,bankStates+9
 7351 319e 8230      		cpi r24,lo8(2)
 7352 31a0 01F0      		breq .L444
3502:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
 7353               		.loc 1 3502 0
 7354 31a2 1092 0000 		sts midiOutputBank0,__zero_reg__
3503:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
 7355               		.loc 1 3503 0
 7356 31a6 8091 6F00 		lds r24,111
 7357 31aa 8D7F      		andi r24,lo8(-3)
 7358 31ac 8093 6F00 		sts 111,r24
3504:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
 7359               		.loc 1 3504 0
 7360 31b0 B19A      		sbi 0x16,1
 7361               	.L444:
3506:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
 7362               		.loc 1 3506 0
 7363 31b2 8091 0000 		lds r24,bankStates+44
 7364 31b6 8230      		cpi r24,lo8(2)
 7365 31b8 01F0      		breq .L445
3508:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
 7366               		.loc 1 3508 0
 7367 31ba 1092 0000 		sts midiOutputBank1,__zero_reg__
3509:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
 7368               		.loc 1 3509 0
 7369 31be 8091 6F00 		lds r24,111
 7370 31c2 8B7F      		andi r24,lo8(-5)
 7371 31c4 8093 6F00 		sts 111,r24
3510:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
 7372               		.loc 1 3510 0
 7373 31c8 B29A      		sbi 0x16,2
 7374               	.L445:
3514:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7375               		.loc 1 3514 0
 7376 31ca 8091 0000 		lds r24,bankStates+9
 7377 31ce 8111      		cpse r24,__zero_reg__
 7378 31d0 00C0      		rjmp .L446
3516:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
 7379               		.loc 1 3516 0
 7380 31d2 8091 0000 		lds r24,sdIsrState
 7381 31d6 8823      		tst r24
 7382 31d8 01F0      		breq .L447
 7383 31da 8330      		cpi r24,lo8(3)
 7384 31dc 01F0      		breq .L447
 7385 31de 8091 0000 		lds r24,sdBank0
 7386 31e2 8111      		cpse r24,__zero_reg__
 7387 31e4 00C0      		rjmp .L446
 7388               	.L447:
3518:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
 7389               		.loc 1 3518 0
 7390 31e6 1092 0000 		sts bankStates+5,__zero_reg__
 7391               	.L446:
3521:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
 7392               		.loc 1 3521 0
 7393 31ea 8091 0000 		lds r24,bankStates+44
 7394 31ee 8111      		cpse r24,__zero_reg__
 7395 31f0 00C0      		rjmp .L448
3523:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
 7396               		.loc 1 3523 0
 7397 31f2 8091 0000 		lds r24,sdIsrState
 7398 31f6 8823      		tst r24
 7399 31f8 01F0      		breq .L449
 7400 31fa 8330      		cpi r24,lo8(3)
 7401 31fc 01F0      		breq .L449
 7402 31fe 8091 0000 		lds r24,sdBank0
 7403 3202 8130      		cpi r24,lo8(1)
 7404 3204 01F4      		brne .L448
 7405               	.L449:
3525:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
 7406               		.loc 1 3525 0
 7407 3206 1092 0000 		sts bankStates+40,__zero_reg__
 7408               	.L448:
 7409               	.LBE259:
 7410               	.LBE258:
 7411               	.LBB260:
 7412               	.LBB261:
3458:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
 7413               		.loc 1 3458 0
 7414 320a 8091 0000 		lds r24,encoderValue
 7415 320e 8295      		swap r24
 7416 3210 8695      		lsr r24
 7417 3212 8770      		andi r24,lo8(7)
 7418 3214 8093 0000 		sts scaledEncoderValue,r24
3459:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
 7419               		.loc 1 3459 0
 7420 3218 2091 0000 		lds r18,ledOnOffMask
 7421 321c 2F71      		andi r18,lo8(31)
 7422               	.LVL306:
3461:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
 7423               		.loc 1 3461 0
 7424 321e 80FD      		sbrc r24,0
3463:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
 7425               		.loc 1 3463 0
 7426 3220 2068      		ori r18,lo8(-128)
 7427               	.LVL307:
 7428               	.L450:
3465:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
 7429               		.loc 1 3465 0
 7430 3222 81FD      		sbrc r24,1
3467:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
 7431               		.loc 1 3467 0
 7432 3224 2064      		ori r18,lo8(64)
 7433               	.LVL308:
 7434               	.L451:
 7435               	.LBE261:
3469:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
 7436               		.loc 1 3469 0
 7437 3226 8470      		andi r24,lo8(4)
 7438               	.LBB262:
 7439 3228 01F0      		breq .L452
3471:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
 7440               		.loc 1 3471 0
 7441 322a 2062      		ori r18,lo8(32)
 7442               	.LVL309:
 7443               	.L452:
 7444               	.LBE262:
 7445               	.LBE260:
4457:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
 7446               		.loc 1 4457 0
 7447 322c 3091 0000 		lds r19,currentBank
 7448               	.LVL310:
 7449               	.LBB263:
 7450               	.LBB264:
3406:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
 7451               		.loc 1 3406 0
 7452 3230 207E      		andi r18,lo8(-32)
 7453               	.LVL311:
3408:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
 7454               		.loc 1 3408 0
 7455 3232 832F      		mov r24,r19
 7456 3234 90E0      		ldi r25,0
 7457 3236 A3E2      		ldi r26,lo8(35)
 7458 3238 3A9F      		mul r19,r26
 7459 323a F001      		movw r30,r0
 7460 323c 1124      		clr __zero_reg__
 7461 323e E050      		subi r30,lo8(-(bankStates))
 7462 3240 F040      		sbci r31,hi8(-(bankStates))
 7463 3242 4081      		ld r20,Z
 7464 3244 4330      		cpi r20,lo8(3)
 7465 3246 01F4      		brne .L453
3410:WTPA.c        **** 		temp|=Om_LED_REC;
 7466               		.loc 1 3410 0
 7467 3248 2160      		ori r18,lo8(1)
 7468               	.LVL312:
 7469               	.L453:
3412:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
 7470               		.loc 1 3412 0
 7471 324a 43E2      		ldi r20,lo8(35)
 7472 324c 489F      		mul r20,r24
 7473 324e F001      		movw r30,r0
 7474 3250 499F      		mul r20,r25
 7475 3252 F00D      		add r31,r0
 7476 3254 1124      		clr __zero_reg__
 7477 3256 E050      		subi r30,lo8(-(bankStates))
 7478 3258 F040      		sbci r31,hi8(-(bankStates))
 7479 325a 4081      		ld r20,Z
 7480 325c 4430      		cpi r20,lo8(4)
 7481 325e 01F4      		brne .L454
3414:WTPA.c        **** 		temp|=Om_LED_PLAY;
 7482               		.loc 1 3414 0
 7483 3260 2460      		ori r18,lo8(4)
 7484               	.LVL313:
 7485               	.L454:
3416:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
 7486               		.loc 1 3416 0
 7487 3262 43E2      		ldi r20,lo8(35)
 7488 3264 489F      		mul r20,r24
 7489 3266 F001      		movw r30,r0
 7490 3268 499F      		mul r20,r25
 7491 326a F00D      		add r31,r0
 7492 326c 1124      		clr __zero_reg__
 7493 326e E050      		subi r30,lo8(-(bankStates))
 7494 3270 F040      		sbci r31,hi8(-(bankStates))
 7495 3272 4081      		ld r20,Z
 7496 3274 4530      		cpi r20,lo8(5)
 7497 3276 01F4      		brne .L455
3418:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7498               		.loc 1 3418 0
 7499 3278 2260      		ori r18,lo8(2)
 7500               	.LVL314:
 7501               	.L455:
3420:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
 7502               		.loc 1 3420 0
 7503 327a 43E2      		ldi r20,lo8(35)
 7504 327c 489F      		mul r20,r24
 7505 327e F001      		movw r30,r0
 7506 3280 499F      		mul r20,r25
 7507 3282 F00D      		add r31,r0
 7508 3284 1124      		clr __zero_reg__
 7509 3286 E050      		subi r30,lo8(-(bankStates))
 7510 3288 F040      		sbci r31,hi8(-(bankStates))
 7511 328a 4081      		ld r20,Z
 7512 328c 4230      		cpi r20,lo8(2)
 7513 328e 01F4      		brne .L456
 7514               	.LVL315:
3424:WTPA.c        **** 		temp|=Om_LED_ODUB;
 7515               		.loc 1 3424 0
 7516 3290 2760      		ori r18,lo8(7)
 7517               	.LVL316:
 7518               	.L456:
3427:WTPA.c        **** 	if(outOfRam==true)
 7519               		.loc 1 3427 0
 7520 3292 4091 0000 		lds r20,outOfRam
 7521 3296 4130      		cpi r20,lo8(1)
 7522 3298 01F4      		brne .L457
3429:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
 7523               		.loc 1 3429 0
 7524 329a 2860      		ori r18,lo8(8)
 7525               	.LVL317:
 7526               	.L457:
3431:WTPA.c        **** 	if(theBank==BANK_1)
 7527               		.loc 1 3431 0
 7528 329c 3130      		cpi r19,lo8(1)
 7529 329e 01F4      		brne .L458
3433:WTPA.c        **** 		temp|=Om_LED_BANK;
 7530               		.loc 1 3433 0
 7531 32a0 2061      		ori r18,lo8(16)
 7532               	.LVL318:
 7533               	.L458:
3436:WTPA.c        **** 	ledOnOffMask=temp;
 7534               		.loc 1 3436 0
 7535 32a2 2093 0000 		sts ledOnOffMask,r18
3438:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
 7536               		.loc 1 3438 0
 7537 32a6 23E2      		ldi r18,lo8(35)
 7538               	.LVL319:
 7539 32a8 289F      		mul r18,r24
 7540 32aa F001      		movw r30,r0
 7541 32ac 299F      		mul r18,r25
 7542 32ae F00D      		add r31,r0
 7543 32b0 1124      		clr __zero_reg__
 7544 32b2 E050      		subi r30,lo8(-(bankStates))
 7545 32b4 F040      		sbci r31,hi8(-(bankStates))
 7546 32b6 4089      		ldd r20,Z+16
 7547 32b8 5189      		ldd r21,Z+17
 7548 32ba 6289      		ldd r22,Z+18
 7549 32bc 7389      		ldd r23,Z+19
 7550 32be 8485      		ldd r24,Z+12
 7551 32c0 9585      		ldd r25,Z+13
 7552 32c2 A685      		ldd r26,Z+14
 7553 32c4 B785      		ldd r27,Z+15
 7554 32c6 4817      		cp r20,r24
 7555 32c8 5907      		cpc r21,r25
 7556 32ca 6A07      		cpc r22,r26
 7557 32cc 7B07      		cpc r23,r27
 7558 32ce 01F4      		brne .L459
 7559               	.LBE264:
3440:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
 7560               		.loc 1 3440 0
 7561 32d0 8091 0000 		lds r24,ledBlinkMask
 7562               	.LBB269:
 7563 32d4 82FD      		sbrc r24,2
 7564 32d6 00C0      		rjmp .L347
3442:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
 7565               		.loc 1 3442 0
 7566 32d8 84E0      		ldi r24,lo8(4)
 7567 32da 90E0      		ldi r25,0
 7568 32dc 00C0      		rjmp .L553
 7569               	.L459:
 7570               	.LBB265:
 7571               	.LBB266:
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 7572               		.loc 1 1520 0
 7573 32de 80E0      		ldi r24,0
 7574 32e0 90E0      		ldi r25,0
 7575               	.L553:
 7576               	/* epilogue start */
 7577               	.LBE266:
 7578               	.LBE265:
 7579               	.LBE269:
 7580               	.LBE263:
4458:WTPA.c        **** }
 7581               		.loc 1 4458 0
 7582 32e2 0F90      		pop __tmp_reg__
 7583 32e4 DF91      		pop r29
 7584 32e6 CF91      		pop r28
 7585 32e8 1F91      		pop r17
 7586 32ea 0F91      		pop r16
 7587 32ec FF90      		pop r15
 7588 32ee EF90      		pop r14
 7589 32f0 DF90      		pop r13
 7590 32f2 CF90      		pop r12
 7591 32f4 BF90      		pop r11
 7592 32f6 AF90      		pop r10
 7593 32f8 9F90      		pop r9
 7594 32fa 8F90      		pop r8
 7595               	.LBB271:
 7596               	.LBB270:
 7597               	.LBB268:
 7598               	.LBB267:
1520:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
 7599               		.loc 1 1520 0
 7600 32fc 0C94 0000 		jmp BlinkLeds
 7601               	.LVL320:
 7602               	.L347:
 7603               	/* epilogue start */
 7604               	.LBE267:
 7605               	.LBE268:
 7606               	.LBE270:
 7607               	.LBE271:
4458:WTPA.c        **** }
 7608               		.loc 1 4458 0
 7609 3300 0F90      		pop __tmp_reg__
 7610 3302 DF91      		pop r29
 7611 3304 CF91      		pop r28
 7612 3306 1F91      		pop r17
 7613 3308 0F91      		pop r16
 7614 330a FF90      		pop r15
 7615 330c EF90      		pop r14
 7616 330e DF90      		pop r13
 7617 3310 CF90      		pop r12
 7618 3312 BF90      		pop r11
 7619 3314 AF90      		pop r10
 7620 3316 9F90      		pop r9
 7621 3318 8F90      		pop r8
 7622 331a 0895      		ret
 7623               		.cfi_endproc
 7624               	.LFE67:
 7626               	.global	__vector_12
 7628               	__vector_12:
 7629               	.LFB7:
1115:WTPA.c        **** {
 7630               		.loc 1 1115 0
 7631               		.cfi_startproc
 7632 331c 1F92      		push r1
 7633               	.LCFI70:
 7634               		.cfi_def_cfa_offset 3
 7635               		.cfi_offset 1, -2
 7636 331e 0F92      		push r0
 7637               	.LCFI71:
 7638               		.cfi_def_cfa_offset 4
 7639               		.cfi_offset 0, -3
 7640 3320 0FB6      		in r0,__SREG__
 7641 3322 0F92      		push r0
 7642 3324 1124      		clr __zero_reg__
 7643 3326 2F93      		push r18
 7644               	.LCFI72:
 7645               		.cfi_def_cfa_offset 5
 7646               		.cfi_offset 18, -4
 7647 3328 3F93      		push r19
 7648               	.LCFI73:
 7649               		.cfi_def_cfa_offset 6
 7650               		.cfi_offset 19, -5
 7651 332a 4F93      		push r20
 7652               	.LCFI74:
 7653               		.cfi_def_cfa_offset 7
 7654               		.cfi_offset 20, -6
 7655 332c 5F93      		push r21
 7656               	.LCFI75:
 7657               		.cfi_def_cfa_offset 8
 7658               		.cfi_offset 21, -7
 7659 332e 6F93      		push r22
 7660               	.LCFI76:
 7661               		.cfi_def_cfa_offset 9
 7662               		.cfi_offset 22, -8
 7663 3330 7F93      		push r23
 7664               	.LCFI77:
 7665               		.cfi_def_cfa_offset 10
 7666               		.cfi_offset 23, -9
 7667 3332 8F93      		push r24
 7668               	.LCFI78:
 7669               		.cfi_def_cfa_offset 11
 7670               		.cfi_offset 24, -10
 7671 3334 9F93      		push r25
 7672               	.LCFI79:
 7673               		.cfi_def_cfa_offset 12
 7674               		.cfi_offset 25, -11
 7675 3336 AF93      		push r26
 7676               	.LCFI80:
 7677               		.cfi_def_cfa_offset 13
 7678               		.cfi_offset 26, -12
 7679 3338 BF93      		push r27
 7680               	.LCFI81:
 7681               		.cfi_def_cfa_offset 14
 7682               		.cfi_offset 27, -13
 7683 333a EF93      		push r30
 7684               	.LCFI82:
 7685               		.cfi_def_cfa_offset 15
 7686               		.cfi_offset 30, -14
 7687 333c FF93      		push r31
 7688               	.LCFI83:
 7689               		.cfi_def_cfa_offset 16
 7690               		.cfi_offset 31, -15
 7691               	/* prologue: Signal */
 7692               	/* frame size = 0 */
 7693               	/* stack size = 15 */
 7694               	.L__stack_usage = 15
1120:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7695               		.loc 1 1120 0
 7696 333e 8091 0000 		lds r24,bankStates+2
 7697 3342 8823      		tst r24
 7698 3344 01F0      		breq .L563
1120:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7699               		.loc 1 1120 0 is_stmt 0 discriminator 1
 7700 3346 8091 0000 		lds r24,bankStates+2
 7701 334a 8823      		tst r24
 7702 334c 01F0      		breq .L564
 7703 334e 8091 0000 		lds r24,flipFlop.1807
 7704 3352 8823      		tst r24
 7705 3354 01F0      		breq .L564
 7706               	.L563:
1122:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
 7707               		.loc 1 1122 0 is_stmt 1
 7708 3356 0E94 0000 		call UpdateAudioChannel0
 7709               	.LVL321:
 7710 335a 8093 0000 		sts extIsrOutputBank0,r24
 7711               	.L564:
1124:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 7712               		.loc 1 1124 0
 7713 335e 1092 0000 		sts flipFlop.1807,__zero_reg__
1125:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 7714               		.loc 1 1125 0
 7715 3362 E091 0000 		lds r30,UpdateOutput
 7716 3366 F091 0000 		lds r31,UpdateOutput+1
 7717 336a 0995      		icall
 7718               	.LVL322:
1126:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 7719               		.loc 1 1126 0
 7720 336c 8091 7A00 		lds r24,122
 7721 3370 86FD      		sbrc r24,6
 7722 3372 00C0      		rjmp .L562
1128:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 7723               		.loc 1 1128 0
 7724 3374 8091 7900 		lds r24,121
 7725 3378 8058      		subi r24,lo8(-(-128))
 7726 337a 8093 0000 		sts adcByte,r24
1129:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 7727               		.loc 1 1129 0
 7728 337e 8091 7A00 		lds r24,122
 7729 3382 8064      		ori r24,lo8(64)
 7730 3384 8093 7A00 		sts 122,r24
 7731               	.L562:
 7732               	/* epilogue start */
1131:WTPA.c        **** }
 7733               		.loc 1 1131 0
 7734 3388 FF91      		pop r31
 7735 338a EF91      		pop r30
 7736 338c BF91      		pop r27
 7737 338e AF91      		pop r26
 7738 3390 9F91      		pop r25
 7739 3392 8F91      		pop r24
 7740 3394 7F91      		pop r23
 7741 3396 6F91      		pop r22
 7742 3398 5F91      		pop r21
 7743 339a 4F91      		pop r20
 7744 339c 3F91      		pop r19
 7745 339e 2F91      		pop r18
 7746 33a0 0F90      		pop r0
 7747 33a2 0FBE      		out __SREG__,r0
 7748 33a4 0F90      		pop r0
 7749 33a6 1F90      		pop r1
 7750 33a8 1895      		reti
 7751               		.cfi_endproc
 7752               	.LFE7:
 7754               	.global	__vector_6
 7756               	__vector_6:
 7757               	.LFB8:
1136:WTPA.c        **** {
 7758               		.loc 1 1136 0
 7759               		.cfi_startproc
 7760 33aa 1F92      		push r1
 7761               	.LCFI84:
 7762               		.cfi_def_cfa_offset 3
 7763               		.cfi_offset 1, -2
 7764 33ac 0F92      		push r0
 7765               	.LCFI85:
 7766               		.cfi_def_cfa_offset 4
 7767               		.cfi_offset 0, -3
 7768 33ae 0FB6      		in r0,__SREG__
 7769 33b0 0F92      		push r0
 7770 33b2 1124      		clr __zero_reg__
 7771 33b4 2F93      		push r18
 7772               	.LCFI86:
 7773               		.cfi_def_cfa_offset 5
 7774               		.cfi_offset 18, -4
 7775 33b6 3F93      		push r19
 7776               	.LCFI87:
 7777               		.cfi_def_cfa_offset 6
 7778               		.cfi_offset 19, -5
 7779 33b8 4F93      		push r20
 7780               	.LCFI88:
 7781               		.cfi_def_cfa_offset 7
 7782               		.cfi_offset 20, -6
 7783 33ba 5F93      		push r21
 7784               	.LCFI89:
 7785               		.cfi_def_cfa_offset 8
 7786               		.cfi_offset 21, -7
 7787 33bc 6F93      		push r22
 7788               	.LCFI90:
 7789               		.cfi_def_cfa_offset 9
 7790               		.cfi_offset 22, -8
 7791 33be 7F93      		push r23
 7792               	.LCFI91:
 7793               		.cfi_def_cfa_offset 10
 7794               		.cfi_offset 23, -9
 7795 33c0 8F93      		push r24
 7796               	.LCFI92:
 7797               		.cfi_def_cfa_offset 11
 7798               		.cfi_offset 24, -10
 7799 33c2 9F93      		push r25
 7800               	.LCFI93:
 7801               		.cfi_def_cfa_offset 12
 7802               		.cfi_offset 25, -11
 7803 33c4 AF93      		push r26
 7804               	.LCFI94:
 7805               		.cfi_def_cfa_offset 13
 7806               		.cfi_offset 26, -12
 7807 33c6 BF93      		push r27
 7808               	.LCFI95:
 7809               		.cfi_def_cfa_offset 14
 7810               		.cfi_offset 27, -13
 7811 33c8 EF93      		push r30
 7812               	.LCFI96:
 7813               		.cfi_def_cfa_offset 15
 7814               		.cfi_offset 30, -14
 7815 33ca FF93      		push r31
 7816               	.LCFI97:
 7817               		.cfi_def_cfa_offset 16
 7818               		.cfi_offset 31, -15
 7819               	/* prologue: Signal */
 7820               	/* frame size = 0 */
 7821               	/* stack size = 15 */
 7822               	.L__stack_usage = 15
1141:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 7823               		.loc 1 1141 0
 7824 33cc 8091 0000 		lds r24,bankStates+37
 7825 33d0 8823      		tst r24
 7826 33d2 01F0      		breq .L576
1141:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 7827               		.loc 1 1141 0 is_stmt 0 discriminator 1
 7828 33d4 8091 0000 		lds r24,bankStates+37
 7829 33d8 8823      		tst r24
 7830 33da 01F0      		breq .L577
 7831 33dc 8091 0000 		lds r24,flipFlop.1813
 7832 33e0 8823      		tst r24
 7833 33e2 01F0      		breq .L577
 7834               	.L576:
1143:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
 7835               		.loc 1 1143 0 is_stmt 1
 7836 33e4 0E94 0000 		call UpdateAudioChannel1
 7837               	.LVL323:
 7838 33e8 8093 0000 		sts extIsrOutputBank1,r24
 7839               	.L577:
1145:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 7840               		.loc 1 1145 0
 7841 33ec 1092 0000 		sts flipFlop.1813,__zero_reg__
1146:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 7842               		.loc 1 1146 0
 7843 33f0 E091 0000 		lds r30,UpdateOutput
 7844 33f4 F091 0000 		lds r31,UpdateOutput+1
 7845 33f8 0995      		icall
 7846               	.LVL324:
1147:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 7847               		.loc 1 1147 0
 7848 33fa 8091 7A00 		lds r24,122
 7849 33fe 86FD      		sbrc r24,6
 7850 3400 00C0      		rjmp .L578
1149:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 7851               		.loc 1 1149 0
 7852 3402 8091 7900 		lds r24,121
 7853 3406 8058      		subi r24,lo8(-(-128))
 7854 3408 8093 0000 		sts adcByte,r24
1150:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 7855               		.loc 1 1150 0
 7856 340c 8091 7A00 		lds r24,122
 7857 3410 8064      		ori r24,lo8(64)
 7858 3412 8093 7A00 		sts 122,r24
 7859               	.L578:
1152:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
 7860               		.loc 1 1152 0
 7861 3416 DA9A      		sbi 0x1b,2
 7862               	/* epilogue start */
1161:WTPA.c        **** }
 7863               		.loc 1 1161 0
 7864 3418 FF91      		pop r31
 7865 341a EF91      		pop r30
 7866 341c BF91      		pop r27
 7867 341e AF91      		pop r26
 7868 3420 9F91      		pop r25
 7869 3422 8F91      		pop r24
 7870 3424 7F91      		pop r23
 7871 3426 6F91      		pop r22
 7872 3428 5F91      		pop r21
 7873 342a 4F91      		pop r20
 7874 342c 3F91      		pop r19
 7875 342e 2F91      		pop r18
 7876 3430 0F90      		pop r0
 7877 3432 0FBE      		out __SREG__,r0
 7878 3434 0F90      		pop r0
 7879 3436 1F90      		pop r1
 7880 3438 1895      		reti
 7881               		.cfi_endproc
 7882               	.LFE8:
 7884               	.global	__vector_13
 7886               	__vector_13:
 7887               	.LFB9:
1165:WTPA.c        **** {
 7888               		.loc 1 1165 0
 7889               		.cfi_startproc
 7890 343a 1F92      		push r1
 7891               	.LCFI98:
 7892               		.cfi_def_cfa_offset 3
 7893               		.cfi_offset 1, -2
 7894 343c 0F92      		push r0
 7895               	.LCFI99:
 7896               		.cfi_def_cfa_offset 4
 7897               		.cfi_offset 0, -3
 7898 343e 0FB6      		in r0,__SREG__
 7899 3440 0F92      		push r0
 7900 3442 1124      		clr __zero_reg__
 7901 3444 0F93      		push r16
 7902               	.LCFI100:
 7903               		.cfi_def_cfa_offset 5
 7904               		.cfi_offset 16, -4
 7905 3446 1F93      		push r17
 7906               	.LCFI101:
 7907               		.cfi_def_cfa_offset 6
 7908               		.cfi_offset 17, -5
 7909 3448 2F93      		push r18
 7910               	.LCFI102:
 7911               		.cfi_def_cfa_offset 7
 7912               		.cfi_offset 18, -6
 7913 344a 3F93      		push r19
 7914               	.LCFI103:
 7915               		.cfi_def_cfa_offset 8
 7916               		.cfi_offset 19, -7
 7917 344c 4F93      		push r20
 7918               	.LCFI104:
 7919               		.cfi_def_cfa_offset 9
 7920               		.cfi_offset 20, -8
 7921 344e 5F93      		push r21
 7922               	.LCFI105:
 7923               		.cfi_def_cfa_offset 10
 7924               		.cfi_offset 21, -9
 7925 3450 6F93      		push r22
 7926               	.LCFI106:
 7927               		.cfi_def_cfa_offset 11
 7928               		.cfi_offset 22, -10
 7929 3452 7F93      		push r23
 7930               	.LCFI107:
 7931               		.cfi_def_cfa_offset 12
 7932               		.cfi_offset 23, -11
 7933 3454 8F93      		push r24
 7934               	.LCFI108:
 7935               		.cfi_def_cfa_offset 13
 7936               		.cfi_offset 24, -12
 7937 3456 9F93      		push r25
 7938               	.LCFI109:
 7939               		.cfi_def_cfa_offset 14
 7940               		.cfi_offset 25, -13
 7941 3458 AF93      		push r26
 7942               	.LCFI110:
 7943               		.cfi_def_cfa_offset 15
 7944               		.cfi_offset 26, -14
 7945 345a BF93      		push r27
 7946               	.LCFI111:
 7947               		.cfi_def_cfa_offset 16
 7948               		.cfi_offset 27, -15
 7949 345c CF93      		push r28
 7950               	.LCFI112:
 7951               		.cfi_def_cfa_offset 17
 7952               		.cfi_offset 28, -16
 7953 345e DF93      		push r29
 7954               	.LCFI113:
 7955               		.cfi_def_cfa_offset 18
 7956               		.cfi_offset 29, -17
 7957 3460 EF93      		push r30
 7958               	.LCFI114:
 7959               		.cfi_def_cfa_offset 19
 7960               		.cfi_offset 30, -18
 7961 3462 FF93      		push r31
 7962               	.LCFI115:
 7963               		.cfi_def_cfa_offset 20
 7964               		.cfi_offset 31, -19
 7965               	/* prologue: Signal */
 7966               	/* frame size = 0 */
 7967               	/* stack size = 19 */
 7968               	.L__stack_usage = 19
1175:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7969               		.loc 1 1175 0
 7970 3464 8091 0000 		lds r24,bankStates+2
 7971 3468 8823      		tst r24
 7972 346a 01F0      		breq .L589
1175:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 7973               		.loc 1 1175 0 is_stmt 0 discriminator 1
 7974 346c 8091 0000 		lds r24,bankStates+2
 7975 3470 8823      		tst r24
 7976 3472 01F0      		breq .L590
 7977 3474 8091 0000 		lds r24,flipFlop.1821
 7978 3478 8823      		tst r24
 7979 347a 01F0      		breq .L590
 7980               	.L589:
1177:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
 7981               		.loc 1 1177 0 is_stmt 1
 7982 347c 0E94 0000 		call UpdateAudioChannel0
 7983               	.LVL325:
 7984 3480 8093 0000 		sts midiOutputBank0,r24
 7985               	.L590:
1179:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
 7986               		.loc 1 1179 0
 7987 3484 8091 0000 		lds r24,bankStates+7
 7988 3488 8823      		tst r24
 7989 348a 01F0      		breq .L591
1181:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
 7990               		.loc 1 1181 0
 7991 348c A091 0000 		lds r26,bankStates+7
 7992 3490 2091 0000 		lds r18,bankStates+10
 7993 3494 3091 0000 		lds r19,bankStates+10+1
 7994               	.LVL326:
 7995 3498 B0E0      		ldi r27,0
 7996 349a 0E94 0000 		call __umulhisi3
1182:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 7997               		.loc 1 1182 0
 7998 349e 2FE7      		ldi r18,lo8(127)
 7999 34a0 30E0      		ldi r19,0
 8000 34a2 40E0      		ldi r20,0
 8001 34a4 50E0      		ldi r21,0
 8002               	.LVL327:
 8003 34a6 0E94 0000 		call __udivmodsi4
 8004               	.LVL328:
1183:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8005               		.loc 1 1183 0
 8006 34aa 0091 8800 		lds r16,136
 8007 34ae 1091 8900 		lds r17,136+1
 8008 34b2 C091 0000 		lds r28,bankStates+10
 8009 34b6 D091 0000 		lds r29,bankStates+10+1
1182:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8010               		.loc 1 1182 0
 8011 34ba 6091 0000 		lds r22,random31
 8012 34be 7091 0000 		lds r23,random31+1
 8013 34c2 8091 0000 		lds r24,random31+2
 8014 34c6 9091 0000 		lds r25,random31+3
 8015 34ca 0E94 0000 		call __udivmodsi4
 8016               	.LVL329:
1183:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8017               		.loc 1 1183 0
 8018 34ce C00F      		add r28,r16
 8019 34d0 D11F      		adc r29,r17
 8020 34d2 4091 0000 		lds r20,lastJitterValue.1820
 8021 34d6 5091 0000 		lds r21,lastJitterValue.1820+1
 8022 34da C40F      		add r28,r20
 8023 34dc D51F      		adc r29,r21
 8024 34de C61B      		sub r28,r22
 8025 34e0 D70B      		sbc r29,r23
 8026 34e2 D093 8900 		sts 136+1,r29
 8027 34e6 C093 8800 		sts 136,r28
1184:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8028               		.loc 1 1184 0
 8029 34ea 7093 0000 		sts lastJitterValue.1820+1,r23
 8030 34ee 6093 0000 		sts lastJitterValue.1820,r22
 8031 34f2 00C0      		rjmp .L592
 8032               	.LVL330:
 8033               	.L591:
1188:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8034               		.loc 1 1188 0
 8035 34f4 2091 8800 		lds r18,136
 8036 34f8 3091 8900 		lds r19,136+1
 8037 34fc 8091 0000 		lds r24,bankStates+10
 8038 3500 9091 0000 		lds r25,bankStates+10+1
 8039 3504 820F      		add r24,r18
 8040 3506 931F      		adc r25,r19
 8041 3508 9093 8900 		sts 136+1,r25
 8042 350c 8093 8800 		sts 136,r24
 8043               	.L592:
1190:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8044               		.loc 1 1190 0
 8045 3510 1092 0000 		sts flipFlop.1821,__zero_reg__
1191:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8046               		.loc 1 1191 0
 8047 3514 E091 0000 		lds r30,UpdateOutput
 8048 3518 F091 0000 		lds r31,UpdateOutput+1
 8049 351c 0995      		icall
 8050               	.LVL331:
1192:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8051               		.loc 1 1192 0
 8052 351e 8091 7A00 		lds r24,122
 8053 3522 86FD      		sbrc r24,6
 8054 3524 00C0      		rjmp .L588
1194:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8055               		.loc 1 1194 0
 8056 3526 8091 7900 		lds r24,121
 8057 352a 8058      		subi r24,lo8(-(-128))
 8058 352c 8093 0000 		sts adcByte,r24
1195:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8059               		.loc 1 1195 0
 8060 3530 8091 7A00 		lds r24,122
 8061 3534 8064      		ori r24,lo8(64)
 8062 3536 8093 7A00 		sts 122,r24
 8063               	.L588:
 8064               	/* epilogue start */
1197:WTPA.c        **** }
 8065               		.loc 1 1197 0
 8066 353a FF91      		pop r31
 8067 353c EF91      		pop r30
 8068 353e DF91      		pop r29
 8069 3540 CF91      		pop r28
 8070 3542 BF91      		pop r27
 8071 3544 AF91      		pop r26
 8072 3546 9F91      		pop r25
 8073 3548 8F91      		pop r24
 8074 354a 7F91      		pop r23
 8075 354c 6F91      		pop r22
 8076 354e 5F91      		pop r21
 8077 3550 4F91      		pop r20
 8078 3552 3F91      		pop r19
 8079 3554 2F91      		pop r18
 8080 3556 1F91      		pop r17
 8081 3558 0F91      		pop r16
 8082 355a 0F90      		pop r0
 8083 355c 0FBE      		out __SREG__,r0
 8084 355e 0F90      		pop r0
 8085 3560 1F90      		pop r1
 8086 3562 1895      		reti
 8087               		.cfi_endproc
 8088               	.LFE9:
 8090               	.global	__vector_14
 8092               	__vector_14:
 8093               	.LFB10:
1201:WTPA.c        **** {
 8094               		.loc 1 1201 0
 8095               		.cfi_startproc
 8096 3564 1F92      		push r1
 8097               	.LCFI116:
 8098               		.cfi_def_cfa_offset 3
 8099               		.cfi_offset 1, -2
 8100 3566 0F92      		push r0
 8101               	.LCFI117:
 8102               		.cfi_def_cfa_offset 4
 8103               		.cfi_offset 0, -3
 8104 3568 0FB6      		in r0,__SREG__
 8105 356a 0F92      		push r0
 8106 356c 1124      		clr __zero_reg__
 8107 356e 0F93      		push r16
 8108               	.LCFI118:
 8109               		.cfi_def_cfa_offset 5
 8110               		.cfi_offset 16, -4
 8111 3570 1F93      		push r17
 8112               	.LCFI119:
 8113               		.cfi_def_cfa_offset 6
 8114               		.cfi_offset 17, -5
 8115 3572 2F93      		push r18
 8116               	.LCFI120:
 8117               		.cfi_def_cfa_offset 7
 8118               		.cfi_offset 18, -6
 8119 3574 3F93      		push r19
 8120               	.LCFI121:
 8121               		.cfi_def_cfa_offset 8
 8122               		.cfi_offset 19, -7
 8123 3576 4F93      		push r20
 8124               	.LCFI122:
 8125               		.cfi_def_cfa_offset 9
 8126               		.cfi_offset 20, -8
 8127 3578 5F93      		push r21
 8128               	.LCFI123:
 8129               		.cfi_def_cfa_offset 10
 8130               		.cfi_offset 21, -9
 8131 357a 6F93      		push r22
 8132               	.LCFI124:
 8133               		.cfi_def_cfa_offset 11
 8134               		.cfi_offset 22, -10
 8135 357c 7F93      		push r23
 8136               	.LCFI125:
 8137               		.cfi_def_cfa_offset 12
 8138               		.cfi_offset 23, -11
 8139 357e 8F93      		push r24
 8140               	.LCFI126:
 8141               		.cfi_def_cfa_offset 13
 8142               		.cfi_offset 24, -12
 8143 3580 9F93      		push r25
 8144               	.LCFI127:
 8145               		.cfi_def_cfa_offset 14
 8146               		.cfi_offset 25, -13
 8147 3582 AF93      		push r26
 8148               	.LCFI128:
 8149               		.cfi_def_cfa_offset 15
 8150               		.cfi_offset 26, -14
 8151 3584 BF93      		push r27
 8152               	.LCFI129:
 8153               		.cfi_def_cfa_offset 16
 8154               		.cfi_offset 27, -15
 8155 3586 CF93      		push r28
 8156               	.LCFI130:
 8157               		.cfi_def_cfa_offset 17
 8158               		.cfi_offset 28, -16
 8159 3588 DF93      		push r29
 8160               	.LCFI131:
 8161               		.cfi_def_cfa_offset 18
 8162               		.cfi_offset 29, -17
 8163 358a EF93      		push r30
 8164               	.LCFI132:
 8165               		.cfi_def_cfa_offset 19
 8166               		.cfi_offset 30, -18
 8167 358c FF93      		push r31
 8168               	.LCFI133:
 8169               		.cfi_def_cfa_offset 20
 8170               		.cfi_offset 31, -19
 8171               	/* prologue: Signal */
 8172               	/* frame size = 0 */
 8173               	/* stack size = 19 */
 8174               	.L__stack_usage = 19
1211:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8175               		.loc 1 1211 0
 8176 358e 8091 0000 		lds r24,bankStates+37
 8177 3592 8823      		tst r24
 8178 3594 01F0      		breq .L604
1211:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 8179               		.loc 1 1211 0 is_stmt 0 discriminator 1
 8180 3596 8091 0000 		lds r24,bankStates+37
 8181 359a 8823      		tst r24
 8182 359c 01F0      		breq .L605
 8183 359e 8091 0000 		lds r24,flipFlop.1829
 8184 35a2 8823      		tst r24
 8185 35a4 01F0      		breq .L605
 8186               	.L604:
1213:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
 8187               		.loc 1 1213 0 is_stmt 1
 8188 35a6 0E94 0000 		call UpdateAudioChannel1
 8189               	.LVL332:
 8190 35aa 8093 0000 		sts midiOutputBank1,r24
 8191               	.L605:
1215:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
 8192               		.loc 1 1215 0
 8193 35ae 8091 0000 		lds r24,bankStates+42
 8194 35b2 8823      		tst r24
 8195 35b4 01F0      		breq .L606
1217:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
 8196               		.loc 1 1217 0
 8197 35b6 A091 0000 		lds r26,bankStates+42
 8198 35ba 2091 0000 		lds r18,bankStates+45
 8199 35be 3091 0000 		lds r19,bankStates+45+1
 8200               	.LVL333:
 8201 35c2 B0E0      		ldi r27,0
 8202 35c4 0E94 0000 		call __umulhisi3
1218:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8203               		.loc 1 1218 0
 8204 35c8 2FE7      		ldi r18,lo8(127)
 8205 35ca 30E0      		ldi r19,0
 8206 35cc 40E0      		ldi r20,0
 8207 35ce 50E0      		ldi r21,0
 8208               	.LVL334:
 8209 35d0 0E94 0000 		call __udivmodsi4
 8210               	.LVL335:
1219:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8211               		.loc 1 1219 0
 8212 35d4 0091 8A00 		lds r16,138
 8213 35d8 1091 8B00 		lds r17,138+1
 8214 35dc C091 0000 		lds r28,bankStates+45
 8215 35e0 D091 0000 		lds r29,bankStates+45+1
1218:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 8216               		.loc 1 1218 0
 8217 35e4 6091 0000 		lds r22,random31
 8218 35e8 7091 0000 		lds r23,random31+1
 8219 35ec 8091 0000 		lds r24,random31+2
 8220 35f0 9091 0000 		lds r25,random31+3
 8221 35f4 0E94 0000 		call __udivmodsi4
 8222               	.LVL336:
1219:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 8223               		.loc 1 1219 0
 8224 35f8 C00F      		add r28,r16
 8225 35fa D11F      		adc r29,r17
 8226 35fc 4091 0000 		lds r20,lastJitterValue.1828
 8227 3600 5091 0000 		lds r21,lastJitterValue.1828+1
 8228 3604 C40F      		add r28,r20
 8229 3606 D51F      		adc r29,r21
 8230 3608 C61B      		sub r28,r22
 8231 360a D70B      		sbc r29,r23
 8232 360c D093 8B00 		sts 138+1,r29
 8233 3610 C093 8A00 		sts 138,r28
1220:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 8234               		.loc 1 1220 0
 8235 3614 7093 0000 		sts lastJitterValue.1828+1,r23
 8236 3618 6093 0000 		sts lastJitterValue.1828,r22
 8237 361c 00C0      		rjmp .L607
 8238               	.LVL337:
 8239               	.L606:
1224:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 8240               		.loc 1 1224 0
 8241 361e 2091 8A00 		lds r18,138
 8242 3622 3091 8B00 		lds r19,138+1
 8243 3626 8091 0000 		lds r24,bankStates+45
 8244 362a 9091 0000 		lds r25,bankStates+45+1
 8245 362e 820F      		add r24,r18
 8246 3630 931F      		adc r25,r19
 8247 3632 9093 8B00 		sts 138+1,r25
 8248 3636 8093 8A00 		sts 138,r24
 8249               	.L607:
1226:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 8250               		.loc 1 1226 0
 8251 363a 1092 0000 		sts flipFlop.1829,__zero_reg__
1227:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 8252               		.loc 1 1227 0
 8253 363e E091 0000 		lds r30,UpdateOutput
 8254 3642 F091 0000 		lds r31,UpdateOutput+1
 8255 3646 0995      		icall
 8256               	.LVL338:
1228:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8257               		.loc 1 1228 0
 8258 3648 8091 7A00 		lds r24,122
 8259 364c 86FD      		sbrc r24,6
 8260 364e 00C0      		rjmp .L603
1230:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 8261               		.loc 1 1230 0
 8262 3650 8091 7900 		lds r24,121
 8263 3654 8058      		subi r24,lo8(-(-128))
 8264 3656 8093 0000 		sts adcByte,r24
1231:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 8265               		.loc 1 1231 0
 8266 365a 8091 7A00 		lds r24,122
 8267 365e 8064      		ori r24,lo8(64)
 8268 3660 8093 7A00 		sts 122,r24
 8269               	.L603:
 8270               	/* epilogue start */
1233:WTPA.c        **** }
 8271               		.loc 1 1233 0
 8272 3664 FF91      		pop r31
 8273 3666 EF91      		pop r30
 8274 3668 DF91      		pop r29
 8275 366a CF91      		pop r28
 8276 366c BF91      		pop r27
 8277 366e AF91      		pop r26
 8278 3670 9F91      		pop r25
 8279 3672 8F91      		pop r24
 8280 3674 7F91      		pop r23
 8281 3676 6F91      		pop r22
 8282 3678 5F91      		pop r21
 8283 367a 4F91      		pop r20
 8284 367c 3F91      		pop r19
 8285 367e 2F91      		pop r18
 8286 3680 1F91      		pop r17
 8287 3682 0F91      		pop r16
 8288 3684 0F90      		pop r0
 8289 3686 0FBE      		out __SREG__,r0
 8290 3688 0F90      		pop r0
 8291 368a 1F90      		pop r1
 8292 368c 1895      		reti
 8293               		.cfi_endproc
 8294               	.LFE10:
 8296               	.global	__vector_10
 8298               	__vector_10:
 8299               	.LFB11:
1239:WTPA.c        **** {
 8300               		.loc 1 1239 0
 8301               		.cfi_startproc
 8302 368e 1F92      		push r1
 8303               	.LCFI134:
 8304               		.cfi_def_cfa_offset 3
 8305               		.cfi_offset 1, -2
 8306 3690 0F92      		push r0
 8307               	.LCFI135:
 8308               		.cfi_def_cfa_offset 4
 8309               		.cfi_offset 0, -3
 8310 3692 0FB6      		in r0,__SREG__
 8311 3694 0F92      		push r0
 8312 3696 1124      		clr __zero_reg__
 8313 3698 2F93      		push r18
 8314               	.LCFI136:
 8315               		.cfi_def_cfa_offset 5
 8316               		.cfi_offset 18, -4
 8317 369a 3F93      		push r19
 8318               	.LCFI137:
 8319               		.cfi_def_cfa_offset 6
 8320               		.cfi_offset 19, -5
 8321 369c 4F93      		push r20
 8322               	.LCFI138:
 8323               		.cfi_def_cfa_offset 7
 8324               		.cfi_offset 20, -6
 8325 369e 5F93      		push r21
 8326               	.LCFI139:
 8327               		.cfi_def_cfa_offset 8
 8328               		.cfi_offset 21, -7
 8329 36a0 6F93      		push r22
 8330               	.LCFI140:
 8331               		.cfi_def_cfa_offset 9
 8332               		.cfi_offset 22, -8
 8333 36a2 7F93      		push r23
 8334               	.LCFI141:
 8335               		.cfi_def_cfa_offset 10
 8336               		.cfi_offset 23, -9
 8337 36a4 8F93      		push r24
 8338               	.LCFI142:
 8339               		.cfi_def_cfa_offset 11
 8340               		.cfi_offset 24, -10
 8341 36a6 9F93      		push r25
 8342               	.LCFI143:
 8343               		.cfi_def_cfa_offset 12
 8344               		.cfi_offset 25, -11
 8345 36a8 AF93      		push r26
 8346               	.LCFI144:
 8347               		.cfi_def_cfa_offset 13
 8348               		.cfi_offset 26, -12
 8349 36aa BF93      		push r27
 8350               	.LCFI145:
 8351               		.cfi_def_cfa_offset 14
 8352               		.cfi_offset 27, -13
 8353 36ac EF93      		push r30
 8354               	.LCFI146:
 8355               		.cfi_def_cfa_offset 15
 8356               		.cfi_offset 30, -14
 8357 36ae FF93      		push r31
 8358               	.LCFI147:
 8359               		.cfi_def_cfa_offset 16
 8360               		.cfi_offset 31, -15
 8361               	/* prologue: Signal */
 8362               	/* frame size = 0 */
 8363               	/* stack size = 15 */
 8364               	.L__stack_usage = 15
1243:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
 8365               		.loc 1 1243 0
 8366 36b0 8091 0000 		lds r24,sdIsrState
 8367 36b4 8130      		cpi r24,lo8(1)
 8368 36b6 01F0      		breq .+2
 8369 36b8 00C0      		rjmp .L619
1245:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 8370               		.loc 1 1245 0
 8371 36ba 8091 0000 		lds r24,sdRamSampleRemaining
 8372 36be 9091 0000 		lds r25,sdRamSampleRemaining+1
 8373 36c2 A091 0000 		lds r26,sdRamSampleRemaining+2
 8374 36c6 B091 0000 		lds r27,sdRamSampleRemaining+3
 8375 36ca 892B      		or r24,r25
 8376 36cc 8A2B      		or r24,r26
 8377 36ce 8B2B      		or r24,r27
 8378 36d0 01F4      		brne .+2
 8379 36d2 00C0      		rjmp .L620
1247:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 8380               		.loc 1 1247 0
 8381 36d4 8091 0000 		lds r24,sdBytesInFifo
 8382 36d8 9091 0000 		lds r25,sdBytesInFifo+1
 8383 36dc 892B      		or r24,r25
 8384 36de 01F4      		brne .+2
 8385 36e0 00C0      		rjmp .L618
1249:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 8386               		.loc 1 1249 0
 8387 36e2 E091 0000 		lds r30,sdFifoReadPointer
 8388 36e6 F091 0000 		lds r31,sdFifoReadPointer+1
 8389 36ea E050      		subi r30,lo8(-(sdFifo))
 8390 36ec F040      		sbci r31,hi8(-(sdFifo))
 8391 36ee 2081      		ld r18,Z
 8392               	.LVL339:
1251:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 8393               		.loc 1 1251 0
 8394 36f0 8091 0000 		lds r24,sdFifoReadPointer
 8395 36f4 9091 0000 		lds r25,sdFifoReadPointer+1
 8396 36f8 0196      		adiw r24,1
 8397 36fa 9093 0000 		sts sdFifoReadPointer+1,r25
 8398 36fe 8093 0000 		sts sdFifoReadPointer,r24
1252:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 8399               		.loc 1 1252 0
 8400 3702 8091 0000 		lds r24,sdFifoReadPointer
 8401 3706 9091 0000 		lds r25,sdFifoReadPointer+1
 8402 370a 8115      		cp r24,__zero_reg__
 8403 370c 9340      		sbci r25,3
 8404 370e 00F0      		brlo .L622
1254:WTPA.c        **** 					sdFifoReadPointer=0;
 8405               		.loc 1 1254 0
 8406 3710 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 8407 3714 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 8408               	.L622:
1257:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 8409               		.loc 1 1257 0
 8410 3718 8091 0000 		lds r24,sdBytesInFifo
 8411 371c 9091 0000 		lds r25,sdBytesInFifo+1
 8412 3720 0197      		sbiw r24,1
 8413 3722 9093 0000 		sts sdBytesInFifo+1,r25
 8414 3726 8093 0000 		sts sdBytesInFifo,r24
1258:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 8415               		.loc 1 1258 0
 8416 372a 8091 0000 		lds r24,sdRamSampleRemaining
 8417 372e 9091 0000 		lds r25,sdRamSampleRemaining+1
 8418 3732 A091 0000 		lds r26,sdRamSampleRemaining+2
 8419 3736 B091 0000 		lds r27,sdRamSampleRemaining+3
 8420 373a 0197      		sbiw r24,1
 8421 373c A109      		sbc r26,__zero_reg__
 8422 373e B109      		sbc r27,__zero_reg__
 8423 3740 8093 0000 		sts sdRamSampleRemaining,r24
 8424 3744 9093 0000 		sts sdRamSampleRemaining+1,r25
 8425 3748 A093 0000 		sts sdRamSampleRemaining+2,r26
 8426 374c B093 0000 		sts sdRamSampleRemaining+3,r27
1262:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
 8427               		.loc 1 1262 0
 8428 3750 8FEF      		ldi r24,lo8(-1)
 8429 3752 84B9      		out 0x4,r24
1263:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
 8430               		.loc 1 1263 0
 8431 3754 8091 0000 		lds r24,sdRamAddress
 8432 3758 85B9      		out 0x5,r24
1264:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
 8433               		.loc 1 1264 0
 8434 375a 139A      		sbi 0x2,3
1265:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
 8435               		.loc 1 1265 0
 8436 375c 1398      		cbi 0x2,3
1267:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
 8437               		.loc 1 1267 0
 8438 375e 4091 0000 		lds r20,sdRamAddress
 8439 3762 5091 0000 		lds r21,sdRamAddress+1
 8440 3766 6091 0000 		lds r22,sdRamAddress+2
 8441 376a 7091 0000 		lds r23,sdRamAddress+3
 8442 376e BB27      		clr r27
 8443 3770 A72F      		mov r26,r23
 8444 3772 962F      		mov r25,r22
 8445 3774 852F      		mov r24,r21
 8446 3776 85B9      		out 0x5,r24
1268:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
 8447               		.loc 1 1268 0
 8448 3778 149A      		sbi 0x2,4
1269:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
 8449               		.loc 1 1269 0
 8450 377a 1498      		cbi 0x2,4
1270:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high
 8451               		.loc 1 1270 0
 8452 377c CB01      		movw r24,r22
 8453 377e AA27      		clr r26
 8454 3780 BB27      		clr r27
 8455 3782 8770      		andi r24,7
 8456 3784 9927      		clr r25
 8457 3786 AA27      		clr r26
 8458 3788 BB27      		clr r27
 8459 378a 8868      		ori r24,136
 8460 378c 88B9      		out 0x8,r24
1272:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
 8461               		.loc 1 1272 0
 8462 378e 25B9      		out 0x5,r18
1275:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
 8463               		.loc 1 1275 0
 8464 3790 8091 0000 		lds r24,sdBank0
 8465 3794 8130      		cpi r24,lo8(1)
 8466 3796 01F4      		brne .L623
1277:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 8467               		.loc 1 1277 0
 8468 3798 4F5F      		subi r20,-1
 8469 379a 5F4F      		sbci r21,-1
 8470 379c 6F4F      		sbci r22,-1
 8471 379e 7F4F      		sbci r23,-1
 8472 37a0 00C0      		rjmp .L640
 8473               	.L623:
1281:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 8474               		.loc 1 1281 0
 8475 37a2 4150      		subi r20,1
 8476 37a4 5109      		sbc r21,__zero_reg__
 8477 37a6 6109      		sbc r22,__zero_reg__
 8478 37a8 7109      		sbc r23,__zero_reg__
 8479               	.L640:
 8480 37aa 4093 0000 		sts sdRamAddress,r20
 8481 37ae 5093 0000 		sts sdRamAddress+1,r21
 8482 37b2 6093 0000 		sts sdRamAddress+2,r22
 8483 37b6 7093 0000 		sts sdRamAddress+3,r23
1285:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 8484               		.loc 1 1285 0
 8485 37ba 1198      		cbi 0x2,1
1286:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
 8486               		.loc 1 1286 0
 8487 37bc 119A      		sbi 0x2,1
 8488 37be 00C0      		rjmp .L618
 8489               	.LVL340:
 8490               	.L620:
1292:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8491               		.loc 1 1292 0
 8492 37c0 1092 0000 		sts sdIsrState,__zero_reg__
1293:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 8493               		.loc 1 1293 0
 8494 37c4 1092 B100 		sts 177,__zero_reg__
1294:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8495               		.loc 1 1294 0
 8496 37c8 8091 7000 		lds r24,112
 8497 37cc 8B7F      		andi r24,lo8(-5)
 8498 37ce 8093 7000 		sts 112,r24
1296:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
 8499               		.loc 1 1296 0
 8500 37d2 2091 0000 		lds r18,sdBank0
 8501 37d6 8091 0000 		lds r24,sdRamAddress
 8502 37da 9091 0000 		lds r25,sdRamAddress+1
 8503 37de A091 0000 		lds r26,sdRamAddress+2
 8504 37e2 B091 0000 		lds r27,sdRamAddress+3
 8505 37e6 2130      		cpi r18,lo8(1)
 8506 37e8 01F4      		brne .L625
1298:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
 8507               		.loc 1 1298 0
 8508 37ea 1092 0000 		sts bankStates+5,__zero_reg__
1299:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8509               		.loc 1 1299 0
 8510 37ee 8093 0000 		sts bankStates+12,r24
 8511 37f2 9093 0000 		sts bankStates+12+1,r25
 8512 37f6 A093 0000 		sts bankStates+12+2,r26
 8513 37fa B093 0000 		sts bankStates+12+3,r27
1300:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8514               		.loc 1 1300 0
 8515 37fe 8093 0000 		sts bankStates+20,r24
 8516 3802 9093 0000 		sts bankStates+20+1,r25
 8517 3806 A093 0000 		sts bankStates+20+2,r26
 8518 380a B093 0000 		sts bankStates+20+3,r27
 8519 380e 00C0      		rjmp .L618
 8520               	.L625:
1304:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
 8521               		.loc 1 1304 0
 8522 3810 1092 0000 		sts bankStates+40,__zero_reg__
1305:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 8523               		.loc 1 1305 0
 8524 3814 8093 0000 		sts bankStates+47,r24
 8525 3818 9093 0000 		sts bankStates+47+1,r25
 8526 381c A093 0000 		sts bankStates+47+2,r26
 8527 3820 B093 0000 		sts bankStates+47+3,r27
1306:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 8528               		.loc 1 1306 0
 8529 3824 8093 0000 		sts bankStates+55,r24
 8530 3828 9093 0000 		sts bankStates+55+1,r25
 8531 382c A093 0000 		sts bankStates+55+2,r26
 8532 3830 B093 0000 		sts bankStates+55+3,r27
 8533 3834 00C0      		rjmp .L618
 8534               	.L619:
1310:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
 8535               		.loc 1 1310 0
 8536 3836 8230      		cpi r24,lo8(2)
 8537 3838 01F0      		breq .+2
 8538 383a 00C0      		rjmp .L626
1313:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
 8539               		.loc 1 1313 0
 8540 383c 8091 0000 		lds r24,sdBytesInFifo
 8541 3840 9091 0000 		lds r25,sdBytesInFifo+1
 8542 3844 8115      		cp r24,__zero_reg__
 8543 3846 9340      		sbci r25,3
 8544 3848 00F0      		brlo .+2
 8545 384a 00C0      		rjmp .L618
1315:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
 8546               		.loc 1 1315 0
 8547 384c 8091 0000 		lds r24,sdRamSampleRemaining
 8548 3850 9091 0000 		lds r25,sdRamSampleRemaining+1
 8549 3854 A091 0000 		lds r26,sdRamSampleRemaining+2
 8550 3858 B091 0000 		lds r27,sdRamSampleRemaining+3
 8551 385c 892B      		or r24,r25
 8552 385e 8A2B      		or r24,r26
 8553 3860 8B2B      		or r24,r27
 8554 3862 01F4      		brne .+2
 8555 3864 00C0      		rjmp .L627
1318:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
 8556               		.loc 1 1318 0
 8557 3866 8091 0000 		lds r24,sdRamAddress
 8558 386a 85B9      		out 0x5,r24
1319:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
 8559               		.loc 1 1319 0
 8560 386c 139A      		sbi 0x2,3
1320:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
 8561               		.loc 1 1320 0
 8562 386e 1398      		cbi 0x2,3
1322:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
 8563               		.loc 1 1322 0
 8564 3870 4091 0000 		lds r20,sdRamAddress
 8565 3874 5091 0000 		lds r21,sdRamAddress+1
 8566 3878 6091 0000 		lds r22,sdRamAddress+2
 8567 387c 7091 0000 		lds r23,sdRamAddress+3
 8568 3880 BB27      		clr r27
 8569 3882 A72F      		mov r26,r23
 8570 3884 962F      		mov r25,r22
 8571 3886 852F      		mov r24,r21
 8572 3888 85B9      		out 0x5,r24
1323:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
 8573               		.loc 1 1323 0
 8574 388a 149A      		sbi 0x2,4
1324:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
 8575               		.loc 1 1324 0
 8576 388c 1498      		cbi 0x2,4
1326:WTPA.c        **** 				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high 
 8577               		.loc 1 1326 0
 8578 388e CB01      		movw r24,r22
 8579 3890 AA27      		clr r26
 8580 3892 BB27      		clr r27
 8581 3894 8770      		andi r24,7
 8582 3896 9927      		clr r25
 8583 3898 AA27      		clr r26
 8584 389a BB27      		clr r27
 8585 389c 8868      		ori r24,136
 8586 389e 88B9      		out 0x8,r24
1328:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 8587               		.loc 1 1328 0
 8588 38a0 14B8      		out 0x4,__zero_reg__
1329:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 8589               		.loc 1 1329 0
 8590 38a2 1298      		cbi 0x2,2
1332:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
 8591               		.loc 1 1332 0
 8592 38a4 8091 0000 		lds r24,sdBank0
 8593 38a8 8130      		cpi r24,lo8(1)
 8594 38aa 01F4      		brne .L628
1334:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 8595               		.loc 1 1334 0
 8596 38ac 4F5F      		subi r20,-1
 8597 38ae 5F4F      		sbci r21,-1
 8598 38b0 6F4F      		sbci r22,-1
 8599 38b2 7F4F      		sbci r23,-1
 8600 38b4 00C0      		rjmp .L641
 8601               	.L628:
1338:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 8602               		.loc 1 1338 0
 8603 38b6 4150      		subi r20,1
 8604 38b8 5109      		sbc r21,__zero_reg__
 8605 38ba 6109      		sbc r22,__zero_reg__
 8606 38bc 7109      		sbc r23,__zero_reg__
 8607               	.L641:
 8608 38be 4093 0000 		sts sdRamAddress,r20
 8609 38c2 5093 0000 		sts sdRamAddress+1,r21
 8610 38c6 6093 0000 		sts sdRamAddress+2,r22
 8611 38ca 7093 0000 		sts sdRamAddress+3,r23
1343:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 8612               		.loc 1 1343 0
 8613 38ce 83B1      		in r24,0x3
 8614               	.LVL341:
1344:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 8615               		.loc 1 1344 0
 8616 38d0 129A      		sbi 0x2,2
1345:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 8617               		.loc 1 1345 0
 8618 38d2 9FEF      		ldi r25,lo8(-1)
 8619 38d4 94B9      		out 0x4,r25
1350:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
 8620               		.loc 1 1350 0
 8621 38d6 E091 0000 		lds r30,sdFifoWritePointer
 8622 38da F091 0000 		lds r31,sdFifoWritePointer+1
 8623 38de E050      		subi r30,lo8(-(sdFifo))
 8624 38e0 F040      		sbci r31,hi8(-(sdFifo))
 8625 38e2 8083      		st Z,r24
1351:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
 8626               		.loc 1 1351 0
 8627 38e4 8091 0000 		lds r24,sdFifoWritePointer
 8628 38e8 9091 0000 		lds r25,sdFifoWritePointer+1
 8629               	.LVL342:
 8630 38ec 0196      		adiw r24,1
 8631 38ee 9093 0000 		sts sdFifoWritePointer+1,r25
 8632 38f2 8093 0000 		sts sdFifoWritePointer,r24
1353:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
 8633               		.loc 1 1353 0
 8634 38f6 8091 0000 		lds r24,sdFifoWritePointer
 8635 38fa 9091 0000 		lds r25,sdFifoWritePointer+1
 8636 38fe 8115      		cp r24,__zero_reg__
 8637 3900 9340      		sbci r25,3
 8638 3902 00F0      		brlo .L630
1355:WTPA.c        **** 					sdFifoWritePointer=0;
 8639               		.loc 1 1355 0
 8640 3904 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 8641 3908 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 8642               	.L630:
1358:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
 8643               		.loc 1 1358 0
 8644 390c 8091 0000 		lds r24,sdBytesInFifo
 8645 3910 9091 0000 		lds r25,sdBytesInFifo+1
 8646 3914 0196      		adiw r24,1
 8647 3916 9093 0000 		sts sdBytesInFifo+1,r25
 8648 391a 8093 0000 		sts sdBytesInFifo,r24
1359:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
 8649               		.loc 1 1359 0
 8650 391e 8091 0000 		lds r24,sdRamSampleRemaining
 8651 3922 9091 0000 		lds r25,sdRamSampleRemaining+1
 8652 3926 A091 0000 		lds r26,sdRamSampleRemaining+2
 8653 392a B091 0000 		lds r27,sdRamSampleRemaining+3
 8654 392e 0197      		sbiw r24,1
 8655 3930 A109      		sbc r26,__zero_reg__
 8656 3932 B109      		sbc r27,__zero_reg__
 8657 3934 8093 0000 		sts sdRamSampleRemaining,r24
 8658 3938 9093 0000 		sts sdRamSampleRemaining+1,r25
 8659 393c A093 0000 		sts sdRamSampleRemaining+2,r26
 8660 3940 B093 0000 		sts sdRamSampleRemaining+3,r27
 8661 3944 00C0      		rjmp .L618
 8662               	.LVL343:
 8663               	.L627:
1364:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8664               		.loc 1 1364 0
 8665 3946 1092 0000 		sts sdIsrState,__zero_reg__
1365:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
 8666               		.loc 1 1365 0
 8667 394a 1092 B100 		sts 177,__zero_reg__
1366:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8668               		.loc 1 1366 0
 8669 394e 8091 7000 		lds r24,112
 8670 3952 8B7F      		andi r24,lo8(-5)
 8671 3954 8093 7000 		sts 112,r24
1368:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
 8672               		.loc 1 1368 0
 8673 3958 8091 0000 		lds r24,sdBank0
 8674 395c 8130      		cpi r24,lo8(1)
 8675 395e 01F4      		brne .L631
1370:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
 8676               		.loc 1 1370 0
 8677 3960 1092 0000 		sts bankStates+5,__zero_reg__
 8678 3964 00C0      		rjmp .L618
 8679               	.L631:
1374:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
 8680               		.loc 1 1374 0
 8681 3966 1092 0000 		sts bankStates+40,__zero_reg__
 8682 396a 00C0      		rjmp .L618
 8683               	.L626:
1379:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
 8684               		.loc 1 1379 0
 8685 396c 8330      		cpi r24,lo8(3)
 8686 396e 01F0      		breq .+2
 8687 3970 00C0      		rjmp .L618
1381:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 8688               		.loc 1 1381 0
 8689 3972 8091 0000 		lds r24,sdRamSampleRemaining
 8690 3976 9091 0000 		lds r25,sdRamSampleRemaining+1
 8691 397a A091 0000 		lds r26,sdRamSampleRemaining+2
 8692 397e B091 0000 		lds r27,sdRamSampleRemaining+3
 8693 3982 892B      		or r24,r25
 8694 3984 8A2B      		or r24,r26
 8695 3986 8B2B      		or r24,r27
 8696 3988 01F4      		brne .+2
 8697 398a 00C0      		rjmp .L632
1383:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 8698               		.loc 1 1383 0
 8699 398c 8091 0000 		lds r24,sdBytesInFifo
 8700 3990 9091 0000 		lds r25,sdBytesInFifo+1
 8701 3994 892B      		or r24,r25
 8702 3996 01F4      		brne .+2
 8703 3998 00C0      		rjmp .L618
1385:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 8704               		.loc 1 1385 0
 8705 399a E091 0000 		lds r30,sdFifoReadPointer
 8706 399e F091 0000 		lds r31,sdFifoReadPointer+1
 8707 39a2 E050      		subi r30,lo8(-(sdFifo))
 8708 39a4 F040      		sbci r31,hi8(-(sdFifo))
 8709 39a6 2081      		ld r18,Z
 8710               	.LVL344:
1387:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 8711               		.loc 1 1387 0
 8712 39a8 8091 0000 		lds r24,sdFifoReadPointer
 8713 39ac 9091 0000 		lds r25,sdFifoReadPointer+1
 8714 39b0 0196      		adiw r24,1
 8715 39b2 9093 0000 		sts sdFifoReadPointer+1,r25
 8716 39b6 8093 0000 		sts sdFifoReadPointer,r24
1388:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 8717               		.loc 1 1388 0
 8718 39ba 8091 0000 		lds r24,sdFifoReadPointer
 8719 39be 9091 0000 		lds r25,sdFifoReadPointer+1
 8720 39c2 8115      		cp r24,__zero_reg__
 8721 39c4 9340      		sbci r25,3
 8722 39c6 00F0      		brlo .L633
1390:WTPA.c        **** 					sdFifoReadPointer=0;
 8723               		.loc 1 1390 0
 8724 39c8 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 8725 39cc 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 8726               	.L633:
1393:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 8727               		.loc 1 1393 0
 8728 39d0 8091 0000 		lds r24,sdBytesInFifo
 8729 39d4 9091 0000 		lds r25,sdBytesInFifo+1
 8730 39d8 0197      		sbiw r24,1
 8731 39da 9093 0000 		sts sdBytesInFifo+1,r25
 8732 39de 8093 0000 		sts sdBytesInFifo,r24
1394:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 8733               		.loc 1 1394 0
 8734 39e2 8091 0000 		lds r24,sdRamSampleRemaining
 8735 39e6 9091 0000 		lds r25,sdRamSampleRemaining+1
 8736 39ea A091 0000 		lds r26,sdRamSampleRemaining+2
 8737 39ee B091 0000 		lds r27,sdRamSampleRemaining+3
 8738 39f2 0197      		sbiw r24,1
 8739 39f4 A109      		sbc r26,__zero_reg__
 8740 39f6 B109      		sbc r27,__zero_reg__
 8741 39f8 8093 0000 		sts sdRamSampleRemaining,r24
 8742 39fc 9093 0000 		sts sdRamSampleRemaining+1,r25
 8743 3a00 A093 0000 		sts sdRamSampleRemaining+2,r26
 8744 3a04 B093 0000 		sts sdRamSampleRemaining+3,r27
1398:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
 8745               		.loc 1 1398 0
 8746 3a08 2093 0000 		sts sdStreamOutput,r18
1399:WTPA.c        **** 				UpdateOutput();				// Update the DAC
 8747               		.loc 1 1399 0
 8748 3a0c E091 0000 		lds r30,UpdateOutput
 8749 3a10 F091 0000 		lds r31,UpdateOutput+1
 8750 3a14 0995      		icall
 8751               	.LVL345:
 8752 3a16 00C0      		rjmp .L618
 8753               	.L632:
1404:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 8754               		.loc 1 1404 0
 8755 3a18 1092 0000 		sts sdIsrState,__zero_reg__
1405:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 8756               		.loc 1 1405 0
 8757 3a1c 1092 B100 		sts 177,__zero_reg__
1406:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 8758               		.loc 1 1406 0
 8759 3a20 8091 7000 		lds r24,112
 8760 3a24 8B7F      		andi r24,lo8(-5)
 8761 3a26 8093 7000 		sts 112,r24
1409:WTPA.c        **** 			sdStreamOutput=0;
 8762               		.loc 1 1409 0
 8763 3a2a 1092 0000 		sts sdStreamOutput,__zero_reg__
 8764               	.L618:
 8765               	/* epilogue start */
1412:WTPA.c        **** }
 8766               		.loc 1 1412 0
 8767 3a2e FF91      		pop r31
 8768 3a30 EF91      		pop r30
 8769 3a32 BF91      		pop r27
 8770 3a34 AF91      		pop r26
 8771 3a36 9F91      		pop r25
 8772 3a38 8F91      		pop r24
 8773 3a3a 7F91      		pop r23
 8774 3a3c 6F91      		pop r22
 8775 3a3e 5F91      		pop r21
 8776 3a40 4F91      		pop r20
 8777 3a42 3F91      		pop r19
 8778 3a44 2F91      		pop r18
 8779 3a46 0F90      		pop r0
 8780 3a48 0FBE      		out __SREG__,r0
 8781 3a4a 0F90      		pop r0
 8782 3a4c 1F90      		pop r1
 8783 3a4e 1895      		reti
 8784               		.cfi_endproc
 8785               	.LFE11:
 8787               	.global	__vector_9
 8789               	__vector_9:
 8790               	.LFB12:
1417:WTPA.c        **** {
 8791               		.loc 1 1417 0
 8792               		.cfi_startproc
 8793 3a50 1F92      		push r1
 8794               	.LCFI148:
 8795               		.cfi_def_cfa_offset 3
 8796               		.cfi_offset 1, -2
 8797 3a52 0F92      		push r0
 8798               	.LCFI149:
 8799               		.cfi_def_cfa_offset 4
 8800               		.cfi_offset 0, -3
 8801 3a54 0FB6      		in r0,__SREG__
 8802 3a56 0F92      		push r0
 8803 3a58 1124      		clr __zero_reg__
 8804 3a5a 8F93      		push r24
 8805               	.LCFI150:
 8806               		.cfi_def_cfa_offset 5
 8807               		.cfi_offset 24, -4
 8808 3a5c 9F93      		push r25
 8809               	.LCFI151:
 8810               		.cfi_def_cfa_offset 6
 8811               		.cfi_offset 25, -5
 8812               	/* prologue: Signal */
 8813               	/* frame size = 0 */
 8814               	/* stack size = 5 */
 8815               	.L__stack_usage = 5
1421:WTPA.c        **** 	if(ledPwm>pwmCount)
 8816               		.loc 1 1421 0
 8817 3a5e 9091 0000 		lds r25,ledPwm
 8818 3a62 8091 0000 		lds r24,pwmCount.1841
 8819 3a66 8917      		cp r24,r25
 8820 3a68 00F4      		brsh .L643
1423:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
 8821               		.loc 1 1423 0
 8822 3a6a 9FEF      		ldi r25,lo8(-1)
 8823 3a6c 95B9      		out 0x5,r25
 8824 3a6e 00C0      		rjmp .L644
 8825               	.L643:
1427:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
 8826               		.loc 1 1427 0
 8827 3a70 15B8      		out 0x5,__zero_reg__
 8828               	.L644:
1429:WTPA.c        **** 	pwmCount++;
 8829               		.loc 1 1429 0
 8830 3a72 8F5F      		subi r24,lo8(-(1))
 8831 3a74 8093 0000 		sts pwmCount.1841,r24
 8832               	/* epilogue start */
1430:WTPA.c        **** }
 8833               		.loc 1 1430 0
 8834 3a78 9F91      		pop r25
 8835 3a7a 8F91      		pop r24
 8836 3a7c 0F90      		pop r0
 8837 3a7e 0FBE      		out __SREG__,r0
 8838 3a80 0F90      		pop r0
 8839 3a82 1F90      		pop r1
 8840 3a84 1895      		reti
 8841               		.cfi_endproc
 8842               	.LFE12:
 8844               	.global	__vector_default
 8846               	__vector_default:
 8847               	.LFB13:
1433:WTPA.c        **** {
 8848               		.loc 1 1433 0
 8849               		.cfi_startproc
 8850 3a86 1F92      		push r1
 8851               	.LCFI152:
 8852               		.cfi_def_cfa_offset 3
 8853               		.cfi_offset 1, -2
 8854 3a88 0F92      		push r0
 8855               	.LCFI153:
 8856               		.cfi_def_cfa_offset 4
 8857               		.cfi_offset 0, -3
 8858 3a8a 0FB6      		in r0,__SREG__
 8859 3a8c 0F92      		push r0
 8860 3a8e 1124      		clr __zero_reg__
 8861               	/* prologue: Signal */
 8862               	/* frame size = 0 */
 8863               	/* stack size = 3 */
 8864               	.L__stack_usage = 3
 8865               	/* epilogue start */
1437:WTPA.c        **** }
 8866               		.loc 1 1437 0
 8867 3a90 0F90      		pop r0
 8868 3a92 0FBE      		out __SREG__,r0
 8869 3a94 0F90      		pop r0
 8870 3a96 1F90      		pop r1
 8871 3a98 1895      		reti
 8872               		.cfi_endproc
 8873               	.LFE13:
 8875               	.global	HandleSoftclock
 8877               	HandleSoftclock:
 8878               	.LFB15:
1458:WTPA.c        **** {
 8879               		.loc 1 1458 0
 8880               		.cfi_startproc
 8881               	/* prologue: function */
 8882               	/* frame size = 0 */
 8883               	/* stack size = 0 */
 8884               	.L__stack_usage = 0
1459:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 8885               		.loc 1 1459 0
 8886 3a9a A89B      		sbis 0x15,0
 8887 3a9c 00C0      		rjmp .L646
 8888               	.LBB274:
 8889               	.LBB275:
1461:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 8890               		.loc 1 1461 0
 8891 3a9e A89A      		sbi 0x15,0
1462:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 8892               		.loc 1 1462 0
 8893 3aa0 8091 0000 		lds r24,systemTicks
 8894 3aa4 9091 0000 		lds r25,systemTicks+1
 8895               	.LVL346:
 8896 3aa8 0196      		adiw r24,1
 8897               	.LVL347:
 8898 3aaa 9093 0000 		sts systemTicks+1,r25
 8899 3aae 8093 0000 		sts systemTicks,r24
 8900               	.LVL348:
 8901               	.L646:
 8902 3ab2 0895      		ret
 8903               	.LBE275:
 8904               	.LBE274:
 8905               		.cfi_endproc
 8906               	.LFE15:
 8908               		.section	.text.startup,"ax",@progbits
 8909               	.global	main
 8911               	main:
 8912               	.LFB72:
4740:WTPA.c        **** 
4741:WTPA.c        **** 
4742:WTPA.c        **** //-----------------------------------------------------------------------
4743:WTPA.c        **** //-----------------------------------------------------------------------
4744:WTPA.c        **** // Program main loop.
4745:WTPA.c        **** //-----------------------------------------------------------------------
4746:WTPA.c        **** //-----------------------------------------------------------------------
4747:WTPA.c        **** 
4748:WTPA.c        **** int main(void)
4749:WTPA.c        **** // Initialize this mess.
4750:WTPA.c        **** {
 8913               		.loc 1 4750 0
 8914               		.cfi_startproc
 8915               	/* prologue: function */
 8916               	/* frame size = 0 */
 8917               	/* stack size = 0 */
 8918               	.L__stack_usage = 0
4751:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
 8919               		.loc 1 4751 0
 8920 0000 CFEF      		ldi r28,lo8(-1)
 8921 0002 C093 6400 		sts 100,r28
4752:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
 8922               		.loc 1 4752 0
 8923 0006 85B7      		in r24,0x35
 8924 0008 8F7E      		andi r24,lo8(-17)
 8925 000a 85BF      		out 0x35,r24
4753:WTPA.c        **** 
4754:WTPA.c        **** 	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initia
4755:WTPA.c        **** 
4756:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
 8926               		.loc 1 4756 0
 8927 000c 8FEE      		ldi r24,lo8(-17)
 8928 000e 87B9      		out 0x7,r24
4757:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
 8929               		.loc 1 4757 0
 8930 0010 88E0      		ldi r24,lo8(8)
 8931 0012 88B9      		out 0x8,r24
4758:WTPA.c        **** 
4759:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
 8932               		.loc 1 4759 0
 8933 0014 80E8      		ldi r24,lo8(-128)
 8934 0016 8AB9      		out 0xa,r24
4760:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
 8935               		.loc 1 4760 0
 8936 0018 1BB8      		out 0xb,__zero_reg__
4761:WTPA.c        **** 
4762:WTPA.c        **** //	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pi
4763:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
 8937               		.loc 1 4763 0
 8938 001a 96E0      		ldi r25,lo8(6)
 8939 001c 92B9      		out 0x2,r25
4764:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
 8940               		.loc 1 4764 0
 8941 001e 9EE3      		ldi r25,lo8(62)
 8942 0020 91B9      		out 0x1,r25
4765:WTPA.c        **** 
4766:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
 8943               		.loc 1 4766 0
 8944 0022 C4B9      		out 0x4,r28
4767:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
 8945               		.loc 1 4767 0
 8946 0024 85B9      		out 0x5,r24
4768:WTPA.c        **** 
4769:WTPA.c        **** 	// Set the DAC to midscale to avoid pops on the first interrupt call.
4770:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
 8947               		.loc 1 4770 0
 8948 0026 129A      		sbi 0x2,2
4771:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 8949               		.loc 1 4771 0
 8950 0028 C4B9      		out 0x4,r28
4772:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
 8951               		.loc 1 4772 0
 8952 002a 159A      		sbi 0x2,5
4773:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 8953               		.loc 1 4773 0
 8954 002c 1598      		cbi 0x2,5
4774:WTPA.c        **** 
4775:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
 8955               		.loc 1 4775 0
 8956 002e 0E94 0000 		call InitSdInterface
 8957               	.LVL349:
 8958               	.LBB310:
 8959               	.LBB311:
1601:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
 8960               		.loc 1 1601 0
 8961 0032 66E2      		ldi r22,lo8(38)
 8962 0034 70E0      		ldi r23,0
 8963 0036 81E0      		ldi r24,lo8(1)
 8964 0038 0E94 0000 		call SetTimer
 8965               	.LVL350:
1603:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
 8966               		.loc 1 1603 0
 8967 003c 3D98      		cbi 0x7,5
1604:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
 8968               		.loc 1 1604 0
 8969 003e 459A      		sbi 0x8,5
 8970               	.LBE311:
 8971               	.LBE310:
 8972               	.LBB312:
 8973               	.LBB313:
1674:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
 8974               		.loc 1 1674 0
 8975 0040 80B1      		in r24,0
 8976 0042 807C      		andi r24,lo8(-64)
 8977 0044 8093 0000 		sts encoderState,r24
1675:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
 8978               		.loc 1 1675 0
 8979 0048 1092 0000 		sts encoderValue,__zero_reg__
 8980               	.LBE313:
 8981               	.LBE312:
 8982               	.LBB314:
 8983               	.LBB315:
1588:WTPA.c        **** 	ledOnOffMask=0;
 8984               		.loc 1 1588 0
 8985 004c 1092 0000 		sts ledOnOffMask,__zero_reg__
1589:WTPA.c        **** 	ledBlinkMask=0;
 8986               		.loc 1 1589 0
 8987 0050 1092 0000 		sts ledBlinkMask,__zero_reg__
1590:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
 8988               		.loc 1 1590 0
 8989 0054 80E0      		ldi r24,0
 8990 0056 0E94 0000 		call WriteLedLatch
 8991               	.LVL351:
 8992               	.LBE315:
 8993               	.LBE314:
4776:WTPA.c        **** 	InitSwitches();
4777:WTPA.c        **** 	InitEncoder();
4778:WTPA.c        **** 	InitLeds();
4779:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
 8994               		.loc 1 4779 0
 8995 005a 0E94 0000 		call InitMidi
 8996               	.LVL352:
4780:WTPA.c        **** 	InitUart0();
 8997               		.loc 1 4780 0
 8998 005e 0E94 0000 		call InitUart0
 8999               	.LVL353:
 9000               	.LBB316:
 9001               	.LBB317:
1775:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
 9002               		.loc 1 1775 0
 9003 0062 8091 6400 		lds r24,100
 9004 0066 8E7F      		andi r24,lo8(-2)
 9005 0068 8093 6400 		sts 100,r24
1776:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
 9006               		.loc 1 1776 0
 9007 006c 80E6      		ldi r24,lo8(96)
 9008 006e 8093 7C00 		sts 124,r24
1777:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
 9009               		.loc 1 1777 0
 9010 0072 81E0      		ldi r24,lo8(1)
 9011 0074 8093 7E00 		sts 126,r24
1778:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
 9012               		.loc 1 1778 0
 9013 0078 85E9      		ldi r24,lo8(-107)
 9014 007a 8093 7A00 		sts 122,r24
1780:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
 9015               		.loc 1 1780 0
 9016 007e 8091 7A00 		lds r24,122
 9017 0082 8064      		ori r24,lo8(64)
 9018 0084 8093 7A00 		sts 122,r24
 9019               	.LBE317:
 9020               	.LBE316:
 9021               	.LBB318:
 9022               	.LBB319:
1478:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
 9023               		.loc 1 1478 0
 9024 0088 8091 6400 		lds r24,100
 9025 008c 8F7D      		andi r24,lo8(-33)
 9026 008e 8093 6400 		sts 100,r24
1479:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
 9027               		.loc 1 1479 0
 9028 0092 1092 6E00 		sts 110,__zero_reg__
1480:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
 9029               		.loc 1 1480 0
 9030 0096 14BC      		out 0x24,__zero_reg__
1481:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
 9031               		.loc 1 1481 0
 9032 0098 16BC      		out 0x26,__zero_reg__
1482:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 9033               		.loc 1 1482 0
 9034 009a C5BB      		out 0x15,r28
1483:WTPA.c        **** 	systemTicks=0;
 9035               		.loc 1 1483 0
 9036 009c 1092 0000 		sts systemTicks+1,__zero_reg__
 9037 00a0 1092 0000 		sts systemTicks,__zero_reg__
1485:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 9038               		.loc 1 1485 0
 9039 00a4 83E0      		ldi r24,lo8(3)
 9040 00a6 85BD      		out 0x25,r24
 9041               	.LBE319:
 9042               	.LBE318:
 9043               	.LBB320:
 9044               	.LBB321:
2034:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
 9045               		.loc 1 2034 0
 9046 00a8 8091 6400 		lds r24,100
 9047 00ac 877F      		andi r24,lo8(-9)
 9048 00ae 8093 6400 		sts 100,r24
2035:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
 9049               		.loc 1 2035 0
 9050 00b2 1092 6F00 		sts 111,__zero_reg__
2036:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
 9051               		.loc 1 2036 0
 9052 00b6 8FEF      		ldi r24,lo8(-1)
 9053 00b8 9FEF      		ldi r25,lo8(-1)
 9054 00ba 9093 8900 		sts 136+1,r25
 9055 00be 8093 8800 		sts 136,r24
2037:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
 9056               		.loc 1 2037 0
 9057 00c2 9093 8B00 		sts 138+1,r25
 9058 00c6 8093 8A00 		sts 138,r24
2038:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
 9059               		.loc 1 2038 0
 9060 00ca 1092 8000 		sts 128,__zero_reg__
2039:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
 9061               		.loc 1 2039 0
 9062 00ce 1092 8100 		sts 129,__zero_reg__
2040:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
 9063               		.loc 1 2040 0
 9064 00d2 1092 8500 		sts 132+1,__zero_reg__
 9065 00d6 1092 8400 		sts 132,__zero_reg__
2041:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
 9066               		.loc 1 2041 0
 9067 00da C6BB      		out 0x16,r28
 9068               	.LBE321:
 9069               	.LBE320:
4781:WTPA.c        **** //	InitUart1();
4782:WTPA.c        **** 	InitAdc();
4783:WTPA.c        **** 	InitSoftclock();
4784:WTPA.c        **** //	InitRandom();
4785:WTPA.c        **** 	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.
4786:WTPA.c        **** 
4787:WTPA.c        **** 	newKeys=0;
 9070               		.loc 1 4787 0
 9071 00dc 1092 0000 		sts newKeys,__zero_reg__
4788:WTPA.c        **** 	keyState=0;
 9072               		.loc 1 4788 0
 9073 00e0 1092 0000 		sts keyState,__zero_reg__
4789:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
 9074               		.loc 1 4789 0
 9075 00e4 1092 0000 		sts cardState,__zero_reg__
4790:WTPA.c        **** 	cardDetect=false;
 9076               		.loc 1 4790 0
 9077 00e8 1092 0000 		sts cardDetect,__zero_reg__
4791:WTPA.c        **** 
4792:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
 9078               		.loc 1 4792 0
 9079               	/* #APP */
 9080               	 ;  4792 "WTPA.c" 1
 9081 00ec 7894      		sei
 9082               	 ;  0 "" 2
 9083               	.LVL354:
 9084               	/* #NOAPP */
 9085               	.LBB322:
 9086               	.LBB323:
1447:WTPA.c        **** 	State=newState;
 9087               		.loc 1 1447 0
 9088 00ee 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 9089 00f0 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 9090 00f2 9093 0000 		sts State+1,r25
 9091 00f6 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 9092               		.loc 1 1448 0
 9093 00fa 1092 0000 		sts subState,__zero_reg__
 9094               	.LBE323:
 9095               	.LBE322:
 9096               	.LBB324:
 9097               	.LBB325:
1622:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9098               		.loc 1 1622 0
 9099 00fe CC24      		clr r12
 9100 0100 CA94      		dec r12
 9101               	.LBE325:
 9102               	.LBE324:
 9103               	.LBB328:
 9104               	.LBB329:
1570:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9105               		.loc 1 1570 0
 9106 0102 EE24      		clr r14
 9107 0104 E394      		inc r14
 9108 0106 F12C      		mov r15,__zero_reg__
 9109               	.LBE329:
 9110               	.LBE328:
 9111               	.LBB331:
 9112               	.LBB332:
2583:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 9113               		.loc 1 2583 0
 9114 0108 C0E0      		ldi r28,0
 9115 010a D2E0      		ldi r29,lo8(2)
2593:WTPA.c        **** 				bytesLeftInBlock-=4;
 9116               		.loc 1 2593 0
 9117 010c 6CE0      		ldi r22,lo8(12)
 9118 010e 362E      		mov r3,r22
2608:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 9119               		.loc 1 2608 0
 9120 0110 77E0      		ldi r23,lo8(7)
 9121 0112 972E      		mov r9,r23
2785:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 9122               		.loc 1 2785 0
 9123 0114 EBE0      		ldi r30,lo8(11)
 9124 0116 8E2E      		mov r8,r30
2791:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
 9125               		.loc 1 2791 0
 9126 0118 FEE0      		ldi r31,lo8(14)
 9127 011a DF2E      		mov r13,r31
2737:WTPA.c        **** 				cardState=SD_READ_ABORT;
 9128               		.loc 1 2737 0
 9129 011c ADE0      		ldi r26,lo8(13)
 9130 011e BA2E      		mov r11,r26
2824:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 9131               		.loc 1 2824 0
 9132 0120 B4E0      		ldi r27,lo8(4)
 9133 0122 2B2E      		mov r2,r27
2843:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 9134               		.loc 1 2843 0
 9135 0124 1AE0      		ldi r17,lo8(10)
 9136 0126 A12E      		mov r10,r17
 9137               	.L769:
 9138               	.LBE332:
 9139               	.LBE331:
 9140               	.LBB349:
 9141               	.LBB326:
1617:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
 9142               		.loc 1 1617 0
 9143 0128 81E0      		ldi r24,lo8(1)
 9144 012a 0E94 0000 		call CheckTimer
 9145               	.LVL355:
 9146 012e 8823      		tst r24
 9147 0130 01F0      		breq .L652
1620:WTPA.c        **** 		sreg=SREG;
 9148               		.loc 1 1620 0
 9149 0132 9FB7      		in r25,__SREG__
 9150               	.LVL356:
1621:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
 9151               		.loc 1 1621 0
 9152               	/* #APP */
 9153               	 ;  1621 "WTPA.c" 1
 9154 0134 F894      		cli
 9155               	 ;  0 "" 2
1622:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 9156               		.loc 1 1622 0
 9157               	/* #NOAPP */
 9158 0136 C5B8      		out 0x5,r12
1623:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 9159               		.loc 1 1623 0
 9160 0138 14B8      		out 0x4,__zero_reg__
1624:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 9161               		.loc 1 1624 0
 9162 013a 4398      		cbi 0x8,3
1625:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
 9163               		.loc 1 1625 0
 9164               	/* #APP */
 9165               	 ;  1625 "WTPA.c" 1
 9166 013c 0000      		nop
 9167               	 ;  0 "" 2
1626:WTPA.c        **** 		asm volatile("nop"::);
 9168               		.loc 1 1626 0
 9169               	 ;  1626 "WTPA.c" 1
 9170 013e 0000      		nop
 9171               	 ;  0 "" 2
1627:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 9172               		.loc 1 1627 0
 9173               	/* #NOAPP */
 9174 0140 83B1      		in r24,0x3
 9175 0142 8095      		com r24
 9176 0144 8093 0000 		sts keyState,r24
1628:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 9177               		.loc 1 1628 0
 9178 0148 439A      		sbi 0x8,3
1629:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 9179               		.loc 1 1629 0
 9180 014a C4B8      		out 0x4,r12
1630:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
 9181               		.loc 1 1630 0
 9182 014c 9FBF      		out __SREG__,r25
1632:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
 9183               		.loc 1 1632 0
 9184 014e 3599      		sbic 0x6,5
 9185 0150 00C0      		rjmp .L653
1634:WTPA.c        **** 			cardDetect=true;
 9186               		.loc 1 1634 0
 9187 0152 81E0      		ldi r24,lo8(1)
 9188 0154 8093 0000 		sts cardDetect,r24
 9189 0158 00C0      		rjmp .L654
 9190               	.L653:
1638:WTPA.c        **** 			cardDetect=false;
 9191               		.loc 1 1638 0
 9192 015a 1092 0000 		sts cardDetect,__zero_reg__
 9193               	.L654:
1641:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
 9194               		.loc 1 1641 0
 9195 015e 66E2      		ldi r22,lo8(38)
 9196 0160 70E0      		ldi r23,0
 9197 0162 81E0      		ldi r24,lo8(1)
 9198 0164 0E94 0000 		call SetTimer
 9199               	.LVL357:
 9200               	.L652:
1644:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
 9201               		.loc 1 1644 0
 9202 0168 9091 0000 		lds r25,keyState
 9203 016c 8091 0000 		lds r24,lastKeyState.1891
 9204 0170 8095      		com r24
 9205 0172 8923      		and r24,r25
 9206 0174 8093 0000 		sts newKeys,r24
1645:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
 9207               		.loc 1 1645 0
 9208 0178 8095      		com r24
 9209               	.LBE326:
 9210 017a 8923      		and r24,r25
 9211               	.LBB327:
 9212 017c 8093 0000 		sts keysHeld,r24
1646:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
 9213               		.loc 1 1646 0
 9214 0180 9093 0000 		sts lastKeyState.1891,r25
 9215               	.LBE327:
 9216               	.LBE349:
 9217               	.LBB350:
 9218               	.LBB351:
1687:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
 9219               		.loc 1 1687 0
 9220 0184 2091 0000 		lds r18,systemTicks
 9221 0188 3091 0000 		lds r19,systemTicks+1
 9222 018c 8091 0000 		lds r24,lastEncTime.1900
 9223 0190 9091 0000 		lds r25,lastEncTime.1900+1
 9224 0194 2817      		cp r18,r24
 9225 0196 3907      		cpc r19,r25
 9226 0198 01F0      		breq .L656
1689:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
 9227               		.loc 1 1689 0
 9228 019a 8091 0000 		lds r24,systemTicks
 9229 019e 9091 0000 		lds r25,systemTicks+1
 9230 01a2 9093 0000 		sts lastEncTime.1900+1,r25
 9231 01a6 8093 0000 		sts lastEncTime.1900,r24
1690:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
 9232               		.loc 1 1690 0
 9233 01aa 80B1      		in r24,0
 9234 01ac 807C      		andi r24,lo8(-64)
 9235 01ae 8093 0000 		sts encoderState,r24
1692:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
 9236               		.loc 1 1692 0
 9237 01b2 9091 0000 		lds r25,lastEncoderState.1899
 9238 01b6 8917      		cp r24,r25
 9239 01b8 01F0      		breq .L656
1694:WTPA.c        **** 			if(encoderState==ENC_POS_A)
 9240               		.loc 1 1694 0
 9241 01ba 8111      		cpse r24,__zero_reg__
 9242 01bc 00C0      		rjmp .L658
1696:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
 9243               		.loc 1 1696 0
 9244 01be 9038      		cpi r25,lo8(-128)
 9245 01c0 01F4      		brne .L659
 9246 01c2 00C0      		rjmp .L858
 9247               	.L659:
1701:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
 9248               		.loc 1 1701 0
 9249 01c4 9034      		cpi r25,lo8(64)
 9250 01c6 01F4      		brne .L660
 9251 01c8 00C0      		rjmp .L855
 9252               	.L658:
1707:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
 9253               		.loc 1 1707 0
 9254 01ca 8034      		cpi r24,lo8(64)
 9255 01cc 01F4      		brne .L661
1709:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
 9256               		.loc 1 1709 0
 9257 01ce 9111      		cpse r25,__zero_reg__
 9258 01d0 00C0      		rjmp .L662
 9259 01d2 00C0      		rjmp .L858
 9260               	.L662:
1714:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
 9261               		.loc 1 1714 0
 9262 01d4 903C      		cpi r25,lo8(-64)
 9263 01d6 01F4      		brne .L660
 9264 01d8 00C0      		rjmp .L855
 9265               	.L661:
1720:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
 9266               		.loc 1 1720 0
 9267 01da 803C      		cpi r24,lo8(-64)
 9268 01dc 01F4      		brne .L663
1722:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
 9269               		.loc 1 1722 0
 9270 01de 9034      		cpi r25,lo8(64)
 9271 01e0 01F4      		brne .L664
 9272 01e2 00C0      		rjmp .L858
 9273               	.L664:
1727:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
 9274               		.loc 1 1727 0
 9275 01e4 9038      		cpi r25,lo8(-128)
 9276 01e6 01F4      		brne .L660
 9277 01e8 00C0      		rjmp .L855
 9278               	.L663:
1733:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
 9279               		.loc 1 1733 0
 9280 01ea 8038      		cpi r24,lo8(-128)
 9281 01ec 01F4      		brne .L660
1735:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
 9282               		.loc 1 1735 0
 9283 01ee 903C      		cpi r25,lo8(-64)
 9284 01f0 01F4      		brne .L665
 9285               	.L858:
1738:WTPA.c        **** 					encoderValue--;
 9286               		.loc 1 1738 0
 9287 01f2 9091 0000 		lds r25,encoderValue
 9288 01f6 9150      		subi r25,lo8(-(-1))
 9289 01f8 00C0      		rjmp .L854
 9290               	.L665:
1740:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
 9291               		.loc 1 1740 0
 9292 01fa 9111      		cpse r25,__zero_reg__
 9293 01fc 00C0      		rjmp .L660
 9294               	.L855:
1743:WTPA.c        **** 					encoderValue++;
 9295               		.loc 1 1743 0
 9296 01fe 9091 0000 		lds r25,encoderValue
 9297 0202 9F5F      		subi r25,lo8(-(1))
 9298               	.L854:
 9299 0204 9093 0000 		sts encoderValue,r25
 9300               	.L660:
1747:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
 9301               		.loc 1 1747 0
 9302 0208 8093 0000 		sts lastEncoderState.1899,r24
 9303               	.L656:
 9304               	.LBE351:
 9305               	.LBE350:
4793:WTPA.c        **** 
4794:WTPA.c        **** 	SetState(DoFruitcakeIntro);	// Get gay.
4795:WTPA.c        **** 
4796:WTPA.c        **** 	while(1)
4797:WTPA.c        **** 	{
4798:WTPA.c        **** 		HandleSwitches();		// Flag newKeys.
4799:WTPA.c        **** 		HandleEncoder();		// Keep track of encoder states and increment values.
4800:WTPA.c        **** 		HandleSoftclock();		// Keep the timer timing.
 9306               		.loc 1 4800 0
 9307 020c 0E94 0000 		call HandleSoftclock
 9308               	.LVL358:
 9309               	.LBB352:
 9310               	.LBB330:
1558:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
 9311               		.loc 1 1558 0
 9312 0210 8091 0000 		lds r24,ledBlinkMask
 9313 0214 8823      		tst r24
 9314 0216 01F0      		breq .L666
 9315 0218 82E0      		ldi r24,lo8(2)
 9316 021a 0E94 0000 		call CheckTimer
 9317               	.LVL359:
 9318 021e 8823      		tst r24
 9319 0220 01F0      		breq .L666
1562:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9320               		.loc 1 1562 0
 9321 0222 2091 0000 		lds r18,ledBlinkMask
 9322 0226 30E0      		ldi r19,0
1564:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9323               		.loc 1 1564 0
 9324 0228 F091 0000 		lds r31,toggle.1877
 9325 022c E091 0000 		lds r30,ledOnOffMask
 9326 0230 80E0      		ldi r24,0
 9327 0232 90E0      		ldi r25,0
 9328               	.L669:
1562:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 9329               		.loc 1 1562 0
 9330 0234 B901      		movw r22,r18
 9331 0236 082E      		mov r0,r24
 9332 0238 00C0      		rjmp 2f
 9333               		1:
 9334 023a 7595      		asr r23
 9335 023c 6795      		ror r22
 9336               		2:
 9337 023e 0A94      		dec r0
 9338 0240 02F4      		brpl 1b
 9339 0242 60FF      		sbrs r22,0
 9340 0244 00C0      		rjmp .L667
1566:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9341               		.loc 1 1566 0
 9342 0246 B701      		movw r22,r14
 9343 0248 082E      		mov r0,r24
 9344 024a 00C0      		rjmp 2f
 9345               		1:
 9346 024c 660F      		lsl r22
 9347 024e 771F      		rol r23
 9348               		2:
 9349 0250 0A94      		dec r0
 9350 0252 02F4      		brpl 1b
 9351 0254 AB01      		movw r20,r22
1564:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 9352               		.loc 1 1564 0
 9353 0256 FF23      		tst r31
 9354 0258 01F0      		breq .L668
1566:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 9355               		.loc 1 1566 0
 9356 025a E62B      		or r30,r22
 9357 025c 00C0      		rjmp .L667
 9358               	.L668:
1570:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 9359               		.loc 1 1570 0
 9360 025e 4095      		com r20
 9361 0260 E423      		and r30,r20
 9362               	.L667:
 9363               	.LVL360:
 9364 0262 0196      		adiw r24,1
1560:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
 9365               		.loc 1 1560 0
 9366 0264 8830      		cpi r24,8
 9367 0266 9105      		cpc r25,__zero_reg__
 9368 0268 01F4      		brne .L669
 9369 026a E093 0000 		sts ledOnOffMask,r30
1575:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
 9370               		.loc 1 1575 0
 9371 026e 81E0      		ldi r24,lo8(1)
 9372 0270 9091 0000 		lds r25,toggle.1877
 9373 0274 9111      		cpse r25,__zero_reg__
 9374 0276 80E0      		ldi r24,0
 9375               	.L670:
 9376 0278 8093 0000 		sts toggle.1877,r24
1576:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
 9377               		.loc 1 1576 0
 9378 027c 68E9      		ldi r22,lo8(-104)
 9379 027e 70E0      		ldi r23,0
 9380 0280 82E0      		ldi r24,lo8(2)
 9381 0282 0E94 0000 		call SetTimer
 9382               	.LVL361:
1577:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
 9383               		.loc 1 1577 0
 9384 0286 8091 0000 		lds r24,ledOnOffMask
 9385 028a 0E94 0000 		call WriteLedLatch
 9386               	.LVL362:
 9387 028e 00C0      		rjmp .L671
 9388               	.L666:
1579:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
 9389               		.loc 1 1579 0
 9390 0290 1091 0000 		lds r17,ledOnOffMask
 9391 0294 8091 0000 		lds r24,lastLedMask.1878
 9392 0298 8117      		cp r24,r17
 9393 029a 01F0      		breq .L671
1581:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
 9394               		.loc 1 1581 0
 9395 029c 812F      		mov r24,r17
 9396 029e 0E94 0000 		call WriteLedLatch
 9397               	.LVL363:
1582:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
 9398               		.loc 1 1582 0
 9399 02a2 1093 0000 		sts lastLedMask.1878,r17
 9400               	.L671:
 9401               	.LBE330:
 9402               	.LBE352:
 9403               	.LBB353:
 9404               	.LBB347:
2358:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
 9405               		.loc 1 2358 0
 9406 02a6 9091 0000 		lds r25,cardDetect
 9407 02aa 8091 0000 		lds r24,cardState
 9408 02ae 9111      		cpse r25,__zero_reg__
 9409 02b0 00C0      		rjmp .L672
2360:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 9410               		.loc 1 2360 0
 9411 02b2 8823      		tst r24
 9412 02b4 01F4      		brne .+2
 9413 02b6 00C0      		rjmp .L674
 9414 02b8 00C0      		rjmp .L761
 9415               	.L672:
2368:WTPA.c        **** 		switch(cardState)
 9416               		.loc 1 2368 0
 9417 02ba 8630      		cpi r24,lo8(6)
 9418 02bc 01F4      		brne .+2
 9419 02be 00C0      		rjmp .L681
 9420 02c0 00F4      		brsh .L689
 9421 02c2 8230      		cpi r24,lo8(2)
 9422 02c4 01F4      		brne .+2
 9423 02c6 00C0      		rjmp .L677
 9424 02c8 00F4      		brsh .L690
 9425 02ca 8823      		tst r24
 9426 02cc 01F0      		breq .L675
 9427 02ce 8130      		cpi r24,lo8(1)
 9428 02d0 01F0      		breq .+2
 9429 02d2 00C0      		rjmp .L674
 9430 02d4 00C0      		rjmp .L676
 9431               	.L690:
 9432 02d6 8430      		cpi r24,lo8(4)
 9433 02d8 01F4      		brne .+2
 9434 02da 00C0      		rjmp .L679
 9435 02dc 00F0      		brlo .+2
 9436 02de 00C0      		rjmp .L680
 9437 02e0 00C0      		rjmp .L850
 9438               	.L689:
 9439 02e2 8A30      		cpi r24,lo8(10)
 9440 02e4 01F4      		brne .+2
 9441 02e6 00C0      		rjmp .L685
 9442 02e8 00F4      		brsh .L691
 9443 02ea 8830      		cpi r24,lo8(8)
 9444 02ec 01F4      		brne .+2
 9445 02ee 00C0      		rjmp .L683
 9446 02f0 00F0      		brlo .+2
 9447 02f2 00C0      		rjmp .L684
 9448 02f4 00C0      		rjmp .L851
 9449               	.L691:
 9450 02f6 8C30      		cpi r24,lo8(12)
 9451 02f8 01F4      		brne .+2
 9452 02fa 00C0      		rjmp .L687
 9453 02fc 00F4      		brsh .+2
 9454 02fe 00C0      		rjmp .L686
 9455 0300 8D30      		cpi r24,lo8(13)
 9456 0302 01F0      		breq .+2
 9457 0304 00C0      		rjmp .L674
 9458 0306 00C0      		rjmp .L688
 9459               	.L675:
2376:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
 9460               		.loc 1 2376 0
 9461 0308 81E0      		ldi r24,lo8(1)
 9462 030a 8093 0000 		sts cardState,r24
2377:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
 9463               		.loc 1 2377 0
 9464 030e 64EC      		ldi r22,lo8(-60)
 9465 0310 74E0      		ldi r23,lo8(4)
 9466 0312 83E0      		ldi r24,lo8(3)
 9467 0314 0E94 0000 		call SetTimer
 9468               	.LVL364:
 9469 0318 00C0      		rjmp .L674
 9470               	.L676:
2381:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
 9471               		.loc 1 2381 0
 9472 031a 83E0      		ldi r24,lo8(3)
 9473 031c 0E94 0000 		call CheckTimer
 9474               	.LVL365:
 9475 0320 8823      		tst r24
 9476 0322 01F4      		brne .+2
 9477 0324 00C0      		rjmp .L674
2383:WTPA.c        **** 				sdPlaybackQueued=false;
 9478               		.loc 1 2383 0
 9479 0326 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2384:WTPA.c        **** 				sdAbortRead=false;
 9480               		.loc 1 2384 0
 9481 032a 1092 0000 		sts sdAbortRead,__zero_reg__
2386:WTPA.c        **** 				if(SdHandshake()==true)	// Give it a shot...
 9482               		.loc 1 2386 0
 9483 032e 0E94 0000 		call SdHandshake
 9484               	.LVL366:
 9485 0332 8130      		cpi r24,lo8(1)
 9486 0334 01F0      		breq .+2
 9487 0336 00C0      		rjmp .L693
 9488               	.LVL367:
 9489               	.LBB333:
 9490               	.LBB334:
2151:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
 9491               		.loc 1 2151 0
 9492 0338 60E0      		ldi r22,0
 9493 033a 70E0      		ldi r23,0
 9494 033c CB01      		movw r24,r22
 9495 033e 0E94 0000 		call SdBeginSingleBlockRead
 9496               	.LVL368:
 9497 0342 8130      		cpi r24,lo8(1)
 9498 0344 01F0      		breq .+2
 9499 0346 00C0      		rjmp .L770
2160:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
 9500               		.loc 1 2160 0
 9501 0348 6AE7      		ldi r22,lo8(122)
 9502 034a 70E0      		ldi r23,0
 9503 034c 83E0      		ldi r24,lo8(3)
 9504 034e 0E94 0000 		call SetTimer
 9505               	.LVL369:
 9506 0352 00C0      		rjmp .L695
 9507               	.L699:
2164:WTPA.c        **** 			HandleSoftclock();	// Kludgy
 9508               		.loc 1 2164 0
 9509 0354 0E94 0000 		call HandleSoftclock
 9510               	.LVL370:
 9511               	.L695:
2162:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 9512               		.loc 1 2162 0
 9513 0358 83E0      		ldi r24,lo8(3)
 9514 035a 0E94 0000 		call CheckTimer
 9515               	.LVL371:
 9516 035e 8823      		tst r24
 9517 0360 01F0      		breq .L696
 9518               	.L700:
2168:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9519               		.loc 1 2168 0
 9520 0362 8FEF      		ldi r24,lo8(-1)
 9521 0364 0E94 0000 		call TransferSdByte
 9522               	.LVL372:
 9523 0368 182F      		mov r17,r24
 9524               	.LVL373:
2174:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9525               		.loc 1 2174 0
 9526 036a 8FEF      		ldi r24,lo8(-1)
 9527 036c 0E94 0000 		call TransferSdByte
 9528               	.LVL374:
2175:WTPA.c        **** 		if(theByte!='T')
 9529               		.loc 1 2175 0
 9530 0370 8435      		cpi r24,lo8(84)
 9531 0372 01F4      		brne .L771
 9532 0374 00C0      		rjmp .L852
 9533               	.LVL375:
 9534               	.L696:
2162:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 9535               		.loc 1 2162 0
 9536 0376 8FEF      		ldi r24,lo8(-1)
 9537 0378 0E94 0000 		call TransferSdByte
 9538               	.LVL376:
 9539 037c 8E3F      		cpi r24,lo8(-2)
 9540 037e 01F4      		brne .L699
 9541 0380 00C0      		rjmp .L700
 9542               	.LVL377:
 9543               	.L852:
2169:WTPA.c        **** 		if(theByte!='W')
 9544               		.loc 1 2169 0
 9545 0382 6624      		clr r6
 9546 0384 6394      		inc r6
 9547 0386 1735      		cpi r17,lo8(87)
 9548 0388 01F0      		breq .L697
 9549               	.L771:
2177:WTPA.c        **** 			filesystemGood=false;
 9550               		.loc 1 2177 0
 9551 038a 612C      		mov r6,__zero_reg__
 9552               	.L697:
 9553               	.LVL378:
2180:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9554               		.loc 1 2180 0
 9555 038c 8FEF      		ldi r24,lo8(-1)
 9556               	.LVL379:
 9557 038e 0E94 0000 		call TransferSdByte
 9558               	.LVL380:
2181:WTPA.c        **** 		if(theByte!='P')
 9559               		.loc 1 2181 0
 9560 0392 8035      		cpi r24,lo8(80)
 9561 0394 01F0      		breq .L702
2183:WTPA.c        **** 			filesystemGood=false;
 9562               		.loc 1 2183 0
 9563 0396 612C      		mov r6,__zero_reg__
 9564               	.LVL381:
 9565               	.L702:
2186:WTPA.c        **** 		theByte=TransferSdByte(DUMMY_BYTE);
 9566               		.loc 1 2186 0
 9567 0398 8FEF      		ldi r24,lo8(-1)
 9568               	.LVL382:
 9569 039a 0E94 0000 		call TransferSdByte
 9570               	.LVL383:
2187:WTPA.c        **** 		if(theByte!='A')
 9571               		.loc 1 2187 0
 9572 039e 8134      		cpi r24,lo8(65)
 9573 03a0 01F0      		breq .L703
2189:WTPA.c        **** 			filesystemGood=false;
 9574               		.loc 1 2189 0
 9575 03a2 612C      		mov r6,__zero_reg__
 9576               	.LVL384:
 9577               	.L703:
 9578 03a4 0CE0      		ldi r16,lo8(12)
 9579 03a6 10E0      		ldi r17,0
 9580               	.LVL385:
 9581               	.L704:
2197:WTPA.c        **** 			TransferSdByte(0xFF);
 9582               		.loc 1 2197 0
 9583 03a8 8FEF      		ldi r24,lo8(-1)
 9584 03aa 0E94 0000 		call TransferSdByte
 9585               	.LVL386:
 9586 03ae 0150      		subi r16,1
 9587 03b0 1109      		sbc r17,__zero_reg__
2195:WTPA.c        **** 		for(i=0;i<12;i++)					// 12 don't care bytes
 9588               		.loc 1 2195 0
 9589 03b2 01F4      		brne .L704
2200:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
 9590               		.loc 1 2200 0
 9591 03b4 71E0      		ldi r23,lo8(1)
 9592 03b6 6712      		cpse r6,r23
 9593 03b8 00C0      		rjmp .L774
 9594 03ba 00E0      		ldi r16,lo8(sampleToc)
 9595 03bc 10E0      		ldi r17,hi8(sampleToc)
 9596               	.L706:
2204:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
 9597               		.loc 1 2204 0
 9598 03be 8FEF      		ldi r24,lo8(-1)
 9599 03c0 0E94 0000 		call TransferSdByte
 9600               	.LVL387:
 9601 03c4 F801      		movw r30,r16
 9602 03c6 8193      		st Z+,r24
 9603 03c8 8F01      		movw r16,r30
2202:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
 9604               		.loc 1 2202 0
 9605 03ca F0E0      		ldi r31,hi8(sampleToc+64)
 9606 03cc 0030      		cpi r16,lo8(sampleToc+64)
 9607 03ce 1F07      		cpc r17,r31
 9608 03d0 01F4      		brne .L706
 9609               	.L708:
 9610               	.LVL388:
2200:WTPA.c        **** 		if(filesystemGood==true)			// Load TOC if this is a legit card
 9611               		.loc 1 2200 0
 9612 03d2 02EB      		ldi r16,lo8(-78)
 9613 03d4 11E0      		ldi r17,lo8(1)
 9614 03d6 00C0      		rjmp .L707
 9615               	.LVL389:
 9616               	.L774:
 9617 03d8 00E4      		ldi r16,lo8(64)
 9618 03da 10E0      		ldi r17,0
 9619               	.L705:
2211:WTPA.c        **** 				TransferSdByte(0xFF);
 9620               		.loc 1 2211 0
 9621 03dc 8FEF      		ldi r24,lo8(-1)
 9622 03de 0E94 0000 		call TransferSdByte
 9623               	.LVL390:
 9624 03e2 0150      		subi r16,1
 9625 03e4 1109      		sbc r17,__zero_reg__
2209:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
 9626               		.loc 1 2209 0
 9627 03e6 01F4      		brne .L705
 9628 03e8 00C0      		rjmp .L708
 9629               	.L707:
2217:WTPA.c        **** 			TransferSdByte(0xFF);
 9630               		.loc 1 2217 0
 9631 03ea 8FEF      		ldi r24,lo8(-1)
 9632 03ec 0E94 0000 		call TransferSdByte
 9633               	.LVL391:
 9634 03f0 0150      		subi r16,1
 9635 03f2 1109      		sbc r17,__zero_reg__
2215:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
 9636               		.loc 1 2215 0
 9637 03f4 01F4      		brne .L707
 9638 03f6 00C0      		rjmp .L812
 9639               	.LVL392:
 9640               	.L770:
2222:WTPA.c        **** 		filesystemGood=false;	// Error issuing read command
 9641               		.loc 1 2222 0
 9642 03f8 612C      		mov r6,__zero_reg__
 9643               	.LVL393:
 9644               	.L812:
2224:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 9645               		.loc 1 2224 0
 9646 03fa 8091 C800 		lds r24,200
 9647 03fe 86FF      		sbrs r24,6
 9648 0400 00C0      		rjmp .L812
2227:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
 9649               		.loc 1 2227 0
 9650 0402 0E94 0000 		call EndSdTransfer
 9651               	.LVL394:
2228:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 9652               		.loc 1 2228 0
 9653 0406 8FEF      		ldi r24,lo8(-1)
 9654 0408 0E94 0000 		call TransferSdByte
 9655               	.LVL395:
 9656               	.LBE334:
 9657               	.LBE333:
2388:WTPA.c        **** 					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct file
 9658               		.loc 1 2388 0
 9659 040c 21E0      		ldi r18,lo8(1)
 9660 040e 6212      		cpse r6,r18
 9661 0410 00C0      		rjmp .L710
2390:WTPA.c        **** 						cardState=SD_IDLE;		// Card is legit and ready to go.
 9662               		.loc 1 2390 0
 9663 0412 D092 0000 		sts cardState,r13
 9664               	.LBB335:
 9665               	.LBB336:
2934:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 9666               		.loc 1 2934 0
 9667 0416 8091 6400 		lds r24,100
 9668 041a 8F7B      		andi r24,lo8(-65)
 9669 041c 8093 6400 		sts 100,r24
2936:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 9670               		.loc 1 2936 0
 9671 0420 82E0      		ldi r24,lo8(2)
 9672 0422 8093 B000 		sts 176,r24
2937:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
 9673               		.loc 1 2937 0
 9674 0426 1092 B100 		sts 177,__zero_reg__
2938:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 9675               		.loc 1 2938 0
 9676 042a 1092 B200 		sts 178,__zero_reg__
2939:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 9677               		.loc 1 2939 0
 9678 042e 81E7      		ldi r24,lo8(113)
 9679 0430 8093 B300 		sts 179,r24
2940:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 9680               		.loc 1 2940 0
 9681 0434 C7BA      		out 0x17,r12
2941:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
 9682               		.loc 1 2941 0
 9683 0436 1092 7000 		sts 112,__zero_reg__
2943:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
 9684               		.loc 1 2943 0
 9685 043a 1092 0000 		sts sdIsrState,__zero_reg__
2944:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
 9686               		.loc 1 2944 0
 9687 043e 1092 0000 		sts sdStreamOutput,__zero_reg__
 9688 0442 00C0      		rjmp .L674
 9689               	.L710:
 9690               	.LBE336:
 9691               	.LBE335:
2395:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
 9692               		.loc 1 2395 0
 9693 0444 8FE0      		ldi r24,lo8(15)
 9694 0446 8093 0000 		sts cardState,r24
 9695               	.LVL396:
 9696 044a E0E0      		ldi r30,lo8(sampleToc)
 9697 044c F0E0      		ldi r31,hi8(sampleToc)
 9698               	.LVL397:
 9699               	.L711:
 9700               	.LBB337:
 9701               	.LBB338:
2082:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 9702               		.loc 1 2082 0
 9703 044e 1192      		st Z+,__zero_reg__
2080:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 9704               		.loc 1 2080 0
 9705 0450 30E0      		ldi r19,hi8(sampleToc+64)
 9706 0452 E030      		cpi r30,lo8(sampleToc+64)
 9707 0454 F307      		cpc r31,r19
 9708 0456 01F4      		brne .L711
 9709               	.LVL398:
 9710               	.LBE338:
 9711               	.LBE337:
 9712               	.LBB339:
 9713               	.LBB340:
1447:WTPA.c        **** 	State=newState;
 9714               		.loc 1 1447 0
 9715 0458 80E0      		ldi r24,lo8(gs(DoFormatCard))
 9716 045a 90E0      		ldi r25,hi8(gs(DoFormatCard))
 9717 045c 9093 0000 		sts State+1,r25
 9718 0460 8093 0000 		sts State,r24
1448:WTPA.c        **** 	subState=SS_0;
 9719               		.loc 1 1448 0
 9720 0464 1092 0000 		sts subState,__zero_reg__
 9721 0468 00C0      		rjmp .L674
 9722               	.LVL399:
 9723               	.L693:
 9724               	.LBE340:
 9725               	.LBE339:
2402:WTPA.c        **** 					cardState=SD_INVALID;
 9726               		.loc 1 2402 0
 9727 046a 8FE0      		ldi r24,lo8(15)
 9728 046c 00C0      		rjmp .L857
 9729               	.L677:
2412:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 9730               		.loc 1 2412 0
 9731 046e 2FB7      		in r18,__SREG__
 9732               	.LVL400:
2413:WTPA.c        **** 			cli();
 9733               		.loc 1 2413 0
 9734               	/* #APP */
 9735               	 ;  2413 "WTPA.c" 1
 9736 0470 F894      		cli
 9737               	 ;  0 "" 2
2414:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 9738               		.loc 1 2414 0
 9739               	/* #NOAPP */
 9740 0472 8091 0000 		lds r24,sdBytesInFifo
 9741 0476 9091 0000 		lds r25,sdBytesInFifo+1
 9742 047a 8115      		cp r24,__zero_reg__
 9743 047c 9240      		sbci r25,2
 9744 047e 00F4      		brsh .L712
 9745 0480 8091 0000 		lds r24,sdBytesInFifo
 9746 0484 9091 0000 		lds r25,sdBytesInFifo+1
 9747 0488 4091 0000 		lds r20,sdCardSampleRemaining
 9748 048c 5091 0000 		lds r21,sdCardSampleRemaining+1
 9749 0490 6091 0000 		lds r22,sdCardSampleRemaining+2
 9750 0494 7091 0000 		lds r23,sdCardSampleRemaining+3
 9751 0498 A0E0      		ldi r26,0
 9752 049a B0E0      		ldi r27,0
 9753 049c 8417      		cp r24,r20
 9754 049e 9507      		cpc r25,r21
 9755 04a0 A607      		cpc r26,r22
 9756 04a2 B707      		cpc r27,r23
 9757 04a4 00F4      		brsh .+2
 9758 04a6 00C0      		rjmp .L730
 9759               	.L712:
2416:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
 9760               		.loc 1 2416 0
 9761 04a8 2FBF      		out __SREG__,r18
2417:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
 9762               		.loc 1 2417 0
 9763 04aa 6091 0000 		lds r22,sdSampleStartBlock
 9764 04ae 7091 0000 		lds r23,sdSampleStartBlock+1
 9765 04b2 8091 0000 		lds r24,sdSampleStartBlock+2
 9766 04b6 9091 0000 		lds r25,sdSampleStartBlock+3
 9767 04ba 0E94 0000 		call SdBeginSingleBlockWrite
 9768               	.LVL401:
 9769 04be 8130      		cpi r24,lo8(1)
 9770 04c0 01F0      		breq .+2
 9771 04c2 00C0      		rjmp .L761
2419:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 9772               		.loc 1 2419 0
 9773 04c4 D093 0000 		sts bytesLeftInBlock.2003+1,r29
 9774 04c8 C093 0000 		sts bytesLeftInBlock.2003,r28
2421:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
 9775               		.loc 1 2421 0
 9776 04cc 8FEF      		ldi r24,lo8(-1)
 9777 04ce 0E94 0000 		call TransferSdByte
 9778               	.LVL402:
2422:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
 9779               		.loc 1 2422 0
 9780 04d2 8FEF      		ldi r24,lo8(-1)
 9781 04d4 0E94 0000 		call TransferSdByte
 9782               	.LVL403:
2423:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
 9783               		.loc 1 2423 0
 9784 04d8 8EEF      		ldi r24,lo8(-2)
 9785 04da 0E94 0000 		call TransferSdByte
 9786               	.LVL404:
2424:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
 9787               		.loc 1 2424 0
 9788 04de 8091 0000 		lds r24,sdCardSampleRemaining
 9789 04e2 9091 0000 		lds r25,sdCardSampleRemaining+1
 9790 04e6 A091 0000 		lds r26,sdCardSampleRemaining+2
 9791 04ea B091 0000 		lds r27,sdCardSampleRemaining+3
 9792 04ee 8B2F      		mov r24,r27
 9793 04f0 0E94 0000 		call TransferSdByte
 9794               	.LVL405:
2425:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
 9795               		.loc 1 2425 0
 9796 04f4 6091 0000 		lds r22,sdCardSampleRemaining
 9797 04f8 7091 0000 		lds r23,sdCardSampleRemaining+1
 9798 04fc 8091 0000 		lds r24,sdCardSampleRemaining+2
 9799 0500 9091 0000 		lds r25,sdCardSampleRemaining+3
 9800 0504 0E94 0000 		call TransferSdByte
 9801               	.LVL406:
2426:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
 9802               		.loc 1 2426 0
 9803 0508 8091 0000 		lds r24,sdCardSampleRemaining
 9804 050c 9091 0000 		lds r25,sdCardSampleRemaining+1
 9805 0510 A091 0000 		lds r26,sdCardSampleRemaining+2
 9806 0514 B091 0000 		lds r27,sdCardSampleRemaining+3
 9807 0518 892F      		mov r24,r25
 9808 051a 0E94 0000 		call TransferSdByte
 9809               	.LVL407:
2427:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
 9810               		.loc 1 2427 0
 9811 051e 8091 0000 		lds r24,sdCardSampleRemaining
 9812 0522 9091 0000 		lds r25,sdCardSampleRemaining+1
 9813 0526 A091 0000 		lds r26,sdCardSampleRemaining+2
 9814 052a B091 0000 		lds r27,sdCardSampleRemaining+3
 9815 052e 0E94 0000 		call TransferSdByte
 9816               	.LVL408:
2429:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
 9817               		.loc 1 2429 0
 9818 0532 8091 0000 		lds r24,bytesLeftInBlock.2003
 9819 0536 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 9820 053a 0497      		sbiw r24,4
 9821 053c 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 9822 0540 8093 0000 		sts bytesLeftInBlock.2003,r24
 9823 0544 00C0      		rjmp .L859
 9824               	.L850:
 9825 0546 0091 0000 		lds r16,bytesLeftInBlock.2003
 9826 054a 1091 0000 		lds r17,bytesLeftInBlock.2003+1
 9827 054e 0134      		cpi r16,65
 9828 0550 1105      		cpc r17,__zero_reg__
 9829 0552 00F0      		brlo .L715
 9830 0554 00E4      		ldi r16,lo8(64)
 9831 0556 10E0      		ldi r17,0
 9832               	.L715:
 9833               	.LVL409:
2454:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 9834               		.loc 1 2454 0
 9835 0558 612C      		mov r6,__zero_reg__
 9836 055a 00C0      		rjmp .L716
 9837               	.LVL410:
 9838               	.L720:
2456:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
 9839               		.loc 1 2456 0
 9840 055c 8091 0000 		lds r24,sdCardSampleRemaining
 9841 0560 9091 0000 		lds r25,sdCardSampleRemaining+1
 9842 0564 A091 0000 		lds r26,sdCardSampleRemaining+2
 9843 0568 B091 0000 		lds r27,sdCardSampleRemaining+3
 9844 056c 892B      		or r24,r25
 9845 056e 8A2B      		or r24,r26
 9846 0570 8B2B      		or r24,r27
 9847 0572 01F0      		breq .L717
2458:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
 9848               		.loc 1 2458 0
 9849 0574 E091 0000 		lds r30,sdFifoReadPointer
 9850 0578 F091 0000 		lds r31,sdFifoReadPointer+1
 9851 057c E050      		subi r30,lo8(-(sdFifo))
 9852 057e F040      		sbci r31,hi8(-(sdFifo))
 9853 0580 8081      		ld r24,Z
 9854 0582 0E94 0000 		call TransferSdByte
 9855               	.LVL411:
2459:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
 9856               		.loc 1 2459 0
 9857 0586 8091 0000 		lds r24,sdCardSampleRemaining
 9858 058a 9091 0000 		lds r25,sdCardSampleRemaining+1
 9859 058e A091 0000 		lds r26,sdCardSampleRemaining+2
 9860 0592 B091 0000 		lds r27,sdCardSampleRemaining+3
 9861 0596 0197      		sbiw r24,1
 9862 0598 A109      		sbc r26,__zero_reg__
 9863 059a B109      		sbc r27,__zero_reg__
 9864 059c 8093 0000 		sts sdCardSampleRemaining,r24
 9865 05a0 9093 0000 		sts sdCardSampleRemaining+1,r25
 9866 05a4 A093 0000 		sts sdCardSampleRemaining+2,r26
 9867 05a8 B093 0000 		sts sdCardSampleRemaining+3,r27
2461:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
 9868               		.loc 1 2461 0
 9869 05ac 8091 0000 		lds r24,sdFifoReadPointer
 9870 05b0 9091 0000 		lds r25,sdFifoReadPointer+1
 9871 05b4 0196      		adiw r24,1
 9872 05b6 9093 0000 		sts sdFifoReadPointer+1,r25
 9873 05ba 8093 0000 		sts sdFifoReadPointer,r24
2463:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 9874               		.loc 1 2463 0
 9875 05be 8091 0000 		lds r24,sdFifoReadPointer
 9876 05c2 9091 0000 		lds r25,sdFifoReadPointer+1
 9877 05c6 8115      		cp r24,__zero_reg__
 9878 05c8 9340      		sbci r25,3
 9879 05ca 00F0      		brlo .L718
2465:WTPA.c        **** 						sdFifoReadPointer=0;
 9880               		.loc 1 2465 0
 9881 05cc 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 9882 05d0 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 9883               	.L718:
2468:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 9884               		.loc 1 2468 0
 9885 05d4 2FB7      		in r18,__SREG__
 9886               	.LVL412:
2469:WTPA.c        **** 					cli();
 9887               		.loc 1 2469 0
 9888               	/* #APP */
 9889               	 ;  2469 "WTPA.c" 1
 9890 05d6 F894      		cli
 9891               	 ;  0 "" 2
2470:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
 9892               		.loc 1 2470 0
 9893               	/* #NOAPP */
 9894 05d8 8091 0000 		lds r24,sdBytesInFifo
 9895 05dc 9091 0000 		lds r25,sdBytesInFifo+1
 9896 05e0 0197      		sbiw r24,1
 9897 05e2 9093 0000 		sts sdBytesInFifo+1,r25
 9898 05e6 8093 0000 		sts sdBytesInFifo,r24
2471:WTPA.c        **** 					SREG=sreg;
 9899               		.loc 1 2471 0
 9900 05ea 2FBF      		out __SREG__,r18
 9901 05ec 00C0      		rjmp .L719
 9902               	.LVL413:
 9903               	.L717:
2475:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
 9904               		.loc 1 2475 0
 9905 05ee 8FEF      		ldi r24,lo8(-1)
 9906 05f0 0E94 0000 		call TransferSdByte
 9907               	.LVL414:
 9908               	.L719:
2478:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
 9909               		.loc 1 2478 0
 9910 05f4 8091 0000 		lds r24,bytesLeftInBlock.2003
 9911 05f8 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 9912 05fc 0197      		sbiw r24,1
 9913 05fe 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 9914 0602 8093 0000 		sts bytesLeftInBlock.2003,r24
2454:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 9915               		.loc 1 2454 0
 9916 0606 6394      		inc r6
 9917               	.LVL415:
 9918               	.L716:
 9919 0608 862D      		mov r24,r6
 9920 060a 90E0      		ldi r25,0
 9921 060c 8017      		cp r24,r16
 9922 060e 9107      		cpc r25,r17
 9923 0610 00F4      		brsh .+2
 9924 0612 00C0      		rjmp .L720
2482:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
 9925               		.loc 1 2482 0
 9926 0614 8091 0000 		lds r24,bytesLeftInBlock.2003
 9927 0618 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 9928 061c 892B      		or r24,r25
 9929 061e 01F0      		breq .+2
 9930 0620 00C0      		rjmp .L674
2484:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 9931               		.loc 1 2484 0
 9932 0622 8FEF      		ldi r24,lo8(-1)
 9933 0624 0E94 0000 		call TransferSdByte
 9934               	.LVL416:
2485:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 9935               		.loc 1 2485 0
 9936 0628 8FEF      		ldi r24,lo8(-1)
 9937 062a 0E94 0000 		call TransferSdByte
 9938               	.LVL417:
2486:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 9939               		.loc 1 2486 0
 9940 062e 8FEF      		ldi r24,lo8(-1)
 9941 0630 0E94 0000 		call TransferSdByte
 9942               	.LVL418:
 9943 0634 8F71      		andi r24,lo8(31)
 9944               	.LVL419:
2488:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 9945               		.loc 1 2488 0
 9946 0636 8530      		cpi r24,lo8(5)
 9947 0638 01F0      		breq .+2
 9948 063a 00C0      		rjmp .L761
2490:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 9949               		.loc 1 2490 0
 9950 063c 62E6      		ldi r22,lo8(98)
 9951 063e 72E0      		ldi r23,lo8(2)
 9952 0640 83E0      		ldi r24,lo8(3)
 9953               	.LVL420:
 9954 0642 0E94 0000 		call SetTimer
 9955               	.LVL421:
2491:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
 9956               		.loc 1 2491 0
 9957 0646 2092 0000 		sts cardState,r2
 9958 064a 00C0      		rjmp .L674
 9959               	.LVL422:
 9960               	.L679:
2501:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
 9961               		.loc 1 2501 0
 9962 064c 83E0      		ldi r24,lo8(3)
 9963 064e 0E94 0000 		call CheckTimer
 9964               	.LVL423:
 9965 0652 8111      		cpse r24,__zero_reg__
 9966 0654 00C0      		rjmp .L761
 9967 0656 14E0      		ldi r17,lo8(4)
 9968               	.L724:
2506:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 9969               		.loc 1 2506 0
 9970 0658 8FEF      		ldi r24,lo8(-1)
 9971 065a 0E94 0000 		call TransferSdByte
 9972               	.LVL424:
2507:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 9973               		.loc 1 2507 0
 9974 065e 8F3F      		cpi r24,lo8(-1)
 9975 0660 01F4      		brne .+2
 9976 0662 00C0      		rjmp .L723
 9977               	.LVL425:
 9978 0664 1150      		subi r17,lo8(-(-1))
2504:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 9979               		.loc 1 2504 0
 9980 0666 01F4      		brne .L724
 9981 0668 00C0      		rjmp .L674
 9982               	.L725:
2521:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 9983               		.loc 1 2521 0
 9984 066a 8091 C800 		lds r24,200
 9985 066e 86FF      		sbrs r24,6
 9986 0670 00C0      		rjmp .L725
2524:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
 9987               		.loc 1 2524 0
 9988 0672 8091 0000 		lds r24,sdCardSampleRemaining
 9989 0676 9091 0000 		lds r25,sdCardSampleRemaining+1
 9990 067a A091 0000 		lds r26,sdCardSampleRemaining+2
 9991 067e B091 0000 		lds r27,sdCardSampleRemaining+3
 9992 0682 892B      		or r24,r25
 9993 0684 8A2B      		or r24,r26
 9994 0686 8B2B      		or r24,r27
 9995 0688 01F0      		breq .L726
2526:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
 9996               		.loc 1 2526 0
 9997 068a 85E0      		ldi r24,lo8(5)
 9998 068c 00C0      		rjmp .L857
 9999               	.L726:
2530:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
 10000               		.loc 1 2530 0
 10001 068e 2091 0000 		lds r18,sdCurrentSlot
 10002 0692 3091 0000 		lds r19,sdCurrentSlot+1
 10003               	.LVL426:
 10004               	.LBB341:
 10005               	.LBB342:
2094:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 10006               		.loc 1 2094 0
 10007 0696 F901      		movw r30,r18
 10008 0698 43E0      		ldi r20,3
 10009               		1:
 10010 069a F695      		lsr r31
 10011 069c E795      		ror r30
 10012 069e 4A95      		dec r20
 10013 06a0 01F4      		brne 1b
 10014               	.LBE342:
4801:WTPA.c        **** 		HandleLeds();			// Keep LEDs updated.
4802:WTPA.c        **** 		UpdateCard();			// Keep the SD card state machine running.
4803:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
4804:WTPA.c        **** 
4805:WTPA.c        **** //daNextJump=random31;
4806:WTPA.c        **** //daNextJumpPrime=(keyState+systemTicks);
4807:WTPA.c        **** 
4808:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
4809:WTPA.c        **** 		{
4810:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
4811:WTPA.c        **** 		}
4812:WTPA.c        **** 
4813:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
4814:WTPA.c        **** 		{
4815:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
4816:WTPA.c        **** 			{
4817:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
4818:WTPA.c        **** 			}
4819:WTPA.c        **** 		}
4820:WTPA.c        **** 
4821:WTPA.c        **** 		State();				// Execute the current program state.
4822:WTPA.c        **** 	}
4823:WTPA.c        **** 	return(0);
4824:WTPA.c        **** }
 10015               		.loc 1 4824 0
 10016 06a2 FF27      		clr r31
 10017               	.LBB343:
2097:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 10018               		.loc 1 2097 0
 10019 06a4 E050      		subi r30,lo8(-(sampleToc))
 10020 06a6 F040      		sbci r31,hi8(-(sampleToc))
 10021 06a8 4081      		ld r20,Z
 10022               	.LBE343:
2095:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 10023               		.loc 1 2095 0
 10024 06aa 2770      		andi r18,7
 10025 06ac 3327      		clr r19
 10026               	.LVL427:
 10027               	.LBB344:
2097:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 10028               		.loc 1 2097 0
 10029 06ae 842F      		mov r24,r20
 10030 06b0 90E0      		ldi r25,0
 10031 06b2 022E      		mov r0,r18
 10032 06b4 00C0      		rjmp 2f
 10033               		1:
 10034 06b6 9595      		asr r25
 10035 06b8 8795      		ror r24
 10036               		2:
 10037 06ba 0A94      		dec r0
 10038 06bc 02F4      		brpl 1b
 10039 06be 80FF      		sbrs r24,0
 10040 06c0 00C0      		rjmp .L853
 10041 06c2 00C0      		rjmp .L727
 10042               	.LVL428:
 10043               	.L680:
 10044               	.LBE344:
 10045               	.LBE341:
2549:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
 10046               		.loc 1 2549 0
 10047 06c4 2FB7      		in r18,__SREG__
 10048               	.LVL429:
2550:WTPA.c        **** 			cli();
 10049               		.loc 1 2550 0
 10050               	/* #APP */
 10051               	 ;  2550 "WTPA.c" 1
 10052 06c6 F894      		cli
 10053               	 ;  0 "" 2
2551:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 10054               		.loc 1 2551 0
 10055               	/* #NOAPP */
 10056 06c8 8091 0000 		lds r24,sdBytesInFifo
 10057 06cc 9091 0000 		lds r25,sdBytesInFifo+1
 10058 06d0 8115      		cp r24,__zero_reg__
 10059 06d2 9240      		sbci r25,2
 10060 06d4 00F4      		brsh .L729
 10061 06d6 8091 0000 		lds r24,sdBytesInFifo
 10062 06da 9091 0000 		lds r25,sdBytesInFifo+1
 10063 06de 4091 0000 		lds r20,sdCardSampleRemaining
 10064 06e2 5091 0000 		lds r21,sdCardSampleRemaining+1
 10065 06e6 6091 0000 		lds r22,sdCardSampleRemaining+2
 10066 06ea 7091 0000 		lds r23,sdCardSampleRemaining+3
 10067 06ee A0E0      		ldi r26,0
 10068 06f0 B0E0      		ldi r27,0
 10069 06f2 8417      		cp r24,r20
 10070 06f4 9507      		cpc r25,r21
 10071 06f6 A607      		cpc r26,r22
 10072 06f8 B707      		cpc r27,r23
 10073 06fa 00F0      		brlo .L730
 10074               	.L729:
2553:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
 10075               		.loc 1 2553 0
 10076 06fc 2FBF      		out __SREG__,r18
2554:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
 10077               		.loc 1 2554 0
 10078 06fe 2091 0000 		lds r18,sdCurrentBlockOffset
 10079 0702 3091 0000 		lds r19,sdCurrentBlockOffset+1
 10080               	.LVL430:
 10081 0706 2F5F      		subi r18,-1
 10082 0708 3F4F      		sbci r19,-1
 10083 070a 3093 0000 		sts sdCurrentBlockOffset+1,r19
 10084 070e 2093 0000 		sts sdCurrentBlockOffset,r18
2556:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
 10085               		.loc 1 2556 0
 10086 0712 6091 0000 		lds r22,sdSampleStartBlock
 10087 0716 7091 0000 		lds r23,sdSampleStartBlock+1
 10088 071a 8091 0000 		lds r24,sdSampleStartBlock+2
 10089 071e 9091 0000 		lds r25,sdSampleStartBlock+3
 10090 0722 620F      		add r22,r18
 10091 0724 731F      		adc r23,r19
 10092 0726 811D      		adc r24,__zero_reg__
 10093 0728 911D      		adc r25,__zero_reg__
 10094 072a 0E94 0000 		call SdBeginSingleBlockWrite
 10095               	.LVL431:
 10096 072e 8130      		cpi r24,lo8(1)
 10097 0730 01F0      		breq .+2
 10098 0732 00C0      		rjmp .L761
2558:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 10099               		.loc 1 2558 0
 10100 0734 D093 0000 		sts bytesLeftInBlock.2003+1,r29
 10101 0738 C093 0000 		sts bytesLeftInBlock.2003,r28
2560:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
 10102               		.loc 1 2560 0
 10103 073c 8FEF      		ldi r24,lo8(-1)
 10104 073e 0E94 0000 		call TransferSdByte
 10105               	.LVL432:
2561:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
 10106               		.loc 1 2561 0
 10107 0742 8FEF      		ldi r24,lo8(-1)
 10108 0744 0E94 0000 		call TransferSdByte
 10109               	.LVL433:
2562:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
 10110               		.loc 1 2562 0
 10111 0748 8EEF      		ldi r24,lo8(-2)
 10112 074a 0E94 0000 		call TransferSdByte
 10113               	.LVL434:
 10114               	.L859:
2563:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
 10115               		.loc 1 2563 0
 10116 074e 83E0      		ldi r24,lo8(3)
 10117 0750 00C0      		rjmp .L857
 10118               	.LVL435:
 10119               	.L730:
2572:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
 10120               		.loc 1 2572 0
 10121 0752 2FBF      		out __SREG__,r18
 10122 0754 00C0      		rjmp .L674
 10123               	.LVL436:
 10124               	.L681:
2581:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
 10125               		.loc 1 2581 0
 10126 0756 60E0      		ldi r22,0
 10127 0758 70E0      		ldi r23,0
 10128 075a CB01      		movw r24,r22
 10129 075c 0E94 0000 		call SdBeginSingleBlockWrite
 10130               	.LVL437:
 10131 0760 8130      		cpi r24,lo8(1)
 10132 0762 01F0      		breq .+2
 10133 0764 00C0      		rjmp .L761
2583:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 10134               		.loc 1 2583 0
 10135 0766 D093 0000 		sts bytesLeftInBlock.2003+1,r29
 10136 076a C093 0000 		sts bytesLeftInBlock.2003,r28
2585:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10137               		.loc 1 2585 0
 10138 076e 8FEF      		ldi r24,lo8(-1)
 10139 0770 0E94 0000 		call TransferSdByte
 10140               	.LVL438:
2586:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
 10141               		.loc 1 2586 0
 10142 0774 8FEF      		ldi r24,lo8(-1)
 10143 0776 0E94 0000 		call TransferSdByte
 10144               	.LVL439:
2587:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
 10145               		.loc 1 2587 0
 10146 077a 8EEF      		ldi r24,lo8(-2)
 10147 077c 0E94 0000 		call TransferSdByte
 10148               	.LVL440:
2588:WTPA.c        **** 				TransferSdByte('W');				// Send flag that this is a WTPA card
 10149               		.loc 1 2588 0
 10150 0780 87E5      		ldi r24,lo8(87)
 10151 0782 0E94 0000 		call TransferSdByte
 10152               	.LVL441:
2589:WTPA.c        **** 				TransferSdByte('T');
 10153               		.loc 1 2589 0
 10154 0786 84E5      		ldi r24,lo8(84)
 10155 0788 0E94 0000 		call TransferSdByte
 10156               	.LVL442:
2590:WTPA.c        **** 				TransferSdByte('P');
 10157               		.loc 1 2590 0
 10158 078c 80E5      		ldi r24,lo8(80)
 10159 078e 0E94 0000 		call TransferSdByte
 10160               	.LVL443:
2591:WTPA.c        **** 				TransferSdByte('A');
 10161               		.loc 1 2591 0
 10162 0792 81E4      		ldi r24,lo8(65)
 10163 0794 0E94 0000 		call TransferSdByte
 10164               	.LVL444:
2593:WTPA.c        **** 				bytesLeftInBlock-=4;
 10165               		.loc 1 2593 0
 10166 0798 8091 0000 		lds r24,bytesLeftInBlock.2003
 10167 079c 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10168 07a0 0497      		sbiw r24,4
 10169 07a2 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10170 07a6 8093 0000 		sts bytesLeftInBlock.2003,r24
 10171               	.LVL445:
 10172 07aa 1CE0      		ldi r17,lo8(12)
 10173               	.LVL446:
 10174               	.L733:
2597:WTPA.c        **** 					TransferSdByte('x');
 10175               		.loc 1 2597 0
 10176 07ac 88E7      		ldi r24,lo8(120)
 10177 07ae 0E94 0000 		call TransferSdByte
 10178               	.LVL447:
 10179 07b2 1150      		subi r17,lo8(-(-1))
2595:WTPA.c        **** 				for(i=0;i<12;i++)					// 12 don't care bytes
 10180               		.loc 1 2595 0
 10181 07b4 01F4      		brne .L733
2600:WTPA.c        **** 				bytesLeftInBlock-=12;
 10182               		.loc 1 2600 0
 10183 07b6 8091 0000 		lds r24,bytesLeftInBlock.2003
 10184 07ba 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10185 07be 0C97      		sbiw r24,12
 10186 07c0 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10187 07c4 8093 0000 		sts bytesLeftInBlock.2003,r24
 10188               	.LVL448:
 10189 07c8 00E0      		ldi r16,lo8(sampleToc)
 10190 07ca 10E0      		ldi r17,hi8(sampleToc)
 10191               	.LVL449:
 10192               	.L734:
2604:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
 10193               		.loc 1 2604 0
 10194 07cc F801      		movw r30,r16
 10195 07ce 8191      		ld r24,Z+
 10196 07d0 8F01      		movw r16,r30
 10197 07d2 0E94 0000 		call TransferSdByte
 10198               	.LVL450:
2602:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
 10199               		.loc 1 2602 0
 10200 07d6 F0E0      		ldi r31,hi8(sampleToc+64)
 10201 07d8 0030      		cpi r16,lo8(sampleToc+64)
 10202 07da 1F07      		cpc r17,r31
 10203 07dc 01F4      		brne .L734
2607:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
 10204               		.loc 1 2607 0
 10205 07de 8091 0000 		lds r24,bytesLeftInBlock.2003
 10206 07e2 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10207 07e6 8054      		subi r24,64
 10208 07e8 9109      		sbc r25,__zero_reg__
 10209 07ea 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10210 07ee 8093 0000 		sts bytesLeftInBlock.2003,r24
2608:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 10211               		.loc 1 2608 0
 10212 07f2 9092 0000 		sts cardState,r9
 10213 07f6 00C0      		rjmp .L674
 10214               	.L851:
 10215 07f8 0091 0000 		lds r16,bytesLeftInBlock.2003
 10216 07fc 1091 0000 		lds r17,bytesLeftInBlock.2003+1
 10217 0800 0134      		cpi r16,65
 10218 0802 1105      		cpc r17,__zero_reg__
 10219 0804 00F0      		brlo .L735
 10220 0806 00E4      		ldi r16,lo8(64)
 10221 0808 10E0      		ldi r17,0
 10222               	.L735:
 10223               	.LVL451:
2626:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10224               		.loc 1 2626 0
 10225 080a 612C      		mov r6,__zero_reg__
 10226 080c 00C0      		rjmp .L736
 10227               	.LVL452:
 10228               	.L737:
2628:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 10229               		.loc 1 2628 0
 10230 080e 8FEF      		ldi r24,lo8(-1)
 10231 0810 0E94 0000 		call TransferSdByte
 10232               	.LVL453:
2629:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
 10233               		.loc 1 2629 0
 10234 0814 8091 0000 		lds r24,bytesLeftInBlock.2003
 10235 0818 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10236 081c 0197      		sbiw r24,1
 10237 081e 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10238 0822 8093 0000 		sts bytesLeftInBlock.2003,r24
2626:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 10239               		.loc 1 2626 0
 10240 0826 6394      		inc r6
 10241               	.LVL454:
 10242               	.L736:
 10243 0828 862D      		mov r24,r6
 10244 082a 90E0      		ldi r25,0
 10245 082c 8017      		cp r24,r16
 10246 082e 9107      		cpc r25,r17
 10247 0830 00F0      		brlo .L737
2632:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
 10248               		.loc 1 2632 0
 10249 0832 8091 0000 		lds r24,bytesLeftInBlock.2003
 10250 0836 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10251 083a 892B      		or r24,r25
 10252 083c 01F0      		breq .+2
 10253 083e 00C0      		rjmp .L674
2634:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10254               		.loc 1 2634 0
 10255 0840 8FEF      		ldi r24,lo8(-1)
 10256 0842 0E94 0000 		call TransferSdByte
 10257               	.LVL455:
2635:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 10258               		.loc 1 2635 0
 10259 0846 8FEF      		ldi r24,lo8(-1)
 10260 0848 0E94 0000 		call TransferSdByte
 10261               	.LVL456:
2636:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 10262               		.loc 1 2636 0
 10263 084c 8FEF      		ldi r24,lo8(-1)
 10264 084e 0E94 0000 		call TransferSdByte
 10265               	.LVL457:
 10266 0852 8F71      		andi r24,lo8(31)
 10267               	.LVL458:
2638:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 10268               		.loc 1 2638 0
 10269 0854 8530      		cpi r24,lo8(5)
 10270 0856 01F0      		breq .+2
 10271 0858 00C0      		rjmp .L761
2640:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 10272               		.loc 1 2640 0
 10273 085a 62E6      		ldi r22,lo8(98)
 10274 085c 72E0      		ldi r23,lo8(2)
 10275 085e 83E0      		ldi r24,lo8(3)
 10276               	.LVL459:
 10277 0860 0E94 0000 		call SetTimer
 10278               	.LVL460:
2641:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
 10279               		.loc 1 2641 0
 10280 0864 88E0      		ldi r24,lo8(8)
 10281               	.LVL461:
 10282               	.L857:
 10283 0866 8093 0000 		sts cardState,r24
 10284 086a 00C0      		rjmp .L674
 10285               	.L683:
2651:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10286               		.loc 1 2651 0
 10287 086c 83E0      		ldi r24,lo8(3)
 10288 086e 0E94 0000 		call CheckTimer
 10289               	.LVL462:
 10290 0872 8111      		cpse r24,__zero_reg__
 10291 0874 00C0      		rjmp .L761
 10292 0876 14E0      		ldi r17,lo8(4)
 10293               	.L741:
2656:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10294               		.loc 1 2656 0
 10295 0878 8FEF      		ldi r24,lo8(-1)
 10296 087a 0E94 0000 		call TransferSdByte
 10297               	.LVL463:
2657:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 10298               		.loc 1 2657 0
 10299 087e 8F3F      		cpi r24,lo8(-1)
 10300 0880 01F4      		brne .+2
 10301 0882 00C0      		rjmp .L740
 10302               	.LVL464:
 10303 0884 1150      		subi r17,lo8(-(-1))
2654:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
 10304               		.loc 1 2654 0
 10305 0886 01F4      		brne .L741
 10306 0888 00C0      		rjmp .L674
 10307               	.L742:
2671:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10308               		.loc 1 2671 0
 10309 088a 8091 C800 		lds r24,200
 10310 088e 86FF      		sbrs r24,6
 10311 0890 00C0      		rjmp .L742
 10312 0892 00C0      		rjmp .L727
 10313               	.L684:
2687:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 10314               		.loc 1 2687 0
 10315 0894 83E0      		ldi r24,lo8(3)
 10316 0896 0E94 0000 		call CheckTimer
 10317               	.LVL465:
 10318 089a 8111      		cpse r24,__zero_reg__
 10319 089c 00C0      		rjmp .L761
 10320 089e 14E0      		ldi r17,lo8(4)
 10321               	.L745:
2692:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10322               		.loc 1 2692 0
 10323 08a0 8FEF      		ldi r24,lo8(-1)
 10324 08a2 0E94 0000 		call TransferSdByte
 10325               	.LVL466:
2693:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 10326               		.loc 1 2693 0
 10327 08a6 8F3F      		cpi r24,lo8(-1)
 10328 08a8 01F4      		brne .L744
 10329               	.LVL467:
 10330 08aa 1150      		subi r17,lo8(-(-1))
2690:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 10331               		.loc 1 2690 0
 10332 08ac 01F4      		brne .L745
 10333 08ae 00C0      		rjmp .L674
 10334               	.LVL468:
 10335               	.L744:
2703:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 10336               		.loc 1 2703 0
 10337 08b0 8E3F      		cpi r24,lo8(-2)
 10338 08b2 01F0      		breq .+2
 10339 08b4 00C0      		rjmp .L761
2705:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
 10340               		.loc 1 2705 0
 10341 08b6 D093 0000 		sts bytesLeftInBlock.2003+1,r29
 10342 08ba C093 0000 		sts bytesLeftInBlock.2003,r28
2707:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
 10343               		.loc 1 2707 0
 10344 08be 8FEF      		ldi r24,lo8(-1)
 10345               	.LVL469:
 10346 08c0 0E94 0000 		call TransferSdByte
 10347               	.LVL470:
 10348 08c4 90E0      		ldi r25,0
 10349 08c6 A0E0      		ldi r26,0
 10350 08c8 B0E0      		ldi r27,0
 10351 08ca B82F      		mov r27,r24
 10352 08cc AA27      		clr r26
 10353 08ce 9927      		clr r25
 10354 08d0 8827      		clr r24
 10355 08d2 8093 0000 		sts sdCardSampleRemaining,r24
 10356 08d6 9093 0000 		sts sdCardSampleRemaining+1,r25
 10357 08da A093 0000 		sts sdCardSampleRemaining+2,r26
 10358 08de B093 0000 		sts sdCardSampleRemaining+3,r27
2708:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
 10359               		.loc 1 2708 0
 10360 08e2 4090 0000 		lds r4,sdCardSampleRemaining
 10361 08e6 5090 0000 		lds r5,sdCardSampleRemaining+1
 10362 08ea 6090 0000 		lds r6,sdCardSampleRemaining+2
 10363 08ee 7090 0000 		lds r7,sdCardSampleRemaining+3
 10364 08f2 8FEF      		ldi r24,lo8(-1)
 10365 08f4 0E94 0000 		call TransferSdByte
 10366               	.LVL471:
 10367 08f8 B301      		movw r22,r6
 10368 08fa A201      		movw r20,r4
 10369 08fc 682B      		or r22,r24
 10370 08fe 4093 0000 		sts sdCardSampleRemaining,r20
 10371 0902 5093 0000 		sts sdCardSampleRemaining+1,r21
 10372 0906 6093 0000 		sts sdCardSampleRemaining+2,r22
 10373 090a 7093 0000 		sts sdCardSampleRemaining+3,r23
2709:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
 10374               		.loc 1 2709 0
 10375 090e 4090 0000 		lds r4,sdCardSampleRemaining
 10376 0912 5090 0000 		lds r5,sdCardSampleRemaining+1
 10377 0916 6090 0000 		lds r6,sdCardSampleRemaining+2
 10378 091a 7090 0000 		lds r7,sdCardSampleRemaining+3
 10379 091e 8FEF      		ldi r24,lo8(-1)
 10380 0920 0E94 0000 		call TransferSdByte
 10381               	.LVL472:
 10382 0924 B301      		movw r22,r6
 10383 0926 A201      		movw r20,r4
 10384 0928 582B      		or r21,r24
 10385 092a 4093 0000 		sts sdCardSampleRemaining,r20
 10386 092e 5093 0000 		sts sdCardSampleRemaining+1,r21
 10387 0932 6093 0000 		sts sdCardSampleRemaining+2,r22
 10388 0936 7093 0000 		sts sdCardSampleRemaining+3,r23
2710:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
 10389               		.loc 1 2710 0
 10390 093a 4090 0000 		lds r4,sdCardSampleRemaining
 10391 093e 5090 0000 		lds r5,sdCardSampleRemaining+1
 10392 0942 6090 0000 		lds r6,sdCardSampleRemaining+2
 10393 0946 7090 0000 		lds r7,sdCardSampleRemaining+3
 10394 094a 8FEF      		ldi r24,lo8(-1)
 10395 094c 0E94 0000 		call TransferSdByte
 10396               	.LVL473:
 10397 0950 B301      		movw r22,r6
 10398 0952 A201      		movw r20,r4
 10399 0954 482B      		or r20,r24
 10400 0956 4093 0000 		sts sdCardSampleRemaining,r20
 10401 095a 5093 0000 		sts sdCardSampleRemaining+1,r21
 10402 095e 6093 0000 		sts sdCardSampleRemaining+2,r22
 10403 0962 7093 0000 		sts sdCardSampleRemaining+3,r23
2712:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
 10404               		.loc 1 2712 0
 10405 0966 8091 0000 		lds r24,sdCardSampleRemaining
 10406 096a 9091 0000 		lds r25,sdCardSampleRemaining+1
 10407 096e A091 0000 		lds r26,sdCardSampleRemaining+2
 10408 0972 B091 0000 		lds r27,sdCardSampleRemaining+3
 10409 0976 8093 0000 		sts sdRamSampleRemaining,r24
 10410 097a 9093 0000 		sts sdRamSampleRemaining+1,r25
 10411 097e A093 0000 		sts sdRamSampleRemaining+2,r26
 10412 0982 B093 0000 		sts sdRamSampleRemaining+3,r27
2714:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
 10413               		.loc 1 2714 0
 10414 0986 8091 0000 		lds r24,bytesLeftInBlock.2003
 10415 098a 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10416 098e 0497      		sbiw r24,4
 10417 0990 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10418 0994 8093 0000 		sts bytesLeftInBlock.2003,r24
 10419 0998 00C0      		rjmp .L861
 10420               	.L685:
2735:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
 10421               		.loc 1 2735 0
 10422 099a 8091 0000 		lds r24,sdAbortRead
 10423 099e 8130      		cpi r24,lo8(1)
 10424 09a0 01F4      		brne .L747
 10425 09a2 00C0      		rjmp .L856
 10426               	.L747:
 10427 09a4 0091 0000 		lds r16,bytesLeftInBlock.2003
 10428 09a8 1091 0000 		lds r17,bytesLeftInBlock.2003+1
 10429 09ac 0134      		cpi r16,65
 10430 09ae 1105      		cpc r17,__zero_reg__
 10431 09b0 00F0      		brlo .L748
 10432 09b2 00E4      		ldi r16,lo8(64)
 10433 09b4 10E0      		ldi r17,0
 10434               	.L748:
 10435               	.LVL474:
2751:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 10436               		.loc 1 2751 0
 10437 09b6 612C      		mov r6,__zero_reg__
 10438 09b8 00C0      		rjmp .L749
 10439               	.LVL475:
 10440               	.L752:
2753:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
 10441               		.loc 1 2753 0
 10442 09ba 8FEF      		ldi r24,lo8(-1)
 10443 09bc 0E94 0000 		call TransferSdByte
 10444               	.LVL476:
2754:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
 10445               		.loc 1 2754 0
 10446 09c0 2091 0000 		lds r18,bytesLeftInBlock.2003
 10447 09c4 3091 0000 		lds r19,bytesLeftInBlock.2003+1
 10448 09c8 2150      		subi r18,1
 10449 09ca 3109      		sbc r19,__zero_reg__
 10450 09cc 3093 0000 		sts bytesLeftInBlock.2003+1,r19
 10451 09d0 2093 0000 		sts bytesLeftInBlock.2003,r18
2756:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
 10452               		.loc 1 2756 0
 10453 09d4 4091 0000 		lds r20,sdCardSampleRemaining
 10454 09d8 5091 0000 		lds r21,sdCardSampleRemaining+1
 10455 09dc 6091 0000 		lds r22,sdCardSampleRemaining+2
 10456 09e0 7091 0000 		lds r23,sdCardSampleRemaining+3
 10457 09e4 452B      		or r20,r21
 10458 09e6 462B      		or r20,r22
 10459 09e8 472B      		or r20,r23
 10460 09ea 01F0      		breq .L750
2758:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
 10461               		.loc 1 2758 0
 10462 09ec 4091 0000 		lds r20,sdCardSampleRemaining
 10463 09f0 5091 0000 		lds r21,sdCardSampleRemaining+1
 10464 09f4 6091 0000 		lds r22,sdCardSampleRemaining+2
 10465 09f8 7091 0000 		lds r23,sdCardSampleRemaining+3
 10466 09fc 4150      		subi r20,1
 10467 09fe 5109      		sbc r21,__zero_reg__
 10468 0a00 6109      		sbc r22,__zero_reg__
 10469 0a02 7109      		sbc r23,__zero_reg__
 10470 0a04 4093 0000 		sts sdCardSampleRemaining,r20
 10471 0a08 5093 0000 		sts sdCardSampleRemaining+1,r21
 10472 0a0c 6093 0000 		sts sdCardSampleRemaining+2,r22
 10473 0a10 7093 0000 		sts sdCardSampleRemaining+3,r23
2760:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
 10474               		.loc 1 2760 0
 10475 0a14 E091 0000 		lds r30,sdFifoWritePointer
 10476 0a18 F091 0000 		lds r31,sdFifoWritePointer+1
 10477 0a1c E050      		subi r30,lo8(-(sdFifo))
 10478 0a1e F040      		sbci r31,hi8(-(sdFifo))
 10479 0a20 8083      		st Z,r24
2761:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
 10480               		.loc 1 2761 0
 10481 0a22 8091 0000 		lds r24,sdFifoWritePointer
 10482 0a26 9091 0000 		lds r25,sdFifoWritePointer+1
 10483               	.LVL477:
 10484 0a2a 0196      		adiw r24,1
 10485 0a2c 9093 0000 		sts sdFifoWritePointer+1,r25
 10486 0a30 8093 0000 		sts sdFifoWritePointer,r24
2763:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 10487               		.loc 1 2763 0
 10488 0a34 8091 0000 		lds r24,sdFifoWritePointer
 10489 0a38 9091 0000 		lds r25,sdFifoWritePointer+1
 10490 0a3c 8115      		cp r24,__zero_reg__
 10491 0a3e 9340      		sbci r25,3
 10492 0a40 00F0      		brlo .L751
2765:WTPA.c        **** 							sdFifoWritePointer=0;
 10493               		.loc 1 2765 0
 10494 0a42 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 10495 0a46 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 10496               	.L751:
2768:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 10497               		.loc 1 2768 0
 10498 0a4a 2FB7      		in r18,__SREG__
 10499               	.LVL478:
2769:WTPA.c        **** 						cli();
 10500               		.loc 1 2769 0
 10501               	/* #APP */
 10502               	 ;  2769 "WTPA.c" 1
 10503 0a4c F894      		cli
 10504               	 ;  0 "" 2
2770:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
 10505               		.loc 1 2770 0
 10506               	/* #NOAPP */
 10507 0a4e 8091 0000 		lds r24,sdBytesInFifo
 10508 0a52 9091 0000 		lds r25,sdBytesInFifo+1
 10509 0a56 0196      		adiw r24,1
 10510 0a58 9093 0000 		sts sdBytesInFifo+1,r25
 10511 0a5c 8093 0000 		sts sdBytesInFifo,r24
2771:WTPA.c        **** 						SREG=sreg;
 10512               		.loc 1 2771 0
 10513 0a60 2FBF      		out __SREG__,r18
 10514               	.LVL479:
 10515               	.L750:
2751:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 10516               		.loc 1 2751 0
 10517 0a62 6394      		inc r6
 10518               	.LVL480:
 10519               	.L749:
 10520 0a64 862D      		mov r24,r6
 10521 0a66 90E0      		ldi r25,0
 10522 0a68 8017      		cp r24,r16
 10523 0a6a 9107      		cpc r25,r17
 10524 0a6c 00F4      		brsh .+2
 10525 0a6e 00C0      		rjmp .L752
2776:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
 10526               		.loc 1 2776 0
 10527 0a70 8091 0000 		lds r24,bytesLeftInBlock.2003
 10528 0a74 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10529 0a78 892B      		or r24,r25
 10530 0a7a 01F0      		breq .+2
 10531 0a7c 00C0      		rjmp .L674
2778:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10532               		.loc 1 2778 0
 10533 0a7e 8FEF      		ldi r24,lo8(-1)
 10534 0a80 0E94 0000 		call TransferSdByte
 10535               	.LVL481:
2779:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10536               		.loc 1 2779 0
 10537 0a84 8FEF      		ldi r24,lo8(-1)
 10538 0a86 0E94 0000 		call TransferSdByte
 10539               	.LVL482:
 10540               	.L753:
2780:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10541               		.loc 1 2780 0
 10542 0a8a 8091 C800 		lds r24,200
 10543 0a8e 86FF      		sbrs r24,6
 10544 0a90 00C0      		rjmp .L753
2783:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10545               		.loc 1 2783 0
 10546 0a92 0E94 0000 		call EndSdTransfer
 10547               	.LVL483:
2784:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10548               		.loc 1 2784 0
 10549 0a96 8FEF      		ldi r24,lo8(-1)
 10550 0a98 0E94 0000 		call TransferSdByte
 10551               	.LVL484:
2785:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 10552               		.loc 1 2785 0
 10553 0a9c 8092 0000 		sts cardState,r8
2787:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
 10554               		.loc 1 2787 0
 10555 0aa0 8091 0000 		lds r24,sdCardSampleRemaining
 10556 0aa4 9091 0000 		lds r25,sdCardSampleRemaining+1
 10557 0aa8 A091 0000 		lds r26,sdCardSampleRemaining+2
 10558 0aac B091 0000 		lds r27,sdCardSampleRemaining+3
 10559 0ab0 892B      		or r24,r25
 10560 0ab2 8A2B      		or r24,r26
 10561 0ab4 8B2B      		or r24,r27
 10562 0ab6 01F0      		breq .+2
 10563 0ab8 00C0      		rjmp .L674
 10564               	.L811:
2789:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10565               		.loc 1 2789 0
 10566 0aba 8091 C800 		lds r24,200
 10567 0abe 86FF      		sbrs r24,6
 10568 0ac0 00C0      		rjmp .L811
 10569 0ac2 00C0      		rjmp .L727
 10570               	.LVL485:
 10571               	.L686:
2798:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 10572               		.loc 1 2798 0
 10573 0ac4 EFB7      		in r30,__SREG__
 10574               	.LVL486:
2799:WTPA.c        **** 			cli();
 10575               		.loc 1 2799 0
 10576               	/* #APP */
 10577               	 ;  2799 "WTPA.c" 1
 10578 0ac6 F894      		cli
 10579               	 ;  0 "" 2
2801:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
 10580               		.loc 1 2801 0
 10581               	/* #NOAPP */
 10582 0ac8 2091 0000 		lds r18,sdBytesInFifo
 10583 0acc 3091 0000 		lds r19,sdBytesInFifo+1
 10584 0ad0 80E0      		ldi r24,0
 10585 0ad2 93E0      		ldi r25,lo8(3)
 10586 0ad4 AC01      		movw r20,r24
 10587 0ad6 421B      		sub r20,r18
 10588 0ad8 530B      		sbc r21,r19
 10589 0ada 9A01      		movw r18,r20
 10590 0adc 2115      		cp r18,__zero_reg__
 10591 0ade 3240      		sbci r19,2
 10592 0ae0 00F4      		brsh .L755
 10593 0ae2 2091 0000 		lds r18,sdBytesInFifo
 10594 0ae6 3091 0000 		lds r19,sdBytesInFifo+1
 10595 0aea 4091 0000 		lds r20,sdCardSampleRemaining
 10596 0aee 5091 0000 		lds r21,sdCardSampleRemaining+1
 10597 0af2 6091 0000 		lds r22,sdCardSampleRemaining+2
 10598 0af6 7091 0000 		lds r23,sdCardSampleRemaining+3
 10599 0afa 821B      		sub r24,r18
 10600 0afc 930B      		sbc r25,r19
 10601 0afe A0E0      		ldi r26,0
 10602 0b00 B0E0      		ldi r27,0
 10603 0b02 8417      		cp r24,r20
 10604 0b04 9507      		cpc r25,r21
 10605 0b06 A607      		cpc r26,r22
 10606 0b08 B707      		cpc r27,r23
 10607 0b0a 00F0      		brlo .L756
 10608               	.L755:
2803:WTPA.c        **** 				SREG=sreg;				// ISR back on.
 10609               		.loc 1 2803 0
 10610 0b0c EFBF      		out __SREG__,r30
2804:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
 10611               		.loc 1 2804 0
 10612 0b0e 2091 0000 		lds r18,sdCurrentBlockOffset
 10613 0b12 3091 0000 		lds r19,sdCurrentBlockOffset+1
 10614 0b16 2F5F      		subi r18,-1
 10615 0b18 3F4F      		sbci r19,-1
 10616 0b1a 3093 0000 		sts sdCurrentBlockOffset+1,r19
 10617 0b1e 2093 0000 		sts sdCurrentBlockOffset,r18
2806:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
 10618               		.loc 1 2806 0
 10619 0b22 6091 0000 		lds r22,sdSampleStartBlock
 10620 0b26 7091 0000 		lds r23,sdSampleStartBlock+1
 10621 0b2a 8091 0000 		lds r24,sdSampleStartBlock+2
 10622 0b2e 9091 0000 		lds r25,sdSampleStartBlock+3
 10623 0b32 620F      		add r22,r18
 10624 0b34 731F      		adc r23,r19
 10625 0b36 811D      		adc r24,__zero_reg__
 10626 0b38 911D      		adc r25,__zero_reg__
 10627 0b3a 0E94 0000 		call SdBeginSingleBlockRead
 10628               	.LVL487:
 10629 0b3e 8130      		cpi r24,lo8(1)
 10630 0b40 01F0      		breq .+2
 10631 0b42 00C0      		rjmp .L761
2808:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 10632               		.loc 1 2808 0
 10633 0b44 6AE7      		ldi r22,lo8(122)
 10634 0b46 70E0      		ldi r23,0
 10635 0b48 83E0      		ldi r24,lo8(3)
 10636 0b4a 0E94 0000 		call SetTimer
 10637               	.LVL488:
2809:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
 10638               		.loc 1 2809 0
 10639 0b4e 3092 0000 		sts cardState,r3
 10640 0b52 00C0      		rjmp .L674
 10641               	.LVL489:
 10642               	.L756:
2818:WTPA.c        **** 				SREG=sreg;	// ISR back on.
 10643               		.loc 1 2818 0
 10644 0b54 EFBF      		out __SREG__,r30
 10645 0b56 00C0      		rjmp .L674
 10646               	.LVL490:
 10647               	.L687:
2824:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 10648               		.loc 1 2824 0
 10649 0b58 83E0      		ldi r24,lo8(3)
 10650 0b5a 0E94 0000 		call CheckTimer
 10651               	.LVL491:
 10652 0b5e 8111      		cpse r24,__zero_reg__
 10653 0b60 00C0      		rjmp .L761
 10654 0b62 14E0      		ldi r17,lo8(4)
 10655               	.L760:
2829:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 10656               		.loc 1 2829 0
 10657 0b64 8FEF      		ldi r24,lo8(-1)
 10658 0b66 0E94 0000 		call TransferSdByte
 10659               	.LVL492:
2830:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 10660               		.loc 1 2830 0
 10661 0b6a 8F3F      		cpi r24,lo8(-1)
 10662 0b6c 01F4      		brne .L759
 10663               	.LVL493:
 10664 0b6e 1150      		subi r17,lo8(-(-1))
2827:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
 10665               		.loc 1 2827 0
 10666 0b70 01F4      		brne .L760
 10667 0b72 00C0      		rjmp .L674
 10668               	.LVL494:
 10669               	.L759:
2839:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 10670               		.loc 1 2839 0
 10671 0b74 8E3F      		cpi r24,lo8(-2)
 10672 0b76 01F0      		breq .+2
 10673 0b78 00C0      		rjmp .L761
2841:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
 10674               		.loc 1 2841 0
 10675 0b7a D093 0000 		sts bytesLeftInBlock.2003+1,r29
 10676 0b7e C093 0000 		sts bytesLeftInBlock.2003,r28
 10677               	.LVL495:
 10678               	.L861:
2843:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 10679               		.loc 1 2843 0
 10680 0b82 A092 0000 		sts cardState,r10
2844:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
 10681               		.loc 1 2844 0
 10682 0b86 8091 0000 		lds r24,sdAbortRead
 10683 0b8a 8130      		cpi r24,lo8(1)
 10684 0b8c 01F0      		breq .+2
 10685 0b8e 00C0      		rjmp .L674
 10686               	.L856:
2846:WTPA.c        **** 						cardState=SD_READ_ABORT;
 10687               		.loc 1 2846 0
 10688 0b90 B092 0000 		sts cardState,r11
2847:WTPA.c        **** 						sdAbortRead=false;
 10689               		.loc 1 2847 0
 10690 0b94 1092 0000 		sts sdAbortRead,__zero_reg__
 10691 0b98 00C0      		rjmp .L674
 10692               	.L688:
 10693 0b9a 0091 0000 		lds r16,bytesLeftInBlock.2003
 10694 0b9e 1091 0000 		lds r17,bytesLeftInBlock.2003+1
 10695 0ba2 0134      		cpi r16,65
 10696 0ba4 1105      		cpc r17,__zero_reg__
 10697 0ba6 00F0      		brlo .L762
 10698 0ba8 00E4      		ldi r16,lo8(64)
 10699 0baa 10E0      		ldi r17,0
 10700               	.L762:
 10701               	.LVL496:
2871:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 10702               		.loc 1 2871 0
 10703 0bac 612C      		mov r6,__zero_reg__
 10704 0bae 00C0      		rjmp .L763
 10705               	.LVL497:
 10706               	.L764:
2873:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
 10707               		.loc 1 2873 0
 10708 0bb0 8FEF      		ldi r24,lo8(-1)
 10709 0bb2 0E94 0000 		call TransferSdByte
 10710               	.LVL498:
2874:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
 10711               		.loc 1 2874 0
 10712 0bb6 8091 0000 		lds r24,bytesLeftInBlock.2003
 10713 0bba 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10714 0bbe 0197      		sbiw r24,1
 10715 0bc0 9093 0000 		sts bytesLeftInBlock.2003+1,r25
 10716 0bc4 8093 0000 		sts bytesLeftInBlock.2003,r24
2871:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 10717               		.loc 1 2871 0
 10718 0bc8 6394      		inc r6
 10719               	.LVL499:
 10720               	.L763:
 10721 0bca 862D      		mov r24,r6
 10722 0bcc 90E0      		ldi r25,0
 10723 0bce 8017      		cp r24,r16
 10724 0bd0 9107      		cpc r25,r17
 10725 0bd2 00F0      		brlo .L764
2878:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
 10726               		.loc 1 2878 0
 10727 0bd4 8091 0000 		lds r24,bytesLeftInBlock.2003
 10728 0bd8 9091 0000 		lds r25,bytesLeftInBlock.2003+1
 10729 0bdc 892B      		or r24,r25
 10730 0bde 01F4      		brne .L674
2880:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10731               		.loc 1 2880 0
 10732 0be0 8FEF      		ldi r24,lo8(-1)
 10733 0be2 0E94 0000 		call TransferSdByte
 10734               	.LVL500:
2881:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 10735               		.loc 1 2881 0
 10736 0be6 8FEF      		ldi r24,lo8(-1)
 10737 0be8 0E94 0000 		call TransferSdByte
 10738               	.LVL501:
 10739               	.L765:
2882:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10740               		.loc 1 2882 0
 10741 0bec 8091 C800 		lds r24,200
 10742 0bf0 86FF      		sbrs r24,6
 10743 0bf2 00C0      		rjmp .L765
2885:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
 10744               		.loc 1 2885 0
 10745 0bf4 0E94 0000 		call EndSdTransfer
 10746               	.LVL502:
2886:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
 10747               		.loc 1 2886 0
 10748 0bf8 8FEF      		ldi r24,lo8(-1)
 10749 0bfa 0E94 0000 		call TransferSdByte
 10750               	.LVL503:
 10751               	.L766:
2888:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 10752               		.loc 1 2888 0
 10753 0bfe 8091 C800 		lds r24,200
 10754 0c02 86FF      		sbrs r24,6
 10755 0c04 00C0      		rjmp .L766
2890:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
 10756               		.loc 1 2890 0
 10757 0c06 D092 0000 		sts cardState,r13
2892:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
 10758               		.loc 1 2892 0
 10759 0c0a 8091 0000 		lds r24,sdPlaybackQueued
 10760 0c0e 8130      		cpi r24,lo8(1)
 10761 0c10 01F4      		brne .L674
2894:WTPA.c        **** 					sdPlaybackQueued=false;
 10762               		.loc 1 2894 0
 10763 0c12 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2896:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
 10764               		.loc 1 2896 0
 10765 0c16 8091 0000 		lds r24,sdQueuedSlot
 10766 0c1a 9091 0000 		lds r25,sdQueuedSlot+1
 10767 0c1e 0E94 0000 		call PlaySampleFromSd
 10768               	.LVL504:
 10769               	.L674:
 10770               	.LBE347:
 10771               	.LBE353:
4803:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
 10772               		.loc 1 4803 0
 10773 0c22 0E94 0000 		call GetRandomLongInt
 10774               	.LVL505:
4808:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
 10775               		.loc 1 4808 0
 10776 0c26 0E94 0000 		call Uart0GotByte
 10777               	.LVL506:
 10778 0c2a 8823      		tst r24
 10779 0c2c 01F0      		breq .L767
4810:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
 10780               		.loc 1 4810 0
 10781 0c2e 0E94 0000 		call Uart0GetByte
 10782               	.LVL507:
 10783 0c32 0E94 0000 		call HandleIncomingMidiByte
 10784               	.LVL508:
 10785               	.L767:
4813:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
 10786               		.loc 1 4813 0
 10787 0c36 0E94 0000 		call MidiTxBufferNotEmpty
 10788               	.LVL509:
 10789 0c3a 8823      		tst r24
 10790 0c3c 01F0      		breq .L768
4815:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
 10791               		.loc 1 4815 0
 10792 0c3e 8091 C000 		lds r24,192
 10793 0c42 85FF      		sbrs r24,5
 10794 0c44 00C0      		rjmp .L768
4817:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
 10795               		.loc 1 4817 0
 10796 0c46 0E94 0000 		call PopOutgoingMidiByte
 10797               	.LVL510:
 10798 0c4a 8093 C600 		sts 198,r24
 10799               	.L768:
4821:WTPA.c        **** 		State();				// Execute the current program state.
 10800               		.loc 1 4821 0
 10801 0c4e E091 0000 		lds r30,State
 10802 0c52 F091 0000 		lds r31,State+1
 10803 0c56 0995      		icall
 10804               	.LVL511:
4822:WTPA.c        **** 	}
 10805               		.loc 1 4822 0
 10806 0c58 00C0      		rjmp .L769
 10807               	.LVL512:
 10808               	.L853:
 10809               	.LBB354:
 10810               	.LBB348:
 10811               	.LBB345:
 10812               	.LBB346:
2117:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 10813               		.loc 1 2117 0
 10814 0c5a B701      		movw r22,r14
 10815 0c5c 00C0      		rjmp 2f
 10816               		1:
 10817 0c5e 660F      		lsl r22
 10818 0c60 771F      		rol r23
 10819               		2:
 10820 0c62 2A95      		dec r18
 10821 0c64 02F4      		brpl 1b
 10822 0c66 9B01      		movw r18,r22
 10823               	.LVL513:
 10824 0c68 242B      		or r18,r20
 10825 0c6a 2083      		st Z,r18
 10826               	.LBE346:
 10827               	.LBE345:
2533:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
 10828               		.loc 1 2533 0
 10829 0c6c 86E0      		ldi r24,lo8(6)
 10830 0c6e 00C0      		rjmp .L857
 10831               	.LVL514:
 10832               	.L727:
2537:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
 10833               		.loc 1 2537 0
 10834 0c70 D092 0000 		sts cardState,r13
 10835 0c74 00C0      		rjmp .L674
 10836               	.LVL515:
 10837               	.L723:
2519:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10838               		.loc 1 2519 0
 10839 0c76 0E94 0000 		call EndSdTransfer
 10840               	.LVL516:
2520:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10841               		.loc 1 2520 0
 10842 0c7a 8FEF      		ldi r24,lo8(-1)
 10843 0c7c 0E94 0000 		call TransferSdByte
 10844               	.LVL517:
 10845 0c80 00C0      		rjmp .L725
 10846               	.LVL518:
 10847               	.L740:
2669:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 10848               		.loc 1 2669 0
 10849 0c82 0E94 0000 		call EndSdTransfer
 10850               	.LVL519:
2670:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 10851               		.loc 1 2670 0
 10852 0c86 8FEF      		ldi r24,lo8(-1)
 10853 0c88 0E94 0000 		call TransferSdByte
 10854               	.LVL520:
 10855 0c8c 00C0      		rjmp .L742
 10856               	.L761:
2852:WTPA.c        **** 					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
 10857               		.loc 1 2852 0
 10858 0c8e 1092 0000 		sts cardState,__zero_reg__
 10859 0c92 00C0      		rjmp .L674
 10860               	.LBE348:
 10861               	.LBE354:
 10862               		.cfi_endproc
 10863               	.LFE72:
 10865               		.comm	UpdateOutput,2,1
 10866               		.local	sdCardSampleRemaining
 10867               		.comm	sdCardSampleRemaining,4,1
 10868               		.local	sdRamSampleRemaining
 10869               		.comm	sdRamSampleRemaining,4,1
 10870               		.local	sdBytesInFifo
 10871               		.comm	sdBytesInFifo,2,1
 10872               		.local	sdFifoWritePointer
 10873               		.comm	sdFifoWritePointer,2,1
 10874               		.local	sdFifoReadPointer
 10875               		.comm	sdFifoReadPointer,2,1
 10876               		.local	sdFifo
 10877               		.comm	sdFifo,768,1
 10878               		.local	adcByte
 10879               		.comm	adcByte,1,1
 10880               		.local	sliceRemaining
 10881               		.comm	sliceRemaining,8,1
 10882               		.local	sliceSize
 10883               		.comm	sliceSize,8,1
 10884               		.local	granularPositionArrayPointer
 10885               		.comm	granularPositionArrayPointer,2,1
 10886               		.local	outOfRam
 10887               		.comm	outOfRam,1,1
 10888               		.comm	State,2,1
 10889               		.local	ledPwm
 10890               		.comm	ledPwm,1,1
 10891               		.local	flipFlop.1807
 10892               		.comm	flipFlop.1807,1,1
 10893               		.local	extIsrOutputBank0
 10894               		.comm	extIsrOutputBank0,1,1
 10895               		.local	sawtooth.1751
 10896               		.comm	sawtooth.1751,1,1
 10897               		.local	granularPositionArray
 10898               		.comm	granularPositionArray,256,1
 10899               		.local	flipFlop.1813
 10900               		.comm	flipFlop.1813,1,1
 10901               		.local	extIsrOutputBank1
 10902               		.comm	extIsrOutputBank1,1,1
 10903               		.local	sawtooth.1763
 10904               		.comm	sawtooth.1763,1,1
 10905               		.local	flipFlop.1821
 10906               		.comm	flipFlop.1821,1,1
 10907               		.local	midiOutputBank0
 10908               		.comm	midiOutputBank0,1,1
 10909               		.data
 10912               	random31:
 10913 0000 EF        		.byte	-17
 10914 0001 BE        		.byte	-66
 10915 0002 00        		.byte	0
 10916 0003 00        		.byte	0
 10917               		.local	lastJitterValue.1820
 10918               		.comm	lastJitterValue.1820,2,1
 10919               		.local	flipFlop.1829
 10920               		.comm	flipFlop.1829,1,1
 10921               		.local	midiOutputBank1
 10922               		.comm	midiOutputBank1,1,1
 10923               		.local	lastJitterValue.1828
 10924               		.comm	lastJitterValue.1828,2,1
 10925               		.local	sdIsrState
 10926               		.comm	sdIsrState,1,1
 10927               		.local	sdRamAddress
 10928               		.comm	sdRamAddress,4,1
 10929               		.local	sdBank0
 10930               		.comm	sdBank0,1,1
 10931               		.local	sdStreamOutput
 10932               		.comm	sdStreamOutput,1,1
 10933               		.local	pwmCount.1841
 10934               		.comm	pwmCount.1841,1,1
 10935               		.local	newKeys
 10936               		.comm	newKeys,1,1
 10937               		.local	keyState
 10938               		.comm	keyState,1,1
 10939               		.local	cardState
 10940               		.comm	cardState,1,1
 10941               		.local	cardDetect
 10942               		.comm	cardDetect,1,1
 10943               		.local	subState
 10944               		.comm	subState,1,1
 10945               		.local	i.2252
 10946               		.comm	i.2252,1,1
 10947               		.local	ledOnOffMask
 10948               		.comm	ledOnOffMask,1,1
 10949               		.local	realtimeOn.2207
 10950               		.comm	realtimeOn.2207,2,1
 10951               		.local	theMidiRecordRate
 10952               		.comm	theMidiRecordRate,4,1
 10953               		.local	currentBank
 10954               		.comm	currentBank,1,1
 10955               		.local	currentMidiMessage.2205
 10956               		.comm	currentMidiMessage.2205,4,1
 10959               	currentNoteOn.2206:
 10960 0004 3C        		.byte	60
 10961 0005 3C        		.byte	60
 10962               		.local	lastDacByte
 10963               		.comm	lastDacByte,1,1
 10964               		.section	.rodata
 10967               	OctaveZeroCompareMatches:
 10968 0000 FFFF      		.word	-1
 10969 0002 A1F1      		.word	-3679
 10970 0004 11E4      		.word	-7151
 10971 0006 44D7      		.word	-10428
 10972 0008 2FCB      		.word	-13521
 10973 000a C8BF      		.word	-16440
 10974 000c 04B5      		.word	-19196
 10975 000e DBAA      		.word	-21797
 10976 0010 44A1      		.word	-24252
 10977 0012 3798      		.word	-26569
 10978 0014 AC8F      		.word	-28756
 10979 0016 9C87      		.word	-30820
 10980               		.local	keysHeld
 10981               		.comm	keysHeld,1,1
 10982               		.local	encoderValue
 10983               		.comm	encoderValue,1,1
 10984               		.local	lastEncoderValue.2194
 10985               		.comm	lastEncoderValue.2194,1,1
 10986               		.local	scaledEncoderValue
 10987               		.comm	scaledEncoderValue,1,1
 10988               		.local	sdCurrentSlot
 10989               		.comm	sdCurrentSlot,2,1
 10990               		.local	sdSampleStartBlock
 10991               		.comm	sdSampleStartBlock,4,1
 10992               		.local	sdCurrentBlockOffset
 10993               		.comm	sdCurrentBlockOffset,2,1
 10994               		.local	sdAbortRead
 10995               		.comm	sdAbortRead,1,1
 10996               		.local	sdQueuedSlot
 10997               		.comm	sdQueuedSlot,2,1
 10998               		.local	sdPlaybackQueued
 10999               		.comm	sdPlaybackQueued,1,1
 11000               		.local	ledBlinkMask
 11001               		.comm	ledBlinkMask,1,1
 11002               		.local	lastShuttleRead.2242
 11003               		.comm	lastShuttleRead.2242,1,1
 11004               		.local	encoderState
 11005               		.comm	encoderState,1,1
 11006               		.local	lastKeyState.1891
 11007               		.comm	lastKeyState.1891,1,1
 11008               		.local	lastEncTime.1900
 11009               		.comm	lastEncTime.1900,2,1
 11010               		.local	lastEncoderState.1899
 11011               		.comm	lastEncoderState.1899,1,1
 11012               		.local	toggle.1877
 11013               		.comm	toggle.1877,1,1
 11014               		.local	lastLedMask.1878
 11015               		.comm	lastLedMask.1878,1,1
 11016               		.local	bytesLeftInBlock.2003
 11017               		.comm	bytesLeftInBlock.2003,2,1
 11018               		.local	sampleToc
 11019               		.comm	sampleToc,64,1
 11020               		.text
 11021               	.Letext0:
 11022               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 11023               		.file 3 "defines.h"
 11024               		.file 4 "globals.h"
 11025               		.file 5 "midi.h"
 11026               		.file 6 "softclock.h"
 11027               		.file 7 "microSD.h"
 11028               		.file 8 "eeprom.h"
 11029               		.file 9 "uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 WTPA.c
     /tmp/cckkF7hn.s:2      *ABS*:0000003e __SP_H__
     /tmp/cckkF7hn.s:3      *ABS*:0000003d __SP_L__
     /tmp/cckkF7hn.s:4      *ABS*:0000003f __SREG__
     /tmp/cckkF7hn.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cckkF7hn.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cckkF7hn.s:11     .text:00000000 UpdateAudioChannel0
     /tmp/cckkF7hn.s:10894  .bss:00000325 sawtooth.1751
     /tmp/cckkF7hn.s:10877  .bss:0000030e adcByte
     /tmp/cckkF7hn.s:10885  .bss:00000321 outOfRam
     /tmp/cckkF7hn.s:10879  .bss:0000030f sliceRemaining
     /tmp/cckkF7hn.s:10881  .bss:00000317 sliceSize
     /tmp/cckkF7hn.s:10883  .bss:0000031f granularPositionArrayPointer
     /tmp/cckkF7hn.s:10896  .bss:00000326 granularPositionArray
     /tmp/cckkF7hn.s:821    .text:0000075c UpdateAudioChannel1
     /tmp/cckkF7hn.s:10902  .bss:00000428 sawtooth.1763
     /tmp/cckkF7hn.s:1657   .text:00000ee0 OutputMultiplyBanks
     /tmp/cckkF7hn.s:10892  .bss:00000324 extIsrOutputBank0
     /tmp/cckkF7hn.s:10906  .bss:0000042a midiOutputBank0
     /tmp/cckkF7hn.s:10900  .bss:00000427 extIsrOutputBank1
     /tmp/cckkF7hn.s:10920  .bss:0000042e midiOutputBank1
     /tmp/cckkF7hn.s:10956  .bss:0000044b lastDacByte
     /tmp/cckkF7hn.s:1761   .text:00000f78 OutputAddBanks
     /tmp/cckkF7hn.s:10930  .bss:00000437 sdStreamOutput
     /tmp/cckkF7hn.s:1834   .text:00000fe4 OutputXorBanks
     /tmp/cckkF7hn.s:1920   .text:0000105e OutputAndBanks
     /tmp/cckkF7hn.s:2006   .text:000010d8 WriteLedLatch
     /tmp/cckkF7hn.s:2041   .text:000010ea SdIsrStartStreamingAudio
     /tmp/cckkF7hn.s:10924  .bss:00000431 sdIsrState
     /tmp/cckkF7hn.s:2085   .text:00001116 GetRandomLongInt
     /tmp/cckkF7hn.s:10912  .data:00000000 random31
     /tmp/cckkF7hn.s:2133   .text:00001168 MakeNewGranularArray
     /tmp/cckkF7hn.s:2470   .text:00001362 UpdateAdjustedSampleAddresses
     /tmp/cckkF7hn.s:3303   .text:00001b6a RevertSampleToUnadjusted
     /tmp/cckkF7hn.s:3358   .text:00001ba4 BlinkLeds
     /tmp/cckkF7hn.s:10999  .bss:0000045c ledBlinkMask
     /tmp/cckkF7hn.s:10946  .bss:0000043f ledOnOffMask
     /tmp/cckkF7hn.s:3424   .text:00001bf8 KillLeds
     /tmp/cckkF7hn.s:3443   .text:00001c04 DoFruitcakeIntro
     /tmp/cckkF7hn.s:10942  .bss:0000043d subState
     /tmp/cckkF7hn.s:10944  .bss:0000043e i.2252
     /tmp/cckkF7hn.s:10887  .bss:00000322 ledPwm
     /tmp/cckkF7hn.s:4510   .text:00002158 DoStartupSelect
                            *COM*:00000002 State
     /tmp/cckkF7hn.s:3669   .text:00001d5c SdStartSampleRead
     /tmp/cckkF7hn.s:10989  .bss:00000452 sdSampleStartBlock
     /tmp/cckkF7hn.s:10991  .bss:00000456 sdCurrentBlockOffset
     /tmp/cckkF7hn.s:10873  .bss:0000000c sdFifoReadPointer
     /tmp/cckkF7hn.s:10871  .bss:0000000a sdFifoWritePointer
     /tmp/cckkF7hn.s:10869  .bss:00000008 sdBytesInFifo
     /tmp/cckkF7hn.s:10938  .bss:0000043b cardState
     /tmp/cckkF7hn.s:3775   .text:00001de0 SetSampleClock.part.0
     /tmp/cckkF7hn.s:3802   .text:00001df8 SetSampleClock
     /tmp/cckkF7hn.s:3889   .text:00001e74 StartPlayback
     /tmp/cckkF7hn.s:4017   .text:00001f0a ContinuePlayback
     /tmp/cckkF7hn.s:4096   .text:00001f5a StartRecording
     /tmp/cckkF7hn.s:4242   .text:00002016 StartOverdub
     /tmp/cckkF7hn.s:4337   .text:00002082 StartRealtime
     /tmp/cckkF7hn.s:4399   .text:000020be DoFormatCard
     /tmp/cckkF7hn.s:10936  .bss:0000043a keyState
     /tmp/cckkF7hn.s:10934  .bss:00000439 newKeys
     /tmp/cckkF7hn.s:4700   .text:00002228 DoSawtooth
     /tmp/cckkF7hn.s:4891   .text:00002332 SetMidiChannels
     /tmp/cckkF7hn.s:5057   .text:000023fe DoSampler
     /tmp/cckkF7hn.s:4589   .text:000021a4 PlaySampleFromSd
     /tmp/cckkF7hn.s:10867  .bss:00000004 sdRamSampleRemaining
     /tmp/cckkF7hn.s:10993  .bss:00000458 sdAbortRead
     /tmp/cckkF7hn.s:10995  .bss:00000459 sdQueuedSlot
     /tmp/cckkF7hn.s:10997  .bss:0000045b sdPlaybackQueued
                            *COM*:00000002 UpdateOutput
     /tmp/cckkF7hn.s:10981  .bss:0000044d encoderValue
     /tmp/cckkF7hn.s:11001  .bss:0000045d lastShuttleRead.2242
     /tmp/cckkF7hn.s:10948  .bss:00000440 realtimeOn.2207
     /tmp/cckkF7hn.s:10950  .bss:00000442 theMidiRecordRate
     /tmp/cckkF7hn.s:10967  .rodata:00000000 OctaveZeroCompareMatches
     /tmp/cckkF7hn.s:10952  .bss:00000446 currentBank
     /tmp/cckkF7hn.s:10963  .bss:0000044c keysHeld
     /tmp/cckkF7hn.s:10987  .bss:00000450 sdCurrentSlot
                             .bss:00000000 sdCardSampleRemaining
     /tmp/cckkF7hn.s:10928  .bss:00000436 sdBank0
     /tmp/cckkF7hn.s:10926  .bss:00000432 sdRamAddress
     /tmp/cckkF7hn.s:10983  .bss:0000044e lastEncoderValue.2194
     /tmp/cckkF7hn.s:10985  .bss:0000044f scaledEncoderValue
     /tmp/cckkF7hn.s:10954  .bss:00000447 currentMidiMessage.2205
     /tmp/cckkF7hn.s:10959  .data:00000004 currentNoteOn.2206
     /tmp/cckkF7hn.s:7628   .text:0000331c __vector_12
     /tmp/cckkF7hn.s:10890  .bss:00000323 flipFlop.1807
     /tmp/cckkF7hn.s:7756   .text:000033aa __vector_6
     /tmp/cckkF7hn.s:10898  .bss:00000426 flipFlop.1813
     /tmp/cckkF7hn.s:7886   .text:0000343a __vector_13
     /tmp/cckkF7hn.s:10904  .bss:00000429 flipFlop.1821
     /tmp/cckkF7hn.s:10908  .bss:0000042b lastJitterValue.1820
     /tmp/cckkF7hn.s:8092   .text:00003564 __vector_14
     /tmp/cckkF7hn.s:10918  .bss:0000042d flipFlop.1829
     /tmp/cckkF7hn.s:10922  .bss:0000042f lastJitterValue.1828
     /tmp/cckkF7hn.s:8298   .text:0000368e __vector_10
     /tmp/cckkF7hn.s:10875  .bss:0000000e sdFifo
     /tmp/cckkF7hn.s:8789   .text:00003a50 __vector_9
     /tmp/cckkF7hn.s:10932  .bss:00000438 pwmCount.1841
     /tmp/cckkF7hn.s:8846   .text:00003a86 __vector_default
     /tmp/cckkF7hn.s:8877   .text:00003a9a HandleSoftclock
     /tmp/cckkF7hn.s:8911   .text.startup:00000000 main
     /tmp/cckkF7hn.s:11003  .bss:0000045e encoderState
     /tmp/cckkF7hn.s:10940  .bss:0000043c cardDetect
     /tmp/cckkF7hn.s:11005  .bss:0000045f lastKeyState.1891
     /tmp/cckkF7hn.s:11007  .bss:00000460 lastEncTime.1900
     /tmp/cckkF7hn.s:11009  .bss:00000462 lastEncoderState.1899
     /tmp/cckkF7hn.s:11011  .bss:00000463 toggle.1877
     /tmp/cckkF7hn.s:11013  .bss:00000464 lastLedMask.1878
     /tmp/cckkF7hn.s:11017  .bss:00000467 sampleToc
     /tmp/cckkF7hn.s:11015  .bss:00000465 bytesLeftInBlock.2003

UNDEFINED SYMBOLS
bankStates
__muluhisi3
__udivmodsi4
SetTimer
CheckTimer
SdBeginSingleBlockRead
EepromRead
midiChannelNumberA
midiChannelNumberB
EepromWrite
__udivmodqi4
PutMidiMessageInOutgoingFifo
midiMessagesInIncomingFifo
GetMidiMessageFromIncomingFifo
__tablejump2__
__umulhisi3
systemTicks
InitSdInterface
InitMidi
InitUart0
SdHandshake
TransferSdByte
EndSdTransfer
SdBeginSingleBlockWrite
Uart0GotByte
Uart0GetByte
HandleIncomingMidiByte
MidiTxBufferNotEmpty
PopOutgoingMidiByte
__do_copy_data
__do_clear_bss
