   1               		.file	"WTPA.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	UpdateAudioChannel0:
  12               	.LFB1:
  13               		.file 1 "WTPA.c"
   1:WTPA.c        **** // Where's the Party At?
   2:WTPA.c        **** // VERSION 2 DA EMPIRE STRIKES BLACK
   3:WTPA.c        **** // ==================================
   4:WTPA.c        **** // Todd Michael Bailey
   5:WTPA.c        **** // todd@narrat1ve.com
   6:WTPA.c        **** // Tue Jul  6 19:36:23 EDT 2010
   7:WTPA.c        **** 
   8:WTPA.c        **** #include	"includes.h"
   9:WTPA.c        **** #define		CURRENT_FIRMWARE_VERSION	0x12		// Starts at 0x10 for WTPA2.  0x11, messing around from 201
  10:WTPA.c        **** 
  11:WTPA.c        **** //=============================
  12:WTPA.c        **** // HOLLER-WARE LICENSE:
  13:WTPA.c        **** // Todd Bailey wrote this.  Do whatever you want with this code, but holler at me if you like it, u
  14:WTPA.c        **** // xoxoxo
  15:WTPA.c        **** // bai1ey.tm@gmail.com
  16:WTPA.c        **** //
  17:WTPA.c        **** // Todd Bailey would like to take this opportunity to shout out to:
  18:WTPA.c        **** //
  19:WTPA.c        **** // Todd Squires, who continues to be wholly intolerant of my bad programming habits and whose TB4 O
  20:WTPA.c        **** // Andrew Reitano for the Nintendo sample playback code,
  21:WTPA.c        **** // Olivier Gillet for the code review, some great ISR speed suggestions, harping on me about remova
  22:WTPA.c        **** // Nick Read, Daniel Fishkin, and Charlie Spears for slangin solder and et cet,
  23:WTPA.c        **** // ChaN for the awesome page on SD interfacing,
  24:WTPA.c        **** // Limor Fried and Phil Torrone, for staying on my ass about making kits,
  25:WTPA.c        **** // Glitched, Dan Nigrin, Altitude, Rodrigo, Sealion, and everybody else on the Narrat1ve forum for 
  26:WTPA.c        **** // BMT Toys and everybody there for putting me through the embedded-systems wringer for all those y
  27:WTPA.c        **** // Jim Williams, Paul Horowitz, Winfield Hill, and all the other people who've forgotten more than 
  28:WTPA.c        **** // and most importantly,
  29:WTPA.c        **** // You, the Customer.
  30:WTPA.c        **** //=============================
  31:WTPA.c        **** 
  32:WTPA.c        **** //=============================
  33:WTPA.c        **** // Atmel AVR Atmega644p MCU, 5v operation.
  34:WTPA.c        **** // 20MHz Crystal Oscillator.
  35:WTPA.c        **** // Originally built with:
  36:WTPA.c        **** // AVR-Binutils 2.19,
  37:WTPA.c        **** // AVR-GCC 4.3.2,
  38:WTPA.c        **** // AVR-libc 1.6.4
  39:WTPA.c        **** //==============================
  40:WTPA.c        **** 
  41:WTPA.c        **** /*
  42:WTPA.c        **** Description:
  43:WTPA.c        **** ==============================================================================
  44:WTPA.c        **** Just rock out, you know?
  45:WTPA.c        **** The real description for lots of this sampler is in the manuals.
  46:WTPA.c        **** 
  47:WTPA.c        **** Technical descriptions of just about everything can be found by grepping through the code comments.
  48:WTPA.c        **** It might be worth your time to check out the original WTPA code as well as the WTPA2 code.
  49:WTPA.c        **** 
  50:WTPA.c        **** 
  51:WTPA.c        **** Changelog:
  52:WTPA.c        **** ==============================================================================
  53:WTPA.c        **** ==============================================================================
  54:WTPA.c        **** Made a CHANGELOG file in this directory.  Only valid for WTPA2 changes once releases start.  You'll
  55:WTPA.c        **** 
  56:WTPA.c        **** */
  57:WTPA.c        **** 
  58:WTPA.c        **** // I hate Prototypes:
  59:WTPA.c        **** static void DoFruitcakeIntro(void);
  60:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  61:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate);
  62:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot);
  63:WTPA.c        **** static void InitSdIsr(void);
  64:WTPA.c        **** static void DoSampler(void);
  65:WTPA.c        **** 
  66:WTPA.c        **** //-----------------------------------------------------------------------
  67:WTPA.c        **** //-----------------------------------------------------------------------
  68:WTPA.c        **** // Lists:
  69:WTPA.c        **** //-----------------------------------------------------------------------
  70:WTPA.c        **** //-----------------------------------------------------------------------
  71:WTPA.c        **** 
  72:WTPA.c        **** // Audio ISR States -- these are the different things we can do in the audio related ISR.
  73:WTPA.c        **** //---------------------------------------------------------------------------------------
  74:WTPA.c        **** 
  75:WTPA.c        **** enum
  76:WTPA.c        **** 	{
  77:WTPA.c        **** 		AUDIO_IDLE=0,
  78:WTPA.c        **** 		AUDIO_SAWTOOTH,
  79:WTPA.c        **** 		AUDIO_REALTIME,
  80:WTPA.c        **** 		AUDIO_RECORD,
  81:WTPA.c        **** 		AUDIO_PLAYBACK,
  82:WTPA.c        **** 		AUDIO_OVERDUB,
  83:WTPA.c        **** 		NUM_AUDIO_FUNCTIONS,
  84:WTPA.c        **** 	};
  85:WTPA.c        **** 
  86:WTPA.c        **** 
  87:WTPA.c        **** // LEDs.
  88:WTPA.c        **** //-----------------------------------------------------------------------
  89:WTPA.c        **** enum					// LED enum used for keeping track of our LED masks.
  90:WTPA.c        **** 	{
  91:WTPA.c        **** 		LED_0=0,
  92:WTPA.c        **** 		LED_1,
  93:WTPA.c        **** 		LED_2,
  94:WTPA.c        **** 		LED_3,
  95:WTPA.c        **** 		LED_4,
  96:WTPA.c        **** 		LED_5,
  97:WTPA.c        **** 		LED_6,
  98:WTPA.c        **** 		LED_7,
  99:WTPA.c        **** 		NUM_LEDS,
 100:WTPA.c        **** 	};
 101:WTPA.c        **** 
 102:WTPA.c        **** // WTPA has gotten to the point where each LED pretty much corresponds to an indicator of something
 103:WTPA.c        **** // To reflect this, the masks here arrange LEDs by FUNCTION, to make code easier to read.
 104:WTPA.c        **** 
 105:WTPA.c        **** #define	Om_LED_REC			(1<<LED_0)
 106:WTPA.c        **** #define	Om_LED_ODUB			(1<<LED_1)
 107:WTPA.c        **** #define	Om_LED_PLAY			(1<<LED_2)
 108:WTPA.c        **** #define	Om_LED_OUT_OF_MEM	(1<<LED_3)	// @@@ lose this guy.
 109:WTPA.c        **** #define	Om_LED_BANK			(1<<LED_4)
 110:WTPA.c        **** #define	Om_LED_FX2			(1<<LED_5)
 111:WTPA.c        **** #define	Om_LED_FX1			(1<<LED_6)
 112:WTPA.c        **** #define	Om_LED_FX0			(1<<LED_7)
 113:WTPA.c        **** 
 114:WTPA.c        **** static unsigned char
 115:WTPA.c        **** 	ledOnOffMask,		// What leds are on and off now?
 116:WTPA.c        **** 	ledBlinkMask;		// What leds are blinking right now?
 117:WTPA.c        **** 
 118:WTPA.c        **** static volatile unsigned char
 119:WTPA.c        **** 	ledPwm;				// Used for our benighted intro.
 120:WTPA.c        **** 
 121:WTPA.c        **** //-----------------------------------------------------------------------
 122:WTPA.c        **** //-----------------------------------------------------------------------
 123:WTPA.c        **** // Application Globals:
 124:WTPA.c        **** //-----------------------------------------------------------------------
 125:WTPA.c        **** //-----------------------------------------------------------------------
 126:WTPA.c        **** 
 127:WTPA.c        **** // Keys and switch variables
 128:WTPA.c        **** //-----------------------------------------------------------------------
 129:WTPA.c        **** static unsigned char
 130:WTPA.c        **** 	keyState,
 131:WTPA.c        **** 	newKeys,
 132:WTPA.c        **** 	keysHeld;
 133:WTPA.c        **** 
 134:WTPA.c        **** static bool
 135:WTPA.c        **** 	cardDetect;		// Is SD card physically in the slot?
 136:WTPA.c        **** 
 137:WTPA.c        **** // Application flags and housekeeping.
 138:WTPA.c        **** //-----------------------------------------------------------------------
 139:WTPA.c        **** STATE_FUNC				//  Creates a pointer called State to an instance of STATE_FUNC().
 140:WTPA.c        **** 	*State;
 141:WTPA.c        **** static unsigned char
 142:WTPA.c        **** 	subState;			//  Keeps track of the minor states (sub states) the device can be in.
 143:WTPA.c        **** 
 144:WTPA.c        **** static volatile bool
 145:WTPA.c        **** 	outOfRam;				// Goes true in the ISR if we run out of RAM.
 146:WTPA.c        **** 
 147:WTPA.c        **** static bool
 148:WTPA.c        **** 	newEncoder,				// Has the encoder moved this loop?
 149:WTPA.c        **** 	encoderCw,				// Goes true for one loop if the encoder has turned clockwise or counterclockwise.  
 150:WTPA.c        **** 	encoderCcw;
 151:WTPA.c        **** 
 152:WTPA.c        **** static unsigned char
 153:WTPA.c        **** 	encoderState,			// What the encoder switches look like.
 154:WTPA.c        **** 	encoderValue,			// Incremental ticks on the encoder.
 155:WTPA.c        **** 	scaledEncoderValue;		// The number that we display on the LEDs and use to select different effects
 156:WTPA.c        **** 
 157:WTPA.c        **** // Granular stuff
 158:WTPA.c        **** //-----------------------------------------------------------------------
 159:WTPA.c        **** 
 160:WTPA.c        **** #define	JITTER_VALUE_MAX	127
 161:WTPA.c        **** #define MAX_SLICES			128
 162:WTPA.c        **** 
 163:WTPA.c        **** static unsigned long
 164:WTPA.c        **** //	random31 __attribute__((section(".noinit")));	//32 bit random number, seeded from noinit sram (s
 165:WTPA.c        **** 	random31=0xBEEF;								// No chance to come up zero because we threw out init code.
 166:WTPA.c        **** 
 167:WTPA.c        **** static volatile unsigned char
 168:WTPA.c        **** 	granularPositionArrayPointer[NUM_BANKS];	// Where are we in the array right now?
 169:WTPA.c        **** 
 170:WTPA.c        **** static volatile unsigned long
 171:WTPA.c        **** 	sliceSize[NUM_BANKS],						// How big are our slices of memory?
 172:WTPA.c        **** 	sliceRemaining[NUM_BANKS];					// How far are we into our slice of memory?
 173:WTPA.c        **** 
 174:WTPA.c        **** static unsigned char
 175:WTPA.c        **** 	granularPositionArray[NUM_BANKS][MAX_SLICES];
 176:WTPA.c        **** 
 177:WTPA.c        **** enum	// Flags we use to determine what to set our clock source to when setting up an audio interrup
 178:WTPA.c        **** {
 179:WTPA.c        **** 	CLK_NONE=0,
 180:WTPA.c        **** 	CLK_EXTERNAL,
 181:WTPA.c        **** 	CLK_INTERNAL,
 182:WTPA.c        **** };
 183:WTPA.c        **** 
 184:WTPA.c        **** 
 185:WTPA.c        **** // ADC globals:
 186:WTPA.c        **** //-----------------------------------------------------------------------
 187:WTPA.c        **** static volatile signed char
 188:WTPA.c        **** 	adcByte;			// The current reading from the ADC.
 189:WTPA.c        **** 
 190:WTPA.c        **** // SD Card Globals:
 191:WTPA.c        **** //-----------------------------------------------------------------------
 192:WTPA.c        **** 
 193:WTPA.c        **** #define SD_WARMUP_TIME							(SECOND)		// SPEC is 250mS but why not be safe.
 194:WTPA.c        **** #define	SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER		(64)			// We leave our SD card open while reading bloc
 195:WTPA.c        **** #define	SD_FIFO_SIZE							(SD_BLOCK_LENGTH+(SD_BLOCK_LENGTH/2))	// AVR's RAM fifo for reads and wr
 196:WTPA.c        **** 
 197:WTPA.c        **** static unsigned char
 198:WTPA.c        **** 	cardState;					// Keeps track of what's going on with the SD Card -- reading, writing, not present
 199:WTPA.c        **** static unsigned char
 200:WTPA.c        **** 	sampleToc[64];				// Local RAM copy of the card's table of contents (where the samples are stored)
 201:WTPA.c        **** static volatile signed char
 202:WTPA.c        **** 	sdFifo[SD_FIFO_SIZE];		// Rolling buffer for getting bytes in and out of the SD card with the stat
 203:WTPA.c        **** 
 204:WTPA.c        **** static volatile unsigned int		// FIFO pointers for the SD card read/write buffer.
 205:WTPA.c        **** 	sdFifoReadPointer,
 206:WTPA.c        **** 	sdFifoWritePointer,
 207:WTPA.c        **** 	sdBytesInFifo;
 208:WTPA.c        **** 
 209:WTPA.c        **** // The below are variables used by the SD state machine and functions:
 210:WTPA.c        **** //static unsigned char
 211:WTPA.c        **** //	sdQueuedBank;		// Bank to play pending stream from SD card on
 212:WTPA.c        **** static unsigned int
 213:WTPA.c        **** 	sdQueuedSlot;		// Pending sample to play once the current stream is closed
 214:WTPA.c        **** static bool
 215:WTPA.c        **** 	sdPlaybackQueued,	// Is there a playback we need to immediately start once the current SD abort fi
 216:WTPA.c        **** 	sdAbortRead;		// Should the SD state machine abort a read in progress?
 217:WTPA.c        **** 
 218:WTPA.c        **** static unsigned long
 219:WTPA.c        **** 	sdSampleStartBlock;
 220:WTPA.c        **** static volatile unsigned long
 221:WTPA.c        **** 	sdRamSampleRemaining,		// Decrements as we write/read samples to/from RAM until we're done.
 222:WTPA.c        **** 	sdCardSampleRemaining;		// Decrements as we write/read samples to/from the sd card until we're don
 223:WTPA.c        **** 
 224:WTPA.c        **** static unsigned int
 225:WTPA.c        **** 	sdCurrentSlot,
 226:WTPA.c        **** 	sdCurrentBlockOffset;
 227:WTPA.c        **** 
 228:WTPA.c        **** enum					// All the things the micro sd card state machine can be doing
 229:WTPA.c        **** 	{
 230:WTPA.c        **** 		SD_NOT_PRESENT=0,
 231:WTPA.c        **** 		SD_WARMUP,
 232:WTPA.c        **** 		SD_WRITE_START,
 233:WTPA.c        **** 		SD_WRITING_BLOCK,
 234:WTPA.c        **** 		SD_WRITE_CARD_WAIT,
 235:WTPA.c        **** 		SD_WRITE_FIFO_WAIT,
 236:WTPA.c        **** 		SD_TOC_WRITE_START,
 237:WTPA.c        **** 		SD_TOC_WRITE_CONTINUE,
 238:WTPA.c        **** 		SD_TOC_WRITE_FINISH,
 239:WTPA.c        **** 		SD_READ_START,
 240:WTPA.c        **** 		SD_READING_BLOCK,
 241:WTPA.c        **** 		SD_READ_FIFO_WAIT,
 242:WTPA.c        **** 		SD_READ_TOKEN_WAIT,
 243:WTPA.c        **** 		SD_READ_ABORT,
 244:WTPA.c        **** 		SD_IDLE,
 245:WTPA.c        **** 		SD_INVALID,
 246:WTPA.c        **** 	};
 247:WTPA.c        **** 
 248:WTPA.c        **** // Variables which handle the SD card's ISR.  These generally keep track of the on-chip buffer for 
 249:WTPA.c        **** 
 250:WTPA.c        **** static unsigned char
 251:WTPA.c        **** 	sdIsrState;					// Keeps track of what the IRQ that deals with data coming off / going to the SD c
 252:WTPA.c        **** static unsigned long
 253:WTPA.c        **** 	sdRamAddress;				// Used to point to the spot in RAM where the data from the sd card is coming or 
 254:WTPA.c        **** static bool
 255:WTPA.c        **** 	sdBank0;					// Tells us whether the SD buffer is messing with the RAM in sample bank 0 or 1.
 256:WTPA.c        **** 
 257:WTPA.c        **** enum					// All the things the micro sd card's interrupt can be doing
 258:WTPA.c        **** 	{
 259:WTPA.c        **** 		SD_ISR_IDLE=0,
 260:WTPA.c        **** 		SD_ISR_LOADING_RAM,
 261:WTPA.c        **** 		SD_ISR_READING_RAM,
 262:WTPA.c        **** 		SD_ISR_STREAMING_PLAYBACK,
 263:WTPA.c        **** 	};
 264:WTPA.c        **** 
 265:WTPA.c        **** //-----------------------------------------------------------------------
 266:WTPA.c        **** 
 267:WTPA.c        **** 
 268:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 269:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 270:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 271:WTPA.c        **** // Da Code:
 272:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 273:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 274:WTPA.c        **** //-------------------------------------------------------------------------------------------------
 275:WTPA.c        **** 
 276:WTPA.c        **** /*
 277:WTPA.c        **** static void PlayCallback(BANK_STATE *theBank)
 278:WTPA.c        **** // NOTE -- callbacks for different audio functions can allow us to combine output bytes more effici
 279:WTPA.c        **** // Old functions summed 4 things -- contributions from MIDI for each bank and contributions from th
 280:WTPA.c        **** // New functions can include an "output byte" in the bank datastructure and just use that, since a 
 281:WTPA.c        **** // Call output callback from play/odub/saw BUT NOT record, too?
 282:WTPA.c        **** {
 283:WTPA.c        **** 	// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the
 284:WTPA.c        **** 	// The playback ISR also allows the various effects to change the output.
 285:WTPA.c        **** 	// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explic
 286:WTPA.c        **** 
 287:WTPA.c        **** 	// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need
 288:WTPA.c        **** 	LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 289:WTPA.c        **** 	PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 290:WTPA.c        **** 	PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 291:WTPA.c        **** 
 292:WTPA.c        **** 	LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the 
 293:WTPA.c        **** 	PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 294:WTPA.c        **** 	PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 295:WTPA.c        **** 
 296:WTPA.c        **** 	PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC
 297:WTPA.c        **** 
 298:WTPA.c        **** 	LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 299:WTPA.c        **** 	PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 300:WTPA.c        **** 
 301:WTPA.c        **** 	// Calculate new addy while data bus settles
 302:WTPA.c        **** 
 303:WTPA.c        **** 	// Handle granular 
 304:WTPA.c        **** 	
 305:WTPA.c        **** 	// Handle backwards vs forwards
 306:WTPA.c        **** 	// Finish getting the byte from RAM.
 307:WTPA.c        **** 
 308:WTPA.c        **** 	outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 309:WTPA.c        **** 	PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 310:WTPA.c        **** 	LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 311:WTPA.c        **** 
 312:WTPA.c        **** 	if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 313:WTPA.c        **** 	{
 314:WTPA.c        **** 		outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 315:WTPA.c        **** 		outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppose
 316:WTPA.c        **** 		outputByte^=0x80;											// Bring it back to signed.
 317:WTPA.c        **** 	}
 318:WTPA.c        **** }
 319:WTPA.c        **** */
 320:WTPA.c        **** 
 321:WTPA.c        **** 
 322:WTPA.c        **** //-----------------------------------------------------------------------
 323:WTPA.c        **** //-----------------------------------------------------------------------
 324:WTPA.c        **** 
 325:WTPA.c        **** // Sun Sep 19 13:38:34 EDT 2010
 326:WTPA.c        **** // Audio Channel Update Code for each bank:
 327:WTPA.c        **** 
 328:WTPA.c        **** //-----------------------------------------------------------------------
 329:WTPA.c        **** //-----------------------------------------------------------------------
 330:WTPA.c        **** // This is where all the audio business happens in this program.
 331:WTPA.c        **** // Variables messed with in the ISRs AND mainline code should be declared volatile.
 332:WTPA.c        **** // The functions declared up here should _ONLY_ ever be called from an interrupt.
 333:WTPA.c        **** 
 334:WTPA.c        **** static unsigned char UpdateAudioChannel0(void)
 335:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 336:WTPA.c        **** // These channel update routines basically handle getting data into or out of RAM based on what the
 337:WTPA.c        **** // Each channel may write something to RAM, and will pass out a byte based on what (if anything) it
 338:WTPA.c        **** {
  14               		.loc 1 338 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  20               	.LVL0:
 339:WTPA.c        **** 	signed int
 340:WTPA.c        **** 		sum;			// For doing saturated adds.
 341:WTPA.c        **** 	signed char
 342:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 343:WTPA.c        **** 	static unsigned char
 344:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 345:WTPA.c        **** 
 346:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 347:WTPA.c        **** 
 348:WTPA.c        **** 	switch(bankStates[BANK_0].audioFunction)
  21               		.loc 1 348 0
  22 0000 8091 0000 		lds r24,bankStates
  23 0004 8330      		cpi r24,lo8(3)
  24 0006 01F4      		brne .+2
  25 0008 00C0      		rjmp .L5
  26 000a 00F0      		brlo .L45
  27 000c 8430      		cpi r24,lo8(4)
  28 000e 01F4      		brne .+2
  29 0010 00C0      		rjmp .L6
  30 0012 8530      		cpi r24,lo8(5)
  31 0014 01F0      		breq .L46
  32               	.L37:
  33 0016 80E0      		ldi r24,0
  34               	.LVL1:
  35               	.L2:
 349:WTPA.c        **** 	{
 350:WTPA.c        **** 
 351:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 352:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 353:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 354:WTPA.c        **** 		break;
 355:WTPA.c        **** 
 356:WTPA.c        **** 		case AUDIO_REALTIME:
 357:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 358:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 359:WTPA.c        **** 
 360:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 361:WTPA.c        **** 		{
 362:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 363:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 364:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 365:WTPA.c        **** 		}
 366:WTPA.c        **** 		break;
 367:WTPA.c        **** 
 368:WTPA.c        **** 		case AUDIO_RECORD:
 369:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 370:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 371:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 372:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 373:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 374:WTPA.c        **** 
 375:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 376:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 377:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 378:WTPA.c        **** 
 379:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 380:WTPA.c        **** 
 381:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 382:WTPA.c        **** //		PORTC&=~0x07;											// Clear PORTC bits 0-2
 383:WTPA.c        **** //		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 384:WTPA.c        **** 
 385:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 386:WTPA.c        **** 		// Compute address while bus settles.
 387:WTPA.c        **** 
 388:WTPA.c        **** 		// 7uS with this:
 389:WTPA.c        **** //		bankStates[BANK_0].currentAddress++;										// Next address please.
 390:WTPA.c        **** //		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of t
 391:WTPA.c        **** //		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending addres
 392:WTPA.c        **** 
 393:WTPA.c        **** //		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each othe
 394:WTPA.c        **** //		{
 395:WTPA.c        **** //			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 396:WTPA.c        **** //			outOfRam=true;									// Signal mainline code that we're out of memory.
 397:WTPA.c        **** //		}
 398:WTPA.c        **** 
 399:WTPA.c        **** 		// 6.6uS with this:
 400:WTPA.c        **** 		bankStates[BANK_0].endAddress=++bankStates[BANK_0].currentAddress;			// Next address please, matc
 401:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address 
 402:WTPA.c        **** 
 403:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 404:WTPA.c        **** 		{
 405:WTPA.c        **** 			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 406:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 407:WTPA.c        **** 		}		
 408:WTPA.c        **** 
 409:WTPA.c        **** 		// Finish writing to RAM.
 410:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 411:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 412:WTPA.c        **** 		break;
 413:WTPA.c        **** 
 414:WTPA.c        **** 		case AUDIO_PLAYBACK:
 415:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 416:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 417:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 418:WTPA.c        **** 
 419:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 420:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 421:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 422:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 423:WTPA.c        **** 
 424:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 425:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 426:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 427:WTPA.c        **** 
 428:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 429:WTPA.c        **** 
 430:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 431:WTPA.c        **** //		PORTC&=~0x07;											// Clear PORTC bits 0-2
 432:WTPA.c        **** //		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 433:WTPA.c        **** 
 434:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 435:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 436:WTPA.c        **** 
 437:WTPA.c        **** 		// Calculate new addy while data bus settles
 438:WTPA.c        **** 
 439:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 440:WTPA.c        **** 		{
 441:WTPA.c        **** 			// Slice first, only worry about forward ### @@@
 442:WTPA.c        **** 
 443:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 444:WTPA.c        **** 			{
 445:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 446:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 447:WTPA.c        **** 			}
 448:WTPA.c        **** 			else	// Slice done, jump to new slice.
 449:WTPA.c        **** 			{
 450:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 451:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 452:WTPA.c        **** 
 453:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 454:WTPA.c        **** 				{
 455:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 456:WTPA.c        **** 				}
 457:WTPA.c        **** 
 458:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 459:WTPA.c        **** 			}
 460:WTPA.c        **** 		}
 461:WTPA.c        **** 		else
 462:WTPA.c        **** 		{
 463:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 464:WTPA.c        **** 			{
 465:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 466:WTPA.c        **** 				{
 467:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 468:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 469:WTPA.c        **** 				}
 470:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 471:WTPA.c        **** 				{
 472:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 473:WTPA.c        **** 				}
 474:WTPA.c        **** 				else
 475:WTPA.c        **** 				{
 476:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 477:WTPA.c        **** 					{
 478:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 479:WTPA.c        **** 					}
 480:WTPA.c        **** 					else
 481:WTPA.c        **** 					{
 482:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 483:WTPA.c        **** 					}
 484:WTPA.c        **** 				}
 485:WTPA.c        **** 			}
 486:WTPA.c        **** 			else	// Going forward through the sample.
 487:WTPA.c        **** 			{
 488:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 489:WTPA.c        **** 				{
 490:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 491:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 492:WTPA.c        **** 				}
 493:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 494:WTPA.c        **** 				{
 495:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 496:WTPA.c        **** 				}
 497:WTPA.c        **** 				else
 498:WTPA.c        **** 				{
 499:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 500:WTPA.c        **** 					{
 501:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 502:WTPA.c        **** 					}
 503:WTPA.c        **** 					else
 504:WTPA.c        **** 					{
 505:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 506:WTPA.c        **** 					}
 507:WTPA.c        **** 				}
 508:WTPA.c        **** 			}
 509:WTPA.c        **** 		}
 510:WTPA.c        **** 
 511:WTPA.c        **** 		// Finish getting the byte from RAM.
 512:WTPA.c        **** 
 513:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 514:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 515:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 516:WTPA.c        **** 
 517:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 518:WTPA.c        **** 		{
 519:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 520:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 521:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 522:WTPA.c        **** 		}
 523:WTPA.c        **** 		break;
 524:WTPA.c        **** 
 525:WTPA.c        **** 		case AUDIO_OVERDUB:
 526:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 527:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 528:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 529:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 530:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 531:WTPA.c        **** 
 532:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 533:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 534:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 535:WTPA.c        **** 
 536:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 537:WTPA.c        **** 
 538:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 539:WTPA.c        **** //		PORTC&=~0x07;											// Clear PORTC bits 0-2
 540:WTPA.c        **** //		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 541:WTPA.c        **** 
 542:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 543:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 544:WTPA.c        **** 
 545:WTPA.c        **** 		// Calculate new address while bus settles (were nops in here)
 546:WTPA.c        **** 
 547:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 548:WTPA.c        **** 		{
 549:WTPA.c        **** 			// Slice first, only worry about forward ###
 550:WTPA.c        **** 
 551:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 552:WTPA.c        **** 			{
 553:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 554:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 555:WTPA.c        **** 			}
 556:WTPA.c        **** 			else	// Slice done, jump to new slice.
 557:WTPA.c        **** 			{
 558:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 559:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 560:WTPA.c        **** 
 561:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 562:WTPA.c        **** 				{
 563:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 564:WTPA.c        **** 				}
 565:WTPA.c        **** 
 566:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 567:WTPA.c        **** 			}
 568:WTPA.c        **** 		}
 569:WTPA.c        **** 		else
 570:WTPA.c        **** 		{
 571:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 572:WTPA.c        **** 			{
 573:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 574:WTPA.c        **** 				{
 575:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 576:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 577:WTPA.c        **** 				}
 578:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 579:WTPA.c        **** 				{
 580:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 581:WTPA.c        **** 				}
 582:WTPA.c        **** 				else
 583:WTPA.c        **** 				{
 584:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 585:WTPA.c        **** 					{
 586:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 587:WTPA.c        **** 					}
 588:WTPA.c        **** 					else
 589:WTPA.c        **** 					{
 590:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 591:WTPA.c        **** 					}
 592:WTPA.c        **** 				}
 593:WTPA.c        **** 			}
 594:WTPA.c        **** 			else	// Going forward through the sample.
 595:WTPA.c        **** 			{
 596:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 597:WTPA.c        **** 				{
 598:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 599:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 600:WTPA.c        **** 				}
 601:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 602:WTPA.c        **** 				{
 603:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 604:WTPA.c        **** 				}
 605:WTPA.c        **** 				else
 606:WTPA.c        **** 				{
 607:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 608:WTPA.c        **** 					{
 609:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 610:WTPA.c        **** 					}
 611:WTPA.c        **** 					else
 612:WTPA.c        **** 					{
 613:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 614:WTPA.c        **** 					}
 615:WTPA.c        **** 				}
 616:WTPA.c        **** 			}
 617:WTPA.c        **** 		}
 618:WTPA.c        **** 
 619:WTPA.c        **** 		// Finished calculating address, bus should be settled, so finish the exchange with RAM
 620:WTPA.c        **** 
 621:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 622:WTPA.c        **** 
 623:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 624:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 625:WTPA.c        **** 
 626:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 627:WTPA.c        **** 		{
 628:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 629:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 630:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 631:WTPA.c        **** 		}
 632:WTPA.c        **** 
 633:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 634:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 635:WTPA.c        **** 		{
 636:WTPA.c        **** 			sum=127;
 637:WTPA.c        **** 		}
 638:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 639:WTPA.c        **** 		{
 640:WTPA.c        **** 			sum=-128;
 641:WTPA.c        **** 		}
 642:WTPA.c        **** 
 643:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 644:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 645:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 646:WTPA.c        **** 		break;
 647:WTPA.c        **** 	}
 648:WTPA.c        **** 
 649:WTPA.c        **** 	return(outputByte);
 650:WTPA.c        **** }
  36               		.loc 1 650 0
  37 0018 0895      		ret
  38               	.LVL2:
  39               	.L45:
 348:WTPA.c        **** 	switch(bankStates[BANK_0].audioFunction)
  40               		.loc 1 348 0
  41 001a 8130      		cpi r24,lo8(1)
  42 001c 01F4      		brne .+2
  43 001e 00C0      		rjmp .L3
  44 0020 8230      		cpi r24,lo8(2)
  45 0022 01F4      		brne .L37
 358:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
  46               		.loc 1 358 0
  47 0024 8091 0000 		lds r24,adcByte
  48               	.LVL3:
 360:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
  49               		.loc 1 360 0
  50 0028 9091 0000 		lds r25,bankStates+9
  51 002c 9923      		tst r25
  52 002e 01F0      		breq .L2
  53               	.L43:
 519:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
  54               		.loc 1 519 0
  55 0030 8058      		subi r24,lo8(-(-128))
  56               	.LVL4:
 520:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
  57               		.loc 1 520 0
  58 0032 9091 0000 		lds r25,bankStates+9
  59 0036 2FEF      		ldi r18,lo8(-1)
  60 0038 30E0      		ldi r19,0
  61 003a 092E      		mov r0,r25
  62 003c 00C0      		rjmp 2f
  63               		1:
  64 003e 220F      		lsl r18
  65               		2:
  66 0040 0A94      		dec r0
  67 0042 02F4      		brpl 1b
  68 0044 8223      		and r24,r18
  69               	.LVL5:
 521:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
  70               		.loc 1 521 0
  71 0046 8058      		subi r24,lo8(-(-128))
  72               	.LVL6:
  73 0048 0895      		ret
  74               	.LVL7:
  75               	.L46:
 528:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
  76               		.loc 1 528 0
  77 004a 8091 0000 		lds r24,bankStates+32
  78 004e 9091 0000 		lds r25,bankStates+32+1
  79 0052 A091 0000 		lds r26,bankStates+32+2
  80 0056 B091 0000 		lds r27,bankStates+32+3
  81 005a 85B9      		out 0x5,r24
 529:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
  82               		.loc 1 529 0
  83 005c 139A      		sbi 0x2,3
 530:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
  84               		.loc 1 530 0
  85 005e 1398      		cbi 0x2,3
 532:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
  86               		.loc 1 532 0
  87 0060 8091 0000 		lds r24,bankStates+32
  88 0064 9091 0000 		lds r25,bankStates+32+1
  89 0068 A091 0000 		lds r26,bankStates+32+2
  90 006c B091 0000 		lds r27,bankStates+32+3
  91 0070 892F      		mov r24,r25
  92 0072 9A2F      		mov r25,r26
  93 0074 AB2F      		mov r26,r27
  94 0076 BB27      		clr r27
  95 0078 85B9      		out 0x5,r24
 533:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
  96               		.loc 1 533 0
  97 007a 149A      		sbi 0x2,4
 534:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
  98               		.loc 1 534 0
  99 007c 1498      		cbi 0x2,4
 536:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 100               		.loc 1 536 0
 101 007e 8091 0000 		lds r24,bankStates+32
 102 0082 9091 0000 		lds r25,bankStates+32+1
 103 0086 A091 0000 		lds r26,bankStates+32+2
 104 008a B091 0000 		lds r27,bankStates+32+3
 105 008e CD01      		movw r24,r26
 106 0090 AA27      		clr r26
 107 0092 BB27      		clr r27
 108 0094 8770      		andi r24,7
 109 0096 9927      		clr r25
 110 0098 AA27      		clr r26
 111 009a BB27      		clr r27
 112 009c 8864      		ori r24,72
 113 009e 88B9      		out 0x8,r24
 542:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 114               		.loc 1 542 0
 115 00a0 14B8      		out 0x4,__zero_reg__
 543:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 116               		.loc 1 543 0
 117 00a2 1298      		cbi 0x2,2
 547:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 118               		.loc 1 547 0
 119 00a4 8091 0000 		lds r24,bankStates+7
 120 00a8 8823      		tst r24
 121 00aa 01F4      		brne .+2
 122 00ac 00C0      		rjmp .L23
 551:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 123               		.loc 1 551 0
 124 00ae 8091 0000 		lds r24,sliceRemaining
 125 00b2 9091 0000 		lds r25,sliceRemaining+1
 126 00b6 A091 0000 		lds r26,sliceRemaining+2
 127 00ba B091 0000 		lds r27,sliceRemaining+3
 128 00be 892B      		or r24,r25
 129 00c0 8A2B      		or r24,r26
 130 00c2 8B2B      		or r24,r27
 131 00c4 01F0      		breq .+2
 132 00c6 00C0      		rjmp .L47
 558:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 133               		.loc 1 558 0
 134 00c8 8091 0000 		lds r24,sliceSize
 135 00cc 9091 0000 		lds r25,sliceSize+1
 136 00d0 A091 0000 		lds r26,sliceSize+2
 137 00d4 B091 0000 		lds r27,sliceSize+3
 138 00d8 8093 0000 		sts sliceRemaining,r24
 139 00dc 9093 0000 		sts sliceRemaining+1,r25
 140 00e0 A093 0000 		sts sliceRemaining+2,r26
 141 00e4 B093 0000 		sts sliceRemaining+3,r27
 559:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 142               		.loc 1 559 0
 143 00e8 8091 0000 		lds r24,granularPositionArrayPointer
 144 00ec 8F5F      		subi r24,lo8(-(1))
 145 00ee 8093 0000 		sts granularPositionArrayPointer,r24
 561:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 146               		.loc 1 561 0
 147 00f2 9091 0000 		lds r25,granularPositionArrayPointer
 148 00f6 8091 0000 		lds r24,bankStates+7
 149 00fa 9817      		cp r25,r24
 150 00fc 01F4      		brne .+2
 151 00fe 00C0      		rjmp .L48
 152               	.L26:
 566:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 153               		.loc 1 566 0
 154 0100 E091 0000 		lds r30,granularPositionArrayPointer
 155 0104 2091 0000 		lds r18,sliceSize
 156 0108 3091 0000 		lds r19,sliceSize+1
 157 010c 4091 0000 		lds r20,sliceSize+2
 158 0110 5091 0000 		lds r21,sliceSize+3
 159 0114 F0E0      		ldi r31,0
 160 0116 E050      		subi r30,lo8(-(granularPositionArray))
 161 0118 F040      		sbci r31,hi8(-(granularPositionArray))
 162 011a A081      		ld r26,Z
 163 011c B0E0      		ldi r27,0
 164 011e 0E94 0000 		call __muluhisi3
 165 0122 6093 0000 		sts bankStates+32,r22
 166 0126 7093 0000 		sts bankStates+32+1,r23
 167 012a 8093 0000 		sts bankStates+32+2,r24
 168 012e 9093 0000 		sts bankStates+32+3,r25
 169 0132 00C0      		rjmp .L25
 170               	.L6:
 420:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 171               		.loc 1 420 0
 172 0134 8091 0000 		lds r24,bankStates+32
 173 0138 9091 0000 		lds r25,bankStates+32+1
 174 013c A091 0000 		lds r26,bankStates+32+2
 175 0140 B091 0000 		lds r27,bankStates+32+3
 176 0144 85B9      		out 0x5,r24
 421:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 177               		.loc 1 421 0
 178 0146 139A      		sbi 0x2,3
 422:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 179               		.loc 1 422 0
 180 0148 1398      		cbi 0x2,3
 424:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 181               		.loc 1 424 0
 182 014a 8091 0000 		lds r24,bankStates+32
 183 014e 9091 0000 		lds r25,bankStates+32+1
 184 0152 A091 0000 		lds r26,bankStates+32+2
 185 0156 B091 0000 		lds r27,bankStates+32+3
 186 015a 892F      		mov r24,r25
 187 015c 9A2F      		mov r25,r26
 188 015e AB2F      		mov r26,r27
 189 0160 BB27      		clr r27
 190 0162 85B9      		out 0x5,r24
 425:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 191               		.loc 1 425 0
 192 0164 149A      		sbi 0x2,4
 426:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 193               		.loc 1 426 0
 194 0166 1498      		cbi 0x2,4
 428:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 195               		.loc 1 428 0
 196 0168 8091 0000 		lds r24,bankStates+32
 197 016c 9091 0000 		lds r25,bankStates+32+1
 198 0170 A091 0000 		lds r26,bankStates+32+2
 199 0174 B091 0000 		lds r27,bankStates+32+3
 200 0178 CD01      		movw r24,r26
 201 017a AA27      		clr r26
 202 017c BB27      		clr r27
 203 017e 8770      		andi r24,7
 204 0180 9927      		clr r25
 205 0182 AA27      		clr r26
 206 0184 BB27      		clr r27
 207 0186 8864      		ori r24,72
 208 0188 88B9      		out 0x8,r24
 434:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 209               		.loc 1 434 0
 210 018a 14B8      		out 0x4,__zero_reg__
 435:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 211               		.loc 1 435 0
 212 018c 1298      		cbi 0x2,2
 439:WTPA.c        **** 		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
 213               		.loc 1 439 0
 214 018e 8091 0000 		lds r24,bankStates+7
 215 0192 8823      		tst r24
 216 0194 01F4      		brne .+2
 217 0196 00C0      		rjmp .L11
 443:WTPA.c        **** 			if(sliceRemaining[BANK_0])	// Moving through our current slice?
 218               		.loc 1 443 0
 219 0198 8091 0000 		lds r24,sliceRemaining
 220 019c 9091 0000 		lds r25,sliceRemaining+1
 221 01a0 A091 0000 		lds r26,sliceRemaining+2
 222 01a4 B091 0000 		lds r27,sliceRemaining+3
 223 01a8 892B      		or r24,r25
 224 01aa 8A2B      		or r24,r26
 225 01ac 8B2B      		or r24,r27
 226 01ae 01F0      		breq .+2
 227 01b0 00C0      		rjmp .L49
 450:WTPA.c        **** 				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
 228               		.loc 1 450 0
 229 01b2 8091 0000 		lds r24,sliceSize
 230 01b6 9091 0000 		lds r25,sliceSize+1
 231 01ba A091 0000 		lds r26,sliceSize+2
 232 01be B091 0000 		lds r27,sliceSize+3
 233 01c2 8093 0000 		sts sliceRemaining,r24
 234 01c6 9093 0000 		sts sliceRemaining+1,r25
 235 01ca A093 0000 		sts sliceRemaining+2,r26
 236 01ce B093 0000 		sts sliceRemaining+3,r27
 451:WTPA.c        **** 				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
 237               		.loc 1 451 0
 238 01d2 8091 0000 		lds r24,granularPositionArrayPointer
 239 01d6 8F5F      		subi r24,lo8(-(1))
 240 01d8 8093 0000 		sts granularPositionArrayPointer,r24
 453:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
 241               		.loc 1 453 0
 242 01dc 9091 0000 		lds r25,granularPositionArrayPointer
 243 01e0 8091 0000 		lds r24,bankStates+7
 244 01e4 9817      		cp r25,r24
 245 01e6 01F4      		brne .+2
 246 01e8 00C0      		rjmp .L50
 247               	.L14:
 458:WTPA.c        **** 				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[
 248               		.loc 1 458 0
 249 01ea E091 0000 		lds r30,granularPositionArrayPointer
 250 01ee 2091 0000 		lds r18,sliceSize
 251 01f2 3091 0000 		lds r19,sliceSize+1
 252 01f6 4091 0000 		lds r20,sliceSize+2
 253 01fa 5091 0000 		lds r21,sliceSize+3
 254 01fe F0E0      		ldi r31,0
 255 0200 E050      		subi r30,lo8(-(granularPositionArray))
 256 0202 F040      		sbci r31,hi8(-(granularPositionArray))
 257 0204 A081      		ld r26,Z
 258 0206 B0E0      		ldi r27,0
 259 0208 0E94 0000 		call __muluhisi3
 260 020c 6093 0000 		sts bankStates+32,r22
 261 0210 7093 0000 		sts bankStates+32+1,r23
 262 0214 8093 0000 		sts bankStates+32+2,r24
 263 0218 9093 0000 		sts bankStates+32+3,r25
 264 021c 00C0      		rjmp .L13
 265               	.L3:
 353:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 266               		.loc 1 353 0
 267 021e 8091 0000 		lds r24,sawtooth.1757
 268               	.LVL8:
 269 0222 982F      		mov r25,r24
 270 0224 9F5F      		subi r25,lo8(-(1))
 271 0226 9093 0000 		sts sawtooth.1757,r25
 354:WTPA.c        **** 		break;
 272               		.loc 1 354 0
 273 022a 0895      		ret
 274               	.LVL9:
 275               	.L5:
 370:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 276               		.loc 1 370 0
 277 022c 8FEF      		ldi r24,lo8(-1)
 278 022e 84B9      		out 0x4,r24
 371:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
 279               		.loc 1 371 0
 280 0230 8091 0000 		lds r24,bankStates+32
 281 0234 9091 0000 		lds r25,bankStates+32+1
 282 0238 A091 0000 		lds r26,bankStates+32+2
 283 023c B091 0000 		lds r27,bankStates+32+3
 284 0240 85B9      		out 0x5,r24
 372:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 285               		.loc 1 372 0
 286 0242 139A      		sbi 0x2,3
 373:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 287               		.loc 1 373 0
 288 0244 1398      		cbi 0x2,3
 375:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the
 289               		.loc 1 375 0
 290 0246 8091 0000 		lds r24,bankStates+32
 291 024a 9091 0000 		lds r25,bankStates+32+1
 292 024e A091 0000 		lds r26,bankStates+32+2
 293 0252 B091 0000 		lds r27,bankStates+32+3
 294 0256 892F      		mov r24,r25
 295 0258 9A2F      		mov r25,r26
 296 025a AB2F      		mov r26,r27
 297 025c BB27      		clr r27
 298 025e 85B9      		out 0x5,r24
 376:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 299               		.loc 1 376 0
 300 0260 149A      		sbi 0x2,4
 377:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 301               		.loc 1 377 0
 302 0262 1498      		cbi 0x2,4
 379:WTPA.c        **** 		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (P
 303               		.loc 1 379 0
 304 0264 8091 0000 		lds r24,bankStates+32
 305 0268 9091 0000 		lds r25,bankStates+32+1
 306 026c A091 0000 		lds r26,bankStates+32+2
 307 0270 B091 0000 		lds r27,bankStates+32+3
 308 0274 CD01      		movw r24,r26
 309 0276 AA27      		clr r26
 310 0278 BB27      		clr r27
 311 027a 8770      		andi r24,7
 312 027c 9927      		clr r25
 313 027e AA27      		clr r26
 314 0280 BB27      		clr r27
 315 0282 8864      		ori r24,72
 316 0284 88B9      		out 0x8,r24
 385:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 317               		.loc 1 385 0
 318 0286 8091 0000 		lds r24,adcByte
 319 028a 85B9      		out 0x5,r24
 400:WTPA.c        **** 		bankStates[BANK_0].endAddress=++bankStates[BANK_0].currentAddress;			// Next address please, matc
 320               		.loc 1 400 0
 321 028c 8091 0000 		lds r24,bankStates+32
 322 0290 9091 0000 		lds r25,bankStates+32+1
 323 0294 A091 0000 		lds r26,bankStates+32+2
 324 0298 B091 0000 		lds r27,bankStates+32+3
 325 029c 0196      		adiw r24,1
 326 029e A11D      		adc r26,__zero_reg__
 327 02a0 B11D      		adc r27,__zero_reg__
 328 02a2 8093 0000 		sts bankStates+32,r24
 329 02a6 9093 0000 		sts bankStates+32+1,r25
 330 02aa A093 0000 		sts bankStates+32+2,r26
 331 02ae B093 0000 		sts bankStates+32+3,r27
 332 02b2 8093 0000 		sts bankStates+13,r24
 333 02b6 9093 0000 		sts bankStates+13+1,r25
 334 02ba A093 0000 		sts bankStates+13+2,r26
 335 02be B093 0000 		sts bankStates+13+3,r27
 401:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address 
 336               		.loc 1 401 0
 337 02c2 8091 0000 		lds r24,bankStates+32
 338 02c6 9091 0000 		lds r25,bankStates+32+1
 339 02ca A091 0000 		lds r26,bankStates+32+2
 340 02ce B091 0000 		lds r27,bankStates+32+3
 341 02d2 8093 0000 		sts bankStates+21,r24
 342 02d6 9093 0000 		sts bankStates+21+1,r25
 343 02da A093 0000 		sts bankStates+21+2,r26
 344 02de B093 0000 		sts bankStates+21+3,r27
 403:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 345               		.loc 1 403 0
 346 02e2 4091 0000 		lds r20,bankStates+13
 347 02e6 5091 0000 		lds r21,bankStates+13+1
 348 02ea 6091 0000 		lds r22,bankStates+13+2
 349 02ee 7091 0000 		lds r23,bankStates+13+3
 350 02f2 8091 0000 		lds r24,bankStates+49
 351 02f6 9091 0000 		lds r25,bankStates+49+1
 352 02fa A091 0000 		lds r26,bankStates+49+2
 353 02fe B091 0000 		lds r27,bankStates+49+3
 354 0302 4817      		cp r20,r24
 355 0304 5907      		cpc r21,r25
 356 0306 6A07      		cpc r22,r26
 357 0308 7B07      		cpc r23,r27
 358 030a 00F0      		brlo .L10
 405:WTPA.c        **** 			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 359               		.loc 1 405 0
 360 030c 1092 0000 		sts bankStates,__zero_reg__
 406:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 361               		.loc 1 406 0
 362 0310 81E0      		ldi r24,lo8(1)
 363 0312 8093 0000 		sts outOfRam,r24
 364               	.L10:
 410:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 365               		.loc 1 410 0
 366 0316 1198      		cbi 0x2,1
 411:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 367               		.loc 1 411 0
 368 0318 119A      		sbi 0x2,1
 412:WTPA.c        **** 		break;
 369               		.loc 1 412 0
 370 031a 80E0      		ldi r24,0
 371 031c 0895      		ret
 372               	.L23:
 571:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 373               		.loc 1 571 0
 374 031e 8091 0000 		lds r24,bankStates+4
 573:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 375               		.loc 1 573 0
 376 0322 4091 0000 		lds r20,bankStates+32
 377 0326 5091 0000 		lds r21,bankStates+32+1
 378 032a 6091 0000 		lds r22,bankStates+32+2
 379 032e 7091 0000 		lds r23,bankStates+32+3
 571:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 380               		.loc 1 571 0
 381 0332 8823      		tst r24
 382 0334 01F4      		brne .+2
 383 0336 00C0      		rjmp .L51
 596:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 384               		.loc 1 596 0
 385 0338 8091 0000 		lds r24,bankStates+21
 386 033c 9091 0000 		lds r25,bankStates+21+1
 387 0340 A091 0000 		lds r26,bankStates+21+2
 388 0344 B091 0000 		lds r27,bankStates+21+3
 389 0348 4817      		cp r20,r24
 390 034a 5907      		cpc r21,r25
 391 034c 6A07      		cpc r22,r26
 392 034e 7B07      		cpc r23,r27
 393 0350 01F4      		brne .+2
 394 0352 00C0      		rjmp .L52
 395               	.L31:
 601:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 396               		.loc 1 601 0
 397 0354 4091 0000 		lds r20,bankStates+32
 398 0358 5091 0000 		lds r21,bankStates+32+1
 399 035c 6091 0000 		lds r22,bankStates+32+2
 400 0360 7091 0000 		lds r23,bankStates+32+3
 401 0364 8091 0000 		lds r24,bankStates+21
 402 0368 9091 0000 		lds r25,bankStates+21+1
 403 036c A091 0000 		lds r26,bankStates+21+2
 404 0370 B091 0000 		lds r27,bankStates+21+3
 405 0374 4817      		cp r20,r24
 406 0376 5907      		cpc r21,r25
 407 0378 6A07      		cpc r22,r26
 408 037a 7B07      		cpc r23,r27
 409 037c 01F4      		brne .+2
 410 037e 00C0      		rjmp .L53
 607:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 411               		.loc 1 607 0
 412 0380 4091 0000 		lds r20,bankStates+32
 413 0384 5091 0000 		lds r21,bankStates+32+1
 414 0388 6091 0000 		lds r22,bankStates+32+2
 415 038c 7091 0000 		lds r23,bankStates+32+3
 416 0390 8091 0000 		lds r24,bankStates+13
 417 0394 9091 0000 		lds r25,bankStates+13+1
 418 0398 A091 0000 		lds r26,bankStates+13+2
 419 039c B091 0000 		lds r27,bankStates+13+3
 420 03a0 4817      		cp r20,r24
 421 03a2 5907      		cpc r21,r25
 422 03a4 6A07      		cpc r22,r26
 423 03a6 7B07      		cpc r23,r27
 424 03a8 01F4      		brne .+2
 425 03aa 00C0      		rjmp .L54
 613:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 426               		.loc 1 613 0
 427 03ac 8091 0000 		lds r24,bankStates+32
 428 03b0 9091 0000 		lds r25,bankStates+32+1
 429 03b4 A091 0000 		lds r26,bankStates+32+2
 430 03b8 B091 0000 		lds r27,bankStates+32+3
 431 03bc 0196      		adiw r24,1
 432 03be A11D      		adc r26,__zero_reg__
 433 03c0 B11D      		adc r27,__zero_reg__
 434 03c2 8093 0000 		sts bankStates+32,r24
 435 03c6 9093 0000 		sts bankStates+32+1,r25
 436 03ca A093 0000 		sts bankStates+32+2,r26
 437 03ce B093 0000 		sts bankStates+32+3,r27
 438               	.L25:
 621:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 439               		.loc 1 621 0
 440 03d2 83B1      		in r24,0x3
 441               	.LVL10:
 623:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 442               		.loc 1 623 0
 443 03d4 129A      		sbi 0x2,2
 624:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 444               		.loc 1 624 0
 445 03d6 9FEF      		ldi r25,lo8(-1)
 446 03d8 94B9      		out 0x4,r25
 626:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 447               		.loc 1 626 0
 448 03da 9091 0000 		lds r25,bankStates+9
 449 03de 9923      		tst r25
 450 03e0 01F0      		breq .L34
 628:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 451               		.loc 1 628 0
 452 03e2 8058      		subi r24,lo8(-(-128))
 453               	.LVL11:
 629:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're suppos
 454               		.loc 1 629 0
 455 03e4 9091 0000 		lds r25,bankStates+9
 456 03e8 2FEF      		ldi r18,lo8(-1)
 457 03ea 30E0      		ldi r19,0
 458 03ec 092E      		mov r0,r25
 459 03ee 00C0      		rjmp 2f
 460               		1:
 461 03f0 220F      		lsl r18
 462               		2:
 463 03f2 0A94      		dec r0
 464 03f4 02F4      		brpl 1b
 465 03f6 8223      		and r24,r18
 466               	.LVL12:
 630:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 467               		.loc 1 630 0
 468 03f8 8058      		subi r24,lo8(-(-128))
 469               	.LVL13:
 470               	.L34:
 633:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 471               		.loc 1 633 0
 472 03fa 2091 0000 		lds r18,adcByte
 473 03fe 3327      		clr r19
 474 0400 27FD      		sbrc r18,7
 475 0402 3095      		com r19
 476 0404 280F      		add r18,r24
 477 0406 311D      		adc r19,__zero_reg__
 478 0408 87FD      		sbrc r24,7
 479 040a 3A95      		dec r19
 480 040c 2038      		cpi r18,-128
 481 040e 9FEF      		ldi r25,-1
 482 0410 3907      		cpc r19,r25
 483 0412 04F4      		brge .L35
 484 0414 20E8      		ldi r18,lo8(-128)
 485 0416 3FEF      		ldi r19,lo8(-1)
 486               	.L35:
 487               	.LVL14:
 643:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 488               		.loc 1 643 0
 489 0418 2038      		cpi r18,-128
 490 041a 3105      		cpc r19,__zero_reg__
 491 041c 04F0      		brlt .L36
 492 041e 2FE7      		ldi r18,lo8(127)
 493 0420 30E0      		ldi r19,0
 494               	.LVL15:
 495               	.L36:
 496 0422 25B9      		out 0x5,r18
 644:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 497               		.loc 1 644 0
 498 0424 1198      		cbi 0x2,1
 645:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 499               		.loc 1 645 0
 500 0426 119A      		sbi 0x2,1
 646:WTPA.c        **** 		break;
 501               		.loc 1 646 0
 502 0428 0895      		ret
 503               	.LVL16:
 504               	.L11:
 463:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 505               		.loc 1 463 0
 506 042a 8091 0000 		lds r24,bankStates+4
 465:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 507               		.loc 1 465 0
 508 042e 4091 0000 		lds r20,bankStates+32
 509 0432 5091 0000 		lds r21,bankStates+32+1
 510 0436 6091 0000 		lds r22,bankStates+32+2
 511 043a 7091 0000 		lds r23,bankStates+32+3
 463:WTPA.c        **** 			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
 512               		.loc 1 463 0
 513 043e 8823      		tst r24
 514 0440 01F4      		brne .+2
 515 0442 00C0      		rjmp .L55
 488:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 516               		.loc 1 488 0
 517 0444 8091 0000 		lds r24,bankStates+21
 518 0448 9091 0000 		lds r25,bankStates+21+1
 519 044c A091 0000 		lds r26,bankStates+21+2
 520 0450 B091 0000 		lds r27,bankStates+21+3
 521 0454 4817      		cp r20,r24
 522 0456 5907      		cpc r21,r25
 523 0458 6A07      		cpc r22,r26
 524 045a 7B07      		cpc r23,r27
 525 045c 01F4      		brne .+2
 526 045e 00C0      		rjmp .L56
 527               	.L19:
 493:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're loo
 528               		.loc 1 493 0
 529 0460 4091 0000 		lds r20,bankStates+32
 530 0464 5091 0000 		lds r21,bankStates+32+1
 531 0468 6091 0000 		lds r22,bankStates+32+2
 532 046c 7091 0000 		lds r23,bankStates+32+3
 533 0470 8091 0000 		lds r24,bankStates+21
 534 0474 9091 0000 		lds r25,bankStates+21+1
 535 0478 A091 0000 		lds r26,bankStates+21+2
 536 047c B091 0000 		lds r27,bankStates+21+3
 537 0480 4817      		cp r20,r24
 538 0482 5907      		cpc r21,r25
 539 0484 6A07      		cpc r22,r26
 540 0486 7B07      		cpc r23,r27
 541 0488 01F4      		brne .+2
 542 048a 00C0      		rjmp .L57
 499:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop 
 543               		.loc 1 499 0
 544 048c 4091 0000 		lds r20,bankStates+32
 545 0490 5091 0000 		lds r21,bankStates+32+1
 546 0494 6091 0000 		lds r22,bankStates+32+2
 547 0498 7091 0000 		lds r23,bankStates+32+3
 548 049c 8091 0000 		lds r24,bankStates+13
 549 04a0 9091 0000 		lds r25,bankStates+13+1
 550 04a4 A091 0000 		lds r26,bankStates+13+2
 551 04a8 B091 0000 		lds r27,bankStates+13+3
 552 04ac 4817      		cp r20,r24
 553 04ae 5907      		cpc r21,r25
 554 04b0 6A07      		cpc r22,r26
 555 04b2 7B07      		cpc r23,r27
 556 04b4 01F4      		brne .+2
 557 04b6 00C0      		rjmp .L58
 505:WTPA.c        **** 						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
 558               		.loc 1 505 0
 559 04b8 8091 0000 		lds r24,bankStates+32
 560 04bc 9091 0000 		lds r25,bankStates+32+1
 561 04c0 A091 0000 		lds r26,bankStates+32+2
 562 04c4 B091 0000 		lds r27,bankStates+32+3
 563 04c8 0196      		adiw r24,1
 564 04ca A11D      		adc r26,__zero_reg__
 565 04cc B11D      		adc r27,__zero_reg__
 566 04ce 8093 0000 		sts bankStates+32,r24
 567 04d2 9093 0000 		sts bankStates+32+1,r25
 568 04d6 A093 0000 		sts bankStates+32+2,r26
 569 04da B093 0000 		sts bankStates+32+3,r27
 570               	.L13:
 513:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 571               		.loc 1 513 0
 572 04de 83B1      		in r24,0x3
 573               	.LVL17:
 514:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 574               		.loc 1 514 0
 575 04e0 129A      		sbi 0x2,2
 515:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 576               		.loc 1 515 0
 577 04e2 9FEF      		ldi r25,lo8(-1)
 578 04e4 94B9      		out 0x4,r25
 517:WTPA.c        **** 		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
 579               		.loc 1 517 0
 580 04e6 9091 0000 		lds r25,bankStates+9
 581 04ea 9923      		tst r25
 582 04ec 01F4      		brne .+2
 583 04ee 00C0      		rjmp .L2
 584 04f0 00C0      		rjmp .L43
 585               	.LVL18:
 586               	.L55:
 465:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 587               		.loc 1 465 0
 588 04f2 8091 0000 		lds r24,bankStates+25
 589 04f6 9091 0000 		lds r25,bankStates+25+1
 590 04fa A091 0000 		lds r26,bankStates+25+2
 591 04fe B091 0000 		lds r27,bankStates+25+3
 592 0502 4817      		cp r20,r24
 593 0504 5907      		cpc r21,r25
 594 0506 6A07      		cpc r22,r26
 595 0508 7B07      		cpc r23,r27
 596 050a 01F4      		brne .+2
 597 050c 00C0      		rjmp .L59
 598               	.L16:
 470:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 599               		.loc 1 470 0
 600 050e 4091 0000 		lds r20,bankStates+32
 601 0512 5091 0000 		lds r21,bankStates+32+1
 602 0516 6091 0000 		lds r22,bankStates+32+2
 603 051a 7091 0000 		lds r23,bankStates+32+3
 604 051e 8091 0000 		lds r24,bankStates+25
 605 0522 9091 0000 		lds r25,bankStates+25+1
 606 0526 A091 0000 		lds r26,bankStates+25+2
 607 052a B091 0000 		lds r27,bankStates+25+3
 608 052e 4817      		cp r20,r24
 609 0530 5907      		cpc r21,r25
 610 0532 6A07      		cpc r22,r26
 611 0534 7B07      		cpc r23,r27
 612 0536 01F4      		brne .+2
 613 0538 00C0      		rjmp .L60
 476:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 614               		.loc 1 476 0
 615 053a 4091 0000 		lds r20,bankStates+32
 616 053e 5091 0000 		lds r21,bankStates+32+1
 617 0542 6091 0000 		lds r22,bankStates+32+2
 618 0546 7091 0000 		lds r23,bankStates+32+3
 619 054a 8091 0000 		lds r24,bankStates+17
 620 054e 9091 0000 		lds r25,bankStates+17+1
 621 0552 A091 0000 		lds r26,bankStates+17+2
 622 0556 B091 0000 		lds r27,bankStates+17+3
 623 055a 4817      		cp r20,r24
 624 055c 5907      		cpc r21,r25
 625 055e 6A07      		cpc r22,r26
 626 0560 7B07      		cpc r23,r27
 627 0562 01F4      		brne .+2
 628 0564 00C0      		rjmp .L61
 482:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 629               		.loc 1 482 0
 630 0566 8091 0000 		lds r24,bankStates+32
 631 056a 9091 0000 		lds r25,bankStates+32+1
 632 056e A091 0000 		lds r26,bankStates+32+2
 633 0572 B091 0000 		lds r27,bankStates+32+3
 634 0576 0197      		sbiw r24,1
 635 0578 A109      		sbc r26,__zero_reg__
 636 057a B109      		sbc r27,__zero_reg__
 637 057c 8093 0000 		sts bankStates+32,r24
 638 0580 9093 0000 		sts bankStates+32+1,r25
 639 0584 A093 0000 		sts bankStates+32+2,r26
 640 0588 B093 0000 		sts bankStates+32+3,r27
 641 058c 00C0      		rjmp .L13
 642               	.L49:
 445:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 643               		.loc 1 445 0
 644 058e 8091 0000 		lds r24,bankStates+32
 645 0592 9091 0000 		lds r25,bankStates+32+1
 646 0596 A091 0000 		lds r26,bankStates+32+2
 647 059a B091 0000 		lds r27,bankStates+32+3
 648 059e 0196      		adiw r24,1
 649 05a0 A11D      		adc r26,__zero_reg__
 650 05a2 B11D      		adc r27,__zero_reg__
 651 05a4 8093 0000 		sts bankStates+32,r24
 652 05a8 9093 0000 		sts bankStates+32+1,r25
 653 05ac A093 0000 		sts bankStates+32+2,r26
 654 05b0 B093 0000 		sts bankStates+32+3,r27
 446:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 655               		.loc 1 446 0
 656 05b4 8091 0000 		lds r24,sliceRemaining
 657 05b8 9091 0000 		lds r25,sliceRemaining+1
 658 05bc A091 0000 		lds r26,sliceRemaining+2
 659 05c0 B091 0000 		lds r27,sliceRemaining+3
 660 05c4 0197      		sbiw r24,1
 661 05c6 A109      		sbc r26,__zero_reg__
 662 05c8 B109      		sbc r27,__zero_reg__
 663 05ca 8093 0000 		sts sliceRemaining,r24
 664 05ce 9093 0000 		sts sliceRemaining+1,r25
 665 05d2 A093 0000 		sts sliceRemaining+2,r26
 666 05d6 B093 0000 		sts sliceRemaining+3,r27
 667 05da 00C0      		rjmp .L13
 668               	.L47:
 553:WTPA.c        **** 				bankStates[BANK_0].currentAddress++;
 669               		.loc 1 553 0
 670 05dc 8091 0000 		lds r24,bankStates+32
 671 05e0 9091 0000 		lds r25,bankStates+32+1
 672 05e4 A091 0000 		lds r26,bankStates+32+2
 673 05e8 B091 0000 		lds r27,bankStates+32+3
 674 05ec 0196      		adiw r24,1
 675 05ee A11D      		adc r26,__zero_reg__
 676 05f0 B11D      		adc r27,__zero_reg__
 677 05f2 8093 0000 		sts bankStates+32,r24
 678 05f6 9093 0000 		sts bankStates+32+1,r25
 679 05fa A093 0000 		sts bankStates+32+2,r26
 680 05fe B093 0000 		sts bankStates+32+3,r27
 554:WTPA.c        **** 				sliceRemaining[BANK_0]--;
 681               		.loc 1 554 0
 682 0602 8091 0000 		lds r24,sliceRemaining
 683 0606 9091 0000 		lds r25,sliceRemaining+1
 684 060a A091 0000 		lds r26,sliceRemaining+2
 685 060e B091 0000 		lds r27,sliceRemaining+3
 686 0612 0197      		sbiw r24,1
 687 0614 A109      		sbc r26,__zero_reg__
 688 0616 B109      		sbc r27,__zero_reg__
 689 0618 8093 0000 		sts sliceRemaining,r24
 690 061c 9093 0000 		sts sliceRemaining+1,r25
 691 0620 A093 0000 		sts sliceRemaining+2,r26
 692 0624 B093 0000 		sts sliceRemaining+3,r27
 693 0628 00C0      		rjmp .L25
 694               	.L51:
 573:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 695               		.loc 1 573 0
 696 062a 8091 0000 		lds r24,bankStates+25
 697 062e 9091 0000 		lds r25,bankStates+25+1
 698 0632 A091 0000 		lds r26,bankStates+25+2
 699 0636 B091 0000 		lds r27,bankStates+25+3
 700 063a 4817      		cp r20,r24
 701 063c 5907      		cpc r21,r25
 702 063e 6A07      		cpc r22,r26
 703 0640 7B07      		cpc r23,r27
 704 0642 01F4      		brne .+2
 705 0644 00C0      		rjmp .L62
 706               	.L28:
 578:WTPA.c        **** 				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're lo
 707               		.loc 1 578 0
 708 0646 4091 0000 		lds r20,bankStates+32
 709 064a 5091 0000 		lds r21,bankStates+32+1
 710 064e 6091 0000 		lds r22,bankStates+32+2
 711 0652 7091 0000 		lds r23,bankStates+32+3
 712 0656 8091 0000 		lds r24,bankStates+25
 713 065a 9091 0000 		lds r25,bankStates+25+1
 714 065e A091 0000 		lds r26,bankStates+25+2
 715 0662 B091 0000 		lds r27,bankStates+25+3
 716 0666 4817      		cp r20,r24
 717 0668 5907      		cpc r21,r25
 718 066a 6A07      		cpc r22,r26
 719 066c 7B07      		cpc r23,r27
 720 066e 01F4      		brne .+2
 721 0670 00C0      		rjmp .L63
 584:WTPA.c        **** 					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loo
 722               		.loc 1 584 0
 723 0672 4091 0000 		lds r20,bankStates+32
 724 0676 5091 0000 		lds r21,bankStates+32+1
 725 067a 6091 0000 		lds r22,bankStates+32+2
 726 067e 7091 0000 		lds r23,bankStates+32+3
 727 0682 8091 0000 		lds r24,bankStates+17
 728 0686 9091 0000 		lds r25,bankStates+17+1
 729 068a A091 0000 		lds r26,bankStates+17+2
 730 068e B091 0000 		lds r27,bankStates+17+3
 731 0692 4817      		cp r20,r24
 732 0694 5907      		cpc r21,r25
 733 0696 6A07      		cpc r22,r26
 734 0698 7B07      		cpc r23,r27
 735 069a 01F4      		brne .+2
 736 069c 00C0      		rjmp .L64
 590:WTPA.c        **** 						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
 737               		.loc 1 590 0
 738 069e 8091 0000 		lds r24,bankStates+32
 739 06a2 9091 0000 		lds r25,bankStates+32+1
 740 06a6 A091 0000 		lds r26,bankStates+32+2
 741 06aa B091 0000 		lds r27,bankStates+32+3
 742 06ae 0197      		sbiw r24,1
 743 06b0 A109      		sbc r26,__zero_reg__
 744 06b2 B109      		sbc r27,__zero_reg__
 745 06b4 8093 0000 		sts bankStates+32,r24
 746 06b8 9093 0000 		sts bankStates+32+1,r25
 747 06bc A093 0000 		sts bankStates+32+2,r26
 748 06c0 B093 0000 		sts bankStates+32+3,r27
 749 06c4 00C0      		rjmp .L25
 750               	.L59:
 465:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 751               		.loc 1 465 0 discriminator 1
 752 06c6 8091 0000 		lds r24,bankStates+1
 753 06ca 8130      		cpi r24,lo8(1)
 754 06cc 01F0      		breq .+2
 755 06ce 00C0      		rjmp .L16
 756               	.L41:
 490:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 757               		.loc 1 490 0
 758 06d0 1092 0000 		sts bankStates,__zero_reg__
 491:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 759               		.loc 1 491 0
 760 06d4 1092 0000 		sts bankStates+10,__zero_reg__
 761 06d8 00C0      		rjmp .L13
 762               	.L62:
 573:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BA
 763               		.loc 1 573 0 discriminator 1
 764 06da 8091 0000 		lds r24,bankStates+1
 765 06de 8130      		cpi r24,lo8(1)
 766 06e0 01F0      		breq .+2
 767 06e2 00C0      		rjmp .L28
 768               	.L42:
 598:WTPA.c        **** 					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
 769               		.loc 1 598 0
 770 06e4 1092 0000 		sts bankStates,__zero_reg__
 599:WTPA.c        **** 					bankStates[BANK_0].clockMode=CLK_NONE;
 771               		.loc 1 599 0
 772 06e8 1092 0000 		sts bankStates+10,__zero_reg__
 773 06ec 00C0      		rjmp .L25
 774               	.L52:
 596:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 775               		.loc 1 596 0 discriminator 1
 776 06ee 8091 0000 		lds r24,bankStates+1
 777 06f2 8130      		cpi r24,lo8(1)
 778 06f4 01F0      		breq .+2
 779 06f6 00C0      		rjmp .L31
 780 06f8 00C0      		rjmp .L42
 781               	.L56:
 488:WTPA.c        **** 				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK
 782               		.loc 1 488 0 discriminator 1
 783 06fa 8091 0000 		lds r24,bankStates+1
 784 06fe 8130      		cpi r24,lo8(1)
 785 0700 01F0      		breq .+2
 786 0702 00C0      		rjmp .L19
 787 0704 00C0      		rjmp .L41
 788               	.L50:
 455:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 789               		.loc 1 455 0
 790 0706 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 791 070a 00C0      		rjmp .L14
 792               	.L48:
 563:WTPA.c        **** 					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
 793               		.loc 1 563 0
 794 070c 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
 795 0710 00C0      		rjmp .L26
 796               	.L57:
 495:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 797               		.loc 1 495 0
 798 0712 8091 0000 		lds r24,bankStates+25
 799 0716 9091 0000 		lds r25,bankStates+25+1
 800 071a A091 0000 		lds r26,bankStates+25+2
 801 071e B091 0000 		lds r27,bankStates+25+3
 802 0722 8093 0000 		sts bankStates+32,r24
 803 0726 9093 0000 		sts bankStates+32+1,r25
 804 072a A093 0000 		sts bankStates+32+2,r26
 805 072e B093 0000 		sts bankStates+32+3,r27
 806 0732 00C0      		rjmp .L13
 807               	.L53:
 603:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to
 808               		.loc 1 603 0
 809 0734 8091 0000 		lds r24,bankStates+25
 810 0738 9091 0000 		lds r25,bankStates+25+1
 811 073c A091 0000 		lds r26,bankStates+25+2
 812 0740 B091 0000 		lds r27,bankStates+25+3
 813 0744 8093 0000 		sts bankStates+32,r24
 814 0748 9093 0000 		sts bankStates+32+1,r25
 815 074c A093 0000 		sts bankStates+32+2,r26
 816 0750 B093 0000 		sts bankStates+32+3,r27
 817 0754 00C0      		rjmp .L25
 818               	.L63:
 580:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 819               		.loc 1 580 0
 820 0756 8091 0000 		lds r24,bankStates+21
 821 075a 9091 0000 		lds r25,bankStates+21+1
 822 075e A091 0000 		lds r26,bankStates+21+2
 823 0762 B091 0000 		lds r27,bankStates+21+3
 824 0766 8093 0000 		sts bankStates+32,r24
 825 076a 9093 0000 		sts bankStates+32+1,r25
 826 076e A093 0000 		sts bankStates+32+2,r26
 827 0772 B093 0000 		sts bankStates+32+3,r27
 828 0776 00C0      		rjmp .L25
 829               	.L60:
 472:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um,
 830               		.loc 1 472 0
 831 0778 8091 0000 		lds r24,bankStates+21
 832 077c 9091 0000 		lds r25,bankStates+21+1
 833 0780 A091 0000 		lds r26,bankStates+21+2
 834 0784 B091 0000 		lds r27,bankStates+21+3
 835 0788 8093 0000 		sts bankStates+32,r24
 836 078c 9093 0000 		sts bankStates+32+1,r25
 837 0790 A093 0000 		sts bankStates+32+2,r26
 838 0794 B093 0000 		sts bankStates+32+3,r27
 839 0798 00C0      		rjmp .L13
 840               	.L61:
 478:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 841               		.loc 1 478 0
 842 079a 8091 0000 		lds r24,bankStates+13
 843 079e 9091 0000 		lds r25,bankStates+13+1
 844 07a2 A091 0000 		lds r26,bankStates+13+2
 845 07a6 B091 0000 		lds r27,bankStates+13+3
 846 07aa 8093 0000 		sts bankStates+32,r24
 847 07ae 9093 0000 		sts bankStates+32+1,r25
 848 07b2 A093 0000 		sts bankStates+32+2,r26
 849 07b6 B093 0000 		sts bankStates+32+3,r27
 850 07ba 00C0      		rjmp .L13
 851               	.L64:
 586:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping thr
 852               		.loc 1 586 0
 853 07bc 8091 0000 		lds r24,bankStates+13
 854 07c0 9091 0000 		lds r25,bankStates+13+1
 855 07c4 A091 0000 		lds r26,bankStates+13+2
 856 07c8 B091 0000 		lds r27,bankStates+13+3
 857 07cc 8093 0000 		sts bankStates+32,r24
 858 07d0 9093 0000 		sts bankStates+32+1,r25
 859 07d4 A093 0000 		sts bankStates+32+2,r26
 860 07d8 B093 0000 		sts bankStates+32+3,r27
 861 07dc 00C0      		rjmp .L25
 862               	.L58:
 501:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 863               		.loc 1 501 0
 864 07de 8091 0000 		lds r24,bankStates+17
 865 07e2 9091 0000 		lds r25,bankStates+17+1
 866 07e6 A091 0000 		lds r26,bankStates+17+2
 867 07ea B091 0000 		lds r27,bankStates+17+3
 868 07ee 8093 0000 		sts bankStates+32,r24
 869 07f2 9093 0000 		sts bankStates+32+1,r25
 870 07f6 A093 0000 		sts bankStates+32+2,r26
 871 07fa B093 0000 		sts bankStates+32+3,r27
 872 07fe 00C0      		rjmp .L13
 873               	.L54:
 609:WTPA.c        **** 						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping th
 874               		.loc 1 609 0
 875 0800 8091 0000 		lds r24,bankStates+17
 876 0804 9091 0000 		lds r25,bankStates+17+1
 877 0808 A091 0000 		lds r26,bankStates+17+2
 878 080c B091 0000 		lds r27,bankStates+17+3
 879 0810 8093 0000 		sts bankStates+32,r24
 880 0814 9093 0000 		sts bankStates+32+1,r25
 881 0818 A093 0000 		sts bankStates+32+2,r26
 882 081c B093 0000 		sts bankStates+32+3,r27
 883 0820 00C0      		rjmp .L25
 884               		.cfi_endproc
 885               	.LFE1:
 888               	UpdateAudioChannel1:
 889               	.LFB2:
 651:WTPA.c        **** 
 652:WTPA.c        **** static unsigned char UpdateAudioChannel1(void)
 653:WTPA.c        **** // New banked idea of the audio handler -- ONE FOR EACH BANK!
 654:WTPA.c        **** {
 890               		.loc 1 654 0
 891               		.cfi_startproc
 892 0822 0F93      		push r16
 893               	.LCFI0:
 894               		.cfi_def_cfa_offset 3
 895               		.cfi_offset 16, -2
 896 0824 1F93      		push r17
 897               	.LCFI1:
 898               		.cfi_def_cfa_offset 4
 899               		.cfi_offset 17, -3
 900               	/* prologue: function */
 901               	/* frame size = 0 */
 902               	/* stack size = 2 */
 903               	.L__stack_usage = 2
 904               	.LVL19:
 655:WTPA.c        **** 	signed int
 656:WTPA.c        **** 		sum;			// For doing saturated adds.
 657:WTPA.c        **** 	signed char
 658:WTPA.c        **** 		outputByte;		// What will we pass out at the end?
 659:WTPA.c        **** 	static unsigned char
 660:WTPA.c        **** 		sawtooth;		// Used for generating sawteeth.
 661:WTPA.c        **** 
 662:WTPA.c        **** 	outputByte=0;		// Pass out midscale by default.
 663:WTPA.c        **** 
 664:WTPA.c        **** 	switch(bankStates[BANK_1].audioFunction)
 905               		.loc 1 664 0
 906 0826 8091 0000 		lds r24,bankStates+36
 907 082a 8330      		cpi r24,lo8(3)
 908 082c 01F4      		brne .+2
 909 082e 00C0      		rjmp .L69
 910 0830 00F0      		brlo .L108
 911 0832 8430      		cpi r24,lo8(4)
 912 0834 01F4      		brne .+2
 913 0836 00C0      		rjmp .L70
 914 0838 8530      		cpi r24,lo8(5)
 915 083a 01F0      		breq .L109
 916               	.L101:
 917 083c 80E0      		ldi r24,0
 918               	.LVL20:
 919               	.L66:
 920               	/* epilogue start */
 665:WTPA.c        **** 	{
 666:WTPA.c        **** 
 667:WTPA.c        **** 		case AUDIO_SAWTOOTH:
 668:WTPA.c        **** 		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
 669:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 670:WTPA.c        **** 		break;
 671:WTPA.c        **** 
 672:WTPA.c        **** 		case AUDIO_REALTIME:
 673:WTPA.c        **** 		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No 
 674:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 675:WTPA.c        **** 
 676:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 677:WTPA.c        **** 		{
 678:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 679:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 680:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 681:WTPA.c        **** 		}
 682:WTPA.c        **** 		break;
 683:WTPA.c        **** 
 684:WTPA.c        **** 		case AUDIO_RECORD:
 685:WTPA.c        **** 		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAY
 686:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 687:WTPA.c        **** 
 688:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 689:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 690:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 691:WTPA.c        **** 
 692:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 693:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 694:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 695:WTPA.c        **** 
 696:WTPA.c        **** 		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) 
 697:WTPA.c        **** 
 698:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 699:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 700:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 701:WTPA.c        **** 
 702:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 703:WTPA.c        **** 
 704:WTPA.c        **** 		// Compute address while bus settles.
 705:WTPA.c        **** 
 706:WTPA.c        **** 		bankStates[BANK_1].currentAddress--;									// Next address please.
 707:WTPA.c        **** 		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the
 708:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address 
 709:WTPA.c        **** 
 710:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 711:WTPA.c        **** 		{
 712:WTPA.c        **** 			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 713:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 714:WTPA.c        **** 		}
 715:WTPA.c        **** 
 716:WTPA.c        **** 		// Put data into RAM.
 717:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 718:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 719:WTPA.c        **** 		break;
 720:WTPA.c        **** 
 721:WTPA.c        **** 		case AUDIO_PLAYBACK:
 722:WTPA.c        **** 		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to th
 723:WTPA.c        **** 		// The playback ISR also allows the various effects to change the output.
 724:WTPA.c        **** 		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will expli
 725:WTPA.c        **** 
 726:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 727:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 728:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 729:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 730:WTPA.c        **** 
 731:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 732:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 733:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 734:WTPA.c        **** 
 735:WTPA.c        **** 		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) 
 736:WTPA.c        **** 
 737:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 738:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 739:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 740:WTPA.c        **** 
 741:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 742:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 743:WTPA.c        **** 
 744:WTPA.c        **** 		// Calculate addy while bus settles (used to be nops here)
 745:WTPA.c        **** 
 746:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 747:WTPA.c        **** 		{
 748:WTPA.c        **** 			// Slice first, only worry about forward ###
 749:WTPA.c        **** 
 750:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 751:WTPA.c        **** 			{
 752:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 753:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 754:WTPA.c        **** 			}
 755:WTPA.c        **** 			else	// Slice done, jump to new slice.
 756:WTPA.c        **** 			{
 757:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 758:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 759:WTPA.c        **** 
 760:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 761:WTPA.c        **** 				{
 762:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 763:WTPA.c        **** 				}
 764:WTPA.c        **** 
 765:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 766:WTPA.c        **** 			}
 767:WTPA.c        **** 		}
 768:WTPA.c        **** 		else
 769:WTPA.c        **** 		{
 770:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 771:WTPA.c        **** 			{
 772:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 773:WTPA.c        **** 				{
 774:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 775:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 776:WTPA.c        **** 				}
 777:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 778:WTPA.c        **** 				{
 779:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 780:WTPA.c        **** 				}
 781:WTPA.c        **** 				else
 782:WTPA.c        **** 				{
 783:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 784:WTPA.c        **** 					{
 785:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 786:WTPA.c        **** 					}
 787:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 788:WTPA.c        **** 					{
 789:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 790:WTPA.c        **** 					}
 791:WTPA.c        **** 				}
 792:WTPA.c        **** 			}
 793:WTPA.c        **** 			else	// Going forward through the sample.
 794:WTPA.c        **** 			{
 795:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 796:WTPA.c        **** 				{
 797:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 798:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 799:WTPA.c        **** 				}
 800:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 801:WTPA.c        **** 				{
 802:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 803:WTPA.c        **** 				}
 804:WTPA.c        **** 				else
 805:WTPA.c        **** 				{
 806:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 807:WTPA.c        **** 					{
 808:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 809:WTPA.c        **** 					}
 810:WTPA.c        **** 					else
 811:WTPA.c        **** 					{
 812:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 813:WTPA.c        **** 					}
 814:WTPA.c        **** 				}
 815:WTPA.c        **** 			}
 816:WTPA.c        **** 		}
 817:WTPA.c        **** 
 818:WTPA.c        **** 		// Done with addy, read RAM.
 819:WTPA.c        **** 
 820:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 821:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 822:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 823:WTPA.c        **** 
 824:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 825:WTPA.c        **** 		{
 826:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 827:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 828:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 829:WTPA.c        **** 		}
 830:WTPA.c        **** 		break;
 831:WTPA.c        **** 
 832:WTPA.c        **** 		case AUDIO_OVERDUB:
 833:WTPA.c        **** 		// WTPA has a destructive overdub as of now.
 834:WTPA.c        **** 		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
 835:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 836:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 837:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 838:WTPA.c        **** 
 839:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 840:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 841:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 842:WTPA.c        **** 
 843:WTPA.c        **** 		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) 
 844:WTPA.c        **** 
 845:WTPA.c        **** 		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an opera
 846:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 847:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 848:WTPA.c        **** 
 849:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 850:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 851:WTPA.c        **** 
 852:WTPA.c        **** 		// Do some operations while we wait for the data bus to settle from turnaround.
 853:WTPA.c        **** 
 854:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 855:WTPA.c        **** 		{
 856:WTPA.c        **** 			// Slice first, only worry about forward ###
 857:WTPA.c        **** 
 858:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 859:WTPA.c        **** 			{
 860:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 861:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 862:WTPA.c        **** 			}
 863:WTPA.c        **** 			else	// Slice done, jump to new slice.
 864:WTPA.c        **** 			{
 865:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 866:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 867:WTPA.c        **** 
 868:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 869:WTPA.c        **** 				{
 870:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 871:WTPA.c        **** 				}
 872:WTPA.c        **** 
 873:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 874:WTPA.c        **** 			}
 875:WTPA.c        **** 		}
 876:WTPA.c        **** 		else
 877:WTPA.c        **** 		{
 878:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 879:WTPA.c        **** 			{
 880:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 881:WTPA.c        **** 				{
 882:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 883:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 884:WTPA.c        **** 				}
 885:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 886:WTPA.c        **** 				{
 887:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 888:WTPA.c        **** 				}
 889:WTPA.c        **** 				else
 890:WTPA.c        **** 				{
 891:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 892:WTPA.c        **** 					{
 893:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 894:WTPA.c        **** 					}
 895:WTPA.c        **** 					else	// We're not at the beginning of the loop, keep heading there.
 896:WTPA.c        **** 					{
 897:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 898:WTPA.c        **** 					}
 899:WTPA.c        **** 				}
 900:WTPA.c        **** 			}
 901:WTPA.c        **** 			else	// Going forward through the sample.
 902:WTPA.c        **** 			{
 903:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 904:WTPA.c        **** 				{
 905:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 906:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 907:WTPA.c        **** 				}
 908:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 909:WTPA.c        **** 				{
 910:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 911:WTPA.c        **** 				}
 912:WTPA.c        **** 				else
 913:WTPA.c        **** 				{
 914:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 915:WTPA.c        **** 					{
 916:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 917:WTPA.c        **** 					}
 918:WTPA.c        **** 					else
 919:WTPA.c        **** 					{
 920:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 921:WTPA.c        **** 					}
 922:WTPA.c        **** 				}
 923:WTPA.c        **** 			}
 924:WTPA.c        **** 		}
 925:WTPA.c        **** 
 926:WTPA.c        **** 		// Finished with addy stuff, now finish data transfer
 927:WTPA.c        **** 
 928:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 929:WTPA.c        **** 
 930:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 931:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 932:WTPA.c        **** 
 933:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 934:WTPA.c        **** 		{
 935:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 936:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 937:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 938:WTPA.c        **** 		}
 939:WTPA.c        **** 
 940:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 941:WTPA.c        **** 		if(sum>127)		// Saturate to top rail.
 942:WTPA.c        **** 		{
 943:WTPA.c        **** 			sum=127;
 944:WTPA.c        **** 		}
 945:WTPA.c        **** 		else if(sum<-128) // Saturate to bottom rail.
 946:WTPA.c        **** 		{
 947:WTPA.c        **** 			sum=-128;
 948:WTPA.c        **** 		}
 949:WTPA.c        **** 
 950:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 951:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 952:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 953:WTPA.c        **** 		break;
 954:WTPA.c        **** 	}
 955:WTPA.c        **** 
 956:WTPA.c        **** 	return(outputByte);
 957:WTPA.c        **** }
 921               		.loc 1 957 0
 922 083e 1F91      		pop r17
 923 0840 0F91      		pop r16
 924 0842 0895      		ret
 925               	.LVL21:
 926               	.L108:
 664:WTPA.c        **** 	switch(bankStates[BANK_1].audioFunction)
 927               		.loc 1 664 0
 928 0844 8130      		cpi r24,lo8(1)
 929 0846 01F4      		brne .+2
 930 0848 00C0      		rjmp .L67
 931 084a 8230      		cpi r24,lo8(2)
 932 084c 01F4      		brne .L101
 674:WTPA.c        **** 		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
 933               		.loc 1 674 0
 934 084e 8091 0000 		lds r24,adcByte
 935               	.LVL22:
 676:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 936               		.loc 1 676 0
 937 0852 9091 0000 		lds r25,bankStates+45
 938 0856 9923      		tst r25
 939 0858 01F0      		breq .L66
 940               	.L107:
 826:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 941               		.loc 1 826 0
 942 085a 8058      		subi r24,lo8(-(-128))
 943               	.LVL23:
 827:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 944               		.loc 1 827 0
 945 085c 9091 0000 		lds r25,bankStates+45
 946 0860 2FEF      		ldi r18,lo8(-1)
 947 0862 30E0      		ldi r19,0
 948 0864 092E      		mov r0,r25
 949 0866 00C0      		rjmp 2f
 950               		1:
 951 0868 220F      		lsl r18
 952               		2:
 953 086a 0A94      		dec r0
 954 086c 02F4      		brpl 1b
 955 086e 8223      		and r24,r18
 956               	.LVL24:
 828:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 957               		.loc 1 828 0
 958 0870 8058      		subi r24,lo8(-(-128))
 959               	.LVL25:
 960               	/* epilogue start */
 961               		.loc 1 957 0
 962 0872 1F91      		pop r17
 963 0874 0F91      		pop r16
 964 0876 0895      		ret
 965               	.LVL26:
 966               	.L109:
 835:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 967               		.loc 1 835 0
 968 0878 8091 0000 		lds r24,bankStates+68
 969 087c 9091 0000 		lds r25,bankStates+68+1
 970 0880 A091 0000 		lds r26,bankStates+68+2
 971 0884 B091 0000 		lds r27,bankStates+68+3
 972 0888 85B9      		out 0x5,r24
 836:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 973               		.loc 1 836 0
 974 088a 139A      		sbi 0x2,3
 837:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 975               		.loc 1 837 0
 976 088c 1398      		cbi 0x2,3
 839:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 977               		.loc 1 839 0
 978 088e 8091 0000 		lds r24,bankStates+68
 979 0892 9091 0000 		lds r25,bankStates+68+1
 980 0896 A091 0000 		lds r26,bankStates+68+2
 981 089a B091 0000 		lds r27,bankStates+68+3
 982 089e 892F      		mov r24,r25
 983 08a0 9A2F      		mov r25,r26
 984 08a2 AB2F      		mov r26,r27
 985 08a4 BB27      		clr r27
 986 08a6 85B9      		out 0x5,r24
 840:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 987               		.loc 1 840 0
 988 08a8 149A      		sbi 0x2,4
 841:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 989               		.loc 1 841 0
 990 08aa 1498      		cbi 0x2,4
 846:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 991               		.loc 1 846 0
 992 08ac 88B1      		in r24,0x8
 993 08ae 887F      		andi r24,lo8(-8)
 994 08b0 88B9      		out 0x8,r24
 847:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 995               		.loc 1 847 0
 996 08b2 28B1      		in r18,0x8
 997 08b4 8091 0000 		lds r24,bankStates+68
 998 08b8 9091 0000 		lds r25,bankStates+68+1
 999 08bc A091 0000 		lds r26,bankStates+68+2
 1000 08c0 B091 0000 		lds r27,bankStates+68+3
 1001 08c4 8A2F      		mov r24,r26
 1002 08c6 8770      		andi r24,lo8(7)
 1003 08c8 822B      		or r24,r18
 1004 08ca 88B9      		out 0x8,r24
 849:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1005               		.loc 1 849 0
 1006 08cc 14B8      		out 0x4,__zero_reg__
 850:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1007               		.loc 1 850 0
 1008 08ce 1298      		cbi 0x2,2
 854:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1009               		.loc 1 854 0
 1010 08d0 8091 0000 		lds r24,bankStates+43
 1011 08d4 8823      		tst r24
 1012 08d6 01F4      		brne .+2
 1013 08d8 00C0      		rjmp .L87
 858:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1014               		.loc 1 858 0
 1015 08da 8091 0000 		lds r24,sliceRemaining+4
 1016 08de 9091 0000 		lds r25,sliceRemaining+4+1
 1017 08e2 A091 0000 		lds r26,sliceRemaining+4+2
 1018 08e6 B091 0000 		lds r27,sliceRemaining+4+3
 1019 08ea 892B      		or r24,r25
 1020 08ec 8A2B      		or r24,r26
 1021 08ee 8B2B      		or r24,r27
 1022 08f0 01F0      		breq .+2
 1023 08f2 00C0      		rjmp .L110
 865:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1024               		.loc 1 865 0
 1025 08f4 8091 0000 		lds r24,sliceSize+4
 1026 08f8 9091 0000 		lds r25,sliceSize+4+1
 1027 08fc A091 0000 		lds r26,sliceSize+4+2
 1028 0900 B091 0000 		lds r27,sliceSize+4+3
 1029 0904 8093 0000 		sts sliceRemaining+4,r24
 1030 0908 9093 0000 		sts sliceRemaining+4+1,r25
 1031 090c A093 0000 		sts sliceRemaining+4+2,r26
 1032 0910 B093 0000 		sts sliceRemaining+4+3,r27
 866:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1033               		.loc 1 866 0
 1034 0914 8091 0000 		lds r24,granularPositionArrayPointer+1
 1035 0918 8F5F      		subi r24,lo8(-(1))
 1036 091a 8093 0000 		sts granularPositionArrayPointer+1,r24
 868:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1037               		.loc 1 868 0
 1038 091e 9091 0000 		lds r25,granularPositionArrayPointer+1
 1039 0922 8091 0000 		lds r24,bankStates+43
 1040 0926 9817      		cp r25,r24
 1041 0928 01F4      		brne .+2
 1042 092a 00C0      		rjmp .L111
 1043               	.L90:
 873:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1044               		.loc 1 873 0
 1045 092c E091 0000 		lds r30,granularPositionArrayPointer+1
 1046 0930 2091 0000 		lds r18,sliceSize+4
 1047 0934 3091 0000 		lds r19,sliceSize+4+1
 1048 0938 4091 0000 		lds r20,sliceSize+4+2
 1049 093c 5091 0000 		lds r21,sliceSize+4+3
 1050 0940 F0E0      		ldi r31,0
 1051 0942 E050      		subi r30,lo8(-(granularPositionArray+128))
 1052 0944 F040      		sbci r31,hi8(-(granularPositionArray+128))
 1053 0946 A081      		ld r26,Z
 1054 0948 B0E0      		ldi r27,0
 1055 094a 0E94 0000 		call __muluhisi3
 1056 094e 0FEF      		ldi r16,lo8(-1)
 1057 0950 1FEF      		ldi r17,lo8(-1)
 1058 0952 27E0      		ldi r18,lo8(7)
 1059 0954 30E0      		ldi r19,0
 1060 0956 061B      		sub r16,r22
 1061 0958 170B      		sbc r17,r23
 1062 095a 280B      		sbc r18,r24
 1063 095c 390B      		sbc r19,r25
 1064 095e 0093 0000 		sts bankStates+68,r16
 1065 0962 1093 0000 		sts bankStates+68+1,r17
 1066 0966 2093 0000 		sts bankStates+68+2,r18
 1067 096a 3093 0000 		sts bankStates+68+3,r19
 1068 096e 00C0      		rjmp .L89
 1069               	.L70:
 727:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 1070               		.loc 1 727 0
 1071 0970 8091 0000 		lds r24,bankStates+68
 1072 0974 9091 0000 		lds r25,bankStates+68+1
 1073 0978 A091 0000 		lds r26,bankStates+68+2
 1074 097c B091 0000 		lds r27,bankStates+68+3
 1075 0980 85B9      		out 0x5,r24
 728:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 1076               		.loc 1 728 0
 1077 0982 139A      		sbi 0x2,3
 729:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 1078               		.loc 1 729 0
 1079 0984 1398      		cbi 0x2,3
 731:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 1080               		.loc 1 731 0
 1081 0986 8091 0000 		lds r24,bankStates+68
 1082 098a 9091 0000 		lds r25,bankStates+68+1
 1083 098e A091 0000 		lds r26,bankStates+68+2
 1084 0992 B091 0000 		lds r27,bankStates+68+3
 1085 0996 892F      		mov r24,r25
 1086 0998 9A2F      		mov r25,r26
 1087 099a AB2F      		mov r26,r27
 1088 099c BB27      		clr r27
 1089 099e 85B9      		out 0x5,r24
 732:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 1090               		.loc 1 732 0
 1091 09a0 149A      		sbi 0x2,4
 733:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 1092               		.loc 1 733 0
 1093 09a2 1498      		cbi 0x2,4
 738:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 1094               		.loc 1 738 0
 1095 09a4 88B1      		in r24,0x8
 1096 09a6 887F      		andi r24,lo8(-8)
 1097 09a8 88B9      		out 0x8,r24
 739:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 1098               		.loc 1 739 0
 1099 09aa 28B1      		in r18,0x8
 1100 09ac 8091 0000 		lds r24,bankStates+68
 1101 09b0 9091 0000 		lds r25,bankStates+68+1
 1102 09b4 A091 0000 		lds r26,bankStates+68+2
 1103 09b8 B091 0000 		lds r27,bankStates+68+3
 1104 09bc 8A2F      		mov r24,r26
 1105 09be 8770      		andi r24,lo8(7)
 1106 09c0 822B      		or r24,r18
 1107 09c2 88B9      		out 0x8,r24
 741:WTPA.c        **** 		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 1108               		.loc 1 741 0
 1109 09c4 14B8      		out 0x4,__zero_reg__
 742:WTPA.c        **** 		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 1110               		.loc 1 742 0
 1111 09c6 1298      		cbi 0x2,2
 746:WTPA.c        **** 		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
 1112               		.loc 1 746 0
 1113 09c8 8091 0000 		lds r24,bankStates+43
 1114 09cc 8823      		tst r24
 1115 09ce 01F4      		brne .+2
 1116 09d0 00C0      		rjmp .L75
 750:WTPA.c        **** 			if(sliceRemaining[BANK_1])	// Moving through our current slice?
 1117               		.loc 1 750 0
 1118 09d2 8091 0000 		lds r24,sliceRemaining+4
 1119 09d6 9091 0000 		lds r25,sliceRemaining+4+1
 1120 09da A091 0000 		lds r26,sliceRemaining+4+2
 1121 09de B091 0000 		lds r27,sliceRemaining+4+3
 1122 09e2 892B      		or r24,r25
 1123 09e4 8A2B      		or r24,r26
 1124 09e6 8B2B      		or r24,r27
 1125 09e8 01F0      		breq .+2
 1126 09ea 00C0      		rjmp .L112
 757:WTPA.c        **** 				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
 1127               		.loc 1 757 0
 1128 09ec 8091 0000 		lds r24,sliceSize+4
 1129 09f0 9091 0000 		lds r25,sliceSize+4+1
 1130 09f4 A091 0000 		lds r26,sliceSize+4+2
 1131 09f8 B091 0000 		lds r27,sliceSize+4+3
 1132 09fc 8093 0000 		sts sliceRemaining+4,r24
 1133 0a00 9093 0000 		sts sliceRemaining+4+1,r25
 1134 0a04 A093 0000 		sts sliceRemaining+4+2,r26
 1135 0a08 B093 0000 		sts sliceRemaining+4+3,r27
 758:WTPA.c        **** 				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
 1136               		.loc 1 758 0
 1137 0a0c 8091 0000 		lds r24,granularPositionArrayPointer+1
 1138 0a10 8F5F      		subi r24,lo8(-(1))
 1139 0a12 8093 0000 		sts granularPositionArrayPointer+1,r24
 760:WTPA.c        **** 				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
 1140               		.loc 1 760 0
 1141 0a16 9091 0000 		lds r25,granularPositionArrayPointer+1
 1142 0a1a 8091 0000 		lds r24,bankStates+43
 1143 0a1e 9817      		cp r25,r24
 1144 0a20 01F4      		brne .+2
 1145 0a22 00C0      		rjmp .L113
 1146               	.L78:
 765:WTPA.c        **** 				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granular
 1147               		.loc 1 765 0
 1148 0a24 E091 0000 		lds r30,granularPositionArrayPointer+1
 1149 0a28 2091 0000 		lds r18,sliceSize+4
 1150 0a2c 3091 0000 		lds r19,sliceSize+4+1
 1151 0a30 4091 0000 		lds r20,sliceSize+4+2
 1152 0a34 5091 0000 		lds r21,sliceSize+4+3
 1153 0a38 F0E0      		ldi r31,0
 1154 0a3a E050      		subi r30,lo8(-(granularPositionArray+128))
 1155 0a3c F040      		sbci r31,hi8(-(granularPositionArray+128))
 1156 0a3e A081      		ld r26,Z
 1157 0a40 B0E0      		ldi r27,0
 1158 0a42 0E94 0000 		call __muluhisi3
 1159 0a46 0FEF      		ldi r16,lo8(-1)
 1160 0a48 1FEF      		ldi r17,lo8(-1)
 1161 0a4a 27E0      		ldi r18,lo8(7)
 1162 0a4c 30E0      		ldi r19,0
 1163 0a4e 061B      		sub r16,r22
 1164 0a50 170B      		sbc r17,r23
 1165 0a52 280B      		sbc r18,r24
 1166 0a54 390B      		sbc r19,r25
 1167 0a56 0093 0000 		sts bankStates+68,r16
 1168 0a5a 1093 0000 		sts bankStates+68+1,r17
 1169 0a5e 2093 0000 		sts bankStates+68+2,r18
 1170 0a62 3093 0000 		sts bankStates+68+3,r19
 1171 0a66 00C0      		rjmp .L77
 1172               	.L67:
 669:WTPA.c        **** 		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
 1173               		.loc 1 669 0
 1174 0a68 8091 0000 		lds r24,sawtooth.1769
 1175               	.LVL27:
 1176 0a6c 982F      		mov r25,r24
 1177 0a6e 9F5F      		subi r25,lo8(-(1))
 1178 0a70 9093 0000 		sts sawtooth.1769,r25
 1179               	.LVL28:
 1180               	/* epilogue start */
 1181               		.loc 1 957 0
 1182 0a74 1F91      		pop r17
 1183 0a76 0F91      		pop r16
 1184 0a78 0895      		ret
 1185               	.LVL29:
 1186               	.L69:
 686:WTPA.c        **** 		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of th
 1187               		.loc 1 686 0
 1188 0a7a 8FEF      		ldi r24,lo8(-1)
 1189 0a7c 84B9      		out 0x4,r24
 688:WTPA.c        **** 		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
 1190               		.loc 1 688 0
 1191 0a7e 8091 0000 		lds r24,bankStates+68
 1192 0a82 9091 0000 		lds r25,bankStates+68+1
 1193 0a86 A091 0000 		lds r26,bankStates+68+2
 1194 0a8a B091 0000 		lds r27,bankStates+68+3
 1195 0a8e 85B9      		out 0x5,r24
 689:WTPA.c        **** 		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
 1196               		.loc 1 689 0
 1197 0a90 139A      		sbi 0x2,3
 690:WTPA.c        **** 		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
 1198               		.loc 1 690 0
 1199 0a92 1398      		cbi 0x2,3
 692:WTPA.c        **** 		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the
 1200               		.loc 1 692 0
 1201 0a94 8091 0000 		lds r24,bankStates+68
 1202 0a98 9091 0000 		lds r25,bankStates+68+1
 1203 0a9c A091 0000 		lds r26,bankStates+68+2
 1204 0aa0 B091 0000 		lds r27,bankStates+68+3
 1205 0aa4 892F      		mov r24,r25
 1206 0aa6 9A2F      		mov r25,r26
 1207 0aa8 AB2F      		mov r26,r27
 1208 0aaa BB27      		clr r27
 1209 0aac 85B9      		out 0x5,r24
 693:WTPA.c        **** 		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
 1210               		.loc 1 693 0
 1211 0aae 149A      		sbi 0x2,4
 694:WTPA.c        **** 		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
 1212               		.loc 1 694 0
 1213 0ab0 1498      		cbi 0x2,4
 699:WTPA.c        **** 		PORTC&=~0x07;											// Clear PORTC bits 0-2
 1214               		.loc 1 699 0
 1215 0ab2 88B1      		in r24,0x8
 1216 0ab4 887F      		andi r24,lo8(-8)
 1217 0ab6 88B9      		out 0x8,r24
 700:WTPA.c        **** 		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
 1218               		.loc 1 700 0
 1219 0ab8 28B1      		in r18,0x8
 1220 0aba 8091 0000 		lds r24,bankStates+68
 1221 0abe 9091 0000 		lds r25,bankStates+68+1
 1222 0ac2 A091 0000 		lds r26,bankStates+68+2
 1223 0ac6 B091 0000 		lds r27,bankStates+68+3
 1224 0aca 8A2F      		mov r24,r26
 1225 0acc 8770      		andi r24,lo8(7)
 1226 0ace 822B      		or r24,r18
 1227 0ad0 88B9      		out 0x8,r24
 702:WTPA.c        **** 		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
 1228               		.loc 1 702 0
 1229 0ad2 8091 0000 		lds r24,adcByte
 1230 0ad6 85B9      		out 0x5,r24
 706:WTPA.c        **** 		bankStates[BANK_1].currentAddress--;									// Next address please.
 1231               		.loc 1 706 0
 1232 0ad8 8091 0000 		lds r24,bankStates+68
 1233 0adc 9091 0000 		lds r25,bankStates+68+1
 1234 0ae0 A091 0000 		lds r26,bankStates+68+2
 1235 0ae4 B091 0000 		lds r27,bankStates+68+3
 1236 0ae8 0197      		sbiw r24,1
 1237 0aea A109      		sbc r26,__zero_reg__
 1238 0aec B109      		sbc r27,__zero_reg__
 1239 0aee 8093 0000 		sts bankStates+68,r24
 1240 0af2 9093 0000 		sts bankStates+68+1,r25
 1241 0af6 A093 0000 		sts bankStates+68+2,r26
 1242 0afa B093 0000 		sts bankStates+68+3,r27
 707:WTPA.c        **** 		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the
 1243               		.loc 1 707 0
 1244 0afe 8091 0000 		lds r24,bankStates+68
 1245 0b02 9091 0000 		lds r25,bankStates+68+1
 1246 0b06 A091 0000 		lds r26,bankStates+68+2
 1247 0b0a B091 0000 		lds r27,bankStates+68+3
 1248 0b0e 8093 0000 		sts bankStates+49,r24
 1249 0b12 9093 0000 		sts bankStates+49+1,r25
 1250 0b16 A093 0000 		sts bankStates+49+2,r26
 1251 0b1a B093 0000 		sts bankStates+49+3,r27
 708:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address 
 1252               		.loc 1 708 0
 1253 0b1e 8091 0000 		lds r24,bankStates+68
 1254 0b22 9091 0000 		lds r25,bankStates+68+1
 1255 0b26 A091 0000 		lds r26,bankStates+68+2
 1256 0b2a B091 0000 		lds r27,bankStates+68+3
 1257 0b2e 8093 0000 		sts bankStates+57,r24
 1258 0b32 9093 0000 		sts bankStates+57+1,r25
 1259 0b36 A093 0000 		sts bankStates+57+2,r26
 1260 0b3a B093 0000 		sts bankStates+57+3,r27
 710:WTPA.c        **** 		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?
 1261               		.loc 1 710 0
 1262 0b3e 4091 0000 		lds r20,bankStates+13
 1263 0b42 5091 0000 		lds r21,bankStates+13+1
 1264 0b46 6091 0000 		lds r22,bankStates+13+2
 1265 0b4a 7091 0000 		lds r23,bankStates+13+3
 1266 0b4e 8091 0000 		lds r24,bankStates+49
 1267 0b52 9091 0000 		lds r25,bankStates+49+1
 1268 0b56 A091 0000 		lds r26,bankStates+49+2
 1269 0b5a B091 0000 		lds r27,bankStates+49+3
 1270 0b5e 4817      		cp r20,r24
 1271 0b60 5907      		cpc r21,r25
 1272 0b62 6A07      		cpc r22,r26
 1273 0b64 7B07      		cpc r23,r27
 1274 0b66 00F0      		brlo .L74
 712:WTPA.c        **** 			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
 1275               		.loc 1 712 0
 1276 0b68 1092 0000 		sts bankStates+36,__zero_reg__
 713:WTPA.c        **** 			outOfRam=true;									// Signal mainline code that we're out of memory.
 1277               		.loc 1 713 0
 1278 0b6c 81E0      		ldi r24,lo8(1)
 1279 0b6e 8093 0000 		sts outOfRam,r24
 1280               	.L74:
 717:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 1281               		.loc 1 717 0
 1282 0b72 1198      		cbi 0x2,1
 718:WTPA.c        **** 		PORTA|=(Om_RAM_WE);					// Disbale writes.
 1283               		.loc 1 718 0
 1284 0b74 119A      		sbi 0x2,1
 719:WTPA.c        **** 		break;
 1285               		.loc 1 719 0
 1286 0b76 80E0      		ldi r24,0
 1287               	.LVL30:
 1288               	/* epilogue start */
 1289               		.loc 1 957 0
 1290 0b78 1F91      		pop r17
 1291 0b7a 0F91      		pop r16
 1292 0b7c 0895      		ret
 1293               	.LVL31:
 1294               	.L87:
 878:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1295               		.loc 1 878 0
 1296 0b7e 8091 0000 		lds r24,bankStates+40
 880:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1297               		.loc 1 880 0
 1298 0b82 4091 0000 		lds r20,bankStates+68
 1299 0b86 5091 0000 		lds r21,bankStates+68+1
 1300 0b8a 6091 0000 		lds r22,bankStates+68+2
 1301 0b8e 7091 0000 		lds r23,bankStates+68+3
 878:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1302               		.loc 1 878 0
 1303 0b92 8823      		tst r24
 1304 0b94 01F4      		brne .+2
 1305 0b96 00C0      		rjmp .L114
 903:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1306               		.loc 1 903 0
 1307 0b98 8091 0000 		lds r24,bankStates+57
 1308 0b9c 9091 0000 		lds r25,bankStates+57+1
 1309 0ba0 A091 0000 		lds r26,bankStates+57+2
 1310 0ba4 B091 0000 		lds r27,bankStates+57+3
 1311 0ba8 4817      		cp r20,r24
 1312 0baa 5907      		cpc r21,r25
 1313 0bac 6A07      		cpc r22,r26
 1314 0bae 7B07      		cpc r23,r27
 1315 0bb0 01F4      		brne .+2
 1316 0bb2 00C0      		rjmp .L115
 1317               	.L95:
 908:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1318               		.loc 1 908 0
 1319 0bb4 4091 0000 		lds r20,bankStates+68
 1320 0bb8 5091 0000 		lds r21,bankStates+68+1
 1321 0bbc 6091 0000 		lds r22,bankStates+68+2
 1322 0bc0 7091 0000 		lds r23,bankStates+68+3
 1323 0bc4 8091 0000 		lds r24,bankStates+57
 1324 0bc8 9091 0000 		lds r25,bankStates+57+1
 1325 0bcc A091 0000 		lds r26,bankStates+57+2
 1326 0bd0 B091 0000 		lds r27,bankStates+57+3
 1327 0bd4 4817      		cp r20,r24
 1328 0bd6 5907      		cpc r21,r25
 1329 0bd8 6A07      		cpc r22,r26
 1330 0bda 7B07      		cpc r23,r27
 1331 0bdc 01F4      		brne .+2
 1332 0bde 00C0      		rjmp .L116
 914:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1333               		.loc 1 914 0
 1334 0be0 4091 0000 		lds r20,bankStates+68
 1335 0be4 5091 0000 		lds r21,bankStates+68+1
 1336 0be8 6091 0000 		lds r22,bankStates+68+2
 1337 0bec 7091 0000 		lds r23,bankStates+68+3
 1338 0bf0 8091 0000 		lds r24,bankStates+49
 1339 0bf4 9091 0000 		lds r25,bankStates+49+1
 1340 0bf8 A091 0000 		lds r26,bankStates+49+2
 1341 0bfc B091 0000 		lds r27,bankStates+49+3
 1342 0c00 4817      		cp r20,r24
 1343 0c02 5907      		cpc r21,r25
 1344 0c04 6A07      		cpc r22,r26
 1345 0c06 7B07      		cpc r23,r27
 1346 0c08 01F4      		brne .+2
 1347 0c0a 00C0      		rjmp .L117
 920:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1348               		.loc 1 920 0
 1349 0c0c 8091 0000 		lds r24,bankStates+68
 1350 0c10 9091 0000 		lds r25,bankStates+68+1
 1351 0c14 A091 0000 		lds r26,bankStates+68+2
 1352 0c18 B091 0000 		lds r27,bankStates+68+3
 1353 0c1c 0197      		sbiw r24,1
 1354 0c1e A109      		sbc r26,__zero_reg__
 1355 0c20 B109      		sbc r27,__zero_reg__
 1356 0c22 8093 0000 		sts bankStates+68,r24
 1357 0c26 9093 0000 		sts bankStates+68+1,r25
 1358 0c2a A093 0000 		sts bankStates+68+2,r26
 1359 0c2e B093 0000 		sts bankStates+68+3,r27
 1360               	.L89:
 928:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the 
 1361               		.loc 1 928 0
 1362 0c32 83B1      		in r24,0x3
 1363               	.LVL32:
 930:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1364               		.loc 1 930 0
 1365 0c34 129A      		sbi 0x2,2
 931:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1366               		.loc 1 931 0
 1367 0c36 9FEF      		ldi r25,lo8(-1)
 1368 0c38 94B9      		out 0x4,r25
 933:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1369               		.loc 1 933 0
 1370 0c3a 9091 0000 		lds r25,bankStates+45
 1371 0c3e 9923      		tst r25
 1372 0c40 01F0      		breq .L98
 935:WTPA.c        **** 			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
 1373               		.loc 1 935 0
 1374 0c42 8058      		subi r24,lo8(-(-128))
 1375               	.LVL33:
 936:WTPA.c        **** 			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're suppos
 1376               		.loc 1 936 0
 1377 0c44 9091 0000 		lds r25,bankStates+45
 1378 0c48 2FEF      		ldi r18,lo8(-1)
 1379 0c4a 30E0      		ldi r19,0
 1380 0c4c 092E      		mov r0,r25
 1381 0c4e 00C0      		rjmp 2f
 1382               		1:
 1383 0c50 220F      		lsl r18
 1384               		2:
 1385 0c52 0A94      		dec r0
 1386 0c54 02F4      		brpl 1b
 1387 0c56 8223      		and r24,r18
 1388               	.LVL34:
 937:WTPA.c        **** 			outputByte^=0x80;											// Bring it back to signed.
 1389               		.loc 1 937 0
 1390 0c58 8058      		subi r24,lo8(-(-128))
 1391               	.LVL35:
 1392               	.L98:
 940:WTPA.c        **** 		sum=outputByte+adcByte;			// Do saturated add mess.
 1393               		.loc 1 940 0
 1394 0c5a 2091 0000 		lds r18,adcByte
 1395 0c5e 3327      		clr r19
 1396 0c60 27FD      		sbrc r18,7
 1397 0c62 3095      		com r19
 1398 0c64 280F      		add r18,r24
 1399 0c66 311D      		adc r19,__zero_reg__
 1400 0c68 87FD      		sbrc r24,7
 1401 0c6a 3A95      		dec r19
 1402 0c6c 2038      		cpi r18,-128
 1403 0c6e 9FEF      		ldi r25,-1
 1404 0c70 3907      		cpc r19,r25
 1405 0c72 04F4      		brge .L99
 1406 0c74 20E8      		ldi r18,lo8(-128)
 1407 0c76 3FEF      		ldi r19,lo8(-1)
 1408               	.L99:
 1409               	.LVL36:
 950:WTPA.c        **** 		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed fr
 1410               		.loc 1 950 0
 1411 0c78 2038      		cpi r18,-128
 1412 0c7a 3105      		cpc r19,__zero_reg__
 1413 0c7c 04F0      		brlt .L100
 1414 0c7e 2FE7      		ldi r18,lo8(127)
 1415 0c80 30E0      		ldi r19,0
 1416               	.LVL37:
 1417               	.L100:
 1418 0c82 25B9      		out 0x5,r18
 951:WTPA.c        **** 		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
 1419               		.loc 1 951 0
 1420 0c84 1198      		cbi 0x2,1
 952:WTPA.c        **** 		PORTA|=(Om_RAM_WE);			// Disbale writes.
 1421               		.loc 1 952 0
 1422 0c86 119A      		sbi 0x2,1
 1423               	.LVL38:
 1424               	/* epilogue start */
 1425               		.loc 1 957 0
 1426 0c88 1F91      		pop r17
 1427 0c8a 0F91      		pop r16
 1428 0c8c 0895      		ret
 1429               	.LVL39:
 1430               	.L75:
 770:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1431               		.loc 1 770 0
 1432 0c8e 8091 0000 		lds r24,bankStates+40
 772:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1433               		.loc 1 772 0
 1434 0c92 4091 0000 		lds r20,bankStates+68
 1435 0c96 5091 0000 		lds r21,bankStates+68+1
 1436 0c9a 6091 0000 		lds r22,bankStates+68+2
 1437 0c9e 7091 0000 		lds r23,bankStates+68+3
 770:WTPA.c        **** 			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
 1438               		.loc 1 770 0
 1439 0ca2 8823      		tst r24
 1440 0ca4 01F4      		brne .+2
 1441 0ca6 00C0      		rjmp .L118
 795:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1442               		.loc 1 795 0
 1443 0ca8 8091 0000 		lds r24,bankStates+57
 1444 0cac 9091 0000 		lds r25,bankStates+57+1
 1445 0cb0 A091 0000 		lds r26,bankStates+57+2
 1446 0cb4 B091 0000 		lds r27,bankStates+57+3
 1447 0cb8 4817      		cp r20,r24
 1448 0cba 5907      		cpc r21,r25
 1449 0cbc 6A07      		cpc r22,r26
 1450 0cbe 7B07      		cpc r23,r27
 1451 0cc0 01F4      		brne .+2
 1452 0cc2 00C0      		rjmp .L119
 1453               	.L83:
 800:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're loo
 1454               		.loc 1 800 0
 1455 0cc4 4091 0000 		lds r20,bankStates+68
 1456 0cc8 5091 0000 		lds r21,bankStates+68+1
 1457 0ccc 6091 0000 		lds r22,bankStates+68+2
 1458 0cd0 7091 0000 		lds r23,bankStates+68+3
 1459 0cd4 8091 0000 		lds r24,bankStates+57
 1460 0cd8 9091 0000 		lds r25,bankStates+57+1
 1461 0cdc A091 0000 		lds r26,bankStates+57+2
 1462 0ce0 B091 0000 		lds r27,bankStates+57+3
 1463 0ce4 4817      		cp r20,r24
 1464 0ce6 5907      		cpc r21,r25
 1465 0ce8 6A07      		cpc r22,r26
 1466 0cea 7B07      		cpc r23,r27
 1467 0cec 01F4      		brne .+2
 1468 0cee 00C0      		rjmp .L120
 806:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop 
 1469               		.loc 1 806 0
 1470 0cf0 4091 0000 		lds r20,bankStates+68
 1471 0cf4 5091 0000 		lds r21,bankStates+68+1
 1472 0cf8 6091 0000 		lds r22,bankStates+68+2
 1473 0cfc 7091 0000 		lds r23,bankStates+68+3
 1474 0d00 8091 0000 		lds r24,bankStates+49
 1475 0d04 9091 0000 		lds r25,bankStates+49+1
 1476 0d08 A091 0000 		lds r26,bankStates+49+2
 1477 0d0c B091 0000 		lds r27,bankStates+49+3
 1478 0d10 4817      		cp r20,r24
 1479 0d12 5907      		cpc r21,r25
 1480 0d14 6A07      		cpc r22,r26
 1481 0d16 7B07      		cpc r23,r27
 1482 0d18 01F4      		brne .+2
 1483 0d1a 00C0      		rjmp .L121
 812:WTPA.c        **** 						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
 1484               		.loc 1 812 0
 1485 0d1c 8091 0000 		lds r24,bankStates+68
 1486 0d20 9091 0000 		lds r25,bankStates+68+1
 1487 0d24 A091 0000 		lds r26,bankStates+68+2
 1488 0d28 B091 0000 		lds r27,bankStates+68+3
 1489 0d2c 0197      		sbiw r24,1
 1490 0d2e A109      		sbc r26,__zero_reg__
 1491 0d30 B109      		sbc r27,__zero_reg__
 1492 0d32 8093 0000 		sts bankStates+68,r24
 1493 0d36 9093 0000 		sts bankStates+68+1,r25
 1494 0d3a A093 0000 		sts bankStates+68+2,r26
 1495 0d3e B093 0000 		sts bankStates+68+3,r27
 1496               	.L77:
 820:WTPA.c        **** 		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 1497               		.loc 1 820 0
 1498 0d42 83B1      		in r24,0x3
 1499               	.LVL40:
 821:WTPA.c        **** 		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 1500               		.loc 1 821 0
 1501 0d44 129A      		sbi 0x2,2
 822:WTPA.c        **** 		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 1502               		.loc 1 822 0
 1503 0d46 9FEF      		ldi r25,lo8(-1)
 1504 0d48 94B9      		out 0x4,r25
 824:WTPA.c        **** 		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
 1505               		.loc 1 824 0
 1506 0d4a 9091 0000 		lds r25,bankStates+45
 1507 0d4e 9923      		tst r25
 1508 0d50 01F4      		brne .+2
 1509 0d52 00C0      		rjmp .L66
 1510 0d54 00C0      		rjmp .L107
 1511               	.LVL41:
 1512               	.L118:
 772:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1513               		.loc 1 772 0
 1514 0d56 8091 0000 		lds r24,bankStates+61
 1515 0d5a 9091 0000 		lds r25,bankStates+61+1
 1516 0d5e A091 0000 		lds r26,bankStates+61+2
 1517 0d62 B091 0000 		lds r27,bankStates+61+3
 1518 0d66 4817      		cp r20,r24
 1519 0d68 5907      		cpc r21,r25
 1520 0d6a 6A07      		cpc r22,r26
 1521 0d6c 7B07      		cpc r23,r27
 1522 0d6e 01F4      		brne .+2
 1523 0d70 00C0      		rjmp .L122
 1524               	.L80:
 777:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1525               		.loc 1 777 0
 1526 0d72 4091 0000 		lds r20,bankStates+68
 1527 0d76 5091 0000 		lds r21,bankStates+68+1
 1528 0d7a 6091 0000 		lds r22,bankStates+68+2
 1529 0d7e 7091 0000 		lds r23,bankStates+68+3
 1530 0d82 8091 0000 		lds r24,bankStates+61
 1531 0d86 9091 0000 		lds r25,bankStates+61+1
 1532 0d8a A091 0000 		lds r26,bankStates+61+2
 1533 0d8e B091 0000 		lds r27,bankStates+61+3
 1534 0d92 4817      		cp r20,r24
 1535 0d94 5907      		cpc r21,r25
 1536 0d96 6A07      		cpc r22,r26
 1537 0d98 7B07      		cpc r23,r27
 1538 0d9a 01F4      		brne .+2
 1539 0d9c 00C0      		rjmp .L123
 783:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1540               		.loc 1 783 0
 1541 0d9e 4091 0000 		lds r20,bankStates+68
 1542 0da2 5091 0000 		lds r21,bankStates+68+1
 1543 0da6 6091 0000 		lds r22,bankStates+68+2
 1544 0daa 7091 0000 		lds r23,bankStates+68+3
 1545 0dae 8091 0000 		lds r24,bankStates+53
 1546 0db2 9091 0000 		lds r25,bankStates+53+1
 1547 0db6 A091 0000 		lds r26,bankStates+53+2
 1548 0dba B091 0000 		lds r27,bankStates+53+3
 1549 0dbe 4817      		cp r20,r24
 1550 0dc0 5907      		cpc r21,r25
 1551 0dc2 6A07      		cpc r22,r26
 1552 0dc4 7B07      		cpc r23,r27
 1553 0dc6 01F4      		brne .+2
 1554 0dc8 00C0      		rjmp .L124
 789:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1555               		.loc 1 789 0
 1556 0dca 8091 0000 		lds r24,bankStates+68
 1557 0dce 9091 0000 		lds r25,bankStates+68+1
 1558 0dd2 A091 0000 		lds r26,bankStates+68+2
 1559 0dd6 B091 0000 		lds r27,bankStates+68+3
 1560 0dda 0196      		adiw r24,1
 1561 0ddc A11D      		adc r26,__zero_reg__
 1562 0dde B11D      		adc r27,__zero_reg__
 1563 0de0 8093 0000 		sts bankStates+68,r24
 1564 0de4 9093 0000 		sts bankStates+68+1,r25
 1565 0de8 A093 0000 		sts bankStates+68+2,r26
 1566 0dec B093 0000 		sts bankStates+68+3,r27
 1567 0df0 00C0      		rjmp .L77
 1568               	.L112:
 752:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1569               		.loc 1 752 0
 1570 0df2 8091 0000 		lds r24,bankStates+68
 1571 0df6 9091 0000 		lds r25,bankStates+68+1
 1572 0dfa A091 0000 		lds r26,bankStates+68+2
 1573 0dfe B091 0000 		lds r27,bankStates+68+3
 1574 0e02 0197      		sbiw r24,1
 1575 0e04 A109      		sbc r26,__zero_reg__
 1576 0e06 B109      		sbc r27,__zero_reg__
 1577 0e08 8093 0000 		sts bankStates+68,r24
 1578 0e0c 9093 0000 		sts bankStates+68+1,r25
 1579 0e10 A093 0000 		sts bankStates+68+2,r26
 1580 0e14 B093 0000 		sts bankStates+68+3,r27
 753:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1581               		.loc 1 753 0
 1582 0e18 8091 0000 		lds r24,sliceRemaining+4
 1583 0e1c 9091 0000 		lds r25,sliceRemaining+4+1
 1584 0e20 A091 0000 		lds r26,sliceRemaining+4+2
 1585 0e24 B091 0000 		lds r27,sliceRemaining+4+3
 1586 0e28 0197      		sbiw r24,1
 1587 0e2a A109      		sbc r26,__zero_reg__
 1588 0e2c B109      		sbc r27,__zero_reg__
 1589 0e2e 8093 0000 		sts sliceRemaining+4,r24
 1590 0e32 9093 0000 		sts sliceRemaining+4+1,r25
 1591 0e36 A093 0000 		sts sliceRemaining+4+2,r26
 1592 0e3a B093 0000 		sts sliceRemaining+4+3,r27
 1593 0e3e 00C0      		rjmp .L77
 1594               	.L110:
 860:WTPA.c        **** 				bankStates[BANK_1].currentAddress--;
 1595               		.loc 1 860 0
 1596 0e40 8091 0000 		lds r24,bankStates+68
 1597 0e44 9091 0000 		lds r25,bankStates+68+1
 1598 0e48 A091 0000 		lds r26,bankStates+68+2
 1599 0e4c B091 0000 		lds r27,bankStates+68+3
 1600 0e50 0197      		sbiw r24,1
 1601 0e52 A109      		sbc r26,__zero_reg__
 1602 0e54 B109      		sbc r27,__zero_reg__
 1603 0e56 8093 0000 		sts bankStates+68,r24
 1604 0e5a 9093 0000 		sts bankStates+68+1,r25
 1605 0e5e A093 0000 		sts bankStates+68+2,r26
 1606 0e62 B093 0000 		sts bankStates+68+3,r27
 861:WTPA.c        **** 				sliceRemaining[BANK_1]--;
 1607               		.loc 1 861 0
 1608 0e66 8091 0000 		lds r24,sliceRemaining+4
 1609 0e6a 9091 0000 		lds r25,sliceRemaining+4+1
 1610 0e6e A091 0000 		lds r26,sliceRemaining+4+2
 1611 0e72 B091 0000 		lds r27,sliceRemaining+4+3
 1612 0e76 0197      		sbiw r24,1
 1613 0e78 A109      		sbc r26,__zero_reg__
 1614 0e7a B109      		sbc r27,__zero_reg__
 1615 0e7c 8093 0000 		sts sliceRemaining+4,r24
 1616 0e80 9093 0000 		sts sliceRemaining+4+1,r25
 1617 0e84 A093 0000 		sts sliceRemaining+4+2,r26
 1618 0e88 B093 0000 		sts sliceRemaining+4+3,r27
 1619 0e8c 00C0      		rjmp .L89
 1620               	.L114:
 880:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1621               		.loc 1 880 0
 1622 0e8e 8091 0000 		lds r24,bankStates+61
 1623 0e92 9091 0000 		lds r25,bankStates+61+1
 1624 0e96 A091 0000 		lds r26,bankStates+61+2
 1625 0e9a B091 0000 		lds r27,bankStates+61+3
 1626 0e9e 4817      		cp r20,r24
 1627 0ea0 5907      		cpc r21,r25
 1628 0ea2 6A07      		cpc r22,r26
 1629 0ea4 7B07      		cpc r23,r27
 1630 0ea6 01F4      		brne .+2
 1631 0ea8 00C0      		rjmp .L125
 1632               	.L92:
 885:WTPA.c        **** 				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're lo
 1633               		.loc 1 885 0
 1634 0eaa 4091 0000 		lds r20,bankStates+68
 1635 0eae 5091 0000 		lds r21,bankStates+68+1
 1636 0eb2 6091 0000 		lds r22,bankStates+68+2
 1637 0eb6 7091 0000 		lds r23,bankStates+68+3
 1638 0eba 8091 0000 		lds r24,bankStates+61
 1639 0ebe 9091 0000 		lds r25,bankStates+61+1
 1640 0ec2 A091 0000 		lds r26,bankStates+61+2
 1641 0ec6 B091 0000 		lds r27,bankStates+61+3
 1642 0eca 4817      		cp r20,r24
 1643 0ecc 5907      		cpc r21,r25
 1644 0ece 6A07      		cpc r22,r26
 1645 0ed0 7B07      		cpc r23,r27
 1646 0ed2 01F4      		brne .+2
 1647 0ed4 00C0      		rjmp .L126
 891:WTPA.c        **** 					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loo
 1648               		.loc 1 891 0
 1649 0ed6 4091 0000 		lds r20,bankStates+68
 1650 0eda 5091 0000 		lds r21,bankStates+68+1
 1651 0ede 6091 0000 		lds r22,bankStates+68+2
 1652 0ee2 7091 0000 		lds r23,bankStates+68+3
 1653 0ee6 8091 0000 		lds r24,bankStates+53
 1654 0eea 9091 0000 		lds r25,bankStates+53+1
 1655 0eee A091 0000 		lds r26,bankStates+53+2
 1656 0ef2 B091 0000 		lds r27,bankStates+53+3
 1657 0ef6 4817      		cp r20,r24
 1658 0ef8 5907      		cpc r21,r25
 1659 0efa 6A07      		cpc r22,r26
 1660 0efc 7B07      		cpc r23,r27
 1661 0efe 01F4      		brne .+2
 1662 0f00 00C0      		rjmp .L127
 897:WTPA.c        **** 						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
 1663               		.loc 1 897 0
 1664 0f02 8091 0000 		lds r24,bankStates+68
 1665 0f06 9091 0000 		lds r25,bankStates+68+1
 1666 0f0a A091 0000 		lds r26,bankStates+68+2
 1667 0f0e B091 0000 		lds r27,bankStates+68+3
 1668 0f12 0196      		adiw r24,1
 1669 0f14 A11D      		adc r26,__zero_reg__
 1670 0f16 B11D      		adc r27,__zero_reg__
 1671 0f18 8093 0000 		sts bankStates+68,r24
 1672 0f1c 9093 0000 		sts bankStates+68+1,r25
 1673 0f20 A093 0000 		sts bankStates+68+2,r26
 1674 0f24 B093 0000 		sts bankStates+68+3,r27
 1675 0f28 00C0      		rjmp .L89
 1676               	.L122:
 772:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1677               		.loc 1 772 0 discriminator 1
 1678 0f2a 8091 0000 		lds r24,bankStates+37
 1679 0f2e 8130      		cpi r24,lo8(1)
 1680 0f30 01F0      		breq .+2
 1681 0f32 00C0      		rjmp .L80
 1682               	.L105:
 797:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1683               		.loc 1 797 0
 1684 0f34 1092 0000 		sts bankStates+36,__zero_reg__
 798:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1685               		.loc 1 798 0
 1686 0f38 1092 0000 		sts bankStates+46,__zero_reg__
 1687 0f3c 00C0      		rjmp .L77
 1688               	.L125:
 880:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BA
 1689               		.loc 1 880 0 discriminator 1
 1690 0f3e 8091 0000 		lds r24,bankStates+37
 1691 0f42 8130      		cpi r24,lo8(1)
 1692 0f44 01F0      		breq .+2
 1693 0f46 00C0      		rjmp .L92
 1694               	.L106:
 905:WTPA.c        **** 					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 1695               		.loc 1 905 0
 1696 0f48 1092 0000 		sts bankStates+36,__zero_reg__
 906:WTPA.c        **** 					bankStates[BANK_1].clockMode=CLK_NONE;
 1697               		.loc 1 906 0
 1698 0f4c 1092 0000 		sts bankStates+46,__zero_reg__
 1699 0f50 00C0      		rjmp .L89
 1700               	.L115:
 903:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1701               		.loc 1 903 0 discriminator 1
 1702 0f52 8091 0000 		lds r24,bankStates+37
 1703 0f56 8130      		cpi r24,lo8(1)
 1704 0f58 01F0      		breq .+2
 1705 0f5a 00C0      		rjmp .L95
 1706 0f5c 00C0      		rjmp .L106
 1707               	.L119:
 795:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK
 1708               		.loc 1 795 0 discriminator 1
 1709 0f5e 8091 0000 		lds r24,bankStates+37
 1710 0f62 8130      		cpi r24,lo8(1)
 1711 0f64 01F0      		breq .+2
 1712 0f66 00C0      		rjmp .L83
 1713 0f68 00C0      		rjmp .L105
 1714               	.L113:
 762:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1715               		.loc 1 762 0
 1716 0f6a 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1717 0f6e 00C0      		rjmp .L78
 1718               	.L111:
 870:WTPA.c        **** 					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
 1719               		.loc 1 870 0
 1720 0f70 1092 0000 		sts granularPositionArrayPointer+1,__zero_reg__
 1721 0f74 00C0      		rjmp .L90
 1722               	.L120:
 802:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1723               		.loc 1 802 0
 1724 0f76 8091 0000 		lds r24,bankStates+61
 1725 0f7a 9091 0000 		lds r25,bankStates+61+1
 1726 0f7e A091 0000 		lds r26,bankStates+61+2
 1727 0f82 B091 0000 		lds r27,bankStates+61+3
 1728 0f86 8093 0000 		sts bankStates+68,r24
 1729 0f8a 9093 0000 		sts bankStates+68+1,r25
 1730 0f8e A093 0000 		sts bankStates+68+2,r26
 1731 0f92 B093 0000 		sts bankStates+68+3,r27
 1732 0f96 00C0      		rjmp .L77
 1733               	.L116:
 910:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to
 1734               		.loc 1 910 0
 1735 0f98 8091 0000 		lds r24,bankStates+61
 1736 0f9c 9091 0000 		lds r25,bankStates+61+1
 1737 0fa0 A091 0000 		lds r26,bankStates+61+2
 1738 0fa4 B091 0000 		lds r27,bankStates+61+3
 1739 0fa8 8093 0000 		sts bankStates+68,r24
 1740 0fac 9093 0000 		sts bankStates+68+1,r25
 1741 0fb0 A093 0000 		sts bankStates+68+2,r26
 1742 0fb4 B093 0000 		sts bankStates+68+3,r27
 1743 0fb8 00C0      		rjmp .L89
 1744               	.L126:
 887:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1745               		.loc 1 887 0
 1746 0fba 8091 0000 		lds r24,bankStates+57
 1747 0fbe 9091 0000 		lds r25,bankStates+57+1
 1748 0fc2 A091 0000 		lds r26,bankStates+57+2
 1749 0fc6 B091 0000 		lds r27,bankStates+57+3
 1750 0fca 8093 0000 		sts bankStates+68,r24
 1751 0fce 9093 0000 		sts bankStates+68+1,r25
 1752 0fd2 A093 0000 		sts bankStates+68+2,r26
 1753 0fd6 B093 0000 		sts bankStates+68+3,r27
 1754 0fda 00C0      		rjmp .L89
 1755               	.L123:
 779:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um,
 1756               		.loc 1 779 0
 1757 0fdc 8091 0000 		lds r24,bankStates+57
 1758 0fe0 9091 0000 		lds r25,bankStates+57+1
 1759 0fe4 A091 0000 		lds r26,bankStates+57+2
 1760 0fe8 B091 0000 		lds r27,bankStates+57+3
 1761 0fec 8093 0000 		sts bankStates+68,r24
 1762 0ff0 9093 0000 		sts bankStates+68+1,r25
 1763 0ff4 A093 0000 		sts bankStates+68+2,r26
 1764 0ff8 B093 0000 		sts bankStates+68+3,r27
 1765 0ffc 00C0      		rjmp .L77
 1766               	.L124:
 785:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1767               		.loc 1 785 0
 1768 0ffe 8091 0000 		lds r24,bankStates+49
 1769 1002 9091 0000 		lds r25,bankStates+49+1
 1770 1006 A091 0000 		lds r26,bankStates+49+2
 1771 100a B091 0000 		lds r27,bankStates+49+3
 1772 100e 8093 0000 		sts bankStates+68,r24
 1773 1012 9093 0000 		sts bankStates+68+1,r25
 1774 1016 A093 0000 		sts bankStates+68+2,r26
 1775 101a B093 0000 		sts bankStates+68+3,r27
 1776 101e 00C0      		rjmp .L77
 1777               	.L127:
 893:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping thr
 1778               		.loc 1 893 0
 1779 1020 8091 0000 		lds r24,bankStates+49
 1780 1024 9091 0000 		lds r25,bankStates+49+1
 1781 1028 A091 0000 		lds r26,bankStates+49+2
 1782 102c B091 0000 		lds r27,bankStates+49+3
 1783 1030 8093 0000 		sts bankStates+68,r24
 1784 1034 9093 0000 		sts bankStates+68+1,r25
 1785 1038 A093 0000 		sts bankStates+68+2,r26
 1786 103c B093 0000 		sts bankStates+68+3,r27
 1787 1040 00C0      		rjmp .L89
 1788               	.L121:
 808:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1789               		.loc 1 808 0
 1790 1042 8091 0000 		lds r24,bankStates+53
 1791 1046 9091 0000 		lds r25,bankStates+53+1
 1792 104a A091 0000 		lds r26,bankStates+53+2
 1793 104e B091 0000 		lds r27,bankStates+53+3
 1794 1052 8093 0000 		sts bankStates+68,r24
 1795 1056 9093 0000 		sts bankStates+68+1,r25
 1796 105a A093 0000 		sts bankStates+68+2,r26
 1797 105e B093 0000 		sts bankStates+68+3,r27
 1798 1062 00C0      		rjmp .L77
 1799               	.L117:
 916:WTPA.c        **** 						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping th
 1800               		.loc 1 916 0
 1801 1064 8091 0000 		lds r24,bankStates+53
 1802 1068 9091 0000 		lds r25,bankStates+53+1
 1803 106c A091 0000 		lds r26,bankStates+53+2
 1804 1070 B091 0000 		lds r27,bankStates+53+3
 1805 1074 8093 0000 		sts bankStates+68,r24
 1806 1078 9093 0000 		sts bankStates+68+1,r25
 1807 107c A093 0000 		sts bankStates+68+2,r26
 1808 1080 B093 0000 		sts bankStates+68+3,r27
 1809 1084 00C0      		rjmp .L89
 1810               		.cfi_endproc
 1811               	.LFE2:
 1814               	OutputMultiplyBanks:
 1815               	.LFB3:
 958:WTPA.c        **** 
 959:WTPA.c        **** //-----------------------------------------------------------------------------
 960:WTPA.c        **** //-----------------------------------------------------------------------------
 961:WTPA.c        **** // DAC output handling and sample combination functions:
 962:WTPA.c        **** // These functions are called (via pointer) everytime a bank updates.
 963:WTPA.c        **** // They worry about summing (or whatever) the different audio sources and spitting them out on the 
 964:WTPA.c        **** //-----------------------------------------------------------------------------
 965:WTPA.c        **** //-----------------------------------------------------------------------------
 966:WTPA.c        **** 
 967:WTPA.c        **** // Globals used in the audio and output update functions.
 968:WTPA.c        **** 
 969:WTPA.c        **** typedef void OUTPUT_FUNCTION(void);	// Creates a datatype -- a void function called OUTPUT_FUNCTION
 970:WTPA.c        **** 
 971:WTPA.c        **** OUTPUT_FUNCTION					// Assigns a pointer called UpdateOutput to an instance of OUTPUT_FUNCTION()
 972:WTPA.c        **** 	*UpdateOutput;
 973:WTPA.c        **** 
 974:WTPA.c        **** static signed char
 975:WTPA.c        **** 	extIsrOutputBank0,
 976:WTPA.c        **** 	extIsrOutputBank1,
 977:WTPA.c        **** 	midiOutputBank0,
 978:WTPA.c        **** 	midiOutputBank1,
 979:WTPA.c        **** 	sdStreamOutput;		// Contribution to DAC coming directly off the SD card
 980:WTPA.c        **** 
 981:WTPA.c        **** static unsigned char
 982:WTPA.c        **** 	lastDacByte;	// Very possible we haven't changed output values since last time (like for instance 
 983:WTPA.c        **** 
 984:WTPA.c        **** static void OutputMultiplyBanks(void)
 985:WTPA.c        **** // Multiply the audio output of banks0 and 1 and spit it out
 986:WTPA.c        **** {
 1816               		.loc 1 986 0
 1817               		.cfi_startproc
 1818               	/* prologue: function */
 1819               	/* frame size = 0 */
 1820               	/* stack size = 0 */
 1821               	.L__stack_usage = 0
 987:WTPA.c        **** 	signed int
 988:WTPA.c        **** 		sum0,			// Temporary variables for saturated adds, multiplies, other math.
 989:WTPA.c        **** 		sum1;
 990:WTPA.c        **** 
 991:WTPA.c        **** 	unsigned char
 992:WTPA.c        **** 		output;			// What to put on the DAC
 993:WTPA.c        **** 
 994:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 1822               		.loc 1 994 0
 1823 1086 8091 0000 		lds r24,extIsrOutputBank0
 1824 108a 2091 0000 		lds r18,midiOutputBank0
 1825 108e 3327      		clr r19
 1826 1090 27FD      		sbrc r18,7
 1827 1092 3095      		com r19
 1828 1094 280F      		add r18,r24
 1829 1096 311D      		adc r19,__zero_reg__
 1830 1098 87FD      		sbrc r24,7
 1831 109a 3A95      		dec r19
 1832 109c 2038      		cpi r18,-128
 1833 109e 4FEF      		ldi r20,-1
 1834 10a0 3407      		cpc r19,r20
 1835 10a2 04F4      		brge .L129
 1836 10a4 20E8      		ldi r18,lo8(-128)
 1837 10a6 3FEF      		ldi r19,lo8(-1)
 1838               	.L129:
 1839               	.LVL42:
 995:WTPA.c        **** 	if(sum0>127)		// Pin high.
 996:WTPA.c        **** 	{
 997:WTPA.c        **** 		sum0=127;
 998:WTPA.c        **** 	}
 999:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1000:WTPA.c        **** 	{
1001:WTPA.c        **** 		sum0=-128;
1002:WTPA.c        **** 	}
1003:WTPA.c        **** 
1004:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 1840               		.loc 1 1004 0
 1841 10a8 4091 0000 		lds r20,extIsrOutputBank1
 1842 10ac 8091 0000 		lds r24,midiOutputBank1
 1843 10b0 9927      		clr r25
 1844 10b2 87FD      		sbrc r24,7
 1845 10b4 9095      		com r25
 1846 10b6 840F      		add r24,r20
 1847 10b8 911D      		adc r25,__zero_reg__
 1848 10ba 47FD      		sbrc r20,7
 1849 10bc 9A95      		dec r25
 1850 10be 8138      		cpi r24,-127
 1851 10c0 4FEF      		ldi r20,-1
 1852 10c2 9407      		cpc r25,r20
 1853 10c4 04F4      		brge .L130
 1854 10c6 81E8      		ldi r24,lo8(-127)
 1855 10c8 9FEF      		ldi r25,lo8(-1)
 1856               	.L130:
 1857               	.LVL43:
1005:WTPA.c        **** 	if(sum1>127)		// Pin high.
1006:WTPA.c        **** 	{
1007:WTPA.c        **** 		sum1=127;
1008:WTPA.c        **** 	}
1009:WTPA.c        **** 	else if(sum1<-127)		// Pin low.  (was pegged to -128)
1010:WTPA.c        **** 	{
1011:WTPA.c        **** 		sum1=-127;
1012:WTPA.c        **** 	}
1013:WTPA.c        **** 
1014:WTPA.c        **** 	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale ou
 1858               		.loc 1 1014 0
 1859 10ca 2038      		cpi r18,-128
 1860 10cc 3105      		cpc r19,__zero_reg__
 1861 10ce 04F0      		brlt .L131
 1862 10d0 2FE7      		ldi r18,lo8(127)
 1863 10d2 30E0      		ldi r19,0
 1864               	.LVL44:
 1865               	.L131:
 1866 10d4 8038      		cpi r24,-128
 1867 10d6 9105      		cpc r25,__zero_reg__
 1868 10d8 04F0      		brlt .L132
 1869 10da 8FE7      		ldi r24,lo8(127)
 1870 10dc 90E0      		ldi r25,0
 1871               	.LVL45:
 1872               	.L132:
 1873 10de 289F      		mul r18,r24
 1874 10e0 A001      		movw r20,r0
 1875 10e2 299F      		mul r18,r25
 1876 10e4 500D      		add r21,r0
 1877 10e6 389F      		mul r19,r24
 1878 10e8 500D      		add r21,r0
 1879 10ea 1124      		clr r1
 1880 10ec 57FD      		sbrc r21,7
 1881 10ee 00C0      		rjmp .L135
 1882               	.L133:
 1883 10f0 CA01      		movw r24,r20
 1884 10f2 082E      		mov __tmp_reg__,r24
 1885 10f4 892F      		mov r24,r25
 1886 10f6 000C      		lsl __tmp_reg__
 1887 10f8 881F      		rol r24
 1888 10fa 990B      		sbc r25,r25
 1889 10fc 000C      		lsl __tmp_reg__
 1890 10fe 881F      		rol r24
 1891 1100 991F      		rol r25
1015:WTPA.c        **** 
1016:WTPA.c        **** //@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the re
1017:WTPA.c        **** //@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide 
1018:WTPA.c        **** 
1019:WTPA.c        **** 	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
 1892               		.loc 1 1019 0
 1893 1102 8058      		subi r24,128
 1894 1104 9095      		com r25
 1895 1106 282F      		mov r18,r24
 1896               	.LVL46:
1020:WTPA.c        **** 
1021:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1897               		.loc 1 1021 0
 1898 1108 3091 0000 		lds r19,lastDacByte
 1899 110c 8317      		cp r24,r19
 1900 110e 01F0      		breq .L134
1022:WTPA.c        **** 	{
1023:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1901               		.loc 1 1023 0
 1902 1110 9FEF      		ldi r25,lo8(-1)
 1903 1112 94B9      		out 0x4,r25
1024:WTPA.c        **** 
1025:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1904               		.loc 1 1025 0
 1905 1114 85B9      		out 0x5,r24
1026:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1906               		.loc 1 1026 0
 1907 1116 159A      		sbi 0x2,5
1027:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1908               		.loc 1 1027 0
 1909 1118 1598      		cbi 0x2,5
 1910               	.L134:
1028:WTPA.c        **** 	}
1029:WTPA.c        **** 
1030:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1911               		.loc 1 1030 0
 1912 111a 2093 0000 		sts lastDacByte,r18
 1913 111e 0895      		ret
 1914               	.LVL47:
 1915               	.L135:
1014:WTPA.c        **** 	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale ou
 1916               		.loc 1 1014 0
 1917 1120 415C      		subi r20,-63
 1918 1122 5F4F      		sbci r21,-1
 1919 1124 00C0      		rjmp .L133
 1920               		.cfi_endproc
 1921               	.LFE3:
 1924               	OutputAddBanks:
 1925               	.LFB4:
1031:WTPA.c        **** }
1032:WTPA.c        **** 
1033:WTPA.c        **** static void OutputAddBanks(void)
1034:WTPA.c        **** // Add audio from the two banks and spit it out (normally what we do)
1035:WTPA.c        **** {
 1926               		.loc 1 1035 0
 1927               		.cfi_startproc
 1928               	/* prologue: function */
 1929               	/* frame size = 0 */
 1930               	/* stack size = 0 */
 1931               	.L__stack_usage = 0
1036:WTPA.c        **** 	signed int
1037:WTPA.c        **** 		sum0;				// Temporary variables for saturated adds, multiplies, other math.
1038:WTPA.c        **** 
1039:WTPA.c        **** 	unsigned char
1040:WTPA.c        **** 		output;			// What to put on the DAC
1041:WTPA.c        **** 
1042:WTPA.c        **** //	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everythi
1043:WTPA.c        **** 	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum e
 1932               		.loc 1 1043 0
 1933 1126 2091 0000 		lds r18,extIsrOutputBank0
 1934 112a 8091 0000 		lds r24,extIsrOutputBank1
 1935 112e 9927      		clr r25
 1936 1130 87FD      		sbrc r24,7
 1937 1132 9095      		com r25
 1938 1134 820F      		add r24,r18
 1939 1136 911D      		adc r25,__zero_reg__
 1940 1138 27FD      		sbrc r18,7
 1941 113a 9A95      		dec r25
 1942 113c 2091 0000 		lds r18,midiOutputBank0
 1943 1140 820F      		add r24,r18
 1944 1142 911D      		adc r25,__zero_reg__
 1945 1144 27FD      		sbrc r18,7
 1946 1146 9A95      		dec r25
 1947 1148 2091 0000 		lds r18,midiOutputBank1
 1948 114c 820F      		add r24,r18
 1949 114e 911D      		adc r25,__zero_reg__
 1950 1150 27FD      		sbrc r18,7
 1951 1152 9A95      		dec r25
 1952 1154 2091 0000 		lds r18,sdStreamOutput
 1953 1158 820F      		add r24,r18
 1954 115a 911D      		adc r25,__zero_reg__
 1955 115c 27FD      		sbrc r18,7
 1956 115e 9A95      		dec r25
 1957 1160 8038      		cpi r24,-128
 1958 1162 2FEF      		ldi r18,-1
 1959 1164 9207      		cpc r25,r18
 1960 1166 04F4      		brge .L137
 1961 1168 80E8      		ldi r24,lo8(-128)
 1962 116a 9FEF      		ldi r25,lo8(-1)
 1963               	.L137:
 1964               	.LVL48:
1044:WTPA.c        **** 	if(sum0>127)		// Pin high.
1045:WTPA.c        **** 	{
1046:WTPA.c        **** 		sum0=127;
1047:WTPA.c        **** 	}
1048:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1049:WTPA.c        **** 	{
1050:WTPA.c        **** 		sum0=-128;
1051:WTPA.c        **** 	}
1052:WTPA.c        **** 	output=(signed char)sum0;		// Cast back to 8 bits.
1053:WTPA.c        **** 	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
 1965               		.loc 1 1053 0
 1966 116c 8038      		cpi r24,-128
 1967 116e 9105      		cpc r25,__zero_reg__
 1968 1170 04F0      		brlt .L138
 1969 1172 8FE7      		ldi r24,lo8(127)
 1970 1174 90E0      		ldi r25,0
 1971               	.LVL49:
 1972               	.L138:
 1973 1176 8058      		subi r24,128
 1974 1178 282F      		mov r18,r24
 1975               	.LVL50:
1054:WTPA.c        **** 
1055:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 1976               		.loc 1 1055 0
 1977 117a 3091 0000 		lds r19,lastDacByte
 1978 117e 8317      		cp r24,r19
 1979 1180 01F0      		breq .L139
1056:WTPA.c        **** 	{
1057:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 1980               		.loc 1 1057 0
 1981 1182 9FEF      		ldi r25,lo8(-1)
 1982 1184 94B9      		out 0x4,r25
1058:WTPA.c        **** 
1059:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 1983               		.loc 1 1059 0
 1984 1186 85B9      		out 0x5,r24
1060:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 1985               		.loc 1 1060 0
 1986 1188 159A      		sbi 0x2,5
1061:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 1987               		.loc 1 1061 0
 1988 118a 1598      		cbi 0x2,5
 1989               	.L139:
1062:WTPA.c        **** 	}
1063:WTPA.c        **** 
1064:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 1990               		.loc 1 1064 0
 1991 118c 2093 0000 		sts lastDacByte,r18
 1992 1190 0895      		ret
 1993               		.cfi_endproc
 1994               	.LFE4:
 1997               	OutputXorBanks:
 1998               	.LFB5:
1065:WTPA.c        **** }
1066:WTPA.c        **** 
1067:WTPA.c        **** static void OutputXorBanks(void)
1068:WTPA.c        **** // Performs a bitwise XOR and spits out the result
1069:WTPA.c        **** {
 1999               		.loc 1 1069 0
 2000               		.cfi_startproc
 2001               	/* prologue: function */
 2002               	/* frame size = 0 */
 2003               	/* stack size = 0 */
 2004               	.L__stack_usage = 0
1070:WTPA.c        **** 	signed int
1071:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1072:WTPA.c        **** 		sum1;
1073:WTPA.c        **** 
1074:WTPA.c        **** 	unsigned char
1075:WTPA.c        **** 		output;			// What to put on the DAC
1076:WTPA.c        **** 
1077:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 2005               		.loc 1 1077 0
 2006 1192 2091 0000 		lds r18,extIsrOutputBank0
 2007 1196 8091 0000 		lds r24,midiOutputBank0
 2008 119a 9927      		clr r25
 2009 119c 87FD      		sbrc r24,7
 2010 119e 9095      		com r25
 2011 11a0 820F      		add r24,r18
 2012 11a2 911D      		adc r25,__zero_reg__
 2013 11a4 27FD      		sbrc r18,7
 2014 11a6 9A95      		dec r25
 2015 11a8 8038      		cpi r24,-128
 2016 11aa 2FEF      		ldi r18,-1
 2017 11ac 9207      		cpc r25,r18
 2018 11ae 04F4      		brge .L141
 2019 11b0 80E8      		ldi r24,lo8(-128)
 2020 11b2 9FEF      		ldi r25,lo8(-1)
 2021               	.L141:
 2022               	.LVL51:
1078:WTPA.c        **** 	if(sum0>127)		// Pin high.
1079:WTPA.c        **** 	{
1080:WTPA.c        **** 		sum0=127;
1081:WTPA.c        **** 	}
1082:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1083:WTPA.c        **** 	{
1084:WTPA.c        **** 		sum0=-128;
1085:WTPA.c        **** 	}
1086:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 2023               		.loc 1 1086 0
 2024 11b4 4091 0000 		lds r20,extIsrOutputBank1
 2025 11b8 2091 0000 		lds r18,midiOutputBank1
 2026 11bc 3327      		clr r19
 2027 11be 27FD      		sbrc r18,7
 2028 11c0 3095      		com r19
 2029 11c2 240F      		add r18,r20
 2030 11c4 311D      		adc r19,__zero_reg__
 2031 11c6 47FD      		sbrc r20,7
 2032 11c8 3A95      		dec r19
 2033 11ca 2038      		cpi r18,-128
 2034 11cc 4FEF      		ldi r20,-1
 2035 11ce 3407      		cpc r19,r20
 2036 11d0 04F4      		brge .L142
 2037 11d2 20E8      		ldi r18,lo8(-128)
 2038 11d4 3FEF      		ldi r19,lo8(-1)
 2039               	.L142:
 2040               	.LVL52:
1087:WTPA.c        **** 	if(sum1>127)		// Pin high.
1088:WTPA.c        **** 	{
1089:WTPA.c        **** 		sum1=127;
1090:WTPA.c        **** 	}
1091:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1092:WTPA.c        **** 	{
1093:WTPA.c        **** 		sum1=-128;
1094:WTPA.c        **** 	}
1095:WTPA.c        **** 	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 2041               		.loc 1 1095 0
 2042 11d6 2038      		cpi r18,-128
 2043 11d8 3105      		cpc r19,__zero_reg__
 2044 11da 04F0      		brlt .L143
 2045 11dc 2FE7      		ldi r18,lo8(127)
 2046 11de 30E0      		ldi r19,0
 2047               	.LVL53:
 2048               	.L143:
 2049 11e0 2058      		subi r18,128
 2050 11e2 3095      		com r19
 2051 11e4 8038      		cpi r24,-128
 2052 11e6 9105      		cpc r25,__zero_reg__
 2053 11e8 04F0      		brlt .L144
 2054 11ea 8FE7      		ldi r24,lo8(127)
 2055 11ec 90E0      		ldi r25,0
 2056               	.LVL54:
 2057               	.L144:
 2058 11ee 8058      		subi r24,128
 2059 11f0 9095      		com r25
 2060 11f2 8227      		eor r24,r18
 2061               	.LVL55:
1096:WTPA.c        **** 
1097:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 2062               		.loc 1 1097 0
 2063 11f4 9091 0000 		lds r25,lastDacByte
 2064 11f8 8917      		cp r24,r25
 2065 11fa 01F0      		breq .L145
1098:WTPA.c        **** 	{
1099:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 2066               		.loc 1 1099 0
 2067 11fc 9FEF      		ldi r25,lo8(-1)
 2068 11fe 94B9      		out 0x4,r25
1100:WTPA.c        **** 
1101:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 2069               		.loc 1 1101 0
 2070 1200 85B9      		out 0x5,r24
1102:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 2071               		.loc 1 1102 0
 2072 1202 159A      		sbi 0x2,5
1103:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 2073               		.loc 1 1103 0
 2074 1204 1598      		cbi 0x2,5
 2075               	.L145:
1104:WTPA.c        **** 	}
1105:WTPA.c        **** 
1106:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 2076               		.loc 1 1106 0
 2077 1206 8093 0000 		sts lastDacByte,r24
 2078 120a 0895      		ret
 2079               		.cfi_endproc
 2080               	.LFE5:
 2083               	OutputAndBanks:
 2084               	.LFB6:
1107:WTPA.c        **** }
1108:WTPA.c        **** 
1109:WTPA.c        **** static void OutputAndBanks(void)
1110:WTPA.c        **** // Performs a bitwise AND and spits out the result
1111:WTPA.c        **** {
 2085               		.loc 1 1111 0
 2086               		.cfi_startproc
 2087               	/* prologue: function */
 2088               	/* frame size = 0 */
 2089               	/* stack size = 0 */
 2090               	.L__stack_usage = 0
1112:WTPA.c        **** 	signed int
1113:WTPA.c        **** 		sum0,				// Temporary variables for saturated adds, multiplies, other math.
1114:WTPA.c        **** 		sum1;
1115:WTPA.c        **** 
1116:WTPA.c        **** 	unsigned char
1117:WTPA.c        **** 		output;			// What to put on the DAC
1118:WTPA.c        **** 
1119:WTPA.c        **** 	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
 2091               		.loc 1 1119 0
 2092 120c 2091 0000 		lds r18,extIsrOutputBank0
 2093 1210 8091 0000 		lds r24,midiOutputBank0
 2094 1214 9927      		clr r25
 2095 1216 87FD      		sbrc r24,7
 2096 1218 9095      		com r25
 2097 121a 820F      		add r24,r18
 2098 121c 911D      		adc r25,__zero_reg__
 2099 121e 27FD      		sbrc r18,7
 2100 1220 9A95      		dec r25
 2101 1222 8038      		cpi r24,-128
 2102 1224 2FEF      		ldi r18,-1
 2103 1226 9207      		cpc r25,r18
 2104 1228 04F4      		brge .L147
 2105 122a 80E8      		ldi r24,lo8(-128)
 2106 122c 9FEF      		ldi r25,lo8(-1)
 2107               	.L147:
 2108               	.LVL56:
1120:WTPA.c        **** 	if(sum0>127)		// Pin high.
1121:WTPA.c        **** 	{
1122:WTPA.c        **** 		sum0=127;
1123:WTPA.c        **** 	}
1124:WTPA.c        **** 	else if(sum0<-128)		// Pin low.
1125:WTPA.c        **** 	{
1126:WTPA.c        **** 		sum0=-128;
1127:WTPA.c        **** 	}
1128:WTPA.c        **** 	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
 2109               		.loc 1 1128 0
 2110 122e 4091 0000 		lds r20,extIsrOutputBank1
 2111 1232 2091 0000 		lds r18,midiOutputBank1
 2112 1236 3327      		clr r19
 2113 1238 27FD      		sbrc r18,7
 2114 123a 3095      		com r19
 2115 123c 240F      		add r18,r20
 2116 123e 311D      		adc r19,__zero_reg__
 2117 1240 47FD      		sbrc r20,7
 2118 1242 3A95      		dec r19
 2119 1244 2038      		cpi r18,-128
 2120 1246 4FEF      		ldi r20,-1
 2121 1248 3407      		cpc r19,r20
 2122 124a 04F4      		brge .L148
 2123 124c 20E8      		ldi r18,lo8(-128)
 2124 124e 3FEF      		ldi r19,lo8(-1)
 2125               	.L148:
 2126               	.LVL57:
1129:WTPA.c        **** 	if(sum1>127)		// Pin high.
1130:WTPA.c        **** 	{
1131:WTPA.c        **** 		sum1=127;
1132:WTPA.c        **** 	}
1133:WTPA.c        **** 	else if(sum1<-128)		// Pin low.
1134:WTPA.c        **** 	{
1135:WTPA.c        **** 		sum1=-128;
1136:WTPA.c        **** 	}
1137:WTPA.c        **** 	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, ma
 2127               		.loc 1 1137 0
 2128 1250 2038      		cpi r18,-128
 2129 1252 3105      		cpc r19,__zero_reg__
 2130 1254 04F0      		brlt .L149
 2131 1256 2FE7      		ldi r18,lo8(127)
 2132 1258 30E0      		ldi r19,0
 2133               	.LVL58:
 2134               	.L149:
 2135 125a 2058      		subi r18,128
 2136 125c 3095      		com r19
 2137 125e 8038      		cpi r24,-128
 2138 1260 9105      		cpc r25,__zero_reg__
 2139 1262 04F0      		brlt .L150
 2140 1264 8FE7      		ldi r24,lo8(127)
 2141 1266 90E0      		ldi r25,0
 2142               	.LVL59:
 2143               	.L150:
 2144 1268 8058      		subi r24,128
 2145 126a 9095      		com r25
 2146 126c 8223      		and r24,r18
 2147               	.LVL60:
1138:WTPA.c        **** 
1139:WTPA.c        **** 	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
 2148               		.loc 1 1139 0
 2149 126e 9091 0000 		lds r25,lastDacByte
 2150 1272 8917      		cp r24,r25
 2151 1274 01F0      		breq .L151
1140:WTPA.c        **** 	{
1141:WTPA.c        **** 		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 2152               		.loc 1 1141 0
 2153 1276 9FEF      		ldi r25,lo8(-1)
 2154 1278 94B9      		out 0x4,r25
1142:WTPA.c        **** 
1143:WTPA.c        **** 		LATCH_PORT=output;		// Put the output on the output latch's input.
 2155               		.loc 1 1143 0
 2156 127a 85B9      		out 0x5,r24
1144:WTPA.c        **** 		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output.
 2157               		.loc 1 1144 0
 2158 127c 159A      		sbi 0x2,5
1145:WTPA.c        **** 		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 2159               		.loc 1 1145 0
 2160 127e 1598      		cbi 0x2,5
 2161               	.L151:
1146:WTPA.c        **** 	}
1147:WTPA.c        **** 
1148:WTPA.c        **** 	lastDacByte=output;		// Flag this byte has having been spit out last time.
 2162               		.loc 1 1148 0
 2163 1280 8093 0000 		sts lastDacByte,r24
 2164 1284 0895      		ret
 2165               		.cfi_endproc
 2166               	.LFE6:
 2169               	MakeNewGranularArray:
 2170               	.LFB62:
1149:WTPA.c        **** }
1150:WTPA.c        **** //-----------------------------------------------------------------------------
1151:WTPA.c        **** //-----------------------------------------------------------------------------
1152:WTPA.c        **** // Interrupt Vectors:
1153:WTPA.c        **** // These handle updating audio in the different banks (and the dumb LED intro)
1154:WTPA.c        **** //-----------------------------------------------------------------------------
1155:WTPA.c        **** //-----------------------------------------------------------------------------
1156:WTPA.c        **** 
1157:WTPA.c        **** ISR(TIMER1_CAPT_vect)
1158:WTPA.c        **** // The vector triggered by an external clock edge and associated with Bank0
1159:WTPA.c        **** {
1160:WTPA.c        **** 	static bool
1161:WTPA.c        **** 		flipFlop;		// Used for half-time
1162:WTPA.c        **** 
1163:WTPA.c        **** 	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
1164:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1165:WTPA.c        **** 	{
1166:WTPA.c        **** 		UpdateAudioChannel0();							// If so, then call the audioIsr for bank 0 and do whatever it's cur
1167:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
1168:WTPA.c        **** 	}
1169:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1170:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1171:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1172:WTPA.c        **** 	{
1173:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1174:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1175:WTPA.c        **** 	}
1176:WTPA.c        **** 	PORTC&=~Om_TEST_PIN_0;		// @@@ Used to time ISRs
1177:WTPA.c        **** }
1178:WTPA.c        **** 
1179:WTPA.c        **** ISR(PCINT2_vect)
1180:WTPA.c        **** // The vector triggered by a pin change and associated with Bank1
1181:WTPA.c        **** // It's on PC4
1182:WTPA.c        **** {
1183:WTPA.c        **** 	static bool
1184:WTPA.c        **** 		flipFlop;		// Used for half-time
1185:WTPA.c        **** 
1186:WTPA.c        **** 	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
1187:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1188:WTPA.c        **** 	{
1189:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
1190:WTPA.c        **** 	}
1191:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1192:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1193:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1194:WTPA.c        **** 	{
1195:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1196:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1197:WTPA.c        **** 	}
1198:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
1199:WTPA.c        **** 
1200:WTPA.c        **** // Mon May 23 16:06:37 EDT 2011
1201:WTPA.c        **** // With new hardware (relaxation osc and pulse shaper) we removed the level check above.  The clock
1202:WTPA.c        **** // However, we will need to clear the pin-change interrupt flag, since it may get set again about t
1203:WTPA.c        **** // Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and 
1204:WTPA.c        **** 
1205:WTPA.c        **** // Fri Jun 24 11:20:40 EDT 2011
1206:WTPA.c        **** // They're more like 5uS now, but still plenty short
1207:WTPA.c        **** }
1208:WTPA.c        **** 
1209:WTPA.c        **** ISR(TIMER1_COMPA_vect)
1210:WTPA.c        **** // The bank0 internal timer vectors here on an interrupt.
1211:WTPA.c        **** {
1212:WTPA.c        **** 	unsigned long
1213:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1214:WTPA.c        **** 	static unsigned int
1215:WTPA.c        **** 		lastJitterValue;
1216:WTPA.c        **** 	static bool
1217:WTPA.c        **** 		flipFlop;		// Used for half-time
1218:WTPA.c        **** 
1219:WTPA.c        **** 	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
1220:WTPA.c        **** 
1221:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
1222:WTPA.c        **** 	{
1223:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
1224:WTPA.c        **** 	}
1225:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
1226:WTPA.c        **** 	{
1227:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
1228:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1229:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1230:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1231:WTPA.c        **** 	}
1232:WTPA.c        **** 	else
1233:WTPA.c        **** 	{
1234:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1235:WTPA.c        **** 	}
1236:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1237:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1238:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1239:WTPA.c        **** 	{
1240:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1241:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1242:WTPA.c        **** 	}
1243:WTPA.c        **** }
1244:WTPA.c        **** 
1245:WTPA.c        **** ISR(TIMER1_COMPB_vect)
1246:WTPA.c        **** // The interrupt associated with bank1 when it's using internal interrupts goes here.
1247:WTPA.c        **** {
1248:WTPA.c        **** 	unsigned long
1249:WTPA.c        **** 		jitterTemp;			// Used to calculate new jitter values.
1250:WTPA.c        **** 	static unsigned int
1251:WTPA.c        **** 		lastJitterValue;
1252:WTPA.c        **** 	static bool
1253:WTPA.c        **** 		flipFlop;		// Used for half-time
1254:WTPA.c        **** 
1255:WTPA.c        **** //	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
1256:WTPA.c        **** 
1257:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
1258:WTPA.c        **** 	{
1259:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
1260:WTPA.c        **** 	}
1261:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
1262:WTPA.c        **** 	{
1263:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
1264:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
1265:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
1266:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
1267:WTPA.c        **** 	}
1268:WTPA.c        **** 	else
1269:WTPA.c        **** 	{
1270:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
1271:WTPA.c        **** 	}
1272:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
1273:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
1274:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
1275:WTPA.c        **** 	{
1276:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
1277:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
1278:WTPA.c        **** 	}
1279:WTPA.c        **** }
1280:WTPA.c        **** 
1281:WTPA.c        **** ISR(TIMER2_COMPB_vect)
1282:WTPA.c        **** // This interrupt handles data in the SD buffer and doing what needs to be done with it.
1283:WTPA.c        **** // This includes direct playback from the SD card, writing SD data to the ram banks, and reading ra
1284:WTPA.c        **** // When writing/reading RAM, the bank in question should be locked against other RAM accesses.
1285:WTPA.c        **** {
1286:WTPA.c        **** 	unsigned char
1287:WTPA.c        **** 		theByte;
1288:WTPA.c        **** 
1289:WTPA.c        **** //	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
1290:WTPA.c        **** 
1291:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
1292:WTPA.c        **** 	{
1293:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1294:WTPA.c        **** 		{
1295:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1296:WTPA.c        **** 			{
1297:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1298:WTPA.c        **** 
1299:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1300:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1301:WTPA.c        **** 				{
1302:WTPA.c        **** 					sdFifoReadPointer=0;
1303:WTPA.c        **** 				}
1304:WTPA.c        **** 
1305:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1306:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1307:WTPA.c        **** 
1308:WTPA.c        **** 				// Now put this byte into the RAM bank in the correct address.
1309:WTPA.c        **** 
1310:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
1311:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
1312:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
1313:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
1314:WTPA.c        **** 
1315:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
1316:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
1317:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
1318:WTPA.c        **** 				//PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin hi
1319:WTPA.c        **** 
1320:WTPA.c        **** 				// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an ope
1321:WTPA.c        **** 				PORTC&=~0x07;											// Clear PORTC bits 0-2
1322:WTPA.c        **** 				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
1323:WTPA.c        **** 
1324:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
1325:WTPA.c        **** 
1326:WTPA.c        **** 				// Compute address while bus settles.
1327:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
1328:WTPA.c        **** 				{
1329:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1330:WTPA.c        **** 				}
1331:WTPA.c        **** 				else
1332:WTPA.c        **** 				{
1333:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1334:WTPA.c        **** 				}
1335:WTPA.c        **** 
1336:WTPA.c        **** 				// Finish writing to RAM.
1337:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
1338:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
1339:WTPA.c        **** 
1340:WTPA.c        **** 			}
1341:WTPA.c        **** 		}
1342:WTPA.c        **** 		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current 
1343:WTPA.c        **** 		{
1344:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1345:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1346:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1347:WTPA.c        **** 
1348:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
1349:WTPA.c        **** 			{
1350:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
1351:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1352:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1353:WTPA.c        **** 			}
1354:WTPA.c        **** 			else
1355:WTPA.c        **** 			{
1356:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
1357:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
1358:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
1359:WTPA.c        **** 			}
1360:WTPA.c        **** 		}
1361:WTPA.c        **** 	}
1362:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
1363:WTPA.c        **** 	{
1364:WTPA.c        **** 		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pau
1365:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
1366:WTPA.c        **** 		{
1367:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
1368:WTPA.c        **** 			{
1369:WTPA.c        **** 				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't nee
1370:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
1371:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
1372:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
1373:WTPA.c        **** 
1374:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
1375:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
1376:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
1377:WTPA.c        **** 
1378:WTPA.c        **** 				//PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin hig
1379:WTPA.c        **** 
1380:WTPA.c        **** 				// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an ope
1381:WTPA.c        **** 				PORTC&=~0x07;											// Clear PORTC bits 0-2
1382:WTPA.c        **** 				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
1383:WTPA.c        **** 
1384:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
1385:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
1386:WTPA.c        **** 
1387:WTPA.c        **** 				// Calculate new addy while data bus settles
1388:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
1389:WTPA.c        **** 				{
1390:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
1391:WTPA.c        **** 				}
1392:WTPA.c        **** 				else
1393:WTPA.c        **** 				{
1394:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
1395:WTPA.c        **** 				}
1396:WTPA.c        **** 
1397:WTPA.c        **** 				// Finish getting the byte from RAM.
1398:WTPA.c        **** 
1399:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
1400:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
1401:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
1402:WTPA.c        **** 
1403:WTPA.c        **** 				// Now put this byte from RAM into the sd fifo
1404:WTPA.c        **** 
1405:WTPA.c        **** 
1406:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
1407:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
1408:WTPA.c        **** 
1409:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
1410:WTPA.c        **** 				{
1411:WTPA.c        **** 					sdFifoWritePointer=0;
1412:WTPA.c        **** 				}
1413:WTPA.c        **** 
1414:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
1415:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
1416:WTPA.c        **** 
1417:WTPA.c        **** 			}
1418:WTPA.c        **** 			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank fo
1419:WTPA.c        **** 			{
1420:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1421:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
1422:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1423:WTPA.c        **** 
1424:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
1425:WTPA.c        **** 				{
1426:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
1427:WTPA.c        **** 				}
1428:WTPA.c        **** 				else
1429:WTPA.c        **** 				{
1430:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
1431:WTPA.c        **** 				}
1432:WTPA.c        **** 			}
1433:WTPA.c        **** 		}
1434:WTPA.c        **** 	}
1435:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
1436:WTPA.c        **** 	{
1437:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
1438:WTPA.c        **** 		{
1439:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
1440:WTPA.c        **** 			{
1441:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
1442:WTPA.c        **** 
1443:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
1444:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
1445:WTPA.c        **** 				{
1446:WTPA.c        **** 					sdFifoReadPointer=0;
1447:WTPA.c        **** 				}
1448:WTPA.c        **** 
1449:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
1450:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
1451:WTPA.c        **** 
1452:WTPA.c        **** 				// Now spit the byte out the DAC.
1453:WTPA.c        **** 
1454:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
1455:WTPA.c        **** 				UpdateOutput();				// Update the DAC
1456:WTPA.c        **** 			}
1457:WTPA.c        **** 		}
1458:WTPA.c        **** 		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
1459:WTPA.c        **** 		{
1460:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
1461:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
1462:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
1463:WTPA.c        **** 
1464:WTPA.c        **** 			// Set this contribution to the DAC to midscale (this output source is now quiet)
1465:WTPA.c        **** 			sdStreamOutput=0;
1466:WTPA.c        **** 			UpdateOutput();				// Update the DAC
1467:WTPA.c        **** 		}
1468:WTPA.c        **** 	}
1469:WTPA.c        **** }
1470:WTPA.c        **** 
1471:WTPA.c        **** ISR(TIMER2_COMPA_vect)
1472:WTPA.c        **** // Serves exclusively to make our FABULOUS intro happen
1473:WTPA.c        **** // As far as the PWM goes, this should happen as often as possible.
1474:WTPA.c        **** {
1475:WTPA.c        **** 	static unsigned char
1476:WTPA.c        **** 		pwmCount;
1477:WTPA.c        **** 
1478:WTPA.c        **** 	if(ledPwm>pwmCount)
1479:WTPA.c        **** 	{
1480:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
1481:WTPA.c        **** 	}
1482:WTPA.c        **** 	else
1483:WTPA.c        **** 	{
1484:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
1485:WTPA.c        **** 	}
1486:WTPA.c        **** 	pwmCount++;
1487:WTPA.c        **** }
1488:WTPA.c        **** 
1489:WTPA.c        **** ISR(__vector_default)
1490:WTPA.c        **** {
1491:WTPA.c        ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
1492:WTPA.c        **** 	//	printf("Buggy Interrupt Generated!  Flags = ");
1493:WTPA.c        **** 	//  printf("*****put interrupt register values here****");
1494:WTPA.c        **** }
1495:WTPA.c        **** 
1496:WTPA.c        **** //-----------------------------------------------------------------------
1497:WTPA.c        **** //-----------------------------------------------------------------------
1498:WTPA.c        **** // State Machine Functions.
1499:WTPA.c        **** //-----------------------------------------------------------------------
1500:WTPA.c        **** //-----------------------------------------------------------------------
1501:WTPA.c        **** 
1502:WTPA.c        **** static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should be
1503:WTPA.c        **** {
1504:WTPA.c        **** 	State=newState;
1505:WTPA.c        **** 	subState=SS_0;
1506:WTPA.c        **** }
1507:WTPA.c        **** 
1508:WTPA.c        **** //-----------------------------------------------------------------------
1509:WTPA.c        **** //-----------------------------------------------------------------------
1510:WTPA.c        **** // Local Software Clock stuff.
1511:WTPA.c        **** //-----------------------------------------------------------------------
1512:WTPA.c        **** //-----------------------------------------------------------------------
1513:WTPA.c        **** 
1514:WTPA.c        **** void HandleSoftclock(void)
1515:WTPA.c        **** // NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
1516:WTPA.c        **** // This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up
1517:WTPA.c        **** {
1518:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
1519:WTPA.c        **** 	{
1520:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
1521:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
1522:WTPA.c        **** 	}
1523:WTPA.c        **** }
1524:WTPA.c        **** 
1525:WTPA.c        **** static void InitSoftclock(void)
1526:WTPA.c        **** // Wed Dec  3 22:28:06 CST 2008
1527:WTPA.c        **** // I've changed the way the softclock works from the last rev.  It's no longer and interrupt based 
1528:WTPA.c        **** // Also, since hardware TIMR1 is needed for bigger and better things than keeping human-time, we're
1529:WTPA.c        **** // This means we don't steal cycles from any other ISRs, but it also means that if we write dumb co
1530:WTPA.c        **** // we might miss a systemTick.
1531:WTPA.c        **** // NOTE:  w/ TMR0 running at 1/256 prescale at 20MHz, our smallest time unit is 3.2768mSecs.
1532:WTPA.c        **** // NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.
1533:WTPA.c        **** 
1534:WTPA.c        **** // With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing e
1535:WTPA.c        **** 
1536:WTPA.c        **** {
1537:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
1538:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
1539:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
1540:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
1541:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
1542:WTPA.c        **** 	systemTicks=0;
1543:WTPA.c        **** //	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
1544:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
1545:WTPA.c        **** }
1546:WTPA.c        **** 
1547:WTPA.c        **** //-----------------------------------------------------------------------
1548:WTPA.c        **** // LED functions:
1549:WTPA.c        **** //-----------------------------------------------------------------------
1550:WTPA.c        **** 
1551:WTPA.c        **** // Thu Apr  1 13:08:08 EDT 2010
1552:WTPA.c        **** // Changed blinking mechanisms to be smaller and blink fixed times, and also use fewer timer fcns
1553:WTPA.c        **** 
1554:WTPA.c        **** #define		BLINK_TIME			(SECOND/8)
1555:WTPA.c        **** 
1556:WTPA.c        **** static void BlinkLeds(unsigned int theMask)
1557:WTPA.c        **** // Sets up the mask of leds to blink and their blink rate.
1558:WTPA.c        **** // NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from
1559:WTPA.c        **** // NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when w
1560:WTPA.c        **** {
1561:WTPA.c        **** 	unsigned char
1562:WTPA.c        **** 		i;
1563:WTPA.c        **** 
1564:WTPA.c        **** 	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
1565:WTPA.c        **** 	{
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
1567:WTPA.c        **** 		{
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
1569:WTPA.c        **** 		}
1570:WTPA.c        **** 	}
1571:WTPA.c        **** 
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
1574:WTPA.c        **** }
1575:WTPA.c        **** 
1576:WTPA.c        **** static void StopBlinking(void)
1577:WTPA.c        **** // Stops all blinking LEDs.
1578:WTPA.c        **** {
1579:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1580:WTPA.c        **** }
1581:WTPA.c        **** 
1582:WTPA.c        **** static void KillLeds(void)
1583:WTPA.c        **** // Turns off all LEDs immediately.
1584:WTPA.c        **** {
1585:WTPA.c        **** 	ledOnOffMask=0;
1586:WTPA.c        **** 	BlinkLeds(0);		// Durrrr.....
1587:WTPA.c        **** }
1588:WTPA.c        **** 
1589:WTPA.c        **** static void WriteLedLatch(unsigned char theMask)
1590:WTPA.c        **** // Take the current on/off LED mask and put it onto the LED output latch.
1591:WTPA.c        **** // This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
1592:WTPA.c        **** {
1593:WTPA.c        **** 	unsigned char
1594:WTPA.c        **** 		sreg;
1595:WTPA.c        **** 
1596:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
1597:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
1598:WTPA.c        **** 
1599:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
1600:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
1601:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
1602:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
1603:WTPA.c        **** 
1604:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
1605:WTPA.c        **** }
1606:WTPA.c        **** 
1607:WTPA.c        **** static void HandleLeds(void)
1608:WTPA.c        **** // Runs in the main loop updating the state of the LEDs.  Only messes with the databus when there's
1609:WTPA.c        **** {
1610:WTPA.c        **** 	unsigned char
1611:WTPA.c        **** 		i;
1612:WTPA.c        **** 	static bool
1613:WTPA.c        **** 		toggle;				// Flip flop for blinking.
1614:WTPA.c        **** 	static unsigned char
1615:WTPA.c        **** 		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.
1616:WTPA.c        **** 
1617:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
1618:WTPA.c        **** 	{
1619:WTPA.c        **** 		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
1620:WTPA.c        **** 		{
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
1622:WTPA.c        **** 			{
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
1624:WTPA.c        **** 				{
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
1626:WTPA.c        **** 				}
1627:WTPA.c        **** 				else
1628:WTPA.c        **** 				{
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
1630:WTPA.c        **** 				}
1631:WTPA.c        **** 			}
1632:WTPA.c        **** 		}
1633:WTPA.c        **** 
1634:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
1635:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
1636:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
1637:WTPA.c        **** 	}
1638:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
1639:WTPA.c        **** 	{
1640:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
1641:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
1642:WTPA.c        **** 	}
1643:WTPA.c        **** }
1644:WTPA.c        **** 
1645:WTPA.c        **** static void InitLeds(void)
1646:WTPA.c        **** {
1647:WTPA.c        **** 	ledOnOffMask=0;
1648:WTPA.c        **** 	ledBlinkMask=0;
1649:WTPA.c        **** 	WriteLedLatch(0);	// ...send the LED value to the latch.
1650:WTPA.c        **** }
1651:WTPA.c        **** 
1652:WTPA.c        **** //-----------------------------------------------------------------------
1653:WTPA.c        **** //-----------------------------------------------------------------------
1654:WTPA.c        **** // Switch functions:
1655:WTPA.c        **** //-----------------------------------------------------------------------
1656:WTPA.c        **** //-----------------------------------------------------------------------
1657:WTPA.c        **** 
1658:WTPA.c        **** static void InitSwitches(void)
1659:WTPA.c        **** {
1660:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
1661:WTPA.c        **** 
1662:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
1663:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
1664:WTPA.c        **** 
1665:WTPA.c        **** }
1666:WTPA.c        **** 
1667:WTPA.c        **** static void HandleSwitches(void)
1668:WTPA.c        **** // Read input pins, debounce, make keypresses positive-true, and flag newly-appeared keys.
1669:WTPA.c        **** // Make sure we've allowed enough time to turn the bus around.  The old RAM took a couple cycles be
1670:WTPA.c        **** {
1671:WTPA.c        **** 	static unsigned char
1672:WTPA.c        **** 		lastKeyState;
1673:WTPA.c        **** 	unsigned char
1674:WTPA.c        **** 		sreg;
1675:WTPA.c        **** 
1676:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
1677:WTPA.c        **** 	{
1678:WTPA.c        **** 		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
1679:WTPA.c        **** 		sreg=SREG;
1680:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
1681:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
1682:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
1683:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
1684:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
1685:WTPA.c        **** 		asm volatile("nop"::);
1686:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
1687:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
1688:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
1689:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
1690:WTPA.c        **** 
1691:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
1692:WTPA.c        **** 		{
1693:WTPA.c        **** 			cardDetect=true;
1694:WTPA.c        **** 		}
1695:WTPA.c        **** 		else
1696:WTPA.c        **** 		{
1697:WTPA.c        **** 			cardDetect=false;
1698:WTPA.c        **** 		}
1699:WTPA.c        **** 
1700:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
1701:WTPA.c        **** 	}
1702:WTPA.c        **** 
1703:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
1704:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
1705:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
1706:WTPA.c        **** }
1707:WTPA.c        **** 
1708:WTPA.c        **** //-----------------------------------------------------------------------
1709:WTPA.c        **** //-----------------------------------------------------------------------
1710:WTPA.c        **** // Encoder functions:
1711:WTPA.c        **** //-----------------------------------------------------------------------
1712:WTPA.c        **** //-----------------------------------------------------------------------
1713:WTPA.c        **** // The encoders I set this up with are 24 pulses per revolution.
1714:WTPA.c        **** // They are Bourns 652-PEC124230F-N0024, from Mouser.
1715:WTPA.c        **** // From the DS:  5mSec max bounce at 15RPM (waaay faster than we'll go) with "standard noise reduct
1716:WTPA.c        **** // This encoder (like most others) puts out 2 bit Gray code (where only one switch changes at a tim
1717:WTPA.c        **** 
1718:WTPA.c        **** // Thu Sep  2 15:04:47 EDT 2010
1719:WTPA.c        **** // OK.  More monkeying with reading the encoder shows us that a "pulse" is actually a transition of
1720:WTPA.c        **** // This is good (it means more resolution -- there are 4*24 readable transitions per revolution) bu
1721:WTPA.c        **** // Did this -- the encoder is really sensitive.  We still either miss reads or are getting switch b
1722:WTPA.c        **** 
1723:WTPA.c        **** // Thu Sep  2 16:39:43 EDT 2010 -- Added hardware filter from the panasonic datasheet.  Works a dre
1724:WTPA.c        **** 
1725:WTPA.c        **** // Encoder bit masks (dependent on port position)
1726:WTPA.c        **** #define	ENC_POS_A	0x00
1727:WTPA.c        **** #define	ENC_POS_B	0x40
1728:WTPA.c        **** #define	ENC_POS_C	0xC0
1729:WTPA.c        **** #define	ENC_POS_D	0x80
1730:WTPA.c        **** 
1731:WTPA.c        **** static void InitEncoder(void)
1732:WTPA.c        **** {
1733:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
1734:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
1735:WTPA.c        **** 	newEncoder=false;
1736:WTPA.c        **** 	encoderCw=false;
1737:WTPA.c        **** 	encoderCcw=false;
1738:WTPA.c        **** }
1739:WTPA.c        **** 
1740:WTPA.c        **** static void HandleEncoder(void)
1741:WTPA.c        **** // Fri Jun 24 11:29:53 EDT 2011
1742:WTPA.c        **** // Steps backwards from earlier prototype for some reason
1743:WTPA.c        **** {
1744:WTPA.c        **** 	static unsigned char
1745:WTPA.c        **** 		lastEncoderState=0;
1746:WTPA.c        **** 	static unsigned int
1747:WTPA.c        **** 		lastEncTime=0;
1748:WTPA.c        **** 
1749:WTPA.c        **** 	newEncoder=false;	// Clear variables which indicate changes in encoder readings
1750:WTPA.c        **** 	encoderCw=false;
1751:WTPA.c        **** 	encoderCcw=false;
1752:WTPA.c        **** 
1753:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
1754:WTPA.c        **** 	{
1755:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
1756:WTPA.c        **** 
1757:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
1758:WTPA.c        **** 
1759:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
1760:WTPA.c        **** 		{
1761:WTPA.c        **** 			if(encoderState==ENC_POS_A)
1762:WTPA.c        **** 			{
1763:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
1764:WTPA.c        **** 				{
1765:WTPA.c        **** //					encoderValue++;
1766:WTPA.c        **** 					encoderValue--;
1767:WTPA.c        **** 					encoderCcw=true;
1768:WTPA.c        **** 					newEncoder=true;
1769:WTPA.c        **** 				}
1770:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
1771:WTPA.c        **** 				{
1772:WTPA.c        **** //					encoderValue--;
1773:WTPA.c        **** 					encoderValue++;
1774:WTPA.c        **** 					encoderCw=true;
1775:WTPA.c        **** 					newEncoder=true;
1776:WTPA.c        **** 				}
1777:WTPA.c        **** 			}
1778:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
1779:WTPA.c        **** 			{
1780:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
1781:WTPA.c        **** 				{
1782:WTPA.c        **** //					encoderValue++;
1783:WTPA.c        **** 					encoderValue--;
1784:WTPA.c        **** 					encoderCcw=true;
1785:WTPA.c        **** 					newEncoder=true;
1786:WTPA.c        **** 				}
1787:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
1788:WTPA.c        **** 				{
1789:WTPA.c        **** //					encoderValue--;
1790:WTPA.c        **** 					encoderValue++;
1791:WTPA.c        **** 					encoderCw=true;
1792:WTPA.c        **** 					newEncoder=true;
1793:WTPA.c        **** 				}
1794:WTPA.c        **** 			}
1795:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
1796:WTPA.c        **** 			{
1797:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
1798:WTPA.c        **** 				{
1799:WTPA.c        **** //					encoderValue++;
1800:WTPA.c        **** 					encoderValue--;
1801:WTPA.c        **** 					encoderCcw=true;
1802:WTPA.c        **** 					newEncoder=true;
1803:WTPA.c        **** 				}
1804:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
1805:WTPA.c        **** 				{
1806:WTPA.c        **** //					encoderValue--;
1807:WTPA.c        **** 					encoderValue++;
1808:WTPA.c        **** 					encoderCw=true;
1809:WTPA.c        **** 					newEncoder=true;
1810:WTPA.c        **** 				}
1811:WTPA.c        **** 			}
1812:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
1813:WTPA.c        **** 			{
1814:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
1815:WTPA.c        **** 				{
1816:WTPA.c        **** //					encoderValue++;
1817:WTPA.c        **** 					encoderValue--;
1818:WTPA.c        **** 					encoderCcw=true;
1819:WTPA.c        **** 					newEncoder=true;
1820:WTPA.c        **** 				}
1821:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
1822:WTPA.c        **** 				{
1823:WTPA.c        **** //					encoderValue--;
1824:WTPA.c        **** 					encoderValue++;
1825:WTPA.c        **** 					encoderCw=true;
1826:WTPA.c        **** 					newEncoder=true;
1827:WTPA.c        **** 				}
1828:WTPA.c        **** 			}
1829:WTPA.c        **** 
1830:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
1831:WTPA.c        **** 		}
1832:WTPA.c        **** 	}
1833:WTPA.c        **** }
1834:WTPA.c        **** 
1835:WTPA.c        **** //-----------------------------------------------------------------------
1836:WTPA.c        **** //-----------------------------------------------------------------------
1837:WTPA.c        **** // A/D Control Functions:
1838:WTPA.c        **** //-----------------------------------------------------------------------
1839:WTPA.c        **** //-----------------------------------------------------------------------
1840:WTPA.c        **** // WTPA2 uses only one analog input (ADC0).  It's used to sample the audio input.  In old versions 
1841:WTPA.c        **** // The best resolution we can get from this hardware is 10 bits, +/- 2 lsbs.
1842:WTPA.c        **** // The max sampling rate we can pull at full resolution is 15kHz.  We always use the ADC single end
1843:WTPA.c        **** // work in differential mode with the PDIP package.  A conversion takes 13 ADC clocks normally, or 
1844:WTPA.c        **** // The datasheet is unclear how much resolution is lost above 15kHz.  Guess we'll find out!
1845:WTPA.c        **** // NOTE:  Since the RAM can only store 8 bits per sample, we're only using 8 bits of the conversion
1846:WTPA.c        **** 
1847:WTPA.c        **** /*
1848:WTPA.c        **** static void UnInitAdc(void)
1849:WTPA.c        **** {
1850:WTPA.c        **** 	ADCSRA&=~(1<<ADEN);		// Disable ADC.
1851:WTPA.c        **** 	PRR|=(1<<PRADC);		// Power down the ADC.
1852:WTPA.c        **** }
1853:WTPA.c        **** */
1854:WTPA.c        **** 
1855:WTPA.c        **** static void InitAdc(void)
1856:WTPA.c        **** // Note, we don't set up the Adc to trigger on anything right away.
1857:WTPA.c        **** {
1858:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
1859:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
1860:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
1861:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
1862:WTPA.c        **** //	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the A
1863:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
1864:WTPA.c        **** 	// ADCSRB controls auto-triggering, which we aren't using right now.
1865:WTPA.c        **** }
1866:WTPA.c        **** 
1867:WTPA.c        **** //-----------------------------------------------------------------------
1868:WTPA.c        **** // RAM / DAC functions:
1869:WTPA.c        **** //-----------------------------------------------------------------------
1870:WTPA.c        **** 
1871:WTPA.c        **** // Fri Jun 17 19:11:18 EDT 2011
1872:WTPA.c        **** // As of WTPA2 these are all inlined where they need to go.  The notes below are for posterity
1873:WTPA.c        **** 
1874:WTPA.c        **** // Will be totally different than the oldschool serial biz.....
1875:WTPA.c        **** // Should probably all be inlined in the ISR.
1876:WTPA.c        **** // Just so you remember, Parallel SRAM pretty much always works like this:
1877:WTPA.c        **** 
1878:WTPA.c        **** // The chip is always enabled (CS is always low).  The other two control pins are active low also -
1879:WTPA.c        **** // When WE is low, the value on the DATA pins is latched into the address on the ADDRESS pins.  Ass
1880:WTPA.c        **** // When WE is high, the byte stored at the ADDRESS on pins A0-A18 is latched out on the DATA pins, 
1881:WTPA.c        **** // If OE is high, the DATA port will be high impedance no matter what.
1882:WTPA.c        **** // The ADDRESS pins can always be outputs as far as the MCU is concerned.
1883:WTPA.c        **** 
1884:WTPA.c        **** // A typical write might look like:
1885:WTPA.c        **** // 1.)  OE and WE are high.
1886:WTPA.c        **** // 2.)  The address is set and the data latches on the MCU are made into outputs. The correct value
1887:WTPA.c        **** // 3.)  WE is brought low and the data is latched in.
1888:WTPA.c        **** // 4.)  WE is brought high.  The address and data lines can now be changed without messing up data 
1889:WTPA.c        **** 
1890:WTPA.c        **** // A typical read might look like this:
1891:WTPA.c        **** // 1.)  OE and WE are high.
1892:WTPA.c        **** // 2.)  The address is set correctly and the DATA PORT on the MCU is made high impedance.
1893:WTPA.c        **** // 3.)  OE is brought low, and the data to be read shows up on the DATA lines.
1894:WTPA.c        **** // 4.)  The MCU reads the DATA lines.
1895:WTPA.c        **** // 5.)  OE can be brought high again or left low -- it only needs to change if we're going to write
1896:WTPA.c        **** 
1897:WTPA.c        **** // On 373 Parallel Latches:
1898:WTPA.c        **** // These guys are pretty simple.  In this circuit, their OE is tied low (enabled).
1899:WTPA.c        **** // While LE (Latch Enable) is High, the Latch is transparent from input port to output port.
1900:WTPA.c        **** // When LE is brought low, the current state of the inputs will be latched, and the outputs will th
1901:WTPA.c        **** // So, we will will probably just leave LE low most of the time on the latches and strobe it high w
1902:WTPA.c        **** 
1903:WTPA.c        **** 
1904:WTPA.c        **** 
1905:WTPA.c        **** //-----------------------------------------------------------------------
1906:WTPA.c        **** //-----------------------------------------------------------------------
1907:WTPA.c        **** // General Sampler/ISR Functions:
1908:WTPA.c        **** //-----------------------------------------------------------------------
1909:WTPA.c        **** //-----------------------------------------------------------------------
1910:WTPA.c        **** // We've changed these to use both OCR1x interrupts and the "normal" waveform generation mode (from
1911:WTPA.c        **** // 	This allows us to generate different pitches for the two banks using TIMER1.  We do this by rea
1912:WTPA.c        **** // 	that interrupt occurs.  The OCR value will keep rolling like this, the timer will never be rese
1913:WTPA.c        **** //  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrup
1914:WTPA.c        **** 
1915:WTPA.c        **** // Tue Aug 23 18:25:06 EDT 2011
1916:WTPA.c        **** // Updated these functions to clear the sdUsingBank(x) flags when these are called so the interrupt
1917:WTPA.c        **** 
1918:WTPA.c        **** // Thu Nov 24 19:22:24 CST 2011
1919:WTPA.c        **** // Updated to account for locking banks (removed above).  Necessary now because we can be screwing 
1920:WTPA.c        **** 
1921:WTPA.c        **** static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1922:WTPA.c        **** // This code is common to all the requests to start different audio modes (record, playback, overdu
1923:WTPA.c        **** // Timer interrupts should be disabled when you call this!
1924:WTPA.c        **** {
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
1926:WTPA.c        **** 
1927:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
1928:WTPA.c        **** 	{
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
1930:WTPA.c        **** 
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
1932:WTPA.c        **** 		{
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1937:WTPA.c        **** 		}
1938:WTPA.c        **** 		else					// Bank 1 is associated with OCR1B
1939:WTPA.c        **** 		{
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
1944:WTPA.c        **** 		}
1945:WTPA.c        **** 	}
1946:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
1947:WTPA.c        **** 	{
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
1949:WTPA.c        **** 		{
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
1953:WTPA.c        **** 		}
1954:WTPA.c        **** 		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC in
1955:WTPA.c        **** 		{
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
1959:WTPA.c        **** 		}
1960:WTPA.c        **** 	}
1961:WTPA.c        **** }
1962:WTPA.c        **** 
1963:WTPA.c        **** static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
1964:WTPA.c        **** // Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the re
1965:WTPA.c        **** // If we're using the internal clock, set the rate.
1966:WTPA.c        **** // Sat Apr 11 13:49:31 CDT 2009  --  ?
1967:WTPA.c        **** // Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow th
1968:WTPA.c        **** {
1969:WTPA.c        **** 
1970:WTPA.c        **** 	unsigned char
1971:WTPA.c        **** 		sreg;
1972:WTPA.c        **** 
1973:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
1974:WTPA.c        **** 	{
1975:WTPA.c        **** 
1976:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
1977:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
1978:WTPA.c        **** 
1979:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
1980:WTPA.c        **** 
1981:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
1982:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
1983:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
1984:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
1985:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
1986:WTPA.c        **** 
1987:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
1988:WTPA.c        **** 
1989:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
1990:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
1991:WTPA.c        **** 
1992:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
1993:WTPA.c        **** 
1994:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
1995:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
1996:WTPA.c        **** 		{
1997:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
1998:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
1999:WTPA.c        **** 		}
2000:WTPA.c        **** 	}
2001:WTPA.c        **** }
2002:WTPA.c        **** 
2003:WTPA.c        **** static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2004:WTPA.c        **** // Point to the beginning of the sample, select the clock source, and get the interrupts going.
2005:WTPA.c        **** // Set the clock rate if we're using the internal clock.
2006:WTPA.c        **** // Mon Jul  6 19:05:04 CDT 2009
2007:WTPA.c        **** // We've made it clear that the beginning of the sample is relative, in the sense that if we're pla
2008:WTPA.c        **** {
2009:WTPA.c        **** 	unsigned char
2010:WTPA.c        **** 		sreg;
2011:WTPA.c        **** 
2012:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
2013:WTPA.c        **** 	{
2014:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
2015:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
2016:WTPA.c        **** 
2017:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
2018:WTPA.c        **** 
2019:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
2020:WTPA.c        **** 		{
2021:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
2022:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
2023:WTPA.c        **** 		}
2024:WTPA.c        **** 		else
2025:WTPA.c        **** 		{
2026:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
2027:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
2028:WTPA.c        **** 		}
2029:WTPA.c        **** 
2030:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio func
2031:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
2032:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
2033:WTPA.c        **** 	}
2034:WTPA.c        **** }
2035:WTPA.c        **** 
2036:WTPA.c        **** static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2037:WTPA.c        **** // Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
2038:WTPA.c        **** // Used if we pause playback and want to continue where we left off, or stop overdubbing and jump r
2039:WTPA.c        **** {
2040:WTPA.c        **** 	unsigned char
2041:WTPA.c        **** 		sreg;
2042:WTPA.c        **** 
2043:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
2044:WTPA.c        **** 	{
2045:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
2046:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
2047:WTPA.c        **** 
2048:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
2049:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
2050:WTPA.c        **** 
2051:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
2052:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
2053:WTPA.c        **** 	}
2054:WTPA.c        **** }
2055:WTPA.c        **** 
2056:WTPA.c        **** static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2057:WTPA.c        **** // Begin recording to ram at the current RAM address.
2058:WTPA.c        **** // Continue playing back from that address, too.
2059:WTPA.c        **** {
2060:WTPA.c        **** 	unsigned char
2061:WTPA.c        **** 		sreg;
2062:WTPA.c        **** 
2063:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
2064:WTPA.c        **** 	{
2065:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
2066:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
2067:WTPA.c        **** 
2068:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
2069:WTPA.c        **** 		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fu
2070:WTPA.c        **** 
2071:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
2072:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
2073:WTPA.c        **** 
2074:WTPA.c        **** 		// Throw out the results of an old conversion since it could be very old (unless it's already goi
2075:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
2076:WTPA.c        **** 		{
2077:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
2078:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
2079:WTPA.c        **** 		}
2080:WTPA.c        **** 	}
2081:WTPA.c        **** }
2082:WTPA.c        **** 
2083:WTPA.c        **** static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
2084:WTPA.c        **** // Begins processing audio in realtime on the passed channel using the passed clock source.
2085:WTPA.c        **** // Thu Nov 24 19:40:21 CST 2011
2086:WTPA.c        **** // OK to do realtime even when banks are locked since we don't use the RAM
2087:WTPA.c        **** {
2088:WTPA.c        **** 	unsigned char
2089:WTPA.c        **** 		sreg;
2090:WTPA.c        **** 
2091:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
2092:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
2093:WTPA.c        **** 
2094:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
2095:WTPA.c        **** 	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio fun
2096:WTPA.c        **** 
2097:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
2098:WTPA.c        **** 
2099:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
2100:WTPA.c        **** 	{
2101:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
2102:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
2103:WTPA.c        **** 	}
2104:WTPA.c        **** }
2105:WTPA.c        **** 
2106:WTPA.c        **** /*
2107:WTPA.c        **** static void UnInitSampleClock(void)
2108:WTPA.c        **** {
2109:WTPA.c        **** 	PRR|=(1<<PRTIM1);	// Turn the TMR1 power off.
2110:WTPA.c        **** }
2111:WTPA.c        **** */
2112:WTPA.c        **** 
2113:WTPA.c        **** static void InitSampleClock(void)
2114:WTPA.c        **** // Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
2115:WTPA.c        **** // Or just turn it on so we can use the Input Capture pin to generate interrupts for the external c
2116:WTPA.c        **** {
2117:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
2118:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
2119:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
2120:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
2121:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
2122:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
2123:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
2124:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
2125:WTPA.c        **** }
2126:WTPA.c        **** 
2127:WTPA.c        **** 
2128:WTPA.c        **** //-----------------------------------------------------------------------
2129:WTPA.c        **** // SD Memory/Filesystem handling:
2130:WTPA.c        **** //-----------------------------------------------------------------------
2131:WTPA.c        **** // Fri Jun 17 19:13:12 EDT 2011
2132:WTPA.c        **** // Update the state of the uSD card.  Detect and initialize it when it needs that kind of thing.
2133:WTPA.c        **** // Keep track of card validity and when the card is being accessed, etc etc
2134:WTPA.c        **** // WTPA2 TOC:
2135:WTPA.c        **** // ====================
2136:WTPA.c        **** // Block 0:
2137:WTPA.c        **** // 4 	chars 		"WTPA"
2138:WTPA.c        **** // 4	chars		Extended descriptor ("SAMP", "BOOT", "DPCM" -- indicates the type of data on the card)
2139:WTPA.c        **** // 8 	bytes 		don't care
2140:WTPA.c        **** // 64	bytes		Full/Empty sample slot info (512 bits which tell whether a sample is present or not in
2141:WTPA.c        **** // 432	bytes 		don't care
2142:WTPA.c        **** 
2143:WTPA.c        **** // Samples in SD-land:
2144:WTPA.c        **** // --------------------
2145:WTPA.c        **** // WTPA has a fifo in RAM which is 768 bytes long (1.5 blocks).
2146:WTPA.c        **** // Reading, we fill it a block (512 bytes) at a time.  When there is room for 512 bytes in the FIFO
2147:WTPA.c        **** // In order to not hang our state machine for two long, a fraction of a block is read at a time.  T
2148:WTPA.c        **** // Storing parameters works by storing the sample exactly as it is written to the DAC, meaning if t
2149:WTPA.c        **** // Likewise, reducing bit depth or editing a sample will mean the sample is permanently stored that
2150:WTPA.c        **** 
2151:WTPA.c        **** // Sample Format:
2152:WTPA.c        **** // ---------------
2153:WTPA.c        **** // Sample format is currently:
2154:WTPA.c        **** // 4 bytes 	==	sample length
2155:WTPA.c        **** // n bytes	==	sample
2156:WTPA.c        **** // NOTE -- we handle the case where a sample + the four byte addy is bigger than a sample slot (512
2157:WTPA.c        **** 
2158:WTPA.c        **** static void	ClearSampleToc(void)
2159:WTPA.c        **** // Empties the TOC of samples in local ram.
2160:WTPA.c        **** {
2161:WTPA.c        **** 	unsigned char
2162:WTPA.c        **** 		i;
2163:WTPA.c        **** 
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
2165:WTPA.c        **** 	{
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
2167:WTPA.c        **** 	}
2168:WTPA.c        **** }
2169:WTPA.c        **** 
2170:WTPA.c        **** static bool CheckSdSlotFull(unsigned int theSlot)
2171:WTPA.c        **** // Return true if the corresponding bit in the TOC is a 1.
2172:WTPA.c        **** // This is 64 bytes of 8 bits and we want to isolate the bit in question
2173:WTPA.c        **** {
2174:WTPA.c        **** 	unsigned char
2175:WTPA.c        **** 		theByte,
2176:WTPA.c        **** 		theBit;
2177:WTPA.c        **** 
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2180:WTPA.c        **** 
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
2182:WTPA.c        **** 	{
2183:WTPA.c        **** 		return(true);
2184:WTPA.c        **** 	}
2185:WTPA.c        **** 	else
2186:WTPA.c        **** 	{
2187:WTPA.c        **** 		return(false);
2188:WTPA.c        **** 	}
2189:WTPA.c        **** }
2190:WTPA.c        **** 
2191:WTPA.c        **** static void MarkSdSlotFull(unsigned int theSlot)
2192:WTPA.c        **** // Changes a bit in the TOC to a 1 to mark it full.
2193:WTPA.c        **** {
2194:WTPA.c        **** 	unsigned char
2195:WTPA.c        **** 		theByte,
2196:WTPA.c        **** 		theBit;
2197:WTPA.c        **** 
2198:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2199:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2200:WTPA.c        **** 
2201:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
2202:WTPA.c        **** }
2203:WTPA.c        **** 
2204:WTPA.c        **** static void MarkSdSlotEmpty(unsigned int theSlot)
2205:WTPA.c        **** // Changes a bit in the TOC to a 0 to mark it empty.
2206:WTPA.c        **** {
2207:WTPA.c        **** 	unsigned char
2208:WTPA.c        **** 		theByte,
2209:WTPA.c        **** 		theBit;
2210:WTPA.c        **** 
2211:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
2212:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
2213:WTPA.c        **** 
2214:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
2215:WTPA.c        **** }
2216:WTPA.c        **** 
2217:WTPA.c        **** enum							// The things we can recognize a card to be from it's header
2218:WTPA.c        **** 	{
2219:WTPA.c        **** 		SD_TYPE_UNFORMATTED=0,
2220:WTPA.c        **** 		SD_TYPE_SAMPLES,
2221:WTPA.c        **** 		SD_TYPE_DPCM,
2222:WTPA.c        **** 		SD_TYPE_BOOT,
2223:WTPA.c        **** 	};
2224:WTPA.c        **** 
2225:WTPA.c        **** static unsigned char GetCardFilesystem(void)
2226:WTPA.c        **** // Look for the tell tale signs of the party on this card.  If they are there, read in the TOC and 
2227:WTPA.c        **** {
2228:WTPA.c        **** 	unsigned char
2229:WTPA.c        **** 		filesystemType;
2230:WTPA.c        **** 	unsigned char
2231:WTPA.c        **** 		sdTypeBuffer[8];
2232:WTPA.c        **** 	unsigned int
2233:WTPA.c        **** 		i;
2234:WTPA.c        **** 
2235:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
2236:WTPA.c        **** 
2237:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
2238:WTPA.c        **** 	{
2239:WTPA.c        **** 		// Wait for a data packet from the card.
2240:WTPA.c        **** 		// EITHER read in the first four bytes then pull CS high  -- SD SPEC specifies that the SD card A
2241:WTPA.c        ****  		// Tue Jun 21 17:11:28 EDT 2011
2242:WTPA.c        ****  		// @@@ this appears to be bad news.  Tends to leave DO low.
2243:WTPA.c        **** 		// So --
2244:WTPA.c        **** 		// Read the first four bytes and test them, then read the remainder of the block and checksum and
2245:WTPA.c        **** 
2246:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
2247:WTPA.c        **** 
2248:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
2249:WTPA.c        **** 		{
2250:WTPA.c        **** 			HandleSoftclock();	// Kludgy
2251:WTPA.c        **** 		}
2252:WTPA.c        **** 
2253:WTPA.c        **** 		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
2254:WTPA.c        **** 		{
2255:WTPA.c        **** 			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
2256:WTPA.c        **** 		}
2257:WTPA.c        **** 
2258:WTPA.c        **** 		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A')
2259:WTPA.c        **** 		{
2260:WTPA.c        **** 			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'
2261:WTPA.c        **** 			{
2262:WTPA.c        **** 				filesystemType=SD_TYPE_SAMPLES;
2263:WTPA.c        **** 			}
2264:WTPA.c        **** 			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]
2265:WTPA.c        **** 			{
2266:WTPA.c        **** 				filesystemType=SD_TYPE_DPCM;			
2267:WTPA.c        **** 			}
2268:WTPA.c        **** 			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]
2269:WTPA.c        **** 			{
2270:WTPA.c        **** 				filesystemType=SD_TYPE_BOOT;						
2271:WTPA.c        **** 			}
2272:WTPA.c        **** 		}
2273:WTPA.c        **** 
2274:WTPA.c        **** 		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a stri
2275:WTPA.c        **** 		{
2276:WTPA.c        **** 			TransferSdByte(0xFF);
2277:WTPA.c        **** 		}
2278:WTPA.c        **** 
2279:WTPA.c        **** 		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
2280:WTPA.c        **** 		{
2281:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
2282:WTPA.c        **** 			{
2283:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
2284:WTPA.c        **** 			}
2285:WTPA.c        **** 		}
2286:WTPA.c        **** 		else
2287:WTPA.c        **** 		{
2288:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
2289:WTPA.c        **** 			{
2290:WTPA.c        **** 				TransferSdByte(0xFF);
2291:WTPA.c        **** 			}
2292:WTPA.c        **** 
2293:WTPA.c        **** 		}
2294:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
2295:WTPA.c        **** 		{
2296:WTPA.c        **** 			TransferSdByte(0xFF);
2297:WTPA.c        **** 		}
2298:WTPA.c        **** 	}
2299:WTPA.c        **** 
2300:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
2301:WTPA.c        **** 		;
2302:WTPA.c        **** 
2303:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
2304:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
2305:WTPA.c        **** 
2306:WTPA.c        **** 	return(filesystemType);
2307:WTPA.c        **** }
2308:WTPA.c        **** 
2309:WTPA.c        **** static void DoFormatCard(void)
2310:WTPA.c        **** // We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
2311:WTPA.c        **** // Give the user the option to purge the card of its evil ways, and do so and reboot.
2312:WTPA.c        **** {
2313:WTPA.c        **** 	if(subState==SS_0)
2314:WTPA.c        **** 	{
2315:WTPA.c        **** 		KillLeds();		// Turn off LEDs
2316:WTPA.c        **** 
2317:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
2318:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
2319:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
2320:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
2321:WTPA.c        **** 
2322:WTPA.c        **** 		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going 
2323:WTPA.c        **** 		subState=SS_1;
2324:WTPA.c        **** 	}
2325:WTPA.c        **** 	else if(subState==SS_1)
2326:WTPA.c        **** 	{
2327:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
2328:WTPA.c        **** 		{
2329:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
2330:WTPA.c        **** 			KillLeds();
2331:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
2332:WTPA.c        **** 			subState=SS_2;
2333:WTPA.c        **** 		}
2334:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
2335:WTPA.c        **** 		{
2336:WTPA.c        **** 			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
2337:WTPA.c        **** 		}
2338:WTPA.c        **** 	}
2339:WTPA.c        **** 	else if(subState==SS_2)
2340:WTPA.c        **** 	{
2341:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
2342:WTPA.c        **** 		{
2343:WTPA.c        **** 			KillLeds();
2344:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
2345:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
2346:WTPA.c        **** 			{
2347:WTPA.c        **** 				SetState(DoFruitcakeIntro);	// Start sampler over again.
2348:WTPA.c        **** 			}
2349:WTPA.c        **** 		}
2350:WTPA.c        **** 	}
2351:WTPA.c        **** }
2352:WTPA.c        **** 
2353:WTPA.c        **** static bool SdStartSampleRead(unsigned int sampleSlot)
2354:WTPA.c        **** // Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
2355:WTPA.c        **** // Begins a sample read in the correct spot.
2356:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2357:WTPA.c        **** {
2358:WTPA.c        **** 	unsigned char
2359:WTPA.c        **** 		sreg;
2360:WTPA.c        **** 
2361:WTPA.c        **** 	sreg=SREG;
2362:WTPA.c        **** 	cli();		// Pause ISR
2363:WTPA.c        **** 
2364:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
2365:WTPA.c        **** 	{
2366:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
2367:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
2368:WTPA.c        **** 
2369:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
2370:WTPA.c        **** 		sdFifoWritePointer=0;
2371:WTPA.c        **** 		sdBytesInFifo=0;
2372:WTPA.c        **** 
2373:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2374:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
2375:WTPA.c        **** 
2376:WTPA.c        **** 		SREG=sreg;	// Resume ISR
2377:WTPA.c        **** 
2378:WTPA.c        **** 		return(true);
2379:WTPA.c        **** 	}
2380:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2381:WTPA.c        **** 	return(false);
2382:WTPA.c        **** }
2383:WTPA.c        **** 
2384:WTPA.c        **** static void SdStartSampleWrite(unsigned int sampleSlot, unsigned long sampleLength)
2385:WTPA.c        **** // Initializes the state machine and FIFOs for writing a sample to the SD card
2386:WTPA.c        **** // NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
2387:WTPA.c        **** // Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
2388:WTPA.c        **** {
2389:WTPA.c        **** 	unsigned char
2390:WTPA.c        **** 		sreg;
2391:WTPA.c        **** 
2392:WTPA.c        **** 	sreg=SREG;
2393:WTPA.c        **** 	cli();		// Pause ISR
2394:WTPA.c        **** 
2395:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
2396:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
2397:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
2398:WTPA.c        **** 
2399:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2400:WTPA.c        **** 	sdFifoWritePointer=0;
2401:WTPA.c        **** 	sdBytesInFifo=0;
2402:WTPA.c        **** 
2403:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
2404:WTPA.c        **** 	{
2405:WTPA.c        **** 		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get fr
2406:WTPA.c        **** 	}
2407:WTPA.c        **** 	else
2408:WTPA.c        **** 	{
2409:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
2410:WTPA.c        **** 	}
2411:WTPA.c        **** 
2412:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
2413:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
2414:WTPA.c        **** 	SREG=sreg;	// Resume ISR
2415:WTPA.c        **** }
2416:WTPA.c        **** 
2417:WTPA.c        **** static void ResetSdCard(void)
2418:WTPA.c        **** // If we unceremoniously pull a card, do this.
2419:WTPA.c        **** {
2420:WTPA.c        **** 	unsigned char
2421:WTPA.c        **** 		sreg;
2422:WTPA.c        **** 
2423:WTPA.c        **** 	sreg=SREG;
2424:WTPA.c        **** 	cli();
2425:WTPA.c        **** 	
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
2427:WTPA.c        **** 	ClearSampleToc();
2428:WTPA.c        **** 	
2429:WTPA.c        **** 	// Stop SD card ISR
2430:WTPA.c        **** 
2431:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
2432:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
2433:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
2434:WTPA.c        **** 
2435:WTPA.c        **** 	// Set this contribution to the DAC to midscale (this output source is now quiet)
2436:WTPA.c        **** 	sdStreamOutput=0;
2437:WTPA.c        **** 
2438:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
2439:WTPA.c        **** 	sdFifoWritePointer=0;
2440:WTPA.c        **** 	sdBytesInFifo=0;
2441:WTPA.c        **** 
2442:WTPA.c        **** 	InitSdInterface();
2443:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
2444:WTPA.c        **** 
2445:WTPA.c        **** 	SREG=sreg;
2446:WTPA.c        **** }
2447:WTPA.c        **** 
2448:WTPA.c        **** static void UpdateCard(void)
2449:WTPA.c        **** // Updates the state machine which keeps the card reads/writes/inits going like they should.
2450:WTPA.c        **** {
2451:WTPA.c        **** 	unsigned char
2452:WTPA.c        **** 		theByte,
2453:WTPA.c        **** 		sreg,
2454:WTPA.c        **** 		i;
2455:WTPA.c        **** 
2456:WTPA.c        **** 	signed char
2457:WTPA.c        **** 		tempSample;		// Must be signed or we can get bit errors (will hold ADC data most of the time)
2458:WTPA.c        **** 
2459:WTPA.c        **** 	unsigned int
2460:WTPA.c        **** 		numTransferBytes;
2461:WTPA.c        **** 
2462:WTPA.c        **** 	static unsigned int
2463:WTPA.c        **** 		bytesLeftInBlock;	// How many bytes left in the given block
2464:WTPA.c        **** 
2465:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
2466:WTPA.c        **** 	{
2467:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
2468:WTPA.c        **** 		{
2469:WTPA.c        **** 			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2470:WTPA.c        **** 		}
2471:WTPA.c        **** 	}
2472:WTPA.c        **** 	else	// Yup, got a card
2473:WTPA.c        **** 	{
2474:WTPA.c        **** 		switch(cardState)
2475:WTPA.c        **** 		{
2476:WTPA.c        **** 
2477:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2478:WTPA.c        **** // Warmup / Init	----------------------------------------------------------------------------------
2479:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2480:WTPA.c        **** 
2481:WTPA.c        **** 			case SD_NOT_PRESENT:	// Card just inserted
2482:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
2483:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
2484:WTPA.c        **** 			break;
2485:WTPA.c        **** 
2486:WTPA.c        **** 			case SD_WARMUP:				// Card inserted, timer has been started.
2487:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
2488:WTPA.c        **** 			{
2489:WTPA.c        **** 				sdPlaybackQueued=false;
2490:WTPA.c        **** 				sdAbortRead=false;
2491:WTPA.c        **** 
2492:WTPA.c        **** 				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk
2493:WTPA.c        **** 				{
2494:WTPA.c        **** 					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that migh
2495:WTPA.c        **** 
2496:WTPA.c        **** 					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
2497:WTPA.c        **** 					{
2498:WTPA.c        **** 						cardState=SD_IDLE;			// Card is legit and ready to go.
2499:WTPA.c        **** 						InitSdIsr();				// Enable the timers necessary to give the SD card its own IRQ
2500:WTPA.c        **** 					}
2501:WTPA.c        **** 					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler
2502:WTPA.c        **** 					{
2503:WTPA.c        **** 						// @@@ Load up DPCM stuff
2504:WTPA.c        **** 					}
2505:WTPA.c        **** 
2506:WTPA.c        **** 					else	// Valid card, but either invalid filesystem or BOOT card.  Vector to "are you sure" stat
2507:WTPA.c        **** 					{
2508:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
2509:WTPA.c        **** 						ClearSampleToc();		// Write toc to zero
2510:WTPA.c        **** 						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to m
2511:WTPA.c        **** 					}
2512:WTPA.c        **** 				}
2513:WTPA.c        **** 				else	// Not a valid handshake.  Get on with our lives.
2514:WTPA.c        **** 				{
2515:WTPA.c        **** 					cardState=SD_INVALID;
2516:WTPA.c        **** 				}
2517:WTPA.c        **** 			}
2518:WTPA.c        **** 			break;
2519:WTPA.c        **** 
2520:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2521:WTPA.c        **** // Writing Samples to the Card	--------------------------------------------------------------------
2522:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2523:WTPA.c        **** 
2524:WTPA.c        **** 			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with th
2525:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2526:WTPA.c        **** 			cli();
2527:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2528:WTPA.c        **** 			{
2529:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
2530:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
2531:WTPA.c        **** 				{
2532:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2533:WTPA.c        **** 
2534:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
2535:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
2536:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
2537:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
2538:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
2539:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
2540:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
2541:WTPA.c        **** 
2542:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
2543:WTPA.c        **** 
2544:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing o
2545:WTPA.c        **** 				}
2546:WTPA.c        **** 				else // Couldn't open card for write
2547:WTPA.c        **** 				{
2548:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2549:WTPA.c        **** 				}
2550:WTPA.c        **** 			}
2551:WTPA.c        **** 			else	// Fifo not ready yet
2552:WTPA.c        **** 			{
2553:WTPA.c        **** 				SREG=sreg;	// Turn ISR back on
2554:WTPA.c        **** 			}
2555:WTPA.c        **** 			break;
2556:WTPA.c        **** 
2557:WTPA.c        **** 			case SD_WRITING_BLOCK:										// The SD card is open and we're currently writing a block.
2558:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2559:WTPA.c        **** 			{
2560:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2561:WTPA.c        **** 			}
2562:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2563:WTPA.c        **** 			{
2564:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2565:WTPA.c        **** 			}
2566:WTPA.c        **** 
2567:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
2568:WTPA.c        **** 			{
2569:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
2570:WTPA.c        **** 				{
2571:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
2572:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
2573:WTPA.c        **** 
2574:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
2575:WTPA.c        **** 
2576:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2577:WTPA.c        **** 					{
2578:WTPA.c        **** 						sdFifoReadPointer=0;
2579:WTPA.c        **** 					}
2580:WTPA.c        **** 
2581:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2582:WTPA.c        **** 					cli();
2583:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
2584:WTPA.c        **** 					SREG=sreg;
2585:WTPA.c        **** 				}
2586:WTPA.c        **** 				else	// If sample has been loaded already
2587:WTPA.c        **** 				{
2588:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
2589:WTPA.c        **** 				}
2590:WTPA.c        **** 
2591:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
2592:WTPA.c        **** 			}
2593:WTPA.c        **** 
2594:WTPA.c        **** 			// Have we written an entire block?
2595:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
2596:WTPA.c        **** 			{
2597:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2598:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2599:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2600:WTPA.c        **** 
2601:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2602:WTPA.c        **** 				{
2603:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2604:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
2605:WTPA.c        **** 				}
2606:WTPA.c        **** 				else	// Something wrong with the write.
2607:WTPA.c        **** 				{
2608:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2609:WTPA.c        **** 				}
2610:WTPA.c        **** 			}
2611:WTPA.c        **** 			break;
2612:WTPA.c        **** 
2613:WTPA.c        **** 			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writi
2614:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
2615:WTPA.c        **** 			{
2616:WTPA.c        **** 				i=0;
2617:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2618:WTPA.c        **** 				{
2619:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2620:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2621:WTPA.c        **** 					{
2622:WTPA.c        **** 						i++;	// Try again.
2623:WTPA.c        **** 					}
2624:WTPA.c        **** 					else
2625:WTPA.c        **** 					{
2626:WTPA.c        **** 						i=4;	// Got a result, stop polling
2627:WTPA.c        **** 					}
2628:WTPA.c        **** 				}
2629:WTPA.c        **** 
2630:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
2631:WTPA.c        **** 				{
2632:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2633:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2634:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2635:WTPA.c        **** 						;
2636:WTPA.c        **** 
2637:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
2638:WTPA.c        **** 					{
2639:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
2640:WTPA.c        **** 					}
2641:WTPA.c        **** 					else	// We've written the entire sample to the SD card, and the SD card block write is done.  
2642:WTPA.c        **** 					{
2643:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
2644:WTPA.c        **** 						{
2645:WTPA.c        **** 							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been fille
2646:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
2647:WTPA.c        **** 						}
2648:WTPA.c        **** 						else
2649:WTPA.c        **** 						{
2650:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
2651:WTPA.c        **** 						}
2652:WTPA.c        **** 					}
2653:WTPA.c        **** 				}
2654:WTPA.c        **** 			}
2655:WTPA.c        **** 			else	// Timed out waiting for block to write.
2656:WTPA.c        **** 			{
2657:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2658:WTPA.c        **** 			}
2659:WTPA.c        **** 			break;
2660:WTPA.c        **** 
2661:WTPA.c        **** 			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full
2662:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
2663:WTPA.c        **** 			cli();
2664:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
2665:WTPA.c        **** 			{
2666:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
2667:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
2668:WTPA.c        **** 
2669:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
2670:WTPA.c        **** 				{
2671:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
2672:WTPA.c        **** 
2673:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
2674:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
2675:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
2676:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
2677:WTPA.c        **** 				}
2678:WTPA.c        **** 				else	// Couldn't successfully open block to write
2679:WTPA.c        **** 				{
2680:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2681:WTPA.c        **** 				}
2682:WTPA.c        **** 			}
2683:WTPA.c        **** 			else	// Bytes remaining in sample, but not enough in the fifo yet
2684:WTPA.c        **** 			{
2685:WTPA.c        **** 				SREG=sreg;			// Done reading ISR variables.
2686:WTPA.c        **** 			}
2687:WTPA.c        **** 			break;
2688:WTPA.c        **** 
2689:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2690:WTPA.c        **** // Writing TOC to the Card	------------------------------------------------------------------------
2691:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2692:WTPA.c        **** 
2693:WTPA.c        **** 			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via n
2694:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
2695:WTPA.c        **** 			{
2696:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
2697:WTPA.c        **** 
2698:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2699:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
2700:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
2701:WTPA.c        **** 				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
2702:WTPA.c        **** 				TransferSdByte('T');
2703:WTPA.c        **** 				TransferSdByte('P');
2704:WTPA.c        **** 				TransferSdByte('A');
2705:WTPA.c        **** 				TransferSdByte('S');				// These four characters indicate this card holds sample data (as oppos
2706:WTPA.c        **** 				TransferSdByte('A');
2707:WTPA.c        **** 				TransferSdByte('M');
2708:WTPA.c        **** 				TransferSdByte('P');
2709:WTPA.c        **** 
2710:WTPA.c        **** 				bytesLeftInBlock-=8;
2711:WTPA.c        **** 
2712:WTPA.c        **** 				for(i=0;i<8;i++)					// 8 don't care bytes
2713:WTPA.c        **** 				{
2714:WTPA.c        **** 					TransferSdByte('x');
2715:WTPA.c        **** 				}
2716:WTPA.c        **** 
2717:WTPA.c        **** 				bytesLeftInBlock-=8;
2718:WTPA.c        **** 
2719:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
2720:WTPA.c        **** 				{
2721:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
2722:WTPA.c        **** 				}
2723:WTPA.c        **** 
2724:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
2725:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
2726:WTPA.c        **** 			}
2727:WTPA.c        **** 			else	// Block write failed
2728:WTPA.c        **** 			{
2729:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2730:WTPA.c        **** 			}
2731:WTPA.c        **** 			break;
2732:WTPA.c        **** 
2733:WTPA.c        **** 			case SD_TOC_WRITE_CONTINUE:				// Keep writing don't cares to the block until we're done.
2734:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2735:WTPA.c        **** 			{
2736:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2737:WTPA.c        **** 			}
2738:WTPA.c        **** 			else	// Less than a chunk left in the block, send the rest of the block.
2739:WTPA.c        **** 			{
2740:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2741:WTPA.c        **** 			}
2742:WTPA.c        **** 
2743:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
2744:WTPA.c        **** 			{
2745:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
2746:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
2747:WTPA.c        **** 			}
2748:WTPA.c        **** 
2749:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
2750:WTPA.c        **** 			{
2751:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2752:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
2753:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
2754:WTPA.c        **** 
2755:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
2756:WTPA.c        **** 				{
2757:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
2758:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
2759:WTPA.c        **** 				}
2760:WTPA.c        **** 				else	// Something wrong with the write.
2761:WTPA.c        **** 				{
2762:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2763:WTPA.c        **** 				}
2764:WTPA.c        **** 			}
2765:WTPA.c        **** 			break;
2766:WTPA.c        **** 
2767:WTPA.c        **** 			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
2768:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2769:WTPA.c        **** 			{
2770:WTPA.c        **** 				i=0;
2771:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is done writing
2772:WTPA.c        **** 				{
2773:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2774:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
2775:WTPA.c        **** 					{
2776:WTPA.c        **** 						i++;	// Try again.
2777:WTPA.c        **** 					}
2778:WTPA.c        **** 					else
2779:WTPA.c        **** 					{
2780:WTPA.c        **** 						i=4;	// Got a result, stop polling
2781:WTPA.c        **** 					}
2782:WTPA.c        **** 				}
2783:WTPA.c        **** 
2784:WTPA.c        **** 				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
2785:WTPA.c        **** 				{
2786:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2787:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2788:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2789:WTPA.c        **** 						;
2790:WTPA.c        **** 					cardState=SD_IDLE;				// DONE!
2791:WTPA.c        **** 				}
2792:WTPA.c        **** 			}
2793:WTPA.c        **** 			else	// Timed out waiting for block to write.
2794:WTPA.c        **** 			{
2795:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2796:WTPA.c        **** 			}
2797:WTPA.c        **** 			break;
2798:WTPA.c        **** 
2799:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2800:WTPA.c        **** // Reading Samples from the Card ------------------------------------------------------------------
2801:WTPA.c        **** // ------------------------------------------------------------------------------------------------
2802:WTPA.c        **** 
2803:WTPA.c        **** 			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token t
2804:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
2805:WTPA.c        **** 			{
2806:WTPA.c        **** 				i=0;
2807:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2808:WTPA.c        **** 				{
2809:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2810:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2811:WTPA.c        **** 					{
2812:WTPA.c        **** 						i++;	// Try again.
2813:WTPA.c        **** 					}
2814:WTPA.c        **** 					else
2815:WTPA.c        **** 					{
2816:WTPA.c        **** 						i=4;	// Got a result, stop polling
2817:WTPA.c        **** 					}
2818:WTPA.c        **** 				}
2819:WTPA.c        **** 
2820:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2821:WTPA.c        **** 				{
2822:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
2823:WTPA.c        **** 
2824:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
2825:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
2826:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
2827:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
2828:WTPA.c        **** 
2829:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
2830:WTPA.c        **** 
2831:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
2832:WTPA.c        **** 					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handl
2833:WTPA.c        **** 
2834:WTPA.c        **** 					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abor
2835:WTPA.c        **** 					{
2836:WTPA.c        **** 						cardState=SD_READ_ABORT;
2837:WTPA.c        **** 						sdAbortRead=false;
2838:WTPA.c        **** 					}
2839:WTPA.c        **** 				}
2840:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2841:WTPA.c        **** 				{
2842:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2843:WTPA.c        **** 				}
2844:WTPA.c        **** 			}
2845:WTPA.c        **** 			else	// Timed out starting read.
2846:WTPA.c        **** 			{
2847:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2848:WTPA.c        **** 			}
2849:WTPA.c        **** 			break;
2850:WTPA.c        **** 
2851:WTPA.c        **** 			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes 
2852:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
2853:WTPA.c        **** 			{
2854:WTPA.c        **** 				cardState=SD_READ_ABORT;
2855:WTPA.c        **** 				sdAbortRead=false;
2856:WTPA.c        **** 			}
2857:WTPA.c        **** 			else
2858:WTPA.c        **** 			{
2859:WTPA.c        **** 				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block
2860:WTPA.c        **** 				{
2861:WTPA.c        **** 					numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2862:WTPA.c        **** 				}
2863:WTPA.c        **** 				else	// Less than a chunk left in the block, read the rest of the block.
2864:WTPA.c        **** 				{
2865:WTPA.c        **** 					numTransferBytes=bytesLeftInBlock;
2866:WTPA.c        **** 				}
2867:WTPA.c        **** 
2868:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
2869:WTPA.c        **** 				{
2870:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
2871:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
2872:WTPA.c        **** 
2873:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
2874:WTPA.c        **** 					{
2875:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
2876:WTPA.c        **** 
2877:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
2878:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
2879:WTPA.c        **** 
2880:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
2881:WTPA.c        **** 						{
2882:WTPA.c        **** 							sdFifoWritePointer=0;
2883:WTPA.c        **** 						}
2884:WTPA.c        **** 
2885:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
2886:WTPA.c        **** 						cli();
2887:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
2888:WTPA.c        **** 						SREG=sreg;
2889:WTPA.c        **** 					}
2890:WTPA.c        **** 				}
2891:WTPA.c        **** 
2892:WTPA.c        **** 				// Check done-ness of block read:
2893:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
2894:WTPA.c        **** 				{
2895:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2896:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2897:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2898:WTPA.c        **** 						;
2899:WTPA.c        **** 
2900:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
2901:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
2902:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
2903:WTPA.c        **** 
2904:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
2905:WTPA.c        **** 					{
2906:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
2907:WTPA.c        **** 							;
2908:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
2909:WTPA.c        **** 					}
2910:WTPA.c        **** 				}
2911:WTPA.c        **** 			}
2912:WTPA.c        **** 			break;
2913:WTPA.c        **** 
2914:WTPA.c        **** 			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through e
2915:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
2916:WTPA.c        **** 			cli();
2917:WTPA.c        **** 
2918:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
2919:WTPA.c        **** 			{
2920:WTPA.c        **** 				SREG=sreg;				// ISR back on.
2921:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
2922:WTPA.c        **** 
2923:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
2924:WTPA.c        **** 				{
2925:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
2926:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
2927:WTPA.c        **** 				}
2928:WTPA.c        **** 				else	// Read failed!
2929:WTPA.c        **** 				{
2930:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2931:WTPA.c        **** 				}
2932:WTPA.c        **** 			}
2933:WTPA.c        **** 			else	// ISR has not cleared enough of the sample out of the FIFO yet.
2934:WTPA.c        **** 			{
2935:WTPA.c        **** 				SREG=sreg;	// ISR back on.
2936:WTPA.c        **** 			}
2937:WTPA.c        **** 			break;
2938:WTPA.c        **** 
2939:WTPA.c        **** 
2940:WTPA.c        **** 			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token 
2941:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
2942:WTPA.c        **** 			{
2943:WTPA.c        **** 				i=0;
2944:WTPA.c        **** 				while(i<4)		// Try a few times to see if the card is ready to give us data
2945:WTPA.c        **** 				{
2946:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
2947:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
2948:WTPA.c        **** 					{
2949:WTPA.c        **** 						i++;	// Try again.
2950:WTPA.c        **** 					}
2951:WTPA.c        **** 					else
2952:WTPA.c        **** 					{
2953:WTPA.c        **** 						i=4;	// Got a result, stop polling
2954:WTPA.c        **** 					}
2955:WTPA.c        **** 				}
2956:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
2957:WTPA.c        **** 				{
2958:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
2959:WTPA.c        **** 
2960:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
2961:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
2962:WTPA.c        **** 					{
2963:WTPA.c        **** 						cardState=SD_READ_ABORT;
2964:WTPA.c        **** 						sdAbortRead=false;
2965:WTPA.c        **** 					}
2966:WTPA.c        **** 				}
2967:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
2968:WTPA.c        **** 				{
2969:WTPA.c        **** 					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2970:WTPA.c        **** 				}
2971:WTPA.c        **** 			}
2972:WTPA.c        **** 			else	// Timed out starting read.
2973:WTPA.c        **** 			{
2974:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
2975:WTPA.c        **** 			}
2976:WTPA.c        **** 			break;
2977:WTPA.c        **** 
2978:WTPA.c        **** 			case SD_READ_ABORT:				// We've been asked to start a new playback stream from the SD while a bl
2979:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
2980:WTPA.c        **** 			{
2981:WTPA.c        **** 				numTransferBytes=SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER;
2982:WTPA.c        **** 			}
2983:WTPA.c        **** 			else	// Less than a chunk left in the block, read the rest of the block.
2984:WTPA.c        **** 			{
2985:WTPA.c        **** 				numTransferBytes=bytesLeftInBlock;
2986:WTPA.c        **** 			}
2987:WTPA.c        **** 
2988:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
2989:WTPA.c        **** 			{
2990:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
2991:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
2992:WTPA.c        **** 			}
2993:WTPA.c        **** 
2994:WTPA.c        **** 			// Check done-ness of block read:
2995:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
2996:WTPA.c        **** 			{
2997:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2998:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
2999:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
3000:WTPA.c        **** 					;
3001:WTPA.c        **** 
3002:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
3003:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
3004:WTPA.c        **** 
3005:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
3006:WTPA.c        **** 					;
3007:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
3008:WTPA.c        **** 
3009:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
3010:WTPA.c        **** 				{
3011:WTPA.c        **** 					sdPlaybackQueued=false;
3012:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
3013:WTPA.c        **** 				}
3014:WTPA.c        **** 			}
3015:WTPA.c        **** 			break;
3016:WTPA.c        **** 
3017:WTPA.c        **** 			case SD_IDLE:		// Do nothing if IDLE.
3018:WTPA.c        **** 			case SD_INVALID:	// If we're invalid, fall through and do nothing.
3019:WTPA.c        **** 			default:
3020:WTPA.c        **** 			break;
3021:WTPA.c        **** 		}
3022:WTPA.c        **** 	}
3023:WTPA.c        **** }
3024:WTPA.c        **** 
3025:WTPA.c        **** 
3026:WTPA.c        **** //-----------------------------------------------------------------------
3027:WTPA.c        **** //-----------------------------------------------------------------------
3028:WTPA.c        **** // SD Sample Read and Write Functions:
3029:WTPA.c        **** //-----------------------------------------------------------------------
3030:WTPA.c        **** //-----------------------------------------------------------------------
3031:WTPA.c        **** // The functions the main loop calls to get and put samples on the SD card.
3032:WTPA.c        **** // Sat Sep 24 19:08:17 EDT 2011
3033:WTPA.c        **** // This includes both the SD card state machine stuff (run from the main loop) and any ISRs needed 
3034:WTPA.c        **** 
3035:WTPA.c        **** 
3036:WTPA.c        **** static void InitSdIsr(void)
3037:WTPA.c        **** // Prepare a timer interrupt to handle filling and emptying the SD card's buffer
3038:WTPA.c        **** // This can fill the SRAM with data from the SD card, fill the SD card with data from the SRAM, or 
3039:WTPA.c        **** // NOTE -- we are using compare match B on timer 2 for this.  Compare match A is already used for t
3040:WTPA.c        **** // NOTE -- This means we have to call this after we finish the PWM business or the timer will be re
3041:WTPA.c        **** // Sat Sep 24 19:07:57 EDT 2011
3042:WTPA.c        **** // In our old code, we were reading and writing every 780 cycles (~25kHz) and playing back every 90
3043:WTPA.c        **** // In the new code we need to use 907/8 or 113 -- this gives a playback rate of about 22124, or an 
3044:WTPA.c        **** // We COULD go back and forth between 113 and 114, which gives us an average of 0.1% (1.73 cents) w
3045:WTPA.c        **** // Listening to some tests on the internet I can't tell the difference, so we do this the easy way 
3046:WTPA.c        **** // (Reading and writing don't matter, since we don't hear them and a small percentage difference wo
3047:WTPA.c        **** {
3048:WTPA.c        **** 	// Set up timer 2 OC2B to make SD buffer interrupts
3049:WTPA.c        **** 
3050:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
3051:WTPA.c        **** 
3052:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
3053:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
3054:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3055:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
3056:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
3057:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
3058:WTPA.c        **** 
3059:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
3060:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
3061:WTPA.c        **** }
3062:WTPA.c        **** 
3063:WTPA.c        **** static void SdIsrStartReadingRam(unsigned char theBank)
3064:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3065:WTPA.c        **** // Tell it to collect bytes from the passed bank and fill the buffer.
3066:WTPA.c        **** {
3067:WTPA.c        **** 	unsigned char
3068:WTPA.c        **** 		sreg;
3069:WTPA.c        **** 
3070:WTPA.c        **** 	sreg=SREG;
3071:WTPA.c        **** 	cli();		// Pause ISRs
3072:WTPA.c        **** 
3073:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
3074:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
3075:WTPA.c        **** 
3076:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
3077:WTPA.c        **** 	{
3078:WTPA.c        **** 		sdBank0=true;
3079:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
3080:WTPA.c        **** 	}
3081:WTPA.c        **** 	else
3082:WTPA.c        **** 	{
3083:WTPA.c        **** 		sdBank0=false;
3084:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3085:WTPA.c        **** 	}
3086:WTPA.c        **** 
3087:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3088:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3089:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3090:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3091:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3092:WTPA.c        **** 
3093:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3094:WTPA.c        **** }
3095:WTPA.c        **** 
3096:WTPA.c        **** static void SdIsrStartWritingRam(unsigned char theBank)
3097:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3098:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
3099:WTPA.c        **** {
3100:WTPA.c        **** 	unsigned char
3101:WTPA.c        **** 		sreg;
3102:WTPA.c        **** 
3103:WTPA.c        **** 	sreg=SREG;
3104:WTPA.c        **** 	cli();		// Pause ISRs
3105:WTPA.c        **** 
3106:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
3107:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
3108:WTPA.c        **** 
3109:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
3110:WTPA.c        **** 	{
3111:WTPA.c        **** 		sdBank0=true;
3112:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
3113:WTPA.c        **** 	}
3114:WTPA.c        **** 	else
3115:WTPA.c        **** 	{
3116:WTPA.c        **** 		sdBank0=false;
3117:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
3118:WTPA.c        **** 	}
3119:WTPA.c        **** 
3120:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3121:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
3122:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3123:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3124:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3125:WTPA.c        **** 
3126:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3127:WTPA.c        **** }
3128:WTPA.c        **** 
3129:WTPA.c        **** static void SdIsrStartStreamingAudio(void)
3130:WTPA.c        **** // Start the ISR that handles the SD card's buffer.
3131:WTPA.c        **** // Tell it to take the bytes in the SD buffer and put them into SRAM.
3132:WTPA.c        **** {
3133:WTPA.c        **** 	unsigned char
3134:WTPA.c        **** 		sreg;
3135:WTPA.c        **** 
3136:WTPA.c        **** 	sreg=SREG;
3137:WTPA.c        **** 	cli();		// Pause ISRs
3138:WTPA.c        **** 
3139:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
3140:WTPA.c        **** 
3141:WTPA.c        **** 	TCNT2=0;			// Init counter reg
3142:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
3143:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
3144:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
3145:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
3146:WTPA.c        **** 
3147:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
3148:WTPA.c        **** }
3149:WTPA.c        **** 
3150:WTPA.c        **** static unsigned long GetLengthOfSample(unsigned char theBank)
3151:WTPA.c        **** // Returns the length of the sample, handles my laziness.
3152:WTPA.c        **** {
3153:WTPA.c        **** 	unsigned long
3154:WTPA.c        **** 		theLength;
3155:WTPA.c        **** 
3156:WTPA.c        **** 	if(theBank==BANK_0)
3157:WTPA.c        **** 	{
3158:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3159:WTPA.c        **** 		{
3160:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
3161:WTPA.c        **** 		}
3162:WTPA.c        **** 		else
3163:WTPA.c        **** 		{
3164:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
3165:WTPA.c        **** 		}
3166:WTPA.c        **** 	}
3167:WTPA.c        **** 	else
3168:WTPA.c        **** 	{
3169:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
3170:WTPA.c        **** 		{
3171:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
3172:WTPA.c        **** 		}
3173:WTPA.c        **** 		else
3174:WTPA.c        **** 		{
3175:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
3176:WTPA.c        **** 		}
3177:WTPA.c        **** 	}
3178:WTPA.c        **** 
3179:WTPA.c        **** 	return(theLength);
3180:WTPA.c        **** }
3181:WTPA.c        **** 
3182:WTPA.c        **** //------------------------------------------------------------------------------------------
3183:WTPA.c        **** // Below are the SD functions that we call from the mainline code to write, read and stream
3184:WTPA.c        **** //------------------------------------------------------------------------------------------
3185:WTPA.c        **** 
3186:WTPA.c        **** static void WriteSampleToSd(unsigned char theBank, unsigned int theSlot)
3187:WTPA.c        **** // Takes the sample currently in the passed bank, with any audio effects applied, and puts it in th
3188:WTPA.c        **** // Makes sure the SD card has been properly groomed first.
3189:WTPA.c        **** // NOTE: SD state machine will shut down the write process itself
3190:WTPA.c        **** {
3191:WTPA.c        **** 	unsigned long
3192:WTPA.c        **** 		theLength;
3193:WTPA.c        **** 	unsigned char
3194:WTPA.c        **** 		sreg;
3195:WTPA.c        **** 
3196:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3197:WTPA.c        **** 	{
3198:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3199:WTPA.c        **** 		{
3200:WTPA.c        **** 			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank
3201:WTPA.c        **** 
3202:WTPA.c        **** 			sreg=SREG;
3203:WTPA.c        **** 			cli();		// Pause ISR
3204:WTPA.c        **** 
3205:WTPA.c        **** 			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and 
3206:WTPA.c        **** 			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3207:WTPA.c        **** 
3208:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3209:WTPA.c        **** 		}
3210:WTPA.c        **** 	}
3211:WTPA.c        **** }
3212:WTPA.c        **** 
3213:WTPA.c        **** static void ReadSampleFromSd(unsigned char theBank, unsigned int theSlot)
3214:WTPA.c        **** // Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card 
3215:WTPA.c        **** {
3216:WTPA.c        **** 	unsigned char
3217:WTPA.c        **** 		sreg;
3218:WTPA.c        **** 
3219:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3220:WTPA.c        **** 	{
3221:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
3222:WTPA.c        **** 		{
3223:WTPA.c        **** 			sreg=SREG;
3224:WTPA.c        **** 			cli();		// Pause ISR
3225:WTPA.c        **** 
3226:WTPA.c        **** 			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
3227:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
3228:WTPA.c        **** 			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's b
3229:WTPA.c        **** 
3230:WTPA.c        **** 			SREG=sreg;		// Resume ISR
3231:WTPA.c        **** 		}
3232:WTPA.c        **** 	}
3233:WTPA.c        **** }
3234:WTPA.c        **** 
3235:WTPA.c        **** static void PlaySampleFromSd(unsigned int theSlot)
3236:WTPA.c        **** // Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample i
3237:WTPA.c        **** {
3238:WTPA.c        **** 	unsigned char
3239:WTPA.c        **** 		sreg;
3240:WTPA.c        **** 
3241:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
3242:WTPA.c        **** 	{
3243:WTPA.c        **** 		sreg=SREG;	 // Pause ISRs
3244:WTPA.c        **** 		cli();
3245:WTPA.c        **** 
3246:WTPA.c        **** 		SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3247:WTPA.c        **** 		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byte
3248:WTPA.c        **** 		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3249:WTPA.c        **** 
3250:WTPA.c        **** 		SREG=sreg;	// resume isr
3251:WTPA.c        **** 	}
3252:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
3253:WTPA.c        **** 	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck u
3254:WTPA.c        **** 	{
3255:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
3256:WTPA.c        **** 		{
3257:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
3258:WTPA.c        **** 			cli();
3259:WTPA.c        **** 
3260:WTPA.c        **** 			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
3261:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
3262:WTPA.c        **** 			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
3263:WTPA.c        **** 
3264:WTPA.c        **** 			SREG=sreg;	// resume isr
3265:WTPA.c        **** 		}
3266:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
3267:WTPA.c        **** 		{
3268:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3269:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3270:WTPA.c        **** 		}
3271:WTPA.c        **** 		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and
3272:WTPA.c        **** 		{
3273:WTPA.c        **** //			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
3274:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
3275:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
3276:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
3277:WTPA.c        **** 
3278:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
3279:WTPA.c        **** 			cli();
3280:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
3281:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
3282:WTPA.c        **** 			SREG=sreg;
3283:WTPA.c        **** 		}
3284:WTPA.c        **** 	}
3285:WTPA.c        **** }
3286:WTPA.c        **** 
3287:WTPA.c        **** 
3288:WTPA.c        **** //static void CleanupSdPlayback(void)
3289:WTPA.c        **** // Runs in the main loop and makes sure that the SD state machine closes any blocks opened during S
3290:WTPA.c        **** // This happens if the user tells the sampler to do a different playback/record function and the IS
3291:WTPA.c        **** // NOTE -- the SD will not read from or write to RAM if the card is not idle, so we only need to wo
3292:WTPA.c        **** // Sun Nov 13 20:03:28 EST 2011
3293:WTPA.c        **** // Do we need to check for abort conditions anymore?  I kinda think not, since SD playback no longe
3294:WTPA.c        **** //{
3295:WTPA.c        **** //	if(sdIsrState==SD_ISR_IDLE)
3296:WTPA.c        **** //	{
3297:WTPA.c        **** //		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR 
3298:WTPA.c        **** //	}
3299:WTPA.c        **** 
3300:WTPA.c        **** /*
3301:WTPA.c        **** 	if(bankStates[BANK_0].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_0].audioFunction!=AUDIO_READ_
3302:WTPA.c        **** 	{
3303:WTPA.c        **** 		if(bankStates[BANK_1].audioFunction!=AUDIO_WRITE_SD&&bankStates[BANK_1].audioFunction!=AUDIO_READ
3304:WTPA.c        **** 		{
3305:WTPA.c        **** 			if(cardState==SD_READ_START||cardState==SD_READING_BLOCK||cardState==SD_READ_FIFO_WAIT||cardStat
3306:WTPA.c        **** 			{
3307:WTPA.c        **** 				if(cardState==SD_READ_FIFO_WAIT)	// If we're waiting for the FIFO, we can just abort; there isn
3308:WTPA.c        **** 				{
3309:WTPA.c        **** 						cardState=SD_IDLE;	// Just end it.
3310:WTPA.c        **** 				}
3311:WTPA.c        **** 				else
3312:WTPA.c        **** 				{
3313:WTPA.c        **** 						sdAbortRead=true;	// We're in mid-read.  Let the state machine know to abort the read when it
3314:WTPA.c        **** 				}
3315:WTPA.c        **** 			}
3316:WTPA.c        **** 		}
3317:WTPA.c        **** 	}
3318:WTPA.c        **** */
3319:WTPA.c        **** //}
3320:WTPA.c        **** 
3321:WTPA.c        **** //--------------------------------------
3322:WTPA.c        **** //--------------------------------------
3323:WTPA.c        **** // MIDI Functions
3324:WTPA.c        **** //--------------------------------------
3325:WTPA.c        **** //--------------------------------------
3326:WTPA.c        **** // Control Changes messages are what tells the midi state machine what to do next.
3327:WTPA.c        **** 
3328:WTPA.c        **** /*
3329:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>5)		// About 9.6k -- This is MIDI N
3330:WTPA.c        **** #define		MIDI_GENERIC_NOTE		60											// We use this to pass our midi out note when the sampler 
3331:WTPA.c        **** */
3332:WTPA.c        **** 
3333:WTPA.c        **** #define		MIDI_RECORD_RATE		((OctaveZeroCompareMatches[C_NOTE])>>4)		// 4.8k -- This is MIDI Note 48
3334:WTPA.c        **** #define		MIDI_GENERIC_NOTE		48											// We use this to pass our midi out note when the sampler 
3335:WTPA.c        **** 
3336:WTPA.c        **** static unsigned int
3337:WTPA.c        **** 	theMidiRecordRate[NUM_BANKS];		// Make this from out EEPROM data.
3338:WTPA.c        **** 
3339:WTPA.c        **** // Control Change messages:
3340:WTPA.c        **** // The messages which control binary effects (like Half Speed, or backwards masking) are just inter
3341:WTPA.c        **** 
3342:WTPA.c        **** // Fri Mar 26 22:02:22 EDT 2010
3343:WTPA.c        **** // Renumbered to undefined CCs
3344:WTPA.c        **** 
3345:WTPA.c        **** #define		MIDI_RECORDING				3
3346:WTPA.c        **** #define		MIDI_OVERDUB				9
3347:WTPA.c        **** #define		MIDI_REALTIME				14
3348:WTPA.c        **** #define		MIDI_LOOP					15
3349:WTPA.c        **** #define		MIDI_HALF_SPEED				16
3350:WTPA.c        **** #define		MIDI_PLAY_BACKWARDS			17
3351:WTPA.c        **** #define		MIDI_CANCEL_EFFECTS			18
3352:WTPA.c        **** #define		MIDI_BIT_REDUCTION			19		// Crustiness quotient.
3353:WTPA.c        **** #define 	MIDI_GRANULARITY			20		// Beatbox.
3354:WTPA.c        **** #define 	MIDI_JITTER					21		// Hisssss
3355:WTPA.c        **** #define 	MIDI_OUTPUT_COMBINATION		22		// Set the output (SUM, XOR, AND, MULT) with this message.
3356:WTPA.c        **** #define 	MIDI_STORE_RECORD_NOTE		23		// Makes the next NOTE_ON into the record rate we'll use from 
3357:WTPA.c        **** 
3358:WTPA.c        **** // Editing functions:
3359:WTPA.c        **** 
3360:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_RESOLUTE	24
3361:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_RESOLUTE		25
3362:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE	26
3363:WTPA.c        **** #define 	MIDI_REVERT_SAMPLE_TO_FULL			27
3364:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_START_WIDE		28
3365:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_END_WIDE			29
3366:WTPA.c        **** #define 	MIDI_ADJUST_SAMPLE_WINDOW_WIDE		30
3367:WTPA.c        **** 
3368:WTPA.c        **** static const unsigned int OctaveZeroCompareMatches[]=
3369:WTPA.c        **** // This table corresponds to a musical octave (the lowest octave we can generate with a 16-bit comp
3370:WTPA.c        **** {
3371:WTPA.c        **** 	65535,		// This is 300 Hz. (Followed by 600, 1.2k, 2.4k, 4.8k, 9.6k, 19.2k shifted over by 1 to 6 
3372:WTPA.c        **** 	61857,
3373:WTPA.c        **** 	58385,
3374:WTPA.c        **** 	55108,
3375:WTPA.c        **** 	52015,
3376:WTPA.c        **** 	49096,
3377:WTPA.c        **** 	46340,
3378:WTPA.c        **** 	43739,
3379:WTPA.c        **** 	41284,
3380:WTPA.c        **** 	38967,
3381:WTPA.c        **** 	36780,
3382:WTPA.c        **** 	34716,
3383:WTPA.c        **** };
3384:WTPA.c        **** 
3385:WTPA.c        **** enum	// Note names for lookups.
3386:WTPA.c        **** {
3387:WTPA.c        **** 	C_NOTE=0,
3388:WTPA.c        **** 	D_FLAT_NOTE,
3389:WTPA.c        **** 	D_NOTE,
3390:WTPA.c        **** 	E_FLAT_NOTE,
3391:WTPA.c        **** 	E_NOTE,
3392:WTPA.c        **** 	F_NOTE,
3393:WTPA.c        **** 	G_FLAT_NOTE,
3394:WTPA.c        **** 	G_NOTE,
3395:WTPA.c        **** 	A_FLAT_NOTE,
3396:WTPA.c        **** 	A_NOTE,
3397:WTPA.c        **** 	B_FLAT_NOTE,
3398:WTPA.c        **** 	B_NOTE,
3399:WTPA.c        **** };
3400:WTPA.c        **** 
3401:WTPA.c        **** static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
3402:WTPA.c        **** // Here we take a midi note number and turn it into the timer one compare match interrupt value.
3403:WTPA.c        **** {
3404:WTPA.c        **** 	unsigned char
3405:WTPA.c        **** 		theIndex,
3406:WTPA.c        **** 		theOctave;
3407:WTPA.c        **** 
3408:WTPA.c        **** 	theOctave=(theNote/12);	// Which octave?
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
3410:WTPA.c        **** 
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
3412:WTPA.c        **** 
3413:WTPA.c        **** }
3414:WTPA.c        **** 
3415:WTPA.c        **** //--------------------------------------
3416:WTPA.c        **** //--------------------------------------
3417:WTPA.c        **** // General Interface Functions
3418:WTPA.c        **** //--------------------------------------
3419:WTPA.c        **** //--------------------------------------
3420:WTPA.c        **** 
3421:WTPA.c        **** //==============================================
3422:WTPA.c        **** // Display update stuff, housekeeping:
3423:WTPA.c        **** 
3424:WTPA.c        **** static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
3425:WTPA.c        **** // We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for t
3426:WTPA.c        **** {
3427:WTPA.c        **** 	if(theBank==BANK_0)
3428:WTPA.c        **** 	{
3429:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
3430:WTPA.c        **** 	}
3431:WTPA.c        **** 	else if(theBank==BANK_1)
3432:WTPA.c        **** 	{
3433:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
3434:WTPA.c        **** 	}
3435:WTPA.c        **** }
3436:WTPA.c        **** 
3437:WTPA.c        **** static unsigned char GetMidiRecordNote(unsigned char theBank)
3438:WTPA.c        **** // Get the note we stored in EEPROM.
3439:WTPA.c        **** {
3440:WTPA.c        **** 	unsigned char
3441:WTPA.c        **** 		x;
3442:WTPA.c        **** 
3443:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3444:WTPA.c        **** 
3445:WTPA.c        **** 	if(theBank==BANK_0)
3446:WTPA.c        **** 	{
3447:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
3448:WTPA.c        **** 	}
3449:WTPA.c        **** 	else if(theBank==BANK_1)
3450:WTPA.c        **** 	{
3451:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
3452:WTPA.c        **** 	}
3453:WTPA.c        **** 
3454:WTPA.c        **** 	if(x<90)					// Legit number?
3455:WTPA.c        **** 	{
3456:WTPA.c        **** 		return(x);
3457:WTPA.c        **** 	}
3458:WTPA.c        **** 	else
3459:WTPA.c        **** 	{
3460:WTPA.c        **** 		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or 
3461:WTPA.c        **** 		return(x);
3462:WTPA.c        **** 	}
3463:WTPA.c        **** }
3464:WTPA.c        **** 
3465:WTPA.c        **** 
3466:WTPA.c        **** static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
3467:WTPA.c        **** // We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This
3468:WTPA.c        **** {
3469:WTPA.c        **** 	if(theBank==BANK_0)
3470:WTPA.c        **** 	{
3471:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
3472:WTPA.c        **** 	}
3473:WTPA.c        **** 	else if(theBank==BANK_1)
3474:WTPA.c        **** 	{
3475:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
3476:WTPA.c        **** 	}
3477:WTPA.c        **** }
3478:WTPA.c        **** 
3479:WTPA.c        **** 
3480:WTPA.c        **** static unsigned char GetMidiChannel(unsigned char theBank)
3481:WTPA.c        **** // Get the midi channel we stored in EEPROM.
3482:WTPA.c        **** {
3483:WTPA.c        **** 	unsigned char
3484:WTPA.c        **** 		x;
3485:WTPA.c        **** 
3486:WTPA.c        **** 	x=0;		// Return something non-gibberish, always.
3487:WTPA.c        **** 
3488:WTPA.c        **** 	if(theBank==BANK_0)
3489:WTPA.c        **** 	{
3490:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
3491:WTPA.c        **** 	}
3492:WTPA.c        **** 	else if(theBank==BANK_1)
3493:WTPA.c        **** 	{
3494:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
3495:WTPA.c        **** 	}
3496:WTPA.c        **** 
3497:WTPA.c        **** 	if(x<16)					// Legit number?
3498:WTPA.c        **** 	{
3499:WTPA.c        **** 		return(x);
3500:WTPA.c        **** 	}
3501:WTPA.c        **** 	else
3502:WTPA.c        **** 	{
3503:WTPA.c        **** 		if(theBank==BANK_0)
3504:WTPA.c        **** 		{
3505:WTPA.c        **** 			x=0;			// If we've got poo poo in EEPROM or a bad address then default to the first midi channel
3506:WTPA.c        **** 		}
3507:WTPA.c        **** 		else
3508:WTPA.c        **** 		{
3509:WTPA.c        **** 			x=1;			// Return midi channel 2 if we're screwing up the second bank.
3510:WTPA.c        **** 		}
3511:WTPA.c        **** 		return(x);
3512:WTPA.c        **** 	}
3513:WTPA.c        **** }
3514:WTPA.c        **** 
3515:WTPA.c        **** static void BankStatesToLeds(unsigned char theBank)
3516:WTPA.c        **** // Looks at the current bank and decides how to set the LEDs.
3517:WTPA.c        **** {
3518:WTPA.c        **** 	unsigned char
3519:WTPA.c        **** 		temp;
3520:WTPA.c        **** 
3521:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
3522:WTPA.c        **** 
3523:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
3524:WTPA.c        **** 	{
3525:WTPA.c        **** 		temp|=Om_LED_REC;
3526:WTPA.c        **** 	}
3527:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
3528:WTPA.c        **** 	{
3529:WTPA.c        **** 		temp|=Om_LED_PLAY;
3530:WTPA.c        **** 	}
3531:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
3532:WTPA.c        **** 	{
3533:WTPA.c        **** 		temp|=Om_LED_ODUB;
3534:WTPA.c        **** 	}
3535:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
3536:WTPA.c        **** 	{
3537:WTPA.c        **** 		temp|=Om_LED_REC;
3538:WTPA.c        **** 		temp|=Om_LED_PLAY;
3539:WTPA.c        **** 		temp|=Om_LED_ODUB;
3540:WTPA.c        **** 	}
3541:WTPA.c        **** 
3542:WTPA.c        **** 	if(outOfRam==true)
3543:WTPA.c        **** 	{
3544:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
3545:WTPA.c        **** 	}
3546:WTPA.c        **** 	if(theBank==BANK_1)
3547:WTPA.c        **** 	{
3548:WTPA.c        **** 		temp|=Om_LED_BANK;
3549:WTPA.c        **** 	}
3550:WTPA.c        **** 
3551:WTPA.c        **** 	ledOnOffMask=temp;
3552:WTPA.c        **** 
3553:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
3554:WTPA.c        **** 	{
3555:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
3556:WTPA.c        **** 		{
3557:WTPA.c        **** 			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in ou
3558:WTPA.c        **** 		}
3559:WTPA.c        **** 	}
3560:WTPA.c        **** 	else
3561:WTPA.c        **** 	{
3562:WTPA.c        **** 		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we 
3563:WTPA.c        **** 	}
3564:WTPA.c        **** }
3565:WTPA.c        **** 
3566:WTPA.c        **** static void EncoderReadingToLeds(void)
3567:WTPA.c        **** // Take the value on our analog input, scale it, and display it on the LEDs.
3568:WTPA.c        **** // @@@ Note, this is a badly named function since it both generates the scaled global pot value AND
3569:WTPA.c        **** {
3570:WTPA.c        **** 	unsigned char
3571:WTPA.c        **** 		temp;
3572:WTPA.c        **** 
3573:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
3574:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
3575:WTPA.c        **** 
3576:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
3577:WTPA.c        **** 	{
3578:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
3579:WTPA.c        **** 	}
3580:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
3581:WTPA.c        **** 	{
3582:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
3583:WTPA.c        **** 	}
3584:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
3585:WTPA.c        **** 	{
3586:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
3587:WTPA.c        **** 	}
3588:WTPA.c        **** 
3589:WTPA.c        **** 	ledOnOffMask=temp;		// Update the leds.
3590:WTPA.c        **** }
3591:WTPA.c        **** 
3592:WTPA.c        **** static void CleanupAudioSources(void)
3593:WTPA.c        **** // Look through all the banks, and if none are using a given interrupt source, disable that interru
3594:WTPA.c        **** // Also voids the contributions those interrupts have to the audio output.
3595:WTPA.c        **** {
3596:WTPA.c        **** 	// If we aren't streaming from the SD, void contribution to the DAC
3597:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
3598:WTPA.c        **** 	{
3599:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
3600:WTPA.c        **** 	}
3601:WTPA.c        **** 
3602:WTPA.c        **** 	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
3603:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
3604:WTPA.c        **** 	{
3605:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
3606:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
3607:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
3608:WTPA.c        **** 	}
3609:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
3610:WTPA.c        **** 	{
3611:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
3612:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
3613:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
3614:WTPA.c        **** 	}
3615:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
3616:WTPA.c        **** 	{
3617:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
3618:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
3619:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
3620:WTPA.c        **** 	}
3621:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
3622:WTPA.c        **** 	{
3623:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
3624:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
3625:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
3626:WTPA.c        **** 	}
3627:WTPA.c        **** 
3628:WTPA.c        **** 	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop
3629:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
3630:WTPA.c        **** 	{
3631:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
3632:WTPA.c        **** 		{
3633:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
3634:WTPA.c        **** 		}
3635:WTPA.c        **** 	}
3636:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
3637:WTPA.c        **** 	{
3638:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
3639:WTPA.c        **** 		{
3640:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
3641:WTPA.c        **** 		}
3642:WTPA.c        **** 	}
3643:WTPA.c        **** }
3644:WTPA.c        **** 
3645:WTPA.c        **** //--------------------------------------
3646:WTPA.c        **** //--------------------------------------
3647:WTPA.c        **** // Granularizing Functions:
3648:WTPA.c        **** //--------------------------------------
3649:WTPA.c        **** //--------------------------------------
3650:WTPA.c        **** 
3651:WTPA.c        **** static unsigned long GetRandomLongInt(void)
3652:WTPA.c        **** {
3653:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
3654:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
3655:WTPA.c        **** 	{
3656:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3657:WTPA.c        **** 	}
3658:WTPA.c        **** 	return(random31);
3659:WTPA.c        **** }
3660:WTPA.c        **** 
3661:WTPA.c        **** /*
3662:WTPA.c        **** static void InitRandom(void)
3663:WTPA.c        **** // Maximal (?) LSFR implementation complements of "curtvm" on AVRFreaks.  Thanks!
3664:WTPA.c        **** // Not sure where his tap numbers came from, but we'll see how they work out.
3665:WTPA.c        **** // This LFSR is initialized here from the poo-poo (undef'd) area of RAM and checked against zero.  
3666:WTPA.c        **** {
3667:WTPA.c        **** 	if(random31==0)	 			// If init sram happens to be 0
3668:WTPA.c        **** 	{
3669:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
3670:WTPA.c        **** 	}
3671:WTPA.c        **** }
3672:WTPA.c        **** */
3673:WTPA.c        **** 
3674:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
3675:WTPA.c        **** // Make a new random order of slices as big as the user wants, up to MAX_SLICES.
3676:WTPA.c        **** // We will first fill an array with incrementing numbers up to the number of slices we care about, 
3677:WTPA.c        **** // Leave this function having updated the number of slices our sample will be divided into and the 
3678:WTPA.c        **** // Further, point to the first random slice in the randomized array, and point the sample address t
3679:WTPA.c        **** {
 2171               		.loc 1 3679 0
 2172               		.cfi_startproc
 2173               	.LVL61:
 2174 1286 2F92      		push r2
 2175               	.LCFI2:
 2176               		.cfi_def_cfa_offset 3
 2177               		.cfi_offset 2, -2
 2178 1288 3F92      		push r3
 2179               	.LCFI3:
 2180               		.cfi_def_cfa_offset 4
 2181               		.cfi_offset 3, -3
 2182 128a 4F92      		push r4
 2183               	.LCFI4:
 2184               		.cfi_def_cfa_offset 5
 2185               		.cfi_offset 4, -4
 2186 128c 5F92      		push r5
 2187               	.LCFI5:
 2188               		.cfi_def_cfa_offset 6
 2189               		.cfi_offset 5, -5
 2190 128e 6F92      		push r6
 2191               	.LCFI6:
 2192               		.cfi_def_cfa_offset 7
 2193               		.cfi_offset 6, -6
 2194 1290 7F92      		push r7
 2195               	.LCFI7:
 2196               		.cfi_def_cfa_offset 8
 2197               		.cfi_offset 7, -7
 2198 1292 8F92      		push r8
 2199               	.LCFI8:
 2200               		.cfi_def_cfa_offset 9
 2201               		.cfi_offset 8, -8
 2202 1294 9F92      		push r9
 2203               	.LCFI9:
 2204               		.cfi_def_cfa_offset 10
 2205               		.cfi_offset 9, -9
 2206 1296 AF92      		push r10
 2207               	.LCFI10:
 2208               		.cfi_def_cfa_offset 11
 2209               		.cfi_offset 10, -10
 2210 1298 BF92      		push r11
 2211               	.LCFI11:
 2212               		.cfi_def_cfa_offset 12
 2213               		.cfi_offset 11, -11
 2214 129a CF92      		push r12
 2215               	.LCFI12:
 2216               		.cfi_def_cfa_offset 13
 2217               		.cfi_offset 12, -12
 2218 129c DF92      		push r13
 2219               	.LCFI13:
 2220               		.cfi_def_cfa_offset 14
 2221               		.cfi_offset 13, -13
 2222 129e EF92      		push r14
 2223               	.LCFI14:
 2224               		.cfi_def_cfa_offset 15
 2225               		.cfi_offset 14, -14
 2226 12a0 FF92      		push r15
 2227               	.LCFI15:
 2228               		.cfi_def_cfa_offset 16
 2229               		.cfi_offset 15, -15
 2230 12a2 0F93      		push r16
 2231               	.LCFI16:
 2232               		.cfi_def_cfa_offset 17
 2233               		.cfi_offset 16, -16
 2234 12a4 1F93      		push r17
 2235               	.LCFI17:
 2236               		.cfi_def_cfa_offset 18
 2237               		.cfi_offset 17, -17
 2238 12a6 CF93      		push r28
 2239               	.LCFI18:
 2240               		.cfi_def_cfa_offset 19
 2241               		.cfi_offset 28, -18
 2242 12a8 DF93      		push r29
 2243               	.LCFI19:
 2244               		.cfi_def_cfa_offset 20
 2245               		.cfi_offset 29, -19
 2246 12aa CDB7      		in r28,__SP_L__
 2247 12ac DEB7      		in r29,__SP_H__
 2248               	.LCFI20:
 2249               		.cfi_def_cfa_register 28
 2250 12ae 2797      		sbiw r28,7
 2251               	.LCFI21:
 2252               		.cfi_def_cfa_offset 27
 2253 12b0 0FB6      		in __tmp_reg__,__SREG__
 2254 12b2 F894      		cli
 2255 12b4 DEBF      		out __SP_H__,r29
 2256 12b6 0FBE      		out __SREG__,__tmp_reg__
 2257 12b8 CDBF      		out __SP_L__,r28
 2258               	/* prologue: function */
 2259               	/* frame size = 7 */
 2260               	/* stack size = 25 */
 2261               	.L__stack_usage = 25
 2262 12ba 282E      		mov r2,r24
3680:WTPA.c        **** 	unsigned char
3681:WTPA.c        **** 		sreg,
3682:WTPA.c        **** 		i,
3683:WTPA.c        **** 		origContents,
3684:WTPA.c        **** 		randIndex,
3685:WTPA.c        **** 		randContents;
3686:WTPA.c        **** 
3687:WTPA.c        **** 	if(numSlices>1)		// Enough slices to do something?
 2263               		.loc 1 3687 0
 2264 12bc 6230      		cpi r22,lo8(2)
 2265 12be 00F4      		brsh .+2
 2266 12c0 00C0      		rjmp .L153
3688:WTPA.c        **** 	{
3689:WTPA.c        **** 		sreg=SREG;
 2267               		.loc 1 3689 0
 2268 12c2 2FB7      		in r18,__SREG__
 2269 12c4 2D83      		std Y+5,r18
 2270               	.LVL62:
3690:WTPA.c        **** 		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
 2271               		.loc 1 3690 0
 2272               	/* #APP */
 2273               	 ;  3690 "WTPA.c" 1
 2274 12c6 F894      		cli
 2275               	 ;  0 "" 2
 2276               	/* #NOAPP */
 2277 12c8 062F      		mov r16,r22
 2278 12ca 6138      		cpi r22,lo8(-127)
 2279 12cc 00F0      		brlo .+2
 2280 12ce 00C0      		rjmp .L164
 2281               	.L154:
 2282               	.LVL63:
 2283 12d0 422D      		mov r20,r2
 2284 12d2 50E0      		ldi r21,0
 2285 12d4 5C83      		std Y+4,r21
 2286 12d6 4B83      		std Y+3,r20
3674:WTPA.c        **** static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
 2287               		.loc 1 3674 0
 2288 12d8 5695      		lsr r21
 2289 12da 542F      		mov r21,r20
 2290 12dc 4427      		clr r20
 2291 12de 5795      		ror r21
 2292 12e0 4795      		ror r20
 2293 12e2 5A83      		std Y+2,r21
 2294 12e4 4983      		std Y+1,r20
 2295 12e6 9A01      		movw r18,r20
 2296               	.LVL64:
 2297 12e8 2050      		subi r18,lo8(-(granularPositionArray))
 2298 12ea 3040      		sbci r19,hi8(-(granularPositionArray))
 2299 12ec F901      		movw r30,r18
3691:WTPA.c        **** 
3692:WTPA.c        **** 		if(numSlices>MAX_SLICES)
3693:WTPA.c        **** 		{
3694:WTPA.c        **** 			numSlices=MAX_SLICES;
3695:WTPA.c        **** 		}
3696:WTPA.c        **** 
3697:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2300               		.loc 1 3697 0
 2301 12ee 80E0      		ldi r24,0
 2302               	.LVL65:
 2303               	.L155:
3698:WTPA.c        **** 		{
3699:WTPA.c        **** 			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwa
 2304               		.loc 1 3699 0 discriminator 2
 2305 12f0 8193      		st Z+,r24
3697:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2306               		.loc 1 3697 0 discriminator 2
 2307 12f2 8F5F      		subi r24,lo8(-(1))
 2308               	.LVL66:
 2309 12f4 8017      		cp r24,r16
 2310 12f6 00F0      		brlo .L155
 2311 12f8 402E      		mov r4,r16
 2312 12fa 512C      		mov r5,__zero_reg__
 2313 12fc 612C      		mov r6,__zero_reg__
 2314 12fe 712C      		mov r7,__zero_reg__
 2315 1300 C090 0000 		lds r12,random31
 2316 1304 D090 0000 		lds r13,random31+1
 2317 1308 E090 0000 		lds r14,random31+2
 2318 130c F090 0000 		lds r15,random31+3
3697:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
 2319               		.loc 1 3697 0 is_stmt 0
 2320 1310 10E0      		ldi r17,0
 2321 1312 3F83      		std Y+7,r19
 2322 1314 2E83      		std Y+6,r18
 2323 1316 D901      		movw r26,r18
 2324 1318 00C0      		rjmp .L158
 2325               	.LVL67:
 2326               	.L157:
 2327 131a 7501      		movw r14,r10
 2328 131c 6401      		movw r12,r8
 2329               	.LVL68:
3700:WTPA.c        **** 		}
3701:WTPA.c        **** 
3702:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
3703:WTPA.c        **** 		{
3704:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
3705:WTPA.c        **** 			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care abo
 2330               		.loc 1 3705 0 is_stmt 1 discriminator 2
 2331 131e C501      		movw r24,r10
 2332 1320 B401      		movw r22,r8
 2333 1322 A301      		movw r20,r6
 2334 1324 9201      		movw r18,r4
 2335 1326 0E94 0000 		call __udivmodsi4
3706:WTPA.c        **** 			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery ad
 2336               		.loc 1 3706 0 discriminator 2
 2337 132a FB01      		movw r30,r22
 2338 132c 2981      		ldd r18,Y+1
 2339 132e 3A81      		ldd r19,Y+2
 2340 1330 E20F      		add r30,r18
 2341 1332 F31F      		adc r31,r19
 2342 1334 E050      		subi r30,lo8(-(granularPositionArray))
 2343 1336 F040      		sbci r31,hi8(-(granularPositionArray))
 2344 1338 8081      		ld r24,Z
 2345               	.LVL69:
3707:WTPA.c        **** 			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the
 2346               		.loc 1 3707 0 discriminator 2
 2347 133a AE81      		ldd r26,Y+6
 2348 133c BF81      		ldd r27,Y+7
 2349 133e 8D93      		st X+,r24
 2350 1340 BF83      		std Y+7,r27
 2351 1342 AE83      		std Y+6,r26
3708:WTPA.c        **** 			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original reg
 2352               		.loc 1 3708 0 discriminator 2
 2353 1344 3082      		st Z,r3
3702:WTPA.c        **** 		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffl
 2354               		.loc 1 3702 0 discriminator 2
 2355 1346 1F5F      		subi r17,lo8(-(1))
 2356               	.LVL70:
 2357 1348 1017      		cp r17,r16
 2358 134a 00F4      		brsh .L165
 2359               	.LVL71:
 2360               	.L158:
3704:WTPA.c        **** 			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array ad
 2361               		.loc 1 3704 0 discriminator 2
 2362 134c 3C90      		ld r3,X
 2363 134e 4601      		movw r8,r12
 2364 1350 5701      		movw r10,r14
 2365 1352 880C      		lsl r8
 2366 1354 991C      		rol r9
 2367 1356 AA1C      		rol r10
 2368 1358 BB1C      		rol r11
 2369 135a F6FE      		sbrs r15,6
 2370 135c 00C0      		rjmp .L157
 2371               	.LBB136:
 2372               	.LBB137:
3656:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 2373               		.loc 1 3656 0 discriminator 2
 2374 135e B5EB      		ldi r27,181
 2375 1360 8B26      		eor r8,r27
 2376 1362 B5E9      		ldi r27,149
 2377 1364 9B26      		eor r9,r27
 2378 1366 BAEA      		ldi r27,170
 2379 1368 AB26      		eor r10,r27
 2380 136a B0E2      		ldi r27,32
 2381 136c BB26      		eor r11,r27
 2382 136e 00C0      		rjmp .L157
 2383               	.LVL72:
 2384               	.L165:
 2385 1370 8092 0000 		sts random31,r8
 2386 1374 9092 0000 		sts random31+1,r9
 2387 1378 A092 0000 		sts random31+2,r10
 2388 137c B092 0000 		sts random31+3,r11
 2389               	.LBE137:
 2390               	.LBE136:
3709:WTPA.c        **** 		}
3710:WTPA.c        **** 
3711:WTPA.c        **** 		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
 2391               		.loc 1 3711 0
 2392 1380 2220      		tst r2
 2393 1382 01F4      		brne .+2
 2394 1384 00C0      		rjmp .L166
3712:WTPA.c        **** 		{
3713:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
3714:WTPA.c        **** 		}
3715:WTPA.c        **** 		else					// Otherwise assume banks grow down.
3716:WTPA.c        **** 		{
3717:WTPA.c        **** 			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
 2395               		.loc 1 3717 0
 2396 1386 8091 0000 		lds r24,bankStates+49
 2397 138a 9091 0000 		lds r25,bankStates+49+1
 2398 138e A091 0000 		lds r26,bankStates+49+2
 2399 1392 B091 0000 		lds r27,bankStates+49+3
 2400               	.LVL73:
 2401 1396 CC24      		clr r12
 2402 1398 CA94      		dec r12
 2403 139a DC2C      		mov r13,r12
 2404 139c 37E0      		ldi r19,lo8(7)
 2405 139e E32E      		mov r14,r19
 2406 13a0 F12C      		mov r15,__zero_reg__
 2407 13a2 A701      		movw r20,r14
 2408 13a4 9601      		movw r18,r12
 2409 13a6 281B      		sub r18,r24
 2410 13a8 390B      		sbc r19,r25
 2411 13aa 4A0B      		sbc r20,r26
 2412 13ac 5B0B      		sbc r21,r27
 2413 13ae CA01      		movw r24,r20
 2414 13b0 B901      		movw r22,r18
 2415 13b2 A301      		movw r20,r6
 2416 13b4 9201      		movw r18,r4
 2417 13b6 0E94 0000 		call __udivmodsi4
 2418               	.LVL74:
 2419 13ba 2093 0000 		sts sliceSize+4,r18
 2420 13be 3093 0000 		sts sliceSize+4+1,r19
 2421 13c2 4093 0000 		sts sliceSize+4+2,r20
 2422 13c6 5093 0000 		sts sliceSize+4+3,r21
3718:WTPA.c        **** 		}
3719:WTPA.c        **** 
3720:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
 2423               		.loc 1 3720 0
 2424 13ca 84E2      		ldi r24,lo8(36)
 2425 13cc 4B81      		ldd r20,Y+3
 2426 13ce 5C81      		ldd r21,Y+4
 2427 13d0 849F      		mul r24,r20
 2428 13d2 F001      		movw r30,r0
 2429 13d4 859F      		mul r24,r21
 2430 13d6 F00D      		add r31,r0
 2431 13d8 1124      		clr __zero_reg__
 2432 13da E050      		subi r30,lo8(-(bankStates))
 2433 13dc F040      		sbci r31,hi8(-(bankStates))
 2434 13de 0783      		std Z+7,r16
3721:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
 2435               		.loc 1 3721 0
 2436 13e0 FA01      		movw r30,r20
 2437 13e2 E050      		subi r30,lo8(-(granularPositionArrayPointer))
 2438 13e4 F040      		sbci r31,hi8(-(granularPositionArrayPointer))
 2439 13e6 1082      		st Z,__zero_reg__
3722:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
 2440               		.loc 1 3722 0
 2441 13e8 9A01      		movw r18,r20
 2442 13ea 220F      		lsl r18
 2443 13ec 331F      		rol r19
 2444 13ee 220F      		lsl r18
 2445 13f0 331F      		rol r19
 2446 13f2 F901      		movw r30,r18
 2447 13f4 E050      		subi r30,lo8(-(sliceSize))
 2448 13f6 F040      		sbci r31,hi8(-(sliceSize))
 2449 13f8 8081      		ld r24,Z
 2450 13fa 9181      		ldd r25,Z+1
 2451 13fc A281      		ldd r26,Z+2
 2452 13fe B381      		ldd r27,Z+3
 2453 1400 F901      		movw r30,r18
 2454 1402 E050      		subi r30,lo8(-(sliceRemaining))
 2455 1404 F040      		sbci r31,hi8(-(sliceRemaining))
 2456 1406 8083      		st Z,r24
 2457 1408 9183      		std Z+1,r25
 2458 140a A283      		std Z+2,r26
 2459 140c B383      		std Z+3,r27
3723:WTPA.c        **** 
3724:WTPA.c        **** 		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the fir
3725:WTPA.c        **** 		{
3726:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
3727:WTPA.c        **** 		}
3728:WTPA.c        **** 		else
3729:WTPA.c        **** 		{
3730:WTPA.c        **** 			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceS
 2460               		.loc 1 3730 0
 2461 140e 2091 0000 		lds r18,sliceSize+4
 2462 1412 3091 0000 		lds r19,sliceSize+4+1
 2463 1416 4091 0000 		lds r20,sliceSize+4+2
 2464 141a 5091 0000 		lds r21,sliceSize+4+3
 2465 141e A091 0000 		lds r26,granularPositionArray+128
 2466 1422 B0E0      		ldi r27,0
 2467 1424 0E94 0000 		call __muluhisi3
 2468 1428 C61A      		sub r12,r22
 2469 142a D70A      		sbc r13,r23
 2470 142c E80A      		sbc r14,r24
 2471 142e F90A      		sbc r15,r25
 2472 1430 C092 0000 		sts bankStates+68,r12
 2473 1434 D092 0000 		sts bankStates+68+1,r13
 2474 1438 E092 0000 		sts bankStates+68+2,r14
 2475 143c F092 0000 		sts bankStates+68+3,r15
 2476               	.L160:
3731:WTPA.c        **** 		}
3732:WTPA.c        **** 
3733:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 2477               		.loc 1 3733 0
 2478 1440 5D81      		ldd r21,Y+5
 2479 1442 5FBF      		out __SREG__,r21
 2480               	.LVL75:
 2481               	.L152:
 2482               	/* epilogue start */
3734:WTPA.c        **** 	}
3735:WTPA.c        **** 	else
3736:WTPA.c        **** 	{
3737:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
3738:WTPA.c        **** 	}
3739:WTPA.c        **** }
 2483               		.loc 1 3739 0
 2484 1444 2796      		adiw r28,7
 2485 1446 0FB6      		in __tmp_reg__,__SREG__
 2486 1448 F894      		cli
 2487 144a DEBF      		out __SP_H__,r29
 2488 144c 0FBE      		out __SREG__,__tmp_reg__
 2489 144e CDBF      		out __SP_L__,r28
 2490 1450 DF91      		pop r29
 2491 1452 CF91      		pop r28
 2492 1454 1F91      		pop r17
 2493 1456 0F91      		pop r16
 2494 1458 FF90      		pop r15
 2495 145a EF90      		pop r14
 2496 145c DF90      		pop r13
 2497 145e CF90      		pop r12
 2498 1460 BF90      		pop r11
 2499 1462 AF90      		pop r10
 2500 1464 9F90      		pop r9
 2501 1466 8F90      		pop r8
 2502 1468 7F90      		pop r7
 2503 146a 6F90      		pop r6
 2504 146c 5F90      		pop r5
 2505 146e 4F90      		pop r4
 2506 1470 3F90      		pop r3
 2507 1472 2F90      		pop r2
 2508               	.LVL76:
 2509 1474 0895      		ret
 2510               	.LVL77:
 2511               	.L166:
3713:WTPA.c        **** 			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
 2512               		.loc 1 3713 0
 2513 1476 6091 0000 		lds r22,bankStates+13
 2514 147a 7091 0000 		lds r23,bankStates+13+1
 2515 147e 8091 0000 		lds r24,bankStates+13+2
 2516 1482 9091 0000 		lds r25,bankStates+13+3
 2517 1486 A301      		movw r20,r6
 2518 1488 9201      		movw r18,r4
 2519 148a 0E94 0000 		call __udivmodsi4
 2520 148e 2093 0000 		sts sliceSize,r18
 2521 1492 3093 0000 		sts sliceSize+1,r19
 2522 1496 4093 0000 		sts sliceSize+2,r20
 2523 149a 5093 0000 		sts sliceSize+3,r21
3720:WTPA.c        **** 		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided int
 2524               		.loc 1 3720 0
 2525 149e 0093 0000 		sts bankStates+7,r16
3721:WTPA.c        **** 		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
 2526               		.loc 1 3721 0
 2527 14a2 1092 0000 		sts granularPositionArrayPointer,__zero_reg__
3722:WTPA.c        **** 		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
 2528               		.loc 1 3722 0
 2529 14a6 8091 0000 		lds r24,sliceSize
 2530 14aa 9091 0000 		lds r25,sliceSize+1
 2531 14ae A091 0000 		lds r26,sliceSize+2
 2532 14b2 B091 0000 		lds r27,sliceSize+3
 2533               	.LVL78:
 2534 14b6 8093 0000 		sts sliceRemaining,r24
 2535 14ba 9093 0000 		sts sliceRemaining+1,r25
 2536 14be A093 0000 		sts sliceRemaining+2,r26
 2537 14c2 B093 0000 		sts sliceRemaining+3,r27
3726:WTPA.c        **** 			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_S
 2538               		.loc 1 3726 0
 2539 14c6 2091 0000 		lds r18,sliceSize
 2540 14ca 3091 0000 		lds r19,sliceSize+1
 2541 14ce 4091 0000 		lds r20,sliceSize+2
 2542 14d2 5091 0000 		lds r21,sliceSize+3
 2543 14d6 A091 0000 		lds r26,granularPositionArray
 2544 14da B0E0      		ldi r27,0
 2545 14dc 0E94 0000 		call __muluhisi3
 2546 14e0 6093 0000 		sts bankStates+32,r22
 2547 14e4 7093 0000 		sts bankStates+32+1,r23
 2548 14e8 8093 0000 		sts bankStates+32+2,r24
 2549 14ec 9093 0000 		sts bankStates+32+3,r25
 2550 14f0 00C0      		rjmp .L160
 2551               	.LVL79:
 2552               	.L164:
 2553 14f2 00E8      		ldi r16,lo8(-128)
 2554               	.LVL80:
 2555 14f4 00C0      		rjmp .L154
 2556               	.LVL81:
 2557               	.L153:
3737:WTPA.c        **** 		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
 2558               		.loc 1 3737 0
 2559 14f6 84E2      		ldi r24,lo8(36)
 2560 14f8 289E      		mul r2,r24
 2561 14fa F001      		movw r30,r0
 2562 14fc 1124      		clr __zero_reg__
 2563 14fe E050      		subi r30,lo8(-(bankStates))
 2564 1500 F040      		sbci r31,hi8(-(bankStates))
 2565 1502 1782      		std Z+7,__zero_reg__
 2566 1504 00C0      		rjmp .L152
 2567               		.cfi_endproc
 2568               	.LFE62:
 2571               	UpdateAdjustedSampleAddresses:
 2572               	.LFB63:
3740:WTPA.c        **** 
3741:WTPA.c        **** //--------------------------------------
3742:WTPA.c        **** //--------------------------------------
3743:WTPA.c        **** // Shuttle / Loop Size Adjust Functions:
3744:WTPA.c        **** //--------------------------------------
3745:WTPA.c        **** //--------------------------------------
3746:WTPA.c        **** // These functions are called to bump the beginning of a sample forward or backward by an amount di
3747:WTPA.c        **** // The resolution of these functions is dependent on the absolute number of individual samples curr
3748:WTPA.c        **** // 	we divide the entire sample by 256 to find our "chunk size" and then shuttle the sample start /
3749:WTPA.c        **** // NOTE:  It is possible with these commands to position the sample's working boundaries such that 
3750:WTPA.c        **** // NOTE:  It is possible to move a sample's adjusted end come BEFORE its adjusted beginning.  We mu
3751:WTPA.c        **** // NOTE:  It is possible to have the sample roll around the end address.  Account for this.
3752:WTPA.c        **** 
3753:WTPA.c        **** // We will need to update the ISR so that playback rolls through the end address.
3754:WTPA.c        **** // Mon Nov  9 22:32:16 EST 2009 -- Think I got it.
3755:WTPA.c        **** 
3756:WTPA.c        **** // Thu Mar 25 21:44:28 EDT 2010
3757:WTPA.c        **** // Window problems.  When the window wraps around the absolute address of the sample, bad shit goes
3758:WTPA.c        **** // Fri Mar 26 14:46:06 EDT 2010
3759:WTPA.c        **** // Fixed.  I made some dumb changes to the ISR address wrapping and also didn't accout for the fact
3760:WTPA.c        **** 
3761:WTPA.c        **** // Fri Mar 26 18:55:07 EDT 2010
3762:WTPA.c        **** // Changed the way the whole sampler thinks about "direction" in playback.  The user sets the backw
3763:WTPA.c        **** // The variable read by the interrupt is "sampleDirection" which actually tells us which way to go 
3764:WTPA.c        **** // This system lets us arbitrarily set the way we want the sample to go, and then reverse it when t
3765:WTPA.c        **** 
3766:WTPA.c        **** static void UpdateAdjustedSampleAddresses(unsigned char theBank)
3767:WTPA.c        **** // Using window, start, and stop info, this routine sets the beginning and end point within a sampl
3768:WTPA.c        **** // We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of th
3769:WTPA.c        **** // Wed Jun 22 13:50:04 EDT 2011
3770:WTPA.c        **** // Now that we use an encoder we could adjust this more finely if we wanted to.
3771:WTPA.c        **** {
 2573               		.loc 1 3771 0
 2574               		.cfi_startproc
 2575               	.LVL82:
 2576 1506 4F92      		push r4
 2577               	.LCFI22:
 2578               		.cfi_def_cfa_offset 3
 2579               		.cfi_offset 4, -2
 2580 1508 5F92      		push r5
 2581               	.LCFI23:
 2582               		.cfi_def_cfa_offset 4
 2583               		.cfi_offset 5, -3
 2584 150a 6F92      		push r6
 2585               	.LCFI24:
 2586               		.cfi_def_cfa_offset 5
 2587               		.cfi_offset 6, -4
 2588 150c 7F92      		push r7
 2589               	.LCFI25:
 2590               		.cfi_def_cfa_offset 6
 2591               		.cfi_offset 7, -5
 2592 150e 8F92      		push r8
 2593               	.LCFI26:
 2594               		.cfi_def_cfa_offset 7
 2595               		.cfi_offset 8, -6
 2596 1510 9F92      		push r9
 2597               	.LCFI27:
 2598               		.cfi_def_cfa_offset 8
 2599               		.cfi_offset 9, -7
 2600 1512 AF92      		push r10
 2601               	.LCFI28:
 2602               		.cfi_def_cfa_offset 9
 2603               		.cfi_offset 10, -8
 2604 1514 BF92      		push r11
 2605               	.LCFI29:
 2606               		.cfi_def_cfa_offset 10
 2607               		.cfi_offset 11, -9
 2608 1516 CF92      		push r12
 2609               	.LCFI30:
 2610               		.cfi_def_cfa_offset 11
 2611               		.cfi_offset 12, -10
 2612 1518 DF92      		push r13
 2613               	.LCFI31:
 2614               		.cfi_def_cfa_offset 12
 2615               		.cfi_offset 13, -11
 2616 151a EF92      		push r14
 2617               	.LCFI32:
 2618               		.cfi_def_cfa_offset 13
 2619               		.cfi_offset 14, -12
 2620 151c FF92      		push r15
 2621               	.LCFI33:
 2622               		.cfi_def_cfa_offset 14
 2623               		.cfi_offset 15, -13
 2624               	/* prologue: function */
 2625               	/* frame size = 0 */
 2626               	/* stack size = 12 */
 2627               	.L__stack_usage = 12
3772:WTPA.c        **** 	unsigned char
3773:WTPA.c        **** 		sreg;
3774:WTPA.c        **** 	unsigned long
3775:WTPA.c        **** 		chunkSize;
3776:WTPA.c        **** 
3777:WTPA.c        **** 	sreg=SREG;
 2628               		.loc 1 3777 0
 2629 151e EFB7      		in r30,__SREG__
 2630               	.LVL83:
3778:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 2631               		.loc 1 3778 0
 2632               	/* #APP */
 2633               	 ;  3778 "WTPA.c" 1
 2634 1520 F894      		cli
 2635               	 ;  0 "" 2
3779:WTPA.c        **** 
3780:WTPA.c        **** 	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
 2636               		.loc 1 3780 0
 2637               	/* #NOAPP */
 2638 1522 8111      		cpse r24,__zero_reg__
 2639 1524 00C0      		rjmp .L168
3781:WTPA.c        **** 	{
3782:WTPA.c        **** 		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of
 2640               		.loc 1 3782 0
 2641 1526 8091 0000 		lds r24,bankStates+13
 2642 152a 9091 0000 		lds r25,bankStates+13+1
 2643 152e A091 0000 		lds r26,bankStates+13+2
 2644 1532 B091 0000 		lds r27,bankStates+13+3
 2645               	.LVL84:
 2646 1536 880F      		lsl r24
 2647 1538 991F      		rol r25
 2648 153a AA1F      		rol r26
 2649 153c BB1F      		rol r27
 2650 153e 880F      		lsl r24
 2651 1540 991F      		rol r25
 2652 1542 AA1F      		rol r26
 2653 1544 BB1F      		rol r27
 2654 1546 880F      		lsl r24
 2655 1548 991F      		rol r25
 2656 154a AA1F      		rol r26
 2657 154c BB1F      		rol r27
 2658 154e 892E      		mov r8,r25
 2659 1550 9A2E      		mov r9,r26
 2660 1552 AB2E      		mov r10,r27
 2661 1554 BB24      		clr r11
 2662               	.LVL85:
3783:WTPA.c        **** 
3784:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3785:WTPA.c        **** 
3786:WTPA.c        **** 		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sam
 2663               		.loc 1 3786 0
 2664 1556 A091 0000 		lds r26,bankStates+29
 2665 155a 8091 0000 		lds r24,bankStates+31
 2666 155e B0E0      		ldi r27,0
 2667 1560 A80F      		add r26,r24
 2668 1562 B11D      		adc r27,__zero_reg__
 2669 1564 A501      		movw r20,r10
 2670 1566 9401      		movw r18,r8
 2671 1568 0E94 0000 		call __muluhisi3
 2672 156c F3E0      		ldi r31,3
 2673               		1:
 2674 156e 9695      		lsr r25
 2675 1570 8795      		ror r24
 2676 1572 7795      		ror r23
 2677 1574 6795      		ror r22
 2678 1576 FA95      		dec r31
 2679 1578 01F4      		brne 1b
 2680 157a 6093 0000 		sts bankStates+25,r22
 2681 157e 7093 0000 		sts bankStates+25+1,r23
 2682 1582 8093 0000 		sts bankStates+25+2,r24
 2683 1586 9093 0000 		sts bankStates+25+3,r25
3787:WTPA.c        **** 		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_
 2684               		.loc 1 3787 0
 2685 158a 4090 0000 		lds r4,bankStates+13
 2686 158e 5090 0000 		lds r5,bankStates+13+1
 2687 1592 6090 0000 		lds r6,bankStates+13+2
 2688 1596 7090 0000 		lds r7,bankStates+13+3
 2689 159a F091 0000 		lds r31,bankStates+30
 2690 159e A091 0000 		lds r26,bankStates+31
 2691 15a2 B0E0      		ldi r27,0
 2692 15a4 0E94 0000 		call __muluhisi3
 2693 15a8 6B01      		movw r12,r22
 2694 15aa 7C01      		movw r14,r24
 2695 15ac A3E0      		ldi r26,3
 2696               		1:
 2697 15ae F694      		lsr r15
 2698 15b0 E794      		ror r14
 2699 15b2 D794      		ror r13
 2700 15b4 C794      		ror r12
 2701 15b6 AA95      		dec r26
 2702 15b8 01F4      		brne 1b
 2703 15ba C40C      		add r12,r4
 2704 15bc D51C      		adc r13,r5
 2705 15be E61C      		adc r14,r6
 2706 15c0 F71C      		adc r15,r7
 2707 15c2 AF2F      		mov r26,r31
 2708 15c4 B0E0      		ldi r27,0
 2709 15c6 0E94 0000 		call __muluhisi3
 2710 15ca B3E0      		ldi r27,3
 2711               		1:
 2712 15cc 9695      		lsr r25
 2713 15ce 8795      		ror r24
 2714 15d0 7795      		ror r23
 2715 15d2 6795      		ror r22
 2716 15d4 BA95      		dec r27
 2717 15d6 01F4      		brne 1b
 2718 15d8 C61A      		sub r12,r22
 2719 15da D70A      		sbc r13,r23
 2720 15dc E80A      		sbc r14,r24
 2721 15de F90A      		sbc r15,r25
 2722 15e0 C092 0000 		sts bankStates+21,r12
 2723 15e4 D092 0000 		sts bankStates+21+1,r13
 2724 15e8 E092 0000 		sts bankStates+21+2,r14
 2725 15ec F092 0000 		sts bankStates+21+3,r15
3788:WTPA.c        **** 
3789:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3790:WTPA.c        **** 
3791:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse play
 2726               		.loc 1 3791 0
 2727 15f0 4091 0000 		lds r20,bankStates+25
 2728 15f4 5091 0000 		lds r21,bankStates+25+1
 2729 15f8 6091 0000 		lds r22,bankStates+25+2
 2730 15fc 7091 0000 		lds r23,bankStates+25+3
 2731 1600 8091 0000 		lds r24,bankStates+21
 2732 1604 9091 0000 		lds r25,bankStates+21+1
 2733 1608 A091 0000 		lds r26,bankStates+21+2
 2734 160c B091 0000 		lds r27,bankStates+21+3
 2735 1610 8417      		cp r24,r20
 2736 1612 9507      		cpc r25,r21
 2737 1614 A607      		cpc r26,r22
 2738 1616 B707      		cpc r27,r23
 2739 1618 00F0      		brlo .+2
 2740 161a 00C0      		rjmp .L169
3792:WTPA.c        **** 		{
3793:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 2741               		.loc 1 3793 0
 2742 161c 8091 0000 		lds r24,bankStates+3
 2743 1620 8130      		cpi r24,lo8(1)
 2744 1622 01F4      		brne .+2
 2745 1624 00C0      		rjmp .L200
3794:WTPA.c        **** 			{
3795:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
3796:WTPA.c        **** 			}
3797:WTPA.c        **** 			else
3798:WTPA.c        **** 			{
3799:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 2746               		.loc 1 3799 0
 2747 1626 1092 0000 		sts bankStates+4,__zero_reg__
 2748               	.L171:
3800:WTPA.c        **** 			}
3801:WTPA.c        **** 
3802:WTPA.c        **** 			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
 2749               		.loc 1 3802 0
 2750 162a 8091 0000 		lds r24,bankStates+25
 2751 162e 9091 0000 		lds r25,bankStates+25+1
 2752 1632 A091 0000 		lds r26,bankStates+25+2
 2753 1636 B091 0000 		lds r27,bankStates+25+3
 2754               	.LVL86:
3803:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to st
 2755               		.loc 1 3803 0
 2756 163a 4091 0000 		lds r20,bankStates+21
 2757 163e 5091 0000 		lds r21,bankStates+21+1
 2758 1642 6091 0000 		lds r22,bankStates+21+2
 2759 1646 7091 0000 		lds r23,bankStates+21+3
 2760 164a 4093 0000 		sts bankStates+25,r20
 2761 164e 5093 0000 		sts bankStates+25+1,r21
 2762 1652 6093 0000 		sts bankStates+25+2,r22
 2763 1656 7093 0000 		sts bankStates+25+3,r23
3804:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
 2764               		.loc 1 3804 0
 2765 165a 8093 0000 		sts bankStates+21,r24
 2766 165e 9093 0000 		sts bankStates+21+1,r25
 2767 1662 A093 0000 		sts bankStates+21+2,r26
 2768 1666 B093 0000 		sts bankStates+21+3,r27
 2769               	.LVL87:
 2770               	.L172:
3805:WTPA.c        **** 		}
3806:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3807:WTPA.c        **** 		{
3808:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
3809:WTPA.c        **** 			{
3810:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
3811:WTPA.c        **** 			}
3812:WTPA.c        **** 			else
3813:WTPA.c        **** 			{
3814:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
3815:WTPA.c        **** 			}
3816:WTPA.c        **** 		}
3817:WTPA.c        **** 
3818:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3819:WTPA.c        **** 
3820:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the e
 2771               		.loc 1 3820 0
 2772 166a 4091 0000 		lds r20,bankStates+25
 2773 166e 5091 0000 		lds r21,bankStates+25+1
 2774 1672 6091 0000 		lds r22,bankStates+25+2
 2775 1676 7091 0000 		lds r23,bankStates+25+3
 2776 167a 8091 0000 		lds r24,bankStates+13
 2777 167e 9091 0000 		lds r25,bankStates+13+1
 2778 1682 A091 0000 		lds r26,bankStates+13+2
 2779 1686 B091 0000 		lds r27,bankStates+13+3
 2780 168a 8417      		cp r24,r20
 2781 168c 9507      		cpc r25,r21
 2782 168e A607      		cpc r26,r22
 2783 1690 B707      		cpc r27,r23
 2784 1692 00F4      		brsh .L174
3821:WTPA.c        **** 		{
3822:WTPA.c        **** 			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK
 2785               		.loc 1 3822 0
 2786 1694 8091 0000 		lds r24,bankStates+25
 2787 1698 9091 0000 		lds r25,bankStates+25+1
 2788 169c A091 0000 		lds r26,bankStates+25+2
 2789 16a0 B091 0000 		lds r27,bankStates+25+3
 2790 16a4 4091 0000 		lds r20,bankStates+13
 2791 16a8 5091 0000 		lds r21,bankStates+13+1
 2792 16ac 6091 0000 		lds r22,bankStates+13+2
 2793 16b0 7091 0000 		lds r23,bankStates+13+3
 2794 16b4 841B      		sub r24,r20
 2795 16b6 950B      		sbc r25,r21
 2796 16b8 A60B      		sbc r26,r22
 2797 16ba B70B      		sbc r27,r23
 2798 16bc 8093 0000 		sts bankStates+25,r24
 2799 16c0 9093 0000 		sts bankStates+25+1,r25
 2800 16c4 A093 0000 		sts bankStates+25+2,r26
 2801 16c8 B093 0000 		sts bankStates+25+3,r27
 2802               	.L174:
3823:WTPA.c        **** 		}
3824:WTPA.c        **** 		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
 2803               		.loc 1 3824 0
 2804 16cc 4091 0000 		lds r20,bankStates+21
 2805 16d0 5091 0000 		lds r21,bankStates+21+1
 2806 16d4 6091 0000 		lds r22,bankStates+21+2
 2807 16d8 7091 0000 		lds r23,bankStates+21+3
 2808 16dc 8091 0000 		lds r24,bankStates+13
 2809 16e0 9091 0000 		lds r25,bankStates+13+1
 2810 16e4 A091 0000 		lds r26,bankStates+13+2
 2811 16e8 B091 0000 		lds r27,bankStates+13+3
 2812 16ec 8417      		cp r24,r20
 2813 16ee 9507      		cpc r25,r21
 2814 16f0 A607      		cpc r26,r22
 2815 16f2 B707      		cpc r27,r23
 2816 16f4 00F4      		brsh .L176
3825:WTPA.c        **** 		{
3826:WTPA.c        **** 			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].
 2817               		.loc 1 3826 0
 2818 16f6 8091 0000 		lds r24,bankStates+21
 2819 16fa 9091 0000 		lds r25,bankStates+21+1
 2820 16fe A091 0000 		lds r26,bankStates+21+2
 2821 1702 B091 0000 		lds r27,bankStates+21+3
 2822 1706 4091 0000 		lds r20,bankStates+13
 2823 170a 5091 0000 		lds r21,bankStates+13+1
 2824 170e 6091 0000 		lds r22,bankStates+13+2
 2825 1712 7091 0000 		lds r23,bankStates+13+3
 2826 1716 841B      		sub r24,r20
 2827 1718 950B      		sbc r25,r21
 2828 171a A60B      		sbc r26,r22
 2829 171c B70B      		sbc r27,r23
 2830 171e 8093 0000 		sts bankStates+21,r24
 2831 1722 9093 0000 		sts bankStates+21+1,r25
 2832 1726 A093 0000 		sts bankStates+21+2,r26
 2833 172a B093 0000 		sts bankStates+21+3,r27
3827:WTPA.c        **** 
3828:WTPA.c        **** 			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wra
 2834               		.loc 1 3828 0
 2835 172e 4091 0000 		lds r20,bankStates+21
 2836 1732 5091 0000 		lds r21,bankStates+21+1
 2837 1736 6091 0000 		lds r22,bankStates+21+2
 2838 173a 7091 0000 		lds r23,bankStates+21+3
 2839 173e 8091 0000 		lds r24,bankStates+25
 2840 1742 9091 0000 		lds r25,bankStates+25+1
 2841 1746 A091 0000 		lds r26,bankStates+25+2
 2842 174a B091 0000 		lds r27,bankStates+25+3
 2843 174e 4817      		cp r20,r24
 2844 1750 5907      		cpc r21,r25
 2845 1752 6A07      		cpc r22,r26
 2846 1754 7B07      		cpc r23,r27
 2847 1756 01F4      		brne .+2
 2848 1758 00C0      		rjmp .L201
 2849               	.L176:
3829:WTPA.c        **** 			{
3830:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
3831:WTPA.c        **** 			}
3832:WTPA.c        **** 		}
3833:WTPA.c        **** 
3834:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3835:WTPA.c        **** 
3836:WTPA.c        **** 		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapp
 2850               		.loc 1 3836 0
 2851 175a 4091 0000 		lds r20,bankStates+25
 2852 175e 5091 0000 		lds r21,bankStates+25+1
 2853 1762 6091 0000 		lds r22,bankStates+25+2
 2854 1766 7091 0000 		lds r23,bankStates+25+3
 2855 176a 8091 0000 		lds r24,bankStates+21
 2856 176e 9091 0000 		lds r25,bankStates+21+1
 2857 1772 A091 0000 		lds r26,bankStates+21+2
 2858 1776 B091 0000 		lds r27,bankStates+21+3
 2859 177a 8417      		cp r24,r20
 2860 177c 9507      		cpc r25,r21
 2861 177e A607      		cpc r26,r22
 2862 1780 B707      		cpc r27,r23
 2863 1782 00F0      		brlo .+2
 2864 1784 00C0      		rjmp .L178
3837:WTPA.c        **** 		{
3838:WTPA.c        **** 			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK
 2865               		.loc 1 3838 0
 2866 1786 4091 0000 		lds r20,bankStates+32
 2867 178a 5091 0000 		lds r21,bankStates+32+1
 2868 178e 6091 0000 		lds r22,bankStates+32+2
 2869 1792 7091 0000 		lds r23,bankStates+32+3
 2870 1796 8091 0000 		lds r24,bankStates+25
 2871 179a 9091 0000 		lds r25,bankStates+25+1
 2872 179e A091 0000 		lds r26,bankStates+25+2
 2873 17a2 B091 0000 		lds r27,bankStates+25+3
 2874 17a6 4817      		cp r20,r24
 2875 17a8 5907      		cpc r21,r25
 2876 17aa 6A07      		cpc r22,r26
 2877 17ac 7B07      		cpc r23,r27
 2878 17ae 00F0      		brlo .+2
 2879 17b0 00C0      		rjmp .L180
 2880               		.loc 1 3838 0 is_stmt 0 discriminator 1
 2881 17b2 4091 0000 		lds r20,bankStates+32
 2882 17b6 5091 0000 		lds r21,bankStates+32+1
 2883 17ba 6091 0000 		lds r22,bankStates+32+2
 2884 17be 7091 0000 		lds r23,bankStates+32+3
 2885 17c2 8091 0000 		lds r24,bankStates+21
 2886 17c6 9091 0000 		lds r25,bankStates+21+1
 2887 17ca A091 0000 		lds r26,bankStates+21+2
 2888 17ce B091 0000 		lds r27,bankStates+21+3
 2889 17d2 8417      		cp r24,r20
 2890 17d4 9507      		cpc r25,r21
 2891 17d6 A607      		cpc r26,r22
 2892 17d8 B707      		cpc r27,r23
 2893 17da 00F0      		brlo .+2
 2894 17dc 00C0      		rjmp .L180
3839:WTPA.c        **** 			{
3840:WTPA.c        **** 				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BAN
 2895               		.loc 1 3840 0 is_stmt 1
 2896 17de 4091 0000 		lds r20,bankStates+25
 2897 17e2 5091 0000 		lds r21,bankStates+25+1
 2898 17e6 6091 0000 		lds r22,bankStates+25+2
 2899 17ea 7091 0000 		lds r23,bankStates+25+3
 2900 17ee 8090 0000 		lds r8,bankStates+32
 2901 17f2 9090 0000 		lds r9,bankStates+32+1
 2902 17f6 A090 0000 		lds r10,bankStates+32+2
 2903 17fa B090 0000 		lds r11,bankStates+32+3
 2904 17fe 8091 0000 		lds r24,bankStates+32
 2905 1802 9091 0000 		lds r25,bankStates+32+1
 2906 1806 A091 0000 		lds r26,bankStates+32+2
 2907 180a B091 0000 		lds r27,bankStates+32+3
 2908 180e C090 0000 		lds r12,bankStates+21
 2909 1812 D090 0000 		lds r13,bankStates+21+1
 2910 1816 E090 0000 		lds r14,bankStates+21+2
 2911 181a F090 0000 		lds r15,bankStates+21+3
 2912 181e 4819      		sub r20,r8
 2913 1820 5909      		sbc r21,r9
 2914 1822 6A09      		sbc r22,r10
 2915 1824 7B09      		sbc r23,r11
 2916 1826 8C19      		sub r24,r12
 2917 1828 9D09      		sbc r25,r13
 2918 182a AE09      		sbc r26,r14
 2919 182c BF09      		sbc r27,r15
 2920 182e 4817      		cp r20,r24
 2921 1830 5907      		cpc r21,r25
 2922 1832 6A07      		cpc r22,r26
 2923 1834 7B07      		cpc r23,r27
 2924 1836 00F4      		brsh .+2
 2925 1838 00C0      		rjmp .L196
 2926               	.L199:
3841:WTPA.c        **** 				{
3842:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;	// Round to the sta
3843:WTPA.c        **** 				}
3844:WTPA.c        **** 				else
3845:WTPA.c        **** 				{
3846:WTPA.c        **** 					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;	// Round to the end.
3847:WTPA.c        **** 				}
3848:WTPA.c        **** 			}
3849:WTPA.c        **** 		}
3850:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is before the end).
3851:WTPA.c        **** 		{
3852:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
3853:WTPA.c        **** 			{
3854:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the 
 2927               		.loc 1 3854 0
 2928 183a 8091 0000 		lds r24,bankStates+25
 2929 183e 9091 0000 		lds r25,bankStates+25+1
 2930 1842 A091 0000 		lds r26,bankStates+25+2
 2931 1846 B091 0000 		lds r27,bankStates+25+3
 2932 184a 8093 0000 		sts bankStates+32,r24
 2933 184e 9093 0000 		sts bankStates+32+1,r25
 2934 1852 A093 0000 		sts bankStates+32+2,r26
 2935 1856 B093 0000 		sts bankStates+32+3,r27
 2936 185a 00C0      		rjmp .L180
 2937               	.LVL88:
 2938               	.L168:
3855:WTPA.c        **** 			}
3856:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
3857:WTPA.c        **** 			{
3858:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
3859:WTPA.c        **** 			}
3860:WTPA.c        **** 		}
3861:WTPA.c        **** 	}
3862:WTPA.c        **** 	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
3863:WTPA.c        **** 	{
3864:WTPA.c        **** 		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
3865:WTPA.c        **** 		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of 
 2939               		.loc 1 3865 0
 2940 185c 8091 0000 		lds r24,bankStates+49
 2941 1860 9091 0000 		lds r25,bankStates+49+1
 2942 1864 A091 0000 		lds r26,bankStates+49+2
 2943 1868 B091 0000 		lds r27,bankStates+49+3
 2944               	.LVL89:
 2945 186c CC24      		clr r12
 2946 186e CA94      		dec r12
 2947 1870 DC2C      		mov r13,r12
 2948 1872 77E0      		ldi r23,lo8(7)
 2949 1874 E72E      		mov r14,r23
 2950 1876 F12C      		mov r15,__zero_reg__
 2951 1878 A701      		movw r20,r14
 2952 187a 9601      		movw r18,r12
 2953 187c 281B      		sub r18,r24
 2954 187e 390B      		sbc r19,r25
 2955 1880 4A0B      		sbc r20,r26
 2956 1882 5B0B      		sbc r21,r27
 2957 1884 DA01      		movw r26,r20
 2958 1886 C901      		movw r24,r18
 2959 1888 880F      		lsl r24
 2960 188a 991F      		rol r25
 2961 188c AA1F      		rol r26
 2962 188e BB1F      		rol r27
 2963 1890 880F      		lsl r24
 2964 1892 991F      		rol r25
 2965 1894 AA1F      		rol r26
 2966 1896 BB1F      		rol r27
 2967 1898 880F      		lsl r24
 2968 189a 991F      		rol r25
 2969 189c AA1F      		rol r26
 2970 189e BB1F      		rol r27
 2971 18a0 892E      		mov r8,r25
 2972 18a2 9A2E      		mov r9,r26
 2973 18a4 AB2E      		mov r10,r27
 2974 18a6 BB24      		clr r11
 2975               	.LVL90:
3866:WTPA.c        **** 
3867:WTPA.c        **** 		// Move the start and end points.  Removed fixed decimal points.
3868:WTPA.c        **** 
3869:WTPA.c        **** 		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sam
 2976               		.loc 1 3869 0
 2977 18a8 A091 0000 		lds r26,bankStates+65
 2978 18ac 8091 0000 		lds r24,bankStates+67
 2979 18b0 B0E0      		ldi r27,0
 2980 18b2 A80F      		add r26,r24
 2981 18b4 B11D      		adc r27,__zero_reg__
 2982 18b6 A501      		movw r20,r10
 2983 18b8 9401      		movw r18,r8
 2984 18ba 0E94 0000 		call __muluhisi3
 2985 18be F3E0      		ldi r31,3
 2986               		1:
 2987 18c0 9695      		lsr r25
 2988 18c2 8795      		ror r24
 2989 18c4 7795      		ror r23
 2990 18c6 6795      		ror r22
 2991 18c8 FA95      		dec r31
 2992 18ca 01F4      		brne 1b
 2993 18cc C61A      		sub r12,r22
 2994 18ce D70A      		sbc r13,r23
 2995 18d0 E80A      		sbc r14,r24
 2996 18d2 F90A      		sbc r15,r25
 2997 18d4 C092 0000 		sts bankStates+61,r12
 2998 18d8 D092 0000 		sts bankStates+61+1,r13
 2999 18dc E092 0000 		sts bankStates+61+2,r14
 3000 18e0 F092 0000 		sts bankStates+61+3,r15
3870:WTPA.c        **** 		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_
 3001               		.loc 1 3870 0
 3002 18e4 4090 0000 		lds r4,bankStates+49
 3003 18e8 5090 0000 		lds r5,bankStates+49+1
 3004 18ec 6090 0000 		lds r6,bankStates+49+2
 3005 18f0 7090 0000 		lds r7,bankStates+49+3
 3006 18f4 A091 0000 		lds r26,bankStates+66
 3007 18f8 F091 0000 		lds r31,bankStates+67
 3008 18fc B0E0      		ldi r27,0
 3009 18fe 0E94 0000 		call __muluhisi3
 3010 1902 6B01      		movw r12,r22
 3011 1904 7C01      		movw r14,r24
 3012 1906 A3E0      		ldi r26,3
 3013               		1:
 3014 1908 F694      		lsr r15
 3015 190a E794      		ror r14
 3016 190c D794      		ror r13
 3017 190e C794      		ror r12
 3018 1910 AA95      		dec r26
 3019 1912 01F4      		brne 1b
 3020 1914 C40C      		add r12,r4
 3021 1916 D51C      		adc r13,r5
 3022 1918 E61C      		adc r14,r6
 3023 191a F71C      		adc r15,r7
 3024 191c AF2F      		mov r26,r31
 3025 191e B0E0      		ldi r27,0
 3026 1920 0E94 0000 		call __muluhisi3
 3027 1924 B3E0      		ldi r27,3
 3028               		1:
 3029 1926 9695      		lsr r25
 3030 1928 8795      		ror r24
 3031 192a 7795      		ror r23
 3032 192c 6795      		ror r22
 3033 192e BA95      		dec r27
 3034 1930 01F4      		brne 1b
 3035 1932 C61A      		sub r12,r22
 3036 1934 D70A      		sbc r13,r23
 3037 1936 E80A      		sbc r14,r24
 3038 1938 F90A      		sbc r15,r25
 3039 193a C092 0000 		sts bankStates+57,r12
 3040 193e D092 0000 		sts bankStates+57+1,r13
 3041 1942 E092 0000 		sts bankStates+57+2,r14
 3042 1946 F092 0000 		sts bankStates+57+3,r15
3871:WTPA.c        **** 
3872:WTPA.c        **** 		// Now check to see whether the end is before or after the start, and if that's changed, reverse 
3873:WTPA.c        **** 
3874:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse play
 3043               		.loc 1 3874 0
 3044 194a 4091 0000 		lds r20,bankStates+61
 3045 194e 5091 0000 		lds r21,bankStates+61+1
 3046 1952 6091 0000 		lds r22,bankStates+61+2
 3047 1956 7091 0000 		lds r23,bankStates+61+3
 3048 195a 8091 0000 		lds r24,bankStates+57
 3049 195e 9091 0000 		lds r25,bankStates+57+1
 3050 1962 A091 0000 		lds r26,bankStates+57+2
 3051 1966 B091 0000 		lds r27,bankStates+57+3
 3052 196a 4817      		cp r20,r24
 3053 196c 5907      		cpc r21,r25
 3054 196e 6A07      		cpc r22,r26
 3055 1970 7B07      		cpc r23,r27
 3056 1972 00F0      		brlo .+2
 3057 1974 00C0      		rjmp .L184
3875:WTPA.c        **** 		{
3876:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
 3058               		.loc 1 3876 0
 3059 1976 8091 0000 		lds r24,bankStates+39
 3060 197a 8130      		cpi r24,lo8(1)
 3061 197c 01F4      		brne .+2
 3062 197e 00C0      		rjmp .L202
3877:WTPA.c        **** 			{
3878:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
3879:WTPA.c        **** 			}
3880:WTPA.c        **** 			else
3881:WTPA.c        **** 			{
3882:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3063               		.loc 1 3882 0
 3064 1980 1092 0000 		sts bankStates+40,__zero_reg__
 3065               	.L186:
3883:WTPA.c        **** 			}
3884:WTPA.c        **** 
3885:WTPA.c        **** 			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
 3066               		.loc 1 3885 0
 3067 1984 8091 0000 		lds r24,bankStates+61
 3068 1988 9091 0000 		lds r25,bankStates+61+1
 3069 198c A091 0000 		lds r26,bankStates+61+2
 3070 1990 B091 0000 		lds r27,bankStates+61+3
 3071               	.LVL91:
3886:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to st
 3072               		.loc 1 3886 0
 3073 1994 4091 0000 		lds r20,bankStates+57
 3074 1998 5091 0000 		lds r21,bankStates+57+1
 3075 199c 6091 0000 		lds r22,bankStates+57+2
 3076 19a0 7091 0000 		lds r23,bankStates+57+3
 3077 19a4 4093 0000 		sts bankStates+61,r20
 3078 19a8 5093 0000 		sts bankStates+61+1,r21
 3079 19ac 6093 0000 		sts bankStates+61+2,r22
 3080 19b0 7093 0000 		sts bankStates+61+3,r23
3887:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
 3081               		.loc 1 3887 0
 3082 19b4 8093 0000 		sts bankStates+57,r24
 3083 19b8 9093 0000 		sts bankStates+57+1,r25
 3084 19bc A093 0000 		sts bankStates+57+2,r26
 3085 19c0 B093 0000 		sts bankStates+57+3,r27
 3086               	.LVL92:
 3087               	.L187:
3888:WTPA.c        **** 		}
3889:WTPA.c        **** 		else	// Sample is in a "normal" orientation.  Make sure it plays right.
3890:WTPA.c        **** 		{
3891:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
3892:WTPA.c        **** 			{
3893:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
3894:WTPA.c        **** 			}
3895:WTPA.c        **** 			else
3896:WTPA.c        **** 			{
3897:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
3898:WTPA.c        **** 			}
3899:WTPA.c        **** 		}
3900:WTPA.c        **** 
3901:WTPA.c        **** 		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space,
3902:WTPA.c        **** 
3903:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the e
 3088               		.loc 1 3903 0
 3089 19c4 4091 0000 		lds r20,bankStates+61
 3090 19c8 5091 0000 		lds r21,bankStates+61+1
 3091 19cc 6091 0000 		lds r22,bankStates+61+2
 3092 19d0 7091 0000 		lds r23,bankStates+61+3
 3093 19d4 8091 0000 		lds r24,bankStates+49
 3094 19d8 9091 0000 		lds r25,bankStates+49+1
 3095 19dc A091 0000 		lds r26,bankStates+49+2
 3096 19e0 B091 0000 		lds r27,bankStates+49+3
 3097 19e4 4817      		cp r20,r24
 3098 19e6 5907      		cpc r21,r25
 3099 19e8 6A07      		cpc r22,r26
 3100 19ea 7B07      		cpc r23,r27
 3101 19ec 00F4      		brsh .L189
3904:WTPA.c        **** 		{
3905:WTPA.c        **** 			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bank
 3102               		.loc 1 3905 0
 3103 19ee 8091 0000 		lds r24,bankStates+61
 3104 19f2 9091 0000 		lds r25,bankStates+61+1
 3105 19f6 A091 0000 		lds r26,bankStates+61+2
 3106 19fa B091 0000 		lds r27,bankStates+61+3
 3107 19fe 4091 0000 		lds r20,bankStates+49
 3108 1a02 5091 0000 		lds r21,bankStates+49+1
 3109 1a06 6091 0000 		lds r22,bankStates+49+2
 3110 1a0a 7091 0000 		lds r23,bankStates+49+3
 3111 1a0e 0197      		sbiw r24,1
 3112 1a10 A84F      		sbci r26,-8
 3113 1a12 BF4F      		sbci r27,-1
 3114 1a14 841B      		sub r24,r20
 3115 1a16 950B      		sbc r25,r21
 3116 1a18 A60B      		sbc r26,r22
 3117 1a1a B70B      		sbc r27,r23
 3118 1a1c 8093 0000 		sts bankStates+61,r24
 3119 1a20 9093 0000 		sts bankStates+61+1,r25
 3120 1a24 A093 0000 		sts bankStates+61+2,r26
 3121 1a28 B093 0000 		sts bankStates+61+3,r27
 3122               	.L189:
3906:WTPA.c        **** 		}
3907:WTPA.c        **** 		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
 3123               		.loc 1 3907 0
 3124 1a2c 4091 0000 		lds r20,bankStates+57
 3125 1a30 5091 0000 		lds r21,bankStates+57+1
 3126 1a34 6091 0000 		lds r22,bankStates+57+2
 3127 1a38 7091 0000 		lds r23,bankStates+57+3
 3128 1a3c 8091 0000 		lds r24,bankStates+49
 3129 1a40 9091 0000 		lds r25,bankStates+49+1
 3130 1a44 A091 0000 		lds r26,bankStates+49+2
 3131 1a48 B091 0000 		lds r27,bankStates+49+3
 3132 1a4c 4817      		cp r20,r24
 3133 1a4e 5907      		cpc r21,r25
 3134 1a50 6A07      		cpc r22,r26
 3135 1a52 7B07      		cpc r23,r27
 3136 1a54 00F4      		brsh .L191
3908:WTPA.c        **** 		{
3909:WTPA.c        **** 			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankSt
 3137               		.loc 1 3909 0
 3138 1a56 8091 0000 		lds r24,bankStates+57
 3139 1a5a 9091 0000 		lds r25,bankStates+57+1
 3140 1a5e A091 0000 		lds r26,bankStates+57+2
 3141 1a62 B091 0000 		lds r27,bankStates+57+3
 3142 1a66 4091 0000 		lds r20,bankStates+49
 3143 1a6a 5091 0000 		lds r21,bankStates+49+1
 3144 1a6e 6091 0000 		lds r22,bankStates+49+2
 3145 1a72 7091 0000 		lds r23,bankStates+49+3
 3146 1a76 0197      		sbiw r24,1
 3147 1a78 A84F      		sbci r26,-8
 3148 1a7a BF4F      		sbci r27,-1
 3149 1a7c 841B      		sub r24,r20
 3150 1a7e 950B      		sbc r25,r21
 3151 1a80 A60B      		sbc r26,r22
 3152 1a82 B70B      		sbc r27,r23
 3153 1a84 8093 0000 		sts bankStates+57,r24
 3154 1a88 9093 0000 		sts bankStates+57+1,r25
 3155 1a8c A093 0000 		sts bankStates+57+2,r26
 3156 1a90 B093 0000 		sts bankStates+57+3,r27
3910:WTPA.c        **** 
3911:WTPA.c        **** 			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wra
 3157               		.loc 1 3911 0
 3158 1a94 4091 0000 		lds r20,bankStates+57
 3159 1a98 5091 0000 		lds r21,bankStates+57+1
 3160 1a9c 6091 0000 		lds r22,bankStates+57+2
 3161 1aa0 7091 0000 		lds r23,bankStates+57+3
 3162 1aa4 8091 0000 		lds r24,bankStates+61
 3163 1aa8 9091 0000 		lds r25,bankStates+61+1
 3164 1aac A091 0000 		lds r26,bankStates+61+2
 3165 1ab0 B091 0000 		lds r27,bankStates+61+3
 3166 1ab4 4817      		cp r20,r24
 3167 1ab6 5907      		cpc r21,r25
 3168 1ab8 6A07      		cpc r22,r26
 3169 1aba 7B07      		cpc r23,r27
 3170 1abc 01F4      		brne .+2
 3171 1abe 00C0      		rjmp .L203
 3172               	.L191:
3912:WTPA.c        **** 			{
3913:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
3914:WTPA.c        **** 			}
3915:WTPA.c        **** 		}
3916:WTPA.c        **** 
3917:WTPA.c        **** 		// Finally, if the current sample address pointer is not in between the start and end points anym
3918:WTPA.c        **** 
3919:WTPA.c        **** 		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapp
 3173               		.loc 1 3919 0
 3174 1ac0 4091 0000 		lds r20,bankStates+61
 3175 1ac4 5091 0000 		lds r21,bankStates+61+1
 3176 1ac8 6091 0000 		lds r22,bankStates+61+2
 3177 1acc 7091 0000 		lds r23,bankStates+61+3
 3178 1ad0 8091 0000 		lds r24,bankStates+57
 3179 1ad4 9091 0000 		lds r25,bankStates+57+1
 3180 1ad8 A091 0000 		lds r26,bankStates+57+2
 3181 1adc B091 0000 		lds r27,bankStates+57+3
 3182 1ae0 4817      		cp r20,r24
 3183 1ae2 5907      		cpc r21,r25
 3184 1ae4 6A07      		cpc r22,r26
 3185 1ae6 7B07      		cpc r23,r27
 3186 1ae8 00F0      		brlo .+2
 3187 1aea 00C0      		rjmp .L193
3920:WTPA.c        **** 		{
3921:WTPA.c        **** 			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK
 3188               		.loc 1 3921 0
 3189 1aec 4091 0000 		lds r20,bankStates+68
 3190 1af0 5091 0000 		lds r21,bankStates+68+1
 3191 1af4 6091 0000 		lds r22,bankStates+68+2
 3192 1af8 7091 0000 		lds r23,bankStates+68+3
 3193 1afc 8091 0000 		lds r24,bankStates+61
 3194 1b00 9091 0000 		lds r25,bankStates+61+1
 3195 1b04 A091 0000 		lds r26,bankStates+61+2
 3196 1b08 B091 0000 		lds r27,bankStates+61+3
 3197 1b0c 8417      		cp r24,r20
 3198 1b0e 9507      		cpc r25,r21
 3199 1b10 A607      		cpc r26,r22
 3200 1b12 B707      		cpc r27,r23
 3201 1b14 00F0      		brlo .+2
 3202 1b16 00C0      		rjmp .L180
 3203               		.loc 1 3921 0 is_stmt 0 discriminator 1
 3204 1b18 4091 0000 		lds r20,bankStates+68
 3205 1b1c 5091 0000 		lds r21,bankStates+68+1
 3206 1b20 6091 0000 		lds r22,bankStates+68+2
 3207 1b24 7091 0000 		lds r23,bankStates+68+3
 3208 1b28 8091 0000 		lds r24,bankStates+57
 3209 1b2c 9091 0000 		lds r25,bankStates+57+1
 3210 1b30 A091 0000 		lds r26,bankStates+57+2
 3211 1b34 B091 0000 		lds r27,bankStates+57+3
 3212 1b38 4817      		cp r20,r24
 3213 1b3a 5907      		cpc r21,r25
 3214 1b3c 6A07      		cpc r22,r26
 3215 1b3e 7B07      		cpc r23,r27
 3216 1b40 00F4      		brsh .L180
3922:WTPA.c        **** 			{
3923:WTPA.c        **** 				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BAN
 3217               		.loc 1 3923 0 is_stmt 1
 3218 1b42 4091 0000 		lds r20,bankStates+68
 3219 1b46 5091 0000 		lds r21,bankStates+68+1
 3220 1b4a 6091 0000 		lds r22,bankStates+68+2
 3221 1b4e 7091 0000 		lds r23,bankStates+68+3
 3222 1b52 8090 0000 		lds r8,bankStates+61
 3223 1b56 9090 0000 		lds r9,bankStates+61+1
 3224 1b5a A090 0000 		lds r10,bankStates+61+2
 3225 1b5e B090 0000 		lds r11,bankStates+61+3
 3226 1b62 8091 0000 		lds r24,bankStates+57
 3227 1b66 9091 0000 		lds r25,bankStates+57+1
 3228 1b6a A091 0000 		lds r26,bankStates+57+2
 3229 1b6e B091 0000 		lds r27,bankStates+57+3
 3230 1b72 C090 0000 		lds r12,bankStates+68
 3231 1b76 D090 0000 		lds r13,bankStates+68+1
 3232 1b7a E090 0000 		lds r14,bankStates+68+2
 3233 1b7e F090 0000 		lds r15,bankStates+68+3
 3234 1b82 4819      		sub r20,r8
 3235 1b84 5909      		sbc r21,r9
 3236 1b86 6A09      		sbc r22,r10
 3237 1b88 7B09      		sbc r23,r11
 3238 1b8a 8C19      		sub r24,r12
 3239 1b8c 9D09      		sbc r25,r13
 3240 1b8e AE09      		sbc r26,r14
 3241 1b90 BF09      		sbc r27,r15
 3242 1b92 8417      		cp r24,r20
 3243 1b94 9507      		cpc r25,r21
 3244 1b96 A607      		cpc r26,r22
 3245 1b98 B707      		cpc r27,r23
 3246 1b9a 00F4      		brsh .+2
 3247 1b9c 00C0      		rjmp .L198
 3248               	.L197:
3924:WTPA.c        **** 				{
3925:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;	// Round to the sta
3926:WTPA.c        **** 				}
3927:WTPA.c        **** 				else
3928:WTPA.c        **** 				{
3929:WTPA.c        **** 					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;	// Round to the end.
3930:WTPA.c        **** 				}
3931:WTPA.c        **** 			}
3932:WTPA.c        **** 		}
3933:WTPA.c        **** 		else	// Not wrapping around the end (this means the start addy is xxx the end).
3934:WTPA.c        **** 		{
3935:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
3936:WTPA.c        **** 			{
3937:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the 
 3249               		.loc 1 3937 0
 3250 1b9e 8091 0000 		lds r24,bankStates+61
 3251 1ba2 9091 0000 		lds r25,bankStates+61+1
 3252 1ba6 A091 0000 		lds r26,bankStates+61+2
 3253 1baa B091 0000 		lds r27,bankStates+61+3
 3254 1bae 8093 0000 		sts bankStates+68,r24
 3255 1bb2 9093 0000 		sts bankStates+68+1,r25
 3256 1bb6 A093 0000 		sts bankStates+68+2,r26
 3257 1bba B093 0000 		sts bankStates+68+3,r27
 3258               	.L180:
3938:WTPA.c        **** 			}
3939:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
3940:WTPA.c        **** 			{
3941:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
3942:WTPA.c        **** 			}
3943:WTPA.c        **** 		}
3944:WTPA.c        **** 	}
3945:WTPA.c        **** 
3946:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 3259               		.loc 1 3946 0
 3260 1bbe EFBF      		out __SREG__,r30
 3261               	/* epilogue start */
3947:WTPA.c        **** }
 3262               		.loc 1 3947 0
 3263 1bc0 FF90      		pop r15
 3264 1bc2 EF90      		pop r14
 3265 1bc4 DF90      		pop r13
 3266 1bc6 CF90      		pop r12
 3267 1bc8 BF90      		pop r11
 3268 1bca AF90      		pop r10
 3269 1bcc 9F90      		pop r9
 3270 1bce 8F90      		pop r8
 3271 1bd0 7F90      		pop r7
 3272 1bd2 6F90      		pop r6
 3273 1bd4 5F90      		pop r5
 3274 1bd6 4F90      		pop r4
 3275 1bd8 0895      		ret
 3276               	.LVL93:
 3277               	.L184:
3891:WTPA.c        **** 			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
 3278               		.loc 1 3891 0
 3279 1bda 8091 0000 		lds r24,bankStates+39
 3280 1bde 8130      		cpi r24,lo8(1)
 3281 1be0 01F0      		breq .L204
3897:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3282               		.loc 1 3897 0
 3283 1be2 81E0      		ldi r24,lo8(1)
 3284 1be4 8093 0000 		sts bankStates+40,r24
 3285 1be8 00C0      		rjmp .L187
 3286               	.L169:
3808:WTPA.c        **** 			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
 3287               		.loc 1 3808 0
 3288 1bea 8091 0000 		lds r24,bankStates+3
 3289 1bee 8130      		cpi r24,lo8(1)
 3290 1bf0 01F0      		breq .L205
3814:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 3291               		.loc 1 3814 0
 3292 1bf2 81E0      		ldi r24,lo8(1)
 3293 1bf4 8093 0000 		sts bankStates+4,r24
 3294 1bf8 00C0      		rjmp .L172
 3295               	.L205:
3810:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=false;
 3296               		.loc 1 3810 0
 3297 1bfa 1092 0000 		sts bankStates+4,__zero_reg__
 3298 1bfe 00C0      		rjmp .L172
 3299               	.L204:
3893:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=false;
 3300               		.loc 1 3893 0
 3301 1c00 1092 0000 		sts bankStates+40,__zero_reg__
 3302 1c04 00C0      		rjmp .L187
 3303               	.L202:
3878:WTPA.c        **** 				bankStates[BANK_1].sampleDirection=true;
 3304               		.loc 1 3878 0
 3305 1c06 8093 0000 		sts bankStates+40,r24
 3306 1c0a 00C0      		rjmp .L186
 3307               	.L200:
3795:WTPA.c        **** 				bankStates[BANK_0].sampleDirection=true;
 3308               		.loc 1 3795 0
 3309 1c0c 8093 0000 		sts bankStates+4,r24
 3310 1c10 00C0      		rjmp .L171
 3311               	.LVL94:
 3312               	.L193:
3935:WTPA.c        **** 			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
 3313               		.loc 1 3935 0
 3314 1c12 4091 0000 		lds r20,bankStates+68
 3315 1c16 5091 0000 		lds r21,bankStates+68+1
 3316 1c1a 6091 0000 		lds r22,bankStates+68+2
 3317 1c1e 7091 0000 		lds r23,bankStates+68+3
 3318 1c22 8091 0000 		lds r24,bankStates+61
 3319 1c26 9091 0000 		lds r25,bankStates+61+1
 3320 1c2a A091 0000 		lds r26,bankStates+61+2
 3321 1c2e B091 0000 		lds r27,bankStates+61+3
 3322 1c32 8417      		cp r24,r20
 3323 1c34 9507      		cpc r25,r21
 3324 1c36 A607      		cpc r26,r22
 3325 1c38 B707      		cpc r27,r23
 3326 1c3a 00F4      		brsh .+2
 3327 1c3c 00C0      		rjmp .L197
3939:WTPA.c        **** 			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
 3328               		.loc 1 3939 0
 3329 1c3e 4091 0000 		lds r20,bankStates+68
 3330 1c42 5091 0000 		lds r21,bankStates+68+1
 3331 1c46 6091 0000 		lds r22,bankStates+68+2
 3332 1c4a 7091 0000 		lds r23,bankStates+68+3
 3333 1c4e 8091 0000 		lds r24,bankStates+57
 3334 1c52 9091 0000 		lds r25,bankStates+57+1
 3335 1c56 A091 0000 		lds r26,bankStates+57+2
 3336 1c5a B091 0000 		lds r27,bankStates+57+3
 3337 1c5e 4817      		cp r20,r24
 3338 1c60 5907      		cpc r21,r25
 3339 1c62 6A07      		cpc r22,r26
 3340 1c64 7B07      		cpc r23,r27
 3341 1c66 00F0      		brlo .+2
 3342 1c68 00C0      		rjmp .L180
 3343               	.L198:
3941:WTPA.c        **** 				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the be
 3344               		.loc 1 3941 0
 3345 1c6a 8091 0000 		lds r24,bankStates+57
 3346 1c6e 9091 0000 		lds r25,bankStates+57+1
 3347 1c72 A091 0000 		lds r26,bankStates+57+2
 3348 1c76 B091 0000 		lds r27,bankStates+57+3
 3349 1c7a 8093 0000 		sts bankStates+68,r24
 3350 1c7e 9093 0000 		sts bankStates+68+1,r25
 3351 1c82 A093 0000 		sts bankStates+68+2,r26
 3352 1c86 B093 0000 		sts bankStates+68+3,r27
 3353 1c8a 00C0      		rjmp .L180
 3354               	.L178:
3852:WTPA.c        **** 			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
 3355               		.loc 1 3852 0
 3356 1c8c 4091 0000 		lds r20,bankStates+32
 3357 1c90 5091 0000 		lds r21,bankStates+32+1
 3358 1c94 6091 0000 		lds r22,bankStates+32+2
 3359 1c98 7091 0000 		lds r23,bankStates+32+3
 3360 1c9c 8091 0000 		lds r24,bankStates+25
 3361 1ca0 9091 0000 		lds r25,bankStates+25+1
 3362 1ca4 A091 0000 		lds r26,bankStates+25+2
 3363 1ca8 B091 0000 		lds r27,bankStates+25+3
 3364 1cac 4817      		cp r20,r24
 3365 1cae 5907      		cpc r21,r25
 3366 1cb0 6A07      		cpc r22,r26
 3367 1cb2 7B07      		cpc r23,r27
 3368 1cb4 00F4      		brsh .+2
 3369 1cb6 00C0      		rjmp .L199
3856:WTPA.c        **** 			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
 3370               		.loc 1 3856 0
 3371 1cb8 4091 0000 		lds r20,bankStates+32
 3372 1cbc 5091 0000 		lds r21,bankStates+32+1
 3373 1cc0 6091 0000 		lds r22,bankStates+32+2
 3374 1cc4 7091 0000 		lds r23,bankStates+32+3
 3375 1cc8 8091 0000 		lds r24,bankStates+21
 3376 1ccc 9091 0000 		lds r25,bankStates+21+1
 3377 1cd0 A091 0000 		lds r26,bankStates+21+2
 3378 1cd4 B091 0000 		lds r27,bankStates+21+3
 3379 1cd8 8417      		cp r24,r20
 3380 1cda 9507      		cpc r25,r21
 3381 1cdc A607      		cpc r26,r22
 3382 1cde B707      		cpc r27,r23
 3383 1ce0 00F0      		brlo .+2
 3384 1ce2 00C0      		rjmp .L180
 3385               	.L196:
3858:WTPA.c        **** 				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the be
 3386               		.loc 1 3858 0
 3387 1ce4 8091 0000 		lds r24,bankStates+21
 3388 1ce8 9091 0000 		lds r25,bankStates+21+1
 3389 1cec A091 0000 		lds r26,bankStates+21+2
 3390 1cf0 B091 0000 		lds r27,bankStates+21+3
 3391 1cf4 8093 0000 		sts bankStates+32,r24
 3392 1cf8 9093 0000 		sts bankStates+32+1,r25
 3393 1cfc A093 0000 		sts bankStates+32+2,r26
 3394 1d00 B093 0000 		sts bankStates+32+3,r27
 3395 1d04 00C0      		rjmp .L180
 3396               	.L203:
3913:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end a
 3397               		.loc 1 3913 0
 3398 1d06 8091 0000 		lds r24,bankStates+57
 3399 1d0a 9091 0000 		lds r25,bankStates+57+1
 3400 1d0e A091 0000 		lds r26,bankStates+57+2
 3401 1d12 B091 0000 		lds r27,bankStates+57+3
 3402 1d16 0196      		adiw r24,1
 3403 1d18 A11D      		adc r26,__zero_reg__
 3404 1d1a B11D      		adc r27,__zero_reg__
 3405 1d1c 8093 0000 		sts bankStates+57,r24
 3406 1d20 9093 0000 		sts bankStates+57+1,r25
 3407 1d24 A093 0000 		sts bankStates+57+2,r26
 3408 1d28 B093 0000 		sts bankStates+57+3,r27
 3409 1d2c 00C0      		rjmp .L191
 3410               	.L201:
3830:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end a
 3411               		.loc 1 3830 0
 3412 1d2e 8091 0000 		lds r24,bankStates+21
 3413 1d32 9091 0000 		lds r25,bankStates+21+1
 3414 1d36 A091 0000 		lds r26,bankStates+21+2
 3415 1d3a B091 0000 		lds r27,bankStates+21+3
 3416 1d3e 0197      		sbiw r24,1
 3417 1d40 A109      		sbc r26,__zero_reg__
 3418 1d42 B109      		sbc r27,__zero_reg__
 3419 1d44 8093 0000 		sts bankStates+21,r24
 3420 1d48 9093 0000 		sts bankStates+21+1,r25
 3421 1d4c A093 0000 		sts bankStates+21+2,r26
 3422 1d50 B093 0000 		sts bankStates+21+3,r27
 3423 1d54 00C0      		rjmp .L176
 3424               		.cfi_endproc
 3425               	.LFE63:
 3428               	DoStartupSelect:
 3429               	.LFB74:
3948:WTPA.c        **** 
3949:WTPA.c        **** static void RevertSampleToUnadjusted(unsigned char theBank)
3950:WTPA.c        **** // Removes user adjustments to sample and returns it to maximum size.
3951:WTPA.c        **** // @@@ Since the current sample address must be within these bounds, there is no need to adjust it.
3952:WTPA.c        **** // @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
3953:WTPA.c        **** {
3954:WTPA.c        **** 	unsigned char
3955:WTPA.c        **** 		sreg;
3956:WTPA.c        **** 
3957:WTPA.c        **** 	sreg=SREG;
3958:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
3959:WTPA.c        **** 
3960:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
3961:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
3962:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
3963:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
3964:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
3965:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
3966:WTPA.c        **** }
3967:WTPA.c        **** 
3968:WTPA.c        **** static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
3969:WTPA.c        **** // Moves the memory location where the sample begins (or loops) playback farther into the sample.
3970:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3971:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3972:WTPA.c        **** {
3973:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
3974:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3975:WTPA.c        **** }
3976:WTPA.c        **** 
3977:WTPA.c        **** static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
3978:WTPA.c        **** // Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
3979:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3980:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3981:WTPA.c        **** {
3982:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
3983:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3984:WTPA.c        **** }
3985:WTPA.c        **** 
3986:WTPA.c        **** static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
3987:WTPA.c        **** // Shuttles the entire adjusted sample window farther into the sample.
3988:WTPA.c        **** // This divides the current sample size by the value of an unsigned char and places the new boundar
3989:WTPA.c        **** // Note:  If the current sample address is out of the new range, this will pull it in.
3990:WTPA.c        **** {
3991:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
3992:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
3993:WTPA.c        **** }
3994:WTPA.c        **** 
3995:WTPA.c        **** //--------------------------------------
3996:WTPA.c        **** //--------------------------------------
3997:WTPA.c        **** // SAMPLER Main Loop!
3998:WTPA.c        **** //--------------------------------------
3999:WTPA.c        **** //--------------------------------------
4000:WTPA.c        **** 
4001:WTPA.c        **** static unsigned char
4002:WTPA.c        **** 	currentBank;					// Keeps track of the bank we're thinking about.
4003:WTPA.c        **** 
4004:WTPA.c        **** static void SdCardMenu(void)
4005:WTPA.c        **** // Give the user a manual interface for managing samples stored on the SD card.
4006:WTPA.c        **** // LED_7 will blink if there is a sample in the currently selected slot.
4007:WTPA.c        **** // The index of the currently selected sample slot will be indicated on LEDs 0-6, and are scrolled 
4008:WTPA.c        **** // Below is the button map.
4009:WTPA.c        **** // NOTE:  Load and Save functions apply to the bank currently selected.
4010:WTPA.c        **** 
4011:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
4012:WTPA.c        **** // ------------------------------------------------------------------------------------------------
4013:WTPA.c        **** // No Shift:	Play		Load		Save		Delete		Exit		Exit		Exit		Exit
4014:WTPA.c        **** {
4015:WTPA.c        **** 	if(subState==SS_0)		// Initialize LEDs and slots
4016:WTPA.c        **** 	{		
4017:WTPA.c        **** 		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
4018:WTPA.c        **** 		{
4019:WTPA.c        **** 			sdCurrentSlot=127;
4020:WTPA.c        **** 		}		
4021:WTPA.c        **** 
4022:WTPA.c        **** 		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently lookin
4023:WTPA.c        **** 		StopBlinking();					// Make sure nothing is errantly blinking
4024:WTPA.c        **** 
4025:WTPA.c        **** 		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
4026:WTPA.c        **** 		{
4027:WTPA.c        **** 			BlinkLeds(1<<LED_7);
4028:WTPA.c        **** 		}	
4029:WTPA.c        **** 
4030:WTPA.c        **** 		subState=SS_1;
4031:WTPA.c        **** 	}
4032:WTPA.c        **** 	else
4033:WTPA.c        **** 	{
4034:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
4035:WTPA.c        **** 		{
4036:WTPA.c        **** 			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
4037:WTPA.c        **** 			{
4038:WTPA.c        **** 				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
4039:WTPA.c        **** 			}
4040:WTPA.c        **** 
4041:WTPA.c        **** 			KillLeds();				// Exit menu
4042:WTPA.c        **** 			SetState(DoSampler);
4043:WTPA.c        **** 		}
4044:WTPA.c        **** 		else
4045:WTPA.c        **** 		{
4046:WTPA.c        **** 			if(newEncoder)		// Increment or decrement card slot if encoder moves
4047:WTPA.c        **** 			{
4048:WTPA.c        **** 				if(encoderCw)
4049:WTPA.c        **** 				{
4050:WTPA.c        **** 					sdCurrentSlot++;
4051:WTPA.c        **** 					if(sdCurrentSlot>127)
4052:WTPA.c        **** 					{
4053:WTPA.c        **** 						sdCurrentSlot=0;
4054:WTPA.c        **** 					}
4055:WTPA.c        **** 				}
4056:WTPA.c        **** 				else if(encoderCcw)
4057:WTPA.c        **** 				{
4058:WTPA.c        **** 					if(sdCurrentSlot==0)
4059:WTPA.c        **** 					{
4060:WTPA.c        **** 						sdCurrentSlot=127;
4061:WTPA.c        **** 					}
4062:WTPA.c        **** 					else
4063:WTPA.c        **** 					{
4064:WTPA.c        **** 						sdCurrentSlot--;
4065:WTPA.c        **** 					}
4066:WTPA.c        **** 				}
4067:WTPA.c        **** 
4068:WTPA.c        **** 				ledOnOffMask=sdCurrentSlot;		
4069:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
4070:WTPA.c        **** 				{
4071:WTPA.c        **** 					BlinkLeds(1<<LED_7);
4072:WTPA.c        **** 				}	
4073:WTPA.c        **** 				else
4074:WTPA.c        **** 				{
4075:WTPA.c        **** 					StopBlinking();
4076:WTPA.c        **** 					ledOnOffMask&=~(1<<LED_7);
4077:WTPA.c        **** 				}
4078:WTPA.c        **** 			}
4079:WTPA.c        **** 
4080:WTPA.c        **** 			if(newKeys&Im_SWITCH_0)		// Stream sample
4081:WTPA.c        **** 			{
4082:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4083:WTPA.c        **** 				{		
4084:WTPA.c        **** 					PlaySampleFromSd(sdCurrentSlot);
4085:WTPA.c        **** 				}
4086:WTPA.c        **** 			}		
4087:WTPA.c        **** 			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
4088:WTPA.c        **** 			{
4089:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4090:WTPA.c        **** 				{		
4091:WTPA.c        **** 					ReadSampleFromSd(currentBank,sdCurrentSlot);
4092:WTPA.c        **** 				}
4093:WTPA.c        **** 			}		
4094:WTPA.c        **** 			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
4095:WTPA.c        **** 			{
4096:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4097:WTPA.c        **** 				{
4098:WTPA.c        **** 					WriteSampleToSd(currentBank,sdCurrentSlot);
4099:WTPA.c        **** 					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
4100:WTPA.c        **** 				}
4101:WTPA.c        **** 			}		
4102:WTPA.c        **** 			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like 
4103:WTPA.c        **** 			{
4104:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
4105:WTPA.c        **** 				{		
4106:WTPA.c        **** 					if(cardState==SD_IDLE)	// Got what we wanted?
4107:WTPA.c        **** 					{
4108:WTPA.c        **** 						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
4109:WTPA.c        **** 						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
4110:WTPA.c        **** 						StopBlinking();					// Update LED to reflect that this is now full
4111:WTPA.c        **** 						ledOnOffMask&=~(1<<LED_7);
4112:WTPA.c        **** 					}
4113:WTPA.c        **** 				}
4114:WTPA.c        **** 			}		
4115:WTPA.c        **** 			
4116:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
4117:WTPA.c        **** 			{
4118:WTPA.c        **** 				KillLeds();
4119:WTPA.c        **** 				SetState(DoSampler);
4120:WTPA.c        **** 			}
4121:WTPA.c        **** 		}
4122:WTPA.c        **** 	}
4123:WTPA.c        **** }
4124:WTPA.c        **** 
4125:WTPA.c        **** static void UpdateUserSwitches(void)
4126:WTPA.c        **** // Take the button-mashings of the player and translate them into something useful.
4127:WTPA.c        **** // There are two "shift" keys on WTPA2 (switch 6 and 7).
4128:WTPA.c        **** // Button functions are relative to how many shift keys are being held down: 0, one, or two.
4129:WTPA.c        **** 
4130:WTPA.c        **** // Button		0			1			2			3			4			5			6			7
4131:WTPA.c        **** // ------------------------------------------------------------------------------------------------
4132:WTPA.c        **** // No Shift:	Rec			Odub		Restart		Single		Pause		Bank		Shift1		Shift2
4133:WTPA.c        **** // Shift 1:		BitDepth	Halftime	Realtime	Granular	SumMode		Backwards	(pressed)	(not pressed)
4134:WTPA.c        **** // Shift 2:		Edit Start	Edit End	Edit Wind	Play SD		Jitter		?			(not press)	(pressed)
4135:WTPA.c        **** // Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
4136:WTPA.c        **** {
4137:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4138:WTPA.c        **** 	// Two shift keys:
4139:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4140:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
4141:WTPA.c        **** 	{
4142:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
4143:WTPA.c        **** 		{
4144:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
4145:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
4146:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
4147:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
4148:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
4149:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
4150:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
4151:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
4152:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
4153:WTPA.c        **** 			bankStates[currentBank].realtimeOn=false;
4154:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
4155:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
4156:WTPA.c        **** 		}
4157:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
4158:WTPA.c        **** 		{
4159:WTPA.c        **** 			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
4160:WTPA.c        **** 			{
4161:WTPA.c        **** 				SetState(SdCardMenu);
4162:WTPA.c        **** 			}
4163:WTPA.c        **** 		}
4164:WTPA.c        **** 	}
4165:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4166:WTPA.c        **** 	// Shift 1:
4167:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4168:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
4169:WTPA.c        **** 	{
4170:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
4171:WTPA.c        **** 		{
4172:WTPA.c        **** 			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just
4173:WTPA.c        **** 			{
4174:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
4175:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
4176:WTPA.c        **** 			}
4177:WTPA.c        **** 		}
4178:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
4179:WTPA.c        **** 		{
4180:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
4181:WTPA.c        **** 			{
4182:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
4183:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
4184:WTPA.c        **** 			}
4185:WTPA.c        **** 			else
4186:WTPA.c        **** 			{
4187:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
4188:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
4189:WTPA.c        **** 			}
4190:WTPA.c        **** 		}
4191:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
4192:WTPA.c        **** 		{
4193:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
4194:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
4195:WTPA.c        **** 		}
4196:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- res
4197:WTPA.c        **** 		{
4198:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
4199:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
4200:WTPA.c        **** 		}
4201:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
4202:WTPA.c        **** 		{
4203:WTPA.c        **** 			if(newEncoder)	// Only change to new values
4204:WTPA.c        **** 			{
4205:WTPA.c        **** 				switch(scaledEncoderValue)
4206:WTPA.c        **** 				{
4207:WTPA.c        **** 					case 0:
4208:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4209:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4210:WTPA.c        **** 					break;
4211:WTPA.c        **** 
4212:WTPA.c        **** 					case 1:
4213:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
4214:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4215:WTPA.c        **** 					break;
4216:WTPA.c        **** 
4217:WTPA.c        **** 					case 2:
4218:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
4219:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4220:WTPA.c        **** 					break;
4221:WTPA.c        **** 
4222:WTPA.c        **** 					case 3:
4223:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
4224:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
4225:WTPA.c        **** 					break;
4226:WTPA.c        **** 
4227:WTPA.c        **** 					default:
4228:WTPA.c        **** 					break;
4229:WTPA.c        **** 				}
4230:WTPA.c        **** 			}
4231:WTPA.c        **** 		}
4232:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
4233:WTPA.c        **** 		{
4234:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
4235:WTPA.c        **** 			{
4236:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
4237:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
4238:WTPA.c        **** 			}
4239:WTPA.c        **** 			else
4240:WTPA.c        **** 			{
4241:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
4242:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
4243:WTPA.c        **** 			}
4244:WTPA.c        **** 
4245:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
4246:WTPA.c        **** 		}
4247:WTPA.c        **** 	}
4248:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4249:WTPA.c        **** 	// Shift 2:
4250:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4251:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
4252:WTPA.c        **** 	{
4253:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
4254:WTPA.c        **** 		{
4255:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
4256:WTPA.c        **** 			{
4257:WTPA.c        **** 				AdjustSampleStart(currentBank,encoderValue);
4258:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
4259:WTPA.c        **** 			}
4260:WTPA.c        **** 		}
4261:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
4262:WTPA.c        **** 		{
4263:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
4264:WTPA.c        **** 			{
4265:WTPA.c        **** 				AdjustSampleEnd(currentBank,encoderValue);
4266:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
4267:WTPA.c        **** 			}
4268:WTPA.c        **** 		}
4269:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
4270:WTPA.c        **** 		{
4271:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
4272:WTPA.c        **** 			{
4273:WTPA.c        **** 				AdjustSampleWindow(currentBank,encoderValue);
4274:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
4275:WTPA.c        **** 			}
4276:WTPA.c        **** 		}
4277:WTPA.c        **** 
4278:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
4279:WTPA.c        **** 		{
4280:WTPA.c        **** 			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
4281:WTPA.c        **** 
4282:WTPA.c        **** 		}
4283:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)		// Update Jitter
4284:WTPA.c        **** 		{
4285:WTPA.c        **** 			//	bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;		// 
4286:WTPA.c        **** 		}
4287:WTPA.c        **** 	}
4288:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4289:WTPA.c        **** 	// No shift keys pressed:
4290:WTPA.c        **** 	// -----------------------------------------------------------------------------------
4291:WTPA.c        **** 	else	// User isn't holding shift keys, look for single key presses
4292:WTPA.c        **** 	{
4293:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
4294:WTPA.c        **** 		{
4295:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
4296:WTPA.c        **** 			{
4297:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4298:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4299:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4300:WTPA.c        **** 			}
4301:WTPA.c        **** 			else											// We're not recording right now, so start doing it.
4302:WTPA.c        **** 			{
4303:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
4304:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
4305:WTPA.c        **** 			}
4306:WTPA.c        **** 		}
4307:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
4308:WTPA.c        **** 		{
4309:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
4310:WTPA.c        **** 			{
4311:WTPA.c        **** 				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorde
4312:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4313:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
4314:WTPA.c        **** 			}
4315:WTPA.c        **** 			else							// We're not recording right now, so start doing it.
4316:WTPA.c        **** 			{
4317:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
4318:WTPA.c        **** 				{
4319:WTPA.c        **** 					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
4320:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
4321:WTPA.c        **** 				}
4322:WTPA.c        **** 			}
4323:WTPA.c        **** 		}
4324:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
4325:WTPA.c        **** 		{
4326:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4327:WTPA.c        **** 			{
4328:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded 
4329:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
4330:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4331:WTPA.c        **** 			}
4332:WTPA.c        **** 		}
4333:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
4334:WTPA.c        **** 		{
4335:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
4336:WTPA.c        **** 			{
4337:WTPA.c        **** 				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
4338:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
4339:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
4340:WTPA.c        **** 			}
4341:WTPA.c        **** 		}
4342:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
4343:WTPA.c        **** 		{
4344:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
4345:WTPA.c        **** 			{
4346:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
4347:WTPA.c        **** 				{
4348:WTPA.c        **** 					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are 
4349:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
4350:WTPA.c        **** 				}
4351:WTPA.c        **** 			}
4352:WTPA.c        **** 			else		// Pause whatever we were doing.
4353:WTPA.c        **** 			{
4354:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
4355:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
4356:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
4357:WTPA.c        **** 			}
4358:WTPA.c        **** 
4359:WTPA.c        **** 		}
4360:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
4361:WTPA.c        **** 		{
4362:WTPA.c        **** 			currentBank++;
4363:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
4364:WTPA.c        **** 			{
4365:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
4366:WTPA.c        **** 			}
4367:WTPA.c        **** 		}
4368:WTPA.c        **** 	}
4369:WTPA.c        **** }
4370:WTPA.c        **** 
4371:WTPA.c        **** static void DoSampler(void)
4372:WTPA.c        **** // Sampler main loop.  This handles getting switch inputs and MIDI and calling all the functions ne
4373:WTPA.c        **** // If we want to enter a "menu" we should leave this state and return when it's time to run normall
4374:WTPA.c        **** // An old note:
4375:WTPA.c        **** // Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do somethi
4376:WTPA.c        **** // power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be 
4377:WTPA.c        **** {
4378:WTPA.c        **** 	unsigned char
4379:WTPA.c        **** 		sreg;
4380:WTPA.c        **** 
4381:WTPA.c        **** 	static MIDI_MESSAGE
4382:WTPA.c        **** 		currentMidiMessage;				// Used to point to incoming midi messages.
4383:WTPA.c        **** 
4384:WTPA.c        **** 	static unsigned char
4385:WTPA.c        **** 		currentNoteOn[NUM_BANKS]=		// Used to keep track of what notes we've got on in MIDI.
4386:WTPA.c        **** 		{
4387:WTPA.c        **** 			60,							// In case we record, then overdub immediately without playing anything, we'll need a 
4388:WTPA.c        **** 			60,
4389:WTPA.c        **** 		};
4390:WTPA.c        **** 
4391:WTPA.c        **** 	unsigned int
4392:WTPA.c        **** 		pitchWheelValue;				// Figures out what to do with the pitchbend data.
4393:WTPA.c        **** 
4394:WTPA.c        **** 	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sam
4395:WTPA.c        **** 	{
4396:WTPA.c        **** 		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI
4397:WTPA.c        **** 
4398:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
4399:WTPA.c        **** 		{
4400:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
4401:WTPA.c        **** 
4402:WTPA.c        **** //			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
4403:WTPA.c        **** //			{
4404:WTPA.c        **** //				// Do this here.
4405:WTPA.c        **** //			}
4406:WTPA.c        **** 
4407:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
4408:WTPA.c        **** 			{
4409:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
4410:WTPA.c        **** 				{
4411:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
4412:WTPA.c        **** 					{
4413:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
4414:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
4415:WTPA.c        **** 					}
4416:WTPA.c        **** 				}
4417:WTPA.c        **** 			}
4418:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
4419:WTPA.c        **** 			{
4420:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
4421:WTPA.c        **** 
4422:WTPA.c        **** 				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
4423:WTPA.c        **** 				{
4424:WTPA.c        **** 					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNot
4425:WTPA.c        **** 				}
4426:WTPA.c        **** 				else
4427:WTPA.c        **** 				{
4428:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
4429:WTPA.c        **** 					{
4430:WTPA.c        **** 						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNo
4431:WTPA.c        **** 					}
4432:WTPA.c        **** 				}
4433:WTPA.c        **** 			}
4434:WTPA.c        **** 
4435:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
4436:WTPA.c        **** 			{
4437:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
4438:WTPA.c        **** 				{
4439:WTPA.c        **** 					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
4440:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4441:WTPA.c        **** 					{
4442:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
4443:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll defa
4444:WTPA.c        **** 					}
4445:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
4446:WTPA.c        **** 					{
4447:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4448:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4449:WTPA.c        **** 					}
4450:WTPA.c        **** 					break;
4451:WTPA.c        **** 
4452:WTPA.c        **** 					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
4453:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4454:WTPA.c        **** 					{
4455:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
4456:WTPA.c        **** 						{
4457:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
4458:WTPA.c        **** 							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll defaul
4459:WTPA.c        **** 						}
4460:WTPA.c        **** 					}
4461:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
4462:WTPA.c        **** 					{
4463:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
4464:WTPA.c        **** 					}
4465:WTPA.c        **** 					break;
4466:WTPA.c        **** 
4467:WTPA.c        **** 					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
4468:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4469:WTPA.c        **** 					{
4470:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
4471:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so th
4472:WTPA.c        **** 					}
4473:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
4474:WTPA.c        **** 					{
4475:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
4476:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
4477:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playba
4478:WTPA.c        **** 					}
4479:WTPA.c        **** 
4480:WTPA.c        **** 					break;
4481:WTPA.c        **** 
4482:WTPA.c        **** 					case MIDI_LOOP:							// Keep playing samples over again until note off.
4483:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4484:WTPA.c        **** 					{
4485:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4486:WTPA.c        **** 					}
4487:WTPA.c        **** 					else
4488:WTPA.c        **** 					{
4489:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
4490:WTPA.c        **** 					}
4491:WTPA.c        **** 					break;
4492:WTPA.c        **** 
4493:WTPA.c        **** 					case MIDI_HALF_SPEED:							// Skrew and chop.
4494:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4495:WTPA.c        **** 					{
4496:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
4497:WTPA.c        **** 					}
4498:WTPA.c        **** 					else
4499:WTPA.c        **** 					{
4500:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4501:WTPA.c        **** 					}
4502:WTPA.c        **** 					break;
4503:WTPA.c        **** 
4504:WTPA.c        **** 					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
4505:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
4506:WTPA.c        **** 					{
4507:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
4508:WTPA.c        **** 					}
4509:WTPA.c        **** 					else
4510:WTPA.c        **** 					{
4511:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4512:WTPA.c        **** 					}
4513:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
4514:WTPA.c        **** 					break;
4515:WTPA.c        **** 
4516:WTPA.c        **** 					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
4517:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
4518:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
4519:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
4520:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
4521:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
4522:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4523:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
4524:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
4525:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
4526:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
4527:WTPA.c        **** 					break;
4528:WTPA.c        **** 
4529:WTPA.c        **** 					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
4530:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
4531:WTPA.c        **** 					{
4532:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
4533:WTPA.c        **** 					}
4534:WTPA.c        **** 					break;
4535:WTPA.c        **** 
4536:WTPA.c        **** 					case MIDI_GRANULARITY:						// Beatbox.
4537:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4538:WTPA.c        **** 					break;
4539:WTPA.c        **** 
4540:WTPA.c        **** 					case MIDI_JITTER:							// Hisssss
4541:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
4542:WTPA.c        **** 					break;
4543:WTPA.c        **** 
4544:WTPA.c        **** 					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
4545:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
4546:WTPA.c        **** 					{
4547:WTPA.c        **** 						case 0:
4548:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
4549:WTPA.c        **** 						break;
4550:WTPA.c        **** 
4551:WTPA.c        **** 						case 1:
4552:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
4553:WTPA.c        **** 						break;
4554:WTPA.c        **** 
4555:WTPA.c        **** 						case 2:
4556:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
4557:WTPA.c        **** 						break;
4558:WTPA.c        **** 
4559:WTPA.c        **** 						case 3:
4560:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
4561:WTPA.c        **** 						break;
4562:WTPA.c        **** 
4563:WTPA.c        **** 						default:
4564:WTPA.c        **** 						break;
4565:WTPA.c        **** 					}
4566:WTPA.c        **** 					break;
4567:WTPA.c        **** 
4568:WTPA.c        **** 					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
4569:WTPA.c        **** 					sreg=SREG;
4570:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
4571:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
4572:WTPA.c        **** 					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelN
4573:WTPA.c        **** 					SREG=sreg;		// Re-enable interrupts.
4574:WTPA.c        **** 					break;
4575:WTPA.c        **** 
4576:WTPA.c        **** //	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-siz
4577:WTPA.c        **** 
4578:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
4579:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4580:WTPA.c        **** 					break;
4581:WTPA.c        **** 
4582:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
4583:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4584:WTPA.c        **** 					break;
4585:WTPA.c        **** 
4586:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
4587:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
4588:WTPA.c        **** 					break;
4589:WTPA.c        **** 
4590:WTPA.c        **** 					case MIDI_REVERT_SAMPLE_TO_FULL:
4591:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
4592:WTPA.c        **** 					break;
4593:WTPA.c        **** 
4594:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_START_WIDE:
4595:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4596:WTPA.c        **** 					break;
4597:WTPA.c        **** 
4598:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_END_WIDE:
4599:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4600:WTPA.c        **** 					break;
4601:WTPA.c        **** 
4602:WTPA.c        **** 					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
4603:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
4604:WTPA.c        **** 					break;
4605:WTPA.c        **** 
4606:WTPA.c        **** 					default:
4607:WTPA.c        **** 					break;
4608:WTPA.c        **** 				}
4609:WTPA.c        **** 			}
4610:WTPA.c        **** 
4611:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
4612:WTPA.c        **** 			{
4613:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
4614:WTPA.c        **** 
4615:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
4616:WTPA.c        **** 				{
4617:WTPA.c        **** 					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This
4618:WTPA.c        **** 					{
4619:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4620:WTPA.c        **** 					}
4621:WTPA.c        **** 					else						// Pitch the note by some amount (add value to the OCR1A).
4622:WTPA.c        **** 					{
4623:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
4624:WTPA.c        **** 					}
4625:WTPA.c        **** 				}
4626:WTPA.c        **** 				else
4627:WTPA.c        **** 				{
4628:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
4629:WTPA.c        **** 				}
4630:WTPA.c        **** 			}
4631:WTPA.c        **** 		}
4632:WTPA.c        **** 	}
4633:WTPA.c        **** 
4634:WTPA.c        **** //	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle clo
4635:WTPA.c        **** 	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Voi
4636:WTPA.c        **** 	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
4637:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
4638:WTPA.c        **** }
4639:WTPA.c        **** 
4640:WTPA.c        **** static void InitSampler(void)
4641:WTPA.c        **** // Gets all variables and data structures read and set when the sampler starts up.
4642:WTPA.c        **** {
4643:WTPA.c        **** 	unsigned char
4644:WTPA.c        **** 		i;
4645:WTPA.c        **** 
4646:WTPA.c        **** 	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
4647:WTPA.c        **** 	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
4648:WTPA.c        **** 	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcod
4649:WTPA.c        **** 	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcod
4650:WTPA.c        **** 
4651:WTPA.c        **** 	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
4652:WTPA.c        **** 	{
4653:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
4654:WTPA.c        **** 		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
4655:WTPA.c        **** 		bankStates[i].loopOnce=false;
4656:WTPA.c        **** 		bankStates[i].bitReduction=0;				// No crusties yet.
4657:WTPA.c        **** 		bankStates[i].jitterValue=0;				// No hissies yet.
4658:WTPA.c        **** 		bankStates[i].granularSlices=0;				// No remix yet.
4659:WTPA.c        **** 		bankStates[i].halfSpeed=false;
4660:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
4661:WTPA.c        **** 		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
4662:WTPA.c        **** 		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the begi
4663:WTPA.c        **** 		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sam
4664:WTPA.c        **** 		bankStates[i].realtimeOn=false;						// We'll default to playback.
4665:WTPA.c        **** 		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
4666:WTPA.c        **** 
4667:WTPA.c        **** 		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
4668:WTPA.c        **** 
4669:WTPA.c        **** 		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
4670:WTPA.c        **** 		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful numb
4671:WTPA.c        **** 	}
4672:WTPA.c        **** 
4673:WTPA.c        **** 	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4674:WTPA.c        **** 
4675:WTPA.c        **** 	currentBank=BANK_0;			// Point at the first bank until we change banks.
4676:WTPA.c        **** 	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
4677:WTPA.c        **** 
4678:WTPA.c        **** 	KillLeds();					// All leds off, and no blinking.
4679:WTPA.c        **** 	SetState(DoSampler);		// Get to sampling
4680:WTPA.c        **** }
4681:WTPA.c        **** 
4682:WTPA.c        **** //--------------------------------------
4683:WTPA.c        **** //--------------------------------------
4684:WTPA.c        **** // DAC Testing.
4685:WTPA.c        **** //--------------------------------------
4686:WTPA.c        **** //--------------------------------------
4687:WTPA.c        **** 
4688:WTPA.c        **** static void DoSawtooth(void)
4689:WTPA.c        **** // See if we can get some audio out.  And look good doing it.
4690:WTPA.c        **** // Also test to see if our flash is present and working.
4691:WTPA.c        **** {
4692:WTPA.c        **** 	if(subState==SS_0)
4693:WTPA.c        **** 	{
4694:WTPA.c        **** 		KillLeds();							// Start with LEDs off.
4695:WTPA.c        **** 		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
4696:WTPA.c        **** 		subState=SS_1;
4697:WTPA.c        **** 	}
4698:WTPA.c        **** 	else if(subState==SS_1)
4699:WTPA.c        **** 	{
4700:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4701:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
4702:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
4703:WTPA.c        **** 		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
4704:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
4705:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
4706:WTPA.c        **** 
4707:WTPA.c        **** 		subState=SS_2;					// And wait forever.
4708:WTPA.c        **** 	}
4709:WTPA.c        **** 	else if(subState==SS_2)
4710:WTPA.c        **** 	{
4711:WTPA.c        **** 
4712:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4713:WTPA.c        **** 		{
4714:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
4715:WTPA.c        **** 		}
4716:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4717:WTPA.c        **** 		{
4718:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
4719:WTPA.c        **** 		}
4720:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
4721:WTPA.c        **** 		{
4722:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
4723:WTPA.c        **** 		}
4724:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
4725:WTPA.c        **** 		{
4726:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
4727:WTPA.c        **** 		}
4728:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
4729:WTPA.c        **** 		{
4730:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
4731:WTPA.c        **** 		}
4732:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
4733:WTPA.c        **** 		{
4734:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
4735:WTPA.c        **** 		}
4736:WTPA.c        **** 
4737:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
4738:WTPA.c        **** 		{
4739:WTPA.c        **** 			StopBlinking();
4740:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
4741:WTPA.c        **** 		}
4742:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
4743:WTPA.c        **** 		{
4744:WTPA.c        **** 			StopBlinking();
4745:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
4746:WTPA.c        **** 		}
4747:WTPA.c        **** 		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
4748:WTPA.c        **** 		{
4749:WTPA.c        **** 			StopBlinking();
4750:WTPA.c        **** 			ledOnOffMask=encoderValue;
4751:WTPA.c        **** 		}
4752:WTPA.c        **** 	}
4753:WTPA.c        **** }
4754:WTPA.c        **** 
4755:WTPA.c        **** /*
4756:WTPA.c        **** static void MidiOutputTestBinnis(void)
4757:WTPA.c        **** {
4758:WTPA.c        **** 	if(subState==SS_0)
4759:WTPA.c        **** 	{
4760:WTPA.c        **** 		midiChannelNumberA=0x01;			// @@@ Hardcoded midi channel for now.
4761:WTPA.c        **** 		midiChannelNumberB=0x02;			// @@@ Hardcoded midi channel for now.
4762:WTPA.c        **** 		StopReadingPot();				// Make sure this silly business is gone (for now)
4763:WTPA.c        **** 		KillLeds();						// All leds off, and no blinking.
4764:WTPA.c        **** 		subState=SS_1;
4765:WTPA.c        **** 	}
4766:WTPA.c        **** 	else
4767:WTPA.c        **** 	{
4768:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4769:WTPA.c        **** 		{
4770:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_0));	// Toggle the LED.
4771:WTPA.c        **** 			// Hardcoded Note On, middle C, Velocity 64, Midi channel 1.
4772:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4773:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4774:WTPA.c        **** 			Uart0SendByte(64);			// @@@
4775:WTPA.c        **** 
4776:WTPA.c        **** 		}
4777:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4778:WTPA.c        **** 		{
4779:WTPA.c        **** 			SetLedsOnOff(ledOnOffMask^(1<<LED_1));	// Toggle the LED.
4780:WTPA.c        **** 			// Hardcoded Note Off, middle C, Velocity 0, Midi channel 1.
4781:WTPA.c        **** 			Uart0SendByte(0x91);		// @@@
4782:WTPA.c        **** 			Uart0SendByte(60);			// @@@
4783:WTPA.c        **** 			Uart0SendByte(0);			// @@@
4784:WTPA.c        **** 		}
4785:WTPA.c        **** 	}
4786:WTPA.c        **** }
4787:WTPA.c        **** */
4788:WTPA.c        **** 
4789:WTPA.c        **** 
4790:WTPA.c        **** static void SetMidiChannels(void)
4791:WTPA.c        **** // This is a state the user can enter at startup where they set and store desired midi channels usi
4792:WTPA.c        **** {
4793:WTPA.c        **** 	if(subState==SS_0)
4794:WTPA.c        **** 	{
4795:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
4796:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
4797:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
4798:WTPA.c        **** 		subState=SS_1;
4799:WTPA.c        **** 	}
4800:WTPA.c        **** 	else
4801:WTPA.c        **** 	{
4802:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
4803:WTPA.c        **** 		{
4804:WTPA.c        **** 			midiChannelNumberA++;
4805:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
4806:WTPA.c        **** 			{
4807:WTPA.c        **** 				midiChannelNumberA=0;
4808:WTPA.c        **** 			}
4809:WTPA.c        **** 
4810:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
4811:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
4812:WTPA.c        **** 		}
4813:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
4814:WTPA.c        **** 		{
4815:WTPA.c        **** 			midiChannelNumberB++;
4816:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
4817:WTPA.c        **** 			{
4818:WTPA.c        **** 				midiChannelNumberB=0;
4819:WTPA.c        **** 			}
4820:WTPA.c        **** 
4821:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
4822:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
4823:WTPA.c        **** 		}
4824:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
4825:WTPA.c        **** 		{
4826:WTPA.c        **** 			StoreMidiChannel(BANK_0,midiChannelNumberA);
4827:WTPA.c        **** 			StoreMidiChannel(BANK_1,midiChannelNumberB);
4828:WTPA.c        **** 			SetState(InitSampler);
4829:WTPA.c        **** 		}
4830:WTPA.c        **** 	}
4831:WTPA.c        **** }
4832:WTPA.c        **** 
4833:WTPA.c        **** static void DoStartupSelect(void)
4834:WTPA.c        **** // Make all our initial state decisions.
4835:WTPA.c        **** // Give switches time to settle.
4836:WTPA.c        **** {
 3430               		.loc 1 4836 0
 3431               		.cfi_startproc
 3432               	/* prologue: function */
 3433               	/* frame size = 0 */
 3434               	/* stack size = 0 */
 3435               	.L__stack_usage = 0
4837:WTPA.c        **** 	if(subState==SS_0)
 3436               		.loc 1 4837 0
 3437 1d56 8091 0000 		lds r24,subState
 3438 1d5a 8823      		tst r24
 3439 1d5c 01F0      		breq .L214
4838:WTPA.c        **** 	{
4839:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
4840:WTPA.c        **** 		subState=SS_1;
4841:WTPA.c        **** 	}
4842:WTPA.c        **** 	else
4843:WTPA.c        **** 	{
4844:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 3440               		.loc 1 4844 0
 3441 1d5e 80E0      		ldi r24,0
 3442 1d60 0E94 0000 		call CheckTimer
 3443               	.LVL95:
 3444 1d64 8823      		tst r24
 3445 1d66 01F0      		breq .L206
 3446               	.LBB146:
 3447               	.LBB147:
4845:WTPA.c        **** 		{
4846:WTPA.c        **** 			if(keyState&Im_SWITCH_0)
 3448               		.loc 1 4846 0
 3449 1d68 8091 0000 		lds r24,keyState
 3450 1d6c 80FD      		sbrc r24,0
 3451 1d6e 00C0      		rjmp .L215
4847:WTPA.c        **** 			{
4848:WTPA.c        **** 				SetState(DoSawtooth);
4849:WTPA.c        **** 			}
4850:WTPA.c        **** 			else if(keyState&Im_SWITCH_5)
 3452               		.loc 1 4850 0
 3453 1d70 85FD      		sbrc r24,5
 3454 1d72 00C0      		rjmp .L216
 3455               	.LVL96:
 3456               	.LBB148:
 3457               	.LBB149:
1504:WTPA.c        **** 	State=newState;
 3458               		.loc 1 1504 0
 3459 1d74 80E0      		ldi r24,lo8(gs(InitSampler))
 3460 1d76 90E0      		ldi r25,hi8(gs(InitSampler))
 3461 1d78 9093 0000 		sts State+1,r25
 3462 1d7c 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 3463               		.loc 1 1505 0
 3464 1d80 1092 0000 		sts subState,__zero_reg__
 3465               	.LVL97:
 3466               	.L206:
 3467 1d84 0895      		ret
 3468               	.L214:
 3469               	.LBE149:
 3470               	.LBE148:
 3471               	.LBE147:
 3472               	.LBE146:
4839:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/8));
 3473               		.loc 1 4839 0
 3474 1d86 68E9      		ldi r22,lo8(-104)
 3475 1d88 70E0      		ldi r23,0
 3476 1d8a 0E94 0000 		call SetTimer
 3477               	.LVL98:
4840:WTPA.c        **** 		subState=SS_1;
 3478               		.loc 1 4840 0
 3479 1d8e 81E0      		ldi r24,lo8(1)
 3480 1d90 8093 0000 		sts subState,r24
 3481 1d94 0895      		ret
 3482               	.L216:
 3483               	.LVL99:
 3484               	.LBB155:
 3485               	.LBB154:
 3486               	.LBB150:
 3487               	.LBB151:
1504:WTPA.c        **** 	State=newState;
 3488               		.loc 1 1504 0
 3489 1d96 80E0      		ldi r24,lo8(gs(SetMidiChannels))
 3490 1d98 90E0      		ldi r25,hi8(gs(SetMidiChannels))
 3491 1d9a 9093 0000 		sts State+1,r25
 3492 1d9e 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 3493               		.loc 1 1505 0
 3494 1da2 1092 0000 		sts subState,__zero_reg__
 3495 1da6 0895      		ret
 3496               	.LVL100:
 3497               	.L215:
 3498               	.LBE151:
 3499               	.LBE150:
 3500               	.LBB152:
 3501               	.LBB153:
1504:WTPA.c        **** 	State=newState;
 3502               		.loc 1 1504 0
 3503 1da8 80E0      		ldi r24,lo8(gs(DoSawtooth))
 3504 1daa 90E0      		ldi r25,hi8(gs(DoSawtooth))
 3505 1dac 9093 0000 		sts State+1,r25
 3506 1db0 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 3507               		.loc 1 1505 0
 3508 1db4 1092 0000 		sts subState,__zero_reg__
 3509 1db8 0895      		ret
 3510               	.LBE153:
 3511               	.LBE152:
 3512               	.LBE154:
 3513               	.LBE155:
 3514               		.cfi_endproc
 3515               	.LFE74:
 3518               	SetMidiChannels:
 3519               	.LFB73:
4792:WTPA.c        **** {
 3520               		.loc 1 4792 0
 3521               		.cfi_startproc
 3522               	/* prologue: function */
 3523               	/* frame size = 0 */
 3524               	/* stack size = 0 */
 3525               	.L__stack_usage = 0
4793:WTPA.c        **** 	if(subState==SS_0)
 3526               		.loc 1 4793 0
 3527 1dba 8091 0000 		lds r24,subState
 3528 1dbe 8823      		tst r24
 3529 1dc0 01F0      		breq .L239
4802:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 3530               		.loc 1 4802 0
 3531 1dc2 8091 0000 		lds r24,newKeys
 3532 1dc6 80FF      		sbrs r24,0
 3533 1dc8 00C0      		rjmp .L222
4804:WTPA.c        **** 			midiChannelNumberA++;
 3534               		.loc 1 4804 0
 3535 1dca 2091 0000 		lds r18,midiChannelNumberA
 3536 1dce 2F5F      		subi r18,lo8(-(1))
4805:WTPA.c        **** 			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
 3537               		.loc 1 4805 0
 3538 1dd0 2031      		cpi r18,lo8(16)
 3539 1dd2 00F0      		brlo .+2
 3540 1dd4 00C0      		rjmp .L223
4804:WTPA.c        **** 			midiChannelNumberA++;
 3541               		.loc 1 4804 0
 3542 1dd6 2093 0000 		sts midiChannelNumberA,r18
 3543               	.L224:
4810:WTPA.c        **** 			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
 3544               		.loc 1 4810 0
 3545 1dda 9091 0000 		lds r25,ledOnOffMask
 3546 1dde 907F      		andi r25,lo8(-16)
4811:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
 3547               		.loc 1 4811 0
 3548 1de0 922B      		or r25,r18
 3549 1de2 9093 0000 		sts ledOnOffMask,r25
 3550               	.L222:
4813:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 3551               		.loc 1 4813 0
 3552 1de6 81FF      		sbrs r24,1
 3553 1de8 00C0      		rjmp .L225
4815:WTPA.c        **** 			midiChannelNumberB++;
 3554               		.loc 1 4815 0
 3555 1dea 9091 0000 		lds r25,midiChannelNumberB
 3556               	.LVL101:
 3557 1dee 9F5F      		subi r25,lo8(-(1))
 3558               	.LVL102:
4816:WTPA.c        **** 			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
 3559               		.loc 1 4816 0
 3560 1df0 9031      		cpi r25,lo8(16)
 3561               	.LVL103:
 3562 1df2 00F0      		brlo .+2
 3563 1df4 00C0      		rjmp .L226
4815:WTPA.c        **** 			midiChannelNumberB++;
 3564               		.loc 1 4815 0
 3565 1df6 9093 0000 		sts midiChannelNumberB,r25
 3566 1dfa 292F      		mov r18,r25
 3567 1dfc 2295      		swap r18
 3568 1dfe 207F      		andi r18,lo8(-16)
 3569               	.L227:
4821:WTPA.c        **** 			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
 3570               		.loc 1 4821 0
 3571 1e00 9091 0000 		lds r25,ledOnOffMask
 3572               	.LVL104:
 3573 1e04 9F70      		andi r25,lo8(15)
4822:WTPA.c        **** 			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
 3574               		.loc 1 4822 0
 3575 1e06 922B      		or r25,r18
 3576 1e08 9093 0000 		sts ledOnOffMask,r25
 3577               	.L225:
4824:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
 3578               		.loc 1 4824 0
 3579 1e0c 82FF      		sbrs r24,2
 3580 1e0e 0895      		ret
 3581               	.L240:
 3582               	.LVL105:
 3583               	.LBB166:
 3584               	.LBB167:
3471:WTPA.c        **** 		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
 3585               		.loc 1 3471 0
 3586 1e10 6091 0000 		lds r22,midiChannelNumberA
 3587 1e14 84E0      		ldi r24,lo8(4)
 3588 1e16 90E0      		ldi r25,0
 3589 1e18 0E94 0000 		call EepromWrite
 3590               	.LVL106:
 3591               	.LBE167:
 3592               	.LBE166:
 3593               	.LBB168:
 3594               	.LBB169:
3475:WTPA.c        **** 		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
 3595               		.loc 1 3475 0
 3596 1e1c 6091 0000 		lds r22,midiChannelNumberB
 3597 1e20 88E0      		ldi r24,lo8(8)
 3598 1e22 90E0      		ldi r25,0
 3599 1e24 0E94 0000 		call EepromWrite
 3600               	.LVL107:
 3601               	.LBE169:
 3602               	.LBE168:
 3603               	.LBB170:
 3604               	.LBB171:
1504:WTPA.c        **** 	State=newState;
 3605               		.loc 1 1504 0
 3606 1e28 80E0      		ldi r24,lo8(gs(InitSampler))
 3607 1e2a 90E0      		ldi r25,hi8(gs(InitSampler))
 3608 1e2c 9093 0000 		sts State+1,r25
 3609 1e30 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 3610               		.loc 1 1505 0
 3611 1e34 1092 0000 		sts subState,__zero_reg__
 3612 1e38 0895      		ret
 3613               	.LVL108:
 3614               	.L239:
 3615               	.LBE171:
 3616               	.LBE170:
 3617               	.LBB172:
 3618               	.LBB173:
3490:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 3619               		.loc 1 3490 0
 3620 1e3a 84E0      		ldi r24,lo8(4)
 3621 1e3c 0E94 0000 		call EepromRead
 3622               	.LVL109:
3497:WTPA.c        **** 	if(x<16)					// Legit number?
 3623               		.loc 1 3497 0
 3624 1e40 8031      		cpi r24,lo8(16)
 3625 1e42 00F0      		brlo .L219
3511:WTPA.c        **** 		return(x);
 3626               		.loc 1 3511 0
 3627 1e44 80E0      		ldi r24,0
 3628               	.LVL110:
 3629               	.L219:
 3630               	.LBE173:
 3631               	.LBE172:
4795:WTPA.c        **** 		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
 3632               		.loc 1 4795 0
 3633 1e46 8093 0000 		sts midiChannelNumberA,r24
 3634               	.LVL111:
 3635               	.LBB174:
 3636               	.LBB175:
3494:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 3637               		.loc 1 3494 0
 3638 1e4a 88E0      		ldi r24,lo8(8)
 3639 1e4c 0E94 0000 		call EepromRead
 3640               	.LVL112:
3497:WTPA.c        **** 	if(x<16)					// Legit number?
 3641               		.loc 1 3497 0
 3642 1e50 8031      		cpi r24,lo8(16)
 3643 1e52 00F0      		brlo .L241
 3644 1e54 90E1      		ldi r25,lo8(16)
3511:WTPA.c        **** 		return(x);
 3645               		.loc 1 3511 0
 3646 1e56 81E0      		ldi r24,lo8(1)
 3647               	.LVL113:
 3648               	.L220:
 3649               	.LBE175:
 3650               	.LBE174:
4796:WTPA.c        **** 		midiChannelNumberB=GetMidiChannel(BANK_1);
 3651               		.loc 1 4796 0
 3652 1e58 8093 0000 		sts midiChannelNumberB,r24
4797:WTPA.c        **** 		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The bi
 3653               		.loc 1 4797 0
 3654 1e5c 8091 0000 		lds r24,midiChannelNumberA
 3655 1e60 892B      		or r24,r25
 3656 1e62 8093 0000 		sts ledOnOffMask,r24
4798:WTPA.c        **** 		subState=SS_1;
 3657               		.loc 1 4798 0
 3658 1e66 81E0      		ldi r24,lo8(1)
 3659 1e68 8093 0000 		sts subState,r24
 3660 1e6c 0895      		ret
 3661               	.LVL114:
 3662               	.L223:
4807:WTPA.c        **** 				midiChannelNumberA=0;
 3663               		.loc 1 4807 0
 3664 1e6e 1092 0000 		sts midiChannelNumberA,__zero_reg__
 3665 1e72 20E0      		ldi r18,0
 3666 1e74 00C0      		rjmp .L224
 3667               	.LVL115:
 3668               	.L226:
4818:WTPA.c        **** 				midiChannelNumberB=0;
 3669               		.loc 1 4818 0
 3670 1e76 1092 0000 		sts midiChannelNumberB,__zero_reg__
 3671 1e7a 20E0      		ldi r18,0
 3672 1e7c 00C0      		rjmp .L227
 3673               	.LVL116:
 3674               	.L241:
 3675 1e7e 982F      		mov r25,r24
 3676 1e80 9295      		swap r25
 3677 1e82 907F      		andi r25,lo8(-16)
 3678 1e84 00C0      		rjmp .L220
 3679               		.cfi_endproc
 3680               	.LFE73:
 3683               	StartRecording:
 3684               	.LFB29:
1968:WTPA.c        **** {
 3685               		.loc 1 1968 0
 3686               		.cfi_startproc
 3687               	.LVL117:
 3688 1e86 0F93      		push r16
 3689               	.LCFI34:
 3690               		.cfi_def_cfa_offset 3
 3691               		.cfi_offset 16, -2
 3692 1e88 1F93      		push r17
 3693               	.LCFI35:
 3694               		.cfi_def_cfa_offset 4
 3695               		.cfi_offset 17, -3
 3696               	/* prologue: function */
 3697               	/* frame size = 0 */
 3698               	/* stack size = 2 */
 3699               	.L__stack_usage = 2
1973:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 3700               		.loc 1 1973 0
 3701 1e8a A82F      		mov r26,r24
 3702 1e8c B0E0      		ldi r27,0
 3703 1e8e 94E2      		ldi r25,lo8(36)
 3704 1e90 899F      		mul r24,r25
 3705 1e92 F001      		movw r30,r0
 3706 1e94 1124      		clr __zero_reg__
 3707 1e96 E050      		subi r30,lo8(-(bankStates))
 3708 1e98 F040      		sbci r31,hi8(-(bankStates))
 3709 1e9a 9581      		ldd r25,Z+5
 3710 1e9c 9923      		tst r25
 3711 1e9e 01F0      		breq .L243
1973:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 3712               		.loc 1 1973 0 is_stmt 0 discriminator 1
 3713 1ea0 9091 0000 		lds r25,sdIsrState
 3714 1ea4 9150      		subi r25,lo8(-(-1))
 3715 1ea6 9230      		cpi r25,lo8(2)
 3716 1ea8 00F4      		brsh .+2
 3717 1eaa 00C0      		rjmp .L242
 3718               	.L243:
1976:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 3719               		.loc 1 1976 0 is_stmt 1
 3720 1eac 7FB7      		in r23,__SREG__
 3721               	.LVL118:
1977:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 3722               		.loc 1 1977 0
 3723               	/* #APP */
 3724               	 ;  1977 "WTPA.c" 1
 3725 1eae F894      		cli
 3726               	 ;  0 "" 2
1979:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into
 3727               		.loc 1 1979 0
 3728               	/* #NOAPP */
 3729 1eb0 94E2      		ldi r25,lo8(36)
 3730 1eb2 9A9F      		mul r25,r26
 3731 1eb4 F001      		movw r30,r0
 3732 1eb6 9B9F      		mul r25,r27
 3733 1eb8 F00D      		add r31,r0
 3734 1eba 1124      		clr __zero_reg__
 3735 1ebc E050      		subi r30,lo8(-(bankStates))
 3736 1ebe F040      		sbci r31,hi8(-(bankStates))
 3737 1ec0 93E0      		ldi r25,lo8(3)
 3738 1ec2 9083      		st Z,r25
1981:WTPA.c        **** 		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning o
 3739               		.loc 1 1981 0
 3740 1ec4 0189      		ldd r16,Z+17
 3741 1ec6 1289      		ldd r17,Z+18
 3742 1ec8 2389      		ldd r18,Z+19
 3743 1eca 3489      		ldd r19,Z+20
 3744 1ecc 00A3      		std Z+32,r16
 3745 1ece 11A3      		std Z+33,r17
 3746 1ed0 22A3      		std Z+34,r18
 3747 1ed2 33A3      		std Z+35,r19
1982:WTPA.c        **** 		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sampl
 3748               		.loc 1 1982 0
 3749 1ed4 0189      		ldd r16,Z+17
 3750 1ed6 1289      		ldd r17,Z+18
 3751 1ed8 2389      		ldd r18,Z+19
 3752 1eda 3489      		ldd r19,Z+20
 3753 1edc 0587      		std Z+13,r16
 3754 1ede 1687      		std Z+14,r17
 3755 1ee0 2787      		std Z+15,r18
 3756 1ee2 308B      		std Z+16,r19
1983:WTPA.c        **** 		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming ye
 3757               		.loc 1 1983 0
 3758 1ee4 0189      		ldd r16,Z+17
 3759 1ee6 1289      		ldd r17,Z+18
 3760 1ee8 2389      		ldd r18,Z+19
 3761 1eea 3489      		ldd r19,Z+20
 3762 1eec 018F      		std Z+25,r16
 3763 1eee 128F      		std Z+26,r17
 3764 1ef0 238F      		std Z+27,r18
 3765 1ef2 348F      		std Z+28,r19
1984:WTPA.c        **** 		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
 3766               		.loc 1 1984 0
 3767 1ef4 0189      		ldd r16,Z+17
 3768 1ef6 1289      		ldd r17,Z+18
 3769 1ef8 2389      		ldd r18,Z+19
 3770 1efa 3489      		ldd r19,Z+20
 3771 1efc 058B      		std Z+21,r16
 3772 1efe 168B      		std Z+22,r17
 3773 1f00 278B      		std Z+23,r18
 3774 1f02 308F      		std Z+24,r19
1985:WTPA.c        **** 		bankStates[theBank].sampleWindowOffset=0;									// "
 3775               		.loc 1 1985 0
 3776 1f04 178E      		std Z+31,__zero_reg__
1987:WTPA.c        **** 		outOfRam=false;						// Plenty of ram left...
 3777               		.loc 1 1987 0
 3778 1f06 1092 0000 		sts outOfRam,__zero_reg__
 3779               	.LVL119:
 3780               	.LBB182:
 3781               	.LBB183:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 3782               		.loc 1 1925 0
 3783 1f0a 6287      		std Z+10,r22
1927:WTPA.c        **** 	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-cont
 3784               		.loc 1 1927 0
 3785 1f0c 6230      		cpi r22,lo8(2)
 3786 1f0e 01F0      		breq .L253
1946:WTPA.c        **** 	else if(theClock==CLK_EXTERNAL)	// External clock.
 3787               		.loc 1 1946 0
 3788 1f10 6130      		cpi r22,lo8(1)
 3789 1f12 01F0      		breq .L254
 3790               	.LVL120:
 3791               	.L247:
 3792               	.LBE183:
 3793               	.LBE182:
1990:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 3794               		.loc 1 1990 0
 3795 1f14 84E2      		ldi r24,lo8(36)
 3796 1f16 8A9F      		mul r24,r26
 3797 1f18 F001      		movw r30,r0
 3798 1f1a 8B9F      		mul r24,r27
 3799 1f1c F00D      		add r31,r0
 3800 1f1e 1124      		clr __zero_reg__
 3801 1f20 E050      		subi r30,lo8(-(bankStates))
 3802 1f22 F040      		sbci r31,hi8(-(bankStates))
 3803 1f24 81E0      		ldi r24,lo8(1)
 3804 1f26 8583      		std Z+5,r24
1992:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 3805               		.loc 1 1992 0
 3806 1f28 7FBF      		out __SREG__,r23
1995:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 3807               		.loc 1 1995 0
 3808 1f2a 8091 7A00 		lds r24,122
 3809 1f2e 86FD      		sbrc r24,6
 3810 1f30 00C0      		rjmp .L242
 3811               	.LBB187:
 3812               	.LBB188:
1997:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 3813               		.loc 1 1997 0
 3814 1f32 8091 7900 		lds r24,121
 3815 1f36 8058      		subi r24,lo8(-(-128))
 3816 1f38 8093 0000 		sts adcByte,r24
1998:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 3817               		.loc 1 1998 0
 3818 1f3c 8091 7A00 		lds r24,122
 3819 1f40 8064      		ori r24,lo8(64)
 3820 1f42 8093 7A00 		sts 122,r24
 3821               	.LVL121:
 3822               	.L242:
 3823               	/* epilogue start */
 3824               	.LBE188:
 3825               	.LBE187:
2001:WTPA.c        **** }
 3826               		.loc 1 2001 0
 3827 1f46 1F91      		pop r17
 3828 1f48 0F91      		pop r16
 3829 1f4a 0895      		ret
 3830               	.LVL122:
 3831               	.L254:
 3832               	.LBB189:
 3833               	.LBB186:
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 3834               		.loc 1 1948 0
 3835 1f4c 8823      		tst r24
 3836 1f4e 01F0      		breq .L255
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 3837               		.loc 1 1956 0
 3838 1f50 DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 3839               		.loc 1 1957 0
 3840 1f52 84E0      		ldi r24,lo8(4)
 3841               	.LVL123:
 3842 1f54 8093 6800 		sts 104,r24
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 3843               		.loc 1 1958 0
 3844 1f58 80E1      		ldi r24,lo8(16)
 3845 1f5a 8093 6D00 		sts 109,r24
 3846 1f5e 00C0      		rjmp .L247
 3847               	.LVL124:
 3848               	.L253:
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 3849               		.loc 1 1929 0
 3850 1f60 5487      		std Z+12,r21
 3851 1f62 4387      		std Z+11,r20
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 3852               		.loc 1 1931 0
 3853 1f64 8111      		cpse r24,__zero_reg__
 3854 1f66 00C0      		rjmp .L246
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3855               		.loc 1 1933 0
 3856 1f68 8091 8400 		lds r24,132
 3857 1f6c 9091 8500 		lds r25,132+1
 3858               	.LVL125:
 3859 1f70 840F      		add r24,r20
 3860 1f72 951F      		adc r25,r21
 3861 1f74 9093 8900 		sts 136+1,r25
 3862 1f78 8093 8800 		sts 136,r24
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 3863               		.loc 1 1934 0
 3864 1f7c B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 3865               		.loc 1 1935 0
 3866 1f7e 8091 6F00 		lds r24,111
 3867 1f82 8260      		ori r24,lo8(2)
 3868 1f84 8093 6F00 		sts 111,r24
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 3869               		.loc 1 1936 0
 3870 1f88 81E0      		ldi r24,lo8(1)
 3871 1f8a 8093 8100 		sts 129,r24
 3872 1f8e 00C0      		rjmp .L247
 3873               	.LVL126:
 3874               	.L246:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 3875               		.loc 1 1940 0
 3876 1f90 8091 8400 		lds r24,132
 3877 1f94 9091 8500 		lds r25,132+1
 3878               	.LVL127:
 3879 1f98 840F      		add r24,r20
 3880 1f9a 951F      		adc r25,r21
 3881 1f9c 9093 8B00 		sts 138+1,r25
 3882 1fa0 8093 8A00 		sts 138,r24
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 3883               		.loc 1 1941 0
 3884 1fa4 B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 3885               		.loc 1 1942 0
 3886 1fa6 8091 6F00 		lds r24,111
 3887 1faa 8460      		ori r24,lo8(4)
 3888 1fac 8093 6F00 		sts 111,r24
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 3889               		.loc 1 1943 0
 3890 1fb0 81E0      		ldi r24,lo8(1)
 3891 1fb2 8093 8100 		sts 129,r24
 3892 1fb6 00C0      		rjmp .L247
 3893               	.LVL128:
 3894               	.L255:
 3895               	.LBB184:
 3896               	.LBB185:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 3897               		.loc 1 1950 0
 3898 1fb8 8091 8100 		lds r24,129
 3899               	.LVL129:
 3900 1fbc 8064      		ori r24,lo8(64)
 3901 1fbe 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 3902               		.loc 1 1951 0
 3903 1fc2 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 3904               		.loc 1 1952 0
 3905 1fc4 8091 6F00 		lds r24,111
 3906 1fc8 8062      		ori r24,lo8(32)
 3907 1fca 8093 6F00 		sts 111,r24
 3908 1fce 00C0      		rjmp .L247
 3909               	.LBE185:
 3910               	.LBE184:
 3911               	.LBE186:
 3912               	.LBE189:
 3913               		.cfi_endproc
 3914               	.LFE29:
 3917               	InitSampler:
 3918               	.LFB71:
4642:WTPA.c        **** {
 3919               		.loc 1 4642 0
 3920               		.cfi_startproc
 3921               	/* prologue: function */
 3922               	/* frame size = 0 */
 3923               	/* stack size = 0 */
 3924               	.L__stack_usage = 0
 3925               	.LVL130:
 3926               	.LBB206:
 3927               	.LBB207:
3490:WTPA.c        **** 		x=EepromRead(4);		// Get the channel from EEPROM.
 3928               		.loc 1 3490 0
 3929 1fd0 84E0      		ldi r24,lo8(4)
 3930 1fd2 0E94 0000 		call EepromRead
 3931               	.LVL131:
3497:WTPA.c        **** 	if(x<16)					// Legit number?
 3932               		.loc 1 3497 0
 3933 1fd6 8031      		cpi r24,lo8(16)
 3934 1fd8 00F0      		brlo .L257
3511:WTPA.c        **** 		return(x);
 3935               		.loc 1 3511 0
 3936 1fda 80E0      		ldi r24,0
 3937               	.LVL132:
 3938               	.L257:
 3939               	.LBE207:
 3940               	.LBE206:
4646:WTPA.c        **** 	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
 3941               		.loc 1 4646 0
 3942 1fdc 8093 0000 		sts midiChannelNumberA,r24
 3943               	.LVL133:
 3944               	.LBB208:
 3945               	.LBB209:
3494:WTPA.c        **** 		x=EepromRead(8);		// Get the channel from EEPROM.
 3946               		.loc 1 3494 0
 3947 1fe0 88E0      		ldi r24,lo8(8)
 3948 1fe2 0E94 0000 		call EepromRead
 3949               	.LVL134:
3497:WTPA.c        **** 	if(x<16)					// Legit number?
 3950               		.loc 1 3497 0
 3951 1fe6 8031      		cpi r24,lo8(16)
 3952 1fe8 00F0      		brlo .L258
3511:WTPA.c        **** 		return(x);
 3953               		.loc 1 3511 0
 3954 1fea 81E0      		ldi r24,lo8(1)
 3955               	.LVL135:
 3956               	.L258:
 3957               	.LBE209:
 3958               	.LBE208:
4647:WTPA.c        **** 	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
 3959               		.loc 1 4647 0
 3960 1fec 8093 0000 		sts midiChannelNumberB,r24
4648:WTPA.c        **** 	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcod
 3961               		.loc 1 4648 0
 3962 1ff0 1092 0000 		sts bankStates+17,__zero_reg__
 3963 1ff4 1092 0000 		sts bankStates+17+1,__zero_reg__
 3964 1ff8 1092 0000 		sts bankStates+17+2,__zero_reg__
 3965 1ffc 1092 0000 		sts bankStates+17+3,__zero_reg__
4649:WTPA.c        **** 	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcod
 3966               		.loc 1 4649 0
 3967 2000 8FEF      		ldi r24,lo8(-1)
 3968 2002 9FEF      		ldi r25,lo8(-1)
 3969 2004 A7E0      		ldi r26,lo8(7)
 3970 2006 B0E0      		ldi r27,0
 3971 2008 8093 0000 		sts bankStates+53,r24
 3972 200c 9093 0000 		sts bankStates+53+1,r25
 3973 2010 A093 0000 		sts bankStates+53+2,r26
 3974 2014 B093 0000 		sts bankStates+53+3,r27
 3975               	.LVL136:
4653:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 3976               		.loc 1 4653 0
 3977 2018 1092 0000 		sts bankStates,__zero_reg__
4654:WTPA.c        **** 		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
 3978               		.loc 1 4654 0
 3979 201c 1092 0000 		sts bankStates+10,__zero_reg__
4655:WTPA.c        **** 		bankStates[i].loopOnce=false;
 3980               		.loc 1 4655 0
 3981 2020 1092 0000 		sts bankStates+1,__zero_reg__
4656:WTPA.c        **** 		bankStates[i].bitReduction=0;				// No crusties yet.
 3982               		.loc 1 4656 0
 3983 2024 1092 0000 		sts bankStates+9,__zero_reg__
4657:WTPA.c        **** 		bankStates[i].jitterValue=0;				// No hissies yet.
 3984               		.loc 1 4657 0
 3985 2028 1092 0000 		sts bankStates+8,__zero_reg__
4658:WTPA.c        **** 		bankStates[i].granularSlices=0;				// No remix yet.
 3986               		.loc 1 4658 0
 3987 202c 1092 0000 		sts bankStates+7,__zero_reg__
4659:WTPA.c        **** 		bankStates[i].halfSpeed=false;
 3988               		.loc 1 4659 0
 3989 2030 1092 0000 		sts bankStates+2,__zero_reg__
4660:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
 3990               		.loc 1 4660 0
 3991 2034 81E0      		ldi r24,lo8(1)
 3992 2036 8093 0000 		sts bankStates+4,r24
4661:WTPA.c        **** 		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
 3993               		.loc 1 4661 0
 3994 203a 1092 0000 		sts bankStates+3,__zero_reg__
4662:WTPA.c        **** 		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the begi
 3995               		.loc 1 4662 0
 3996 203e 8091 0000 		lds r24,bankStates+17
 3997 2042 9091 0000 		lds r25,bankStates+17+1
 3998 2046 A091 0000 		lds r26,bankStates+17+2
 3999 204a B091 0000 		lds r27,bankStates+17+3
 4000 204e 8093 0000 		sts bankStates+32,r24
 4001 2052 9093 0000 		sts bankStates+32+1,r25
 4002 2056 A093 0000 		sts bankStates+32+2,r26
 4003 205a B093 0000 		sts bankStates+32+3,r27
4663:WTPA.c        **** 		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sam
 4004               		.loc 1 4663 0
 4005 205e 8091 0000 		lds r24,bankStates+17
 4006 2062 9091 0000 		lds r25,bankStates+17+1
 4007 2066 A091 0000 		lds r26,bankStates+17+2
 4008 206a B091 0000 		lds r27,bankStates+17+3
 4009 206e 8093 0000 		sts bankStates+13,r24
 4010 2072 9093 0000 		sts bankStates+13+1,r25
 4011 2076 A093 0000 		sts bankStates+13+2,r26
 4012 207a B093 0000 		sts bankStates+13+3,r27
4664:WTPA.c        **** 		bankStates[i].realtimeOn=false;						// We'll default to playback.
 4013               		.loc 1 4664 0
 4014 207e 1092 0000 		sts bankStates+6,__zero_reg__
4665:WTPA.c        **** 		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
 4015               		.loc 1 4665 0
 4016 2082 1092 0000 		sts bankStates+5,__zero_reg__
 4017               	.LVL137:
 4018               	.LBB210:
 4019               	.LBB211:
3957:WTPA.c        **** 	sreg=SREG;
 4020               		.loc 1 3957 0
 4021 2086 2FB7      		in r18,__SREG__
 4022               	.LVL138:
3958:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 4023               		.loc 1 3958 0
 4024               	/* #APP */
 4025               	 ;  3958 "WTPA.c" 1
 4026 2088 F894      		cli
 4027               	 ;  0 "" 2
3960:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 4028               		.loc 1 3960 0
 4029               	/* #NOAPP */
 4030 208a 8091 0000 		lds r24,bankStates+17
 4031 208e 9091 0000 		lds r25,bankStates+17+1
 4032 2092 A091 0000 		lds r26,bankStates+17+2
 4033 2096 B091 0000 		lds r27,bankStates+17+3
 4034 209a 8093 0000 		sts bankStates+25,r24
 4035 209e 9093 0000 		sts bankStates+25+1,r25
 4036 20a2 A093 0000 		sts bankStates+25+2,r26
 4037 20a6 B093 0000 		sts bankStates+25+3,r27
3961:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 4038               		.loc 1 3961 0
 4039 20aa 8091 0000 		lds r24,bankStates+13
 4040 20ae 9091 0000 		lds r25,bankStates+13+1
 4041 20b2 A091 0000 		lds r26,bankStates+13+2
 4042 20b6 B091 0000 		lds r27,bankStates+13+3
 4043 20ba 8093 0000 		sts bankStates+21,r24
 4044 20be 9093 0000 		sts bankStates+21+1,r25
 4045 20c2 A093 0000 		sts bankStates+21+2,r26
 4046 20c6 B093 0000 		sts bankStates+21+3,r27
3962:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 4047               		.loc 1 3962 0
 4048 20ca 1092 0000 		sts bankStates+29,__zero_reg__
3963:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 4049               		.loc 1 3963 0
 4050 20ce 1092 0000 		sts bankStates+30,__zero_reg__
3964:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 4051               		.loc 1 3964 0
 4052 20d2 1092 0000 		sts bankStates+31,__zero_reg__
3965:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 4053               		.loc 1 3965 0
 4054 20d6 2FBF      		out __SREG__,r18
 4055               	.LVL139:
 4056               	.LBE211:
 4057               	.LBE210:
 4058               	.LBB213:
 4059               	.LBB214:
3447:WTPA.c        **** 		x=EepromRead(7);		// Get the channel from EEPROM.
 4060               		.loc 1 3447 0
 4061 20d8 87E0      		ldi r24,lo8(7)
 4062 20da 0E94 0000 		call EepromRead
 4063               	.LVL140:
3454:WTPA.c        **** 	if(x<90)					// Legit number?
 4064               		.loc 1 3454 0
 4065 20de 8A35      		cpi r24,lo8(90)
 4066 20e0 00F4      		brsh .+2
 4067 20e2 00C0      		rjmp .L265
 4068 20e4 24E0      		ldi r18,lo8(4)
 4069 20e6 30E0      		ldi r19,0
 4070 20e8 E0E0      		ldi r30,0
 4071 20ea F0E0      		ldi r31,0
 4072               	.LVL141:
 4073               	.L259:
 4074               	.LBE214:
 4075               	.LBE213:
 4076               	.LBB216:
 4077               	.LBB217:
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 4078               		.loc 1 3411 0
 4079 20ec EE0F      		lsl r30
 4080 20ee FF1F      		rol r31
 4081 20f0 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 4082 20f2 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 4083 20f4 8081      		ld r24,Z
 4084 20f6 9181      		ldd r25,Z+1
 4085 20f8 00C0      		rjmp 2f
 4086               		1:
 4087 20fa 9695      		lsr r25
 4088 20fc 8795      		ror r24
 4089               		2:
 4090 20fe 2A95      		dec r18
 4091 2100 02F4      		brpl 1b
 4092               	.LBE217:
 4093               	.LBE216:
4670:WTPA.c        **** 		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful numb
 4094               		.loc 1 4670 0
 4095 2102 9093 0000 		sts theMidiRecordRate+1,r25
 4096 2106 8093 0000 		sts theMidiRecordRate,r24
 4097               	.LVL142:
4653:WTPA.c        **** 		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
 4098               		.loc 1 4653 0
 4099 210a 1092 0000 		sts bankStates+36,__zero_reg__
4654:WTPA.c        **** 		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
 4100               		.loc 1 4654 0
 4101 210e 1092 0000 		sts bankStates+46,__zero_reg__
4655:WTPA.c        **** 		bankStates[i].loopOnce=false;
 4102               		.loc 1 4655 0
 4103 2112 1092 0000 		sts bankStates+37,__zero_reg__
4656:WTPA.c        **** 		bankStates[i].bitReduction=0;				// No crusties yet.
 4104               		.loc 1 4656 0
 4105 2116 1092 0000 		sts bankStates+45,__zero_reg__
4657:WTPA.c        **** 		bankStates[i].jitterValue=0;				// No hissies yet.
 4106               		.loc 1 4657 0
 4107 211a 1092 0000 		sts bankStates+44,__zero_reg__
4658:WTPA.c        **** 		bankStates[i].granularSlices=0;				// No remix yet.
 4108               		.loc 1 4658 0
 4109 211e 1092 0000 		sts bankStates+43,__zero_reg__
4659:WTPA.c        **** 		bankStates[i].halfSpeed=false;
 4110               		.loc 1 4659 0
 4111 2122 1092 0000 		sts bankStates+38,__zero_reg__
4660:WTPA.c        **** 		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
 4112               		.loc 1 4660 0
 4113 2126 81E0      		ldi r24,lo8(1)
 4114 2128 8093 0000 		sts bankStates+40,r24
4661:WTPA.c        **** 		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
 4115               		.loc 1 4661 0
 4116 212c 1092 0000 		sts bankStates+39,__zero_reg__
4662:WTPA.c        **** 		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the begi
 4117               		.loc 1 4662 0
 4118 2130 8091 0000 		lds r24,bankStates+53
 4119 2134 9091 0000 		lds r25,bankStates+53+1
 4120 2138 A091 0000 		lds r26,bankStates+53+2
 4121 213c B091 0000 		lds r27,bankStates+53+3
 4122 2140 8093 0000 		sts bankStates+68,r24
 4123 2144 9093 0000 		sts bankStates+68+1,r25
 4124 2148 A093 0000 		sts bankStates+68+2,r26
 4125 214c B093 0000 		sts bankStates+68+3,r27
4663:WTPA.c        **** 		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 sam
 4126               		.loc 1 4663 0
 4127 2150 8091 0000 		lds r24,bankStates+53
 4128 2154 9091 0000 		lds r25,bankStates+53+1
 4129 2158 A091 0000 		lds r26,bankStates+53+2
 4130 215c B091 0000 		lds r27,bankStates+53+3
 4131 2160 8093 0000 		sts bankStates+49,r24
 4132 2164 9093 0000 		sts bankStates+49+1,r25
 4133 2168 A093 0000 		sts bankStates+49+2,r26
 4134 216c B093 0000 		sts bankStates+49+3,r27
4664:WTPA.c        **** 		bankStates[i].realtimeOn=false;						// We'll default to playback.
 4135               		.loc 1 4664 0
 4136 2170 1092 0000 		sts bankStates+42,__zero_reg__
4665:WTPA.c        **** 		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
 4137               		.loc 1 4665 0
 4138 2174 1092 0000 		sts bankStates+41,__zero_reg__
 4139               	.LVL143:
 4140               	.LBB219:
 4141               	.LBB212:
3957:WTPA.c        **** 	sreg=SREG;
 4142               		.loc 1 3957 0
 4143 2178 2FB7      		in r18,__SREG__
 4144               	.LVL144:
3958:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 4145               		.loc 1 3958 0
 4146               	/* #APP */
 4147               	 ;  3958 "WTPA.c" 1
 4148 217a F894      		cli
 4149               	 ;  0 "" 2
3960:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 4150               		.loc 1 3960 0
 4151               	/* #NOAPP */
 4152 217c 8091 0000 		lds r24,bankStates+53
 4153 2180 9091 0000 		lds r25,bankStates+53+1
 4154 2184 A091 0000 		lds r26,bankStates+53+2
 4155 2188 B091 0000 		lds r27,bankStates+53+3
 4156 218c 8093 0000 		sts bankStates+61,r24
 4157 2190 9093 0000 		sts bankStates+61+1,r25
 4158 2194 A093 0000 		sts bankStates+61+2,r26
 4159 2198 B093 0000 		sts bankStates+61+3,r27
3961:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 4160               		.loc 1 3961 0
 4161 219c 8091 0000 		lds r24,bankStates+49
 4162 21a0 9091 0000 		lds r25,bankStates+49+1
 4163 21a4 A091 0000 		lds r26,bankStates+49+2
 4164 21a8 B091 0000 		lds r27,bankStates+49+3
 4165 21ac 8093 0000 		sts bankStates+57,r24
 4166 21b0 9093 0000 		sts bankStates+57+1,r25
 4167 21b4 A093 0000 		sts bankStates+57+2,r26
 4168 21b8 B093 0000 		sts bankStates+57+3,r27
3962:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 4169               		.loc 1 3962 0
 4170 21bc 1092 0000 		sts bankStates+65,__zero_reg__
3963:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 4171               		.loc 1 3963 0
 4172 21c0 1092 0000 		sts bankStates+66,__zero_reg__
3964:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 4173               		.loc 1 3964 0
 4174 21c4 1092 0000 		sts bankStates+67,__zero_reg__
3965:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 4175               		.loc 1 3965 0
 4176 21c8 2FBF      		out __SREG__,r18
 4177               	.LVL145:
 4178               	.LBE212:
 4179               	.LBE219:
 4180               	.LBB220:
 4181               	.LBB215:
3451:WTPA.c        **** 		x=EepromRead(11);		// Get the channel from EEPROM.
 4182               		.loc 1 3451 0
 4183 21ca 8BE0      		ldi r24,lo8(11)
 4184 21cc 0E94 0000 		call EepromRead
 4185               	.LVL146:
3454:WTPA.c        **** 	if(x<90)					// Legit number?
 4186               		.loc 1 3454 0
 4187 21d0 8A35      		cpi r24,lo8(90)
 4188 21d2 00F0      		brlo .L266
 4189 21d4 24E0      		ldi r18,lo8(4)
 4190 21d6 30E0      		ldi r19,0
 4191 21d8 E0E0      		ldi r30,0
 4192 21da F0E0      		ldi r31,0
 4193               	.LVL147:
 4194               	.L260:
 4195               	.LBE215:
 4196               	.LBE220:
 4197               	.LBB221:
 4198               	.LBB218:
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 4199               		.loc 1 3411 0
 4200 21dc EE0F      		lsl r30
 4201 21de FF1F      		rol r31
 4202 21e0 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 4203 21e2 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 4204 21e4 8081      		ld r24,Z
 4205 21e6 9181      		ldd r25,Z+1
 4206 21e8 00C0      		rjmp 2f
 4207               		1:
 4208 21ea 9695      		lsr r25
 4209 21ec 8795      		ror r24
 4210               		2:
 4211 21ee 2A95      		dec r18
 4212 21f0 02F4      		brpl 1b
 4213               	.LBE218:
 4214               	.LBE221:
4670:WTPA.c        **** 		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful numb
 4215               		.loc 1 4670 0
 4216 21f2 9093 0000 		sts theMidiRecordRate+2+1,r25
 4217 21f6 8093 0000 		sts theMidiRecordRate+2,r24
 4218               	.LVL148:
4673:WTPA.c        **** 	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 4219               		.loc 1 4673 0
 4220 21fa 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 4221 21fc 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 4222 21fe 9093 0000 		sts UpdateOutput+1,r25
 4223 2202 8093 0000 		sts UpdateOutput,r24
4675:WTPA.c        **** 	currentBank=BANK_0;			// Point at the first bank until we change banks.
 4224               		.loc 1 4675 0
 4225 2206 1092 0000 		sts currentBank,__zero_reg__
4676:WTPA.c        **** 	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
 4226               		.loc 1 4676 0
 4227 220a 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 4228 220e 1092 0000 		sts sdCurrentSlot,__zero_reg__
 4229               	.LBB222:
 4230               	.LBB223:
1585:WTPA.c        **** 	ledOnOffMask=0;
 4231               		.loc 1 1585 0
 4232 2212 1092 0000 		sts ledOnOffMask,__zero_reg__
 4233               	.LVL149:
 4234               	.LBB224:
 4235               	.LBB225:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 4236               		.loc 1 1572 0
 4237 2216 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 4238               		.loc 1 1573 0
 4239 221a 68E9      		ldi r22,lo8(-104)
 4240 221c 70E0      		ldi r23,0
 4241 221e 82E0      		ldi r24,lo8(2)
 4242 2220 0E94 0000 		call SetTimer
 4243               	.LVL150:
 4244               	.LBE225:
 4245               	.LBE224:
 4246               	.LBE223:
 4247               	.LBE222:
 4248               	.LBB226:
 4249               	.LBB227:
1504:WTPA.c        **** 	State=newState;
 4250               		.loc 1 1504 0
 4251 2224 80E0      		ldi r24,lo8(gs(DoSampler))
 4252 2226 90E0      		ldi r25,hi8(gs(DoSampler))
 4253 2228 9093 0000 		sts State+1,r25
 4254 222c 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 4255               		.loc 1 1505 0
 4256 2230 1092 0000 		sts subState,__zero_reg__
 4257 2234 0895      		ret
 4258               	.LVL151:
 4259               	.L265:
 4260 2236 6CE0      		ldi r22,lo8(12)
 4261 2238 0E94 0000 		call __udivmodqi4
 4262               	.LVL152:
 4263 223c E92F      		mov r30,r25
 4264 223e F0E0      		ldi r31,0
 4265 2240 282F      		mov r18,r24
 4266 2242 00C0      		rjmp .L259
 4267               	.LVL153:
 4268               	.L266:
 4269 2244 6CE0      		ldi r22,lo8(12)
 4270 2246 0E94 0000 		call __udivmodqi4
 4271               	.LVL154:
 4272 224a E92F      		mov r30,r25
 4273 224c F0E0      		ldi r31,0
 4274 224e 282F      		mov r18,r24
 4275 2250 00C0      		rjmp .L260
 4276               	.LBE227:
 4277               	.LBE226:
 4278               		.cfi_endproc
 4279               	.LFE71:
 4282               	PlaySampleFromSd:
 4283               	.LFB52:
3237:WTPA.c        **** {
 4284               		.loc 1 3237 0
 4285               		.cfi_startproc
 4286               	.LVL155:
 4287 2252 CF92      		push r12
 4288               	.LCFI36:
 4289               		.cfi_def_cfa_offset 3
 4290               		.cfi_offset 12, -2
 4291 2254 DF92      		push r13
 4292               	.LCFI37:
 4293               		.cfi_def_cfa_offset 4
 4294               		.cfi_offset 13, -3
 4295 2256 EF92      		push r14
 4296               	.LCFI38:
 4297               		.cfi_def_cfa_offset 5
 4298               		.cfi_offset 14, -4
 4299 2258 FF92      		push r15
 4300               	.LCFI39:
 4301               		.cfi_def_cfa_offset 6
 4302               		.cfi_offset 15, -5
 4303 225a CF93      		push r28
 4304               	.LCFI40:
 4305               		.cfi_def_cfa_offset 7
 4306               		.cfi_offset 28, -6
 4307 225c DF93      		push r29
 4308               	.LCFI41:
 4309               		.cfi_def_cfa_offset 8
 4310               		.cfi_offset 29, -7
 4311               	/* prologue: function */
 4312               	/* frame size = 0 */
 4313               	/* stack size = 6 */
 4314               	.L__stack_usage = 6
3241:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 4315               		.loc 1 3241 0
 4316 225e 2091 0000 		lds r18,cardState
 4317 2262 2E30      		cpi r18,lo8(14)
 4318 2264 01F0      		breq .L282
3252:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, 
 4319               		.loc 1 3252 0
 4320 2266 3091 0000 		lds r19,sdIsrState
 4321 226a 3330      		cpi r19,lo8(3)
 4322 226c 01F0      		breq .L283
 4323               	/* epilogue start */
3285:WTPA.c        **** }
 4324               		.loc 1 3285 0
 4325 226e DF91      		pop r29
 4326 2270 CF91      		pop r28
 4327 2272 FF90      		pop r15
 4328 2274 EF90      		pop r14
 4329 2276 DF90      		pop r13
 4330 2278 CF90      		pop r12
 4331 227a 0895      		ret
 4332               	.L283:
3255:WTPA.c        **** 		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIF
 4333               		.loc 1 3255 0
 4334 227c 2B30      		cpi r18,lo8(11)
 4335 227e 01F0      		breq .L282
3266:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4336               		.loc 1 3266 0
 4337 2280 2D30      		cpi r18,lo8(13)
 4338 2282 01F0      		breq .L275
3266:WTPA.c        **** 		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning 
 4339               		.loc 1 3266 0 is_stmt 0 discriminator 1
 4340 2284 2091 0000 		lds r18,sdAbortRead
 4341 2288 2130      		cpi r18,lo8(1)
 4342 228a 01F0      		breq .L275
3274:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4343               		.loc 1 3274 0 is_stmt 1
 4344 228c 8093 0000 		sts sdQueuedSlot,r24
 4345 2290 9093 0000 		sts sdQueuedSlot+1,r25
3275:WTPA.c        **** 			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
 4346               		.loc 1 3275 0
 4347 2294 81E0      		ldi r24,lo8(1)
 4348               	.LVL156:
 4349 2296 8093 0000 		sts sdPlaybackQueued,r24
3276:WTPA.c        **** 			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie
 4350               		.loc 1 3276 0
 4351 229a 8093 0000 		sts sdAbortRead,r24
3278:WTPA.c        **** 			sreg=SREG;	 		// Pause ISRs
 4352               		.loc 1 3278 0
 4353 229e 9FB7      		in r25,__SREG__
 4354               	.LVL157:
3279:WTPA.c        **** 			cli();
 4355               		.loc 1 3279 0
 4356               	/* #APP */
 4357               	 ;  3279 "WTPA.c" 1
 4358 22a0 F894      		cli
 4359               	 ;  0 "" 2
3280:WTPA.c        **** 			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
 4360               		.loc 1 3280 0
 4361               	/* #NOAPP */
 4362 22a2 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 4363 22a6 1092 0000 		sts sdBytesInFifo,__zero_reg__
3281:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
 4364               		.loc 1 3281 0
 4365 22aa 8091 7000 		lds r24,112
 4366 22ae 8B7F      		andi r24,lo8(-5)
 4367 22b0 8093 7000 		sts 112,r24
3282:WTPA.c        **** 			SREG=sreg;
 4368               		.loc 1 3282 0
 4369 22b4 9FBF      		out __SREG__,r25
 4370               	/* epilogue start */
3285:WTPA.c        **** }
 4371               		.loc 1 3285 0
 4372 22b6 DF91      		pop r29
 4373 22b8 CF91      		pop r28
 4374 22ba FF90      		pop r15
 4375 22bc EF90      		pop r14
 4376 22be DF90      		pop r13
 4377 22c0 CF90      		pop r12
 4378 22c2 0895      		ret
 4379               	.LVL158:
 4380               	.L275:
3269:WTPA.c        **** 			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
 4381               		.loc 1 3269 0
 4382 22c4 8093 0000 		sts sdQueuedSlot,r24
 4383 22c8 9093 0000 		sts sdQueuedSlot+1,r25
 4384               	/* epilogue start */
3285:WTPA.c        **** }
 4385               		.loc 1 3285 0
 4386 22cc DF91      		pop r29
 4387 22ce CF91      		pop r28
 4388 22d0 FF90      		pop r15
 4389 22d2 EF90      		pop r14
 4390 22d4 DF90      		pop r13
 4391 22d6 CF90      		pop r12
 4392 22d8 0895      		ret
 4393               	.L282:
3257:WTPA.c        **** 			sreg=SREG;	 // Pause ISRs
 4394               		.loc 1 3257 0
 4395 22da CFB7      		in r28,__SREG__
 4396               	.LVL159:
3258:WTPA.c        **** 			cli();
 4397               		.loc 1 3258 0
 4398               	/* #APP */
 4399               	 ;  3258 "WTPA.c" 1
 4400 22dc F894      		cli
 4401               	 ;  0 "" 2
 4402               	/* #NOAPP */
 4403               	.LBB236:
 4404               	.LBB237:
2361:WTPA.c        **** 	sreg=SREG;
 4405               		.loc 1 2361 0
 4406 22de DFB7      		in r29,__SREG__
 4407               	.LVL160:
2362:WTPA.c        **** 	cli();		// Pause ISR
 4408               		.loc 1 2362 0
 4409               	/* #APP */
 4410               	 ;  2362 "WTPA.c" 1
 4411 22e0 F894      		cli
 4412               	 ;  0 "" 2
2364:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
 4413               		.loc 1 2364 0
 4414               	/* #NOAPP */
 4415 22e2 D82E      		mov r13,r24
 4416 22e4 DD0C      		lsl r13
 4417 22e6 DD0C      		lsl r13
 4418 22e8 C12C      		mov r12,__zero_reg__
 4419 22ea 8FEF      		ldi r24,-1
 4420 22ec C81A      		sub r12,r24
 4421 22ee D80A      		sbc r13,r24
 4422               	.LVL161:
 4423 22f0 E12C      		mov r14,__zero_reg__
 4424 22f2 F12C      		mov r15,__zero_reg__
 4425 22f4 C701      		movw r24,r14
 4426 22f6 B601      		movw r22,r12
 4427 22f8 0E94 0000 		call SdBeginSingleBlockRead
 4428               	.LVL162:
 4429 22fc 8130      		cpi r24,lo8(1)
 4430 22fe 01F0      		breq .L284
2380:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 4431               		.loc 1 2380 0
 4432 2300 DFBF      		out __SREG__,r29
 4433               	.L274:
 4434               	.LBE237:
 4435               	.LBE236:
3261:WTPA.c        **** 			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero byt
 4436               		.loc 1 3261 0
 4437 2302 81E0      		ldi r24,lo8(1)
 4438 2304 90E0      		ldi r25,0
 4439 2306 A0E0      		ldi r26,0
 4440 2308 B0E0      		ldi r27,0
 4441 230a 8093 0000 		sts sdRamSampleRemaining,r24
 4442 230e 9093 0000 		sts sdRamSampleRemaining+1,r25
 4443 2312 A093 0000 		sts sdRamSampleRemaining+2,r26
 4444 2316 B093 0000 		sts sdRamSampleRemaining+3,r27
 4445               	.LBB239:
 4446               	.LBB240:
3136:WTPA.c        **** 	sreg=SREG;
 4447               		.loc 1 3136 0
 4448 231a 9FB7      		in r25,__SREG__
 4449               	.LVL163:
3137:WTPA.c        **** 	cli();		// Pause ISRs
 4450               		.loc 1 3137 0
 4451               	/* #APP */
 4452               	 ;  3137 "WTPA.c" 1
 4453 231c F894      		cli
 4454               	 ;  0 "" 2
3139:WTPA.c        **** 	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit t
 4455               		.loc 1 3139 0
 4456               	/* #NOAPP */
 4457 231e 83E0      		ldi r24,lo8(3)
 4458 2320 8093 0000 		sts sdIsrState,r24
3141:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 4459               		.loc 1 3141 0
 4460 2324 1092 B200 		sts 178,__zero_reg__
3142:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 4461               		.loc 1 3142 0
 4462 2328 81E7      		ldi r24,lo8(113)
 4463 232a 8093 B300 		sts 179,r24
3143:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 4464               		.loc 1 3143 0
 4465 232e 8FEF      		ldi r24,lo8(-1)
 4466 2330 87BB      		out 0x17,r24
3144:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 4467               		.loc 1 3144 0
 4468 2332 8091 7000 		lds r24,112
 4469 2336 8460      		ori r24,lo8(4)
 4470 2338 8093 7000 		sts 112,r24
3145:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 4471               		.loc 1 3145 0
 4472 233c 82E0      		ldi r24,lo8(2)
 4473 233e 8093 B100 		sts 177,r24
3147:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 4474               		.loc 1 3147 0
 4475 2342 9FBF      		out __SREG__,r25
 4476               	.LBE240:
 4477               	.LBE239:
3264:WTPA.c        **** 			SREG=sreg;	// resume isr
 4478               		.loc 1 3264 0
 4479 2344 CFBF      		out __SREG__,r28
 4480               	/* epilogue start */
3285:WTPA.c        **** }
 4481               		.loc 1 3285 0
 4482 2346 DF91      		pop r29
 4483               	.LVL164:
 4484 2348 CF91      		pop r28
 4485               	.LVL165:
 4486 234a FF90      		pop r15
 4487 234c EF90      		pop r14
 4488 234e DF90      		pop r13
 4489 2350 CF90      		pop r12
 4490 2352 0895      		ret
 4491               	.LVL166:
 4492               	.L284:
 4493               	.LBB241:
 4494               	.LBB238:
2366:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
 4495               		.loc 1 2366 0
 4496 2354 C092 0000 		sts sdSampleStartBlock,r12
 4497 2358 D092 0000 		sts sdSampleStartBlock+1,r13
 4498 235c E092 0000 		sts sdSampleStartBlock+2,r14
 4499 2360 F092 0000 		sts sdSampleStartBlock+3,r15
2367:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
 4500               		.loc 1 2367 0
 4501 2364 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 4502 2368 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2369:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
 4503               		.loc 1 2369 0
 4504 236c 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 4505 2370 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2370:WTPA.c        **** 		sdFifoWritePointer=0;
 4506               		.loc 1 2370 0
 4507 2374 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 4508 2378 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2371:WTPA.c        **** 		sdBytesInFifo=0;
 4509               		.loc 1 2371 0
 4510 237c 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 4511 2380 1092 0000 		sts sdBytesInFifo,__zero_reg__
2373:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 4512               		.loc 1 2373 0
 4513 2384 6AE7      		ldi r22,lo8(122)
 4514 2386 70E0      		ldi r23,0
 4515 2388 83E0      		ldi r24,lo8(3)
 4516 238a 0E94 0000 		call SetTimer
 4517               	.LVL167:
2374:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
 4518               		.loc 1 2374 0
 4519 238e 89E0      		ldi r24,lo8(9)
 4520 2390 8093 0000 		sts cardState,r24
2376:WTPA.c        **** 		SREG=sreg;	// Resume ISR
 4521               		.loc 1 2376 0
 4522 2394 DFBF      		out __SREG__,r29
 4523 2396 00C0      		rjmp .L274
 4524               	.LBE238:
 4525               	.LBE241:
 4526               		.cfi_endproc
 4527               	.LFE52:
 4530               	DoFruitcakeIntro:
 4531               	.LFB75:
4851:WTPA.c        **** 			{
4852:WTPA.c        **** 				SetState(SetMidiChannels);
4853:WTPA.c        **** 			}
4854:WTPA.c        **** 			else
4855:WTPA.c        **** 			{
4856:WTPA.c        **** 				SetState(InitSampler);
4857:WTPA.c        **** 			}
4858:WTPA.c        **** 		}
4859:WTPA.c        **** 	}
4860:WTPA.c        **** }
4861:WTPA.c        **** 
4862:WTPA.c        **** static void DoFruitcakeIntro(void)
4863:WTPA.c        **** // Oh god why.
4864:WTPA.c        **** {
 4532               		.loc 1 4864 0
 4533               		.cfi_startproc
 4534 2398 CF93      		push r28
 4535               	.LCFI42:
 4536               		.cfi_def_cfa_offset 3
 4537               		.cfi_offset 28, -2
 4538               	/* prologue: function */
 4539               	/* frame size = 0 */
 4540               	/* stack size = 1 */
 4541               	.L__stack_usage = 1
4865:WTPA.c        **** 	static unsigned char
4866:WTPA.c        **** 		i;
4867:WTPA.c        **** 
4868:WTPA.c        **** 	if(subState==SS_0)
 4542               		.loc 1 4868 0
 4543 239a C091 0000 		lds r28,subState
 4544 239e CC23      		tst r28
 4545 23a0 01F0      		breq .L311
4869:WTPA.c        **** 	{
4870:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4871:WTPA.c        **** 
4872:WTPA.c        **** 		KillLeds();
4873:WTPA.c        **** 		i=0;
4874:WTPA.c        **** 		ledOnOffMask=0;
4875:WTPA.c        **** 		subState=SS_1;
4876:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
4877:WTPA.c        **** 	}
4878:WTPA.c        **** 	else if(subState==SS_1)
 4546               		.loc 1 4878 0
 4547 23a2 C130      		cpi r28,lo8(1)
 4548 23a4 01F4      		brne .+2
 4549 23a6 00C0      		rjmp .L312
4879:WTPA.c        **** 	{
4880:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4881:WTPA.c        **** 		{
4882:WTPA.c        **** 			subState=SS_2;
4883:WTPA.c        **** 		}
4884:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4885:WTPA.c        **** 	}
4886:WTPA.c        **** 
4887:WTPA.c        **** 	else if(subState==SS_2)
 4550               		.loc 1 4887 0
 4551 23a8 C230      		cpi r28,lo8(2)
 4552 23aa 01F0      		breq .L313
4888:WTPA.c        **** 	{
4889:WTPA.c        **** 		if(i<NUM_LEDS)
4890:WTPA.c        **** 		{
4891:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4892:WTPA.c        **** 			{
4893:WTPA.c        **** 				ledOnOffMask|=(1<<i);
4894:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
4895:WTPA.c        **** 				i++;
4896:WTPA.c        **** 			}
4897:WTPA.c        **** 		}
4898:WTPA.c        **** 		else
4899:WTPA.c        **** 		{
4900:WTPA.c        **** 			if(CheckTimer(TIMER_1))
4901:WTPA.c        **** 			{
4902:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
4903:WTPA.c        **** 				ledPwm=255;
4904:WTPA.c        **** 				// Grudgingly enable pwm hackery.
4905:WTPA.c        **** 
4906:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
4907:WTPA.c        **** 
4908:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
4909:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
4910:WTPA.c        **** 				TCNT2=0;			// Init counter reg
4911:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
4912:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
4913:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
4914:WTPA.c        **** 
4915:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
4916:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
4917:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
4918:WTPA.c        **** 
4919:WTPA.c        **** 				subState=SS_3;
4920:WTPA.c        **** 			}
4921:WTPA.c        **** 		}
4922:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4923:WTPA.c        **** 	}
4924:WTPA.c        **** 	else if(subState==SS_3)
 4553               		.loc 1 4924 0
 4554 23ac C330      		cpi r28,lo8(3)
 4555 23ae 01F4      		brne .+2
 4556 23b0 00C0      		rjmp .L314
4925:WTPA.c        **** 	{
4926:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4927:WTPA.c        **** 		{
4928:WTPA.c        **** 			if(ledPwm>1)
4929:WTPA.c        **** 			{
4930:WTPA.c        **** 				ledPwm-=2;
4931:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
4932:WTPA.c        **** 			}
4933:WTPA.c        **** 			else
4934:WTPA.c        **** 			{
4935:WTPA.c        **** 				// Gleefully disable PWM.
4936:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
4937:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
4938:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
4939:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
4940:WTPA.c        **** 
4941:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
4942:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
4943:WTPA.c        **** 
4944:WTPA.c        **** 				KillLeds();				// App knows leds are off.
4945:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
4946:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
4947:WTPA.c        **** 				subState=SS_4;
4948:WTPA.c        **** 			}
4949:WTPA.c        **** 		}
4950:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4951:WTPA.c        **** 	}
4952:WTPA.c        **** 	else if(subState==SS_4)
 4557               		.loc 1 4952 0
 4558 23b2 C430      		cpi r28,lo8(4)
 4559 23b4 01F4      		brne .+2
 4560 23b6 00C0      		rjmp .L315
 4561               	/* epilogue start */
4953:WTPA.c        **** 	{
4954:WTPA.c        **** 		if(CheckTimer(TIMER_1))
4955:WTPA.c        **** 		{
4956:WTPA.c        **** 			KillLeds();
4957:WTPA.c        **** 			SetState(DoStartupSelect);		// Get crackin.
4958:WTPA.c        **** 		}
4959:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
4960:WTPA.c        **** 	}
4961:WTPA.c        **** }
 4562               		.loc 1 4961 0
 4563 23b8 CF91      		pop r28
 4564 23ba 0895      		ret
 4565               	.L311:
4870:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 4566               		.loc 1 4870 0
 4567 23bc 1092 0000 		sts cardState,__zero_reg__
 4568               	.LBB256:
 4569               	.LBB257:
1585:WTPA.c        **** 	ledOnOffMask=0;
 4570               		.loc 1 1585 0
 4571 23c0 1092 0000 		sts ledOnOffMask,__zero_reg__
 4572               	.LVL168:
 4573               	.LBB258:
 4574               	.LBB259:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 4575               		.loc 1 1572 0
 4576 23c4 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 4577               		.loc 1 1573 0
 4578 23c8 68E9      		ldi r22,lo8(-104)
 4579 23ca 70E0      		ldi r23,0
 4580 23cc 82E0      		ldi r24,lo8(2)
 4581 23ce 0E94 0000 		call SetTimer
 4582               	.LVL169:
 4583               	.LBE259:
 4584               	.LBE258:
 4585               	.LBE257:
 4586               	.LBE256:
4873:WTPA.c        **** 		i=0;
 4587               		.loc 1 4873 0
 4588 23d2 1092 0000 		sts i.2279,__zero_reg__
4874:WTPA.c        **** 		ledOnOffMask=0;
 4589               		.loc 1 4874 0
 4590 23d6 1092 0000 		sts ledOnOffMask,__zero_reg__
4875:WTPA.c        **** 		subState=SS_1;
 4591               		.loc 1 4875 0
 4592 23da 81E0      		ldi r24,lo8(1)
 4593 23dc 8093 0000 		sts subState,r24
4876:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 4594               		.loc 1 4876 0
 4595 23e0 61E3      		ldi r22,lo8(49)
 4596 23e2 71E0      		ldi r23,lo8(1)
 4597 23e4 80E0      		ldi r24,0
 4598               	/* epilogue start */
 4599               		.loc 1 4961 0
 4600 23e6 CF91      		pop r28
4876:WTPA.c        **** 		SetTimer(TIMER_1,(SECOND/4));
 4601               		.loc 1 4876 0
 4602 23e8 0C94 0000 		jmp SetTimer
 4603               	.LVL170:
 4604               	.L313:
4889:WTPA.c        **** 		if(i<NUM_LEDS)
 4605               		.loc 1 4889 0
 4606 23ec 8091 0000 		lds r24,i.2279
 4607 23f0 8830      		cpi r24,lo8(8)
 4608 23f2 00F4      		brsh .L291
4891:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 4609               		.loc 1 4891 0
 4610 23f4 80E0      		ldi r24,0
 4611 23f6 0E94 0000 		call CheckTimer
 4612               	.LVL171:
 4613 23fa 8823      		tst r24
 4614 23fc 01F0      		breq .L298
4893:WTPA.c        **** 				ledOnOffMask|=(1<<i);
 4615               		.loc 1 4893 0
 4616 23fe 81E0      		ldi r24,lo8(1)
 4617 2400 90E0      		ldi r25,0
 4618 2402 0090 0000 		lds r0,i.2279
 4619 2406 00C0      		rjmp 2f
 4620               		1:
 4621 2408 880F      		lsl r24
 4622 240a 991F      		rol r25
 4623               		2:
 4624 240c 0A94      		dec r0
 4625 240e 02F4      		brpl 1b
 4626 2410 9091 0000 		lds r25,ledOnOffMask
 4627 2414 982B      		or r25,r24
 4628 2416 9093 0000 		sts ledOnOffMask,r25
4894:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/20));
 4629               		.loc 1 4894 0
 4630 241a 6DE3      		ldi r22,lo8(61)
 4631 241c 70E0      		ldi r23,0
 4632 241e 80E0      		ldi r24,0
 4633 2420 0E94 0000 		call SetTimer
 4634               	.LVL172:
4895:WTPA.c        **** 				i++;
 4635               		.loc 1 4895 0
 4636 2424 8091 0000 		lds r24,i.2279
 4637 2428 8F5F      		subi r24,lo8(-(1))
 4638 242a 8093 0000 		sts i.2279,r24
 4639               	.L298:
4959:WTPA.c        **** 		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
 4640               		.loc 1 4959 0
 4641 242e 1092 0000 		sts cardState,__zero_reg__
 4642               	/* epilogue start */
 4643               		.loc 1 4961 0
 4644 2432 CF91      		pop r28
 4645 2434 0895      		ret
 4646               	.L312:
4880:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4647               		.loc 1 4880 0
 4648 2436 80E0      		ldi r24,0
 4649 2438 0E94 0000 		call CheckTimer
 4650               	.LVL173:
 4651 243c 8823      		tst r24
 4652 243e 01F0      		breq .L298
4882:WTPA.c        **** 			subState=SS_2;
 4653               		.loc 1 4882 0
 4654 2440 82E0      		ldi r24,lo8(2)
 4655 2442 8093 0000 		sts subState,r24
 4656 2446 00C0      		rjmp .L298
 4657               	.L291:
4900:WTPA.c        **** 			if(CheckTimer(TIMER_1))
 4658               		.loc 1 4900 0
 4659 2448 80E0      		ldi r24,0
 4660 244a 0E94 0000 		call CheckTimer
 4661               	.LVL174:
 4662 244e 8823      		tst r24
 4663 2450 01F0      		breq .L298
4902:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/8));
 4664               		.loc 1 4902 0
 4665 2452 68E9      		ldi r22,lo8(-104)
 4666 2454 70E0      		ldi r23,0
 4667 2456 80E0      		ldi r24,0
 4668 2458 0E94 0000 		call SetTimer
 4669               	.LVL175:
4903:WTPA.c        **** 				ledPwm=255;
 4670               		.loc 1 4903 0
 4671 245c 8FEF      		ldi r24,lo8(-1)
 4672 245e 8093 0000 		sts ledPwm,r24
4906:WTPA.c        **** 				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 4673               		.loc 1 4906 0
 4674 2462 9091 6400 		lds r25,100
 4675 2466 9F7B      		andi r25,lo8(-65)
 4676 2468 9093 6400 		sts 100,r25
4908:WTPA.c        **** 				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 4677               		.loc 1 4908 0
 4678 246c C093 B000 		sts 176,r28
4909:WTPA.c        **** 				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
 4679               		.loc 1 4909 0
 4680 2470 91E0      		ldi r25,lo8(1)
 4681 2472 9093 B100 		sts 177,r25
4910:WTPA.c        **** 				TCNT2=0;			// Init counter reg
 4682               		.loc 1 4910 0
 4683 2476 1092 B200 		sts 178,__zero_reg__
4911:WTPA.c        **** 				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
 4684               		.loc 1 4911 0
 4685 247a 90E8      		ldi r25,lo8(-128)
 4686 247c 9093 B300 		sts 179,r25
4912:WTPA.c        **** 				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 4687               		.loc 1 4912 0
 4688 2480 87BB      		out 0x17,r24
4913:WTPA.c        **** 				TIMSK2=0x02;		// Enable the compare match interrupt.
 4689               		.loc 1 4913 0
 4690 2482 C093 7000 		sts 112,r28
4915:WTPA.c        **** 				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
 4691               		.loc 1 4915 0
 4692 2486 92B1      		in r25,0x2
 4693 2488 9660      		ori r25,lo8(6)
 4694 248a 92B9      		out 0x2,r25
4916:WTPA.c        **** 				LATCH_DDR=0xFF;					// Make sure the bus is an output.
 4695               		.loc 1 4916 0
 4696 248c 84B9      		out 0x4,r24
4917:WTPA.c        **** 				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
 4697               		.loc 1 4917 0
 4698 248e 5F9A      		sbi 0xb,7
4919:WTPA.c        **** 				subState=SS_3;
 4699               		.loc 1 4919 0
 4700 2490 83E0      		ldi r24,lo8(3)
 4701 2492 8093 0000 		sts subState,r24
 4702 2496 00C0      		rjmp .L298
 4703               	.L315:
4954:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4704               		.loc 1 4954 0
 4705 2498 80E0      		ldi r24,0
 4706 249a 0E94 0000 		call CheckTimer
 4707               	.LVL176:
 4708 249e 8823      		tst r24
 4709 24a0 01F0      		breq .L298
 4710               	.LBB260:
 4711               	.LBB261:
1585:WTPA.c        **** 	ledOnOffMask=0;
 4712               		.loc 1 1585 0
 4713 24a2 1092 0000 		sts ledOnOffMask,__zero_reg__
 4714               	.LVL177:
 4715               	.LBB262:
 4716               	.LBB263:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 4717               		.loc 1 1572 0
 4718 24a6 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 4719               		.loc 1 1573 0
 4720 24aa 68E9      		ldi r22,lo8(-104)
 4721 24ac 70E0      		ldi r23,0
 4722 24ae 82E0      		ldi r24,lo8(2)
 4723 24b0 0E94 0000 		call SetTimer
 4724               	.LVL178:
 4725               	.LBE263:
 4726               	.LBE262:
 4727               	.LBE261:
 4728               	.LBE260:
 4729               	.LBB264:
 4730               	.LBB265:
1504:WTPA.c        **** 	State=newState;
 4731               		.loc 1 1504 0
 4732 24b4 80E0      		ldi r24,lo8(gs(DoStartupSelect))
 4733 24b6 90E0      		ldi r25,hi8(gs(DoStartupSelect))
 4734 24b8 9093 0000 		sts State+1,r25
 4735 24bc 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 4736               		.loc 1 1505 0
 4737 24c0 1092 0000 		sts subState,__zero_reg__
 4738 24c4 00C0      		rjmp .L298
 4739               	.LVL179:
 4740               	.L314:
 4741               	.LBE265:
 4742               	.LBE264:
4926:WTPA.c        **** 		if(CheckTimer(TIMER_1))
 4743               		.loc 1 4926 0
 4744 24c6 80E0      		ldi r24,0
 4745 24c8 0E94 0000 		call CheckTimer
 4746               	.LVL180:
 4747 24cc 8823      		tst r24
 4748 24ce 01F4      		brne .+2
 4749 24d0 00C0      		rjmp .L298
4928:WTPA.c        **** 			if(ledPwm>1)
 4750               		.loc 1 4928 0
 4751 24d2 8091 0000 		lds r24,ledPwm
 4752 24d6 8230      		cpi r24,lo8(2)
 4753 24d8 00F0      		brlo .L297
4930:WTPA.c        **** 				ledPwm-=2;
 4754               		.loc 1 4930 0
 4755 24da 8091 0000 		lds r24,ledPwm
 4756 24de 8250      		subi r24,lo8(-(-2))
 4757 24e0 8093 0000 		sts ledPwm,r24
4931:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/256));
 4758               		.loc 1 4931 0
 4759 24e4 64E0      		ldi r22,lo8(4)
 4760 24e6 70E0      		ldi r23,0
 4761 24e8 80E0      		ldi r24,0
 4762 24ea 0E94 0000 		call SetTimer
 4763               	.LVL181:
 4764 24ee 00C0      		rjmp .L298
 4765               	.L297:
4936:WTPA.c        **** 				TIMSK2=0x00;		// Disable all timer 0 interrupts.
 4766               		.loc 1 4936 0
 4767 24f0 1092 7000 		sts 112,__zero_reg__
4937:WTPA.c        **** 				TCCR2A=0x00;		// Normal ports
 4768               		.loc 1 4937 0
 4769 24f4 1092 B000 		sts 176,__zero_reg__
4938:WTPA.c        **** 				TCCR2B=0x00;		// Turn clock off.
 4770               		.loc 1 4938 0
 4771 24f8 1092 B100 		sts 177,__zero_reg__
4939:WTPA.c        **** 				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
 4772               		.loc 1 4939 0
 4773 24fc 8091 6400 		lds r24,100
 4774 2500 8064      		ori r24,lo8(64)
 4775 2502 8093 6400 		sts 100,r24
4941:WTPA.c        **** 				LATCH_PORT=0x00;		// LEDs off.
 4776               		.loc 1 4941 0
 4777 2506 15B8      		out 0x5,__zero_reg__
4942:WTPA.c        **** 				PORTD&=~(Om_LED_LA);	// ...Keep them off.
 4778               		.loc 1 4942 0
 4779 2508 5F98      		cbi 0xb,7
 4780               	.LBB266:
 4781               	.LBB267:
1585:WTPA.c        **** 	ledOnOffMask=0;
 4782               		.loc 1 1585 0
 4783 250a 1092 0000 		sts ledOnOffMask,__zero_reg__
 4784               	.LVL182:
 4785               	.LBB268:
 4786               	.LBB269:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 4787               		.loc 1 1572 0
 4788 250e 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 4789               		.loc 1 1573 0
 4790 2512 68E9      		ldi r22,lo8(-104)
 4791 2514 70E0      		ldi r23,0
 4792 2516 82E0      		ldi r24,lo8(2)
 4793 2518 0E94 0000 		call SetTimer
 4794               	.LVL183:
 4795               	.LBE269:
 4796               	.LBE268:
 4797               	.LBE267:
 4798               	.LBE266:
4945:WTPA.c        **** 				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boo
 4799               		.loc 1 4945 0
 4800 251c 82E1      		ldi r24,lo8(18)
 4801 251e 8093 0000 		sts ledOnOffMask,r24
4946:WTPA.c        **** 				SetTimer(TIMER_1,(SECOND/2));
 4802               		.loc 1 4946 0
 4803 2522 62E6      		ldi r22,lo8(98)
 4804 2524 72E0      		ldi r23,lo8(2)
 4805 2526 80E0      		ldi r24,0
 4806 2528 0E94 0000 		call SetTimer
 4807               	.LVL184:
4947:WTPA.c        **** 				subState=SS_4;
 4808               		.loc 1 4947 0
 4809 252c 84E0      		ldi r24,lo8(4)
 4810 252e 8093 0000 		sts subState,r24
 4811 2532 00C0      		rjmp .L298
 4812               		.cfi_endproc
 4813               	.LFE75:
 4816               	DoSampler:
 4817               	.LFB70:
4377:WTPA.c        **** {
 4818               		.loc 1 4377 0
 4819               		.cfi_startproc
 4820 2534 CF92      		push r12
 4821               	.LCFI43:
 4822               		.cfi_def_cfa_offset 3
 4823               		.cfi_offset 12, -2
 4824 2536 DF92      		push r13
 4825               	.LCFI44:
 4826               		.cfi_def_cfa_offset 4
 4827               		.cfi_offset 13, -3
 4828 2538 EF92      		push r14
 4829               	.LCFI45:
 4830               		.cfi_def_cfa_offset 5
 4831               		.cfi_offset 14, -4
 4832 253a FF92      		push r15
 4833               	.LCFI46:
 4834               		.cfi_def_cfa_offset 6
 4835               		.cfi_offset 15, -5
 4836 253c 0F93      		push r16
 4837               	.LCFI47:
 4838               		.cfi_def_cfa_offset 7
 4839               		.cfi_offset 16, -6
 4840 253e 1F93      		push r17
 4841               	.LCFI48:
 4842               		.cfi_def_cfa_offset 8
 4843               		.cfi_offset 17, -7
 4844 2540 CF93      		push r28
 4845               	.LCFI49:
 4846               		.cfi_def_cfa_offset 9
 4847               		.cfi_offset 28, -8
 4848 2542 DF93      		push r29
 4849               	.LCFI50:
 4850               		.cfi_def_cfa_offset 10
 4851               		.cfi_offset 29, -9
 4852 2544 1F92      		push __zero_reg__
 4853               	.LCFI51:
 4854               		.cfi_def_cfa_offset 11
 4855 2546 CDB7      		in r28,__SP_L__
 4856 2548 DEB7      		in r29,__SP_H__
 4857               	.LCFI52:
 4858               		.cfi_def_cfa_register 28
 4859               	/* prologue: function */
 4860               	/* frame size = 1 */
 4861               	/* stack size = 9 */
 4862               	.L__stack_usage = 9
4394:WTPA.c        **** 	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sam
 4863               		.loc 1 4394 0
 4864 254a 8091 0000 		lds r24,subState
 4865 254e 8823      		tst r24
 4866 2550 01F4      		brne .+2
 4867 2552 00C0      		rjmp .L317
 4868               	.L650:
 4869 2554 6091 0000 		lds r22,sdIsrState
 4870               	.L318:
 4871               	.LBB404:
 4872               	.LBB405:
3597:WTPA.c        **** 	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
 4873               		.loc 1 3597 0
 4874 2558 6330      		cpi r22,lo8(3)
 4875 255a 01F0      		breq .L455
 4876               	.L491:
3599:WTPA.c        **** 		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR st
 4877               		.loc 1 3599 0
 4878 255c 1092 0000 		sts sdStreamOutput,__zero_reg__
 4879               	.L455:
3603:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
 4880               		.loc 1 3603 0
 4881 2560 8091 0000 		lds r24,bankStates+10
 4882 2564 8130      		cpi r24,lo8(1)
 4883 2566 01F0      		breq .L456
3605:WTPA.c        **** 		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
 4884               		.loc 1 3605 0
 4885 2568 1092 0000 		sts extIsrOutputBank0,__zero_reg__
3606:WTPA.c        **** 		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 4886               		.loc 1 3606 0
 4887 256c 8091 6F00 		lds r24,111
 4888 2570 8F7D      		andi r24,lo8(-33)
 4889 2572 8093 6F00 		sts 111,r24
3607:WTPA.c        **** 		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
 4890               		.loc 1 3607 0
 4891 2576 B59A      		sbi 0x16,5
 4892               	.L456:
3609:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
 4893               		.loc 1 3609 0
 4894 2578 8091 0000 		lds r24,bankStates+46
 4895 257c 8130      		cpi r24,lo8(1)
 4896 257e 01F0      		breq .L457
3611:WTPA.c        **** 		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
 4897               		.loc 1 3611 0
 4898 2580 1092 0000 		sts extIsrOutputBank1,__zero_reg__
3612:WTPA.c        **** 		PCICR=0;			// No global PCINTS.
 4899               		.loc 1 3612 0
 4900 2584 1092 6800 		sts 104,__zero_reg__
3613:WTPA.c        **** 		PCMSK2=0;			// No PORTC interrupts enabled.
 4901               		.loc 1 3613 0
 4902 2588 1092 6D00 		sts 109,__zero_reg__
 4903               	.L457:
3615:WTPA.c        **** 	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
 4904               		.loc 1 3615 0
 4905 258c 8091 0000 		lds r24,bankStates+10
 4906 2590 8230      		cpi r24,lo8(2)
 4907 2592 01F0      		breq .L458
3617:WTPA.c        **** 		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
 4908               		.loc 1 3617 0
 4909 2594 1092 0000 		sts midiOutputBank0,__zero_reg__
3618:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
 4910               		.loc 1 3618 0
 4911 2598 8091 6F00 		lds r24,111
 4912 259c 8D7F      		andi r24,lo8(-3)
 4913 259e 8093 6F00 		sts 111,r24
3619:WTPA.c        **** 		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
 4914               		.loc 1 3619 0
 4915 25a2 B19A      		sbi 0x16,1
 4916               	.L458:
3621:WTPA.c        **** 	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
 4917               		.loc 1 3621 0
 4918 25a4 8091 0000 		lds r24,bankStates+46
 4919 25a8 8230      		cpi r24,lo8(2)
 4920 25aa 01F0      		breq .L459
3623:WTPA.c        **** 		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
 4921               		.loc 1 3623 0
 4922 25ac 1092 0000 		sts midiOutputBank1,__zero_reg__
3624:WTPA.c        **** 		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
 4923               		.loc 1 3624 0
 4924 25b0 8091 6F00 		lds r24,111
 4925 25b4 8B7F      		andi r24,lo8(-5)
 4926 25b6 8093 6F00 		sts 111,r24
3625:WTPA.c        **** 		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
 4927               		.loc 1 3625 0
 4928 25ba B29A      		sbi 0x16,2
 4929               	.L459:
3629:WTPA.c        **** 	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
 4930               		.loc 1 3629 0
 4931 25bc 8091 0000 		lds r24,bankStates+10
 4932 25c0 8111      		cpse r24,__zero_reg__
 4933 25c2 00C0      		rjmp .L460
3631:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
 4934               		.loc 1 3631 0
 4935 25c4 6111      		cpse r22,__zero_reg__
 4936 25c6 00C0      		rjmp .L653
 4937               	.L461:
3633:WTPA.c        **** 			bankStates[BANK_0].isLocked=false;
 4938               		.loc 1 3633 0
 4939 25c8 1092 0000 		sts bankStates+5,__zero_reg__
 4940               	.L460:
3636:WTPA.c        **** 	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
 4941               		.loc 1 3636 0
 4942 25cc 8091 0000 		lds r24,bankStates+46
 4943 25d0 8111      		cpse r24,__zero_reg__
 4944 25d2 00C0      		rjmp .L462
3638:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set s
 4945               		.loc 1 3638 0
 4946 25d4 6623      		tst r22
 4947 25d6 01F4      		brne .+2
 4948 25d8 00C0      		rjmp .L463
 4949 25da 6330      		cpi r22,lo8(3)
 4950 25dc 01F4      		brne .+2
 4951 25de 00C0      		rjmp .L463
 4952 25e0 8091 0000 		lds r24,sdBank0
 4953 25e4 8130      		cpi r24,lo8(1)
 4954 25e6 01F4      		brne .+2
 4955 25e8 00C0      		rjmp .L463
 4956               	.L462:
 4957               	.LBE405:
 4958               	.LBE404:
 4959               	.LBB408:
 4960               	.LBB409:
3573:WTPA.c        **** 	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit ra
 4961               		.loc 1 3573 0
 4962 25ea 8091 0000 		lds r24,encoderValue
 4963 25ee 8295      		swap r24
 4964 25f0 8695      		lsr r24
 4965 25f2 8770      		andi r24,lo8(7)
 4966 25f4 8093 0000 		sts scaledEncoderValue,r24
3574:WTPA.c        **** 	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're tes
 4967               		.loc 1 3574 0
 4968 25f8 2091 0000 		lds r18,ledOnOffMask
 4969 25fc 2F71      		andi r18,lo8(31)
 4970               	.LVL185:
3576:WTPA.c        **** 	if(scaledEncoderValue&(1<<0))
 4971               		.loc 1 3576 0
 4972 25fe 80FD      		sbrc r24,0
3578:WTPA.c        **** 		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
 4973               		.loc 1 3578 0
 4974 2600 2068      		ori r18,lo8(-128)
 4975               	.LVL186:
 4976               	.L464:
3580:WTPA.c        **** 	if(scaledEncoderValue&(1<<1))
 4977               		.loc 1 3580 0
 4978 2602 81FD      		sbrc r24,1
3582:WTPA.c        **** 		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
 4979               		.loc 1 3582 0
 4980 2604 2064      		ori r18,lo8(64)
 4981               	.LVL187:
 4982               	.L465:
 4983               	.LBE409:
3584:WTPA.c        **** 	if(scaledEncoderValue&(1<<2))
 4984               		.loc 1 3584 0
 4985 2606 8470      		andi r24,lo8(4)
 4986               	.LBB410:
 4987 2608 01F0      		breq .L466
3586:WTPA.c        **** 		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
 4988               		.loc 1 3586 0
 4989 260a 2062      		ori r18,lo8(32)
 4990               	.LVL188:
 4991               	.L466:
 4992               	.LBE410:
 4993               	.LBE408:
4637:WTPA.c        **** 	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
 4994               		.loc 1 4637 0
 4995 260c 3091 0000 		lds r19,currentBank
 4996               	.LVL189:
 4997               	.LBB411:
 4998               	.LBB412:
3521:WTPA.c        **** 	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
 4999               		.loc 1 3521 0
 5000 2610 207E      		andi r18,lo8(-32)
 5001               	.LVL190:
3523:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
 5002               		.loc 1 3523 0
 5003 2612 832F      		mov r24,r19
 5004 2614 90E0      		ldi r25,0
 5005 2616 44E2      		ldi r20,lo8(36)
 5006 2618 349F      		mul r19,r20
 5007 261a F001      		movw r30,r0
 5008 261c 1124      		clr __zero_reg__
 5009 261e E050      		subi r30,lo8(-(bankStates))
 5010 2620 F040      		sbci r31,hi8(-(bankStates))
 5011 2622 4081      		ld r20,Z
 5012 2624 4330      		cpi r20,lo8(3)
 5013 2626 01F4      		brne .+2
 5014 2628 00C0      		rjmp .L654
 5015               	.L467:
3527:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
 5016               		.loc 1 3527 0
 5017 262a 44E2      		ldi r20,lo8(36)
 5018 262c 489F      		mul r20,r24
 5019 262e F001      		movw r30,r0
 5020 2630 499F      		mul r20,r25
 5021 2632 F00D      		add r31,r0
 5022 2634 1124      		clr __zero_reg__
 5023 2636 E050      		subi r30,lo8(-(bankStates))
 5024 2638 F040      		sbci r31,hi8(-(bankStates))
 5025 263a 4081      		ld r20,Z
 5026 263c 4430      		cpi r20,lo8(4)
 5027 263e 01F4      		brne .+2
 5028 2640 00C0      		rjmp .L655
 5029               	.L468:
3531:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
 5030               		.loc 1 3531 0
 5031 2642 44E2      		ldi r20,lo8(36)
 5032 2644 489F      		mul r20,r24
 5033 2646 F001      		movw r30,r0
 5034 2648 499F      		mul r20,r25
 5035 264a F00D      		add r31,r0
 5036 264c 1124      		clr __zero_reg__
 5037 264e E050      		subi r30,lo8(-(bankStates))
 5038 2650 F040      		sbci r31,hi8(-(bankStates))
 5039 2652 4081      		ld r20,Z
 5040 2654 4530      		cpi r20,lo8(5)
 5041 2656 01F4      		brne .+2
 5042 2658 00C0      		rjmp .L656
 5043               	.L469:
3535:WTPA.c        **** 	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
 5044               		.loc 1 3535 0
 5045 265a 44E2      		ldi r20,lo8(36)
 5046 265c 489F      		mul r20,r24
 5047 265e F001      		movw r30,r0
 5048 2660 499F      		mul r20,r25
 5049 2662 F00D      		add r31,r0
 5050 2664 1124      		clr __zero_reg__
 5051 2666 E050      		subi r30,lo8(-(bankStates))
 5052 2668 F040      		sbci r31,hi8(-(bankStates))
 5053 266a 4081      		ld r20,Z
 5054 266c 4230      		cpi r20,lo8(2)
 5055 266e 01F4      		brne .+2
 5056 2670 00C0      		rjmp .L657
 5057               	.L470:
3542:WTPA.c        **** 	if(outOfRam==true)
 5058               		.loc 1 3542 0
 5059 2672 4091 0000 		lds r20,outOfRam
 5060 2676 4130      		cpi r20,lo8(1)
 5061 2678 01F4      		brne .+2
 5062 267a 00C0      		rjmp .L658
3546:WTPA.c        **** 	if(theBank==BANK_1)
 5063               		.loc 1 3546 0
 5064 267c 3130      		cpi r19,lo8(1)
 5065 267e 01F4      		brne .+2
 5066 2680 00C0      		rjmp .L659
 5067               	.L472:
3551:WTPA.c        **** 	ledOnOffMask=temp;
 5068               		.loc 1 3551 0
 5069 2682 2093 0000 		sts ledOnOffMask,r18
3553:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
 5070               		.loc 1 3553 0
 5071 2686 34E2      		ldi r19,lo8(36)
 5072               	.LVL191:
 5073 2688 389F      		mul r19,r24
 5074 268a F001      		movw r30,r0
 5075 268c 399F      		mul r19,r25
 5076 268e F00D      		add r31,r0
 5077 2690 1124      		clr __zero_reg__
 5078 2692 E050      		subi r30,lo8(-(bankStates))
 5079 2694 F040      		sbci r31,hi8(-(bankStates))
 5080 2696 4189      		ldd r20,Z+17
 5081 2698 5289      		ldd r21,Z+18
 5082 269a 6389      		ldd r22,Z+19
 5083 269c 7489      		ldd r23,Z+20
 5084 269e 8585      		ldd r24,Z+13
 5085 26a0 9685      		ldd r25,Z+14
 5086 26a2 A785      		ldd r26,Z+15
 5087 26a4 B089      		ldd r27,Z+16
 5088               	.LVL192:
3555:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
 5089               		.loc 1 3555 0
 5090 26a6 3091 0000 		lds r19,ledBlinkMask
3553:WTPA.c        **** 	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample
 5091               		.loc 1 3553 0
 5092 26aa 4817      		cp r20,r24
 5093 26ac 5907      		cpc r21,r25
 5094 26ae 6A07      		cpc r22,r26
 5095 26b0 7B07      		cpc r23,r27
 5096 26b2 01F0      		breq .L660
 5097 26b4 832F      		mov r24,r19
 5098 26b6 90E0      		ldi r25,0
 5099               	.LBB413:
 5100               	.LBB414:
 5101               	.LBB415:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5102               		.loc 1 1566 0
 5103 26b8 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5104               		.loc 1 1568 0
 5105 26ba 2E7F      		andi r18,lo8(-2)
 5106               	.LVL193:
 5107               	.L483:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5108               		.loc 1 1566 0
 5109 26bc 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5110               		.loc 1 1568 0
 5111 26be 2D7F      		andi r18,lo8(-3)
 5112               	.L484:
 5113               	.LVL194:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5114               		.loc 1 1566 0
 5115 26c0 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5116               		.loc 1 1568 0
 5117 26c2 2B7F      		andi r18,lo8(-5)
 5118               	.L485:
 5119               	.LVL195:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5120               		.loc 1 1566 0
 5121 26c4 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5122               		.loc 1 1568 0
 5123 26c6 277F      		andi r18,lo8(-9)
 5124               	.L486:
 5125               	.LVL196:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5126               		.loc 1 1566 0
 5127 26c8 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5128               		.loc 1 1568 0
 5129 26ca 2F7E      		andi r18,lo8(-17)
 5130               	.L487:
 5131               	.LVL197:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5132               		.loc 1 1566 0
 5133 26cc 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5134               		.loc 1 1568 0
 5135 26ce 2F7D      		andi r18,lo8(-33)
 5136               	.L488:
 5137               	.LVL198:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5138               		.loc 1 1566 0
 5139 26d0 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5140               		.loc 1 1568 0
 5141 26d2 2F7B      		andi r18,lo8(-65)
 5142               	.L489:
 5143               	.LVL199:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5144               		.loc 1 1566 0
 5145 26d4 880F      		lsl r24
 5146 26d6 892F      		mov r24,r25
 5147 26d8 881F      		rol r24
 5148 26da 990B      		sbc r25,r25
 5149 26dc 892B      		or r24,r25
 5150 26de 01F4      		brne .L661
 5151               	.L490:
 5152               	.LVL200:
 5153 26e0 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 5154               		.loc 1 1572 0
 5155 26e4 1092 0000 		sts ledBlinkMask,__zero_reg__
 5156               	.LVL201:
 5157               	.L652:
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 5158               		.loc 1 1573 0
 5159 26e8 68E9      		ldi r22,lo8(-104)
 5160 26ea 70E0      		ldi r23,0
 5161 26ec 82E0      		ldi r24,lo8(2)
 5162               	/* epilogue start */
 5163               	.LBE415:
 5164               	.LBE414:
 5165               	.LBE413:
 5166               	.LBE412:
 5167               	.LBE411:
4638:WTPA.c        **** }
 5168               		.loc 1 4638 0
 5169 26ee 0F90      		pop __tmp_reg__
 5170 26f0 DF91      		pop r29
 5171 26f2 CF91      		pop r28
 5172 26f4 1F91      		pop r17
 5173 26f6 0F91      		pop r16
 5174 26f8 FF90      		pop r15
 5175 26fa EF90      		pop r14
 5176 26fc DF90      		pop r13
 5177 26fe CF90      		pop r12
 5178               	.LBB429:
 5179               	.LBB424:
 5180               	.LBB420:
 5181               	.LBB418:
 5182               	.LBB416:
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 5183               		.loc 1 1573 0
 5184 2700 0C94 0000 		jmp SetTimer
 5185               	.LVL202:
 5186               	.L463:
 5187               	.LBE416:
 5188               	.LBE418:
 5189               	.LBE420:
 5190               	.LBE424:
 5191               	.LBE429:
 5192               	.LBB430:
 5193               	.LBB406:
3640:WTPA.c        **** 			bankStates[BANK_1].isLocked=false;
 5194               		.loc 1 3640 0
 5195 2704 1092 0000 		sts bankStates+41,__zero_reg__
 5196 2708 00C0      		rjmp .L462
 5197               	.LVL203:
 5198               	.L661:
 5199               	.LBE406:
 5200               	.LBE430:
 5201               	.LBB431:
 5202               	.LBB425:
 5203               	.LBB421:
 5204               	.LBB419:
 5205               	.LBB417:
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5206               		.loc 1 1568 0
 5207 270a 2F77      		andi r18,lo8(127)
 5208 270c 00C0      		rjmp .L490
 5209               	.LVL204:
 5210               	.L653:
 5211               	.LBE417:
 5212               	.LBE419:
 5213               	.LBE421:
 5214               	.LBE425:
 5215               	.LBE431:
 5216               	.LBB432:
 5217               	.LBB407:
3631:WTPA.c        **** 		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set 
 5218               		.loc 1 3631 0
 5219 270e 6330      		cpi r22,lo8(3)
 5220 2710 01F4      		brne .+2
 5221 2712 00C0      		rjmp .L461
 5222 2714 8091 0000 		lds r24,sdBank0
 5223 2718 8111      		cpse r24,__zero_reg__
 5224 271a 00C0      		rjmp .L460
 5225 271c 00C0      		rjmp .L461
 5226               	.LVL205:
 5227               	.L660:
 5228               	.LBE407:
 5229               	.LBE432:
 5230               	.LBB433:
 5231               	.LBB426:
3555:WTPA.c        **** 		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
 5232               		.loc 1 3555 0
 5233 271e 32FF      		sbrs r19,2
 5234 2720 00C0      		rjmp .L662
 5235               	/* epilogue start */
 5236               	.LBE426:
 5237               	.LBE433:
4638:WTPA.c        **** }
 5238               		.loc 1 4638 0
 5239 2722 0F90      		pop __tmp_reg__
 5240 2724 DF91      		pop r29
 5241 2726 CF91      		pop r28
 5242 2728 1F91      		pop r17
 5243 272a 0F91      		pop r16
 5244 272c FF90      		pop r15
 5245 272e EF90      		pop r14
 5246 2730 DF90      		pop r13
 5247 2732 CF90      		pop r12
 5248 2734 0895      		ret
 5249               	.LVL206:
 5250               	.L317:
 5251               	.LBB434:
 5252               	.LBB435:
4140:WTPA.c        **** 	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
 5253               		.loc 1 4140 0
 5254 2736 8091 0000 		lds r24,keysHeld
 5255 273a 86FF      		sbrs r24,6
 5256 273c 00C0      		rjmp .L319
 5257 273e 87FD      		sbrc r24,7
 5258 2740 00C0      		rjmp .L663
 5259               	.LBE435:
4170:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
 5260               		.loc 1 4170 0
 5261 2742 8091 0000 		lds r24,keyState
 5262               	.LBB524:
 5263 2746 80FF      		sbrs r24,0
 5264 2748 00C0      		rjmp .L647
4172:WTPA.c        **** 			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just
 5265               		.loc 1 4172 0
 5266 274a 8091 0000 		lds r24,newEncoder
 5267 274e 8111      		cpse r24,__zero_reg__
 5268 2750 00C0      		rjmp .L325
 5269 2752 8091 0000 		lds r24,newKeys
 5270 2756 80FF      		sbrs r24,0
 5271 2758 00C0      		rjmp .L324
 5272               	.L325:
4174:WTPA.c        **** 				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
 5273               		.loc 1 4174 0
 5274 275a 8091 0000 		lds r24,currentBank
 5275 275e 2091 0000 		lds r18,scaledEncoderValue
 5276 2762 34E2      		ldi r19,lo8(36)
 5277 2764 839F      		mul r24,r19
 5278 2766 F001      		movw r30,r0
 5279 2768 1124      		clr __zero_reg__
 5280 276a E050      		subi r30,lo8(-(bankStates))
 5281 276c F040      		sbci r31,hi8(-(bankStates))
 5282 276e 2187      		std Z+9,r18
4175:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledE
 5283               		.loc 1 4175 0
 5284 2770 43E1      		ldi r20,lo8(19)
 5285 2772 64E0      		ldi r22,lo8(4)
 5286 2774 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5287               	.LVL207:
 5288               	.L647:
 5289 2778 8091 0000 		lds r24,newKeys
 5290               	.L324:
4178:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
 5291               		.loc 1 4178 0
 5292 277c 81FF      		sbrs r24,1
 5293 277e 00C0      		rjmp .L326
4180:WTPA.c        **** 			if(bankStates[currentBank].halfSpeed==false)
 5294               		.loc 1 4180 0
 5295 2780 8091 0000 		lds r24,currentBank
 5296 2784 44E2      		ldi r20,lo8(36)
 5297 2786 849F      		mul r24,r20
 5298 2788 F001      		movw r30,r0
 5299 278a 1124      		clr __zero_reg__
 5300 278c E050      		subi r30,lo8(-(bankStates))
 5301 278e F040      		sbci r31,hi8(-(bankStates))
 5302 2790 9281      		ldd r25,Z+2
 5303 2792 9111      		cpse r25,__zero_reg__
 5304 2794 00C0      		rjmp .L327
4182:WTPA.c        **** 				bankStates[currentBank].halfSpeed=true;
 5305               		.loc 1 4182 0
 5306 2796 91E0      		ldi r25,lo8(1)
 5307 2798 9283      		std Z+2,r25
4183:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENER
 5308               		.loc 1 4183 0
 5309 279a 20E4      		ldi r18,lo8(64)
 5310 279c 40E1      		ldi r20,lo8(16)
 5311 279e 64E0      		ldi r22,lo8(4)
 5312 27a0 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5313               	.LVL208:
 5314 27a4 8091 0000 		lds r24,newKeys
 5315               	.L326:
4191:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)		// Do realtime
 5316               		.loc 1 4191 0
 5317 27a8 82FD      		sbrc r24,2
 5318 27aa 00C0      		rjmp .L664
 5319               	.L328:
4196:WTPA.c        **** 		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- res
 5320               		.loc 1 4196 0
 5321 27ac 8091 0000 		lds r24,keyState
 5322 27b0 83FF      		sbrs r24,3
 5323 27b2 00C0      		rjmp .L332
 5324 27b4 9091 0000 		lds r25,newEncoder
 5325 27b8 9111      		cpse r25,__zero_reg__
 5326 27ba 00C0      		rjmp .L333
 5327               	.L332:
 5328               	.LBE524:
 5329 27bc 9091 0000 		lds r25,newKeys
 5330               	.LBB525:
 5331 27c0 93FF      		sbrs r25,3
 5332 27c2 00C0      		rjmp .L334
 5333               	.L333:
4198:WTPA.c        **** 			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
 5334               		.loc 1 4198 0
 5335 27c4 2091 0000 		lds r18,encoderValue
 5336 27c8 2695      		lsr r18
 5337 27ca 1091 0000 		lds r17,currentBank
 5338 27ce 622F      		mov r22,r18
 5339 27d0 812F      		mov r24,r17
 5340 27d2 2983      		std Y+1,r18
 5341 27d4 0E94 0000 		call MakeNewGranularArray
 5342               	.LVL209:
4199:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderVa
 5343               		.loc 1 4199 0
 5344 27d8 2981      		ldd r18,Y+1
 5345 27da 44E1      		ldi r20,lo8(20)
 5346 27dc 64E0      		ldi r22,lo8(4)
 5347 27de 812F      		mov r24,r17
 5348 27e0 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5349               	.LVL210:
 5350 27e4 8091 0000 		lds r24,keyState
 5351               	.L334:
4201:WTPA.c        **** 		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
 5352               		.loc 1 4201 0
 5353 27e8 84FF      		sbrs r24,4
 5354 27ea 00C0      		rjmp .L335
4203:WTPA.c        **** 			if(newEncoder)	// Only change to new values
 5355               		.loc 1 4203 0
 5356 27ec 8091 0000 		lds r24,newEncoder
 5357 27f0 8111      		cpse r24,__zero_reg__
 5358 27f2 00C0      		rjmp .L665
 5359               	.L335:
 5360               	.LBE525:
4232:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
 5361               		.loc 1 4232 0
 5362 27f4 8091 0000 		lds r24,newKeys
 5363               	.LBB526:
 5364 27f8 85FF      		sbrs r24,5
 5365 27fa 00C0      		rjmp .L322
4234:WTPA.c        **** 			if(bankStates[currentBank].backwardsPlayback==false)
 5366               		.loc 1 4234 0
 5367 27fc 8091 0000 		lds r24,currentBank
 5368 2800 B4E2      		ldi r27,lo8(36)
 5369 2802 8B9F      		mul r24,r27
 5370 2804 F001      		movw r30,r0
 5371 2806 1124      		clr __zero_reg__
 5372 2808 E050      		subi r30,lo8(-(bankStates))
 5373 280a F040      		sbci r31,hi8(-(bankStates))
 5374 280c 9381      		ldd r25,Z+3
 5375 280e 9111      		cpse r25,__zero_reg__
 5376 2810 00C0      		rjmp .L340
4236:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=true;
 5377               		.loc 1 4236 0
 5378 2812 91E0      		ldi r25,lo8(1)
 5379 2814 9383      		std Z+3,r25
4237:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_G
 5380               		.loc 1 4237 0
 5381 2816 20E4      		ldi r18,lo8(64)
 5382 2818 41E1      		ldi r20,lo8(17)
 5383 281a 64E0      		ldi r22,lo8(4)
 5384 281c 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5385               	.LVL211:
 5386               	.L341:
4245:WTPA.c        **** 			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when cons
 5387               		.loc 1 4245 0
 5388 2820 8091 0000 		lds r24,currentBank
 5389 2824 0E94 0000 		call UpdateAdjustedSampleAddresses
 5390               	.LVL212:
 5391               	.L322:
 5392               	.LBE526:
 5393               	.LBE434:
4398:WTPA.c        **** 		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
 5394               		.loc 1 4398 0
 5395 2828 8091 0000 		lds r24,midiMessagesInIncomingFifo
 5396 282c 8823      		tst r24
 5397 282e 01F4      		brne .+2
 5398 2830 00C0      		rjmp .L650
4400:WTPA.c        **** 			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
 5399               		.loc 1 4400 0
 5400 2832 80E0      		ldi r24,lo8(currentMidiMessage.2230)
 5401 2834 90E0      		ldi r25,hi8(currentMidiMessage.2230)
 5402 2836 0E94 0000 		call GetMidiMessageFromIncomingFifo
 5403               	.LVL213:
4407:WTPA.c        **** 			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our ser
 5404               		.loc 1 4407 0
 5405 283a 4091 0000 		lds r20,currentMidiMessage.2230+1
 5406 283e 4230      		cpi r20,lo8(2)
 5407 2840 01F4      		brne .+2
 5408 2842 00C0      		rjmp .L666
4418:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
 5409               		.loc 1 4418 0
 5410 2844 4130      		cpi r20,lo8(1)
 5411 2846 01F4      		brne .+2
 5412 2848 00C0      		rjmp .L667
4435:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change me
 5413               		.loc 1 4435 0
 5414 284a 4430      		cpi r20,lo8(4)
 5415 284c 01F4      		brne .+2
 5416 284e 00C0      		rjmp .L668
4611:WTPA.c        **** 			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this int
 5417               		.loc 1 4611 0
 5418 2850 4730      		cpi r20,lo8(7)
 5419 2852 01F0      		breq .+2
 5420 2854 00C0      		rjmp .L650
4613:WTPA.c        **** 				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn 
 5421               		.loc 1 4613 0
 5422 2856 2091 0000 		lds r18,currentMidiMessage.2230+3
 5423 285a 8091 0000 		lds r24,currentMidiMessage.2230+2
 5424 285e 90E0      		ldi r25,0
 5425 2860 E0E8      		ldi r30,lo8(-128)
 5426 2862 2E9F      		mul r18,r30
 5427 2864 800D      		add r24,r0
 5428 2866 911D      		adc r25,r1
 5429 2868 1124      		clr __zero_reg__
 5430               	.LVL214:
4615:WTPA.c        **** 				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
 5431               		.loc 1 4615 0
 5432 286a 8115      		cp r24,__zero_reg__
 5433 286c F0E2      		ldi r31,32
 5434 286e 9F07      		cpc r25,r31
 5435 2870 01F4      		brne .+2
 5436 2872 00C0      		rjmp .L453
4619:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 5437               		.loc 1 4619 0
 5438 2874 4091 0000 		lds r20,currentMidiMessage.2230
 5439 2878 50E0      		ldi r21,0
 5440 287a FA01      		movw r30,r20
 5441 287c E050      		subi r30,lo8(-(currentNoteOn.2231))
 5442 287e F040      		sbci r31,hi8(-(currentNoteOn.2231))
 5443 2880 7081      		ld r23,Z
 5444               	.LVL215:
4623:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 5445               		.loc 1 4623 0
 5446 2882 20E0      		ldi r18,0
 5447 2884 30E2      		ldi r19,lo8(32)
 5448 2886 281B      		sub r18,r24
 5449 2888 390B      		sbc r19,r25
 5450               	.LBB535:
 5451               	.LBB536:
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 5452               		.loc 1 3409 0
 5453 288a 6BEA      		ldi r22,lo8(-85)
 5454 288c 769F      		mul r23,r22
 5455 288e 612D      		mov r22,r1
 5456 2890 1124      		clr __zero_reg__
 5457 2892 6695      		lsr r22
 5458 2894 6695      		lsr r22
 5459 2896 6695      		lsr r22
 5460 2898 862F      		mov r24,r22
 5461               	.LVL216:
 5462 289a 880F      		lsl r24
 5463 289c 860F      		add r24,r22
 5464 289e 880F      		lsl r24
 5465 28a0 880F      		lsl r24
 5466 28a2 781B      		sub r23,r24
 5467               	.LVL217:
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 5468               		.loc 1 3411 0
 5469 28a4 E72F      		mov r30,r23
 5470               	.LVL218:
 5471 28a6 F0E0      		ldi r31,0
 5472 28a8 EE0F      		lsl r30
 5473 28aa FF1F      		rol r31
 5474 28ac E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 5475 28ae F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 5476 28b0 8081      		ld r24,Z
 5477 28b2 9181      		ldd r25,Z+1
 5478 28b4 00C0      		rjmp 2f
 5479               		1:
 5480 28b6 9695      		lsr r25
 5481 28b8 8795      		ror r24
 5482               		2:
 5483 28ba 6A95      		dec r22
 5484 28bc 02F4      		brpl 1b
 5485               	.LBE536:
 5486               	.LBE535:
4623:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(
 5487               		.loc 1 4623 0
 5488 28be 280F      		add r18,r24
 5489 28c0 391F      		adc r19,r25
 5490 28c2 84E2      		ldi r24,lo8(36)
 5491 28c4 849F      		mul r24,r20
 5492 28c6 F001      		movw r30,r0
 5493 28c8 859F      		mul r24,r21
 5494 28ca F00D      		add r31,r0
 5495 28cc 1124      		clr __zero_reg__
 5496 28ce E050      		subi r30,lo8(-(bankStates))
 5497 28d0 F040      		sbci r31,hi8(-(bankStates))
 5498 28d2 3487      		std Z+12,r19
 5499 28d4 2387      		std Z+11,r18
 5500 28d6 6091 0000 		lds r22,sdIsrState
 5501 28da 00C0      		rjmp .L318
 5502               	.LVL219:
 5503               	.L658:
 5504               	.LBB537:
 5505               	.LBB427:
3544:WTPA.c        **** 		temp|=Om_LED_OUT_OF_MEM;
 5506               		.loc 1 3544 0
 5507 28dc 2860      		ori r18,lo8(8)
 5508               	.LVL220:
3546:WTPA.c        **** 	if(theBank==BANK_1)
 5509               		.loc 1 3546 0
 5510 28de 3130      		cpi r19,lo8(1)
 5511 28e0 01F0      		breq .+2
 5512 28e2 00C0      		rjmp .L472
 5513               	.L659:
3548:WTPA.c        **** 		temp|=Om_LED_BANK;
 5514               		.loc 1 3548 0
 5515 28e4 2061      		ori r18,lo8(16)
 5516               	.LVL221:
 5517 28e6 00C0      		rjmp .L472
 5518               	.L657:
 5519               	.LVL222:
3539:WTPA.c        **** 		temp|=Om_LED_ODUB;
 5520               		.loc 1 3539 0
 5521 28e8 2760      		ori r18,lo8(7)
 5522               	.LVL223:
 5523 28ea 00C0      		rjmp .L470
 5524               	.L654:
3525:WTPA.c        **** 		temp|=Om_LED_REC;
 5525               		.loc 1 3525 0
 5526 28ec 2160      		ori r18,lo8(1)
 5527               	.LVL224:
 5528 28ee 00C0      		rjmp .L467
 5529               	.L656:
3533:WTPA.c        **** 		temp|=Om_LED_ODUB;
 5530               		.loc 1 3533 0
 5531 28f0 2260      		ori r18,lo8(2)
 5532               	.LVL225:
 5533 28f2 00C0      		rjmp .L469
 5534               	.L655:
3529:WTPA.c        **** 		temp|=Om_LED_PLAY;
 5535               		.loc 1 3529 0
 5536 28f4 2460      		ori r18,lo8(4)
 5537               	.LVL226:
 5538 28f6 00C0      		rjmp .L468
 5539               	.LVL227:
 5540               	.L319:
 5541               	.LBE427:
 5542               	.LBE537:
 5543               	.LBB538:
 5544               	.LBB527:
4251:WTPA.c        **** 	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
 5545               		.loc 1 4251 0
 5546 28f8 87FD      		sbrc r24,7
 5547 28fa 00C0      		rjmp .L669
4293:WTPA.c        **** 		if(newKeys&Im_REC)										// Record switch pressed.
 5548               		.loc 1 4293 0
 5549 28fc 8091 0000 		lds r24,newKeys
 5550 2900 80FF      		sbrs r24,0
 5551 2902 00C0      		rjmp .L346
4295:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
 5552               		.loc 1 4295 0
 5553 2904 1091 0000 		lds r17,currentBank
 5554 2908 212F      		mov r18,r17
 5555 290a 30E0      		ldi r19,0
 5556 290c 84E2      		ldi r24,lo8(36)
 5557 290e 189F      		mul r17,r24
 5558 2910 F001      		movw r30,r0
 5559 2912 1124      		clr __zero_reg__
 5560 2914 E050      		subi r30,lo8(-(bankStates))
 5561 2916 F040      		sbci r31,hi8(-(bankStates))
 5562 2918 8081      		ld r24,Z
 5563 291a 8330      		cpi r24,lo8(3)
 5564 291c 01F4      		brne .+2
 5565 291e 00C0      		rjmp .L670
4303:WTPA.c        **** 				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
 5566               		.loc 1 4303 0
 5567 2920 40E0      		ldi r20,0
 5568 2922 50E0      		ldi r21,0
 5569 2924 61E0      		ldi r22,lo8(1)
 5570 2926 812F      		mov r24,r17
 5571 2928 0E94 0000 		call StartRecording
 5572               	.LVL228:
4304:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERI
 5573               		.loc 1 4304 0
 5574 292c 20E3      		ldi r18,lo8(48)
 5575 292e 43E0      		ldi r20,lo8(3)
 5576 2930 64E0      		ldi r22,lo8(4)
 5577 2932 812F      		mov r24,r17
 5578 2934 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5579               	.LVL229:
 5580 2938 00C0      		rjmp .L322
 5581               	.LVL230:
 5582               	.L662:
 5583 293a 832F      		mov r24,r19
 5584 293c 90E0      		ldi r25,0
 5585               	.LBE527:
 5586               	.LBE538:
 5587               	.LBB539:
 5588               	.LBB428:
 5589               	.LBB422:
 5590               	.LBB423:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5591               		.loc 1 1566 0
 5592 293e 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5593               		.loc 1 1568 0
 5594 2940 2E7F      		andi r18,lo8(-2)
 5595               	.LVL231:
 5596               	.L475:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5597               		.loc 1 1566 0
 5598 2942 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5599               		.loc 1 1568 0
 5600 2944 2D7F      		andi r18,lo8(-3)
 5601               	.L476:
 5602               	.LVL232:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5603               		.loc 1 1566 0
 5604 2946 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5605               		.loc 1 1568 0
 5606 2948 2B7F      		andi r18,lo8(-5)
 5607               	.L477:
 5608               	.LVL233:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5609               		.loc 1 1566 0
 5610 294a 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5611               		.loc 1 1568 0
 5612 294c 277F      		andi r18,lo8(-9)
 5613               	.L478:
 5614               	.LVL234:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5615               		.loc 1 1566 0
 5616 294e 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5617               		.loc 1 1568 0
 5618 2950 2F7E      		andi r18,lo8(-17)
 5619               	.L479:
 5620               	.LVL235:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5621               		.loc 1 1566 0
 5622 2952 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5623               		.loc 1 1568 0
 5624 2954 2F7D      		andi r18,lo8(-33)
 5625               	.L480:
 5626               	.LVL236:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5627               		.loc 1 1566 0
 5628 2956 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5629               		.loc 1 1568 0
 5630 2958 2F7B      		andi r18,lo8(-65)
 5631               	.L481:
 5632               	.LVL237:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 5633               		.loc 1 1566 0
 5634 295a 880F      		lsl r24
 5635 295c 892F      		mov r24,r25
 5636 295e 881F      		rol r24
 5637 2960 990B      		sbc r25,r25
 5638 2962 892B      		or r24,r25
 5639 2964 01F0      		breq .L482
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 5640               		.loc 1 1568 0
 5641 2966 2F77      		andi r18,lo8(127)
 5642               	.L482:
 5643               	.LVL238:
 5644 2968 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 5645               		.loc 1 1572 0
 5646 296c 84E0      		ldi r24,lo8(4)
 5647 296e 8093 0000 		sts ledBlinkMask,r24
 5648 2972 00C0      		rjmp .L652
 5649               	.LVL239:
 5650               	.L346:
 5651               	.LBE423:
 5652               	.LBE422:
 5653               	.LBE428:
 5654               	.LBE539:
 5655               	.LBB540:
 5656               	.LBB528:
4307:WTPA.c        **** 		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes 
 5657               		.loc 1 4307 0
 5658 2974 81FF      		sbrs r24,1
 5659 2976 00C0      		rjmp .L354
4309:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
 5660               		.loc 1 4309 0
 5661 2978 E091 0000 		lds r30,currentBank
 5662 297c 8E2F      		mov r24,r30
 5663 297e EE2E      		mov r14,r30
 5664 2980 F12C      		mov r15,__zero_reg__
 5665 2982 94E2      		ldi r25,lo8(36)
 5666 2984 E99F      		mul r30,r25
 5667 2986 D001      		movw r26,r0
 5668 2988 1124      		clr __zero_reg__
 5669 298a A050      		subi r26,lo8(-(bankStates))
 5670 298c B040      		sbci r27,hi8(-(bankStates))
 5671 298e 9C91      		ld r25,X
 5672 2990 9530      		cpi r25,lo8(5)
 5673 2992 01F4      		brne .+2
 5674 2994 00C0      		rjmp .L671
4317:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how
 5675               		.loc 1 4317 0
 5676 2996 5196      		adiw r26,17
 5677 2998 0D91      		ld r16,X+
 5678 299a 1D91      		ld r17,X+
 5679 299c 2D91      		ld r18,X+
 5680 299e 3C91      		ld r19,X
 5681 29a0 5497      		sbiw r26,17+3
 5682 29a2 1D96      		adiw r26,13
 5683 29a4 4D91      		ld r20,X+
 5684 29a6 5D91      		ld r21,X+
 5685 29a8 6D91      		ld r22,X+
 5686 29aa 7C91      		ld r23,X
 5687 29ac 5097      		sbiw r26,13+3
 5688 29ae 0417      		cp r16,r20
 5689 29b0 1507      		cpc r17,r21
 5690 29b2 2607      		cpc r18,r22
 5691 29b4 3707      		cpc r19,r23
 5692 29b6 01F4      		brne .+2
 5693 29b8 00C0      		rjmp .L322
 5694               	.LVL240:
 5695               	.LBB436:
 5696               	.LBB437:
2063:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 5697               		.loc 1 2063 0
 5698 29ba 1596      		adiw r26, 5
 5699 29bc 9C91      		ld r25,X
 5700 29be 9923      		tst r25
 5701 29c0 01F0      		breq .L360
 5702 29c2 9091 0000 		lds r25,sdIsrState
 5703 29c6 9150      		subi r25,lo8(-(-1))
 5704 29c8 9230      		cpi r25,lo8(2)
 5705 29ca 00F0      		brlo .L361
 5706               	.L360:
2065:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 5707               		.loc 1 2065 0
 5708 29cc 8FB7      		in r24,__SREG__
 5709               	.LVL241:
2066:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 5710               		.loc 1 2066 0
 5711               	/* #APP */
 5712               	 ;  2066 "WTPA.c" 1
 5713 29ce F894      		cli
 5714               	 ;  0 "" 2
2068:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
 5715               		.loc 1 2068 0
 5716               	/* #NOAPP */
 5717 29d0 94E2      		ldi r25,lo8(36)
 5718 29d2 9E9D      		mul r25,r14
 5719 29d4 D001      		movw r26,r0
 5720 29d6 9F9D      		mul r25,r15
 5721 29d8 B00D      		add r27,r0
 5722 29da 1124      		clr __zero_reg__
 5723 29dc A050      		subi r26,lo8(-(bankStates))
 5724 29de B040      		sbci r27,hi8(-(bankStates))
 5725 29e0 95E0      		ldi r25,lo8(5)
 5726 29e2 9C93      		st X,r25
 5727               	.LVL242:
 5728               	.LBB438:
 5729               	.LBB439:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 5730               		.loc 1 1925 0
 5731 29e4 91E0      		ldi r25,lo8(1)
 5732 29e6 1A96      		adiw r26,10
 5733 29e8 9C93      		st X,r25
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 5734               		.loc 1 1948 0
 5735 29ea EE23      		tst r30
 5736 29ec 01F4      		brne .+2
 5737 29ee 00C0      		rjmp .L672
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 5738               		.loc 1 1956 0
 5739 29f0 DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 5740               		.loc 1 1957 0
 5741 29f2 94E0      		ldi r25,lo8(4)
 5742 29f4 9093 6800 		sts 104,r25
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 5743               		.loc 1 1958 0
 5744 29f8 90E1      		ldi r25,lo8(16)
 5745 29fa 9093 6D00 		sts 109,r25
 5746               	.L363:
 5747               	.LBE439:
 5748               	.LBE438:
2071:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 5749               		.loc 1 2071 0
 5750 29fe 94E2      		ldi r25,lo8(36)
 5751 2a00 9E9D      		mul r25,r14
 5752 2a02 F001      		movw r30,r0
 5753 2a04 9F9D      		mul r25,r15
 5754 2a06 F00D      		add r31,r0
 5755 2a08 1124      		clr __zero_reg__
 5756 2a0a E050      		subi r30,lo8(-(bankStates))
 5757 2a0c F040      		sbci r31,hi8(-(bankStates))
 5758 2a0e 91E0      		ldi r25,lo8(1)
 5759 2a10 9583      		std Z+5,r25
2072:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 5760               		.loc 1 2072 0
 5761 2a12 8FBF      		out __SREG__,r24
2075:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 5762               		.loc 1 2075 0
 5763 2a14 8091 7A00 		lds r24,122
 5764               	.LVL243:
 5765 2a18 86FD      		sbrc r24,6
 5766 2a1a 00C0      		rjmp .L648
 5767               	.LBB443:
 5768               	.LBB444:
2077:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 5769               		.loc 1 2077 0
 5770 2a1c 8091 7900 		lds r24,121
 5771 2a20 8058      		subi r24,lo8(-(-128))
 5772 2a22 8093 0000 		sts adcByte,r24
2078:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 5773               		.loc 1 2078 0
 5774 2a26 8091 7A00 		lds r24,122
 5775 2a2a 8064      		ori r24,lo8(64)
 5776 2a2c 8093 7A00 		sts 122,r24
 5777               	.L648:
 5778 2a30 8091 0000 		lds r24,currentBank
 5779               	.LVL244:
 5780               	.L361:
 5781               	.LBE444:
 5782               	.LBE443:
 5783               	.LBE437:
 5784               	.LBE436:
4320:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC
 5785               		.loc 1 4320 0
 5786 2a34 20E3      		ldi r18,lo8(48)
 5787 2a36 49E0      		ldi r20,lo8(9)
 5788 2a38 64E0      		ldi r22,lo8(4)
 5789 2a3a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5790               	.LVL245:
 5791 2a3e 00C0      		rjmp .L322
 5792               	.LVL246:
 5793               	.L663:
4142:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)		// Bail!
 5794               		.loc 1 4142 0
 5795 2a40 8091 0000 		lds r24,newKeys
 5796 2a44 85FD      		sbrc r24,5
 5797 2a46 00C0      		rjmp .L673
4157:WTPA.c        **** 		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
 5798               		.loc 1 4157 0
 5799 2a48 80FF      		sbrs r24,0
 5800 2a4a 00C0      		rjmp .L322
4159:WTPA.c        **** 			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
 5801               		.loc 1 4159 0
 5802 2a4c 8091 0000 		lds r24,cardState
 5803 2a50 8E30      		cpi r24,lo8(14)
 5804 2a52 01F0      		breq .+2
 5805 2a54 00C0      		rjmp .L322
 5806               	.LVL247:
 5807               	.LBB447:
 5808               	.LBB448:
1504:WTPA.c        **** 	State=newState;
 5809               		.loc 1 1504 0
 5810 2a56 80E0      		ldi r24,lo8(gs(SdCardMenu))
 5811 2a58 90E0      		ldi r25,hi8(gs(SdCardMenu))
 5812 2a5a 9093 0000 		sts State+1,r25
 5813 2a5e 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 5814               		.loc 1 1505 0
 5815 2a62 1092 0000 		sts subState,__zero_reg__
 5816 2a66 00C0      		rjmp .L322
 5817               	.LVL248:
 5818               	.L340:
 5819               	.LBE448:
 5820               	.LBE447:
4241:WTPA.c        **** 				bankStates[currentBank].backwardsPlayback=false;
 5821               		.loc 1 4241 0
 5822 2a68 1382      		std Z+3,__zero_reg__
4242:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		/
 5823               		.loc 1 4242 0
 5824 2a6a 20E0      		ldi r18,0
 5825 2a6c 41E1      		ldi r20,lo8(17)
 5826 2a6e 64E0      		ldi r22,lo8(4)
 5827 2a70 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5828               	.LVL249:
 5829 2a74 00C0      		rjmp .L341
 5830               	.L665:
4205:WTPA.c        **** 				switch(scaledEncoderValue)
 5831               		.loc 1 4205 0
 5832 2a76 8091 0000 		lds r24,scaledEncoderValue
 5833 2a7a 8130      		cpi r24,lo8(1)
 5834 2a7c 01F4      		brne .+2
 5835 2a7e 00C0      		rjmp .L337
 5836 2a80 00F0      		brlo .+2
 5837 2a82 00C0      		rjmp .L674
4208:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
 5838               		.loc 1 4208 0
 5839 2a84 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 5840 2a86 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 5841 2a88 9093 0000 		sts UpdateOutput+1,r25
 5842 2a8c 8093 0000 		sts UpdateOutput,r24
4209:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 5843               		.loc 1 4209 0
 5844 2a90 20E0      		ldi r18,0
 5845 2a92 46E1      		ldi r20,lo8(22)
 5846 2a94 64E0      		ldi r22,lo8(4)
 5847 2a96 8091 0000 		lds r24,currentBank
 5848 2a9a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5849               	.LVL250:
 5850 2a9e 00C0      		rjmp .L335
 5851               	.L327:
4187:WTPA.c        **** 				bankStates[currentBank].halfSpeed=false;
 5852               		.loc 1 4187 0
 5853 2aa0 1282      		std Z+2,__zero_reg__
4188:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Se
 5854               		.loc 1 4188 0
 5855 2aa2 20E0      		ldi r18,0
 5856 2aa4 40E1      		ldi r20,lo8(16)
 5857 2aa6 64E0      		ldi r22,lo8(4)
 5858 2aa8 0E94 0000 		call PutMidiMessageInOutgoingFifo
 5859               	.LVL251:
 5860 2aac 8091 0000 		lds r24,newKeys
 5861 2ab0 00C0      		rjmp .L326
 5862               	.L354:
4324:WTPA.c        **** 		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while l
 5863               		.loc 1 4324 0
 5864 2ab2 82FF      		sbrs r24,2
 5865 2ab4 00C0      		rjmp .L365
4326:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 5866               		.loc 1 4326 0
 5867 2ab6 8091 0000 		lds r24,currentBank
 5868 2aba E82F      		mov r30,r24
 5869 2abc F0E0      		ldi r31,0
 5870 2abe 24E2      		ldi r18,lo8(36)
 5871 2ac0 829F      		mul r24,r18
 5872 2ac2 D001      		movw r26,r0
 5873 2ac4 1124      		clr __zero_reg__
 5874 2ac6 A050      		subi r26,lo8(-(bankStates))
 5875 2ac8 B040      		sbci r27,hi8(-(bankStates))
 5876 2aca 5196      		adiw r26,17
 5877 2acc 0D91      		ld r16,X+
 5878 2ace 1D91      		ld r17,X+
 5879 2ad0 2D91      		ld r18,X+
 5880 2ad2 3C91      		ld r19,X
 5881 2ad4 5497      		sbiw r26,17+3
 5882 2ad6 1D96      		adiw r26,13
 5883 2ad8 4D91      		ld r20,X+
 5884 2ada 5D91      		ld r21,X+
 5885 2adc 6D91      		ld r22,X+
 5886 2ade 7C91      		ld r23,X
 5887 2ae0 5097      		sbiw r26,13+3
 5888 2ae2 0417      		cp r16,r20
 5889 2ae4 1507      		cpc r17,r21
 5890 2ae6 2607      		cpc r18,r22
 5891 2ae8 3707      		cpc r19,r23
 5892 2aea 01F4      		brne .+2
 5893 2aec 00C0      		rjmp .L322
 5894               	.LVL252:
 5895               	.LBB449:
 5896               	.LBB450:
2012:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 5897               		.loc 1 2012 0
 5898 2aee 1596      		adiw r26, 5
 5899 2af0 9C91      		ld r25,X
 5900 2af2 9923      		tst r25
 5901 2af4 01F0      		breq .L366
 5902 2af6 9091 0000 		lds r25,sdIsrState
 5903 2afa 9150      		subi r25,lo8(-(-1))
 5904 2afc 9230      		cpi r25,lo8(2)
 5905 2afe 00F4      		brsh .+2
 5906 2b00 00C0      		rjmp .L367
 5907               	.L366:
2014:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 5908               		.loc 1 2014 0
 5909 2b02 9FB7      		in r25,__SREG__
 5910               	.LVL253:
2015:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 5911               		.loc 1 2015 0
 5912               	/* #APP */
 5913               	 ;  2015 "WTPA.c" 1
 5914 2b04 F894      		cli
 5915               	 ;  0 "" 2
2017:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 5916               		.loc 1 2017 0
 5917               	/* #NOAPP */
 5918 2b06 24E2      		ldi r18,lo8(36)
 5919 2b08 2E9F      		mul r18,r30
 5920 2b0a D001      		movw r26,r0
 5921 2b0c 2F9F      		mul r18,r31
 5922 2b0e B00D      		add r27,r0
 5923 2b10 1124      		clr __zero_reg__
 5924 2b12 A050      		subi r26,lo8(-(bankStates))
 5925 2b14 B040      		sbci r27,hi8(-(bankStates))
 5926 2b16 24E0      		ldi r18,lo8(4)
 5927 2b18 2C93      		st X,r18
2019:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 5928               		.loc 1 2019 0
 5929 2b1a 1396      		adiw r26, 3
 5930 2b1c 2C91      		ld r18,X
 5931 2b1e 1397      		sbiw r26, 3
 5932 2b20 2223      		tst r18
 5933 2b22 01F4      		brne .+2
 5934 2b24 00C0      		rjmp .L368
2021:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 5935               		.loc 1 2021 0
 5936 2b26 5596      		adiw r26,21
 5937 2b28 4D91      		ld r20,X+
 5938 2b2a 5D91      		ld r21,X+
 5939 2b2c 6D91      		ld r22,X+
 5940 2b2e 7C91      		ld r23,X
 5941 2b30 5897      		sbiw r26,21+3
 5942 2b32 9096      		adiw r26,32
 5943 2b34 4D93      		st X+,r20
 5944 2b36 5D93      		st X+,r21
 5945 2b38 6D93      		st X+,r22
 5946 2b3a 7C93      		st X,r23
 5947 2b3c 9397      		sbiw r26,32+3
2022:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 5948               		.loc 1 2022 0
 5949 2b3e 1496      		adiw r26,4
 5950 2b40 1C92      		st X,__zero_reg__
 5951               	.L369:
 5952               	.LVL254:
 5953               	.LBB451:
 5954               	.LBB452:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 5955               		.loc 1 1925 0
 5956 2b42 24E2      		ldi r18,lo8(36)
 5957 2b44 2E9F      		mul r18,r30
 5958 2b46 D001      		movw r26,r0
 5959 2b48 2F9F      		mul r18,r31
 5960 2b4a B00D      		add r27,r0
 5961 2b4c 1124      		clr __zero_reg__
 5962 2b4e A050      		subi r26,lo8(-(bankStates))
 5963 2b50 B040      		sbci r27,hi8(-(bankStates))
 5964 2b52 21E0      		ldi r18,lo8(1)
 5965 2b54 1A96      		adiw r26,10
 5966 2b56 2C93      		st X,r18
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 5967               		.loc 1 1948 0
 5968 2b58 8823      		tst r24
 5969 2b5a 01F4      		brne .+2
 5970 2b5c 00C0      		rjmp .L675
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 5971               		.loc 1 1956 0
 5972 2b5e DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 5973               		.loc 1 1957 0
 5974 2b60 84E0      		ldi r24,lo8(4)
 5975               	.LVL255:
 5976 2b62 8093 6800 		sts 104,r24
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 5977               		.loc 1 1958 0
 5978 2b66 80E1      		ldi r24,lo8(16)
 5979 2b68 8093 6D00 		sts 109,r24
 5980               	.L371:
 5981               	.LBE452:
 5982               	.LBE451:
2031:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 5983               		.loc 1 2031 0
 5984 2b6c 84E2      		ldi r24,lo8(36)
 5985 2b6e 8E9F      		mul r24,r30
 5986 2b70 D001      		movw r26,r0
 5987 2b72 8F9F      		mul r24,r31
 5988 2b74 B00D      		add r27,r0
 5989 2b76 1124      		clr __zero_reg__
 5990 2b78 A050      		subi r26,lo8(-(bankStates))
 5991 2b7a B040      		sbci r27,hi8(-(bankStates))
 5992 2b7c 81E0      		ldi r24,lo8(1)
 5993 2b7e 1596      		adiw r26,5
 5994 2b80 8C93      		st X,r24
2032:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 5995               		.loc 1 2032 0
 5996 2b82 9FBF      		out __SREG__,r25
 5997 2b84 8091 0000 		lds r24,currentBank
 5998 2b88 E82F      		mov r30,r24
 5999               	.LVL256:
 6000 2b8a F0E0      		ldi r31,0
 6001               	.LVL257:
 6002               	.L367:
 6003               	.LBE450:
 6004               	.LBE449:
4329:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6005               		.loc 1 4329 0
 6006 2b8c 94E2      		ldi r25,lo8(36)
 6007 2b8e 9E9F      		mul r25,r30
 6008 2b90 D001      		movw r26,r0
 6009 2b92 9F9F      		mul r25,r31
 6010 2b94 B00D      		add r27,r0
 6011 2b96 1124      		clr __zero_reg__
 6012 2b98 A050      		subi r26,lo8(-(bankStates))
 6013 2b9a B040      		sbci r27,hi8(-(bankStates))
 6014 2b9c 1196      		adiw r26,1
 6015 2b9e 1C92      		st X,__zero_reg__
4330:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6016               		.loc 1 4330 0
 6017 2ba0 20E4      		ldi r18,lo8(64)
 6018 2ba2 40E3      		ldi r20,lo8(48)
 6019 2ba4 61E0      		ldi r22,lo8(1)
 6020 2ba6 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6021               	.LVL258:
 6022 2baa 00C0      		rjmp .L322
 6023               	.LVL259:
 6024               	.L670:
 6025               	.LBB459:
 6026               	.LBB460:
2012:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 6027               		.loc 1 2012 0
 6028 2bac 8581      		ldd r24,Z+5
 6029 2bae 8823      		tst r24
 6030 2bb0 01F0      		breq .L348
 6031 2bb2 8091 0000 		lds r24,sdIsrState
 6032 2bb6 8150      		subi r24,lo8(-(-1))
 6033 2bb8 8230      		cpi r24,lo8(2)
 6034 2bba 00F0      		brlo .L349
 6035               	.L348:
2014:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 6036               		.loc 1 2014 0
 6037 2bbc 8FB7      		in r24,__SREG__
 6038               	.LVL260:
2015:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 6039               		.loc 1 2015 0
 6040               	/* #APP */
 6041               	 ;  2015 "WTPA.c" 1
 6042 2bbe F894      		cli
 6043               	 ;  0 "" 2
2017:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 6044               		.loc 1 2017 0
 6045               	/* #NOAPP */
 6046 2bc0 94E2      		ldi r25,lo8(36)
 6047 2bc2 929F      		mul r25,r18
 6048 2bc4 F001      		movw r30,r0
 6049 2bc6 939F      		mul r25,r19
 6050 2bc8 F00D      		add r31,r0
 6051 2bca 1124      		clr __zero_reg__
 6052 2bcc E050      		subi r30,lo8(-(bankStates))
 6053 2bce F040      		sbci r31,hi8(-(bankStates))
 6054 2bd0 94E0      		ldi r25,lo8(4)
 6055 2bd2 9083      		st Z,r25
2019:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 6056               		.loc 1 2019 0
 6057 2bd4 9381      		ldd r25,Z+3
 6058 2bd6 9923      		tst r25
 6059 2bd8 01F4      		brne .+2
 6060 2bda 00C0      		rjmp .L350
2021:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 6061               		.loc 1 2021 0
 6062 2bdc 4589      		ldd r20,Z+21
 6063 2bde 5689      		ldd r21,Z+22
 6064 2be0 6789      		ldd r22,Z+23
 6065 2be2 708D      		ldd r23,Z+24
 6066 2be4 40A3      		std Z+32,r20
 6067 2be6 51A3      		std Z+33,r21
 6068 2be8 62A3      		std Z+34,r22
 6069 2bea 73A3      		std Z+35,r23
2022:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 6070               		.loc 1 2022 0
 6071 2bec 1482      		std Z+4,__zero_reg__
 6072               	.L351:
 6073               	.LVL261:
 6074               	.LBB461:
 6075               	.LBB462:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 6076               		.loc 1 1925 0
 6077 2bee 94E2      		ldi r25,lo8(36)
 6078 2bf0 929F      		mul r25,r18
 6079 2bf2 F001      		movw r30,r0
 6080 2bf4 939F      		mul r25,r19
 6081 2bf6 F00D      		add r31,r0
 6082 2bf8 1124      		clr __zero_reg__
 6083 2bfa E050      		subi r30,lo8(-(bankStates))
 6084 2bfc F040      		sbci r31,hi8(-(bankStates))
 6085 2bfe 91E0      		ldi r25,lo8(1)
 6086 2c00 9287      		std Z+10,r25
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 6087               		.loc 1 1948 0
 6088 2c02 1123      		tst r17
 6089 2c04 01F4      		brne .+2
 6090 2c06 00C0      		rjmp .L676
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 6091               		.loc 1 1956 0
 6092 2c08 DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 6093               		.loc 1 1957 0
 6094 2c0a 94E0      		ldi r25,lo8(4)
 6095 2c0c 9093 6800 		sts 104,r25
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 6096               		.loc 1 1958 0
 6097 2c10 90E1      		ldi r25,lo8(16)
 6098 2c12 9093 6D00 		sts 109,r25
 6099               	.L353:
 6100               	.LBE462:
 6101               	.LBE461:
2031:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 6102               		.loc 1 2031 0
 6103 2c16 94E2      		ldi r25,lo8(36)
 6104 2c18 929F      		mul r25,r18
 6105 2c1a F001      		movw r30,r0
 6106 2c1c 939F      		mul r25,r19
 6107 2c1e F00D      		add r31,r0
 6108 2c20 1124      		clr __zero_reg__
 6109 2c22 E050      		subi r30,lo8(-(bankStates))
 6110 2c24 F040      		sbci r31,hi8(-(bankStates))
 6111 2c26 91E0      		ldi r25,lo8(1)
 6112 2c28 9583      		std Z+5,r25
2032:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 6113               		.loc 1 2032 0
 6114 2c2a 8FBF      		out __SREG__,r24
 6115 2c2c 1091 0000 		lds r17,currentBank
 6116               	.LVL262:
 6117 2c30 212F      		mov r18,r17
 6118               	.LVL263:
 6119 2c32 30E0      		ldi r19,0
 6120               	.LVL264:
 6121               	.L349:
 6122               	.LBE460:
 6123               	.LBE459:
4298:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 6124               		.loc 1 4298 0
 6125 2c34 84E2      		ldi r24,lo8(36)
 6126 2c36 829F      		mul r24,r18
 6127 2c38 F001      		movw r30,r0
 6128 2c3a 839F      		mul r24,r19
 6129 2c3c F00D      		add r31,r0
 6130 2c3e 1124      		clr __zero_reg__
 6131 2c40 E050      		subi r30,lo8(-(bankStates))
 6132 2c42 F040      		sbci r31,hi8(-(bankStates))
 6133 2c44 1182      		std Z+1,__zero_reg__
4299:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 6134               		.loc 1 4299 0
 6135 2c46 20E4      		ldi r18,lo8(64)
 6136 2c48 40E3      		ldi r20,lo8(48)
 6137 2c4a 61E0      		ldi r22,lo8(1)
 6138 2c4c 812F      		mov r24,r17
 6139 2c4e 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6140               	.LVL265:
 6141 2c52 00C0      		rjmp .L322
 6142               	.LVL266:
 6143               	.L673:
4144:WTPA.c        **** 			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination
 6144               		.loc 1 4144 0
 6145 2c54 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6146 2c56 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6147 2c58 9093 0000 		sts UpdateOutput+1,r25
 6148 2c5c 8093 0000 		sts UpdateOutput,r24
4145:WTPA.c        **** 			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
 6149               		.loc 1 4145 0
 6150 2c60 E091 0000 		lds r30,currentBank
 6151               	.LVL267:
 6152               	.LBB469:
 6153               	.LBB470:
3957:WTPA.c        **** 	sreg=SREG;
 6154               		.loc 1 3957 0
 6155 2c64 3FB7      		in r19,__SREG__
 6156               	.LVL268:
3958:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 6157               		.loc 1 3958 0
 6158               	/* #APP */
 6159               	 ;  3958 "WTPA.c" 1
 6160 2c66 F894      		cli
 6161               	 ;  0 "" 2
3960:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 6162               		.loc 1 3960 0
 6163               	/* #NOAPP */
 6164 2c68 24E2      		ldi r18,lo8(36)
 6165 2c6a 2E9F      		mul r18,r30
 6166 2c6c F001      		movw r30,r0
 6167 2c6e 1124      		clr __zero_reg__
 6168               	.LVL269:
 6169 2c70 E050      		subi r30,lo8(-(bankStates))
 6170 2c72 F040      		sbci r31,hi8(-(bankStates))
 6171 2c74 8189      		ldd r24,Z+17
 6172 2c76 9289      		ldd r25,Z+18
 6173 2c78 A389      		ldd r26,Z+19
 6174 2c7a B489      		ldd r27,Z+20
 6175 2c7c 818F      		std Z+25,r24
 6176 2c7e 928F      		std Z+26,r25
 6177 2c80 A38F      		std Z+27,r26
 6178 2c82 B48F      		std Z+28,r27
3961:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 6179               		.loc 1 3961 0
 6180 2c84 8585      		ldd r24,Z+13
 6181 2c86 9685      		ldd r25,Z+14
 6182 2c88 A785      		ldd r26,Z+15
 6183 2c8a B089      		ldd r27,Z+16
 6184 2c8c 858B      		std Z+21,r24
 6185 2c8e 968B      		std Z+22,r25
 6186 2c90 A78B      		std Z+23,r26
 6187 2c92 B08F      		std Z+24,r27
3962:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 6188               		.loc 1 3962 0
 6189 2c94 158E      		std Z+29,__zero_reg__
3963:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 6190               		.loc 1 3963 0
 6191 2c96 168E      		std Z+30,__zero_reg__
3964:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 6192               		.loc 1 3964 0
 6193 2c98 178E      		std Z+31,__zero_reg__
3965:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 6194               		.loc 1 3965 0
 6195 2c9a 3FBF      		out __SREG__,r19
 6196               	.LBE470:
 6197               	.LBE469:
4146:WTPA.c        **** 			bankStates[currentBank].bitReduction=0;			// No crusties yet.
 6198               		.loc 1 4146 0
 6199 2c9c 8091 0000 		lds r24,currentBank
 6200 2ca0 289F      		mul r18,r24
 6201 2ca2 F001      		movw r30,r0
 6202 2ca4 1124      		clr __zero_reg__
 6203 2ca6 E050      		subi r30,lo8(-(bankStates))
 6204 2ca8 F040      		sbci r31,hi8(-(bankStates))
 6205 2caa 1186      		std Z+9,__zero_reg__
4147:WTPA.c        **** 			bankStates[currentBank].jitterValue=0;			// No hissies yet.
 6206               		.loc 1 4147 0
 6207 2cac 1086      		std Z+8,__zero_reg__
4148:WTPA.c        **** 			bankStates[currentBank].granularSlices=0;		// No remix yet.
 6208               		.loc 1 4148 0
 6209 2cae 1782      		std Z+7,__zero_reg__
4149:WTPA.c        **** 			bankStates[currentBank].halfSpeed=false;
 6210               		.loc 1 4149 0
 6211 2cb0 1282      		std Z+2,__zero_reg__
4150:WTPA.c        **** 			bankStates[currentBank].backwardsPlayback=false;
 6212               		.loc 1 4150 0
 6213 2cb2 1382      		std Z+3,__zero_reg__
4151:WTPA.c        **** 			bankStates[currentBank].sampleDirection=true;
 6214               		.loc 1 4151 0
 6215 2cb4 91E0      		ldi r25,lo8(1)
 6216 2cb6 9483      		std Z+4,r25
4152:WTPA.c        **** 			bankStates[currentBank].loopOnce=false;
 6217               		.loc 1 4152 0
 6218 2cb8 1182      		std Z+1,__zero_reg__
4153:WTPA.c        **** 			bankStates[currentBank].realtimeOn=false;
 6219               		.loc 1 4153 0
 6220 2cba 1682      		std Z+6,__zero_reg__
4154:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			/
 6221               		.loc 1 4154 0
 6222 2cbc 20E0      		ldi r18,0
 6223 2cbe 42E1      		ldi r20,lo8(18)
 6224 2cc0 64E0      		ldi r22,lo8(4)
 6225 2cc2 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6226               	.LVL270:
4155:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,
 6227               		.loc 1 4155 0
 6228 2cc6 20E0      		ldi r18,0
 6229 2cc8 4BE1      		ldi r20,lo8(27)
 6230 2cca 64E0      		ldi r22,lo8(4)
 6231 2ccc 8091 0000 		lds r24,currentBank
 6232 2cd0 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6233               	.LVL271:
 6234 2cd4 00C0      		rjmp .L322
 6235               	.L664:
4193:WTPA.c        **** 			StartRealtime(currentBank,CLK_EXTERNAL,0);
 6236               		.loc 1 4193 0
 6237 2cd6 8091 0000 		lds r24,currentBank
 6238               	.LVL272:
 6239               	.LBB471:
 6240               	.LBB472:
2091:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 6241               		.loc 1 2091 0
 6242 2cda 9FB7      		in r25,__SREG__
 6243               	.LVL273:
2092:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 6244               		.loc 1 2092 0
 6245               	/* #APP */
 6246               	 ;  2092 "WTPA.c" 1
 6247 2cdc F894      		cli
 6248               	 ;  0 "" 2
2094:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 6249               		.loc 1 2094 0
 6250               	/* #NOAPP */
 6251 2cde A4E2      		ldi r26,lo8(36)
 6252 2ce0 8A9F      		mul r24,r26
 6253 2ce2 F001      		movw r30,r0
 6254 2ce4 1124      		clr __zero_reg__
 6255 2ce6 E050      		subi r30,lo8(-(bankStates))
 6256 2ce8 F040      		sbci r31,hi8(-(bankStates))
 6257 2cea 22E0      		ldi r18,lo8(2)
 6258 2cec 2083      		st Z,r18
 6259               	.LVL274:
 6260               	.LBB473:
 6261               	.LBB474:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 6262               		.loc 1 1925 0
 6263 2cee 21E0      		ldi r18,lo8(1)
 6264 2cf0 2287      		std Z+10,r18
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 6265               		.loc 1 1948 0
 6266 2cf2 8823      		tst r24
 6267 2cf4 01F4      		brne .+2
 6268 2cf6 00C0      		rjmp .L677
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 6269               		.loc 1 1956 0
 6270 2cf8 DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 6271               		.loc 1 1957 0
 6272 2cfa 84E0      		ldi r24,lo8(4)
 6273               	.LVL275:
 6274 2cfc 8093 6800 		sts 104,r24
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 6275               		.loc 1 1958 0
 6276 2d00 80E1      		ldi r24,lo8(16)
 6277 2d02 8093 6D00 		sts 109,r24
 6278               	.L330:
 6279               	.LBE474:
 6280               	.LBE473:
2097:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 6281               		.loc 1 2097 0
 6282 2d06 9FBF      		out __SREG__,r25
2099:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 6283               		.loc 1 2099 0
 6284 2d08 8091 7A00 		lds r24,122
 6285 2d0c 86FD      		sbrc r24,6
 6286 2d0e 00C0      		rjmp .L331
 6287               	.LBB478:
 6288               	.LBB479:
2101:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 6289               		.loc 1 2101 0
 6290 2d10 8091 7900 		lds r24,121
 6291 2d14 8058      		subi r24,lo8(-(-128))
 6292 2d16 8093 0000 		sts adcByte,r24
2102:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 6293               		.loc 1 2102 0
 6294 2d1a 8091 7A00 		lds r24,122
 6295 2d1e 8064      		ori r24,lo8(64)
 6296 2d20 8093 7A00 		sts 122,r24
 6297               	.L331:
 6298               	.LBE479:
 6299               	.LBE478:
 6300               	.LBE472:
 6301               	.LBE471:
4194:WTPA.c        **** 			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_
 6302               		.loc 1 4194 0
 6303 2d24 20E3      		ldi r18,lo8(48)
 6304 2d26 4EE0      		ldi r20,lo8(14)
 6305 2d28 64E0      		ldi r22,lo8(4)
 6306 2d2a 8091 0000 		lds r24,currentBank
 6307 2d2e 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6308               	.LVL276:
 6309 2d32 00C0      		rjmp .L328
 6310               	.LVL277:
 6311               	.L669:
4253:WTPA.c        **** 		if(keyState&Im_SWITCH_0)		// Adjust sample start
 6312               		.loc 1 4253 0
 6313 2d34 8091 0000 		lds r24,keyState
 6314 2d38 80FF      		sbrs r24,0
 6315 2d3a 00C0      		rjmp .L343
4255:WTPA.c        **** 			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we ha
 6316               		.loc 1 4255 0
 6317 2d3c 1091 0000 		lds r17,currentBank
 6318 2d40 24E2      		ldi r18,lo8(36)
 6319 2d42 129F      		mul r17,r18
 6320 2d44 F001      		movw r30,r0
 6321 2d46 1124      		clr __zero_reg__
 6322 2d48 E050      		subi r30,lo8(-(bankStates))
 6323 2d4a F040      		sbci r31,hi8(-(bankStates))
 6324 2d4c 858D      		ldd r24,Z+29
 6325 2d4e 0091 0000 		lds r16,encoderValue
 6326 2d52 8017      		cp r24,r16
 6327 2d54 01F0      		breq .L344
 6328               	.LVL278:
 6329               	.LBB482:
 6330               	.LBB483:
3973:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6331               		.loc 1 3973 0
 6332 2d56 058F      		std Z+29,r16
3974:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6333               		.loc 1 3974 0
 6334 2d58 812F      		mov r24,r17
 6335 2d5a 0E94 0000 		call UpdateAdjustedSampleAddresses
 6336               	.LVL279:
 6337               	.LBE483:
 6338               	.LBE482:
4258:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_W
 6339               		.loc 1 4258 0
 6340 2d5e 202F      		mov r18,r16
 6341 2d60 2695      		lsr r18
 6342 2d62 4CE1      		ldi r20,lo8(28)
 6343 2d64 64E0      		ldi r22,lo8(4)
 6344 2d66 812F      		mov r24,r17
 6345 2d68 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6346               	.LVL280:
 6347               	.L344:
 6348               	.LBE528:
4278:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
 6349               		.loc 1 4278 0
 6350 2d6c 8091 0000 		lds r24,newKeys
 6351               	.LBB529:
 6352 2d70 83FF      		sbrs r24,3
 6353 2d72 00C0      		rjmp .L322
4280:WTPA.c        **** 			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
 6354               		.loc 1 4280 0
 6355 2d74 8091 0000 		lds r24,sdCurrentSlot
 6356 2d78 9091 0000 		lds r25,sdCurrentSlot+1
 6357 2d7c 0E94 0000 		call PlaySampleFromSd
 6358               	.LVL281:
 6359 2d80 00C0      		rjmp .L322
 6360               	.L666:
 6361               	.LBE529:
 6362               	.LBE540:
4409:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6363               		.loc 1 4409 0
 6364 2d82 E091 0000 		lds r30,currentMidiMessage.2230
 6365 2d86 8E2F      		mov r24,r30
 6366 2d88 90E0      		ldi r25,0
 6367 2d8a 34E2      		ldi r19,lo8(36)
 6368 2d8c E39F      		mul r30,r19
 6369 2d8e F001      		movw r30,r0
 6370 2d90 1124      		clr __zero_reg__
 6371 2d92 E050      		subi r30,lo8(-(bankStates))
 6372 2d94 F040      		sbci r31,hi8(-(bankStates))
 6373 2d96 2081      		ld r18,Z
 6374 2d98 2430      		cpi r18,lo8(4)
 6375 2d9a 01F0      		breq .L387
4409:WTPA.c        **** 				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[cu
 6376               		.loc 1 4409 0 is_stmt 0 discriminator 1
 6377 2d9c 2081      		ld r18,Z
 6378 2d9e 2230      		cpi r18,lo8(2)
 6379 2da0 01F0      		breq .+2
 6380 2da2 00C0      		rjmp .L650
 6381               	.L387:
4411:WTPA.c        **** 					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampl
 6382               		.loc 1 4411 0 is_stmt 1
 6383 2da4 FC01      		movw r30,r24
 6384 2da6 E050      		subi r30,lo8(-(currentNoteOn.2231))
 6385 2da8 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 6386 2daa 3091 0000 		lds r19,currentMidiMessage.2230+2
 6387 2dae 2081      		ld r18,Z
 6388 2db0 3213      		cpse r19,r18
 6389 2db2 00C0      		rjmp .L650
4413:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in th
 6390               		.loc 1 4413 0
 6391 2db4 24E2      		ldi r18,lo8(36)
 6392 2db6 289F      		mul r18,r24
 6393 2db8 F001      		movw r30,r0
 6394 2dba 299F      		mul r18,r25
 6395 2dbc F00D      		add r31,r0
 6396 2dbe 1124      		clr __zero_reg__
 6397 2dc0 E050      		subi r30,lo8(-(bankStates))
 6398 2dc2 F040      		sbci r31,hi8(-(bankStates))
 6399 2dc4 1082      		st Z,__zero_reg__
4414:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
 6400               		.loc 1 4414 0
 6401 2dc6 1286      		std Z+10,__zero_reg__
 6402 2dc8 6091 0000 		lds r22,sdIsrState
 6403 2dcc 00C0      		rjmp .L318
 6404               	.L667:
4420:WTPA.c        **** 				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is ou
 6405               		.loc 1 4420 0
 6406 2dce 1091 0000 		lds r17,currentMidiMessage.2230
 6407 2dd2 212F      		mov r18,r17
 6408 2dd4 30E0      		ldi r19,0
 6409 2dd6 0091 0000 		lds r16,currentMidiMessage.2230+2
 6410 2dda F901      		movw r30,r18
 6411 2ddc E050      		subi r30,lo8(-(currentNoteOn.2231))
 6412 2dde F040      		sbci r31,hi8(-(currentNoteOn.2231))
 6413 2de0 0083      		st Z,r16
4422:WTPA.c        **** 				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
 6414               		.loc 1 4422 0
 6415 2de2 84E2      		ldi r24,lo8(36)
 6416 2de4 829F      		mul r24,r18
 6417 2de6 F001      		movw r30,r0
 6418 2de8 839F      		mul r24,r19
 6419 2dea F00D      		add r31,r0
 6420 2dec 1124      		clr __zero_reg__
 6421 2dee E050      		subi r30,lo8(-(bankStates))
 6422 2df0 F040      		sbci r31,hi8(-(bankStates))
 6423 2df2 8681      		ldd r24,Z+6
 6424 2df4 8111      		cpse r24,__zero_reg__
 6425 2df6 00C0      		rjmp .L678
4428:WTPA.c        **** 					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.ch
 6426               		.loc 1 4428 0
 6427 2df8 4189      		ldd r20,Z+17
 6428 2dfa 5289      		ldd r21,Z+18
 6429 2dfc 6389      		ldd r22,Z+19
 6430 2dfe 7489      		ldd r23,Z+20
 6431 2e00 8585      		ldd r24,Z+13
 6432 2e02 9685      		ldd r25,Z+14
 6433 2e04 A785      		ldd r26,Z+15
 6434 2e06 B089      		ldd r27,Z+16
 6435 2e08 4817      		cp r20,r24
 6436 2e0a 5907      		cpc r21,r25
 6437 2e0c 6A07      		cpc r22,r26
 6438 2e0e 7B07      		cpc r23,r27
 6439 2e10 01F4      		brne .+2
 6440 2e12 00C0      		rjmp .L650
 6441               	.LVL282:
 6442               	.LBB541:
 6443               	.LBB542:
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6444               		.loc 1 3409 0
 6445 2e14 8BEA      		ldi r24,lo8(-85)
 6446 2e16 089F      		mul r16,r24
 6447 2e18 812D      		mov r24,r1
 6448 2e1a 1124      		clr __zero_reg__
 6449 2e1c 8695      		lsr r24
 6450 2e1e 8695      		lsr r24
 6451 2e20 8695      		lsr r24
 6452 2e22 982F      		mov r25,r24
 6453 2e24 990F      		lsl r25
 6454 2e26 980F      		add r25,r24
 6455 2e28 990F      		lsl r25
 6456 2e2a 990F      		lsl r25
 6457 2e2c 091B      		sub r16,r25
 6458               	.LVL283:
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6459               		.loc 1 3411 0
 6460 2e2e A02F      		mov r26,r16
 6461 2e30 B0E0      		ldi r27,0
 6462 2e32 AA0F      		lsl r26
 6463 2e34 BB1F      		rol r27
 6464 2e36 A050      		subi r26,lo8(-(OctaveZeroCompareMatches))
 6465 2e38 B040      		sbci r27,hi8(-(OctaveZeroCompareMatches))
 6466 2e3a 4D91      		ld r20,X+
 6467 2e3c 5C91      		ld r21,X
 6468 2e3e 00C0      		rjmp 2f
 6469               		1:
 6470 2e40 5695      		lsr r21
 6471 2e42 4795      		ror r20
 6472               		2:
 6473 2e44 8A95      		dec r24
 6474 2e46 02F4      		brpl 1b
 6475               	.LVL284:
 6476               	.LBE542:
 6477               	.LBE541:
 6478               	.LBB543:
 6479               	.LBB544:
2012:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 6480               		.loc 1 2012 0
 6481 2e48 8581      		ldd r24,Z+5
 6482 2e4a 8823      		tst r24
 6483 2e4c 01F0      		breq .L395
 6484 2e4e 6091 0000 		lds r22,sdIsrState
 6485 2e52 862F      		mov r24,r22
 6486 2e54 8150      		subi r24,lo8(-(-1))
 6487 2e56 8230      		cpi r24,lo8(2)
 6488 2e58 00F4      		brsh .+2
 6489 2e5a 00C0      		rjmp .L491
 6490               	.L395:
2014:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 6491               		.loc 1 2014 0
 6492 2e5c 6FB7      		in r22,__SREG__
 6493               	.LVL285:
2015:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 6494               		.loc 1 2015 0
 6495               	/* #APP */
 6496               	 ;  2015 "WTPA.c" 1
 6497 2e5e F894      		cli
 6498               	 ;  0 "" 2
2017:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 6499               		.loc 1 2017 0
 6500               	/* #NOAPP */
 6501 2e60 84E2      		ldi r24,lo8(36)
 6502 2e62 829F      		mul r24,r18
 6503 2e64 F001      		movw r30,r0
 6504 2e66 839F      		mul r24,r19
 6505 2e68 F00D      		add r31,r0
 6506 2e6a 1124      		clr __zero_reg__
 6507 2e6c E050      		subi r30,lo8(-(bankStates))
 6508 2e6e F040      		sbci r31,hi8(-(bankStates))
 6509 2e70 84E0      		ldi r24,lo8(4)
 6510 2e72 8083      		st Z,r24
2019:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 6511               		.loc 1 2019 0
 6512 2e74 8381      		ldd r24,Z+3
 6513 2e76 8823      		tst r24
 6514 2e78 01F4      		brne .+2
 6515 2e7a 00C0      		rjmp .L397
2021:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 6516               		.loc 1 2021 0
 6517 2e7c 8589      		ldd r24,Z+21
 6518 2e7e 9689      		ldd r25,Z+22
 6519 2e80 A789      		ldd r26,Z+23
 6520 2e82 B08D      		ldd r27,Z+24
 6521 2e84 80A3      		std Z+32,r24
 6522 2e86 91A3      		std Z+33,r25
 6523 2e88 A2A3      		std Z+34,r26
 6524 2e8a B3A3      		std Z+35,r27
2022:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 6525               		.loc 1 2022 0
 6526 2e8c 1482      		std Z+4,__zero_reg__
 6527               	.L398:
 6528               	.LVL286:
 6529               	.LBB545:
 6530               	.LBB546:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 6531               		.loc 1 1925 0
 6532 2e8e 84E2      		ldi r24,lo8(36)
 6533 2e90 829F      		mul r24,r18
 6534 2e92 F001      		movw r30,r0
 6535 2e94 839F      		mul r24,r19
 6536 2e96 F00D      		add r31,r0
 6537 2e98 1124      		clr __zero_reg__
 6538 2e9a E050      		subi r30,lo8(-(bankStates))
 6539 2e9c F040      		sbci r31,hi8(-(bankStates))
 6540 2e9e 82E0      		ldi r24,lo8(2)
 6541 2ea0 8287      		std Z+10,r24
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 6542               		.loc 1 1929 0
 6543 2ea2 5487      		std Z+12,r21
 6544 2ea4 4387      		std Z+11,r20
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 6545               		.loc 1 1933 0
 6546 2ea6 8091 8400 		lds r24,132
 6547 2eaa 9091 8500 		lds r25,132+1
 6548 2eae 840F      		add r24,r20
 6549 2eb0 951F      		adc r25,r21
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 6550               		.loc 1 1931 0
 6551 2eb2 1111      		cpse r17,__zero_reg__
 6552 2eb4 00C0      		rjmp .L399
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 6553               		.loc 1 1933 0
 6554 2eb6 9093 8900 		sts 136+1,r25
 6555 2eba 8093 8800 		sts 136,r24
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 6556               		.loc 1 1934 0
 6557 2ebe B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 6558               		.loc 1 1935 0
 6559 2ec0 8091 6F00 		lds r24,111
 6560 2ec4 8260      		ori r24,lo8(2)
 6561 2ec6 8093 6F00 		sts 111,r24
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 6562               		.loc 1 1936 0
 6563 2eca 81E0      		ldi r24,lo8(1)
 6564 2ecc 8093 8100 		sts 129,r24
 6565               	.L400:
 6566               	.LBE546:
 6567               	.LBE545:
2031:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 6568               		.loc 1 2031 0
 6569 2ed0 84E2      		ldi r24,lo8(36)
 6570 2ed2 829F      		mul r24,r18
 6571 2ed4 F001      		movw r30,r0
 6572 2ed6 839F      		mul r24,r19
 6573 2ed8 F00D      		add r31,r0
 6574 2eda 1124      		clr __zero_reg__
 6575               	.LVL287:
 6576               	.L651:
 6577               	.LBE544:
 6578               	.LBE543:
 6579               	.LBB550:
 6580               	.LBB551:
2051:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 6581               		.loc 1 2051 0
 6582 2edc E050      		subi r30,lo8(-(bankStates))
 6583 2ede F040      		sbci r31,hi8(-(bankStates))
 6584 2ee0 81E0      		ldi r24,lo8(1)
 6585 2ee2 8583      		std Z+5,r24
2052:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 6586               		.loc 1 2052 0
 6587 2ee4 6FBF      		out __SREG__,r22
 6588 2ee6 6091 0000 		lds r22,sdIsrState
 6589 2eea 00C0      		rjmp .L318
 6590               	.L343:
 6591               	.LBE551:
 6592               	.LBE550:
 6593               	.LBB558:
 6594               	.LBB530:
4261:WTPA.c        **** 		else if(keyState&Im_SWITCH_1)		// Adjust sample end
 6595               		.loc 1 4261 0
 6596 2eec 81FF      		sbrs r24,1
 6597 2eee 00C0      		rjmp .L345
4263:WTPA.c        **** 			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have
 6598               		.loc 1 4263 0
 6599 2ef0 1091 0000 		lds r17,currentBank
 6600 2ef4 34E2      		ldi r19,lo8(36)
 6601 2ef6 139F      		mul r17,r19
 6602 2ef8 F001      		movw r30,r0
 6603 2efa 1124      		clr __zero_reg__
 6604 2efc E050      		subi r30,lo8(-(bankStates))
 6605 2efe F040      		sbci r31,hi8(-(bankStates))
 6606 2f00 868D      		ldd r24,Z+30
 6607 2f02 0091 0000 		lds r16,encoderValue
 6608 2f06 8017      		cp r24,r16
 6609 2f08 01F4      		brne .+2
 6610 2f0a 00C0      		rjmp .L344
 6611               	.LVL288:
 6612               	.LBB484:
 6613               	.LBB485:
3982:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6614               		.loc 1 3982 0
 6615 2f0c 068F      		std Z+30,r16
3983:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6616               		.loc 1 3983 0
 6617 2f0e 812F      		mov r24,r17
 6618 2f10 0E94 0000 		call UpdateAdjustedSampleAddresses
 6619               	.LVL289:
 6620               	.LBE485:
 6621               	.LBE484:
4266:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WID
 6622               		.loc 1 4266 0
 6623 2f14 202F      		mov r18,r16
 6624 2f16 2695      		lsr r18
 6625 2f18 4DE1      		ldi r20,lo8(29)
 6626 2f1a 64E0      		ldi r22,lo8(4)
 6627 2f1c 812F      		mov r24,r17
 6628 2f1e 0E94 0000 		call PutMidiMessageInOutgoingFifo
 6629               	.LVL290:
 6630 2f22 00C0      		rjmp .L344
 6631               	.LVL291:
 6632               	.L668:
 6633               	.LBE530:
 6634               	.LBE558:
4437:WTPA.c        **** 				switch(currentMidiMessage.dataByteOne)
 6635               		.loc 1 4437 0
 6636 2f24 8091 0000 		lds r24,currentMidiMessage.2230+2
 6637 2f28 90E0      		ldi r25,0
 6638 2f2a FC01      		movw r30,r24
 6639 2f2c 3397      		sbiw r30,3
 6640 2f2e EC31      		cpi r30,28
 6641 2f30 F105      		cpc r31,__zero_reg__
 6642 2f32 00F0      		brlo .+2
 6643 2f34 00C0      		rjmp .L650
 6644 2f36 E050      		subi r30,lo8(-(gs(.L422)))
 6645 2f38 F040      		sbci r31,hi8(-(gs(.L422)))
 6646 2f3a 0C94 0000 		jmp __tablejump2__
 6647               		.section	.progmem.gcc_sw_table,"a",@progbits
 6648               		.p2align	1
 6649               	.L422:
 6650 0000 0000      		.word gs(.L403)
 6651 0002 0000      		.word gs(.L650)
 6652 0004 0000      		.word gs(.L650)
 6653 0006 0000      		.word gs(.L650)
 6654 0008 0000      		.word gs(.L650)
 6655 000a 0000      		.word gs(.L650)
 6656 000c 0000      		.word gs(.L404)
 6657 000e 0000      		.word gs(.L650)
 6658 0010 0000      		.word gs(.L650)
 6659 0012 0000      		.word gs(.L650)
 6660 0014 0000      		.word gs(.L650)
 6661 0016 0000      		.word gs(.L405)
 6662 0018 0000      		.word gs(.L406)
 6663 001a 0000      		.word gs(.L407)
 6664 001c 0000      		.word gs(.L408)
 6665 001e 0000      		.word gs(.L409)
 6666 0020 0000      		.word gs(.L410)
 6667 0022 0000      		.word gs(.L411)
 6668 0024 0000      		.word gs(.L412)
 6669 0026 0000      		.word gs(.L413)
 6670 0028 0000      		.word gs(.L414)
 6671 002a 0000      		.word gs(.L415)
 6672 002c 0000      		.word gs(.L416)
 6673 002e 0000      		.word gs(.L417)
 6674 0030 0000      		.word gs(.L418)
 6675 0032 0000      		.word gs(.L419)
 6676 0034 0000      		.word gs(.L420)
 6677 0036 0000      		.word gs(.L421)
 6678               		.text
 6679               	.L421:
4603:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 6680               		.loc 1 4603 0
 6681 2f3e 9091 0000 		lds r25,currentMidiMessage.2230+3
 6682 2f42 990F      		lsl r25
 6683 2f44 8091 0000 		lds r24,currentMidiMessage.2230
 6684               	.LVL292:
 6685               	.LBB559:
 6686               	.LBB560:
3991:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 6687               		.loc 1 3991 0
 6688 2f48 B4E2      		ldi r27,lo8(36)
 6689 2f4a 8B9F      		mul r24,r27
 6690 2f4c F001      		movw r30,r0
 6691 2f4e 1124      		clr __zero_reg__
 6692 2f50 E050      		subi r30,lo8(-(bankStates))
 6693 2f52 F040      		sbci r31,hi8(-(bankStates))
 6694 2f54 978F      		std Z+31,r25
3992:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6695               		.loc 1 3992 0
 6696 2f56 0E94 0000 		call UpdateAdjustedSampleAddresses
 6697               	.LVL293:
 6698 2f5a 6091 0000 		lds r22,sdIsrState
 6699 2f5e 00C0      		rjmp .L318
 6700               	.L420:
 6701               	.LBE560:
 6702               	.LBE559:
4599:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 6703               		.loc 1 4599 0
 6704 2f60 9091 0000 		lds r25,currentMidiMessage.2230+3
 6705 2f64 990F      		lsl r25
 6706 2f66 8091 0000 		lds r24,currentMidiMessage.2230
 6707               	.LVL294:
 6708               	.LBB561:
 6709               	.LBB562:
3982:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6710               		.loc 1 3982 0
 6711 2f6a A4E2      		ldi r26,lo8(36)
 6712 2f6c 8A9F      		mul r24,r26
 6713 2f6e F001      		movw r30,r0
 6714 2f70 1124      		clr __zero_reg__
 6715 2f72 E050      		subi r30,lo8(-(bankStates))
 6716 2f74 F040      		sbci r31,hi8(-(bankStates))
 6717 2f76 968F      		std Z+30,r25
3983:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6718               		.loc 1 3983 0
 6719 2f78 0E94 0000 		call UpdateAdjustedSampleAddresses
 6720               	.LVL295:
 6721 2f7c 6091 0000 		lds r22,sdIsrState
 6722 2f80 00C0      		rjmp .L318
 6723               	.L419:
 6724               	.LBE562:
 6725               	.LBE561:
4595:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
 6726               		.loc 1 4595 0
 6727 2f82 9091 0000 		lds r25,currentMidiMessage.2230+3
 6728 2f86 990F      		lsl r25
 6729 2f88 8091 0000 		lds r24,currentMidiMessage.2230
 6730               	.LVL296:
 6731               	.LBB563:
 6732               	.LBB564:
3973:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6733               		.loc 1 3973 0
 6734 2f8c 44E2      		ldi r20,lo8(36)
 6735 2f8e 849F      		mul r24,r20
 6736 2f90 F001      		movw r30,r0
 6737 2f92 1124      		clr __zero_reg__
 6738 2f94 E050      		subi r30,lo8(-(bankStates))
 6739 2f96 F040      		sbci r31,hi8(-(bankStates))
 6740 2f98 958F      		std Z+29,r25
3974:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6741               		.loc 1 3974 0
 6742 2f9a 0E94 0000 		call UpdateAdjustedSampleAddresses
 6743               	.LVL297:
 6744 2f9e 6091 0000 		lds r22,sdIsrState
 6745 2fa2 00C0      		rjmp .L318
 6746               	.L418:
 6747               	.LBE564:
 6748               	.LBE563:
4591:WTPA.c        **** 					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
 6749               		.loc 1 4591 0
 6750 2fa4 E091 0000 		lds r30,currentMidiMessage.2230
 6751               	.LVL298:
 6752               	.LBB565:
 6753               	.LBB566:
3957:WTPA.c        **** 	sreg=SREG;
 6754               		.loc 1 3957 0
 6755 2fa8 2FB7      		in r18,__SREG__
 6756               	.LVL299:
3958:WTPA.c        **** 	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
 6757               		.loc 1 3958 0
 6758               	/* #APP */
 6759               	 ;  3958 "WTPA.c" 1
 6760 2faa F894      		cli
 6761               	 ;  0 "" 2
3960:WTPA.c        **** 	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
 6762               		.loc 1 3960 0
 6763               	/* #NOAPP */
 6764 2fac 34E2      		ldi r19,lo8(36)
 6765 2fae E39F      		mul r30,r19
 6766 2fb0 F001      		movw r30,r0
 6767 2fb2 1124      		clr __zero_reg__
 6768               	.LVL300:
 6769 2fb4 E050      		subi r30,lo8(-(bankStates))
 6770 2fb6 F040      		sbci r31,hi8(-(bankStates))
 6771 2fb8 8189      		ldd r24,Z+17
 6772 2fba 9289      		ldd r25,Z+18
 6773 2fbc A389      		ldd r26,Z+19
 6774 2fbe B489      		ldd r27,Z+20
 6775 2fc0 818F      		std Z+25,r24
 6776 2fc2 928F      		std Z+26,r25
 6777 2fc4 A38F      		std Z+27,r26
 6778 2fc6 B48F      		std Z+28,r27
3961:WTPA.c        **** 	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
 6779               		.loc 1 3961 0
 6780 2fc8 8585      		ldd r24,Z+13
 6781 2fca 9685      		ldd r25,Z+14
 6782 2fcc A785      		ldd r26,Z+15
 6783 2fce B089      		ldd r27,Z+16
 6784 2fd0 858B      		std Z+21,r24
 6785 2fd2 968B      		std Z+22,r25
 6786 2fd4 A78B      		std Z+23,r26
 6787 2fd6 B08F      		std Z+24,r27
3962:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=0;
 6788               		.loc 1 3962 0
 6789 2fd8 158E      		std Z+29,__zero_reg__
3963:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=0;
 6790               		.loc 1 3963 0
 6791 2fda 168E      		std Z+30,__zero_reg__
3964:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=0;
 6792               		.loc 1 3964 0
 6793 2fdc 178E      		std Z+31,__zero_reg__
3965:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 6794               		.loc 1 3965 0
 6795 2fde 2FBF      		out __SREG__,r18
 6796 2fe0 6091 0000 		lds r22,sdIsrState
 6797 2fe4 00C0      		rjmp .L318
 6798               	.LVL301:
 6799               	.L417:
 6800               	.LBE566:
 6801               	.LBE565:
4587:WTPA.c        **** 					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 6802               		.loc 1 4587 0
 6803 2fe6 9091 0000 		lds r25,currentMidiMessage.2230+3
 6804 2fea 8091 0000 		lds r24,currentMidiMessage.2230
 6805               	.LVL302:
 6806               	.LBB567:
 6807               	.LBB568:
3991:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 6808               		.loc 1 3991 0
 6809 2fee 24E2      		ldi r18,lo8(36)
 6810 2ff0 829F      		mul r24,r18
 6811 2ff2 F001      		movw r30,r0
 6812 2ff4 1124      		clr __zero_reg__
 6813 2ff6 E050      		subi r30,lo8(-(bankStates))
 6814 2ff8 F040      		sbci r31,hi8(-(bankStates))
 6815 2ffa 978F      		std Z+31,r25
3992:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6816               		.loc 1 3992 0
 6817 2ffc 0E94 0000 		call UpdateAdjustedSampleAddresses
 6818               	.LVL303:
 6819 3000 6091 0000 		lds r22,sdIsrState
 6820 3004 00C0      		rjmp .L318
 6821               	.L416:
 6822               	.LBE568:
 6823               	.LBE567:
4583:WTPA.c        **** 					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 6824               		.loc 1 4583 0
 6825 3006 9091 0000 		lds r25,currentMidiMessage.2230+3
 6826 300a 8091 0000 		lds r24,currentMidiMessage.2230
 6827               	.LVL304:
 6828               	.LBB569:
 6829               	.LBB570:
3982:WTPA.c        **** 	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
 6830               		.loc 1 3982 0
 6831 300e B4E2      		ldi r27,lo8(36)
 6832 3010 8B9F      		mul r24,r27
 6833 3012 F001      		movw r30,r0
 6834 3014 1124      		clr __zero_reg__
 6835 3016 E050      		subi r30,lo8(-(bankStates))
 6836 3018 F040      		sbci r31,hi8(-(bankStates))
 6837 301a 968F      		std Z+30,r25
3983:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6838               		.loc 1 3983 0
 6839 301c 0E94 0000 		call UpdateAdjustedSampleAddresses
 6840               	.LVL305:
 6841 3020 6091 0000 		lds r22,sdIsrState
 6842 3024 00C0      		rjmp .L318
 6843               	.L415:
 6844               	.LBE570:
 6845               	.LBE569:
4579:WTPA.c        **** 					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 6846               		.loc 1 4579 0
 6847 3026 9091 0000 		lds r25,currentMidiMessage.2230+3
 6848 302a 8091 0000 		lds r24,currentMidiMessage.2230
 6849               	.LVL306:
 6850               	.LBB571:
 6851               	.LBB572:
3973:WTPA.c        **** 	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
 6852               		.loc 1 3973 0
 6853 302e A4E2      		ldi r26,lo8(36)
 6854 3030 8A9F      		mul r24,r26
 6855 3032 F001      		movw r30,r0
 6856 3034 1124      		clr __zero_reg__
 6857 3036 E050      		subi r30,lo8(-(bankStates))
 6858 3038 F040      		sbci r31,hi8(-(bankStates))
 6859 303a 958F      		std Z+29,r25
3974:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 6860               		.loc 1 3974 0
 6861 303c 0E94 0000 		call UpdateAdjustedSampleAddresses
 6862               	.LVL307:
 6863 3040 6091 0000 		lds r22,sdIsrState
 6864 3044 00C0      		rjmp .L318
 6865               	.L414:
 6866               	.LBE572:
 6867               	.LBE571:
4569:WTPA.c        **** 					sreg=SREG;
 6868               		.loc 1 4569 0
 6869 3046 1FB7      		in r17,__SREG__
 6870               	.LVL308:
4570:WTPA.c        **** 					cli();		// Disable interrupts while we write to eeprom.
 6871               		.loc 1 4570 0
 6872               	/* #APP */
 6873               	 ;  4570 "WTPA.c" 1
 6874 3048 F894      		cli
 6875               	 ;  0 "" 2
4571:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 6876               		.loc 1 4571 0
 6877               	/* #NOAPP */
 6878 304a 3091 0000 		lds r19,currentMidiMessage.2230
 6879 304e A32F      		mov r26,r19
 6880 3050 B0E0      		ldi r27,0
 6881 3052 FD01      		movw r30,r26
 6882 3054 E050      		subi r30,lo8(-(currentNoteOn.2231))
 6883 3056 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 6884 3058 6081      		ld r22,Z
 6885               	.LVL309:
 6886 305a AA0F      		lsl r26
 6887 305c BB1F      		rol r27
 6888 305e A050      		subi r26,lo8(-(theMidiRecordRate))
 6889 3060 B040      		sbci r27,hi8(-(theMidiRecordRate))
 6890               	.LBB573:
 6891               	.LBB574:
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 6892               		.loc 1 3409 0
 6893 3062 2BEA      		ldi r18,lo8(-85)
 6894 3064 629F      		mul r22,r18
 6895 3066 212D      		mov r18,r1
 6896 3068 1124      		clr __zero_reg__
 6897 306a 2695      		lsr r18
 6898 306c 2695      		lsr r18
 6899 306e 2695      		lsr r18
 6900 3070 822F      		mov r24,r18
 6901 3072 880F      		lsl r24
 6902 3074 820F      		add r24,r18
 6903 3076 880F      		lsl r24
 6904 3078 880F      		lsl r24
 6905 307a E62F      		mov r30,r22
 6906 307c E81B      		sub r30,r24
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 6907               		.loc 1 3411 0
 6908 307e F0E0      		ldi r31,0
 6909 3080 EE0F      		lsl r30
 6910 3082 FF1F      		rol r31
 6911 3084 E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 6912 3086 F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 6913 3088 8081      		ld r24,Z
 6914 308a 9181      		ldd r25,Z+1
 6915 308c 00C0      		rjmp 2f
 6916               		1:
 6917 308e 9695      		lsr r25
 6918 3090 8795      		ror r24
 6919               		2:
 6920 3092 2A95      		dec r18
 6921 3094 02F4      		brpl 1b
 6922               	.LBE574:
 6923               	.LBE573:
4571:WTPA.c        **** 					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[curr
 6924               		.loc 1 4571 0
 6925 3096 8D93      		st X+,r24
 6926 3098 9C93      		st X,r25
 6927               	.LVL310:
 6928               	.LBB575:
 6929               	.LBB576:
3427:WTPA.c        **** 	if(theBank==BANK_0)
 6930               		.loc 1 3427 0
 6931 309a 3323      		tst r19
 6932 309c 01F4      		brne .+2
 6933 309e 00C0      		rjmp .L679
3431:WTPA.c        **** 	else if(theBank==BANK_1)
 6934               		.loc 1 3431 0
 6935 30a0 3130      		cpi r19,lo8(1)
 6936 30a2 01F4      		brne .+2
 6937 30a4 00C0      		rjmp .L680
 6938               	.LVL311:
 6939               	.L451:
 6940               	.LBE576:
 6941               	.LBE575:
4573:WTPA.c        **** 					SREG=sreg;		// Re-enable interrupts.
 6942               		.loc 1 4573 0
 6943 30a6 1FBF      		out __SREG__,r17
 6944 30a8 6091 0000 		lds r22,sdIsrState
4574:WTPA.c        **** 					break;
 6945               		.loc 1 4574 0
 6946 30ac 00C0      		rjmp .L318
 6947               	.LVL312:
 6948               	.L413:
4545:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
 6949               		.loc 1 4545 0
 6950 30ae 8091 0000 		lds r24,currentMidiMessage.2230+3
 6951 30b2 8130      		cpi r24,lo8(1)
 6952 30b4 01F4      		brne .+2
 6953 30b6 00C0      		rjmp .L447
 6954 30b8 00F0      		brlo .+2
 6955 30ba 00C0      		rjmp .L681
4548:WTPA.c        **** 						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinat
 6956               		.loc 1 4548 0
 6957 30bc 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 6958 30be 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 6959 30c0 9093 0000 		sts UpdateOutput+1,r25
 6960 30c4 8093 0000 		sts UpdateOutput,r24
 6961 30c8 6091 0000 		lds r22,sdIsrState
4549:WTPA.c        **** 						break;
 6962               		.loc 1 4549 0
 6963 30cc 00C0      		rjmp .L318
 6964               	.L412:
4541:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
 6965               		.loc 1 4541 0
 6966 30ce E091 0000 		lds r30,currentMidiMessage.2230
 6967 30d2 8091 0000 		lds r24,currentMidiMessage.2230+3
 6968 30d6 94E2      		ldi r25,lo8(36)
 6969 30d8 E99F      		mul r30,r25
 6970 30da F001      		movw r30,r0
 6971 30dc 1124      		clr __zero_reg__
 6972 30de E050      		subi r30,lo8(-(bankStates))
 6973 30e0 F040      		sbci r31,hi8(-(bankStates))
 6974 30e2 8087      		std Z+8,r24
 6975 30e4 6091 0000 		lds r22,sdIsrState
4542:WTPA.c        **** 					break;
 6976               		.loc 1 4542 0
 6977 30e8 00C0      		rjmp .L318
 6978               	.L411:
4537:WTPA.c        **** 					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
 6979               		.loc 1 4537 0
 6980 30ea 6091 0000 		lds r22,currentMidiMessage.2230+3
 6981 30ee 8091 0000 		lds r24,currentMidiMessage.2230
 6982 30f2 0E94 0000 		call MakeNewGranularArray
 6983               	.LVL313:
 6984 30f6 6091 0000 		lds r22,sdIsrState
4538:WTPA.c        **** 					break;
 6985               		.loc 1 4538 0
 6986 30fa 00C0      		rjmp .L318
 6987               	.L410:
4530:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo<8)
 6988               		.loc 1 4530 0
 6989 30fc 8091 0000 		lds r24,currentMidiMessage.2230+3
 6990 3100 8830      		cpi r24,lo8(8)
 6991 3102 00F0      		brlo .+2
 6992 3104 00C0      		rjmp .L650
4532:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
 6993               		.loc 1 4532 0
 6994 3106 E091 0000 		lds r30,currentMidiMessage.2230
 6995 310a 44E2      		ldi r20,lo8(36)
 6996 310c E49F      		mul r30,r20
 6997 310e F001      		movw r30,r0
 6998 3110 1124      		clr __zero_reg__
 6999 3112 E050      		subi r30,lo8(-(bankStates))
 7000 3114 F040      		sbci r31,hi8(-(bankStates))
 7001 3116 8187      		std Z+9,r24
 7002 3118 6091 0000 		lds r22,sdIsrState
 7003 311c 00C0      		rjmp .L318
 7004               	.L409:
4517:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 7005               		.loc 1 4517 0
 7006 311e E091 0000 		lds r30,currentMidiMessage.2230
 7007 3122 34E2      		ldi r19,lo8(36)
 7008 3124 E39F      		mul r30,r19
 7009 3126 F001      		movw r30,r0
 7010 3128 1124      		clr __zero_reg__
 7011 312a E050      		subi r30,lo8(-(bankStates))
 7012 312c F040      		sbci r31,hi8(-(bankStates))
 7013 312e 1182      		std Z+1,__zero_reg__
4518:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
 7014               		.loc 1 4518 0
 7015 3130 1186      		std Z+9,__zero_reg__
4519:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
 7016               		.loc 1 4519 0
 7017 3132 1086      		std Z+8,__zero_reg__
4520:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
 7018               		.loc 1 4520 0
 7019 3134 1782      		std Z+7,__zero_reg__
4521:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 7020               		.loc 1 4521 0
 7021 3136 1282      		std Z+2,__zero_reg__
4522:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 7022               		.loc 1 4522 0
 7023 3138 81E0      		ldi r24,lo8(1)
 7024 313a 8483      		std Z+4,r24
4523:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 7025               		.loc 1 4523 0
 7026 313c 1382      		std Z+3,__zero_reg__
4524:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
 7027               		.loc 1 4524 0
 7028 313e 8483      		std Z+4,r24
4525:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
 7029               		.loc 1 4525 0
 7030 3140 1682      		std Z+6,__zero_reg__
4526:WTPA.c        **** 					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combinati
 7031               		.loc 1 4526 0
 7032 3142 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 7033 3144 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 7034 3146 9093 0000 		sts UpdateOutput+1,r25
 7035 314a 8093 0000 		sts UpdateOutput,r24
 7036 314e 6091 0000 		lds r22,sdIsrState
4527:WTPA.c        **** 					break;
 7037               		.loc 1 4527 0
 7038 3152 00C0      		rjmp .L318
 7039               	.L408:
4505:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7040               		.loc 1 4505 0
 7041 3154 8091 0000 		lds r24,currentMidiMessage.2230+3
4507:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
 7042               		.loc 1 4507 0
 7043 3158 E091 0000 		lds r30,currentMidiMessage.2230
4505:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7044               		.loc 1 4505 0
 7045 315c 8823      		tst r24
 7046 315e 01F4      		brne .+2
 7047 3160 00C0      		rjmp .L442
4507:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
 7048               		.loc 1 4507 0
 7049 3162 B4E2      		ldi r27,lo8(36)
 7050 3164 EB9F      		mul r30,r27
 7051 3166 F001      		movw r30,r0
 7052 3168 1124      		clr __zero_reg__
 7053 316a E050      		subi r30,lo8(-(bankStates))
 7054 316c F040      		sbci r31,hi8(-(bankStates))
 7055 316e 81E0      		ldi r24,lo8(1)
 7056 3170 8383      		std Z+3,r24
 7057               	.L443:
4513:WTPA.c        **** 					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle go
 7058               		.loc 1 4513 0
 7059 3172 8091 0000 		lds r24,currentMidiMessage.2230
 7060 3176 0E94 0000 		call UpdateAdjustedSampleAddresses
 7061               	.LVL314:
 7062 317a 6091 0000 		lds r22,sdIsrState
4514:WTPA.c        **** 					break;
 7063               		.loc 1 4514 0
 7064 317e 00C0      		rjmp .L318
 7065               	.L407:
4494:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7066               		.loc 1 4494 0
 7067 3180 8091 0000 		lds r24,currentMidiMessage.2230+3
4496:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
 7068               		.loc 1 4496 0
 7069 3184 E091 0000 		lds r30,currentMidiMessage.2230
4494:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7070               		.loc 1 4494 0
 7071 3188 8823      		tst r24
 7072 318a 01F4      		brne .+2
 7073 318c 00C0      		rjmp .L441
4496:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
 7074               		.loc 1 4496 0
 7075 318e 94E2      		ldi r25,lo8(36)
 7076 3190 E99F      		mul r30,r25
 7077 3192 F001      		movw r30,r0
 7078 3194 1124      		clr __zero_reg__
 7079 3196 E050      		subi r30,lo8(-(bankStates))
 7080 3198 F040      		sbci r31,hi8(-(bankStates))
 7081 319a 81E0      		ldi r24,lo8(1)
 7082 319c 8283      		std Z+2,r24
 7083 319e 6091 0000 		lds r22,sdIsrState
 7084 31a2 00C0      		rjmp .L318
 7085               	.L405:
4468:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7086               		.loc 1 4468 0
 7087 31a4 8091 0000 		lds r24,currentMidiMessage.2230+3
 7088 31a8 8111      		cpse r24,__zero_reg__
 7089 31aa 00C0      		rjmp .L682
4473:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be
 7090               		.loc 1 4473 0
 7091 31ac E091 0000 		lds r30,currentMidiMessage.2230
 7092 31b0 34E2      		ldi r19,lo8(36)
 7093 31b2 E39F      		mul r30,r19
 7094 31b4 F001      		movw r30,r0
 7095 31b6 1124      		clr __zero_reg__
 7096 31b8 E050      		subi r30,lo8(-(bankStates))
 7097 31ba F040      		sbci r31,hi8(-(bankStates))
 7098 31bc 8081      		ld r24,Z
 7099 31be 8230      		cpi r24,lo8(2)
 7100 31c0 01F0      		breq .+2
 7101 31c2 00C0      		rjmp .L650
4475:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 7102               		.loc 1 4475 0
 7103 31c4 1082      		st Z,__zero_reg__
4476:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 7104               		.loc 1 4476 0
 7105 31c6 1286      		std Z+10,__zero_reg__
4477:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playba
 7106               		.loc 1 4477 0
 7107 31c8 1682      		std Z+6,__zero_reg__
 7108 31ca 6091 0000 		lds r22,sdIsrState
 7109 31ce 00C0      		rjmp .L318
 7110               	.L406:
4483:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7111               		.loc 1 4483 0
 7112 31d0 8091 0000 		lds r24,currentMidiMessage.2230+3
4485:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 7113               		.loc 1 4485 0
 7114 31d4 E091 0000 		lds r30,currentMidiMessage.2230
4483:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7115               		.loc 1 4483 0
 7116 31d8 8823      		tst r24
 7117 31da 01F4      		brne .+2
 7118 31dc 00C0      		rjmp .L440
4485:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
 7119               		.loc 1 4485 0
 7120 31de 44E2      		ldi r20,lo8(36)
 7121 31e0 E49F      		mul r30,r20
 7122 31e2 F001      		movw r30,r0
 7123 31e4 1124      		clr __zero_reg__
 7124 31e6 E050      		subi r30,lo8(-(bankStates))
 7125 31e8 F040      		sbci r31,hi8(-(bankStates))
 7126 31ea 1182      		std Z+1,__zero_reg__
 7127 31ec 6091 0000 		lds r22,sdIsrState
 7128 31f0 00C0      		rjmp .L318
 7129               	.L404:
4453:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7130               		.loc 1 4453 0
 7131 31f2 8091 0000 		lds r24,currentMidiMessage.2230+3
 7132 31f6 8823      		tst r24
 7133 31f8 01F4      		brne .+2
 7134 31fa 00C0      		rjmp .L425
4455:WTPA.c        **** 						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.c
 7135               		.loc 1 4455 0
 7136 31fc 1091 0000 		lds r17,currentMidiMessage.2230
 7137 3200 212F      		mov r18,r17
 7138 3202 30E0      		ldi r19,0
 7139 3204 94E2      		ldi r25,lo8(36)
 7140 3206 199F      		mul r17,r25
 7141 3208 F001      		movw r30,r0
 7142 320a 1124      		clr __zero_reg__
 7143 320c E050      		subi r30,lo8(-(bankStates))
 7144 320e F040      		sbci r31,hi8(-(bankStates))
 7145 3210 4189      		ldd r20,Z+17
 7146 3212 5289      		ldd r21,Z+18
 7147 3214 6389      		ldd r22,Z+19
 7148 3216 7489      		ldd r23,Z+20
 7149 3218 8585      		ldd r24,Z+13
 7150 321a 9685      		ldd r25,Z+14
 7151 321c A785      		ldd r26,Z+15
 7152 321e B089      		ldd r27,Z+16
 7153 3220 4817      		cp r20,r24
 7154 3222 5907      		cpc r21,r25
 7155 3224 6A07      		cpc r22,r26
 7156 3226 7B07      		cpc r23,r27
 7157 3228 01F4      		brne .+2
 7158 322a 00C0      		rjmp .L650
4457:WTPA.c        **** 							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.
 7159               		.loc 1 4457 0
 7160 322c D901      		movw r26,r18
 7161 322e A050      		subi r26,lo8(-(currentNoteOn.2231))
 7162 3230 B040      		sbci r27,hi8(-(currentNoteOn.2231))
 7163 3232 4C91      		ld r20,X
 7164 3234 50E0      		ldi r21,0
 7165               	.LVL315:
 7166               	.LBB578:
 7167               	.LBB579:
2063:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 7168               		.loc 1 2063 0
 7169 3236 8581      		ldd r24,Z+5
 7170 3238 8823      		tst r24
 7171 323a 01F0      		breq .L427
 7172 323c 6091 0000 		lds r22,sdIsrState
 7173 3240 862F      		mov r24,r22
 7174 3242 8150      		subi r24,lo8(-(-1))
 7175 3244 8230      		cpi r24,lo8(2)
 7176 3246 00F4      		brsh .+2
 7177 3248 00C0      		rjmp .L428
 7178               	.L427:
2065:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 7179               		.loc 1 2065 0
 7180 324a 6FB7      		in r22,__SREG__
 7181               	.LVL316:
2066:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 7182               		.loc 1 2066 0
 7183               	/* #APP */
 7184               	 ;  2066 "WTPA.c" 1
 7185 324c F894      		cli
 7186               	 ;  0 "" 2
2068:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the 
 7187               		.loc 1 2068 0
 7188               	/* #NOAPP */
 7189 324e 84E2      		ldi r24,lo8(36)
 7190 3250 829F      		mul r24,r18
 7191 3252 F001      		movw r30,r0
 7192 3254 839F      		mul r24,r19
 7193 3256 F00D      		add r31,r0
 7194 3258 1124      		clr __zero_reg__
 7195 325a E050      		subi r30,lo8(-(bankStates))
 7196 325c F040      		sbci r31,hi8(-(bankStates))
 7197 325e 85E0      		ldi r24,lo8(5)
 7198 3260 8083      		st Z,r24
 7199               	.LVL317:
 7200               	.LBB580:
 7201               	.LBB581:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 7202               		.loc 1 1925 0
 7203 3262 82E0      		ldi r24,lo8(2)
 7204 3264 8287      		std Z+10,r24
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 7205               		.loc 1 1929 0
 7206 3266 5487      		std Z+12,r21
 7207 3268 4387      		std Z+11,r20
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 7208               		.loc 1 1933 0
 7209 326a 8091 8400 		lds r24,132
 7210 326e 9091 8500 		lds r25,132+1
 7211 3272 840F      		add r24,r20
 7212 3274 951F      		adc r25,r21
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 7213               		.loc 1 1931 0
 7214 3276 1111      		cpse r17,__zero_reg__
 7215 3278 00C0      		rjmp .L429
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 7216               		.loc 1 1933 0
 7217 327a 9093 8900 		sts 136+1,r25
 7218 327e 8093 8800 		sts 136,r24
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 7219               		.loc 1 1934 0
 7220 3282 B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 7221               		.loc 1 1935 0
 7222 3284 8091 6F00 		lds r24,111
 7223 3288 8260      		ori r24,lo8(2)
 7224 328a 8093 6F00 		sts 111,r24
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 7225               		.loc 1 1936 0
 7226 328e 81E0      		ldi r24,lo8(1)
 7227 3290 8093 8100 		sts 129,r24
 7228               	.L430:
 7229               	.LBE581:
 7230               	.LBE580:
2071:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 7231               		.loc 1 2071 0
 7232 3294 84E2      		ldi r24,lo8(36)
 7233 3296 829F      		mul r24,r18
 7234 3298 F001      		movw r30,r0
 7235 329a 839F      		mul r24,r19
 7236 329c F00D      		add r31,r0
 7237 329e 1124      		clr __zero_reg__
 7238 32a0 E050      		subi r30,lo8(-(bankStates))
 7239 32a2 F040      		sbci r31,hi8(-(bankStates))
 7240 32a4 81E0      		ldi r24,lo8(1)
 7241 32a6 8583      		std Z+5,r24
2072:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 7242               		.loc 1 2072 0
 7243 32a8 6FBF      		out __SREG__,r22
2075:WTPA.c        **** 		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock 
 7244               		.loc 1 2075 0
 7245 32aa 8091 7A00 		lds r24,122
 7246 32ae 86FD      		sbrc r24,6
 7247 32b0 00C0      		rjmp .L649
 7248               	.LBB583:
 7249               	.LBB584:
2077:WTPA.c        **** 			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bo
 7250               		.loc 1 2077 0
 7251 32b2 8091 7900 		lds r24,121
 7252 32b6 8058      		subi r24,lo8(-(-128))
 7253 32b8 8093 0000 		sts adcByte,r24
2078:WTPA.c        **** 			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 7254               		.loc 1 2078 0
 7255 32bc 8091 7A00 		lds r24,122
 7256 32c0 8064      		ori r24,lo8(64)
 7257 32c2 8093 7A00 		sts 122,r24
 7258               	.L649:
 7259 32c6 6091 0000 		lds r22,sdIsrState
 7260               	.LVL318:
 7261 32ca 1091 0000 		lds r17,currentMidiMessage.2230
 7262               	.LVL319:
 7263               	.L428:
 7264               	.LBE584:
 7265               	.LBE583:
 7266               	.LBE579:
 7267               	.LBE578:
4458:WTPA.c        **** 							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll defaul
 7268               		.loc 1 4458 0
 7269 32ce A4E2      		ldi r26,lo8(36)
 7270 32d0 1A9F      		mul r17,r26
 7271 32d2 F001      		movw r30,r0
 7272 32d4 1124      		clr __zero_reg__
 7273 32d6 E050      		subi r30,lo8(-(bankStates))
 7274 32d8 F040      		sbci r31,hi8(-(bankStates))
 7275 32da 1682      		std Z+6,__zero_reg__
 7276 32dc 00C0      		rjmp .L318
 7277               	.LVL320:
 7278               	.L403:
4440:WTPA.c        **** 					if(currentMidiMessage.dataByteTwo)
 7279               		.loc 1 4440 0
 7280 32de 8091 0000 		lds r24,currentMidiMessage.2230+3
 7281 32e2 8111      		cpse r24,__zero_reg__
 7282 32e4 00C0      		rjmp .L683
4445:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must alre
 7283               		.loc 1 4445 0
 7284 32e6 E091 0000 		lds r30,currentMidiMessage.2230
 7285 32ea 84E2      		ldi r24,lo8(36)
 7286 32ec E89F      		mul r30,r24
 7287 32ee F001      		movw r30,r0
 7288 32f0 1124      		clr __zero_reg__
 7289 32f2 E050      		subi r30,lo8(-(bankStates))
 7290 32f4 F040      		sbci r31,hi8(-(bankStates))
 7291 32f6 8081      		ld r24,Z
 7292 32f8 8330      		cpi r24,lo8(3)
 7293 32fa 01F0      		breq .+2
 7294 32fc 00C0      		rjmp .L650
4447:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in 
 7295               		.loc 1 4447 0
 7296 32fe 1082      		st Z,__zero_reg__
4448:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this ban
 7297               		.loc 1 4448 0
 7298 3300 1286      		std Z+10,__zero_reg__
 7299 3302 6091 0000 		lds r22,sdIsrState
 7300 3306 00C0      		rjmp .L318
 7301               	.LVL321:
 7302               	.L677:
 7303               	.LBB587:
 7304               	.LBB531:
 7305               	.LBB486:
 7306               	.LBB481:
 7307               	.LBB480:
 7308               	.LBB477:
 7309               	.LBB475:
 7310               	.LBB476:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 7311               		.loc 1 1950 0
 7312 3308 8091 8100 		lds r24,129
 7313               	.LVL322:
 7314 330c 8064      		ori r24,lo8(64)
 7315 330e 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 7316               		.loc 1 1951 0
 7317 3312 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7318               		.loc 1 1952 0
 7319 3314 8091 6F00 		lds r24,111
 7320 3318 8062      		ori r24,lo8(32)
 7321 331a 8093 6F00 		sts 111,r24
 7322 331e 00C0      		rjmp .L330
 7323               	.LVL323:
 7324               	.L365:
 7325               	.LBE476:
 7326               	.LBE475:
 7327               	.LBE477:
 7328               	.LBE480:
 7329               	.LBE481:
 7330               	.LBE486:
4333:WTPA.c        **** 		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginn
 7331               		.loc 1 4333 0
 7332 3320 83FF      		sbrs r24,3
 7333 3322 00C0      		rjmp .L372
4335:WTPA.c        **** 			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have somet
 7334               		.loc 1 4335 0
 7335 3324 E091 0000 		lds r30,currentBank
 7336 3328 2E2F      		mov r18,r30
 7337 332a 30E0      		ldi r19,0
 7338 332c 44E2      		ldi r20,lo8(36)
 7339 332e E49F      		mul r30,r20
 7340 3330 8001      		movw r16,r0
 7341 3332 1124      		clr __zero_reg__
 7342 3334 0050      		subi r16,lo8(-(bankStates))
 7343 3336 1040      		sbci r17,hi8(-(bankStates))
 7344 3338 D801      		movw r26,r16
 7345 333a 5196      		adiw r26,17
 7346 333c CD90      		ld r12,X+
 7347 333e DD90      		ld r13,X+
 7348 3340 ED90      		ld r14,X+
 7349 3342 FC90      		ld r15,X
 7350 3344 5497      		sbiw r26,17+3
 7351 3346 1D96      		adiw r26,13
 7352 3348 4D91      		ld r20,X+
 7353 334a 5D91      		ld r21,X+
 7354 334c 6D91      		ld r22,X+
 7355 334e 7C91      		ld r23,X
 7356 3350 5097      		sbiw r26,13+3
 7357 3352 C416      		cp r12,r20
 7358 3354 D506      		cpc r13,r21
 7359 3356 E606      		cpc r14,r22
 7360 3358 F706      		cpc r15,r23
 7361 335a 01F4      		brne .+2
 7362 335c 00C0      		rjmp .L322
 7363               	.LVL324:
 7364               	.LBB487:
 7365               	.LBB488:
2012:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 7366               		.loc 1 2012 0
 7367 335e 1596      		adiw r26, 5
 7368 3360 8C91      		ld r24,X
 7369 3362 8823      		tst r24
 7370 3364 01F0      		breq .L373
 7371 3366 8091 0000 		lds r24,sdIsrState
 7372 336a 8150      		subi r24,lo8(-(-1))
 7373 336c 8230      		cpi r24,lo8(2)
 7374 336e 00F4      		brsh .+2
 7375 3370 00C0      		rjmp .L374
 7376               	.L373:
2014:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 7377               		.loc 1 2014 0
 7378 3372 9FB7      		in r25,__SREG__
 7379               	.LVL325:
2015:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 7380               		.loc 1 2015 0
 7381               	/* #APP */
 7382               	 ;  2015 "WTPA.c" 1
 7383 3374 F894      		cli
 7384               	 ;  0 "" 2
2017:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get int
 7385               		.loc 1 2017 0
 7386               	/* #NOAPP */
 7387 3376 84E2      		ldi r24,lo8(36)
 7388 3378 829F      		mul r24,r18
 7389 337a D001      		movw r26,r0
 7390 337c 839F      		mul r24,r19
 7391 337e B00D      		add r27,r0
 7392 3380 1124      		clr __zero_reg__
 7393 3382 A050      		subi r26,lo8(-(bankStates))
 7394 3384 B040      		sbci r27,hi8(-(bankStates))
 7395 3386 84E0      		ldi r24,lo8(4)
 7396 3388 8C93      		st X,r24
2019:WTPA.c        **** 		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
 7397               		.loc 1 2019 0
 7398 338a 1396      		adiw r26, 3
 7399 338c 8C91      		ld r24,X
 7400 338e 1397      		sbiw r26, 3
 7401 3390 8823      		tst r24
 7402 3392 01F4      		brne .+2
 7403 3394 00C0      		rjmp .L375
2021:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "begi
 7404               		.loc 1 2021 0
 7405 3396 5596      		adiw r26,21
 7406 3398 4D91      		ld r20,X+
 7407 339a 5D91      		ld r21,X+
 7408 339c 6D91      		ld r22,X+
 7409 339e 7C91      		ld r23,X
 7410 33a0 5897      		sbiw r26,21+3
 7411 33a2 9096      		adiw r26,32
 7412 33a4 4D93      		st X+,r20
 7413 33a6 5D93      		st X+,r21
 7414 33a8 6D93      		st X+,r22
 7415 33aa 7C93      		st X,r23
 7416 33ac 9397      		sbiw r26,32+3
2022:WTPA.c        **** 			bankStates[theBank].sampleDirection=false;	// make us run backwards.
 7417               		.loc 1 2022 0
 7418 33ae 1496      		adiw r26,4
 7419 33b0 1C92      		st X,__zero_reg__
 7420               	.L376:
 7421               	.LVL326:
 7422               	.LBB489:
 7423               	.LBB490:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 7424               		.loc 1 1925 0
 7425 33b2 84E2      		ldi r24,lo8(36)
 7426 33b4 829F      		mul r24,r18
 7427 33b6 D001      		movw r26,r0
 7428 33b8 839F      		mul r24,r19
 7429 33ba B00D      		add r27,r0
 7430 33bc 1124      		clr __zero_reg__
 7431 33be A050      		subi r26,lo8(-(bankStates))
 7432 33c0 B040      		sbci r27,hi8(-(bankStates))
 7433 33c2 81E0      		ldi r24,lo8(1)
 7434 33c4 1A96      		adiw r26,10
 7435 33c6 8C93      		st X,r24
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 7436               		.loc 1 1948 0
 7437 33c8 EE23      		tst r30
 7438 33ca 01F4      		brne .+2
 7439 33cc 00C0      		rjmp .L684
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 7440               		.loc 1 1956 0
 7441 33ce DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 7442               		.loc 1 1957 0
 7443 33d0 84E0      		ldi r24,lo8(4)
 7444 33d2 8093 6800 		sts 104,r24
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 7445               		.loc 1 1958 0
 7446 33d6 80E1      		ldi r24,lo8(16)
 7447 33d8 8093 6D00 		sts 109,r24
 7448               	.L378:
 7449               	.LBE490:
 7450               	.LBE489:
2031:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 7451               		.loc 1 2031 0
 7452 33dc 84E2      		ldi r24,lo8(36)
 7453 33de 829F      		mul r24,r18
 7454 33e0 F001      		movw r30,r0
 7455 33e2 839F      		mul r24,r19
 7456 33e4 F00D      		add r31,r0
 7457 33e6 1124      		clr __zero_reg__
 7458 33e8 E050      		subi r30,lo8(-(bankStates))
 7459 33ea F040      		sbci r31,hi8(-(bankStates))
 7460 33ec 81E0      		ldi r24,lo8(1)
 7461 33ee 8583      		std Z+5,r24
2032:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 7462               		.loc 1 2032 0
 7463 33f0 9FBF      		out __SREG__,r25
 7464 33f2 E091 0000 		lds r30,currentBank
 7465               	.LVL327:
 7466               	.L374:
 7467               	.LBE488:
 7468               	.LBE487:
4338:WTPA.c        **** 				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
 7469               		.loc 1 4338 0
 7470 33f6 F4E2      		ldi r31,lo8(36)
 7471 33f8 EF9F      		mul r30,r31
 7472 33fa D001      		movw r26,r0
 7473 33fc 1124      		clr __zero_reg__
 7474 33fe A050      		subi r26,lo8(-(bankStates))
 7475 3400 B040      		sbci r27,hi8(-(bankStates))
 7476 3402 81E0      		ldi r24,lo8(1)
 7477 3404 1196      		adiw r26,1
 7478 3406 8C93      		st X,r24
4339:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VE
 7479               		.loc 1 4339 0
 7480 3408 20E4      		ldi r18,lo8(64)
 7481               	.LVL328:
 7482 340a 40E3      		ldi r20,lo8(48)
 7483 340c 61E0      		ldi r22,lo8(1)
 7484 340e 8E2F      		mov r24,r30
 7485 3410 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7486               	.LVL329:
 7487 3414 00C0      		rjmp .L322
 7488               	.LVL330:
 7489               	.L674:
4205:WTPA.c        **** 				switch(scaledEncoderValue)
 7490               		.loc 1 4205 0
 7491 3416 8230      		cpi r24,lo8(2)
 7492 3418 01F0      		breq .L338
 7493 341a 8330      		cpi r24,lo8(3)
 7494 341c 01F0      		breq .+2
 7495 341e 00C0      		rjmp .L335
4223:WTPA.c        **** 					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinati
 7496               		.loc 1 4223 0
 7497 3420 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 7498 3422 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 7499 3424 9093 0000 		sts UpdateOutput+1,r25
 7500 3428 8093 0000 		sts UpdateOutput,r24
4224:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 7501               		.loc 1 4224 0
 7502 342c 23E0      		ldi r18,lo8(3)
 7503 342e 46E1      		ldi r20,lo8(22)
 7504 3430 64E0      		ldi r22,lo8(4)
 7505 3432 8091 0000 		lds r24,currentBank
 7506 3436 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7507               	.LVL331:
 7508 343a 00C0      		rjmp .L335
 7509               	.L345:
4269:WTPA.c        **** 		else if(keyState&Im_SWITCH_2)		// Adjust sample window
 7510               		.loc 1 4269 0
 7511 343c 82FF      		sbrs r24,2
 7512 343e 00C0      		rjmp .L344
4271:WTPA.c        **** 			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we h
 7513               		.loc 1 4271 0
 7514 3440 1091 0000 		lds r17,currentBank
 7515 3444 44E2      		ldi r20,lo8(36)
 7516 3446 149F      		mul r17,r20
 7517 3448 F001      		movw r30,r0
 7518 344a 1124      		clr __zero_reg__
 7519 344c E050      		subi r30,lo8(-(bankStates))
 7520 344e F040      		sbci r31,hi8(-(bankStates))
 7521 3450 878D      		ldd r24,Z+31
 7522 3452 0091 0000 		lds r16,encoderValue
 7523 3456 8017      		cp r24,r16
 7524 3458 01F4      		brne .+2
 7525 345a 00C0      		rjmp .L344
 7526               	.LVL332:
 7527               	.LBB496:
 7528               	.LBB497:
3991:WTPA.c        **** 	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
 7529               		.loc 1 3991 0
 7530 345c 078F      		std Z+31,r16
3992:WTPA.c        **** 	UpdateAdjustedSampleAddresses(theBank);
 7531               		.loc 1 3992 0
 7532 345e 812F      		mov r24,r17
 7533 3460 0E94 0000 		call UpdateAdjustedSampleAddresses
 7534               	.LVL333:
 7535               	.LBE497:
 7536               	.LBE496:
4274:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_
 7537               		.loc 1 4274 0
 7538 3464 202F      		mov r18,r16
 7539 3466 2695      		lsr r18
 7540 3468 4EE1      		ldi r20,lo8(30)
 7541 346a 64E0      		ldi r22,lo8(4)
 7542 346c 812F      		mov r24,r17
 7543 346e 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7544               	.LVL334:
 7545 3472 00C0      		rjmp .L344
 7546               	.LVL335:
 7547               	.L337:
4213:WTPA.c        **** 					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of comb
 7548               		.loc 1 4213 0
 7549 3474 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 7550 3476 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 7551 3478 9093 0000 		sts UpdateOutput+1,r25
 7552 347c 8093 0000 		sts UpdateOutput,r24
4214:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 7553               		.loc 1 4214 0
 7554 3480 21E0      		ldi r18,lo8(1)
 7555 3482 46E1      		ldi r20,lo8(22)
 7556 3484 64E0      		ldi r22,lo8(4)
 7557 3486 8091 0000 		lds r24,currentBank
 7558 348a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7559               	.LVL336:
 7560 348e 00C0      		rjmp .L335
 7561               	.L338:
4218:WTPA.c        **** 					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinati
 7562               		.loc 1 4218 0
 7563 3490 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 7564 3492 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 7565 3494 9093 0000 		sts UpdateOutput+1,r25
 7566 3498 8093 0000 		sts UpdateOutput,r24
4219:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,s
 7567               		.loc 1 4219 0
 7568 349c 22E0      		ldi r18,lo8(2)
 7569 349e 46E1      		ldi r20,lo8(22)
 7570 34a0 64E0      		ldi r22,lo8(4)
 7571 34a2 8091 0000 		lds r24,currentBank
 7572 34a6 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7573               	.LVL337:
 7574 34aa 00C0      		rjmp .L335
 7575               	.LVL338:
 7576               	.L350:
 7577               	.LBB498:
 7578               	.LBB467:
2026:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 7579               		.loc 1 2026 0
 7580 34ac 418D      		ldd r20,Z+25
 7581 34ae 528D      		ldd r21,Z+26
 7582 34b0 638D      		ldd r22,Z+27
 7583 34b2 748D      		ldd r23,Z+28
 7584 34b4 40A3      		std Z+32,r20
 7585 34b6 51A3      		std Z+33,r21
 7586 34b8 62A3      		std Z+34,r22
 7587 34ba 73A3      		std Z+35,r23
2027:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 7588               		.loc 1 2027 0
 7589 34bc 91E0      		ldi r25,lo8(1)
 7590 34be 9483      		std Z+4,r25
 7591 34c0 00C0      		rjmp .L351
 7592               	.LVL339:
 7593               	.L372:
 7594               	.LBE467:
 7595               	.LBE498:
4342:WTPA.c        **** 		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this wi
 7596               		.loc 1 4342 0
 7597 34c2 84FF      		sbrs r24,4
 7598 34c4 00C0      		rjmp .L379
4344:WTPA.c        **** 			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
 7599               		.loc 1 4344 0
 7600 34c6 8091 0000 		lds r24,currentBank
 7601 34ca A82F      		mov r26,r24
 7602 34cc B0E0      		ldi r27,0
 7603 34ce 24E2      		ldi r18,lo8(36)
 7604 34d0 829F      		mul r24,r18
 7605 34d2 F001      		movw r30,r0
 7606 34d4 1124      		clr __zero_reg__
 7607 34d6 E050      		subi r30,lo8(-(bankStates))
 7608 34d8 F040      		sbci r31,hi8(-(bankStates))
 7609 34da 9081      		ld r25,Z
 7610 34dc 9111      		cpse r25,__zero_reg__
 7611 34de 00C0      		rjmp .L380
4346:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 7612               		.loc 1 4346 0
 7613 34e0 0189      		ldd r16,Z+17
 7614 34e2 1289      		ldd r17,Z+18
 7615 34e4 2389      		ldd r18,Z+19
 7616 34e6 3489      		ldd r19,Z+20
 7617 34e8 4585      		ldd r20,Z+13
 7618 34ea 5685      		ldd r21,Z+14
 7619 34ec 6785      		ldd r22,Z+15
 7620 34ee 7089      		ldd r23,Z+16
 7621 34f0 0417      		cp r16,r20
 7622 34f2 1507      		cpc r17,r21
 7623 34f4 2607      		cpc r18,r22
 7624 34f6 3707      		cpc r19,r23
 7625 34f8 01F4      		brne .+2
 7626 34fa 00C0      		rjmp .L322
 7627               	.LVL340:
 7628               	.LBB499:
 7629               	.LBB500:
2043:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 7630               		.loc 1 2043 0
 7631 34fc 94E2      		ldi r25,lo8(36)
 7632 34fe 9A9F      		mul r25,r26
 7633 3500 F001      		movw r30,r0
 7634 3502 9B9F      		mul r25,r27
 7635 3504 F00D      		add r31,r0
 7636 3506 1124      		clr __zero_reg__
 7637 3508 E050      		subi r30,lo8(-(bankStates))
 7638 350a F040      		sbci r31,hi8(-(bankStates))
 7639 350c 9581      		ldd r25,Z+5
 7640 350e 9923      		tst r25
 7641 3510 01F0      		breq .L381
 7642 3512 9091 0000 		lds r25,sdIsrState
 7643 3516 9150      		subi r25,lo8(-(-1))
 7644 3518 9230      		cpi r25,lo8(2)
 7645 351a 00F0      		brlo .L382
 7646               	.L381:
2045:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 7647               		.loc 1 2045 0
 7648 351c 2FB7      		in r18,__SREG__
 7649               	.LVL341:
2046:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 7650               		.loc 1 2046 0
 7651               	/* #APP */
 7652               	 ;  2046 "WTPA.c" 1
 7653 351e F894      		cli
 7654               	 ;  0 "" 2
2048:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 7655               		.loc 1 2048 0
 7656               	/* #NOAPP */
 7657 3520 94E2      		ldi r25,lo8(36)
 7658 3522 9A9F      		mul r25,r26
 7659 3524 F001      		movw r30,r0
 7660 3526 9B9F      		mul r25,r27
 7661 3528 F00D      		add r31,r0
 7662 352a 1124      		clr __zero_reg__
 7663 352c E050      		subi r30,lo8(-(bankStates))
 7664 352e F040      		sbci r31,hi8(-(bankStates))
 7665 3530 94E0      		ldi r25,lo8(4)
 7666 3532 9083      		st Z,r25
 7667               	.LVL342:
 7668               	.LBB501:
 7669               	.LBB502:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 7670               		.loc 1 1925 0
 7671 3534 31E0      		ldi r19,lo8(1)
 7672 3536 3287      		std Z+10,r19
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 7673               		.loc 1 1948 0
 7674 3538 8823      		tst r24
 7675 353a 01F4      		brne .+2
 7676 353c 00C0      		rjmp .L685
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 7677               		.loc 1 1956 0
 7678 353e DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 7679               		.loc 1 1957 0
 7680 3540 9093 6800 		sts 104,r25
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 7681               		.loc 1 1958 0
 7682 3544 80E1      		ldi r24,lo8(16)
 7683               	.LVL343:
 7684 3546 8093 6D00 		sts 109,r24
 7685               	.L384:
 7686               	.LBE502:
 7687               	.LBE501:
2051:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 7688               		.loc 1 2051 0
 7689 354a 84E2      		ldi r24,lo8(36)
 7690 354c 8A9F      		mul r24,r26
 7691 354e F001      		movw r30,r0
 7692 3550 8B9F      		mul r24,r27
 7693 3552 F00D      		add r31,r0
 7694 3554 1124      		clr __zero_reg__
 7695 3556 E050      		subi r30,lo8(-(bankStates))
 7696 3558 F040      		sbci r31,hi8(-(bankStates))
 7697 355a 81E0      		ldi r24,lo8(1)
 7698 355c 8583      		std Z+5,r24
2052:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 7699               		.loc 1 2052 0
 7700 355e 2FBF      		out __SREG__,r18
 7701               	.LVL344:
 7702               	.L382:
 7703               	.LBE500:
 7704               	.LBE499:
4349:WTPA.c        **** 					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_V
 7705               		.loc 1 4349 0
 7706 3560 20E4      		ldi r18,lo8(64)
 7707 3562 40E3      		ldi r20,lo8(48)
 7708 3564 61E0      		ldi r22,lo8(1)
 7709 3566 8091 0000 		lds r24,currentBank
 7710 356a 0E94 0000 		call PutMidiMessageInOutgoingFifo
 7711               	.LVL345:
 7712 356e 00C0      		rjmp .L322
 7713               	.LVL346:
 7714               	.L678:
 7715               	.LBE531:
 7716               	.LBE587:
 7717               	.LBB588:
 7718               	.LBB589:
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7719               		.loc 1 3409 0
 7720 3570 2BEA      		ldi r18,lo8(-85)
 7721 3572 029F      		mul r16,r18
 7722 3574 212D      		mov r18,r1
 7723 3576 1124      		clr __zero_reg__
 7724 3578 2695      		lsr r18
 7725 357a 2695      		lsr r18
 7726 357c 2695      		lsr r18
 7727 357e 822F      		mov r24,r18
 7728 3580 880F      		lsl r24
 7729 3582 820F      		add r24,r18
 7730 3584 880F      		lsl r24
 7731 3586 880F      		lsl r24
 7732 3588 A02F      		mov r26,r16
 7733 358a A81B      		sub r26,r24
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7734               		.loc 1 3411 0
 7735 358c B0E0      		ldi r27,0
 7736 358e AA0F      		lsl r26
 7737 3590 BB1F      		rol r27
 7738 3592 A050      		subi r26,lo8(-(OctaveZeroCompareMatches))
 7739 3594 B040      		sbci r27,hi8(-(OctaveZeroCompareMatches))
 7740 3596 8D91      		ld r24,X+
 7741 3598 9C91      		ld r25,X
 7742 359a 00C0      		rjmp 2f
 7743               		1:
 7744 359c 9695      		lsr r25
 7745 359e 8795      		ror r24
 7746               		2:
 7747 35a0 2A95      		dec r18
 7748 35a2 02F4      		brpl 1b
 7749               	.LVL347:
 7750               	.LBE589:
 7751               	.LBE588:
 7752               	.LBB590:
 7753               	.LBB591:
2091:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 7754               		.loc 1 2091 0
 7755 35a4 5FB7      		in r21,__SREG__
 7756               	.LVL348:
2092:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 7757               		.loc 1 2092 0
 7758               	/* #APP */
 7759               	 ;  2092 "WTPA.c" 1
 7760 35a6 F894      		cli
 7761               	 ;  0 "" 2
2094:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 7762               		.loc 1 2094 0
 7763               	/* #NOAPP */
 7764 35a8 22E0      		ldi r18,lo8(2)
 7765 35aa 2083      		st Z,r18
 7766               	.LVL349:
 7767               	.LBB592:
 7768               	.LBB593:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 7769               		.loc 1 1925 0
 7770 35ac 2287      		std Z+10,r18
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 7771               		.loc 1 1929 0
 7772 35ae 9487      		std Z+12,r25
 7773 35b0 8387      		std Z+11,r24
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 7774               		.loc 1 1933 0
 7775 35b2 2091 8400 		lds r18,132
 7776 35b6 3091 8500 		lds r19,132+1
 7777 35ba 280F      		add r18,r24
 7778 35bc 391F      		adc r19,r25
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 7779               		.loc 1 1931 0
 7780 35be 1111      		cpse r17,__zero_reg__
 7781 35c0 00C0      		rjmp .L391
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 7782               		.loc 1 1933 0
 7783 35c2 3093 8900 		sts 136+1,r19
 7784 35c6 2093 8800 		sts 136,r18
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 7785               		.loc 1 1934 0
 7786 35ca B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 7787               		.loc 1 1935 0
 7788 35cc 8091 6F00 		lds r24,111
 7789               	.LVL350:
 7790 35d0 8260      		ori r24,lo8(2)
 7791 35d2 8093 6F00 		sts 111,r24
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 7792               		.loc 1 1936 0
 7793 35d6 4093 8100 		sts 129,r20
 7794               	.L392:
 7795               	.LBE593:
 7796               	.LBE592:
2097:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 7797               		.loc 1 2097 0
 7798 35da 5FBF      		out __SREG__,r21
2099:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 7799               		.loc 1 2099 0
 7800 35dc 8091 7A00 		lds r24,122
 7801 35e0 86FF      		sbrs r24,6
 7802 35e2 00C0      		rjmp .+4
 7803 35e4 0C94 0000 		jmp .L650
 7804               	.LBB595:
 7805               	.LBB596:
2101:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 7806               		.loc 1 2101 0
 7807 35e8 8091 7900 		lds r24,121
 7808 35ec 8058      		subi r24,lo8(-(-128))
 7809 35ee 8093 0000 		sts adcByte,r24
2102:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 7810               		.loc 1 2102 0
 7811 35f2 8091 7A00 		lds r24,122
 7812 35f6 8064      		ori r24,lo8(64)
 7813 35f8 8093 7A00 		sts 122,r24
 7814 35fc 6091 0000 		lds r22,sdIsrState
 7815 3600 0C94 0000 		jmp .L318
 7816               	.LVL351:
 7817               	.L676:
 7818               	.LBE596:
 7819               	.LBE595:
 7820               	.LBE591:
 7821               	.LBE590:
 7822               	.LBB599:
 7823               	.LBB532:
 7824               	.LBB508:
 7825               	.LBB468:
 7826               	.LBB466:
 7827               	.LBB465:
 7828               	.LBB463:
 7829               	.LBB464:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 7830               		.loc 1 1950 0
 7831 3604 9091 8100 		lds r25,129
 7832 3608 9064      		ori r25,lo8(64)
 7833 360a 9093 8100 		sts 129,r25
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 7834               		.loc 1 1951 0
 7835 360e B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7836               		.loc 1 1952 0
 7837 3610 9091 6F00 		lds r25,111
 7838 3614 9062      		ori r25,lo8(32)
 7839 3616 9093 6F00 		sts 111,r25
 7840 361a 00C0      		rjmp .L353
 7841               	.LVL352:
 7842               	.L453:
 7843               	.LBE464:
 7844               	.LBE463:
 7845               	.LBE465:
 7846               	.LBE466:
 7847               	.LBE468:
 7848               	.LBE508:
 7849               	.LBE532:
 7850               	.LBE599:
4628:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7851               		.loc 1 4628 0
 7852 361c 2091 0000 		lds r18,currentMidiMessage.2230
 7853 3620 30E0      		ldi r19,0
 7854 3622 F901      		movw r30,r18
 7855 3624 E050      		subi r30,lo8(-(currentNoteOn.2231))
 7856 3626 F040      		sbci r31,hi8(-(currentNoteOn.2231))
 7857 3628 9081      		ld r25,Z
 7858               	.LVL353:
 7859               	.LBB600:
 7860               	.LBB601:
3409:WTPA.c        **** 	theIndex=(theNote%12);	// Which note inside the octave?
 7861               		.loc 1 3409 0
 7862 362a 4BEA      		ldi r20,lo8(-85)
 7863 362c 949F      		mul r25,r20
 7864 362e 412D      		mov r20,r1
 7865 3630 1124      		clr __zero_reg__
 7866 3632 4695      		lsr r20
 7867 3634 4695      		lsr r20
 7868 3636 4695      		lsr r20
 7869 3638 842F      		mov r24,r20
 7870               	.LVL354:
 7871 363a 880F      		lsl r24
 7872 363c 840F      		add r24,r20
 7873 363e 880F      		lsl r24
 7874 3640 880F      		lsl r24
 7875 3642 981B      		sub r25,r24
 7876               	.LVL355:
3411:WTPA.c        **** 	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup tab
 7877               		.loc 1 3411 0
 7878 3644 E92F      		mov r30,r25
 7879               	.LVL356:
 7880 3646 F0E0      		ldi r31,0
 7881 3648 EE0F      		lsl r30
 7882 364a FF1F      		rol r31
 7883 364c E050      		subi r30,lo8(-(OctaveZeroCompareMatches))
 7884 364e F040      		sbci r31,hi8(-(OctaveZeroCompareMatches))
 7885 3650 8081      		ld r24,Z
 7886 3652 9181      		ldd r25,Z+1
 7887 3654 00C0      		rjmp 2f
 7888               		1:
 7889 3656 9695      		lsr r25
 7890 3658 8795      		ror r24
 7891               		2:
 7892 365a 4A95      		dec r20
 7893 365c 02F4      		brpl 1b
 7894               	.LBE601:
 7895               	.LBE600:
4628:WTPA.c        **** 					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(c
 7896               		.loc 1 4628 0
 7897 365e 44E2      		ldi r20,lo8(36)
 7898 3660 429F      		mul r20,r18
 7899 3662 F001      		movw r30,r0
 7900 3664 439F      		mul r20,r19
 7901 3666 F00D      		add r31,r0
 7902 3668 1124      		clr __zero_reg__
 7903 366a E050      		subi r30,lo8(-(bankStates))
 7904 366c F040      		sbci r31,hi8(-(bankStates))
 7905 366e 9487      		std Z+12,r25
 7906 3670 8387      		std Z+11,r24
 7907 3672 0C94 0000 		jmp .L650
 7908               	.LVL357:
 7909               	.L399:
 7910               	.LBB602:
 7911               	.LBB549:
 7912               	.LBB548:
 7913               	.LBB547:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 7914               		.loc 1 1940 0
 7915 3676 9093 8B00 		sts 138+1,r25
 7916 367a 8093 8A00 		sts 138,r24
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 7917               		.loc 1 1941 0
 7918 367e B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 7919               		.loc 1 1942 0
 7920 3680 8091 6F00 		lds r24,111
 7921 3684 8460      		ori r24,lo8(4)
 7922 3686 8093 6F00 		sts 111,r24
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 7923               		.loc 1 1943 0
 7924 368a 81E0      		ldi r24,lo8(1)
 7925 368c 8093 8100 		sts 129,r24
 7926 3690 00C0      		rjmp .L400
 7927               	.LVL358:
 7928               	.L397:
 7929               	.LBE547:
 7930               	.LBE548:
2026:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 7931               		.loc 1 2026 0
 7932 3692 818D      		ldd r24,Z+25
 7933 3694 928D      		ldd r25,Z+26
 7934 3696 A38D      		ldd r26,Z+27
 7935 3698 B48D      		ldd r27,Z+28
 7936 369a 80A3      		std Z+32,r24
 7937 369c 91A3      		std Z+33,r25
 7938 369e A2A3      		std Z+34,r26
 7939 36a0 B3A3      		std Z+35,r27
2027:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 7940               		.loc 1 2027 0
 7941 36a2 81E0      		ldi r24,lo8(1)
 7942 36a4 8483      		std Z+4,r24
 7943 36a6 00C0      		rjmp .L398
 7944               	.LVL359:
 7945               	.L672:
 7946               	.LBE549:
 7947               	.LBE602:
 7948               	.LBB603:
 7949               	.LBB533:
 7950               	.LBB509:
 7951               	.LBB446:
 7952               	.LBB445:
 7953               	.LBB442:
 7954               	.LBB440:
 7955               	.LBB441:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 7956               		.loc 1 1950 0
 7957 36a8 9091 8100 		lds r25,129
 7958 36ac 9064      		ori r25,lo8(64)
 7959 36ae 9093 8100 		sts 129,r25
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 7960               		.loc 1 1951 0
 7961 36b2 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 7962               		.loc 1 1952 0
 7963 36b4 9091 6F00 		lds r25,111
 7964 36b8 9062      		ori r25,lo8(32)
 7965 36ba 9093 6F00 		sts 111,r25
 7966 36be 00C0      		rjmp .L363
 7967               	.LVL360:
 7968               	.L368:
 7969               	.LBE441:
 7970               	.LBE440:
 7971               	.LBE442:
 7972               	.LBE445:
 7973               	.LBE446:
 7974               	.LBE509:
 7975               	.LBB510:
 7976               	.LBB457:
2026:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 7977               		.loc 1 2026 0
 7978 36c0 5996      		adiw r26,25
 7979 36c2 4D91      		ld r20,X+
 7980 36c4 5D91      		ld r21,X+
 7981 36c6 6D91      		ld r22,X+
 7982 36c8 7C91      		ld r23,X
 7983 36ca 5C97      		sbiw r26,25+3
 7984 36cc 9096      		adiw r26,32
 7985 36ce 4D93      		st X+,r20
 7986 36d0 5D93      		st X+,r21
 7987 36d2 6D93      		st X+,r22
 7988 36d4 7C93      		st X,r23
 7989 36d6 9397      		sbiw r26,32+3
2027:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 7990               		.loc 1 2027 0
 7991 36d8 21E0      		ldi r18,lo8(1)
 7992 36da 1496      		adiw r26,4
 7993 36dc 2C93      		st X,r18
 7994 36de 00C0      		rjmp .L369
 7995               	.LVL361:
 7996               	.L379:
 7997               	.LBE457:
 7998               	.LBE510:
4360:WTPA.c        **** 		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
 7999               		.loc 1 4360 0
 8000 36e0 85FF      		sbrs r24,5
 8001 36e2 00C0      		rjmp .L322
4362:WTPA.c        **** 			currentBank++;
 8002               		.loc 1 4362 0
 8003 36e4 8091 0000 		lds r24,currentBank
 8004 36e8 8F5F      		subi r24,lo8(-(1))
 8005 36ea 8093 0000 		sts currentBank,r24
4363:WTPA.c        **** 			if(currentBank>=NUM_BANKS)
 8006               		.loc 1 4363 0
 8007 36ee 8230      		cpi r24,lo8(2)
 8008 36f0 00F4      		brsh .+2
 8009 36f2 00C0      		rjmp .L322
4365:WTPA.c        **** 				currentBank=BANK_0;		// Loop around.
 8010               		.loc 1 4365 0
 8011 36f4 1092 0000 		sts currentBank,__zero_reg__
 8012 36f8 00C0      		rjmp .L322
 8013               	.LVL362:
 8014               	.L391:
 8015               	.LBE533:
 8016               	.LBE603:
 8017               	.LBB604:
 8018               	.LBB598:
 8019               	.LBB597:
 8020               	.LBB594:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8021               		.loc 1 1940 0
 8022 36fa 3093 8B00 		sts 138+1,r19
 8023 36fe 2093 8A00 		sts 138,r18
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 8024               		.loc 1 1941 0
 8025 3702 B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 8026               		.loc 1 1942 0
 8027 3704 8091 6F00 		lds r24,111
 8028               	.LVL363:
 8029 3708 8460      		ori r24,lo8(4)
 8030 370a 8093 6F00 		sts 111,r24
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8031               		.loc 1 1943 0
 8032 370e 4093 8100 		sts 129,r20
 8033 3712 00C0      		rjmp .L392
 8034               	.LVL364:
 8035               	.L671:
 8036               	.LBE594:
 8037               	.LBE597:
 8038               	.LBE598:
 8039               	.LBE604:
 8040               	.LBB605:
 8041               	.LBB534:
 8042               	.LBB511:
 8043               	.LBB512:
2043:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 8044               		.loc 1 2043 0
 8045 3714 1596      		adiw r26, 5
 8046 3716 8C91      		ld r24,X
 8047 3718 8823      		tst r24
 8048 371a 01F0      		breq .L356
 8049 371c 8091 0000 		lds r24,sdIsrState
 8050 3720 8150      		subi r24,lo8(-(-1))
 8051 3722 8230      		cpi r24,lo8(2)
 8052 3724 00F0      		brlo .L357
 8053               	.L356:
2045:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 8054               		.loc 1 2045 0
 8055 3726 9FB7      		in r25,__SREG__
 8056               	.LVL365:
2046:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 8057               		.loc 1 2046 0
 8058               	/* #APP */
 8059               	 ;  2046 "WTPA.c" 1
 8060 3728 F894      		cli
 8061               	 ;  0 "" 2
2048:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 8062               		.loc 1 2048 0
 8063               	/* #NOAPP */
 8064 372a 84E2      		ldi r24,lo8(36)
 8065 372c 8E9D      		mul r24,r14
 8066 372e D001      		movw r26,r0
 8067 3730 8F9D      		mul r24,r15
 8068 3732 B00D      		add r27,r0
 8069 3734 1124      		clr __zero_reg__
 8070 3736 A050      		subi r26,lo8(-(bankStates))
 8071 3738 B040      		sbci r27,hi8(-(bankStates))
 8072 373a 84E0      		ldi r24,lo8(4)
 8073 373c 8C93      		st X,r24
 8074               	.LVL366:
 8075               	.LBB513:
 8076               	.LBB514:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 8077               		.loc 1 1925 0
 8078 373e 21E0      		ldi r18,lo8(1)
 8079 3740 1A96      		adiw r26,10
 8080 3742 2C93      		st X,r18
1948:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample 
 8081               		.loc 1 1948 0
 8082 3744 EE23      		tst r30
 8083 3746 01F4      		brne .+2
 8084 3748 00C0      		rjmp .L686
1956:WTPA.c        **** 			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
 8085               		.loc 1 1956 0
 8086 374a DA9A      		sbi 0x1b,2
1957:WTPA.c        **** 			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
 8087               		.loc 1 1957 0
 8088 374c 8093 6800 		sts 104,r24
1958:WTPA.c        **** 			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
 8089               		.loc 1 1958 0
 8090 3750 80E1      		ldi r24,lo8(16)
 8091 3752 8093 6D00 		sts 109,r24
 8092               	.L359:
 8093               	.LBE514:
 8094               	.LBE513:
2051:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 8095               		.loc 1 2051 0
 8096 3756 84E2      		ldi r24,lo8(36)
 8097 3758 8E9D      		mul r24,r14
 8098 375a F001      		movw r30,r0
 8099 375c 8F9D      		mul r24,r15
 8100 375e F00D      		add r31,r0
 8101 3760 1124      		clr __zero_reg__
 8102 3762 E050      		subi r30,lo8(-(bankStates))
 8103 3764 F040      		sbci r31,hi8(-(bankStates))
 8104 3766 81E0      		ldi r24,lo8(1)
 8105 3768 8583      		std Z+5,r24
2052:WTPA.c        **** 		SREG=sreg;		// Restore interrupts.
 8106               		.loc 1 2052 0
 8107 376a 9FBF      		out __SREG__,r25
 8108 376c E091 0000 		lds r30,currentBank
 8109               	.LVL367:
 8110               	.L357:
 8111               	.LBE512:
 8112               	.LBE511:
4312:WTPA.c        **** 				bankStates[currentBank].loopOnce=false;
 8113               		.loc 1 4312 0
 8114 3770 F4E2      		ldi r31,lo8(36)
 8115 3772 EF9F      		mul r30,r31
 8116 3774 D001      		movw r26,r0
 8117 3776 1124      		clr __zero_reg__
 8118 3778 A050      		subi r26,lo8(-(bankStates))
 8119 377a B040      		sbci r27,hi8(-(bankStates))
 8120 377c 1196      		adiw r26,1
 8121 377e 1C92      		st X,__zero_reg__
4313:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send 
 8122               		.loc 1 4313 0
 8123 3780 20E0      		ldi r18,0
 8124 3782 49E0      		ldi r20,lo8(9)
 8125 3784 64E0      		ldi r22,lo8(4)
 8126 3786 8E2F      		mov r24,r30
 8127 3788 0E94 0000 		call PutMidiMessageInOutgoingFifo
 8128               	.LVL368:
 8129 378c 00C0      		rjmp .L322
 8130               	.LVL369:
 8131               	.L675:
 8132               	.LBB520:
 8133               	.LBB458:
 8134               	.LBB456:
 8135               	.LBB455:
 8136               	.LBB453:
 8137               	.LBB454:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 8138               		.loc 1 1950 0
 8139 378e 8091 8100 		lds r24,129
 8140               	.LVL370:
 8141 3792 8064      		ori r24,lo8(64)
 8142 3794 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 8143               		.loc 1 1951 0
 8144 3798 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 8145               		.loc 1 1952 0
 8146 379a 8091 6F00 		lds r24,111
 8147 379e 8062      		ori r24,lo8(32)
 8148 37a0 8093 6F00 		sts 111,r24
 8149 37a4 00C0      		rjmp .L371
 8150               	.LVL371:
 8151               	.L375:
 8152               	.LBE454:
 8153               	.LBE453:
 8154               	.LBE455:
 8155               	.LBE456:
 8156               	.LBE458:
 8157               	.LBE520:
 8158               	.LBB521:
 8159               	.LBB495:
2026:WTPA.c        **** 			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beg
 8160               		.loc 1 2026 0
 8161 37a6 5996      		adiw r26,25
 8162 37a8 4D91      		ld r20,X+
 8163 37aa 5D91      		ld r21,X+
 8164 37ac 6D91      		ld r22,X+
 8165 37ae 7C91      		ld r23,X
 8166 37b0 5C97      		sbiw r26,25+3
 8167 37b2 9096      		adiw r26,32
 8168 37b4 4D93      		st X+,r20
 8169 37b6 5D93      		st X+,r21
 8170 37b8 6D93      		st X+,r22
 8171 37ba 7C93      		st X,r23
 8172 37bc 9397      		sbiw r26,32+3
2027:WTPA.c        **** 			bankStates[theBank].sampleDirection=true;	// make us run forwards.
 8173               		.loc 1 2027 0
 8174 37be 81E0      		ldi r24,lo8(1)
 8175 37c0 1496      		adiw r26,4
 8176 37c2 8C93      		st X,r24
 8177 37c4 00C0      		rjmp .L376
 8178               	.LVL372:
 8179               	.L684:
 8180               	.LBB494:
 8181               	.LBB493:
 8182               	.LBB491:
 8183               	.LBB492:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 8184               		.loc 1 1950 0
 8185 37c6 8091 8100 		lds r24,129
 8186 37ca 8064      		ori r24,lo8(64)
 8187 37cc 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 8188               		.loc 1 1951 0
 8189 37d0 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 8190               		.loc 1 1952 0
 8191 37d2 8091 6F00 		lds r24,111
 8192 37d6 8062      		ori r24,lo8(32)
 8193 37d8 8093 6F00 		sts 111,r24
 8194 37dc 00C0      		rjmp .L378
 8195               	.LVL373:
 8196               	.L686:
 8197               	.LBE492:
 8198               	.LBE491:
 8199               	.LBE493:
 8200               	.LBE494:
 8201               	.LBE495:
 8202               	.LBE521:
 8203               	.LBB522:
 8204               	.LBB519:
 8205               	.LBB518:
 8206               	.LBB517:
 8207               	.LBB515:
 8208               	.LBB516:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 8209               		.loc 1 1950 0
 8210 37de 8091 8100 		lds r24,129
 8211 37e2 8064      		ori r24,lo8(64)
 8212 37e4 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 8213               		.loc 1 1951 0
 8214 37e8 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 8215               		.loc 1 1952 0
 8216 37ea 8091 6F00 		lds r24,111
 8217 37ee 8062      		ori r24,lo8(32)
 8218 37f0 8093 6F00 		sts 111,r24
 8219 37f4 00C0      		rjmp .L359
 8220               	.LVL374:
 8221               	.L380:
 8222               	.LBE516:
 8223               	.LBE515:
 8224               	.LBE517:
 8225               	.LBE518:
 8226               	.LBE519:
 8227               	.LBE522:
4354:WTPA.c        **** 				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
 8228               		.loc 1 4354 0
 8229 37f6 1082      		st Z,__zero_reg__
4355:WTPA.c        **** 				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
 8230               		.loc 1 4355 0
 8231 37f8 1286      		std Z+10,__zero_reg__
4356:WTPA.c        **** 				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send i
 8232               		.loc 1 4356 0
 8233 37fa 20E0      		ldi r18,0
 8234 37fc 40E3      		ldi r20,lo8(48)
 8235 37fe 62E0      		ldi r22,lo8(2)
 8236 3800 0E94 0000 		call PutMidiMessageInOutgoingFifo
 8237               	.LVL375:
 8238 3804 0C94 0000 		jmp .L322
 8239               	.LVL376:
 8240               	.L685:
 8241               	.LBB523:
 8242               	.LBB507:
 8243               	.LBB506:
 8244               	.LBB505:
 8245               	.LBB503:
 8246               	.LBB504:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 8247               		.loc 1 1950 0
 8248 3808 8091 8100 		lds r24,129
 8249               	.LVL377:
 8250 380c 8064      		ori r24,lo8(64)
 8251 380e 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 8252               		.loc 1 1951 0
 8253 3812 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 8254               		.loc 1 1952 0
 8255 3814 8091 6F00 		lds r24,111
 8256 3818 8062      		ori r24,lo8(32)
 8257 381a 8093 6F00 		sts 111,r24
 8258 381e 00C0      		rjmp .L384
 8259               	.LVL378:
 8260               	.L425:
 8261               	.LBE504:
 8262               	.LBE503:
 8263               	.LBE505:
 8264               	.LBE506:
 8265               	.LBE507:
 8266               	.LBE523:
 8267               	.LBE534:
 8268               	.LBE605:
4461:WTPA.c        **** 					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must alr
 8269               		.loc 1 4461 0
 8270 3820 2091 0000 		lds r18,currentMidiMessage.2230
 8271 3824 822F      		mov r24,r18
 8272 3826 90E0      		ldi r25,0
 8273 3828 B4E2      		ldi r27,lo8(36)
 8274 382a 2B9F      		mul r18,r27
 8275 382c F001      		movw r30,r0
 8276 382e 1124      		clr __zero_reg__
 8277 3830 E050      		subi r30,lo8(-(bankStates))
 8278 3832 F040      		sbci r31,hi8(-(bankStates))
 8279 3834 3081      		ld r19,Z
 8280 3836 3530      		cpi r19,lo8(5)
 8281 3838 01F0      		breq .+4
 8282 383a 0C94 0000 		jmp .L650
4463:WTPA.c        **** 						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessa
 8283               		.loc 1 4463 0
 8284 383e DC01      		movw r26,r24
 8285 3840 A050      		subi r26,lo8(-(currentNoteOn.2231))
 8286 3842 B040      		sbci r27,hi8(-(currentNoteOn.2231))
 8287 3844 4C91      		ld r20,X
 8288 3846 50E0      		ldi r21,0
 8289               	.LVL379:
 8290               	.LBB606:
 8291               	.LBB556:
2043:WTPA.c        **** 	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_R
 8292               		.loc 1 2043 0
 8293 3848 3581      		ldd r19,Z+5
 8294 384a 3323      		tst r19
 8295 384c 01F0      		breq .L432
 8296 384e 6091 0000 		lds r22,sdIsrState
 8297 3852 362F      		mov r19,r22
 8298 3854 3150      		subi r19,lo8(-(-1))
 8299 3856 3230      		cpi r19,lo8(2)
 8300 3858 00F4      		brsh .+4
 8301 385a 0C94 0000 		jmp .L491
 8302               	.L432:
2045:WTPA.c        **** 		sreg=SREG;	// Store global interrupt state.
 8303               		.loc 1 2045 0
 8304 385e 6FB7      		in r22,__SREG__
 8305               	.LVL380:
2046:WTPA.c        **** 		cli();		// Disable interrupts while we muck with the settings.
 8306               		.loc 1 2046 0
 8307               	/* #APP */
 8308               	 ;  2046 "WTPA.c" 1
 8309 3860 F894      		cli
 8310               	 ;  0 "" 2
2048:WTPA.c        **** 		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the
 8311               		.loc 1 2048 0
 8312               	/* #NOAPP */
 8313 3862 34E2      		ldi r19,lo8(36)
 8314 3864 389F      		mul r19,r24
 8315 3866 F001      		movw r30,r0
 8316 3868 399F      		mul r19,r25
 8317 386a F00D      		add r31,r0
 8318 386c 1124      		clr __zero_reg__
 8319 386e E050      		subi r30,lo8(-(bankStates))
 8320 3870 F040      		sbci r31,hi8(-(bankStates))
 8321 3872 34E0      		ldi r19,lo8(4)
 8322 3874 3083      		st Z,r19
 8323               	.LVL381:
 8324               	.LBB552:
 8325               	.LBB553:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 8326               		.loc 1 1925 0
 8327 3876 32E0      		ldi r19,lo8(2)
 8328 3878 3287      		std Z+10,r19
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 8329               		.loc 1 1929 0
 8330 387a 5487      		std Z+12,r21
 8331 387c 4387      		std Z+11,r20
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 8332               		.loc 1 1931 0
 8333 387e 2111      		cpse r18,__zero_reg__
 8334 3880 00C0      		rjmp .L433
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8335               		.loc 1 1933 0
 8336 3882 2091 8400 		lds r18,132
 8337 3886 3091 8500 		lds r19,132+1
 8338               	.LVL382:
 8339 388a 240F      		add r18,r20
 8340 388c 351F      		adc r19,r21
 8341 388e 3093 8900 		sts 136+1,r19
 8342 3892 2093 8800 		sts 136,r18
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 8343               		.loc 1 1934 0
 8344 3896 B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 8345               		.loc 1 1935 0
 8346 3898 2091 6F00 		lds r18,111
 8347 389c 2260      		ori r18,lo8(2)
 8348 389e 2093 6F00 		sts 111,r18
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8349               		.loc 1 1936 0
 8350 38a2 21E0      		ldi r18,lo8(1)
 8351 38a4 2093 8100 		sts 129,r18
 8352               	.L434:
 8353               	.LBE553:
 8354               	.LBE552:
2051:WTPA.c        **** 		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
 8355               		.loc 1 2051 0
 8356 38a8 24E2      		ldi r18,lo8(36)
 8357 38aa 289F      		mul r18,r24
 8358 38ac F001      		movw r30,r0
 8359 38ae 299F      		mul r18,r25
 8360 38b0 F00D      		add r31,r0
 8361 38b2 1124      		clr __zero_reg__
 8362 38b4 00C0      		rjmp .L651
 8363               	.LVL383:
 8364               	.L681:
 8365               	.LBE556:
 8366               	.LBE606:
4545:WTPA.c        **** 					switch(currentMidiMessage.dataByteTwo)
 8367               		.loc 1 4545 0
 8368 38b6 8230      		cpi r24,lo8(2)
 8369 38b8 01F4      		brne .+2
 8370 38ba 00C0      		rjmp .L448
 8371 38bc 8330      		cpi r24,lo8(3)
 8372 38be 01F0      		breq .+4
 8373 38c0 0C94 0000 		jmp .L650
4560:WTPA.c        **** 						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combinat
 8374               		.loc 1 4560 0
 8375 38c4 80E0      		ldi r24,lo8(gs(OutputXorBanks))
 8376 38c6 90E0      		ldi r25,hi8(gs(OutputXorBanks))
 8377 38c8 9093 0000 		sts UpdateOutput+1,r25
 8378 38cc 8093 0000 		sts UpdateOutput,r24
 8379 38d0 6091 0000 		lds r22,sdIsrState
4561:WTPA.c        **** 						break;
 8380               		.loc 1 4561 0
 8381 38d4 0C94 0000 		jmp .L318
 8382               	.L442:
4511:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
 8383               		.loc 1 4511 0
 8384 38d8 24E2      		ldi r18,lo8(36)
 8385 38da E29F      		mul r30,r18
 8386 38dc F001      		movw r30,r0
 8387 38de 1124      		clr __zero_reg__
 8388 38e0 E050      		subi r30,lo8(-(bankStates))
 8389 38e2 F040      		sbci r31,hi8(-(bankStates))
 8390 38e4 1382      		std Z+3,__zero_reg__
 8391 38e6 00C0      		rjmp .L443
 8392               	.L441:
4500:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
 8393               		.loc 1 4500 0
 8394 38e8 A4E2      		ldi r26,lo8(36)
 8395 38ea EA9F      		mul r30,r26
 8396 38ec F001      		movw r30,r0
 8397 38ee 1124      		clr __zero_reg__
 8398 38f0 E050      		subi r30,lo8(-(bankStates))
 8399 38f2 F040      		sbci r31,hi8(-(bankStates))
 8400 38f4 1282      		std Z+2,__zero_reg__
 8401 38f6 6091 0000 		lds r22,sdIsrState
 8402 38fa 0C94 0000 		jmp .L318
 8403               	.L440:
4489:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
 8404               		.loc 1 4489 0
 8405 38fe 84E2      		ldi r24,lo8(36)
 8406 3900 E89F      		mul r30,r24
 8407 3902 F001      		movw r30,r0
 8408 3904 1124      		clr __zero_reg__
 8409 3906 E050      		subi r30,lo8(-(bankStates))
 8410 3908 F040      		sbci r31,hi8(-(bankStates))
 8411 390a 81E0      		ldi r24,lo8(1)
 8412 390c 8183      		std Z+1,r24
 8413 390e 6091 0000 		lds r22,sdIsrState
 8414 3912 0C94 0000 		jmp .L318
 8415               	.L683:
4442:WTPA.c        **** 						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMes
 8416               		.loc 1 4442 0
 8417 3916 8091 0000 		lds r24,currentMidiMessage.2230
 8418 391a E82F      		mov r30,r24
 8419 391c F0E0      		ldi r31,0
 8420 391e EE0F      		lsl r30
 8421 3920 FF1F      		rol r31
 8422 3922 E050      		subi r30,lo8(-(theMidiRecordRate))
 8423 3924 F040      		sbci r31,hi8(-(theMidiRecordRate))
 8424 3926 4081      		ld r20,Z
 8425 3928 5181      		ldd r21,Z+1
 8426 392a 62E0      		ldi r22,lo8(2)
 8427 392c 0E94 0000 		call StartRecording
 8428               	.LVL384:
4443:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll defa
 8429               		.loc 1 4443 0
 8430 3930 E091 0000 		lds r30,currentMidiMessage.2230
 8431 3934 44E2      		ldi r20,lo8(36)
 8432 3936 E49F      		mul r30,r20
 8433 3938 F001      		movw r30,r0
 8434 393a 1124      		clr __zero_reg__
 8435 393c E050      		subi r30,lo8(-(bankStates))
 8436 393e F040      		sbci r31,hi8(-(bankStates))
 8437 3940 1682      		std Z+6,__zero_reg__
 8438 3942 6091 0000 		lds r22,sdIsrState
 8439 3946 0C94 0000 		jmp .L318
 8440               	.LVL385:
 8441               	.L429:
 8442               	.LBB607:
 8443               	.LBB586:
 8444               	.LBB585:
 8445               	.LBB582:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8446               		.loc 1 1940 0
 8447 394a 9093 8B00 		sts 138+1,r25
 8448 394e 8093 8A00 		sts 138,r24
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 8449               		.loc 1 1941 0
 8450 3952 B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 8451               		.loc 1 1942 0
 8452 3954 8091 6F00 		lds r24,111
 8453 3958 8460      		ori r24,lo8(4)
 8454 395a 8093 6F00 		sts 111,r24
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8455               		.loc 1 1943 0
 8456 395e 81E0      		ldi r24,lo8(1)
 8457 3960 8093 8100 		sts 129,r24
 8458 3964 00C0      		rjmp .L430
 8459               	.LVL386:
 8460               	.L682:
 8461               	.LBE582:
 8462               	.LBE585:
 8463               	.LBE586:
 8464               	.LBE607:
4470:WTPA.c        **** 						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMess
 8465               		.loc 1 4470 0
 8466 3966 4091 0000 		lds r20,currentMidiMessage.2230
 8467 396a 842F      		mov r24,r20
 8468 396c 90E0      		ldi r25,0
 8469 396e FC01      		movw r30,r24
 8470 3970 EE0F      		lsl r30
 8471 3972 FF1F      		rol r31
 8472 3974 E050      		subi r30,lo8(-(theMidiRecordRate))
 8473 3976 F040      		sbci r31,hi8(-(theMidiRecordRate))
 8474 3978 2081      		ld r18,Z
 8475 397a 3181      		ldd r19,Z+1
 8476               	.LVL387:
 8477               	.LBB608:
 8478               	.LBB609:
2091:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state.
 8479               		.loc 1 2091 0
 8480 397c 5FB7      		in r21,__SREG__
 8481               	.LVL388:
2092:WTPA.c        **** 	cli();		// Disable interrupts while we muck with the settings.
 8482               		.loc 1 2092 0
 8483               	/* #APP */
 8484               	 ;  2092 "WTPA.c" 1
 8485 397e F894      		cli
 8486               	 ;  0 "" 2
2094:WTPA.c        **** 	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the 
 8487               		.loc 1 2094 0
 8488               	/* #NOAPP */
 8489 3980 64E2      		ldi r22,lo8(36)
 8490 3982 689F      		mul r22,r24
 8491 3984 F001      		movw r30,r0
 8492 3986 699F      		mul r22,r25
 8493 3988 F00D      		add r31,r0
 8494 398a 1124      		clr __zero_reg__
 8495 398c E050      		subi r30,lo8(-(bankStates))
 8496 398e F040      		sbci r31,hi8(-(bankStates))
 8497 3990 82E0      		ldi r24,lo8(2)
 8498 3992 8083      		st Z,r24
 8499               	.LVL389:
 8500               	.LBB610:
 8501               	.LBB611:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 8502               		.loc 1 1925 0
 8503 3994 8287      		std Z+10,r24
1929:WTPA.c        **** 		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this va
 8504               		.loc 1 1929 0
 8505 3996 3487      		std Z+12,r19
 8506 3998 2387      		std Z+11,r18
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8507               		.loc 1 1933 0
 8508 399a 8091 8400 		lds r24,132
 8509 399e 9091 8500 		lds r25,132+1
 8510 39a2 820F      		add r24,r18
 8511 39a4 931F      		adc r25,r19
1931:WTPA.c        **** 		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
 8512               		.loc 1 1931 0
 8513 39a6 4111      		cpse r20,__zero_reg__
 8514 39a8 00C0      		rjmp .L436
1933:WTPA.c        **** 			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8515               		.loc 1 1933 0
 8516 39aa 9093 8900 		sts 136+1,r25
 8517 39ae 8093 8800 		sts 136,r24
1934:WTPA.c        **** 			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
 8518               		.loc 1 1934 0
 8519 39b2 B19A      		sbi 0x16,1
1935:WTPA.c        **** 			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
 8520               		.loc 1 1935 0
 8521 39b4 8091 6F00 		lds r24,111
 8522 39b8 8260      		ori r24,lo8(2)
 8523 39ba 8093 6F00 		sts 111,r24
1936:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8524               		.loc 1 1936 0
 8525 39be 81E0      		ldi r24,lo8(1)
 8526 39c0 8093 8100 		sts 129,r24
 8527               	.L437:
 8528               	.LBE611:
 8529               	.LBE610:
2097:WTPA.c        **** 	SREG=sreg;		// Restore interrupts.
 8530               		.loc 1 2097 0
 8531 39c4 5FBF      		out __SREG__,r21
2099:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 8532               		.loc 1 2099 0
 8533 39c6 8091 7A00 		lds r24,122
 8534 39ca 86FD      		sbrc r24,6
 8535 39cc 00C0      		rjmp .L438
 8536               	.LBB613:
 8537               	.LBB614:
2101:WTPA.c        **** 		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using bot
 8538               		.loc 1 2101 0
 8539 39ce 8091 7900 		lds r24,121
 8540 39d2 8058      		subi r24,lo8(-(-128))
 8541 39d4 8093 0000 		sts adcByte,r24
2102:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
 8542               		.loc 1 2102 0
 8543 39d8 8091 7A00 		lds r24,122
 8544 39dc 8064      		ori r24,lo8(64)
 8545 39de 8093 7A00 		sts 122,r24
 8546               	.L438:
 8547               	.LBE614:
 8548               	.LBE613:
 8549               	.LBE609:
 8550               	.LBE608:
4471:WTPA.c        **** 						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so th
 8551               		.loc 1 4471 0
 8552 39e2 E091 0000 		lds r30,currentMidiMessage.2230
 8553 39e6 24E2      		ldi r18,lo8(36)
 8554               	.LVL390:
 8555 39e8 E29F      		mul r30,r18
 8556 39ea F001      		movw r30,r0
 8557 39ec 1124      		clr __zero_reg__
 8558 39ee E050      		subi r30,lo8(-(bankStates))
 8559 39f0 F040      		sbci r31,hi8(-(bankStates))
 8560 39f2 81E0      		ldi r24,lo8(1)
 8561 39f4 8683      		std Z+6,r24
 8562 39f6 6091 0000 		lds r22,sdIsrState
 8563 39fa 0C94 0000 		jmp .L318
 8564               	.LVL391:
 8565               	.L436:
 8566               	.LBB617:
 8567               	.LBB616:
 8568               	.LBB615:
 8569               	.LBB612:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8570               		.loc 1 1940 0
 8571 39fe 9093 8B00 		sts 138+1,r25
 8572 3a02 8093 8A00 		sts 138,r24
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 8573               		.loc 1 1941 0
 8574 3a06 B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 8575               		.loc 1 1942 0
 8576 3a08 8091 6F00 		lds r24,111
 8577 3a0c 8460      		ori r24,lo8(4)
 8578 3a0e 8093 6F00 		sts 111,r24
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8579               		.loc 1 1943 0
 8580 3a12 81E0      		ldi r24,lo8(1)
 8581 3a14 8093 8100 		sts 129,r24
 8582 3a18 00C0      		rjmp .L437
 8583               	.LVL392:
 8584               	.L448:
 8585               	.LBE612:
 8586               	.LBE615:
 8587               	.LBE616:
 8588               	.LBE617:
4556:WTPA.c        **** 						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combinat
 8589               		.loc 1 4556 0
 8590 3a1a 80E0      		ldi r24,lo8(gs(OutputAndBanks))
 8591 3a1c 90E0      		ldi r25,hi8(gs(OutputAndBanks))
 8592 3a1e 9093 0000 		sts UpdateOutput+1,r25
 8593 3a22 8093 0000 		sts UpdateOutput,r24
 8594 3a26 6091 0000 		lds r22,sdIsrState
4557:WTPA.c        **** 						break;
 8595               		.loc 1 4557 0
 8596 3a2a 0C94 0000 		jmp .L318
 8597               	.LVL393:
 8598               	.L680:
 8599               	.LBB618:
 8600               	.LBB577:
3433:WTPA.c        **** 		EepromWrite(11,theNote);	// Write the channel to EEPROM.
 8601               		.loc 1 3433 0
 8602 3a2e 8BE0      		ldi r24,lo8(11)
 8603 3a30 90E0      		ldi r25,0
 8604 3a32 0E94 0000 		call EepromWrite
 8605               	.LVL394:
 8606 3a36 00C0      		rjmp .L451
 8607               	.LVL395:
 8608               	.L679:
3429:WTPA.c        **** 		EepromWrite(7,theNote);	// Write the channel to EEPROM.
 8609               		.loc 1 3429 0
 8610 3a38 87E0      		ldi r24,lo8(7)
 8611 3a3a 90E0      		ldi r25,0
 8612 3a3c 0E94 0000 		call EepromWrite
 8613               	.LVL396:
 8614 3a40 00C0      		rjmp .L451
 8615               	.LVL397:
 8616               	.L447:
 8617               	.LBE577:
 8618               	.LBE618:
4552:WTPA.c        **** 						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of com
 8619               		.loc 1 4552 0
 8620 3a42 80E0      		ldi r24,lo8(gs(OutputMultiplyBanks))
 8621 3a44 90E0      		ldi r25,hi8(gs(OutputMultiplyBanks))
 8622 3a46 9093 0000 		sts UpdateOutput+1,r25
 8623 3a4a 8093 0000 		sts UpdateOutput,r24
 8624 3a4e 6091 0000 		lds r22,sdIsrState
4553:WTPA.c        **** 						break;
 8625               		.loc 1 4553 0
 8626 3a52 0C94 0000 		jmp .L318
 8627               	.LVL398:
 8628               	.L433:
 8629               	.LBB619:
 8630               	.LBB557:
 8631               	.LBB555:
 8632               	.LBB554:
1940:WTPA.c        **** 			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
 8633               		.loc 1 1940 0
 8634 3a56 2091 8400 		lds r18,132
 8635 3a5a 3091 8500 		lds r19,132+1
 8636               	.LVL399:
 8637 3a5e 240F      		add r18,r20
 8638 3a60 351F      		adc r19,r21
 8639 3a62 3093 8B00 		sts 138+1,r19
 8640 3a66 2093 8A00 		sts 138,r18
1941:WTPA.c        **** 			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
 8641               		.loc 1 1941 0
 8642 3a6a B29A      		sbi 0x16,2
1942:WTPA.c        **** 			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
 8643               		.loc 1 1942 0
 8644 3a6c 2091 6F00 		lds r18,111
 8645 3a70 2460      		ori r18,lo8(4)
 8646 3a72 2093 6F00 		sts 111,r18
1943:WTPA.c        **** 			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
 8647               		.loc 1 1943 0
 8648 3a76 21E0      		ldi r18,lo8(1)
 8649 3a78 2093 8100 		sts 129,r18
 8650 3a7c 00C0      		rjmp .L434
 8651               	.LBE554:
 8652               	.LBE555:
 8653               	.LBE557:
 8654               	.LBE619:
 8655               		.cfi_endproc
 8656               	.LFE70:
 8659               	DoSawtooth:
 8660               	.LFB72:
4691:WTPA.c        **** {
 8661               		.loc 1 4691 0
 8662               		.cfi_startproc
 8663               	/* prologue: function */
 8664               	/* frame size = 0 */
 8665               	/* stack size = 0 */
 8666               	.L__stack_usage = 0
4692:WTPA.c        **** 	if(subState==SS_0)
 8667               		.loc 1 4692 0
 8668 3a7e 8091 0000 		lds r24,subState
 8669 3a82 8823      		tst r24
 8670 3a84 01F4      		brne .+2
 8671 3a86 00C0      		rjmp .L851
4698:WTPA.c        **** 	else if(subState==SS_1)
 8672               		.loc 1 4698 0
 8673 3a88 8130      		cpi r24,lo8(1)
 8674 3a8a 01F4      		brne .+2
 8675 3a8c 00C0      		rjmp .L852
4709:WTPA.c        **** 	else if(subState==SS_2)
 8676               		.loc 1 4709 0
 8677 3a8e 8230      		cpi r24,lo8(2)
 8678 3a90 01F0      		breq .L853
 8679               	.L687:
 8680 3a92 0895      		ret
 8681               	.L853:
 8682               	.LBB644:
 8683               	.LBB645:
4712:WTPA.c        **** 		if(newKeys&Im_SWITCH_0)
 8684               		.loc 1 4712 0
 8685 3a94 8091 0000 		lds r24,newKeys
 8686 3a98 80FF      		sbrs r24,0
 8687 3a9a 00C0      		rjmp .L699
4714:WTPA.c        **** 			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
 8688               		.loc 1 4714 0
 8689 3a9c 9091 0000 		lds r25,ledOnOffMask
 8690 3aa0 21E0      		ldi r18,lo8(1)
 8691 3aa2 9227      		eor r25,r18
 8692 3aa4 9093 0000 		sts ledOnOffMask,r25
 8693               	.L699:
4716:WTPA.c        **** 		if(newKeys&Im_SWITCH_1)
 8694               		.loc 1 4716 0
 8695 3aa8 81FF      		sbrs r24,1
 8696 3aaa 00C0      		rjmp .L700
4718:WTPA.c        **** 			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
 8697               		.loc 1 4718 0
 8698 3aac 9091 0000 		lds r25,ledOnOffMask
 8699 3ab0 22E0      		ldi r18,lo8(2)
 8700 3ab2 9227      		eor r25,r18
 8701 3ab4 9093 0000 		sts ledOnOffMask,r25
 8702               	.L700:
4720:WTPA.c        **** 		if(newKeys&Im_SWITCH_2)
 8703               		.loc 1 4720 0
 8704 3ab8 82FF      		sbrs r24,2
 8705 3aba 00C0      		rjmp .L701
4722:WTPA.c        **** 			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
 8706               		.loc 1 4722 0
 8707 3abc 9091 0000 		lds r25,ledOnOffMask
 8708 3ac0 24E0      		ldi r18,lo8(4)
 8709 3ac2 9227      		eor r25,r18
 8710 3ac4 9093 0000 		sts ledOnOffMask,r25
 8711               	.L701:
4724:WTPA.c        **** 		if(newKeys&Im_SWITCH_3)
 8712               		.loc 1 4724 0
 8713 3ac8 83FF      		sbrs r24,3
 8714 3aca 00C0      		rjmp .L702
4726:WTPA.c        **** 			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
 8715               		.loc 1 4726 0
 8716 3acc 9091 0000 		lds r25,ledOnOffMask
 8717 3ad0 28E0      		ldi r18,lo8(8)
 8718 3ad2 9227      		eor r25,r18
 8719 3ad4 9093 0000 		sts ledOnOffMask,r25
 8720               	.L702:
4728:WTPA.c        **** 		if(newKeys&Im_SWITCH_4)
 8721               		.loc 1 4728 0
 8722 3ad8 84FF      		sbrs r24,4
 8723 3ada 00C0      		rjmp .L703
4730:WTPA.c        **** 			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
 8724               		.loc 1 4730 0
 8725 3adc 9091 0000 		lds r25,ledOnOffMask
 8726 3ae0 20E1      		ldi r18,lo8(16)
 8727 3ae2 9227      		eor r25,r18
 8728 3ae4 9093 0000 		sts ledOnOffMask,r25
 8729               	.L703:
4732:WTPA.c        **** 		if(newKeys&Im_SWITCH_5)
 8730               		.loc 1 4732 0
 8731 3ae8 85FF      		sbrs r24,5
 8732 3aea 00C0      		rjmp .L704
4734:WTPA.c        **** 			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
 8733               		.loc 1 4734 0
 8734 3aec 9091 0000 		lds r25,ledOnOffMask
 8735 3af0 20E2      		ldi r18,lo8(32)
 8736 3af2 9227      		eor r25,r18
 8737 3af4 9093 0000 		sts ledOnOffMask,r25
 8738               	.L704:
4737:WTPA.c        **** 		if(newKeys&Im_SWITCH_6)
 8739               		.loc 1 4737 0
 8740 3af8 86FD      		sbrc r24,6
 8741 3afa 00C0      		rjmp .L854
 8742               	.L705:
4742:WTPA.c        **** 		if(newKeys&Im_SWITCH_7)
 8743               		.loc 1 4742 0
 8744 3afc 87FD      		sbrc r24,7
 8745 3afe 00C0      		rjmp .L855
 8746               	.L714:
4747:WTPA.c        **** 		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
 8747               		.loc 1 4747 0
 8748 3b00 8091 0000 		lds r24,newEncoder
 8749 3b04 8823      		tst r24
 8750 3b06 01F0      		breq .L687
 8751 3b08 3091 0000 		lds r19,ledBlinkMask
 8752 3b0c 832F      		mov r24,r19
 8753 3b0e 90E0      		ldi r25,0
 8754 3b10 2091 0000 		lds r18,ledOnOffMask
 8755               	.LBB646:
 8756               	.LBB647:
 8757               	.LBB648:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8758               		.loc 1 1566 0
 8759 3b14 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8760               		.loc 1 1568 0
 8761 3b16 2E7F      		andi r18,lo8(-2)
 8762               	.L723:
 8763               	.LVL400:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8764               		.loc 1 1566 0
 8765 3b18 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8766               		.loc 1 1568 0
 8767 3b1a 2D7F      		andi r18,lo8(-3)
 8768               	.L724:
 8769               	.LVL401:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8770               		.loc 1 1566 0
 8771 3b1c 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8772               		.loc 1 1568 0
 8773 3b1e 2B7F      		andi r18,lo8(-5)
 8774               	.L725:
 8775               	.LVL402:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8776               		.loc 1 1566 0
 8777 3b20 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8778               		.loc 1 1568 0
 8779 3b22 277F      		andi r18,lo8(-9)
 8780               	.L726:
 8781               	.LVL403:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8782               		.loc 1 1566 0
 8783 3b24 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8784               		.loc 1 1568 0
 8785 3b26 2F7E      		andi r18,lo8(-17)
 8786               	.L727:
 8787               	.LVL404:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8788               		.loc 1 1566 0
 8789 3b28 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8790               		.loc 1 1568 0
 8791 3b2a 2F7D      		andi r18,lo8(-33)
 8792               	.L728:
 8793               	.LVL405:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8794               		.loc 1 1566 0
 8795 3b2c 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8796               		.loc 1 1568 0
 8797 3b2e 2F7B      		andi r18,lo8(-65)
 8798               	.L729:
 8799               	.LVL406:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8800               		.loc 1 1566 0
 8801 3b30 880F      		lsl r24
 8802 3b32 892F      		mov r24,r25
 8803 3b34 881F      		rol r24
 8804 3b36 990B      		sbc r25,r25
 8805 3b38 892B      		or r24,r25
 8806 3b3a 01F0      		breq .L730
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8807               		.loc 1 1568 0
 8808 3b3c 2F77      		andi r18,lo8(127)
 8809               	.L730:
 8810               	.LVL407:
 8811 3b3e 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 8812               		.loc 1 1572 0
 8813 3b42 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 8814               		.loc 1 1573 0
 8815 3b46 68E9      		ldi r22,lo8(-104)
 8816 3b48 70E0      		ldi r23,0
 8817 3b4a 82E0      		ldi r24,lo8(2)
 8818 3b4c 0E94 0000 		call SetTimer
 8819               	.LVL408:
 8820               	.LBE648:
 8821               	.LBE647:
 8822               	.LBE646:
4750:WTPA.c        **** 			ledOnOffMask=encoderValue;
 8823               		.loc 1 4750 0
 8824 3b50 8091 0000 		lds r24,encoderValue
 8825 3b54 8093 0000 		sts ledOnOffMask,r24
 8826 3b58 0895      		ret
 8827               	.LVL409:
 8828               	.L851:
 8829               	.LBE645:
 8830               	.LBE644:
 8831               	.LBB657:
 8832               	.LBB658:
1585:WTPA.c        **** 	ledOnOffMask=0;
 8833               		.loc 1 1585 0
 8834 3b5a 1092 0000 		sts ledOnOffMask,__zero_reg__
 8835               	.LVL410:
 8836               	.LBB659:
 8837               	.LBB660:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 8838               		.loc 1 1572 0
 8839 3b5e 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 8840               		.loc 1 1573 0
 8841 3b62 68E9      		ldi r22,lo8(-104)
 8842 3b64 70E0      		ldi r23,0
 8843 3b66 82E0      		ldi r24,lo8(2)
 8844 3b68 0E94 0000 		call SetTimer
 8845               	.LVL411:
 8846 3b6c 3091 0000 		lds r19,ledBlinkMask
 8847 3b70 832F      		mov r24,r19
 8848 3b72 90E0      		ldi r25,0
 8849 3b74 2091 0000 		lds r18,ledOnOffMask
 8850               	.LBE660:
 8851               	.LBE659:
 8852               	.LBE658:
 8853               	.LBE657:
 8854               	.LBB661:
 8855               	.LBB662:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8856               		.loc 1 1566 0
 8857 3b78 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8858               		.loc 1 1568 0
 8859 3b7a 2E7F      		andi r18,lo8(-2)
 8860               	.L689:
 8861               	.LVL412:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8862               		.loc 1 1566 0
 8863 3b7c 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8864               		.loc 1 1568 0
 8865 3b7e 2D7F      		andi r18,lo8(-3)
 8866               	.L690:
 8867               	.LVL413:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8868               		.loc 1 1566 0
 8869 3b80 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8870               		.loc 1 1568 0
 8871 3b82 2B7F      		andi r18,lo8(-5)
 8872               	.L691:
 8873               	.LVL414:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8874               		.loc 1 1566 0
 8875 3b84 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8876               		.loc 1 1568 0
 8877 3b86 277F      		andi r18,lo8(-9)
 8878               	.L692:
 8879               	.LVL415:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8880               		.loc 1 1566 0
 8881 3b88 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8882               		.loc 1 1568 0
 8883 3b8a 2F7E      		andi r18,lo8(-17)
 8884               	.L693:
 8885               	.LVL416:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8886               		.loc 1 1566 0
 8887 3b8c 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8888               		.loc 1 1568 0
 8889 3b8e 2F7D      		andi r18,lo8(-33)
 8890               	.L694:
 8891               	.LVL417:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8892               		.loc 1 1566 0
 8893 3b90 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8894               		.loc 1 1568 0
 8895 3b92 2F7B      		andi r18,lo8(-65)
 8896               	.L695:
 8897               	.LVL418:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8898               		.loc 1 1566 0
 8899 3b94 880F      		lsl r24
 8900 3b96 892F      		mov r24,r25
 8901 3b98 881F      		rol r24
 8902 3b9a 990B      		sbc r25,r25
 8903 3b9c 892B      		or r24,r25
 8904 3b9e 01F0      		breq .L696
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8905               		.loc 1 1568 0
 8906 3ba0 2F77      		andi r18,lo8(127)
 8907               	.L696:
 8908               	.LVL419:
 8909 3ba2 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 8910               		.loc 1 1572 0
 8911 3ba6 80EC      		ldi r24,lo8(-64)
 8912 3ba8 8093 0000 		sts ledBlinkMask,r24
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 8913               		.loc 1 1573 0
 8914 3bac 68E9      		ldi r22,lo8(-104)
 8915 3bae 70E0      		ldi r23,0
 8916 3bb0 82E0      		ldi r24,lo8(2)
 8917 3bb2 0E94 0000 		call SetTimer
 8918               	.LVL420:
 8919               	.LBE662:
 8920               	.LBE661:
4696:WTPA.c        **** 		subState=SS_1;
 8921               		.loc 1 4696 0
 8922 3bb6 81E0      		ldi r24,lo8(1)
 8923 3bb8 8093 0000 		sts subState,r24
 8924 3bbc 0895      		ret
 8925               	.LVL421:
 8926               	.L854:
 8927 3bbe 3091 0000 		lds r19,ledBlinkMask
 8928 3bc2 832F      		mov r24,r19
 8929 3bc4 90E0      		ldi r25,0
 8930 3bc6 2091 0000 		lds r18,ledOnOffMask
 8931               	.LBB663:
 8932               	.LBB655:
 8933               	.LBB649:
 8934               	.LBB650:
 8935               	.LBB651:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8936               		.loc 1 1566 0
 8937 3bca 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8938               		.loc 1 1568 0
 8939 3bcc 2E7F      		andi r18,lo8(-2)
 8940               	.L706:
 8941               	.LVL422:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8942               		.loc 1 1566 0
 8943 3bce 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8944               		.loc 1 1568 0
 8945 3bd0 2D7F      		andi r18,lo8(-3)
 8946               	.L707:
 8947               	.LVL423:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8948               		.loc 1 1566 0
 8949 3bd2 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8950               		.loc 1 1568 0
 8951 3bd4 2B7F      		andi r18,lo8(-5)
 8952               	.L708:
 8953               	.LVL424:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8954               		.loc 1 1566 0
 8955 3bd6 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8956               		.loc 1 1568 0
 8957 3bd8 277F      		andi r18,lo8(-9)
 8958               	.L709:
 8959               	.LVL425:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8960               		.loc 1 1566 0
 8961 3bda 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8962               		.loc 1 1568 0
 8963 3bdc 2F7E      		andi r18,lo8(-17)
 8964               	.L710:
 8965               	.LVL426:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8966               		.loc 1 1566 0
 8967 3bde 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8968               		.loc 1 1568 0
 8969 3be0 2F7D      		andi r18,lo8(-33)
 8970               	.L711:
 8971               	.LVL427:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8972               		.loc 1 1566 0
 8973 3be2 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8974               		.loc 1 1568 0
 8975 3be4 2F7B      		andi r18,lo8(-65)
 8976               	.L712:
 8977               	.LVL428:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 8978               		.loc 1 1566 0
 8979 3be6 880F      		lsl r24
 8980 3be8 892F      		mov r24,r25
 8981 3bea 881F      		rol r24
 8982 3bec 990B      		sbc r25,r25
 8983 3bee 892B      		or r24,r25
 8984 3bf0 01F0      		breq .L713
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 8985               		.loc 1 1568 0
 8986 3bf2 2F77      		andi r18,lo8(127)
 8987               	.L713:
 8988               	.LVL429:
 8989 3bf4 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 8990               		.loc 1 1572 0
 8991 3bf8 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 8992               		.loc 1 1573 0
 8993 3bfc 68E9      		ldi r22,lo8(-104)
 8994 3bfe 70E0      		ldi r23,0
 8995 3c00 82E0      		ldi r24,lo8(2)
 8996 3c02 0E94 0000 		call SetTimer
 8997               	.LVL430:
 8998               	.LBE651:
 8999               	.LBE650:
 9000               	.LBE649:
4740:WTPA.c        **** 			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
 9001               		.loc 1 4740 0
 9002 3c06 8091 0000 		lds r24,ledOnOffMask
 9003 3c0a 90E4      		ldi r25,lo8(64)
 9004 3c0c 8927      		eor r24,r25
 9005 3c0e 8093 0000 		sts ledOnOffMask,r24
 9006 3c12 8091 0000 		lds r24,newKeys
 9007 3c16 00C0      		rjmp .L705
 9008               	.LVL431:
 9009               	.L852:
 9010               	.LBE655:
 9011               	.LBE663:
4700:WTPA.c        **** 		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 9012               		.loc 1 4700 0
 9013               	/* #APP */
 9014               	 ;  4700 "WTPA.c" 1
 9015 3c18 F894      		cli
 9016               	 ;  0 "" 2
4701:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vecto
 9017               		.loc 1 4701 0
 9018               	/* #NOAPP */
 9019 3c1a 8093 0000 		sts bankStates,r24
4702:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
 9020               		.loc 1 4702 0
 9021 3c1e 8093 0000 		sts bankStates+10,r24
 9022               	.LVL432:
 9023               	.LBB664:
 9024               	.LBB665:
1925:WTPA.c        **** 	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?
 9025               		.loc 1 1925 0
 9026 3c22 8093 0000 		sts bankStates+10,r24
 9027               	.LBB666:
 9028               	.LBB667:
1950:WTPA.c        **** 			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
 9029               		.loc 1 1950 0
 9030 3c26 8091 8100 		lds r24,129
 9031 3c2a 8064      		ori r24,lo8(64)
 9032 3c2c 8093 8100 		sts 129,r24
1951:WTPA.c        **** 			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
 9033               		.loc 1 1951 0
 9034 3c30 B59A      		sbi 0x16,5
1952:WTPA.c        **** 			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
 9035               		.loc 1 1952 0
 9036 3c32 8091 6F00 		lds r24,111
 9037 3c36 8062      		ori r24,lo8(32)
 9038 3c38 8093 6F00 		sts 111,r24
 9039               	.LBE667:
 9040               	.LBE666:
 9041               	.LBE665:
 9042               	.LBE664:
4704:WTPA.c        **** 		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
 9043               		.loc 1 4704 0
 9044 3c3c 80E0      		ldi r24,lo8(gs(OutputAddBanks))
 9045 3c3e 90E0      		ldi r25,hi8(gs(OutputAddBanks))
 9046 3c40 9093 0000 		sts UpdateOutput+1,r25
 9047 3c44 8093 0000 		sts UpdateOutput,r24
4705:WTPA.c        **** 		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
 9048               		.loc 1 4705 0
 9049               	/* #APP */
 9050               	 ;  4705 "WTPA.c" 1
 9051 3c48 7894      		sei
 9052               	 ;  0 "" 2
4707:WTPA.c        **** 		subState=SS_2;					// And wait forever.
 9053               		.loc 1 4707 0
 9054               	/* #NOAPP */
 9055 3c4a 82E0      		ldi r24,lo8(2)
 9056 3c4c 8093 0000 		sts subState,r24
 9057 3c50 0895      		ret
 9058               	.LVL433:
 9059               	.L855:
 9060 3c52 3091 0000 		lds r19,ledBlinkMask
 9061 3c56 832F      		mov r24,r19
 9062 3c58 90E0      		ldi r25,0
 9063 3c5a 2091 0000 		lds r18,ledOnOffMask
 9064               	.LBB668:
 9065               	.LBB656:
 9066               	.LBB652:
 9067               	.LBB653:
 9068               	.LBB654:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9069               		.loc 1 1566 0
 9070 3c5e 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9071               		.loc 1 1568 0
 9072 3c60 2E7F      		andi r18,lo8(-2)
 9073               	.L715:
 9074               	.LVL434:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9075               		.loc 1 1566 0
 9076 3c62 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9077               		.loc 1 1568 0
 9078 3c64 2D7F      		andi r18,lo8(-3)
 9079               	.L716:
 9080               	.LVL435:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9081               		.loc 1 1566 0
 9082 3c66 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9083               		.loc 1 1568 0
 9084 3c68 2B7F      		andi r18,lo8(-5)
 9085               	.L717:
 9086               	.LVL436:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9087               		.loc 1 1566 0
 9088 3c6a 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9089               		.loc 1 1568 0
 9090 3c6c 277F      		andi r18,lo8(-9)
 9091               	.L718:
 9092               	.LVL437:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9093               		.loc 1 1566 0
 9094 3c6e 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9095               		.loc 1 1568 0
 9096 3c70 2F7E      		andi r18,lo8(-17)
 9097               	.L719:
 9098               	.LVL438:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9099               		.loc 1 1566 0
 9100 3c72 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9101               		.loc 1 1568 0
 9102 3c74 2F7D      		andi r18,lo8(-33)
 9103               	.L720:
 9104               	.LVL439:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9105               		.loc 1 1566 0
 9106 3c76 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9107               		.loc 1 1568 0
 9108 3c78 2F7B      		andi r18,lo8(-65)
 9109               	.L721:
 9110               	.LVL440:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9111               		.loc 1 1566 0
 9112 3c7a 880F      		lsl r24
 9113 3c7c 892F      		mov r24,r25
 9114 3c7e 881F      		rol r24
 9115 3c80 990B      		sbc r25,r25
 9116 3c82 892B      		or r24,r25
 9117 3c84 01F0      		breq .L722
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9118               		.loc 1 1568 0
 9119 3c86 2F77      		andi r18,lo8(127)
 9120               	.L722:
 9121               	.LVL441:
 9122 3c88 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9123               		.loc 1 1572 0
 9124 3c8c 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9125               		.loc 1 1573 0
 9126 3c90 68E9      		ldi r22,lo8(-104)
 9127 3c92 70E0      		ldi r23,0
 9128 3c94 82E0      		ldi r24,lo8(2)
 9129 3c96 0E94 0000 		call SetTimer
 9130               	.LVL442:
 9131               	.LBE654:
 9132               	.LBE653:
 9133               	.LBE652:
4745:WTPA.c        **** 			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
 9134               		.loc 1 4745 0
 9135 3c9a 8091 0000 		lds r24,ledOnOffMask
 9136 3c9e 8058      		subi r24,lo8(-(-128))
 9137 3ca0 8093 0000 		sts ledOnOffMask,r24
 9138 3ca4 00C0      		rjmp .L714
 9139               	.LBE656:
 9140               	.LBE668:
 9141               		.cfi_endproc
 9142               	.LFE72:
 9145               	SdCardMenu:
 9146               	.LFB68:
4014:WTPA.c        **** {
 9147               		.loc 1 4014 0
 9148               		.cfi_startproc
 9149 3ca6 BF92      		push r11
 9150               	.LCFI53:
 9151               		.cfi_def_cfa_offset 3
 9152               		.cfi_offset 11, -2
 9153 3ca8 CF92      		push r12
 9154               	.LCFI54:
 9155               		.cfi_def_cfa_offset 4
 9156               		.cfi_offset 12, -3
 9157 3caa DF92      		push r13
 9158               	.LCFI55:
 9159               		.cfi_def_cfa_offset 5
 9160               		.cfi_offset 13, -4
 9161 3cac EF92      		push r14
 9162               	.LCFI56:
 9163               		.cfi_def_cfa_offset 6
 9164               		.cfi_offset 14, -5
 9165 3cae FF92      		push r15
 9166               	.LCFI57:
 9167               		.cfi_def_cfa_offset 7
 9168               		.cfi_offset 15, -6
 9169 3cb0 0F93      		push r16
 9170               	.LCFI58:
 9171               		.cfi_def_cfa_offset 8
 9172               		.cfi_offset 16, -7
 9173 3cb2 1F93      		push r17
 9174               	.LCFI59:
 9175               		.cfi_def_cfa_offset 9
 9176               		.cfi_offset 17, -8
 9177 3cb4 CF93      		push r28
 9178               	.LCFI60:
 9179               		.cfi_def_cfa_offset 10
 9180               		.cfi_offset 28, -9
 9181 3cb6 DF93      		push r29
 9182               	.LCFI61:
 9183               		.cfi_def_cfa_offset 11
 9184               		.cfi_offset 29, -10
 9185               	/* prologue: function */
 9186               	/* frame size = 0 */
 9187               	/* stack size = 9 */
 9188               	.L__stack_usage = 9
4015:WTPA.c        **** 	if(subState==SS_0)		// Initialize LEDs and slots
 9189               		.loc 1 4015 0
 9190 3cb8 8091 0000 		lds r24,subState
 9191 3cbc 8111      		cpse r24,__zero_reg__
 9192 3cbe 00C0      		rjmp .L857
4017:WTPA.c        **** 		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
 9193               		.loc 1 4017 0
 9194 3cc0 8091 0000 		lds r24,sdCurrentSlot
 9195 3cc4 9091 0000 		lds r25,sdCurrentSlot+1
 9196 3cc8 8038      		cpi r24,-128
 9197 3cca 9105      		cpc r25,__zero_reg__
 9198 3ccc 00F0      		brlo .+2
 9199 3cce 00C0      		rjmp .L858
 9200 3cd0 482F      		mov r20,r24
 9201               	.L859:
 9202               	.LVL443:
 9203 3cd2 2091 0000 		lds r18,ledBlinkMask
 9204 3cd6 822F      		mov r24,r18
 9205 3cd8 90E0      		ldi r25,0
 9206               	.LBB733:
 9207               	.LBB734:
 9208               	.LBB735:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9209               		.loc 1 1566 0
 9210 3cda 20FD      		sbrc r18,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9211               		.loc 1 1568 0
 9212 3cdc 4E7F      		andi r20,lo8(-2)
 9213               	.L860:
 9214               	.LVL444:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9215               		.loc 1 1566 0
 9216 3cde 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9217               		.loc 1 1568 0
 9218 3ce0 4D7F      		andi r20,lo8(-3)
 9219               	.L861:
 9220               	.LVL445:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9221               		.loc 1 1566 0
 9222 3ce2 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9223               		.loc 1 1568 0
 9224 3ce4 4B7F      		andi r20,lo8(-5)
 9225               	.L862:
 9226               	.LVL446:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9227               		.loc 1 1566 0
 9228 3ce6 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9229               		.loc 1 1568 0
 9230 3ce8 477F      		andi r20,lo8(-9)
 9231               	.L863:
 9232               	.LVL447:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9233               		.loc 1 1566 0
 9234 3cea 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9235               		.loc 1 1568 0
 9236 3cec 4F7E      		andi r20,lo8(-17)
 9237               	.L864:
 9238               	.LVL448:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9239               		.loc 1 1566 0
 9240 3cee 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9241               		.loc 1 1568 0
 9242 3cf0 4F7D      		andi r20,lo8(-33)
 9243               	.L865:
 9244               	.LVL449:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9245               		.loc 1 1566 0
 9246 3cf2 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9247               		.loc 1 1568 0
 9248 3cf4 4F7B      		andi r20,lo8(-65)
 9249               	.L866:
 9250               	.LVL450:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9251               		.loc 1 1566 0
 9252 3cf6 9C01      		movw r18,r24
 9253 3cf8 220F      		lsl r18
 9254 3cfa 232F      		mov r18,r19
 9255 3cfc 221F      		rol r18
 9256 3cfe 330B      		sbc r19,r19
 9257 3d00 232B      		or r18,r19
 9258 3d02 01F0      		breq .L867
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9259               		.loc 1 1568 0
 9260 3d04 4F77      		andi r20,lo8(127)
 9261               	.L867:
 9262               	.LVL451:
 9263 3d06 4093 0000 		sts ledOnOffMask,r20
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9264               		.loc 1 1572 0
 9265 3d0a 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9266               		.loc 1 1573 0
 9267 3d0e 68E9      		ldi r22,lo8(-104)
 9268 3d10 70E0      		ldi r23,0
 9269 3d12 82E0      		ldi r24,lo8(2)
 9270 3d14 0E94 0000 		call SetTimer
 9271               	.LVL452:
 9272               	.LBE735:
 9273               	.LBE734:
 9274               	.LBE733:
4025:WTPA.c        **** 		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
 9275               		.loc 1 4025 0
 9276 3d18 2091 0000 		lds r18,sdCurrentSlot
 9277 3d1c 3091 0000 		lds r19,sdCurrentSlot+1
 9278               	.LVL453:
 9279               	.LBB736:
 9280               	.LBB737:
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 9281               		.loc 1 2178 0
 9282 3d20 F901      		movw r30,r18
 9283 3d22 F695      		lsr r31
 9284 3d24 E795      		ror r30
 9285 3d26 F695      		lsr r31
 9286 3d28 E795      		ror r30
 9287 3d2a F695      		lsr r31
 9288 3d2c E795      		ror r30
 9289               	.LBE737:
4962:WTPA.c        **** 
4963:WTPA.c        **** 
4964:WTPA.c        **** //-----------------------------------------------------------------------
4965:WTPA.c        **** //-----------------------------------------------------------------------
4966:WTPA.c        **** // Program main loop.
4967:WTPA.c        **** //-----------------------------------------------------------------------
4968:WTPA.c        **** //-----------------------------------------------------------------------
4969:WTPA.c        **** 
4970:WTPA.c        **** int main(void)
4971:WTPA.c        **** // Initialize this mess.
4972:WTPA.c        **** {
4973:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
4974:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
4975:WTPA.c        **** 
4976:WTPA.c        **** 	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initia
4977:WTPA.c        **** 
4978:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
4979:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
4980:WTPA.c        **** 
4981:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
4982:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
4983:WTPA.c        **** 
4984:WTPA.c        **** //	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pi
4985:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
4986:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
4987:WTPA.c        **** 
4988:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
4989:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
4990:WTPA.c        **** 
4991:WTPA.c        **** 	// Set the DAC to midscale to avoid pops on the first interrupt call.
4992:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
4993:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
4994:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
4995:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
4996:WTPA.c        **** 
4997:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
4998:WTPA.c        **** 	InitSwitches();
4999:WTPA.c        **** 	InitEncoder();
5000:WTPA.c        **** 	InitLeds();
5001:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
5002:WTPA.c        **** 	InitUart0();
5003:WTPA.c        **** //	InitUart1();
5004:WTPA.c        **** 	InitAdc();
5005:WTPA.c        **** 	InitSoftclock();
5006:WTPA.c        **** //	InitRandom();
5007:WTPA.c        **** 	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.
5008:WTPA.c        **** 
5009:WTPA.c        **** 	newKeys=0;
5010:WTPA.c        **** 	keyState=0;
5011:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
5012:WTPA.c        **** 	cardDetect=false;
5013:WTPA.c        **** 
5014:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
5015:WTPA.c        **** 
5016:WTPA.c        **** 	SetState(DoFruitcakeIntro);	// Daze and Astound
5017:WTPA.c        **** 
5018:WTPA.c        **** 	while(1)
5019:WTPA.c        **** 	{
5020:WTPA.c        **** 		HandleSwitches();		// Flag newKeys.
5021:WTPA.c        **** 		HandleEncoder();		// Keep track of encoder states and increment values.
5022:WTPA.c        **** 		HandleSoftclock();		// Keep the timer timing.
5023:WTPA.c        **** 		HandleLeds();			// Keep LEDs updated.
5024:WTPA.c        **** 		UpdateCard();			// Keep the SD card state machine running.
5025:WTPA.c        **** 		GetRandomLongInt();		// Keep random numbers rolling.
5026:WTPA.c        **** 
5027:WTPA.c        **** //daNextJump=random31;
5028:WTPA.c        **** //daNextJumpPrime=(keyState+systemTicks);
5029:WTPA.c        **** 
5030:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
5031:WTPA.c        **** 		{
5032:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
5033:WTPA.c        **** 		}
5034:WTPA.c        **** 
5035:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
5036:WTPA.c        **** 		{
5037:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
5038:WTPA.c        **** 			{
5039:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
5040:WTPA.c        **** 			}
5041:WTPA.c        **** 		}
5042:WTPA.c        **** 
5043:WTPA.c        **** 		State();				// Execute the current program state.
5044:WTPA.c        **** 	}
5045:WTPA.c        **** 	return(0);
5046:WTPA.c        **** }
 9290               		.loc 1 5046 0
 9291 3d2e FF27      		clr r31
 9292               	.LBB738:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9293               		.loc 1 2181 0
 9294 3d30 E050      		subi r30,lo8(-(sampleToc))
 9295 3d32 F040      		sbci r31,hi8(-(sampleToc))
 9296 3d34 8081      		ld r24,Z
 9297 3d36 90E0      		ldi r25,0
 9298               	.LBE738:
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 9299               		.loc 1 2179 0
 9300 3d38 2770      		andi r18,7
 9301 3d3a 3327      		clr r19
 9302               	.LVL454:
 9303               	.LBB739:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9304               		.loc 1 2181 0
 9305 3d3c 00C0      		rjmp 2f
 9306               		1:
 9307 3d3e 9595      		asr r25
 9308 3d40 8795      		ror r24
 9309               		2:
 9310 3d42 2A95      		dec r18
 9311 3d44 02F4      		brpl 1b
 9312 3d46 80FF      		sbrs r24,0
 9313 3d48 00C0      		rjmp .L868
 9314 3d4a 3091 0000 		lds r19,ledBlinkMask
 9315 3d4e 832F      		mov r24,r19
 9316 3d50 90E0      		ldi r25,0
 9317 3d52 2091 0000 		lds r18,ledOnOffMask
 9318               	.LBE739:
 9319               	.LBE736:
 9320               	.LBB740:
 9321               	.LBB741:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9322               		.loc 1 1566 0
 9323 3d56 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9324               		.loc 1 1568 0
 9325 3d58 2E7F      		andi r18,lo8(-2)
 9326               	.L869:
 9327               	.LVL455:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9328               		.loc 1 1566 0
 9329 3d5a 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9330               		.loc 1 1568 0
 9331 3d5c 2D7F      		andi r18,lo8(-3)
 9332               	.L870:
 9333               	.LVL456:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9334               		.loc 1 1566 0
 9335 3d5e 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9336               		.loc 1 1568 0
 9337 3d60 2B7F      		andi r18,lo8(-5)
 9338               	.L871:
 9339               	.LVL457:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9340               		.loc 1 1566 0
 9341 3d62 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9342               		.loc 1 1568 0
 9343 3d64 277F      		andi r18,lo8(-9)
 9344               	.L872:
 9345               	.LVL458:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9346               		.loc 1 1566 0
 9347 3d66 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9348               		.loc 1 1568 0
 9349 3d68 2F7E      		andi r18,lo8(-17)
 9350               	.L873:
 9351               	.LVL459:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9352               		.loc 1 1566 0
 9353 3d6a 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9354               		.loc 1 1568 0
 9355 3d6c 2F7D      		andi r18,lo8(-33)
 9356               	.L874:
 9357               	.LVL460:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9358               		.loc 1 1566 0
 9359 3d6e 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9360               		.loc 1 1568 0
 9361 3d70 2F7B      		andi r18,lo8(-65)
 9362               	.L875:
 9363               	.LVL461:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9364               		.loc 1 1566 0
 9365 3d72 880F      		lsl r24
 9366 3d74 892F      		mov r24,r25
 9367 3d76 881F      		rol r24
 9368 3d78 990B      		sbc r25,r25
 9369 3d7a 892B      		or r24,r25
 9370 3d7c 01F0      		breq .+2
 9371 3d7e 00C0      		rjmp .L1117
 9372               	.L876:
 9373               	.LVL462:
 9374 3d80 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9375               		.loc 1 1572 0
 9376 3d84 80E8      		ldi r24,lo8(-128)
 9377 3d86 8093 0000 		sts ledBlinkMask,r24
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9378               		.loc 1 1573 0
 9379 3d8a 68E9      		ldi r22,lo8(-104)
 9380 3d8c 70E0      		ldi r23,0
 9381 3d8e 82E0      		ldi r24,lo8(2)
 9382 3d90 0E94 0000 		call SetTimer
 9383               	.LVL463:
 9384               	.L868:
 9385               	.LBE741:
 9386               	.LBE740:
4030:WTPA.c        **** 		subState=SS_1;
 9387               		.loc 1 4030 0
 9388 3d94 81E0      		ldi r24,lo8(1)
 9389 3d96 8093 0000 		sts subState,r24
 9390 3d9a 00C0      		rjmp .L856
 9391               	.LVL464:
 9392               	.L857:
 9393               	.LBB743:
 9394               	.LBB744:
4034:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
 9395               		.loc 1 4034 0
 9396 3d9c 8091 0000 		lds r24,cardDetect
 9397 3da0 8111      		cpse r24,__zero_reg__
 9398 3da2 00C0      		rjmp .L1118
4036:WTPA.c        **** 			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 9399               		.loc 1 4036 0
 9400 3da4 8091 0000 		lds r24,cardState
 9401 3da8 8111      		cpse r24,__zero_reg__
 9402 3daa 00C0      		rjmp .L879
 9403               	.L942:
 9404               	.LBB745:
 9405               	.LBB746:
1585:WTPA.c        **** 	ledOnOffMask=0;
 9406               		.loc 1 1585 0
 9407 3dac 1092 0000 		sts ledOnOffMask,__zero_reg__
 9408               	.LVL465:
 9409               	.LBB747:
 9410               	.LBB748:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9411               		.loc 1 1572 0
 9412 3db0 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9413               		.loc 1 1573 0
 9414 3db4 68E9      		ldi r22,lo8(-104)
 9415 3db6 70E0      		ldi r23,0
 9416 3db8 82E0      		ldi r24,lo8(2)
 9417 3dba 0E94 0000 		call SetTimer
 9418               	.LVL466:
 9419               	.LBE748:
 9420               	.LBE747:
 9421               	.LBE746:
 9422               	.LBE745:
 9423               	.LBB749:
 9424               	.LBB750:
1504:WTPA.c        **** 	State=newState;
 9425               		.loc 1 1504 0
 9426 3dbe 80E0      		ldi r24,lo8(gs(DoSampler))
 9427 3dc0 90E0      		ldi r25,hi8(gs(DoSampler))
 9428 3dc2 9093 0000 		sts State+1,r25
 9429 3dc6 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 9430               		.loc 1 1505 0
 9431 3dca 1092 0000 		sts subState,__zero_reg__
 9432               	.LVL467:
 9433               	.L856:
 9434               	/* epilogue start */
 9435               	.LBE750:
 9436               	.LBE749:
 9437               	.LBE744:
 9438               	.LBE743:
4123:WTPA.c        **** }
 9439               		.loc 1 4123 0
 9440 3dce DF91      		pop r29
 9441 3dd0 CF91      		pop r28
 9442 3dd2 1F91      		pop r17
 9443 3dd4 0F91      		pop r16
 9444 3dd6 FF90      		pop r15
 9445 3dd8 EF90      		pop r14
 9446 3dda DF90      		pop r13
 9447 3ddc CF90      		pop r12
 9448 3dde BF90      		pop r11
 9449 3de0 0895      		ret
 9450               	.L1118:
 9451               	.LBB815:
 9452               	.LBB813:
4034:WTPA.c        **** 		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
 9453               		.loc 1 4034 0
 9454 3de2 8091 0000 		lds r24,cardState
 9455 3de6 8F30      		cpi r24,lo8(15)
 9456 3de8 01F4      		brne .+2
 9457 3dea 00C0      		rjmp .L879
4046:WTPA.c        **** 			if(newEncoder)		// Increment or decrement card slot if encoder moves
 9458               		.loc 1 4046 0
 9459 3dec 8091 0000 		lds r24,newEncoder
 9460 3df0 8823      		tst r24
 9461 3df2 01F4      		brne .+2
 9462 3df4 00C0      		rjmp .L883
4048:WTPA.c        **** 				if(encoderCw)
 9463               		.loc 1 4048 0
 9464 3df6 8091 0000 		lds r24,encoderCw
 9465 3dfa 8111      		cpse r24,__zero_reg__
 9466 3dfc 00C0      		rjmp .L1119
4056:WTPA.c        **** 				else if(encoderCcw)
 9467               		.loc 1 4056 0
 9468 3dfe 8091 0000 		lds r24,encoderCcw
4058:WTPA.c        **** 					if(sdCurrentSlot==0)
 9469               		.loc 1 4058 0
 9470 3e02 4091 0000 		lds r20,sdCurrentSlot
 9471 3e06 5091 0000 		lds r21,sdCurrentSlot+1
4056:WTPA.c        **** 				else if(encoderCcw)
 9472               		.loc 1 4056 0
 9473 3e0a 8823      		tst r24
 9474 3e0c 01F4      		brne .+2
 9475 3e0e 00C0      		rjmp .L1115
4058:WTPA.c        **** 					if(sdCurrentSlot==0)
 9476               		.loc 1 4058 0
 9477 3e10 4115      		cp r20,__zero_reg__
 9478 3e12 5105      		cpc r21,__zero_reg__
 9479 3e14 01F0      		breq .+2
 9480 3e16 00C0      		rjmp .L888
4060:WTPA.c        **** 						sdCurrentSlot=127;
 9481               		.loc 1 4060 0
 9482 3e18 8FE7      		ldi r24,lo8(127)
 9483 3e1a 90E0      		ldi r25,0
 9484 3e1c 9093 0000 		sts sdCurrentSlot+1,r25
 9485 3e20 8093 0000 		sts sdCurrentSlot,r24
 9486 3e24 47E0      		ldi r20,lo8(7)
 9487 3e26 50E0      		ldi r21,0
 9488 3e28 2FE0      		ldi r18,lo8(15)
 9489 3e2a 30E0      		ldi r19,0
 9490 3e2c 6FE7      		ldi r22,lo8(127)
 9491               	.L886:
 9492               	.LBB751:
 9493               	.LBB752:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9494               		.loc 1 2181 0
 9495 3e2e F901      		movw r30,r18
 9496 3e30 E050      		subi r30,lo8(-(sampleToc))
 9497 3e32 F040      		sbci r31,hi8(-(sampleToc))
 9498 3e34 8081      		ld r24,Z
 9499 3e36 90E0      		ldi r25,0
 9500 3e38 00C0      		rjmp 2f
 9501               		1:
 9502 3e3a 9595      		asr r25
 9503 3e3c 8795      		ror r24
 9504               		2:
 9505 3e3e 4A95      		dec r20
 9506 3e40 02F4      		brpl 1b
 9507 3e42 2091 0000 		lds r18,ledBlinkMask
 9508 3e46 80FF      		sbrs r24,0
 9509 3e48 00C0      		rjmp .L889
 9510 3e4a 822F      		mov r24,r18
 9511 3e4c 90E0      		ldi r25,0
 9512               	.LBE752:
 9513               	.LBE751:
 9514               	.LBB753:
 9515               	.LBB754:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9516               		.loc 1 1566 0
 9517 3e4e 20FD      		sbrc r18,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9518               		.loc 1 1568 0
 9519 3e50 6E7F      		andi r22,lo8(-2)
 9520               	.L890:
 9521               	.LVL468:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9522               		.loc 1 1566 0
 9523 3e52 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9524               		.loc 1 1568 0
 9525 3e54 6D7F      		andi r22,lo8(-3)
 9526               	.L891:
 9527               	.LVL469:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9528               		.loc 1 1566 0
 9529 3e56 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9530               		.loc 1 1568 0
 9531 3e58 6B7F      		andi r22,lo8(-5)
 9532               	.L892:
 9533               	.LVL470:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9534               		.loc 1 1566 0
 9535 3e5a 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9536               		.loc 1 1568 0
 9537 3e5c 677F      		andi r22,lo8(-9)
 9538               	.L893:
 9539               	.LVL471:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9540               		.loc 1 1566 0
 9541 3e5e 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9542               		.loc 1 1568 0
 9543 3e60 6F7E      		andi r22,lo8(-17)
 9544               	.L894:
 9545               	.LVL472:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9546               		.loc 1 1566 0
 9547 3e62 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9548               		.loc 1 1568 0
 9549 3e64 6F7D      		andi r22,lo8(-33)
 9550               	.L895:
 9551               	.LVL473:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9552               		.loc 1 1566 0
 9553 3e66 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9554               		.loc 1 1568 0
 9555 3e68 6F7B      		andi r22,lo8(-65)
 9556               	.L896:
 9557               	.LVL474:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9558               		.loc 1 1566 0
 9559 3e6a 880F      		lsl r24
 9560 3e6c 892F      		mov r24,r25
 9561 3e6e 881F      		rol r24
 9562 3e70 990B      		sbc r25,r25
 9563 3e72 892B      		or r24,r25
 9564 3e74 01F0      		breq .L897
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9565               		.loc 1 1568 0
 9566 3e76 6F77      		andi r22,lo8(127)
 9567               	.L897:
 9568               	.LVL475:
 9569 3e78 6093 0000 		sts ledOnOffMask,r22
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9570               		.loc 1 1572 0
 9571 3e7c 80E8      		ldi r24,lo8(-128)
 9572 3e7e 8093 0000 		sts ledBlinkMask,r24
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9573               		.loc 1 1573 0
 9574 3e82 68E9      		ldi r22,lo8(-104)
 9575 3e84 70E0      		ldi r23,0
 9576 3e86 82E0      		ldi r24,lo8(2)
 9577 3e88 0E94 0000 		call SetTimer
 9578               	.LVL476:
 9579               	.L883:
 9580               	.LBE754:
 9581               	.LBE753:
4080:WTPA.c        **** 			if(newKeys&Im_SWITCH_0)		// Stream sample
 9582               		.loc 1 4080 0
 9583 3e8c 1091 0000 		lds r17,newKeys
 9584 3e90 10FF      		sbrs r17,0
 9585 3e92 00C0      		rjmp .L906
4082:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 9586               		.loc 1 4082 0
 9587 3e94 8091 0000 		lds r24,sdCurrentSlot
 9588 3e98 9091 0000 		lds r25,sdCurrentSlot+1
 9589               	.LVL477:
 9590               	.LBB755:
 9591               	.LBB756:
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 9592               		.loc 1 2178 0
 9593 3e9c FC01      		movw r30,r24
 9594 3e9e F695      		lsr r31
 9595 3ea0 E795      		ror r30
 9596 3ea2 F695      		lsr r31
 9597 3ea4 E795      		ror r30
 9598 3ea6 F695      		lsr r31
 9599 3ea8 E795      		ror r30
 9600               	.LBE756:
 9601               		.loc 1 5046 0
 9602 3eaa FF27      		clr r31
 9603               	.LBB757:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9604               		.loc 1 2181 0
 9605 3eac E050      		subi r30,lo8(-(sampleToc))
 9606 3eae F040      		sbci r31,hi8(-(sampleToc))
 9607 3eb0 2081      		ld r18,Z
 9608 3eb2 30E0      		ldi r19,0
 9609               	.LBE757:
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 9610               		.loc 1 2179 0
 9611 3eb4 AC01      		movw r20,r24
 9612 3eb6 4770      		andi r20,7
 9613 3eb8 5527      		clr r21
 9614               	.LBB758:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9615               		.loc 1 2181 0
 9616 3eba 00C0      		rjmp 2f
 9617               		1:
 9618 3ebc 3595      		asr r19
 9619 3ebe 2795      		ror r18
 9620               		2:
 9621 3ec0 4A95      		dec r20
 9622 3ec2 02F4      		brpl 1b
 9623 3ec4 20FD      		sbrc r18,0
 9624 3ec6 00C0      		rjmp .L907
 9625               	.LVL478:
 9626               	.L906:
 9627               	.LBE758:
 9628               	.LBE755:
4087:WTPA.c        **** 			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
 9629               		.loc 1 4087 0
 9630 3ec8 11FF      		sbrs r17,1
 9631 3eca 00C0      		rjmp .L908
4089:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 9632               		.loc 1 4089 0
 9633 3ecc C090 0000 		lds r12,sdCurrentSlot
 9634 3ed0 D090 0000 		lds r13,sdCurrentSlot+1
 9635               	.LVL479:
 9636               	.LBB759:
 9637               	.LBB760:
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 9638               		.loc 1 2178 0
 9639 3ed4 F601      		movw r30,r12
 9640 3ed6 F695      		lsr r31
 9641 3ed8 E795      		ror r30
 9642 3eda F695      		lsr r31
 9643 3edc E795      		ror r30
 9644 3ede F695      		lsr r31
 9645 3ee0 E795      		ror r30
 9646               	.LBE760:
 9647               		.loc 1 5046 0
 9648 3ee2 FF27      		clr r31
 9649               	.LBB761:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9650               		.loc 1 2181 0
 9651 3ee4 E050      		subi r30,lo8(-(sampleToc))
 9652 3ee6 F040      		sbci r31,hi8(-(sampleToc))
 9653 3ee8 8081      		ld r24,Z
 9654 3eea 90E0      		ldi r25,0
 9655               	.LBE761:
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 9656               		.loc 1 2179 0
 9657 3eec 9601      		movw r18,r12
 9658 3eee 2770      		andi r18,7
 9659 3ef0 3327      		clr r19
 9660               	.LBB762:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9661               		.loc 1 2181 0
 9662 3ef2 00C0      		rjmp 2f
 9663               		1:
 9664 3ef4 9595      		asr r25
 9665 3ef6 8795      		ror r24
 9666               		2:
 9667 3ef8 2A95      		dec r18
 9668 3efa 02F4      		brpl 1b
 9669 3efc 80FF      		sbrs r24,0
 9670 3efe 00C0      		rjmp .L908
 9671               	.LBE762:
 9672               	.LBE759:
4091:WTPA.c        **** 					ReadSampleFromSd(currentBank,sdCurrentSlot);
 9673               		.loc 1 4091 0
 9674 3f00 0091 0000 		lds r16,currentBank
 9675               	.LVL480:
 9676               	.LBB763:
 9677               	.LBB764:
3219:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 9678               		.loc 1 3219 0
 9679 3f04 8091 0000 		lds r24,cardState
 9680 3f08 8E30      		cpi r24,lo8(14)
 9681 3f0a 01F0      		breq .+2
 9682 3f0c 00C0      		rjmp .L908
3221:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 9683               		.loc 1 3221 0
 9684 3f0e C02F      		mov r28,r16
 9685 3f10 D0E0      		ldi r29,0
 9686 3f12 84E2      		ldi r24,lo8(36)
 9687 3f14 089F      		mul r16,r24
 9688 3f16 F001      		movw r30,r0
 9689 3f18 1124      		clr __zero_reg__
 9690 3f1a E050      		subi r30,lo8(-(bankStates))
 9691 3f1c F040      		sbci r31,hi8(-(bankStates))
 9692 3f1e 8581      		ldd r24,Z+5
 9693 3f20 8111      		cpse r24,__zero_reg__
 9694 3f22 00C0      		rjmp .L908
3223:WTPA.c        **** 			sreg=SREG;
 9695               		.loc 1 3223 0
 9696 3f24 1FB7      		in r17,__SREG__
 9697               	.LVL481:
3224:WTPA.c        **** 			cli();		// Pause ISR
 9698               		.loc 1 3224 0
 9699               	/* #APP */
 9700               	 ;  3224 "WTPA.c" 1
 9701 3f26 F894      		cli
 9702               	 ;  0 "" 2
 9703               	.LVL482:
 9704               	/* #NOAPP */
 9705               	.LBB765:
 9706               	.LBB766:
2361:WTPA.c        **** 	sreg=SREG;
 9707               		.loc 1 2361 0
 9708 3f28 BFB6      		in r11,__SREG__
 9709               	.LVL483:
2362:WTPA.c        **** 	cli();		// Pause ISR
 9710               		.loc 1 2362 0
 9711               	/* #APP */
 9712               	 ;  2362 "WTPA.c" 1
 9713 3f2a F894      		cli
 9714               	 ;  0 "" 2
2364:WTPA.c        **** 	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block r
 9715               		.loc 1 2364 0
 9716               	/* #NOAPP */
 9717 3f2c DC2C      		mov r13,r12
 9718 3f2e CC24      		clr r12
 9719 3f30 DD0C      		lsl r13
 9720 3f32 DD0C      		lsl r13
 9721               	.LVL484:
 9722 3f34 4FEF      		ldi r20,-1
 9723 3f36 C41A      		sub r12,r20
 9724 3f38 D40A      		sbc r13,r20
 9725 3f3a E12C      		mov r14,__zero_reg__
 9726 3f3c F12C      		mov r15,__zero_reg__
 9727 3f3e C701      		movw r24,r14
 9728 3f40 B601      		movw r22,r12
 9729 3f42 0E94 0000 		call SdBeginSingleBlockRead
 9730               	.LVL485:
 9731 3f46 8130      		cpi r24,lo8(1)
 9732 3f48 01F4      		brne .+2
 9733 3f4a 00C0      		rjmp .L1120
2380:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 9734               		.loc 1 2380 0
 9735 3f4c BFBE      		out __SREG__,r11
 9736               	.L911:
 9737               	.LBE766:
 9738               	.LBE765:
3227:WTPA.c        **** 			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non
 9739               		.loc 1 3227 0
 9740 3f4e 81E0      		ldi r24,lo8(1)
 9741 3f50 90E0      		ldi r25,0
 9742 3f52 A0E0      		ldi r26,0
 9743 3f54 B0E0      		ldi r27,0
 9744 3f56 8093 0000 		sts sdRamSampleRemaining,r24
 9745 3f5a 9093 0000 		sts sdRamSampleRemaining+1,r25
 9746 3f5e A093 0000 		sts sdRamSampleRemaining+2,r26
 9747 3f62 B093 0000 		sts sdRamSampleRemaining+3,r27
 9748               	.LVL486:
 9749               	.LBB768:
 9750               	.LBB769:
3103:WTPA.c        **** 	sreg=SREG;
 9751               		.loc 1 3103 0
 9752 3f66 2FB7      		in r18,__SREG__
 9753               	.LVL487:
3104:WTPA.c        **** 	cli();		// Pause ISRs
 9754               		.loc 1 3104 0
 9755               	/* #APP */
 9756               	 ;  3104 "WTPA.c" 1
 9757 3f68 F894      		cli
 9758               	 ;  0 "" 2
3106:WTPA.c        **** 	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in t
 9759               		.loc 1 3106 0
 9760               	/* #NOAPP */
 9761 3f6a 81E0      		ldi r24,lo8(1)
 9762 3f6c 8093 0000 		sts sdIsrState,r24
3107:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 9763               		.loc 1 3107 0
 9764 3f70 94E2      		ldi r25,lo8(36)
 9765 3f72 9C9F      		mul r25,r28
 9766 3f74 F001      		movw r30,r0
 9767 3f76 9D9F      		mul r25,r29
 9768 3f78 F00D      		add r31,r0
 9769 3f7a 1124      		clr __zero_reg__
 9770 3f7c E050      		subi r30,lo8(-(bankStates))
 9771 3f7e F040      		sbci r31,hi8(-(bankStates))
 9772 3f80 8583      		std Z+5,r24
3109:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 9773               		.loc 1 3109 0
 9774 3f82 0023      		tst r16
 9775 3f84 01F4      		brne .+2
 9776 3f86 00C0      		rjmp .L1121
3116:WTPA.c        **** 		sdBank0=false;
 9777               		.loc 1 3116 0
 9778 3f88 1092 0000 		sts sdBank0,__zero_reg__
3117:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 9779               		.loc 1 3117 0
 9780 3f8c 8FEF      		ldi r24,lo8(-1)
 9781 3f8e 9FEF      		ldi r25,lo8(-1)
 9782 3f90 A7E0      		ldi r26,lo8(7)
 9783 3f92 B0E0      		ldi r27,0
 9784 3f94 8093 0000 		sts sdRamAddress,r24
 9785 3f98 9093 0000 		sts sdRamAddress+1,r25
 9786 3f9c A093 0000 		sts sdRamAddress+2,r26
 9787 3fa0 B093 0000 		sts sdRamAddress+3,r27
 9788               	.L913:
3120:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 9789               		.loc 1 3120 0
 9790 3fa4 1092 B200 		sts 178,__zero_reg__
3121:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 9791               		.loc 1 3121 0
 9792 3fa8 81E6      		ldi r24,lo8(97)
 9793 3faa 8093 B300 		sts 179,r24
3122:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 9794               		.loc 1 3122 0
 9795 3fae 8FEF      		ldi r24,lo8(-1)
 9796 3fb0 87BB      		out 0x17,r24
3123:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 9797               		.loc 1 3123 0
 9798 3fb2 8091 7000 		lds r24,112
 9799 3fb6 8460      		ori r24,lo8(4)
 9800 3fb8 8093 7000 		sts 112,r24
3124:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 9801               		.loc 1 3124 0
 9802 3fbc 82E0      		ldi r24,lo8(2)
 9803 3fbe 8093 B100 		sts 177,r24
3126:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 9804               		.loc 1 3126 0
 9805 3fc2 2FBF      		out __SREG__,r18
 9806               	.LBE769:
 9807               	.LBE768:
3230:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 9808               		.loc 1 3230 0
 9809 3fc4 1FBF      		out __SREG__,r17
 9810 3fc6 1091 0000 		lds r17,newKeys
 9811               	.LVL488:
 9812               	.L908:
 9813               	.LBE764:
 9814               	.LBE763:
4094:WTPA.c        **** 			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
 9815               		.loc 1 4094 0
 9816 3fca 12FF      		sbrs r17,2
 9817 3fcc 00C0      		rjmp .L914
4096:WTPA.c        **** 				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have some
 9818               		.loc 1 4096 0
 9819 3fce F090 0000 		lds r15,currentBank
 9820 3fd2 2F2D      		mov r18,r15
 9821 3fd4 30E0      		ldi r19,0
 9822 3fd6 84E2      		ldi r24,lo8(36)
 9823 3fd8 F89E      		mul r15,r24
 9824 3fda F001      		movw r30,r0
 9825 3fdc 1124      		clr __zero_reg__
 9826 3fde E050      		subi r30,lo8(-(bankStates))
 9827 3fe0 F040      		sbci r31,hi8(-(bankStates))
 9828 3fe2 4189      		ldd r20,Z+17
 9829 3fe4 5289      		ldd r21,Z+18
 9830 3fe6 6389      		ldd r22,Z+19
 9831 3fe8 7489      		ldd r23,Z+20
 9832 3fea 8585      		ldd r24,Z+13
 9833 3fec 9685      		ldd r25,Z+14
 9834 3fee A785      		ldd r26,Z+15
 9835 3ff0 B089      		ldd r27,Z+16
 9836 3ff2 4817      		cp r20,r24
 9837 3ff4 5907      		cpc r21,r25
 9838 3ff6 6A07      		cpc r22,r26
 9839 3ff8 7B07      		cpc r23,r27
 9840 3ffa 01F0      		breq .L914
4098:WTPA.c        **** 					WriteSampleToSd(currentBank,sdCurrentSlot);
 9841               		.loc 1 4098 0
 9842 3ffc D091 0000 		lds r29,sdCurrentSlot
 9843 4000 1091 0000 		lds r17,sdCurrentSlot+1
 9844               	.LVL489:
 9845               	.LBB775:
 9846               	.LBB776:
3196:WTPA.c        **** 	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
 9847               		.loc 1 3196 0
 9848 4004 8091 0000 		lds r24,cardState
 9849 4008 8E30      		cpi r24,lo8(14)
 9850 400a 01F4      		brne .+2
 9851 400c 00C0      		rjmp .L1122
 9852               	.L915:
 9853               	.LVL490:
 9854 400e 3091 0000 		lds r19,ledBlinkMask
 9855 4012 832F      		mov r24,r19
 9856 4014 90E0      		ldi r25,0
 9857 4016 2091 0000 		lds r18,ledOnOffMask
 9858               	.LBE776:
 9859               	.LBE775:
 9860               	.LBB791:
 9861               	.LBB792:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9862               		.loc 1 1566 0
 9863 401a 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9864               		.loc 1 1568 0
 9865 401c 2E7F      		andi r18,lo8(-2)
 9866               	.L924:
 9867               	.LVL491:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9868               		.loc 1 1566 0
 9869 401e 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9870               		.loc 1 1568 0
 9871 4020 2D7F      		andi r18,lo8(-3)
 9872               	.L925:
 9873               	.LVL492:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9874               		.loc 1 1566 0
 9875 4022 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9876               		.loc 1 1568 0
 9877 4024 2B7F      		andi r18,lo8(-5)
 9878               	.L926:
 9879               	.LVL493:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9880               		.loc 1 1566 0
 9881 4026 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9882               		.loc 1 1568 0
 9883 4028 277F      		andi r18,lo8(-9)
 9884               	.L927:
 9885               	.LVL494:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9886               		.loc 1 1566 0
 9887 402a 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9888               		.loc 1 1568 0
 9889 402c 2F7E      		andi r18,lo8(-17)
 9890               	.L928:
 9891               	.LVL495:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9892               		.loc 1 1566 0
 9893 402e 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9894               		.loc 1 1568 0
 9895 4030 2F7D      		andi r18,lo8(-33)
 9896               	.L929:
 9897               	.LVL496:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9898               		.loc 1 1566 0
 9899 4032 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9900               		.loc 1 1568 0
 9901 4034 2F7B      		andi r18,lo8(-65)
 9902               	.L930:
 9903               	.LVL497:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 9904               		.loc 1 1566 0
 9905 4036 880F      		lsl r24
 9906 4038 892F      		mov r24,r25
 9907 403a 881F      		rol r24
 9908 403c 990B      		sbc r25,r25
 9909 403e 892B      		or r24,r25
 9910 4040 01F0      		breq .L931
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 9911               		.loc 1 1568 0
 9912 4042 2F77      		andi r18,lo8(127)
 9913               	.L931:
 9914               	.LVL498:
 9915 4044 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 9916               		.loc 1 1572 0
 9917 4048 80E8      		ldi r24,lo8(-128)
 9918 404a 8093 0000 		sts ledBlinkMask,r24
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 9919               		.loc 1 1573 0
 9920 404e 68E9      		ldi r22,lo8(-104)
 9921 4050 70E0      		ldi r23,0
 9922 4052 82E0      		ldi r24,lo8(2)
 9923 4054 0E94 0000 		call SetTimer
 9924               	.LVL499:
 9925 4058 1091 0000 		lds r17,newKeys
 9926               	.LVL500:
 9927               	.L914:
 9928               	.LBE792:
 9929               	.LBE791:
4102:WTPA.c        **** 			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like 
 9930               		.loc 1 4102 0
 9931 405c 13FF      		sbrs r17,3
 9932 405e 00C0      		rjmp .L932
4104:WTPA.c        **** 				if(CheckSdSlotFull(sdCurrentSlot))
 9933               		.loc 1 4104 0
 9934 4060 8091 0000 		lds r24,sdCurrentSlot
 9935 4064 9091 0000 		lds r25,sdCurrentSlot+1
 9936               	.LVL501:
 9937               	.LBB793:
 9938               	.LBB794:
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 9939               		.loc 1 2178 0
 9940 4068 FC01      		movw r30,r24
 9941 406a F695      		lsr r31
 9942 406c E795      		ror r30
 9943 406e F695      		lsr r31
 9944 4070 E795      		ror r30
 9945 4072 F695      		lsr r31
 9946 4074 E795      		ror r30
 9947               	.LBE794:
 9948               		.loc 1 5046 0
 9949 4076 FF27      		clr r31
 9950               	.LBB795:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9951               		.loc 1 2181 0
 9952 4078 E050      		subi r30,lo8(-(sampleToc))
 9953 407a F040      		sbci r31,hi8(-(sampleToc))
 9954 407c 4081      		ld r20,Z
 9955               	.LBE795:
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 9956               		.loc 1 2179 0
 9957 407e 9C01      		movw r18,r24
 9958 4080 2770      		andi r18,7
 9959 4082 3327      		clr r19
 9960               	.LBB796:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 9961               		.loc 1 2181 0
 9962 4084 842F      		mov r24,r20
 9963               	.LVL502:
 9964 4086 90E0      		ldi r25,0
 9965 4088 022E      		mov r0,r18
 9966 408a 00C0      		rjmp 2f
 9967               		1:
 9968 408c 9595      		asr r25
 9969 408e 8795      		ror r24
 9970               		2:
 9971 4090 0A94      		dec r0
 9972 4092 02F4      		brpl 1b
 9973 4094 80FF      		sbrs r24,0
 9974 4096 00C0      		rjmp .L932
 9975               	.LBE796:
 9976               	.LBE793:
4106:WTPA.c        **** 					if(cardState==SD_IDLE)	// Got what we wanted?
 9977               		.loc 1 4106 0
 9978 4098 8091 0000 		lds r24,cardState
 9979 409c 8E30      		cpi r24,lo8(14)
 9980 409e 01F4      		brne .L932
 9981               	.LVL503:
 9982               	.LBB797:
 9983               	.LBB798:
2214:WTPA.c        **** 	sampleToc[theByte]&=~(1<<theBit);	// Clear it
 9984               		.loc 1 2214 0
 9985 40a0 81E0      		ldi r24,lo8(1)
 9986 40a2 90E0      		ldi r25,0
 9987 40a4 00C0      		rjmp 2f
 9988               		1:
 9989 40a6 880F      		lsl r24
 9990               		2:
 9991 40a8 2A95      		dec r18
 9992 40aa 02F4      		brpl 1b
 9993 40ac 8095      		com r24
 9994 40ae 8423      		and r24,r20
 9995 40b0 8083      		st Z,r24
 9996               	.LBE798:
 9997               	.LBE797:
4109:WTPA.c        **** 						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
 9998               		.loc 1 4109 0
 9999 40b2 86E0      		ldi r24,lo8(6)
 10000 40b4 8093 0000 		sts cardState,r24
 10001               	.LVL504:
 10002 40b8 3091 0000 		lds r19,ledBlinkMask
 10003 40bc 832F      		mov r24,r19
 10004 40be 90E0      		ldi r25,0
 10005 40c0 2091 0000 		lds r18,ledOnOffMask
 10006               	.LVL505:
 10007               	.LBB799:
 10008               	.LBB800:
 10009               	.LBB801:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10010               		.loc 1 1566 0
 10011 40c4 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10012               		.loc 1 1568 0
 10013 40c6 2E7F      		andi r18,lo8(-2)
 10014               	.L934:
 10015               	.LVL506:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10016               		.loc 1 1566 0
 10017 40c8 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10018               		.loc 1 1568 0
 10019 40ca 2D7F      		andi r18,lo8(-3)
 10020               	.L935:
 10021               	.LVL507:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10022               		.loc 1 1566 0
 10023 40cc 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10024               		.loc 1 1568 0
 10025 40ce 2B7F      		andi r18,lo8(-5)
 10026               	.L936:
 10027               	.LVL508:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10028               		.loc 1 1566 0
 10029 40d0 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10030               		.loc 1 1568 0
 10031 40d2 277F      		andi r18,lo8(-9)
 10032               	.L937:
 10033               	.LVL509:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10034               		.loc 1 1566 0
 10035 40d4 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10036               		.loc 1 1568 0
 10037 40d6 2F7E      		andi r18,lo8(-17)
 10038               	.L938:
 10039               	.LVL510:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10040               		.loc 1 1566 0
 10041 40d8 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10042               		.loc 1 1568 0
 10043 40da 2F7D      		andi r18,lo8(-33)
 10044               	.L939:
 10045               	.LVL511:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10046               		.loc 1 1566 0
 10047 40dc 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10048               		.loc 1 1568 0
 10049 40de 2F7B      		andi r18,lo8(-65)
 10050               	.L940:
 10051               	.LVL512:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10052               		.loc 1 1566 0
 10053 40e0 880F      		lsl r24
 10054 40e2 892F      		mov r24,r25
 10055 40e4 881F      		rol r24
 10056 40e6 990B      		sbc r25,r25
 10057 40e8 892B      		or r24,r25
 10058 40ea 01F0      		breq .L941
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10059               		.loc 1 1568 0
 10060 40ec 2F77      		andi r18,lo8(127)
 10061               	.L941:
 10062               	.LVL513:
 10063 40ee 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10064               		.loc 1 1572 0
 10065 40f2 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10066               		.loc 1 1573 0
 10067 40f6 68E9      		ldi r22,lo8(-104)
 10068 40f8 70E0      		ldi r23,0
 10069 40fa 82E0      		ldi r24,lo8(2)
 10070 40fc 0E94 0000 		call SetTimer
 10071               	.LVL514:
 10072               	.LBE801:
 10073               	.LBE800:
 10074               	.LBE799:
4111:WTPA.c        **** 						ledOnOffMask&=~(1<<LED_7);
 10075               		.loc 1 4111 0
 10076 4100 8091 0000 		lds r24,ledOnOffMask
 10077 4104 8F77      		andi r24,lo8(127)
 10078 4106 8093 0000 		sts ledOnOffMask,r24
 10079 410a 1091 0000 		lds r17,newKeys
 10080               	.LVL515:
 10081               	.L932:
4116:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
 10082               		.loc 1 4116 0
 10083 410e 14FD      		sbrc r17,4
 10084 4110 00C0      		rjmp .L942
4004:WTPA.c        **** static void SdCardMenu(void)
 10085               		.loc 1 4004 0
 10086 4112 812F      		mov r24,r17
 10087 4114 8076      		andi r24,lo8(96)
4116:WTPA.c        **** 			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		
 10088               		.loc 1 4116 0
 10089 4116 01F0      		breq .+2
 10090 4118 00C0      		rjmp .L942
 10091 411a 17FF      		sbrs r17,7
 10092 411c 00C0      		rjmp .L856
 10093 411e 00C0      		rjmp .L942
 10094               	.L858:
 10095               	.LBE813:
 10096               	.LBE815:
4019:WTPA.c        **** 			sdCurrentSlot=127;
 10097               		.loc 1 4019 0
 10098 4120 8FE7      		ldi r24,lo8(127)
 10099 4122 90E0      		ldi r25,0
 10100 4124 9093 0000 		sts sdCurrentSlot+1,r25
 10101 4128 8093 0000 		sts sdCurrentSlot,r24
 10102 412c 4FE7      		ldi r20,lo8(127)
 10103 412e 00C0      		rjmp .L859
 10104               	.LVL516:
 10105               	.L1117:
 10106               	.LBB816:
 10107               	.LBB742:
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10108               		.loc 1 1568 0
 10109 4130 2F77      		andi r18,lo8(127)
 10110 4132 00C0      		rjmp .L876
 10111               	.LVL517:
 10112               	.L879:
 10113               	.LBE742:
 10114               	.LBE816:
 10115               	.LBB817:
 10116               	.LBB814:
 10117               	.LBB802:
 10118               	.LBB803:
2423:WTPA.c        **** 	sreg=SREG;
 10119               		.loc 1 2423 0
 10120 4134 CFB7      		in r28,__SREG__
 10121               	.LVL518:
2424:WTPA.c        **** 	cli();
 10122               		.loc 1 2424 0
 10123               	/* #APP */
 10124               	 ;  2424 "WTPA.c" 1
 10125 4136 F894      		cli
 10126               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 10127               		.loc 1 2426 0
 10128               	/* #NOAPP */
 10129 4138 0E94 0000 		call EndSdTransfer
 10130               	.LVL519:
 10131 413c E0E0      		ldi r30,lo8(sampleToc)
 10132 413e F0E0      		ldi r31,hi8(sampleToc)
 10133               	.LVL520:
 10134               	.L882:
 10135               	.LBB804:
 10136               	.LBB805:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 10137               		.loc 1 2166 0
 10138 4140 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 10139               		.loc 1 2164 0
 10140 4142 40E0      		ldi r20,hi8(sampleToc+64)
 10141 4144 E030      		cpi r30,lo8(sampleToc+64)
 10142 4146 F407      		cpc r31,r20
 10143 4148 01F4      		brne .L882
 10144               	.LBE805:
 10145               	.LBE804:
2431:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 10146               		.loc 1 2431 0
 10147 414a 1092 0000 		sts sdIsrState,__zero_reg__
2432:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
 10148               		.loc 1 2432 0
 10149 414e 1092 B100 		sts 177,__zero_reg__
2433:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 10150               		.loc 1 2433 0
 10151 4152 8091 7000 		lds r24,112
 10152 4156 8B7F      		andi r24,lo8(-5)
 10153 4158 8093 7000 		sts 112,r24
2436:WTPA.c        **** 	sdStreamOutput=0;
 10154               		.loc 1 2436 0
 10155 415c 1092 0000 		sts sdStreamOutput,__zero_reg__
2438:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 10156               		.loc 1 2438 0
 10157 4160 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 10158 4164 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2439:WTPA.c        **** 	sdFifoWritePointer=0;
 10159               		.loc 1 2439 0
 10160 4168 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 10161 416c 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2440:WTPA.c        **** 	sdBytesInFifo=0;
 10162               		.loc 1 2440 0
 10163 4170 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 10164 4174 1092 0000 		sts sdBytesInFifo,__zero_reg__
2442:WTPA.c        **** 	InitSdInterface();
 10165               		.loc 1 2442 0
 10166 4178 0E94 0000 		call InitSdInterface
 10167               	.LVL521:
2443:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
 10168               		.loc 1 2443 0
 10169 417c 1092 0000 		sts cardState,__zero_reg__
2445:WTPA.c        **** 	SREG=sreg;
 10170               		.loc 1 2445 0
 10171 4180 CFBF      		out __SREG__,r28
 10172 4182 00C0      		rjmp .L942
 10173               	.LVL522:
 10174               	.L907:
 10175               	.LBE803:
 10176               	.LBE802:
4084:WTPA.c        **** 					PlaySampleFromSd(sdCurrentSlot);
 10177               		.loc 1 4084 0
 10178 4184 0E94 0000 		call PlaySampleFromSd
 10179               	.LVL523:
 10180 4188 1091 0000 		lds r17,newKeys
 10181 418c 00C0      		rjmp .L906
 10182               	.L1119:
4050:WTPA.c        **** 					sdCurrentSlot++;
 10183               		.loc 1 4050 0
 10184 418e 8091 0000 		lds r24,sdCurrentSlot
 10185 4192 9091 0000 		lds r25,sdCurrentSlot+1
 10186 4196 0196      		adiw r24,1
4051:WTPA.c        **** 					if(sdCurrentSlot>127)
 10187               		.loc 1 4051 0
 10188 4198 8038      		cpi r24,-128
 10189 419a 9105      		cpc r25,__zero_reg__
 10190 419c 00F0      		brlo .+2
 10191 419e 00C0      		rjmp .L885
4050:WTPA.c        **** 					sdCurrentSlot++;
 10192               		.loc 1 4050 0
 10193 41a0 9093 0000 		sts sdCurrentSlot+1,r25
 10194 41a4 8093 0000 		sts sdCurrentSlot,r24
 10195 41a8 682F      		mov r22,r24
 10196 41aa 9C01      		movw r18,r24
 10197 41ac 3695      		lsr r19
 10198 41ae 2795      		ror r18
 10199 41b0 3695      		lsr r19
 10200 41b2 2795      		ror r18
 10201 41b4 3695      		lsr r19
 10202 41b6 2795      		ror r18
 10203 41b8 AC01      		movw r20,r24
 10204 41ba 4770      		andi r20,7
 10205 41bc 5527      		clr r21
 10206 41be 00C0      		rjmp .L886
 10207               	.L889:
 10208 41c0 822F      		mov r24,r18
 10209 41c2 90E0      		ldi r25,0
 10210               	.LBB806:
 10211               	.LBB807:
 10212               	.LBB808:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10213               		.loc 1 1566 0
 10214 41c4 20FD      		sbrc r18,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10215               		.loc 1 1568 0
 10216 41c6 6E7F      		andi r22,lo8(-2)
 10217               	.L898:
 10218               	.LVL524:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10219               		.loc 1 1566 0
 10220 41c8 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10221               		.loc 1 1568 0
 10222 41ca 6D7F      		andi r22,lo8(-3)
 10223               	.L899:
 10224               	.LVL525:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10225               		.loc 1 1566 0
 10226 41cc 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10227               		.loc 1 1568 0
 10228 41ce 6B7F      		andi r22,lo8(-5)
 10229               	.L900:
 10230               	.LVL526:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10231               		.loc 1 1566 0
 10232 41d0 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10233               		.loc 1 1568 0
 10234 41d2 677F      		andi r22,lo8(-9)
 10235               	.L901:
 10236               	.LVL527:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10237               		.loc 1 1566 0
 10238 41d4 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10239               		.loc 1 1568 0
 10240 41d6 6F7E      		andi r22,lo8(-17)
 10241               	.L902:
 10242               	.LVL528:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10243               		.loc 1 1566 0
 10244 41d8 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10245               		.loc 1 1568 0
 10246 41da 6F7D      		andi r22,lo8(-33)
 10247               	.L903:
 10248               	.LVL529:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10249               		.loc 1 1566 0
 10250 41dc 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10251               		.loc 1 1568 0
 10252 41de 6F7B      		andi r22,lo8(-65)
 10253               	.L904:
 10254               	.LVL530:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10255               		.loc 1 1566 0
 10256 41e0 880F      		lsl r24
 10257 41e2 892F      		mov r24,r25
 10258 41e4 881F      		rol r24
 10259 41e6 990B      		sbc r25,r25
 10260 41e8 892B      		or r24,r25
 10261 41ea 01F0      		breq .L905
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10262               		.loc 1 1568 0
 10263 41ec 6F77      		andi r22,lo8(127)
 10264               	.L905:
 10265               	.LVL531:
 10266 41ee 6093 0000 		sts ledOnOffMask,r22
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10267               		.loc 1 1572 0
 10268 41f2 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10269               		.loc 1 1573 0
 10270 41f6 68E9      		ldi r22,lo8(-104)
 10271 41f8 70E0      		ldi r23,0
 10272 41fa 82E0      		ldi r24,lo8(2)
 10273 41fc 0E94 0000 		call SetTimer
 10274               	.LVL532:
 10275               	.LBE808:
 10276               	.LBE807:
 10277               	.LBE806:
4076:WTPA.c        **** 					ledOnOffMask&=~(1<<LED_7);
 10278               		.loc 1 4076 0
 10279 4200 8091 0000 		lds r24,ledOnOffMask
 10280 4204 8F77      		andi r24,lo8(127)
 10281 4206 8093 0000 		sts ledOnOffMask,r24
 10282 420a 00C0      		rjmp .L883
 10283               	.LVL533:
 10284               	.L888:
4064:WTPA.c        **** 						sdCurrentSlot--;
 10285               		.loc 1 4064 0
 10286 420c 4150      		subi r20,1
 10287 420e 5109      		sbc r21,__zero_reg__
 10288 4210 5093 0000 		sts sdCurrentSlot+1,r21
 10289 4214 4093 0000 		sts sdCurrentSlot,r20
 10290               	.L1115:
 10291 4218 642F      		mov r22,r20
 10292 421a 9A01      		movw r18,r20
 10293 421c 3695      		lsr r19
 10294 421e 2795      		ror r18
 10295 4220 3695      		lsr r19
 10296 4222 2795      		ror r18
 10297 4224 3695      		lsr r19
 10298 4226 2795      		ror r18
 10299 4228 3327      		clr r19
 10300 422a 4770      		andi r20,7
 10301 422c 5527      		clr r21
 10302 422e 00C0      		rjmp .L886
 10303               	.L885:
4053:WTPA.c        **** 						sdCurrentSlot=0;
 10304               		.loc 1 4053 0
 10305 4230 1092 0000 		sts sdCurrentSlot+1,__zero_reg__
 10306 4234 1092 0000 		sts sdCurrentSlot,__zero_reg__
 10307 4238 40E0      		ldi r20,0
 10308 423a 50E0      		ldi r21,0
 10309 423c 20E0      		ldi r18,0
 10310 423e 30E0      		ldi r19,0
 10311 4240 60E0      		ldi r22,0
 10312 4242 00C0      		rjmp .L886
 10313               	.LVL534:
 10314               	.L1122:
 10315               	.LBB809:
 10316               	.LBB789:
3198:WTPA.c        **** 		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
 10317               		.loc 1 3198 0
 10318 4244 8581      		ldd r24,Z+5
 10319 4246 8111      		cpse r24,__zero_reg__
 10320 4248 00C0      		rjmp .L915
 10321               	.LVL535:
 10322               	.LBB777:
 10323               	.LBB778:
3158:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 10324               		.loc 1 3158 0
 10325 424a 8781      		ldd r24,Z+7
3156:WTPA.c        **** 	if(theBank==BANK_0)
 10326               		.loc 1 3156 0
 10327 424c F110      		cpse r15,__zero_reg__
 10328 424e 00C0      		rjmp .L916
3158:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 10329               		.loc 1 3158 0
 10330 4250 8111      		cpse r24,__zero_reg__
 10331 4252 00C0      		rjmp .L917
3160:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+
 10332               		.loc 1 3160 0
 10333 4254 8589      		ldd r24,Z+21
 10334 4256 9689      		ldd r25,Z+22
 10335 4258 A789      		ldd r26,Z+23
 10336 425a B08D      		ldd r27,Z+24
 10337 425c 418D      		ldd r20,Z+25
 10338 425e 528D      		ldd r21,Z+26
 10339 4260 638D      		ldd r22,Z+27
 10340 4262 748D      		ldd r23,Z+28
 10341 4264 0196      		adiw r24,1
 10342 4266 A11D      		adc r26,__zero_reg__
 10343 4268 B11D      		adc r27,__zero_reg__
 10344 426a 841B      		sub r24,r20
 10345 426c 950B      		sbc r25,r21
 10346 426e A60B      		sbc r26,r22
 10347 4270 B70B      		sbc r27,r23
 10348               	.LVL536:
 10349               	.L918:
 10350               	.LBE778:
 10351               	.LBE777:
3202:WTPA.c        **** 			sreg=SREG;
 10352               		.loc 1 3202 0
 10353 4272 CFB7      		in r28,__SREG__
 10354               	.LVL537:
3203:WTPA.c        **** 			cli();		// Pause ISR
 10355               		.loc 1 3203 0
 10356               	/* #APP */
 10357               	 ;  3203 "WTPA.c" 1
 10358 4274 F894      		cli
 10359               	 ;  0 "" 2
 10360               	.LVL538:
 10361               	/* #NOAPP */
 10362               	.LBB781:
 10363               	.LBB782:
2392:WTPA.c        **** 	sreg=SREG;
 10364               		.loc 1 2392 0
 10365 4276 EFB7      		in r30,__SREG__
 10366               	.LVL539:
2393:WTPA.c        **** 	cli();		// Pause ISR
 10367               		.loc 1 2393 0
 10368               	/* #APP */
 10369               	 ;  2393 "WTPA.c" 1
 10370 4278 F894      		cli
 10371               	 ;  0 "" 2
2395:WTPA.c        **** 	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
 10372               		.loc 1 2395 0
 10373               	/* #NOAPP */
 10374 427a D093 0000 		sts sdCurrentSlot,r29
 10375 427e 1093 0000 		sts sdCurrentSlot+1,r17
2396:WTPA.c        **** 	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block 
 10376               		.loc 1 2396 0
 10377 4282 5D2F      		mov r21,r29
 10378 4284 550F      		lsl r21
 10379 4286 550F      		lsl r21
 10380 4288 40E0      		ldi r20,0
 10381 428a 4F5F      		subi r20,-1
 10382 428c 5F4F      		sbci r21,-1
 10383 428e 60E0      		ldi r22,0
 10384 4290 70E0      		ldi r23,0
 10385 4292 4093 0000 		sts sdSampleStartBlock,r20
 10386 4296 5093 0000 		sts sdSampleStartBlock+1,r21
 10387 429a 6093 0000 		sts sdSampleStartBlock+2,r22
 10388 429e 7093 0000 		sts sdSampleStartBlock+3,r23
2397:WTPA.c        **** 	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
 10389               		.loc 1 2397 0
 10390 42a2 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 10391 42a6 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2399:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 10392               		.loc 1 2399 0
 10393 42aa 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 10394 42ae 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2400:WTPA.c        **** 	sdFifoWritePointer=0;
 10395               		.loc 1 2400 0
 10396 42b2 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 10397 42b6 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2401:WTPA.c        **** 	sdBytesInFifo=0;
 10398               		.loc 1 2401 0
 10399 42ba 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 10400 42be 1092 0000 		sts sdBytesInFifo,__zero_reg__
2403:WTPA.c        **** 	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would 
 10401               		.loc 1 2403 0
 10402 42c2 8D3F      		cpi r24,-3
 10403 42c4 4FEF      		ldi r20,-1
 10404 42c6 9407      		cpc r25,r20
 10405 42c8 47E0      		ldi r20,7
 10406 42ca A407      		cpc r26,r20
 10407 42cc B105      		cpc r27,__zero_reg__
 10408 42ce 00F0      		brlo .L1116
2409:WTPA.c        **** 		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
 10409               		.loc 1 2409 0
 10410 42d0 8CEF      		ldi r24,lo8(-4)
 10411 42d2 9FEF      		ldi r25,lo8(-1)
 10412 42d4 A7E0      		ldi r26,lo8(7)
 10413 42d6 B0E0      		ldi r27,0
 10414               	.LVL540:
 10415               	.L1116:
 10416 42d8 8093 0000 		sts sdRamSampleRemaining,r24
 10417 42dc 9093 0000 		sts sdRamSampleRemaining+1,r25
 10418 42e0 A093 0000 		sts sdRamSampleRemaining+2,r26
 10419 42e4 B093 0000 		sts sdRamSampleRemaining+3,r27
2412:WTPA.c        **** 	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from S
 10420               		.loc 1 2412 0
 10421 42e8 8091 0000 		lds r24,sdRamSampleRemaining
 10422 42ec 9091 0000 		lds r25,sdRamSampleRemaining+1
 10423 42f0 A091 0000 		lds r26,sdRamSampleRemaining+2
 10424 42f4 B091 0000 		lds r27,sdRamSampleRemaining+3
 10425 42f8 8093 0000 		sts sdCardSampleRemaining,r24
 10426 42fc 9093 0000 		sts sdCardSampleRemaining+1,r25
 10427 4300 A093 0000 		sts sdCardSampleRemaining+2,r26
 10428 4304 B093 0000 		sts sdCardSampleRemaining+3,r27
2413:WTPA.c        **** 	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have
 10429               		.loc 1 2413 0
 10430 4308 82E0      		ldi r24,lo8(2)
 10431 430a 8093 0000 		sts cardState,r24
2414:WTPA.c        **** 	SREG=sreg;	// Resume ISR
 10432               		.loc 1 2414 0
 10433 430e EFBF      		out __SREG__,r30
 10434               	.LVL541:
 10435               	.LBE782:
 10436               	.LBE781:
 10437               	.LBB783:
 10438               	.LBB784:
3070:WTPA.c        **** 	sreg=SREG;
 10439               		.loc 1 3070 0
 10440 4310 4FB7      		in r20,__SREG__
 10441               	.LVL542:
3071:WTPA.c        **** 	cli();		// Pause ISRs
 10442               		.loc 1 3071 0
 10443               	/* #APP */
 10444               	 ;  3071 "WTPA.c" 1
 10445 4312 F894      		cli
 10446               	 ;  0 "" 2
3073:WTPA.c        **** 	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
 10447               		.loc 1 3073 0
 10448               	/* #NOAPP */
 10449 4314 8093 0000 		sts sdIsrState,r24
3074:WTPA.c        **** 	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
 10450               		.loc 1 3074 0
 10451 4318 84E2      		ldi r24,lo8(36)
 10452 431a 829F      		mul r24,r18
 10453 431c F001      		movw r30,r0
 10454 431e 839F      		mul r24,r19
 10455 4320 F00D      		add r31,r0
 10456 4322 1124      		clr __zero_reg__
 10457               	.LVL543:
 10458 4324 E050      		subi r30,lo8(-(bankStates))
 10459 4326 F040      		sbci r31,hi8(-(bankStates))
 10460 4328 81E0      		ldi r24,lo8(1)
 10461 432a 8583      		std Z+5,r24
3076:WTPA.c        **** 	if(theBank==BANK_0)		// Pointing at this bank?
 10462               		.loc 1 3076 0
 10463 432c FF20      		tst r15
 10464 432e 01F0      		breq .L1123
3083:WTPA.c        **** 		sdBank0=false;
 10465               		.loc 1 3083 0
 10466 4330 1092 0000 		sts sdBank0,__zero_reg__
3084:WTPA.c        **** 		sdRamAddress=BANK_1_START_ADDRESS;
 10467               		.loc 1 3084 0
 10468 4334 8FEF      		ldi r24,lo8(-1)
 10469 4336 9FEF      		ldi r25,lo8(-1)
 10470 4338 A7E0      		ldi r26,lo8(7)
 10471 433a B0E0      		ldi r27,0
 10472 433c 8093 0000 		sts sdRamAddress,r24
 10473 4340 9093 0000 		sts sdRamAddress+1,r25
 10474 4344 A093 0000 		sts sdRamAddress+2,r26
 10475 4348 B093 0000 		sts sdRamAddress+3,r27
 10476               	.L923:
3087:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 10477               		.loc 1 3087 0
 10478 434c 1092 B200 		sts 178,__zero_reg__
3088:WTPA.c        **** 	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
 10479               		.loc 1 3088 0
 10480 4350 81E6      		ldi r24,lo8(97)
 10481 4352 8093 B300 		sts 179,r24
3089:WTPA.c        **** 	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
 10482               		.loc 1 3089 0
 10483 4356 8FEF      		ldi r24,lo8(-1)
 10484 4358 87BB      		out 0x17,r24
3090:WTPA.c        **** 	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
 10485               		.loc 1 3090 0
 10486 435a 8091 7000 		lds r24,112
 10487 435e 8460      		ori r24,lo8(4)
 10488 4360 8093 7000 		sts 112,r24
3091:WTPA.c        **** 	TCCR2B=0x02;				// Clock on, prescaler /8
 10489               		.loc 1 3091 0
 10490 4364 82E0      		ldi r24,lo8(2)
 10491 4366 8093 B100 		sts 177,r24
3093:WTPA.c        **** 	SREG=sreg;	// Resume ISRs
 10492               		.loc 1 3093 0
 10493 436a 4FBF      		out __SREG__,r20
 10494               	.LBE784:
 10495               	.LBE783:
3208:WTPA.c        **** 			SREG=sreg;		// Resume ISR
 10496               		.loc 1 3208 0
 10497 436c CFBF      		out __SREG__,r28
 10498 436e 00C0      		rjmp .L915
 10499               	.LVL544:
 10500               	.L916:
 10501               	.LBB786:
 10502               	.LBB779:
3169:WTPA.c        **** 		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
 10503               		.loc 1 3169 0
 10504 4370 8823      		tst r24
 10505 4372 01F0      		breq .L1124
3175:WTPA.c        **** 			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
 10506               		.loc 1 3175 0
 10507 4374 8189      		ldd r24,Z+17
 10508 4376 9289      		ldd r25,Z+18
 10509 4378 A389      		ldd r26,Z+19
 10510 437a B489      		ldd r27,Z+20
 10511 437c 4585      		ldd r20,Z+13
 10512 437e 5685      		ldd r21,Z+14
 10513 4380 6785      		ldd r22,Z+15
 10514 4382 7089      		ldd r23,Z+16
 10515 4384 841B      		sub r24,r20
 10516 4386 950B      		sbc r25,r21
 10517 4388 A60B      		sbc r26,r22
 10518 438a B70B      		sbc r27,r23
 10519               	.LVL545:
 10520 438c 00C0      		rjmp .L918
 10521               	.LVL546:
 10522               	.L1123:
 10523               	.LBE779:
 10524               	.LBE786:
 10525               	.LBB787:
 10526               	.LBB785:
3078:WTPA.c        **** 		sdBank0=true;
 10527               		.loc 1 3078 0
 10528 438e 8093 0000 		sts sdBank0,r24
3079:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 10529               		.loc 1 3079 0
 10530 4392 1092 0000 		sts sdRamAddress,__zero_reg__
 10531 4396 1092 0000 		sts sdRamAddress+1,__zero_reg__
 10532 439a 1092 0000 		sts sdRamAddress+2,__zero_reg__
 10533 439e 1092 0000 		sts sdRamAddress+3,__zero_reg__
 10534 43a2 00C0      		rjmp .L923
 10535               	.LVL547:
 10536               	.L1121:
 10537               	.LBE785:
 10538               	.LBE787:
 10539               	.LBE789:
 10540               	.LBE809:
 10541               	.LBB810:
 10542               	.LBB773:
 10543               	.LBB771:
 10544               	.LBB770:
3111:WTPA.c        **** 		sdBank0=true;
 10545               		.loc 1 3111 0
 10546 43a4 8093 0000 		sts sdBank0,r24
3112:WTPA.c        **** 		sdRamAddress=BANK_0_START_ADDRESS;
 10547               		.loc 1 3112 0
 10548 43a8 1092 0000 		sts sdRamAddress,__zero_reg__
 10549 43ac 1092 0000 		sts sdRamAddress+1,__zero_reg__
 10550 43b0 1092 0000 		sts sdRamAddress+2,__zero_reg__
 10551 43b4 1092 0000 		sts sdRamAddress+3,__zero_reg__
 10552 43b8 00C0      		rjmp .L913
 10553               	.LVL548:
 10554               	.L917:
 10555               	.LBE770:
 10556               	.LBE771:
 10557               	.LBE773:
 10558               	.LBE810:
 10559               	.LBB811:
 10560               	.LBB790:
 10561               	.LBB788:
 10562               	.LBB780:
3164:WTPA.c        **** 			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the leng
 10563               		.loc 1 3164 0
 10564 43ba 8585      		ldd r24,Z+13
 10565 43bc 9685      		ldd r25,Z+14
 10566 43be A785      		ldd r26,Z+15
 10567 43c0 B089      		ldd r27,Z+16
 10568               	.LVL549:
 10569 43c2 00C0      		rjmp .L918
 10570               	.LVL550:
 10571               	.L1124:
3171:WTPA.c        **** 			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+
 10572               		.loc 1 3171 0
 10573 43c4 818D      		ldd r24,Z+25
 10574 43c6 928D      		ldd r25,Z+26
 10575 43c8 A38D      		ldd r26,Z+27
 10576 43ca B48D      		ldd r27,Z+28
 10577 43cc 4589      		ldd r20,Z+21
 10578 43ce 5689      		ldd r21,Z+22
 10579 43d0 6789      		ldd r22,Z+23
 10580 43d2 708D      		ldd r23,Z+24
 10581 43d4 0196      		adiw r24,1
 10582 43d6 A11D      		adc r26,__zero_reg__
 10583 43d8 B11D      		adc r27,__zero_reg__
 10584 43da 841B      		sub r24,r20
 10585 43dc 950B      		sbc r25,r21
 10586 43de A60B      		sbc r26,r22
 10587 43e0 B70B      		sbc r27,r23
 10588               	.LVL551:
 10589 43e2 00C0      		rjmp .L918
 10590               	.LVL552:
 10591               	.L1120:
 10592               	.LBE780:
 10593               	.LBE788:
 10594               	.LBE790:
 10595               	.LBE811:
 10596               	.LBB812:
 10597               	.LBB774:
 10598               	.LBB772:
 10599               	.LBB767:
2366:WTPA.c        **** 		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block
 10600               		.loc 1 2366 0
 10601 43e4 C092 0000 		sts sdSampleStartBlock,r12
 10602 43e8 D092 0000 		sts sdSampleStartBlock+1,r13
 10603 43ec E092 0000 		sts sdSampleStartBlock+2,r14
 10604 43f0 F092 0000 		sts sdSampleStartBlock+3,r15
2367:WTPA.c        **** 		sdCurrentBlockOffset=0;						// Read first block first
 10605               		.loc 1 2367 0
 10606 43f4 1092 0000 		sts sdCurrentBlockOffset+1,__zero_reg__
 10607 43f8 1092 0000 		sts sdCurrentBlockOffset,__zero_reg__
2369:WTPA.c        **** 		sdFifoReadPointer=0;		// Reset FIFO variables
 10608               		.loc 1 2369 0
 10609 43fc 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 10610 4400 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2370:WTPA.c        **** 		sdFifoWritePointer=0;
 10611               		.loc 1 2370 0
 10612 4404 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 10613 4408 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2371:WTPA.c        **** 		sdBytesInFifo=0;
 10614               		.loc 1 2371 0
 10615 440c 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 10616 4410 1092 0000 		sts sdBytesInFifo,__zero_reg__
2373:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 10617               		.loc 1 2373 0
 10618 4414 6AE7      		ldi r22,lo8(122)
 10619 4416 70E0      		ldi r23,0
 10620 4418 83E0      		ldi r24,lo8(3)
 10621 441a 0E94 0000 		call SetTimer
 10622               	.LVL553:
2374:WTPA.c        **** 		cardState=SD_READ_START;				// Read in the first sample block with the state machine
 10623               		.loc 1 2374 0
 10624 441e 89E0      		ldi r24,lo8(9)
 10625 4420 8093 0000 		sts cardState,r24
2376:WTPA.c        **** 		SREG=sreg;	// Resume ISR
 10626               		.loc 1 2376 0
 10627 4424 BFBE      		out __SREG__,r11
 10628 4426 00C0      		rjmp .L911
 10629               	.LBE767:
 10630               	.LBE772:
 10631               	.LBE774:
 10632               	.LBE812:
 10633               	.LBE814:
 10634               	.LBE817:
 10635               		.cfi_endproc
 10636               	.LFE68:
 10639               	DoFormatCard:
 10640               	.LFB40:
2312:WTPA.c        **** {
 10641               		.loc 1 2312 0
 10642               		.cfi_startproc
 10643               	/* prologue: function */
 10644               	/* frame size = 0 */
 10645               	/* stack size = 0 */
 10646               	.L__stack_usage = 0
2313:WTPA.c        **** 	if(subState==SS_0)
 10647               		.loc 1 2313 0
 10648 4428 8091 0000 		lds r24,subState
 10649 442c 8823      		tst r24
 10650 442e 01F0      		breq .L1172
2325:WTPA.c        **** 	else if(subState==SS_1)
 10651               		.loc 1 2325 0
 10652 4430 8130      		cpi r24,lo8(1)
 10653 4432 01F0      		breq .L1173
2339:WTPA.c        **** 	else if(subState==SS_2)
 10654               		.loc 1 2339 0
 10655 4434 8230      		cpi r24,lo8(2)
 10656 4436 01F0      		breq .L1174
 10657               	.L1125:
 10658 4438 0895      		ret
 10659               	.L1174:
2341:WTPA.c        **** 		if(cardState==SD_IDLE)	// Got what we wanted?
 10660               		.loc 1 2341 0
 10661 443a 8091 0000 		lds r24,cardState
 10662 443e 8E30      		cpi r24,lo8(14)
 10663 4440 01F4      		brne .L1125
 10664               	.LBB840:
 10665               	.LBB841:
 10666               	.LBB842:
 10667               	.LBB843:
1585:WTPA.c        **** 	ledOnOffMask=0;
 10668               		.loc 1 1585 0
 10669 4442 1092 0000 		sts ledOnOffMask,__zero_reg__
 10670               	.LVL554:
 10671               	.LBB844:
 10672               	.LBB845:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10673               		.loc 1 1572 0
 10674 4446 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10675               		.loc 1 1573 0
 10676 444a 68E9      		ldi r22,lo8(-104)
 10677 444c 70E0      		ldi r23,0
 10678 444e 82E0      		ldi r24,lo8(2)
 10679 4450 0E94 0000 		call SetTimer
 10680               	.LVL555:
 10681               	.LBE845:
 10682               	.LBE844:
 10683               	.LBE843:
 10684               	.LBE842:
2344:WTPA.c        **** 			ledOnOffMask|=(1<<LED_1);
 10685               		.loc 1 2344 0
 10686 4454 8091 0000 		lds r24,ledOnOffMask
 10687 4458 8260      		ori r24,lo8(2)
 10688 445a 8093 0000 		sts ledOnOffMask,r24
2345:WTPA.c        **** 			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
 10689               		.loc 1 2345 0
 10690 445e 8091 0000 		lds r24,cardState
 10691 4462 8823      		tst r24
 10692 4464 01F0      		breq .L1138
 10693 4466 8091 0000 		lds r24,newKeys
 10694 446a 8823      		tst r24
 10695 446c 01F0      		breq .L1125
 10696               	.L1138:
 10697               	.LVL556:
 10698               	.LBB846:
 10699               	.LBB847:
1504:WTPA.c        **** 	State=newState;
 10700               		.loc 1 1504 0
 10701 446e 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 10702 4470 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 10703 4472 9093 0000 		sts State+1,r25
 10704 4476 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 10705               		.loc 1 1505 0
 10706 447a 1092 0000 		sts subState,__zero_reg__
 10707               	.LVL557:
 10708               	.L1176:
 10709 447e 0895      		ret
 10710               	.LVL558:
 10711               	.L1173:
 10712               	.LBE847:
 10713               	.LBE846:
 10714               	.LBE841:
 10715               	.LBE840:
2327:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 10716               		.loc 1 2327 0
 10717 4480 8091 0000 		lds r24,keyState
 10718 4484 80FF      		sbrs r24,0
 10719 4486 00C0      		rjmp .L1137
2327:WTPA.c        **** 		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
 10720               		.loc 1 2327 0 is_stmt 0 discriminator 1
 10721 4488 87FD      		sbrc r24,7
 10722 448a 00C0      		rjmp .L1175
 10723               	.L1137:
2334:WTPA.c        **** 		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
 10724               		.loc 1 2334 0 is_stmt 1
 10725 448c 8091 0000 		lds r24,cardState
 10726 4490 8111      		cpse r24,__zero_reg__
 10727 4492 00C0      		rjmp .L1125
 10728               	.LVL559:
 10729               	.LBB851:
 10730               	.LBB850:
 10731               	.LBB849:
 10732               	.LBB848:
1504:WTPA.c        **** 	State=newState;
 10733               		.loc 1 1504 0
 10734 4494 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 10735 4496 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 10736 4498 9093 0000 		sts State+1,r25
 10737 449c 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 10738               		.loc 1 1505 0
 10739 44a0 1092 0000 		sts subState,__zero_reg__
 10740 44a4 00C0      		rjmp .L1176
 10741               	.LVL560:
 10742               	.L1172:
 10743               	.LBE848:
 10744               	.LBE849:
 10745               	.LBE850:
 10746               	.LBE851:
 10747               	.LBB852:
 10748               	.LBB853:
1585:WTPA.c        **** 	ledOnOffMask=0;
 10749               		.loc 1 1585 0
 10750 44a6 1092 0000 		sts ledOnOffMask,__zero_reg__
 10751               	.LVL561:
 10752               	.LBB854:
 10753               	.LBB855:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10754               		.loc 1 1572 0
 10755 44aa 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10756               		.loc 1 1573 0
 10757 44ae 68E9      		ldi r22,lo8(-104)
 10758 44b0 70E0      		ldi r23,0
 10759 44b2 82E0      		ldi r24,lo8(2)
 10760 44b4 0E94 0000 		call SetTimer
 10761               	.LVL562:
 10762               	.LBE855:
 10763               	.LBE854:
 10764               	.LBE853:
 10765               	.LBE852:
2317:WTPA.c        **** 		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
 10766               		.loc 1 2317 0
 10767 44b8 1092 0000 		sts bankStates,__zero_reg__
2318:WTPA.c        **** 		bankStates[BANK_0].clockMode=CLK_NONE;
 10768               		.loc 1 2318 0
 10769 44bc 1092 0000 		sts bankStates+10,__zero_reg__
2319:WTPA.c        **** 		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
 10770               		.loc 1 2319 0
 10771 44c0 1092 0000 		sts bankStates+36,__zero_reg__
2320:WTPA.c        **** 		bankStates[BANK_1].clockMode=CLK_NONE;
 10772               		.loc 1 2320 0
 10773 44c4 1092 0000 		sts bankStates+46,__zero_reg__
 10774               	.LVL563:
 10775 44c8 3091 0000 		lds r19,ledBlinkMask
 10776 44cc 832F      		mov r24,r19
 10777 44ce 90E0      		ldi r25,0
 10778 44d0 2091 0000 		lds r18,ledOnOffMask
 10779               	.LBB856:
 10780               	.LBB857:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10781               		.loc 1 1566 0
 10782 44d4 30FD      		sbrc r19,0
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10783               		.loc 1 1568 0
 10784 44d6 2E7F      		andi r18,lo8(-2)
 10785               	.L1127:
 10786               	.LVL564:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10787               		.loc 1 1566 0
 10788 44d8 81FD      		sbrc r24,1
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10789               		.loc 1 1568 0
 10790 44da 2D7F      		andi r18,lo8(-3)
 10791               	.L1128:
 10792               	.LVL565:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10793               		.loc 1 1566 0
 10794 44dc 82FD      		sbrc r24,2
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10795               		.loc 1 1568 0
 10796 44de 2B7F      		andi r18,lo8(-5)
 10797               	.L1129:
 10798               	.LVL566:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10799               		.loc 1 1566 0
 10800 44e0 83FD      		sbrc r24,3
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10801               		.loc 1 1568 0
 10802 44e2 277F      		andi r18,lo8(-9)
 10803               	.L1130:
 10804               	.LVL567:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10805               		.loc 1 1566 0
 10806 44e4 84FD      		sbrc r24,4
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10807               		.loc 1 1568 0
 10808 44e6 2F7E      		andi r18,lo8(-17)
 10809               	.L1131:
 10810               	.LVL568:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10811               		.loc 1 1566 0
 10812 44e8 85FD      		sbrc r24,5
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10813               		.loc 1 1568 0
 10814 44ea 2F7D      		andi r18,lo8(-33)
 10815               	.L1132:
 10816               	.LVL569:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10817               		.loc 1 1566 0
 10818 44ec 86FD      		sbrc r24,6
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10819               		.loc 1 1568 0
 10820 44ee 2F7B      		andi r18,lo8(-65)
 10821               	.L1133:
 10822               	.LVL570:
1566:WTPA.c        **** 		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
 10823               		.loc 1 1566 0
 10824 44f0 880F      		lsl r24
 10825 44f2 892F      		mov r24,r25
 10826 44f4 881F      		rol r24
 10827 44f6 990B      		sbc r25,r25
 10828 44f8 892B      		or r24,r25
 10829 44fa 01F0      		breq .L1134
1568:WTPA.c        **** 			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their b
 10830               		.loc 1 1568 0
 10831 44fc 2F77      		andi r18,lo8(127)
 10832               	.L1134:
 10833               	.LVL571:
 10834 44fe 2093 0000 		sts ledOnOffMask,r18
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10835               		.loc 1 1572 0
 10836 4502 81E8      		ldi r24,lo8(-127)
 10837 4504 8093 0000 		sts ledBlinkMask,r24
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10838               		.loc 1 1573 0
 10839 4508 68E9      		ldi r22,lo8(-104)
 10840 450a 70E0      		ldi r23,0
 10841 450c 82E0      		ldi r24,lo8(2)
 10842 450e 0E94 0000 		call SetTimer
 10843               	.LVL572:
 10844               	.LBE857:
 10845               	.LBE856:
2323:WTPA.c        **** 		subState=SS_1;
 10846               		.loc 1 2323 0
 10847 4512 81E0      		ldi r24,lo8(1)
 10848 4514 8093 0000 		sts subState,r24
 10849 4518 0895      		ret
 10850               	.LVL573:
 10851               	.L1175:
2329:WTPA.c        **** 			cardState=SD_TOC_WRITE_START;	// Start TOC write
 10852               		.loc 1 2329 0
 10853 451a 86E0      		ldi r24,lo8(6)
 10854 451c 8093 0000 		sts cardState,r24
 10855               	.LBB858:
 10856               	.LBB859:
1585:WTPA.c        **** 	ledOnOffMask=0;
 10857               		.loc 1 1585 0
 10858 4520 1092 0000 		sts ledOnOffMask,__zero_reg__
 10859               	.LVL574:
 10860               	.LBB860:
 10861               	.LBB861:
1572:WTPA.c        **** 	ledBlinkMask=theMask;				// Now assign new leds to blink.
 10862               		.loc 1 1572 0
 10863 4524 1092 0000 		sts ledBlinkMask,__zero_reg__
1573:WTPA.c        **** 	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
 10864               		.loc 1 1573 0
 10865 4528 68E9      		ldi r22,lo8(-104)
 10866 452a 70E0      		ldi r23,0
 10867 452c 82E0      		ldi r24,lo8(2)
 10868 452e 0E94 0000 		call SetTimer
 10869               	.LVL575:
 10870               	.LBE861:
 10871               	.LBE860:
 10872               	.LBE859:
 10873               	.LBE858:
2331:WTPA.c        **** 			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
 10874               		.loc 1 2331 0
 10875 4532 8091 0000 		lds r24,ledOnOffMask
 10876 4536 8168      		ori r24,lo8(-127)
 10877 4538 8093 0000 		sts ledOnOffMask,r24
2332:WTPA.c        **** 			subState=SS_2;
 10878               		.loc 1 2332 0
 10879 453c 82E0      		ldi r24,lo8(2)
 10880 453e 8093 0000 		sts subState,r24
 10881 4542 0895      		ret
 10882               		.cfi_endproc
 10883               	.LFE40:
 10885               	.global	__vector_12
 10887               	__vector_12:
 10888               	.LFB7:
1159:WTPA.c        **** {
 10889               		.loc 1 1159 0
 10890               		.cfi_startproc
 10891 4544 1F92      		push r1
 10892               	.LCFI62:
 10893               		.cfi_def_cfa_offset 3
 10894               		.cfi_offset 1, -2
 10895 4546 0F92      		push r0
 10896               	.LCFI63:
 10897               		.cfi_def_cfa_offset 4
 10898               		.cfi_offset 0, -3
 10899 4548 0FB6      		in r0,__SREG__
 10900 454a 0F92      		push r0
 10901 454c 1124      		clr __zero_reg__
 10902 454e 2F93      		push r18
 10903               	.LCFI64:
 10904               		.cfi_def_cfa_offset 5
 10905               		.cfi_offset 18, -4
 10906 4550 3F93      		push r19
 10907               	.LCFI65:
 10908               		.cfi_def_cfa_offset 6
 10909               		.cfi_offset 19, -5
 10910 4552 4F93      		push r20
 10911               	.LCFI66:
 10912               		.cfi_def_cfa_offset 7
 10913               		.cfi_offset 20, -6
 10914 4554 5F93      		push r21
 10915               	.LCFI67:
 10916               		.cfi_def_cfa_offset 8
 10917               		.cfi_offset 21, -7
 10918 4556 6F93      		push r22
 10919               	.LCFI68:
 10920               		.cfi_def_cfa_offset 9
 10921               		.cfi_offset 22, -8
 10922 4558 7F93      		push r23
 10923               	.LCFI69:
 10924               		.cfi_def_cfa_offset 10
 10925               		.cfi_offset 23, -9
 10926 455a 8F93      		push r24
 10927               	.LCFI70:
 10928               		.cfi_def_cfa_offset 11
 10929               		.cfi_offset 24, -10
 10930 455c 9F93      		push r25
 10931               	.LCFI71:
 10932               		.cfi_def_cfa_offset 12
 10933               		.cfi_offset 25, -11
 10934 455e AF93      		push r26
 10935               	.LCFI72:
 10936               		.cfi_def_cfa_offset 13
 10937               		.cfi_offset 26, -12
 10938 4560 BF93      		push r27
 10939               	.LCFI73:
 10940               		.cfi_def_cfa_offset 14
 10941               		.cfi_offset 27, -13
 10942 4562 EF93      		push r30
 10943               	.LCFI74:
 10944               		.cfi_def_cfa_offset 15
 10945               		.cfi_offset 30, -14
 10946 4564 FF93      		push r31
 10947               	.LCFI75:
 10948               		.cfi_def_cfa_offset 16
 10949               		.cfi_offset 31, -15
 10950               	/* prologue: Signal */
 10951               	/* frame size = 0 */
 10952               	/* stack size = 15 */
 10953               	.L__stack_usage = 15
1163:WTPA.c        **** 	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
 10954               		.loc 1 1163 0
 10955 4566 469A      		sbi 0x8,6
1164:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 10956               		.loc 1 1164 0
 10957 4568 8091 0000 		lds r24,bankStates+2
 10958 456c 8823      		tst r24
 10959 456e 01F0      		breq .L1178
1164:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 10960               		.loc 1 1164 0 is_stmt 0 discriminator 1
 10961 4570 8091 0000 		lds r24,bankStates+2
 10962 4574 8111      		cpse r24,__zero_reg__
 10963 4576 00C0      		rjmp .L1190
 10964               	.L1179:
1169:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 10965               		.loc 1 1169 0 is_stmt 1
 10966 4578 1092 0000 		sts flipFlop.1813,__zero_reg__
1170:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 10967               		.loc 1 1170 0
 10968 457c E091 0000 		lds r30,UpdateOutput
 10969 4580 F091 0000 		lds r31,UpdateOutput+1
 10970 4584 0995      		icall
 10971               	.LVL576:
1171:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 10972               		.loc 1 1171 0
 10973 4586 8091 7A00 		lds r24,122
 10974 458a 86FD      		sbrc r24,6
 10975 458c 00C0      		rjmp .L1180
1173:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 10976               		.loc 1 1173 0
 10977 458e 8091 7900 		lds r24,121
 10978 4592 8058      		subi r24,lo8(-(-128))
 10979 4594 8093 0000 		sts adcByte,r24
1174:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 10980               		.loc 1 1174 0
 10981 4598 8091 7A00 		lds r24,122
 10982 459c 8064      		ori r24,lo8(64)
 10983 459e 8093 7A00 		sts 122,r24
 10984               	.L1180:
1176:WTPA.c        **** 	PORTC&=~Om_TEST_PIN_0;		// @@@ Used to time ISRs
 10985               		.loc 1 1176 0
 10986 45a2 4698      		cbi 0x8,6
 10987               	/* epilogue start */
1177:WTPA.c        **** }
 10988               		.loc 1 1177 0
 10989 45a4 FF91      		pop r31
 10990 45a6 EF91      		pop r30
 10991 45a8 BF91      		pop r27
 10992 45aa AF91      		pop r26
 10993 45ac 9F91      		pop r25
 10994 45ae 8F91      		pop r24
 10995 45b0 7F91      		pop r23
 10996 45b2 6F91      		pop r22
 10997 45b4 5F91      		pop r21
 10998 45b6 4F91      		pop r20
 10999 45b8 3F91      		pop r19
 11000 45ba 2F91      		pop r18
 11001 45bc 0F90      		pop r0
 11002 45be 0FBE      		out __SREG__,r0
 11003 45c0 0F90      		pop r0
 11004 45c2 1F90      		pop r1
 11005 45c4 1895      		reti
 11006               	.L1190:
1164:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 11007               		.loc 1 1164 0 discriminator 1
 11008 45c6 8091 0000 		lds r24,flipFlop.1813
 11009 45ca 8823      		tst r24
 11010 45cc 01F0      		breq .L1179
 11011               	.L1178:
1166:WTPA.c        **** 		UpdateAudioChannel0();							// If so, then call the audioIsr for bank 0 and do whatever it's cur
 11012               		.loc 1 1166 0
 11013 45ce 0E94 0000 		call UpdateAudioChannel0
 11014               	.LVL577:
1167:WTPA.c        **** 		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do what
 11015               		.loc 1 1167 0
 11016 45d2 0E94 0000 		call UpdateAudioChannel0
 11017               	.LVL578:
 11018 45d6 8093 0000 		sts extIsrOutputBank0,r24
 11019 45da 00C0      		rjmp .L1179
 11020               		.cfi_endproc
 11021               	.LFE7:
 11023               	.global	__vector_6
 11025               	__vector_6:
 11026               	.LFB8:
1182:WTPA.c        **** {
 11027               		.loc 1 1182 0
 11028               		.cfi_startproc
 11029 45dc 1F92      		push r1
 11030               	.LCFI76:
 11031               		.cfi_def_cfa_offset 3
 11032               		.cfi_offset 1, -2
 11033 45de 0F92      		push r0
 11034               	.LCFI77:
 11035               		.cfi_def_cfa_offset 4
 11036               		.cfi_offset 0, -3
 11037 45e0 0FB6      		in r0,__SREG__
 11038 45e2 0F92      		push r0
 11039 45e4 1124      		clr __zero_reg__
 11040 45e6 2F93      		push r18
 11041               	.LCFI78:
 11042               		.cfi_def_cfa_offset 5
 11043               		.cfi_offset 18, -4
 11044 45e8 3F93      		push r19
 11045               	.LCFI79:
 11046               		.cfi_def_cfa_offset 6
 11047               		.cfi_offset 19, -5
 11048 45ea 4F93      		push r20
 11049               	.LCFI80:
 11050               		.cfi_def_cfa_offset 7
 11051               		.cfi_offset 20, -6
 11052 45ec 5F93      		push r21
 11053               	.LCFI81:
 11054               		.cfi_def_cfa_offset 8
 11055               		.cfi_offset 21, -7
 11056 45ee 6F93      		push r22
 11057               	.LCFI82:
 11058               		.cfi_def_cfa_offset 9
 11059               		.cfi_offset 22, -8
 11060 45f0 7F93      		push r23
 11061               	.LCFI83:
 11062               		.cfi_def_cfa_offset 10
 11063               		.cfi_offset 23, -9
 11064 45f2 8F93      		push r24
 11065               	.LCFI84:
 11066               		.cfi_def_cfa_offset 11
 11067               		.cfi_offset 24, -10
 11068 45f4 9F93      		push r25
 11069               	.LCFI85:
 11070               		.cfi_def_cfa_offset 12
 11071               		.cfi_offset 25, -11
 11072 45f6 AF93      		push r26
 11073               	.LCFI86:
 11074               		.cfi_def_cfa_offset 13
 11075               		.cfi_offset 26, -12
 11076 45f8 BF93      		push r27
 11077               	.LCFI87:
 11078               		.cfi_def_cfa_offset 14
 11079               		.cfi_offset 27, -13
 11080 45fa EF93      		push r30
 11081               	.LCFI88:
 11082               		.cfi_def_cfa_offset 15
 11083               		.cfi_offset 30, -14
 11084 45fc FF93      		push r31
 11085               	.LCFI89:
 11086               		.cfi_def_cfa_offset 16
 11087               		.cfi_offset 31, -15
 11088               	/* prologue: Signal */
 11089               	/* frame size = 0 */
 11090               	/* stack size = 15 */
 11091               	.L__stack_usage = 15
1186:WTPA.c        **** 	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
 11092               		.loc 1 1186 0
 11093 45fe 479A      		sbi 0x8,7
1187:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11094               		.loc 1 1187 0
 11095 4600 8091 0000 		lds r24,bankStates+38
 11096 4604 8823      		tst r24
 11097 4606 01F0      		breq .L1192
1187:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11098               		.loc 1 1187 0 is_stmt 0 discriminator 1
 11099 4608 8091 0000 		lds r24,bankStates+38
 11100 460c 8111      		cpse r24,__zero_reg__
 11101 460e 00C0      		rjmp .L1204
 11102               	.L1193:
1191:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 11103               		.loc 1 1191 0 is_stmt 1
 11104 4610 1092 0000 		sts flipFlop.1819,__zero_reg__
1192:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 11105               		.loc 1 1192 0
 11106 4614 E091 0000 		lds r30,UpdateOutput
 11107 4618 F091 0000 		lds r31,UpdateOutput+1
 11108 461c 0995      		icall
 11109               	.LVL579:
1193:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 11110               		.loc 1 1193 0
 11111 461e 8091 7A00 		lds r24,122
 11112 4622 86FD      		sbrc r24,6
 11113 4624 00C0      		rjmp .L1194
1195:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 11114               		.loc 1 1195 0
 11115 4626 8091 7900 		lds r24,121
 11116 462a 8058      		subi r24,lo8(-(-128))
 11117 462c 8093 0000 		sts adcByte,r24
1196:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 11118               		.loc 1 1196 0
 11119 4630 8091 7A00 		lds r24,122
 11120 4634 8064      		ori r24,lo8(64)
 11121 4636 8093 7A00 		sts 122,r24
 11122               	.L1194:
1198:WTPA.c        **** 	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
 11123               		.loc 1 1198 0
 11124 463a DA9A      		sbi 0x1b,2
 11125               	/* epilogue start */
1207:WTPA.c        **** }
 11126               		.loc 1 1207 0
 11127 463c FF91      		pop r31
 11128 463e EF91      		pop r30
 11129 4640 BF91      		pop r27
 11130 4642 AF91      		pop r26
 11131 4644 9F91      		pop r25
 11132 4646 8F91      		pop r24
 11133 4648 7F91      		pop r23
 11134 464a 6F91      		pop r22
 11135 464c 5F91      		pop r21
 11136 464e 4F91      		pop r20
 11137 4650 3F91      		pop r19
 11138 4652 2F91      		pop r18
 11139 4654 0F90      		pop r0
 11140 4656 0FBE      		out __SREG__,r0
 11141 4658 0F90      		pop r0
 11142 465a 1F90      		pop r1
 11143 465c 1895      		reti
 11144               	.L1204:
1187:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11145               		.loc 1 1187 0 discriminator 1
 11146 465e 8091 0000 		lds r24,flipFlop.1819
 11147 4662 8823      		tst r24
 11148 4664 01F0      		breq .L1193
 11149               	.L1192:
1189:WTPA.c        **** 		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do what
 11150               		.loc 1 1189 0
 11151 4666 0E94 0000 		call UpdateAudioChannel1
 11152               	.LVL580:
 11153 466a 8093 0000 		sts extIsrOutputBank1,r24
 11154 466e 00C0      		rjmp .L1193
 11155               		.cfi_endproc
 11156               	.LFE8:
 11158               	.global	__vector_13
 11160               	__vector_13:
 11161               	.LFB9:
1211:WTPA.c        **** {
 11162               		.loc 1 1211 0
 11163               		.cfi_startproc
 11164 4670 1F92      		push r1
 11165               	.LCFI90:
 11166               		.cfi_def_cfa_offset 3
 11167               		.cfi_offset 1, -2
 11168 4672 0F92      		push r0
 11169               	.LCFI91:
 11170               		.cfi_def_cfa_offset 4
 11171               		.cfi_offset 0, -3
 11172 4674 0FB6      		in r0,__SREG__
 11173 4676 0F92      		push r0
 11174 4678 1124      		clr __zero_reg__
 11175 467a 0F93      		push r16
 11176               	.LCFI92:
 11177               		.cfi_def_cfa_offset 5
 11178               		.cfi_offset 16, -4
 11179 467c 1F93      		push r17
 11180               	.LCFI93:
 11181               		.cfi_def_cfa_offset 6
 11182               		.cfi_offset 17, -5
 11183 467e 2F93      		push r18
 11184               	.LCFI94:
 11185               		.cfi_def_cfa_offset 7
 11186               		.cfi_offset 18, -6
 11187 4680 3F93      		push r19
 11188               	.LCFI95:
 11189               		.cfi_def_cfa_offset 8
 11190               		.cfi_offset 19, -7
 11191 4682 4F93      		push r20
 11192               	.LCFI96:
 11193               		.cfi_def_cfa_offset 9
 11194               		.cfi_offset 20, -8
 11195 4684 5F93      		push r21
 11196               	.LCFI97:
 11197               		.cfi_def_cfa_offset 10
 11198               		.cfi_offset 21, -9
 11199 4686 6F93      		push r22
 11200               	.LCFI98:
 11201               		.cfi_def_cfa_offset 11
 11202               		.cfi_offset 22, -10
 11203 4688 7F93      		push r23
 11204               	.LCFI99:
 11205               		.cfi_def_cfa_offset 12
 11206               		.cfi_offset 23, -11
 11207 468a 8F93      		push r24
 11208               	.LCFI100:
 11209               		.cfi_def_cfa_offset 13
 11210               		.cfi_offset 24, -12
 11211 468c 9F93      		push r25
 11212               	.LCFI101:
 11213               		.cfi_def_cfa_offset 14
 11214               		.cfi_offset 25, -13
 11215 468e AF93      		push r26
 11216               	.LCFI102:
 11217               		.cfi_def_cfa_offset 15
 11218               		.cfi_offset 26, -14
 11219 4690 BF93      		push r27
 11220               	.LCFI103:
 11221               		.cfi_def_cfa_offset 16
 11222               		.cfi_offset 27, -15
 11223 4692 CF93      		push r28
 11224               	.LCFI104:
 11225               		.cfi_def_cfa_offset 17
 11226               		.cfi_offset 28, -16
 11227 4694 DF93      		push r29
 11228               	.LCFI105:
 11229               		.cfi_def_cfa_offset 18
 11230               		.cfi_offset 29, -17
 11231 4696 EF93      		push r30
 11232               	.LCFI106:
 11233               		.cfi_def_cfa_offset 19
 11234               		.cfi_offset 30, -18
 11235 4698 FF93      		push r31
 11236               	.LCFI107:
 11237               		.cfi_def_cfa_offset 20
 11238               		.cfi_offset 31, -19
 11239               	/* prologue: Signal */
 11240               	/* frame size = 0 */
 11241               	/* stack size = 19 */
 11242               	.L__stack_usage = 19
1219:WTPA.c        **** 	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
 11243               		.loc 1 1219 0
 11244 469a 469A      		sbi 0x8,6
1221:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 11245               		.loc 1 1221 0
 11246 469c 8091 0000 		lds r24,bankStates+2
 11247 46a0 8823      		tst r24
 11248 46a2 01F4      		brne .+2
 11249 46a4 00C0      		rjmp .L1206
1221:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 11250               		.loc 1 1221 0 is_stmt 0 discriminator 1
 11251 46a6 8091 0000 		lds r24,bankStates+2
 11252 46aa 8111      		cpse r24,__zero_reg__
 11253 46ac 00C0      		rjmp .L1220
 11254               	.L1207:
1225:WTPA.c        **** 	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this 
 11255               		.loc 1 1225 0 is_stmt 1
 11256 46ae 8091 0000 		lds r24,bankStates+8
 11257 46b2 8823      		tst r24
 11258 46b4 01F4      		brne .+2
 11259 46b6 00C0      		rjmp .L1208
1227:WTPA.c        **** 		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNot
 11260               		.loc 1 1227 0
 11261 46b8 A091 0000 		lds r26,bankStates+8
 11262 46bc 2091 0000 		lds r18,bankStates+11
 11263 46c0 3091 0000 		lds r19,bankStates+11+1
 11264               	.LVL581:
 11265 46c4 B0E0      		ldi r27,0
 11266 46c6 0E94 0000 		call __umulhisi3
1228:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 11267               		.loc 1 1228 0
 11268 46ca 2FE7      		ldi r18,lo8(127)
 11269 46cc 30E0      		ldi r19,0
 11270 46ce 40E0      		ldi r20,0
 11271 46d0 50E0      		ldi r21,0
 11272               	.LVL582:
 11273 46d2 0E94 0000 		call __udivmodsi4
 11274               	.LVL583:
1229:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 11275               		.loc 1 1229 0
 11276 46d6 0091 8800 		lds r16,136
 11277 46da 1091 8900 		lds r17,136+1
 11278 46de C091 0000 		lds r28,bankStates+11
 11279 46e2 D091 0000 		lds r29,bankStates+11+1
1228:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 11280               		.loc 1 1228 0
 11281 46e6 6091 0000 		lds r22,random31
 11282 46ea 7091 0000 		lds r23,random31+1
 11283 46ee 8091 0000 		lds r24,random31+2
 11284 46f2 9091 0000 		lds r25,random31+3
 11285 46f6 0E94 0000 		call __udivmodsi4
 11286               	.LVL584:
1229:WTPA.c        **** 		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 11287               		.loc 1 1229 0
 11288 46fa C00F      		add r28,r16
 11289 46fc D11F      		adc r29,r17
 11290 46fe 4091 0000 		lds r20,lastJitterValue.1826
 11291 4702 5091 0000 		lds r21,lastJitterValue.1826+1
 11292 4706 C40F      		add r28,r20
 11293 4708 D51F      		adc r29,r21
 11294 470a C61B      		sub r28,r22
 11295 470c D70B      		sbc r29,r23
 11296 470e D093 8900 		sts 136+1,r29
 11297 4712 C093 8800 		sts 136,r28
1230:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 11298               		.loc 1 1230 0
 11299 4716 7093 0000 		sts lastJitterValue.1826+1,r23
 11300 471a 6093 0000 		sts lastJitterValue.1826,r22
 11301               	.LVL585:
 11302               	.L1209:
1236:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 11303               		.loc 1 1236 0
 11304 471e 1092 0000 		sts flipFlop.1827,__zero_reg__
1237:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 11305               		.loc 1 1237 0
 11306 4722 E091 0000 		lds r30,UpdateOutput
 11307 4726 F091 0000 		lds r31,UpdateOutput+1
 11308 472a 0995      		icall
 11309               	.LVL586:
1238:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 11310               		.loc 1 1238 0
 11311 472c 8091 7A00 		lds r24,122
 11312 4730 86FD      		sbrc r24,6
 11313 4732 00C0      		rjmp .L1205
1240:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 11314               		.loc 1 1240 0
 11315 4734 8091 7900 		lds r24,121
 11316 4738 8058      		subi r24,lo8(-(-128))
 11317 473a 8093 0000 		sts adcByte,r24
1241:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 11318               		.loc 1 1241 0
 11319 473e 8091 7A00 		lds r24,122
 11320 4742 8064      		ori r24,lo8(64)
 11321 4744 8093 7A00 		sts 122,r24
 11322               	.L1205:
 11323               	/* epilogue start */
1243:WTPA.c        **** }
 11324               		.loc 1 1243 0
 11325 4748 FF91      		pop r31
 11326 474a EF91      		pop r30
 11327 474c DF91      		pop r29
 11328 474e CF91      		pop r28
 11329 4750 BF91      		pop r27
 11330 4752 AF91      		pop r26
 11331 4754 9F91      		pop r25
 11332 4756 8F91      		pop r24
 11333 4758 7F91      		pop r23
 11334 475a 6F91      		pop r22
 11335 475c 5F91      		pop r21
 11336 475e 4F91      		pop r20
 11337 4760 3F91      		pop r19
 11338 4762 2F91      		pop r18
 11339 4764 1F91      		pop r17
 11340 4766 0F91      		pop r16
 11341 4768 0F90      		pop r0
 11342 476a 0FBE      		out __SREG__,r0
 11343 476c 0F90      		pop r0
 11344 476e 1F90      		pop r1
 11345 4770 1895      		reti
 11346               	.L1208:
1234:WTPA.c        **** 		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 11347               		.loc 1 1234 0
 11348 4772 2091 8800 		lds r18,136
 11349 4776 3091 8900 		lds r19,136+1
 11350 477a 8091 0000 		lds r24,bankStates+11
 11351 477e 9091 0000 		lds r25,bankStates+11+1
 11352 4782 820F      		add r24,r18
 11353 4784 931F      		adc r25,r19
 11354 4786 9093 8900 		sts 136+1,r25
 11355 478a 8093 8800 		sts 136,r24
 11356 478e 00C0      		rjmp .L1209
 11357               	.L1220:
1221:WTPA.c        **** 	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the
 11358               		.loc 1 1221 0 discriminator 1
 11359 4790 8091 0000 		lds r24,flipFlop.1827
 11360 4794 8823      		tst r24
 11361 4796 01F4      		brne .+2
 11362 4798 00C0      		rjmp .L1207
 11363               	.L1206:
1223:WTPA.c        **** 		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whate
 11364               		.loc 1 1223 0
 11365 479a 0E94 0000 		call UpdateAudioChannel0
 11366               	.LVL587:
 11367 479e 8093 0000 		sts midiOutputBank0,r24
 11368 47a2 00C0      		rjmp .L1207
 11369               		.cfi_endproc
 11370               	.LFE9:
 11372               	.global	__vector_14
 11374               	__vector_14:
 11375               	.LFB10:
1247:WTPA.c        **** {
 11376               		.loc 1 1247 0
 11377               		.cfi_startproc
 11378 47a4 1F92      		push r1
 11379               	.LCFI108:
 11380               		.cfi_def_cfa_offset 3
 11381               		.cfi_offset 1, -2
 11382 47a6 0F92      		push r0
 11383               	.LCFI109:
 11384               		.cfi_def_cfa_offset 4
 11385               		.cfi_offset 0, -3
 11386 47a8 0FB6      		in r0,__SREG__
 11387 47aa 0F92      		push r0
 11388 47ac 1124      		clr __zero_reg__
 11389 47ae 0F93      		push r16
 11390               	.LCFI110:
 11391               		.cfi_def_cfa_offset 5
 11392               		.cfi_offset 16, -4
 11393 47b0 1F93      		push r17
 11394               	.LCFI111:
 11395               		.cfi_def_cfa_offset 6
 11396               		.cfi_offset 17, -5
 11397 47b2 2F93      		push r18
 11398               	.LCFI112:
 11399               		.cfi_def_cfa_offset 7
 11400               		.cfi_offset 18, -6
 11401 47b4 3F93      		push r19
 11402               	.LCFI113:
 11403               		.cfi_def_cfa_offset 8
 11404               		.cfi_offset 19, -7
 11405 47b6 4F93      		push r20
 11406               	.LCFI114:
 11407               		.cfi_def_cfa_offset 9
 11408               		.cfi_offset 20, -8
 11409 47b8 5F93      		push r21
 11410               	.LCFI115:
 11411               		.cfi_def_cfa_offset 10
 11412               		.cfi_offset 21, -9
 11413 47ba 6F93      		push r22
 11414               	.LCFI116:
 11415               		.cfi_def_cfa_offset 11
 11416               		.cfi_offset 22, -10
 11417 47bc 7F93      		push r23
 11418               	.LCFI117:
 11419               		.cfi_def_cfa_offset 12
 11420               		.cfi_offset 23, -11
 11421 47be 8F93      		push r24
 11422               	.LCFI118:
 11423               		.cfi_def_cfa_offset 13
 11424               		.cfi_offset 24, -12
 11425 47c0 9F93      		push r25
 11426               	.LCFI119:
 11427               		.cfi_def_cfa_offset 14
 11428               		.cfi_offset 25, -13
 11429 47c2 AF93      		push r26
 11430               	.LCFI120:
 11431               		.cfi_def_cfa_offset 15
 11432               		.cfi_offset 26, -14
 11433 47c4 BF93      		push r27
 11434               	.LCFI121:
 11435               		.cfi_def_cfa_offset 16
 11436               		.cfi_offset 27, -15
 11437 47c6 CF93      		push r28
 11438               	.LCFI122:
 11439               		.cfi_def_cfa_offset 17
 11440               		.cfi_offset 28, -16
 11441 47c8 DF93      		push r29
 11442               	.LCFI123:
 11443               		.cfi_def_cfa_offset 18
 11444               		.cfi_offset 29, -17
 11445 47ca EF93      		push r30
 11446               	.LCFI124:
 11447               		.cfi_def_cfa_offset 19
 11448               		.cfi_offset 30, -18
 11449 47cc FF93      		push r31
 11450               	.LCFI125:
 11451               		.cfi_def_cfa_offset 20
 11452               		.cfi_offset 31, -19
 11453               	/* prologue: Signal */
 11454               	/* frame size = 0 */
 11455               	/* stack size = 19 */
 11456               	.L__stack_usage = 19
1257:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11457               		.loc 1 1257 0
 11458 47ce 8091 0000 		lds r24,bankStates+38
 11459 47d2 8823      		tst r24
 11460 47d4 01F4      		brne .+2
 11461 47d6 00C0      		rjmp .L1222
1257:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11462               		.loc 1 1257 0 is_stmt 0 discriminator 1
 11463 47d8 8091 0000 		lds r24,bankStates+38
 11464 47dc 8111      		cpse r24,__zero_reg__
 11465 47de 00C0      		rjmp .L1236
 11466               	.L1223:
1261:WTPA.c        **** 	if(bankStates[BANK_1].jitterValue)				// Jitter on?
 11467               		.loc 1 1261 0 is_stmt 1
 11468 47e0 8091 0000 		lds r24,bankStates+44
 11469 47e4 8823      		tst r24
 11470 47e6 01F4      		brne .+2
 11471 47e8 00C0      		rjmp .L1224
1263:WTPA.c        **** 		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNot
 11472               		.loc 1 1263 0
 11473 47ea A091 0000 		lds r26,bankStates+44
 11474 47ee 2091 0000 		lds r18,bankStates+47
 11475 47f2 3091 0000 		lds r19,bankStates+47+1
 11476               	.LVL588:
 11477 47f6 B0E0      		ldi r27,0
 11478 47f8 0E94 0000 		call __umulhisi3
1264:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 11479               		.loc 1 1264 0
 11480 47fc 2FE7      		ldi r18,lo8(127)
 11481 47fe 30E0      		ldi r19,0
 11482 4800 40E0      		ldi r20,0
 11483 4802 50E0      		ldi r21,0
 11484               	.LVL589:
 11485 4804 0E94 0000 		call __udivmodsi4
 11486               	.LVL590:
1265:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 11487               		.loc 1 1265 0
 11488 4808 0091 8A00 		lds r16,138
 11489 480c 1091 8B00 		lds r17,138+1
 11490 4810 C091 0000 		lds r28,bankStates+47
 11491 4814 D091 0000 		lds r29,bankStates+47+1
1264:WTPA.c        **** 		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and
 11492               		.loc 1 1264 0
 11493 4818 6091 0000 		lds r22,random31
 11494 481c 7091 0000 		lds r23,random31+1
 11495 4820 8091 0000 		lds r24,random31+2
 11496 4824 9091 0000 		lds r25,random31+3
 11497 4828 0E94 0000 		call __udivmodsi4
 11498               	.LVL591:
1265:WTPA.c        **** 		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR val
 11499               		.loc 1 1265 0
 11500 482c C00F      		add r28,r16
 11501 482e D11F      		adc r29,r17
 11502 4830 4091 0000 		lds r20,lastJitterValue.1834
 11503 4834 5091 0000 		lds r21,lastJitterValue.1834+1
 11504 4838 C40F      		add r28,r20
 11505 483a D51F      		adc r29,r21
 11506 483c C61B      		sub r28,r22
 11507 483e D70B      		sbc r29,r23
 11508 4840 D093 8B00 		sts 138+1,r29
 11509 4844 C093 8A00 		sts 138,r28
1266:WTPA.c        **** 		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next tim
 11510               		.loc 1 1266 0
 11511 4848 7093 0000 		sts lastJitterValue.1834+1,r23
 11512 484c 6093 0000 		sts lastJitterValue.1834,r22
 11513               	.LVL592:
 11514               	.L1225:
1272:WTPA.c        **** 	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
 11515               		.loc 1 1272 0
 11516 4850 1092 0000 		sts flipFlop.1835,__zero_reg__
1273:WTPA.c        **** 	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources a
 11517               		.loc 1 1273 0
 11518 4854 E091 0000 		lds r30,UpdateOutput
 11519 4858 F091 0000 		lds r31,UpdateOutput+1
 11520 485c 0995      		icall
 11521               	.LVL593:
1274:WTPA.c        **** 	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock s
 11522               		.loc 1 1274 0
 11523 485e 8091 7A00 		lds r24,122
 11524 4862 86FD      		sbrc r24,6
 11525 4864 00C0      		rjmp .L1221
1276:WTPA.c        **** 		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both
 11526               		.loc 1 1276 0
 11527 4866 8091 7900 		lds r24,121
 11528 486a 8058      		subi r24,lo8(-(-128))
 11529 486c 8093 0000 		sts adcByte,r24
1277:WTPA.c        **** 		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the s
 11530               		.loc 1 1277 0
 11531 4870 8091 7A00 		lds r24,122
 11532 4874 8064      		ori r24,lo8(64)
 11533 4876 8093 7A00 		sts 122,r24
 11534               	.L1221:
 11535               	/* epilogue start */
1279:WTPA.c        **** }
 11536               		.loc 1 1279 0
 11537 487a FF91      		pop r31
 11538 487c EF91      		pop r30
 11539 487e DF91      		pop r29
 11540 4880 CF91      		pop r28
 11541 4882 BF91      		pop r27
 11542 4884 AF91      		pop r26
 11543 4886 9F91      		pop r25
 11544 4888 8F91      		pop r24
 11545 488a 7F91      		pop r23
 11546 488c 6F91      		pop r22
 11547 488e 5F91      		pop r21
 11548 4890 4F91      		pop r20
 11549 4892 3F91      		pop r19
 11550 4894 2F91      		pop r18
 11551 4896 1F91      		pop r17
 11552 4898 0F91      		pop r16
 11553 489a 0F90      		pop r0
 11554 489c 0FBE      		out __SREG__,r0
 11555 489e 0F90      		pop r0
 11556 48a0 1F90      		pop r1
 11557 48a2 1895      		reti
 11558               	.L1224:
1270:WTPA.c        **** 		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for th
 11559               		.loc 1 1270 0
 11560 48a4 2091 8A00 		lds r18,138
 11561 48a8 3091 8B00 		lds r19,138+1
 11562 48ac 8091 0000 		lds r24,bankStates+47
 11563 48b0 9091 0000 		lds r25,bankStates+47+1
 11564 48b4 820F      		add r24,r18
 11565 48b6 931F      		adc r25,r19
 11566 48b8 9093 8B00 		sts 138+1,r25
 11567 48bc 8093 8A00 		sts 138,r24
 11568 48c0 00C0      		rjmp .L1225
 11569               	.L1236:
1257:WTPA.c        **** 	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the
 11570               		.loc 1 1257 0 discriminator 1
 11571 48c2 8091 0000 		lds r24,flipFlop.1835
 11572 48c6 8823      		tst r24
 11573 48c8 01F4      		brne .+2
 11574 48ca 00C0      		rjmp .L1223
 11575               	.L1222:
1259:WTPA.c        **** 		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatev
 11576               		.loc 1 1259 0
 11577 48cc 0E94 0000 		call UpdateAudioChannel1
 11578               	.LVL594:
 11579 48d0 8093 0000 		sts midiOutputBank1,r24
 11580 48d4 00C0      		rjmp .L1223
 11581               		.cfi_endproc
 11582               	.LFE10:
 11584               	.global	__vector_10
 11586               	__vector_10:
 11587               	.LFB11:
1285:WTPA.c        **** {
 11588               		.loc 1 1285 0
 11589               		.cfi_startproc
 11590 48d6 1F92      		push r1
 11591               	.LCFI126:
 11592               		.cfi_def_cfa_offset 3
 11593               		.cfi_offset 1, -2
 11594 48d8 0F92      		push r0
 11595               	.LCFI127:
 11596               		.cfi_def_cfa_offset 4
 11597               		.cfi_offset 0, -3
 11598 48da 0FB6      		in r0,__SREG__
 11599 48dc 0F92      		push r0
 11600 48de 1124      		clr __zero_reg__
 11601 48e0 2F93      		push r18
 11602               	.LCFI128:
 11603               		.cfi_def_cfa_offset 5
 11604               		.cfi_offset 18, -4
 11605 48e2 3F93      		push r19
 11606               	.LCFI129:
 11607               		.cfi_def_cfa_offset 6
 11608               		.cfi_offset 19, -5
 11609 48e4 4F93      		push r20
 11610               	.LCFI130:
 11611               		.cfi_def_cfa_offset 7
 11612               		.cfi_offset 20, -6
 11613 48e6 5F93      		push r21
 11614               	.LCFI131:
 11615               		.cfi_def_cfa_offset 8
 11616               		.cfi_offset 21, -7
 11617 48e8 6F93      		push r22
 11618               	.LCFI132:
 11619               		.cfi_def_cfa_offset 9
 11620               		.cfi_offset 22, -8
 11621 48ea 7F93      		push r23
 11622               	.LCFI133:
 11623               		.cfi_def_cfa_offset 10
 11624               		.cfi_offset 23, -9
 11625 48ec 8F93      		push r24
 11626               	.LCFI134:
 11627               		.cfi_def_cfa_offset 11
 11628               		.cfi_offset 24, -10
 11629 48ee 9F93      		push r25
 11630               	.LCFI135:
 11631               		.cfi_def_cfa_offset 12
 11632               		.cfi_offset 25, -11
 11633 48f0 AF93      		push r26
 11634               	.LCFI136:
 11635               		.cfi_def_cfa_offset 13
 11636               		.cfi_offset 26, -12
 11637 48f2 BF93      		push r27
 11638               	.LCFI137:
 11639               		.cfi_def_cfa_offset 14
 11640               		.cfi_offset 27, -13
 11641 48f4 EF93      		push r30
 11642               	.LCFI138:
 11643               		.cfi_def_cfa_offset 15
 11644               		.cfi_offset 30, -14
 11645 48f6 FF93      		push r31
 11646               	.LCFI139:
 11647               		.cfi_def_cfa_offset 16
 11648               		.cfi_offset 31, -15
 11649               	/* prologue: Signal */
 11650               	/* frame size = 0 */
 11651               	/* stack size = 15 */
 11652               	.L__stack_usage = 15
1291:WTPA.c        **** 	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
 11653               		.loc 1 1291 0
 11654 48f8 8091 0000 		lds r24,sdIsrState
 11655 48fc 8130      		cpi r24,lo8(1)
 11656 48fe 01F0      		breq .L1259
1362:WTPA.c        **** 	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
 11657               		.loc 1 1362 0
 11658 4900 8230      		cpi r24,lo8(2)
 11659 4902 01F4      		brne .+2
 11660 4904 00C0      		rjmp .L1260
1435:WTPA.c        **** 	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to th
 11661               		.loc 1 1435 0
 11662 4906 8330      		cpi r24,lo8(3)
 11663 4908 01F4      		brne .+2
 11664 490a 00C0      		rjmp .L1261
 11665               	.L1237:
 11666               	/* epilogue start */
1469:WTPA.c        **** }
 11667               		.loc 1 1469 0
 11668 490c FF91      		pop r31
 11669 490e EF91      		pop r30
 11670 4910 BF91      		pop r27
 11671 4912 AF91      		pop r26
 11672 4914 9F91      		pop r25
 11673 4916 8F91      		pop r24
 11674 4918 7F91      		pop r23
 11675 491a 6F91      		pop r22
 11676 491c 5F91      		pop r21
 11677 491e 4F91      		pop r20
 11678 4920 3F91      		pop r19
 11679 4922 2F91      		pop r18
 11680 4924 0F90      		pop r0
 11681 4926 0FBE      		out __SREG__,r0
 11682 4928 0F90      		pop r0
 11683 492a 1F90      		pop r1
 11684 492c 1895      		reti
 11685               	.L1259:
1293:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 11686               		.loc 1 1293 0
 11687 492e 8091 0000 		lds r24,sdRamSampleRemaining
 11688 4932 9091 0000 		lds r25,sdRamSampleRemaining+1
 11689 4936 A091 0000 		lds r26,sdRamSampleRemaining+2
 11690 493a B091 0000 		lds r27,sdRamSampleRemaining+3
 11691 493e 892B      		or r24,r25
 11692 4940 8A2B      		or r24,r26
 11693 4942 8B2B      		or r24,r27
 11694 4944 01F4      		brne .+2
 11695 4946 00C0      		rjmp .L1239
1295:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 11696               		.loc 1 1295 0
 11697 4948 8091 0000 		lds r24,sdBytesInFifo
 11698 494c 9091 0000 		lds r25,sdBytesInFifo+1
 11699 4950 892B      		or r24,r25
 11700 4952 01F0      		breq .L1237
1297:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 11701               		.loc 1 1297 0
 11702 4954 E091 0000 		lds r30,sdFifoReadPointer
 11703 4958 F091 0000 		lds r31,sdFifoReadPointer+1
 11704 495c E050      		subi r30,lo8(-(sdFifo))
 11705 495e F040      		sbci r31,hi8(-(sdFifo))
 11706 4960 3081      		ld r19,Z
 11707               	.LVL595:
1299:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 11708               		.loc 1 1299 0
 11709 4962 8091 0000 		lds r24,sdFifoReadPointer
 11710 4966 9091 0000 		lds r25,sdFifoReadPointer+1
 11711 496a 0196      		adiw r24,1
 11712 496c 9093 0000 		sts sdFifoReadPointer+1,r25
 11713 4970 8093 0000 		sts sdFifoReadPointer,r24
1300:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 11714               		.loc 1 1300 0
 11715 4974 8091 0000 		lds r24,sdFifoReadPointer
 11716 4978 9091 0000 		lds r25,sdFifoReadPointer+1
 11717 497c 8115      		cp r24,__zero_reg__
 11718 497e 9340      		sbci r25,3
 11719 4980 00F0      		brlo .+2
 11720 4982 00C0      		rjmp .L1262
 11721               	.L1241:
1305:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 11722               		.loc 1 1305 0
 11723 4984 8091 0000 		lds r24,sdBytesInFifo
 11724 4988 9091 0000 		lds r25,sdBytesInFifo+1
 11725 498c 0197      		sbiw r24,1
 11726 498e 9093 0000 		sts sdBytesInFifo+1,r25
 11727 4992 8093 0000 		sts sdBytesInFifo,r24
1306:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 11728               		.loc 1 1306 0
 11729 4996 8091 0000 		lds r24,sdRamSampleRemaining
 11730 499a 9091 0000 		lds r25,sdRamSampleRemaining+1
 11731 499e A091 0000 		lds r26,sdRamSampleRemaining+2
 11732 49a2 B091 0000 		lds r27,sdRamSampleRemaining+3
 11733 49a6 0197      		sbiw r24,1
 11734 49a8 A109      		sbc r26,__zero_reg__
 11735 49aa B109      		sbc r27,__zero_reg__
 11736 49ac 8093 0000 		sts sdRamSampleRemaining,r24
 11737 49b0 9093 0000 		sts sdRamSampleRemaining+1,r25
 11738 49b4 A093 0000 		sts sdRamSampleRemaining+2,r26
 11739 49b8 B093 0000 		sts sdRamSampleRemaining+3,r27
1310:WTPA.c        **** 				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version o
 11740               		.loc 1 1310 0
 11741 49bc 8FEF      		ldi r24,lo8(-1)
 11742 49be 84B9      		out 0x4,r24
1311:WTPA.c        **** 				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
 11743               		.loc 1 1311 0
 11744 49c0 8091 0000 		lds r24,sdRamAddress
 11745 49c4 85B9      		out 0x5,r24
1312:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
 11746               		.loc 1 1312 0
 11747 49c6 139A      		sbi 0x2,3
1313:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
 11748               		.loc 1 1313 0
 11749 49c8 1398      		cbi 0x2,3
1315:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
 11750               		.loc 1 1315 0
 11751 49ca 8091 0000 		lds r24,sdRamAddress
 11752 49ce 9091 0000 		lds r25,sdRamAddress+1
 11753 49d2 A091 0000 		lds r26,sdRamAddress+2
 11754 49d6 B091 0000 		lds r27,sdRamAddress+3
 11755 49da 492F      		mov r20,r25
 11756 49dc 5A2F      		mov r21,r26
 11757 49de 6B2F      		mov r22,r27
 11758 49e0 7727      		clr r23
 11759 49e2 45B9      		out 0x5,r20
1316:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
 11760               		.loc 1 1316 0
 11761 49e4 149A      		sbi 0x2,4
1317:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
 11762               		.loc 1 1317 0
 11763 49e6 1498      		cbi 0x2,4
1321:WTPA.c        **** 				PORTC&=~0x07;											// Clear PORTC bits 0-2
 11764               		.loc 1 1321 0
 11765 49e8 28B1      		in r18,0x8
 11766 49ea 287F      		andi r18,lo8(-8)
 11767 49ec 28B9      		out 0x8,r18
1322:WTPA.c        **** 				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
 11768               		.loc 1 1322 0
 11769 49ee 48B1      		in r20,0x8
 11770 49f0 2A2F      		mov r18,r26
 11771 49f2 2770      		andi r18,lo8(7)
 11772 49f4 242B      		or r18,r20
 11773 49f6 28B9      		out 0x8,r18
1324:WTPA.c        **** 				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
 11774               		.loc 1 1324 0
 11775 49f8 35B9      		out 0x5,r19
1327:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
 11776               		.loc 1 1327 0
 11777 49fa 2091 0000 		lds r18,sdBank0
 11778 49fe 2130      		cpi r18,lo8(1)
 11779 4a00 01F4      		brne .+2
 11780 4a02 00C0      		rjmp .L1263
1333:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 11781               		.loc 1 1333 0
 11782 4a04 0197      		sbiw r24,1
 11783 4a06 A109      		sbc r26,__zero_reg__
 11784 4a08 B109      		sbc r27,__zero_reg__
 11785 4a0a 8093 0000 		sts sdRamAddress,r24
 11786 4a0e 9093 0000 		sts sdRamAddress+1,r25
 11787 4a12 A093 0000 		sts sdRamAddress+2,r26
 11788 4a16 B093 0000 		sts sdRamAddress+3,r27
 11789               	.L1243:
1337:WTPA.c        **** 				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
 11790               		.loc 1 1337 0
 11791 4a1a 1198      		cbi 0x2,1
1338:WTPA.c        **** 				PORTA|=(Om_RAM_WE);					// Disbale writes.
 11792               		.loc 1 1338 0
 11793 4a1c 119A      		sbi 0x2,1
 11794 4a1e 00C0      		rjmp .L1237
 11795               	.LVL596:
 11796               	.L1260:
1365:WTPA.c        **** 		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
 11797               		.loc 1 1365 0
 11798 4a20 8091 0000 		lds r24,sdBytesInFifo
 11799 4a24 9091 0000 		lds r25,sdBytesInFifo+1
 11800 4a28 8115      		cp r24,__zero_reg__
 11801 4a2a 9340      		sbci r25,3
 11802 4a2c 00F0      		brlo .+2
 11803 4a2e 00C0      		rjmp .L1237
1367:WTPA.c        **** 			if(sdRamSampleRemaining)	// Any sample left in RAM?
 11804               		.loc 1 1367 0
 11805 4a30 8091 0000 		lds r24,sdRamSampleRemaining
 11806 4a34 9091 0000 		lds r25,sdRamSampleRemaining+1
 11807 4a38 A091 0000 		lds r26,sdRamSampleRemaining+2
 11808 4a3c B091 0000 		lds r27,sdRamSampleRemaining+3
 11809 4a40 892B      		or r24,r25
 11810 4a42 8A2B      		or r24,r26
 11811 4a44 8B2B      		or r24,r27
 11812 4a46 01F4      		brne .+2
 11813 4a48 00C0      		rjmp .L1246
1370:WTPA.c        **** 				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
 11814               		.loc 1 1370 0
 11815 4a4a 8091 0000 		lds r24,sdRamAddress
 11816 4a4e 85B9      		out 0x5,r24
1371:WTPA.c        **** 				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
 11817               		.loc 1 1371 0
 11818 4a50 139A      		sbi 0x2,3
1372:WTPA.c        **** 				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
 11819               		.loc 1 1372 0
 11820 4a52 1398      		cbi 0x2,3
1374:WTPA.c        **** 				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
 11821               		.loc 1 1374 0
 11822 4a54 8091 0000 		lds r24,sdRamAddress
 11823 4a58 9091 0000 		lds r25,sdRamAddress+1
 11824 4a5c A091 0000 		lds r26,sdRamAddress+2
 11825 4a60 B091 0000 		lds r27,sdRamAddress+3
 11826 4a64 492F      		mov r20,r25
 11827 4a66 5A2F      		mov r21,r26
 11828 4a68 6B2F      		mov r22,r27
 11829 4a6a 7727      		clr r23
 11830 4a6c 45B9      		out 0x5,r20
1375:WTPA.c        **** 				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
 11831               		.loc 1 1375 0
 11832 4a6e 149A      		sbi 0x2,4
1376:WTPA.c        **** 				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
 11833               		.loc 1 1376 0
 11834 4a70 1498      		cbi 0x2,4
1381:WTPA.c        **** 				PORTC&=~0x07;											// Clear PORTC bits 0-2
 11835               		.loc 1 1381 0
 11836 4a72 28B1      		in r18,0x8
 11837 4a74 287F      		andi r18,lo8(-8)
 11838 4a76 28B9      		out 0x8,r18
1382:WTPA.c        **** 				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
 11839               		.loc 1 1382 0
 11840 4a78 38B1      		in r19,0x8
 11841 4a7a 2A2F      		mov r18,r26
 11842 4a7c 2770      		andi r18,lo8(7)
 11843 4a7e 232B      		or r18,r19
 11844 4a80 28B9      		out 0x8,r18
1384:WTPA.c        **** 				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
 11845               		.loc 1 1384 0
 11846 4a82 14B8      		out 0x4,__zero_reg__
1385:WTPA.c        **** 				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
 11847               		.loc 1 1385 0
 11848 4a84 1298      		cbi 0x2,2
1388:WTPA.c        **** 				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
 11849               		.loc 1 1388 0
 11850 4a86 2091 0000 		lds r18,sdBank0
 11851 4a8a 2130      		cpi r18,lo8(1)
 11852 4a8c 01F4      		brne .+2
 11853 4a8e 00C0      		rjmp .L1264
1394:WTPA.c        **** 					sdRamAddress--;		// Next address is lower for bank 1.
 11854               		.loc 1 1394 0
 11855 4a90 0197      		sbiw r24,1
 11856 4a92 A109      		sbc r26,__zero_reg__
 11857 4a94 B109      		sbc r27,__zero_reg__
 11858 4a96 8093 0000 		sts sdRamAddress,r24
 11859 4a9a 9093 0000 		sts sdRamAddress+1,r25
 11860 4a9e A093 0000 		sts sdRamAddress+2,r26
 11861 4aa2 B093 0000 		sts sdRamAddress+3,r27
 11862               	.L1248:
1399:WTPA.c        **** 				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
 11863               		.loc 1 1399 0
 11864 4aa6 83B1      		in r24,0x3
 11865               	.LVL597:
1400:WTPA.c        **** 				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
 11866               		.loc 1 1400 0
 11867 4aa8 129A      		sbi 0x2,2
1401:WTPA.c        **** 				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
 11868               		.loc 1 1401 0
 11869 4aaa 9FEF      		ldi r25,lo8(-1)
 11870 4aac 94B9      		out 0x4,r25
1406:WTPA.c        **** 				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
 11871               		.loc 1 1406 0
 11872 4aae E091 0000 		lds r30,sdFifoWritePointer
 11873 4ab2 F091 0000 		lds r31,sdFifoWritePointer+1
 11874 4ab6 E050      		subi r30,lo8(-(sdFifo))
 11875 4ab8 F040      		sbci r31,hi8(-(sdFifo))
 11876 4aba 8083      		st Z,r24
1407:WTPA.c        **** 				sdFifoWritePointer++;				// Move to next spot in fifo
 11877               		.loc 1 1407 0
 11878 4abc 8091 0000 		lds r24,sdFifoWritePointer
 11879 4ac0 9091 0000 		lds r25,sdFifoWritePointer+1
 11880               	.LVL598:
 11881 4ac4 0196      		adiw r24,1
 11882 4ac6 9093 0000 		sts sdFifoWritePointer+1,r25
 11883 4aca 8093 0000 		sts sdFifoWritePointer,r24
1409:WTPA.c        **** 				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
 11884               		.loc 1 1409 0
 11885 4ace 8091 0000 		lds r24,sdFifoWritePointer
 11886 4ad2 9091 0000 		lds r25,sdFifoWritePointer+1
 11887 4ad6 8115      		cp r24,__zero_reg__
 11888 4ad8 9340      		sbci r25,3
 11889 4ada 00F0      		brlo .L1249
1411:WTPA.c        **** 					sdFifoWritePointer=0;
 11890               		.loc 1 1411 0
 11891 4adc 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 11892 4ae0 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 11893               	.L1249:
1414:WTPA.c        **** 				sdBytesInFifo++;				// One more byte in the FIFO
 11894               		.loc 1 1414 0
 11895 4ae4 8091 0000 		lds r24,sdBytesInFifo
 11896 4ae8 9091 0000 		lds r25,sdBytesInFifo+1
 11897 4aec 0196      		adiw r24,1
 11898 4aee 9093 0000 		sts sdBytesInFifo+1,r25
 11899 4af2 8093 0000 		sts sdBytesInFifo,r24
1415:WTPA.c        **** 				sdRamSampleRemaining--;		// One less byte in the sample
 11900               		.loc 1 1415 0
 11901 4af6 8091 0000 		lds r24,sdRamSampleRemaining
 11902 4afa 9091 0000 		lds r25,sdRamSampleRemaining+1
 11903 4afe A091 0000 		lds r26,sdRamSampleRemaining+2
 11904 4b02 B091 0000 		lds r27,sdRamSampleRemaining+3
 11905 4b06 0197      		sbiw r24,1
 11906 4b08 A109      		sbc r26,__zero_reg__
 11907 4b0a B109      		sbc r27,__zero_reg__
 11908 4b0c 8093 0000 		sts sdRamSampleRemaining,r24
 11909 4b10 9093 0000 		sts sdRamSampleRemaining+1,r25
 11910 4b14 A093 0000 		sts sdRamSampleRemaining+2,r26
 11911 4b18 B093 0000 		sts sdRamSampleRemaining+3,r27
 11912 4b1c 00C0      		rjmp .L1237
 11913               	.LVL599:
 11914               	.L1261:
1437:WTPA.c        **** 		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
 11915               		.loc 1 1437 0
 11916 4b1e 8091 0000 		lds r24,sdRamSampleRemaining
 11917 4b22 9091 0000 		lds r25,sdRamSampleRemaining+1
 11918 4b26 A091 0000 		lds r26,sdRamSampleRemaining+2
 11919 4b2a B091 0000 		lds r27,sdRamSampleRemaining+3
 11920 4b2e 892B      		or r24,r25
 11921 4b30 8A2B      		or r24,r26
 11922 4b32 8B2B      		or r24,r27
 11923 4b34 01F4      		brne .+2
 11924 4b36 00C0      		rjmp .L1251
1439:WTPA.c        **** 			if(sdBytesInFifo)	// Anything currently in the FIFO?
 11925               		.loc 1 1439 0
 11926 4b38 8091 0000 		lds r24,sdBytesInFifo
 11927 4b3c 9091 0000 		lds r25,sdBytesInFifo+1
 11928 4b40 892B      		or r24,r25
 11929 4b42 01F4      		brne .+2
 11930 4b44 00C0      		rjmp .L1237
1441:WTPA.c        **** 				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
 11931               		.loc 1 1441 0
 11932 4b46 E091 0000 		lds r30,sdFifoReadPointer
 11933 4b4a F091 0000 		lds r31,sdFifoReadPointer+1
 11934 4b4e E050      		subi r30,lo8(-(sdFifo))
 11935 4b50 F040      		sbci r31,hi8(-(sdFifo))
 11936 4b52 2081      		ld r18,Z
 11937               	.LVL600:
1443:WTPA.c        **** 				sdFifoReadPointer++;					// Move to next spot in fifo
 11938               		.loc 1 1443 0
 11939 4b54 8091 0000 		lds r24,sdFifoReadPointer
 11940 4b58 9091 0000 		lds r25,sdFifoReadPointer+1
 11941 4b5c 0196      		adiw r24,1
 11942 4b5e 9093 0000 		sts sdFifoReadPointer+1,r25
 11943 4b62 8093 0000 		sts sdFifoReadPointer,r24
1444:WTPA.c        **** 				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
 11944               		.loc 1 1444 0
 11945 4b66 8091 0000 		lds r24,sdFifoReadPointer
 11946 4b6a 9091 0000 		lds r25,sdFifoReadPointer+1
 11947 4b6e 8115      		cp r24,__zero_reg__
 11948 4b70 9340      		sbci r25,3
 11949 4b72 00F0      		brlo .L1252
1446:WTPA.c        **** 					sdFifoReadPointer=0;
 11950               		.loc 1 1446 0
 11951 4b74 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 11952 4b78 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 11953               	.L1252:
1449:WTPA.c        **** 				sdBytesInFifo--;				// One less byte in the FIFO
 11954               		.loc 1 1449 0
 11955 4b7c 8091 0000 		lds r24,sdBytesInFifo
 11956 4b80 9091 0000 		lds r25,sdBytesInFifo+1
 11957 4b84 0197      		sbiw r24,1
 11958 4b86 9093 0000 		sts sdBytesInFifo+1,r25
 11959 4b8a 8093 0000 		sts sdBytesInFifo,r24
1450:WTPA.c        **** 				sdRamSampleRemaining--;			// One less byte in the sample
 11960               		.loc 1 1450 0
 11961 4b8e 8091 0000 		lds r24,sdRamSampleRemaining
 11962 4b92 9091 0000 		lds r25,sdRamSampleRemaining+1
 11963 4b96 A091 0000 		lds r26,sdRamSampleRemaining+2
 11964 4b9a B091 0000 		lds r27,sdRamSampleRemaining+3
 11965 4b9e 0197      		sbiw r24,1
 11966 4ba0 A109      		sbc r26,__zero_reg__
 11967 4ba2 B109      		sbc r27,__zero_reg__
 11968 4ba4 8093 0000 		sts sdRamSampleRemaining,r24
 11969 4ba8 9093 0000 		sts sdRamSampleRemaining+1,r25
 11970 4bac A093 0000 		sts sdRamSampleRemaining+2,r26
 11971 4bb0 B093 0000 		sts sdRamSampleRemaining+3,r27
1454:WTPA.c        **** 				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating rou
 11972               		.loc 1 1454 0
 11973 4bb4 2093 0000 		sts sdStreamOutput,r18
1455:WTPA.c        **** 				UpdateOutput();				// Update the DAC
 11974               		.loc 1 1455 0
 11975 4bb8 E091 0000 		lds r30,UpdateOutput
 11976 4bbc F091 0000 		lds r31,UpdateOutput+1
 11977 4bc0 0995      		icall
 11978               	.LVL601:
 11979 4bc2 00C0      		rjmp .L1237
 11980               	.L1239:
1344:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 11981               		.loc 1 1344 0
 11982 4bc4 1092 0000 		sts sdIsrState,__zero_reg__
1345:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 11983               		.loc 1 1345 0
 11984 4bc8 1092 B100 		sts 177,__zero_reg__
1346:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 11985               		.loc 1 1346 0
 11986 4bcc 8091 7000 		lds r24,112
 11987 4bd0 8B7F      		andi r24,lo8(-5)
 11988 4bd2 8093 7000 		sts 112,r24
1348:WTPA.c        **** 			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
 11989               		.loc 1 1348 0
 11990 4bd6 8091 0000 		lds r24,sdBank0
 11991 4bda 8130      		cpi r24,lo8(1)
 11992 4bdc 01F4      		brne .+2
 11993 4bde 00C0      		rjmp .L1265
1356:WTPA.c        **** 				bankStates[BANK_1].isLocked=false;					// Unlock bank
 11994               		.loc 1 1356 0
 11995 4be0 1092 0000 		sts bankStates+41,__zero_reg__
1357:WTPA.c        **** 				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 11996               		.loc 1 1357 0
 11997 4be4 8091 0000 		lds r24,sdRamAddress
 11998 4be8 9091 0000 		lds r25,sdRamAddress+1
 11999 4bec A091 0000 		lds r26,sdRamAddress+2
 12000 4bf0 B091 0000 		lds r27,sdRamAddress+3
 12001 4bf4 8093 0000 		sts bankStates+49,r24
 12002 4bf8 9093 0000 		sts bankStates+49+1,r25
 12003 4bfc A093 0000 		sts bankStates+49+2,r26
 12004 4c00 B093 0000 		sts bankStates+49+3,r27
1358:WTPA.c        **** 				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 12005               		.loc 1 1358 0
 12006 4c04 8093 0000 		sts bankStates+57,r24
 12007 4c08 9093 0000 		sts bankStates+57+1,r25
 12008 4c0c A093 0000 		sts bankStates+57+2,r26
 12009 4c10 B093 0000 		sts bankStates+57+3,r27
 12010 4c14 00C0      		rjmp .L1237
 12011               	.L1246:
1420:WTPA.c        **** 				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 12012               		.loc 1 1420 0
 12013 4c16 1092 0000 		sts sdIsrState,__zero_reg__
1421:WTPA.c        **** 				TCCR2B=0;					// Stop this timer
 12014               		.loc 1 1421 0
 12015 4c1a 1092 B100 		sts 177,__zero_reg__
1422:WTPA.c        **** 				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 12016               		.loc 1 1422 0
 12017 4c1e 8091 7000 		lds r24,112
 12018 4c22 8B7F      		andi r24,lo8(-5)
 12019 4c24 8093 7000 		sts 112,r24
1424:WTPA.c        **** 				if(sdBank0==true)	// Unlock the bank for other RAM accesses
 12020               		.loc 1 1424 0
 12021 4c28 8091 0000 		lds r24,sdBank0
 12022 4c2c 8130      		cpi r24,lo8(1)
 12023 4c2e 01F0      		breq .L1266
1430:WTPA.c        **** 					bankStates[BANK_1].isLocked=false;					// Unlock bank
 12024               		.loc 1 1430 0
 12025 4c30 1092 0000 		sts bankStates+41,__zero_reg__
 12026 4c34 00C0      		rjmp .L1237
 12027               	.L1251:
1460:WTPA.c        **** 			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 12028               		.loc 1 1460 0
 12029 4c36 1092 0000 		sts sdIsrState,__zero_reg__
1461:WTPA.c        **** 			TCCR2B=0;					// Stop this timer
 12030               		.loc 1 1461 0
 12031 4c3a 1092 B100 		sts 177,__zero_reg__
1462:WTPA.c        **** 			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 12032               		.loc 1 1462 0
 12033 4c3e 8091 7000 		lds r24,112
 12034 4c42 8B7F      		andi r24,lo8(-5)
 12035 4c44 8093 7000 		sts 112,r24
1465:WTPA.c        **** 			sdStreamOutput=0;
 12036               		.loc 1 1465 0
 12037 4c48 1092 0000 		sts sdStreamOutput,__zero_reg__
1466:WTPA.c        **** 			UpdateOutput();				// Update the DAC
 12038               		.loc 1 1466 0
 12039 4c4c E091 0000 		lds r30,UpdateOutput
 12040 4c50 F091 0000 		lds r31,UpdateOutput+1
 12041 4c54 0995      		icall
 12042               	.LVL602:
 12043 4c56 00C0      		rjmp .L1237
 12044               	.LVL603:
 12045               	.L1262:
1302:WTPA.c        **** 					sdFifoReadPointer=0;
 12046               		.loc 1 1302 0
 12047 4c58 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 12048 4c5c 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 12049 4c60 00C0      		rjmp .L1241
 12050               	.LVL604:
 12051               	.L1264:
1390:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 12052               		.loc 1 1390 0
 12053 4c62 0196      		adiw r24,1
 12054 4c64 A11D      		adc r26,__zero_reg__
 12055 4c66 B11D      		adc r27,__zero_reg__
 12056 4c68 8093 0000 		sts sdRamAddress,r24
 12057 4c6c 9093 0000 		sts sdRamAddress+1,r25
 12058 4c70 A093 0000 		sts sdRamAddress+2,r26
 12059 4c74 B093 0000 		sts sdRamAddress+3,r27
 12060 4c78 00C0      		rjmp .L1248
 12061               	.L1266:
1426:WTPA.c        **** 					bankStates[BANK_0].isLocked=false;					// Unlock bank
 12062               		.loc 1 1426 0
 12063 4c7a 1092 0000 		sts bankStates+5,__zero_reg__
 12064 4c7e 00C0      		rjmp .L1237
 12065               	.L1265:
1350:WTPA.c        **** 				bankStates[BANK_0].isLocked=false;					// Unlock bank
 12066               		.loc 1 1350 0
 12067 4c80 1092 0000 		sts bankStates+5,__zero_reg__
1351:WTPA.c        **** 				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the curr
 12068               		.loc 1 1351 0
 12069 4c84 8091 0000 		lds r24,sdRamAddress
 12070 4c88 9091 0000 		lds r25,sdRamAddress+1
 12071 4c8c A091 0000 		lds r26,sdRamAddress+2
 12072 4c90 B091 0000 		lds r27,sdRamAddress+3
 12073 4c94 8093 0000 		sts bankStates+13,r24
 12074 4c98 9093 0000 		sts bankStates+13+1,r25
 12075 4c9c A093 0000 		sts bankStates+13+2,r26
 12076 4ca0 B093 0000 		sts bankStates+13+3,r27
1352:WTPA.c        **** 				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed
 12077               		.loc 1 1352 0
 12078 4ca4 8093 0000 		sts bankStates+21,r24
 12079 4ca8 9093 0000 		sts bankStates+21+1,r25
 12080 4cac A093 0000 		sts bankStates+21+2,r26
 12081 4cb0 B093 0000 		sts bankStates+21+3,r27
 12082 4cb4 00C0      		rjmp .L1237
 12083               	.LVL605:
 12084               	.L1263:
1329:WTPA.c        **** 					sdRamAddress++;		// Next address is higher for bank 0...
 12085               		.loc 1 1329 0
 12086 4cb6 0196      		adiw r24,1
 12087 4cb8 A11D      		adc r26,__zero_reg__
 12088 4cba B11D      		adc r27,__zero_reg__
 12089 4cbc 8093 0000 		sts sdRamAddress,r24
 12090 4cc0 9093 0000 		sts sdRamAddress+1,r25
 12091 4cc4 A093 0000 		sts sdRamAddress+2,r26
 12092 4cc8 B093 0000 		sts sdRamAddress+3,r27
 12093 4ccc 00C0      		rjmp .L1243
 12094               		.cfi_endproc
 12095               	.LFE11:
 12097               	.global	__vector_9
 12099               	__vector_9:
 12100               	.LFB12:
1474:WTPA.c        **** {
 12101               		.loc 1 1474 0
 12102               		.cfi_startproc
 12103 4cce 1F92      		push r1
 12104               	.LCFI140:
 12105               		.cfi_def_cfa_offset 3
 12106               		.cfi_offset 1, -2
 12107 4cd0 0F92      		push r0
 12108               	.LCFI141:
 12109               		.cfi_def_cfa_offset 4
 12110               		.cfi_offset 0, -3
 12111 4cd2 0FB6      		in r0,__SREG__
 12112 4cd4 0F92      		push r0
 12113 4cd6 1124      		clr __zero_reg__
 12114 4cd8 8F93      		push r24
 12115               	.LCFI142:
 12116               		.cfi_def_cfa_offset 5
 12117               		.cfi_offset 24, -4
 12118 4cda 9F93      		push r25
 12119               	.LCFI143:
 12120               		.cfi_def_cfa_offset 6
 12121               		.cfi_offset 25, -5
 12122               	/* prologue: Signal */
 12123               	/* frame size = 0 */
 12124               	/* stack size = 5 */
 12125               	.L__stack_usage = 5
1478:WTPA.c        **** 	if(ledPwm>pwmCount)
 12126               		.loc 1 1478 0
 12127 4cdc 9091 0000 		lds r25,ledPwm
 12128 4ce0 8091 0000 		lds r24,pwmCount.1847
 12129 4ce4 8917      		cp r24,r25
 12130 4ce6 00F0      		brlo .L1270
1484:WTPA.c        **** 		LATCH_PORT=0x00;	// LEDs go off.
 12131               		.loc 1 1484 0
 12132 4ce8 15B8      		out 0x5,__zero_reg__
 12133               	.L1269:
1486:WTPA.c        **** 	pwmCount++;
 12134               		.loc 1 1486 0
 12135 4cea 8F5F      		subi r24,lo8(-(1))
 12136 4cec 8093 0000 		sts pwmCount.1847,r24
 12137               	/* epilogue start */
1487:WTPA.c        **** }
 12138               		.loc 1 1487 0
 12139 4cf0 9F91      		pop r25
 12140 4cf2 8F91      		pop r24
 12141 4cf4 0F90      		pop r0
 12142 4cf6 0FBE      		out __SREG__,r0
 12143 4cf8 0F90      		pop r0
 12144 4cfa 1F90      		pop r1
 12145 4cfc 1895      		reti
 12146               	.L1270:
1480:WTPA.c        **** 		LATCH_PORT=0xFF;	// LEDs go on.
 12147               		.loc 1 1480 0
 12148 4cfe 9FEF      		ldi r25,lo8(-1)
 12149 4d00 95B9      		out 0x5,r25
 12150 4d02 00C0      		rjmp .L1269
 12151               		.cfi_endproc
 12152               	.LFE12:
 12154               	.global	__vector_default
 12156               	__vector_default:
 12157               	.LFB13:
1490:WTPA.c        **** {
 12158               		.loc 1 1490 0
 12159               		.cfi_startproc
 12160 4d04 1F92      		push r1
 12161               	.LCFI144:
 12162               		.cfi_def_cfa_offset 3
 12163               		.cfi_offset 1, -2
 12164 4d06 0F92      		push r0
 12165               	.LCFI145:
 12166               		.cfi_def_cfa_offset 4
 12167               		.cfi_offset 0, -3
 12168 4d08 0FB6      		in r0,__SREG__
 12169 4d0a 0F92      		push r0
 12170 4d0c 1124      		clr __zero_reg__
 12171               	/* prologue: Signal */
 12172               	/* frame size = 0 */
 12173               	/* stack size = 3 */
 12174               	.L__stack_usage = 3
 12175               	/* epilogue start */
1494:WTPA.c        **** }
 12176               		.loc 1 1494 0
 12177 4d0e 0F90      		pop r0
 12178 4d10 0FBE      		out __SREG__,r0
 12179 4d12 0F90      		pop r0
 12180 4d14 1F90      		pop r1
 12181 4d16 1895      		reti
 12182               		.cfi_endproc
 12183               	.LFE13:
 12185               	.global	HandleSoftclock
 12187               	HandleSoftclock:
 12188               	.LFB15:
1517:WTPA.c        **** {
 12189               		.loc 1 1517 0
 12190               		.cfi_startproc
 12191               	/* prologue: function */
 12192               	/* frame size = 0 */
 12193               	/* stack size = 0 */
 12194               	.L__stack_usage = 0
1518:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 12195               		.loc 1 1518 0
 12196 4d18 A89B      		sbis 0x15,0
 12197 4d1a 00C0      		rjmp .L1272
 12198               	.LBB864:
 12199               	.LBB865:
1520:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 12200               		.loc 1 1520 0
 12201 4d1c A89A      		sbi 0x15,0
1521:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 12202               		.loc 1 1521 0
 12203 4d1e 8091 0000 		lds r24,systemTicks
 12204 4d22 9091 0000 		lds r25,systemTicks+1
 12205               	.LVL606:
 12206 4d26 0196      		adiw r24,1
 12207               	.LVL607:
 12208 4d28 9093 0000 		sts systemTicks+1,r25
 12209 4d2c 8093 0000 		sts systemTicks,r24
 12210               	.LVL608:
 12211               	.L1272:
 12212 4d30 0895      		ret
 12213               	.LBE865:
 12214               	.LBE864:
 12215               		.cfi_endproc
 12216               	.LFE15:
 12218               		.section	.text.startup,"ax",@progbits
 12219               	.global	main
 12221               	main:
 12222               	.LFB76:
4972:WTPA.c        **** {
 12223               		.loc 1 4972 0
 12224               		.cfi_startproc
 12225 0000 CF93      		push r28
 12226               	.LCFI146:
 12227               		.cfi_def_cfa_offset 3
 12228               		.cfi_offset 28, -2
 12229 0002 DF93      		push r29
 12230               	.LCFI147:
 12231               		.cfi_def_cfa_offset 4
 12232               		.cfi_offset 29, -3
 12233 0004 CDB7      		in r28,__SP_L__
 12234 0006 DEB7      		in r29,__SP_H__
 12235               	.LCFI148:
 12236               		.cfi_def_cfa_register 28
 12237 0008 2C97      		sbiw r28,12
 12238               	.LCFI149:
 12239               		.cfi_def_cfa_offset 16
 12240 000a 0FB6      		in __tmp_reg__,__SREG__
 12241 000c F894      		cli
 12242 000e DEBF      		out __SP_H__,r29
 12243 0010 0FBE      		out __SREG__,__tmp_reg__
 12244 0012 CDBF      		out __SP_L__,r28
 12245               	/* prologue: function */
 12246               	/* frame size = 12 */
 12247               	/* stack size = 14 */
 12248               	.L__stack_usage = 14
4973:WTPA.c        **** 	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
 12249               		.loc 1 4973 0
 12250 0014 1FEF      		ldi r17,lo8(-1)
 12251 0016 1093 6400 		sts 100,r17
4974:WTPA.c        **** 	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
 12252               		.loc 1 4974 0
 12253 001a 85B7      		in r24,0x35
 12254 001c 8F7E      		andi r24,lo8(-17)
 12255 001e 85BF      		out 0x35,r24
4978:WTPA.c        **** 	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initial
 12256               		.loc 1 4978 0
 12257 0020 8FEE      		ldi r24,lo8(-17)
 12258 0022 87B9      		out 0x7,r24
4979:WTPA.c        **** 	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the sw
 12259               		.loc 1 4979 0
 12260 0024 88E0      		ldi r24,lo8(8)
 12261 0026 88B9      		out 0x8,r24
4981:WTPA.c        **** 	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latc
 12262               		.loc 1 4981 0
 12263 0028 80E8      		ldi r24,lo8(-128)
 12264 002a 8AB9      		out 0xa,r24
4982:WTPA.c        **** 	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
 12265               		.loc 1 4982 0
 12266 002c 1BB8      		out 0xb,__zero_reg__
4985:WTPA.c        **** 	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pu
 12267               		.loc 1 4985 0
 12268 002e 96E0      		ldi r25,lo8(6)
 12269 0030 92B9      		out 0x2,r25
4986:WTPA.c        **** 	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in
 12270               		.loc 1 4986 0
 12271 0032 9EE3      		ldi r25,lo8(62)
 12272 0034 91B9      		out 0x1,r25
4988:WTPA.c        **** 	DDRB=0xFF;			// Latch port to OP.
 12273               		.loc 1 4988 0
 12274 0036 14B9      		out 0x4,r17
4989:WTPA.c        **** 	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
 12275               		.loc 1 4989 0
 12276 0038 85B9      		out 0x5,r24
4992:WTPA.c        **** 	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
 12277               		.loc 1 4992 0
 12278 003a 129A      		sbi 0x2,2
4993:WTPA.c        **** 	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
 12279               		.loc 1 4993 0
 12280 003c 14B9      		out 0x4,r17
4994:WTPA.c        **** 	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output.
 12281               		.loc 1 4994 0
 12282 003e 159A      		sbi 0x2,5
4995:WTPA.c        **** 	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
 12283               		.loc 1 4995 0
 12284 0040 1598      		cbi 0x2,5
4997:WTPA.c        **** 	InitSdInterface();		// Turn on SD hardware
 12285               		.loc 1 4997 0
 12286 0042 0E94 0000 		call InitSdInterface
 12287               	.LVL609:
 12288               	.LBB968:
 12289               	.LBB969:
1660:WTPA.c        **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
 12290               		.loc 1 1660 0
 12291 0046 66E2      		ldi r22,lo8(38)
 12292 0048 70E0      		ldi r23,0
 12293 004a 81E0      		ldi r24,lo8(1)
 12294 004c 0E94 0000 		call SetTimer
 12295               	.LVL610:
1662:WTPA.c        **** 	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
 12296               		.loc 1 1662 0
 12297 0050 3D98      		cbi 0x7,5
1663:WTPA.c        **** 	PORTC|=Im_CARD_DETECT;	// Pull it up.
 12298               		.loc 1 1663 0
 12299 0052 459A      		sbi 0x8,5
 12300               	.LBE969:
 12301               	.LBE968:
 12302               	.LBB970:
 12303               	.LBB971:
1733:WTPA.c        **** 	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
 12304               		.loc 1 1733 0
 12305 0054 80B1      		in r24,0
 12306 0056 807C      		andi r24,lo8(-64)
 12307 0058 8093 0000 		sts encoderState,r24
1734:WTPA.c        **** 	encoderValue=0;							// zero our relative position.
 12308               		.loc 1 1734 0
 12309 005c 1092 0000 		sts encoderValue,__zero_reg__
1735:WTPA.c        **** 	newEncoder=false;
 12310               		.loc 1 1735 0
 12311 0060 1092 0000 		sts newEncoder,__zero_reg__
1736:WTPA.c        **** 	encoderCw=false;
 12312               		.loc 1 1736 0
 12313 0064 1092 0000 		sts encoderCw,__zero_reg__
1737:WTPA.c        **** 	encoderCcw=false;
 12314               		.loc 1 1737 0
 12315 0068 1092 0000 		sts encoderCcw,__zero_reg__
 12316               	.LBE971:
 12317               	.LBE970:
 12318               	.LBB972:
 12319               	.LBB973:
1647:WTPA.c        **** 	ledOnOffMask=0;
 12320               		.loc 1 1647 0
 12321 006c 1092 0000 		sts ledOnOffMask,__zero_reg__
1648:WTPA.c        **** 	ledBlinkMask=0;
 12322               		.loc 1 1648 0
 12323 0070 1092 0000 		sts ledBlinkMask,__zero_reg__
 12324               	.LVL611:
 12325               	.LBB974:
 12326               	.LBB975:
1596:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 12327               		.loc 1 1596 0
 12328 0074 8FB7      		in r24,__SREG__
 12329               	.LVL612:
1597:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 12330               		.loc 1 1597 0
 12331               	/* #APP */
 12332               	 ;  1597 "WTPA.c" 1
 12333 0076 F894      		cli
 12334               	 ;  0 "" 2
1599:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 12335               		.loc 1 1599 0
 12336               	/* #NOAPP */
 12337 0078 15B8      		out 0x5,__zero_reg__
1600:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 12338               		.loc 1 1600 0
 12339 007a 14B9      		out 0x4,r17
1601:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 12340               		.loc 1 1601 0
 12341 007c 5F9A      		sbi 0xb,7
1602:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 12342               		.loc 1 1602 0
 12343 007e 5F98      		cbi 0xb,7
1604:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 12344               		.loc 1 1604 0
 12345 0080 8FBF      		out __SREG__,r24
 12346               	.LBE975:
 12347               	.LBE974:
 12348               	.LBE973:
 12349               	.LBE972:
5001:WTPA.c        **** 	InitMidi();					// Get the MIDI stack initialized.
 12350               		.loc 1 5001 0
 12351 0082 0E94 0000 		call InitMidi
 12352               	.LVL613:
5002:WTPA.c        **** 	InitUart0();
 12353               		.loc 1 5002 0
 12354 0086 0E94 0000 		call InitUart0
 12355               	.LVL614:
 12356               	.LBB976:
 12357               	.LBB977:
1858:WTPA.c        **** 	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
 12358               		.loc 1 1858 0
 12359 008a 8091 6400 		lds r24,100
 12360 008e 8E7F      		andi r24,lo8(-2)
 12361 0090 8093 6400 		sts 100,r24
1859:WTPA.c        **** 	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start
 12362               		.loc 1 1859 0
 12363 0094 80E6      		ldi r24,lo8(96)
 12364 0096 8093 7C00 		sts 124,r24
1860:WTPA.c        **** 	DIDR0 = 0x01;			// Disable the digital input for ADC0.
 12365               		.loc 1 1860 0
 12366 009a 81E0      		ldi r24,lo8(1)
 12367 009c 8093 7E00 		sts 126,r24
1861:WTPA.c        **** 	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC
 12368               		.loc 1 1861 0
 12369 00a0 85E9      		ldi r24,lo8(-107)
 12370 00a2 8093 7A00 		sts 122,r24
1863:WTPA.c        **** 	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
 12371               		.loc 1 1863 0
 12372 00a6 8091 7A00 		lds r24,122
 12373 00aa 8064      		ori r24,lo8(64)
 12374 00ac 8093 7A00 		sts 122,r24
 12375               	.LBE977:
 12376               	.LBE976:
 12377               	.LBB978:
 12378               	.LBB979:
1537:WTPA.c        **** 	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
 12379               		.loc 1 1537 0
 12380 00b0 8091 6400 		lds r24,100
 12381 00b4 8F7D      		andi r24,lo8(-33)
 12382 00b6 8093 6400 		sts 100,r24
1538:WTPA.c        **** 	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
 12383               		.loc 1 1538 0
 12384 00ba 1092 6E00 		sts 110,__zero_reg__
1539:WTPA.c        **** 	TCCR0A=0;			// Normal Ports.
 12385               		.loc 1 1539 0
 12386 00be 14BC      		out 0x24,__zero_reg__
1540:WTPA.c        **** 	TCNT0=0;			// Initialize the counter to 0.
 12387               		.loc 1 1540 0
 12388 00c0 16BC      		out 0x26,__zero_reg__
1541:WTPA.c        **** 	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
 12389               		.loc 1 1541 0
 12390 00c2 15BB      		out 0x15,r17
1542:WTPA.c        **** 	systemTicks=0;
 12391               		.loc 1 1542 0
 12392 00c4 1092 0000 		sts systemTicks+1,__zero_reg__
 12393 00c8 1092 0000 		sts systemTicks,__zero_reg__
1544:WTPA.c        **** 	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
 12394               		.loc 1 1544 0
 12395 00cc 83E0      		ldi r24,lo8(3)
 12396 00ce 85BD      		out 0x25,r24
 12397               	.LBE979:
 12398               	.LBE978:
 12399               	.LBB980:
 12400               	.LBB981:
2117:WTPA.c        **** 	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
 12401               		.loc 1 2117 0
 12402 00d0 8091 6400 		lds r24,100
 12403 00d4 877F      		andi r24,lo8(-9)
 12404 00d6 8093 6400 		sts 100,r24
2118:WTPA.c        **** 	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
 12405               		.loc 1 2118 0
 12406 00da 1092 6F00 		sts 111,__zero_reg__
2119:WTPA.c        **** 	OCR1A=65535;		// Set the compare register arbitrarily
 12407               		.loc 1 2119 0
 12408 00de 8FEF      		ldi r24,lo8(-1)
 12409 00e0 9FEF      		ldi r25,lo8(-1)
 12410 00e2 9093 8900 		sts 136+1,r25
 12411 00e6 8093 8800 		sts 136,r24
2120:WTPA.c        **** 	OCR1B=65535;		// Set the compare register arbitrarily
 12412               		.loc 1 2120 0
 12413 00ea 9093 8B00 		sts 138+1,r25
 12414 00ee 8093 8A00 		sts 138,r24
2121:WTPA.c        **** 	TCCR1A=0;			// Normal Ports.
 12415               		.loc 1 2121 0
 12416 00f2 1092 8000 		sts 128,__zero_reg__
2122:WTPA.c        **** 	TCCR1B=0;			// Stop the timer.
 12417               		.loc 1 2122 0
 12418 00f6 1092 8100 		sts 129,__zero_reg__
2123:WTPA.c        **** 	TCNT1=0;			// Initialize the counter to 0.
 12419               		.loc 1 2123 0
 12420 00fa 1092 8500 		sts 132+1,__zero_reg__
 12421 00fe 1092 8400 		sts 132,__zero_reg__
2124:WTPA.c        **** 	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
 12422               		.loc 1 2124 0
 12423 0102 16BB      		out 0x16,r17
 12424               	.LBE981:
 12425               	.LBE980:
5009:WTPA.c        **** 	newKeys=0;
 12426               		.loc 1 5009 0
 12427 0104 1092 0000 		sts newKeys,__zero_reg__
5010:WTPA.c        **** 	keyState=0;
 12428               		.loc 1 5010 0
 12429 0108 1092 0000 		sts keyState,__zero_reg__
5011:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// No card yet
 12430               		.loc 1 5011 0
 12431 010c 1092 0000 		sts cardState,__zero_reg__
5012:WTPA.c        **** 	cardDetect=false;
 12432               		.loc 1 5012 0
 12433 0110 1092 0000 		sts cardDetect,__zero_reg__
5014:WTPA.c        **** 	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
 12434               		.loc 1 5014 0
 12435               	/* #APP */
 12436               	 ;  5014 "WTPA.c" 1
 12437 0114 7894      		sei
 12438               	 ;  0 "" 2
 12439               	.LVL615:
 12440               	/* #NOAPP */
 12441               	.LBB982:
 12442               	.LBB983:
1504:WTPA.c        **** 	State=newState;
 12443               		.loc 1 1504 0
 12444 0116 80E0      		ldi r24,lo8(gs(DoFruitcakeIntro))
 12445 0118 90E0      		ldi r25,hi8(gs(DoFruitcakeIntro))
 12446 011a 9093 0000 		sts State+1,r25
 12447 011e 8093 0000 		sts State,r24
1505:WTPA.c        **** 	subState=SS_0;
 12448               		.loc 1 1505 0
 12449 0122 1092 0000 		sts subState,__zero_reg__
 12450 0126 00E0      		ldi r16,lo8(gs(DoFormatCard))
 12451 0128 202E      		mov r2,r16
 12452 012a 00E0      		ldi r16,hi8(gs(DoFormatCard))
 12453 012c 302E      		mov r3,r16
 12454               	.LBE983:
 12455               	.LBE982:
 12456               	.LBB984:
 12457               	.LBB985:
1681:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 12458               		.loc 1 1681 0
 12459 012e 9924      		clr r9
 12460 0130 9A94      		dec r9
 12461               	.LBE985:
 12462               	.LBE984:
 12463               	.LBB989:
 12464               	.LBB990:
2696:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 12465               		.loc 1 2696 0
 12466 0132 C12C      		mov r12,__zero_reg__
 12467 0134 82E0      		ldi r24,lo8(2)
 12468 0136 D82E      		mov r13,r24
2908:WTPA.c        **** 						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
 12469               		.loc 1 2908 0
 12470 0138 9EE0      		ldi r25,lo8(14)
 12471 013a 892E      		mov r8,r25
2854:WTPA.c        **** 				cardState=SD_READ_ABORT;
 12472               		.loc 1 2854 0
 12473 013c 2DE0      		ldi r18,lo8(13)
 12474 013e 722E      		mov r7,r18
2960:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 12475               		.loc 1 2960 0
 12476 0140 3AE0      		ldi r19,lo8(10)
 12477 0142 532E      		mov r5,r19
2918:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
 12478               		.loc 1 2918 0
 12479 0144 E12C      		mov r14,__zero_reg__
 12480 0146 43E0      		ldi r20,lo8(3)
 12481 0148 F42E      		mov r15,r20
 12482               	.LBB991:
 12483               	.LBB992:
2201:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 12484               		.loc 1 2201 0
 12485 014a AA24      		clr r10
 12486 014c A394      		inc r10
 12487 014e B12C      		mov r11,__zero_reg__
 12488               	.LBE992:
 12489               	.LBE991:
2646:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
 12490               		.loc 1 2646 0
 12491 0150 66E0      		ldi r22,lo8(6)
 12492 0152 462E      		mov r4,r22
 12493 0154 00C0      		rjmp .L1420
 12494               	.L1598:
2467:WTPA.c        **** 		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
 12495               		.loc 1 2467 0
 12496 0156 8091 0000 		lds r24,cardState
 12497 015a 8111      		cpse r24,__zero_reg__
 12498 015c 00C0      		rjmp .L1594
 12499               	.L1314:
 12500               	.LBE990:
 12501               	.LBE989:
 12502               	.LBB1072:
 12503               	.LBB1073:
3653:WTPA.c        **** 	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
 12504               		.loc 1 3653 0
 12505 015e 8091 0000 		lds r24,random31
 12506 0162 9091 0000 		lds r25,random31+1
 12507 0166 A091 0000 		lds r26,random31+2
 12508 016a B091 0000 		lds r27,random31+3
3654:WTPA.c        **** 	if(random31 & 0x80000000)	// If bit31 set, do the xor.
 12509               		.loc 1 3654 0
 12510 016e AC01      		movw r20,r24
 12511 0170 BD01      		movw r22,r26
 12512 0172 440F      		lsl r20
 12513 0174 551F      		rol r21
 12514 0176 661F      		rol r22
 12515 0178 771F      		rol r23
 12516 017a B6FD      		sbrc r27,6
 12517 017c 00C0      		rjmp .L1416
 12518               	.L1593:
3656:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 12519               		.loc 1 3656 0
 12520 017e 4093 0000 		sts random31,r20
 12521 0182 5093 0000 		sts random31+1,r21
 12522 0186 6093 0000 		sts random31+2,r22
 12523 018a 7093 0000 		sts random31+3,r23
 12524               	.LBE1073:
 12525               	.LBE1072:
5030:WTPA.c        **** 		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART in
 12526               		.loc 1 5030 0
 12527 018e 0E94 0000 		call Uart0GotByte
 12528               	.LVL616:
 12529 0192 8111      		cpse r24,__zero_reg__
 12530 0194 00C0      		rjmp .L1595
 12531               	.L1418:
5035:WTPA.c        **** 		if(MidiTxBufferNotEmpty())			// Got something to say?
 12532               		.loc 1 5035 0
 12533 0196 0E94 0000 		call MidiTxBufferNotEmpty
 12534               	.LVL617:
 12535 019a 8823      		tst r24
 12536 019c 01F0      		breq .L1419
5037:WTPA.c        **** 			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
 12537               		.loc 1 5037 0
 12538 019e 8091 C000 		lds r24,192
 12539 01a2 85FD      		sbrc r24,5
 12540 01a4 00C0      		rjmp .L1596
 12541               	.L1419:
5043:WTPA.c        **** 		State();				// Execute the current program state.
 12542               		.loc 1 5043 0
 12543 01a6 E091 0000 		lds r30,State
 12544 01aa F091 0000 		lds r31,State+1
 12545 01ae 0995      		icall
 12546               	.LVL618:
 12547               	.L1420:
 12548               	.LBB1075:
 12549               	.LBB986:
1676:WTPA.c        **** 	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
 12550               		.loc 1 1676 0
 12551 01b0 81E0      		ldi r24,lo8(1)
 12552 01b2 0E94 0000 		call CheckTimer
 12553               	.LVL619:
 12554 01b6 8823      		tst r24
 12555 01b8 01F0      		breq .L1278
1679:WTPA.c        **** 		sreg=SREG;
 12556               		.loc 1 1679 0
 12557 01ba 9FB7      		in r25,__SREG__
 12558               	.LVL620:
1680:WTPA.c        **** 		cli();						// Store sreg, pause interrupts.
 12559               		.loc 1 1680 0
 12560               	/* #APP */
 12561               	 ;  1680 "WTPA.c" 1
 12562 01bc F894      		cli
 12563               	 ;  0 "" 2
1681:WTPA.c        **** 		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
 12564               		.loc 1 1681 0
 12565               	/* #NOAPP */
 12566 01be 95B8      		out 0x5,r9
1682:WTPA.c        **** 		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
 12567               		.loc 1 1682 0
 12568 01c0 14B8      		out 0x4,__zero_reg__
1683:WTPA.c        **** 		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
 12569               		.loc 1 1683 0
 12570 01c2 4398      		cbi 0x8,3
1684:WTPA.c        **** 		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
 12571               		.loc 1 1684 0
 12572               	/* #APP */
 12573               	 ;  1684 "WTPA.c" 1
 12574 01c4 0000      		nop
 12575               	 ;  0 "" 2
1685:WTPA.c        **** 		asm volatile("nop"::);
 12576               		.loc 1 1685 0
 12577               	 ;  1685 "WTPA.c" 1
 12578 01c6 0000      		nop
 12579               	 ;  0 "" 2
1686:WTPA.c        **** 		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
 12580               		.loc 1 1686 0
 12581               	/* #NOAPP */
 12582 01c8 83B1      		in r24,0x3
 12583 01ca 8095      		com r24
 12584 01cc 8093 0000 		sts keyState,r24
1687:WTPA.c        **** 		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
 12585               		.loc 1 1687 0
 12586 01d0 439A      		sbi 0x8,3
1688:WTPA.c        **** 		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
 12587               		.loc 1 1688 0
 12588 01d2 94B8      		out 0x4,r9
1689:WTPA.c        **** 		SREG=sreg;					// Stop tying up interrupts
 12589               		.loc 1 1689 0
 12590 01d4 9FBF      		out __SREG__,r25
1691:WTPA.c        **** 		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
 12591               		.loc 1 1691 0
 12592 01d6 3599      		sbic 0x6,5
 12593 01d8 00C0      		rjmp .L1279
1693:WTPA.c        **** 			cardDetect=true;
 12594               		.loc 1 1693 0
 12595 01da 81E0      		ldi r24,lo8(1)
 12596 01dc 8093 0000 		sts cardDetect,r24
 12597               	.L1280:
1700:WTPA.c        **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
 12598               		.loc 1 1700 0
 12599 01e0 66E2      		ldi r22,lo8(38)
 12600 01e2 70E0      		ldi r23,0
 12601 01e4 81E0      		ldi r24,lo8(1)
 12602 01e6 0E94 0000 		call SetTimer
 12603               	.LVL621:
 12604               	.L1278:
1703:WTPA.c        **** 	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the 
 12605               		.loc 1 1703 0
 12606 01ea 9091 0000 		lds r25,keyState
 12607 01ee 8091 0000 		lds r24,lastKeyState.1897
 12608 01f2 8095      		com r24
 12609 01f4 8923      		and r24,r25
 12610 01f6 8093 0000 		sts newKeys,r24
1704:WTPA.c        **** 	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been
 12611               		.loc 1 1704 0
 12612 01fa 8095      		com r24
 12613               	.LBE986:
 12614 01fc 8923      		and r24,r25
 12615               	.LBB987:
 12616 01fe 8093 0000 		sts keysHeld,r24
1705:WTPA.c        **** 	lastKeyState=keyState;								// And store this keystate as old news.
 12617               		.loc 1 1705 0
 12618 0202 9093 0000 		sts lastKeyState.1897,r25
 12619               	.LBE987:
 12620               	.LBE1075:
 12621               	.LBB1076:
 12622               	.LBB1077:
1749:WTPA.c        **** 	newEncoder=false;	// Clear variables which indicate changes in encoder readings
 12623               		.loc 1 1749 0
 12624 0206 1092 0000 		sts newEncoder,__zero_reg__
1750:WTPA.c        **** 	encoderCw=false;
 12625               		.loc 1 1750 0
 12626 020a 1092 0000 		sts encoderCw,__zero_reg__
1751:WTPA.c        **** 	encoderCcw=false;
 12627               		.loc 1 1751 0
 12628 020e 1092 0000 		sts encoderCcw,__zero_reg__
1753:WTPA.c        **** 	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
 12629               		.loc 1 1753 0
 12630 0212 2091 0000 		lds r18,systemTicks
 12631 0216 3091 0000 		lds r19,systemTicks+1
 12632 021a 8091 0000 		lds r24,lastEncTime.1906
 12633 021e 9091 0000 		lds r25,lastEncTime.1906+1
 12634 0222 2817      		cp r18,r24
 12635 0224 3907      		cpc r19,r25
 12636 0226 01F0      		breq .L1282
1755:WTPA.c        **** 		lastEncTime=systemTicks;					// update last read time.
 12637               		.loc 1 1755 0
 12638 0228 8091 0000 		lds r24,systemTicks
 12639 022c 9091 0000 		lds r25,systemTicks+1
 12640 0230 9093 0000 		sts lastEncTime.1906+1,r25
 12641 0234 8093 0000 		sts lastEncTime.1906,r24
1757:WTPA.c        **** 		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
 12642               		.loc 1 1757 0
 12643 0238 80B1      		in r24,0
 12644 023a 807C      		andi r24,lo8(-64)
 12645 023c 8093 0000 		sts encoderState,r24
1759:WTPA.c        **** 		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if 
 12646               		.loc 1 1759 0
 12647 0240 9091 0000 		lds r25,lastEncoderState.1905
 12648 0244 8917      		cp r24,r25
 12649 0246 01F0      		breq .L1282
1761:WTPA.c        **** 			if(encoderState==ENC_POS_A)
 12650               		.loc 1 1761 0
 12651 0248 8111      		cpse r24,__zero_reg__
 12652 024a 00C0      		rjmp .L1284
1763:WTPA.c        **** 				if(lastEncoderState==ENC_POS_D)
 12653               		.loc 1 1763 0
 12654 024c 9038      		cpi r25,lo8(-128)
 12655 024e 01F4      		brne .+2
 12656 0250 00C0      		rjmp .L1588
1770:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_B)
 12657               		.loc 1 1770 0
 12658 0252 9034      		cpi r25,lo8(64)
 12659 0254 01F4      		brne .+2
 12660 0256 00C0      		rjmp .L1587
 12661               	.L1286:
1830:WTPA.c        **** 			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
 12662               		.loc 1 1830 0
 12663 0258 8093 0000 		sts lastEncoderState.1905,r24
 12664               	.L1282:
 12665               	.LBE1077:
 12666               	.LBE1076:
 12667               	.LBB1081:
 12668               	.LBB1082:
1518:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 12669               		.loc 1 1518 0
 12670 025c A89B      		sbis 0x15,0
 12671 025e 00C0      		rjmp .L1292
 12672               	.LBB1083:
 12673               	.LBB1084:
1520:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 12674               		.loc 1 1520 0
 12675 0260 A89A      		sbi 0x15,0
1521:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 12676               		.loc 1 1521 0
 12677 0262 8091 0000 		lds r24,systemTicks
 12678 0266 9091 0000 		lds r25,systemTicks+1
 12679               	.LVL622:
 12680 026a 0196      		adiw r24,1
 12681               	.LVL623:
 12682 026c 9093 0000 		sts systemTicks+1,r25
 12683 0270 8093 0000 		sts systemTicks,r24
 12684               	.LVL624:
 12685               	.L1292:
 12686               	.LBE1084:
 12687               	.LBE1083:
 12688               	.LBE1082:
 12689               	.LBE1081:
 12690               	.LBB1085:
 12691               	.LBB1086:
1617:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
 12692               		.loc 1 1617 0
 12693 0274 8091 0000 		lds r24,ledBlinkMask
 12694               	.LVL625:
 12695 0278 8111      		cpse r24,__zero_reg__
 12696 027a 00C0      		rjmp .L1597
 12697               	.L1293:
1638:WTPA.c        **** 	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to 
 12698               		.loc 1 1638 0
 12699 027c 8091 0000 		lds r24,ledOnOffMask
 12700 0280 9091 0000 		lds r25,lastLedMask.1884
 12701 0284 9817      		cp r25,r24
 12702 0286 01F0      		breq .L1311
 12703               	.LVL626:
 12704               	.LBB1087:
 12705               	.LBB1088:
1596:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 12706               		.loc 1 1596 0
 12707 0288 9FB7      		in r25,__SREG__
 12708               	.LVL627:
1597:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 12709               		.loc 1 1597 0
 12710               	/* #APP */
 12711               	 ;  1597 "WTPA.c" 1
 12712 028a F894      		cli
 12713               	 ;  0 "" 2
1599:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 12714               		.loc 1 1599 0
 12715               	/* #NOAPP */
 12716 028c 85B9      		out 0x5,r24
1600:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 12717               		.loc 1 1600 0
 12718 028e 94B8      		out 0x4,r9
1601:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 12719               		.loc 1 1601 0
 12720 0290 5F9A      		sbi 0xb,7
1602:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 12721               		.loc 1 1602 0
 12722 0292 5F98      		cbi 0xb,7
1604:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 12723               		.loc 1 1604 0
 12724 0294 9FBF      		out __SREG__,r25
 12725               	.LBE1088:
 12726               	.LBE1087:
1641:WTPA.c        **** 		lastLedMask=ledOnOffMask;		// And mark it as sent.
 12727               		.loc 1 1641 0
 12728 0296 8091 0000 		lds r24,ledOnOffMask
 12729               	.LVL628:
 12730 029a 8093 0000 		sts lastLedMask.1884,r24
 12731               	.LVL629:
 12732               	.L1311:
 12733               	.LBE1086:
 12734               	.LBE1085:
 12735               	.LBB1093:
 12736               	.LBB1067:
2465:WTPA.c        **** 	if(cardDetect==false)		// No card in the slot?
 12737               		.loc 1 2465 0
 12738 029e 8091 0000 		lds r24,cardDetect
 12739 02a2 8823      		tst r24
 12740 02a4 01F4      		brne .+2
 12741 02a6 00C0      		rjmp .L1598
2474:WTPA.c        **** 		switch(cardState)
 12742               		.loc 1 2474 0
 12743 02a8 8091 0000 		lds r24,cardState
 12744 02ac 8630      		cpi r24,lo8(6)
 12745 02ae 01F4      		brne .+2
 12746 02b0 00C0      		rjmp .L1322
 12747 02b2 00F0      		brlo .+2
 12748 02b4 00C0      		rjmp .L1330
 12749 02b6 8230      		cpi r24,lo8(2)
 12750 02b8 01F4      		brne .+2
 12751 02ba 00C0      		rjmp .L1318
 12752 02bc 00F0      		brlo .+2
 12753 02be 00C0      		rjmp .L1331
 12754 02c0 8823      		tst r24
 12755 02c2 01F4      		brne .+2
 12756 02c4 00C0      		rjmp .L1316
 12757 02c6 8130      		cpi r24,lo8(1)
 12758 02c8 01F0      		breq .+2
 12759 02ca 00C0      		rjmp .L1314
2487:WTPA.c        **** 			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
 12760               		.loc 1 2487 0
 12761 02cc 83E0      		ldi r24,lo8(3)
 12762 02ce 0E94 0000 		call CheckTimer
 12763               	.LVL630:
 12764 02d2 8823      		tst r24
 12765 02d4 01F4      		brne .+2
 12766 02d6 00C0      		rjmp .L1314
2489:WTPA.c        **** 				sdPlaybackQueued=false;
 12767               		.loc 1 2489 0
 12768 02d8 1092 0000 		sts sdPlaybackQueued,__zero_reg__
2490:WTPA.c        **** 				sdAbortRead=false;
 12769               		.loc 1 2490 0
 12770 02dc 1092 0000 		sts sdAbortRead,__zero_reg__
2492:WTPA.c        **** 				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk
 12771               		.loc 1 2492 0
 12772 02e0 0E94 0000 		call SdHandshake
 12773               	.LVL631:
 12774 02e4 8130      		cpi r24,lo8(1)
 12775 02e6 01F4      		brne .+2
 12776 02e8 00C0      		rjmp .L1599
2515:WTPA.c        **** 					cardState=SD_INVALID;
 12777               		.loc 1 2515 0
 12778 02ea 8FE0      		ldi r24,lo8(15)
 12779 02ec 8093 0000 		sts cardState,r24
 12780 02f0 00C0      		rjmp .L1314
 12781               	.L1284:
 12782               	.LBE1067:
 12783               	.LBE1093:
 12784               	.LBB1094:
 12785               	.LBB1078:
1778:WTPA.c        **** 			else if(encoderState==ENC_POS_B)
 12786               		.loc 1 1778 0
 12787 02f2 8034      		cpi r24,lo8(64)
 12788 02f4 01F4      		brne .+2
 12789 02f6 00C0      		rjmp .L1600
1795:WTPA.c        **** 			else if(encoderState==ENC_POS_C)
 12790               		.loc 1 1795 0
 12791 02f8 803C      		cpi r24,lo8(-64)
 12792 02fa 01F4      		brne .+2
 12793 02fc 00C0      		rjmp .L1601
1812:WTPA.c        **** 			else if(encoderState==ENC_POS_D)
 12794               		.loc 1 1812 0
 12795 02fe 8038      		cpi r24,lo8(-128)
 12796 0300 01F0      		breq .+2
 12797 0302 00C0      		rjmp .L1286
1814:WTPA.c        **** 				if(lastEncoderState==ENC_POS_C)
 12798               		.loc 1 1814 0
 12799 0304 903C      		cpi r25,lo8(-64)
 12800 0306 01F4      		brne .+2
 12801 0308 00C0      		rjmp .L1588
1821:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_A)
 12802               		.loc 1 1821 0
 12803 030a 9111      		cpse r25,__zero_reg__
 12804 030c 00C0      		rjmp .L1286
 12805               	.L1587:
1824:WTPA.c        **** 					encoderValue++;
 12806               		.loc 1 1824 0
 12807 030e 9091 0000 		lds r25,encoderValue
 12808 0312 9F5F      		subi r25,lo8(-(1))
 12809 0314 9093 0000 		sts encoderValue,r25
1825:WTPA.c        **** 					encoderCw=true;
 12810               		.loc 1 1825 0
 12811 0318 91E0      		ldi r25,lo8(1)
 12812 031a 9093 0000 		sts encoderCw,r25
1826:WTPA.c        **** 					newEncoder=true;
 12813               		.loc 1 1826 0
 12814 031e 9093 0000 		sts newEncoder,r25
 12815 0322 00C0      		rjmp .L1286
 12816               	.LVL632:
 12817               	.L1279:
 12818               	.LBE1078:
 12819               	.LBE1094:
 12820               	.LBB1095:
 12821               	.LBB988:
1697:WTPA.c        **** 			cardDetect=false;
 12822               		.loc 1 1697 0
 12823 0324 1092 0000 		sts cardDetect,__zero_reg__
 12824 0328 00C0      		rjmp .L1280
 12825               	.LVL633:
 12826               	.L1595:
 12827               	.LBE988:
 12828               	.LBE1095:
5032:WTPA.c        **** 			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incomin
 12829               		.loc 1 5032 0
 12830 032a 0E94 0000 		call Uart0GetByte
 12831               	.LVL634:
 12832 032e 0E94 0000 		call HandleIncomingMidiByte
 12833               	.LVL635:
 12834 0332 00C0      		rjmp .L1418
 12835               	.L1597:
 12836               	.LBB1096:
 12837               	.LBB1091:
1617:WTPA.c        **** 	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
 12838               		.loc 1 1617 0
 12839 0334 82E0      		ldi r24,lo8(2)
 12840 0336 0E94 0000 		call CheckTimer
 12841               	.LVL636:
 12842 033a 8823      		tst r24
 12843 033c 01F4      		brne .+2
 12844 033e 00C0      		rjmp .L1293
 12845               	.LVL637:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12846               		.loc 1 1621 0
 12847 0340 2091 0000 		lds r18,ledBlinkMask
 12848 0344 822F      		mov r24,r18
 12849 0346 90E0      		ldi r25,0
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12850               		.loc 1 1623 0
 12851 0348 3091 0000 		lds r19,toggle.1883
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12852               		.loc 1 1621 0
 12853 034c 20FF      		sbrs r18,0
 12854 034e 00C0      		rjmp .L1294
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12855               		.loc 1 1625 0
 12856 0350 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12857               		.loc 1 1623 0
 12858 0354 3111      		cpse r19,__zero_reg__
 12859 0356 00C0      		rjmp .L1295
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12860               		.loc 1 1629 0
 12861 0358 4E7F      		andi r20,lo8(-2)
 12862 035a 4093 0000 		sts ledOnOffMask,r20
 12863               	.L1294:
 12864               	.LVL638:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12865               		.loc 1 1621 0
 12866 035e 21FF      		sbrs r18,1
 12867 0360 00C0      		rjmp .L1296
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12868               		.loc 1 1625 0
 12869 0362 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12870               		.loc 1 1623 0
 12871 0366 3111      		cpse r19,__zero_reg__
 12872 0368 00C0      		rjmp .L1297
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12873               		.loc 1 1629 0
 12874 036a 4D7F      		andi r20,lo8(-3)
 12875 036c 4093 0000 		sts ledOnOffMask,r20
 12876               	.L1296:
 12877               	.LVL639:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12878               		.loc 1 1621 0
 12879 0370 22FF      		sbrs r18,2
 12880 0372 00C0      		rjmp .L1298
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12881               		.loc 1 1625 0
 12882 0374 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12883               		.loc 1 1623 0
 12884 0378 3111      		cpse r19,__zero_reg__
 12885 037a 00C0      		rjmp .L1299
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12886               		.loc 1 1629 0
 12887 037c 4B7F      		andi r20,lo8(-5)
 12888 037e 4093 0000 		sts ledOnOffMask,r20
 12889               	.L1298:
 12890               	.LVL640:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12891               		.loc 1 1621 0
 12892 0382 23FF      		sbrs r18,3
 12893 0384 00C0      		rjmp .L1300
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12894               		.loc 1 1625 0
 12895 0386 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12896               		.loc 1 1623 0
 12897 038a 3111      		cpse r19,__zero_reg__
 12898 038c 00C0      		rjmp .L1301
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12899               		.loc 1 1629 0
 12900 038e 477F      		andi r20,lo8(-9)
 12901 0390 4093 0000 		sts ledOnOffMask,r20
 12902               	.L1300:
 12903               	.LVL641:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12904               		.loc 1 1621 0
 12905 0394 24FF      		sbrs r18,4
 12906 0396 00C0      		rjmp .L1302
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12907               		.loc 1 1625 0
 12908 0398 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12909               		.loc 1 1623 0
 12910 039c 3111      		cpse r19,__zero_reg__
 12911 039e 00C0      		rjmp .L1303
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12912               		.loc 1 1629 0
 12913 03a0 4F7E      		andi r20,lo8(-17)
 12914 03a2 4093 0000 		sts ledOnOffMask,r20
 12915               	.L1302:
 12916               	.LVL642:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12917               		.loc 1 1621 0
 12918 03a6 25FF      		sbrs r18,5
 12919 03a8 00C0      		rjmp .L1304
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12920               		.loc 1 1625 0
 12921 03aa 4091 0000 		lds r20,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12922               		.loc 1 1623 0
 12923 03ae 3111      		cpse r19,__zero_reg__
 12924 03b0 00C0      		rjmp .L1305
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12925               		.loc 1 1629 0
 12926 03b2 4F7D      		andi r20,lo8(-33)
 12927 03b4 4093 0000 		sts ledOnOffMask,r20
 12928               	.L1304:
 12929               	.LVL643:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12930               		.loc 1 1621 0
 12931 03b8 26FF      		sbrs r18,6
 12932 03ba 00C0      		rjmp .L1306
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12933               		.loc 1 1625 0
 12934 03bc 2091 0000 		lds r18,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12935               		.loc 1 1623 0
 12936 03c0 3111      		cpse r19,__zero_reg__
 12937 03c2 00C0      		rjmp .L1307
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12938               		.loc 1 1629 0
 12939 03c4 2F7B      		andi r18,lo8(-65)
 12940 03c6 2093 0000 		sts ledOnOffMask,r18
 12941               	.L1306:
 12942               	.LVL644:
1621:WTPA.c        **** 			if(ledBlinkMask&(1<<i))
 12943               		.loc 1 1621 0
 12944 03ca 880F      		lsl r24
 12945 03cc 892F      		mov r24,r25
 12946 03ce 881F      		rol r24
 12947 03d0 990B      		sbc r25,r25
 12948 03d2 892B      		or r24,r25
 12949 03d4 01F0      		breq .L1308
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 12950               		.loc 1 1625 0
 12951 03d6 8091 0000 		lds r24,ledOnOffMask
1623:WTPA.c        **** 				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
 12952               		.loc 1 1623 0
 12953 03da 3111      		cpse r19,__zero_reg__
 12954 03dc 00C0      		rjmp .L1309
1629:WTPA.c        **** 					ledOnOffMask&=~(1<<i);
 12955               		.loc 1 1629 0
 12956 03de 8F77      		andi r24,lo8(127)
 12957 03e0 8093 0000 		sts ledOnOffMask,r24
 12958               	.L1308:
 12959               	.LVL645:
1634:WTPA.c        **** 		toggle=(!toggle);						// flip the sign of the led for next time.
 12960               		.loc 1 1634 0
 12961 03e4 81E0      		ldi r24,lo8(1)
 12962 03e6 3111      		cpse r19,__zero_reg__
 12963 03e8 80E0      		ldi r24,0
 12964               	.L1310:
 12965 03ea 8093 0000 		sts toggle.1883,r24
1635:WTPA.c        **** 		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
 12966               		.loc 1 1635 0
 12967 03ee 68E9      		ldi r22,lo8(-104)
 12968 03f0 70E0      		ldi r23,0
 12969 03f2 82E0      		ldi r24,lo8(2)
 12970 03f4 0E94 0000 		call SetTimer
 12971               	.LVL646:
1636:WTPA.c        **** 		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
 12972               		.loc 1 1636 0
 12973 03f8 9091 0000 		lds r25,ledOnOffMask
 12974               	.LVL647:
 12975               	.LBB1089:
 12976               	.LBB1090:
1596:WTPA.c        **** 	sreg=SREG;	// Store global interrupt state
 12977               		.loc 1 1596 0
 12978 03fc 8FB7      		in r24,__SREG__
 12979               	.LVL648:
1597:WTPA.c        **** 	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and W
 12980               		.loc 1 1597 0
 12981               	/* #APP */
 12982               	 ;  1597 "WTPA.c" 1
 12983 03fe F894      		cli
 12984               	 ;  0 "" 2
1599:WTPA.c        **** 	LATCH_PORT=theMask;				// Put passed data onto bus.
 12985               		.loc 1 1599 0
 12986               	/* #NOAPP */
 12987 0400 95B9      		out 0x5,r25
1600:WTPA.c        **** 	LATCH_DDR=0xFF;					// Make sure the bus is an output.
 12988               		.loc 1 1600 0
 12989 0402 94B8      		out 0x4,r9
1601:WTPA.c        **** 	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
 12990               		.loc 1 1601 0
 12991 0404 5F9A      		sbi 0xb,7
1602:WTPA.c        **** 	PORTD&=~(Om_LED_LA);			// ...Keep it there.
 12992               		.loc 1 1602 0
 12993 0406 5F98      		cbi 0xb,7
1604:WTPA.c        **** 	SREG=sreg;						// Restore interrupts.
 12994               		.loc 1 1604 0
 12995 0408 8FBF      		out __SREG__,r24
 12996 040a 00C0      		rjmp .L1311
 12997               	.LVL649:
 12998               	.L1416:
 12999               	.LBE1090:
 13000               	.LBE1089:
 13001               	.LBE1091:
 13002               	.LBE1096:
 13003               	.LBB1097:
 13004               	.LBB1074:
3656:WTPA.c        **** 		random31^=0x20AA95B5;	//xor magic number (taps)
 13005               		.loc 1 3656 0
 13006 040c 85EB      		ldi r24,181
 13007 040e 4827      		eor r20,r24
 13008 0410 85E9      		ldi r24,149
 13009 0412 5827      		eor r21,r24
 13010 0414 8AEA      		ldi r24,170
 13011 0416 6827      		eor r22,r24
 13012 0418 80E2      		ldi r24,32
 13013 041a 7827      		eor r23,r24
 13014 041c 00C0      		rjmp .L1593
 13015               	.L1330:
 13016               	.LBE1074:
 13017               	.LBE1097:
 13018               	.LBB1098:
 13019               	.LBB1068:
2474:WTPA.c        **** 		switch(cardState)
 13020               		.loc 1 2474 0
 13021 041e 8A30      		cpi r24,lo8(10)
 13022 0420 01F4      		brne .+2
 13023 0422 00C0      		rjmp .L1326
 13024 0424 00F0      		brlo .+2
 13025 0426 00C0      		rjmp .L1332
 13026 0428 8830      		cpi r24,lo8(8)
 13027 042a 01F4      		brne .+2
 13028 042c 00C0      		rjmp .L1324
 13029 042e 00F4      		brsh .+2
 13030 0430 00C0      		rjmp .L1602
2804:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 13031               		.loc 1 2804 0
 13032 0432 83E0      		ldi r24,lo8(3)
 13033 0434 0E94 0000 		call CheckTimer
 13034               	.LVL650:
 13035 0438 8111      		cpse r24,__zero_reg__
 13036 043a 00C0      		rjmp .L1389
2809:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13037               		.loc 1 2809 0
 13038 043c 8FEF      		ldi r24,lo8(-1)
 13039 043e 0E94 0000 		call TransferSdByte
 13040               	.LVL651:
2810:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 13041               		.loc 1 2810 0
 13042 0442 8F3F      		cpi r24,lo8(-1)
 13043 0444 01F4      		brne .+2
 13044 0446 00C0      		rjmp .L1603
 13045               	.L1390:
2820:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 13046               		.loc 1 2820 0
 13047 0448 8E3F      		cpi r24,lo8(-2)
 13048 044a 01F4      		brne .+2
 13049 044c 00C0      		rjmp .L1604
 13050               	.L1391:
2840:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
 13051               		.loc 1 2840 0
 13052 044e 8F3F      		cpi r24,lo8(-1)
 13053 0450 01F4      		brne .+2
 13054 0452 00C0      		rjmp .L1314
 13055               	.LBB994:
 13056               	.LBB995:
2423:WTPA.c        **** 	sreg=SREG;
 13057               		.loc 1 2423 0
 13058 0454 1FB7      		in r17,__SREG__
 13059               	.LVL652:
2424:WTPA.c        **** 	cli();
 13060               		.loc 1 2424 0
 13061               	/* #APP */
 13062               	 ;  2424 "WTPA.c" 1
 13063 0456 F894      		cli
 13064               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13065               		.loc 1 2426 0
 13066               	/* #NOAPP */
 13067 0458 0E94 0000 		call EndSdTransfer
 13068               	.LVL653:
 13069 045c E0E0      		ldi r30,lo8(sampleToc)
 13070 045e F0E0      		ldi r31,hi8(sampleToc)
 13071               	.LVL654:
 13072               	.L1392:
 13073               	.LBB996:
 13074               	.LBB997:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13075               		.loc 1 2166 0
 13076 0460 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13077               		.loc 1 2164 0
 13078 0462 90E0      		ldi r25,hi8(sampleToc+64)
 13079 0464 E030      		cpi r30,lo8(sampleToc+64)
 13080 0466 F907      		cpc r31,r25
 13081 0468 01F4      		brne .L1392
 13082               	.LVL655:
 13083               	.L1589:
 13084               	.LBE997:
 13085               	.LBE996:
 13086               	.LBE995:
 13087               	.LBE994:
 13088               	.LBB998:
 13089               	.LBB999:
2431:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
 13090               		.loc 1 2431 0
 13091 046a 1092 0000 		sts sdIsrState,__zero_reg__
2432:WTPA.c        **** 	TCCR2B=0;					// Stop this timer
 13092               		.loc 1 2432 0
 13093 046e 1092 B100 		sts 177,__zero_reg__
2433:WTPA.c        **** 	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
 13094               		.loc 1 2433 0
 13095 0472 8091 7000 		lds r24,112
 13096 0476 8B7F      		andi r24,lo8(-5)
 13097 0478 8093 7000 		sts 112,r24
2436:WTPA.c        **** 	sdStreamOutput=0;
 13098               		.loc 1 2436 0
 13099 047c 1092 0000 		sts sdStreamOutput,__zero_reg__
2438:WTPA.c        **** 	sdFifoReadPointer=0;		// Reset FIFO variables
 13100               		.loc 1 2438 0
 13101 0480 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 13102 0484 1092 0000 		sts sdFifoReadPointer,__zero_reg__
2439:WTPA.c        **** 	sdFifoWritePointer=0;
 13103               		.loc 1 2439 0
 13104 0488 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 13105 048c 1092 0000 		sts sdFifoWritePointer,__zero_reg__
2440:WTPA.c        **** 	sdBytesInFifo=0;
 13106               		.loc 1 2440 0
 13107 0490 1092 0000 		sts sdBytesInFifo+1,__zero_reg__
 13108 0494 1092 0000 		sts sdBytesInFifo,__zero_reg__
2442:WTPA.c        **** 	InitSdInterface();
 13109               		.loc 1 2442 0
 13110 0498 0E94 0000 		call InitSdInterface
 13111               	.LVL656:
2443:WTPA.c        **** 	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
 13112               		.loc 1 2443 0
 13113 049c 1092 0000 		sts cardState,__zero_reg__
2445:WTPA.c        **** 	SREG=sreg;
 13114               		.loc 1 2445 0
 13115 04a0 1FBF      		out __SREG__,r17
 13116 04a2 00C0      		rjmp .L1314
 13117               	.L1588:
 13118               	.LBE999:
 13119               	.LBE998:
 13120               	.LBE1068:
 13121               	.LBE1098:
 13122               	.LBB1099:
 13123               	.LBB1079:
1817:WTPA.c        **** 					encoderValue--;
 13124               		.loc 1 1817 0
 13125 04a4 9091 0000 		lds r25,encoderValue
 13126 04a8 9150      		subi r25,lo8(-(-1))
 13127 04aa 9093 0000 		sts encoderValue,r25
1818:WTPA.c        **** 					encoderCcw=true;
 13128               		.loc 1 1818 0
 13129 04ae 91E0      		ldi r25,lo8(1)
 13130 04b0 9093 0000 		sts encoderCcw,r25
1819:WTPA.c        **** 					newEncoder=true;
 13131               		.loc 1 1819 0
 13132 04b4 9093 0000 		sts newEncoder,r25
 13133 04b8 00C0      		rjmp .L1286
 13134               	.L1596:
 13135               	.LBE1079:
 13136               	.LBE1099:
5039:WTPA.c        **** 				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
 13137               		.loc 1 5039 0
 13138 04ba 0E94 0000 		call PopOutgoingMidiByte
 13139               	.LVL657:
 13140 04be 8093 C600 		sts 198,r24
 13141 04c2 00C0      		rjmp .L1419
 13142               	.L1594:
 13143               	.LBB1100:
 13144               	.LBB1069:
 13145               	.LBB1003:
 13146               	.LBB1004:
2423:WTPA.c        **** 	sreg=SREG;
 13147               		.loc 1 2423 0
 13148 04c4 1FB7      		in r17,__SREG__
 13149               	.LVL658:
2424:WTPA.c        **** 	cli();
 13150               		.loc 1 2424 0
 13151               	/* #APP */
 13152               	 ;  2424 "WTPA.c" 1
 13153 04c6 F894      		cli
 13154               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13155               		.loc 1 2426 0
 13156               	/* #NOAPP */
 13157 04c8 0E94 0000 		call EndSdTransfer
 13158               	.LVL659:
 13159 04cc E0E0      		ldi r30,lo8(sampleToc)
 13160 04ce F0E0      		ldi r31,hi8(sampleToc)
 13161               	.LVL660:
 13162               	.L1315:
 13163               	.LBB1005:
 13164               	.LBB1006:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13165               		.loc 1 2166 0
 13166 04d0 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13167               		.loc 1 2164 0
 13168 04d2 20E0      		ldi r18,hi8(sampleToc+64)
 13169 04d4 E030      		cpi r30,lo8(sampleToc+64)
 13170 04d6 F207      		cpc r31,r18
 13171 04d8 01F4      		brne .L1315
 13172 04da 00C0      		rjmp .L1589
 13173               	.LVL661:
 13174               	.L1600:
 13175               	.LBE1006:
 13176               	.LBE1005:
 13177               	.LBE1004:
 13178               	.LBE1003:
 13179               	.LBE1069:
 13180               	.LBE1100:
 13181               	.LBB1101:
 13182               	.LBB1080:
1780:WTPA.c        **** 				if(lastEncoderState==ENC_POS_A)
 13183               		.loc 1 1780 0
 13184 04dc 9923      		tst r25
 13185 04de 01F0      		breq .L1588
1787:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_C)
 13186               		.loc 1 1787 0
 13187 04e0 903C      		cpi r25,lo8(-64)
 13188 04e2 01F0      		breq .+2
 13189 04e4 00C0      		rjmp .L1286
 13190 04e6 00C0      		rjmp .L1587
 13191               	.L1601:
1797:WTPA.c        **** 				if(lastEncoderState==ENC_POS_B)
 13192               		.loc 1 1797 0
 13193 04e8 9034      		cpi r25,lo8(64)
 13194 04ea 01F0      		breq .L1588
1804:WTPA.c        **** 				else if(lastEncoderState==ENC_POS_D)
 13195               		.loc 1 1804 0
 13196 04ec 9038      		cpi r25,lo8(-128)
 13197 04ee 01F0      		breq .+2
 13198 04f0 00C0      		rjmp .L1286
 13199 04f2 00C0      		rjmp .L1587
 13200               	.L1331:
 13201               	.LBE1080:
 13202               	.LBE1101:
 13203               	.LBB1102:
 13204               	.LBB1070:
2474:WTPA.c        **** 		switch(cardState)
 13205               		.loc 1 2474 0
 13206 04f4 8430      		cpi r24,lo8(4)
 13207 04f6 01F4      		brne .+2
 13208 04f8 00C0      		rjmp .L1320
 13209 04fa 00F4      		brsh .+2
 13210 04fc 00C0      		rjmp .L1605
2662:WTPA.c        **** 			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
 13211               		.loc 1 2662 0
 13212 04fe 2FB7      		in r18,__SREG__
 13213               	.LVL662:
2663:WTPA.c        **** 			cli();
 13214               		.loc 1 2663 0
 13215               	/* #APP */
 13216               	 ;  2663 "WTPA.c" 1
 13217 0500 F894      		cli
 13218               	 ;  0 "" 2
2664:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 13219               		.loc 1 2664 0
 13220               	/* #NOAPP */
 13221 0502 8091 0000 		lds r24,sdBytesInFifo
 13222 0506 9091 0000 		lds r25,sdBytesInFifo+1
 13223 050a 8115      		cp r24,__zero_reg__
 13224 050c 9240      		sbci r25,2
 13225 050e 00F4      		brsh .L1373
 13226 0510 8091 0000 		lds r24,sdBytesInFifo
 13227 0514 9091 0000 		lds r25,sdBytesInFifo+1
 13228 0518 4091 0000 		lds r20,sdCardSampleRemaining
 13229 051c 5091 0000 		lds r21,sdCardSampleRemaining+1
 13230 0520 6091 0000 		lds r22,sdCardSampleRemaining+2
 13231 0524 7091 0000 		lds r23,sdCardSampleRemaining+3
 13232 0528 A0E0      		ldi r26,0
 13233 052a B0E0      		ldi r27,0
 13234 052c 8417      		cp r24,r20
 13235 052e 9507      		cpc r25,r21
 13236 0530 A607      		cpc r26,r22
 13237 0532 B707      		cpc r27,r23
 13238 0534 00F4      		brsh .+2
 13239 0536 00C0      		rjmp .L1403
 13240               	.L1373:
2666:WTPA.c        **** 				SREG=sreg;																	// Done reading ISR variables.
 13241               		.loc 1 2666 0
 13242 0538 2FBF      		out __SREG__,r18
2667:WTPA.c        **** 				sdCurrentBlockOffset++;		// On to the next
 13243               		.loc 1 2667 0
 13244 053a 2091 0000 		lds r18,sdCurrentBlockOffset
 13245 053e 3091 0000 		lds r19,sdCurrentBlockOffset+1
 13246               	.LVL663:
 13247 0542 2F5F      		subi r18,-1
 13248 0544 3F4F      		sbci r19,-1
 13249 0546 3093 0000 		sts sdCurrentBlockOffset+1,r19
 13250 054a 2093 0000 		sts sdCurrentBlockOffset,r18
2669:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the c
 13251               		.loc 1 2669 0
 13252 054e 6091 0000 		lds r22,sdSampleStartBlock
 13253 0552 7091 0000 		lds r23,sdSampleStartBlock+1
 13254 0556 8091 0000 		lds r24,sdSampleStartBlock+2
 13255 055a 9091 0000 		lds r25,sdSampleStartBlock+3
 13256 055e 620F      		add r22,r18
 13257 0560 731F      		adc r23,r19
 13258 0562 811D      		adc r24,__zero_reg__
 13259 0564 911D      		adc r25,__zero_reg__
 13260 0566 0E94 0000 		call SdBeginSingleBlockWrite
 13261               	.LVL664:
 13262 056a 8130      		cpi r24,lo8(1)
 13263 056c 01F4      		brne .+2
 13264 056e 00C0      		rjmp .L1606
 13265               	.LBB1007:
 13266               	.LBB1008:
2423:WTPA.c        **** 	sreg=SREG;
 13267               		.loc 1 2423 0
 13268 0570 1FB7      		in r17,__SREG__
 13269               	.LVL665:
2424:WTPA.c        **** 	cli();
 13270               		.loc 1 2424 0
 13271               	/* #APP */
 13272               	 ;  2424 "WTPA.c" 1
 13273 0572 F894      		cli
 13274               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13275               		.loc 1 2426 0
 13276               	/* #NOAPP */
 13277 0574 0E94 0000 		call EndSdTransfer
 13278               	.LVL666:
 13279 0578 E0E0      		ldi r30,lo8(sampleToc)
 13280 057a F0E0      		ldi r31,hi8(sampleToc)
 13281               	.LVL667:
 13282               	.L1376:
 13283               	.LBB1009:
 13284               	.LBB1010:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13285               		.loc 1 2166 0
 13286 057c 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13287               		.loc 1 2164 0
 13288 057e 50E0      		ldi r21,hi8(sampleToc+64)
 13289 0580 E030      		cpi r30,lo8(sampleToc+64)
 13290 0582 F507      		cpc r31,r21
 13291 0584 01F4      		brne .L1376
 13292 0586 00C0      		rjmp .L1589
 13293               	.LVL668:
 13294               	.L1332:
 13295               	.LBE1010:
 13296               	.LBE1009:
 13297               	.LBE1008:
 13298               	.LBE1007:
2474:WTPA.c        **** 		switch(cardState)
 13299               		.loc 1 2474 0
 13300 0588 8C30      		cpi r24,lo8(12)
 13301 058a 01F4      		brne .+2
 13302 058c 00C0      		rjmp .L1328
 13303 058e 00F4      		brsh .+2
 13304 0590 00C0      		rjmp .L1327
 13305 0592 8D30      		cpi r24,lo8(13)
 13306 0594 01F0      		breq .+2
 13307 0596 00C0      		rjmp .L1314
2979:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
 13308               		.loc 1 2979 0
 13309 0598 8091 0000 		lds r24,bytesLeftInBlock.2026
 13310 059c 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13311 05a0 8C01      		movw r16,r24
 13312 05a2 8134      		cpi r24,65
 13313 05a4 9105      		cpc r25,__zero_reg__
 13314 05a6 00F0      		brlo .L1411
 13315 05a8 00E4      		ldi r16,lo8(64)
 13316 05aa 10E0      		ldi r17,0
 13317               	.L1411:
 13318               	.LVL669:
2988:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 13319               		.loc 1 2988 0
 13320 05ac 0115      		cp r16,__zero_reg__
 13321 05ae 1105      		cpc r17,__zero_reg__
 13322 05b0 01F0      		breq .L1412
 13323 05b2 612C      		mov r6,__zero_reg__
 13324               	.LVL670:
 13325               	.L1413:
2990:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
 13326               		.loc 1 2990 0
 13327 05b4 8FEF      		ldi r24,lo8(-1)
 13328 05b6 0E94 0000 		call TransferSdByte
 13329               	.LVL671:
2991:WTPA.c        **** 				bytesLeftInBlock--;				// One less byte in the block read.
 13330               		.loc 1 2991 0
 13331 05ba 8091 0000 		lds r24,bytesLeftInBlock.2026
 13332 05be 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13333 05c2 0197      		sbiw r24,1
 13334 05c4 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 13335 05c8 8093 0000 		sts bytesLeftInBlock.2026,r24
2988:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zer
 13336               		.loc 1 2988 0
 13337 05cc 6394      		inc r6
 13338               	.LVL672:
 13339 05ce 262D      		mov r18,r6
 13340 05d0 30E0      		ldi r19,0
 13341 05d2 2017      		cp r18,r16
 13342 05d4 3107      		cpc r19,r17
 13343 05d6 00F0      		brlo .L1413
 13344               	.LVL673:
 13345               	.L1412:
2995:WTPA.c        **** 			if(bytesLeftInBlock==0)				// Handle closing this block
 13346               		.loc 1 2995 0
 13347 05d8 892B      		or r24,r25
 13348 05da 01F0      		breq .+2
 13349 05dc 00C0      		rjmp .L1314
2997:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 13350               		.loc 1 2997 0
 13351 05de 8FEF      		ldi r24,lo8(-1)
 13352 05e0 0E94 0000 		call TransferSdByte
 13353               	.LVL674:
2998:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 13354               		.loc 1 2998 0
 13355 05e4 8FEF      		ldi r24,lo8(-1)
 13356 05e6 0E94 0000 		call TransferSdByte
 13357               	.LVL675:
 13358               	.L1414:
2999:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 13359               		.loc 1 2999 0
 13360 05ea 8091 C800 		lds r24,200
 13361 05ee 86FF      		sbrs r24,6
 13362 05f0 00C0      		rjmp .L1414
3002:WTPA.c        **** 				EndSdTransfer();				// Bring CS high
 13363               		.loc 1 3002 0
 13364 05f2 0E94 0000 		call EndSdTransfer
 13365               	.LVL676:
3003:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to wh
 13366               		.loc 1 3003 0
 13367 05f6 8FEF      		ldi r24,lo8(-1)
 13368 05f8 0E94 0000 		call TransferSdByte
 13369               	.LVL677:
 13370               	.L1415:
3005:WTPA.c        **** 				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 13371               		.loc 1 3005 0
 13372 05fc 8091 C800 		lds r24,200
 13373 0600 86FF      		sbrs r24,6
 13374 0602 00C0      		rjmp .L1415
3007:WTPA.c        **** 				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
 13375               		.loc 1 3007 0
 13376 0604 8092 0000 		sts cardState,r8
3009:WTPA.c        **** 				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
 13377               		.loc 1 3009 0
 13378 0608 8091 0000 		lds r24,sdPlaybackQueued
 13379 060c 8130      		cpi r24,lo8(1)
 13380 060e 01F0      		breq .+2
 13381 0610 00C0      		rjmp .L1314
3011:WTPA.c        **** 					sdPlaybackQueued=false;
 13382               		.loc 1 3011 0
 13383 0612 1092 0000 		sts sdPlaybackQueued,__zero_reg__
3012:WTPA.c        **** 					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
 13384               		.loc 1 3012 0
 13385 0616 8091 0000 		lds r24,sdQueuedSlot
 13386 061a 9091 0000 		lds r25,sdQueuedSlot+1
 13387 061e 0E94 0000 		call PlaySampleFromSd
 13388               	.LVL678:
 13389 0622 00C0      		rjmp .L1314
 13390               	.LVL679:
 13391               	.L1303:
 13392               	.LBE1070:
 13393               	.LBE1102:
 13394               	.LBB1103:
 13395               	.LBB1092:
1625:WTPA.c        **** 					ledOnOffMask|=(1<<i);
 13396               		.loc 1 1625 0
 13397 0624 4061      		ori r20,lo8(16)
 13398 0626 4093 0000 		sts ledOnOffMask,r20
 13399 062a 00C0      		rjmp .L1302
 13400               	.LVL680:
 13401               	.L1305:
 13402 062c 4062      		ori r20,lo8(32)
 13403 062e 4093 0000 		sts ledOnOffMask,r20
 13404 0632 00C0      		rjmp .L1304
 13405               	.LVL681:
 13406               	.L1307:
 13407 0634 2064      		ori r18,lo8(64)
 13408 0636 2093 0000 		sts ledOnOffMask,r18
 13409 063a 00C0      		rjmp .L1306
 13410               	.LVL682:
 13411               	.L1309:
 13412 063c 8068      		ori r24,lo8(-128)
 13413 063e 8093 0000 		sts ledOnOffMask,r24
 13414 0642 00C0      		rjmp .L1308
 13415               	.LVL683:
 13416               	.L1295:
 13417 0644 4160      		ori r20,lo8(1)
 13418 0646 4093 0000 		sts ledOnOffMask,r20
 13419 064a 00C0      		rjmp .L1294
 13420               	.LVL684:
 13421               	.L1297:
 13422 064c 4260      		ori r20,lo8(2)
 13423 064e 4093 0000 		sts ledOnOffMask,r20
 13424 0652 00C0      		rjmp .L1296
 13425               	.LVL685:
 13426               	.L1299:
 13427 0654 4460      		ori r20,lo8(4)
 13428 0656 4093 0000 		sts ledOnOffMask,r20
 13429 065a 00C0      		rjmp .L1298
 13430               	.LVL686:
 13431               	.L1301:
 13432 065c 4860      		ori r20,lo8(8)
 13433 065e 4093 0000 		sts ledOnOffMask,r20
 13434 0662 00C0      		rjmp .L1300
 13435               	.LVL687:
 13436               	.L1327:
 13437               	.LBE1092:
 13438               	.LBE1103:
 13439               	.LBB1104:
 13440               	.LBB1071:
2915:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 13441               		.loc 1 2915 0
 13442 0664 2FB7      		in r18,__SREG__
 13443               	.LVL688:
2916:WTPA.c        **** 			cli();
 13444               		.loc 1 2916 0
 13445               	/* #APP */
 13446               	 ;  2916 "WTPA.c" 1
 13447 0666 F894      		cli
 13448               	 ;  0 "" 2
2918:WTPA.c        **** 			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleR
 13449               		.loc 1 2918 0
 13450               	/* #NOAPP */
 13451 0668 8091 0000 		lds r24,sdBytesInFifo
 13452 066c 9091 0000 		lds r25,sdBytesInFifo+1
 13453 0670 F701      		movw r30,r14
 13454 0672 E81B      		sub r30,r24
 13455 0674 F90B      		sbc r31,r25
 13456 0676 CF01      		movw r24,r30
 13457 0678 8115      		cp r24,__zero_reg__
 13458 067a 9240      		sbci r25,2
 13459 067c 00F4      		brsh .L1402
 13460 067e 8091 0000 		lds r24,sdBytesInFifo
 13461 0682 9091 0000 		lds r25,sdBytesInFifo+1
 13462 0686 4091 0000 		lds r20,sdCardSampleRemaining
 13463 068a 5091 0000 		lds r21,sdCardSampleRemaining+1
 13464 068e 6091 0000 		lds r22,sdCardSampleRemaining+2
 13465 0692 7091 0000 		lds r23,sdCardSampleRemaining+3
 13466 0696 F701      		movw r30,r14
 13467 0698 E81B      		sub r30,r24
 13468 069a F90B      		sbc r31,r25
 13469 069c CF01      		movw r24,r30
 13470 069e A0E0      		ldi r26,0
 13471 06a0 B0E0      		ldi r27,0
 13472 06a2 8417      		cp r24,r20
 13473 06a4 9507      		cpc r25,r21
 13474 06a6 A607      		cpc r26,r22
 13475 06a8 B707      		cpc r27,r23
 13476 06aa 00F4      		brsh .+2
 13477 06ac 00C0      		rjmp .L1403
 13478               	.L1402:
2920:WTPA.c        **** 				SREG=sreg;				// ISR back on.
 13479               		.loc 1 2920 0
 13480 06ae 2FBF      		out __SREG__,r18
2921:WTPA.c        **** 				sdCurrentBlockOffset++;	// Point at next block
 13481               		.loc 1 2921 0
 13482 06b0 2091 0000 		lds r18,sdCurrentBlockOffset
 13483 06b4 3091 0000 		lds r19,sdCurrentBlockOffset+1
 13484               	.LVL689:
 13485 06b8 2F5F      		subi r18,-1
 13486 06ba 3F4F      		sbci r19,-1
 13487 06bc 3093 0000 		sts sdCurrentBlockOffset+1,r19
 13488 06c0 2093 0000 		sts sdCurrentBlockOffset,r18
2923:WTPA.c        **** 				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the ca
 13489               		.loc 1 2923 0
 13490 06c4 6091 0000 		lds r22,sdSampleStartBlock
 13491 06c8 7091 0000 		lds r23,sdSampleStartBlock+1
 13492 06cc 8091 0000 		lds r24,sdSampleStartBlock+2
 13493 06d0 9091 0000 		lds r25,sdSampleStartBlock+3
 13494 06d4 620F      		add r22,r18
 13495 06d6 731F      		adc r23,r19
 13496 06d8 811D      		adc r24,__zero_reg__
 13497 06da 911D      		adc r25,__zero_reg__
 13498 06dc 0E94 0000 		call SdBeginSingleBlockRead
 13499               	.LVL690:
 13500 06e0 8130      		cpi r24,lo8(1)
 13501 06e2 01F4      		brne .+2
 13502 06e4 00C0      		rjmp .L1607
 13503               	.LBB1011:
 13504               	.LBB1012:
2423:WTPA.c        **** 	sreg=SREG;
 13505               		.loc 1 2423 0
 13506 06e6 1FB7      		in r17,__SREG__
 13507               	.LVL691:
2424:WTPA.c        **** 	cli();
 13508               		.loc 1 2424 0
 13509               	/* #APP */
 13510               	 ;  2424 "WTPA.c" 1
 13511 06e8 F894      		cli
 13512               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13513               		.loc 1 2426 0
 13514               	/* #NOAPP */
 13515 06ea 0E94 0000 		call EndSdTransfer
 13516               	.LVL692:
 13517 06ee E0E0      		ldi r30,lo8(sampleToc)
 13518 06f0 F0E0      		ldi r31,hi8(sampleToc)
 13519               	.LVL693:
 13520               	.L1405:
 13521               	.LBB1013:
 13522               	.LBB1014:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13523               		.loc 1 2166 0
 13524 06f2 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13525               		.loc 1 2164 0
 13526 06f4 20E0      		ldi r18,hi8(sampleToc+64)
 13527 06f6 E030      		cpi r30,lo8(sampleToc+64)
 13528 06f8 F207      		cpc r31,r18
 13529 06fa 01F4      		brne .L1405
 13530 06fc 00C0      		rjmp .L1589
 13531               	.LVL694:
 13532               	.L1328:
 13533               	.LBE1014:
 13534               	.LBE1013:
 13535               	.LBE1012:
 13536               	.LBE1011:
2941:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
 13537               		.loc 1 2941 0
 13538 06fe 83E0      		ldi r24,lo8(3)
 13539 0700 0E94 0000 		call CheckTimer
 13540               	.LVL695:
 13541 0704 8111      		cpse r24,__zero_reg__
 13542 0706 00C0      		rjmp .L1406
2946:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13543               		.loc 1 2946 0
 13544 0708 8FEF      		ldi r24,lo8(-1)
 13545 070a 0E94 0000 		call TransferSdByte
 13546               	.LVL696:
2947:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 13547               		.loc 1 2947 0
 13548 070e 8F3F      		cpi r24,lo8(-1)
 13549 0710 01F4      		brne .+2
 13550 0712 00C0      		rjmp .L1608
 13551               	.L1407:
2956:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 13552               		.loc 1 2956 0
 13553 0714 8E3F      		cpi r24,lo8(-2)
 13554 0716 01F4      		brne .+2
 13555 0718 00C0      		rjmp .L1609
2967:WTPA.c        **** 				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
 13556               		.loc 1 2967 0
 13557 071a 8F3F      		cpi r24,lo8(-1)
 13558 071c 01F4      		brne .+2
 13559 071e 00C0      		rjmp .L1314
 13560               	.LBB1015:
 13561               	.LBB1016:
2423:WTPA.c        **** 	sreg=SREG;
 13562               		.loc 1 2423 0
 13563 0720 1FB7      		in r17,__SREG__
 13564               	.LVL697:
2424:WTPA.c        **** 	cli();
 13565               		.loc 1 2424 0
 13566               	/* #APP */
 13567               	 ;  2424 "WTPA.c" 1
 13568 0722 F894      		cli
 13569               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13570               		.loc 1 2426 0
 13571               	/* #NOAPP */
 13572 0724 0E94 0000 		call EndSdTransfer
 13573               	.LVL698:
 13574 0728 E0E0      		ldi r30,lo8(sampleToc)
 13575 072a F0E0      		ldi r31,hi8(sampleToc)
 13576               	.LVL699:
 13577               	.L1409:
 13578               	.LBB1017:
 13579               	.LBB1018:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13580               		.loc 1 2166 0
 13581 072c 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13582               		.loc 1 2164 0
 13583 072e 30E0      		ldi r19,hi8(sampleToc+64)
 13584 0730 E030      		cpi r30,lo8(sampleToc+64)
 13585 0732 F307      		cpc r31,r19
 13586 0734 01F4      		brne .L1409
 13587 0736 00C0      		rjmp .L1589
 13588               	.LVL700:
 13589               	.L1605:
 13590               	.LBE1018:
 13591               	.LBE1017:
 13592               	.LBE1016:
 13593               	.LBE1015:
2558:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
 13594               		.loc 1 2558 0
 13595 0738 8091 0000 		lds r24,bytesLeftInBlock.2026
 13596 073c 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13597 0740 8C01      		movw r16,r24
 13598 0742 8134      		cpi r24,65
 13599 0744 9105      		cpc r25,__zero_reg__
 13600 0746 00F0      		brlo .L1358
 13601 0748 00E4      		ldi r16,lo8(64)
 13602 074a 10E0      		ldi r17,0
 13603               	.L1358:
 13604               	.LVL701:
2567:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 13605               		.loc 1 2567 0
 13606 074c 0115      		cp r16,__zero_reg__
 13607 074e 1105      		cpc r17,__zero_reg__
 13608 0750 01F4      		brne .+2
 13609 0752 00C0      		rjmp .L1359
 13610 0754 612C      		mov r6,__zero_reg__
 13611 0756 00C0      		rjmp .L1363
 13612               	.LVL702:
 13613               	.L1610:
2571:WTPA.c        **** 					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
 13614               		.loc 1 2571 0
 13615 0758 E091 0000 		lds r30,sdFifoReadPointer
 13616 075c F091 0000 		lds r31,sdFifoReadPointer+1
 13617 0760 E050      		subi r30,lo8(-(sdFifo))
 13618 0762 F040      		sbci r31,hi8(-(sdFifo))
 13619 0764 8081      		ld r24,Z
 13620 0766 0E94 0000 		call TransferSdByte
 13621               	.LVL703:
2572:WTPA.c        **** 					sdCardSampleRemaining--;						// One less sample byte to go into the card
 13622               		.loc 1 2572 0
 13623 076a 8091 0000 		lds r24,sdCardSampleRemaining
 13624 076e 9091 0000 		lds r25,sdCardSampleRemaining+1
 13625 0772 A091 0000 		lds r26,sdCardSampleRemaining+2
 13626 0776 B091 0000 		lds r27,sdCardSampleRemaining+3
 13627 077a 0197      		sbiw r24,1
 13628 077c A109      		sbc r26,__zero_reg__
 13629 077e B109      		sbc r27,__zero_reg__
 13630 0780 8093 0000 		sts sdCardSampleRemaining,r24
 13631 0784 9093 0000 		sts sdCardSampleRemaining+1,r25
 13632 0788 A093 0000 		sts sdCardSampleRemaining+2,r26
 13633 078c B093 0000 		sts sdCardSampleRemaining+3,r27
2574:WTPA.c        **** 					sdFifoReadPointer++;			// Move to next spot in fifo
 13634               		.loc 1 2574 0
 13635 0790 8091 0000 		lds r24,sdFifoReadPointer
 13636 0794 9091 0000 		lds r25,sdFifoReadPointer+1
 13637 0798 0196      		adiw r24,1
 13638 079a 9093 0000 		sts sdFifoReadPointer+1,r25
 13639 079e 8093 0000 		sts sdFifoReadPointer,r24
2576:WTPA.c        **** 					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 13640               		.loc 1 2576 0
 13641 07a2 8091 0000 		lds r24,sdFifoReadPointer
 13642 07a6 9091 0000 		lds r25,sdFifoReadPointer+1
 13643 07aa 8115      		cp r24,__zero_reg__
 13644 07ac 9340      		sbci r25,3
 13645 07ae 00F0      		brlo .L1361
2578:WTPA.c        **** 						sdFifoReadPointer=0;
 13646               		.loc 1 2578 0
 13647 07b0 1092 0000 		sts sdFifoReadPointer+1,__zero_reg__
 13648 07b4 1092 0000 		sts sdFifoReadPointer,__zero_reg__
 13649               	.L1361:
2581:WTPA.c        **** 					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 13650               		.loc 1 2581 0
 13651 07b8 2FB7      		in r18,__SREG__
 13652               	.LVL704:
2582:WTPA.c        **** 					cli();
 13653               		.loc 1 2582 0
 13654               	/* #APP */
 13655               	 ;  2582 "WTPA.c" 1
 13656 07ba F894      		cli
 13657               	 ;  0 "" 2
2583:WTPA.c        **** 					sdBytesInFifo--;	// Stored one more byte.
 13658               		.loc 1 2583 0
 13659               	/* #NOAPP */
 13660 07bc 8091 0000 		lds r24,sdBytesInFifo
 13661 07c0 9091 0000 		lds r25,sdBytesInFifo+1
 13662 07c4 0197      		sbiw r24,1
 13663 07c6 9093 0000 		sts sdBytesInFifo+1,r25
 13664 07ca 8093 0000 		sts sdBytesInFifo,r24
2584:WTPA.c        **** 					SREG=sreg;
 13665               		.loc 1 2584 0
 13666 07ce 2FBF      		out __SREG__,r18
 13667               	.LVL705:
 13668               	.L1362:
2591:WTPA.c        **** 				bytesLeftInBlock--;			// One less byte in the block write.
 13669               		.loc 1 2591 0
 13670 07d0 8091 0000 		lds r24,bytesLeftInBlock.2026
 13671 07d4 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13672 07d8 0197      		sbiw r24,1
 13673 07da 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 13674 07de 8093 0000 		sts bytesLeftInBlock.2026,r24
2567:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes ze
 13675               		.loc 1 2567 0
 13676 07e2 6394      		inc r6
 13677               	.LVL706:
 13678 07e4 262D      		mov r18,r6
 13679 07e6 30E0      		ldi r19,0
 13680 07e8 2017      		cp r18,r16
 13681 07ea 3107      		cpc r19,r17
 13682 07ec 00F4      		brsh .L1359
 13683               	.LVL707:
 13684               	.L1363:
2569:WTPA.c        **** 				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
 13685               		.loc 1 2569 0
 13686 07ee 8091 0000 		lds r24,sdCardSampleRemaining
 13687 07f2 9091 0000 		lds r25,sdCardSampleRemaining+1
 13688 07f6 A091 0000 		lds r26,sdCardSampleRemaining+2
 13689 07fa B091 0000 		lds r27,sdCardSampleRemaining+3
 13690 07fe 892B      		or r24,r25
 13691 0800 8A2B      		or r24,r26
 13692 0802 8B2B      		or r24,r27
 13693 0804 01F0      		breq .+2
 13694 0806 00C0      		rjmp .L1610
2588:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
 13695               		.loc 1 2588 0
 13696 0808 8FEF      		ldi r24,lo8(-1)
 13697 080a 0E94 0000 		call TransferSdByte
 13698               	.LVL708:
 13699 080e 00C0      		rjmp .L1362
 13700               	.L1359:
2595:WTPA.c        **** 			if(bytesLeftInBlock==0)		// Handle closing this block
 13701               		.loc 1 2595 0
 13702 0810 892B      		or r24,r25
 13703 0812 01F0      		breq .+2
 13704 0814 00C0      		rjmp .L1314
2597:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 13705               		.loc 1 2597 0
 13706 0816 8FEF      		ldi r24,lo8(-1)
 13707 0818 0E94 0000 		call TransferSdByte
 13708               	.LVL709:
2598:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 13709               		.loc 1 2598 0
 13710 081c 8FEF      		ldi r24,lo8(-1)
 13711 081e 0E94 0000 		call TransferSdByte
 13712               	.LVL710:
2599:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 13713               		.loc 1 2599 0
 13714 0822 8FEF      		ldi r24,lo8(-1)
 13715 0824 0E94 0000 		call TransferSdByte
 13716               	.LVL711:
 13717 0828 8F71      		andi r24,lo8(31)
 13718               	.LVL712:
2601:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 13719               		.loc 1 2601 0
 13720 082a 8530      		cpi r24,lo8(5)
 13721 082c 01F4      		brne .+2
 13722 082e 00C0      		rjmp .L1611
 13723               	.LBB1019:
 13724               	.LBB1020:
2423:WTPA.c        **** 	sreg=SREG;
 13725               		.loc 1 2423 0
 13726 0830 1FB7      		in r17,__SREG__
 13727               	.LVL713:
2424:WTPA.c        **** 	cli();
 13728               		.loc 1 2424 0
 13729               	/* #APP */
 13730               	 ;  2424 "WTPA.c" 1
 13731 0832 F894      		cli
 13732               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13733               		.loc 1 2426 0
 13734               	/* #NOAPP */
 13735 0834 0E94 0000 		call EndSdTransfer
 13736               	.LVL714:
 13737 0838 E0E0      		ldi r30,lo8(sampleToc)
 13738 083a F0E0      		ldi r31,hi8(sampleToc)
 13739               	.LVL715:
 13740               	.L1365:
 13741               	.LBB1021:
 13742               	.LBB1022:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13743               		.loc 1 2166 0
 13744 083c 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13745               		.loc 1 2164 0
 13746 083e 20E0      		ldi r18,hi8(sampleToc+64)
 13747 0840 E030      		cpi r30,lo8(sampleToc+64)
 13748 0842 F207      		cpc r31,r18
 13749 0844 01F4      		brne .L1365
 13750 0846 00C0      		rjmp .L1589
 13751               	.LVL716:
 13752               	.L1320:
 13753               	.LBE1022:
 13754               	.LBE1021:
 13755               	.LBE1020:
 13756               	.LBE1019:
2614:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
 13757               		.loc 1 2614 0
 13758 0848 83E0      		ldi r24,lo8(3)
 13759 084a 0E94 0000 		call CheckTimer
 13760               	.LVL717:
 13761 084e 8111      		cpse r24,__zero_reg__
 13762 0850 00C0      		rjmp .L1366
2619:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13763               		.loc 1 2619 0
 13764 0852 8FEF      		ldi r24,lo8(-1)
 13765 0854 0E94 0000 		call TransferSdByte
 13766               	.LVL718:
2620:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13767               		.loc 1 2620 0
 13768 0858 8F3F      		cpi r24,lo8(-1)
 13769 085a 01F0      		breq .L1367
 13770               	.LVL719:
2619:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13771               		.loc 1 2619 0
 13772 085c 8FEF      		ldi r24,lo8(-1)
 13773 085e 0E94 0000 		call TransferSdByte
 13774               	.LVL720:
2620:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13775               		.loc 1 2620 0
 13776 0862 8F3F      		cpi r24,lo8(-1)
 13777 0864 01F0      		breq .L1367
 13778               	.LVL721:
2619:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13779               		.loc 1 2619 0
 13780 0866 8FEF      		ldi r24,lo8(-1)
 13781 0868 0E94 0000 		call TransferSdByte
 13782               	.LVL722:
2620:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13783               		.loc 1 2620 0
 13784 086c 8F3F      		cpi r24,lo8(-1)
 13785 086e 01F0      		breq .L1367
 13786               	.LVL723:
2619:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13787               		.loc 1 2619 0
 13788 0870 8FEF      		ldi r24,lo8(-1)
 13789 0872 0E94 0000 		call TransferSdByte
 13790               	.LVL724:
2620:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13791               		.loc 1 2620 0
 13792 0876 8F3F      		cpi r24,lo8(-1)
 13793 0878 01F0      		breq .+2
 13794 087a 00C0      		rjmp .L1314
 13795               	.L1367:
2632:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 13796               		.loc 1 2632 0
 13797 087c 0E94 0000 		call EndSdTransfer
 13798               	.LVL725:
2633:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 13799               		.loc 1 2633 0
 13800 0880 8FEF      		ldi r24,lo8(-1)
 13801 0882 0E94 0000 		call TransferSdByte
 13802               	.LVL726:
 13803               	.L1368:
2634:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 13804               		.loc 1 2634 0
 13805 0886 8091 C800 		lds r24,200
 13806 088a 86FF      		sbrs r24,6
 13807 088c 00C0      		rjmp .L1368
2637:WTPA.c        **** 					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the ca
 13808               		.loc 1 2637 0
 13809 088e 8091 0000 		lds r24,sdCardSampleRemaining
 13810 0892 9091 0000 		lds r25,sdCardSampleRemaining+1
 13811 0896 A091 0000 		lds r26,sdCardSampleRemaining+2
 13812 089a B091 0000 		lds r27,sdCardSampleRemaining+3
 13813 089e 892B      		or r24,r25
 13814 08a0 8A2B      		or r24,r26
 13815 08a2 8B2B      		or r24,r27
 13816 08a4 01F0      		breq .+2
 13817 08a6 00C0      		rjmp .L1612
2643:WTPA.c        **** 						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is alr
 13818               		.loc 1 2643 0
 13819 08a8 2091 0000 		lds r18,sdCurrentSlot
 13820 08ac 3091 0000 		lds r19,sdCurrentSlot+1
 13821               	.LVL727:
 13822               	.LBB1023:
 13823               	.LBB1024:
2178:WTPA.c        **** 	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
 13824               		.loc 1 2178 0
 13825 08b0 F901      		movw r30,r18
 13826 08b2 F695      		lsr r31
 13827 08b4 E795      		ror r30
 13828 08b6 F695      		lsr r31
 13829 08b8 E795      		ror r30
 13830 08ba F695      		lsr r31
 13831 08bc E795      		ror r30
 13832               	.LBE1024:
 13833               		.loc 1 5046 0
 13834 08be FF27      		clr r31
 13835               	.LBB1025:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 13836               		.loc 1 2181 0
 13837 08c0 E050      		subi r30,lo8(-(sampleToc))
 13838 08c2 F040      		sbci r31,hi8(-(sampleToc))
 13839 08c4 4081      		ld r20,Z
 13840               	.LBE1025:
2179:WTPA.c        **** 	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
 13841               		.loc 1 2179 0
 13842 08c6 2770      		andi r18,7
 13843 08c8 3327      		clr r19
 13844               	.LVL728:
 13845               	.LBB1026:
2181:WTPA.c        **** 	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
 13846               		.loc 1 2181 0
 13847 08ca 842F      		mov r24,r20
 13848 08cc 90E0      		ldi r25,0
 13849 08ce 022E      		mov r0,r18
 13850 08d0 00C0      		rjmp 2f
 13851               		1:
 13852 08d2 9595      		asr r25
 13853 08d4 8795      		ror r24
 13854               		2:
 13855 08d6 0A94      		dec r0
 13856 08d8 02F4      		brpl 1b
 13857 08da 80FD      		sbrc r24,0
 13858 08dc 00C0      		rjmp .L1370
 13859               	.LVL729:
 13860               	.LBE1026:
 13861               	.LBE1023:
 13862               	.LBB1027:
 13863               	.LBB993:
2201:WTPA.c        **** 	sampleToc[theByte]|=(1<<theBit);	// Set it
 13864               		.loc 1 2201 0
 13865 08de C501      		movw r24,r10
 13866 08e0 00C0      		rjmp 2f
 13867               		1:
 13868 08e2 880F      		lsl r24
 13869 08e4 991F      		rol r25
 13870               		2:
 13871 08e6 2A95      		dec r18
 13872 08e8 02F4      		brpl 1b
 13873 08ea 9C01      		movw r18,r24
 13874               	.LVL730:
 13875 08ec 242B      		or r18,r20
 13876 08ee 2083      		st Z,r18
 13877               	.LBE993:
 13878               	.LBE1027:
2646:WTPA.c        **** 							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
 13879               		.loc 1 2646 0
 13880 08f0 4092 0000 		sts cardState,r4
 13881 08f4 00C0      		rjmp .L1314
 13882               	.LVL731:
 13883               	.L1602:
2734:WTPA.c        **** 			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block,
 13884               		.loc 1 2734 0
 13885 08f6 8091 0000 		lds r24,bytesLeftInBlock.2026
 13886 08fa 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13887 08fe 8C01      		movw r16,r24
 13888 0900 8134      		cpi r24,65
 13889 0902 9105      		cpc r25,__zero_reg__
 13890 0904 00F0      		brlo .L1380
 13891 0906 00E4      		ldi r16,lo8(64)
 13892 0908 10E0      		ldi r17,0
 13893               	.L1380:
 13894               	.LVL732:
2743:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 13895               		.loc 1 2743 0
 13896 090a 0115      		cp r16,__zero_reg__
 13897 090c 1105      		cpc r17,__zero_reg__
 13898 090e 01F0      		breq .L1381
 13899 0910 612C      		mov r6,__zero_reg__
 13900               	.LVL733:
 13901               	.L1382:
2745:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 13902               		.loc 1 2745 0
 13903 0912 8FEF      		ldi r24,lo8(-1)
 13904 0914 0E94 0000 		call TransferSdByte
 13905               	.LVL734:
2746:WTPA.c        **** 				bytesLeftInBlock--;					// One less byte to send.
 13906               		.loc 1 2746 0
 13907 0918 8091 0000 		lds r24,bytesLeftInBlock.2026
 13908 091c 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 13909 0920 0197      		sbiw r24,1
 13910 0922 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 13911 0926 8093 0000 		sts bytesLeftInBlock.2026,r24
2743:WTPA.c        **** 			for(i=0;i<numTransferBytes;i++)
 13912               		.loc 1 2743 0
 13913 092a 6394      		inc r6
 13914               	.LVL735:
 13915 092c 262D      		mov r18,r6
 13916 092e 30E0      		ldi r19,0
 13917 0930 2017      		cp r18,r16
 13918 0932 3107      		cpc r19,r17
 13919 0934 00F0      		brlo .L1382
 13920               	.LVL736:
 13921               	.L1381:
2749:WTPA.c        **** 			if(bytesLeftInBlock==0)					// Handle closing this block
 13922               		.loc 1 2749 0
 13923 0936 892B      		or r24,r25
 13924 0938 01F0      		breq .+2
 13925 093a 00C0      		rjmp .L1314
2751:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 13926               		.loc 1 2751 0
 13927 093c 8FEF      		ldi r24,lo8(-1)
 13928 093e 0E94 0000 		call TransferSdByte
 13929               	.LVL737:
2752:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
 13930               		.loc 1 2752 0
 13931 0942 8FEF      		ldi r24,lo8(-1)
 13932 0944 0E94 0000 		call TransferSdByte
 13933               	.LVL738:
2753:WTPA.c        **** 				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
 13934               		.loc 1 2753 0
 13935 0948 8FEF      		ldi r24,lo8(-1)
 13936 094a 0E94 0000 		call TransferSdByte
 13937               	.LVL739:
 13938 094e 8F71      		andi r24,lo8(31)
 13939               	.LVL740:
2755:WTPA.c        **** 				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
 13940               		.loc 1 2755 0
 13941 0950 8530      		cpi r24,lo8(5)
 13942 0952 01F4      		brne .+2
 13943 0954 00C0      		rjmp .L1613
 13944               	.LBB1028:
 13945               	.LBB1029:
2423:WTPA.c        **** 	sreg=SREG;
 13946               		.loc 1 2423 0
 13947 0956 1FB7      		in r17,__SREG__
 13948               	.LVL741:
2424:WTPA.c        **** 	cli();
 13949               		.loc 1 2424 0
 13950               	/* #APP */
 13951               	 ;  2424 "WTPA.c" 1
 13952 0958 F894      		cli
 13953               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 13954               		.loc 1 2426 0
 13955               	/* #NOAPP */
 13956 095a 0E94 0000 		call EndSdTransfer
 13957               	.LVL742:
 13958 095e E0E0      		ldi r30,lo8(sampleToc)
 13959 0960 F0E0      		ldi r31,hi8(sampleToc)
 13960               	.LVL743:
 13961               	.L1384:
 13962               	.LBB1030:
 13963               	.LBB1031:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 13964               		.loc 1 2166 0
 13965 0962 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 13966               		.loc 1 2164 0
 13967 0964 50E0      		ldi r21,hi8(sampleToc+64)
 13968 0966 E030      		cpi r30,lo8(sampleToc+64)
 13969 0968 F507      		cpc r31,r21
 13970 096a 01F4      		brne .L1384
 13971 096c 00C0      		rjmp .L1589
 13972               	.LVL744:
 13973               	.L1324:
 13974               	.LBE1031:
 13975               	.LBE1030:
 13976               	.LBE1029:
 13977               	.LBE1028:
2768:WTPA.c        **** 			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
 13978               		.loc 1 2768 0
 13979 096e 83E0      		ldi r24,lo8(3)
 13980 0970 0E94 0000 		call CheckTimer
 13981               	.LVL745:
 13982 0974 8111      		cpse r24,__zero_reg__
 13983 0976 00C0      		rjmp .L1385
2773:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13984               		.loc 1 2773 0
 13985 0978 8FEF      		ldi r24,lo8(-1)
 13986 097a 0E94 0000 		call TransferSdByte
 13987               	.LVL746:
2774:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13988               		.loc 1 2774 0
 13989 097e 8F3F      		cpi r24,lo8(-1)
 13990 0980 01F0      		breq .L1386
 13991               	.LVL747:
2773:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 13992               		.loc 1 2773 0
 13993 0982 8FEF      		ldi r24,lo8(-1)
 13994 0984 0E94 0000 		call TransferSdByte
 13995               	.LVL748:
2774:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 13996               		.loc 1 2774 0
 13997 0988 8F3F      		cpi r24,lo8(-1)
 13998 098a 01F0      		breq .L1386
 13999               	.LVL749:
2773:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14000               		.loc 1 2773 0
 14001 098c 8FEF      		ldi r24,lo8(-1)
 14002 098e 0E94 0000 		call TransferSdByte
 14003               	.LVL750:
2774:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 14004               		.loc 1 2774 0
 14005 0992 8F3F      		cpi r24,lo8(-1)
 14006 0994 01F0      		breq .L1386
 14007               	.LVL751:
2773:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14008               		.loc 1 2773 0
 14009 0996 8FEF      		ldi r24,lo8(-1)
 14010 0998 0E94 0000 		call TransferSdByte
 14011               	.LVL752:
2774:WTPA.c        **** 					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when p
 14012               		.loc 1 2774 0
 14013 099c 8F3F      		cpi r24,lo8(-1)
 14014 099e 01F0      		breq .+2
 14015 09a0 00C0      		rjmp .L1314
 14016               	.L1386:
2786:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 14017               		.loc 1 2786 0
 14018 09a2 0E94 0000 		call EndSdTransfer
 14019               	.LVL753:
2787:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 14020               		.loc 1 2787 0
 14021 09a6 8FEF      		ldi r24,lo8(-1)
 14022 09a8 0E94 0000 		call TransferSdByte
 14023               	.LVL754:
 14024               	.L1387:
2788:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 14025               		.loc 1 2788 0
 14026 09ac 8091 C800 		lds r24,200
 14027 09b0 86FF      		sbrs r24,6
 14028 09b2 00C0      		rjmp .L1387
 14029               	.L1370:
2650:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
 14030               		.loc 1 2650 0
 14031 09b4 8092 0000 		sts cardState,r8
 14032 09b8 00C0      		rjmp .L1314
 14033               	.L1318:
2525:WTPA.c        **** 			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
 14034               		.loc 1 2525 0
 14035 09ba 2FB7      		in r18,__SREG__
 14036               	.LVL755:
2526:WTPA.c        **** 			cli();
 14037               		.loc 1 2526 0
 14038               	/* #APP */
 14039               	 ;  2526 "WTPA.c" 1
 14040 09bc F894      		cli
 14041               	 ;  0 "" 2
2527:WTPA.c        **** 			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full bl
 14042               		.loc 1 2527 0
 14043               	/* #NOAPP */
 14044 09be 8091 0000 		lds r24,sdBytesInFifo
 14045 09c2 9091 0000 		lds r25,sdBytesInFifo+1
 14046 09c6 8115      		cp r24,__zero_reg__
 14047 09c8 9240      		sbci r25,2
 14048 09ca 00F4      		brsh .L1354
 14049 09cc 8091 0000 		lds r24,sdBytesInFifo
 14050 09d0 9091 0000 		lds r25,sdBytesInFifo+1
 14051 09d4 4091 0000 		lds r20,sdCardSampleRemaining
 14052 09d8 5091 0000 		lds r21,sdCardSampleRemaining+1
 14053 09dc 6091 0000 		lds r22,sdCardSampleRemaining+2
 14054 09e0 7091 0000 		lds r23,sdCardSampleRemaining+3
 14055 09e4 A0E0      		ldi r26,0
 14056 09e6 B0E0      		ldi r27,0
 14057 09e8 8417      		cp r24,r20
 14058 09ea 9507      		cpc r25,r21
 14059 09ec A607      		cpc r26,r22
 14060 09ee B707      		cpc r27,r23
 14061 09f0 00F4      		brsh .+2
 14062 09f2 00C0      		rjmp .L1403
 14063               	.L1354:
2529:WTPA.c        **** 				SREG=sreg;	// Done reading ISR variables.
 14064               		.loc 1 2529 0
 14065 09f4 2FBF      		out __SREG__,r18
2530:WTPA.c        **** 				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single bloc
 14066               		.loc 1 2530 0
 14067 09f6 6091 0000 		lds r22,sdSampleStartBlock
 14068 09fa 7091 0000 		lds r23,sdSampleStartBlock+1
 14069 09fe 8091 0000 		lds r24,sdSampleStartBlock+2
 14070 0a02 9091 0000 		lds r25,sdSampleStartBlock+3
 14071 0a06 0E94 0000 		call SdBeginSingleBlockWrite
 14072               	.LVL756:
 14073 0a0a 8130      		cpi r24,lo8(1)
 14074 0a0c 01F4      		brne .+2
 14075 0a0e 00C0      		rjmp .L1614
 14076               	.LBB1032:
 14077               	.LBB1033:
2423:WTPA.c        **** 	sreg=SREG;
 14078               		.loc 1 2423 0
 14079 0a10 1FB7      		in r17,__SREG__
 14080               	.LVL757:
2424:WTPA.c        **** 	cli();
 14081               		.loc 1 2424 0
 14082               	/* #APP */
 14083               	 ;  2424 "WTPA.c" 1
 14084 0a12 F894      		cli
 14085               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14086               		.loc 1 2426 0
 14087               	/* #NOAPP */
 14088 0a14 0E94 0000 		call EndSdTransfer
 14089               	.LVL758:
 14090 0a18 E0E0      		ldi r30,lo8(sampleToc)
 14091 0a1a F0E0      		ldi r31,hi8(sampleToc)
 14092               	.LVL759:
 14093               	.L1357:
 14094               	.LBB1034:
 14095               	.LBB1035:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14096               		.loc 1 2166 0
 14097 0a1c 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14098               		.loc 1 2164 0
 14099 0a1e 80E0      		ldi r24,hi8(sampleToc+64)
 14100 0a20 E030      		cpi r30,lo8(sampleToc+64)
 14101 0a22 F807      		cpc r31,r24
 14102 0a24 01F4      		brne .L1357
 14103 0a26 00C0      		rjmp .L1589
 14104               	.LVL760:
 14105               	.L1322:
 14106               	.LBE1035:
 14107               	.LBE1034:
 14108               	.LBE1033:
 14109               	.LBE1032:
2694:WTPA.c        **** 			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
 14110               		.loc 1 2694 0
 14111 0a28 60E0      		ldi r22,0
 14112 0a2a 70E0      		ldi r23,0
 14113 0a2c CB01      		movw r24,r22
 14114 0a2e 0E94 0000 		call SdBeginSingleBlockWrite
 14115               	.LVL761:
 14116 0a32 8130      		cpi r24,lo8(1)
 14117 0a34 01F4      		brne .+2
 14118 0a36 00C0      		rjmp .L1615
 14119               	.LBB1036:
 14120               	.LBB1037:
2423:WTPA.c        **** 	sreg=SREG;
 14121               		.loc 1 2423 0
 14122 0a38 1FB7      		in r17,__SREG__
 14123               	.LVL762:
2424:WTPA.c        **** 	cli();
 14124               		.loc 1 2424 0
 14125               	/* #APP */
 14126               	 ;  2424 "WTPA.c" 1
 14127 0a3a F894      		cli
 14128               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14129               		.loc 1 2426 0
 14130               	/* #NOAPP */
 14131 0a3c 0E94 0000 		call EndSdTransfer
 14132               	.LVL763:
 14133 0a40 E0E0      		ldi r30,lo8(sampleToc)
 14134 0a42 F0E0      		ldi r31,hi8(sampleToc)
 14135               	.LVL764:
 14136               	.L1379:
 14137               	.LBB1038:
 14138               	.LBB1039:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14139               		.loc 1 2166 0
 14140 0a44 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14141               		.loc 1 2164 0
 14142 0a46 30E0      		ldi r19,hi8(sampleToc+64)
 14143 0a48 E030      		cpi r30,lo8(sampleToc+64)
 14144 0a4a F307      		cpc r31,r19
 14145 0a4c 01F4      		brne .L1379
 14146 0a4e 00C0      		rjmp .L1589
 14147               	.LVL765:
 14148               	.L1326:
 14149               	.LBE1039:
 14150               	.LBE1038:
 14151               	.LBE1037:
 14152               	.LBE1036:
2852:WTPA.c        **** 			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are in
 14153               		.loc 1 2852 0
 14154 0a50 8091 0000 		lds r24,sdAbortRead
 14155 0a54 8130      		cpi r24,lo8(1)
 14156 0a56 01F4      		brne .+2
 14157 0a58 00C0      		rjmp .L1590
2859:WTPA.c        **** 				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block
 14158               		.loc 1 2859 0
 14159 0a5a 8091 0000 		lds r24,bytesLeftInBlock.2026
 14160 0a5e 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14161 0a62 8C01      		movw r16,r24
 14162 0a64 8134      		cpi r24,65
 14163 0a66 9105      		cpc r25,__zero_reg__
 14164 0a68 00F0      		brlo .L1395
 14165 0a6a 00E4      		ldi r16,lo8(64)
 14166 0a6c 10E0      		ldi r17,0
 14167               	.L1395:
 14168               	.LVL766:
2868:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 14169               		.loc 1 2868 0
 14170 0a6e 0115      		cp r16,__zero_reg__
 14171 0a70 1105      		cpc r17,__zero_reg__
 14172 0a72 01F4      		brne .+2
 14173 0a74 00C0      		rjmp .L1396
 14174 0a76 612C      		mov r6,__zero_reg__
 14175               	.LVL767:
 14176               	.L1399:
2870:WTPA.c        **** 					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to
 14177               		.loc 1 2870 0
 14178 0a78 8FEF      		ldi r24,lo8(-1)
 14179 0a7a 0E94 0000 		call TransferSdByte
 14180               	.LVL768:
2871:WTPA.c        **** 					bytesLeftInBlock--;						// One less byte in the block read.
 14181               		.loc 1 2871 0
 14182 0a7e 2091 0000 		lds r18,bytesLeftInBlock.2026
 14183 0a82 3091 0000 		lds r19,bytesLeftInBlock.2026+1
 14184 0a86 2150      		subi r18,1
 14185 0a88 3109      		sbc r19,__zero_reg__
 14186 0a8a 3093 0000 		sts bytesLeftInBlock.2026+1,r19
 14187 0a8e 2093 0000 		sts bytesLeftInBlock.2026,r18
2873:WTPA.c        **** 					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with i
 14188               		.loc 1 2873 0
 14189 0a92 4091 0000 		lds r20,sdCardSampleRemaining
 14190 0a96 5091 0000 		lds r21,sdCardSampleRemaining+1
 14191 0a9a 6091 0000 		lds r22,sdCardSampleRemaining+2
 14192 0a9e 7091 0000 		lds r23,sdCardSampleRemaining+3
 14193 0aa2 452B      		or r20,r21
 14194 0aa4 462B      		or r20,r22
 14195 0aa6 472B      		or r20,r23
 14196 0aa8 01F0      		breq .L1397
2875:WTPA.c        **** 						sdCardSampleRemaining--;				// One less sample byte.
 14197               		.loc 1 2875 0
 14198 0aaa 4091 0000 		lds r20,sdCardSampleRemaining
 14199 0aae 5091 0000 		lds r21,sdCardSampleRemaining+1
 14200 0ab2 6091 0000 		lds r22,sdCardSampleRemaining+2
 14201 0ab6 7091 0000 		lds r23,sdCardSampleRemaining+3
 14202 0aba 4150      		subi r20,1
 14203 0abc 5109      		sbc r21,__zero_reg__
 14204 0abe 6109      		sbc r22,__zero_reg__
 14205 0ac0 7109      		sbc r23,__zero_reg__
 14206 0ac2 4093 0000 		sts sdCardSampleRemaining,r20
 14207 0ac6 5093 0000 		sts sdCardSampleRemaining+1,r21
 14208 0aca 6093 0000 		sts sdCardSampleRemaining+2,r22
 14209 0ace 7093 0000 		sts sdCardSampleRemaining+3,r23
2877:WTPA.c        **** 						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
 14210               		.loc 1 2877 0
 14211 0ad2 E091 0000 		lds r30,sdFifoWritePointer
 14212 0ad6 F091 0000 		lds r31,sdFifoWritePointer+1
 14213 0ada E050      		subi r30,lo8(-(sdFifo))
 14214 0adc F040      		sbci r31,hi8(-(sdFifo))
 14215 0ade 8083      		st Z,r24
2878:WTPA.c        **** 						sdFifoWritePointer++;				// Move to next spot in fifo
 14216               		.loc 1 2878 0
 14217 0ae0 8091 0000 		lds r24,sdFifoWritePointer
 14218 0ae4 9091 0000 		lds r25,sdFifoWritePointer+1
 14219               	.LVL769:
 14220 0ae8 0196      		adiw r24,1
 14221 0aea 9093 0000 		sts sdFifoWritePointer+1,r25
 14222 0aee 8093 0000 		sts sdFifoWritePointer,r24
2880:WTPA.c        **** 						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
 14223               		.loc 1 2880 0
 14224 0af2 8091 0000 		lds r24,sdFifoWritePointer
 14225 0af6 9091 0000 		lds r25,sdFifoWritePointer+1
 14226 0afa 8115      		cp r24,__zero_reg__
 14227 0afc 9340      		sbci r25,3
 14228 0afe 00F0      		brlo .L1398
2882:WTPA.c        **** 							sdFifoWritePointer=0;
 14229               		.loc 1 2882 0
 14230 0b00 1092 0000 		sts sdFifoWritePointer+1,__zero_reg__
 14231 0b04 1092 0000 		sts sdFifoWritePointer,__zero_reg__
 14232               	.L1398:
2885:WTPA.c        **** 						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
 14233               		.loc 1 2885 0
 14234 0b08 2FB7      		in r18,__SREG__
 14235               	.LVL770:
2886:WTPA.c        **** 						cli();
 14236               		.loc 1 2886 0
 14237               	/* #APP */
 14238               	 ;  2886 "WTPA.c" 1
 14239 0b0a F894      		cli
 14240               	 ;  0 "" 2
2887:WTPA.c        **** 						sdBytesInFifo++;	// Stored one more byte.
 14241               		.loc 1 2887 0
 14242               	/* #NOAPP */
 14243 0b0c 8091 0000 		lds r24,sdBytesInFifo
 14244 0b10 9091 0000 		lds r25,sdBytesInFifo+1
 14245 0b14 0196      		adiw r24,1
 14246 0b16 9093 0000 		sts sdBytesInFifo+1,r25
 14247 0b1a 8093 0000 		sts sdBytesInFifo,r24
2888:WTPA.c        **** 						SREG=sreg;
 14248               		.loc 1 2888 0
 14249 0b1e 2FBF      		out __SREG__,r18
 14250               	.LVL771:
 14251               	.L1397:
2868:WTPA.c        **** 				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes 
 14252               		.loc 1 2868 0
 14253 0b20 6394      		inc r6
 14254               	.LVL772:
 14255 0b22 862D      		mov r24,r6
 14256 0b24 90E0      		ldi r25,0
 14257 0b26 8017      		cp r24,r16
 14258 0b28 9107      		cpc r25,r17
 14259 0b2a 00F4      		brsh .+2
 14260 0b2c 00C0      		rjmp .L1399
 14261 0b2e 8091 0000 		lds r24,bytesLeftInBlock.2026
 14262 0b32 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14263               	.LVL773:
 14264               	.L1396:
2893:WTPA.c        **** 				if(bytesLeftInBlock==0)		// Handle closing this block
 14265               		.loc 1 2893 0
 14266 0b36 892B      		or r24,r25
 14267 0b38 01F0      		breq .+2
 14268 0b3a 00C0      		rjmp .L1314
2895:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 14269               		.loc 1 2895 0
 14270 0b3c 8FEF      		ldi r24,lo8(-1)
 14271 0b3e 0E94 0000 		call TransferSdByte
 14272               	.LVL774:
2896:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
 14273               		.loc 1 2896 0
 14274 0b42 8FEF      		ldi r24,lo8(-1)
 14275 0b44 0E94 0000 		call TransferSdByte
 14276               	.LVL775:
 14277               	.L1400:
2897:WTPA.c        **** 					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 14278               		.loc 1 2897 0
 14279 0b48 8091 C800 		lds r24,200
 14280 0b4c 86FF      		sbrs r24,6
 14281 0b4e 00C0      		rjmp .L1400
2900:WTPA.c        **** 					EndSdTransfer();				// Bring CS high
 14282               		.loc 1 2900 0
 14283 0b50 0E94 0000 		call EndSdTransfer
 14284               	.LVL776:
2901:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to w
 14285               		.loc 1 2901 0
 14286 0b54 8FEF      		ldi r24,lo8(-1)
 14287 0b56 0E94 0000 		call TransferSdByte
 14288               	.LVL777:
2902:WTPA.c        **** 					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remain
 14289               		.loc 1 2902 0
 14290 0b5a 4BE0      		ldi r20,lo8(11)
 14291 0b5c 4093 0000 		sts cardState,r20
2904:WTPA.c        **** 					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine i
 14292               		.loc 1 2904 0
 14293 0b60 8091 0000 		lds r24,sdCardSampleRemaining
 14294 0b64 9091 0000 		lds r25,sdCardSampleRemaining+1
 14295 0b68 A091 0000 		lds r26,sdCardSampleRemaining+2
 14296 0b6c B091 0000 		lds r27,sdCardSampleRemaining+3
 14297 0b70 892B      		or r24,r25
 14298 0b72 8A2B      		or r24,r26
 14299 0b74 8B2B      		or r24,r27
 14300 0b76 01F0      		breq .+2
 14301 0b78 00C0      		rjmp .L1314
 14302               	.L1509:
2906:WTPA.c        **** 						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
 14303               		.loc 1 2906 0
 14304 0b7a 8091 C800 		lds r24,200
 14305 0b7e 86FF      		sbrs r24,6
 14306 0b80 00C0      		rjmp .L1509
2650:WTPA.c        **** 							cardState=SD_IDLE;				// DONE!
 14307               		.loc 1 2650 0
 14308 0b82 8092 0000 		sts cardState,r8
 14309 0b86 00C0      		rjmp .L1314
 14310               	.LVL778:
 14311               	.L1316:
2482:WTPA.c        **** 			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
 14312               		.loc 1 2482 0
 14313 0b88 81E0      		ldi r24,lo8(1)
 14314 0b8a 8093 0000 		sts cardState,r24
2483:WTPA.c        **** 			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
 14315               		.loc 1 2483 0
 14316 0b8e 64EC      		ldi r22,lo8(-60)
 14317 0b90 74E0      		ldi r23,lo8(4)
 14318 0b92 83E0      		ldi r24,lo8(3)
 14319 0b94 0E94 0000 		call SetTimer
 14320               	.LVL779:
 14321 0b98 00C0      		rjmp .L1314
 14322               	.LVL780:
 14323               	.L1403:
2935:WTPA.c        **** 				SREG=sreg;	// ISR back on.
 14324               		.loc 1 2935 0
 14325 0b9a 2FBF      		out __SREG__,r18
 14326 0b9c 00C0      		rjmp .L1314
 14327               	.LVL781:
 14328               	.L1615:
2696:WTPA.c        **** 				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
 14329               		.loc 1 2696 0
 14330 0b9e D092 0000 		sts bytesLeftInBlock.2026+1,r13
 14331 0ba2 C092 0000 		sts bytesLeftInBlock.2026,r12
2698:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send a pad
 14332               		.loc 1 2698 0
 14333 0ba6 8FEF      		ldi r24,lo8(-1)
 14334 0ba8 0E94 0000 		call TransferSdByte
 14335               	.LVL782:
2699:WTPA.c        **** 				TransferSdByte(DUMMY_BYTE);			// Send another pad
 14336               		.loc 1 2699 0
 14337 0bac 8FEF      		ldi r24,lo8(-1)
 14338 0bae 0E94 0000 		call TransferSdByte
 14339               	.LVL783:
2700:WTPA.c        **** 				TransferSdByte(0xFE);				// Send DATA_START token
 14340               		.loc 1 2700 0
 14341 0bb2 8EEF      		ldi r24,lo8(-2)
 14342 0bb4 0E94 0000 		call TransferSdByte
 14343               	.LVL784:
2701:WTPA.c        **** 				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
 14344               		.loc 1 2701 0
 14345 0bb8 87E5      		ldi r24,lo8(87)
 14346 0bba 0E94 0000 		call TransferSdByte
 14347               	.LVL785:
2702:WTPA.c        **** 				TransferSdByte('T');
 14348               		.loc 1 2702 0
 14349 0bbe 84E5      		ldi r24,lo8(84)
 14350 0bc0 0E94 0000 		call TransferSdByte
 14351               	.LVL786:
2703:WTPA.c        **** 				TransferSdByte('P');
 14352               		.loc 1 2703 0
 14353 0bc4 80E5      		ldi r24,lo8(80)
 14354 0bc6 0E94 0000 		call TransferSdByte
 14355               	.LVL787:
2704:WTPA.c        **** 				TransferSdByte('A');
 14356               		.loc 1 2704 0
 14357 0bca 81E4      		ldi r24,lo8(65)
 14358 0bcc 0E94 0000 		call TransferSdByte
 14359               	.LVL788:
2705:WTPA.c        **** 				TransferSdByte('S');				// These four characters indicate this card holds sample data (as oppos
 14360               		.loc 1 2705 0
 14361 0bd0 83E5      		ldi r24,lo8(83)
 14362 0bd2 0E94 0000 		call TransferSdByte
 14363               	.LVL789:
2706:WTPA.c        **** 				TransferSdByte('A');
 14364               		.loc 1 2706 0
 14365 0bd6 81E4      		ldi r24,lo8(65)
 14366 0bd8 0E94 0000 		call TransferSdByte
 14367               	.LVL790:
2707:WTPA.c        **** 				TransferSdByte('M');
 14368               		.loc 1 2707 0
 14369 0bdc 8DE4      		ldi r24,lo8(77)
 14370 0bde 0E94 0000 		call TransferSdByte
 14371               	.LVL791:
2708:WTPA.c        **** 				TransferSdByte('P');
 14372               		.loc 1 2708 0
 14373 0be2 80E5      		ldi r24,lo8(80)
 14374 0be4 0E94 0000 		call TransferSdByte
 14375               	.LVL792:
2710:WTPA.c        **** 				bytesLeftInBlock-=8;
 14376               		.loc 1 2710 0
 14377 0be8 8091 0000 		lds r24,bytesLeftInBlock.2026
 14378 0bec 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14379 0bf0 0897      		sbiw r24,8
 14380 0bf2 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 14381 0bf6 8093 0000 		sts bytesLeftInBlock.2026,r24
 14382               	.LVL793:
2714:WTPA.c        **** 					TransferSdByte('x');
 14383               		.loc 1 2714 0
 14384 0bfa 88E7      		ldi r24,lo8(120)
 14385 0bfc 0E94 0000 		call TransferSdByte
 14386               	.LVL794:
 14387 0c00 88E7      		ldi r24,lo8(120)
 14388 0c02 0E94 0000 		call TransferSdByte
 14389               	.LVL795:
 14390 0c06 88E7      		ldi r24,lo8(120)
 14391 0c08 0E94 0000 		call TransferSdByte
 14392               	.LVL796:
 14393 0c0c 88E7      		ldi r24,lo8(120)
 14394 0c0e 0E94 0000 		call TransferSdByte
 14395               	.LVL797:
 14396 0c12 88E7      		ldi r24,lo8(120)
 14397 0c14 0E94 0000 		call TransferSdByte
 14398               	.LVL798:
 14399 0c18 88E7      		ldi r24,lo8(120)
 14400 0c1a 0E94 0000 		call TransferSdByte
 14401               	.LVL799:
 14402 0c1e 88E7      		ldi r24,lo8(120)
 14403 0c20 0E94 0000 		call TransferSdByte
 14404               	.LVL800:
 14405 0c24 88E7      		ldi r24,lo8(120)
 14406 0c26 0E94 0000 		call TransferSdByte
 14407               	.LVL801:
2717:WTPA.c        **** 				bytesLeftInBlock-=8;
 14408               		.loc 1 2717 0
 14409 0c2a 8091 0000 		lds r24,bytesLeftInBlock.2026
 14410 0c2e 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14411 0c32 0897      		sbiw r24,8
 14412 0c34 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 14413 0c38 8093 0000 		sts bytesLeftInBlock.2026,r24
 14414               	.LVL802:
 14415 0c3c 00E0      		ldi r16,lo8(sampleToc)
 14416 0c3e 10E0      		ldi r17,hi8(sampleToc)
 14417               	.LVL803:
 14418               	.L1378:
2721:WTPA.c        **** 					TransferSdByte(sampleToc[i]);
 14419               		.loc 1 2721 0
 14420 0c40 F801      		movw r30,r16
 14421 0c42 8191      		ld r24,Z+
 14422 0c44 8F01      		movw r16,r30
 14423 0c46 0E94 0000 		call TransferSdByte
 14424               	.LVL804:
2719:WTPA.c        **** 				for(i=0;i<64;i++)					// Write table of contents.
 14425               		.loc 1 2719 0
 14426 0c4a F0E0      		ldi r31,hi8(sampleToc+64)
 14427 0c4c 0030      		cpi r16,lo8(sampleToc+64)
 14428 0c4e 1F07      		cpc r17,r31
 14429 0c50 01F4      		brne .L1378
2724:WTPA.c        **** 				bytesLeftInBlock-=64;						// shave off bytes from block counter
 14430               		.loc 1 2724 0
 14431 0c52 8091 0000 		lds r24,bytesLeftInBlock.2026
 14432 0c56 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14433 0c5a 8054      		subi r24,64
 14434 0c5c 9109      		sbc r25,__zero_reg__
 14435 0c5e 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 14436 0c62 8093 0000 		sts bytesLeftInBlock.2026,r24
2725:WTPA.c        **** 				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
 14437               		.loc 1 2725 0
 14438 0c66 27E0      		ldi r18,lo8(7)
 14439 0c68 2093 0000 		sts cardState,r18
 14440 0c6c 00C0      		rjmp .L1314
 14441               	.LVL805:
 14442               	.L1609:
2958:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
 14443               		.loc 1 2958 0
 14444 0c6e D092 0000 		sts bytesLeftInBlock.2026+1,r13
 14445 0c72 C092 0000 		sts bytesLeftInBlock.2026,r12
2960:WTPA.c        **** 					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
 14446               		.loc 1 2960 0
 14447 0c76 5092 0000 		sts cardState,r5
2961:WTPA.c        **** 					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort
 14448               		.loc 1 2961 0
 14449 0c7a 8091 0000 		lds r24,sdAbortRead
 14450               	.LVL806:
 14451 0c7e 8130      		cpi r24,lo8(1)
 14452 0c80 01F0      		breq .+2
 14453 0c82 00C0      		rjmp .L1314
 14454               	.L1590:
2963:WTPA.c        **** 						cardState=SD_READ_ABORT;
 14455               		.loc 1 2963 0
 14456 0c84 7092 0000 		sts cardState,r7
2964:WTPA.c        **** 						sdAbortRead=false;
 14457               		.loc 1 2964 0
 14458 0c88 1092 0000 		sts sdAbortRead,__zero_reg__
 14459 0c8c 00C0      		rjmp .L1314
 14460               	.LVL807:
 14461               	.L1608:
2946:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14462               		.loc 1 2946 0
 14463 0c8e 0E94 0000 		call TransferSdByte
 14464               	.LVL808:
2947:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14465               		.loc 1 2947 0
 14466 0c92 8F3F      		cpi r24,lo8(-1)
 14467 0c94 01F0      		breq .+2
 14468 0c96 00C0      		rjmp .L1407
 14469               	.LVL809:
2946:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14470               		.loc 1 2946 0
 14471 0c98 0E94 0000 		call TransferSdByte
 14472               	.LVL810:
2947:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14473               		.loc 1 2947 0
 14474 0c9c 8F3F      		cpi r24,lo8(-1)
 14475 0c9e 01F0      		breq .+2
 14476 0ca0 00C0      		rjmp .L1407
 14477               	.LVL811:
2946:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14478               		.loc 1 2946 0
 14479 0ca2 0E94 0000 		call TransferSdByte
 14480               	.LVL812:
2947:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14481               		.loc 1 2947 0
 14482 0ca6 8F3F      		cpi r24,lo8(-1)
 14483 0ca8 01F0      		breq .+2
 14484 0caa 00C0      		rjmp .L1407
 14485 0cac 00C0      		rjmp .L1314
 14486               	.L1603:
 14487               	.LVL813:
2809:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14488               		.loc 1 2809 0
 14489 0cae 0E94 0000 		call TransferSdByte
 14490               	.LVL814:
2810:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14491               		.loc 1 2810 0
 14492 0cb2 8F3F      		cpi r24,lo8(-1)
 14493 0cb4 01F0      		breq .+2
 14494 0cb6 00C0      		rjmp .L1390
 14495               	.LVL815:
2809:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14496               		.loc 1 2809 0
 14497 0cb8 0E94 0000 		call TransferSdByte
 14498               	.LVL816:
2810:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14499               		.loc 1 2810 0
 14500 0cbc 8F3F      		cpi r24,lo8(-1)
 14501 0cbe 01F0      		breq .+2
 14502 0cc0 00C0      		rjmp .L1390
 14503               	.LVL817:
2809:WTPA.c        **** 					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
 14504               		.loc 1 2809 0
 14505 0cc2 0E94 0000 		call TransferSdByte
 14506               	.LVL818:
2810:WTPA.c        **** 					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
 14507               		.loc 1 2810 0
 14508 0cc6 8F3F      		cpi r24,lo8(-1)
 14509 0cc8 01F4      		brne .+2
 14510 0cca 00C0      		rjmp .L1314
2820:WTPA.c        **** 				if(theByte==0xFE)	// Got a start token!
 14511               		.loc 1 2820 0
 14512 0ccc 8E3F      		cpi r24,lo8(-2)
 14513 0cce 01F0      		breq .+2
 14514 0cd0 00C0      		rjmp .L1391
 14515               	.L1604:
2822:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
 14516               		.loc 1 2822 0
 14517 0cd2 D092 0000 		sts bytesLeftInBlock.2026+1,r13
 14518 0cd6 C092 0000 		sts bytesLeftInBlock.2026,r12
2824:WTPA.c        **** 					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four
 14519               		.loc 1 2824 0
 14520 0cda 8FEF      		ldi r24,lo8(-1)
 14521               	.LVL819:
 14522 0cdc 0E94 0000 		call TransferSdByte
 14523               	.LVL820:
 14524 0ce0 90E0      		ldi r25,0
 14525 0ce2 A0E0      		ldi r26,0
 14526 0ce4 B0E0      		ldi r27,0
 14527 0ce6 B82F      		mov r27,r24
 14528 0ce8 AA27      		clr r26
 14529 0cea 9927      		clr r25
 14530 0cec 8827      		clr r24
 14531 0cee 8093 0000 		sts sdCardSampleRemaining,r24
 14532 0cf2 9093 0000 		sts sdCardSampleRemaining+1,r25
 14533 0cf6 A093 0000 		sts sdCardSampleRemaining+2,r26
 14534 0cfa B093 0000 		sts sdCardSampleRemaining+3,r27
2825:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
 14535               		.loc 1 2825 0
 14536 0cfe 8FEF      		ldi r24,lo8(-1)
 14537 0d00 0E94 0000 		call TransferSdByte
 14538               	.LVL821:
 14539 0d04 4091 0000 		lds r20,sdCardSampleRemaining
 14540 0d08 5091 0000 		lds r21,sdCardSampleRemaining+1
 14541 0d0c 6091 0000 		lds r22,sdCardSampleRemaining+2
 14542 0d10 7091 0000 		lds r23,sdCardSampleRemaining+3
 14543 0d14 682B      		or r22,r24
 14544 0d16 4093 0000 		sts sdCardSampleRemaining,r20
 14545 0d1a 5093 0000 		sts sdCardSampleRemaining+1,r21
 14546 0d1e 6093 0000 		sts sdCardSampleRemaining+2,r22
 14547 0d22 7093 0000 		sts sdCardSampleRemaining+3,r23
2826:WTPA.c        **** 					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
 14548               		.loc 1 2826 0
 14549 0d26 8FEF      		ldi r24,lo8(-1)
 14550 0d28 0E94 0000 		call TransferSdByte
 14551               	.LVL822:
 14552 0d2c 4091 0000 		lds r20,sdCardSampleRemaining
 14553 0d30 5091 0000 		lds r21,sdCardSampleRemaining+1
 14554 0d34 6091 0000 		lds r22,sdCardSampleRemaining+2
 14555 0d38 7091 0000 		lds r23,sdCardSampleRemaining+3
 14556 0d3c 582B      		or r21,r24
 14557 0d3e 4093 0000 		sts sdCardSampleRemaining,r20
 14558 0d42 5093 0000 		sts sdCardSampleRemaining+1,r21
 14559 0d46 6093 0000 		sts sdCardSampleRemaining+2,r22
 14560 0d4a 7093 0000 		sts sdCardSampleRemaining+3,r23
2827:WTPA.c        **** 					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
 14561               		.loc 1 2827 0
 14562 0d4e 8FEF      		ldi r24,lo8(-1)
 14563 0d50 0E94 0000 		call TransferSdByte
 14564               	.LVL823:
 14565 0d54 4091 0000 		lds r20,sdCardSampleRemaining
 14566 0d58 5091 0000 		lds r21,sdCardSampleRemaining+1
 14567 0d5c 6091 0000 		lds r22,sdCardSampleRemaining+2
 14568 0d60 7091 0000 		lds r23,sdCardSampleRemaining+3
 14569 0d64 482B      		or r20,r24
 14570 0d66 4093 0000 		sts sdCardSampleRemaining,r20
 14571 0d6a 5093 0000 		sts sdCardSampleRemaining+1,r21
 14572 0d6e 6093 0000 		sts sdCardSampleRemaining+2,r22
 14573 0d72 7093 0000 		sts sdCardSampleRemaining+3,r23
2829:WTPA.c        **** 					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == 
 14574               		.loc 1 2829 0
 14575 0d76 8091 0000 		lds r24,sdCardSampleRemaining
 14576 0d7a 9091 0000 		lds r25,sdCardSampleRemaining+1
 14577 0d7e A091 0000 		lds r26,sdCardSampleRemaining+2
 14578 0d82 B091 0000 		lds r27,sdCardSampleRemaining+3
 14579 0d86 8093 0000 		sts sdRamSampleRemaining,r24
 14580 0d8a 9093 0000 		sts sdRamSampleRemaining+1,r25
 14581 0d8e A093 0000 		sts sdRamSampleRemaining+2,r26
 14582 0d92 B093 0000 		sts sdRamSampleRemaining+3,r27
2831:WTPA.c        **** 					bytesLeftInBlock-=4;				// Keep track of where we are in the block
 14583               		.loc 1 2831 0
 14584 0d96 8091 0000 		lds r24,bytesLeftInBlock.2026
 14585 0d9a 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14586 0d9e 0497      		sbiw r24,4
 14587 0da0 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 14588 0da4 8093 0000 		sts bytesLeftInBlock.2026,r24
2832:WTPA.c        **** 					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handl
 14589               		.loc 1 2832 0
 14590 0da8 5092 0000 		sts cardState,r5
2834:WTPA.c        **** 					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abor
 14591               		.loc 1 2834 0
 14592 0dac 8091 0000 		lds r24,sdAbortRead
 14593 0db0 8130      		cpi r24,lo8(1)
 14594 0db2 01F0      		breq .+2
 14595 0db4 00C0      		rjmp .L1314
2963:WTPA.c        **** 						cardState=SD_READ_ABORT;
 14596               		.loc 1 2963 0
 14597 0db6 7092 0000 		sts cardState,r7
2964:WTPA.c        **** 						sdAbortRead=false;
 14598               		.loc 1 2964 0
 14599 0dba 1092 0000 		sts sdAbortRead,__zero_reg__
 14600 0dbe 00C0      		rjmp .L1314
 14601               	.L1606:
2671:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 14602               		.loc 1 2671 0
 14603 0dc0 D092 0000 		sts bytesLeftInBlock.2026+1,r13
 14604 0dc4 C092 0000 		sts bytesLeftInBlock.2026,r12
2673:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send a pad
 14605               		.loc 1 2673 0
 14606 0dc8 8FEF      		ldi r24,lo8(-1)
 14607 0dca 0E94 0000 		call TransferSdByte
 14608               	.LVL824:
2674:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);			// Send another pad
 14609               		.loc 1 2674 0
 14610 0dce 8FEF      		ldi r24,lo8(-1)
 14611 0dd0 0E94 0000 		call TransferSdByte
 14612               	.LVL825:
2675:WTPA.c        **** 					TransferSdByte(0xFE);				// Send DATA_START token
 14613               		.loc 1 2675 0
 14614 0dd4 8EEF      		ldi r24,lo8(-2)
 14615 0dd6 0E94 0000 		call TransferSdByte
 14616               	.LVL826:
2676:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
 14617               		.loc 1 2676 0
 14618 0dda 83E0      		ldi r24,lo8(3)
 14619 0ddc 8093 0000 		sts cardState,r24
 14620 0de0 00C0      		rjmp .L1314
 14621               	.L1406:
 14622               	.LBB1040:
 14623               	.LBB1002:
2423:WTPA.c        **** 	sreg=SREG;
 14624               		.loc 1 2423 0
 14625 0de2 1FB7      		in r17,__SREG__
 14626               	.LVL827:
2424:WTPA.c        **** 	cli();
 14627               		.loc 1 2424 0
 14628               	/* #APP */
 14629               	 ;  2424 "WTPA.c" 1
 14630 0de4 F894      		cli
 14631               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14632               		.loc 1 2426 0
 14633               	/* #NOAPP */
 14634 0de6 0E94 0000 		call EndSdTransfer
 14635               	.LVL828:
 14636 0dea E0E0      		ldi r30,lo8(sampleToc)
 14637 0dec F0E0      		ldi r31,hi8(sampleToc)
 14638               	.LVL829:
 14639               	.L1410:
 14640               	.LBB1000:
 14641               	.LBB1001:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14642               		.loc 1 2166 0
 14643 0dee 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14644               		.loc 1 2164 0
 14645 0df0 40E0      		ldi r20,hi8(sampleToc+64)
 14646 0df2 E030      		cpi r30,lo8(sampleToc+64)
 14647 0df4 F407      		cpc r31,r20
 14648 0df6 01F4      		brne .L1410
 14649 0df8 00C0      		rjmp .L1589
 14650               	.LVL830:
 14651               	.L1389:
 14652               	.LBE1001:
 14653               	.LBE1000:
 14654               	.LBE1002:
 14655               	.LBE1040:
 14656               	.LBB1041:
 14657               	.LBB1042:
2423:WTPA.c        **** 	sreg=SREG;
 14658               		.loc 1 2423 0
 14659 0dfa 1FB7      		in r17,__SREG__
 14660               	.LVL831:
2424:WTPA.c        **** 	cli();
 14661               		.loc 1 2424 0
 14662               	/* #APP */
 14663               	 ;  2424 "WTPA.c" 1
 14664 0dfc F894      		cli
 14665               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14666               		.loc 1 2426 0
 14667               	/* #NOAPP */
 14668 0dfe 0E94 0000 		call EndSdTransfer
 14669               	.LVL832:
 14670 0e02 E0E0      		ldi r30,lo8(sampleToc)
 14671 0e04 F0E0      		ldi r31,hi8(sampleToc)
 14672               	.LVL833:
 14673               	.L1393:
 14674               	.LBB1043:
 14675               	.LBB1044:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14676               		.loc 1 2166 0
 14677 0e06 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14678               		.loc 1 2164 0
 14679 0e08 20E0      		ldi r18,hi8(sampleToc+64)
 14680 0e0a E030      		cpi r30,lo8(sampleToc+64)
 14681 0e0c F207      		cpc r31,r18
 14682 0e0e 01F4      		brne .L1393
 14683 0e10 00C0      		rjmp .L1589
 14684               	.LVL834:
 14685               	.L1614:
 14686               	.LBE1044:
 14687               	.LBE1043:
 14688               	.LBE1042:
 14689               	.LBE1041:
2532:WTPA.c        **** 					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
 14690               		.loc 1 2532 0
 14691 0e12 D092 0000 		sts bytesLeftInBlock.2026+1,r13
 14692 0e16 C092 0000 		sts bytesLeftInBlock.2026,r12
2534:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send a pad
 14693               		.loc 1 2534 0
 14694 0e1a 8FEF      		ldi r24,lo8(-1)
 14695 0e1c 0E94 0000 		call TransferSdByte
 14696               	.LVL835:
2535:WTPA.c        **** 					TransferSdByte(DUMMY_BYTE);							// Send another pad
 14697               		.loc 1 2535 0
 14698 0e20 8FEF      		ldi r24,lo8(-1)
 14699 0e22 0E94 0000 		call TransferSdByte
 14700               	.LVL836:
2536:WTPA.c        **** 					TransferSdByte(0xFE);								// Send DATA_START token
 14701               		.loc 1 2536 0
 14702 0e26 8EEF      		ldi r24,lo8(-2)
 14703 0e28 0E94 0000 		call TransferSdByte
 14704               	.LVL837:
2537:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
 14705               		.loc 1 2537 0
 14706 0e2c 8091 0000 		lds r24,sdCardSampleRemaining
 14707 0e30 9091 0000 		lds r25,sdCardSampleRemaining+1
 14708 0e34 A091 0000 		lds r26,sdCardSampleRemaining+2
 14709 0e38 B091 0000 		lds r27,sdCardSampleRemaining+3
 14710 0e3c 8B2F      		mov r24,r27
 14711 0e3e 0E94 0000 		call TransferSdByte
 14712               	.LVL838:
2538:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
 14713               		.loc 1 2538 0
 14714 0e42 6091 0000 		lds r22,sdCardSampleRemaining
 14715 0e46 7091 0000 		lds r23,sdCardSampleRemaining+1
 14716 0e4a 8091 0000 		lds r24,sdCardSampleRemaining+2
 14717 0e4e 9091 0000 		lds r25,sdCardSampleRemaining+3
 14718 0e52 0E94 0000 		call TransferSdByte
 14719               	.LVL839:
2539:WTPA.c        **** 					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
 14720               		.loc 1 2539 0
 14721 0e56 8091 0000 		lds r24,sdCardSampleRemaining
 14722 0e5a 9091 0000 		lds r25,sdCardSampleRemaining+1
 14723 0e5e A091 0000 		lds r26,sdCardSampleRemaining+2
 14724 0e62 B091 0000 		lds r27,sdCardSampleRemaining+3
 14725 0e66 892F      		mov r24,r25
 14726 0e68 0E94 0000 		call TransferSdByte
 14727               	.LVL840:
2540:WTPA.c        **** 					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
 14728               		.loc 1 2540 0
 14729 0e6c 8091 0000 		lds r24,sdCardSampleRemaining
 14730 0e70 9091 0000 		lds r25,sdCardSampleRemaining+1
 14731 0e74 A091 0000 		lds r26,sdCardSampleRemaining+2
 14732 0e78 B091 0000 		lds r27,sdCardSampleRemaining+3
 14733 0e7c 0E94 0000 		call TransferSdByte
 14734               	.LVL841:
2542:WTPA.c        **** 					bytesLeftInBlock-=4;							// Keep track of where we are in the block
 14735               		.loc 1 2542 0
 14736 0e80 8091 0000 		lds r24,bytesLeftInBlock.2026
 14737 0e84 9091 0000 		lds r25,bytesLeftInBlock.2026+1
 14738 0e88 0497      		sbiw r24,4
 14739 0e8a 9093 0000 		sts bytesLeftInBlock.2026+1,r25
 14740 0e8e 8093 0000 		sts bytesLeftInBlock.2026,r24
2544:WTPA.c        **** 					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing o
 14741               		.loc 1 2544 0
 14742 0e92 83E0      		ldi r24,lo8(3)
 14743 0e94 8093 0000 		sts cardState,r24
 14744 0e98 00C0      		rjmp .L1314
 14745               	.L1385:
 14746               	.LBB1045:
 14747               	.LBB1046:
2423:WTPA.c        **** 	sreg=SREG;
 14748               		.loc 1 2423 0
 14749 0e9a 1FB7      		in r17,__SREG__
 14750               	.LVL842:
2424:WTPA.c        **** 	cli();
 14751               		.loc 1 2424 0
 14752               	/* #APP */
 14753               	 ;  2424 "WTPA.c" 1
 14754 0e9c F894      		cli
 14755               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14756               		.loc 1 2426 0
 14757               	/* #NOAPP */
 14758 0e9e 0E94 0000 		call EndSdTransfer
 14759               	.LVL843:
 14760 0ea2 E0E0      		ldi r30,lo8(sampleToc)
 14761 0ea4 F0E0      		ldi r31,hi8(sampleToc)
 14762               	.LVL844:
 14763               	.L1388:
 14764               	.LBB1047:
 14765               	.LBB1048:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14766               		.loc 1 2166 0
 14767 0ea6 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14768               		.loc 1 2164 0
 14769 0ea8 80E0      		ldi r24,hi8(sampleToc+64)
 14770 0eaa E030      		cpi r30,lo8(sampleToc+64)
 14771 0eac F807      		cpc r31,r24
 14772 0eae 01F4      		brne .L1388
 14773 0eb0 00C0      		rjmp .L1589
 14774               	.LVL845:
 14775               	.L1366:
 14776               	.LBE1048:
 14777               	.LBE1047:
 14778               	.LBE1046:
 14779               	.LBE1045:
 14780               	.LBB1049:
 14781               	.LBB1050:
2423:WTPA.c        **** 	sreg=SREG;
 14782               		.loc 1 2423 0
 14783 0eb2 1FB7      		in r17,__SREG__
 14784               	.LVL846:
2424:WTPA.c        **** 	cli();
 14785               		.loc 1 2424 0
 14786               	/* #APP */
 14787               	 ;  2424 "WTPA.c" 1
 14788 0eb4 F894      		cli
 14789               	 ;  0 "" 2
2426:WTPA.c        **** 	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
 14790               		.loc 1 2426 0
 14791               	/* #NOAPP */
 14792 0eb6 0E94 0000 		call EndSdTransfer
 14793               	.LVL847:
 14794 0eba E0E0      		ldi r30,lo8(sampleToc)
 14795 0ebc F0E0      		ldi r31,hi8(sampleToc)
 14796               	.LVL848:
 14797               	.L1372:
 14798               	.LBB1051:
 14799               	.LBB1052:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14800               		.loc 1 2166 0
 14801 0ebe 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14802               		.loc 1 2164 0
 14803 0ec0 30E0      		ldi r19,hi8(sampleToc+64)
 14804 0ec2 E030      		cpi r30,lo8(sampleToc+64)
 14805 0ec4 F307      		cpc r31,r19
 14806 0ec6 01F4      		brne .L1372
 14807 0ec8 00C0      		rjmp .L1589
 14808               	.LVL849:
 14809               	.L1607:
 14810               	.LBE1052:
 14811               	.LBE1051:
 14812               	.LBE1050:
 14813               	.LBE1049:
2925:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
 14814               		.loc 1 2925 0
 14815 0eca 6AE7      		ldi r22,lo8(122)
 14816 0ecc 70E0      		ldi r23,0
 14817 0ece 83E0      		ldi r24,lo8(3)
 14818 0ed0 0E94 0000 		call SetTimer
 14819               	.LVL850:
2926:WTPA.c        **** 					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to b
 14820               		.loc 1 2926 0
 14821 0ed4 FCE0      		ldi r31,lo8(12)
 14822 0ed6 F093 0000 		sts cardState,r31
 14823 0eda 00C0      		rjmp .L1314
 14824               	.LVL851:
 14825               	.L1613:
2757:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 14826               		.loc 1 2757 0
 14827 0edc 62E6      		ldi r22,lo8(98)
 14828 0ede 72E0      		ldi r23,lo8(2)
 14829 0ee0 83E0      		ldi r24,lo8(3)
 14830               	.LVL852:
 14831 0ee2 0E94 0000 		call SetTimer
 14832               	.LVL853:
2758:WTPA.c        **** 					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
 14833               		.loc 1 2758 0
 14834 0ee6 48E0      		ldi r20,lo8(8)
 14835 0ee8 4093 0000 		sts cardState,r20
 14836 0eec 00C0      		rjmp .L1314
 14837               	.LVL854:
 14838               	.L1611:
2603:WTPA.c        **** 					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
 14839               		.loc 1 2603 0
 14840 0eee 62E6      		ldi r22,lo8(98)
 14841 0ef0 72E0      		ldi r23,lo8(2)
 14842 0ef2 83E0      		ldi r24,lo8(3)
 14843               	.LVL855:
 14844 0ef4 0E94 0000 		call SetTimer
 14845               	.LVL856:
2604:WTPA.c        **** 					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
 14846               		.loc 1 2604 0
 14847 0ef8 84E0      		ldi r24,lo8(4)
 14848 0efa 8093 0000 		sts cardState,r24
 14849 0efe 00C0      		rjmp .L1314
 14850               	.LVL857:
 14851               	.L1599:
 14852               	.LBB1053:
 14853               	.LBB1054:
2237:WTPA.c        **** 	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
 14854               		.loc 1 2237 0
 14855 0f00 60E0      		ldi r22,0
 14856 0f02 70E0      		ldi r23,0
 14857 0f04 CB01      		movw r24,r22
 14858 0f06 0E94 0000 		call SdBeginSingleBlockRead
 14859               	.LVL858:
 14860 0f0a 8130      		cpi r24,lo8(1)
 14861 0f0c 01F4      		brne .+2
 14862 0f0e 00C0      		rjmp .L1616
2235:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
 14863               		.loc 1 2235 0
 14864 0f10 612C      		mov r6,__zero_reg__
 14865               	.LVL859:
 14866               	.L1510:
2300:WTPA.c        **** 	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
 14867               		.loc 1 2300 0
 14868 0f12 8091 C800 		lds r24,200
 14869 0f16 86FF      		sbrs r24,6
 14870 0f18 00C0      		rjmp .L1510
2303:WTPA.c        **** 	EndSdTransfer();				// Bring CS high
 14871               		.loc 1 2303 0
 14872 0f1a 0E94 0000 		call EndSdTransfer
 14873               	.LVL860:
2304:WTPA.c        **** 	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where
 14874               		.loc 1 2304 0
 14875 0f1e 8FEF      		ldi r24,lo8(-1)
 14876 0f20 0E94 0000 		call TransferSdByte
 14877               	.LVL861:
 14878               	.LBE1054:
 14879               	.LBE1053:
2496:WTPA.c        **** 					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
 14880               		.loc 1 2496 0
 14881 0f24 21E0      		ldi r18,lo8(1)
 14882 0f26 6216      		cp r6,r18
 14883 0f28 01F0      		breq .L1617
2501:WTPA.c        **** 					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler
 14884               		.loc 1 2501 0
 14885 0f2a 32E0      		ldi r19,lo8(2)
 14886 0f2c 6316      		cp r6,r19
 14887 0f2e 01F4      		brne .+2
 14888 0f30 00C0      		rjmp .L1314
2508:WTPA.c        **** 						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Form
 14889               		.loc 1 2508 0
 14890 0f32 8FE0      		ldi r24,lo8(15)
 14891 0f34 8093 0000 		sts cardState,r24
 14892               	.LVL862:
 14893 0f38 E0E0      		ldi r30,lo8(sampleToc)
 14894 0f3a F0E0      		ldi r31,hi8(sampleToc)
 14895               	.LVL863:
 14896               	.L1353:
 14897               	.LBB1060:
 14898               	.LBB1061:
2166:WTPA.c        **** 		sampleToc[i]=0x00;		// 8 bits of "no sample present"
 14899               		.loc 1 2166 0
 14900 0f3c 1192      		st Z+,__zero_reg__
2164:WTPA.c        **** 	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
 14901               		.loc 1 2164 0
 14902 0f3e 40E0      		ldi r20,hi8(sampleToc+64)
 14903 0f40 E030      		cpi r30,lo8(sampleToc+64)
 14904 0f42 F407      		cpc r31,r20
 14905 0f44 01F4      		brne .L1353
 14906               	.LVL864:
 14907               	.LBE1061:
 14908               	.LBE1060:
 14909               	.LBB1062:
 14910               	.LBB1063:
1504:WTPA.c        **** 	State=newState;
 14911               		.loc 1 1504 0
 14912 0f46 3092 0000 		sts State+1,r3
 14913 0f4a 2092 0000 		sts State,r2
1505:WTPA.c        **** 	subState=SS_0;
 14914               		.loc 1 1505 0
 14915 0f4e 1092 0000 		sts subState,__zero_reg__
 14916 0f52 00C0      		rjmp .L1314
 14917               	.LVL865:
 14918               	.L1612:
 14919               	.LBE1063:
 14920               	.LBE1062:
2639:WTPA.c        **** 						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start anot
 14921               		.loc 1 2639 0
 14922 0f54 85E0      		ldi r24,lo8(5)
 14923 0f56 8093 0000 		sts cardState,r24
 14924 0f5a 00C0      		rjmp .L1314
 14925               	.L1617:
2498:WTPA.c        **** 						cardState=SD_IDLE;			// Card is legit and ready to go.
 14926               		.loc 1 2498 0
 14927 0f5c 8092 0000 		sts cardState,r8
 14928               	.LBB1064:
 14929               	.LBB1065:
3050:WTPA.c        **** 	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
 14930               		.loc 1 3050 0
 14931 0f60 8091 6400 		lds r24,100
 14932 0f64 8F7B      		andi r24,lo8(-65)
 14933 0f66 8093 6400 		sts 100,r24
3052:WTPA.c        **** 	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
 14934               		.loc 1 3052 0
 14935 0f6a 82E0      		ldi r24,lo8(2)
 14936 0f6c 8093 B000 		sts 176,r24
3053:WTPA.c        **** 	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
 14937               		.loc 1 3053 0
 14938 0f70 1092 B100 		sts 177,__zero_reg__
3054:WTPA.c        **** 	TCNT2=0;			// Init counter reg
 14939               		.loc 1 3054 0
 14940 0f74 1092 B200 		sts 178,__zero_reg__
3055:WTPA.c        **** 	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch 
 14941               		.loc 1 3055 0
 14942 0f78 81E7      		ldi r24,lo8(113)
 14943 0f7a 8093 B300 		sts 179,r24
3056:WTPA.c        **** 	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
 14944               		.loc 1 3056 0
 14945 0f7e 97BA      		out 0x17,r9
3057:WTPA.c        **** 	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
 14946               		.loc 1 3057 0
 14947 0f80 1092 7000 		sts 112,__zero_reg__
3059:WTPA.c        **** 	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
 14948               		.loc 1 3059 0
 14949 0f84 1092 0000 		sts sdIsrState,__zero_reg__
3060:WTPA.c        **** 	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
 14950               		.loc 1 3060 0
 14951 0f88 1092 0000 		sts sdStreamOutput,__zero_reg__
 14952 0f8c 00C0      		rjmp .L1314
 14953               	.LVL866:
 14954               	.L1616:
 14955               	.LBE1065:
 14956               	.LBE1064:
 14957               	.LBB1066:
 14958               	.LBB1059:
2246:WTPA.c        **** 		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
 14959               		.loc 1 2246 0
 14960 0f8e 6AE7      		ldi r22,lo8(122)
 14961 0f90 70E0      		ldi r23,0
 14962 0f92 83E0      		ldi r24,lo8(3)
 14963 0f94 0E94 0000 		call SetTimer
 14964               	.LVL867:
 14965               	.L1581:
2248:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 14966               		.loc 1 2248 0
 14967 0f98 83E0      		ldi r24,lo8(3)
 14968 0f9a 0E94 0000 		call CheckTimer
 14969               	.LVL868:
 14970 0f9e 8111      		cpse r24,__zero_reg__
 14971 0fa0 00C0      		rjmp .L1342
 14972               	.L1338:
 14973 0fa2 8FEF      		ldi r24,lo8(-1)
 14974 0fa4 0E94 0000 		call TransferSdByte
 14975               	.LVL869:
 14976 0fa8 8E3F      		cpi r24,lo8(-2)
 14977 0faa 01F0      		breq .L1342
 14978               	.LBB1055:
 14979               	.LBB1056:
1518:WTPA.c        **** 	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
 14980               		.loc 1 1518 0
 14981 0fac A89B      		sbis 0x15,0
 14982 0fae 00C0      		rjmp .L1581
 14983               	.LBB1057:
 14984               	.LBB1058:
1520:WTPA.c        **** 		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
 14985               		.loc 1 1520 0
 14986 0fb0 A89A      		sbi 0x15,0
1521:WTPA.c        **** 		systemTicks++;			// Increment the system ticks.
 14987               		.loc 1 1521 0
 14988 0fb2 8091 0000 		lds r24,systemTicks
 14989 0fb6 9091 0000 		lds r25,systemTicks+1
 14990               	.LVL870:
 14991 0fba 0196      		adiw r24,1
 14992               	.LVL871:
 14993 0fbc 9093 0000 		sts systemTicks+1,r25
 14994 0fc0 8093 0000 		sts systemTicks,r24
 14995               	.LVL872:
 14996               	.LBE1058:
 14997               	.LBE1057:
 14998               	.LBE1056:
 14999               	.LBE1055:
2248:WTPA.c        **** 		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the
 15000               		.loc 1 2248 0
 15001 0fc4 83E0      		ldi r24,lo8(3)
 15002               	.LVL873:
 15003 0fc6 0E94 0000 		call CheckTimer
 15004               	.LVL874:
 15005 0fca 8823      		tst r24
 15006 0fcc 01F0      		breq .L1338
 15007               	.L1342:
 15008               	.LVL875:
2255:WTPA.c        **** 			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
 15009               		.loc 1 2255 0
 15010 0fce 8FEF      		ldi r24,lo8(-1)
 15011 0fd0 0E94 0000 		call TransferSdByte
 15012               	.LVL876:
 15013 0fd4 482F      		mov r20,r24
 15014 0fd6 8983      		std Y+1,r24
 15015               	.LVL877:
 15016 0fd8 8FEF      		ldi r24,lo8(-1)
 15017 0fda 4C87      		std Y+12,r20
 15018 0fdc 0E94 0000 		call TransferSdByte
 15019               	.LVL878:
 15020 0fe0 382F      		mov r19,r24
 15021 0fe2 8A83      		std Y+2,r24
 15022               	.LVL879:
 15023 0fe4 8FEF      		ldi r24,lo8(-1)
 15024 0fe6 3B87      		std Y+11,r19
 15025 0fe8 0E94 0000 		call TransferSdByte
 15026               	.LVL880:
 15027 0fec 282F      		mov r18,r24
 15028 0fee 8B83      		std Y+3,r24
 15029               	.LVL881:
 15030 0ff0 8FEF      		ldi r24,lo8(-1)
 15031 0ff2 2A87      		std Y+10,r18
 15032 0ff4 0E94 0000 		call TransferSdByte
 15033               	.LVL882:
 15034 0ff8 682E      		mov r6,r24
 15035 0ffa 8C83      		std Y+4,r24
 15036               	.LVL883:
 15037 0ffc 8FEF      		ldi r24,lo8(-1)
 15038 0ffe 0E94 0000 		call TransferSdByte
 15039               	.LVL884:
 15040 1002 982F      		mov r25,r24
 15041 1004 8D83      		std Y+5,r24
 15042               	.LVL885:
 15043 1006 8FEF      		ldi r24,lo8(-1)
 15044 1008 9987      		std Y+9,r25
 15045 100a 0E94 0000 		call TransferSdByte
 15046               	.LVL886:
 15047 100e 082F      		mov r16,r24
 15048 1010 8E83      		std Y+6,r24
 15049               	.LVL887:
 15050 1012 8FEF      		ldi r24,lo8(-1)
 15051 1014 0E94 0000 		call TransferSdByte
 15052               	.LVL888:
 15053 1018 182F      		mov r17,r24
 15054 101a 8F83      		std Y+7,r24
 15055               	.LVL889:
 15056 101c 8FEF      		ldi r24,lo8(-1)
 15057 101e 0E94 0000 		call TransferSdByte
 15058               	.LVL890:
 15059 1022 8887      		std Y+8,r24
 15060               	.LVL891:
2258:WTPA.c        **** 		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A')
 15061               		.loc 1 2258 0
 15062 1024 4C85      		ldd r20,Y+12
 15063 1026 2A85      		ldd r18,Y+10
 15064 1028 3B85      		ldd r19,Y+11
 15065 102a 9985      		ldd r25,Y+9
 15066 102c 4735      		cpi r20,lo8(87)
 15067 102e 01F0      		breq .L1618
 15068               	.L1424:
2235:WTPA.c        **** 	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
 15069               		.loc 1 2235 0
 15070 1030 612C      		mov r6,__zero_reg__
 15071               	.L1346:
 15072               	.LVL892:
2276:WTPA.c        **** 			TransferSdByte(0xFF);
 15073               		.loc 1 2276 0
 15074 1032 8FEF      		ldi r24,lo8(-1)
 15075 1034 0E94 0000 		call TransferSdByte
 15076               	.LVL893:
 15077 1038 8FEF      		ldi r24,lo8(-1)
 15078 103a 0E94 0000 		call TransferSdByte
 15079               	.LVL894:
 15080 103e 8FEF      		ldi r24,lo8(-1)
 15081 1040 0E94 0000 		call TransferSdByte
 15082               	.LVL895:
 15083 1044 8FEF      		ldi r24,lo8(-1)
 15084 1046 0E94 0000 		call TransferSdByte
 15085               	.LVL896:
 15086 104a 8FEF      		ldi r24,lo8(-1)
 15087 104c 0E94 0000 		call TransferSdByte
 15088               	.LVL897:
 15089 1050 8FEF      		ldi r24,lo8(-1)
 15090 1052 0E94 0000 		call TransferSdByte
 15091               	.LVL898:
 15092 1056 8FEF      		ldi r24,lo8(-1)
 15093 1058 0E94 0000 		call TransferSdByte
 15094               	.LVL899:
 15095 105c 8FEF      		ldi r24,lo8(-1)
 15096 105e 0E94 0000 		call TransferSdByte
 15097               	.LVL900:
 15098 1062 00E4      		ldi r16,lo8(64)
 15099 1064 10E0      		ldi r17,0
 15100               	.LVL901:
 15101               	.L1349:
2290:WTPA.c        **** 				TransferSdByte(0xFF);
 15102               		.loc 1 2290 0
 15103 1066 8FEF      		ldi r24,lo8(-1)
 15104 1068 0E94 0000 		call TransferSdByte
 15105               	.LVL902:
 15106 106c 0150      		subi r16,1
 15107 106e 1109      		sbc r17,__zero_reg__
2288:WTPA.c        **** 			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
 15108               		.loc 1 2288 0
 15109 1070 01F4      		brne .L1349
 15110               	.LVL903:
 15111               	.L1348:
2262:WTPA.c        **** 				filesystemType=SD_TYPE_SAMPLES;
 15112               		.loc 1 2262 0
 15113 1072 02EB      		ldi r16,lo8(-78)
 15114 1074 11E0      		ldi r17,lo8(1)
 15115               	.LVL904:
 15116               	.L1350:
2296:WTPA.c        **** 			TransferSdByte(0xFF);
 15117               		.loc 1 2296 0
 15118 1076 8FEF      		ldi r24,lo8(-1)
 15119 1078 0E94 0000 		call TransferSdByte
 15120               	.LVL905:
 15121 107c 0150      		subi r16,1
 15122 107e 1109      		sbc r17,__zero_reg__
2294:WTPA.c        **** 		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
 15123               		.loc 1 2294 0
 15124 1080 01F4      		brne .L1350
 15125 1082 00C0      		rjmp .L1510
 15126               	.LVL906:
 15127               	.L1618:
2258:WTPA.c        **** 		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A')
 15128               		.loc 1 2258 0
 15129 1084 3435      		cpi r19,lo8(84)
 15130 1086 01F4      		brne .L1424
 15131 1088 2035      		cpi r18,lo8(80)
 15132 108a 01F4      		brne .L1424
 15133 108c 31E4      		ldi r19,lo8(65)
 15134 108e 6312      		cpse r6,r19
 15135 1090 00C0      		rjmp .L1424
2260:WTPA.c        **** 			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'
 15136               		.loc 1 2260 0
 15137 1092 9335      		cpi r25,lo8(83)
 15138 1094 01F0      		breq .L1619
2264:WTPA.c        **** 			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]
 15139               		.loc 1 2264 0
 15140 1096 9434      		cpi r25,lo8(68)
 15141 1098 01F0      		breq .L1620
2268:WTPA.c        **** 			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]
 15142               		.loc 1 2268 0
 15143 109a 9234      		cpi r25,lo8(66)
 15144 109c 01F4      		brne .L1424
 15145 109e 0F34      		cpi r16,lo8(79)
 15146 10a0 01F4      		brne .L1424
 15147 10a2 1F34      		cpi r17,lo8(79)
 15148 10a4 01F4      		brne .L1424
 15149 10a6 8435      		cpi r24,lo8(84)
 15150 10a8 01F0      		breq .+2
 15151 10aa 00C0      		rjmp .L1424
2270:WTPA.c        **** 				filesystemType=SD_TYPE_BOOT;						
 15152               		.loc 1 2270 0
 15153 10ac 63E0      		ldi r22,lo8(3)
 15154 10ae 662E      		mov r6,r22
 15155 10b0 00C0      		rjmp .L1346
 15156               	.L1619:
2260:WTPA.c        **** 			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'
 15157               		.loc 1 2260 0
 15158 10b2 0134      		cpi r16,lo8(65)
 15159 10b4 01F0      		breq .+2
 15160 10b6 00C0      		rjmp .L1424
 15161 10b8 1D34      		cpi r17,lo8(77)
 15162 10ba 01F0      		breq .+2
 15163 10bc 00C0      		rjmp .L1424
 15164 10be 8035      		cpi r24,lo8(80)
 15165 10c0 01F0      		breq .+2
 15166 10c2 00C0      		rjmp .L1424
 15167               	.LVL907:
2276:WTPA.c        **** 			TransferSdByte(0xFF);
 15168               		.loc 1 2276 0
 15169 10c4 8FEF      		ldi r24,lo8(-1)
 15170 10c6 0E94 0000 		call TransferSdByte
 15171               	.LVL908:
 15172 10ca 8FEF      		ldi r24,lo8(-1)
 15173 10cc 0E94 0000 		call TransferSdByte
 15174               	.LVL909:
 15175 10d0 8FEF      		ldi r24,lo8(-1)
 15176 10d2 0E94 0000 		call TransferSdByte
 15177               	.LVL910:
 15178 10d6 8FEF      		ldi r24,lo8(-1)
 15179 10d8 0E94 0000 		call TransferSdByte
 15180               	.LVL911:
 15181 10dc 8FEF      		ldi r24,lo8(-1)
 15182 10de 0E94 0000 		call TransferSdByte
 15183               	.LVL912:
 15184 10e2 8FEF      		ldi r24,lo8(-1)
 15185 10e4 0E94 0000 		call TransferSdByte
 15186               	.LVL913:
 15187 10e8 8FEF      		ldi r24,lo8(-1)
 15188 10ea 0E94 0000 		call TransferSdByte
 15189               	.LVL914:
 15190 10ee 8FEF      		ldi r24,lo8(-1)
 15191 10f0 0E94 0000 		call TransferSdByte
 15192               	.LVL915:
 15193 10f4 00E0      		ldi r16,lo8(sampleToc)
 15194 10f6 10E0      		ldi r17,hi8(sampleToc)
 15195               	.LVL916:
 15196               	.L1347:
2283:WTPA.c        **** 				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
 15197               		.loc 1 2283 0
 15198 10f8 8FEF      		ldi r24,lo8(-1)
 15199 10fa 0E94 0000 		call TransferSdByte
 15200               	.LVL917:
 15201 10fe F801      		movw r30,r16
 15202 1100 8193      		st Z+,r24
 15203 1102 8F01      		movw r16,r30
2281:WTPA.c        **** 			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
 15204               		.loc 1 2281 0
 15205 1104 F0E0      		ldi r31,hi8(sampleToc+64)
 15206 1106 0030      		cpi r16,lo8(sampleToc+64)
 15207 1108 1F07      		cpc r17,r31
 15208 110a 01F4      		brne .L1347
2262:WTPA.c        **** 				filesystemType=SD_TYPE_SAMPLES;
 15209               		.loc 1 2262 0
 15210 110c 6624      		clr r6
 15211 110e 6394      		inc r6
 15212 1110 00C0      		rjmp .L1348
 15213               	.LVL918:
 15214               	.L1620:
2264:WTPA.c        **** 			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]
 15215               		.loc 1 2264 0
 15216 1112 0035      		cpi r16,lo8(80)
 15217 1114 01F0      		breq .+2
 15218 1116 00C0      		rjmp .L1424
 15219 1118 1334      		cpi r17,lo8(67)
 15220 111a 01F0      		breq .+2
 15221 111c 00C0      		rjmp .L1424
 15222 111e 8D34      		cpi r24,lo8(77)
 15223 1120 01F0      		breq .+2
 15224 1122 00C0      		rjmp .L1424
2266:WTPA.c        **** 				filesystemType=SD_TYPE_DPCM;			
 15225               		.loc 1 2266 0
 15226 1124 B2E0      		ldi r27,lo8(2)
 15227 1126 6B2E      		mov r6,r27
 15228 1128 00C0      		rjmp .L1346
 15229               	.LBE1059:
 15230               	.LBE1066:
 15231               	.LBE1071:
 15232               	.LBE1104:
 15233               		.cfi_endproc
 15234               	.LFE76:
 15236               		.comm	UpdateOutput,2,1
 15237               		.local	sdCardSampleRemaining
 15238               		.comm	sdCardSampleRemaining,4,1
 15239               		.local	sdRamSampleRemaining
 15240               		.comm	sdRamSampleRemaining,4,1
 15241               		.local	sdBytesInFifo
 15242               		.comm	sdBytesInFifo,2,1
 15243               		.local	sdFifoWritePointer
 15244               		.comm	sdFifoWritePointer,2,1
 15245               		.local	sdFifoReadPointer
 15246               		.comm	sdFifoReadPointer,2,1
 15247               		.local	sdFifo
 15248               		.comm	sdFifo,768,1
 15249               		.local	adcByte
 15250               		.comm	adcByte,1,1
 15251               		.local	sliceRemaining
 15252               		.comm	sliceRemaining,8,1
 15253               		.local	sliceSize
 15254               		.comm	sliceSize,8,1
 15255               		.local	granularPositionArrayPointer
 15256               		.comm	granularPositionArrayPointer,2,1
 15257               		.local	outOfRam
 15258               		.comm	outOfRam,1,1
 15259               		.comm	State,2,1
 15260               		.local	ledPwm
 15261               		.comm	ledPwm,1,1
 15262               		.local	flipFlop.1813
 15263               		.comm	flipFlop.1813,1,1
 15264               		.local	extIsrOutputBank0
 15265               		.comm	extIsrOutputBank0,1,1
 15266               		.local	sawtooth.1757
 15267               		.comm	sawtooth.1757,1,1
 15268               		.local	granularPositionArray
 15269               		.comm	granularPositionArray,256,1
 15270               		.local	flipFlop.1819
 15271               		.comm	flipFlop.1819,1,1
 15272               		.local	extIsrOutputBank1
 15273               		.comm	extIsrOutputBank1,1,1
 15274               		.local	sawtooth.1769
 15275               		.comm	sawtooth.1769,1,1
 15276               		.local	flipFlop.1827
 15277               		.comm	flipFlop.1827,1,1
 15278               		.local	midiOutputBank0
 15279               		.comm	midiOutputBank0,1,1
 15280               		.data
 15283               	random31:
 15284 0000 EF        		.byte	-17
 15285 0001 BE        		.byte	-66
 15286 0002 00        		.byte	0
 15287 0003 00        		.byte	0
 15288               		.local	lastJitterValue.1826
 15289               		.comm	lastJitterValue.1826,2,1
 15290               		.local	flipFlop.1835
 15291               		.comm	flipFlop.1835,1,1
 15292               		.local	midiOutputBank1
 15293               		.comm	midiOutputBank1,1,1
 15294               		.local	lastJitterValue.1834
 15295               		.comm	lastJitterValue.1834,2,1
 15296               		.local	sdIsrState
 15297               		.comm	sdIsrState,1,1
 15298               		.local	sdRamAddress
 15299               		.comm	sdRamAddress,4,1
 15300               		.local	sdBank0
 15301               		.comm	sdBank0,1,1
 15302               		.local	sdStreamOutput
 15303               		.comm	sdStreamOutput,1,1
 15304               		.local	pwmCount.1847
 15305               		.comm	pwmCount.1847,1,1
 15306               		.local	encoderState
 15307               		.comm	encoderState,1,1
 15308               		.local	encoderValue
 15309               		.comm	encoderValue,1,1
 15310               		.local	newEncoder
 15311               		.comm	newEncoder,1,1
 15312               		.local	encoderCw
 15313               		.comm	encoderCw,1,1
 15314               		.local	encoderCcw
 15315               		.comm	encoderCcw,1,1
 15316               		.local	newKeys
 15317               		.comm	newKeys,1,1
 15318               		.local	keyState
 15319               		.comm	keyState,1,1
 15320               		.local	cardState
 15321               		.comm	cardState,1,1
 15322               		.local	cardDetect
 15323               		.comm	cardDetect,1,1
 15324               		.local	subState
 15325               		.comm	subState,1,1
 15326               		.local	i.2279
 15327               		.comm	i.2279,1,1
 15328               		.local	ledOnOffMask
 15329               		.comm	ledOnOffMask,1,1
 15330               		.local	theMidiRecordRate
 15331               		.comm	theMidiRecordRate,4,1
 15332               		.section	.rodata
 15335               	OctaveZeroCompareMatches:
 15336 0000 FFFF      		.word	-1
 15337 0002 A1F1      		.word	-3679
 15338 0004 11E4      		.word	-7151
 15339 0006 44D7      		.word	-10428
 15340 0008 2FCB      		.word	-13521
 15341 000a C8BF      		.word	-16440
 15342 000c 04B5      		.word	-19196
 15343 000e DBAA      		.word	-21797
 15344 0010 44A1      		.word	-24252
 15345 0012 3798      		.word	-26569
 15346 0014 AC8F      		.word	-28756
 15347 0016 9C87      		.word	-30820
 15348               		.local	currentBank
 15349               		.comm	currentBank,1,1
 15350               		.local	sdCurrentSlot
 15351               		.comm	sdCurrentSlot,2,1
 15352               		.local	currentMidiMessage.2230
 15353               		.comm	currentMidiMessage.2230,4,1
 15354               		.data
 15357               	currentNoteOn.2231:
 15358 0004 3C        		.byte	60
 15359 0005 3C        		.byte	60
 15360               		.local	lastDacByte
 15361               		.comm	lastDacByte,1,1
 15362               		.local	keysHeld
 15363               		.comm	keysHeld,1,1
 15364               		.local	scaledEncoderValue
 15365               		.comm	scaledEncoderValue,1,1
 15366               		.local	sampleToc
 15367               		.comm	sampleToc,64,1
 15368               		.local	ledBlinkMask
 15369               		.comm	ledBlinkMask,1,1
 15370               		.local	sdSampleStartBlock
 15371               		.comm	sdSampleStartBlock,4,1
 15372               		.local	sdCurrentBlockOffset
 15373               		.comm	sdCurrentBlockOffset,2,1
 15374               		.local	sdAbortRead
 15375               		.comm	sdAbortRead,1,1
 15376               		.local	sdQueuedSlot
 15377               		.comm	sdQueuedSlot,2,1
 15378               		.local	sdPlaybackQueued
 15379               		.comm	sdPlaybackQueued,1,1
 15380               		.local	lastKeyState.1897
 15381               		.comm	lastKeyState.1897,1,1
 15382               		.local	lastEncTime.1906
 15383               		.comm	lastEncTime.1906,2,1
 15384               		.local	lastEncoderState.1905
 15385               		.comm	lastEncoderState.1905,1,1
 15386               		.local	toggle.1883
 15387               		.comm	toggle.1883,1,1
 15388               		.local	lastLedMask.1884
 15389               		.comm	lastLedMask.1884,1,1
 15390               		.local	bytesLeftInBlock.2026
 15391               		.comm	bytesLeftInBlock.2026,2,1
 15392               		.text
 15393               	.Letext0:
 15394               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 15395               		.file 3 "defines.h"
 15396               		.file 4 "globals.h"
 15397               		.file 5 "midi.h"
 15398               		.file 6 "softclock.h"
 15399               		.file 7 "eeprom.h"
 15400               		.file 8 "microSD.h"
 15401               		.file 9 "uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 WTPA.c
     /tmp/ccLwxkoW.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccLwxkoW.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccLwxkoW.s:4      *ABS*:0000003f __SREG__
     /tmp/ccLwxkoW.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccLwxkoW.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccLwxkoW.s:11     .text:00000000 UpdateAudioChannel0
     /tmp/ccLwxkoW.s:15248  .bss:0000030e adcByte
     /tmp/ccLwxkoW.s:15250  .bss:0000030f sliceRemaining
     /tmp/ccLwxkoW.s:15252  .bss:00000317 sliceSize
     /tmp/ccLwxkoW.s:15254  .bss:0000031f granularPositionArrayPointer
     /tmp/ccLwxkoW.s:15267  .bss:00000326 granularPositionArray
     /tmp/ccLwxkoW.s:15265  .bss:00000325 sawtooth.1757
     /tmp/ccLwxkoW.s:15256  .bss:00000321 outOfRam
     /tmp/ccLwxkoW.s:888    .text:00000822 UpdateAudioChannel1
     /tmp/ccLwxkoW.s:15273  .bss:00000428 sawtooth.1769
     /tmp/ccLwxkoW.s:1814   .text:00001086 OutputMultiplyBanks
     /tmp/ccLwxkoW.s:15263  .bss:00000324 extIsrOutputBank0
     /tmp/ccLwxkoW.s:15277  .bss:0000042a midiOutputBank0
     /tmp/ccLwxkoW.s:15271  .bss:00000427 extIsrOutputBank1
     /tmp/ccLwxkoW.s:15291  .bss:0000042e midiOutputBank1
     /tmp/ccLwxkoW.s:15353  .bss:00000450 lastDacByte
     /tmp/ccLwxkoW.s:1924   .text:00001126 OutputAddBanks
     /tmp/ccLwxkoW.s:15301  .bss:00000437 sdStreamOutput
     /tmp/ccLwxkoW.s:1997   .text:00001192 OutputXorBanks
     /tmp/ccLwxkoW.s:2083   .text:0000120c OutputAndBanks
     /tmp/ccLwxkoW.s:2169   .text:00001286 MakeNewGranularArray
     /tmp/ccLwxkoW.s:15283  .data:00000000 random31
     /tmp/ccLwxkoW.s:2571   .text:00001506 UpdateAdjustedSampleAddresses
     /tmp/ccLwxkoW.s:3428   .text:00001d56 DoStartupSelect
     /tmp/ccLwxkoW.s:15323  .bss:00000442 subState
     /tmp/ccLwxkoW.s:15317  .bss:0000043f keyState
     /tmp/ccLwxkoW.s:3917   .text:00001fd0 InitSampler
                            *COM*:00000002 State
     /tmp/ccLwxkoW.s:3518   .text:00001dba SetMidiChannels
     /tmp/ccLwxkoW.s:8659   .text:00003a7e DoSawtooth
     /tmp/ccLwxkoW.s:15315  .bss:0000043e newKeys
     /tmp/ccLwxkoW.s:15327  .bss:00000444 ledOnOffMask
     /tmp/ccLwxkoW.s:3683   .text:00001e86 StartRecording
     /tmp/ccLwxkoW.s:15295  .bss:00000431 sdIsrState
     /tmp/ccLwxkoW.s:15335  .rodata:00000000 OctaveZeroCompareMatches
     /tmp/ccLwxkoW.s:15329  .bss:00000445 theMidiRecordRate
                            *COM*:00000002 UpdateOutput
     /tmp/ccLwxkoW.s:15331  .bss:00000449 currentBank
     /tmp/ccLwxkoW.s:15349  .bss:0000044a sdCurrentSlot
     /tmp/ccLwxkoW.s:15367  .bss:00000493 ledBlinkMask
     /tmp/ccLwxkoW.s:4816   .text:00002534 DoSampler
     /tmp/ccLwxkoW.s:4282   .text:00002252 PlaySampleFromSd
     /tmp/ccLwxkoW.s:15319  .bss:00000440 cardState
     /tmp/ccLwxkoW.s:15373  .bss:0000049a sdAbortRead
     /tmp/ccLwxkoW.s:15375  .bss:0000049b sdQueuedSlot
     /tmp/ccLwxkoW.s:15377  .bss:0000049d sdPlaybackQueued
     /tmp/ccLwxkoW.s:15240  .bss:00000008 sdBytesInFifo
     /tmp/ccLwxkoW.s:15238  .bss:00000004 sdRamSampleRemaining
     /tmp/ccLwxkoW.s:15369  .bss:00000494 sdSampleStartBlock
     /tmp/ccLwxkoW.s:15371  .bss:00000498 sdCurrentBlockOffset
     /tmp/ccLwxkoW.s:15244  .bss:0000000c sdFifoReadPointer
     /tmp/ccLwxkoW.s:15242  .bss:0000000a sdFifoWritePointer
     /tmp/ccLwxkoW.s:4530   .text:00002398 DoFruitcakeIntro
     /tmp/ccLwxkoW.s:15325  .bss:00000443 i.2279
     /tmp/ccLwxkoW.s:15258  .bss:00000322 ledPwm
     /tmp/ccLwxkoW.s:15299  .bss:00000436 sdBank0
     /tmp/ccLwxkoW.s:15307  .bss:0000043a encoderValue
     /tmp/ccLwxkoW.s:15363  .bss:00000452 scaledEncoderValue
     /tmp/ccLwxkoW.s:15361  .bss:00000451 keysHeld
     /tmp/ccLwxkoW.s:15309  .bss:0000043b newEncoder
     /tmp/ccLwxkoW.s:15351  .bss:0000044c currentMidiMessage.2230
     /tmp/ccLwxkoW.s:15357  .data:00000004 currentNoteOn.2231
     /tmp/ccLwxkoW.s:9145   .text:00003ca6 SdCardMenu
     /tmp/ccLwxkoW.s:15365  .bss:00000453 sampleToc
     /tmp/ccLwxkoW.s:15321  .bss:00000441 cardDetect
     /tmp/ccLwxkoW.s:15311  .bss:0000043c encoderCw
     /tmp/ccLwxkoW.s:15313  .bss:0000043d encoderCcw
     /tmp/ccLwxkoW.s:15297  .bss:00000432 sdRamAddress
                             .bss:00000000 sdCardSampleRemaining
     /tmp/ccLwxkoW.s:10639  .text:00004428 DoFormatCard
     /tmp/ccLwxkoW.s:10887  .text:00004544 __vector_12
     /tmp/ccLwxkoW.s:15261  .bss:00000323 flipFlop.1813
     /tmp/ccLwxkoW.s:11025  .text:000045dc __vector_6
     /tmp/ccLwxkoW.s:15269  .bss:00000426 flipFlop.1819
     /tmp/ccLwxkoW.s:11160  .text:00004670 __vector_13
     /tmp/ccLwxkoW.s:15279  .bss:0000042b lastJitterValue.1826
     /tmp/ccLwxkoW.s:15275  .bss:00000429 flipFlop.1827
     /tmp/ccLwxkoW.s:11374  .text:000047a4 __vector_14
     /tmp/ccLwxkoW.s:15293  .bss:0000042f lastJitterValue.1834
     /tmp/ccLwxkoW.s:15289  .bss:0000042d flipFlop.1835
     /tmp/ccLwxkoW.s:11586  .text:000048d6 __vector_10
     /tmp/ccLwxkoW.s:15246  .bss:0000000e sdFifo
     /tmp/ccLwxkoW.s:12099  .text:00004cce __vector_9
     /tmp/ccLwxkoW.s:15303  .bss:00000438 pwmCount.1847
     /tmp/ccLwxkoW.s:12156  .text:00004d04 __vector_default
     /tmp/ccLwxkoW.s:12187  .text:00004d18 HandleSoftclock
     /tmp/ccLwxkoW.s:12221  .text.startup:00000000 main
     /tmp/ccLwxkoW.s:15305  .bss:00000439 encoderState
     /tmp/ccLwxkoW.s:15379  .bss:0000049e lastKeyState.1897
     /tmp/ccLwxkoW.s:15381  .bss:0000049f lastEncTime.1906
     /tmp/ccLwxkoW.s:15383  .bss:000004a1 lastEncoderState.1905
     /tmp/ccLwxkoW.s:15387  .bss:000004a3 lastLedMask.1884
     /tmp/ccLwxkoW.s:15385  .bss:000004a2 toggle.1883
     /tmp/ccLwxkoW.s:15389  .bss:000004a4 bytesLeftInBlock.2026

UNDEFINED SYMBOLS
bankStates
__muluhisi3
__udivmodsi4
CheckTimer
SetTimer
midiChannelNumberA
midiChannelNumberB
EepromWrite
EepromRead
__udivmodqi4
SdBeginSingleBlockRead
PutMidiMessageInOutgoingFifo
midiMessagesInIncomingFifo
GetMidiMessageFromIncomingFifo
__tablejump2__
EndSdTransfer
InitSdInterface
__umulhisi3
systemTicks
InitMidi
InitUart0
Uart0GotByte
MidiTxBufferNotEmpty
SdHandshake
Uart0GetByte
HandleIncomingMidiByte
TransferSdByte
PopOutgoingMidiByte
SdBeginSingleBlockWrite
__do_copy_data
__do_clear_bss
