
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000054c6  0000555a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000054c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000558  0080011e  0080011e  00005578  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005578  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00005c44  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00005cdb  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  00005d0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000044f5  00000000  00000000  00005dea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a56  00000000  00000000  0000a2df  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000ff3  00000000  00000000  0000ad35  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008f4  00000000  00000000  0000bd28  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001465  00000000  00000000  0000c61c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002534  00000000  00000000  0000da81  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000200  00000000  00000000  0000ffb5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 ea 17 	jmp	0x2fd4	; 0x2fd4 <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 ea 1e 	jmp	0x3dd4	; 0x3dd4 <__vector_9>
      28:	0c 94 09 1d 	jmp	0x3a12	; 0x3a12 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 5b 17 	jmp	0x2eb6	; 0x2eb6 <__vector_12>
      34:	0c 94 32 18 	jmp	0x3064	; 0x3064 <__vector_13>
      38:	0c 94 74 1c 	jmp	0x38e8	; 0x38e8 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	86 14       	cp	r8, r6
      7e:	81 16       	cp	r8, r17
      80:	81 16       	cp	r8, r17
      82:	81 16       	cp	r8, r17
      84:	81 16       	cp	r8, r17
      86:	81 16       	cp	r8, r17
      88:	ab 14       	cp	r10, r11
      8a:	81 16       	cp	r8, r17
      8c:	81 16       	cp	r8, r17
      8e:	81 16       	cp	r8, r17
      90:	81 16       	cp	r8, r17
      92:	ee 14       	cp	r14, r14
      94:	18 15       	cp	r17, r8
      96:	2f 15       	cp	r18, r15
      98:	46 15       	cp	r20, r6
      9a:	5f 15       	cp	r21, r15
      9c:	72 15       	cp	r23, r2
      9e:	81 15       	cp	r24, r1
      a0:	88 15       	cp	r24, r8
      a2:	94 15       	cp	r25, r4
      a4:	af 15       	cp	r26, r15
      a6:	df 15       	cp	r29, r15
      a8:	e8 15       	cp	r30, r8
      aa:	f1 15       	cp	r31, r1
      ac:	fa 15       	cp	r31, r10
      ae:	ff 15       	cp	r31, r15
      b0:	0c 16       	cp	r0, r28
      b2:	19 16       	cp	r1, r25

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e6 ec       	ldi	r30, 0xC6	; 198
      c8:	f4 e5       	ldi	r31, 0x54	; 84
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	26 e0       	ldi	r18, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a6 37       	cpi	r26, 0x76	; 118
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 5a 23 	call	0x46b4	; 0x46b4 <main>
      ea:	0c 94 61 2a 	jmp	0x54c2	; 0x54c2 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 05 1f 	jmp	0x3e0a	; 0x3e0a <__vector_default>

000000f2 <UpdateAudioChannel1>:
	return(outputByte);
}

static unsigned char UpdateAudioChannel1(void)
// New banked idea of the audio handler -- ONE FOR EACH BANK!
{
      f2:	0f 93       	push	r16
      f4:	1f 93       	push	r17
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
      f6:	80 91 12 06 	lds	r24, 0x0612
      fa:	83 30       	cpi	r24, 0x03	; 3
      fc:	c1 f0       	breq	.+48     	; 0x12e <UpdateAudioChannel1+0x3c>
      fe:	30 f4       	brcc	.+12     	; 0x10c <UpdateAudioChannel1+0x1a>
     100:	81 30       	cpi	r24, 0x01	; 1
     102:	59 f0       	breq	.+22     	; 0x11a <UpdateAudioChannel1+0x28>
     104:	82 30       	cpi	r24, 0x02	; 2
     106:	09 f0       	breq	.+2      	; 0x10a <UpdateAudioChannel1+0x18>
     108:	b2 c3       	rjmp	.+1892   	; 0x86e <UpdateAudioChannel1+0x77c>
     10a:	0e c0       	rjmp	.+28     	; 0x128 <UpdateAudioChannel1+0x36>
     10c:	84 30       	cpi	r24, 0x04	; 4
     10e:	09 f4       	brne	.+2      	; 0x112 <UpdateAudioChannel1+0x20>
     110:	8e c0       	rjmp	.+284    	; 0x22e <UpdateAudioChannel1+0x13c>
     112:	85 30       	cpi	r24, 0x05	; 5
     114:	09 f0       	breq	.+2      	; 0x118 <UpdateAudioChannel1+0x26>
     116:	ab c3       	rjmp	.+1878   	; 0x86e <UpdateAudioChannel1+0x77c>
     118:	0f c2       	rjmp	.+1054   	; 0x538 <UpdateAudioChannel1+0x446>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     11a:	80 91 43 04 	lds	r24, 0x0443
     11e:	98 2f       	mov	r25, r24
     120:	9f 5f       	subi	r25, 0xFF	; 255
     122:	90 93 43 04 	sts	0x0443, r25
		break;
     126:	a4 c3       	rjmp	.+1864   	; 0x870 <UpdateAudioChannel1+0x77e>

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     128:	80 91 2c 04 	lds	r24, 0x042C
     12c:	f3 c1       	rjmp	.+998    	; 0x514 <UpdateAudioChannel1+0x422>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12e:	8f ef       	ldi	r24, 0xFF	; 255
     130:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     132:	80 91 32 06 	lds	r24, 0x0632
     136:	90 91 33 06 	lds	r25, 0x0633
     13a:	a0 91 34 06 	lds	r26, 0x0634
     13e:	b0 91 35 06 	lds	r27, 0x0635
     142:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     144:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     146:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     148:	80 91 32 06 	lds	r24, 0x0632
     14c:	90 91 33 06 	lds	r25, 0x0633
     150:	a0 91 34 06 	lds	r26, 0x0634
     154:	b0 91 35 06 	lds	r27, 0x0635
     158:	89 2f       	mov	r24, r25
     15a:	9a 2f       	mov	r25, r26
     15c:	ab 2f       	mov	r26, r27
     15e:	bb 27       	eor	r27, r27
     160:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     162:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     164:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     166:	80 91 32 06 	lds	r24, 0x0632
     16a:	90 91 33 06 	lds	r25, 0x0633
     16e:	a0 91 34 06 	lds	r26, 0x0634
     172:	b0 91 35 06 	lds	r27, 0x0635
     176:	cd 01       	movw	r24, r26
     178:	aa 27       	eor	r26, r26
     17a:	bb 27       	eor	r27, r27
     17c:	87 70       	andi	r24, 0x07	; 7
     17e:	99 27       	eor	r25, r25
     180:	aa 27       	eor	r26, r26
     182:	bb 27       	eor	r27, r27
     184:	88 68       	ori	r24, 0x88	; 136
     186:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     188:	80 91 2c 04 	lds	r24, 0x042C
     18c:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     18e:	80 91 32 06 	lds	r24, 0x0632
     192:	90 91 33 06 	lds	r25, 0x0633
     196:	a0 91 34 06 	lds	r26, 0x0634
     19a:	b0 91 35 06 	lds	r27, 0x0635
     19e:	01 97       	sbiw	r24, 0x01	; 1
     1a0:	a1 09       	sbc	r26, r1
     1a2:	b1 09       	sbc	r27, r1
     1a4:	80 93 32 06 	sts	0x0632, r24
     1a8:	90 93 33 06 	sts	0x0633, r25
     1ac:	a0 93 34 06 	sts	0x0634, r26
     1b0:	b0 93 35 06 	sts	0x0635, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     1b4:	80 91 32 06 	lds	r24, 0x0632
     1b8:	90 91 33 06 	lds	r25, 0x0633
     1bc:	a0 91 34 06 	lds	r26, 0x0634
     1c0:	b0 91 35 06 	lds	r27, 0x0635
     1c4:	80 93 1f 06 	sts	0x061F, r24
     1c8:	90 93 20 06 	sts	0x0620, r25
     1cc:	a0 93 21 06 	sts	0x0621, r26
     1d0:	b0 93 22 06 	sts	0x0622, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1d4:	80 91 32 06 	lds	r24, 0x0632
     1d8:	90 91 33 06 	lds	r25, 0x0633
     1dc:	a0 91 34 06 	lds	r26, 0x0634
     1e0:	b0 91 35 06 	lds	r27, 0x0635
     1e4:	80 93 27 06 	sts	0x0627, r24
     1e8:	90 93 28 06 	sts	0x0628, r25
     1ec:	a0 93 29 06 	sts	0x0629, r26
     1f0:	b0 93 2a 06 	sts	0x062A, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1f4:	40 91 f1 05 	lds	r20, 0x05F1
     1f8:	50 91 f2 05 	lds	r21, 0x05F2
     1fc:	60 91 f3 05 	lds	r22, 0x05F3
     200:	70 91 f4 05 	lds	r23, 0x05F4
     204:	80 91 1f 06 	lds	r24, 0x061F
     208:	90 91 20 06 	lds	r25, 0x0620
     20c:	a0 91 21 06 	lds	r26, 0x0621
     210:	b0 91 22 06 	lds	r27, 0x0622
     214:	48 17       	cp	r20, r24
     216:	59 07       	cpc	r21, r25
     218:	6a 07       	cpc	r22, r26
     21a:	7b 07       	cpc	r23, r27
     21c:	28 f0       	brcs	.+10     	; 0x228 <UpdateAudioChannel1+0x136>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     21e:	10 92 12 06 	sts	0x0612, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	80 93 3f 04 	sts	0x043F, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     228:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     22a:	11 9a       	sbi	0x02, 1	; 2
     22c:	20 c3       	rjmp	.+1600   	; 0x86e <UpdateAudioChannel1+0x77c>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     22e:	80 91 32 06 	lds	r24, 0x0632
     232:	90 91 33 06 	lds	r25, 0x0633
     236:	a0 91 34 06 	lds	r26, 0x0634
     23a:	b0 91 35 06 	lds	r27, 0x0635
     23e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     240:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     242:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     244:	80 91 32 06 	lds	r24, 0x0632
     248:	90 91 33 06 	lds	r25, 0x0633
     24c:	a0 91 34 06 	lds	r26, 0x0634
     250:	b0 91 35 06 	lds	r27, 0x0635
     254:	89 2f       	mov	r24, r25
     256:	9a 2f       	mov	r25, r26
     258:	ab 2f       	mov	r26, r27
     25a:	bb 27       	eor	r27, r27
     25c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     25e:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     260:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     262:	80 91 32 06 	lds	r24, 0x0632
     266:	90 91 33 06 	lds	r25, 0x0633
     26a:	a0 91 34 06 	lds	r26, 0x0634
     26e:	b0 91 35 06 	lds	r27, 0x0635
     272:	cd 01       	movw	r24, r26
     274:	aa 27       	eor	r26, r26
     276:	bb 27       	eor	r27, r27
     278:	87 70       	andi	r24, 0x07	; 7
     27a:	99 27       	eor	r25, r25
     27c:	aa 27       	eor	r26, r26
     27e:	bb 27       	eor	r27, r27
     280:	88 68       	ori	r24, 0x88	; 136
     282:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     284:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     286:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     288:	80 91 19 06 	lds	r24, 0x0619
     28c:	88 23       	and	r24, r24
     28e:	09 f4       	brne	.+2      	; 0x292 <UpdateAudioChannel1+0x1a0>
     290:	72 c0       	rjmp	.+228    	; 0x376 <UpdateAudioChannel1+0x284>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     292:	80 91 31 04 	lds	r24, 0x0431
     296:	90 91 32 04 	lds	r25, 0x0432
     29a:	a0 91 33 04 	lds	r26, 0x0433
     29e:	b0 91 34 04 	lds	r27, 0x0434
     2a2:	89 2b       	or	r24, r25
     2a4:	8a 2b       	or	r24, r26
     2a6:	8b 2b       	or	r24, r27
     2a8:	39 f1       	breq	.+78     	; 0x2f8 <UpdateAudioChannel1+0x206>
			{
				bankStates[BANK_1].currentAddress--;
     2aa:	80 91 32 06 	lds	r24, 0x0632
     2ae:	90 91 33 06 	lds	r25, 0x0633
     2b2:	a0 91 34 06 	lds	r26, 0x0634
     2b6:	b0 91 35 06 	lds	r27, 0x0635
     2ba:	01 97       	sbiw	r24, 0x01	; 1
     2bc:	a1 09       	sbc	r26, r1
     2be:	b1 09       	sbc	r27, r1
     2c0:	80 93 32 06 	sts	0x0632, r24
     2c4:	90 93 33 06 	sts	0x0633, r25
     2c8:	a0 93 34 06 	sts	0x0634, r26
     2cc:	b0 93 35 06 	sts	0x0635, r27
				sliceRemaining[BANK_1]--;
     2d0:	80 91 31 04 	lds	r24, 0x0431
     2d4:	90 91 32 04 	lds	r25, 0x0432
     2d8:	a0 91 33 04 	lds	r26, 0x0433
     2dc:	b0 91 34 04 	lds	r27, 0x0434
     2e0:	01 97       	sbiw	r24, 0x01	; 1
     2e2:	a1 09       	sbc	r26, r1
     2e4:	b1 09       	sbc	r27, r1
     2e6:	80 93 31 04 	sts	0x0431, r24
     2ea:	90 93 32 04 	sts	0x0432, r25
     2ee:	a0 93 33 04 	sts	0x0433, r26
     2f2:	b0 93 34 04 	sts	0x0434, r27
     2f6:	0a c1       	rjmp	.+532    	; 0x50c <UpdateAudioChannel1+0x41a>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     2f8:	80 91 39 04 	lds	r24, 0x0439
     2fc:	90 91 3a 04 	lds	r25, 0x043A
     300:	a0 91 3b 04 	lds	r26, 0x043B
     304:	b0 91 3c 04 	lds	r27, 0x043C
     308:	80 93 31 04 	sts	0x0431, r24
     30c:	90 93 32 04 	sts	0x0432, r25
     310:	a0 93 33 04 	sts	0x0433, r26
     314:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     318:	80 91 3e 04 	lds	r24, 0x043E
     31c:	8f 5f       	subi	r24, 0xFF	; 255
     31e:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     322:	90 91 3e 04 	lds	r25, 0x043E
     326:	80 91 19 06 	lds	r24, 0x0619
     32a:	98 13       	cpse	r25, r24
     32c:	02 c0       	rjmp	.+4      	; 0x332 <UpdateAudioChannel1+0x240>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     32e:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     332:	e0 91 3e 04 	lds	r30, 0x043E
     336:	20 91 39 04 	lds	r18, 0x0439
     33a:	30 91 3a 04 	lds	r19, 0x043A
     33e:	40 91 3b 04 	lds	r20, 0x043B
     342:	50 91 3c 04 	lds	r21, 0x043C
     346:	f0 e0       	ldi	r31, 0x00	; 0
     348:	ec 53       	subi	r30, 0x3C	; 60
     34a:	fb 4f       	sbci	r31, 0xFB	; 251
     34c:	a0 81       	ld	r26, Z
     34e:	b0 e0       	ldi	r27, 0x00	; 0
     350:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     354:	0f ef       	ldi	r16, 0xFF	; 255
     356:	1f ef       	ldi	r17, 0xFF	; 255
     358:	27 e0       	ldi	r18, 0x07	; 7
     35a:	30 e0       	ldi	r19, 0x00	; 0
     35c:	06 1b       	sub	r16, r22
     35e:	17 0b       	sbc	r17, r23
     360:	28 0b       	sbc	r18, r24
     362:	39 0b       	sbc	r19, r25
     364:	00 93 32 06 	sts	0x0632, r16
     368:	10 93 33 06 	sts	0x0633, r17
     36c:	20 93 34 06 	sts	0x0634, r18
     370:	30 93 35 06 	sts	0x0635, r19
     374:	cb c0       	rjmp	.+406    	; 0x50c <UpdateAudioChannel1+0x41a>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     376:	80 91 16 06 	lds	r24, 0x0616
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     37a:	40 91 32 06 	lds	r20, 0x0632
     37e:	50 91 33 06 	lds	r21, 0x0633
     382:	60 91 34 06 	lds	r22, 0x0634
     386:	70 91 35 06 	lds	r23, 0x0635
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     38a:	81 11       	cpse	r24, r1
     38c:	5a c0       	rjmp	.+180    	; 0x442 <UpdateAudioChannel1+0x350>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     38e:	80 91 2b 06 	lds	r24, 0x062B
     392:	90 91 2c 06 	lds	r25, 0x062C
     396:	a0 91 2d 06 	lds	r26, 0x062D
     39a:	b0 91 2e 06 	lds	r27, 0x062E
     39e:	48 17       	cp	r20, r24
     3a0:	59 07       	cpc	r21, r25
     3a2:	6a 07       	cpc	r22, r26
     3a4:	7b 07       	cpc	r23, r27
     3a6:	29 f4       	brne	.+10     	; 0x3b2 <UpdateAudioChannel1+0x2c0>
     3a8:	80 91 13 06 	lds	r24, 0x0613
     3ac:	81 30       	cpi	r24, 0x01	; 1
     3ae:	09 f4       	brne	.+2      	; 0x3b2 <UpdateAudioChannel1+0x2c0>
     3b0:	59 c0       	rjmp	.+178    	; 0x464 <UpdateAudioChannel1+0x372>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     3b2:	40 91 32 06 	lds	r20, 0x0632
     3b6:	50 91 33 06 	lds	r21, 0x0633
     3ba:	60 91 34 06 	lds	r22, 0x0634
     3be:	70 91 35 06 	lds	r23, 0x0635
     3c2:	80 91 2b 06 	lds	r24, 0x062B
     3c6:	90 91 2c 06 	lds	r25, 0x062C
     3ca:	a0 91 2d 06 	lds	r26, 0x062D
     3ce:	b0 91 2e 06 	lds	r27, 0x062E
     3d2:	48 17       	cp	r20, r24
     3d4:	59 07       	cpc	r21, r25
     3d6:	6a 07       	cpc	r22, r26
     3d8:	7b 07       	cpc	r23, r27
     3da:	49 f4       	brne	.+18     	; 0x3ee <UpdateAudioChannel1+0x2fc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     3dc:	80 91 27 06 	lds	r24, 0x0627
     3e0:	90 91 28 06 	lds	r25, 0x0628
     3e4:	a0 91 29 06 	lds	r26, 0x0629
     3e8:	b0 91 2a 06 	lds	r27, 0x062A
     3ec:	87 c0       	rjmp	.+270    	; 0x4fc <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3ee:	40 91 32 06 	lds	r20, 0x0632
     3f2:	50 91 33 06 	lds	r21, 0x0633
     3f6:	60 91 34 06 	lds	r22, 0x0634
     3fa:	70 91 35 06 	lds	r23, 0x0635
     3fe:	80 91 23 06 	lds	r24, 0x0623
     402:	90 91 24 06 	lds	r25, 0x0624
     406:	a0 91 25 06 	lds	r26, 0x0625
     40a:	b0 91 26 06 	lds	r27, 0x0626
     40e:	48 17       	cp	r20, r24
     410:	59 07       	cpc	r21, r25
     412:	6a 07       	cpc	r22, r26
     414:	7b 07       	cpc	r23, r27
     416:	49 f4       	brne	.+18     	; 0x42a <UpdateAudioChannel1+0x338>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     418:	80 91 1f 06 	lds	r24, 0x061F
     41c:	90 91 20 06 	lds	r25, 0x0620
     420:	a0 91 21 06 	lds	r26, 0x0621
     424:	b0 91 22 06 	lds	r27, 0x0622
     428:	69 c0       	rjmp	.+210    	; 0x4fc <UpdateAudioChannel1+0x40a>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     42a:	80 91 32 06 	lds	r24, 0x0632
     42e:	90 91 33 06 	lds	r25, 0x0633
     432:	a0 91 34 06 	lds	r26, 0x0634
     436:	b0 91 35 06 	lds	r27, 0x0635
     43a:	01 96       	adiw	r24, 0x01	; 1
     43c:	a1 1d       	adc	r26, r1
     43e:	b1 1d       	adc	r27, r1
     440:	5d c0       	rjmp	.+186    	; 0x4fc <UpdateAudioChannel1+0x40a>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     442:	80 91 27 06 	lds	r24, 0x0627
     446:	90 91 28 06 	lds	r25, 0x0628
     44a:	a0 91 29 06 	lds	r26, 0x0629
     44e:	b0 91 2a 06 	lds	r27, 0x062A
     452:	48 17       	cp	r20, r24
     454:	59 07       	cpc	r21, r25
     456:	6a 07       	cpc	r22, r26
     458:	7b 07       	cpc	r23, r27
     45a:	49 f4       	brne	.+18     	; 0x46e <UpdateAudioChannel1+0x37c>
     45c:	80 91 13 06 	lds	r24, 0x0613
     460:	81 30       	cpi	r24, 0x01	; 1
     462:	29 f4       	brne	.+10     	; 0x46e <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     464:	10 92 12 06 	sts	0x0612, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     468:	10 92 1c 06 	sts	0x061C, r1
     46c:	4f c0       	rjmp	.+158    	; 0x50c <UpdateAudioChannel1+0x41a>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     46e:	40 91 32 06 	lds	r20, 0x0632
     472:	50 91 33 06 	lds	r21, 0x0633
     476:	60 91 34 06 	lds	r22, 0x0634
     47a:	70 91 35 06 	lds	r23, 0x0635
     47e:	80 91 27 06 	lds	r24, 0x0627
     482:	90 91 28 06 	lds	r25, 0x0628
     486:	a0 91 29 06 	lds	r26, 0x0629
     48a:	b0 91 2a 06 	lds	r27, 0x062A
     48e:	48 17       	cp	r20, r24
     490:	59 07       	cpc	r21, r25
     492:	6a 07       	cpc	r22, r26
     494:	7b 07       	cpc	r23, r27
     496:	49 f4       	brne	.+18     	; 0x4aa <UpdateAudioChannel1+0x3b8>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     498:	80 91 2b 06 	lds	r24, 0x062B
     49c:	90 91 2c 06 	lds	r25, 0x062C
     4a0:	a0 91 2d 06 	lds	r26, 0x062D
     4a4:	b0 91 2e 06 	lds	r27, 0x062E
     4a8:	29 c0       	rjmp	.+82     	; 0x4fc <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     4aa:	40 91 32 06 	lds	r20, 0x0632
     4ae:	50 91 33 06 	lds	r21, 0x0633
     4b2:	60 91 34 06 	lds	r22, 0x0634
     4b6:	70 91 35 06 	lds	r23, 0x0635
     4ba:	80 91 1f 06 	lds	r24, 0x061F
     4be:	90 91 20 06 	lds	r25, 0x0620
     4c2:	a0 91 21 06 	lds	r26, 0x0621
     4c6:	b0 91 22 06 	lds	r27, 0x0622
     4ca:	48 17       	cp	r20, r24
     4cc:	59 07       	cpc	r21, r25
     4ce:	6a 07       	cpc	r22, r26
     4d0:	7b 07       	cpc	r23, r27
     4d2:	49 f4       	brne	.+18     	; 0x4e6 <UpdateAudioChannel1+0x3f4>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     4d4:	80 91 23 06 	lds	r24, 0x0623
     4d8:	90 91 24 06 	lds	r25, 0x0624
     4dc:	a0 91 25 06 	lds	r26, 0x0625
     4e0:	b0 91 26 06 	lds	r27, 0x0626
     4e4:	0b c0       	rjmp	.+22     	; 0x4fc <UpdateAudioChannel1+0x40a>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     4e6:	80 91 32 06 	lds	r24, 0x0632
     4ea:	90 91 33 06 	lds	r25, 0x0633
     4ee:	a0 91 34 06 	lds	r26, 0x0634
     4f2:	b0 91 35 06 	lds	r27, 0x0635
     4f6:	01 97       	sbiw	r24, 0x01	; 1
     4f8:	a1 09       	sbc	r26, r1
     4fa:	b1 09       	sbc	r27, r1
     4fc:	80 93 32 06 	sts	0x0632, r24
     500:	90 93 33 06 	sts	0x0633, r25
     504:	a0 93 34 06 	sts	0x0634, r26
     508:	b0 93 35 06 	sts	0x0635, r27
			}
		}

		// Done with addy, read RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     50c:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     50e:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     510:	9f ef       	ldi	r25, 0xFF	; 255
     512:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     514:	90 91 1b 06 	lds	r25, 0x061B
     518:	99 23       	and	r25, r25
     51a:	09 f4       	brne	.+2      	; 0x51e <UpdateAudioChannel1+0x42c>
     51c:	a9 c1       	rjmp	.+850    	; 0x870 <UpdateAudioChannel1+0x77e>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     51e:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     520:	90 91 1b 06 	lds	r25, 0x061B
     524:	2f ef       	ldi	r18, 0xFF	; 255
     526:	30 e0       	ldi	r19, 0x00	; 0
     528:	09 2e       	mov	r0, r25
     52a:	01 c0       	rjmp	.+2      	; 0x52e <UpdateAudioChannel1+0x43c>
     52c:	22 0f       	add	r18, r18
     52e:	0a 94       	dec	r0
     530:	ea f7       	brpl	.-6      	; 0x52c <UpdateAudioChannel1+0x43a>
     532:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     534:	80 58       	subi	r24, 0x80	; 128
     536:	9c c1       	rjmp	.+824    	; 0x870 <UpdateAudioChannel1+0x77e>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     538:	80 91 32 06 	lds	r24, 0x0632
     53c:	90 91 33 06 	lds	r25, 0x0633
     540:	a0 91 34 06 	lds	r26, 0x0634
     544:	b0 91 35 06 	lds	r27, 0x0635
     548:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     54a:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     54c:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     54e:	80 91 32 06 	lds	r24, 0x0632
     552:	90 91 33 06 	lds	r25, 0x0633
     556:	a0 91 34 06 	lds	r26, 0x0634
     55a:	b0 91 35 06 	lds	r27, 0x0635
     55e:	89 2f       	mov	r24, r25
     560:	9a 2f       	mov	r25, r26
     562:	ab 2f       	mov	r26, r27
     564:	bb 27       	eor	r27, r27
     566:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     568:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     56a:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     56c:	80 91 32 06 	lds	r24, 0x0632
     570:	90 91 33 06 	lds	r25, 0x0633
     574:	a0 91 34 06 	lds	r26, 0x0634
     578:	b0 91 35 06 	lds	r27, 0x0635
     57c:	cd 01       	movw	r24, r26
     57e:	aa 27       	eor	r26, r26
     580:	bb 27       	eor	r27, r27
     582:	87 70       	andi	r24, 0x07	; 7
     584:	99 27       	eor	r25, r25
     586:	aa 27       	eor	r26, r26
     588:	bb 27       	eor	r27, r27
     58a:	88 68       	ori	r24, 0x88	; 136
     58c:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     58e:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     590:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     592:	80 91 19 06 	lds	r24, 0x0619
     596:	88 23       	and	r24, r24
     598:	09 f4       	brne	.+2      	; 0x59c <UpdateAudioChannel1+0x4aa>
     59a:	72 c0       	rjmp	.+228    	; 0x680 <UpdateAudioChannel1+0x58e>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     59c:	80 91 31 04 	lds	r24, 0x0431
     5a0:	90 91 32 04 	lds	r25, 0x0432
     5a4:	a0 91 33 04 	lds	r26, 0x0433
     5a8:	b0 91 34 04 	lds	r27, 0x0434
     5ac:	89 2b       	or	r24, r25
     5ae:	8a 2b       	or	r24, r26
     5b0:	8b 2b       	or	r24, r27
     5b2:	39 f1       	breq	.+78     	; 0x602 <UpdateAudioChannel1+0x510>
			{
				bankStates[BANK_1].currentAddress--;
     5b4:	80 91 32 06 	lds	r24, 0x0632
     5b8:	90 91 33 06 	lds	r25, 0x0633
     5bc:	a0 91 34 06 	lds	r26, 0x0634
     5c0:	b0 91 35 06 	lds	r27, 0x0635
     5c4:	01 97       	sbiw	r24, 0x01	; 1
     5c6:	a1 09       	sbc	r26, r1
     5c8:	b1 09       	sbc	r27, r1
     5ca:	80 93 32 06 	sts	0x0632, r24
     5ce:	90 93 33 06 	sts	0x0633, r25
     5d2:	a0 93 34 06 	sts	0x0634, r26
     5d6:	b0 93 35 06 	sts	0x0635, r27
				sliceRemaining[BANK_1]--;
     5da:	80 91 31 04 	lds	r24, 0x0431
     5de:	90 91 32 04 	lds	r25, 0x0432
     5e2:	a0 91 33 04 	lds	r26, 0x0433
     5e6:	b0 91 34 04 	lds	r27, 0x0434
     5ea:	01 97       	sbiw	r24, 0x01	; 1
     5ec:	a1 09       	sbc	r26, r1
     5ee:	b1 09       	sbc	r27, r1
     5f0:	80 93 31 04 	sts	0x0431, r24
     5f4:	90 93 32 04 	sts	0x0432, r25
     5f8:	a0 93 33 04 	sts	0x0433, r26
     5fc:	b0 93 34 04 	sts	0x0434, r27
     600:	0a c1       	rjmp	.+532    	; 0x816 <UpdateAudioChannel1+0x724>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     602:	80 91 39 04 	lds	r24, 0x0439
     606:	90 91 3a 04 	lds	r25, 0x043A
     60a:	a0 91 3b 04 	lds	r26, 0x043B
     60e:	b0 91 3c 04 	lds	r27, 0x043C
     612:	80 93 31 04 	sts	0x0431, r24
     616:	90 93 32 04 	sts	0x0432, r25
     61a:	a0 93 33 04 	sts	0x0433, r26
     61e:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     622:	80 91 3e 04 	lds	r24, 0x043E
     626:	8f 5f       	subi	r24, 0xFF	; 255
     628:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     62c:	90 91 3e 04 	lds	r25, 0x043E
     630:	80 91 19 06 	lds	r24, 0x0619
     634:	98 13       	cpse	r25, r24
     636:	02 c0       	rjmp	.+4      	; 0x63c <UpdateAudioChannel1+0x54a>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     638:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     63c:	e0 91 3e 04 	lds	r30, 0x043E
     640:	20 91 39 04 	lds	r18, 0x0439
     644:	30 91 3a 04 	lds	r19, 0x043A
     648:	40 91 3b 04 	lds	r20, 0x043B
     64c:	50 91 3c 04 	lds	r21, 0x043C
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	ec 53       	subi	r30, 0x3C	; 60
     654:	fb 4f       	sbci	r31, 0xFB	; 251
     656:	a0 81       	ld	r26, Z
     658:	b0 e0       	ldi	r27, 0x00	; 0
     65a:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     65e:	0f ef       	ldi	r16, 0xFF	; 255
     660:	1f ef       	ldi	r17, 0xFF	; 255
     662:	27 e0       	ldi	r18, 0x07	; 7
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	06 1b       	sub	r16, r22
     668:	17 0b       	sbc	r17, r23
     66a:	28 0b       	sbc	r18, r24
     66c:	39 0b       	sbc	r19, r25
     66e:	00 93 32 06 	sts	0x0632, r16
     672:	10 93 33 06 	sts	0x0633, r17
     676:	20 93 34 06 	sts	0x0634, r18
     67a:	30 93 35 06 	sts	0x0635, r19
     67e:	cb c0       	rjmp	.+406    	; 0x816 <UpdateAudioChannel1+0x724>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     680:	80 91 16 06 	lds	r24, 0x0616
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     684:	40 91 32 06 	lds	r20, 0x0632
     688:	50 91 33 06 	lds	r21, 0x0633
     68c:	60 91 34 06 	lds	r22, 0x0634
     690:	70 91 35 06 	lds	r23, 0x0635
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     694:	81 11       	cpse	r24, r1
     696:	5a c0       	rjmp	.+180    	; 0x74c <UpdateAudioChannel1+0x65a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     698:	80 91 2b 06 	lds	r24, 0x062B
     69c:	90 91 2c 06 	lds	r25, 0x062C
     6a0:	a0 91 2d 06 	lds	r26, 0x062D
     6a4:	b0 91 2e 06 	lds	r27, 0x062E
     6a8:	48 17       	cp	r20, r24
     6aa:	59 07       	cpc	r21, r25
     6ac:	6a 07       	cpc	r22, r26
     6ae:	7b 07       	cpc	r23, r27
     6b0:	29 f4       	brne	.+10     	; 0x6bc <UpdateAudioChannel1+0x5ca>
     6b2:	80 91 13 06 	lds	r24, 0x0613
     6b6:	81 30       	cpi	r24, 0x01	; 1
     6b8:	09 f4       	brne	.+2      	; 0x6bc <UpdateAudioChannel1+0x5ca>
     6ba:	59 c0       	rjmp	.+178    	; 0x76e <UpdateAudioChannel1+0x67c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     6bc:	40 91 32 06 	lds	r20, 0x0632
     6c0:	50 91 33 06 	lds	r21, 0x0633
     6c4:	60 91 34 06 	lds	r22, 0x0634
     6c8:	70 91 35 06 	lds	r23, 0x0635
     6cc:	80 91 2b 06 	lds	r24, 0x062B
     6d0:	90 91 2c 06 	lds	r25, 0x062C
     6d4:	a0 91 2d 06 	lds	r26, 0x062D
     6d8:	b0 91 2e 06 	lds	r27, 0x062E
     6dc:	48 17       	cp	r20, r24
     6de:	59 07       	cpc	r21, r25
     6e0:	6a 07       	cpc	r22, r26
     6e2:	7b 07       	cpc	r23, r27
     6e4:	49 f4       	brne	.+18     	; 0x6f8 <UpdateAudioChannel1+0x606>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     6e6:	80 91 27 06 	lds	r24, 0x0627
     6ea:	90 91 28 06 	lds	r25, 0x0628
     6ee:	a0 91 29 06 	lds	r26, 0x0629
     6f2:	b0 91 2a 06 	lds	r27, 0x062A
     6f6:	87 c0       	rjmp	.+270    	; 0x806 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6f8:	40 91 32 06 	lds	r20, 0x0632
     6fc:	50 91 33 06 	lds	r21, 0x0633
     700:	60 91 34 06 	lds	r22, 0x0634
     704:	70 91 35 06 	lds	r23, 0x0635
     708:	80 91 23 06 	lds	r24, 0x0623
     70c:	90 91 24 06 	lds	r25, 0x0624
     710:	a0 91 25 06 	lds	r26, 0x0625
     714:	b0 91 26 06 	lds	r27, 0x0626
     718:	48 17       	cp	r20, r24
     71a:	59 07       	cpc	r21, r25
     71c:	6a 07       	cpc	r22, r26
     71e:	7b 07       	cpc	r23, r27
     720:	49 f4       	brne	.+18     	; 0x734 <UpdateAudioChannel1+0x642>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     722:	80 91 1f 06 	lds	r24, 0x061F
     726:	90 91 20 06 	lds	r25, 0x0620
     72a:	a0 91 21 06 	lds	r26, 0x0621
     72e:	b0 91 22 06 	lds	r27, 0x0622
     732:	69 c0       	rjmp	.+210    	; 0x806 <UpdateAudioChannel1+0x714>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     734:	80 91 32 06 	lds	r24, 0x0632
     738:	90 91 33 06 	lds	r25, 0x0633
     73c:	a0 91 34 06 	lds	r26, 0x0634
     740:	b0 91 35 06 	lds	r27, 0x0635
     744:	01 96       	adiw	r24, 0x01	; 1
     746:	a1 1d       	adc	r26, r1
     748:	b1 1d       	adc	r27, r1
     74a:	5d c0       	rjmp	.+186    	; 0x806 <UpdateAudioChannel1+0x714>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     74c:	80 91 27 06 	lds	r24, 0x0627
     750:	90 91 28 06 	lds	r25, 0x0628
     754:	a0 91 29 06 	lds	r26, 0x0629
     758:	b0 91 2a 06 	lds	r27, 0x062A
     75c:	48 17       	cp	r20, r24
     75e:	59 07       	cpc	r21, r25
     760:	6a 07       	cpc	r22, r26
     762:	7b 07       	cpc	r23, r27
     764:	49 f4       	brne	.+18     	; 0x778 <UpdateAudioChannel1+0x686>
     766:	80 91 13 06 	lds	r24, 0x0613
     76a:	81 30       	cpi	r24, 0x01	; 1
     76c:	29 f4       	brne	.+10     	; 0x778 <UpdateAudioChannel1+0x686>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     76e:	10 92 12 06 	sts	0x0612, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     772:	10 92 1c 06 	sts	0x061C, r1
     776:	4f c0       	rjmp	.+158    	; 0x816 <UpdateAudioChannel1+0x724>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     778:	40 91 32 06 	lds	r20, 0x0632
     77c:	50 91 33 06 	lds	r21, 0x0633
     780:	60 91 34 06 	lds	r22, 0x0634
     784:	70 91 35 06 	lds	r23, 0x0635
     788:	80 91 27 06 	lds	r24, 0x0627
     78c:	90 91 28 06 	lds	r25, 0x0628
     790:	a0 91 29 06 	lds	r26, 0x0629
     794:	b0 91 2a 06 	lds	r27, 0x062A
     798:	48 17       	cp	r20, r24
     79a:	59 07       	cpc	r21, r25
     79c:	6a 07       	cpc	r22, r26
     79e:	7b 07       	cpc	r23, r27
     7a0:	49 f4       	brne	.+18     	; 0x7b4 <UpdateAudioChannel1+0x6c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     7a2:	80 91 2b 06 	lds	r24, 0x062B
     7a6:	90 91 2c 06 	lds	r25, 0x062C
     7aa:	a0 91 2d 06 	lds	r26, 0x062D
     7ae:	b0 91 2e 06 	lds	r27, 0x062E
     7b2:	29 c0       	rjmp	.+82     	; 0x806 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     7b4:	40 91 32 06 	lds	r20, 0x0632
     7b8:	50 91 33 06 	lds	r21, 0x0633
     7bc:	60 91 34 06 	lds	r22, 0x0634
     7c0:	70 91 35 06 	lds	r23, 0x0635
     7c4:	80 91 1f 06 	lds	r24, 0x061F
     7c8:	90 91 20 06 	lds	r25, 0x0620
     7cc:	a0 91 21 06 	lds	r26, 0x0621
     7d0:	b0 91 22 06 	lds	r27, 0x0622
     7d4:	48 17       	cp	r20, r24
     7d6:	59 07       	cpc	r21, r25
     7d8:	6a 07       	cpc	r22, r26
     7da:	7b 07       	cpc	r23, r27
     7dc:	49 f4       	brne	.+18     	; 0x7f0 <UpdateAudioChannel1+0x6fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     7de:	80 91 23 06 	lds	r24, 0x0623
     7e2:	90 91 24 06 	lds	r25, 0x0624
     7e6:	a0 91 25 06 	lds	r26, 0x0625
     7ea:	b0 91 26 06 	lds	r27, 0x0626
     7ee:	0b c0       	rjmp	.+22     	; 0x806 <UpdateAudioChannel1+0x714>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     7f0:	80 91 32 06 	lds	r24, 0x0632
     7f4:	90 91 33 06 	lds	r25, 0x0633
     7f8:	a0 91 34 06 	lds	r26, 0x0634
     7fc:	b0 91 35 06 	lds	r27, 0x0635
     800:	01 97       	sbiw	r24, 0x01	; 1
     802:	a1 09       	sbc	r26, r1
     804:	b1 09       	sbc	r27, r1
     806:	80 93 32 06 	sts	0x0632, r24
     80a:	90 93 33 06 	sts	0x0633, r25
     80e:	a0 93 34 06 	sts	0x0634, r26
     812:	b0 93 35 06 	sts	0x0635, r27
			}
		}

		// Finished with addy stuff, now finish data transfer

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     816:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     818:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     81a:	9f ef       	ldi	r25, 0xFF	; 255
     81c:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     81e:	90 91 1b 06 	lds	r25, 0x061B
     822:	99 23       	and	r25, r25
     824:	61 f0       	breq	.+24     	; 0x83e <UpdateAudioChannel1+0x74c>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     826:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     828:	90 91 1b 06 	lds	r25, 0x061B
     82c:	2f ef       	ldi	r18, 0xFF	; 255
     82e:	30 e0       	ldi	r19, 0x00	; 0
     830:	09 2e       	mov	r0, r25
     832:	01 c0       	rjmp	.+2      	; 0x836 <UpdateAudioChannel1+0x744>
     834:	22 0f       	add	r18, r18
     836:	0a 94       	dec	r0
     838:	ea f7       	brpl	.-6      	; 0x834 <UpdateAudioChannel1+0x742>
     83a:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     83c:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     83e:	20 91 2c 04 	lds	r18, 0x042C
     842:	33 27       	eor	r19, r19
     844:	27 fd       	sbrc	r18, 7
     846:	30 95       	com	r19
     848:	28 0f       	add	r18, r24
     84a:	31 1d       	adc	r19, r1
     84c:	87 fd       	sbrc	r24, 7
     84e:	3a 95       	dec	r19
     850:	20 38       	cpi	r18, 0x80	; 128
     852:	9f ef       	ldi	r25, 0xFF	; 255
     854:	39 07       	cpc	r19, r25
     856:	14 f4       	brge	.+4      	; 0x85c <UpdateAudioChannel1+0x76a>
     858:	20 e8       	ldi	r18, 0x80	; 128
     85a:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     85c:	20 38       	cpi	r18, 0x80	; 128
     85e:	31 05       	cpc	r19, r1
     860:	14 f0       	brlt	.+4      	; 0x866 <UpdateAudioChannel1+0x774>
     862:	2f e7       	ldi	r18, 0x7F	; 127
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     868:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     86a:	11 9a       	sbi	0x02, 1	; 2
		break;
     86c:	01 c0       	rjmp	.+2      	; 0x870 <UpdateAudioChannel1+0x77e>
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     86e:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     876:	80 91 67 05 	lds	r24, 0x0567
     87a:	20 91 45 05 	lds	r18, 0x0545
     87e:	33 27       	eor	r19, r19
     880:	27 fd       	sbrc	r18, 7
     882:	30 95       	com	r19
     884:	28 0f       	add	r18, r24
     886:	31 1d       	adc	r19, r1
     888:	87 fd       	sbrc	r24, 7
     88a:	3a 95       	dec	r19
     88c:	20 38       	cpi	r18, 0x80	; 128
     88e:	4f ef       	ldi	r20, 0xFF	; 255
     890:	34 07       	cpc	r19, r20
     892:	14 f4       	brge	.+4      	; 0x898 <OutputMultiplyBanks+0x22>
     894:	20 e8       	ldi	r18, 0x80	; 128
     896:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     898:	40 91 42 04 	lds	r20, 0x0442
     89c:	80 91 4a 05 	lds	r24, 0x054A
     8a0:	99 27       	eor	r25, r25
     8a2:	87 fd       	sbrc	r24, 7
     8a4:	90 95       	com	r25
     8a6:	84 0f       	add	r24, r20
     8a8:	91 1d       	adc	r25, r1
     8aa:	47 fd       	sbrc	r20, 7
     8ac:	9a 95       	dec	r25
     8ae:	81 38       	cpi	r24, 0x81	; 129
     8b0:	4f ef       	ldi	r20, 0xFF	; 255
     8b2:	94 07       	cpc	r25, r20
     8b4:	14 f4       	brge	.+4      	; 0x8ba <OutputMultiplyBanks+0x44>
     8b6:	81 e8       	ldi	r24, 0x81	; 129
     8b8:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
     8ba:	20 38       	cpi	r18, 0x80	; 128
     8bc:	31 05       	cpc	r19, r1
     8be:	14 f0       	brlt	.+4      	; 0x8c4 <OutputMultiplyBanks+0x4e>
     8c0:	2f e7       	ldi	r18, 0x7F	; 127
     8c2:	30 e0       	ldi	r19, 0x00	; 0
     8c4:	80 38       	cpi	r24, 0x80	; 128
     8c6:	91 05       	cpc	r25, r1
     8c8:	14 f0       	brlt	.+4      	; 0x8ce <OutputMultiplyBanks+0x58>
     8ca:	8f e7       	ldi	r24, 0x7F	; 127
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	28 9f       	mul	r18, r24
     8d0:	a0 01       	movw	r20, r0
     8d2:	29 9f       	mul	r18, r25
     8d4:	50 0d       	add	r21, r0
     8d6:	38 9f       	mul	r19, r24
     8d8:	50 0d       	add	r21, r0
     8da:	11 24       	eor	r1, r1
     8dc:	57 ff       	sbrs	r21, 7
     8de:	02 c0       	rjmp	.+4      	; 0x8e4 <OutputMultiplyBanks+0x6e>
     8e0:	41 5c       	subi	r20, 0xC1	; 193
     8e2:	5f 4f       	sbci	r21, 0xFF	; 255
     8e4:	ca 01       	movw	r24, r20
     8e6:	e6 e0       	ldi	r30, 0x06	; 6
     8e8:	95 95       	asr	r25
     8ea:	87 95       	ror	r24
     8ec:	ea 95       	dec	r30
     8ee:	e1 f7       	brne	.-8      	; 0x8e8 <OutputMultiplyBanks+0x72>

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
     8f0:	80 58       	subi	r24, 0x80	; 128
     8f2:	90 95       	com	r25
     8f4:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
     8f6:	30 91 68 05 	lds	r19, 0x0568
     8fa:	83 17       	cp	r24, r19
     8fc:	29 f0       	breq	.+10     	; 0x908 <OutputMultiplyBanks+0x92>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     8fe:	9f ef       	ldi	r25, 0xFF	; 255
     900:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
     902:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
     904:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     906:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
     908:	20 93 68 05 	sts	0x0568, r18
     90c:	08 95       	ret

0000090e <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC

//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
     90e:	20 91 67 05 	lds	r18, 0x0567
     912:	80 91 42 04 	lds	r24, 0x0442
     916:	99 27       	eor	r25, r25
     918:	87 fd       	sbrc	r24, 7
     91a:	90 95       	com	r25
     91c:	82 0f       	add	r24, r18
     91e:	91 1d       	adc	r25, r1
     920:	27 fd       	sbrc	r18, 7
     922:	9a 95       	dec	r25
     924:	20 91 45 05 	lds	r18, 0x0545
     928:	82 0f       	add	r24, r18
     92a:	91 1d       	adc	r25, r1
     92c:	27 fd       	sbrc	r18, 7
     92e:	9a 95       	dec	r25
     930:	20 91 4a 05 	lds	r18, 0x054A
     934:	82 0f       	add	r24, r18
     936:	91 1d       	adc	r25, r1
     938:	27 fd       	sbrc	r18, 7
     93a:	9a 95       	dec	r25
     93c:	20 91 53 05 	lds	r18, 0x0553
     940:	82 0f       	add	r24, r18
     942:	91 1d       	adc	r25, r1
     944:	27 fd       	sbrc	r18, 7
     946:	9a 95       	dec	r25
     948:	80 38       	cpi	r24, 0x80	; 128
     94a:	2f ef       	ldi	r18, 0xFF	; 255
     94c:	92 07       	cpc	r25, r18
     94e:	14 f4       	brge	.+4      	; 0x954 <OutputAddBanks+0x46>
     950:	80 e8       	ldi	r24, 0x80	; 128
     952:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
     954:	80 38       	cpi	r24, 0x80	; 128
     956:	91 05       	cpc	r25, r1
     958:	14 f0       	brlt	.+4      	; 0x95e <OutputAddBanks+0x50>
     95a:	8f e7       	ldi	r24, 0x7F	; 127
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	80 58       	subi	r24, 0x80	; 128
     960:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
     962:	30 91 68 05 	lds	r19, 0x0568
     966:	83 17       	cp	r24, r19
     968:	29 f0       	breq	.+10     	; 0x974 <OutputAddBanks+0x66>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     96a:	9f ef       	ldi	r25, 0xFF	; 255
     96c:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
     96e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
     970:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     972:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
     974:	20 93 68 05 	sts	0x0568, r18
     978:	08 95       	ret

0000097a <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     97a:	20 91 67 05 	lds	r18, 0x0567
     97e:	80 91 45 05 	lds	r24, 0x0545
     982:	99 27       	eor	r25, r25
     984:	87 fd       	sbrc	r24, 7
     986:	90 95       	com	r25
     988:	82 0f       	add	r24, r18
     98a:	91 1d       	adc	r25, r1
     98c:	27 fd       	sbrc	r18, 7
     98e:	9a 95       	dec	r25
     990:	80 38       	cpi	r24, 0x80	; 128
     992:	2f ef       	ldi	r18, 0xFF	; 255
     994:	92 07       	cpc	r25, r18
     996:	14 f4       	brge	.+4      	; 0x99c <OutputXorBanks+0x22>
     998:	80 e8       	ldi	r24, 0x80	; 128
     99a:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     99c:	40 91 42 04 	lds	r20, 0x0442
     9a0:	20 91 4a 05 	lds	r18, 0x054A
     9a4:	33 27       	eor	r19, r19
     9a6:	27 fd       	sbrc	r18, 7
     9a8:	30 95       	com	r19
     9aa:	24 0f       	add	r18, r20
     9ac:	31 1d       	adc	r19, r1
     9ae:	47 fd       	sbrc	r20, 7
     9b0:	3a 95       	dec	r19
     9b2:	20 38       	cpi	r18, 0x80	; 128
     9b4:	4f ef       	ldi	r20, 0xFF	; 255
     9b6:	34 07       	cpc	r19, r20
     9b8:	14 f4       	brge	.+4      	; 0x9be <OutputXorBanks+0x44>
     9ba:	20 e8       	ldi	r18, 0x80	; 128
     9bc:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.
     9be:	20 38       	cpi	r18, 0x80	; 128
     9c0:	31 05       	cpc	r19, r1
     9c2:	14 f0       	brlt	.+4      	; 0x9c8 <OutputXorBanks+0x4e>
     9c4:	2f e7       	ldi	r18, 0x7F	; 127
     9c6:	30 e0       	ldi	r19, 0x00	; 0
     9c8:	20 58       	subi	r18, 0x80	; 128
     9ca:	30 95       	com	r19
     9cc:	80 38       	cpi	r24, 0x80	; 128
     9ce:	91 05       	cpc	r25, r1
     9d0:	14 f0       	brlt	.+4      	; 0x9d6 <OutputXorBanks+0x5c>
     9d2:	8f e7       	ldi	r24, 0x7F	; 127
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	80 58       	subi	r24, 0x80	; 128
     9d8:	90 95       	com	r25
     9da:	82 27       	eor	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
     9dc:	90 91 68 05 	lds	r25, 0x0568
     9e0:	89 17       	cp	r24, r25
     9e2:	29 f0       	breq	.+10     	; 0x9ee <OutputXorBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     9e4:	9f ef       	ldi	r25, 0xFF	; 255
     9e6:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
     9e8:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
     9ea:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     9ec:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
     9ee:	80 93 68 05 	sts	0x0568, r24
     9f2:	08 95       	ret

000009f4 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     9f4:	20 91 67 05 	lds	r18, 0x0567
     9f8:	80 91 45 05 	lds	r24, 0x0545
     9fc:	99 27       	eor	r25, r25
     9fe:	87 fd       	sbrc	r24, 7
     a00:	90 95       	com	r25
     a02:	82 0f       	add	r24, r18
     a04:	91 1d       	adc	r25, r1
     a06:	27 fd       	sbrc	r18, 7
     a08:	9a 95       	dec	r25
     a0a:	80 38       	cpi	r24, 0x80	; 128
     a0c:	2f ef       	ldi	r18, 0xFF	; 255
     a0e:	92 07       	cpc	r25, r18
     a10:	14 f4       	brge	.+4      	; 0xa16 <OutputAndBanks+0x22>
     a12:	80 e8       	ldi	r24, 0x80	; 128
     a14:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     a16:	40 91 42 04 	lds	r20, 0x0442
     a1a:	20 91 4a 05 	lds	r18, 0x054A
     a1e:	33 27       	eor	r19, r19
     a20:	27 fd       	sbrc	r18, 7
     a22:	30 95       	com	r19
     a24:	24 0f       	add	r18, r20
     a26:	31 1d       	adc	r19, r1
     a28:	47 fd       	sbrc	r20, 7
     a2a:	3a 95       	dec	r19
     a2c:	20 38       	cpi	r18, 0x80	; 128
     a2e:	4f ef       	ldi	r20, 0xFF	; 255
     a30:	34 07       	cpc	r19, r20
     a32:	14 f4       	brge	.+4      	; 0xa38 <OutputAndBanks+0x44>
     a34:	20 e8       	ldi	r18, 0x80	; 128
     a36:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.
     a38:	20 38       	cpi	r18, 0x80	; 128
     a3a:	31 05       	cpc	r19, r1
     a3c:	14 f0       	brlt	.+4      	; 0xa42 <OutputAndBanks+0x4e>
     a3e:	2f e7       	ldi	r18, 0x7F	; 127
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	20 58       	subi	r18, 0x80	; 128
     a44:	30 95       	com	r19
     a46:	80 38       	cpi	r24, 0x80	; 128
     a48:	91 05       	cpc	r25, r1
     a4a:	14 f0       	brlt	.+4      	; 0xa50 <OutputAndBanks+0x5c>
     a4c:	8f e7       	ldi	r24, 0x7F	; 127
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	80 58       	subi	r24, 0x80	; 128
     a52:	90 95       	com	r25
     a54:	82 23       	and	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
     a56:	90 91 68 05 	lds	r25, 0x0568
     a5a:	89 17       	cp	r24, r25
     a5c:	29 f0       	breq	.+10     	; 0xa68 <OutputAndBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
     a5e:	9f ef       	ldi	r25, 0xFF	; 255
     a60:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
     a62:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
     a64:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
     a66:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
     a68:	80 93 68 05 	sts	0x0568, r24
     a6c:	08 95       	ret

00000a6e <WriteLedLatch>:
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
     a6e:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
     a70:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
     a72:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
     a74:	8f ef       	ldi	r24, 0xFF	; 255
     a76:	84 b9       	out	0x04, r24	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
     a78:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
     a7a:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
     a7c:	9f bf       	out	0x3f, r25	; 63
     a7e:	08 95       	ret

00000a80 <CheckSdSlotFull>:
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
     a80:	fc 01       	movw	r30, r24
     a82:	a3 e0       	ldi	r26, 0x03	; 3
     a84:	f6 95       	lsr	r31
     a86:	e7 95       	ror	r30
     a88:	aa 95       	dec	r26
     a8a:	e1 f7       	brne	.-8      	; 0xa84 <CheckSdSlotFull+0x4>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
     a8c:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
     a8e:	e3 59       	subi	r30, 0x93	; 147
     a90:	fa 4f       	sbci	r31, 0xFA	; 250
     a92:	20 81       	ld	r18, Z
     a94:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
     a96:	87 70       	andi	r24, 0x07	; 7
     a98:	99 27       	eor	r25, r25

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
     a9a:	02 c0       	rjmp	.+4      	; 0xaa0 <CheckSdSlotFull+0x20>
     a9c:	35 95       	asr	r19
     a9e:	27 95       	ror	r18
     aa0:	8a 95       	dec	r24
     aa2:	e2 f7       	brpl	.-8      	; 0xa9c <CheckSdSlotFull+0x1c>
	}
	else
	{
		return(false);
	}
}
     aa4:	82 2f       	mov	r24, r18
     aa6:	81 70       	andi	r24, 0x01	; 1
     aa8:	08 95       	ret

00000aaa <SdIsrStartStreamingAudio>:
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;

	sreg=SREG;
     aaa:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
     aac:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
     aae:	83 e0       	ldi	r24, 0x03	; 3
     ab0:	80 93 4d 05 	sts	0x054D, r24

	TCNT2=0;			// Init counter reg
     ab4:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
     ab8:	81 e7       	ldi	r24, 0x71	; 113
     aba:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
     abe:	8f ef       	ldi	r24, 0xFF	; 255
     ac0:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
     ac2:	e0 e7       	ldi	r30, 0x70	; 112
     ac4:	f0 e0       	ldi	r31, 0x00	; 0
     ac6:	80 81       	ld	r24, Z
     ac8:	84 60       	ori	r24, 0x04	; 4
     aca:	80 83       	st	Z, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
     acc:	82 e0       	ldi	r24, 0x02	; 2
     ace:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
     ad2:	9f bf       	out	0x3f, r25	; 63
     ad4:	08 95       	ret

00000ad6 <GetRandomLongInt>:
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
     ad6:	40 91 00 01 	lds	r20, 0x0100
     ada:	50 91 01 01 	lds	r21, 0x0101
     ade:	60 91 02 01 	lds	r22, 0x0102
     ae2:	70 91 03 01 	lds	r23, 0x0103
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
     ae6:	db 01       	movw	r26, r22
     ae8:	ca 01       	movw	r24, r20
     aea:	88 0f       	add	r24, r24
     aec:	99 1f       	adc	r25, r25
     aee:	aa 1f       	adc	r26, r26
     af0:	bb 1f       	adc	r27, r27
     af2:	76 ff       	sbrs	r23, 6
     af4:	08 c0       	rjmp	.+16     	; 0xb06 <GetRandomLongInt+0x30>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
     af6:	25 eb       	ldi	r18, 0xB5	; 181
     af8:	82 27       	eor	r24, r18
     afa:	25 e9       	ldi	r18, 0x95	; 149
     afc:	92 27       	eor	r25, r18
     afe:	2a ea       	ldi	r18, 0xAA	; 170
     b00:	a2 27       	eor	r26, r18
     b02:	20 e2       	ldi	r18, 0x20	; 32
     b04:	b2 27       	eor	r27, r18
     b06:	80 93 00 01 	sts	0x0100, r24
     b0a:	90 93 01 01 	sts	0x0101, r25
     b0e:	a0 93 02 01 	sts	0x0102, r26
     b12:	b0 93 03 01 	sts	0x0103, r27
	}
	return(random31);
     b16:	60 91 00 01 	lds	r22, 0x0100
     b1a:	70 91 01 01 	lds	r23, 0x0101
}
     b1e:	80 91 02 01 	lds	r24, 0x0102
     b22:	90 91 03 01 	lds	r25, 0x0103
     b26:	08 95       	ret

00000b28 <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM.
{
     b28:	2f 92       	push	r2
     b2a:	3f 92       	push	r3
     b2c:	4f 92       	push	r4
     b2e:	5f 92       	push	r5
     b30:	6f 92       	push	r6
     b32:	7f 92       	push	r7
     b34:	8f 92       	push	r8
     b36:	9f 92       	push	r9
     b38:	af 92       	push	r10
     b3a:	bf 92       	push	r11
     b3c:	cf 92       	push	r12
     b3e:	df 92       	push	r13
     b40:	ef 92       	push	r14
     b42:	ff 92       	push	r15
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	38 2e       	mov	r3, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
     b4e:	62 30       	cpi	r22, 0x02	; 2
     b50:	08 f4       	brcc	.+2      	; 0xb54 <MakeNewGranularArray+0x2c>
     b52:	cd c0       	rjmp	.+410    	; 0xcee <MakeNewGranularArray+0x1c6>
	{
		sreg=SREG;
     b54:	9f b6       	in	r9, 0x3f	; 63
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
     b56:	f8 94       	cli
     b58:	86 2e       	mov	r8, r22
     b5a:	80 e8       	ldi	r24, 0x80	; 128
     b5c:	86 17       	cp	r24, r22
     b5e:	10 f4       	brcc	.+4      	; 0xb64 <MakeNewGranularArray+0x3c>
     b60:	70 e8       	ldi	r23, 0x80	; 128
     b62:	87 2e       	mov	r8, r23
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
     b64:	c3 2d       	mov	r28, r3
     b66:	d0 e0       	ldi	r29, 0x00	; 0
     b68:	9e 01       	movw	r18, r28
     b6a:	36 95       	lsr	r19
     b6c:	32 2f       	mov	r19, r18
     b6e:	22 27       	eor	r18, r18
     b70:	37 95       	ror	r19
     b72:	27 95       	ror	r18
     b74:	2c 5b       	subi	r18, 0xBC	; 188
     b76:	3b 4f       	sbci	r19, 0xFB	; 251
     b78:	80 e0       	ldi	r24, 0x00	; 0
     b7a:	90 e0       	ldi	r25, 0x00	; 0
     b7c:	f9 01       	movw	r30, r18
     b7e:	e8 0f       	add	r30, r24
     b80:	f9 1f       	adc	r31, r25
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
     b82:	80 83       	st	Z, r24
     b84:	01 96       	adiw	r24, 0x01	; 1
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
     b86:	88 15       	cp	r24, r8
     b88:	c8 f3       	brcs	.-14     	; 0xb7c <MakeNewGranularArray+0x54>
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
     b8a:	6e 01       	movw	r12, r28
     b8c:	d6 94       	lsr	r13
     b8e:	dc 2c       	mov	r13, r12
     b90:	cc 24       	eor	r12, r12
     b92:	d7 94       	ror	r13
     b94:	c7 94       	ror	r12
     b96:	54 e4       	ldi	r21, 0x44	; 68
     b98:	a5 2e       	mov	r10, r21
     b9a:	54 e0       	ldi	r21, 0x04	; 4
     b9c:	b5 2e       	mov	r11, r21
     b9e:	ac 0c       	add	r10, r12
     ba0:	bd 1c       	adc	r11, r13
     ba2:	00 e0       	ldi	r16, 0x00	; 0
     ba4:	10 e0       	ldi	r17, 0x00	; 0
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
     ba6:	48 2c       	mov	r4, r8
     ba8:	51 2c       	mov	r5, r1
     baa:	61 2c       	mov	r6, r1
     bac:	71 2c       	mov	r7, r1
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
     bae:	75 01       	movw	r14, r10
     bb0:	e0 0e       	add	r14, r16
     bb2:	f1 1e       	adc	r15, r17
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
     bb4:	d7 01       	movw	r26, r14
     bb6:	2c 90       	ld	r2, X
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
     bb8:	0e 94 6b 05 	call	0xad6	; 0xad6 <GetRandomLongInt>
     bbc:	a3 01       	movw	r20, r6
     bbe:	92 01       	movw	r18, r4
     bc0:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
     bc4:	fb 01       	movw	r30, r22
     bc6:	ec 0d       	add	r30, r12
     bc8:	fd 1d       	adc	r31, r13
     bca:	ec 5b       	subi	r30, 0xBC	; 188
     bcc:	fb 4f       	sbci	r31, 0xFB	; 251
     bce:	80 81       	ld	r24, Z
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
     bd0:	d7 01       	movw	r26, r14
     bd2:	8c 93       	st	X, r24
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
     bd4:	20 82       	st	Z, r2
     bd6:	0f 5f       	subi	r16, 0xFF	; 255
     bd8:	1f 4f       	sbci	r17, 0xFF	; 255
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
     bda:	08 15       	cp	r16, r8
     bdc:	40 f3       	brcs	.-48     	; 0xbae <MakeNewGranularArray+0x86>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
     bde:	31 10       	cpse	r3, r1
     be0:	15 c0       	rjmp	.+42     	; 0xc0c <MakeNewGranularArray+0xe4>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
     be2:	60 91 f1 05 	lds	r22, 0x05F1
     be6:	70 91 f2 05 	lds	r23, 0x05F2
     bea:	80 91 f3 05 	lds	r24, 0x05F3
     bee:	90 91 f4 05 	lds	r25, 0x05F4
     bf2:	a3 01       	movw	r20, r6
     bf4:	92 01       	movw	r18, r4
     bf6:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
     bfa:	20 93 35 04 	sts	0x0435, r18
     bfe:	30 93 36 04 	sts	0x0436, r19
     c02:	40 93 37 04 	sts	0x0437, r20
     c06:	50 93 38 04 	sts	0x0438, r21
     c0a:	1c c0       	rjmp	.+56     	; 0xc44 <MakeNewGranularArray+0x11c>
		}
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
     c0c:	00 91 1f 06 	lds	r16, 0x061F
     c10:	10 91 20 06 	lds	r17, 0x0620
     c14:	20 91 21 06 	lds	r18, 0x0621
     c18:	30 91 22 06 	lds	r19, 0x0622
     c1c:	6f ef       	ldi	r22, 0xFF	; 255
     c1e:	7f ef       	ldi	r23, 0xFF	; 255
     c20:	87 e0       	ldi	r24, 0x07	; 7
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	60 1b       	sub	r22, r16
     c26:	71 0b       	sbc	r23, r17
     c28:	82 0b       	sbc	r24, r18
     c2a:	93 0b       	sbc	r25, r19
     c2c:	a3 01       	movw	r20, r6
     c2e:	92 01       	movw	r18, r4
     c30:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
     c34:	20 93 39 04 	sts	0x0439, r18
     c38:	30 93 3a 04 	sts	0x043A, r19
     c3c:	40 93 3b 04 	sts	0x043B, r20
     c40:	50 93 3c 04 	sts	0x043C, r21
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
     c44:	8e e2       	ldi	r24, 0x2E	; 46
     c46:	8c 9f       	mul	r24, r28
     c48:	f0 01       	movw	r30, r0
     c4a:	8d 9f       	mul	r24, r29
     c4c:	f0 0d       	add	r31, r0
     c4e:	11 24       	eor	r1, r1
     c50:	ec 51       	subi	r30, 0x1C	; 28
     c52:	fa 4f       	sbci	r31, 0xFA	; 250
     c54:	87 82       	std	Z+7, r8	; 0x07
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
     c56:	fe 01       	movw	r30, r28
     c58:	e3 5c       	subi	r30, 0xC3	; 195
     c5a:	fb 4f       	sbci	r31, 0xFB	; 251
     c5c:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
     c5e:	cc 0f       	add	r28, r28
     c60:	dd 1f       	adc	r29, r29
     c62:	cc 0f       	add	r28, r28
     c64:	dd 1f       	adc	r29, r29
     c66:	fe 01       	movw	r30, r28
     c68:	eb 5c       	subi	r30, 0xCB	; 203
     c6a:	fb 4f       	sbci	r31, 0xFB	; 251
     c6c:	80 81       	ld	r24, Z
     c6e:	91 81       	ldd	r25, Z+1	; 0x01
     c70:	a2 81       	ldd	r26, Z+2	; 0x02
     c72:	b3 81       	ldd	r27, Z+3	; 0x03
     c74:	c3 5d       	subi	r28, 0xD3	; 211
     c76:	db 4f       	sbci	r29, 0xFB	; 251
     c78:	88 83       	st	Y, r24
     c7a:	99 83       	std	Y+1, r25	; 0x01
     c7c:	aa 83       	std	Y+2, r26	; 0x02
     c7e:	bb 83       	std	Y+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
     c80:	31 10       	cpse	r3, r1
     c82:	16 c0       	rjmp	.+44     	; 0xcb0 <MakeNewGranularArray+0x188>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     c84:	20 91 35 04 	lds	r18, 0x0435
     c88:	30 91 36 04 	lds	r19, 0x0436
     c8c:	40 91 37 04 	lds	r20, 0x0437
     c90:	50 91 38 04 	lds	r21, 0x0438
     c94:	a0 91 44 04 	lds	r26, 0x0444
     c98:	b0 e0       	ldi	r27, 0x00	; 0
     c9a:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     c9e:	60 93 04 06 	sts	0x0604, r22
     ca2:	70 93 05 06 	sts	0x0605, r23
     ca6:	80 93 06 06 	sts	0x0606, r24
     caa:	90 93 07 06 	sts	0x0607, r25
     cae:	1d c0       	rjmp	.+58     	; 0xcea <MakeNewGranularArray+0x1c2>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));
     cb0:	20 91 39 04 	lds	r18, 0x0439
     cb4:	30 91 3a 04 	lds	r19, 0x043A
     cb8:	40 91 3b 04 	lds	r20, 0x043B
     cbc:	50 91 3c 04 	lds	r21, 0x043C
     cc0:	a0 91 c4 04 	lds	r26, 0x04C4
     cc4:	b0 e0       	ldi	r27, 0x00	; 0
     cc6:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     cca:	0f ef       	ldi	r16, 0xFF	; 255
     ccc:	1f ef       	ldi	r17, 0xFF	; 255
     cce:	27 e0       	ldi	r18, 0x07	; 7
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	06 1b       	sub	r16, r22
     cd4:	17 0b       	sbc	r17, r23
     cd6:	28 0b       	sbc	r18, r24
     cd8:	39 0b       	sbc	r19, r25
     cda:	00 93 32 06 	sts	0x0632, r16
     cde:	10 93 33 06 	sts	0x0633, r17
     ce2:	20 93 34 06 	sts	0x0634, r18
     ce6:	30 93 35 06 	sts	0x0635, r19
		}

		SREG=sreg;		// Restore interrupts.
     cea:	9f be       	out	0x3f, r9	; 63
     cec:	07 c0       	rjmp	.+14     	; 0xcfc <MakeNewGranularArray+0x1d4>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
     cee:	be e2       	ldi	r27, 0x2E	; 46
     cf0:	8b 9f       	mul	r24, r27
     cf2:	f0 01       	movw	r30, r0
     cf4:	11 24       	eor	r1, r1
     cf6:	ec 51       	subi	r30, 0x1C	; 28
     cf8:	fa 4f       	sbci	r31, 0xFA	; 250
     cfa:	17 82       	std	Z+7, r1	; 0x07
	}
}
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	1f 91       	pop	r17
     d02:	0f 91       	pop	r16
     d04:	ff 90       	pop	r15
     d06:	ef 90       	pop	r14
     d08:	df 90       	pop	r13
     d0a:	cf 90       	pop	r12
     d0c:	bf 90       	pop	r11
     d0e:	af 90       	pop	r10
     d10:	9f 90       	pop	r9
     d12:	8f 90       	pop	r8
     d14:	7f 90       	pop	r7
     d16:	6f 90       	pop	r6
     d18:	5f 90       	pop	r5
     d1a:	4f 90       	pop	r4
     d1c:	3f 90       	pop	r3
     d1e:	2f 90       	pop	r2
     d20:	08 95       	ret

00000d22 <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
     d22:	4f 92       	push	r4
     d24:	5f 92       	push	r5
     d26:	6f 92       	push	r6
     d28:	7f 92       	push	r7
     d2a:	8f 92       	push	r8
     d2c:	9f 92       	push	r9
     d2e:	af 92       	push	r10
     d30:	bf 92       	push	r11
     d32:	cf 92       	push	r12
     d34:	df 92       	push	r13
     d36:	ef 92       	push	r14
     d38:	ff 92       	push	r15
	unsigned char
		sreg;
	unsigned long
		chunkSize;

	sreg=SREG;
     d3a:	ef b7       	in	r30, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
     d3c:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
     d3e:	81 11       	cpse	r24, r1
     d40:	e9 c1       	rjmp	.+978    	; 0x1114 <__stack+0x15>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
     d42:	80 90 f1 05 	lds	r8, 0x05F1
     d46:	90 90 f2 05 	lds	r9, 0x05F2
     d4a:	a0 90 f3 05 	lds	r10, 0x05F3
     d4e:	b0 90 f4 05 	lds	r11, 0x05F4
     d52:	83 e0       	ldi	r24, 0x03	; 3
     d54:	88 0c       	add	r8, r8
     d56:	99 1c       	adc	r9, r9
     d58:	aa 1c       	adc	r10, r10
     d5a:	bb 1c       	adc	r11, r11
     d5c:	8a 95       	dec	r24
     d5e:	d1 f7       	brne	.-12     	; 0xd54 <UpdateAdjustedSampleAddresses+0x32>
     d60:	89 2c       	mov	r8, r9
     d62:	9a 2c       	mov	r9, r10
     d64:	ab 2c       	mov	r10, r11
     d66:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
     d68:	a0 91 01 06 	lds	r26, 0x0601
     d6c:	80 91 03 06 	lds	r24, 0x0603
     d70:	b0 e0       	ldi	r27, 0x00	; 0
     d72:	a8 0f       	add	r26, r24
     d74:	b1 1d       	adc	r27, r1
     d76:	a5 01       	movw	r20, r10
     d78:	94 01       	movw	r18, r8
     d7a:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     d7e:	f3 e0       	ldi	r31, 0x03	; 3
     d80:	96 95       	lsr	r25
     d82:	87 95       	ror	r24
     d84:	77 95       	ror	r23
     d86:	67 95       	ror	r22
     d88:	fa 95       	dec	r31
     d8a:	d1 f7       	brne	.-12     	; 0xd80 <UpdateAdjustedSampleAddresses+0x5e>
     d8c:	60 93 fd 05 	sts	0x05FD, r22
     d90:	70 93 fe 05 	sts	0x05FE, r23
     d94:	80 93 ff 05 	sts	0x05FF, r24
     d98:	90 93 00 06 	sts	0x0600, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
     d9c:	40 90 f1 05 	lds	r4, 0x05F1
     da0:	50 90 f2 05 	lds	r5, 0x05F2
     da4:	60 90 f3 05 	lds	r6, 0x05F3
     da8:	70 90 f4 05 	lds	r7, 0x05F4
     dac:	f0 91 02 06 	lds	r31, 0x0602
     db0:	a0 91 03 06 	lds	r26, 0x0603
     db4:	b0 e0       	ldi	r27, 0x00	; 0
     db6:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     dba:	6b 01       	movw	r12, r22
     dbc:	7c 01       	movw	r14, r24
     dbe:	a3 e0       	ldi	r26, 0x03	; 3
     dc0:	f6 94       	lsr	r15
     dc2:	e7 94       	ror	r14
     dc4:	d7 94       	ror	r13
     dc6:	c7 94       	ror	r12
     dc8:	aa 95       	dec	r26
     dca:	d1 f7       	brne	.-12     	; 0xdc0 <UpdateAdjustedSampleAddresses+0x9e>
     dcc:	c4 0c       	add	r12, r4
     dce:	d5 1c       	adc	r13, r5
     dd0:	e6 1c       	adc	r14, r6
     dd2:	f7 1c       	adc	r15, r7
     dd4:	af 2f       	mov	r26, r31
     dd6:	b0 e0       	ldi	r27, 0x00	; 0
     dd8:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
     ddc:	b3 e0       	ldi	r27, 0x03	; 3
     dde:	96 95       	lsr	r25
     de0:	87 95       	ror	r24
     de2:	77 95       	ror	r23
     de4:	67 95       	ror	r22
     de6:	ba 95       	dec	r27
     de8:	d1 f7       	brne	.-12     	; 0xdde <UpdateAdjustedSampleAddresses+0xbc>
     dea:	c6 1a       	sub	r12, r22
     dec:	d7 0a       	sbc	r13, r23
     dee:	e8 0a       	sbc	r14, r24
     df0:	f9 0a       	sbc	r15, r25
     df2:	c0 92 f9 05 	sts	0x05F9, r12
     df6:	d0 92 fa 05 	sts	0x05FA, r13
     dfa:	e0 92 fb 05 	sts	0x05FB, r14
     dfe:	f0 92 fc 05 	sts	0x05FC, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
     e02:	40 91 fd 05 	lds	r20, 0x05FD
     e06:	50 91 fe 05 	lds	r21, 0x05FE
     e0a:	60 91 ff 05 	lds	r22, 0x05FF
     e0e:	70 91 00 06 	lds	r23, 0x0600
     e12:	80 91 f9 05 	lds	r24, 0x05F9
     e16:	90 91 fa 05 	lds	r25, 0x05FA
     e1a:	a0 91 fb 05 	lds	r26, 0x05FB
     e1e:	b0 91 fc 05 	lds	r27, 0x05FC
     e22:	84 17       	cp	r24, r20
     e24:	95 07       	cpc	r25, r21
     e26:	a6 07       	cpc	r26, r22
     e28:	b7 07       	cpc	r27, r23
     e2a:	50 f5       	brcc	.+84     	; 0xe80 <UpdateAdjustedSampleAddresses+0x15e>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
     e2c:	80 91 e7 05 	lds	r24, 0x05E7
     e30:	81 30       	cpi	r24, 0x01	; 1
     e32:	19 f4       	brne	.+6      	; 0xe3a <UpdateAdjustedSampleAddresses+0x118>
			{
				bankStates[BANK_0].sampleDirection=true;
     e34:	80 93 e8 05 	sts	0x05E8, r24
     e38:	02 c0       	rjmp	.+4      	; 0xe3e <UpdateAdjustedSampleAddresses+0x11c>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
     e3a:	10 92 e8 05 	sts	0x05E8, r1
			}

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
     e3e:	80 91 fd 05 	lds	r24, 0x05FD
     e42:	90 91 fe 05 	lds	r25, 0x05FE
     e46:	a0 91 ff 05 	lds	r26, 0x05FF
     e4a:	b0 91 00 06 	lds	r27, 0x0600
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
     e4e:	40 91 f9 05 	lds	r20, 0x05F9
     e52:	50 91 fa 05 	lds	r21, 0x05FA
     e56:	60 91 fb 05 	lds	r22, 0x05FB
     e5a:	70 91 fc 05 	lds	r23, 0x05FC
     e5e:	40 93 fd 05 	sts	0x05FD, r20
     e62:	50 93 fe 05 	sts	0x05FE, r21
     e66:	60 93 ff 05 	sts	0x05FF, r22
     e6a:	70 93 00 06 	sts	0x0600, r23
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
     e6e:	80 93 f9 05 	sts	0x05F9, r24
     e72:	90 93 fa 05 	sts	0x05FA, r25
     e76:	a0 93 fb 05 	sts	0x05FB, r26
     e7a:	b0 93 fc 05 	sts	0x05FC, r27
     e7e:	0a c0       	rjmp	.+20     	; 0xe94 <UpdateAdjustedSampleAddresses+0x172>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
     e80:	80 91 e7 05 	lds	r24, 0x05E7
     e84:	81 30       	cpi	r24, 0x01	; 1
     e86:	19 f4       	brne	.+6      	; 0xe8e <UpdateAdjustedSampleAddresses+0x16c>
			{
				bankStates[BANK_0].sampleDirection=false;
     e88:	10 92 e8 05 	sts	0x05E8, r1
     e8c:	03 c0       	rjmp	.+6      	; 0xe94 <UpdateAdjustedSampleAddresses+0x172>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	80 93 e8 05 	sts	0x05E8, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
     e94:	40 91 fd 05 	lds	r20, 0x05FD
     e98:	50 91 fe 05 	lds	r21, 0x05FE
     e9c:	60 91 ff 05 	lds	r22, 0x05FF
     ea0:	70 91 00 06 	lds	r23, 0x0600
     ea4:	80 91 f1 05 	lds	r24, 0x05F1
     ea8:	90 91 f2 05 	lds	r25, 0x05F2
     eac:	a0 91 f3 05 	lds	r26, 0x05F3
     eb0:	b0 91 f4 05 	lds	r27, 0x05F4
     eb4:	84 17       	cp	r24, r20
     eb6:	95 07       	cpc	r25, r21
     eb8:	a6 07       	cpc	r26, r22
     eba:	b7 07       	cpc	r27, r23
     ebc:	e0 f4       	brcc	.+56     	; 0xef6 <UpdateAdjustedSampleAddresses+0x1d4>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
     ebe:	80 91 fd 05 	lds	r24, 0x05FD
     ec2:	90 91 fe 05 	lds	r25, 0x05FE
     ec6:	a0 91 ff 05 	lds	r26, 0x05FF
     eca:	b0 91 00 06 	lds	r27, 0x0600
     ece:	40 91 f1 05 	lds	r20, 0x05F1
     ed2:	50 91 f2 05 	lds	r21, 0x05F2
     ed6:	60 91 f3 05 	lds	r22, 0x05F3
     eda:	70 91 f4 05 	lds	r23, 0x05F4
     ede:	84 1b       	sub	r24, r20
     ee0:	95 0b       	sbc	r25, r21
     ee2:	a6 0b       	sbc	r26, r22
     ee4:	b7 0b       	sbc	r27, r23
     ee6:	80 93 fd 05 	sts	0x05FD, r24
     eea:	90 93 fe 05 	sts	0x05FE, r25
     eee:	a0 93 ff 05 	sts	0x05FF, r26
     ef2:	b0 93 00 06 	sts	0x0600, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
     ef6:	40 91 f9 05 	lds	r20, 0x05F9
     efa:	50 91 fa 05 	lds	r21, 0x05FA
     efe:	60 91 fb 05 	lds	r22, 0x05FB
     f02:	70 91 fc 05 	lds	r23, 0x05FC
     f06:	80 91 f1 05 	lds	r24, 0x05F1
     f0a:	90 91 f2 05 	lds	r25, 0x05F2
     f0e:	a0 91 f3 05 	lds	r26, 0x05F3
     f12:	b0 91 f4 05 	lds	r27, 0x05F4
     f16:	84 17       	cp	r24, r20
     f18:	95 07       	cpc	r25, r21
     f1a:	a6 07       	cpc	r26, r22
     f1c:	b7 07       	cpc	r27, r23
     f1e:	08 f0       	brcs	.+2      	; 0xf22 <UpdateAdjustedSampleAddresses+0x200>
     f20:	44 c0       	rjmp	.+136    	; 0xfaa <UpdateAdjustedSampleAddresses+0x288>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
     f22:	80 91 f9 05 	lds	r24, 0x05F9
     f26:	90 91 fa 05 	lds	r25, 0x05FA
     f2a:	a0 91 fb 05 	lds	r26, 0x05FB
     f2e:	b0 91 fc 05 	lds	r27, 0x05FC
     f32:	40 91 f1 05 	lds	r20, 0x05F1
     f36:	50 91 f2 05 	lds	r21, 0x05F2
     f3a:	60 91 f3 05 	lds	r22, 0x05F3
     f3e:	70 91 f4 05 	lds	r23, 0x05F4
     f42:	84 1b       	sub	r24, r20
     f44:	95 0b       	sbc	r25, r21
     f46:	a6 0b       	sbc	r26, r22
     f48:	b7 0b       	sbc	r27, r23
     f4a:	80 93 f9 05 	sts	0x05F9, r24
     f4e:	90 93 fa 05 	sts	0x05FA, r25
     f52:	a0 93 fb 05 	sts	0x05FB, r26
     f56:	b0 93 fc 05 	sts	0x05FC, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
     f5a:	40 91 f9 05 	lds	r20, 0x05F9
     f5e:	50 91 fa 05 	lds	r21, 0x05FA
     f62:	60 91 fb 05 	lds	r22, 0x05FB
     f66:	70 91 fc 05 	lds	r23, 0x05FC
     f6a:	80 91 fd 05 	lds	r24, 0x05FD
     f6e:	90 91 fe 05 	lds	r25, 0x05FE
     f72:	a0 91 ff 05 	lds	r26, 0x05FF
     f76:	b0 91 00 06 	lds	r27, 0x0600
     f7a:	48 17       	cp	r20, r24
     f7c:	59 07       	cpc	r21, r25
     f7e:	6a 07       	cpc	r22, r26
     f80:	7b 07       	cpc	r23, r27
     f82:	99 f4       	brne	.+38     	; 0xfaa <UpdateAdjustedSampleAddresses+0x288>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
     f84:	80 91 f9 05 	lds	r24, 0x05F9
     f88:	90 91 fa 05 	lds	r25, 0x05FA
     f8c:	a0 91 fb 05 	lds	r26, 0x05FB
     f90:	b0 91 fc 05 	lds	r27, 0x05FC
     f94:	01 97       	sbiw	r24, 0x01	; 1
     f96:	a1 09       	sbc	r26, r1
     f98:	b1 09       	sbc	r27, r1
     f9a:	80 93 f9 05 	sts	0x05F9, r24
     f9e:	90 93 fa 05 	sts	0x05FA, r25
     fa2:	a0 93 fb 05 	sts	0x05FB, r26
     fa6:	b0 93 fc 05 	sts	0x05FC, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
     faa:	40 91 fd 05 	lds	r20, 0x05FD
     fae:	50 91 fe 05 	lds	r21, 0x05FE
     fb2:	60 91 ff 05 	lds	r22, 0x05FF
     fb6:	70 91 00 06 	lds	r23, 0x0600
     fba:	80 91 f9 05 	lds	r24, 0x05F9
     fbe:	90 91 fa 05 	lds	r25, 0x05FA
     fc2:	a0 91 fb 05 	lds	r26, 0x05FB
     fc6:	b0 91 fc 05 	lds	r27, 0x05FC
     fca:	84 17       	cp	r24, r20
     fcc:	95 07       	cpc	r25, r21
     fce:	a6 07       	cpc	r26, r22
     fd0:	b7 07       	cpc	r27, r23
     fd2:	08 f0       	brcs	.+2      	; 0xfd6 <UpdateAdjustedSampleAddresses+0x2b4>
     fd4:	5a c0       	rjmp	.+180    	; 0x108a <UpdateAdjustedSampleAddresses+0x368>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
     fd6:	40 91 04 06 	lds	r20, 0x0604
     fda:	50 91 05 06 	lds	r21, 0x0605
     fde:	60 91 06 06 	lds	r22, 0x0606
     fe2:	70 91 07 06 	lds	r23, 0x0607
     fe6:	80 91 fd 05 	lds	r24, 0x05FD
     fea:	90 91 fe 05 	lds	r25, 0x05FE
     fee:	a0 91 ff 05 	lds	r26, 0x05FF
     ff2:	b0 91 00 06 	lds	r27, 0x0600
     ff6:	48 17       	cp	r20, r24
     ff8:	59 07       	cpc	r21, r25
     ffa:	6a 07       	cpc	r22, r26
     ffc:	7b 07       	cpc	r23, r27
     ffe:	08 f0       	brcs	.+2      	; 0x1002 <UpdateAdjustedSampleAddresses+0x2e0>
    1000:	86 c2       	rjmp	.+1292   	; 0x150e <__stack+0x40f>
    1002:	40 91 04 06 	lds	r20, 0x0604
    1006:	50 91 05 06 	lds	r21, 0x0605
    100a:	60 91 06 06 	lds	r22, 0x0606
    100e:	70 91 07 06 	lds	r23, 0x0607
    1012:	80 91 f9 05 	lds	r24, 0x05F9
    1016:	90 91 fa 05 	lds	r25, 0x05FA
    101a:	a0 91 fb 05 	lds	r26, 0x05FB
    101e:	b0 91 fc 05 	lds	r27, 0x05FC
    1022:	84 17       	cp	r24, r20
    1024:	95 07       	cpc	r25, r21
    1026:	a6 07       	cpc	r26, r22
    1028:	b7 07       	cpc	r27, r23
    102a:	08 f0       	brcs	.+2      	; 0x102e <UpdateAdjustedSampleAddresses+0x30c>
    102c:	70 c2       	rjmp	.+1248   	; 0x150e <__stack+0x40f>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?
    102e:	40 91 fd 05 	lds	r20, 0x05FD
    1032:	50 91 fe 05 	lds	r21, 0x05FE
    1036:	60 91 ff 05 	lds	r22, 0x05FF
    103a:	70 91 00 06 	lds	r23, 0x0600
    103e:	80 90 04 06 	lds	r8, 0x0604
    1042:	90 90 05 06 	lds	r9, 0x0605
    1046:	a0 90 06 06 	lds	r10, 0x0606
    104a:	b0 90 07 06 	lds	r11, 0x0607
    104e:	80 91 04 06 	lds	r24, 0x0604
    1052:	90 91 05 06 	lds	r25, 0x0605
    1056:	a0 91 06 06 	lds	r26, 0x0606
    105a:	b0 91 07 06 	lds	r27, 0x0607
    105e:	c0 90 f9 05 	lds	r12, 0x05F9
    1062:	d0 90 fa 05 	lds	r13, 0x05FA
    1066:	e0 90 fb 05 	lds	r14, 0x05FB
    106a:	f0 90 fc 05 	lds	r15, 0x05FC
    106e:	48 19       	sub	r20, r8
    1070:	59 09       	sbc	r21, r9
    1072:	6a 09       	sbc	r22, r10
    1074:	7b 09       	sbc	r23, r11
    1076:	8c 19       	sub	r24, r12
    1078:	9d 09       	sbc	r25, r13
    107a:	ae 09       	sbc	r26, r14
    107c:	bf 09       	sbc	r27, r15
    107e:	48 17       	cp	r20, r24
    1080:	59 07       	cpc	r21, r25
    1082:	6a 07       	cpc	r22, r26
    1084:	7b 07       	cpc	r23, r27
    1086:	e8 f1       	brcs	.+122    	; 0x1102 <__stack+0x3>
    1088:	15 c0       	rjmp	.+42     	; 0x10b4 <UpdateAdjustedSampleAddresses+0x392>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    108a:	40 91 04 06 	lds	r20, 0x0604
    108e:	50 91 05 06 	lds	r21, 0x0605
    1092:	60 91 06 06 	lds	r22, 0x0606
    1096:	70 91 07 06 	lds	r23, 0x0607
    109a:	80 91 fd 05 	lds	r24, 0x05FD
    109e:	90 91 fe 05 	lds	r25, 0x05FE
    10a2:	a0 91 ff 05 	lds	r26, 0x05FF
    10a6:	b0 91 00 06 	lds	r27, 0x0600
    10aa:	48 17       	cp	r20, r24
    10ac:	59 07       	cpc	r21, r25
    10ae:	6a 07       	cpc	r22, r26
    10b0:	7b 07       	cpc	r23, r27
    10b2:	88 f4       	brcc	.+34     	; 0x10d6 <UpdateAdjustedSampleAddresses+0x3b4>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    10b4:	80 91 fd 05 	lds	r24, 0x05FD
    10b8:	90 91 fe 05 	lds	r25, 0x05FE
    10bc:	a0 91 ff 05 	lds	r26, 0x05FF
    10c0:	b0 91 00 06 	lds	r27, 0x0600
    10c4:	80 93 04 06 	sts	0x0604, r24
    10c8:	90 93 05 06 	sts	0x0605, r25
    10cc:	a0 93 06 06 	sts	0x0606, r26
    10d0:	b0 93 07 06 	sts	0x0607, r27
    10d4:	1c c2       	rjmp	.+1080   	; 0x150e <__stack+0x40f>
			}
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    10d6:	40 91 04 06 	lds	r20, 0x0604
    10da:	50 91 05 06 	lds	r21, 0x0605
    10de:	60 91 06 06 	lds	r22, 0x0606
    10e2:	70 91 07 06 	lds	r23, 0x0607
    10e6:	80 91 f9 05 	lds	r24, 0x05F9
    10ea:	90 91 fa 05 	lds	r25, 0x05FA
    10ee:	a0 91 fb 05 	lds	r26, 0x05FB
    10f2:	b0 91 fc 05 	lds	r27, 0x05FC
    10f6:	84 17       	cp	r24, r20
    10f8:	95 07       	cpc	r25, r21
    10fa:	a6 07       	cpc	r26, r22
    10fc:	b7 07       	cpc	r27, r23
    10fe:	08 f0       	brcs	.+2      	; 0x1102 <__stack+0x3>
    1100:	06 c2       	rjmp	.+1036   	; 0x150e <__stack+0x40f>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1102:	80 91 f9 05 	lds	r24, 0x05F9
    1106:	90 91 fa 05 	lds	r25, 0x05FA
    110a:	a0 91 fb 05 	lds	r26, 0x05FB
    110e:	b0 91 fc 05 	lds	r27, 0x05FC
    1112:	d8 cf       	rjmp	.-80     	; 0x10c4 <UpdateAdjustedSampleAddresses+0x3a2>
		}
	}
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    1114:	80 91 1f 06 	lds	r24, 0x061F
    1118:	90 91 20 06 	lds	r25, 0x0620
    111c:	a0 91 21 06 	lds	r26, 0x0621
    1120:	b0 91 22 06 	lds	r27, 0x0622
    1124:	cc 24       	eor	r12, r12
    1126:	ca 94       	dec	r12
    1128:	dc 2c       	mov	r13, r12
    112a:	f7 e0       	ldi	r31, 0x07	; 7
    112c:	ef 2e       	mov	r14, r31
    112e:	f1 2c       	mov	r15, r1
    1130:	46 01       	movw	r8, r12
    1132:	57 01       	movw	r10, r14
    1134:	88 1a       	sub	r8, r24
    1136:	99 0a       	sbc	r9, r25
    1138:	aa 0a       	sbc	r10, r26
    113a:	bb 0a       	sbc	r11, r27
    113c:	a3 e0       	ldi	r26, 0x03	; 3
    113e:	88 0c       	add	r8, r8
    1140:	99 1c       	adc	r9, r9
    1142:	aa 1c       	adc	r10, r10
    1144:	bb 1c       	adc	r11, r11
    1146:	aa 95       	dec	r26
    1148:	d1 f7       	brne	.-12     	; 0x113e <__stack+0x3f>
    114a:	89 2c       	mov	r8, r9
    114c:	9a 2c       	mov	r9, r10
    114e:	ab 2c       	mov	r10, r11
    1150:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1152:	a0 91 2f 06 	lds	r26, 0x062F
    1156:	80 91 31 06 	lds	r24, 0x0631
    115a:	b0 e0       	ldi	r27, 0x00	; 0
    115c:	a8 0f       	add	r26, r24
    115e:	b1 1d       	adc	r27, r1
    1160:	a5 01       	movw	r20, r10
    1162:	94 01       	movw	r18, r8
    1164:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
    1168:	f3 e0       	ldi	r31, 0x03	; 3
    116a:	96 95       	lsr	r25
    116c:	87 95       	ror	r24
    116e:	77 95       	ror	r23
    1170:	67 95       	ror	r22
    1172:	fa 95       	dec	r31
    1174:	d1 f7       	brne	.-12     	; 0x116a <__stack+0x6b>
    1176:	c6 1a       	sub	r12, r22
    1178:	d7 0a       	sbc	r13, r23
    117a:	e8 0a       	sbc	r14, r24
    117c:	f9 0a       	sbc	r15, r25
    117e:	c0 92 2b 06 	sts	0x062B, r12
    1182:	d0 92 2c 06 	sts	0x062C, r13
    1186:	e0 92 2d 06 	sts	0x062D, r14
    118a:	f0 92 2e 06 	sts	0x062E, r15
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    118e:	40 90 1f 06 	lds	r4, 0x061F
    1192:	50 90 20 06 	lds	r5, 0x0620
    1196:	60 90 21 06 	lds	r6, 0x0621
    119a:	70 90 22 06 	lds	r7, 0x0622
    119e:	a0 91 30 06 	lds	r26, 0x0630
    11a2:	f0 91 31 06 	lds	r31, 0x0631
    11a6:	b0 e0       	ldi	r27, 0x00	; 0
    11a8:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
    11ac:	6b 01       	movw	r12, r22
    11ae:	7c 01       	movw	r14, r24
    11b0:	a3 e0       	ldi	r26, 0x03	; 3
    11b2:	f6 94       	lsr	r15
    11b4:	e7 94       	ror	r14
    11b6:	d7 94       	ror	r13
    11b8:	c7 94       	ror	r12
    11ba:	aa 95       	dec	r26
    11bc:	d1 f7       	brne	.-12     	; 0x11b2 <__stack+0xb3>
    11be:	c4 0c       	add	r12, r4
    11c0:	d5 1c       	adc	r13, r5
    11c2:	e6 1c       	adc	r14, r6
    11c4:	f7 1c       	adc	r15, r7
    11c6:	af 2f       	mov	r26, r31
    11c8:	b0 e0       	ldi	r27, 0x00	; 0
    11ca:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
    11ce:	b3 e0       	ldi	r27, 0x03	; 3
    11d0:	96 95       	lsr	r25
    11d2:	87 95       	ror	r24
    11d4:	77 95       	ror	r23
    11d6:	67 95       	ror	r22
    11d8:	ba 95       	dec	r27
    11da:	d1 f7       	brne	.-12     	; 0x11d0 <__stack+0xd1>
    11dc:	c6 1a       	sub	r12, r22
    11de:	d7 0a       	sbc	r13, r23
    11e0:	e8 0a       	sbc	r14, r24
    11e2:	f9 0a       	sbc	r15, r25
    11e4:	c0 92 27 06 	sts	0x0627, r12
    11e8:	d0 92 28 06 	sts	0x0628, r13
    11ec:	e0 92 29 06 	sts	0x0629, r14
    11f0:	f0 92 2a 06 	sts	0x062A, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    11f4:	40 91 2b 06 	lds	r20, 0x062B
    11f8:	50 91 2c 06 	lds	r21, 0x062C
    11fc:	60 91 2d 06 	lds	r22, 0x062D
    1200:	70 91 2e 06 	lds	r23, 0x062E
    1204:	80 91 27 06 	lds	r24, 0x0627
    1208:	90 91 28 06 	lds	r25, 0x0628
    120c:	a0 91 29 06 	lds	r26, 0x0629
    1210:	b0 91 2a 06 	lds	r27, 0x062A
    1214:	48 17       	cp	r20, r24
    1216:	59 07       	cpc	r21, r25
    1218:	6a 07       	cpc	r22, r26
    121a:	7b 07       	cpc	r23, r27
    121c:	50 f5       	brcc	.+84     	; 0x1272 <__stack+0x173>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    121e:	80 91 15 06 	lds	r24, 0x0615
    1222:	81 30       	cpi	r24, 0x01	; 1
    1224:	19 f4       	brne	.+6      	; 0x122c <__stack+0x12d>
			{
				bankStates[BANK_1].sampleDirection=true;
    1226:	80 93 16 06 	sts	0x0616, r24
    122a:	02 c0       	rjmp	.+4      	; 0x1230 <__stack+0x131>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    122c:	10 92 16 06 	sts	0x0616, r1
			}

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    1230:	80 91 2b 06 	lds	r24, 0x062B
    1234:	90 91 2c 06 	lds	r25, 0x062C
    1238:	a0 91 2d 06 	lds	r26, 0x062D
    123c:	b0 91 2e 06 	lds	r27, 0x062E
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    1240:	40 91 27 06 	lds	r20, 0x0627
    1244:	50 91 28 06 	lds	r21, 0x0628
    1248:	60 91 29 06 	lds	r22, 0x0629
    124c:	70 91 2a 06 	lds	r23, 0x062A
    1250:	40 93 2b 06 	sts	0x062B, r20
    1254:	50 93 2c 06 	sts	0x062C, r21
    1258:	60 93 2d 06 	sts	0x062D, r22
    125c:	70 93 2e 06 	sts	0x062E, r23
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    1260:	80 93 27 06 	sts	0x0627, r24
    1264:	90 93 28 06 	sts	0x0628, r25
    1268:	a0 93 29 06 	sts	0x0629, r26
    126c:	b0 93 2a 06 	sts	0x062A, r27
    1270:	0a c0       	rjmp	.+20     	; 0x1286 <__stack+0x187>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    1272:	80 91 15 06 	lds	r24, 0x0615
    1276:	81 30       	cpi	r24, 0x01	; 1
    1278:	19 f4       	brne	.+6      	; 0x1280 <__stack+0x181>
			{
				bankStates[BANK_1].sampleDirection=false;
    127a:	10 92 16 06 	sts	0x0616, r1
    127e:	03 c0       	rjmp	.+6      	; 0x1286 <__stack+0x187>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	80 93 16 06 	sts	0x0616, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    1286:	40 91 2b 06 	lds	r20, 0x062B
    128a:	50 91 2c 06 	lds	r21, 0x062C
    128e:	60 91 2d 06 	lds	r22, 0x062D
    1292:	70 91 2e 06 	lds	r23, 0x062E
    1296:	80 91 1f 06 	lds	r24, 0x061F
    129a:	90 91 20 06 	lds	r25, 0x0620
    129e:	a0 91 21 06 	lds	r26, 0x0621
    12a2:	b0 91 22 06 	lds	r27, 0x0622
    12a6:	48 17       	cp	r20, r24
    12a8:	59 07       	cpc	r21, r25
    12aa:	6a 07       	cpc	r22, r26
    12ac:	7b 07       	cpc	r23, r27
    12ae:	f8 f4       	brcc	.+62     	; 0x12ee <__stack+0x1ef>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    12b0:	80 91 2b 06 	lds	r24, 0x062B
    12b4:	90 91 2c 06 	lds	r25, 0x062C
    12b8:	a0 91 2d 06 	lds	r26, 0x062D
    12bc:	b0 91 2e 06 	lds	r27, 0x062E
    12c0:	40 91 1f 06 	lds	r20, 0x061F
    12c4:	50 91 20 06 	lds	r21, 0x0620
    12c8:	60 91 21 06 	lds	r22, 0x0621
    12cc:	70 91 22 06 	lds	r23, 0x0622
    12d0:	01 97       	sbiw	r24, 0x01	; 1
    12d2:	a8 4f       	sbci	r26, 0xF8	; 248
    12d4:	bf 4f       	sbci	r27, 0xFF	; 255
    12d6:	84 1b       	sub	r24, r20
    12d8:	95 0b       	sbc	r25, r21
    12da:	a6 0b       	sbc	r26, r22
    12dc:	b7 0b       	sbc	r27, r23
    12de:	80 93 2b 06 	sts	0x062B, r24
    12e2:	90 93 2c 06 	sts	0x062C, r25
    12e6:	a0 93 2d 06 	sts	0x062D, r26
    12ea:	b0 93 2e 06 	sts	0x062E, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    12ee:	40 91 27 06 	lds	r20, 0x0627
    12f2:	50 91 28 06 	lds	r21, 0x0628
    12f6:	60 91 29 06 	lds	r22, 0x0629
    12fa:	70 91 2a 06 	lds	r23, 0x062A
    12fe:	80 91 1f 06 	lds	r24, 0x061F
    1302:	90 91 20 06 	lds	r25, 0x0620
    1306:	a0 91 21 06 	lds	r26, 0x0621
    130a:	b0 91 22 06 	lds	r27, 0x0622
    130e:	48 17       	cp	r20, r24
    1310:	59 07       	cpc	r21, r25
    1312:	6a 07       	cpc	r22, r26
    1314:	7b 07       	cpc	r23, r27
    1316:	08 f0       	brcs	.+2      	; 0x131a <__stack+0x21b>
    1318:	47 c0       	rjmp	.+142    	; 0x13a8 <__stack+0x2a9>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    131a:	80 91 27 06 	lds	r24, 0x0627
    131e:	90 91 28 06 	lds	r25, 0x0628
    1322:	a0 91 29 06 	lds	r26, 0x0629
    1326:	b0 91 2a 06 	lds	r27, 0x062A
    132a:	40 91 1f 06 	lds	r20, 0x061F
    132e:	50 91 20 06 	lds	r21, 0x0620
    1332:	60 91 21 06 	lds	r22, 0x0621
    1336:	70 91 22 06 	lds	r23, 0x0622
    133a:	01 97       	sbiw	r24, 0x01	; 1
    133c:	a8 4f       	sbci	r26, 0xF8	; 248
    133e:	bf 4f       	sbci	r27, 0xFF	; 255
    1340:	84 1b       	sub	r24, r20
    1342:	95 0b       	sbc	r25, r21
    1344:	a6 0b       	sbc	r26, r22
    1346:	b7 0b       	sbc	r27, r23
    1348:	80 93 27 06 	sts	0x0627, r24
    134c:	90 93 28 06 	sts	0x0628, r25
    1350:	a0 93 29 06 	sts	0x0629, r26
    1354:	b0 93 2a 06 	sts	0x062A, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    1358:	40 91 27 06 	lds	r20, 0x0627
    135c:	50 91 28 06 	lds	r21, 0x0628
    1360:	60 91 29 06 	lds	r22, 0x0629
    1364:	70 91 2a 06 	lds	r23, 0x062A
    1368:	80 91 2b 06 	lds	r24, 0x062B
    136c:	90 91 2c 06 	lds	r25, 0x062C
    1370:	a0 91 2d 06 	lds	r26, 0x062D
    1374:	b0 91 2e 06 	lds	r27, 0x062E
    1378:	48 17       	cp	r20, r24
    137a:	59 07       	cpc	r21, r25
    137c:	6a 07       	cpc	r22, r26
    137e:	7b 07       	cpc	r23, r27
    1380:	99 f4       	brne	.+38     	; 0x13a8 <__stack+0x2a9>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    1382:	80 91 27 06 	lds	r24, 0x0627
    1386:	90 91 28 06 	lds	r25, 0x0628
    138a:	a0 91 29 06 	lds	r26, 0x0629
    138e:	b0 91 2a 06 	lds	r27, 0x062A
    1392:	01 96       	adiw	r24, 0x01	; 1
    1394:	a1 1d       	adc	r26, r1
    1396:	b1 1d       	adc	r27, r1
    1398:	80 93 27 06 	sts	0x0627, r24
    139c:	90 93 28 06 	sts	0x0628, r25
    13a0:	a0 93 29 06 	sts	0x0629, r26
    13a4:	b0 93 2a 06 	sts	0x062A, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    13a8:	40 91 2b 06 	lds	r20, 0x062B
    13ac:	50 91 2c 06 	lds	r21, 0x062C
    13b0:	60 91 2d 06 	lds	r22, 0x062D
    13b4:	70 91 2e 06 	lds	r23, 0x062E
    13b8:	80 91 27 06 	lds	r24, 0x0627
    13bc:	90 91 28 06 	lds	r25, 0x0628
    13c0:	a0 91 29 06 	lds	r26, 0x0629
    13c4:	b0 91 2a 06 	lds	r27, 0x062A
    13c8:	48 17       	cp	r20, r24
    13ca:	59 07       	cpc	r21, r25
    13cc:	6a 07       	cpc	r22, r26
    13ce:	7b 07       	cpc	r23, r27
    13d0:	08 f0       	brcs	.+2      	; 0x13d4 <__stack+0x2d5>
    13d2:	5a c0       	rjmp	.+180    	; 0x1488 <__stack+0x389>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    13d4:	40 91 32 06 	lds	r20, 0x0632
    13d8:	50 91 33 06 	lds	r21, 0x0633
    13dc:	60 91 34 06 	lds	r22, 0x0634
    13e0:	70 91 35 06 	lds	r23, 0x0635
    13e4:	80 91 2b 06 	lds	r24, 0x062B
    13e8:	90 91 2c 06 	lds	r25, 0x062C
    13ec:	a0 91 2d 06 	lds	r26, 0x062D
    13f0:	b0 91 2e 06 	lds	r27, 0x062E
    13f4:	84 17       	cp	r24, r20
    13f6:	95 07       	cpc	r25, r21
    13f8:	a6 07       	cpc	r26, r22
    13fa:	b7 07       	cpc	r27, r23
    13fc:	08 f0       	brcs	.+2      	; 0x1400 <__stack+0x301>
    13fe:	87 c0       	rjmp	.+270    	; 0x150e <__stack+0x40f>
    1400:	40 91 32 06 	lds	r20, 0x0632
    1404:	50 91 33 06 	lds	r21, 0x0633
    1408:	60 91 34 06 	lds	r22, 0x0634
    140c:	70 91 35 06 	lds	r23, 0x0635
    1410:	80 91 27 06 	lds	r24, 0x0627
    1414:	90 91 28 06 	lds	r25, 0x0628
    1418:	a0 91 29 06 	lds	r26, 0x0629
    141c:	b0 91 2a 06 	lds	r27, 0x062A
    1420:	48 17       	cp	r20, r24
    1422:	59 07       	cpc	r21, r25
    1424:	6a 07       	cpc	r22, r26
    1426:	7b 07       	cpc	r23, r27
    1428:	08 f0       	brcs	.+2      	; 0x142c <__stack+0x32d>
    142a:	71 c0       	rjmp	.+226    	; 0x150e <__stack+0x40f>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?
    142c:	40 91 32 06 	lds	r20, 0x0632
    1430:	50 91 33 06 	lds	r21, 0x0633
    1434:	60 91 34 06 	lds	r22, 0x0634
    1438:	70 91 35 06 	lds	r23, 0x0635
    143c:	80 90 2b 06 	lds	r8, 0x062B
    1440:	90 90 2c 06 	lds	r9, 0x062C
    1444:	a0 90 2d 06 	lds	r10, 0x062D
    1448:	b0 90 2e 06 	lds	r11, 0x062E
    144c:	80 91 27 06 	lds	r24, 0x0627
    1450:	90 91 28 06 	lds	r25, 0x0628
    1454:	a0 91 29 06 	lds	r26, 0x0629
    1458:	b0 91 2a 06 	lds	r27, 0x062A
    145c:	c0 90 32 06 	lds	r12, 0x0632
    1460:	d0 90 33 06 	lds	r13, 0x0633
    1464:	e0 90 34 06 	lds	r14, 0x0634
    1468:	f0 90 35 06 	lds	r15, 0x0635
    146c:	48 19       	sub	r20, r8
    146e:	59 09       	sbc	r21, r9
    1470:	6a 09       	sbc	r22, r10
    1472:	7b 09       	sbc	r23, r11
    1474:	8c 19       	sub	r24, r12
    1476:	9d 09       	sbc	r25, r13
    1478:	ae 09       	sbc	r26, r14
    147a:	bf 09       	sbc	r27, r15
    147c:	84 17       	cp	r24, r20
    147e:	95 07       	cpc	r25, r21
    1480:	a6 07       	cpc	r26, r22
    1482:	b7 07       	cpc	r27, r23
    1484:	a0 f1       	brcs	.+104    	; 0x14ee <__stack+0x3ef>
    1486:	15 c0       	rjmp	.+42     	; 0x14b2 <__stack+0x3b3>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    1488:	40 91 32 06 	lds	r20, 0x0632
    148c:	50 91 33 06 	lds	r21, 0x0633
    1490:	60 91 34 06 	lds	r22, 0x0634
    1494:	70 91 35 06 	lds	r23, 0x0635
    1498:	80 91 2b 06 	lds	r24, 0x062B
    149c:	90 91 2c 06 	lds	r25, 0x062C
    14a0:	a0 91 2d 06 	lds	r26, 0x062D
    14a4:	b0 91 2e 06 	lds	r27, 0x062E
    14a8:	84 17       	cp	r24, r20
    14aa:	95 07       	cpc	r25, r21
    14ac:	a6 07       	cpc	r26, r22
    14ae:	b7 07       	cpc	r27, r23
    14b0:	48 f4       	brcc	.+18     	; 0x14c4 <__stack+0x3c5>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    14b2:	80 91 2b 06 	lds	r24, 0x062B
    14b6:	90 91 2c 06 	lds	r25, 0x062C
    14ba:	a0 91 2d 06 	lds	r26, 0x062D
    14be:	b0 91 2e 06 	lds	r27, 0x062E
    14c2:	1d c0       	rjmp	.+58     	; 0x14fe <__stack+0x3ff>
			}
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    14c4:	40 91 32 06 	lds	r20, 0x0632
    14c8:	50 91 33 06 	lds	r21, 0x0633
    14cc:	60 91 34 06 	lds	r22, 0x0634
    14d0:	70 91 35 06 	lds	r23, 0x0635
    14d4:	80 91 27 06 	lds	r24, 0x0627
    14d8:	90 91 28 06 	lds	r25, 0x0628
    14dc:	a0 91 29 06 	lds	r26, 0x0629
    14e0:	b0 91 2a 06 	lds	r27, 0x062A
    14e4:	48 17       	cp	r20, r24
    14e6:	59 07       	cpc	r21, r25
    14e8:	6a 07       	cpc	r22, r26
    14ea:	7b 07       	cpc	r23, r27
    14ec:	80 f4       	brcc	.+32     	; 0x150e <__stack+0x40f>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    14ee:	80 91 27 06 	lds	r24, 0x0627
    14f2:	90 91 28 06 	lds	r25, 0x0628
    14f6:	a0 91 29 06 	lds	r26, 0x0629
    14fa:	b0 91 2a 06 	lds	r27, 0x062A
    14fe:	80 93 32 06 	sts	0x0632, r24
    1502:	90 93 33 06 	sts	0x0633, r25
    1506:	a0 93 34 06 	sts	0x0634, r26
    150a:	b0 93 35 06 	sts	0x0635, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    150e:	ef bf       	out	0x3f, r30	; 63
}
    1510:	ff 90       	pop	r15
    1512:	ef 90       	pop	r14
    1514:	df 90       	pop	r13
    1516:	cf 90       	pop	r12
    1518:	bf 90       	pop	r11
    151a:	af 90       	pop	r10
    151c:	9f 90       	pop	r9
    151e:	8f 90       	pop	r8
    1520:	7f 90       	pop	r7
    1522:	6f 90       	pop	r6
    1524:	5f 90       	pop	r5
    1526:	4f 90       	pop	r4
    1528:	08 95       	ret

0000152a <RevertSampleToUnadjusted>:
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    152a:	9f b7       	in	r25, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    152c:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    152e:	2e e2       	ldi	r18, 0x2E	; 46
    1530:	82 9f       	mul	r24, r18
    1532:	f0 01       	movw	r30, r0
    1534:	11 24       	eor	r1, r1
    1536:	ec 51       	subi	r30, 0x1C	; 28
    1538:	fa 4f       	sbci	r31, 0xFA	; 250
    153a:	41 89       	ldd	r20, Z+17	; 0x11
    153c:	52 89       	ldd	r21, Z+18	; 0x12
    153e:	63 89       	ldd	r22, Z+19	; 0x13
    1540:	74 89       	ldd	r23, Z+20	; 0x14
    1542:	41 8f       	std	Z+25, r20	; 0x19
    1544:	52 8f       	std	Z+26, r21	; 0x1a
    1546:	63 8f       	std	Z+27, r22	; 0x1b
    1548:	74 8f       	std	Z+28, r23	; 0x1c
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    154a:	45 85       	ldd	r20, Z+13	; 0x0d
    154c:	56 85       	ldd	r21, Z+14	; 0x0e
    154e:	67 85       	ldd	r22, Z+15	; 0x0f
    1550:	70 89       	ldd	r23, Z+16	; 0x10
    1552:	45 8b       	std	Z+21, r20	; 0x15
    1554:	56 8b       	std	Z+22, r21	; 0x16
    1556:	67 8b       	std	Z+23, r22	; 0x17
    1558:	70 8f       	std	Z+24, r23	; 0x18
	bankStates[theBank].sampleStartOffset=0;
    155a:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleEndOffset=0;
    155c:	16 8e       	std	Z+30, r1	; 0x1e
	bankStates[theBank].sampleWindowOffset=0;
    155e:	17 8e       	std	Z+31, r1	; 0x1f
	SREG=sreg;		// Restore interrupts.
    1560:	9f bf       	out	0x3f, r25	; 63
    1562:	08 95       	ret

00001564 <BlinkLeds>:
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1564:	40 91 ad 05 	lds	r20, 0x05AD
    1568:	50 e0       	ldi	r21, 0x00	; 0
    156a:	90 91 5b 05 	lds	r25, 0x055B
    156e:	20 e0       	ldi	r18, 0x00	; 0
    1570:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1572:	61 e0       	ldi	r22, 0x01	; 1
    1574:	70 e0       	ldi	r23, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1576:	da 01       	movw	r26, r20
    1578:	02 2e       	mov	r0, r18
    157a:	02 c0       	rjmp	.+4      	; 0x1580 <BlinkLeds+0x1c>
    157c:	b5 95       	asr	r27
    157e:	a7 95       	ror	r26
    1580:	0a 94       	dec	r0
    1582:	e2 f7       	brpl	.-8      	; 0x157c <BlinkLeds+0x18>
    1584:	a0 ff       	sbrs	r26, 0
    1586:	0a c0       	rjmp	.+20     	; 0x159c <BlinkLeds+0x38>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1588:	db 01       	movw	r26, r22
    158a:	02 2e       	mov	r0, r18
    158c:	02 c0       	rjmp	.+4      	; 0x1592 <BlinkLeds+0x2e>
    158e:	aa 0f       	add	r26, r26
    1590:	bb 1f       	adc	r27, r27
    1592:	0a 94       	dec	r0
    1594:	e2 f7       	brpl	.-8      	; 0x158e <BlinkLeds+0x2a>
    1596:	fd 01       	movw	r30, r26
    1598:	e0 95       	com	r30
    159a:	9e 23       	and	r25, r30
    159c:	2f 5f       	subi	r18, 0xFF	; 255
    159e:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    15a0:	28 30       	cpi	r18, 0x08	; 8
    15a2:	31 05       	cpc	r19, r1
    15a4:	41 f7       	brne	.-48     	; 0x1576 <BlinkLeds+0x12>
    15a6:	90 93 5b 05 	sts	0x055B, r25
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    15aa:	80 93 ad 05 	sts	0x05AD, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    15ae:	68 e9       	ldi	r22, 0x98	; 152
    15b0:	70 e0       	ldi	r23, 0x00	; 0
    15b2:	82 e0       	ldi	r24, 0x02	; 2
    15b4:	0c 94 5e 1f 	jmp	0x3ebc	; 0x3ebc <SetTimer>

000015b8 <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    15b8:	10 92 5b 05 	sts	0x055B, r1
	BlinkLeds(0);		// Durrrr.....
    15bc:	80 e0       	ldi	r24, 0x00	; 0
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	0c 94 b2 0a 	jmp	0x1564	; 0x1564 <BlinkLeds>

000015c4 <StopBlinking>:
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    15c4:	80 e0       	ldi	r24, 0x00	; 0
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	0c 94 b2 0a 	jmp	0x1564	; 0x1564 <BlinkLeds>

000015cc <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    15cc:	cf 93       	push	r28
	static unsigned char
		i;

	if(subState==SS_0)
    15ce:	c0 91 59 05 	lds	r28, 0x0559
    15d2:	c1 11       	cpse	r28, r1
    15d4:	11 c0       	rjmp	.+34     	; 0x15f8 <DoFruitcakeIntro+0x2c>
	{
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    15d6:	10 92 57 05 	sts	0x0557, r1

		KillLeds();
    15da:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
		i=0;
    15de:	10 92 5a 05 	sts	0x055A, r1
		ledOnOffMask=0;
    15e2:	10 92 5b 05 	sts	0x055B, r1
		subState=SS_1;
    15e6:	81 e0       	ldi	r24, 0x01	; 1
    15e8:	80 93 59 05 	sts	0x0559, r24
		SetTimer(TIMER_1,(SECOND/4));
    15ec:	61 e3       	ldi	r22, 0x31	; 49
    15ee:	71 e0       	ldi	r23, 0x01	; 1
    15f0:	80 e0       	ldi	r24, 0x00	; 0
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
}
    15f2:	cf 91       	pop	r28

		KillLeds();
		i=0;
		ledOnOffMask=0;
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
    15f4:	0c 94 5e 1f 	jmp	0x3ebc	; 0x3ebc <SetTimer>
	}
	else if(subState==SS_1)
    15f8:	c1 30       	cpi	r28, 0x01	; 1
    15fa:	41 f4       	brne	.+16     	; 0x160c <DoFruitcakeIntro+0x40>
	{
		if(CheckTimer(TIMER_1))
    15fc:	80 e0       	ldi	r24, 0x00	; 0
    15fe:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    1602:	88 23       	and	r24, r24
    1604:	09 f4       	brne	.+2      	; 0x1608 <DoFruitcakeIntro+0x3c>
    1606:	91 c0       	rjmp	.+290    	; 0x172a <DoFruitcakeIntro+0x15e>
		{
			subState=SS_2;
    1608:	82 e0       	ldi	r24, 0x02	; 2
    160a:	7b c0       	rjmp	.+246    	; 0x1702 <DoFruitcakeIntro+0x136>
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}

	else if(subState==SS_2)
    160c:	c2 30       	cpi	r28, 0x02	; 2
    160e:	09 f0       	breq	.+2      	; 0x1612 <DoFruitcakeIntro+0x46>
    1610:	4a c0       	rjmp	.+148    	; 0x16a6 <DoFruitcakeIntro+0xda>
	{
		if(i<NUM_LEDS)
    1612:	80 91 5a 05 	lds	r24, 0x055A
    1616:	88 30       	cpi	r24, 0x08	; 8
    1618:	f8 f4       	brcc	.+62     	; 0x1658 <DoFruitcakeIntro+0x8c>
		{
			if(CheckTimer(TIMER_1))
    161a:	80 e0       	ldi	r24, 0x00	; 0
    161c:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    1620:	88 23       	and	r24, r24
    1622:	09 f4       	brne	.+2      	; 0x1626 <DoFruitcakeIntro+0x5a>
    1624:	82 c0       	rjmp	.+260    	; 0x172a <DoFruitcakeIntro+0x15e>
			{
				ledOnOffMask|=(1<<i);
    1626:	81 e0       	ldi	r24, 0x01	; 1
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	00 90 5a 05 	lds	r0, 0x055A
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <DoFruitcakeIntro+0x68>
    1630:	88 0f       	add	r24, r24
    1632:	99 1f       	adc	r25, r25
    1634:	0a 94       	dec	r0
    1636:	e2 f7       	brpl	.-8      	; 0x1630 <DoFruitcakeIntro+0x64>
    1638:	90 91 5b 05 	lds	r25, 0x055B
    163c:	98 2b       	or	r25, r24
    163e:	90 93 5b 05 	sts	0x055B, r25
				SetTimer(TIMER_1,(SECOND/20));
    1642:	6d e3       	ldi	r22, 0x3D	; 61
    1644:	70 e0       	ldi	r23, 0x00	; 0
    1646:	80 e0       	ldi	r24, 0x00	; 0
    1648:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
				i++;
    164c:	80 91 5a 05 	lds	r24, 0x055A
    1650:	8f 5f       	subi	r24, 0xFF	; 255
    1652:	80 93 5a 05 	sts	0x055A, r24
    1656:	69 c0       	rjmp	.+210    	; 0x172a <DoFruitcakeIntro+0x15e>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    1658:	80 e0       	ldi	r24, 0x00	; 0
    165a:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    165e:	88 23       	and	r24, r24
    1660:	09 f4       	brne	.+2      	; 0x1664 <DoFruitcakeIntro+0x98>
    1662:	63 c0       	rjmp	.+198    	; 0x172a <DoFruitcakeIntro+0x15e>
			{
				SetTimer(TIMER_1,(SECOND/8));
    1664:	68 e9       	ldi	r22, 0x98	; 152
    1666:	70 e0       	ldi	r23, 0x00	; 0
    1668:	80 e0       	ldi	r24, 0x00	; 0
    166a:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
				ledPwm=255;
    166e:	8f ef       	ldi	r24, 0xFF	; 255
    1670:	80 93 40 04 	sts	0x0440, r24
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    1674:	90 91 64 00 	lds	r25, 0x0064
    1678:	9f 7b       	andi	r25, 0xBF	; 191
    167a:	90 93 64 00 	sts	0x0064, r25

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    167e:	c0 93 b0 00 	sts	0x00B0, r28
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    1682:	91 e0       	ldi	r25, 0x01	; 1
    1684:	90 93 b1 00 	sts	0x00B1, r25
				TCNT2=0;			// Init counter reg
    1688:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    168c:	90 e8       	ldi	r25, 0x80	; 128
    168e:	90 93 b3 00 	sts	0x00B3, r25
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    1692:	87 bb       	out	0x17, r24	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    1694:	c0 93 70 00 	sts	0x0070, r28

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    1698:	92 b1       	in	r25, 0x02	; 2
    169a:	96 60       	ori	r25, 0x06	; 6
    169c:	92 b9       	out	0x02, r25	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    169e:	84 b9       	out	0x04, r24	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    16a0:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;
    16a2:	83 e0       	ldi	r24, 0x03	; 3
    16a4:	2e c0       	rjmp	.+92     	; 0x1702 <DoFruitcakeIntro+0x136>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_3)
    16a6:	c3 30       	cpi	r28, 0x03	; 3
    16a8:	79 f5       	brne	.+94     	; 0x1708 <DoFruitcakeIntro+0x13c>
	{
		if(CheckTimer(TIMER_1))
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    16b0:	88 23       	and	r24, r24
    16b2:	d9 f1       	breq	.+118    	; 0x172a <DoFruitcakeIntro+0x15e>
		{
			if(ledPwm>1)
    16b4:	80 91 40 04 	lds	r24, 0x0440
    16b8:	82 30       	cpi	r24, 0x02	; 2
    16ba:	58 f0       	brcs	.+22     	; 0x16d2 <DoFruitcakeIntro+0x106>
			{
				ledPwm-=2;
    16bc:	80 91 40 04 	lds	r24, 0x0440
    16c0:	82 50       	subi	r24, 0x02	; 2
    16c2:	80 93 40 04 	sts	0x0440, r24
				SetTimer(TIMER_1,(SECOND/256));
    16c6:	64 e0       	ldi	r22, 0x04	; 4
    16c8:	70 e0       	ldi	r23, 0x00	; 0
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
    16d0:	2c c0       	rjmp	.+88     	; 0x172a <DoFruitcakeIntro+0x15e>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    16d2:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    16d6:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    16da:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
    16de:	80 91 64 00 	lds	r24, 0x0064
    16e2:	80 64       	ori	r24, 0x40	; 64
    16e4:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    16e8:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    16ea:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    16ec:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    16f0:	82 e1       	ldi	r24, 0x12	; 18
    16f2:	80 93 5b 05 	sts	0x055B, r24
				SetTimer(TIMER_1,(SECOND/2));
    16f6:	62 e6       	ldi	r22, 0x62	; 98
    16f8:	72 e0       	ldi	r23, 0x02	; 2
    16fa:	80 e0       	ldi	r24, 0x00	; 0
    16fc:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
				subState=SS_4;
    1700:	84 e0       	ldi	r24, 0x04	; 4
    1702:	80 93 59 05 	sts	0x0559, r24
    1706:	11 c0       	rjmp	.+34     	; 0x172a <DoFruitcakeIntro+0x15e>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_4)
    1708:	c4 30       	cpi	r28, 0x04	; 4
    170a:	89 f4       	brne	.+34     	; 0x172e <DoFruitcakeIntro+0x162>
	{
		if(CheckTimer(TIMER_1))
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    1712:	88 23       	and	r24, r24
    1714:	51 f0       	breq	.+20     	; 0x172a <DoFruitcakeIntro+0x15e>
		{
			KillLeds();
    1716:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    171a:	81 ec       	ldi	r24, 0xC1	; 193
    171c:	9d e0       	ldi	r25, 0x0D	; 13
    171e:	90 93 e3 05 	sts	0x05E3, r25
    1722:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    1726:	10 92 59 05 	sts	0x0559, r1
		if(CheckTimer(TIMER_1))
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    172a:	10 92 57 05 	sts	0x0557, r1
	}
}
    172e:	cf 91       	pop	r28
    1730:	08 95       	ret

00001732 <ResetSdCard>:
	SREG=sreg;	// Resume ISR
}

static void ResetSdCard(void)
// If we unceremoniously pull a card, do this.
{
    1732:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1734:	cf b7       	in	r28, 0x3f	; 63
	cli();
    1736:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    1738:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
    173c:	ed e6       	ldi	r30, 0x6D	; 109
    173e:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    1740:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    1742:	85 e0       	ldi	r24, 0x05	; 5
    1744:	ed 3a       	cpi	r30, 0xAD	; 173
    1746:	f8 07       	cpc	r31, r24
    1748:	d9 f7       	brne	.-10     	; 0x1740 <ResetSdCard+0xe>
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
	ClearSampleToc();
	
	// Stop SD card ISR

	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    174a:	10 92 4d 05 	sts	0x054D, r1
	TCCR2B=0;					// Stop this timer
    174e:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    1752:	80 91 70 00 	lds	r24, 0x0070
    1756:	8b 7f       	andi	r24, 0xFB	; 251
    1758:	80 93 70 00 	sts	0x0070, r24

	// Set this contribution to the DAC to midscale (this output source is now quiet)
	sdStreamOutput=0;
    175c:	10 92 53 05 	sts	0x0553, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    1760:	10 92 2b 01 	sts	0x012B, r1
    1764:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    1768:	10 92 29 01 	sts	0x0129, r1
    176c:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    1770:	10 92 27 01 	sts	0x0127, r1
    1774:	10 92 26 01 	sts	0x0126, r1

	InitSdInterface();
    1778:	0e 94 7e 21 	call	0x42fc	; 0x42fc <InitSdInterface>
	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
    177c:	10 92 57 05 	sts	0x0557, r1

	SREG=sreg;
    1780:	cf bf       	out	0x3f, r28	; 63
}
    1782:	cf 91       	pop	r28
    1784:	08 95       	ret

00001786 <SdStartSampleRead>:

static bool SdStartSampleRead(unsigned int sampleSlot)
// Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
// Begins a sample read in the correct spot.
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
    1786:	cf 92       	push	r12
    1788:	df 92       	push	r13
    178a:	ef 92       	push	r14
    178c:	ff 92       	push	r15
    178e:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1790:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    1792:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    1794:	38 2f       	mov	r19, r24
    1796:	33 0f       	add	r19, r19
    1798:	33 0f       	add	r19, r19
    179a:	20 e0       	ldi	r18, 0x00	; 0
    179c:	69 01       	movw	r12, r18
    179e:	8f ef       	ldi	r24, 0xFF	; 255
    17a0:	c8 1a       	sub	r12, r24
    17a2:	d8 0a       	sbc	r13, r24
    17a4:	e1 2c       	mov	r14, r1
    17a6:	f1 2c       	mov	r15, r1
    17a8:	c7 01       	movw	r24, r14
    17aa:	b6 01       	movw	r22, r12
    17ac:	0e 94 38 23 	call	0x4670	; 0x4670 <SdBeginSingleBlockRead>
    17b0:	81 30       	cpi	r24, 0x01	; 1
    17b2:	19 f5       	brne	.+70     	; 0x17fa <SdStartSampleRead+0x74>
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    17b4:	c0 92 b0 05 	sts	0x05B0, r12
    17b8:	d0 92 b1 05 	sts	0x05B1, r13
    17bc:	e0 92 b2 05 	sts	0x05B2, r14
    17c0:	f0 92 b3 05 	sts	0x05B3, r15
		sdCurrentBlockOffset=0;						// Read first block first
    17c4:	10 92 b5 05 	sts	0x05B5, r1
    17c8:	10 92 b4 05 	sts	0x05B4, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    17cc:	10 92 2b 01 	sts	0x012B, r1
    17d0:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    17d4:	10 92 29 01 	sts	0x0129, r1
    17d8:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    17dc:	10 92 27 01 	sts	0x0127, r1
    17e0:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    17e4:	6a e7       	ldi	r22, 0x7A	; 122
    17e6:	70 e0       	ldi	r23, 0x00	; 0
    17e8:	83 e0       	ldi	r24, 0x03	; 3
    17ea:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    17ee:	89 e0       	ldi	r24, 0x09	; 9
    17f0:	80 93 57 05 	sts	0x0557, r24

		SREG=sreg;	// Resume ISR
    17f4:	cf bf       	out	0x3f, r28	; 63

		return(true);
    17f6:	81 e0       	ldi	r24, 0x01	; 1
    17f8:	02 c0       	rjmp	.+4      	; 0x17fe <SdStartSampleRead+0x78>
	}
	SREG=sreg;	// Resume ISR
    17fa:	cf bf       	out	0x3f, r28	; 63
	return(false);
    17fc:	80 e0       	ldi	r24, 0x00	; 0
}
    17fe:	cf 91       	pop	r28
    1800:	ff 90       	pop	r15
    1802:	ef 90       	pop	r14
    1804:	df 90       	pop	r13
    1806:	cf 90       	pop	r12
    1808:	08 95       	ret

0000180a <SetSampleClock.part.1>:
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    180a:	e1 e8       	ldi	r30, 0x81	; 129
    180c:	f0 e0       	ldi	r31, 0x00	; 0
    180e:	80 81       	ld	r24, Z
    1810:	80 64       	ori	r24, 0x40	; 64
    1812:	80 83       	st	Z, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1814:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1816:	ef e6       	ldi	r30, 0x6F	; 111
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	80 81       	ld	r24, Z
    181c:	80 62       	ori	r24, 0x20	; 32
    181e:	80 83       	st	Z, r24
    1820:	08 95       	ret

00001822 <SetSampleClock>:

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    1822:	9e e2       	ldi	r25, 0x2E	; 46
    1824:	89 9f       	mul	r24, r25
    1826:	f0 01       	movw	r30, r0
    1828:	11 24       	eor	r1, r1
    182a:	ec 51       	subi	r30, 0x1C	; 28
    182c:	fa 4f       	sbci	r31, 0xFA	; 250
    182e:	62 87       	std	Z+10, r22	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1830:	62 30       	cpi	r22, 0x02	; 2
    1832:	39 f5       	brne	.+78     	; 0x1882 <SetSampleClock+0x60>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1834:	54 87       	std	Z+12, r21	; 0x0c
    1836:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1838:	81 11       	cpse	r24, r1
    183a:	0f c0       	rjmp	.+30     	; 0x185a <SetSampleClock+0x38>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    183c:	80 91 84 00 	lds	r24, 0x0084
    1840:	90 91 85 00 	lds	r25, 0x0085
    1844:	84 0f       	add	r24, r20
    1846:	95 1f       	adc	r25, r21
    1848:	90 93 89 00 	sts	0x0089, r25
    184c:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1850:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    1852:	80 91 6f 00 	lds	r24, 0x006F
    1856:	82 60       	ori	r24, 0x02	; 2
    1858:	0e c0       	rjmp	.+28     	; 0x1876 <SetSampleClock+0x54>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    185a:	80 91 84 00 	lds	r24, 0x0084
    185e:	90 91 85 00 	lds	r25, 0x0085
    1862:	84 0f       	add	r24, r20
    1864:	95 1f       	adc	r25, r21
    1866:	90 93 8b 00 	sts	0x008B, r25
    186a:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    186e:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1870:	80 91 6f 00 	lds	r24, 0x006F
    1874:	84 60       	ori	r24, 0x04	; 4
    1876:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	80 93 81 00 	sts	0x0081, r24
    1880:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1882:	61 30       	cpi	r22, 0x01	; 1
    1884:	59 f4       	brne	.+22     	; 0x189c <SetSampleClock+0x7a>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1886:	81 11       	cpse	r24, r1
    1888:	02 c0       	rjmp	.+4      	; 0x188e <SetSampleClock+0x6c>
    188a:	0c 94 05 0c 	jmp	0x180a	; 0x180a <SetSampleClock.part.1>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    188e:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    1890:	84 e0       	ldi	r24, 0x04	; 4
    1892:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    1896:	80 e1       	ldi	r24, 0x10	; 16
    1898:	80 93 6d 00 	sts	0x006D, r24
    189c:	08 95       	ret

0000189e <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    189e:	ff 92       	push	r15
    18a0:	0f 93       	push	r16
    18a2:	1f 93       	push	r17
    18a4:	cf 93       	push	r28
    18a6:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    18a8:	c8 2f       	mov	r28, r24
    18aa:	d0 e0       	ldi	r29, 0x00	; 0
    18ac:	9e e2       	ldi	r25, 0x2E	; 46
    18ae:	89 9f       	mul	r24, r25
    18b0:	f0 01       	movw	r30, r0
    18b2:	11 24       	eor	r1, r1
    18b4:	ec 51       	subi	r30, 0x1C	; 28
    18b6:	fa 4f       	sbci	r31, 0xFA	; 250
    18b8:	95 81       	ldd	r25, Z+5	; 0x05
    18ba:	99 23       	and	r25, r25
    18bc:	29 f0       	breq	.+10     	; 0x18c8 <StartPlayback+0x2a>
    18be:	90 91 4d 05 	lds	r25, 0x054D
    18c2:	91 50       	subi	r25, 0x01	; 1
    18c4:	92 30       	cpi	r25, 0x02	; 2
    18c6:	80 f1       	brcs	.+96     	; 0x1928 <StartPlayback+0x8a>
	{
		sreg=SREG;	// Store global interrupt state.
    18c8:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    18ca:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    18cc:	9e e2       	ldi	r25, 0x2E	; 46
    18ce:	9c 9f       	mul	r25, r28
    18d0:	f0 01       	movw	r30, r0
    18d2:	9d 9f       	mul	r25, r29
    18d4:	f0 0d       	add	r31, r0
    18d6:	11 24       	eor	r1, r1
    18d8:	ec 51       	subi	r30, 0x1C	; 28
    18da:	fa 4f       	sbci	r31, 0xFA	; 250
    18dc:	94 e0       	ldi	r25, 0x04	; 4
    18de:	90 83       	st	Z, r25

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    18e0:	93 81       	ldd	r25, Z+3	; 0x03
    18e2:	99 23       	and	r25, r25
    18e4:	51 f0       	breq	.+20     	; 0x18fa <StartPlayback+0x5c>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    18e6:	05 89       	ldd	r16, Z+21	; 0x15
    18e8:	16 89       	ldd	r17, Z+22	; 0x16
    18ea:	27 89       	ldd	r18, Z+23	; 0x17
    18ec:	30 8d       	ldd	r19, Z+24	; 0x18
    18ee:	00 a3       	std	Z+32, r16	; 0x20
    18f0:	11 a3       	std	Z+33, r17	; 0x21
    18f2:	22 a3       	std	Z+34, r18	; 0x22
    18f4:	33 a3       	std	Z+35, r19	; 0x23
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    18f6:	14 82       	std	Z+4, r1	; 0x04
    18f8:	0a c0       	rjmp	.+20     	; 0x190e <StartPlayback+0x70>
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    18fa:	01 8d       	ldd	r16, Z+25	; 0x19
    18fc:	12 8d       	ldd	r17, Z+26	; 0x1a
    18fe:	23 8d       	ldd	r18, Z+27	; 0x1b
    1900:	34 8d       	ldd	r19, Z+28	; 0x1c
    1902:	00 a3       	std	Z+32, r16	; 0x20
    1904:	11 a3       	std	Z+33, r17	; 0x21
    1906:	22 a3       	std	Z+34, r18	; 0x22
    1908:	33 a3       	std	Z+35, r19	; 0x23
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    190a:	91 e0       	ldi	r25, 0x01	; 1
    190c:	94 83       	std	Z+4, r25	; 0x04
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    190e:	0e 94 11 0c 	call	0x1822	; 0x1822 <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    1912:	8e e2       	ldi	r24, 0x2E	; 46
    1914:	8c 9f       	mul	r24, r28
    1916:	f0 01       	movw	r30, r0
    1918:	8d 9f       	mul	r24, r29
    191a:	f0 0d       	add	r31, r0
    191c:	11 24       	eor	r1, r1
    191e:	ec 51       	subi	r30, 0x1C	; 28
    1920:	fa 4f       	sbci	r31, 0xFA	; 250
    1922:	81 e0       	ldi	r24, 0x01	; 1
    1924:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1926:	ff be       	out	0x3f, r15	; 63
	}
}
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	1f 91       	pop	r17
    192e:	0f 91       	pop	r16
    1930:	ff 90       	pop	r15
    1932:	08 95       	ret

00001934 <ContinuePlayback>:

static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
    1934:	1f 93       	push	r17
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    193a:	28 2f       	mov	r18, r24
    193c:	30 e0       	ldi	r19, 0x00	; 0
    193e:	9e e2       	ldi	r25, 0x2E	; 46
    1940:	89 9f       	mul	r24, r25
    1942:	f0 01       	movw	r30, r0
    1944:	11 24       	eor	r1, r1
    1946:	ec 51       	subi	r30, 0x1C	; 28
    1948:	fa 4f       	sbci	r31, 0xFA	; 250
    194a:	95 81       	ldd	r25, Z+5	; 0x05
    194c:	99 23       	and	r25, r25
    194e:	29 f0       	breq	.+10     	; 0x195a <ContinuePlayback+0x26>
    1950:	90 91 4d 05 	lds	r25, 0x054D
    1954:	91 50       	subi	r25, 0x01	; 1
    1956:	92 30       	cpi	r25, 0x02	; 2
    1958:	88 f0       	brcs	.+34     	; 0x197c <ContinuePlayback+0x48>
	{
		sreg=SREG;	// Store global interrupt state.
    195a:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    195c:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    195e:	9e e2       	ldi	r25, 0x2E	; 46
    1960:	92 9f       	mul	r25, r18
    1962:	e0 01       	movw	r28, r0
    1964:	93 9f       	mul	r25, r19
    1966:	d0 0d       	add	r29, r0
    1968:	11 24       	eor	r1, r1
    196a:	cc 51       	subi	r28, 0x1C	; 28
    196c:	da 4f       	sbci	r29, 0xFA	; 250
    196e:	94 e0       	ldi	r25, 0x04	; 4
    1970:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1972:	0e 94 11 0c 	call	0x1822	; 0x1822 <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    197a:	1f bf       	out	0x3f, r17	; 63
	}
}
    197c:	df 91       	pop	r29
    197e:	cf 91       	pop	r28
    1980:	1f 91       	pop	r17
    1982:	08 95       	ret

00001984 <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    1984:	ff 92       	push	r15
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    198e:	28 2f       	mov	r18, r24
    1990:	30 e0       	ldi	r19, 0x00	; 0
    1992:	9e e2       	ldi	r25, 0x2E	; 46
    1994:	89 9f       	mul	r24, r25
    1996:	f0 01       	movw	r30, r0
    1998:	11 24       	eor	r1, r1
    199a:	ec 51       	subi	r30, 0x1C	; 28
    199c:	fa 4f       	sbci	r31, 0xFA	; 250
    199e:	95 81       	ldd	r25, Z+5	; 0x05
    19a0:	99 23       	and	r25, r25
    19a2:	31 f0       	breq	.+12     	; 0x19b0 <StartRecording+0x2c>
    19a4:	90 91 4d 05 	lds	r25, 0x054D
    19a8:	91 50       	subi	r25, 0x01	; 1
    19aa:	92 30       	cpi	r25, 0x02	; 2
    19ac:	08 f4       	brcc	.+2      	; 0x19b0 <StartRecording+0x2c>
    19ae:	42 c0       	rjmp	.+132    	; 0x1a34 <StartRecording+0xb0>
	{

		sreg=SREG;	// Store global interrupt state.
    19b0:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    19b2:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    19b4:	9e e2       	ldi	r25, 0x2E	; 46
    19b6:	92 9f       	mul	r25, r18
    19b8:	e0 01       	movw	r28, r0
    19ba:	93 9f       	mul	r25, r19
    19bc:	d0 0d       	add	r29, r0
    19be:	11 24       	eor	r1, r1
    19c0:	cc 51       	subi	r28, 0x1C	; 28
    19c2:	da 4f       	sbci	r29, 0xFA	; 250
    19c4:	93 e0       	ldi	r25, 0x03	; 3
    19c6:	98 83       	st	Y, r25

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    19c8:	09 89       	ldd	r16, Y+17	; 0x11
    19ca:	1a 89       	ldd	r17, Y+18	; 0x12
    19cc:	2b 89       	ldd	r18, Y+19	; 0x13
    19ce:	3c 89       	ldd	r19, Y+20	; 0x14
    19d0:	08 a3       	std	Y+32, r16	; 0x20
    19d2:	19 a3       	std	Y+33, r17	; 0x21
    19d4:	2a a3       	std	Y+34, r18	; 0x22
    19d6:	3b a3       	std	Y+35, r19	; 0x23
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    19d8:	09 89       	ldd	r16, Y+17	; 0x11
    19da:	1a 89       	ldd	r17, Y+18	; 0x12
    19dc:	2b 89       	ldd	r18, Y+19	; 0x13
    19de:	3c 89       	ldd	r19, Y+20	; 0x14
    19e0:	0d 87       	std	Y+13, r16	; 0x0d
    19e2:	1e 87       	std	Y+14, r17	; 0x0e
    19e4:	2f 87       	std	Y+15, r18	; 0x0f
    19e6:	38 8b       	std	Y+16, r19	; 0x10
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    19e8:	09 89       	ldd	r16, Y+17	; 0x11
    19ea:	1a 89       	ldd	r17, Y+18	; 0x12
    19ec:	2b 89       	ldd	r18, Y+19	; 0x13
    19ee:	3c 89       	ldd	r19, Y+20	; 0x14
    19f0:	09 8f       	std	Y+25, r16	; 0x19
    19f2:	1a 8f       	std	Y+26, r17	; 0x1a
    19f4:	2b 8f       	std	Y+27, r18	; 0x1b
    19f6:	3c 8f       	std	Y+28, r19	; 0x1c
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    19f8:	09 89       	ldd	r16, Y+17	; 0x11
    19fa:	1a 89       	ldd	r17, Y+18	; 0x12
    19fc:	2b 89       	ldd	r18, Y+19	; 0x13
    19fe:	3c 89       	ldd	r19, Y+20	; 0x14
    1a00:	0d 8b       	std	Y+21, r16	; 0x15
    1a02:	1e 8b       	std	Y+22, r17	; 0x16
    1a04:	2f 8b       	std	Y+23, r18	; 0x17
    1a06:	38 8f       	std	Y+24, r19	; 0x18
		bankStates[theBank].sampleWindowOffset=0;									// "
    1a08:	1f 8e       	std	Y+31, r1	; 0x1f

		outOfRam=false;						// Plenty of ram left...
    1a0a:	10 92 3f 04 	sts	0x043F, r1

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    1a0e:	0e 94 11 0c 	call	0x1822	; 0x1822 <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	8d 83       	std	Y+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    1a16:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1a18:	80 91 7a 00 	lds	r24, 0x007A
    1a1c:	86 fd       	sbrc	r24, 6
    1a1e:	0a c0       	rjmp	.+20     	; 0x1a34 <StartRecording+0xb0>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1a20:	80 91 79 00 	lds	r24, 0x0079
    1a24:	80 58       	subi	r24, 0x80	; 128
    1a26:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1a2a:	80 91 7a 00 	lds	r24, 0x007A
    1a2e:	80 64       	ori	r24, 0x40	; 64
    1a30:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    1a34:	df 91       	pop	r29
    1a36:	cf 91       	pop	r28
    1a38:	1f 91       	pop	r17
    1a3a:	0f 91       	pop	r16
    1a3c:	ff 90       	pop	r15
    1a3e:	08 95       	ret

00001a40 <StartOverdub>:
}

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1a46:	28 2f       	mov	r18, r24
    1a48:	30 e0       	ldi	r19, 0x00	; 0
    1a4a:	9e e2       	ldi	r25, 0x2E	; 46
    1a4c:	89 9f       	mul	r24, r25
    1a4e:	f0 01       	movw	r30, r0
    1a50:	11 24       	eor	r1, r1
    1a52:	ec 51       	subi	r30, 0x1C	; 28
    1a54:	fa 4f       	sbci	r31, 0xFA	; 250
    1a56:	95 81       	ldd	r25, Z+5	; 0x05
    1a58:	99 23       	and	r25, r25
    1a5a:	29 f0       	breq	.+10     	; 0x1a66 <StartOverdub+0x26>
    1a5c:	90 91 4d 05 	lds	r25, 0x054D
    1a60:	91 50       	subi	r25, 0x01	; 1
    1a62:	92 30       	cpi	r25, 0x02	; 2
    1a64:	f8 f0       	brcs	.+62     	; 0x1aa4 <StartOverdub+0x64>
	{
		sreg=SREG;	// Store global interrupt state.
    1a66:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1a68:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    1a6a:	9e e2       	ldi	r25, 0x2E	; 46
    1a6c:	92 9f       	mul	r25, r18
    1a6e:	e0 01       	movw	r28, r0
    1a70:	93 9f       	mul	r25, r19
    1a72:	d0 0d       	add	r29, r0
    1a74:	11 24       	eor	r1, r1
    1a76:	cc 51       	subi	r28, 0x1C	; 28
    1a78:	da 4f       	sbci	r29, 0xFA	; 250
    1a7a:	95 e0       	ldi	r25, 0x05	; 5
    1a7c:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1a7e:	0e 94 11 0c 	call	0x1822	; 0x1822 <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1a86:	1f bf       	out	0x3f, r17	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1a88:	80 91 7a 00 	lds	r24, 0x007A
    1a8c:	86 fd       	sbrc	r24, 6
    1a8e:	0a c0       	rjmp	.+20     	; 0x1aa4 <StartOverdub+0x64>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1a90:	80 91 79 00 	lds	r24, 0x0079
    1a94:	80 58       	subi	r24, 0x80	; 128
    1a96:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1a9a:	80 91 7a 00 	lds	r24, 0x007A
    1a9e:	80 64       	ori	r24, 0x40	; 64
    1aa0:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    1aa4:	df 91       	pop	r29
    1aa6:	cf 91       	pop	r28
    1aa8:	1f 91       	pop	r17
    1aaa:	08 95       	ret

00001aac <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
// Thu Nov 24 19:40:21 CST 2011
// OK to do realtime even when banks are locked since we don't use the RAM
{
    1aac:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    1aae:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    1ab0:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    1ab2:	9e e2       	ldi	r25, 0x2E	; 46
    1ab4:	89 9f       	mul	r24, r25
    1ab6:	f0 01       	movw	r30, r0
    1ab8:	11 24       	eor	r1, r1
    1aba:	ec 51       	subi	r30, 0x1C	; 28
    1abc:	fa 4f       	sbci	r31, 0xFA	; 250
    1abe:	92 e0       	ldi	r25, 0x02	; 2
    1ac0:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1ac2:	0e 94 11 0c 	call	0x1822	; 0x1822 <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    1ac6:	cf bf       	out	0x3f, r28	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1ac8:	80 91 7a 00 	lds	r24, 0x007A
    1acc:	86 fd       	sbrc	r24, 6
    1ace:	0a c0       	rjmp	.+20     	; 0x1ae4 <StartRealtime+0x38>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1ad0:	80 91 79 00 	lds	r24, 0x0079
    1ad4:	80 58       	subi	r24, 0x80	; 128
    1ad6:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1ada:	80 91 7a 00 	lds	r24, 0x007A
    1ade:	80 64       	ori	r24, 0x40	; 64
    1ae0:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    1ae8:	80 91 59 05 	lds	r24, 0x0559
    1aec:	81 11       	cpse	r24, r1
    1aee:	10 c0       	rjmp	.+32     	; 0x1b10 <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs
    1af0:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>

		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    1af4:	10 92 e4 05 	sts	0x05E4, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    1af8:	10 92 ee 05 	sts	0x05EE, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    1afc:	10 92 12 06 	sts	0x0612, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    1b00:	10 92 1c 06 	sts	0x061C, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    1b04:	81 e8       	ldi	r24, 0x81	; 129
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	0e 94 b2 0a 	call	0x1564	; 0x1564 <BlinkLeds>
		subState=SS_1;
    1b0c:	81 e0       	ldi	r24, 0x01	; 1
    1b0e:	13 c0       	rjmp	.+38     	; 0x1b36 <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    1b10:	81 30       	cpi	r24, 0x01	; 1
    1b12:	c9 f4       	brne	.+50     	; 0x1b46 <DoFormatCard+0x5e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    1b14:	80 91 56 05 	lds	r24, 0x0556
    1b18:	80 ff       	sbrs	r24, 0
    1b1a:	10 c0       	rjmp	.+32     	; 0x1b3c <DoFormatCard+0x54>
    1b1c:	87 ff       	sbrs	r24, 7
    1b1e:	0e c0       	rjmp	.+28     	; 0x1b3c <DoFormatCard+0x54>
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    1b20:	86 e0       	ldi	r24, 0x06	; 6
    1b22:	80 93 57 05 	sts	0x0557, r24
			KillLeds();
    1b26:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
    1b2a:	80 91 5b 05 	lds	r24, 0x055B
    1b2e:	81 68       	ori	r24, 0x81	; 129
    1b30:	80 93 5b 05 	sts	0x055B, r24
			subState=SS_2;
    1b34:	82 e0       	ldi	r24, 0x02	; 2
    1b36:	80 93 59 05 	sts	0x0559, r24
    1b3a:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    1b3c:	80 91 57 05 	lds	r24, 0x0557
    1b40:	81 11       	cpse	r24, r1
    1b42:	1e c0       	rjmp	.+60     	; 0x1b80 <DoFormatCard+0x98>
    1b44:	15 c0       	rjmp	.+42     	; 0x1b70 <DoFormatCard+0x88>
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    1b46:	82 30       	cpi	r24, 0x02	; 2
    1b48:	d9 f4       	brne	.+54     	; 0x1b80 <DoFormatCard+0x98>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    1b4a:	80 91 57 05 	lds	r24, 0x0557
    1b4e:	8e 30       	cpi	r24, 0x0E	; 14
    1b50:	b9 f4       	brne	.+46     	; 0x1b80 <DoFormatCard+0x98>
		{
			KillLeds();
    1b52:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    1b56:	80 91 5b 05 	lds	r24, 0x055B
    1b5a:	82 60       	ori	r24, 0x02	; 2
    1b5c:	80 93 5b 05 	sts	0x055B, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    1b60:	80 91 57 05 	lds	r24, 0x0557
    1b64:	88 23       	and	r24, r24
    1b66:	21 f0       	breq	.+8      	; 0x1b70 <DoFormatCard+0x88>
    1b68:	80 91 55 05 	lds	r24, 0x0555
    1b6c:	88 23       	and	r24, r24
    1b6e:	41 f0       	breq	.+16     	; 0x1b80 <DoFormatCard+0x98>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1b70:	86 ee       	ldi	r24, 0xE6	; 230
    1b72:	9a e0       	ldi	r25, 0x0A	; 10
    1b74:	90 93 e3 05 	sts	0x05E3, r25
    1b78:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    1b7c:	10 92 59 05 	sts	0x0559, r1
    1b80:	08 95       	ret

00001b82 <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    1b82:	80 91 59 05 	lds	r24, 0x0559
    1b86:	81 11       	cpse	r24, r1
    1b88:	08 c0       	rjmp	.+16     	; 0x1b9a <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    1b8a:	68 e9       	ldi	r22, 0x98	; 152
    1b8c:	70 e0       	ldi	r23, 0x00	; 0
    1b8e:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
		subState=SS_1;
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	80 93 59 05 	sts	0x0559, r24
    1b98:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    1b9a:	80 e0       	ldi	r24, 0x00	; 0
    1b9c:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    1ba0:	88 23       	and	r24, r24
    1ba2:	a1 f0       	breq	.+40     	; 0x1bcc <DoStartupSelect+0x4a>
		{
			if(keyState&Im_SWITCH_0)
    1ba4:	80 91 56 05 	lds	r24, 0x0556
    1ba8:	80 ff       	sbrs	r24, 0
    1baa:	03 c0       	rjmp	.+6      	; 0x1bb2 <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1bac:	87 e4       	ldi	r24, 0x47	; 71
    1bae:	90 e1       	ldi	r25, 0x10	; 16
    1bb0:	07 c0       	rjmp	.+14     	; 0x1bc0 <DoStartupSelect+0x3e>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    1bb2:	85 ff       	sbrs	r24, 5
    1bb4:	03 c0       	rjmp	.+6      	; 0x1bbc <DoStartupSelect+0x3a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1bb6:	8b e5       	ldi	r24, 0x5B	; 91
    1bb8:	91 e1       	ldi	r25, 0x11	; 17
    1bba:	02 c0       	rjmp	.+4      	; 0x1bc0 <DoStartupSelect+0x3e>
    1bbc:	8e eb       	ldi	r24, 0xBE	; 190
    1bbe:	90 e1       	ldi	r25, 0x10	; 16
    1bc0:	90 93 e3 05 	sts	0x05E3, r25
    1bc4:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    1bc8:	10 92 59 05 	sts	0x0559, r1
    1bcc:	08 95       	ret

00001bce <PlaySampleFromSd>:
	}
}

static void PlaySampleFromSd(unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    1bce:	cf 93       	push	r28
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    1bd0:	20 91 57 05 	lds	r18, 0x0557
    1bd4:	2e 30       	cpi	r18, 0x0E	; 14
    1bd6:	09 f4       	brne	.+2      	; 0x1bda <PlaySampleFromSd+0xc>
    1bd8:	06 c0       	rjmp	.+12     	; 0x1be6 <PlaySampleFromSd+0x18>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    1bda:	30 91 4d 05 	lds	r19, 0x054D
    1bde:	33 30       	cpi	r19, 0x03	; 3
    1be0:	b1 f5       	brne	.+108    	; 0x1c4e <PlaySampleFromSd+0x80>
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    1be2:	2b 30       	cpi	r18, 0x0B	; 11
    1be4:	a1 f4       	brne	.+40     	; 0x1c0e <PlaySampleFromSd+0x40>
		{
			sreg=SREG;	 // Pause ISRs
    1be6:	cf b7       	in	r28, 0x3f	; 63
			cli();
    1be8:	f8 94       	cli

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    1bea:	0e 94 c3 0b 	call	0x1786	; 0x1786 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	90 e0       	ldi	r25, 0x00	; 0
    1bf2:	a0 e0       	ldi	r26, 0x00	; 0
    1bf4:	b0 e0       	ldi	r27, 0x00	; 0
    1bf6:	80 93 22 01 	sts	0x0122, r24
    1bfa:	90 93 23 01 	sts	0x0123, r25
    1bfe:	a0 93 24 01 	sts	0x0124, r26
    1c02:	b0 93 25 01 	sts	0x0125, r27
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
    1c06:	0e 94 55 05 	call	0xaaa	; 0xaaa <SdIsrStartStreamingAudio>

			SREG=sreg;	// resume isr
    1c0a:	cf bf       	out	0x3f, r28	; 63
    1c0c:	20 c0       	rjmp	.+64     	; 0x1c4e <PlaySampleFromSd+0x80>
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    1c0e:	2d 30       	cpi	r18, 0x0D	; 13
    1c10:	21 f0       	breq	.+8      	; 0x1c1a <PlaySampleFromSd+0x4c>
    1c12:	20 91 b6 05 	lds	r18, 0x05B6
    1c16:	21 30       	cpi	r18, 0x01	; 1
    1c18:	29 f4       	brne	.+10     	; 0x1c24 <PlaySampleFromSd+0x56>
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    1c1a:	90 93 b8 05 	sts	0x05B8, r25
    1c1e:	80 93 b7 05 	sts	0x05B7, r24
    1c22:	15 c0       	rjmp	.+42     	; 0x1c4e <PlaySampleFromSd+0x80>
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    1c24:	90 93 b8 05 	sts	0x05B8, r25
    1c28:	80 93 b7 05 	sts	0x05B7, r24
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	80 93 b9 05 	sts	0x05B9, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    1c32:	80 93 b6 05 	sts	0x05B6, r24

			sreg=SREG;	 		// Pause ISRs
    1c36:	9f b7       	in	r25, 0x3f	; 63
			cli();
    1c38:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    1c3a:	10 92 27 01 	sts	0x0127, r1
    1c3e:	10 92 26 01 	sts	0x0126, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    1c42:	80 91 70 00 	lds	r24, 0x0070
    1c46:	8b 7f       	andi	r24, 0xFB	; 251
    1c48:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;
    1c4c:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    1c4e:	cf 91       	pop	r28
    1c50:	08 95       	ret

00001c52 <SdCardMenu>:
// NOTE:  Load and Save functions apply to the bank currently selected.

// Button		0			1			2			3			4			5			6			7
// -------------------------------------------------------------------------------------------------------------------
// No Shift:	Play		Load		Save		Delete		Exit		Exit		Exit		Exit
{
    1c52:	ef 92       	push	r14
    1c54:	ff 92       	push	r15
    1c56:	0f 93       	push	r16
    1c58:	1f 93       	push	r17
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
	if(subState==SS_0)		// Initialize LEDs and slots
    1c5e:	80 91 59 05 	lds	r24, 0x0559
    1c62:	81 11       	cpse	r24, r1
    1c64:	23 c0       	rjmp	.+70     	; 0x1cac <SdCardMenu+0x5a>
	{		
		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
    1c66:	80 91 61 05 	lds	r24, 0x0561
    1c6a:	90 91 62 05 	lds	r25, 0x0562
    1c6e:	80 38       	cpi	r24, 0x80	; 128
    1c70:	91 05       	cpc	r25, r1
    1c72:	30 f0       	brcs	.+12     	; 0x1c80 <SdCardMenu+0x2e>
		{
			sdCurrentSlot=127;
    1c74:	8f e7       	ldi	r24, 0x7F	; 127
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	90 93 62 05 	sts	0x0562, r25
    1c7c:	80 93 61 05 	sts	0x0561, r24
		}		

		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently looking at
    1c80:	80 91 61 05 	lds	r24, 0x0561
    1c84:	80 93 5b 05 	sts	0x055B, r24
		StopBlinking();					// Make sure nothing is errantly blinking
    1c88:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>

		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
    1c8c:	80 91 61 05 	lds	r24, 0x0561
    1c90:	90 91 62 05 	lds	r25, 0x0562
    1c94:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    1c98:	88 23       	and	r24, r24
    1c9a:	21 f0       	breq	.+8      	; 0x1ca4 <SdCardMenu+0x52>
		{
			BlinkLeds(1<<LED_7);
    1c9c:	80 e8       	ldi	r24, 0x80	; 128
    1c9e:	90 e0       	ldi	r25, 0x00	; 0
    1ca0:	0e 94 b2 0a 	call	0x1564	; 0x1564 <BlinkLeds>
		}	

		subState=SS_1;
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	80 93 59 05 	sts	0x0559, r24
    1caa:	ea c1       	rjmp	.+980    	; 0x2080 <SdCardMenu+0x42e>
	}
	else
	{
		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
    1cac:	90 91 58 05 	lds	r25, 0x0558
    1cb0:	80 91 57 05 	lds	r24, 0x0557
    1cb4:	99 23       	and	r25, r25
    1cb6:	19 f0       	breq	.+6      	; 0x1cbe <SdCardMenu+0x6c>
    1cb8:	8f 30       	cpi	r24, 0x0F	; 15
    1cba:	39 f4       	brne	.+14     	; 0x1cca <SdCardMenu+0x78>
    1cbc:	03 c0       	rjmp	.+6      	; 0x1cc4 <SdCardMenu+0x72>
		{
			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    1cbe:	88 23       	and	r24, r24
    1cc0:	09 f4       	brne	.+2      	; 0x1cc4 <SdCardMenu+0x72>
    1cc2:	d4 c1       	rjmp	.+936    	; 0x206c <SdCardMenu+0x41a>
			{
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
    1cc4:	0e 94 99 0b 	call	0x1732	; 0x1732 <ResetSdCard>
    1cc8:	d1 c1       	rjmp	.+930    	; 0x206c <SdCardMenu+0x41a>
			KillLeds();				// Exit menu
			SetState(DoSampler);
		}
		else
		{
			if(newEncoder)		// Increment or decrement card slot if encoder moves
    1cca:	80 91 6a 05 	lds	r24, 0x056A
    1cce:	88 23       	and	r24, r24
    1cd0:	e9 f1       	breq	.+122    	; 0x1d4c <SdCardMenu+0xfa>
			{
				if(encoderCw)
    1cd2:	80 91 ae 05 	lds	r24, 0x05AE
    1cd6:	88 23       	and	r24, r24
    1cd8:	89 f0       	breq	.+34     	; 0x1cfc <SdCardMenu+0xaa>
				{
					sdCurrentSlot++;
    1cda:	80 91 61 05 	lds	r24, 0x0561
    1cde:	90 91 62 05 	lds	r25, 0x0562
    1ce2:	01 96       	adiw	r24, 0x01	; 1
    1ce4:	90 93 62 05 	sts	0x0562, r25
    1ce8:	80 93 61 05 	sts	0x0561, r24
					if(sdCurrentSlot>127)
    1cec:	80 38       	cpi	r24, 0x80	; 128
    1cee:	91 05       	cpc	r25, r1
    1cf0:	b8 f0       	brcs	.+46     	; 0x1d20 <SdCardMenu+0xce>
					{
						sdCurrentSlot=0;
    1cf2:	10 92 62 05 	sts	0x0562, r1
    1cf6:	10 92 61 05 	sts	0x0561, r1
    1cfa:	12 c0       	rjmp	.+36     	; 0x1d20 <SdCardMenu+0xce>
					}
				}
				else if(encoderCcw)
    1cfc:	80 91 af 05 	lds	r24, 0x05AF
    1d00:	88 23       	and	r24, r24
    1d02:	71 f0       	breq	.+28     	; 0x1d20 <SdCardMenu+0xce>
				{
					if(sdCurrentSlot==0)
    1d04:	80 91 61 05 	lds	r24, 0x0561
    1d08:	90 91 62 05 	lds	r25, 0x0562
    1d0c:	00 97       	sbiw	r24, 0x00	; 0
    1d0e:	19 f4       	brne	.+6      	; 0x1d16 <SdCardMenu+0xc4>
					{
						sdCurrentSlot=127;
    1d10:	8f e7       	ldi	r24, 0x7F	; 127
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	01 c0       	rjmp	.+2      	; 0x1d18 <SdCardMenu+0xc6>
					}
					else
					{
						sdCurrentSlot--;
    1d16:	01 97       	sbiw	r24, 0x01	; 1
    1d18:	90 93 62 05 	sts	0x0562, r25
    1d1c:	80 93 61 05 	sts	0x0561, r24
					}
				}

				ledOnOffMask=sdCurrentSlot;		
    1d20:	80 91 61 05 	lds	r24, 0x0561
    1d24:	90 91 62 05 	lds	r25, 0x0562
    1d28:	80 93 5b 05 	sts	0x055B, r24
				if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
    1d2c:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    1d30:	88 23       	and	r24, r24
    1d32:	29 f0       	breq	.+10     	; 0x1d3e <SdCardMenu+0xec>
				{
					BlinkLeds(1<<LED_7);
    1d34:	80 e8       	ldi	r24, 0x80	; 128
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	0e 94 b2 0a 	call	0x1564	; 0x1564 <BlinkLeds>
    1d3c:	07 c0       	rjmp	.+14     	; 0x1d4c <SdCardMenu+0xfa>
				}	
				else
				{
					StopBlinking();
    1d3e:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>
					ledOnOffMask&=~(1<<LED_7);
    1d42:	80 91 5b 05 	lds	r24, 0x055B
    1d46:	8f 77       	andi	r24, 0x7F	; 127
    1d48:	80 93 5b 05 	sts	0x055B, r24
				}
			}

			if(newKeys&Im_SWITCH_0)		// Stream sample
    1d4c:	80 91 55 05 	lds	r24, 0x0555
    1d50:	80 ff       	sbrs	r24, 0
    1d52:	0c c0       	rjmp	.+24     	; 0x1d6c <SdCardMenu+0x11a>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    1d54:	c0 91 61 05 	lds	r28, 0x0561
    1d58:	d0 91 62 05 	lds	r29, 0x0562
    1d5c:	ce 01       	movw	r24, r28
    1d5e:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    1d62:	88 23       	and	r24, r24
    1d64:	19 f0       	breq	.+6      	; 0x1d6c <SdCardMenu+0x11a>
				{		
					PlaySampleFromSd(sdCurrentSlot);
    1d66:	ce 01       	movw	r24, r28
    1d68:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <PlaySampleFromSd>
				}
			}		
			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
    1d6c:	80 91 55 05 	lds	r24, 0x0555
    1d70:	81 ff       	sbrs	r24, 1
    1d72:	5d c0       	rjmp	.+186    	; 0x1e2e <SdCardMenu+0x1dc>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    1d74:	00 91 61 05 	lds	r16, 0x0561
    1d78:	10 91 62 05 	lds	r17, 0x0562
    1d7c:	c8 01       	movw	r24, r16
    1d7e:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    1d82:	88 23       	and	r24, r24
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <SdCardMenu+0x136>
    1d86:	53 c0       	rjmp	.+166    	; 0x1e2e <SdCardMenu+0x1dc>
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
    1d88:	f0 90 60 05 	lds	r15, 0x0560
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    1d8c:	80 91 57 05 	lds	r24, 0x0557
    1d90:	8e 30       	cpi	r24, 0x0E	; 14
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <SdCardMenu+0x144>
    1d94:	4c c0       	rjmp	.+152    	; 0x1e2e <SdCardMenu+0x1dc>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    1d96:	2e e2       	ldi	r18, 0x2E	; 46
    1d98:	f2 9e       	mul	r15, r18
    1d9a:	e0 01       	movw	r28, r0
    1d9c:	11 24       	eor	r1, r1
    1d9e:	cc 51       	subi	r28, 0x1C	; 28
    1da0:	da 4f       	sbci	r29, 0xFA	; 250
    1da2:	8d 81       	ldd	r24, Y+5	; 0x05
    1da4:	81 11       	cpse	r24, r1
    1da6:	43 c0       	rjmp	.+134    	; 0x1e2e <SdCardMenu+0x1dc>
		{
			sreg=SREG;
    1da8:	ef b6       	in	r14, 0x3f	; 63
			cli();		// Pause ISR
    1daa:	f8 94       	cli

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
    1dac:	c8 01       	movw	r24, r16
    1dae:	0e 94 c3 0b 	call	0x1786	; 0x1786 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	a0 e0       	ldi	r26, 0x00	; 0
    1db8:	b0 e0       	ldi	r27, 0x00	; 0
    1dba:	80 93 22 01 	sts	0x0122, r24
    1dbe:	90 93 23 01 	sts	0x0123, r25
    1dc2:	a0 93 24 01 	sts	0x0124, r26
    1dc6:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;

	sreg=SREG;
    1dca:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    1dcc:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    1dce:	81 e0       	ldi	r24, 0x01	; 1
    1dd0:	80 93 4d 05 	sts	0x054D, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    1dd4:	8d 83       	std	Y+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    1dd6:	f1 10       	cpse	r15, r1
    1dd8:	0b c0       	rjmp	.+22     	; 0x1df0 <SdCardMenu+0x19e>
	{
		sdBank0=true;
    1dda:	80 93 52 05 	sts	0x0552, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    1dde:	10 92 4e 05 	sts	0x054E, r1
    1de2:	10 92 4f 05 	sts	0x054F, r1
    1de6:	10 92 50 05 	sts	0x0550, r1
    1dea:	10 92 51 05 	sts	0x0551, r1
    1dee:	0e c0       	rjmp	.+28     	; 0x1e0c <SdCardMenu+0x1ba>
	}
	else
	{
		sdBank0=false;
    1df0:	10 92 52 05 	sts	0x0552, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    1df4:	8f ef       	ldi	r24, 0xFF	; 255
    1df6:	9f ef       	ldi	r25, 0xFF	; 255
    1df8:	a7 e0       	ldi	r26, 0x07	; 7
    1dfa:	b0 e0       	ldi	r27, 0x00	; 0
    1dfc:	80 93 4e 05 	sts	0x054E, r24
    1e00:	90 93 4f 05 	sts	0x054F, r25
    1e04:	a0 93 50 05 	sts	0x0550, r26
    1e08:	b0 93 51 05 	sts	0x0551, r27
	}

	TCNT2=0;			// Init counter reg
    1e0c:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    1e10:	81 e6       	ldi	r24, 0x61	; 97
    1e12:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    1e16:	8f ef       	ldi	r24, 0xFF	; 255
    1e18:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    1e1a:	80 91 70 00 	lds	r24, 0x0070
    1e1e:	84 60       	ori	r24, 0x04	; 4
    1e20:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    1e24:	82 e0       	ldi	r24, 0x02	; 2
    1e26:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    1e2a:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    1e2c:	ef be       	out	0x3f, r14	; 63
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
				}
			}		
			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
    1e2e:	80 91 55 05 	lds	r24, 0x0555
    1e32:	82 ff       	sbrs	r24, 2
    1e34:	e1 c0       	rjmp	.+450    	; 0x1ff8 <SdCardMenu+0x3a6>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something in the bank?
    1e36:	e0 91 60 05 	lds	r30, 0x0560
    1e3a:	2e 2f       	mov	r18, r30
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	4e e2       	ldi	r20, 0x2E	; 46
    1e40:	e4 9f       	mul	r30, r20
    1e42:	e0 01       	movw	r28, r0
    1e44:	11 24       	eor	r1, r1
    1e46:	cc 51       	subi	r28, 0x1C	; 28
    1e48:	da 4f       	sbci	r29, 0xFA	; 250
    1e4a:	49 89       	ldd	r20, Y+17	; 0x11
    1e4c:	5a 89       	ldd	r21, Y+18	; 0x12
    1e4e:	6b 89       	ldd	r22, Y+19	; 0x13
    1e50:	7c 89       	ldd	r23, Y+20	; 0x14
    1e52:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e54:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e56:	af 85       	ldd	r26, Y+15	; 0x0f
    1e58:	b8 89       	ldd	r27, Y+16	; 0x10
    1e5a:	48 17       	cp	r20, r24
    1e5c:	59 07       	cpc	r21, r25
    1e5e:	6a 07       	cpc	r22, r26
    1e60:	7b 07       	cpc	r23, r27
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <SdCardMenu+0x214>
    1e64:	c9 c0       	rjmp	.+402    	; 0x1ff8 <SdCardMenu+0x3a6>
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
    1e66:	10 91 61 05 	lds	r17, 0x0561
    1e6a:	00 91 62 05 	lds	r16, 0x0562
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    1e6e:	80 91 57 05 	lds	r24, 0x0557
    1e72:	8e 30       	cpi	r24, 0x0E	; 14
    1e74:	09 f0       	breq	.+2      	; 0x1e78 <SdCardMenu+0x226>
    1e76:	bc c0       	rjmp	.+376    	; 0x1ff0 <SdCardMenu+0x39e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    1e78:	8d 81       	ldd	r24, Y+5	; 0x05
    1e7a:	81 11       	cpse	r24, r1
    1e7c:	b9 c0       	rjmp	.+370    	; 0x1ff0 <SdCardMenu+0x39e>
	unsigned long
		theLength;

	if(theBank==BANK_0)
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    1e7e:	8f 81       	ldd	r24, Y+7	; 0x07
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    1e80:	e1 11       	cpse	r30, r1
    1e82:	10 c0       	rjmp	.+32     	; 0x1ea4 <SdCardMenu+0x252>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    1e84:	81 11       	cpse	r24, r1
    1e86:	09 c0       	rjmp	.+18     	; 0x1e9a <SdCardMenu+0x248>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    1e88:	8d 89       	ldd	r24, Y+21	; 0x15
    1e8a:	9e 89       	ldd	r25, Y+22	; 0x16
    1e8c:	af 89       	ldd	r26, Y+23	; 0x17
    1e8e:	b8 8d       	ldd	r27, Y+24	; 0x18
    1e90:	49 8d       	ldd	r20, Y+25	; 0x19
    1e92:	5a 8d       	ldd	r21, Y+26	; 0x1a
    1e94:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1e96:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1e98:	0f c0       	rjmp	.+30     	; 0x1eb8 <SdCardMenu+0x266>
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    1e9a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e9c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e9e:	af 85       	ldd	r26, Y+15	; 0x0f
    1ea0:	b8 89       	ldd	r27, Y+16	; 0x10
    1ea2:	1a c0       	rjmp	.+52     	; 0x1ed8 <SdCardMenu+0x286>
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    1ea4:	81 11       	cpse	r24, r1
    1ea6:	0c c0       	rjmp	.+24     	; 0x1ec0 <SdCardMenu+0x26e>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    1ea8:	89 8d       	ldd	r24, Y+25	; 0x19
    1eaa:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1eac:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1eae:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1eb0:	4d 89       	ldd	r20, Y+21	; 0x15
    1eb2:	5e 89       	ldd	r21, Y+22	; 0x16
    1eb4:	6f 89       	ldd	r22, Y+23	; 0x17
    1eb6:	78 8d       	ldd	r23, Y+24	; 0x18
    1eb8:	01 96       	adiw	r24, 0x01	; 1
    1eba:	a1 1d       	adc	r26, r1
    1ebc:	b1 1d       	adc	r27, r1
    1ebe:	08 c0       	rjmp	.+16     	; 0x1ed0 <SdCardMenu+0x27e>
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    1ec0:	89 89       	ldd	r24, Y+17	; 0x11
    1ec2:	9a 89       	ldd	r25, Y+18	; 0x12
    1ec4:	ab 89       	ldd	r26, Y+19	; 0x13
    1ec6:	bc 89       	ldd	r27, Y+20	; 0x14
    1ec8:	4d 85       	ldd	r20, Y+13	; 0x0d
    1eca:	5e 85       	ldd	r21, Y+14	; 0x0e
    1ecc:	6f 85       	ldd	r22, Y+15	; 0x0f
    1ece:	78 89       	ldd	r23, Y+16	; 0x10
    1ed0:	84 1b       	sub	r24, r20
    1ed2:	95 0b       	sbc	r25, r21
    1ed4:	a6 0b       	sbc	r26, r22
    1ed6:	b7 0b       	sbc	r27, r23
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    1ed8:	ff b7       	in	r31, 0x3f	; 63
			cli();		// Pause ISR
    1eda:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    1edc:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    1ede:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    1ee0:	10 93 61 05 	sts	0x0561, r17
    1ee4:	00 93 62 05 	sts	0x0562, r16
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    1ee8:	71 2f       	mov	r23, r17
    1eea:	77 0f       	add	r23, r23
    1eec:	77 0f       	add	r23, r23
    1eee:	60 e0       	ldi	r22, 0x00	; 0
    1ef0:	ab 01       	movw	r20, r22
    1ef2:	4f 5f       	subi	r20, 0xFF	; 255
    1ef4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ef6:	60 e0       	ldi	r22, 0x00	; 0
    1ef8:	70 e0       	ldi	r23, 0x00	; 0
    1efa:	40 93 b0 05 	sts	0x05B0, r20
    1efe:	50 93 b1 05 	sts	0x05B1, r21
    1f02:	60 93 b2 05 	sts	0x05B2, r22
    1f06:	70 93 b3 05 	sts	0x05B3, r23
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    1f0a:	10 92 b5 05 	sts	0x05B5, r1
    1f0e:	10 92 b4 05 	sts	0x05B4, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    1f12:	10 92 2b 01 	sts	0x012B, r1
    1f16:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    1f1a:	10 92 29 01 	sts	0x0129, r1
    1f1e:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    1f22:	10 92 27 01 	sts	0x0127, r1
    1f26:	10 92 26 01 	sts	0x0126, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    1f2a:	8d 3f       	cpi	r24, 0xFD	; 253
    1f2c:	4f ef       	ldi	r20, 0xFF	; 255
    1f2e:	94 07       	cpc	r25, r20
    1f30:	47 e0       	ldi	r20, 0x07	; 7
    1f32:	a4 07       	cpc	r26, r20
    1f34:	b1 05       	cpc	r27, r1
    1f36:	08 f4       	brcc	.+2      	; 0x1f3a <SdCardMenu+0x2e8>
    1f38:	04 c0       	rjmp	.+8      	; 0x1f42 <SdCardMenu+0x2f0>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    1f3a:	8c ef       	ldi	r24, 0xFC	; 252
    1f3c:	9f ef       	ldi	r25, 0xFF	; 255
    1f3e:	a7 e0       	ldi	r26, 0x07	; 7
    1f40:	b0 e0       	ldi	r27, 0x00	; 0
    1f42:	80 93 22 01 	sts	0x0122, r24
    1f46:	90 93 23 01 	sts	0x0123, r25
    1f4a:	a0 93 24 01 	sts	0x0124, r26
    1f4e:	b0 93 25 01 	sts	0x0125, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    1f52:	80 91 22 01 	lds	r24, 0x0122
    1f56:	90 91 23 01 	lds	r25, 0x0123
    1f5a:	a0 91 24 01 	lds	r26, 0x0124
    1f5e:	b0 91 25 01 	lds	r27, 0x0125
    1f62:	80 93 1e 01 	sts	0x011E, r24
    1f66:	90 93 1f 01 	sts	0x011F, r25
    1f6a:	a0 93 20 01 	sts	0x0120, r26
    1f6e:	b0 93 21 01 	sts	0x0121, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start
    1f72:	82 e0       	ldi	r24, 0x02	; 2
    1f74:	80 93 57 05 	sts	0x0557, r24
	SREG=sreg;	// Resume ISR
    1f78:	cf bf       	out	0x3f, r28	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;

	sreg=SREG;
    1f7a:	4f b7       	in	r20, 0x3f	; 63
	cli();		// Pause ISRs
    1f7c:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    1f7e:	80 93 4d 05 	sts	0x054D, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    1f82:	8e e2       	ldi	r24, 0x2E	; 46
    1f84:	82 9f       	mul	r24, r18
    1f86:	d0 01       	movw	r26, r0
    1f88:	83 9f       	mul	r24, r19
    1f8a:	b0 0d       	add	r27, r0
    1f8c:	11 24       	eor	r1, r1
    1f8e:	ac 51       	subi	r26, 0x1C	; 28
    1f90:	ba 4f       	sbci	r27, 0xFA	; 250
    1f92:	81 e0       	ldi	r24, 0x01	; 1
    1f94:	15 96       	adiw	r26, 0x05	; 5
    1f96:	8c 93       	st	X, r24

	if(theBank==BANK_0)		// Pointing at this bank?
    1f98:	e1 11       	cpse	r30, r1
    1f9a:	0b c0       	rjmp	.+22     	; 0x1fb2 <SdCardMenu+0x360>
	{
		sdBank0=true;
    1f9c:	80 93 52 05 	sts	0x0552, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    1fa0:	10 92 4e 05 	sts	0x054E, r1
    1fa4:	10 92 4f 05 	sts	0x054F, r1
    1fa8:	10 92 50 05 	sts	0x0550, r1
    1fac:	10 92 51 05 	sts	0x0551, r1
    1fb0:	0e c0       	rjmp	.+28     	; 0x1fce <SdCardMenu+0x37c>
	}
	else
	{
		sdBank0=false;
    1fb2:	10 92 52 05 	sts	0x0552, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    1fb6:	8f ef       	ldi	r24, 0xFF	; 255
    1fb8:	9f ef       	ldi	r25, 0xFF	; 255
    1fba:	a7 e0       	ldi	r26, 0x07	; 7
    1fbc:	b0 e0       	ldi	r27, 0x00	; 0
    1fbe:	80 93 4e 05 	sts	0x054E, r24
    1fc2:	90 93 4f 05 	sts	0x054F, r25
    1fc6:	a0 93 50 05 	sts	0x0550, r26
    1fca:	b0 93 51 05 	sts	0x0551, r27
	}

	TCNT2=0;			// Init counter reg
    1fce:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    1fd2:	81 e6       	ldi	r24, 0x61	; 97
    1fd4:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    1fd8:	8f ef       	ldi	r24, 0xFF	; 255
    1fda:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    1fdc:	80 91 70 00 	lds	r24, 0x0070
    1fe0:	84 60       	ori	r24, 0x04	; 4
    1fe2:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    1fe6:	82 e0       	ldi	r24, 0x02	; 2
    1fe8:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    1fec:	4f bf       	out	0x3f, r20	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    1fee:	ff bf       	out	0x3f, r31	; 63
			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something in the bank?
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
    1ff0:	80 e8       	ldi	r24, 0x80	; 128
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	0e 94 b2 0a 	call	0x1564	; 0x1564 <BlinkLeds>
				}
			}		
			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like "freeing" a sample.
    1ff8:	80 91 55 05 	lds	r24, 0x0555
    1ffc:	83 ff       	sbrs	r24, 3
    1ffe:	2d c0       	rjmp	.+90     	; 0x205a <SdCardMenu+0x408>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    2000:	c0 91 61 05 	lds	r28, 0x0561
    2004:	d0 91 62 05 	lds	r29, 0x0562
    2008:	ce 01       	movw	r24, r28
    200a:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    200e:	88 23       	and	r24, r24
    2010:	21 f1       	breq	.+72     	; 0x205a <SdCardMenu+0x408>
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
    2012:	80 91 57 05 	lds	r24, 0x0557
    2016:	8e 30       	cpi	r24, 0x0E	; 14
    2018:	01 f5       	brne	.+64     	; 0x205a <SdCardMenu+0x408>
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    201a:	fe 01       	movw	r30, r28
    201c:	13 e0       	ldi	r17, 0x03	; 3
    201e:	f6 95       	lsr	r31
    2020:	e7 95       	ror	r30
    2022:	1a 95       	dec	r17
    2024:	e1 f7       	brne	.-8      	; 0x201e <SdCardMenu+0x3cc>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    2026:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]&=~(1<<theBit);	// Clear it
    2028:	e3 59       	subi	r30, 0x93	; 147
    202a:	fa 4f       	sbci	r31, 0xFA	; 250
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    202c:	c7 70       	andi	r28, 0x07	; 7
    202e:	dd 27       	eor	r29, r29

	sampleToc[theByte]&=~(1<<theBit);	// Clear it
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	0c 2e       	mov	r0, r28
    2036:	01 c0       	rjmp	.+2      	; 0x203a <SdCardMenu+0x3e8>
    2038:	88 0f       	add	r24, r24
    203a:	0a 94       	dec	r0
    203c:	ea f7       	brpl	.-6      	; 0x2038 <SdCardMenu+0x3e6>
    203e:	80 95       	com	r24
    2040:	90 81       	ld	r25, Z
    2042:	89 23       	and	r24, r25
    2044:	80 83       	st	Z, r24
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
					{
						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
    2046:	86 e0       	ldi	r24, 0x06	; 6
    2048:	80 93 57 05 	sts	0x0557, r24
						StopBlinking();					// Update LED to reflect that this is now full
    204c:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>
						ledOnOffMask&=~(1<<LED_7);
    2050:	80 91 5b 05 	lds	r24, 0x055B
    2054:	8f 77       	andi	r24, 0x7F	; 127
    2056:	80 93 5b 05 	sts	0x055B, r24
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    205a:	80 91 55 05 	lds	r24, 0x0555
    205e:	84 fd       	sbrc	r24, 4
    2060:	05 c0       	rjmp	.+10     	; 0x206c <SdCardMenu+0x41a>
//--------------------------------------

static unsigned char
	currentBank;					// Keeps track of the bank we're thinking about.

static void SdCardMenu(void)
    2062:	98 2f       	mov	r25, r24
    2064:	90 76       	andi	r25, 0x60	; 96
						ledOnOffMask&=~(1<<LED_7);
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    2066:	11 f4       	brne	.+4      	; 0x206c <SdCardMenu+0x41a>
    2068:	87 ff       	sbrs	r24, 7
    206a:	0a c0       	rjmp	.+20     	; 0x2080 <SdCardMenu+0x42e>
			{
				KillLeds();
    206c:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2070:	81 ec       	ldi	r24, 0xC1	; 193
    2072:	91 e1       	ldi	r25, 0x11	; 17
    2074:	90 93 e3 05 	sts	0x05E3, r25
    2078:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    207c:	10 92 59 05 	sts	0x0559, r1
				KillLeds();
				SetState(DoSampler);
			}
		}
	}
}
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	1f 91       	pop	r17
    2086:	0f 91       	pop	r16
    2088:	ff 90       	pop	r15
    208a:	ef 90       	pop	r14
    208c:	08 95       	ret

0000208e <DoSawtooth>:

static void DoSawtooth(void)
// See if we can get some audio out.  And look good doing it.
// Also test to see if our flash is present and working.
{
	if(subState==SS_0)
    208e:	80 91 59 05 	lds	r24, 0x0559
    2092:	81 11       	cpse	r24, r1
    2094:	08 c0       	rjmp	.+16     	; 0x20a6 <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    2096:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    209a:	80 ec       	ldi	r24, 0xC0	; 192
    209c:	90 e0       	ldi	r25, 0x00	; 0
    209e:	0e 94 b2 0a 	call	0x1564	; 0x1564 <BlinkLeds>
		subState=SS_1;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	13 c0       	rjmp	.+38     	; 0x20cc <DoSawtooth+0x3e>
	}
	else if(subState==SS_1)
    20a6:	81 30       	cpi	r24, 0x01	; 1
    20a8:	a1 f4       	brne	.+40     	; 0x20d2 <DoSawtooth+0x44>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    20aa:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    20ac:	80 93 e4 05 	sts	0x05E4, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    20b0:	80 93 ee 05 	sts	0x05EE, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    20b4:	80 93 ee 05 	sts	0x05EE, r24
    20b8:	0e 94 05 0c 	call	0x180a	; 0x180a <SetSampleClock.part.1>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    20bc:	87 e8       	ldi	r24, 0x87	; 135
    20be:	94 e0       	ldi	r25, 0x04	; 4
    20c0:	90 93 e1 05 	sts	0x05E1, r25
    20c4:	80 93 e0 05 	sts	0x05E0, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    20c8:	78 94       	sei

		subState=SS_2;					// And wait forever.
    20ca:	82 e0       	ldi	r24, 0x02	; 2
    20cc:	80 93 59 05 	sts	0x0559, r24
    20d0:	08 95       	ret
	}
	else if(subState==SS_2)
    20d2:	82 30       	cpi	r24, 0x02	; 2
    20d4:	09 f0       	breq	.+2      	; 0x20d8 <DoSawtooth+0x4a>
    20d6:	51 c0       	rjmp	.+162    	; 0x217a <DoSawtooth+0xec>
	{

		if(newKeys&Im_SWITCH_0)
    20d8:	80 91 55 05 	lds	r24, 0x0555
    20dc:	80 ff       	sbrs	r24, 0
    20de:	06 c0       	rjmp	.+12     	; 0x20ec <DoSawtooth+0x5e>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    20e0:	90 91 5b 05 	lds	r25, 0x055B
    20e4:	21 e0       	ldi	r18, 0x01	; 1
    20e6:	92 27       	eor	r25, r18
    20e8:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_1)
    20ec:	81 ff       	sbrs	r24, 1
    20ee:	06 c0       	rjmp	.+12     	; 0x20fc <DoSawtooth+0x6e>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    20f0:	90 91 5b 05 	lds	r25, 0x055B
    20f4:	22 e0       	ldi	r18, 0x02	; 2
    20f6:	92 27       	eor	r25, r18
    20f8:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_2)
    20fc:	82 ff       	sbrs	r24, 2
    20fe:	06 c0       	rjmp	.+12     	; 0x210c <DoSawtooth+0x7e>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    2100:	90 91 5b 05 	lds	r25, 0x055B
    2104:	24 e0       	ldi	r18, 0x04	; 4
    2106:	92 27       	eor	r25, r18
    2108:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_3)
    210c:	83 ff       	sbrs	r24, 3
    210e:	06 c0       	rjmp	.+12     	; 0x211c <DoSawtooth+0x8e>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    2110:	90 91 5b 05 	lds	r25, 0x055B
    2114:	28 e0       	ldi	r18, 0x08	; 8
    2116:	92 27       	eor	r25, r18
    2118:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_4)
    211c:	84 ff       	sbrs	r24, 4
    211e:	06 c0       	rjmp	.+12     	; 0x212c <DoSawtooth+0x9e>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    2120:	90 91 5b 05 	lds	r25, 0x055B
    2124:	20 e1       	ldi	r18, 0x10	; 16
    2126:	92 27       	eor	r25, r18
    2128:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_5)
    212c:	85 ff       	sbrs	r24, 5
    212e:	06 c0       	rjmp	.+12     	; 0x213c <DoSawtooth+0xae>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    2130:	90 91 5b 05 	lds	r25, 0x055B
    2134:	20 e2       	ldi	r18, 0x20	; 32
    2136:	92 27       	eor	r25, r18
    2138:	90 93 5b 05 	sts	0x055B, r25
		}

		if(newKeys&Im_SWITCH_6)
    213c:	86 ff       	sbrs	r24, 6
    213e:	08 c0       	rjmp	.+16     	; 0x2150 <DoSawtooth+0xc2>
		{
			StopBlinking();
    2140:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    2144:	80 91 5b 05 	lds	r24, 0x055B
    2148:	90 e4       	ldi	r25, 0x40	; 64
    214a:	89 27       	eor	r24, r25
    214c:	80 93 5b 05 	sts	0x055B, r24
		}
		if(newKeys&Im_SWITCH_7)
    2150:	80 91 55 05 	lds	r24, 0x0555
    2154:	87 ff       	sbrs	r24, 7
    2156:	07 c0       	rjmp	.+14     	; 0x2166 <DoSawtooth+0xd8>
		{
			StopBlinking();
    2158:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    215c:	80 91 5b 05 	lds	r24, 0x055B
    2160:	80 58       	subi	r24, 0x80	; 128
    2162:	80 93 5b 05 	sts	0x055B, r24
		}
		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
    2166:	80 91 6a 05 	lds	r24, 0x056A
    216a:	88 23       	and	r24, r24
    216c:	31 f0       	breq	.+12     	; 0x217a <DoSawtooth+0xec>
		{
			StopBlinking();
    216e:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <StopBlinking>
			ledOnOffMask=encoderValue;
    2172:	80 91 6c 05 	lds	r24, 0x056C
    2176:	80 93 5b 05 	sts	0x055B, r24
    217a:	08 95       	ret

0000217c <InitSampler>:
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}

static void InitSampler(void)
// Gets all variables and data structures read and set when the sampler starts up.
{
    217c:	cf 92       	push	r12
    217e:	df 92       	push	r13
    2180:	ef 92       	push	r14
    2182:	ff 92       	push	r15
    2184:	0f 93       	push	r16
    2186:	1f 93       	push	r17
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    218c:	84 e0       	ldi	r24, 0x04	; 4
    218e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    2192:	80 31       	cpi	r24, 0x10	; 16
    2194:	08 f0       	brcs	.+2      	; 0x2198 <InitSampler+0x1c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2196:	80 e0       	ldi	r24, 0x00	; 0
// Gets all variables and data structures read and set when the sampler starts up.
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    2198:	80 93 42 06 	sts	0x0642, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    219c:	88 e0       	ldi	r24, 0x08	; 8
    219e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <EepromRead>
	}

	if(x<16)					// Legit number?
    21a2:	80 31       	cpi	r24, 0x10	; 16
    21a4:	08 f0       	brcs	.+2      	; 0x21a8 <InitSampler+0x2c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    21a6:	81 e0       	ldi	r24, 0x01	; 1
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    21a8:	80 93 5b 06 	sts	0x065B, r24
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    21ac:	10 92 f5 05 	sts	0x05F5, r1
    21b0:	10 92 f6 05 	sts	0x05F6, r1
    21b4:	10 92 f7 05 	sts	0x05F7, r1
    21b8:	10 92 f8 05 	sts	0x05F8, r1
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    21bc:	8f ef       	ldi	r24, 0xFF	; 255
    21be:	9f ef       	ldi	r25, 0xFF	; 255
    21c0:	a7 e0       	ldi	r26, 0x07	; 7
    21c2:	b0 e0       	ldi	r27, 0x00	; 0
    21c4:	80 93 23 06 	sts	0x0623, r24
    21c8:	90 93 24 06 	sts	0x0624, r25
    21cc:	a0 93 25 06 	sts	0x0625, r26
    21d0:	b0 93 26 06 	sts	0x0626, r27
    21d4:	0c e5       	ldi	r16, 0x5C	; 92
    21d6:	15 e0       	ldi	r17, 0x05	; 5
    21d8:	c0 e0       	ldi	r28, 0x00	; 0
    21da:	d0 e0       	ldi	r29, 0x00	; 0

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    21dc:	2e e2       	ldi	r18, 0x2E	; 46
    21de:	e2 2e       	mov	r14, r18
		bankStates[i].loopOnce=false;
		bankStates[i].bitReduction=0;				// No crusties yet.
		bankStates[i].jitterValue=0;				// No hissies yet.
		bankStates[i].granularSlices=0;				// No remix yet.
		bankStates[i].halfSpeed=false;
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    21e0:	dd 24       	eor	r13, r13
    21e2:	d3 94       	inc	r13
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    21e4:	3c e0       	ldi	r19, 0x0C	; 12
    21e6:	f3 2e       	mov	r15, r19
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    21e8:	ec 9e       	mul	r14, r28
    21ea:	f0 01       	movw	r30, r0
    21ec:	ed 9e       	mul	r14, r29
    21ee:	f0 0d       	add	r31, r0
    21f0:	11 24       	eor	r1, r1
    21f2:	ec 51       	subi	r30, 0x1C	; 28
    21f4:	fa 4f       	sbci	r31, 0xFA	; 250
    21f6:	10 82       	st	Z, r1
		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    21f8:	12 86       	std	Z+10, r1	; 0x0a
		bankStates[i].loopOnce=false;
    21fa:	11 82       	std	Z+1, r1	; 0x01
		bankStates[i].bitReduction=0;				// No crusties yet.
    21fc:	11 86       	std	Z+9, r1	; 0x09
		bankStates[i].jitterValue=0;				// No hissies yet.
    21fe:	10 86       	std	Z+8, r1	; 0x08
		bankStates[i].granularSlices=0;				// No remix yet.
    2200:	17 82       	std	Z+7, r1	; 0x07
		bankStates[i].halfSpeed=false;
    2202:	12 82       	std	Z+2, r1	; 0x02
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2204:	d4 82       	std	Z+4, r13	; 0x04
		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    2206:	13 82       	std	Z+3, r1	; 0x03
		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2208:	81 89       	ldd	r24, Z+17	; 0x11
    220a:	92 89       	ldd	r25, Z+18	; 0x12
    220c:	a3 89       	ldd	r26, Z+19	; 0x13
    220e:	b4 89       	ldd	r27, Z+20	; 0x14
    2210:	80 a3       	std	Z+32, r24	; 0x20
    2212:	91 a3       	std	Z+33, r25	; 0x21
    2214:	a2 a3       	std	Z+34, r26	; 0x22
    2216:	b3 a3       	std	Z+35, r27	; 0x23
		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2218:	81 89       	ldd	r24, Z+17	; 0x11
    221a:	92 89       	ldd	r25, Z+18	; 0x12
    221c:	a3 89       	ldd	r26, Z+19	; 0x13
    221e:	b4 89       	ldd	r27, Z+20	; 0x14
    2220:	85 87       	std	Z+13, r24	; 0x0d
    2222:	96 87       	std	Z+14, r25	; 0x0e
    2224:	a7 87       	std	Z+15, r26	; 0x0f
    2226:	b0 8b       	std	Z+16, r27	; 0x10
		bankStates[i].realtimeOn=false;						// We'll default to playback.
    2228:	16 82       	std	Z+6, r1	; 0x06
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    222a:	15 82       	std	Z+5, r1	; 0x05

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
    222c:	8c 2f       	mov	r24, r28
    222e:	0e 94 95 0a 	call	0x152a	; 0x152a <RevertSampleToUnadjusted>
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    2232:	c1 11       	cpse	r28, r1
    2234:	02 c0       	rjmp	.+4      	; 0x223a <InitSampler+0xbe>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    2236:	87 e0       	ldi	r24, 0x07	; 7
    2238:	01 c0       	rjmp	.+2      	; 0x223c <InitSampler+0xc0>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    223a:	8b e0       	ldi	r24, 0x0B	; 11
    223c:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <EepromRead>
	}

	if(x<90)					// Legit number?
    2240:	8a 35       	cpi	r24, 0x5A	; 90
    2242:	08 f0       	brcs	.+2      	; 0x2246 <InitSampler+0xca>
		return(x);
	}
	else
	{
		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or whatever).
		return(x);
    2244:	80 e3       	ldi	r24, 0x30	; 48
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2246:	6f 2d       	mov	r22, r15
    2248:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    224c:	e9 2f       	mov	r30, r25
    224e:	f0 e0       	ldi	r31, 0x00	; 0
    2250:	ee 0f       	add	r30, r30
    2252:	ff 1f       	adc	r31, r31
    2254:	ea 5f       	subi	r30, 0xFA	; 250
    2256:	fe 4f       	sbci	r31, 0xFE	; 254
    2258:	20 81       	ld	r18, Z
    225a:	31 81       	ldd	r19, Z+1	; 0x01
    225c:	02 c0       	rjmp	.+4      	; 0x2262 <InitSampler+0xe6>
    225e:	36 95       	lsr	r19
    2260:	27 95       	ror	r18
    2262:	8a 95       	dec	r24
    2264:	e2 f7       	brpl	.-8      	; 0x225e <InitSampler+0xe2>
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    2266:	f8 01       	movw	r30, r16
    2268:	21 93       	st	Z+, r18
    226a:	31 93       	st	Z+, r19
    226c:	8f 01       	movw	r16, r30
    226e:	21 96       	adiw	r28, 0x01	; 1
	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    2270:	c2 30       	cpi	r28, 0x02	; 2
    2272:	d1 05       	cpc	r29, r1
    2274:	09 f0       	breq	.+2      	; 0x2278 <InitSampler+0xfc>
    2276:	b8 cf       	rjmp	.-144    	; 0x21e8 <InitSampler+0x6c>

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
	}

	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2278:	87 e8       	ldi	r24, 0x87	; 135
    227a:	94 e0       	ldi	r25, 0x04	; 4
    227c:	90 93 e1 05 	sts	0x05E1, r25
    2280:	80 93 e0 05 	sts	0x05E0, r24

	currentBank=BANK_0;			// Point at the first bank until we change banks.
    2284:	10 92 60 05 	sts	0x0560, r1
	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
    2288:	10 92 62 05 	sts	0x0562, r1
    228c:	10 92 61 05 	sts	0x0561, r1

	KillLeds();					// All leds off, and no blinking.
    2290:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2294:	81 ec       	ldi	r24, 0xC1	; 193
    2296:	91 e1       	ldi	r25, 0x11	; 17
    2298:	90 93 e3 05 	sts	0x05E3, r25
    229c:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    22a0:	10 92 59 05 	sts	0x0559, r1
	currentBank=BANK_0;			// Point at the first bank until we change banks.
	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.

	KillLeds();					// All leds off, and no blinking.
	SetState(DoSampler);		// Get to sampling
}
    22a4:	df 91       	pop	r29
    22a6:	cf 91       	pop	r28
    22a8:	1f 91       	pop	r17
    22aa:	0f 91       	pop	r16
    22ac:	ff 90       	pop	r15
    22ae:	ef 90       	pop	r14
    22b0:	df 90       	pop	r13
    22b2:	cf 90       	pop	r12
    22b4:	08 95       	ret

000022b6 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
    22b6:	80 91 59 05 	lds	r24, 0x0559
    22ba:	81 11       	cpse	r24, r1
    22bc:	1d c0       	rjmp	.+58     	; 0x22f8 <SetMidiChannels+0x42>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    22be:	84 e0       	ldi	r24, 0x04	; 4
    22c0:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    22c4:	80 31       	cpi	r24, 0x10	; 16
    22c6:	08 f0       	brcs	.+2      	; 0x22ca <SetMidiChannels+0x14>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    22c8:	80 e0       	ldi	r24, 0x00	; 0
static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    22ca:	80 93 42 06 	sts	0x0642, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    22ce:	88 e0       	ldi	r24, 0x08	; 8
    22d0:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <EepromRead>
	}

	if(x<16)					// Legit number?
    22d4:	80 31       	cpi	r24, 0x10	; 16
    22d6:	08 f0       	brcs	.+2      	; 0x22da <SetMidiChannels+0x24>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    22d8:	81 e0       	ldi	r24, 0x01	; 1
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
		midiChannelNumberB=GetMidiChannel(BANK_1);
    22da:	80 93 5b 06 	sts	0x065B, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    22de:	20 e1       	ldi	r18, 0x10	; 16
    22e0:	82 9f       	mul	r24, r18
    22e2:	c0 01       	movw	r24, r0
    22e4:	11 24       	eor	r1, r1
    22e6:	90 91 42 06 	lds	r25, 0x0642
    22ea:	98 2b       	or	r25, r24
    22ec:	90 93 5b 05 	sts	0x055B, r25
		subState=SS_1;
    22f0:	81 e0       	ldi	r24, 0x01	; 1
    22f2:	80 93 59 05 	sts	0x0559, r24
    22f6:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    22f8:	20 91 55 05 	lds	r18, 0x0555
    22fc:	20 ff       	sbrs	r18, 0
    22fe:	12 c0       	rjmp	.+36     	; 0x2324 <SetMidiChannels+0x6e>
		{
			midiChannelNumberA++;
    2300:	80 91 42 06 	lds	r24, 0x0642
    2304:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    2306:	80 31       	cpi	r24, 0x10	; 16
    2308:	18 f4       	brcc	.+6      	; 0x2310 <SetMidiChannels+0x5a>
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
    230a:	80 93 42 06 	sts	0x0642, r24
    230e:	02 c0       	rjmp	.+4      	; 0x2314 <SetMidiChannels+0x5e>
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
    2310:	10 92 42 06 	sts	0x0642, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    2314:	80 91 5b 05 	lds	r24, 0x055B
    2318:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    231a:	90 91 42 06 	lds	r25, 0x0642
    231e:	89 2b       	or	r24, r25
    2320:	80 93 5b 05 	sts	0x055B, r24
		}
		if(newKeys&Im_SWITCH_1)
    2324:	21 ff       	sbrs	r18, 1
    2326:	16 c0       	rjmp	.+44     	; 0x2354 <SetMidiChannels+0x9e>
		{
			midiChannelNumberB++;
    2328:	80 91 5b 06 	lds	r24, 0x065B
    232c:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    232e:	80 31       	cpi	r24, 0x10	; 16
    2330:	18 f4       	brcc	.+6      	; 0x2338 <SetMidiChannels+0x82>
			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
		}
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
    2332:	80 93 5b 06 	sts	0x065B, r24
    2336:	02 c0       	rjmp	.+4      	; 0x233c <SetMidiChannels+0x86>
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
    2338:	10 92 5b 06 	sts	0x065B, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    233c:	80 91 5b 06 	lds	r24, 0x065B
    2340:	30 e1       	ldi	r19, 0x10	; 16
    2342:	83 9f       	mul	r24, r19
    2344:	c0 01       	movw	r24, r0
    2346:	11 24       	eor	r1, r1
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    2348:	90 91 5b 05 	lds	r25, 0x055B
    234c:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    234e:	98 2b       	or	r25, r24
    2350:	90 93 5b 05 	sts	0x055B, r25
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    2354:	22 ff       	sbrs	r18, 2
    2356:	14 c0       	rjmp	.+40     	; 0x2380 <SetMidiChannels+0xca>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    2358:	60 91 42 06 	lds	r22, 0x0642
    235c:	84 e0       	ldi	r24, 0x04	; 4
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    2364:	60 91 5b 06 	lds	r22, 0x065B
    2368:	88 e0       	ldi	r24, 0x08	; 8
    236a:	90 e0       	ldi	r25, 0x00	; 0
    236c:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2370:	8e eb       	ldi	r24, 0xBE	; 190
    2372:	90 e1       	ldi	r25, 0x10	; 16
    2374:	90 93 e3 05 	sts	0x05E3, r25
    2378:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    237c:	10 92 59 05 	sts	0x0559, r1
    2380:	08 95       	ret

00002382 <DoSampler>:
// Sampler main loop.  This handles getting switch inputs and MIDI and calling all the functions necessary to turn this stuff into audio.
// If we want to enter a "menu" we should leave this state and return when it's time to run normally again.
// An old note:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.
{
    2382:	cf 92       	push	r12
    2384:	df 92       	push	r13
    2386:	ff 92       	push	r15
    2388:	0f 93       	push	r16
    238a:	1f 93       	push	r17
    238c:	cf 93       	push	r28
    238e:	df 93       	push	r29
    2390:	1f 92       	push	r1
    2392:	cd b7       	in	r28, 0x3d	; 61
    2394:	de b7       	in	r29, 0x3e	; 62
		};

	unsigned int
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    2396:	80 91 59 05 	lds	r24, 0x0559
    239a:	81 11       	cpse	r24, r1
    239c:	b2 c4       	rjmp	.+2404   	; 0x2d02 <DoSampler+0x980>
// Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
{
	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
    239e:	80 91 69 05 	lds	r24, 0x0569
    23a2:	86 ff       	sbrs	r24, 6
    23a4:	f3 c0       	rjmp	.+486    	; 0x258c <DoSampler+0x20a>
    23a6:	87 ff       	sbrs	r24, 7
    23a8:	3a c0       	rjmp	.+116    	; 0x241e <DoSampler+0x9c>
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
    23aa:	80 91 55 05 	lds	r24, 0x0555
    23ae:	85 ff       	sbrs	r24, 5
    23b0:	26 c0       	rjmp	.+76     	; 0x23fe <DoSampler+0x7c>
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    23b2:	87 e8       	ldi	r24, 0x87	; 135
    23b4:	94 e0       	ldi	r25, 0x04	; 4
    23b6:	90 93 e1 05 	sts	0x05E1, r25
    23ba:	80 93 e0 05 	sts	0x05E0, r24
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    23be:	10 91 60 05 	lds	r17, 0x0560
    23c2:	81 2f       	mov	r24, r17
    23c4:	0e 94 95 0a 	call	0x152a	; 0x152a <RevertSampleToUnadjusted>
			bankStates[currentBank].bitReduction=0;			// No crusties yet.
    23c8:	2e e2       	ldi	r18, 0x2E	; 46
    23ca:	12 9f       	mul	r17, r18
    23cc:	f0 01       	movw	r30, r0
    23ce:	11 24       	eor	r1, r1
    23d0:	ec 51       	subi	r30, 0x1C	; 28
    23d2:	fa 4f       	sbci	r31, 0xFA	; 250
    23d4:	11 86       	std	Z+9, r1	; 0x09
			bankStates[currentBank].jitterValue=0;			// No hissies yet.
    23d6:	10 86       	std	Z+8, r1	; 0x08
			bankStates[currentBank].granularSlices=0;		// No remix yet.
    23d8:	17 82       	std	Z+7, r1	; 0x07
			bankStates[currentBank].halfSpeed=false;
    23da:	12 82       	std	Z+2, r1	; 0x02
			bankStates[currentBank].backwardsPlayback=false;
    23dc:	13 82       	std	Z+3, r1	; 0x03
			bankStates[currentBank].sampleDirection=true;
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	84 83       	std	Z+4, r24	; 0x04
			bankStates[currentBank].loopOnce=false;
    23e2:	11 82       	std	Z+1, r1	; 0x01
			bankStates[currentBank].realtimeOn=false;
    23e4:	16 82       	std	Z+6, r1	; 0x06
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
    23e6:	20 e0       	ldi	r18, 0x00	; 0
    23e8:	42 e1       	ldi	r20, 0x12	; 18
    23ea:	64 e0       	ldi	r22, 0x04	; 4
    23ec:	81 2f       	mov	r24, r17
    23ee:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
    23f2:	20 e0       	ldi	r18, 0x00	; 0
    23f4:	4b e1       	ldi	r20, 0x1B	; 27
    23f6:	64 e0       	ldi	r22, 0x04	; 4
    23f8:	80 91 60 05 	lds	r24, 0x0560
    23fc:	e4 c1       	rjmp	.+968    	; 0x27c6 <DoSampler+0x444>
		}
		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
    23fe:	80 ff       	sbrs	r24, 0
    2400:	f6 c1       	rjmp	.+1004   	; 0x27ee <DoSampler+0x46c>
		{
			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
    2402:	80 91 57 05 	lds	r24, 0x0557
    2406:	8e 30       	cpi	r24, 0x0E	; 14
    2408:	09 f0       	breq	.+2      	; 0x240c <DoSampler+0x8a>
    240a:	f1 c1       	rjmp	.+994    	; 0x27ee <DoSampler+0x46c>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    240c:	89 e2       	ldi	r24, 0x29	; 41
    240e:	9e e0       	ldi	r25, 0x0E	; 14
    2410:	90 93 e3 05 	sts	0x05E3, r25
    2414:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    2418:	10 92 59 05 	sts	0x0559, r1
    241c:	e8 c1       	rjmp	.+976    	; 0x27ee <DoSampler+0x46c>
	// -----------------------------------------------------------------------------------
	// Shift 1:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    241e:	80 91 56 05 	lds	r24, 0x0556
    2422:	80 ff       	sbrs	r24, 0
    2424:	17 c0       	rjmp	.+46     	; 0x2454 <DoSampler+0xd2>
		{
			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just got pressed
    2426:	80 91 6a 05 	lds	r24, 0x056A
    242a:	81 11       	cpse	r24, r1
    242c:	04 c0       	rjmp	.+8      	; 0x2436 <DoSampler+0xb4>
    242e:	80 91 55 05 	lds	r24, 0x0555
    2432:	80 ff       	sbrs	r24, 0
    2434:	0f c0       	rjmp	.+30     	; 0x2454 <DoSampler+0xd2>
			{
				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    2436:	80 91 60 05 	lds	r24, 0x0560
    243a:	20 91 6b 05 	lds	r18, 0x056B
    243e:	4e e2       	ldi	r20, 0x2E	; 46
    2440:	84 9f       	mul	r24, r20
    2442:	f0 01       	movw	r30, r0
    2444:	11 24       	eor	r1, r1
    2446:	ec 51       	subi	r30, 0x1C	; 28
    2448:	fa 4f       	sbci	r31, 0xFA	; 250
    244a:	21 87       	std	Z+9, r18	; 0x09
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    244c:	43 e1       	ldi	r20, 0x13	; 19
    244e:	64 e0       	ldi	r22, 0x04	; 4
    2450:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
    2454:	80 91 55 05 	lds	r24, 0x0555
    2458:	81 ff       	sbrs	r24, 1
    245a:	15 c0       	rjmp	.+42     	; 0x2486 <DoSampler+0x104>
		{
			if(bankStates[currentBank].halfSpeed==false)
    245c:	80 91 60 05 	lds	r24, 0x0560
    2460:	9e e2       	ldi	r25, 0x2E	; 46
    2462:	89 9f       	mul	r24, r25
    2464:	f0 01       	movw	r30, r0
    2466:	11 24       	eor	r1, r1
    2468:	ec 51       	subi	r30, 0x1C	; 28
    246a:	fa 4f       	sbci	r31, 0xFA	; 250
    246c:	92 81       	ldd	r25, Z+2	; 0x02
    246e:	91 11       	cpse	r25, r1
    2470:	04 c0       	rjmp	.+8      	; 0x247a <DoSampler+0xf8>
			{
				bankStates[currentBank].halfSpeed=true;
    2472:	91 e0       	ldi	r25, 0x01	; 1
    2474:	92 83       	std	Z+2, r25	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2476:	20 e4       	ldi	r18, 0x40	; 64
    2478:	02 c0       	rjmp	.+4      	; 0x247e <DoSampler+0xfc>
			}
			else
			{
				bankStates[currentBank].halfSpeed=false;
    247a:	12 82       	std	Z+2, r1	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    247c:	20 e0       	ldi	r18, 0x00	; 0
    247e:	40 e1       	ldi	r20, 0x10	; 16
    2480:	64 e0       	ldi	r22, 0x04	; 4
    2482:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
    2486:	80 91 55 05 	lds	r24, 0x0555
    248a:	82 ff       	sbrs	r24, 2
    248c:	0e c0       	rjmp	.+28     	; 0x24aa <DoSampler+0x128>
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
    248e:	10 91 60 05 	lds	r17, 0x0560
    2492:	40 e0       	ldi	r20, 0x00	; 0
    2494:	50 e0       	ldi	r21, 0x00	; 0
    2496:	61 e0       	ldi	r22, 0x01	; 1
    2498:	81 2f       	mov	r24, r17
    249a:	0e 94 56 0d 	call	0x1aac	; 0x1aac <StartRealtime>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    249e:	20 e3       	ldi	r18, 0x30	; 48
    24a0:	4e e0       	ldi	r20, 0x0E	; 14
    24a2:	64 e0       	ldi	r22, 0x04	; 4
    24a4:	81 2f       	mov	r24, r17
    24a6:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
		}
		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- reshuffle if the encoder moves OR we get a new button press, but not just while the button is held
    24aa:	80 91 56 05 	lds	r24, 0x0556
    24ae:	83 ff       	sbrs	r24, 3
    24b0:	04 c0       	rjmp	.+8      	; 0x24ba <DoSampler+0x138>
    24b2:	80 91 6a 05 	lds	r24, 0x056A
    24b6:	81 11       	cpse	r24, r1
    24b8:	04 c0       	rjmp	.+8      	; 0x24c2 <DoSampler+0x140>
    24ba:	80 91 55 05 	lds	r24, 0x0555
    24be:	83 ff       	sbrs	r24, 3
    24c0:	10 c0       	rjmp	.+32     	; 0x24e2 <DoSampler+0x160>
		{
			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
    24c2:	20 91 6c 05 	lds	r18, 0x056C
    24c6:	26 95       	lsr	r18
    24c8:	10 91 60 05 	lds	r17, 0x0560
    24cc:	62 2f       	mov	r22, r18
    24ce:	81 2f       	mov	r24, r17
    24d0:	29 83       	std	Y+1, r18	; 0x01
    24d2:	0e 94 94 05 	call	0xb28	; 0xb28 <MakeNewGranularArray>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    24d6:	29 81       	ldd	r18, Y+1	; 0x01
    24d8:	44 e1       	ldi	r20, 0x14	; 20
    24da:	64 e0       	ldi	r22, 0x04	; 4
    24dc:	81 2f       	mov	r24, r17
    24de:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
    24e2:	80 91 56 05 	lds	r24, 0x0556
    24e6:	84 ff       	sbrs	r24, 4
    24e8:	33 c0       	rjmp	.+102    	; 0x2550 <DoSampler+0x1ce>
		{
			if(newEncoder)	// Only change to new values
    24ea:	80 91 6a 05 	lds	r24, 0x056A
    24ee:	88 23       	and	r24, r24
    24f0:	79 f1       	breq	.+94     	; 0x2550 <DoSampler+0x1ce>
			{
				switch(scaledEncoderValue)
    24f2:	80 91 6b 05 	lds	r24, 0x056B
    24f6:	81 30       	cpi	r24, 0x01	; 1
    24f8:	71 f0       	breq	.+28     	; 0x2516 <DoSampler+0x194>
    24fa:	28 f0       	brcs	.+10     	; 0x2506 <DoSampler+0x184>
    24fc:	82 30       	cpi	r24, 0x02	; 2
    24fe:	99 f0       	breq	.+38     	; 0x2526 <DoSampler+0x1a4>
    2500:	83 30       	cpi	r24, 0x03	; 3
    2502:	31 f5       	brne	.+76     	; 0x2550 <DoSampler+0x1ce>
    2504:	18 c0       	rjmp	.+48     	; 0x2536 <DoSampler+0x1b4>
				{
					case 0:
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2506:	87 e8       	ldi	r24, 0x87	; 135
    2508:	94 e0       	ldi	r25, 0x04	; 4
    250a:	90 93 e1 05 	sts	0x05E1, r25
    250e:	80 93 e0 05 	sts	0x05E0, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2512:	20 e0       	ldi	r18, 0x00	; 0
    2514:	17 c0       	rjmp	.+46     	; 0x2544 <DoSampler+0x1c2>
					break;

					case 1:
					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2516:	8b e3       	ldi	r24, 0x3B	; 59
    2518:	94 e0       	ldi	r25, 0x04	; 4
    251a:	90 93 e1 05 	sts	0x05E1, r25
    251e:	80 93 e0 05 	sts	0x05E0, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2522:	21 e0       	ldi	r18, 0x01	; 1
    2524:	0f c0       	rjmp	.+30     	; 0x2544 <DoSampler+0x1c2>
					break;

					case 2:
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2526:	8a ef       	ldi	r24, 0xFA	; 250
    2528:	94 e0       	ldi	r25, 0x04	; 4
    252a:	90 93 e1 05 	sts	0x05E1, r25
    252e:	80 93 e0 05 	sts	0x05E0, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2532:	22 e0       	ldi	r18, 0x02	; 2
    2534:	07 c0       	rjmp	.+14     	; 0x2544 <DoSampler+0x1c2>
					break;

					case 3:
					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2536:	8d eb       	ldi	r24, 0xBD	; 189
    2538:	94 e0       	ldi	r25, 0x04	; 4
    253a:	90 93 e1 05 	sts	0x05E1, r25
    253e:	80 93 e0 05 	sts	0x05E0, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2542:	23 e0       	ldi	r18, 0x03	; 3
    2544:	46 e1       	ldi	r20, 0x16	; 22
    2546:	64 e0       	ldi	r22, 0x04	; 4
    2548:	80 91 60 05 	lds	r24, 0x0560
    254c:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
					default:
					break;
				}
			}
		}
		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
    2550:	80 91 55 05 	lds	r24, 0x0555
    2554:	85 ff       	sbrs	r24, 5
    2556:	4b c1       	rjmp	.+662    	; 0x27ee <DoSampler+0x46c>
		{
			if(bankStates[currentBank].backwardsPlayback==false)
    2558:	80 91 60 05 	lds	r24, 0x0560
    255c:	2e e2       	ldi	r18, 0x2E	; 46
    255e:	82 9f       	mul	r24, r18
    2560:	f0 01       	movw	r30, r0
    2562:	11 24       	eor	r1, r1
    2564:	ec 51       	subi	r30, 0x1C	; 28
    2566:	fa 4f       	sbci	r31, 0xFA	; 250
    2568:	93 81       	ldd	r25, Z+3	; 0x03
    256a:	91 11       	cpse	r25, r1
    256c:	04 c0       	rjmp	.+8      	; 0x2576 <DoSampler+0x1f4>
			{
				bankStates[currentBank].backwardsPlayback=true;
    256e:	91 e0       	ldi	r25, 0x01	; 1
    2570:	93 83       	std	Z+3, r25	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2572:	20 e4       	ldi	r18, 0x40	; 64
    2574:	02 c0       	rjmp	.+4      	; 0x257a <DoSampler+0x1f8>
			}
			else
			{
				bankStates[currentBank].backwardsPlayback=false;
    2576:	13 82       	std	Z+3, r1	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2578:	20 e0       	ldi	r18, 0x00	; 0
    257a:	41 e1       	ldi	r20, 0x11	; 17
    257c:	64 e0       	ldi	r22, 0x04	; 4
    257e:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
			}

			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2582:	80 91 60 05 	lds	r24, 0x0560
    2586:	0e 94 91 06 	call	0xd22	; 0xd22 <UpdateAdjustedSampleAddresses>
    258a:	31 c1       	rjmp	.+610    	; 0x27ee <DoSampler+0x46c>
		}
	}
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
    258c:	87 ff       	sbrs	r24, 7
    258e:	55 c0       	rjmp	.+170    	; 0x263a <DoSampler+0x2b8>
	{
		if(keyState&Im_SWITCH_0)		// Adjust sample start
    2590:	80 91 56 05 	lds	r24, 0x0556
    2594:	80 ff       	sbrs	r24, 0
    2596:	15 c0       	rjmp	.+42     	; 0x25c2 <DoSampler+0x240>
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2598:	10 91 60 05 	lds	r17, 0x0560
    259c:	4e e2       	ldi	r20, 0x2E	; 46
    259e:	14 9f       	mul	r17, r20
    25a0:	f0 01       	movw	r30, r0
    25a2:	11 24       	eor	r1, r1
    25a4:	ec 51       	subi	r30, 0x1C	; 28
    25a6:	fa 4f       	sbci	r31, 0xFA	; 250
    25a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    25aa:	00 91 6c 05 	lds	r16, 0x056C
    25ae:	80 17       	cp	r24, r16
    25b0:	c9 f1       	breq	.+114    	; 0x2624 <DoSampler+0x2a2>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    25b2:	05 8f       	std	Z+29, r16	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    25b4:	81 2f       	mov	r24, r17
    25b6:	0e 94 91 06 	call	0xd22	; 0xd22 <UpdateAdjustedSampleAddresses>
		if(keyState&Im_SWITCH_0)		// Adjust sample start
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    25ba:	20 2f       	mov	r18, r16
    25bc:	26 95       	lsr	r18
    25be:	4c e1       	ldi	r20, 0x1C	; 28
    25c0:	2d c0       	rjmp	.+90     	; 0x261c <DoSampler+0x29a>
			}
		}
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
    25c2:	81 ff       	sbrs	r24, 1
    25c4:	15 c0       	rjmp	.+42     	; 0x25f0 <DoSampler+0x26e>
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    25c6:	10 91 60 05 	lds	r17, 0x0560
    25ca:	8e e2       	ldi	r24, 0x2E	; 46
    25cc:	18 9f       	mul	r17, r24
    25ce:	f0 01       	movw	r30, r0
    25d0:	11 24       	eor	r1, r1
    25d2:	ec 51       	subi	r30, 0x1C	; 28
    25d4:	fa 4f       	sbci	r31, 0xFA	; 250
    25d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    25d8:	00 91 6c 05 	lds	r16, 0x056C
    25dc:	80 17       	cp	r24, r16
    25de:	11 f1       	breq	.+68     	; 0x2624 <DoSampler+0x2a2>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    25e0:	06 8f       	std	Z+30, r16	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    25e2:	81 2f       	mov	r24, r17
    25e4:	0e 94 91 06 	call	0xd22	; 0xd22 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    25e8:	20 2f       	mov	r18, r16
    25ea:	26 95       	lsr	r18
    25ec:	4d e1       	ldi	r20, 0x1D	; 29
    25ee:	16 c0       	rjmp	.+44     	; 0x261c <DoSampler+0x29a>
			}
		}
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
    25f0:	82 ff       	sbrs	r24, 2
    25f2:	18 c0       	rjmp	.+48     	; 0x2624 <DoSampler+0x2a2>
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    25f4:	10 91 60 05 	lds	r17, 0x0560
    25f8:	9e e2       	ldi	r25, 0x2E	; 46
    25fa:	19 9f       	mul	r17, r25
    25fc:	f0 01       	movw	r30, r0
    25fe:	11 24       	eor	r1, r1
    2600:	ec 51       	subi	r30, 0x1C	; 28
    2602:	fa 4f       	sbci	r31, 0xFA	; 250
    2604:	87 8d       	ldd	r24, Z+31	; 0x1f
    2606:	00 91 6c 05 	lds	r16, 0x056C
    260a:	80 17       	cp	r24, r16
    260c:	59 f0       	breq	.+22     	; 0x2624 <DoSampler+0x2a2>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    260e:	07 8f       	std	Z+31, r16	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    2610:	81 2f       	mov	r24, r17
    2612:	0e 94 91 06 	call	0xd22	; 0xd22 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2616:	20 2f       	mov	r18, r16
    2618:	26 95       	lsr	r18
    261a:	4e e1       	ldi	r20, 0x1E	; 30
    261c:	64 e0       	ldi	r22, 0x04	; 4
    261e:	81 2f       	mov	r24, r17
    2620:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
			}
		}

		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
    2624:	80 91 55 05 	lds	r24, 0x0555
    2628:	83 ff       	sbrs	r24, 3
    262a:	e1 c0       	rjmp	.+450    	; 0x27ee <DoSampler+0x46c>
		{
			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
    262c:	80 91 61 05 	lds	r24, 0x0561
    2630:	90 91 62 05 	lds	r25, 0x0562
    2634:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <PlaySampleFromSd>
    2638:	da c0       	rjmp	.+436    	; 0x27ee <DoSampler+0x46c>
	// -----------------------------------------------------------------------------------
	// No shift keys pressed:
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
    263a:	80 91 55 05 	lds	r24, 0x0555
    263e:	80 ff       	sbrs	r24, 0
    2640:	22 c0       	rjmp	.+68     	; 0x2686 <DoSampler+0x304>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2642:	10 91 60 05 	lds	r17, 0x0560
    2646:	ee e2       	ldi	r30, 0x2E	; 46
    2648:	1e 9f       	mul	r17, r30
    264a:	60 01       	movw	r12, r0
    264c:	11 24       	eor	r1, r1
    264e:	84 ee       	ldi	r24, 0xE4	; 228
    2650:	95 e0       	ldi	r25, 0x05	; 5
    2652:	c8 0e       	add	r12, r24
    2654:	d9 1e       	adc	r13, r25
    2656:	f6 01       	movw	r30, r12
    2658:	80 81       	ld	r24, Z
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    265a:	40 e0       	ldi	r20, 0x00	; 0
    265c:	50 e0       	ldi	r21, 0x00	; 0
    265e:	61 e0       	ldi	r22, 0x01	; 1
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2660:	83 30       	cpi	r24, 0x03	; 3
    2662:	49 f4       	brne	.+18     	; 0x2676 <DoSampler+0x2f4>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2664:	81 2f       	mov	r24, r17
    2666:	0e 94 4f 0c 	call	0x189e	; 0x189e <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    266a:	f6 01       	movw	r30, r12
    266c:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    266e:	20 e4       	ldi	r18, 0x40	; 64
    2670:	40 e3       	ldi	r20, 0x30	; 48
    2672:	61 e0       	ldi	r22, 0x01	; 1
    2674:	06 c0       	rjmp	.+12     	; 0x2682 <DoSampler+0x300>
			}
			else											// We're not recording right now, so start doing it.
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2676:	81 2f       	mov	r24, r17
    2678:	0e 94 c2 0c 	call	0x1984	; 0x1984 <StartRecording>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    267c:	20 e3       	ldi	r18, 0x30	; 48
    267e:	43 e0       	ldi	r20, 0x03	; 3
    2680:	64 e0       	ldi	r22, 0x04	; 4
    2682:	81 2f       	mov	r24, r17
    2684:	a0 c0       	rjmp	.+320    	; 0x27c6 <DoSampler+0x444>
			}
		}
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2686:	81 ff       	sbrs	r24, 1
    2688:	31 c0       	rjmp	.+98     	; 0x26ec <DoSampler+0x36a>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    268a:	f0 90 60 05 	lds	r15, 0x0560
    268e:	fe e2       	ldi	r31, 0x2E	; 46
    2690:	ff 9e       	mul	r15, r31
    2692:	60 01       	movw	r12, r0
    2694:	11 24       	eor	r1, r1
    2696:	84 ee       	ldi	r24, 0xE4	; 228
    2698:	95 e0       	ldi	r25, 0x05	; 5
    269a:	c8 0e       	add	r12, r24
    269c:	d9 1e       	adc	r13, r25
    269e:	f6 01       	movw	r30, r12
    26a0:	80 81       	ld	r24, Z
    26a2:	85 30       	cpi	r24, 0x05	; 5
    26a4:	51 f4       	brne	.+20     	; 0x26ba <DoSampler+0x338>
			{
				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
    26a6:	40 e0       	ldi	r20, 0x00	; 0
    26a8:	50 e0       	ldi	r21, 0x00	; 0
    26aa:	61 e0       	ldi	r22, 0x01	; 1
    26ac:	8f 2d       	mov	r24, r15
    26ae:	0e 94 9a 0c 	call	0x1934	; 0x1934 <ContinuePlayback>
				bankStates[currentBank].loopOnce=false;
    26b2:	f6 01       	movw	r30, r12
    26b4:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    26b6:	20 e0       	ldi	r18, 0x00	; 0
    26b8:	16 c0       	rjmp	.+44     	; 0x26e6 <DoSampler+0x364>
			}
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    26ba:	f6 01       	movw	r30, r12
    26bc:	01 89       	ldd	r16, Z+17	; 0x11
    26be:	12 89       	ldd	r17, Z+18	; 0x12
    26c0:	23 89       	ldd	r18, Z+19	; 0x13
    26c2:	34 89       	ldd	r19, Z+20	; 0x14
    26c4:	45 85       	ldd	r20, Z+13	; 0x0d
    26c6:	56 85       	ldd	r21, Z+14	; 0x0e
    26c8:	67 85       	ldd	r22, Z+15	; 0x0f
    26ca:	70 89       	ldd	r23, Z+16	; 0x10
    26cc:	04 17       	cp	r16, r20
    26ce:	15 07       	cpc	r17, r21
    26d0:	26 07       	cpc	r18, r22
    26d2:	37 07       	cpc	r19, r23
    26d4:	09 f4       	brne	.+2      	; 0x26d8 <DoSampler+0x356>
    26d6:	8b c0       	rjmp	.+278    	; 0x27ee <DoSampler+0x46c>
				{
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    26d8:	40 e0       	ldi	r20, 0x00	; 0
    26da:	50 e0       	ldi	r21, 0x00	; 0
    26dc:	61 e0       	ldi	r22, 0x01	; 1
    26de:	8f 2d       	mov	r24, r15
    26e0:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <StartOverdub>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    26e4:	20 e3       	ldi	r18, 0x30	; 48
    26e6:	49 e0       	ldi	r20, 0x09	; 9
    26e8:	64 e0       	ldi	r22, 0x04	; 4
    26ea:	6c c0       	rjmp	.+216    	; 0x27c4 <DoSampler+0x442>
				}
			}
		}
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
    26ec:	82 ff       	sbrs	r24, 2
    26ee:	22 c0       	rjmp	.+68     	; 0x2734 <DoSampler+0x3b2>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    26f0:	f0 90 60 05 	lds	r15, 0x0560
    26f4:	fe e2       	ldi	r31, 0x2E	; 46
    26f6:	ff 9e       	mul	r15, r31
    26f8:	60 01       	movw	r12, r0
    26fa:	11 24       	eor	r1, r1
    26fc:	84 ee       	ldi	r24, 0xE4	; 228
    26fe:	95 e0       	ldi	r25, 0x05	; 5
    2700:	c8 0e       	add	r12, r24
    2702:	d9 1e       	adc	r13, r25
    2704:	f6 01       	movw	r30, r12
    2706:	01 89       	ldd	r16, Z+17	; 0x11
    2708:	12 89       	ldd	r17, Z+18	; 0x12
    270a:	23 89       	ldd	r18, Z+19	; 0x13
    270c:	34 89       	ldd	r19, Z+20	; 0x14
    270e:	45 85       	ldd	r20, Z+13	; 0x0d
    2710:	56 85       	ldd	r21, Z+14	; 0x0e
    2712:	67 85       	ldd	r22, Z+15	; 0x0f
    2714:	70 89       	ldd	r23, Z+16	; 0x10
    2716:	04 17       	cp	r16, r20
    2718:	15 07       	cpc	r17, r21
    271a:	26 07       	cpc	r18, r22
    271c:	37 07       	cpc	r19, r23
    271e:	09 f4       	brne	.+2      	; 0x2722 <DoSampler+0x3a0>
    2720:	66 c0       	rjmp	.+204    	; 0x27ee <DoSampler+0x46c>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2722:	40 e0       	ldi	r20, 0x00	; 0
    2724:	50 e0       	ldi	r21, 0x00	; 0
    2726:	61 e0       	ldi	r22, 0x01	; 1
    2728:	8f 2d       	mov	r24, r15
    272a:	0e 94 4f 0c 	call	0x189e	; 0x189e <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    272e:	f6 01       	movw	r30, r12
    2730:	11 82       	std	Z+1, r1	; 0x01
    2732:	45 c0       	rjmp	.+138    	; 0x27be <DoSampler+0x43c>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    2734:	83 ff       	sbrs	r24, 3
    2736:	23 c0       	rjmp	.+70     	; 0x277e <DoSampler+0x3fc>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2738:	f0 90 60 05 	lds	r15, 0x0560
    273c:	fe e2       	ldi	r31, 0x2E	; 46
    273e:	ff 9e       	mul	r15, r31
    2740:	60 01       	movw	r12, r0
    2742:	11 24       	eor	r1, r1
    2744:	84 ee       	ldi	r24, 0xE4	; 228
    2746:	95 e0       	ldi	r25, 0x05	; 5
    2748:	c8 0e       	add	r12, r24
    274a:	d9 1e       	adc	r13, r25
    274c:	f6 01       	movw	r30, r12
    274e:	01 89       	ldd	r16, Z+17	; 0x11
    2750:	12 89       	ldd	r17, Z+18	; 0x12
    2752:	23 89       	ldd	r18, Z+19	; 0x13
    2754:	34 89       	ldd	r19, Z+20	; 0x14
    2756:	45 85       	ldd	r20, Z+13	; 0x0d
    2758:	56 85       	ldd	r21, Z+14	; 0x0e
    275a:	67 85       	ldd	r22, Z+15	; 0x0f
    275c:	70 89       	ldd	r23, Z+16	; 0x10
    275e:	04 17       	cp	r16, r20
    2760:	15 07       	cpc	r17, r21
    2762:	26 07       	cpc	r18, r22
    2764:	37 07       	cpc	r19, r23
    2766:	09 f4       	brne	.+2      	; 0x276a <DoSampler+0x3e8>
    2768:	42 c0       	rjmp	.+132    	; 0x27ee <DoSampler+0x46c>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    276a:	40 e0       	ldi	r20, 0x00	; 0
    276c:	50 e0       	ldi	r21, 0x00	; 0
    276e:	61 e0       	ldi	r22, 0x01	; 1
    2770:	8f 2d       	mov	r24, r15
    2772:	0e 94 4f 0c 	call	0x189e	; 0x189e <StartPlayback>
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	f6 01       	movw	r30, r12
    277a:	81 83       	std	Z+1, r24	; 0x01
    277c:	20 c0       	rjmp	.+64     	; 0x27be <DoSampler+0x43c>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
			}
		}
		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this will stop it at the current sample location.  If playback is idle it will restart it.  This will not restart a playing sample from the beginning.
    277e:	84 ff       	sbrs	r24, 4
    2780:	2b c0       	rjmp	.+86     	; 0x27d8 <DoSampler+0x456>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    2782:	f0 90 60 05 	lds	r15, 0x0560
    2786:	2e e2       	ldi	r18, 0x2E	; 46
    2788:	f2 9e       	mul	r15, r18
    278a:	f0 01       	movw	r30, r0
    278c:	11 24       	eor	r1, r1
    278e:	ec 51       	subi	r30, 0x1C	; 28
    2790:	fa 4f       	sbci	r31, 0xFA	; 250
    2792:	80 81       	ld	r24, Z
    2794:	81 11       	cpse	r24, r1
    2796:	1a c0       	rjmp	.+52     	; 0x27cc <DoSampler+0x44a>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2798:	01 89       	ldd	r16, Z+17	; 0x11
    279a:	12 89       	ldd	r17, Z+18	; 0x12
    279c:	23 89       	ldd	r18, Z+19	; 0x13
    279e:	34 89       	ldd	r19, Z+20	; 0x14
    27a0:	45 85       	ldd	r20, Z+13	; 0x0d
    27a2:	56 85       	ldd	r21, Z+14	; 0x0e
    27a4:	67 85       	ldd	r22, Z+15	; 0x0f
    27a6:	70 89       	ldd	r23, Z+16	; 0x10
    27a8:	04 17       	cp	r16, r20
    27aa:	15 07       	cpc	r17, r21
    27ac:	26 07       	cpc	r18, r22
    27ae:	37 07       	cpc	r19, r23
    27b0:	f1 f0       	breq	.+60     	; 0x27ee <DoSampler+0x46c>
				{
					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
    27b2:	40 e0       	ldi	r20, 0x00	; 0
    27b4:	50 e0       	ldi	r21, 0x00	; 0
    27b6:	61 e0       	ldi	r22, 0x01	; 1
    27b8:	8f 2d       	mov	r24, r15
    27ba:	0e 94 9a 0c 	call	0x1934	; 0x1934 <ContinuePlayback>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    27be:	20 e4       	ldi	r18, 0x40	; 64
    27c0:	40 e3       	ldi	r20, 0x30	; 48
    27c2:	61 e0       	ldi	r22, 0x01	; 1
    27c4:	8f 2d       	mov	r24, r15
    27c6:	0e 94 d7 1f 	call	0x3fae	; 0x3fae <PutMidiMessageInOutgoingFifo>
    27ca:	11 c0       	rjmp	.+34     	; 0x27ee <DoSampler+0x46c>
				}
			}
			else		// Pause whatever we were doing.
			{
				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    27cc:	10 82       	st	Z, r1
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    27ce:	12 86       	std	Z+10, r1	; 0x0a
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    27d0:	20 e0       	ldi	r18, 0x00	; 0
    27d2:	40 e3       	ldi	r20, 0x30	; 48
    27d4:	62 e0       	ldi	r22, 0x02	; 2
    27d6:	f6 cf       	rjmp	.-20     	; 0x27c4 <DoSampler+0x442>
			}

		}
		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
    27d8:	85 ff       	sbrs	r24, 5
    27da:	09 c0       	rjmp	.+18     	; 0x27ee <DoSampler+0x46c>
		{
			currentBank++;
    27dc:	80 91 60 05 	lds	r24, 0x0560
    27e0:	8f 5f       	subi	r24, 0xFF	; 255
    27e2:	80 93 60 05 	sts	0x0560, r24
			if(currentBank>=NUM_BANKS)
    27e6:	82 30       	cpi	r24, 0x02	; 2
    27e8:	10 f0       	brcs	.+4      	; 0x27ee <DoSampler+0x46c>
			{
				currentBank=BANK_0;		// Loop around.
    27ea:	10 92 60 05 	sts	0x0560, r1

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
	{
		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI

		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
    27ee:	80 91 74 06 	lds	r24, 0x0674
    27f2:	88 23       	and	r24, r24
    27f4:	09 f4       	brne	.+2      	; 0x27f8 <DoSampler+0x476>
    27f6:	85 c2       	rjmp	.+1290   	; 0x2d02 <DoSampler+0x980>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    27f8:	83 e6       	ldi	r24, 0x63	; 99
    27fa:	95 e0       	ldi	r25, 0x05	; 5
    27fc:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <GetMidiMessageFromIncomingFifo>
//			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
//			{
//				// Do this here.
//			}

			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    2800:	80 91 64 05 	lds	r24, 0x0564
    2804:	82 30       	cpi	r24, 0x02	; 2
    2806:	11 f5       	brne	.+68     	; 0x284c <DoSampler+0x4ca>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    2808:	e0 91 63 05 	lds	r30, 0x0563
    280c:	8e 2f       	mov	r24, r30
    280e:	90 e0       	ldi	r25, 0x00	; 0
    2810:	4e e2       	ldi	r20, 0x2E	; 46
    2812:	e4 9f       	mul	r30, r20
    2814:	f0 01       	movw	r30, r0
    2816:	11 24       	eor	r1, r1
    2818:	ec 51       	subi	r30, 0x1C	; 28
    281a:	fa 4f       	sbci	r31, 0xFA	; 250
    281c:	20 81       	ld	r18, Z
    281e:	24 30       	cpi	r18, 0x04	; 4
    2820:	21 f0       	breq	.+8      	; 0x282a <DoSampler+0x4a8>
    2822:	20 81       	ld	r18, Z
    2824:	22 30       	cpi	r18, 0x02	; 2
    2826:	09 f0       	breq	.+2      	; 0x282a <DoSampler+0x4a8>
    2828:	6c c2       	rjmp	.+1240   	; 0x2d02 <DoSampler+0x980>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    282a:	fc 01       	movw	r30, r24
    282c:	ec 5f       	subi	r30, 0xFC	; 252
    282e:	fe 4f       	sbci	r31, 0xFE	; 254
    2830:	30 91 65 05 	lds	r19, 0x0565
    2834:	20 81       	ld	r18, Z
    2836:	32 13       	cpse	r19, r18
    2838:	64 c2       	rjmp	.+1224   	; 0x2d02 <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    283a:	2e e2       	ldi	r18, 0x2E	; 46
    283c:	28 9f       	mul	r18, r24
    283e:	f0 01       	movw	r30, r0
    2840:	29 9f       	mul	r18, r25
    2842:	f0 0d       	add	r31, r0
    2844:	11 24       	eor	r1, r1
    2846:	ec 51       	subi	r30, 0x1C	; 28
    2848:	fa 4f       	sbci	r31, 0xFA	; 250
    284a:	82 c0       	rjmp	.+260    	; 0x2950 <DoSampler+0x5ce>
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    284c:	81 30       	cpi	r24, 0x01	; 1
    284e:	09 f0       	breq	.+2      	; 0x2852 <DoSampler+0x4d0>
    2850:	4d c0       	rjmp	.+154    	; 0x28ec <DoSampler+0x56a>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    2852:	a0 91 63 05 	lds	r26, 0x0563
    2856:	2a 2f       	mov	r18, r26
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	80 91 65 05 	lds	r24, 0x0565
    285e:	f9 01       	movw	r30, r18
    2860:	ec 5f       	subi	r30, 0xFC	; 252
    2862:	fe 4f       	sbci	r31, 0xFE	; 254
    2864:	80 83       	st	Z, r24

				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
    2866:	9e e2       	ldi	r25, 0x2E	; 46
    2868:	92 9f       	mul	r25, r18
    286a:	f0 01       	movw	r30, r0
    286c:	93 9f       	mul	r25, r19
    286e:	f0 0d       	add	r31, r0
    2870:	11 24       	eor	r1, r1
    2872:	ec 51       	subi	r30, 0x1C	; 28
    2874:	fa 4f       	sbci	r31, 0xFA	; 250
    2876:	96 81       	ldd	r25, Z+6	; 0x06
    2878:	99 23       	and	r25, r25
    287a:	a9 f0       	breq	.+42     	; 0x28a6 <DoSampler+0x524>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    287c:	6c e0       	ldi	r22, 0x0C	; 12
    287e:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2882:	e9 2f       	mov	r30, r25
    2884:	f0 e0       	ldi	r31, 0x00	; 0
    2886:	ee 0f       	add	r30, r30
    2888:	ff 1f       	adc	r31, r31
    288a:	ea 5f       	subi	r30, 0xFA	; 250
    288c:	fe 4f       	sbci	r31, 0xFE	; 254
    288e:	40 81       	ld	r20, Z
    2890:	51 81       	ldd	r21, Z+1	; 0x01
    2892:	02 c0       	rjmp	.+4      	; 0x2898 <DoSampler+0x516>
    2894:	56 95       	lsr	r21
    2896:	47 95       	ror	r20
    2898:	8a 95       	dec	r24
    289a:	e2 f7       	brpl	.-8      	; 0x2894 <DoSampler+0x512>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.

				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.
    289c:	62 e0       	ldi	r22, 0x02	; 2
    289e:	8a 2f       	mov	r24, r26
    28a0:	0e 94 56 0d 	call	0x1aac	; 0x1aac <StartRealtime>
    28a4:	2e c2       	rjmp	.+1116   	; 0x2d02 <DoSampler+0x980>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    28a6:	01 89       	ldd	r16, Z+17	; 0x11
    28a8:	12 89       	ldd	r17, Z+18	; 0x12
    28aa:	23 89       	ldd	r18, Z+19	; 0x13
    28ac:	34 89       	ldd	r19, Z+20	; 0x14
    28ae:	45 85       	ldd	r20, Z+13	; 0x0d
    28b0:	56 85       	ldd	r21, Z+14	; 0x0e
    28b2:	67 85       	ldd	r22, Z+15	; 0x0f
    28b4:	70 89       	ldd	r23, Z+16	; 0x10
    28b6:	04 17       	cp	r16, r20
    28b8:	15 07       	cpc	r17, r21
    28ba:	26 07       	cpc	r18, r22
    28bc:	37 07       	cpc	r19, r23
    28be:	09 f4       	brne	.+2      	; 0x28c2 <DoSampler+0x540>
    28c0:	20 c2       	rjmp	.+1088   	; 0x2d02 <DoSampler+0x980>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    28c2:	6c e0       	ldi	r22, 0x0C	; 12
    28c4:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    28c8:	e9 2f       	mov	r30, r25
    28ca:	f0 e0       	ldi	r31, 0x00	; 0
    28cc:	ee 0f       	add	r30, r30
    28ce:	ff 1f       	adc	r31, r31
    28d0:	ea 5f       	subi	r30, 0xFA	; 250
    28d2:	fe 4f       	sbci	r31, 0xFE	; 254
    28d4:	40 81       	ld	r20, Z
    28d6:	51 81       	ldd	r21, Z+1	; 0x01
    28d8:	02 c0       	rjmp	.+4      	; 0x28de <DoSampler+0x55c>
    28da:	56 95       	lsr	r21
    28dc:	47 95       	ror	r20
    28de:	8a 95       	dec	r24
    28e0:	e2 f7       	brpl	.-8      	; 0x28da <DoSampler+0x558>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    28e2:	62 e0       	ldi	r22, 0x02	; 2
    28e4:	8a 2f       	mov	r24, r26
    28e6:	0e 94 4f 0c 	call	0x189e	; 0x189e <StartPlayback>
    28ea:	0b c2       	rjmp	.+1046   	; 0x2d02 <DoSampler+0x980>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    28ec:	84 30       	cpi	r24, 0x04	; 4
    28ee:	09 f0       	breq	.+2      	; 0x28f2 <DoSampler+0x570>
    28f0:	af c1       	rjmp	.+862    	; 0x2c50 <DoSampler+0x8ce>
			{
				switch(currentMidiMessage.dataByteOne)
    28f2:	80 91 65 05 	lds	r24, 0x0565
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	fc 01       	movw	r30, r24
    28fa:	33 97       	sbiw	r30, 0x03	; 3
    28fc:	ec 31       	cpi	r30, 0x1C	; 28
    28fe:	f1 05       	cpc	r31, r1
    2900:	08 f0       	brcs	.+2      	; 0x2904 <DoSampler+0x582>
    2902:	ff c1       	rjmp	.+1022   	; 0x2d02 <DoSampler+0x980>
    2904:	e2 5c       	subi	r30, 0xC2	; 194
    2906:	ff 4f       	sbci	r31, 0xFF	; 255
    2908:	0c 94 44 2a 	jmp	0x5488	; 0x5488 <__tablejump2__>
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    290c:	90 91 66 05 	lds	r25, 0x0566
    2910:	80 91 63 05 	lds	r24, 0x0563
    2914:	99 23       	and	r25, r25
    2916:	91 f0       	breq	.+36     	; 0x293c <DoSampler+0x5ba>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    2918:	a8 2f       	mov	r26, r24
    291a:	b0 e0       	ldi	r27, 0x00	; 0
    291c:	aa 0f       	add	r26, r26
    291e:	bb 1f       	adc	r27, r27
    2920:	a4 5a       	subi	r26, 0xA4	; 164
    2922:	ba 4f       	sbci	r27, 0xFA	; 250
    2924:	4d 91       	ld	r20, X+
    2926:	5c 91       	ld	r21, X
    2928:	62 e0       	ldi	r22, 0x02	; 2
    292a:	0e 94 c2 0c 	call	0x1984	; 0x1984 <StartRecording>
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll default to playback after a recording.
    292e:	e0 91 63 05 	lds	r30, 0x0563
    2932:	8e e2       	ldi	r24, 0x2E	; 46
    2934:	e8 9f       	mul	r30, r24
    2936:	f0 01       	movw	r30, r0
    2938:	11 24       	eor	r1, r1
    293a:	38 c0       	rjmp	.+112    	; 0x29ac <DoSampler+0x62a>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    293c:	9e e2       	ldi	r25, 0x2E	; 46
    293e:	89 9f       	mul	r24, r25
    2940:	f0 01       	movw	r30, r0
    2942:	11 24       	eor	r1, r1
    2944:	ec 51       	subi	r30, 0x1C	; 28
    2946:	fa 4f       	sbci	r31, 0xFA	; 250
    2948:	80 81       	ld	r24, Z
    294a:	83 30       	cpi	r24, 0x03	; 3
    294c:	09 f0       	breq	.+2      	; 0x2950 <DoSampler+0x5ce>
    294e:	d9 c1       	rjmp	.+946    	; 0x2d02 <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2950:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2952:	12 86       	std	Z+10, r1	; 0x0a
    2954:	d6 c1       	rjmp	.+940    	; 0x2d02 <DoSampler+0x980>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2956:	90 91 66 05 	lds	r25, 0x0566
    295a:	80 91 63 05 	lds	r24, 0x0563
    295e:	99 23       	and	r25, r25
    2960:	41 f1       	breq	.+80     	; 0x29b2 <DoSampler+0x630>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2962:	a8 2f       	mov	r26, r24
    2964:	b0 e0       	ldi	r27, 0x00	; 0
    2966:	2e e2       	ldi	r18, 0x2E	; 46
    2968:	f2 2e       	mov	r15, r18
    296a:	fa 9e       	mul	r15, r26
    296c:	f0 01       	movw	r30, r0
    296e:	fb 9e       	mul	r15, r27
    2970:	f0 0d       	add	r31, r0
    2972:	11 24       	eor	r1, r1
    2974:	ec 51       	subi	r30, 0x1C	; 28
    2976:	fa 4f       	sbci	r31, 0xFA	; 250
    2978:	01 89       	ldd	r16, Z+17	; 0x11
    297a:	12 89       	ldd	r17, Z+18	; 0x12
    297c:	23 89       	ldd	r18, Z+19	; 0x13
    297e:	34 89       	ldd	r19, Z+20	; 0x14
    2980:	45 85       	ldd	r20, Z+13	; 0x0d
    2982:	56 85       	ldd	r21, Z+14	; 0x0e
    2984:	67 85       	ldd	r22, Z+15	; 0x0f
    2986:	70 89       	ldd	r23, Z+16	; 0x10
    2988:	04 17       	cp	r16, r20
    298a:	15 07       	cpc	r17, r21
    298c:	26 07       	cpc	r18, r22
    298e:	37 07       	cpc	r19, r23
    2990:	09 f4       	brne	.+2      	; 0x2994 <DoSampler+0x612>
    2992:	b7 c1       	rjmp	.+878    	; 0x2d02 <DoSampler+0x980>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    2994:	ac 5f       	subi	r26, 0xFC	; 252
    2996:	be 4f       	sbci	r27, 0xFE	; 254
    2998:	4c 91       	ld	r20, X
    299a:	50 e0       	ldi	r21, 0x00	; 0
    299c:	62 e0       	ldi	r22, 0x02	; 2
    299e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <StartOverdub>
							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll default to playback after a recording.
    29a2:	e0 91 63 05 	lds	r30, 0x0563
    29a6:	fe 9e       	mul	r15, r30
    29a8:	f0 01       	movw	r30, r0
    29aa:	11 24       	eor	r1, r1
    29ac:	ec 51       	subi	r30, 0x1C	; 28
    29ae:	fa 4f       	sbci	r31, 0xFA	; 250
    29b0:	3d c0       	rjmp	.+122    	; 0x2a2c <DoSampler+0x6aa>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    29b2:	28 2f       	mov	r18, r24
    29b4:	30 e0       	ldi	r19, 0x00	; 0
    29b6:	4e e2       	ldi	r20, 0x2E	; 46
    29b8:	84 9f       	mul	r24, r20
    29ba:	f0 01       	movw	r30, r0
    29bc:	11 24       	eor	r1, r1
    29be:	ec 51       	subi	r30, 0x1C	; 28
    29c0:	fa 4f       	sbci	r31, 0xFA	; 250
    29c2:	90 81       	ld	r25, Z
    29c4:	95 30       	cpi	r25, 0x05	; 5
    29c6:	09 f0       	breq	.+2      	; 0x29ca <DoSampler+0x648>
    29c8:	9c c1       	rjmp	.+824    	; 0x2d02 <DoSampler+0x980>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    29ca:	f9 01       	movw	r30, r18
    29cc:	ec 5f       	subi	r30, 0xFC	; 252
    29ce:	fe 4f       	sbci	r31, 0xFE	; 254
    29d0:	40 81       	ld	r20, Z
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	62 e0       	ldi	r22, 0x02	; 2
    29d6:	0e 94 9a 0c 	call	0x1934	; 0x1934 <ContinuePlayback>
    29da:	93 c1       	rjmp	.+806    	; 0x2d02 <DoSampler+0x980>
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    29dc:	90 91 66 05 	lds	r25, 0x0566
    29e0:	80 91 63 05 	lds	r24, 0x0563
    29e4:	99 23       	and	r25, r25
    29e6:	b1 f0       	breq	.+44     	; 0x2a14 <DoSampler+0x692>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    29e8:	a8 2f       	mov	r26, r24
    29ea:	b0 e0       	ldi	r27, 0x00	; 0
    29ec:	aa 0f       	add	r26, r26
    29ee:	bb 1f       	adc	r27, r27
    29f0:	a4 5a       	subi	r26, 0xA4	; 164
    29f2:	ba 4f       	sbci	r27, 0xFA	; 250
    29f4:	4d 91       	ld	r20, X+
    29f6:	5c 91       	ld	r21, X
    29f8:	62 e0       	ldi	r22, 0x02	; 2
    29fa:	0e 94 56 0d 	call	0x1aac	; 0x1aac <StartRealtime>
						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so that we don't stop realtime processing if we get a note off.
    29fe:	e0 91 63 05 	lds	r30, 0x0563
    2a02:	8e e2       	ldi	r24, 0x2E	; 46
    2a04:	e8 9f       	mul	r30, r24
    2a06:	f0 01       	movw	r30, r0
    2a08:	11 24       	eor	r1, r1
    2a0a:	ec 51       	subi	r30, 0x1C	; 28
    2a0c:	fa 4f       	sbci	r31, 0xFA	; 250
    2a0e:	81 e0       	ldi	r24, 0x01	; 1
    2a10:	86 83       	std	Z+6, r24	; 0x06
    2a12:	77 c1       	rjmp	.+750    	; 0x2d02 <DoSampler+0x980>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    2a14:	9e e2       	ldi	r25, 0x2E	; 46
    2a16:	89 9f       	mul	r24, r25
    2a18:	f0 01       	movw	r30, r0
    2a1a:	11 24       	eor	r1, r1
    2a1c:	ec 51       	subi	r30, 0x1C	; 28
    2a1e:	fa 4f       	sbci	r31, 0xFA	; 250
    2a20:	80 81       	ld	r24, Z
    2a22:	82 30       	cpi	r24, 0x02	; 2
    2a24:	09 f0       	breq	.+2      	; 0x2a28 <DoSampler+0x6a6>
    2a26:	6d c1       	rjmp	.+730    	; 0x2d02 <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2a28:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2a2a:	12 86       	std	Z+10, r1	; 0x0a
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playback.
    2a2c:	16 82       	std	Z+6, r1	; 0x06
    2a2e:	69 c1       	rjmp	.+722    	; 0x2d02 <DoSampler+0x980>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    2a30:	80 91 66 05 	lds	r24, 0x0566
    2a34:	e0 91 63 05 	lds	r30, 0x0563
    2a38:	88 23       	and	r24, r24
    2a3a:	41 f0       	breq	.+16     	; 0x2a4c <DoSampler+0x6ca>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    2a3c:	2e e2       	ldi	r18, 0x2E	; 46
    2a3e:	e2 9f       	mul	r30, r18
    2a40:	f0 01       	movw	r30, r0
    2a42:	11 24       	eor	r1, r1
    2a44:	ec 51       	subi	r30, 0x1C	; 28
    2a46:	fa 4f       	sbci	r31, 0xFA	; 250
    2a48:	11 82       	std	Z+1, r1	; 0x01
    2a4a:	5b c1       	rjmp	.+694    	; 0x2d02 <DoSampler+0x980>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    2a4c:	4e e2       	ldi	r20, 0x2E	; 46
    2a4e:	e4 9f       	mul	r30, r20
    2a50:	f0 01       	movw	r30, r0
    2a52:	11 24       	eor	r1, r1
    2a54:	ec 51       	subi	r30, 0x1C	; 28
    2a56:	fa 4f       	sbci	r31, 0xFA	; 250
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	81 83       	std	Z+1, r24	; 0x01
    2a5c:	52 c1       	rjmp	.+676    	; 0x2d02 <DoSampler+0x980>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    2a5e:	80 91 66 05 	lds	r24, 0x0566
    2a62:	e0 91 63 05 	lds	r30, 0x0563
    2a66:	88 23       	and	r24, r24
    2a68:	49 f0       	breq	.+18     	; 0x2a7c <DoSampler+0x6fa>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    2a6a:	8e e2       	ldi	r24, 0x2E	; 46
    2a6c:	e8 9f       	mul	r30, r24
    2a6e:	f0 01       	movw	r30, r0
    2a70:	11 24       	eor	r1, r1
    2a72:	ec 51       	subi	r30, 0x1C	; 28
    2a74:	fa 4f       	sbci	r31, 0xFA	; 250
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	82 83       	std	Z+2, r24	; 0x02
    2a7a:	43 c1       	rjmp	.+646    	; 0x2d02 <DoSampler+0x980>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    2a7c:	9e e2       	ldi	r25, 0x2E	; 46
    2a7e:	e9 9f       	mul	r30, r25
    2a80:	f0 01       	movw	r30, r0
    2a82:	11 24       	eor	r1, r1
    2a84:	ec 51       	subi	r30, 0x1C	; 28
    2a86:	fa 4f       	sbci	r31, 0xFA	; 250
    2a88:	12 82       	std	Z+2, r1	; 0x02
    2a8a:	3b c1       	rjmp	.+630    	; 0x2d02 <DoSampler+0x980>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    2a8c:	80 91 66 05 	lds	r24, 0x0566
    2a90:	e0 91 63 05 	lds	r30, 0x0563
    2a94:	88 23       	and	r24, r24
    2a96:	49 f0       	breq	.+18     	; 0x2aaa <DoSampler+0x728>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    2a98:	2e e2       	ldi	r18, 0x2E	; 46
    2a9a:	e2 9f       	mul	r30, r18
    2a9c:	f0 01       	movw	r30, r0
    2a9e:	11 24       	eor	r1, r1
    2aa0:	ec 51       	subi	r30, 0x1C	; 28
    2aa2:	fa 4f       	sbci	r31, 0xFA	; 250
    2aa4:	81 e0       	ldi	r24, 0x01	; 1
    2aa6:	83 83       	std	Z+3, r24	; 0x03
    2aa8:	07 c0       	rjmp	.+14     	; 0x2ab8 <DoSampler+0x736>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    2aaa:	4e e2       	ldi	r20, 0x2E	; 46
    2aac:	e4 9f       	mul	r30, r20
    2aae:	f0 01       	movw	r30, r0
    2ab0:	11 24       	eor	r1, r1
    2ab2:	ec 51       	subi	r30, 0x1C	; 28
    2ab4:	fa 4f       	sbci	r31, 0xFA	; 250
    2ab6:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    2ab8:	80 91 63 05 	lds	r24, 0x0563
    2abc:	c6 c0       	rjmp	.+396    	; 0x2c4a <DoSampler+0x8c8>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    2abe:	e0 91 63 05 	lds	r30, 0x0563
    2ac2:	8e e2       	ldi	r24, 0x2E	; 46
    2ac4:	e8 9f       	mul	r30, r24
    2ac6:	f0 01       	movw	r30, r0
    2ac8:	11 24       	eor	r1, r1
    2aca:	ec 51       	subi	r30, 0x1C	; 28
    2acc:	fa 4f       	sbci	r31, 0xFA	; 250
    2ace:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    2ad0:	11 86       	std	Z+9, r1	; 0x09
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    2ad2:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    2ad4:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    2ad6:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    2ad8:	81 e0       	ldi	r24, 0x01	; 1
    2ada:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    2adc:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    2ade:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
    2ae0:	16 82       	std	Z+6, r1	; 0x06
    2ae2:	2d c0       	rjmp	.+90     	; 0x2b3e <DoSampler+0x7bc>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    2ae4:	80 91 66 05 	lds	r24, 0x0566
    2ae8:	88 30       	cpi	r24, 0x08	; 8
    2aea:	08 f0       	brcs	.+2      	; 0x2aee <DoSampler+0x76c>
    2aec:	0a c1       	rjmp	.+532    	; 0x2d02 <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
    2aee:	e0 91 63 05 	lds	r30, 0x0563
    2af2:	9e e2       	ldi	r25, 0x2E	; 46
    2af4:	e9 9f       	mul	r30, r25
    2af6:	f0 01       	movw	r30, r0
    2af8:	11 24       	eor	r1, r1
    2afa:	ec 51       	subi	r30, 0x1C	; 28
    2afc:	fa 4f       	sbci	r31, 0xFA	; 250
    2afe:	81 87       	std	Z+9, r24	; 0x09
    2b00:	00 c1       	rjmp	.+512    	; 0x2d02 <DoSampler+0x980>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    2b02:	60 91 66 05 	lds	r22, 0x0566
    2b06:	80 91 63 05 	lds	r24, 0x0563
    2b0a:	0e 94 94 05 	call	0xb28	; 0xb28 <MakeNewGranularArray>
					break;
    2b0e:	f9 c0       	rjmp	.+498    	; 0x2d02 <DoSampler+0x980>

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
    2b10:	e0 91 63 05 	lds	r30, 0x0563
    2b14:	80 91 66 05 	lds	r24, 0x0566
    2b18:	2e e2       	ldi	r18, 0x2E	; 46
    2b1a:	e2 9f       	mul	r30, r18
    2b1c:	f0 01       	movw	r30, r0
    2b1e:	11 24       	eor	r1, r1
    2b20:	ec 51       	subi	r30, 0x1C	; 28
    2b22:	fa 4f       	sbci	r31, 0xFA	; 250
    2b24:	80 87       	std	Z+8, r24	; 0x08
					break;
    2b26:	ed c0       	rjmp	.+474    	; 0x2d02 <DoSampler+0x980>

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    2b28:	80 91 66 05 	lds	r24, 0x0566
    2b2c:	81 30       	cpi	r24, 0x01	; 1
    2b2e:	51 f0       	breq	.+20     	; 0x2b44 <DoSampler+0x7c2>
    2b30:	30 f0       	brcs	.+12     	; 0x2b3e <DoSampler+0x7bc>
    2b32:	82 30       	cpi	r24, 0x02	; 2
    2b34:	71 f0       	breq	.+28     	; 0x2b52 <DoSampler+0x7d0>
    2b36:	83 30       	cpi	r24, 0x03	; 3
    2b38:	09 f0       	breq	.+2      	; 0x2b3c <DoSampler+0x7ba>
    2b3a:	e3 c0       	rjmp	.+454    	; 0x2d02 <DoSampler+0x980>
    2b3c:	0d c0       	rjmp	.+26     	; 0x2b58 <DoSampler+0x7d6>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2b3e:	87 e8       	ldi	r24, 0x87	; 135
    2b40:	94 e0       	ldi	r25, 0x04	; 4
    2b42:	02 c0       	rjmp	.+4      	; 0x2b48 <DoSampler+0x7c6>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2b44:	8b e3       	ldi	r24, 0x3B	; 59
    2b46:	94 e0       	ldi	r25, 0x04	; 4
    2b48:	90 93 e1 05 	sts	0x05E1, r25
    2b4c:	80 93 e0 05 	sts	0x05E0, r24
						break;
    2b50:	d8 c0       	rjmp	.+432    	; 0x2d02 <DoSampler+0x980>

						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2b52:	8a ef       	ldi	r24, 0xFA	; 250
    2b54:	94 e0       	ldi	r25, 0x04	; 4
    2b56:	f8 cf       	rjmp	.-16     	; 0x2b48 <DoSampler+0x7c6>
						break;

						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2b58:	8d eb       	ldi	r24, 0xBD	; 189
    2b5a:	94 e0       	ldi	r25, 0x04	; 4
    2b5c:	f5 cf       	rjmp	.-22     	; 0x2b48 <DoSampler+0x7c6>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
    2b5e:	1f b7       	in	r17, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    2b60:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    2b62:	50 91 63 05 	lds	r21, 0x0563
    2b66:	a5 2f       	mov	r26, r21
    2b68:	b0 e0       	ldi	r27, 0x00	; 0
    2b6a:	fd 01       	movw	r30, r26
    2b6c:	ec 5f       	subi	r30, 0xFC	; 252
    2b6e:	fe 4f       	sbci	r31, 0xFE	; 254
    2b70:	40 81       	ld	r20, Z
    2b72:	aa 0f       	add	r26, r26
    2b74:	bb 1f       	adc	r27, r27
    2b76:	a4 5a       	subi	r26, 0xA4	; 164
    2b78:	ba 4f       	sbci	r27, 0xFA	; 250
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2b7a:	84 2f       	mov	r24, r20
    2b7c:	6c e0       	ldi	r22, 0x0C	; 12
    2b7e:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2b82:	e9 2f       	mov	r30, r25
    2b84:	f0 e0       	ldi	r31, 0x00	; 0
    2b86:	ee 0f       	add	r30, r30
    2b88:	ff 1f       	adc	r31, r31
    2b8a:	ea 5f       	subi	r30, 0xFA	; 250
    2b8c:	fe 4f       	sbci	r31, 0xFE	; 254
    2b8e:	20 81       	ld	r18, Z
    2b90:	31 81       	ldd	r19, Z+1	; 0x01
    2b92:	02 c0       	rjmp	.+4      	; 0x2b98 <DoSampler+0x816>
    2b94:	36 95       	lsr	r19
    2b96:	27 95       	ror	r18
    2b98:	8a 95       	dec	r24
    2b9a:	e2 f7       	brpl	.-8      	; 0x2b94 <DoSampler+0x812>
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    2b9c:	2d 93       	st	X+, r18
    2b9e:	3c 93       	st	X, r19
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    2ba0:	51 11       	cpse	r21, r1
    2ba2:	04 c0       	rjmp	.+8      	; 0x2bac <DoSampler+0x82a>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    2ba4:	64 2f       	mov	r22, r20
    2ba6:	87 e0       	ldi	r24, 0x07	; 7
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	05 c0       	rjmp	.+10     	; 0x2bb6 <DoSampler+0x834>
	}
	else if(theBank==BANK_1)
    2bac:	51 30       	cpi	r21, 0x01	; 1
    2bae:	29 f4       	brne	.+10     	; 0x2bba <DoSampler+0x838>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    2bb0:	64 2f       	mov	r22, r20
    2bb2:	8b e0       	ldi	r24, 0x0B	; 11
    2bb4:	90 e0       	ldi	r25, 0x00	; 0
    2bb6:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=sreg;		// Re-enable interrupts.
    2bba:	1f bf       	out	0x3f, r17	; 63
					break;
    2bbc:	a2 c0       	rjmp	.+324    	; 0x2d02 <DoSampler+0x980>

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    2bbe:	90 91 66 05 	lds	r25, 0x0566
    2bc2:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2bc6:	4e e2       	ldi	r20, 0x2E	; 46
    2bc8:	84 9f       	mul	r24, r20
    2bca:	f0 01       	movw	r30, r0
    2bcc:	11 24       	eor	r1, r1
    2bce:	20 c0       	rjmp	.+64     	; 0x2c10 <DoSampler+0x88e>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    2bd0:	90 91 66 05 	lds	r25, 0x0566
    2bd4:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2bd8:	2e e2       	ldi	r18, 0x2E	; 46
    2bda:	82 9f       	mul	r24, r18
    2bdc:	f0 01       	movw	r30, r0
    2bde:	11 24       	eor	r1, r1
    2be0:	24 c0       	rjmp	.+72     	; 0x2c2a <DoSampler+0x8a8>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    2be2:	90 91 66 05 	lds	r25, 0x0566
    2be6:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    2bea:	4e e2       	ldi	r20, 0x2E	; 46
    2bec:	84 9f       	mul	r24, r20
    2bee:	f0 01       	movw	r30, r0
    2bf0:	11 24       	eor	r1, r1
    2bf2:	28 c0       	rjmp	.+80     	; 0x2c44 <DoSampler+0x8c2>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    2bf4:	80 91 63 05 	lds	r24, 0x0563
    2bf8:	0e 94 95 0a 	call	0x152a	; 0x152a <RevertSampleToUnadjusted>
					break;
    2bfc:	82 c0       	rjmp	.+260    	; 0x2d02 <DoSampler+0x980>

					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    2bfe:	90 91 66 05 	lds	r25, 0x0566
    2c02:	99 0f       	add	r25, r25
    2c04:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2c08:	2e e2       	ldi	r18, 0x2E	; 46
    2c0a:	82 9f       	mul	r24, r18
    2c0c:	f0 01       	movw	r30, r0
    2c0e:	11 24       	eor	r1, r1
    2c10:	ec 51       	subi	r30, 0x1C	; 28
    2c12:	fa 4f       	sbci	r31, 0xFA	; 250
    2c14:	95 8f       	std	Z+29, r25	; 0x1d
    2c16:	19 c0       	rjmp	.+50     	; 0x2c4a <DoSampler+0x8c8>
					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    2c18:	90 91 66 05 	lds	r25, 0x0566
    2c1c:	99 0f       	add	r25, r25
    2c1e:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2c22:	4e e2       	ldi	r20, 0x2E	; 46
    2c24:	84 9f       	mul	r24, r20
    2c26:	f0 01       	movw	r30, r0
    2c28:	11 24       	eor	r1, r1
    2c2a:	ec 51       	subi	r30, 0x1C	; 28
    2c2c:	fa 4f       	sbci	r31, 0xFA	; 250
    2c2e:	96 8f       	std	Z+30, r25	; 0x1e
    2c30:	0c c0       	rjmp	.+24     	; 0x2c4a <DoSampler+0x8c8>
					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    2c32:	90 91 66 05 	lds	r25, 0x0566
    2c36:	99 0f       	add	r25, r25
    2c38:	80 91 63 05 	lds	r24, 0x0563
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    2c3c:	2e e2       	ldi	r18, 0x2E	; 46
    2c3e:	82 9f       	mul	r24, r18
    2c40:	f0 01       	movw	r30, r0
    2c42:	11 24       	eor	r1, r1
    2c44:	ec 51       	subi	r30, 0x1C	; 28
    2c46:	fa 4f       	sbci	r31, 0xFA	; 250
    2c48:	97 8f       	std	Z+31, r25	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    2c4a:	0e 94 91 06 	call	0xd22	; 0xd22 <UpdateAdjustedSampleAddresses>
    2c4e:	59 c0       	rjmp	.+178    	; 0x2d02 <DoSampler+0x980>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    2c50:	87 30       	cpi	r24, 0x07	; 7
    2c52:	09 f0       	breq	.+2      	; 0x2c56 <DoSampler+0x8d4>
    2c54:	56 c0       	rjmp	.+172    	; 0x2d02 <DoSampler+0x980>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    2c56:	80 91 66 05 	lds	r24, 0x0566
    2c5a:	20 91 65 05 	lds	r18, 0x0565
    2c5e:	30 e0       	ldi	r19, 0x00	; 0
    2c60:	40 e8       	ldi	r20, 0x80	; 128
    2c62:	84 9f       	mul	r24, r20
    2c64:	20 0d       	add	r18, r0
    2c66:	31 1d       	adc	r19, r1
    2c68:	11 24       	eor	r1, r1
    2c6a:	a0 91 63 05 	lds	r26, 0x0563

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    2c6e:	21 15       	cp	r18, r1
    2c70:	80 e2       	ldi	r24, 0x20	; 32
    2c72:	38 07       	cpc	r19, r24
    2c74:	31 f1       	breq	.+76     	; 0x2cc2 <DoSampler+0x940>
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    2c76:	b0 e0       	ldi	r27, 0x00	; 0
    2c78:	fd 01       	movw	r30, r26
    2c7a:	ec 5f       	subi	r30, 0xFC	; 252
    2c7c:	fe 4f       	sbci	r31, 0xFE	; 254
    2c7e:	80 81       	ld	r24, Z
    2c80:	40 e0       	ldi	r20, 0x00	; 0
    2c82:	50 e2       	ldi	r21, 0x20	; 32
    2c84:	42 1b       	sub	r20, r18
    2c86:	53 0b       	sbc	r21, r19
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2c88:	6c e0       	ldi	r22, 0x0C	; 12
    2c8a:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2c8e:	e9 2f       	mov	r30, r25
    2c90:	f0 e0       	ldi	r31, 0x00	; 0
    2c92:	ee 0f       	add	r30, r30
    2c94:	ff 1f       	adc	r31, r31
    2c96:	ea 5f       	subi	r30, 0xFA	; 250
    2c98:	fe 4f       	sbci	r31, 0xFE	; 254
    2c9a:	20 81       	ld	r18, Z
    2c9c:	31 81       	ldd	r19, Z+1	; 0x01
    2c9e:	02 c0       	rjmp	.+4      	; 0x2ca4 <DoSampler+0x922>
    2ca0:	36 95       	lsr	r19
    2ca2:	27 95       	ror	r18
    2ca4:	8a 95       	dec	r24
    2ca6:	e2 f7       	brpl	.-8      	; 0x2ca0 <DoSampler+0x91e>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    2ca8:	42 0f       	add	r20, r18
    2caa:	53 1f       	adc	r21, r19
    2cac:	8e e2       	ldi	r24, 0x2E	; 46
    2cae:	8a 9f       	mul	r24, r26
    2cb0:	f0 01       	movw	r30, r0
    2cb2:	8b 9f       	mul	r24, r27
    2cb4:	f0 0d       	add	r31, r0
    2cb6:	11 24       	eor	r1, r1
    2cb8:	ec 51       	subi	r30, 0x1C	; 28
    2cba:	fa 4f       	sbci	r31, 0xFA	; 250
    2cbc:	54 87       	std	Z+12, r21	; 0x0c
    2cbe:	43 87       	std	Z+11, r20	; 0x0b
    2cc0:	20 c0       	rjmp	.+64     	; 0x2d02 <DoSampler+0x980>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    2cc2:	4a 2f       	mov	r20, r26
    2cc4:	50 e0       	ldi	r21, 0x00	; 0
    2cc6:	fa 01       	movw	r30, r20
    2cc8:	ec 5f       	subi	r30, 0xFC	; 252
    2cca:	fe 4f       	sbci	r31, 0xFE	; 254
    2ccc:	80 81       	ld	r24, Z
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2cce:	6c e0       	ldi	r22, 0x0C	; 12
    2cd0:	0e 94 16 2a 	call	0x542c	; 0x542c <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2cd4:	e9 2f       	mov	r30, r25
    2cd6:	f0 e0       	ldi	r31, 0x00	; 0
    2cd8:	ee 0f       	add	r30, r30
    2cda:	ff 1f       	adc	r31, r31
    2cdc:	ea 5f       	subi	r30, 0xFA	; 250
    2cde:	fe 4f       	sbci	r31, 0xFE	; 254
    2ce0:	20 81       	ld	r18, Z
    2ce2:	31 81       	ldd	r19, Z+1	; 0x01
    2ce4:	02 c0       	rjmp	.+4      	; 0x2cea <DoSampler+0x968>
    2ce6:	36 95       	lsr	r19
    2ce8:	27 95       	ror	r18
    2cea:	8a 95       	dec	r24
    2cec:	e2 f7       	brpl	.-8      	; 0x2ce6 <DoSampler+0x964>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    2cee:	8e e2       	ldi	r24, 0x2E	; 46
    2cf0:	84 9f       	mul	r24, r20
    2cf2:	f0 01       	movw	r30, r0
    2cf4:	85 9f       	mul	r24, r21
    2cf6:	f0 0d       	add	r31, r0
    2cf8:	11 24       	eor	r1, r1
    2cfa:	ec 51       	subi	r30, 0x1C	; 28
    2cfc:	fa 4f       	sbci	r31, 0xFA	; 250
    2cfe:	34 87       	std	Z+12, r19	; 0x0c
    2d00:	23 87       	std	Z+11, r18	; 0x0b
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    2d02:	80 91 4d 05 	lds	r24, 0x054D
    2d06:	83 30       	cpi	r24, 0x03	; 3
    2d08:	11 f0       	breq	.+4      	; 0x2d0e <DoSampler+0x98c>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    2d0a:	10 92 53 05 	sts	0x0553, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    2d0e:	80 91 ee 05 	lds	r24, 0x05EE
    2d12:	81 30       	cpi	r24, 0x01	; 1
    2d14:	41 f0       	breq	.+16     	; 0x2d26 <DoSampler+0x9a4>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    2d16:	10 92 67 05 	sts	0x0567, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    2d1a:	80 91 6f 00 	lds	r24, 0x006F
    2d1e:	8f 7d       	andi	r24, 0xDF	; 223
    2d20:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
    2d24:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    2d26:	80 91 1c 06 	lds	r24, 0x061C
    2d2a:	81 30       	cpi	r24, 0x01	; 1
    2d2c:	31 f0       	breq	.+12     	; 0x2d3a <DoSampler+0x9b8>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    2d2e:	10 92 42 04 	sts	0x0442, r1
		PCICR=0;			// No global PCINTS.
    2d32:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    2d36:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    2d3a:	80 91 ee 05 	lds	r24, 0x05EE
    2d3e:	82 30       	cpi	r24, 0x02	; 2
    2d40:	41 f0       	breq	.+16     	; 0x2d52 <DoSampler+0x9d0>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    2d42:	10 92 45 05 	sts	0x0545, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    2d46:	80 91 6f 00 	lds	r24, 0x006F
    2d4a:	8d 7f       	andi	r24, 0xFD	; 253
    2d4c:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
    2d50:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    2d52:	80 91 1c 06 	lds	r24, 0x061C
    2d56:	82 30       	cpi	r24, 0x02	; 2
    2d58:	41 f0       	breq	.+16     	; 0x2d6a <DoSampler+0x9e8>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    2d5a:	10 92 4a 05 	sts	0x054A, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    2d5e:	80 91 6f 00 	lds	r24, 0x006F
    2d62:	8b 7f       	andi	r24, 0xFB	; 251
    2d64:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
    2d68:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    2d6a:	80 91 ee 05 	lds	r24, 0x05EE
    2d6e:	81 11       	cpse	r24, r1
    2d70:	0c c0       	rjmp	.+24     	; 0x2d8a <DoSampler+0xa08>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    2d72:	80 91 4d 05 	lds	r24, 0x054D
    2d76:	88 23       	and	r24, r24
    2d78:	31 f0       	breq	.+12     	; 0x2d86 <DoSampler+0xa04>
    2d7a:	83 30       	cpi	r24, 0x03	; 3
    2d7c:	21 f0       	breq	.+8      	; 0x2d86 <DoSampler+0xa04>
    2d7e:	80 91 52 05 	lds	r24, 0x0552
    2d82:	81 11       	cpse	r24, r1
    2d84:	02 c0       	rjmp	.+4      	; 0x2d8a <DoSampler+0xa08>
		{
			bankStates[BANK_0].isLocked=false;
    2d86:	10 92 e9 05 	sts	0x05E9, r1
		}
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    2d8a:	80 91 1c 06 	lds	r24, 0x061C
    2d8e:	81 11       	cpse	r24, r1
    2d90:	0c c0       	rjmp	.+24     	; 0x2daa <DoSampler+0xa28>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    2d92:	80 91 4d 05 	lds	r24, 0x054D
    2d96:	88 23       	and	r24, r24
    2d98:	31 f0       	breq	.+12     	; 0x2da6 <DoSampler+0xa24>
    2d9a:	83 30       	cpi	r24, 0x03	; 3
    2d9c:	21 f0       	breq	.+8      	; 0x2da6 <DoSampler+0xa24>
    2d9e:	80 91 52 05 	lds	r24, 0x0552
    2da2:	81 30       	cpi	r24, 0x01	; 1
    2da4:	11 f4       	brne	.+4      	; 0x2daa <DoSampler+0xa28>
		{
			bankStates[BANK_1].isLocked=false;
    2da6:	10 92 17 06 	sts	0x0617, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    2daa:	80 91 6c 05 	lds	r24, 0x056C
    2dae:	82 95       	swap	r24
    2db0:	86 95       	lsr	r24
    2db2:	87 70       	andi	r24, 0x07	; 7
    2db4:	80 93 6b 05 	sts	0x056B, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    2db8:	20 91 5b 05 	lds	r18, 0x055B
    2dbc:	2f 71       	andi	r18, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    2dbe:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    2dc0:	20 68       	ori	r18, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    2dc2:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    2dc4:	20 64       	ori	r18, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    2dc6:	84 70       	andi	r24, 0x04	; 4
    2dc8:	09 f0       	breq	.+2      	; 0x2dcc <DoSampler+0xa4a>
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    2dca:	20 62       	ori	r18, 0x20	; 32
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    2dcc:	30 91 60 05 	lds	r19, 0x0560
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    2dd0:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    2dd2:	83 2f       	mov	r24, r19
    2dd4:	90 e0       	ldi	r25, 0x00	; 0
    2dd6:	4e e2       	ldi	r20, 0x2E	; 46
    2dd8:	34 9f       	mul	r19, r20
    2dda:	f0 01       	movw	r30, r0
    2ddc:	11 24       	eor	r1, r1
    2dde:	ec 51       	subi	r30, 0x1C	; 28
    2de0:	fa 4f       	sbci	r31, 0xFA	; 250
    2de2:	40 81       	ld	r20, Z
    2de4:	43 30       	cpi	r20, 0x03	; 3
    2de6:	09 f4       	brne	.+2      	; 0x2dea <DoSampler+0xa68>
	{
		temp|=Om_LED_REC;
    2de8:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    2dea:	4e e2       	ldi	r20, 0x2E	; 46
    2dec:	48 9f       	mul	r20, r24
    2dee:	f0 01       	movw	r30, r0
    2df0:	49 9f       	mul	r20, r25
    2df2:	f0 0d       	add	r31, r0
    2df4:	11 24       	eor	r1, r1
    2df6:	ec 51       	subi	r30, 0x1C	; 28
    2df8:	fa 4f       	sbci	r31, 0xFA	; 250
    2dfa:	40 81       	ld	r20, Z
    2dfc:	44 30       	cpi	r20, 0x04	; 4
    2dfe:	09 f4       	brne	.+2      	; 0x2e02 <DoSampler+0xa80>
	{
		temp|=Om_LED_PLAY;
    2e00:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    2e02:	4e e2       	ldi	r20, 0x2E	; 46
    2e04:	48 9f       	mul	r20, r24
    2e06:	f0 01       	movw	r30, r0
    2e08:	49 9f       	mul	r20, r25
    2e0a:	f0 0d       	add	r31, r0
    2e0c:	11 24       	eor	r1, r1
    2e0e:	ec 51       	subi	r30, 0x1C	; 28
    2e10:	fa 4f       	sbci	r31, 0xFA	; 250
    2e12:	40 81       	ld	r20, Z
    2e14:	45 30       	cpi	r20, 0x05	; 5
    2e16:	09 f4       	brne	.+2      	; 0x2e1a <DoSampler+0xa98>
	{
		temp|=Om_LED_ODUB;
    2e18:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    2e1a:	4e e2       	ldi	r20, 0x2E	; 46
    2e1c:	48 9f       	mul	r20, r24
    2e1e:	f0 01       	movw	r30, r0
    2e20:	49 9f       	mul	r20, r25
    2e22:	f0 0d       	add	r31, r0
    2e24:	11 24       	eor	r1, r1
    2e26:	ec 51       	subi	r30, 0x1C	; 28
    2e28:	fa 4f       	sbci	r31, 0xFA	; 250
    2e2a:	40 81       	ld	r20, Z
    2e2c:	42 30       	cpi	r20, 0x02	; 2
    2e2e:	09 f4       	brne	.+2      	; 0x2e32 <DoSampler+0xab0>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    2e30:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    2e32:	40 91 3f 04 	lds	r20, 0x043F
    2e36:	41 30       	cpi	r20, 0x01	; 1
    2e38:	09 f4       	brne	.+2      	; 0x2e3c <DoSampler+0xaba>
	{
		temp|=Om_LED_OUT_OF_MEM;
    2e3a:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    2e3c:	31 30       	cpi	r19, 0x01	; 1
    2e3e:	09 f4       	brne	.+2      	; 0x2e42 <DoSampler+0xac0>
	{
		temp|=Om_LED_BANK;
    2e40:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    2e42:	20 93 5b 05 	sts	0x055B, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    2e46:	2e e2       	ldi	r18, 0x2E	; 46
    2e48:	28 9f       	mul	r18, r24
    2e4a:	f0 01       	movw	r30, r0
    2e4c:	29 9f       	mul	r18, r25
    2e4e:	f0 0d       	add	r31, r0
    2e50:	11 24       	eor	r1, r1
    2e52:	ec 51       	subi	r30, 0x1C	; 28
    2e54:	fa 4f       	sbci	r31, 0xFA	; 250
    2e56:	41 89       	ldd	r20, Z+17	; 0x11
    2e58:	52 89       	ldd	r21, Z+18	; 0x12
    2e5a:	63 89       	ldd	r22, Z+19	; 0x13
    2e5c:	74 89       	ldd	r23, Z+20	; 0x14
    2e5e:	85 85       	ldd	r24, Z+13	; 0x0d
    2e60:	96 85       	ldd	r25, Z+14	; 0x0e
    2e62:	a7 85       	ldd	r26, Z+15	; 0x0f
    2e64:	b0 89       	ldd	r27, Z+16	; 0x10
    2e66:	48 17       	cp	r20, r24
    2e68:	59 07       	cpc	r21, r25
    2e6a:	6a 07       	cpc	r22, r26
    2e6c:	7b 07       	cpc	r23, r27
    2e6e:	81 f4       	brne	.+32     	; 0x2e90 <DoSampler+0xb0e>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    2e70:	80 91 ad 05 	lds	r24, 0x05AD
    2e74:	82 fd       	sbrc	r24, 2
    2e76:	16 c0       	rjmp	.+44     	; 0x2ea4 <DoSampler+0xb22>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    2e78:	84 e0       	ldi	r24, 0x04	; 4
    2e7a:	90 e0       	ldi	r25, 0x00	; 0

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    2e7c:	0f 90       	pop	r0
    2e7e:	df 91       	pop	r29
    2e80:	cf 91       	pop	r28
    2e82:	1f 91       	pop	r17
    2e84:	0f 91       	pop	r16
    2e86:	ff 90       	pop	r15
    2e88:	df 90       	pop	r13
    2e8a:	cf 90       	pop	r12

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    2e8c:	0c 94 b2 0a 	jmp	0x1564	; 0x1564 <BlinkLeds>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    2e90:	0f 90       	pop	r0
    2e92:	df 91       	pop	r29
    2e94:	cf 91       	pop	r28
    2e96:	1f 91       	pop	r17
    2e98:	0f 91       	pop	r16
    2e9a:	ff 90       	pop	r15
    2e9c:	df 90       	pop	r13
    2e9e:	cf 90       	pop	r12
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
		}
	}
	else
	{
		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we do.
    2ea0:	0c 94 e2 0a 	jmp	0x15c4	; 0x15c4 <StopBlinking>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    2ea4:	0f 90       	pop	r0
    2ea6:	df 91       	pop	r29
    2ea8:	cf 91       	pop	r28
    2eaa:	1f 91       	pop	r17
    2eac:	0f 91       	pop	r16
    2eae:	ff 90       	pop	r15
    2eb0:	df 90       	pop	r13
    2eb2:	cf 90       	pop	r12
    2eb4:	08 95       	ret

00002eb6 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    2eb6:	1f 92       	push	r1
    2eb8:	0f 92       	push	r0
    2eba:	0f b6       	in	r0, 0x3f	; 63
    2ebc:	0f 92       	push	r0
    2ebe:	11 24       	eor	r1, r1
    2ec0:	2f 93       	push	r18
    2ec2:	3f 93       	push	r19
    2ec4:	4f 93       	push	r20
    2ec6:	5f 93       	push	r21
    2ec8:	6f 93       	push	r22
    2eca:	7f 93       	push	r23
    2ecc:	8f 93       	push	r24
    2ece:	9f 93       	push	r25
    2ed0:	af 93       	push	r26
    2ed2:	bf 93       	push	r27
	// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)

	unsigned long
		theAddy;	// Using a local nonvolatile variable allows the compiler to be smarter about the address resolution and not load a 32-bit number every time.
		
	theAddy=bankStates[BANK_0].currentAddress;
    2ed4:	80 91 04 06 	lds	r24, 0x0604
    2ed8:	90 91 05 06 	lds	r25, 0x0605
    2edc:	a0 91 06 06 	lds	r26, 0x0606
    2ee0:	b0 91 07 06 	lds	r27, 0x0607

//	LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
//	LATCH_PORT=(unsigned char)theAddy;				// Put the LSB of the address on the latch.
	LATCH_PORT=theAddy;								// Put the LSB of the address on the latch.
    2ee4:	85 b9       	out	0x05, r24	; 5

	PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
    2ee6:	13 9a       	sbi	0x02, 3	; 2
	PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
    2ee8:	13 98       	cbi	0x02, 3	; 2

//	LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
//	LATCH_PORT=(unsigned char)(theAddy>>8);					// Put the LSB of the address on the latch.
	LATCH_PORT=(theAddy>>8);								// Put the LSB of the address on the latch.
    2eea:	49 2f       	mov	r20, r25
    2eec:	5a 2f       	mov	r21, r26
    2eee:	6b 2f       	mov	r22, r27
    2ef0:	77 27       	eor	r23, r23
    2ef2:	45 b9       	out	0x05, r20	; 5

	PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
    2ef4:	14 9a       	sbi	0x02, 4	; 2
	PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
    2ef6:	14 98       	cbi	0x02, 4	; 2

//	PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
	PORTC=(0x88|((unsigned char)(theAddy>>16)&0x07));				// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    2ef8:	8a 2f       	mov	r24, r26
    2efa:	87 70       	andi	r24, 0x07	; 7
    2efc:	88 68       	ori	r24, 0x88	; 136
    2efe:	88 b9       	out	0x08, r24	; 8

	LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    2f00:	14 b8       	out	0x04, r1	; 4
	PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    2f02:	12 98       	cbi	0x02, 2	; 2

	// Calculate new addy while data bus settles

	if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].targetAddress)		// Have we run through our entire sample or sample fragment?
    2f04:	40 91 04 06 	lds	r20, 0x0604
    2f08:	50 91 05 06 	lds	r21, 0x0605
    2f0c:	60 91 06 06 	lds	r22, 0x0606
    2f10:	70 91 07 06 	lds	r23, 0x0607
    2f14:	80 91 08 06 	lds	r24, 0x0608
    2f18:	90 91 09 06 	lds	r25, 0x0609
    2f1c:	a0 91 0a 06 	lds	r26, 0x060A
    2f20:	b0 91 0b 06 	lds	r27, 0x060B
    2f24:	48 17       	cp	r20, r24
    2f26:	59 07       	cpc	r21, r25
    2f28:	6a 07       	cpc	r22, r26
    2f2a:	7b 07       	cpc	r23, r27
    2f2c:	91 f4       	brne	.+36     	; 0x2f52 <__vector_12+0x9c>
	{
		if(bankStates[BANK_0].loopOnce==true)									// Yes, and we should be done now.
    2f2e:	80 91 e5 05 	lds	r24, 0x05E5
    2f32:	81 30       	cpi	r24, 0x01	; 1
    2f34:	29 f4       	brne	.+10     	; 0x2f40 <__vector_12+0x8a>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;
    2f36:	10 92 e4 05 	sts	0x05E4, r1
			bankStates[BANK_0].clockMode=CLK_NONE;		
    2f3a:	10 92 ee 05 	sts	0x05EE, r1
    2f3e:	24 c0       	rjmp	.+72     	; 0x2f88 <__vector_12+0xd2>
		}
		else
		{
			bankStates[BANK_0].currentAddress=bankStates[BANK_0].addressAfterLoop;		// We're at the end of the sample and we need to go back to the relative beginning of the sample.
    2f40:	80 91 0c 06 	lds	r24, 0x060C
    2f44:	90 91 0d 06 	lds	r25, 0x060D
    2f48:	a0 91 0e 06 	lds	r26, 0x060E
    2f4c:	b0 91 0f 06 	lds	r27, 0x060F
    2f50:	13 c0       	rjmp	.+38     	; 0x2f78 <__vector_12+0xc2>
		}
	}
	else
	{
		bankStates[BANK_0].currentAddress+=bankStates[BANK_0].sampleIncrement;			// "Increment" the sample address.  Note, this could be forward or backward and we must be sure not to skip the target address
    2f52:	40 91 04 06 	lds	r20, 0x0604
    2f56:	50 91 05 06 	lds	r21, 0x0605
    2f5a:	60 91 06 06 	lds	r22, 0x0606
    2f5e:	70 91 07 06 	lds	r23, 0x0607
    2f62:	80 91 11 06 	lds	r24, 0x0611
    2f66:	99 27       	eor	r25, r25
    2f68:	87 fd       	sbrc	r24, 7
    2f6a:	90 95       	com	r25
    2f6c:	a9 2f       	mov	r26, r25
    2f6e:	b9 2f       	mov	r27, r25
    2f70:	84 0f       	add	r24, r20
    2f72:	95 1f       	adc	r25, r21
    2f74:	a6 1f       	adc	r26, r22
    2f76:	b7 1f       	adc	r27, r23
    2f78:	80 93 04 06 	sts	0x0604, r24
    2f7c:	90 93 05 06 	sts	0x0605, r25
    2f80:	a0 93 06 06 	sts	0x0606, r26
    2f84:	b0 93 07 06 	sts	0x0607, r27
	}

	// Finish getting the byte from RAM.

	bankStates[BANK_0].dacOutput=LATCH_INPUT;		// Get the byte from this address in RAM.
    2f88:	83 b1       	in	r24, 0x03	; 3
    2f8a:	80 93 10 06 	sts	0x0610, r24
	PORTA|=(Om_RAM_OE);								// Tristate the RAM.
    2f8e:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    2f90:	8f ef       	ldi	r24, 0xFF	; 255
    2f92:	84 b9       	out	0x04, r24	; 4

	if(bankStates[BANK_0].bitReduction)	// Low bit rate?
    2f94:	80 91 ed 05 	lds	r24, 0x05ED
    2f98:	88 23       	and	r24, r24
    2f9a:	69 f0       	breq	.+26     	; 0x2fb6 <__vector_12+0x100>
	{
		// @@@ if you never change the top bit do you need to xor it off?
		// @@@ also, sanity check this

//		bankStates[BANK_0].dacOutput^=0x80;											// Bring the signed char back to unsigned for the bitmask.
		bankStates[BANK_0].dacOutput&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
    2f9c:	20 91 10 06 	lds	r18, 0x0610
    2fa0:	30 91 ed 05 	lds	r19, 0x05ED
    2fa4:	8f ef       	ldi	r24, 0xFF	; 255
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	01 c0       	rjmp	.+2      	; 0x2fac <__vector_12+0xf6>
    2faa:	88 0f       	add	r24, r24
    2fac:	3a 95       	dec	r19
    2fae:	ea f7       	brpl	.-6      	; 0x2faa <__vector_12+0xf4>
    2fb0:	28 23       	and	r18, r24
    2fb2:	20 93 10 06 	sts	0x0610, r18
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
	}
	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
*/
	PlayCallback(&bankStates[BANK_0]);
}
    2fb6:	bf 91       	pop	r27
    2fb8:	af 91       	pop	r26
    2fba:	9f 91       	pop	r25
    2fbc:	8f 91       	pop	r24
    2fbe:	7f 91       	pop	r23
    2fc0:	6f 91       	pop	r22
    2fc2:	5f 91       	pop	r21
    2fc4:	4f 91       	pop	r20
    2fc6:	3f 91       	pop	r19
    2fc8:	2f 91       	pop	r18
    2fca:	0f 90       	pop	r0
    2fcc:	0f be       	out	0x3f, r0	; 63
    2fce:	0f 90       	pop	r0
    2fd0:	1f 90       	pop	r1
    2fd2:	18 95       	reti

00002fd4 <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    2fd4:	1f 92       	push	r1
    2fd6:	0f 92       	push	r0
    2fd8:	0f b6       	in	r0, 0x3f	; 63
    2fda:	0f 92       	push	r0
    2fdc:	11 24       	eor	r1, r1
    2fde:	2f 93       	push	r18
    2fe0:	3f 93       	push	r19
    2fe2:	4f 93       	push	r20
    2fe4:	5f 93       	push	r21
    2fe6:	6f 93       	push	r22
    2fe8:	7f 93       	push	r23
    2fea:	8f 93       	push	r24
    2fec:	9f 93       	push	r25
    2fee:	af 93       	push	r26
    2ff0:	bf 93       	push	r27
    2ff2:	ef 93       	push	r30
    2ff4:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    2ff6:	80 91 14 06 	lds	r24, 0x0614
    2ffa:	88 23       	and	r24, r24
    2ffc:	41 f0       	breq	.+16     	; 0x300e <__vector_6+0x3a>
    2ffe:	80 91 14 06 	lds	r24, 0x0614
    3002:	88 23       	and	r24, r24
    3004:	41 f0       	breq	.+16     	; 0x3016 <__vector_6+0x42>
    3006:	80 91 41 04 	lds	r24, 0x0441
    300a:	88 23       	and	r24, r24
    300c:	21 f0       	breq	.+8      	; 0x3016 <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    300e:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel1>
    3012:	80 93 42 04 	sts	0x0442, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3016:	10 92 41 04 	sts	0x0441, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    301a:	e0 91 e0 05 	lds	r30, 0x05E0
    301e:	f0 91 e1 05 	lds	r31, 0x05E1
    3022:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3024:	80 91 7a 00 	lds	r24, 0x007A
    3028:	86 fd       	sbrc	r24, 6
    302a:	0a c0       	rjmp	.+20     	; 0x3040 <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    302c:	80 91 79 00 	lds	r24, 0x0079
    3030:	80 58       	subi	r24, 0x80	; 128
    3032:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3036:	80 91 7a 00 	lds	r24, 0x007A
    303a:	80 64       	ori	r24, 0x40	; 64
    303c:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    3040:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    3042:	ff 91       	pop	r31
    3044:	ef 91       	pop	r30
    3046:	bf 91       	pop	r27
    3048:	af 91       	pop	r26
    304a:	9f 91       	pop	r25
    304c:	8f 91       	pop	r24
    304e:	7f 91       	pop	r23
    3050:	6f 91       	pop	r22
    3052:	5f 91       	pop	r21
    3054:	4f 91       	pop	r20
    3056:	3f 91       	pop	r19
    3058:	2f 91       	pop	r18
    305a:	0f 90       	pop	r0
    305c:	0f be       	out	0x3f, r0	; 63
    305e:	0f 90       	pop	r0
    3060:	1f 90       	pop	r1
    3062:	18 95       	reti

00003064 <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    3064:	1f 92       	push	r1
    3066:	0f 92       	push	r0
    3068:	0f b6       	in	r0, 0x3f	; 63
    306a:	0f 92       	push	r0
    306c:	11 24       	eor	r1, r1
    306e:	0f 93       	push	r16
    3070:	1f 93       	push	r17
    3072:	2f 93       	push	r18
    3074:	3f 93       	push	r19
    3076:	4f 93       	push	r20
    3078:	5f 93       	push	r21
    307a:	6f 93       	push	r22
    307c:	7f 93       	push	r23
    307e:	8f 93       	push	r24
    3080:	9f 93       	push	r25
    3082:	af 93       	push	r26
    3084:	bf 93       	push	r27
    3086:	cf 93       	push	r28
    3088:	df 93       	push	r29
    308a:	ef 93       	push	r30
    308c:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    308e:	80 91 e6 05 	lds	r24, 0x05E6
    3092:	88 23       	and	r24, r24
    3094:	51 f0       	breq	.+20     	; 0x30aa <__vector_13+0x46>
    3096:	80 91 e6 05 	lds	r24, 0x05E6
    309a:	88 23       	and	r24, r24
    309c:	09 f4       	brne	.+2      	; 0x30a0 <__vector_13+0x3c>
    309e:	b4 c3       	rjmp	.+1896   	; 0x3808 <__vector_13+0x7a4>
    30a0:	80 91 44 05 	lds	r24, 0x0544
    30a4:	88 23       	and	r24, r24
    30a6:	09 f4       	brne	.+2      	; 0x30aa <__vector_13+0x46>
    30a8:	af c3       	rjmp	.+1886   	; 0x3808 <__vector_13+0x7a4>
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
    30aa:	80 91 e4 05 	lds	r24, 0x05E4
    30ae:	83 30       	cpi	r24, 0x03	; 3
    30b0:	c1 f0       	breq	.+48     	; 0x30e2 <__vector_13+0x7e>
    30b2:	30 f4       	brcc	.+12     	; 0x30c0 <__vector_13+0x5c>
    30b4:	81 30       	cpi	r24, 0x01	; 1
    30b6:	59 f0       	breq	.+22     	; 0x30ce <__vector_13+0x6a>
    30b8:	82 30       	cpi	r24, 0x02	; 2
    30ba:	09 f0       	breq	.+2      	; 0x30be <__vector_13+0x5a>
    30bc:	a2 c3       	rjmp	.+1860   	; 0x3802 <__vector_13+0x79e>
    30be:	0e c0       	rjmp	.+28     	; 0x30dc <__vector_13+0x78>
    30c0:	84 30       	cpi	r24, 0x04	; 4
    30c2:	09 f4       	brne	.+2      	; 0x30c6 <__vector_13+0x62>
    30c4:	8e c0       	rjmp	.+284    	; 0x31e2 <__vector_13+0x17e>
    30c6:	85 30       	cpi	r24, 0x05	; 5
    30c8:	09 f0       	breq	.+2      	; 0x30cc <__vector_13+0x68>
    30ca:	9b c3       	rjmp	.+1846   	; 0x3802 <__vector_13+0x79e>
    30cc:	07 c2       	rjmp	.+1038   	; 0x34dc <__vector_13+0x478>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
    30ce:	20 91 48 05 	lds	r18, 0x0548
    30d2:	82 2f       	mov	r24, r18
    30d4:	8f 5f       	subi	r24, 0xFF	; 255
    30d6:	80 93 48 05 	sts	0x0548, r24
    30da:	94 c3       	rjmp	.+1832   	; 0x3804 <__vector_13+0x7a0>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
    30dc:	20 91 2c 04 	lds	r18, 0x042C
    30e0:	eb c1       	rjmp	.+982    	; 0x34b8 <__vector_13+0x454>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
    30e2:	8f ef       	ldi	r24, 0xFF	; 255
    30e4:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
    30e6:	80 91 04 06 	lds	r24, 0x0604
    30ea:	90 91 05 06 	lds	r25, 0x0605
    30ee:	a0 91 06 06 	lds	r26, 0x0606
    30f2:	b0 91 07 06 	lds	r27, 0x0607
    30f6:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
    30f8:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
    30fa:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
    30fc:	80 91 04 06 	lds	r24, 0x0604
    3100:	90 91 05 06 	lds	r25, 0x0605
    3104:	a0 91 06 06 	lds	r26, 0x0606
    3108:	b0 91 07 06 	lds	r27, 0x0607
    310c:	89 2f       	mov	r24, r25
    310e:	9a 2f       	mov	r25, r26
    3110:	ab 2f       	mov	r26, r27
    3112:	bb 27       	eor	r27, r27
    3114:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
    3116:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
    3118:	14 98       	cbi	0x02, 4	; 2
		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    311a:	80 91 04 06 	lds	r24, 0x0604
    311e:	90 91 05 06 	lds	r25, 0x0605
    3122:	a0 91 06 06 	lds	r26, 0x0606
    3126:	b0 91 07 06 	lds	r27, 0x0607
    312a:	cd 01       	movw	r24, r26
    312c:	aa 27       	eor	r26, r26
    312e:	bb 27       	eor	r27, r27
    3130:	87 70       	andi	r24, 0x07	; 7
    3132:	99 27       	eor	r25, r25
    3134:	aa 27       	eor	r26, r26
    3136:	bb 27       	eor	r27, r27
    3138:	88 68       	ori	r24, 0x88	; 136
    313a:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
    313c:	80 91 2c 04 	lds	r24, 0x042C
    3140:	85 b9       	out	0x05, r24	; 5
		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
    3142:	80 91 04 06 	lds	r24, 0x0604
    3146:	90 91 05 06 	lds	r25, 0x0605
    314a:	a0 91 06 06 	lds	r26, 0x0606
    314e:	b0 91 07 06 	lds	r27, 0x0607
    3152:	01 96       	adiw	r24, 0x01	; 1
    3154:	a1 1d       	adc	r26, r1
    3156:	b1 1d       	adc	r27, r1
    3158:	80 93 04 06 	sts	0x0604, r24
    315c:	90 93 05 06 	sts	0x0605, r25
    3160:	a0 93 06 06 	sts	0x0606, r26
    3164:	b0 93 07 06 	sts	0x0607, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
    3168:	80 91 04 06 	lds	r24, 0x0604
    316c:	90 91 05 06 	lds	r25, 0x0605
    3170:	a0 91 06 06 	lds	r26, 0x0606
    3174:	b0 91 07 06 	lds	r27, 0x0607
    3178:	80 93 f1 05 	sts	0x05F1, r24
    317c:	90 93 f2 05 	sts	0x05F2, r25
    3180:	a0 93 f3 05 	sts	0x05F3, r26
    3184:	b0 93 f4 05 	sts	0x05F4, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3188:	80 91 04 06 	lds	r24, 0x0604
    318c:	90 91 05 06 	lds	r25, 0x0605
    3190:	a0 91 06 06 	lds	r26, 0x0606
    3194:	b0 91 07 06 	lds	r27, 0x0607
    3198:	80 93 f9 05 	sts	0x05F9, r24
    319c:	90 93 fa 05 	sts	0x05FA, r25
    31a0:	a0 93 fb 05 	sts	0x05FB, r26
    31a4:	b0 93 fc 05 	sts	0x05FC, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
    31a8:	40 91 f1 05 	lds	r20, 0x05F1
    31ac:	50 91 f2 05 	lds	r21, 0x05F2
    31b0:	60 91 f3 05 	lds	r22, 0x05F3
    31b4:	70 91 f4 05 	lds	r23, 0x05F4
    31b8:	80 91 1f 06 	lds	r24, 0x061F
    31bc:	90 91 20 06 	lds	r25, 0x0620
    31c0:	a0 91 21 06 	lds	r26, 0x0621
    31c4:	b0 91 22 06 	lds	r27, 0x0622
    31c8:	48 17       	cp	r20, r24
    31ca:	59 07       	cpc	r21, r25
    31cc:	6a 07       	cpc	r22, r26
    31ce:	7b 07       	cpc	r23, r27
    31d0:	28 f0       	brcs	.+10     	; 0x31dc <__vector_13+0x178>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
    31d2:	10 92 e4 05 	sts	0x05E4, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
    31d6:	81 e0       	ldi	r24, 0x01	; 1
    31d8:	80 93 3f 04 	sts	0x043F, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    31dc:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
    31de:	11 9a       	sbi	0x02, 1	; 2
    31e0:	10 c3       	rjmp	.+1568   	; 0x3802 <__vector_13+0x79e>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
    31e2:	80 91 04 06 	lds	r24, 0x0604
    31e6:	90 91 05 06 	lds	r25, 0x0605
    31ea:	a0 91 06 06 	lds	r26, 0x0606
    31ee:	b0 91 07 06 	lds	r27, 0x0607
    31f2:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
    31f4:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
    31f6:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
    31f8:	80 91 04 06 	lds	r24, 0x0604
    31fc:	90 91 05 06 	lds	r25, 0x0605
    3200:	a0 91 06 06 	lds	r26, 0x0606
    3204:	b0 91 07 06 	lds	r27, 0x0607
    3208:	89 2f       	mov	r24, r25
    320a:	9a 2f       	mov	r25, r26
    320c:	ab 2f       	mov	r26, r27
    320e:	bb 27       	eor	r27, r27
    3210:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
    3212:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
    3214:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3216:	80 91 04 06 	lds	r24, 0x0604
    321a:	90 91 05 06 	lds	r25, 0x0605
    321e:	a0 91 06 06 	lds	r26, 0x0606
    3222:	b0 91 07 06 	lds	r27, 0x0607
    3226:	cd 01       	movw	r24, r26
    3228:	aa 27       	eor	r26, r26
    322a:	bb 27       	eor	r27, r27
    322c:	87 70       	andi	r24, 0x07	; 7
    322e:	99 27       	eor	r25, r25
    3230:	aa 27       	eor	r26, r26
    3232:	bb 27       	eor	r27, r27
    3234:	88 68       	ori	r24, 0x88	; 136
    3236:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    3238:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    323a:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
    323c:	80 91 eb 05 	lds	r24, 0x05EB
    3240:	88 23       	and	r24, r24
    3242:	09 f4       	brne	.+2      	; 0x3246 <__vector_13+0x1e2>
    3244:	6a c0       	rjmp	.+212    	; 0x331a <__vector_13+0x2b6>
		{
			// Slice first, only worry about forward ### @@@

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
    3246:	80 91 2d 04 	lds	r24, 0x042D
    324a:	90 91 2e 04 	lds	r25, 0x042E
    324e:	a0 91 2f 04 	lds	r26, 0x042F
    3252:	b0 91 30 04 	lds	r27, 0x0430
    3256:	89 2b       	or	r24, r25
    3258:	8a 2b       	or	r24, r26
    325a:	8b 2b       	or	r24, r27
    325c:	39 f1       	breq	.+78     	; 0x32ac <__vector_13+0x248>
			{
				bankStates[BANK_0].currentAddress++;
    325e:	80 91 04 06 	lds	r24, 0x0604
    3262:	90 91 05 06 	lds	r25, 0x0605
    3266:	a0 91 06 06 	lds	r26, 0x0606
    326a:	b0 91 07 06 	lds	r27, 0x0607
    326e:	01 96       	adiw	r24, 0x01	; 1
    3270:	a1 1d       	adc	r26, r1
    3272:	b1 1d       	adc	r27, r1
    3274:	80 93 04 06 	sts	0x0604, r24
    3278:	90 93 05 06 	sts	0x0605, r25
    327c:	a0 93 06 06 	sts	0x0606, r26
    3280:	b0 93 07 06 	sts	0x0607, r27
				sliceRemaining[BANK_0]--;
    3284:	80 91 2d 04 	lds	r24, 0x042D
    3288:	90 91 2e 04 	lds	r25, 0x042E
    328c:	a0 91 2f 04 	lds	r26, 0x042F
    3290:	b0 91 30 04 	lds	r27, 0x0430
    3294:	01 97       	sbiw	r24, 0x01	; 1
    3296:	a1 09       	sbc	r26, r1
    3298:	b1 09       	sbc	r27, r1
    329a:	80 93 2d 04 	sts	0x042D, r24
    329e:	90 93 2e 04 	sts	0x042E, r25
    32a2:	a0 93 2f 04 	sts	0x042F, r26
    32a6:	b0 93 30 04 	sts	0x0430, r27
    32aa:	02 c1       	rjmp	.+516    	; 0x34b0 <__vector_13+0x44c>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
    32ac:	80 91 35 04 	lds	r24, 0x0435
    32b0:	90 91 36 04 	lds	r25, 0x0436
    32b4:	a0 91 37 04 	lds	r26, 0x0437
    32b8:	b0 91 38 04 	lds	r27, 0x0438
    32bc:	80 93 2d 04 	sts	0x042D, r24
    32c0:	90 93 2e 04 	sts	0x042E, r25
    32c4:	a0 93 2f 04 	sts	0x042F, r26
    32c8:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
    32cc:	80 91 3d 04 	lds	r24, 0x043D
    32d0:	8f 5f       	subi	r24, 0xFF	; 255
    32d2:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
    32d6:	90 91 3d 04 	lds	r25, 0x043D
    32da:	80 91 eb 05 	lds	r24, 0x05EB
    32de:	98 13       	cpse	r25, r24
    32e0:	02 c0       	rjmp	.+4      	; 0x32e6 <__vector_13+0x282>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
    32e2:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    32e6:	e0 91 3d 04 	lds	r30, 0x043D
    32ea:	20 91 35 04 	lds	r18, 0x0435
    32ee:	30 91 36 04 	lds	r19, 0x0436
    32f2:	40 91 37 04 	lds	r20, 0x0437
    32f6:	50 91 38 04 	lds	r21, 0x0438
    32fa:	f0 e0       	ldi	r31, 0x00	; 0
    32fc:	ec 5b       	subi	r30, 0xBC	; 188
    32fe:	fb 4f       	sbci	r31, 0xFB	; 251
    3300:	a0 81       	ld	r26, Z
    3302:	b0 e0       	ldi	r27, 0x00	; 0
    3304:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
    3308:	60 93 04 06 	sts	0x0604, r22
    330c:	70 93 05 06 	sts	0x0605, r23
    3310:	80 93 06 06 	sts	0x0606, r24
    3314:	90 93 07 06 	sts	0x0607, r25
    3318:	cb c0       	rjmp	.+406    	; 0x34b0 <__vector_13+0x44c>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
    331a:	80 91 e8 05 	lds	r24, 0x05E8
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    331e:	40 91 04 06 	lds	r20, 0x0604
    3322:	50 91 05 06 	lds	r21, 0x0605
    3326:	60 91 06 06 	lds	r22, 0x0606
    332a:	70 91 07 06 	lds	r23, 0x0607
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
    332e:	81 11       	cpse	r24, r1
    3330:	5a c0       	rjmp	.+180    	; 0x33e6 <__vector_13+0x382>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    3332:	80 91 fd 05 	lds	r24, 0x05FD
    3336:	90 91 fe 05 	lds	r25, 0x05FE
    333a:	a0 91 ff 05 	lds	r26, 0x05FF
    333e:	b0 91 00 06 	lds	r27, 0x0600
    3342:	48 17       	cp	r20, r24
    3344:	59 07       	cpc	r21, r25
    3346:	6a 07       	cpc	r22, r26
    3348:	7b 07       	cpc	r23, r27
    334a:	29 f4       	brne	.+10     	; 0x3356 <__vector_13+0x2f2>
    334c:	80 91 e5 05 	lds	r24, 0x05E5
    3350:	81 30       	cpi	r24, 0x01	; 1
    3352:	09 f4       	brne	.+2      	; 0x3356 <__vector_13+0x2f2>
    3354:	59 c0       	rjmp	.+178    	; 0x3408 <__vector_13+0x3a4>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
    3356:	40 91 04 06 	lds	r20, 0x0604
    335a:	50 91 05 06 	lds	r21, 0x0605
    335e:	60 91 06 06 	lds	r22, 0x0606
    3362:	70 91 07 06 	lds	r23, 0x0607
    3366:	80 91 fd 05 	lds	r24, 0x05FD
    336a:	90 91 fe 05 	lds	r25, 0x05FE
    336e:	a0 91 ff 05 	lds	r26, 0x05FF
    3372:	b0 91 00 06 	lds	r27, 0x0600
    3376:	48 17       	cp	r20, r24
    3378:	59 07       	cpc	r21, r25
    337a:	6a 07       	cpc	r22, r26
    337c:	7b 07       	cpc	r23, r27
    337e:	49 f4       	brne	.+18     	; 0x3392 <__vector_13+0x32e>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
    3380:	80 91 f9 05 	lds	r24, 0x05F9
    3384:	90 91 fa 05 	lds	r25, 0x05FA
    3388:	a0 91 fb 05 	lds	r26, 0x05FB
    338c:	b0 91 fc 05 	lds	r27, 0x05FC
    3390:	87 c0       	rjmp	.+270    	; 0x34a0 <__vector_13+0x43c>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
    3392:	40 91 04 06 	lds	r20, 0x0604
    3396:	50 91 05 06 	lds	r21, 0x0605
    339a:	60 91 06 06 	lds	r22, 0x0606
    339e:	70 91 07 06 	lds	r23, 0x0607
    33a2:	80 91 f5 05 	lds	r24, 0x05F5
    33a6:	90 91 f6 05 	lds	r25, 0x05F6
    33aa:	a0 91 f7 05 	lds	r26, 0x05F7
    33ae:	b0 91 f8 05 	lds	r27, 0x05F8
    33b2:	48 17       	cp	r20, r24
    33b4:	59 07       	cpc	r21, r25
    33b6:	6a 07       	cpc	r22, r26
    33b8:	7b 07       	cpc	r23, r27
    33ba:	49 f4       	brne	.+18     	; 0x33ce <__vector_13+0x36a>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
    33bc:	80 91 f1 05 	lds	r24, 0x05F1
    33c0:	90 91 f2 05 	lds	r25, 0x05F2
    33c4:	a0 91 f3 05 	lds	r26, 0x05F3
    33c8:	b0 91 f4 05 	lds	r27, 0x05F4
    33cc:	69 c0       	rjmp	.+210    	; 0x34a0 <__vector_13+0x43c>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
    33ce:	80 91 04 06 	lds	r24, 0x0604
    33d2:	90 91 05 06 	lds	r25, 0x0605
    33d6:	a0 91 06 06 	lds	r26, 0x0606
    33da:	b0 91 07 06 	lds	r27, 0x0607
    33de:	01 97       	sbiw	r24, 0x01	; 1
    33e0:	a1 09       	sbc	r26, r1
    33e2:	b1 09       	sbc	r27, r1
    33e4:	5d c0       	rjmp	.+186    	; 0x34a0 <__vector_13+0x43c>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
    33e6:	80 91 f9 05 	lds	r24, 0x05F9
    33ea:	90 91 fa 05 	lds	r25, 0x05FA
    33ee:	a0 91 fb 05 	lds	r26, 0x05FB
    33f2:	b0 91 fc 05 	lds	r27, 0x05FC
    33f6:	48 17       	cp	r20, r24
    33f8:	59 07       	cpc	r21, r25
    33fa:	6a 07       	cpc	r22, r26
    33fc:	7b 07       	cpc	r23, r27
    33fe:	49 f4       	brne	.+18     	; 0x3412 <__vector_13+0x3ae>
    3400:	80 91 e5 05 	lds	r24, 0x05E5
    3404:	81 30       	cpi	r24, 0x01	; 1
    3406:	29 f4       	brne	.+10     	; 0x3412 <__vector_13+0x3ae>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
    3408:	10 92 e4 05 	sts	0x05E4, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
    340c:	10 92 ee 05 	sts	0x05EE, r1
    3410:	4f c0       	rjmp	.+158    	; 0x34b0 <__vector_13+0x44c>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
    3412:	40 91 04 06 	lds	r20, 0x0604
    3416:	50 91 05 06 	lds	r21, 0x0605
    341a:	60 91 06 06 	lds	r22, 0x0606
    341e:	70 91 07 06 	lds	r23, 0x0607
    3422:	80 91 f9 05 	lds	r24, 0x05F9
    3426:	90 91 fa 05 	lds	r25, 0x05FA
    342a:	a0 91 fb 05 	lds	r26, 0x05FB
    342e:	b0 91 fc 05 	lds	r27, 0x05FC
    3432:	48 17       	cp	r20, r24
    3434:	59 07       	cpc	r21, r25
    3436:	6a 07       	cpc	r22, r26
    3438:	7b 07       	cpc	r23, r27
    343a:	49 f4       	brne	.+18     	; 0x344e <__vector_13+0x3ea>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
    343c:	80 91 fd 05 	lds	r24, 0x05FD
    3440:	90 91 fe 05 	lds	r25, 0x05FE
    3444:	a0 91 ff 05 	lds	r26, 0x05FF
    3448:	b0 91 00 06 	lds	r27, 0x0600
    344c:	29 c0       	rjmp	.+82     	; 0x34a0 <__vector_13+0x43c>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
    344e:	40 91 04 06 	lds	r20, 0x0604
    3452:	50 91 05 06 	lds	r21, 0x0605
    3456:	60 91 06 06 	lds	r22, 0x0606
    345a:	70 91 07 06 	lds	r23, 0x0607
    345e:	80 91 f1 05 	lds	r24, 0x05F1
    3462:	90 91 f2 05 	lds	r25, 0x05F2
    3466:	a0 91 f3 05 	lds	r26, 0x05F3
    346a:	b0 91 f4 05 	lds	r27, 0x05F4
    346e:	48 17       	cp	r20, r24
    3470:	59 07       	cpc	r21, r25
    3472:	6a 07       	cpc	r22, r26
    3474:	7b 07       	cpc	r23, r27
    3476:	49 f4       	brne	.+18     	; 0x348a <__vector_13+0x426>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
    3478:	80 91 f5 05 	lds	r24, 0x05F5
    347c:	90 91 f6 05 	lds	r25, 0x05F6
    3480:	a0 91 f7 05 	lds	r26, 0x05F7
    3484:	b0 91 f8 05 	lds	r27, 0x05F8
    3488:	0b c0       	rjmp	.+22     	; 0x34a0 <__vector_13+0x43c>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
    348a:	80 91 04 06 	lds	r24, 0x0604
    348e:	90 91 05 06 	lds	r25, 0x0605
    3492:	a0 91 06 06 	lds	r26, 0x0606
    3496:	b0 91 07 06 	lds	r27, 0x0607
    349a:	01 96       	adiw	r24, 0x01	; 1
    349c:	a1 1d       	adc	r26, r1
    349e:	b1 1d       	adc	r27, r1
    34a0:	80 93 04 06 	sts	0x0604, r24
    34a4:	90 93 05 06 	sts	0x0605, r25
    34a8:	a0 93 06 06 	sts	0x0606, r26
    34ac:	b0 93 07 06 	sts	0x0607, r27
			}
		}

		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    34b0:	23 b1       	in	r18, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    34b2:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    34b4:	8f ef       	ldi	r24, 0xFF	; 255
    34b6:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
    34b8:	80 91 ed 05 	lds	r24, 0x05ED
    34bc:	88 23       	and	r24, r24
    34be:	09 f4       	brne	.+2      	; 0x34c2 <__vector_13+0x45e>
    34c0:	a1 c1       	rjmp	.+834    	; 0x3804 <__vector_13+0x7a0>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
    34c2:	20 58       	subi	r18, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
    34c4:	30 91 ed 05 	lds	r19, 0x05ED
    34c8:	8f ef       	ldi	r24, 0xFF	; 255
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	03 2e       	mov	r0, r19
    34ce:	01 c0       	rjmp	.+2      	; 0x34d2 <__vector_13+0x46e>
    34d0:	88 0f       	add	r24, r24
    34d2:	0a 94       	dec	r0
    34d4:	ea f7       	brpl	.-6      	; 0x34d0 <__vector_13+0x46c>
    34d6:	28 23       	and	r18, r24
			outputByte^=0x80;											// Bring it back to signed.
    34d8:	20 58       	subi	r18, 0x80	; 128
    34da:	94 c1       	rjmp	.+808    	; 0x3804 <__vector_13+0x7a0>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
    34dc:	80 91 04 06 	lds	r24, 0x0604
    34e0:	90 91 05 06 	lds	r25, 0x0605
    34e4:	a0 91 06 06 	lds	r26, 0x0606
    34e8:	b0 91 07 06 	lds	r27, 0x0607
    34ec:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
    34ee:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
    34f0:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
    34f2:	80 91 04 06 	lds	r24, 0x0604
    34f6:	90 91 05 06 	lds	r25, 0x0605
    34fa:	a0 91 06 06 	lds	r26, 0x0606
    34fe:	b0 91 07 06 	lds	r27, 0x0607
    3502:	89 2f       	mov	r24, r25
    3504:	9a 2f       	mov	r25, r26
    3506:	ab 2f       	mov	r26, r27
    3508:	bb 27       	eor	r27, r27
    350a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
    350c:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
    350e:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3510:	80 91 04 06 	lds	r24, 0x0604
    3514:	90 91 05 06 	lds	r25, 0x0605
    3518:	a0 91 06 06 	lds	r26, 0x0606
    351c:	b0 91 07 06 	lds	r27, 0x0607
    3520:	cd 01       	movw	r24, r26
    3522:	aa 27       	eor	r26, r26
    3524:	bb 27       	eor	r27, r27
    3526:	87 70       	andi	r24, 0x07	; 7
    3528:	99 27       	eor	r25, r25
    352a:	aa 27       	eor	r26, r26
    352c:	bb 27       	eor	r27, r27
    352e:	88 68       	ori	r24, 0x88	; 136
    3530:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    3532:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    3534:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
    3536:	80 91 eb 05 	lds	r24, 0x05EB
    353a:	88 23       	and	r24, r24
    353c:	09 f4       	brne	.+2      	; 0x3540 <__vector_13+0x4dc>
    353e:	6a c0       	rjmp	.+212    	; 0x3614 <__vector_13+0x5b0>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
    3540:	80 91 2d 04 	lds	r24, 0x042D
    3544:	90 91 2e 04 	lds	r25, 0x042E
    3548:	a0 91 2f 04 	lds	r26, 0x042F
    354c:	b0 91 30 04 	lds	r27, 0x0430
    3550:	89 2b       	or	r24, r25
    3552:	8a 2b       	or	r24, r26
    3554:	8b 2b       	or	r24, r27
    3556:	39 f1       	breq	.+78     	; 0x35a6 <__vector_13+0x542>
			{
				bankStates[BANK_0].currentAddress++;
    3558:	80 91 04 06 	lds	r24, 0x0604
    355c:	90 91 05 06 	lds	r25, 0x0605
    3560:	a0 91 06 06 	lds	r26, 0x0606
    3564:	b0 91 07 06 	lds	r27, 0x0607
    3568:	01 96       	adiw	r24, 0x01	; 1
    356a:	a1 1d       	adc	r26, r1
    356c:	b1 1d       	adc	r27, r1
    356e:	80 93 04 06 	sts	0x0604, r24
    3572:	90 93 05 06 	sts	0x0605, r25
    3576:	a0 93 06 06 	sts	0x0606, r26
    357a:	b0 93 07 06 	sts	0x0607, r27
				sliceRemaining[BANK_0]--;
    357e:	80 91 2d 04 	lds	r24, 0x042D
    3582:	90 91 2e 04 	lds	r25, 0x042E
    3586:	a0 91 2f 04 	lds	r26, 0x042F
    358a:	b0 91 30 04 	lds	r27, 0x0430
    358e:	01 97       	sbiw	r24, 0x01	; 1
    3590:	a1 09       	sbc	r26, r1
    3592:	b1 09       	sbc	r27, r1
    3594:	80 93 2d 04 	sts	0x042D, r24
    3598:	90 93 2e 04 	sts	0x042E, r25
    359c:	a0 93 2f 04 	sts	0x042F, r26
    35a0:	b0 93 30 04 	sts	0x0430, r27
    35a4:	02 c1       	rjmp	.+516    	; 0x37aa <__vector_13+0x746>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
    35a6:	80 91 35 04 	lds	r24, 0x0435
    35aa:	90 91 36 04 	lds	r25, 0x0436
    35ae:	a0 91 37 04 	lds	r26, 0x0437
    35b2:	b0 91 38 04 	lds	r27, 0x0438
    35b6:	80 93 2d 04 	sts	0x042D, r24
    35ba:	90 93 2e 04 	sts	0x042E, r25
    35be:	a0 93 2f 04 	sts	0x042F, r26
    35c2:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
    35c6:	80 91 3d 04 	lds	r24, 0x043D
    35ca:	8f 5f       	subi	r24, 0xFF	; 255
    35cc:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
    35d0:	90 91 3d 04 	lds	r25, 0x043D
    35d4:	80 91 eb 05 	lds	r24, 0x05EB
    35d8:	98 13       	cpse	r25, r24
    35da:	02 c0       	rjmp	.+4      	; 0x35e0 <__vector_13+0x57c>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
    35dc:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    35e0:	e0 91 3d 04 	lds	r30, 0x043D
    35e4:	20 91 35 04 	lds	r18, 0x0435
    35e8:	30 91 36 04 	lds	r19, 0x0436
    35ec:	40 91 37 04 	lds	r20, 0x0437
    35f0:	50 91 38 04 	lds	r21, 0x0438
    35f4:	f0 e0       	ldi	r31, 0x00	; 0
    35f6:	ec 5b       	subi	r30, 0xBC	; 188
    35f8:	fb 4f       	sbci	r31, 0xFB	; 251
    35fa:	a0 81       	ld	r26, Z
    35fc:	b0 e0       	ldi	r27, 0x00	; 0
    35fe:	0e 94 56 2a 	call	0x54ac	; 0x54ac <__muluhisi3>
    3602:	60 93 04 06 	sts	0x0604, r22
    3606:	70 93 05 06 	sts	0x0605, r23
    360a:	80 93 06 06 	sts	0x0606, r24
    360e:	90 93 07 06 	sts	0x0607, r25
    3612:	cb c0       	rjmp	.+406    	; 0x37aa <__vector_13+0x746>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
    3614:	80 91 e8 05 	lds	r24, 0x05E8
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    3618:	40 91 04 06 	lds	r20, 0x0604
    361c:	50 91 05 06 	lds	r21, 0x0605
    3620:	60 91 06 06 	lds	r22, 0x0606
    3624:	70 91 07 06 	lds	r23, 0x0607
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
    3628:	81 11       	cpse	r24, r1
    362a:	5a c0       	rjmp	.+180    	; 0x36e0 <__vector_13+0x67c>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    362c:	80 91 fd 05 	lds	r24, 0x05FD
    3630:	90 91 fe 05 	lds	r25, 0x05FE
    3634:	a0 91 ff 05 	lds	r26, 0x05FF
    3638:	b0 91 00 06 	lds	r27, 0x0600
    363c:	48 17       	cp	r20, r24
    363e:	59 07       	cpc	r21, r25
    3640:	6a 07       	cpc	r22, r26
    3642:	7b 07       	cpc	r23, r27
    3644:	29 f4       	brne	.+10     	; 0x3650 <__vector_13+0x5ec>
    3646:	80 91 e5 05 	lds	r24, 0x05E5
    364a:	81 30       	cpi	r24, 0x01	; 1
    364c:	09 f4       	brne	.+2      	; 0x3650 <__vector_13+0x5ec>
    364e:	59 c0       	rjmp	.+178    	; 0x3702 <__vector_13+0x69e>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
    3650:	40 91 04 06 	lds	r20, 0x0604
    3654:	50 91 05 06 	lds	r21, 0x0605
    3658:	60 91 06 06 	lds	r22, 0x0606
    365c:	70 91 07 06 	lds	r23, 0x0607
    3660:	80 91 fd 05 	lds	r24, 0x05FD
    3664:	90 91 fe 05 	lds	r25, 0x05FE
    3668:	a0 91 ff 05 	lds	r26, 0x05FF
    366c:	b0 91 00 06 	lds	r27, 0x0600
    3670:	48 17       	cp	r20, r24
    3672:	59 07       	cpc	r21, r25
    3674:	6a 07       	cpc	r22, r26
    3676:	7b 07       	cpc	r23, r27
    3678:	49 f4       	brne	.+18     	; 0x368c <__vector_13+0x628>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
    367a:	80 91 f9 05 	lds	r24, 0x05F9
    367e:	90 91 fa 05 	lds	r25, 0x05FA
    3682:	a0 91 fb 05 	lds	r26, 0x05FB
    3686:	b0 91 fc 05 	lds	r27, 0x05FC
    368a:	87 c0       	rjmp	.+270    	; 0x379a <__vector_13+0x736>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
    368c:	40 91 04 06 	lds	r20, 0x0604
    3690:	50 91 05 06 	lds	r21, 0x0605
    3694:	60 91 06 06 	lds	r22, 0x0606
    3698:	70 91 07 06 	lds	r23, 0x0607
    369c:	80 91 f5 05 	lds	r24, 0x05F5
    36a0:	90 91 f6 05 	lds	r25, 0x05F6
    36a4:	a0 91 f7 05 	lds	r26, 0x05F7
    36a8:	b0 91 f8 05 	lds	r27, 0x05F8
    36ac:	48 17       	cp	r20, r24
    36ae:	59 07       	cpc	r21, r25
    36b0:	6a 07       	cpc	r22, r26
    36b2:	7b 07       	cpc	r23, r27
    36b4:	49 f4       	brne	.+18     	; 0x36c8 <__vector_13+0x664>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
    36b6:	80 91 f1 05 	lds	r24, 0x05F1
    36ba:	90 91 f2 05 	lds	r25, 0x05F2
    36be:	a0 91 f3 05 	lds	r26, 0x05F3
    36c2:	b0 91 f4 05 	lds	r27, 0x05F4
    36c6:	69 c0       	rjmp	.+210    	; 0x379a <__vector_13+0x736>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
    36c8:	80 91 04 06 	lds	r24, 0x0604
    36cc:	90 91 05 06 	lds	r25, 0x0605
    36d0:	a0 91 06 06 	lds	r26, 0x0606
    36d4:	b0 91 07 06 	lds	r27, 0x0607
    36d8:	01 97       	sbiw	r24, 0x01	; 1
    36da:	a1 09       	sbc	r26, r1
    36dc:	b1 09       	sbc	r27, r1
    36de:	5d c0       	rjmp	.+186    	; 0x379a <__vector_13+0x736>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
    36e0:	80 91 f9 05 	lds	r24, 0x05F9
    36e4:	90 91 fa 05 	lds	r25, 0x05FA
    36e8:	a0 91 fb 05 	lds	r26, 0x05FB
    36ec:	b0 91 fc 05 	lds	r27, 0x05FC
    36f0:	48 17       	cp	r20, r24
    36f2:	59 07       	cpc	r21, r25
    36f4:	6a 07       	cpc	r22, r26
    36f6:	7b 07       	cpc	r23, r27
    36f8:	49 f4       	brne	.+18     	; 0x370c <__vector_13+0x6a8>
    36fa:	80 91 e5 05 	lds	r24, 0x05E5
    36fe:	81 30       	cpi	r24, 0x01	; 1
    3700:	29 f4       	brne	.+10     	; 0x370c <__vector_13+0x6a8>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
    3702:	10 92 e4 05 	sts	0x05E4, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
    3706:	10 92 ee 05 	sts	0x05EE, r1
    370a:	4f c0       	rjmp	.+158    	; 0x37aa <__vector_13+0x746>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
    370c:	40 91 04 06 	lds	r20, 0x0604
    3710:	50 91 05 06 	lds	r21, 0x0605
    3714:	60 91 06 06 	lds	r22, 0x0606
    3718:	70 91 07 06 	lds	r23, 0x0607
    371c:	80 91 f9 05 	lds	r24, 0x05F9
    3720:	90 91 fa 05 	lds	r25, 0x05FA
    3724:	a0 91 fb 05 	lds	r26, 0x05FB
    3728:	b0 91 fc 05 	lds	r27, 0x05FC
    372c:	48 17       	cp	r20, r24
    372e:	59 07       	cpc	r21, r25
    3730:	6a 07       	cpc	r22, r26
    3732:	7b 07       	cpc	r23, r27
    3734:	49 f4       	brne	.+18     	; 0x3748 <__vector_13+0x6e4>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
    3736:	80 91 fd 05 	lds	r24, 0x05FD
    373a:	90 91 fe 05 	lds	r25, 0x05FE
    373e:	a0 91 ff 05 	lds	r26, 0x05FF
    3742:	b0 91 00 06 	lds	r27, 0x0600
    3746:	29 c0       	rjmp	.+82     	; 0x379a <__vector_13+0x736>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
    3748:	40 91 04 06 	lds	r20, 0x0604
    374c:	50 91 05 06 	lds	r21, 0x0605
    3750:	60 91 06 06 	lds	r22, 0x0606
    3754:	70 91 07 06 	lds	r23, 0x0607
    3758:	80 91 f1 05 	lds	r24, 0x05F1
    375c:	90 91 f2 05 	lds	r25, 0x05F2
    3760:	a0 91 f3 05 	lds	r26, 0x05F3
    3764:	b0 91 f4 05 	lds	r27, 0x05F4
    3768:	48 17       	cp	r20, r24
    376a:	59 07       	cpc	r21, r25
    376c:	6a 07       	cpc	r22, r26
    376e:	7b 07       	cpc	r23, r27
    3770:	49 f4       	brne	.+18     	; 0x3784 <__vector_13+0x720>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
    3772:	80 91 f5 05 	lds	r24, 0x05F5
    3776:	90 91 f6 05 	lds	r25, 0x05F6
    377a:	a0 91 f7 05 	lds	r26, 0x05F7
    377e:	b0 91 f8 05 	lds	r27, 0x05F8
    3782:	0b c0       	rjmp	.+22     	; 0x379a <__vector_13+0x736>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
    3784:	80 91 04 06 	lds	r24, 0x0604
    3788:	90 91 05 06 	lds	r25, 0x0605
    378c:	a0 91 06 06 	lds	r26, 0x0606
    3790:	b0 91 07 06 	lds	r27, 0x0607
    3794:	01 96       	adiw	r24, 0x01	; 1
    3796:	a1 1d       	adc	r26, r1
    3798:	b1 1d       	adc	r27, r1
    379a:	80 93 04 06 	sts	0x0604, r24
    379e:	90 93 05 06 	sts	0x0605, r25
    37a2:	a0 93 06 06 	sts	0x0606, r26
    37a6:	b0 93 07 06 	sts	0x0607, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
    37aa:	23 b1       	in	r18, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    37ac:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    37ae:	8f ef       	ldi	r24, 0xFF	; 255
    37b0:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
    37b2:	80 91 ed 05 	lds	r24, 0x05ED
    37b6:	88 23       	and	r24, r24
    37b8:	61 f0       	breq	.+24     	; 0x37d2 <__vector_13+0x76e>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
    37ba:	20 58       	subi	r18, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
    37bc:	30 91 ed 05 	lds	r19, 0x05ED
    37c0:	8f ef       	ldi	r24, 0xFF	; 255
    37c2:	90 e0       	ldi	r25, 0x00	; 0
    37c4:	03 2e       	mov	r0, r19
    37c6:	01 c0       	rjmp	.+2      	; 0x37ca <__vector_13+0x766>
    37c8:	88 0f       	add	r24, r24
    37ca:	0a 94       	dec	r0
    37cc:	ea f7       	brpl	.-6      	; 0x37c8 <__vector_13+0x764>
    37ce:	28 23       	and	r18, r24
			outputByte^=0x80;											// Bring it back to signed.
    37d0:	20 58       	subi	r18, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
    37d2:	80 91 2c 04 	lds	r24, 0x042C
    37d6:	99 27       	eor	r25, r25
    37d8:	87 fd       	sbrc	r24, 7
    37da:	90 95       	com	r25
    37dc:	82 0f       	add	r24, r18
    37de:	91 1d       	adc	r25, r1
    37e0:	27 fd       	sbrc	r18, 7
    37e2:	9a 95       	dec	r25
    37e4:	80 38       	cpi	r24, 0x80	; 128
    37e6:	3f ef       	ldi	r19, 0xFF	; 255
    37e8:	93 07       	cpc	r25, r19
    37ea:	14 f4       	brge	.+4      	; 0x37f0 <__vector_13+0x78c>
    37ec:	80 e8       	ldi	r24, 0x80	; 128
    37ee:	9f ef       	ldi	r25, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
    37f0:	80 38       	cpi	r24, 0x80	; 128
    37f2:	91 05       	cpc	r25, r1
    37f4:	14 f0       	brlt	.+4      	; 0x37fa <__vector_13+0x796>
    37f6:	8f e7       	ldi	r24, 0x7F	; 127
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
    37fc:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
    37fe:	11 9a       	sbi	0x02, 1	; 2
    3800:	01 c0       	rjmp	.+2      	; 0x3804 <__vector_13+0x7a0>
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
    3802:	20 e0       	ldi	r18, 0x00	; 0

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    3804:	20 93 45 05 	sts	0x0545, r18
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    3808:	80 91 ec 05 	lds	r24, 0x05EC
    380c:	88 23       	and	r24, r24
    380e:	a1 f1       	breq	.+104    	; 0x3878 <__vector_13+0x814>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    3810:	a0 91 ec 05 	lds	r26, 0x05EC
    3814:	20 91 ef 05 	lds	r18, 0x05EF
    3818:	30 91 f0 05 	lds	r19, 0x05F0
    381c:	b0 e0       	ldi	r27, 0x00	; 0
    381e:	0e 94 4a 2a 	call	0x5494	; 0x5494 <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    3822:	2f e7       	ldi	r18, 0x7F	; 127
    3824:	30 e0       	ldi	r19, 0x00	; 0
    3826:	40 e0       	ldi	r20, 0x00	; 0
    3828:	50 e0       	ldi	r21, 0x00	; 0
    382a:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    382e:	00 91 88 00 	lds	r16, 0x0088
    3832:	10 91 89 00 	lds	r17, 0x0089
    3836:	c0 91 ef 05 	lds	r28, 0x05EF
    383a:	d0 91 f0 05 	lds	r29, 0x05F0
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    383e:	60 91 00 01 	lds	r22, 0x0100
    3842:	70 91 01 01 	lds	r23, 0x0101
    3846:	80 91 02 01 	lds	r24, 0x0102
    384a:	90 91 03 01 	lds	r25, 0x0103
    384e:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    3852:	c0 0f       	add	r28, r16
    3854:	d1 1f       	adc	r29, r17
    3856:	40 91 46 05 	lds	r20, 0x0546
    385a:	50 91 47 05 	lds	r21, 0x0547
    385e:	c4 0f       	add	r28, r20
    3860:	d5 1f       	adc	r29, r21
    3862:	c6 1b       	sub	r28, r22
    3864:	d7 0b       	sbc	r29, r23
    3866:	d0 93 89 00 	sts	0x0089, r29
    386a:	c0 93 88 00 	sts	0x0088, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    386e:	70 93 47 05 	sts	0x0547, r23
    3872:	60 93 46 05 	sts	0x0546, r22
    3876:	0e c0       	rjmp	.+28     	; 0x3894 <__vector_13+0x830>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    3878:	20 91 88 00 	lds	r18, 0x0088
    387c:	30 91 89 00 	lds	r19, 0x0089
    3880:	80 91 ef 05 	lds	r24, 0x05EF
    3884:	90 91 f0 05 	lds	r25, 0x05F0
    3888:	82 0f       	add	r24, r18
    388a:	93 1f       	adc	r25, r19
    388c:	90 93 89 00 	sts	0x0089, r25
    3890:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3894:	10 92 44 05 	sts	0x0544, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3898:	e0 91 e0 05 	lds	r30, 0x05E0
    389c:	f0 91 e1 05 	lds	r31, 0x05E1
    38a0:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    38a2:	80 91 7a 00 	lds	r24, 0x007A
    38a6:	86 fd       	sbrc	r24, 6
    38a8:	0a c0       	rjmp	.+20     	; 0x38be <__vector_13+0x85a>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    38aa:	80 91 79 00 	lds	r24, 0x0079
    38ae:	80 58       	subi	r24, 0x80	; 128
    38b0:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    38b4:	80 91 7a 00 	lds	r24, 0x007A
    38b8:	80 64       	ori	r24, 0x40	; 64
    38ba:	80 93 7a 00 	sts	0x007A, r24
	}
}
    38be:	ff 91       	pop	r31
    38c0:	ef 91       	pop	r30
    38c2:	df 91       	pop	r29
    38c4:	cf 91       	pop	r28
    38c6:	bf 91       	pop	r27
    38c8:	af 91       	pop	r26
    38ca:	9f 91       	pop	r25
    38cc:	8f 91       	pop	r24
    38ce:	7f 91       	pop	r23
    38d0:	6f 91       	pop	r22
    38d2:	5f 91       	pop	r21
    38d4:	4f 91       	pop	r20
    38d6:	3f 91       	pop	r19
    38d8:	2f 91       	pop	r18
    38da:	1f 91       	pop	r17
    38dc:	0f 91       	pop	r16
    38de:	0f 90       	pop	r0
    38e0:	0f be       	out	0x3f, r0	; 63
    38e2:	0f 90       	pop	r0
    38e4:	1f 90       	pop	r1
    38e6:	18 95       	reti

000038e8 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    38e8:	1f 92       	push	r1
    38ea:	0f 92       	push	r0
    38ec:	0f b6       	in	r0, 0x3f	; 63
    38ee:	0f 92       	push	r0
    38f0:	11 24       	eor	r1, r1
    38f2:	0f 93       	push	r16
    38f4:	1f 93       	push	r17
    38f6:	2f 93       	push	r18
    38f8:	3f 93       	push	r19
    38fa:	4f 93       	push	r20
    38fc:	5f 93       	push	r21
    38fe:	6f 93       	push	r22
    3900:	7f 93       	push	r23
    3902:	8f 93       	push	r24
    3904:	9f 93       	push	r25
    3906:	af 93       	push	r26
    3908:	bf 93       	push	r27
    390a:	cf 93       	push	r28
    390c:	df 93       	push	r29
    390e:	ef 93       	push	r30
    3910:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3912:	80 91 14 06 	lds	r24, 0x0614
    3916:	88 23       	and	r24, r24
    3918:	41 f0       	breq	.+16     	; 0x392a <__vector_14+0x42>
    391a:	80 91 14 06 	lds	r24, 0x0614
    391e:	88 23       	and	r24, r24
    3920:	41 f0       	breq	.+16     	; 0x3932 <__vector_14+0x4a>
    3922:	80 91 49 05 	lds	r24, 0x0549
    3926:	88 23       	and	r24, r24
    3928:	21 f0       	breq	.+8      	; 0x3932 <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    392a:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel1>
    392e:	80 93 4a 05 	sts	0x054A, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    3932:	80 91 1a 06 	lds	r24, 0x061A
    3936:	88 23       	and	r24, r24
    3938:	a1 f1       	breq	.+104    	; 0x39a2 <__vector_14+0xba>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    393a:	a0 91 1a 06 	lds	r26, 0x061A
    393e:	20 91 1d 06 	lds	r18, 0x061D
    3942:	30 91 1e 06 	lds	r19, 0x061E
    3946:	b0 e0       	ldi	r27, 0x00	; 0
    3948:	0e 94 4a 2a 	call	0x5494	; 0x5494 <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    394c:	2f e7       	ldi	r18, 0x7F	; 127
    394e:	30 e0       	ldi	r19, 0x00	; 0
    3950:	40 e0       	ldi	r20, 0x00	; 0
    3952:	50 e0       	ldi	r21, 0x00	; 0
    3954:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    3958:	00 91 8a 00 	lds	r16, 0x008A
    395c:	10 91 8b 00 	lds	r17, 0x008B
    3960:	c0 91 1d 06 	lds	r28, 0x061D
    3964:	d0 91 1e 06 	lds	r29, 0x061E
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    3968:	60 91 00 01 	lds	r22, 0x0100
    396c:	70 91 01 01 	lds	r23, 0x0101
    3970:	80 91 02 01 	lds	r24, 0x0102
    3974:	90 91 03 01 	lds	r25, 0x0103
    3978:	0e 94 22 2a 	call	0x5444	; 0x5444 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    397c:	c0 0f       	add	r28, r16
    397e:	d1 1f       	adc	r29, r17
    3980:	40 91 4b 05 	lds	r20, 0x054B
    3984:	50 91 4c 05 	lds	r21, 0x054C
    3988:	c4 0f       	add	r28, r20
    398a:	d5 1f       	adc	r29, r21
    398c:	c6 1b       	sub	r28, r22
    398e:	d7 0b       	sbc	r29, r23
    3990:	d0 93 8b 00 	sts	0x008B, r29
    3994:	c0 93 8a 00 	sts	0x008A, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    3998:	70 93 4c 05 	sts	0x054C, r23
    399c:	60 93 4b 05 	sts	0x054B, r22
    39a0:	0e c0       	rjmp	.+28     	; 0x39be <__vector_14+0xd6>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    39a2:	20 91 8a 00 	lds	r18, 0x008A
    39a6:	30 91 8b 00 	lds	r19, 0x008B
    39aa:	80 91 1d 06 	lds	r24, 0x061D
    39ae:	90 91 1e 06 	lds	r25, 0x061E
    39b2:	82 0f       	add	r24, r18
    39b4:	93 1f       	adc	r25, r19
    39b6:	90 93 8b 00 	sts	0x008B, r25
    39ba:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    39be:	10 92 49 05 	sts	0x0549, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    39c2:	e0 91 e0 05 	lds	r30, 0x05E0
    39c6:	f0 91 e1 05 	lds	r31, 0x05E1
    39ca:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    39cc:	80 91 7a 00 	lds	r24, 0x007A
    39d0:	86 fd       	sbrc	r24, 6
    39d2:	0a c0       	rjmp	.+20     	; 0x39e8 <__vector_14+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    39d4:	80 91 79 00 	lds	r24, 0x0079
    39d8:	80 58       	subi	r24, 0x80	; 128
    39da:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    39de:	80 91 7a 00 	lds	r24, 0x007A
    39e2:	80 64       	ori	r24, 0x40	; 64
    39e4:	80 93 7a 00 	sts	0x007A, r24
	}
}
    39e8:	ff 91       	pop	r31
    39ea:	ef 91       	pop	r30
    39ec:	df 91       	pop	r29
    39ee:	cf 91       	pop	r28
    39f0:	bf 91       	pop	r27
    39f2:	af 91       	pop	r26
    39f4:	9f 91       	pop	r25
    39f6:	8f 91       	pop	r24
    39f8:	7f 91       	pop	r23
    39fa:	6f 91       	pop	r22
    39fc:	5f 91       	pop	r21
    39fe:	4f 91       	pop	r20
    3a00:	3f 91       	pop	r19
    3a02:	2f 91       	pop	r18
    3a04:	1f 91       	pop	r17
    3a06:	0f 91       	pop	r16
    3a08:	0f 90       	pop	r0
    3a0a:	0f be       	out	0x3f, r0	; 63
    3a0c:	0f 90       	pop	r0
    3a0e:	1f 90       	pop	r1
    3a10:	18 95       	reti

00003a12 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    3a12:	1f 92       	push	r1
    3a14:	0f 92       	push	r0
    3a16:	0f b6       	in	r0, 0x3f	; 63
    3a18:	0f 92       	push	r0
    3a1a:	11 24       	eor	r1, r1
    3a1c:	2f 93       	push	r18
    3a1e:	3f 93       	push	r19
    3a20:	4f 93       	push	r20
    3a22:	5f 93       	push	r21
    3a24:	6f 93       	push	r22
    3a26:	7f 93       	push	r23
    3a28:	8f 93       	push	r24
    3a2a:	9f 93       	push	r25
    3a2c:	af 93       	push	r26
    3a2e:	bf 93       	push	r27
    3a30:	ef 93       	push	r30
    3a32:	ff 93       	push	r31
	unsigned char
		theByte;

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    3a34:	80 91 4d 05 	lds	r24, 0x054D
    3a38:	81 30       	cpi	r24, 0x01	; 1
    3a3a:	09 f0       	breq	.+2      	; 0x3a3e <__vector_10+0x2c>
    3a3c:	be c0       	rjmp	.+380    	; 0x3bba <__vector_10+0x1a8>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    3a3e:	80 91 22 01 	lds	r24, 0x0122
    3a42:	90 91 23 01 	lds	r25, 0x0123
    3a46:	a0 91 24 01 	lds	r26, 0x0124
    3a4a:	b0 91 25 01 	lds	r27, 0x0125
    3a4e:	89 2b       	or	r24, r25
    3a50:	8a 2b       	or	r24, r26
    3a52:	8b 2b       	or	r24, r27
    3a54:	09 f4       	brne	.+2      	; 0x3a58 <__vector_10+0x46>
    3a56:	76 c0       	rjmp	.+236    	; 0x3b44 <__vector_10+0x132>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3a58:	80 91 26 01 	lds	r24, 0x0126
    3a5c:	90 91 27 01 	lds	r25, 0x0127
    3a60:	89 2b       	or	r24, r25
    3a62:	09 f4       	brne	.+2      	; 0x3a66 <__vector_10+0x54>
    3a64:	a6 c1       	rjmp	.+844    	; 0x3db2 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3a66:	e0 91 2a 01 	lds	r30, 0x012A
    3a6a:	f0 91 2b 01 	lds	r31, 0x012B
    3a6e:	e4 5d       	subi	r30, 0xD4	; 212
    3a70:	fe 4f       	sbci	r31, 0xFE	; 254
    3a72:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3a74:	80 91 2a 01 	lds	r24, 0x012A
    3a78:	90 91 2b 01 	lds	r25, 0x012B
    3a7c:	01 96       	adiw	r24, 0x01	; 1
    3a7e:	90 93 2b 01 	sts	0x012B, r25
    3a82:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3a86:	80 91 2a 01 	lds	r24, 0x012A
    3a8a:	90 91 2b 01 	lds	r25, 0x012B
    3a8e:	81 15       	cp	r24, r1
    3a90:	93 40       	sbci	r25, 0x03	; 3
    3a92:	20 f0       	brcs	.+8      	; 0x3a9c <__vector_10+0x8a>
				{
					sdFifoReadPointer=0;
    3a94:	10 92 2b 01 	sts	0x012B, r1
    3a98:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3a9c:	80 91 26 01 	lds	r24, 0x0126
    3aa0:	90 91 27 01 	lds	r25, 0x0127
    3aa4:	01 97       	sbiw	r24, 0x01	; 1
    3aa6:	90 93 27 01 	sts	0x0127, r25
    3aaa:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3aae:	80 91 22 01 	lds	r24, 0x0122
    3ab2:	90 91 23 01 	lds	r25, 0x0123
    3ab6:	a0 91 24 01 	lds	r26, 0x0124
    3aba:	b0 91 25 01 	lds	r27, 0x0125
    3abe:	01 97       	sbiw	r24, 0x01	; 1
    3ac0:	a1 09       	sbc	r26, r1
    3ac2:	b1 09       	sbc	r27, r1
    3ac4:	80 93 22 01 	sts	0x0122, r24
    3ac8:	90 93 23 01 	sts	0x0123, r25
    3acc:	a0 93 24 01 	sts	0x0124, r26
    3ad0:	b0 93 25 01 	sts	0x0125, r27

				// Now put this byte into the RAM bank in the correct address.

				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    3ad4:	8f ef       	ldi	r24, 0xFF	; 255
    3ad6:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    3ad8:	80 91 4e 05 	lds	r24, 0x054E
    3adc:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    3ade:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    3ae0:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    3ae2:	40 91 4e 05 	lds	r20, 0x054E
    3ae6:	50 91 4f 05 	lds	r21, 0x054F
    3aea:	60 91 50 05 	lds	r22, 0x0550
    3aee:	70 91 51 05 	lds	r23, 0x0551
    3af2:	bb 27       	eor	r27, r27
    3af4:	a7 2f       	mov	r26, r23
    3af6:	96 2f       	mov	r25, r22
    3af8:	85 2f       	mov	r24, r21
    3afa:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    3afc:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    3afe:	14 98       	cbi	0x02, 4	; 2
				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3b00:	cb 01       	movw	r24, r22
    3b02:	aa 27       	eor	r26, r26
    3b04:	bb 27       	eor	r27, r27
    3b06:	87 70       	andi	r24, 0x07	; 7
    3b08:	99 27       	eor	r25, r25
    3b0a:	aa 27       	eor	r26, r26
    3b0c:	bb 27       	eor	r27, r27
    3b0e:	88 68       	ori	r24, 0x88	; 136
    3b10:	88 b9       	out	0x08, r24	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    3b12:	25 b9       	out	0x05, r18	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    3b14:	80 91 52 05 	lds	r24, 0x0552
    3b18:	81 30       	cpi	r24, 0x01	; 1
    3b1a:	29 f4       	brne	.+10     	; 0x3b26 <__vector_10+0x114>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    3b1c:	4f 5f       	subi	r20, 0xFF	; 255
    3b1e:	5f 4f       	sbci	r21, 0xFF	; 255
    3b20:	6f 4f       	sbci	r22, 0xFF	; 255
    3b22:	7f 4f       	sbci	r23, 0xFF	; 255
    3b24:	04 c0       	rjmp	.+8      	; 0x3b2e <__vector_10+0x11c>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3b26:	41 50       	subi	r20, 0x01	; 1
    3b28:	51 09       	sbc	r21, r1
    3b2a:	61 09       	sbc	r22, r1
    3b2c:	71 09       	sbc	r23, r1
    3b2e:	40 93 4e 05 	sts	0x054E, r20
    3b32:	50 93 4f 05 	sts	0x054F, r21
    3b36:	60 93 50 05 	sts	0x0550, r22
    3b3a:	70 93 51 05 	sts	0x0551, r23
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    3b3e:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    3b40:	11 9a       	sbi	0x02, 1	; 2
    3b42:	37 c1       	rjmp	.+622    	; 0x3db2 <__vector_10+0x3a0>

			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3b44:	10 92 4d 05 	sts	0x054D, r1
			TCCR2B=0;					// Stop this timer
    3b48:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3b4c:	80 91 70 00 	lds	r24, 0x0070
    3b50:	8b 7f       	andi	r24, 0xFB	; 251
    3b52:	80 93 70 00 	sts	0x0070, r24

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    3b56:	20 91 52 05 	lds	r18, 0x0552
    3b5a:	80 91 4e 05 	lds	r24, 0x054E
    3b5e:	90 91 4f 05 	lds	r25, 0x054F
    3b62:	a0 91 50 05 	lds	r26, 0x0550
    3b66:	b0 91 51 05 	lds	r27, 0x0551
    3b6a:	21 30       	cpi	r18, 0x01	; 1
    3b6c:	99 f4       	brne	.+38     	; 0x3b94 <__vector_10+0x182>
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    3b6e:	10 92 e9 05 	sts	0x05E9, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3b72:	80 93 f1 05 	sts	0x05F1, r24
    3b76:	90 93 f2 05 	sts	0x05F2, r25
    3b7a:	a0 93 f3 05 	sts	0x05F3, r26
    3b7e:	b0 93 f4 05 	sts	0x05F4, r27
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3b82:	80 93 f9 05 	sts	0x05F9, r24
    3b86:	90 93 fa 05 	sts	0x05FA, r25
    3b8a:	a0 93 fb 05 	sts	0x05FB, r26
    3b8e:	b0 93 fc 05 	sts	0x05FC, r27
    3b92:	0f c1       	rjmp	.+542    	; 0x3db2 <__vector_10+0x3a0>
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    3b94:	10 92 17 06 	sts	0x0617, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3b98:	80 93 1f 06 	sts	0x061F, r24
    3b9c:	90 93 20 06 	sts	0x0620, r25
    3ba0:	a0 93 21 06 	sts	0x0621, r26
    3ba4:	b0 93 22 06 	sts	0x0622, r27
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3ba8:	80 93 27 06 	sts	0x0627, r24
    3bac:	90 93 28 06 	sts	0x0628, r25
    3bb0:	a0 93 29 06 	sts	0x0629, r26
    3bb4:	b0 93 2a 06 	sts	0x062A, r27
    3bb8:	fc c0       	rjmp	.+504    	; 0x3db2 <__vector_10+0x3a0>
			}
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    3bba:	82 30       	cpi	r24, 0x02	; 2
    3bbc:	09 f0       	breq	.+2      	; 0x3bc0 <__vector_10+0x1ae>
    3bbe:	98 c0       	rjmp	.+304    	; 0x3cf0 <__vector_10+0x2de>
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    3bc0:	80 91 26 01 	lds	r24, 0x0126
    3bc4:	90 91 27 01 	lds	r25, 0x0127
    3bc8:	81 15       	cp	r24, r1
    3bca:	93 40       	sbci	r25, 0x03	; 3
    3bcc:	08 f0       	brcs	.+2      	; 0x3bd0 <__vector_10+0x1be>
    3bce:	f1 c0       	rjmp	.+482    	; 0x3db2 <__vector_10+0x3a0>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    3bd0:	80 91 22 01 	lds	r24, 0x0122
    3bd4:	90 91 23 01 	lds	r25, 0x0123
    3bd8:	a0 91 24 01 	lds	r26, 0x0124
    3bdc:	b0 91 25 01 	lds	r27, 0x0125
    3be0:	89 2b       	or	r24, r25
    3be2:	8a 2b       	or	r24, r26
    3be4:	8b 2b       	or	r24, r27
    3be6:	09 f4       	brne	.+2      	; 0x3bea <__vector_10+0x1d8>
    3be8:	70 c0       	rjmp	.+224    	; 0x3cca <__vector_10+0x2b8>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    3bea:	80 91 4e 05 	lds	r24, 0x054E
    3bee:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    3bf0:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    3bf2:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    3bf4:	40 91 4e 05 	lds	r20, 0x054E
    3bf8:	50 91 4f 05 	lds	r21, 0x054F
    3bfc:	60 91 50 05 	lds	r22, 0x0550
    3c00:	70 91 51 05 	lds	r23, 0x0551
    3c04:	bb 27       	eor	r27, r27
    3c06:	a7 2f       	mov	r26, r23
    3c08:	96 2f       	mov	r25, r22
    3c0a:	85 2f       	mov	r24, r21
    3c0c:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    3c0e:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    3c10:	14 98       	cbi	0x02, 4	; 2

				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3c12:	cb 01       	movw	r24, r22
    3c14:	aa 27       	eor	r26, r26
    3c16:	bb 27       	eor	r27, r27
    3c18:	87 70       	andi	r24, 0x07	; 7
    3c1a:	99 27       	eor	r25, r25
    3c1c:	aa 27       	eor	r26, r26
    3c1e:	bb 27       	eor	r27, r27
    3c20:	88 68       	ori	r24, 0x88	; 136
    3c22:	88 b9       	out	0x08, r24	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    3c24:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    3c26:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    3c28:	80 91 52 05 	lds	r24, 0x0552
    3c2c:	81 30       	cpi	r24, 0x01	; 1
    3c2e:	29 f4       	brne	.+10     	; 0x3c3a <__vector_10+0x228>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    3c30:	4f 5f       	subi	r20, 0xFF	; 255
    3c32:	5f 4f       	sbci	r21, 0xFF	; 255
    3c34:	6f 4f       	sbci	r22, 0xFF	; 255
    3c36:	7f 4f       	sbci	r23, 0xFF	; 255
    3c38:	04 c0       	rjmp	.+8      	; 0x3c42 <__vector_10+0x230>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3c3a:	41 50       	subi	r20, 0x01	; 1
    3c3c:	51 09       	sbc	r21, r1
    3c3e:	61 09       	sbc	r22, r1
    3c40:	71 09       	sbc	r23, r1
    3c42:	40 93 4e 05 	sts	0x054E, r20
    3c46:	50 93 4f 05 	sts	0x054F, r21
    3c4a:	60 93 50 05 	sts	0x0550, r22
    3c4e:	70 93 51 05 	sts	0x0551, r23
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    3c52:	83 b1       	in	r24, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    3c54:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    3c56:	9f ef       	ldi	r25, 0xFF	; 255
    3c58:	94 b9       	out	0x04, r25	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    3c5a:	e0 91 28 01 	lds	r30, 0x0128
    3c5e:	f0 91 29 01 	lds	r31, 0x0129
    3c62:	e4 5d       	subi	r30, 0xD4	; 212
    3c64:	fe 4f       	sbci	r31, 0xFE	; 254
    3c66:	80 83       	st	Z, r24
				sdFifoWritePointer++;				// Move to next spot in fifo
    3c68:	80 91 28 01 	lds	r24, 0x0128
    3c6c:	90 91 29 01 	lds	r25, 0x0129
    3c70:	01 96       	adiw	r24, 0x01	; 1
    3c72:	90 93 29 01 	sts	0x0129, r25
    3c76:	80 93 28 01 	sts	0x0128, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    3c7a:	80 91 28 01 	lds	r24, 0x0128
    3c7e:	90 91 29 01 	lds	r25, 0x0129
    3c82:	81 15       	cp	r24, r1
    3c84:	93 40       	sbci	r25, 0x03	; 3
    3c86:	20 f0       	brcs	.+8      	; 0x3c90 <__vector_10+0x27e>
				{
					sdFifoWritePointer=0;
    3c88:	10 92 29 01 	sts	0x0129, r1
    3c8c:	10 92 28 01 	sts	0x0128, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    3c90:	80 91 26 01 	lds	r24, 0x0126
    3c94:	90 91 27 01 	lds	r25, 0x0127
    3c98:	01 96       	adiw	r24, 0x01	; 1
    3c9a:	90 93 27 01 	sts	0x0127, r25
    3c9e:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;		// One less byte in the sample
    3ca2:	80 91 22 01 	lds	r24, 0x0122
    3ca6:	90 91 23 01 	lds	r25, 0x0123
    3caa:	a0 91 24 01 	lds	r26, 0x0124
    3cae:	b0 91 25 01 	lds	r27, 0x0125
    3cb2:	01 97       	sbiw	r24, 0x01	; 1
    3cb4:	a1 09       	sbc	r26, r1
    3cb6:	b1 09       	sbc	r27, r1
    3cb8:	80 93 22 01 	sts	0x0122, r24
    3cbc:	90 93 23 01 	sts	0x0123, r25
    3cc0:	a0 93 24 01 	sts	0x0124, r26
    3cc4:	b0 93 25 01 	sts	0x0125, r27
    3cc8:	74 c0       	rjmp	.+232    	; 0x3db2 <__vector_10+0x3a0>

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3cca:	10 92 4d 05 	sts	0x054D, r1
				TCCR2B=0;					// Stop this timer
    3cce:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3cd2:	80 91 70 00 	lds	r24, 0x0070
    3cd6:	8b 7f       	andi	r24, 0xFB	; 251
    3cd8:	80 93 70 00 	sts	0x0070, r24

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    3cdc:	80 91 52 05 	lds	r24, 0x0552
    3ce0:	81 30       	cpi	r24, 0x01	; 1
    3ce2:	19 f4       	brne	.+6      	; 0x3cea <__vector_10+0x2d8>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    3ce4:	10 92 e9 05 	sts	0x05E9, r1
    3ce8:	64 c0       	rjmp	.+200    	; 0x3db2 <__vector_10+0x3a0>
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    3cea:	10 92 17 06 	sts	0x0617, r1
    3cee:	61 c0       	rjmp	.+194    	; 0x3db2 <__vector_10+0x3a0>
				}
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    3cf0:	83 30       	cpi	r24, 0x03	; 3
    3cf2:	09 f0       	breq	.+2      	; 0x3cf6 <__vector_10+0x2e4>
    3cf4:	5e c0       	rjmp	.+188    	; 0x3db2 <__vector_10+0x3a0>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    3cf6:	80 91 22 01 	lds	r24, 0x0122
    3cfa:	90 91 23 01 	lds	r25, 0x0123
    3cfe:	a0 91 24 01 	lds	r26, 0x0124
    3d02:	b0 91 25 01 	lds	r27, 0x0125
    3d06:	89 2b       	or	r24, r25
    3d08:	8a 2b       	or	r24, r26
    3d0a:	8b 2b       	or	r24, r27
    3d0c:	09 f4       	brne	.+2      	; 0x3d10 <__vector_10+0x2fe>
    3d0e:	46 c0       	rjmp	.+140    	; 0x3d9c <__vector_10+0x38a>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3d10:	80 91 26 01 	lds	r24, 0x0126
    3d14:	90 91 27 01 	lds	r25, 0x0127
    3d18:	89 2b       	or	r24, r25
    3d1a:	09 f4       	brne	.+2      	; 0x3d1e <__vector_10+0x30c>
    3d1c:	4a c0       	rjmp	.+148    	; 0x3db2 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3d1e:	e0 91 2a 01 	lds	r30, 0x012A
    3d22:	f0 91 2b 01 	lds	r31, 0x012B
    3d26:	e4 5d       	subi	r30, 0xD4	; 212
    3d28:	fe 4f       	sbci	r31, 0xFE	; 254
    3d2a:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3d2c:	80 91 2a 01 	lds	r24, 0x012A
    3d30:	90 91 2b 01 	lds	r25, 0x012B
    3d34:	01 96       	adiw	r24, 0x01	; 1
    3d36:	90 93 2b 01 	sts	0x012B, r25
    3d3a:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3d3e:	80 91 2a 01 	lds	r24, 0x012A
    3d42:	90 91 2b 01 	lds	r25, 0x012B
    3d46:	81 15       	cp	r24, r1
    3d48:	93 40       	sbci	r25, 0x03	; 3
    3d4a:	20 f0       	brcs	.+8      	; 0x3d54 <__vector_10+0x342>
				{
					sdFifoReadPointer=0;
    3d4c:	10 92 2b 01 	sts	0x012B, r1
    3d50:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3d54:	80 91 26 01 	lds	r24, 0x0126
    3d58:	90 91 27 01 	lds	r25, 0x0127
    3d5c:	01 97       	sbiw	r24, 0x01	; 1
    3d5e:	90 93 27 01 	sts	0x0127, r25
    3d62:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3d66:	80 91 22 01 	lds	r24, 0x0122
    3d6a:	90 91 23 01 	lds	r25, 0x0123
    3d6e:	a0 91 24 01 	lds	r26, 0x0124
    3d72:	b0 91 25 01 	lds	r27, 0x0125
    3d76:	01 97       	sbiw	r24, 0x01	; 1
    3d78:	a1 09       	sbc	r26, r1
    3d7a:	b1 09       	sbc	r27, r1
    3d7c:	80 93 22 01 	sts	0x0122, r24
    3d80:	90 93 23 01 	sts	0x0123, r25
    3d84:	a0 93 24 01 	sts	0x0124, r26
    3d88:	b0 93 25 01 	sts	0x0125, r27

				// Now spit the byte out the DAC.

				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine
    3d8c:	20 93 53 05 	sts	0x0553, r18
				UpdateOutput();				// Update the DAC
    3d90:	e0 91 e0 05 	lds	r30, 0x05E0
    3d94:	f0 91 e1 05 	lds	r31, 0x05E1
    3d98:	09 95       	icall
    3d9a:	0b c0       	rjmp	.+22     	; 0x3db2 <__vector_10+0x3a0>
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3d9c:	10 92 4d 05 	sts	0x054D, r1
			TCCR2B=0;					// Stop this timer
    3da0:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3da4:	80 91 70 00 	lds	r24, 0x0070
    3da8:	8b 7f       	andi	r24, 0xFB	; 251
    3daa:	80 93 70 00 	sts	0x0070, r24

			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    3dae:	10 92 53 05 	sts	0x0553, r1
		}
	}
}
    3db2:	ff 91       	pop	r31
    3db4:	ef 91       	pop	r30
    3db6:	bf 91       	pop	r27
    3db8:	af 91       	pop	r26
    3dba:	9f 91       	pop	r25
    3dbc:	8f 91       	pop	r24
    3dbe:	7f 91       	pop	r23
    3dc0:	6f 91       	pop	r22
    3dc2:	5f 91       	pop	r21
    3dc4:	4f 91       	pop	r20
    3dc6:	3f 91       	pop	r19
    3dc8:	2f 91       	pop	r18
    3dca:	0f 90       	pop	r0
    3dcc:	0f be       	out	0x3f, r0	; 63
    3dce:	0f 90       	pop	r0
    3dd0:	1f 90       	pop	r1
    3dd2:	18 95       	reti

00003dd4 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our FABULOUS intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    3dd4:	1f 92       	push	r1
    3dd6:	0f 92       	push	r0
    3dd8:	0f b6       	in	r0, 0x3f	; 63
    3dda:	0f 92       	push	r0
    3ddc:	11 24       	eor	r1, r1
    3dde:	8f 93       	push	r24
    3de0:	9f 93       	push	r25
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
    3de2:	90 91 40 04 	lds	r25, 0x0440
    3de6:	80 91 54 05 	lds	r24, 0x0554
    3dea:	89 17       	cp	r24, r25
    3dec:	18 f4       	brcc	.+6      	; 0x3df4 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    3dee:	9f ef       	ldi	r25, 0xFF	; 255
    3df0:	95 b9       	out	0x05, r25	; 5
    3df2:	01 c0       	rjmp	.+2      	; 0x3df6 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    3df4:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    3df6:	8f 5f       	subi	r24, 0xFF	; 255
    3df8:	80 93 54 05 	sts	0x0554, r24
}
    3dfc:	9f 91       	pop	r25
    3dfe:	8f 91       	pop	r24
    3e00:	0f 90       	pop	r0
    3e02:	0f be       	out	0x3f, r0	; 63
    3e04:	0f 90       	pop	r0
    3e06:	1f 90       	pop	r1
    3e08:	18 95       	reti

00003e0a <__vector_default>:

ISR(__vector_default)
{
    3e0a:	1f 92       	push	r1
    3e0c:	0f 92       	push	r0
    3e0e:	0f b6       	in	r0, 0x3f	; 63
    3e10:	0f 92       	push	r0
    3e12:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    3e14:	0f 90       	pop	r0
    3e16:	0f be       	out	0x3f, r0	; 63
    3e18:	0f 90       	pop	r0
    3e1a:	1f 90       	pop	r1
    3e1c:	18 95       	reti

00003e1e <HandleSoftclock>:

void HandleSoftclock(void)
// NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
// This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up our concept of time when we have a hang-ey loop.
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    3e1e:	a8 9b       	sbis	0x15, 0	; 21
    3e20:	0a c0       	rjmp	.+20     	; 0x3e36 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    3e22:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    3e24:	80 91 40 06 	lds	r24, 0x0640
    3e28:	90 91 41 06 	lds	r25, 0x0641
    3e2c:	01 96       	adiw	r24, 0x01	; 1
    3e2e:	90 93 41 06 	sts	0x0641, r25
    3e32:	80 93 40 06 	sts	0x0640, r24
    3e36:	08 95       	ret

00003e38 <EepromWrite>:
void EepromWrite(unsigned int theAddress, unsigned char theData)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3e38:	f9 99       	sbic	0x1f, 1	; 31
    3e3a:	fe cf       	rjmp	.-4      	; 0x3e38 <EepromWrite>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3e3c:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3e3e:	f8 94       	cli

	EEAR=theAddress;
    3e40:	92 bd       	out	0x22, r25	; 34
    3e42:	81 bd       	out	0x21, r24	; 33
	EEDR=theData;
    3e44:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    3e46:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    3e48:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    3e4a:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3e4c:	12 bc       	out	0x22, r1	; 34
    3e4e:	11 bc       	out	0x21, r1	; 33
    3e50:	08 95       	ret

00003e52 <EepromRead>:
unsigned char EepromRead(unsigned char theAddress)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3e52:	f9 99       	sbic	0x1f, 1	; 31
    3e54:	fe cf       	rjmp	.-4      	; 0x3e52 <EepromRead>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3e56:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3e58:	f8 94       	cli

	EEAR=theAddress;
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	92 bd       	out	0x22, r25	; 34
    3e5e:	81 bd       	out	0x21, r24	; 33
	EECR|=(1<<EERE);	// Start reading.
    3e60:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    3e62:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3e64:	12 bc       	out	0x22, r1	; 34
    3e66:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    3e68:	80 b5       	in	r24, 0x20	; 32
}
    3e6a:	08 95       	ret

00003e6c <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    3e6c:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    3e70:	88 1f       	adc	r24, r24
    3e72:	88 27       	eor	r24, r24
    3e74:	88 1f       	adc	r24, r24
    3e76:	08 95       	ret

00003e78 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3e78:	80 91 c6 00 	lds	r24, 0x00C6
}
    3e7c:	08 95       	ret

00003e7e <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    3e7e:	80 91 64 00 	lds	r24, 0x0064
    3e82:	8d 7f       	andi	r24, 0xFD	; 253
    3e84:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    3e88:	80 91 c0 00 	lds	r24, 0x00C0
    3e8c:	8d 7f       	andi	r24, 0xFD	; 253
    3e8e:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    3e92:	88 e1       	ldi	r24, 0x18	; 24
    3e94:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    3e98:	87 e2       	ldi	r24, 0x27	; 39
    3e9a:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    3e9e:	86 e0       	ldi	r24, 0x06	; 6
    3ea0:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    3ea4:	80 91 c0 00 	lds	r24, 0x00C0
    3ea8:	85 ff       	sbrs	r24, 5
    3eaa:	fc cf       	rjmp	.-8      	; 0x3ea4 <InitUart0+0x26>
    3eac:	02 c0       	rjmp	.+4      	; 0x3eb2 <InitUart0+0x34>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3eae:	80 91 c6 00 	lds	r24, 0x00C6
	{
		;
	}

//	Uart0FlushBuffer();						// Get rid of any poo poo hanging out in the input buffer.
	while(Uart0GotByte())
    3eb2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <Uart0GotByte>
    3eb6:	81 11       	cpse	r24, r1
    3eb8:	fa cf       	rjmp	.-12     	; 0x3eae <InitUart0+0x30>
	{
		Uart0GetByte();
	}		
}
    3eba:	08 95       	ret

00003ebc <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    3ebc:	90 e0       	ldi	r25, 0x00	; 0
    3ebe:	20 91 40 06 	lds	r18, 0x0640
    3ec2:	30 91 41 06 	lds	r19, 0x0641
    3ec6:	88 0f       	add	r24, r24
    3ec8:	99 1f       	adc	r25, r25
    3eca:	fc 01       	movw	r30, r24
    3ecc:	ed 53       	subi	r30, 0x3D	; 61
    3ece:	fa 4f       	sbci	r31, 0xFA	; 250
    3ed0:	31 83       	std	Z+1, r19	; 0x01
    3ed2:	20 83       	st	Z, r18
	delayTime[timerNum]=ticks_to_wait;
    3ed4:	fc 01       	movw	r30, r24
    3ed6:	e5 53       	subi	r30, 0x35	; 53
    3ed8:	fa 4f       	sbci	r31, 0xFA	; 250
    3eda:	71 83       	std	Z+1, r23	; 0x01
    3edc:	60 83       	st	Z, r22
    3ede:	08 95       	ret

00003ee0 <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    3ee0:	20 91 40 06 	lds	r18, 0x0640
    3ee4:	30 91 41 06 	lds	r19, 0x0641
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	88 0f       	add	r24, r24
    3eec:	99 1f       	adc	r25, r25
    3eee:	fc 01       	movw	r30, r24
    3ef0:	ed 53       	subi	r30, 0x3D	; 61
    3ef2:	fa 4f       	sbci	r31, 0xFA	; 250
    3ef4:	40 81       	ld	r20, Z
    3ef6:	51 81       	ldd	r21, Z+1	; 0x01
    3ef8:	24 1b       	sub	r18, r20
    3efa:	35 0b       	sbc	r19, r21
    3efc:	fc 01       	movw	r30, r24
    3efe:	e5 53       	subi	r30, 0x35	; 53
    3f00:	fa 4f       	sbci	r31, 0xFA	; 250
    3f02:	81 e0       	ldi	r24, 0x01	; 1
    3f04:	40 81       	ld	r20, Z
    3f06:	51 81       	ldd	r21, Z+1	; 0x01
    3f08:	24 17       	cp	r18, r20
    3f0a:	35 07       	cpc	r19, r21
    3f0c:	08 f4       	brcc	.+2      	; 0x3f10 <CheckTimer+0x30>
    3f0e:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    3f10:	08 95       	ret

00003f12 <PutMidiMessageInIncomingFifo>:
}

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    3f12:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    3f14:	80 91 74 06 	lds	r24, 0x0674
    3f18:	86 30       	cpi	r24, 0x06	; 6
    3f1a:	08 f5       	brcc	.+66     	; 0x3f5e <PutMidiMessageInIncomingFifo+0x4c>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    3f1c:	90 91 d7 05 	lds	r25, 0x05D7
    3f20:	11 96       	adiw	r26, 0x01	; 1
    3f22:	2c 91       	ld	r18, X
    3f24:	11 97       	sbiw	r26, 0x01	; 1
    3f26:	34 e0       	ldi	r19, 0x04	; 4
    3f28:	93 9f       	mul	r25, r19
    3f2a:	f0 01       	movw	r30, r0
    3f2c:	11 24       	eor	r1, r1
    3f2e:	ed 5b       	subi	r30, 0xBD	; 189
    3f30:	f9 4f       	sbci	r31, 0xF9	; 249
    3f32:	21 83       	std	Z+1, r18	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    3f34:	12 96       	adiw	r26, 0x02	; 2
    3f36:	2c 91       	ld	r18, X
    3f38:	12 97       	sbiw	r26, 0x02	; 2
    3f3a:	22 83       	std	Z+2, r18	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    3f3c:	13 96       	adiw	r26, 0x03	; 3
    3f3e:	2c 91       	ld	r18, X
    3f40:	13 97       	sbiw	r26, 0x03	; 3
    3f42:	23 83       	std	Z+3, r18	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    3f44:	2c 91       	ld	r18, X
    3f46:	20 83       	st	Z, r18
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3f48:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3f4a:	96 30       	cpi	r25, 0x06	; 6
    3f4c:	18 f4       	brcc	.+6      	; 0x3f54 <PutMidiMessageInIncomingFifo+0x42>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3f4e:	90 93 d7 05 	sts	0x05D7, r25
    3f52:	02 c0       	rjmp	.+4      	; 0x3f58 <PutMidiMessageInIncomingFifo+0x46>
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
    3f54:	10 92 d7 05 	sts	0x05D7, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    3f58:	8f 5f       	subi	r24, 0xFF	; 255
    3f5a:	80 93 74 06 	sts	0x0674, r24
    3f5e:	08 95       	ret

00003f60 <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    3f60:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    3f62:	80 91 74 06 	lds	r24, 0x0674
    3f66:	88 23       	and	r24, r24
    3f68:	09 f1       	breq	.+66     	; 0x3fac <GetMidiMessageFromIncomingFifo+0x4c>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3f6a:	90 91 d3 05 	lds	r25, 0x05D3
    3f6e:	24 e0       	ldi	r18, 0x04	; 4
    3f70:	92 9f       	mul	r25, r18
    3f72:	f0 01       	movw	r30, r0
    3f74:	11 24       	eor	r1, r1
    3f76:	ed 5b       	subi	r30, 0xBD	; 189
    3f78:	f9 4f       	sbci	r31, 0xF9	; 249
    3f7a:	21 81       	ldd	r18, Z+1	; 0x01
    3f7c:	11 96       	adiw	r26, 0x01	; 1
    3f7e:	2c 93       	st	X, r18
    3f80:	11 97       	sbiw	r26, 0x01	; 1
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    3f82:	22 81       	ldd	r18, Z+2	; 0x02
    3f84:	12 96       	adiw	r26, 0x02	; 2
    3f86:	2c 93       	st	X, r18
    3f88:	12 97       	sbiw	r26, 0x02	; 2
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    3f8a:	23 81       	ldd	r18, Z+3	; 0x03
    3f8c:	13 96       	adiw	r26, 0x03	; 3
    3f8e:	2c 93       	st	X, r18
    3f90:	13 97       	sbiw	r26, 0x03	; 3
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    3f92:	20 81       	ld	r18, Z
    3f94:	2c 93       	st	X, r18

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3f96:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3f98:	96 30       	cpi	r25, 0x06	; 6
    3f9a:	18 f4       	brcc	.+6      	; 0x3fa2 <GetMidiMessageFromIncomingFifo+0x42>
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3f9c:	90 93 d3 05 	sts	0x05D3, r25
    3fa0:	02 c0       	rjmp	.+4      	; 0x3fa6 <GetMidiMessageFromIncomingFifo+0x46>
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
    3fa2:	10 92 d3 05 	sts	0x05D3, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    3fa6:	81 50       	subi	r24, 0x01	; 1
    3fa8:	80 93 74 06 	sts	0x0674, r24
    3fac:	08 95       	ret

00003fae <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    3fae:	80 91 75 06 	lds	r24, 0x0675
    3fb2:	86 30       	cpi	r24, 0x06	; 6
    3fb4:	c8 f4       	brcc	.+50     	; 0x3fe8 <PutMidiMessageInOutgoingFifo+0x3a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    3fb6:	90 91 d4 05 	lds	r25, 0x05D4
    3fba:	34 e0       	ldi	r19, 0x04	; 4
    3fbc:	93 9f       	mul	r25, r19
    3fbe:	f0 01       	movw	r30, r0
    3fc0:	11 24       	eor	r1, r1
    3fc2:	e4 5a       	subi	r30, 0xA4	; 164
    3fc4:	f9 4f       	sbci	r31, 0xF9	; 249
    3fc6:	61 83       	std	Z+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    3fc8:	42 83       	std	Z+2, r20	; 0x02
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    3fca:	23 83       	std	Z+3, r18	; 0x03
    3fcc:	20 91 42 06 	lds	r18, 0x0642
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    3fd0:	20 83       	st	Z, r18
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3fd2:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3fd4:	96 30       	cpi	r25, 0x06	; 6
    3fd6:	18 f4       	brcc	.+6      	; 0x3fde <PutMidiMessageInOutgoingFifo+0x30>
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3fd8:	90 93 d4 05 	sts	0x05D4, r25
    3fdc:	02 c0       	rjmp	.+4      	; 0x3fe2 <PutMidiMessageInOutgoingFifo+0x34>
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
    3fde:	10 92 d4 05 	sts	0x05D4, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    3fe2:	8f 5f       	subi	r24, 0xFF	; 255
    3fe4:	80 93 75 06 	sts	0x0675, r24
    3fe8:	08 95       	ret

00003fea <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    3fea:	89 e0       	ldi	r24, 0x09	; 9
    3fec:	80 93 d5 05 	sts	0x05D5, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    3ff0:	10 92 d6 05 	sts	0x05D6, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    3ff4:	10 92 74 06 	sts	0x0674, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    3ff8:	10 92 d7 05 	sts	0x05D7, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    3ffc:	10 92 d3 05 	sts	0x05D3, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    4000:	10 92 75 06 	sts	0x0675, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    4004:	10 92 d4 05 	sts	0x05D4, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    4008:	10 92 d8 05 	sts	0x05D8, r1
    400c:	08 95       	ret

0000400e <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    400e:	1f 93       	push	r17
    4010:	cf 93       	push	r28
    4012:	df 93       	push	r29
    4014:	00 d0       	rcall	.+0      	; 0x4016 <HandleIncomingMidiByte+0x8>
    4016:	00 d0       	rcall	.+0      	; 0x4018 <HandleIncomingMidiByte+0xa>
    4018:	cd b7       	in	r28, 0x3d	; 61
    401a:	de b7       	in	r29, 0x3e	; 62
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    401c:	87 ff       	sbrs	r24, 7
    401e:	2f c0       	rjmp	.+94     	; 0x407e <HandleIncomingMidiByte+0x70>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    4020:	98 2f       	mov	r25, r24
    4022:	9f 70       	andi	r25, 0x0F	; 15
    4024:	20 91 42 06 	lds	r18, 0x0642
    4028:	92 17       	cp	r25, r18
    402a:	21 f0       	breq	.+8      	; 0x4034 <HandleIncomingMidiByte+0x26>
    402c:	30 91 5b 06 	lds	r19, 0x065B
    4030:	93 13       	cpse	r25, r19
    4032:	9f c0       	rjmp	.+318    	; 0x4172 <HandleIncomingMidiByte+0x164>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    4034:	80 7f       	andi	r24, 0xF0	; 240
    4036:	80 39       	cpi	r24, 0x90	; 144
    4038:	19 f4       	brne	.+6      	; 0x4040 <HandleIncomingMidiByte+0x32>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    403a:	10 92 d5 05 	sts	0x05D5, r1
    403e:	16 c0       	rjmp	.+44     	; 0x406c <HandleIncomingMidiByte+0x5e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    4040:	80 38       	cpi	r24, 0x80	; 128
    4042:	31 f4       	brne	.+12     	; 0x4050 <HandleIncomingMidiByte+0x42>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    4044:	81 e0       	ldi	r24, 0x01	; 1
    4046:	80 93 d5 05 	sts	0x05D5, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    404a:	92 13       	cpse	r25, r18
    404c:	15 c0       	rjmp	.+42     	; 0x4078 <HandleIncomingMidiByte+0x6a>
    404e:	10 c0       	rjmp	.+32     	; 0x4070 <HandleIncomingMidiByte+0x62>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    4050:	80 3c       	cpi	r24, 0xC0	; 192
    4052:	11 f4       	brne	.+4      	; 0x4058 <HandleIncomingMidiByte+0x4a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    4054:	82 e0       	ldi	r24, 0x02	; 2
    4056:	08 c0       	rjmp	.+16     	; 0x4068 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    4058:	80 3e       	cpi	r24, 0xE0	; 224
    405a:	11 f4       	brne	.+4      	; 0x4060 <HandleIncomingMidiByte+0x52>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    405c:	87 e0       	ldi	r24, 0x07	; 7
    405e:	04 c0       	rjmp	.+8      	; 0x4068 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    4060:	80 3b       	cpi	r24, 0xB0	; 176
    4062:	09 f0       	breq	.+2      	; 0x4066 <HandleIncomingMidiByte+0x58>
    4064:	86 c0       	rjmp	.+268    	; 0x4172 <HandleIncomingMidiByte+0x164>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    4066:	83 e0       	ldi	r24, 0x03	; 3
    4068:	80 93 d5 05 	sts	0x05D5, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    406c:	92 13       	cpse	r25, r18
    406e:	03 c0       	rjmp	.+6      	; 0x4076 <HandleIncomingMidiByte+0x68>
				{
					temporaryChannel=BANK_0;
    4070:	10 92 d9 05 	sts	0x05D9, r1
    4074:	81 c0       	rjmp	.+258    	; 0x4178 <HandleIncomingMidiByte+0x16a>
				}
				else
				{
					temporaryChannel=BANK_1;
    4076:	81 e0       	ldi	r24, 0x01	; 1
    4078:	80 93 d9 05 	sts	0x05D9, r24
    407c:	7d c0       	rjmp	.+250    	; 0x4178 <HandleIncomingMidiByte+0x16a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    407e:	10 91 d5 05 	lds	r17, 0x05D5
    4082:	14 30       	cpi	r17, 0x04	; 4
    4084:	09 f4       	brne	.+2      	; 0x4088 <HandleIncomingMidiByte+0x7a>
    4086:	53 c0       	rjmp	.+166    	; 0x412e <HandleIncomingMidiByte+0x120>
    4088:	50 f4       	brcc	.+20     	; 0x409e <HandleIncomingMidiByte+0x90>
    408a:	11 30       	cpi	r17, 0x01	; 1
    408c:	a1 f1       	breq	.+104    	; 0x40f6 <HandleIncomingMidiByte+0xe8>
    408e:	c0 f0       	brcs	.+48     	; 0x40c0 <HandleIncomingMidiByte+0xb2>
    4090:	12 30       	cpi	r17, 0x02	; 2
    4092:	09 f4       	brne	.+2      	; 0x4096 <HandleIncomingMidiByte+0x88>
    4094:	43 c0       	rjmp	.+134    	; 0x411c <HandleIncomingMidiByte+0x10e>
    4096:	13 30       	cpi	r17, 0x03	; 3
    4098:	09 f0       	breq	.+2      	; 0x409c <HandleIncomingMidiByte+0x8e>
    409a:	6b c0       	rjmp	.+214    	; 0x4172 <HandleIncomingMidiByte+0x164>
    409c:	44 c0       	rjmp	.+136    	; 0x4126 <HandleIncomingMidiByte+0x118>
    409e:	17 30       	cpi	r17, 0x07	; 7
    40a0:	09 f4       	brne	.+2      	; 0x40a4 <HandleIncomingMidiByte+0x96>
    40a2:	53 c0       	rjmp	.+166    	; 0x414a <HandleIncomingMidiByte+0x13c>
    40a4:	30 f4       	brcc	.+12     	; 0x40b2 <HandleIncomingMidiByte+0xa4>
    40a6:	15 30       	cpi	r17, 0x05	; 5
    40a8:	79 f0       	breq	.+30     	; 0x40c8 <HandleIncomingMidiByte+0xba>
    40aa:	16 30       	cpi	r17, 0x06	; 6
    40ac:	09 f0       	breq	.+2      	; 0x40b0 <HandleIncomingMidiByte+0xa2>
    40ae:	61 c0       	rjmp	.+194    	; 0x4172 <HandleIncomingMidiByte+0x164>
    40b0:	26 c0       	rjmp	.+76     	; 0x40fe <HandleIncomingMidiByte+0xf0>
    40b2:	18 30       	cpi	r17, 0x08	; 8
    40b4:	09 f4       	brne	.+2      	; 0x40b8 <HandleIncomingMidiByte+0xaa>
    40b6:	4d c0       	rjmp	.+154    	; 0x4152 <HandleIncomingMidiByte+0x144>
    40b8:	19 30       	cpi	r17, 0x09	; 9
    40ba:	09 f0       	breq	.+2      	; 0x40be <HandleIncomingMidiByte+0xb0>
    40bc:	5a c0       	rjmp	.+180    	; 0x4172 <HandleIncomingMidiByte+0x164>
    40be:	5c c0       	rjmp	.+184    	; 0x4178 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    40c0:	80 93 da 05 	sts	0x05DA, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    40c4:	85 e0       	ldi	r24, 0x05	; 5
    40c6:	56 c0       	rjmp	.+172    	; 0x4174 <HandleIncomingMidiByte+0x166>
    40c8:	90 91 da 05 	lds	r25, 0x05DA
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    40cc:	81 11       	cpse	r24, r1
    40ce:	05 c0       	rjmp	.+10     	; 0x40da <HandleIncomingMidiByte+0xcc>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    40d0:	82 e0       	ldi	r24, 0x02	; 2
    40d2:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    40d4:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    40d6:	1c 82       	std	Y+4, r1	; 0x04
    40d8:	04 c0       	rjmp	.+8      	; 0x40e2 <HandleIncomingMidiByte+0xd4>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    40da:	21 e0       	ldi	r18, 0x01	; 1
    40dc:	2a 83       	std	Y+2, r18	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    40de:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    40e0:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    40e2:	80 91 d9 05 	lds	r24, 0x05D9
    40e6:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    40e8:	ce 01       	movw	r24, r28
    40ea:	01 96       	adiw	r24, 0x01	; 1
    40ec:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    40f0:	10 92 d5 05 	sts	0x05D5, r1
    40f4:	41 c0       	rjmp	.+130    	; 0x4178 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    40f6:	80 93 da 05 	sts	0x05DA, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    40fa:	86 e0       	ldi	r24, 0x06	; 6
    40fc:	3b c0       	rjmp	.+118    	; 0x4174 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    40fe:	92 e0       	ldi	r25, 0x02	; 2
    4100:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4102:	90 91 da 05 	lds	r25, 0x05DA
    4106:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    4108:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    410a:	80 91 d9 05 	lds	r24, 0x05D9
    410e:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    4110:	ce 01       	movw	r24, r28
    4112:	01 96       	adiw	r24, 0x01	; 1
    4114:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    4118:	81 e0       	ldi	r24, 0x01	; 1
    411a:	2c c0       	rjmp	.+88     	; 0x4174 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    411c:	93 e0       	ldi	r25, 0x03	; 3
    411e:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    4120:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    4122:	1c 82       	std	Y+4, r1	; 0x04
    4124:	1c c0       	rjmp	.+56     	; 0x415e <HandleIncomingMidiByte+0x150>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    4126:	80 93 da 05 	sts	0x05DA, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    412a:	84 e0       	ldi	r24, 0x04	; 4
    412c:	23 c0       	rjmp	.+70     	; 0x4174 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    412e:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    4130:	90 91 da 05 	lds	r25, 0x05DA
    4134:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    4136:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    4138:	80 91 d9 05 	lds	r24, 0x05D9
    413c:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    413e:	ce 01       	movw	r24, r28
    4140:	01 96       	adiw	r24, 0x01	; 1
    4142:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    4146:	83 e0       	ldi	r24, 0x03	; 3
    4148:	15 c0       	rjmp	.+42     	; 0x4174 <HandleIncomingMidiByte+0x166>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    414a:	80 93 da 05 	sts	0x05DA, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    414e:	88 e0       	ldi	r24, 0x08	; 8
    4150:	11 c0       	rjmp	.+34     	; 0x4174 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    4152:	17 e0       	ldi	r17, 0x07	; 7
    4154:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    4156:	90 91 da 05 	lds	r25, 0x05DA
    415a:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    415c:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    415e:	80 91 d9 05 	lds	r24, 0x05D9
    4162:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    4164:	ce 01       	movw	r24, r28
    4166:	01 96       	adiw	r24, 0x01	; 1
    4168:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    416c:	10 93 d5 05 	sts	0x05D5, r17
    4170:	03 c0       	rjmp	.+6      	; 0x4178 <HandleIncomingMidiByte+0x16a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    4172:	89 e0       	ldi	r24, 0x09	; 9
    4174:	80 93 d5 05 	sts	0x05D5, r24
			break;
		}	
	}
}
    4178:	0f 90       	pop	r0
    417a:	0f 90       	pop	r0
    417c:	0f 90       	pop	r0
    417e:	0f 90       	pop	r0
    4180:	df 91       	pop	r29
    4182:	cf 91       	pop	r28
    4184:	1f 91       	pop	r17
    4186:	08 95       	ret

00004188 <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    4188:	80 91 75 06 	lds	r24, 0x0675
    418c:	81 11       	cpse	r24, r1
    418e:	07 c0       	rjmp	.+14     	; 0x419e <MidiTxBufferNotEmpty+0x16>
    4190:	81 e0       	ldi	r24, 0x01	; 1
    4192:	90 91 d6 05 	lds	r25, 0x05D6
    4196:	91 11       	cpse	r25, r1
    4198:	03 c0       	rjmp	.+6      	; 0x41a0 <MidiTxBufferNotEmpty+0x18>
    419a:	80 e0       	ldi	r24, 0x00	; 0
    419c:	08 95       	ret
	{
		return(true);
    419e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    41a0:	08 95       	ret

000041a2 <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    41a2:	80 91 d6 05 	lds	r24, 0x05D6
    41a6:	83 30       	cpi	r24, 0x03	; 3
    41a8:	09 f4       	brne	.+2      	; 0x41ac <PopOutgoingMidiByte+0xa>
    41aa:	87 c0       	rjmp	.+270    	; 0x42ba <PopOutgoingMidiByte+0x118>
    41ac:	30 f4       	brcc	.+12     	; 0x41ba <PopOutgoingMidiByte+0x18>
    41ae:	81 30       	cpi	r24, 0x01	; 1
    41b0:	09 f4       	brne	.+2      	; 0x41b4 <PopOutgoingMidiByte+0x12>
    41b2:	7b c0       	rjmp	.+246    	; 0x42aa <PopOutgoingMidiByte+0x108>
    41b4:	08 f0       	brcs	.+2      	; 0x41b8 <PopOutgoingMidiByte+0x16>
    41b6:	7b c0       	rjmp	.+246    	; 0x42ae <PopOutgoingMidiByte+0x10c>
    41b8:	0c c0       	rjmp	.+24     	; 0x41d2 <PopOutgoingMidiByte+0x30>
    41ba:	85 30       	cpi	r24, 0x05	; 5
    41bc:	09 f4       	brne	.+2      	; 0x41c0 <PopOutgoingMidiByte+0x1e>
    41be:	84 c0       	rjmp	.+264    	; 0x42c8 <PopOutgoingMidiByte+0x126>
    41c0:	08 f4       	brcc	.+2      	; 0x41c4 <PopOutgoingMidiByte+0x22>
    41c2:	7f c0       	rjmp	.+254    	; 0x42c2 <PopOutgoingMidiByte+0x120>
    41c4:	86 30       	cpi	r24, 0x06	; 6
    41c6:	09 f4       	brne	.+2      	; 0x41ca <PopOutgoingMidiByte+0x28>
    41c8:	82 c0       	rjmp	.+260    	; 0x42ce <PopOutgoingMidiByte+0x12c>
    41ca:	87 30       	cpi	r24, 0x07	; 7
    41cc:	09 f0       	breq	.+2      	; 0x41d0 <PopOutgoingMidiByte+0x2e>
    41ce:	86 c0       	rjmp	.+268    	; 0x42dc <PopOutgoingMidiByte+0x13a>
    41d0:	80 c0       	rjmp	.+256    	; 0x42d2 <PopOutgoingMidiByte+0x130>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    41d2:	80 91 75 06 	lds	r24, 0x0675
    41d6:	88 23       	and	r24, r24
    41d8:	f9 f0       	breq	.+62     	; 0x4218 <PopOutgoingMidiByte+0x76>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    41da:	90 91 d8 05 	lds	r25, 0x05D8
    41de:	24 e0       	ldi	r18, 0x04	; 4
    41e0:	92 9f       	mul	r25, r18
    41e2:	f0 01       	movw	r30, r0
    41e4:	11 24       	eor	r1, r1
    41e6:	e4 5a       	subi	r30, 0xA4	; 164
    41e8:	f9 4f       	sbci	r31, 0xF9	; 249
    41ea:	21 81       	ldd	r18, Z+1	; 0x01
    41ec:	20 93 dc 05 	sts	0x05DC, r18
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    41f0:	22 81       	ldd	r18, Z+2	; 0x02
    41f2:	20 93 dd 05 	sts	0x05DD, r18
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    41f6:	23 81       	ldd	r18, Z+3	; 0x03
    41f8:	20 93 de 05 	sts	0x05DE, r18
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    41fc:	20 81       	ld	r18, Z
    41fe:	20 93 db 05 	sts	0x05DB, r18

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    4202:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    4204:	96 30       	cpi	r25, 0x06	; 6
    4206:	18 f4       	brcc	.+6      	; 0x420e <PopOutgoingMidiByte+0x6c>
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    4208:	90 93 d8 05 	sts	0x05D8, r25
    420c:	02 c0       	rjmp	.+4      	; 0x4212 <PopOutgoingMidiByte+0x70>
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
    420e:	10 92 d8 05 	sts	0x05D8, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    4212:	81 50       	subi	r24, 0x01	; 1
    4214:	80 93 75 06 	sts	0x0675, r24
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    4218:	90 91 dc 05 	lds	r25, 0x05DC
    421c:	92 30       	cpi	r25, 0x02	; 2
    421e:	b1 f0       	breq	.+44     	; 0x424c <PopOutgoingMidiByte+0xaa>
    4220:	20 f4       	brcc	.+8      	; 0x422a <PopOutgoingMidiByte+0x88>
    4222:	91 30       	cpi	r25, 0x01	; 1
    4224:	09 f0       	breq	.+2      	; 0x4228 <PopOutgoingMidiByte+0x86>
    4226:	5a c0       	rjmp	.+180    	; 0x42dc <PopOutgoingMidiByte+0x13a>
    4228:	06 c0       	rjmp	.+12     	; 0x4236 <PopOutgoingMidiByte+0x94>
    422a:	93 30       	cpi	r25, 0x03	; 3
    422c:	e9 f0       	breq	.+58     	; 0x4268 <PopOutgoingMidiByte+0xc6>
    422e:	94 30       	cpi	r25, 0x04	; 4
    4230:	09 f0       	breq	.+2      	; 0x4234 <PopOutgoingMidiByte+0x92>
    4232:	54 c0       	rjmp	.+168    	; 0x42dc <PopOutgoingMidiByte+0x13a>
    4234:	29 c0       	rjmp	.+82     	; 0x4288 <PopOutgoingMidiByte+0xe6>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4236:	80 91 db 05 	lds	r24, 0x05DB
    423a:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    423c:	20 91 df 05 	lds	r18, 0x05DF
    4240:	28 13       	cpse	r18, r24
    4242:	0f c0       	rjmp	.+30     	; 0x4262 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    4244:	80 91 dd 05 	lds	r24, 0x05DD
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4248:	93 e0       	ldi	r25, 0x03	; 3
    424a:	2c c0       	rjmp	.+88     	; 0x42a4 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    424c:	80 91 db 05 	lds	r24, 0x05DB
    4250:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    4252:	20 91 df 05 	lds	r18, 0x05DF
    4256:	28 13       	cpse	r18, r24
    4258:	04 c0       	rjmp	.+8      	; 0x4262 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    425a:	80 91 dd 05 	lds	r24, 0x05DD
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    425e:	94 e0       	ldi	r25, 0x04	; 4
    4260:	21 c0       	rjmp	.+66     	; 0x42a4 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4262:	80 93 df 05 	sts	0x05DF, r24
    4266:	1e c0       	rjmp	.+60     	; 0x42a4 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    4268:	80 91 db 05 	lds	r24, 0x05DB
    426c:	80 6c       	ori	r24, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    426e:	90 91 df 05 	lds	r25, 0x05DF
    4272:	98 13       	cpse	r25, r24
    4274:	05 c0       	rjmp	.+10     	; 0x4280 <PopOutgoingMidiByte+0xde>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    4276:	80 91 dd 05 	lds	r24, 0x05DD
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    427a:	10 92 d6 05 	sts	0x05D6, r1
    427e:	08 95       	ret
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4280:	80 93 df 05 	sts	0x05DF, r24
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    4284:	95 e0       	ldi	r25, 0x05	; 5
    4286:	0e c0       	rjmp	.+28     	; 0x42a4 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4288:	80 91 db 05 	lds	r24, 0x05DB
    428c:	80 6b       	ori	r24, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    428e:	90 91 df 05 	lds	r25, 0x05DF
    4292:	98 13       	cpse	r25, r24
    4294:	04 c0       	rjmp	.+8      	; 0x429e <PopOutgoingMidiByte+0xfc>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    4296:	80 91 dd 05 	lds	r24, 0x05DD
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    429a:	97 e0       	ldi	r25, 0x07	; 7
    429c:	03 c0       	rjmp	.+6      	; 0x42a4 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    429e:	80 93 df 05 	sts	0x05DF, r24
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    42a2:	96 e0       	ldi	r25, 0x06	; 6
    42a4:	90 93 d6 05 	sts	0x05D6, r25
    42a8:	08 95       	ret
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    42aa:	83 e0       	ldi	r24, 0x03	; 3
    42ac:	01 c0       	rjmp	.+2      	; 0x42b0 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    42ae:	84 e0       	ldi	r24, 0x04	; 4
    42b0:	80 93 d6 05 	sts	0x05D6, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    42b4:	80 91 dd 05 	lds	r24, 0x05DD
    42b8:	08 95       	ret
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    42ba:	10 92 d6 05 	sts	0x05D6, r1
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
    42be:	80 e4       	ldi	r24, 0x40	; 64
    42c0:	08 95       	ret
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    42c2:	10 92 d6 05 	sts	0x05D6, r1
    42c6:	0a c0       	rjmp	.+20     	; 0x42dc <PopOutgoingMidiByte+0x13a>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    42c8:	10 92 d6 05 	sts	0x05D6, r1
    42cc:	f3 cf       	rjmp	.-26     	; 0x42b4 <PopOutgoingMidiByte+0x112>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    42ce:	87 e0       	ldi	r24, 0x07	; 7
    42d0:	ef cf       	rjmp	.-34     	; 0x42b0 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);								// Return the first data byte.
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    42d2:	10 92 d6 05 	sts	0x05D6, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    42d6:	80 91 de 05 	lds	r24, 0x05DE
    42da:	08 95       	ret

			}
			break;

			default:
			theByte=0;		// Make compiler happy.
    42dc:	80 e0       	ldi	r24, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    42de:	08 95       	ret

000042e0 <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    42e0:	8a b1       	in	r24, 0x0a	; 10
    42e2:	8f 7c       	andi	r24, 0xCF	; 207
    42e4:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    42e6:	8b b1       	in	r24, 0x0b	; 11
    42e8:	80 63       	ori	r24, 0x30	; 48
    42ea:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    42ec:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    42f0:	e4 e6       	ldi	r30, 0x64	; 100
    42f2:	f0 e0       	ldi	r31, 0x00	; 0
    42f4:	80 81       	ld	r24, Z
    42f6:	80 61       	ori	r24, 0x10	; 16
    42f8:	80 83       	st	Z, r24
    42fa:	08 95       	ret

000042fc <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    42fc:	e4 e6       	ldi	r30, 0x64	; 100
    42fe:	f0 e0       	ldi	r31, 0x00	; 0
    4300:	80 81       	ld	r24, Z
    4302:	8f 7e       	andi	r24, 0xEF	; 239
    4304:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    4306:	ec ec       	ldi	r30, 0xCC	; 204
    4308:	f0 e0       	ldi	r31, 0x00	; 0
    430a:	11 82       	std	Z+1, r1	; 0x01
    430c:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    430e:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    4310:	80 ec       	ldi	r24, 0xC0	; 192
    4312:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    4316:	88 e1       	ldi	r24, 0x18	; 24
    4318:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    431c:	81 e0       	ldi	r24, 0x01	; 1
    431e:	90 e0       	ldi	r25, 0x00	; 0
    4320:	91 83       	std	Z+1, r25	; 0x01
    4322:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    4324:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS high.
    4326:	5d 9a       	sbi	0x0b, 5	; 11
    4328:	08 95       	ret

0000432a <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    432a:	5d 9a       	sbi	0x0b, 5	; 11
    432c:	08 95       	ret

0000432e <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    432e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    4330:	5d 98       	cbi	0x0b, 5	; 11
    4332:	08 95       	ret

00004334 <TransferSdByte>:
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4334:	90 91 c8 00 	lds	r25, 0x00C8
    4338:	95 ff       	sbrs	r25, 5
    433a:	fc cf       	rjmp	.-8      	; 0x4334 <TransferSdByte>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    433c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4340:	80 91 c8 00 	lds	r24, 0x00C8
    4344:	87 ff       	sbrs	r24, 7
    4346:	fc cf       	rjmp	.-8      	; 0x4340 <TransferSdByte+0xc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4348:	80 91 ce 00 	lds	r24, 0x00CE
}
    434c:	08 95       	ret

0000434e <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    434e:	80 91 c8 00 	lds	r24, 0x00C8
    4352:	80 64       	ori	r24, 0x40	; 64
    4354:	80 93 c8 00 	sts	0x00C8, r24
	TransferSdByte(0xFF);	
    4358:	8f ef       	ldi	r24, 0xFF	; 255
    435a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    435e:	80 91 c8 00 	lds	r24, 0x00C8
    4362:	86 ff       	sbrs	r24, 6
    4364:	fc cf       	rjmp	.-8      	; 0x435e <SendDummyByte+0x10>
		;
}
    4366:	08 95       	ret

00004368 <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    4368:	df 92       	push	r13
    436a:	ef 92       	push	r14
    436c:	ff 92       	push	r15
    436e:	0f 93       	push	r16
    4370:	1f 93       	push	r17
    4372:	cf 93       	push	r28
    4374:	df 93       	push	r29
    4376:	c8 2f       	mov	r28, r24
    4378:	04 2f       	mov	r16, r20
    437a:	f5 2e       	mov	r15, r21
    437c:	e6 2e       	mov	r14, r22
    437e:	d7 2e       	mov	r13, r23
	unsigned char
		i,
		response,
		tmpCrc;

	StartSdTransfer();		// Assert CS
    4380:	0e 94 97 21 	call	0x432e	; 0x432e <StartSdTransfer>
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.
    4384:	8f ef       	ldi	r24, 0xFF	; 255
    4386:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    438a:	c7 ff       	sbrs	r28, 7
    438c:	31 c0       	rjmp	.+98     	; 0x43f0 <SendSdCommand+0x88>
	{
		TransferSdByte(0x40|CMD55);		// Put the start and transmission bits on the front of the command index
    438e:	87 e7       	ldi	r24, 0x77	; 119
    4390:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4394:	80 e0       	ldi	r24, 0x00	; 0
    4396:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    439a:	80 e0       	ldi	r24, 0x00	; 0
    439c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    43a0:	80 e0       	ldi	r24, 0x00	; 0
    43a2:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		TransferSdByte(0);				// No argument					
    43a6:	80 e0       	ldi	r24, 0x00	; 0
    43a8:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		TransferSdByte(0x01);			// Send the CRC7 byte (and stop bit)
    43ac:	81 e0       	ldi	r24, 0x01	; 1
    43ae:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    43b2:	1a e0       	ldi	r17, 0x0A	; 10

		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    43b4:	8f ef       	ldi	r24, 0xFF	; 255
    43b6:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    43ba:	d8 2f       	mov	r29, r24
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    43bc:	8f 3f       	cpi	r24, 0xFF	; 255
    43be:	11 f4       	brne	.+4      	; 0x43c4 <SendSdCommand+0x5c>
    43c0:	11 50       	subi	r17, 0x01	; 1
    43c2:	c1 f7       	brne	.-16     	; 0x43b4 <SendSdCommand+0x4c>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    43c4:	90 91 c8 00 	lds	r25, 0x00C8
    43c8:	90 64       	ori	r25, 0x40	; 64
    43ca:	90 93 c8 00 	sts	0x00C8, r25
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
    43ce:	8f ef       	ldi	r24, 0xFF	; 255
    43d0:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    43d4:	80 91 c8 00 	lds	r24, 0x00C8
    43d8:	86 ff       	sbrs	r24, 6
    43da:	fc cf       	rjmp	.-8      	; 0x43d4 <SendSdCommand+0x6c>
			;

		if(response>1)				// Something wrong?
    43dc:	d2 30       	cpi	r29, 0x02	; 2
    43de:	18 f0       	brcs	.+6      	; 0x43e6 <SendSdCommand+0x7e>
		{
			EndSdTransfer();	// Bring CS high
    43e0:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
			return(response);	// ACMD preambe returned something weird.  Bail.
    43e4:	34 c0       	rjmp	.+104    	; 0x444e <SendSdCommand+0xe6>
		}

		EndSdTransfer();	// Bring CS high
    43e6:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    43ea:	cf 77       	andi	r28, 0x7F	; 127
		StartSdTransfer();	// Assert CS
    43ec:	0e 94 97 21 	call	0x432e	; 0x432e <StartSdTransfer>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    43f0:	8c 2f       	mov	r24, r28
    43f2:	80 64       	ori	r24, 0x40	; 64
    43f4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    43f8:	8d 2d       	mov	r24, r13
    43fa:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    43fe:	8e 2d       	mov	r24, r14
    4400:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    4404:	8f 2d       	mov	r24, r15
    4406:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	TransferSdByte((unsigned char)argument);			// LSB of argument
    440a:	80 2f       	mov	r24, r16
    440c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    4410:	cc 23       	and	r28, r28
    4412:	21 f0       	breq	.+8      	; 0x441c <SendSdCommand+0xb4>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    4414:	c8 30       	cpi	r28, 0x08	; 8
    4416:	21 f0       	breq	.+8      	; 0x4420 <SendSdCommand+0xb8>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)
    4418:	81 e0       	ldi	r24, 0x01	; 1
    441a:	03 c0       	rjmp	.+6      	; 0x4422 <SendSdCommand+0xba>

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
	{
		tmpCrc=0x95;
    441c:	85 e9       	ldi	r24, 0x95	; 149
    441e:	01 c0       	rjmp	.+2      	; 0x4422 <SendSdCommand+0xba>
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    4420:	87 e8       	ldi	r24, 0x87	; 135
	}
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
    4422:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    4426:	cc 30       	cpi	r28, 0x0C	; 12
    4428:	19 f4       	brne	.+6      	; 0x4430 <SendSdCommand+0xc8>
	{
		TransferSdByte(DUMMY_BYTE);		// Skip "stuff byte".
    442a:	8f ef       	ldi	r24, 0xFF	; 255
    442c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    4430:	1a e0       	ldi	r17, 0x0A	; 10
	
	i=10;		// Give the SD card a 10 byte timeout in which to respond.
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    4432:	8f ef       	ldi	r24, 0xFF	; 255
    4434:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4438:	d8 2f       	mov	r29, r24
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    443a:	8f 3f       	cpi	r24, 0xFF	; 255
    443c:	11 f4       	brne	.+4      	; 0x4442 <SendSdCommand+0xda>
    443e:	11 50       	subi	r17, 0x01	; 1
    4440:	c1 f7       	brne	.-16     	; 0x4432 <SendSdCommand+0xca>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    4442:	c8 30       	cpi	r28, 0x08	; 8
    4444:	21 f0       	breq	.+8      	; 0x444e <SendSdCommand+0xe6>
    4446:	ca 33       	cpi	r28, 0x3A	; 58
    4448:	11 f0       	breq	.+4      	; 0x444e <SendSdCommand+0xe6>
	{
		SendDummyByte();	
    444a:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    444e:	8d 2f       	mov	r24, r29
    4450:	df 91       	pop	r29
    4452:	cf 91       	pop	r28
    4454:	1f 91       	pop	r17
    4456:	0f 91       	pop	r16
    4458:	ff 90       	pop	r15
    445a:	ef 90       	pop	r14
    445c:	df 90       	pop	r13
    445e:	08 95       	ret

00004460 <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    4460:	ef 92       	push	r14
    4462:	ff 92       	push	r15
    4464:	0f 93       	push	r16
    4466:	1f 93       	push	r17
    4468:	cf 93       	push	r28
    446a:	df 93       	push	r29
    446c:	00 d0       	rcall	.+0      	; 0x446e <SdHandshake+0xe>
    446e:	00 d0       	rcall	.+0      	; 0x4470 <SdHandshake+0x10>
    4470:	1f 92       	push	r1
    4472:	cd b7       	in	r28, 0x3d	; 61
    4474:	de b7       	in	r29, 0x3e	; 62
	bool
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
    4476:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
    447a:	14 e1       	ldi	r17, 0x14	; 20
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    447c:	80 91 c8 00 	lds	r24, 0x00C8
    4480:	80 64       	ori	r24, 0x40	; 64
    4482:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
    4486:	8f ef       	ldi	r24, 0xFF	; 255
    4488:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    448c:	11 50       	subi	r17, 0x01	; 1
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    448e:	b1 f7       	brne	.-20     	; 0x447c <SdHandshake+0x1c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4490:	80 91 c8 00 	lds	r24, 0x00C8
    4494:	86 ff       	sbrs	r24, 6
    4496:	fc cf       	rjmp	.-8      	; 0x4490 <SdHandshake+0x30>


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
    4498:	0e 94 97 21 	call	0x432e	; 0x432e <StartSdTransfer>
    449c:	00 e0       	ldi	r16, 0x00	; 0
    449e:	12 e0       	ldi	r17, 0x02	; 2
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    44a0:	80 91 c8 00 	lds	r24, 0x00C8
    44a4:	80 64       	ori	r24, 0x40	; 64
    44a6:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(0xFF);	
    44aa:	8f ef       	ldi	r24, 0xFF	; 255
    44ac:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    44b0:	01 50       	subi	r16, 0x01	; 1
    44b2:	11 09       	sbc	r17, r1

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    44b4:	a9 f7       	brne	.-22     	; 0x44a0 <SdHandshake+0x40>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    44b6:	80 91 c8 00 	lds	r24, 0x00C8
    44ba:	86 ff       	sbrs	r24, 6
    44bc:	fc cf       	rjmp	.-8      	; 0x44b6 <SdHandshake+0x56>
		;
	EndSdTransfer();
    44be:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    44c2:	40 e0       	ldi	r20, 0x00	; 0
    44c4:	50 e0       	ldi	r21, 0x00	; 0
    44c6:	ba 01       	movw	r22, r20
    44c8:	80 e0       	ldi	r24, 0x00	; 0
    44ca:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    44ce:	80 91 c8 00 	lds	r24, 0x00C8
    44d2:	86 ff       	sbrs	r24, 6
    44d4:	fc cf       	rjmp	.-8      	; 0x44ce <SdHandshake+0x6e>
		;
	EndSdTransfer();
    44d6:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    44da:	40 e0       	ldi	r20, 0x00	; 0
    44dc:	50 e0       	ldi	r21, 0x00	; 0
    44de:	ba 01       	movw	r22, r20
    44e0:	80 e0       	ldi	r24, 0x00	; 0
    44e2:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    44e6:	81 30       	cpi	r24, 0x01	; 1
    44e8:	11 f0       	breq	.+4      	; 0x44ee <SdHandshake+0x8e>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
    44ea:	80 e0       	ldi	r24, 0x00	; 0
    44ec:	b1 c0       	rjmp	.+354    	; 0x4650 <SdHandshake+0x1f0>
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high
    44ee:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    44f2:	4a ea       	ldi	r20, 0xAA	; 170
    44f4:	51 e0       	ldi	r21, 0x01	; 1
    44f6:	60 e0       	ldi	r22, 0x00	; 0
    44f8:	70 e0       	ldi	r23, 0x00	; 0
    44fa:	88 e0       	ldi	r24, 0x08	; 8
    44fc:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    4500:	81 30       	cpi	r24, 0x01	; 1
    4502:	09 f0       	breq	.+2      	; 0x4506 <SdHandshake+0xa6>
    4504:	6e c0       	rjmp	.+220    	; 0x45e2 <SdHandshake+0x182>
    4506:	8e 01       	movw	r16, r28
    4508:	0f 5f       	subi	r16, 0xFF	; 255
    450a:	1f 4f       	sbci	r17, 0xFF	; 255
//-----------------------------------------------------------------------
// SD SPI Mode and Initialization Functions
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

bool SdHandshake(void)
    450c:	7e 01       	movw	r14, r28
    450e:	85 e0       	ldi	r24, 0x05	; 5
    4510:	e8 0e       	add	r14, r24
    4512:	f1 1c       	adc	r15, r1

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    4514:	8f ef       	ldi	r24, 0xFF	; 255
    4516:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    451a:	f8 01       	movw	r30, r16
    451c:	81 93       	st	Z+, r24
    451e:	8f 01       	movw	r16, r30
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    4520:	ee 15       	cp	r30, r14
    4522:	ff 05       	cpc	r31, r15
    4524:	b9 f7       	brne	.-18     	; 0x4514 <SdHandshake+0xb4>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    4526:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
			EndSdTransfer();		// Bring CS high
    452a:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    452e:	8b 81       	ldd	r24, Y+3	; 0x03
    4530:	81 30       	cpi	r24, 0x01	; 1
    4532:	d9 f6       	brne	.-74     	; 0x44ea <SdHandshake+0x8a>
    4534:	8c 81       	ldd	r24, Y+4	; 0x04
    4536:	8a 3a       	cpi	r24, 0xAA	; 170
    4538:	c1 f6       	brne	.-80     	; 0x44ea <SdHandshake+0x8a>
			{				
				SetTimer(TIMER_SD,SECOND);
    453a:	64 ec       	ldi	r22, 0xC4	; 196
    453c:	74 e0       	ldi	r23, 0x04	; 4
    453e:	83 e0       	ldi	r24, 0x03	; 3
    4540:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    4544:	04 c0       	rjmp	.+8      	; 0x454e <SdHandshake+0xee>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    4546:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
    454a:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    454e:	83 e0       	ldi	r24, 0x03	; 3
    4550:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4554:	88 23       	and	r24, r24
    4556:	31 f0       	breq	.+12     	; 0x4564 <SdHandshake+0x104>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    4558:	83 e0       	ldi	r24, 0x03	; 3
    455a:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    455e:	88 23       	and	r24, r24
    4560:	81 f0       	breq	.+32     	; 0x4582 <SdHandshake+0x122>
    4562:	c3 cf       	rjmp	.-122    	; 0x44ea <SdHandshake+0x8a>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    4564:	40 e0       	ldi	r20, 0x00	; 0
    4566:	50 e0       	ldi	r21, 0x00	; 0
    4568:	ba 01       	movw	r22, r20
    456a:	89 ea       	ldi	r24, 0xA9	; 169
    456c:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    4570:	81 11       	cpse	r24, r1
    4572:	e9 cf       	rjmp	.-46     	; 0x4546 <SdHandshake+0xe6>
    4574:	f1 cf       	rjmp	.-30     	; 0x4558 <SdHandshake+0xf8>
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    4576:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    457a:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <HandleSoftclock>
						EndSdTransfer();		// Bring CS high.
    457e:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4582:	83 e0       	ldi	r24, 0x03	; 3
    4584:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4588:	88 23       	and	r24, r24
    458a:	31 f0       	breq	.+12     	; 0x4598 <SdHandshake+0x138>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    458c:	83 e0       	ldi	r24, 0x03	; 3
    458e:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4592:	88 23       	and	r24, r24
    4594:	51 f0       	breq	.+20     	; 0x45aa <SdHandshake+0x14a>
    4596:	a9 cf       	rjmp	.-174    	; 0x44ea <SdHandshake+0x8a>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4598:	40 e0       	ldi	r20, 0x00	; 0
    459a:	50 e0       	ldi	r21, 0x00	; 0
    459c:	ba 01       	movw	r22, r20
    459e:	8a e3       	ldi	r24, 0x3A	; 58
    45a0:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    45a4:	81 11       	cpse	r24, r1
    45a6:	e7 cf       	rjmp	.-50     	; 0x4576 <SdHandshake+0x116>
    45a8:	f1 cf       	rjmp	.-30     	; 0x458c <SdHandshake+0x12c>
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    45aa:	8f ef       	ldi	r24, 0xFF	; 255
    45ac:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    45b0:	8f ef       	ldi	r24, 0xFF	; 255
    45b2:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    45b6:	8f ef       	ldi	r24, 0xFF	; 255
    45b8:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    45bc:	8f ef       	ldi	r24, 0xFF	; 255
    45be:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    45c2:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
						EndSdTransfer();			// Bring CS high.
    45c6:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    45ca:	40 e0       	ldi	r20, 0x00	; 0
    45cc:	52 e0       	ldi	r21, 0x02	; 2
    45ce:	60 e0       	ldi	r22, 0x00	; 0
    45d0:	70 e0       	ldi	r23, 0x00	; 0
    45d2:	80 e1       	ldi	r24, 0x10	; 16
    45d4:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
						EndSdTransfer();						// Bring CS high.
    45d8:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
						SendDummyByte();						
    45dc:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
    45e0:	36 c0       	rjmp	.+108    	; 0x464e <SdHandshake+0x1ee>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    45e2:	0e 94 a7 21 	call	0x434e	; 0x434e <SendDummyByte>
			EndSdTransfer();					// Bring CS high
    45e6:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    45ea:	40 e0       	ldi	r20, 0x00	; 0
    45ec:	50 e0       	ldi	r21, 0x00	; 0
    45ee:	ba 01       	movw	r22, r20
    45f0:	89 ea       	ldi	r24, 0xA9	; 169
    45f2:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    45f6:	82 30       	cpi	r24, 0x02	; 2
    45f8:	08 f0       	brcs	.+2      	; 0x45fc <SdHandshake+0x19c>
    45fa:	77 cf       	rjmp	.-274    	; 0x44ea <SdHandshake+0x8a>
			{
				EndSdTransfer();			// Bring CS high.
    45fc:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
				SetTimer(TIMER_SD,SECOND);
    4600:	64 ec       	ldi	r22, 0xC4	; 196
    4602:	74 e0       	ldi	r23, 0x04	; 4
    4604:	83 e0       	ldi	r24, 0x03	; 3
    4606:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    460a:	04 c0       	rjmp	.+8      	; 0x4614 <SdHandshake+0x1b4>
				{
					HandleSoftclock();	// Keep the timer timing.
    460c:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <HandleSoftclock>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    4610:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4614:	83 e0       	ldi	r24, 0x03	; 3
    4616:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    461a:	88 23       	and	r24, r24
    461c:	31 f0       	breq	.+12     	; 0x462a <SdHandshake+0x1ca>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    461e:	83 e0       	ldi	r24, 0x03	; 3
    4620:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4624:	81 11       	cpse	r24, r1
    4626:	61 cf       	rjmp	.-318    	; 0x44ea <SdHandshake+0x8a>
    4628:	09 c0       	rjmp	.+18     	; 0x463c <SdHandshake+0x1dc>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    462a:	40 e0       	ldi	r20, 0x00	; 0
    462c:	50 e0       	ldi	r21, 0x00	; 0
    462e:	ba 01       	movw	r22, r20
    4630:	89 ea       	ldi	r24, 0xA9	; 169
    4632:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    4636:	81 11       	cpse	r24, r1
    4638:	e9 cf       	rjmp	.-46     	; 0x460c <SdHandshake+0x1ac>
    463a:	f1 cf       	rjmp	.-30     	; 0x461e <SdHandshake+0x1be>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    463c:	40 e0       	ldi	r20, 0x00	; 0
    463e:	52 e0       	ldi	r21, 0x02	; 2
    4640:	60 e0       	ldi	r22, 0x00	; 0
    4642:	70 e0       	ldi	r23, 0x00	; 0
    4644:	80 e1       	ldi	r24, 0x10	; 16
    4646:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
					EndSdTransfer();						// Bring CS high.
    464a:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					cardValid=true;							// SDC v1 card, good to go
    464e:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}

	EndSdTransfer();	// Bring CS high
    4650:	8d 83       	std	Y+5, r24	; 0x05
    4652:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    4656:	8d 81       	ldd	r24, Y+5	; 0x05
    4658:	0f 90       	pop	r0
    465a:	0f 90       	pop	r0
    465c:	0f 90       	pop	r0
    465e:	0f 90       	pop	r0
    4660:	0f 90       	pop	r0
    4662:	df 91       	pop	r29
    4664:	cf 91       	pop	r28
    4666:	1f 91       	pop	r17
    4668:	0f 91       	pop	r16
    466a:	ff 90       	pop	r15
    466c:	ef 90       	pop	r14
    466e:	08 95       	ret

00004670 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    4670:	ab 01       	movw	r20, r22
    4672:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4674:	89 e0       	ldi	r24, 0x09	; 9
    4676:	44 0f       	add	r20, r20
    4678:	55 1f       	adc	r21, r21
    467a:	66 1f       	adc	r22, r22
    467c:	77 1f       	adc	r23, r23
    467e:	8a 95       	dec	r24
    4680:	d1 f7       	brne	.-12     	; 0x4676 <SdBeginSingleBlockRead+0x6>

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    4682:	81 e1       	ldi	r24, 0x11	; 17
    4684:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    4688:	91 e0       	ldi	r25, 0x01	; 1
    468a:	81 11       	cpse	r24, r1
    468c:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    468e:	89 2f       	mov	r24, r25
    4690:	08 95       	ret

00004692 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    4692:	ab 01       	movw	r20, r22
    4694:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4696:	99 e0       	ldi	r25, 0x09	; 9
    4698:	44 0f       	add	r20, r20
    469a:	55 1f       	adc	r21, r21
    469c:	66 1f       	adc	r22, r22
    469e:	77 1f       	adc	r23, r23
    46a0:	9a 95       	dec	r25
    46a2:	d1 f7       	brne	.-12     	; 0x4698 <SdBeginSingleBlockWrite+0x6>

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    46a4:	88 e1       	ldi	r24, 0x18	; 24
    46a6:	0e 94 b4 21 	call	0x4368	; 0x4368 <SendSdCommand>
    46aa:	91 e0       	ldi	r25, 0x01	; 1
    46ac:	81 11       	cpse	r24, r1
    46ae:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    46b0:	89 2f       	mov	r24, r25
    46b2:	08 95       	ret

000046b4 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    46b4:	cf 93       	push	r28
    46b6:	df 93       	push	r29
    46b8:	cd b7       	in	r28, 0x3d	; 61
    46ba:	de b7       	in	r29, 0x3e	; 62
    46bc:	28 97       	sbiw	r28, 0x08	; 8
    46be:	0f b6       	in	r0, 0x3f	; 63
    46c0:	f8 94       	cli
    46c2:	de bf       	out	0x3e, r29	; 62
    46c4:	0f be       	out	0x3f, r0	; 63
    46c6:	cd bf       	out	0x3d, r28	; 61
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    46c8:	1f ef       	ldi	r17, 0xFF	; 255
    46ca:	10 93 64 00 	sts	0x0064, r17
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    46ce:	85 b7       	in	r24, 0x35	; 53
    46d0:	8f 7e       	andi	r24, 0xEF	; 239
    46d2:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    46d4:	8f ee       	ldi	r24, 0xEF	; 239
    46d6:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    46d8:	88 e0       	ldi	r24, 0x08	; 8
    46da:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    46dc:	80 e8       	ldi	r24, 0x80	; 128
    46de:	8a b9       	out	0x0a, r24	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    46e0:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    46e2:	96 e0       	ldi	r25, 0x06	; 6
    46e4:	92 b9       	out	0x02, r25	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    46e6:	9e e3       	ldi	r25, 0x3E	; 62
    46e8:	91 b9       	out	0x01, r25	; 1

	DDRB=0xFF;			// Latch port to OP.
    46ea:	14 b9       	out	0x04, r17	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    46ec:	85 b9       	out	0x05, r24	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    46ee:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    46f0:	14 b9       	out	0x04, r17	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    46f2:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    46f4:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    46f6:	0e 94 7e 21 	call	0x42fc	; 0x42fc <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    46fa:	66 e2       	ldi	r22, 0x26	; 38
    46fc:	70 e0       	ldi	r23, 0x00	; 0
    46fe:	81 e0       	ldi	r24, 0x01	; 1
    4700:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    4704:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    4706:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    4708:	80 b1       	in	r24, 0x00	; 0
    470a:	80 7c       	andi	r24, 0xC0	; 192
    470c:	80 93 ba 05 	sts	0x05BA, r24
	encoderValue=0;							// zero our relative position.
    4710:	10 92 6c 05 	sts	0x056C, r1
	newEncoder=false;
    4714:	10 92 6a 05 	sts	0x056A, r1
	encoderCw=false;
    4718:	10 92 ae 05 	sts	0x05AE, r1
	encoderCcw=false;
    471c:	10 92 af 05 	sts	0x05AF, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    4720:	10 92 5b 05 	sts	0x055B, r1
	ledBlinkMask=0;
    4724:	10 92 ad 05 	sts	0x05AD, r1
	WriteLedLatch(0);	// ...send the LED value to the latch.
    4728:	80 e0       	ldi	r24, 0x00	; 0
    472a:	0e 94 37 05 	call	0xa6e	; 0xa6e <WriteLedLatch>

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    472e:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <InitMidi>
	InitUart0();
    4732:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    4736:	80 91 64 00 	lds	r24, 0x0064
    473a:	8e 7f       	andi	r24, 0xFE	; 254
    473c:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    4740:	80 e6       	ldi	r24, 0x60	; 96
    4742:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    4746:	81 e0       	ldi	r24, 0x01	; 1
    4748:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    474c:	85 e9       	ldi	r24, 0x95	; 149
    474e:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    4752:	80 91 7a 00 	lds	r24, 0x007A
    4756:	80 64       	ori	r24, 0x40	; 64
    4758:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    475c:	80 91 64 00 	lds	r24, 0x0064
    4760:	8f 7d       	andi	r24, 0xDF	; 223
    4762:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    4766:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    476a:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    476c:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    476e:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    4770:	10 92 41 06 	sts	0x0641, r1
    4774:	10 92 40 06 	sts	0x0640, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    4778:	83 e0       	ldi	r24, 0x03	; 3
    477a:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    477c:	80 91 64 00 	lds	r24, 0x0064
    4780:	87 7f       	andi	r24, 0xF7	; 247
    4782:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    4786:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    478a:	8f ef       	ldi	r24, 0xFF	; 255
    478c:	9f ef       	ldi	r25, 0xFF	; 255
    478e:	90 93 89 00 	sts	0x0089, r25
    4792:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    4796:	90 93 8b 00 	sts	0x008B, r25
    479a:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    479e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    47a2:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    47a6:	10 92 85 00 	sts	0x0085, r1
    47aa:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    47ae:	16 bb       	out	0x16, r17	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    47b0:	10 92 55 05 	sts	0x0555, r1
	keyState=0;
    47b4:	10 92 56 05 	sts	0x0556, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    47b8:	10 92 57 05 	sts	0x0557, r1
	cardDetect=false;
    47bc:	10 92 58 05 	sts	0x0558, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    47c0:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    47c2:	86 ee       	ldi	r24, 0xE6	; 230
    47c4:	9a e0       	ldi	r25, 0x0A	; 10
    47c6:	90 93 e3 05 	sts	0x05E3, r25
    47ca:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    47ce:	10 92 59 05 	sts	0x0559, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    47d2:	aa 24       	eor	r10, r10
    47d4:	aa 94       	dec	r10
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    47d6:	ee 24       	eor	r14, r14
    47d8:	e3 94       	inc	r14
    47da:	f1 2c       	mov	r15, r1
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    47dc:	00 e0       	ldi	r16, 0x00	; 0
    47de:	12 e0       	ldi	r17, 0x02	; 2
				TransferSdByte('S');				// These four characters indicate this card holds sample data (as opposed to Nintendo DPCMs, or a boot image)
				TransferSdByte('A');
				TransferSdByte('M');
				TransferSdByte('P');

				bytesLeftInBlock-=8;
    47e0:	f8 e0       	ldi	r31, 0x08	; 8
    47e2:	8f 2e       	mov	r8, r31
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    47e4:	a7 e0       	ldi	r26, 0x07	; 7
    47e6:	7a 2e       	mov	r7, r26
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
						;

					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    47e8:	bb e0       	ldi	r27, 0x0B	; 11
    47ea:	6b 2e       	mov	r6, r27

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    47ec:	8e e0       	ldi	r24, 0x0E	; 14
    47ee:	b8 2e       	mov	r11, r24
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    47f0:	9d e0       	ldi	r25, 0x0D	; 13
    47f2:	99 2e       	mov	r9, r25
//-----------------------------------------------------------------------
// Program main loop.
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
    47f4:	6e 01       	movw	r12, r28
    47f6:	29 e0       	ldi	r18, 0x09	; 9
    47f8:	c2 0e       	add	r12, r18
    47fa:	d1 1c       	adc	r13, r1
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    47fc:	81 e0       	ldi	r24, 0x01	; 1
    47fe:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4802:	88 23       	and	r24, r24
    4804:	d9 f0       	breq	.+54     	; 0x483c <main+0x188>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    4806:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    4808:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    480a:	a5 b8       	out	0x05, r10	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    480c:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    480e:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    4810:	00 00       	nop
		asm volatile("nop"::);
    4812:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    4814:	83 b1       	in	r24, 0x03	; 3
    4816:	80 95       	com	r24
    4818:	80 93 56 05 	sts	0x0556, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    481c:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    481e:	a4 b8       	out	0x04, r10	; 4
		SREG=sreg;					// Stop tying up interrupts
    4820:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    4822:	35 99       	sbic	0x06, 5	; 6
    4824:	04 c0       	rjmp	.+8      	; 0x482e <main+0x17a>
		{
			cardDetect=true;
    4826:	81 e0       	ldi	r24, 0x01	; 1
    4828:	80 93 58 05 	sts	0x0558, r24
    482c:	02 c0       	rjmp	.+4      	; 0x4832 <main+0x17e>
		}
		else
		{
			cardDetect=false;
    482e:	10 92 58 05 	sts	0x0558, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
    4832:	66 e2       	ldi	r22, 0x26	; 38
    4834:	70 e0       	ldi	r23, 0x00	; 0
    4836:	81 e0       	ldi	r24, 0x01	; 1
    4838:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    483c:	90 91 56 05 	lds	r25, 0x0556
    4840:	80 91 bb 05 	lds	r24, 0x05BB
    4844:	80 95       	com	r24
    4846:	89 23       	and	r24, r25
    4848:	80 93 55 05 	sts	0x0555, r24
	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been held for more than one debounce loop.
    484c:	80 95       	com	r24
    484e:	89 23       	and	r24, r25
    4850:	80 93 69 05 	sts	0x0569, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    4854:	90 93 bb 05 	sts	0x05BB, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;

	newEncoder=false;	// Clear variables which indicate changes in encoder readings
    4858:	10 92 6a 05 	sts	0x056A, r1
	encoderCw=false;
    485c:	10 92 ae 05 	sts	0x05AE, r1
	encoderCcw=false;
    4860:	10 92 af 05 	sts	0x05AF, r1

	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    4864:	20 91 40 06 	lds	r18, 0x0640
    4868:	30 91 41 06 	lds	r19, 0x0641
    486c:	80 91 bc 05 	lds	r24, 0x05BC
    4870:	90 91 bd 05 	lds	r25, 0x05BD
    4874:	28 17       	cp	r18, r24
    4876:	39 07       	cpc	r19, r25
    4878:	09 f4       	brne	.+2      	; 0x487c <main+0x1c8>
    487a:	43 c0       	rjmp	.+134    	; 0x4902 <main+0x24e>
	{
		lastEncTime=systemTicks;					// update last read time.
    487c:	80 91 40 06 	lds	r24, 0x0640
    4880:	90 91 41 06 	lds	r25, 0x0641
    4884:	90 93 bd 05 	sts	0x05BD, r25
    4888:	80 93 bc 05 	sts	0x05BC, r24

		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    488c:	80 b1       	in	r24, 0x00	; 0
    488e:	80 7c       	andi	r24, 0xC0	; 192
    4890:	80 93 ba 05 	sts	0x05BA, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    4894:	90 91 be 05 	lds	r25, 0x05BE
    4898:	89 17       	cp	r24, r25
    489a:	99 f1       	breq	.+102    	; 0x4902 <main+0x24e>
		{
			if(encoderState==ENC_POS_A)
    489c:	81 11       	cpse	r24, r1
    489e:	06 c0       	rjmp	.+12     	; 0x48ac <main+0x1f8>
			{
				if(lastEncoderState==ENC_POS_D)
    48a0:	90 38       	cpi	r25, 0x80	; 128
    48a2:	09 f4       	brne	.+2      	; 0x48a6 <main+0x1f2>
    48a4:	17 c0       	rjmp	.+46     	; 0x48d4 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_B)
    48a6:	90 34       	cpi	r25, 0x40	; 64
    48a8:	51 f5       	brne	.+84     	; 0x48fe <main+0x24a>
    48aa:	1f c0       	rjmp	.+62     	; 0x48ea <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_B)
    48ac:	80 34       	cpi	r24, 0x40	; 64
    48ae:	31 f4       	brne	.+12     	; 0x48bc <main+0x208>
			{
				if(lastEncoderState==ENC_POS_A)
    48b0:	91 11       	cpse	r25, r1
    48b2:	01 c0       	rjmp	.+2      	; 0x48b6 <main+0x202>
    48b4:	0f c0       	rjmp	.+30     	; 0x48d4 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_C)
    48b6:	90 3c       	cpi	r25, 0xC0	; 192
    48b8:	11 f5       	brne	.+68     	; 0x48fe <main+0x24a>
    48ba:	17 c0       	rjmp	.+46     	; 0x48ea <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_C)
    48bc:	80 3c       	cpi	r24, 0xC0	; 192
    48be:	31 f4       	brne	.+12     	; 0x48cc <main+0x218>
			{
				if(lastEncoderState==ENC_POS_B)
    48c0:	90 34       	cpi	r25, 0x40	; 64
    48c2:	09 f4       	brne	.+2      	; 0x48c6 <main+0x212>
    48c4:	07 c0       	rjmp	.+14     	; 0x48d4 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_D)
    48c6:	90 38       	cpi	r25, 0x80	; 128
    48c8:	d1 f4       	brne	.+52     	; 0x48fe <main+0x24a>
    48ca:	0f c0       	rjmp	.+30     	; 0x48ea <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_D)
    48cc:	80 38       	cpi	r24, 0x80	; 128
    48ce:	b9 f4       	brne	.+46     	; 0x48fe <main+0x24a>
			{
				if(lastEncoderState==ENC_POS_C)
    48d0:	90 3c       	cpi	r25, 0xC0	; 192
    48d2:	49 f4       	brne	.+18     	; 0x48e6 <main+0x232>
				{
//					encoderValue++;
					encoderValue--;
    48d4:	90 91 6c 05 	lds	r25, 0x056C
    48d8:	91 50       	subi	r25, 0x01	; 1
    48da:	90 93 6c 05 	sts	0x056C, r25
					encoderCcw=true;
    48de:	91 e0       	ldi	r25, 0x01	; 1
    48e0:	90 93 af 05 	sts	0x05AF, r25
    48e4:	0a c0       	rjmp	.+20     	; 0x48fa <main+0x246>
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_A)
    48e6:	91 11       	cpse	r25, r1
    48e8:	0a c0       	rjmp	.+20     	; 0x48fe <main+0x24a>
				{
//					encoderValue--;
					encoderValue++;
    48ea:	90 91 6c 05 	lds	r25, 0x056C
    48ee:	9f 5f       	subi	r25, 0xFF	; 255
    48f0:	90 93 6c 05 	sts	0x056C, r25
					encoderCw=true;
    48f4:	91 e0       	ldi	r25, 0x01	; 1
    48f6:	90 93 ae 05 	sts	0x05AE, r25
					newEncoder=true;
    48fa:	90 93 6a 05 	sts	0x056A, r25
				}
			}

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    48fe:	80 93 be 05 	sts	0x05BE, r24

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    4902:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    4906:	80 91 ad 05 	lds	r24, 0x05AD
    490a:	88 23       	and	r24, r24
    490c:	e1 f1       	breq	.+120    	; 0x4986 <main+0x2d2>
    490e:	82 e0       	ldi	r24, 0x02	; 2
    4910:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4914:	88 23       	and	r24, r24
    4916:	b9 f1       	breq	.+110    	; 0x4986 <main+0x2d2>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    4918:	20 91 ad 05 	lds	r18, 0x05AD
    491c:	30 e0       	ldi	r19, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    491e:	f0 91 bf 05 	lds	r31, 0x05BF
    4922:	e0 91 5b 05 	lds	r30, 0x055B
    4926:	80 e0       	ldi	r24, 0x00	; 0
    4928:	90 e0       	ldi	r25, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    492a:	b9 01       	movw	r22, r18
    492c:	08 2e       	mov	r0, r24
    492e:	02 c0       	rjmp	.+4      	; 0x4934 <main+0x280>
    4930:	75 95       	asr	r23
    4932:	67 95       	ror	r22
    4934:	0a 94       	dec	r0
    4936:	e2 f7       	brpl	.-8      	; 0x4930 <main+0x27c>
    4938:	60 ff       	sbrs	r22, 0
    493a:	0e c0       	rjmp	.+28     	; 0x4958 <main+0x2a4>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    493c:	b7 01       	movw	r22, r14
    493e:	08 2e       	mov	r0, r24
    4940:	02 c0       	rjmp	.+4      	; 0x4946 <main+0x292>
    4942:	66 0f       	add	r22, r22
    4944:	77 1f       	adc	r23, r23
    4946:	0a 94       	dec	r0
    4948:	e2 f7       	brpl	.-8      	; 0x4942 <main+0x28e>
    494a:	ab 01       	movw	r20, r22
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    494c:	ff 23       	and	r31, r31
    494e:	11 f0       	breq	.+4      	; 0x4954 <main+0x2a0>
				{
					ledOnOffMask|=(1<<i);
    4950:	e6 2b       	or	r30, r22
    4952:	02 c0       	rjmp	.+4      	; 0x4958 <main+0x2a4>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    4954:	40 95       	com	r20
    4956:	e4 23       	and	r30, r20
    4958:	01 96       	adiw	r24, 0x01	; 1
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    495a:	88 30       	cpi	r24, 0x08	; 8
    495c:	91 05       	cpc	r25, r1
    495e:	29 f7       	brne	.-54     	; 0x492a <main+0x276>
    4960:	e0 93 5b 05 	sts	0x055B, r30
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    4964:	81 e0       	ldi	r24, 0x01	; 1
    4966:	90 91 bf 05 	lds	r25, 0x05BF
    496a:	91 11       	cpse	r25, r1
    496c:	80 e0       	ldi	r24, 0x00	; 0
    496e:	80 93 bf 05 	sts	0x05BF, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    4972:	68 e9       	ldi	r22, 0x98	; 152
    4974:	70 e0       	ldi	r23, 0x00	; 0
    4976:	82 e0       	ldi	r24, 0x02	; 2
    4978:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    497c:	80 91 5b 05 	lds	r24, 0x055B
    4980:	0e 94 37 05 	call	0xa6e	; 0xa6e <WriteLedLatch>
    4984:	0b c0       	rjmp	.+22     	; 0x499c <main+0x2e8>
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    4986:	50 90 5b 05 	lds	r5, 0x055B
    498a:	80 91 c0 05 	lds	r24, 0x05C0
    498e:	85 15       	cp	r24, r5
    4990:	29 f0       	breq	.+10     	; 0x499c <main+0x2e8>
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
    4992:	85 2d       	mov	r24, r5
    4994:	0e 94 37 05 	call	0xa6e	; 0xa6e <WriteLedLatch>
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    4998:	50 92 c0 05 	sts	0x05C0, r5
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    499c:	90 91 58 05 	lds	r25, 0x0558
    49a0:	80 91 57 05 	lds	r24, 0x0557
    49a4:	91 11       	cpse	r25, r1
    49a6:	06 c0       	rjmp	.+12     	; 0x49b4 <main+0x300>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    49a8:	88 23       	and	r24, r24
    49aa:	09 f4       	brne	.+2      	; 0x49ae <main+0x2fa>
    49ac:	17 c5       	rjmp	.+2606   	; 0x53dc <main+0xd28>
		{
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
    49ae:	0e 94 99 0b 	call	0x1732	; 0x1732 <ResetSdCard>
    49b2:	14 c5       	rjmp	.+2600   	; 0x53dc <main+0xd28>
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    49b4:	86 30       	cpi	r24, 0x06	; 6
    49b6:	09 f4       	brne	.+2      	; 0x49ba <main+0x306>
    49b8:	8d c2       	rjmp	.+1306   	; 0x4ed4 <main+0x820>
    49ba:	80 f4       	brcc	.+32     	; 0x49dc <main+0x328>
    49bc:	82 30       	cpi	r24, 0x02	; 2
    49be:	09 f4       	brne	.+2      	; 0x49c2 <main+0x30e>
    49c0:	0e c1       	rjmp	.+540    	; 0x4bde <main+0x52a>
    49c2:	30 f4       	brcc	.+12     	; 0x49d0 <main+0x31c>
    49c4:	88 23       	and	r24, r24
    49c6:	e9 f0       	breq	.+58     	; 0x4a02 <main+0x34e>
    49c8:	81 30       	cpi	r24, 0x01	; 1
    49ca:	09 f0       	breq	.+2      	; 0x49ce <main+0x31a>
    49cc:	07 c5       	rjmp	.+2574   	; 0x53dc <main+0xd28>
    49ce:	22 c0       	rjmp	.+68     	; 0x4a14 <main+0x360>
    49d0:	84 30       	cpi	r24, 0x04	; 4
    49d2:	09 f4       	brne	.+2      	; 0x49d6 <main+0x322>
    49d4:	f4 c1       	rjmp	.+1000   	; 0x4dbe <main+0x70a>
    49d6:	08 f0       	brcs	.+2      	; 0x49da <main+0x326>
    49d8:	34 c2       	rjmp	.+1128   	; 0x4e42 <main+0x78e>
    49da:	6d c1       	rjmp	.+730    	; 0x4cb6 <main+0x602>
    49dc:	8a 30       	cpi	r24, 0x0A	; 10
    49de:	09 f4       	brne	.+2      	; 0x49e2 <main+0x32e>
    49e0:	b0 c3       	rjmp	.+1888   	; 0x5142 <main+0xa8e>
    49e2:	30 f4       	brcc	.+12     	; 0x49f0 <main+0x33c>
    49e4:	88 30       	cpi	r24, 0x08	; 8
    49e6:	09 f4       	brne	.+2      	; 0x49ea <main+0x336>
    49e8:	11 c3       	rjmp	.+1570   	; 0x500c <main+0x958>
    49ea:	08 f0       	brcs	.+2      	; 0x49ee <main+0x33a>
    49ec:	24 c3       	rjmp	.+1608   	; 0x5036 <main+0x982>
    49ee:	d3 c2       	rjmp	.+1446   	; 0x4f96 <main+0x8e2>
    49f0:	8c 30       	cpi	r24, 0x0C	; 12
    49f2:	09 f4       	brne	.+2      	; 0x49f6 <main+0x342>
    49f4:	8a c4       	rjmp	.+2324   	; 0x530a <main+0xc56>
    49f6:	08 f4       	brcc	.+2      	; 0x49fa <main+0x346>
    49f8:	3d c4       	rjmp	.+2170   	; 0x5274 <main+0xbc0>
    49fa:	8d 30       	cpi	r24, 0x0D	; 13
    49fc:	09 f0       	breq	.+2      	; 0x4a00 <main+0x34c>
    49fe:	ee c4       	rjmp	.+2524   	; 0x53dc <main+0xd28>
    4a00:	a7 c4       	rjmp	.+2382   	; 0x5350 <main+0xc9c>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    4a02:	81 e0       	ldi	r24, 0x01	; 1
    4a04:	80 93 57 05 	sts	0x0557, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    4a08:	64 ec       	ldi	r22, 0xC4	; 196
    4a0a:	74 e0       	ldi	r23, 0x04	; 4
    4a0c:	83 e0       	ldi	r24, 0x03	; 3
    4a0e:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
    4a12:	e4 c4       	rjmp	.+2504   	; 0x53dc <main+0xd28>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    4a14:	83 e0       	ldi	r24, 0x03	; 3
    4a16:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4a1a:	88 23       	and	r24, r24
    4a1c:	09 f4       	brne	.+2      	; 0x4a20 <main+0x36c>
    4a1e:	de c4       	rjmp	.+2492   	; 0x53dc <main+0xd28>
			{
				sdPlaybackQueued=false;
    4a20:	10 92 b9 05 	sts	0x05B9, r1
				sdAbortRead=false;
    4a24:	10 92 b6 05 	sts	0x05B6, r1

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
    4a28:	0e 94 30 22 	call	0x4460	; 0x4460 <SdHandshake>
    4a2c:	81 30       	cpi	r24, 0x01	; 1
    4a2e:	09 f0       	breq	.+2      	; 0x4a32 <main+0x37e>
    4a30:	d4 c0       	rjmp	.+424    	; 0x4bda <main+0x526>
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    4a32:	60 e0       	ldi	r22, 0x00	; 0
    4a34:	70 e0       	ldi	r23, 0x00	; 0
    4a36:	cb 01       	movw	r24, r22
    4a38:	0e 94 38 23 	call	0x4670	; 0x4670 <SdBeginSingleBlockRead>
    4a3c:	81 30       	cpi	r24, 0x01	; 1
    4a3e:	09 f0       	breq	.+2      	; 0x4a42 <main+0x38e>
    4a40:	8f c0       	rjmp	.+286    	; 0x4b60 <main+0x4ac>
 		// Tue Jun 21 17:11:28 EDT 2011
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    4a42:	6a e7       	ldi	r22, 0x7A	; 122
    4a44:	70 e0       	ldi	r23, 0x00	; 0
    4a46:	83 e0       	ldi	r24, 0x03	; 3
    4a48:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
    4a4c:	02 c0       	rjmp	.+4      	; 0x4a52 <main+0x39e>

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    4a4e:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <HandleSoftclock>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    4a52:	83 e0       	ldi	r24, 0x03	; 3
    4a54:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4a58:	88 23       	and	r24, r24
    4a5a:	31 f0       	breq	.+12     	; 0x4a68 <main+0x3b4>
    4a5c:	44 24       	eor	r4, r4
    4a5e:	43 94       	inc	r4
    4a60:	51 2c       	mov	r5, r1
    4a62:	4c 0e       	add	r4, r28
    4a64:	5d 1e       	adc	r5, r29
    4a66:	06 c0       	rjmp	.+12     	; 0x4a74 <main+0x3c0>
    4a68:	8f ef       	ldi	r24, 0xFF	; 255
    4a6a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4a6e:	8e 3f       	cpi	r24, 0xFE	; 254
    4a70:	71 f7       	brne	.-36     	; 0x4a4e <main+0x39a>
    4a72:	f4 cf       	rjmp	.-24     	; 0x4a5c <main+0x3a8>
			HandleSoftclock();	// Kludgy
		}

		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
    4a74:	8f ef       	ldi	r24, 0xFF	; 255
    4a76:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4a7a:	f2 01       	movw	r30, r4
    4a7c:	81 93       	st	Z+, r24
    4a7e:	2f 01       	movw	r4, r30
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
		}

		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
    4a80:	ec 15       	cp	r30, r12
    4a82:	fd 05       	cpc	r31, r13
    4a84:	b9 f7       	brne	.-18     	; 0x4a74 <main+0x3c0>
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
		}

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
    4a86:	89 81       	ldd	r24, Y+1	; 0x01
    4a88:	87 35       	cpi	r24, 0x57	; 87
    4a8a:	09 f0       	breq	.+2      	; 0x4a8e <main+0x3da>
    4a8c:	34 c0       	rjmp	.+104    	; 0x4af6 <main+0x442>
    4a8e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a90:	84 35       	cpi	r24, 0x54	; 84
    4a92:	89 f5       	brne	.+98     	; 0x4af6 <main+0x442>
    4a94:	8b 81       	ldd	r24, Y+3	; 0x03
    4a96:	80 35       	cpi	r24, 0x50	; 80
    4a98:	71 f5       	brne	.+92     	; 0x4af6 <main+0x442>
    4a9a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a9c:	81 34       	cpi	r24, 0x41	; 65
    4a9e:	59 f5       	brne	.+86     	; 0x4af6 <main+0x442>
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
    4aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    4aa2:	83 35       	cpi	r24, 0x53	; 83
    4aa4:	61 f4       	brne	.+24     	; 0x4abe <main+0x40a>
    4aa6:	8e 81       	ldd	r24, Y+6	; 0x06
    4aa8:	81 34       	cpi	r24, 0x41	; 65
    4aaa:	29 f5       	brne	.+74     	; 0x4af6 <main+0x442>
    4aac:	8f 81       	ldd	r24, Y+7	; 0x07
    4aae:	8d 34       	cpi	r24, 0x4D	; 77
    4ab0:	11 f5       	brne	.+68     	; 0x4af6 <main+0x442>
    4ab2:	33 24       	eor	r3, r3
    4ab4:	33 94       	inc	r3
    4ab6:	88 85       	ldd	r24, Y+8	; 0x08
    4ab8:	80 35       	cpi	r24, 0x50	; 80
    4aba:	f1 f0       	breq	.+60     	; 0x4af8 <main+0x444>
    4abc:	1c c0       	rjmp	.+56     	; 0x4af6 <main+0x442>
			{
				filesystemType=SD_TYPE_SAMPLES;
			}
			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]=='M'))	// Andrew's Nintendo DPCM samples?
    4abe:	84 34       	cpi	r24, 0x44	; 68
    4ac0:	61 f4       	brne	.+24     	; 0x4ada <main+0x426>
    4ac2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ac4:	80 35       	cpi	r24, 0x50	; 80
    4ac6:	b9 f4       	brne	.+46     	; 0x4af6 <main+0x442>
    4ac8:	8f 81       	ldd	r24, Y+7	; 0x07
    4aca:	83 34       	cpi	r24, 0x43	; 67
    4acc:	a1 f4       	brne	.+40     	; 0x4af6 <main+0x442>
    4ace:	88 85       	ldd	r24, Y+8	; 0x08
    4ad0:	8d 34       	cpi	r24, 0x4D	; 77
    4ad2:	89 f4       	brne	.+34     	; 0x4af6 <main+0x442>
			{
				filesystemType=SD_TYPE_DPCM;			
    4ad4:	62 e0       	ldi	r22, 0x02	; 2
    4ad6:	36 2e       	mov	r3, r22
    4ad8:	0f c0       	rjmp	.+30     	; 0x4af8 <main+0x444>
			}
			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]=='T'))	// Program image for bootloader?
    4ada:	82 34       	cpi	r24, 0x42	; 66
    4adc:	61 f4       	brne	.+24     	; 0x4af6 <main+0x442>
    4ade:	8e 81       	ldd	r24, Y+6	; 0x06
    4ae0:	8f 34       	cpi	r24, 0x4F	; 79
    4ae2:	49 f4       	brne	.+18     	; 0x4af6 <main+0x442>
    4ae4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ae6:	8f 34       	cpi	r24, 0x4F	; 79
    4ae8:	31 f4       	brne	.+12     	; 0x4af6 <main+0x442>
    4aea:	88 85       	ldd	r24, Y+8	; 0x08
    4aec:	84 35       	cpi	r24, 0x54	; 84
    4aee:	19 f4       	brne	.+6      	; 0x4af6 <main+0x442>
			{
				filesystemType=SD_TYPE_BOOT;						
    4af0:	53 e0       	ldi	r21, 0x03	; 3
    4af2:	35 2e       	mov	r3, r21
    4af4:	01 c0       	rjmp	.+2      	; 0x4af8 <main+0x444>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    4af6:	31 2c       	mov	r3, r1
    4af8:	48 e0       	ldi	r20, 0x08	; 8
    4afa:	44 2e       	mov	r4, r20
    4afc:	51 2c       	mov	r5, r1
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
    4afe:	8f ef       	ldi	r24, 0xFF	; 255
    4b00:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4b04:	f1 e0       	ldi	r31, 0x01	; 1
    4b06:	4f 1a       	sub	r4, r31
    4b08:	51 08       	sbc	r5, r1
			{
				filesystemType=SD_TYPE_BOOT;						
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
    4b0a:	c9 f7       	brne	.-14     	; 0x4afe <main+0x44a>
		{
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
    4b0c:	21 e0       	ldi	r18, 0x01	; 1
    4b0e:	32 12       	cpse	r3, r18
    4b10:	14 c0       	rjmp	.+40     	; 0x4b3a <main+0x486>
    4b12:	3d e6       	ldi	r19, 0x6D	; 109
    4b14:	43 2e       	mov	r4, r19
    4b16:	35 e0       	ldi	r19, 0x05	; 5
    4b18:	53 2e       	mov	r5, r19
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    4b1a:	8f ef       	ldi	r24, 0xFF	; 255
    4b1c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4b20:	f2 01       	movw	r30, r4
    4b22:	81 93       	st	Z+, r24
    4b24:	2f 01       	movw	r4, r30
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    4b26:	fd ea       	ldi	r31, 0xAD	; 173
    4b28:	4f 16       	cp	r4, r31
    4b2a:	f5 e0       	ldi	r31, 0x05	; 5
    4b2c:	5f 06       	cpc	r5, r31
    4b2e:	a9 f7       	brne	.-22     	; 0x4b1a <main+0x466>
		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
    4b30:	22 eb       	ldi	r18, 0xB2	; 178
    4b32:	42 2e       	mov	r4, r18
    4b34:	55 24       	eor	r5, r5
    4b36:	53 94       	inc	r5
    4b38:	0b c0       	rjmp	.+22     	; 0x4b50 <main+0x49c>
    4b3a:	90 e4       	ldi	r25, 0x40	; 64
    4b3c:	49 2e       	mov	r4, r25
    4b3e:	51 2c       	mov	r5, r1
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    4b40:	8f ef       	ldi	r24, 0xFF	; 255
    4b42:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4b46:	21 e0       	ldi	r18, 0x01	; 1
    4b48:	42 1a       	sub	r4, r18
    4b4a:	51 08       	sbc	r5, r1
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    4b4c:	c9 f7       	brne	.-14     	; 0x4b40 <main+0x48c>
    4b4e:	f0 cf       	rjmp	.-32     	; 0x4b30 <main+0x47c>
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    4b50:	8f ef       	ldi	r24, 0xFF	; 255
    4b52:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4b56:	31 e0       	ldi	r19, 0x01	; 1
    4b58:	43 1a       	sub	r4, r19
    4b5a:	51 08       	sbc	r5, r1
			{
				TransferSdByte(0xFF);
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    4b5c:	c9 f7       	brne	.-14     	; 0x4b50 <main+0x49c>
    4b5e:	01 c0       	rjmp	.+2      	; 0x4b62 <main+0x4ae>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    4b60:	31 2c       	mov	r3, r1
		{
			TransferSdByte(0xFF);
		}
	}

	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4b62:	80 91 c8 00 	lds	r24, 0x00C8
    4b66:	86 ff       	sbrs	r24, 6
    4b68:	fc cf       	rjmp	.-8      	; 0x4b62 <main+0x4ae>
		;

	EndSdTransfer();				// Bring CS high
    4b6a:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    4b6e:	8f ef       	ldi	r24, 0xFF	; 255
    4b70:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
				{
					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that might be on the card.

					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
    4b74:	41 e0       	ldi	r20, 0x01	; 1
    4b76:	34 12       	cpse	r3, r20
    4b78:	19 c0       	rjmp	.+50     	; 0x4bac <main+0x4f8>
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
    4b7a:	b0 92 57 05 	sts	0x0557, r11
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    4b7e:	80 91 64 00 	lds	r24, 0x0064
    4b82:	8f 7b       	andi	r24, 0xBF	; 191
    4b84:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    4b88:	82 e0       	ldi	r24, 0x02	; 2
    4b8a:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    4b8e:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    4b92:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    4b96:	81 e7       	ldi	r24, 0x71	; 113
    4b98:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    4b9c:	a7 ba       	out	0x17, r10	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    4b9e:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    4ba2:	10 92 4d 05 	sts	0x054D, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    4ba6:	10 92 53 05 	sts	0x0553, r1
    4baa:	18 c4       	rjmp	.+2096   	; 0x53dc <main+0xd28>
					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
						InitSdIsr();				// Enable the timers necessary to give the SD card its own IRQ
					}
					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler routines and get that going.
    4bac:	52 e0       	ldi	r21, 0x02	; 2
    4bae:	35 16       	cp	r3, r21
    4bb0:	09 f4       	brne	.+2      	; 0x4bb4 <main+0x500>
    4bb2:	14 c4       	rjmp	.+2088   	; 0x53dc <main+0xd28>
						// @@@ Load up DPCM stuff
					}

					else	// Valid card, but either invalid filesystem or BOOT card.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    4bb4:	8f e0       	ldi	r24, 0x0F	; 15
    4bb6:	80 93 57 05 	sts	0x0557, r24
    4bba:	ed e6       	ldi	r30, 0x6D	; 109
    4bbc:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    4bbe:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    4bc0:	65 e0       	ldi	r22, 0x05	; 5
    4bc2:	ed 3a       	cpi	r30, 0xAD	; 173
    4bc4:	f6 07       	cpc	r31, r22
    4bc6:	d9 f7       	brne	.-10     	; 0x4bbe <main+0x50a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4bc8:	84 e7       	ldi	r24, 0x74	; 116
    4bca:	9d e0       	ldi	r25, 0x0D	; 13
    4bcc:	90 93 e3 05 	sts	0x05E3, r25
    4bd0:	80 93 e2 05 	sts	0x05E2, r24
	subState=SS_0;
    4bd4:	10 92 59 05 	sts	0x0559, r1
    4bd8:	01 c4       	rjmp	.+2050   	; 0x53dc <main+0xd28>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    4bda:	8f e0       	ldi	r24, 0x0F	; 15
    4bdc:	91 c3       	rjmp	.+1826   	; 0x5300 <main+0xc4c>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    4bde:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4be0:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    4be2:	80 91 26 01 	lds	r24, 0x0126
    4be6:	90 91 27 01 	lds	r25, 0x0127
    4bea:	81 15       	cp	r24, r1
    4bec:	92 40       	sbci	r25, 0x02	; 2
    4bee:	a0 f4       	brcc	.+40     	; 0x4c18 <main+0x564>
    4bf0:	80 91 26 01 	lds	r24, 0x0126
    4bf4:	90 91 27 01 	lds	r25, 0x0127
    4bf8:	40 91 1e 01 	lds	r20, 0x011E
    4bfc:	50 91 1f 01 	lds	r21, 0x011F
    4c00:	60 91 20 01 	lds	r22, 0x0120
    4c04:	70 91 21 01 	lds	r23, 0x0121
    4c08:	a0 e0       	ldi	r26, 0x00	; 0
    4c0a:	b0 e0       	ldi	r27, 0x00	; 0
    4c0c:	84 17       	cp	r24, r20
    4c0e:	95 07       	cpc	r25, r21
    4c10:	a6 07       	cpc	r26, r22
    4c12:	b7 07       	cpc	r27, r23
    4c14:	08 f4       	brcc	.+2      	; 0x4c18 <main+0x564>
    4c16:	5c c1       	rjmp	.+696    	; 0x4ed0 <main+0x81c>
			{
				SREG=sreg;	// Done reading ISR variables.
    4c18:	2f bf       	out	0x3f, r18	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    4c1a:	60 91 b0 05 	lds	r22, 0x05B0
    4c1e:	70 91 b1 05 	lds	r23, 0x05B1
    4c22:	80 91 b2 05 	lds	r24, 0x05B2
    4c26:	90 91 b3 05 	lds	r25, 0x05B3
    4c2a:	0e 94 49 23 	call	0x4692	; 0x4692 <SdBeginSingleBlockWrite>
    4c2e:	81 30       	cpi	r24, 0x01	; 1
    4c30:	09 f0       	breq	.+2      	; 0x4c34 <main+0x580>
    4c32:	bd ce       	rjmp	.-646    	; 0x49ae <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4c34:	10 93 c2 05 	sts	0x05C2, r17
    4c38:	00 93 c1 05 	sts	0x05C1, r16

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    4c3c:	8f ef       	ldi	r24, 0xFF	; 255
    4c3e:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    4c42:	8f ef       	ldi	r24, 0xFF	; 255
    4c44:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    4c48:	8e ef       	ldi	r24, 0xFE	; 254
    4c4a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    4c4e:	80 91 1e 01 	lds	r24, 0x011E
    4c52:	90 91 1f 01 	lds	r25, 0x011F
    4c56:	a0 91 20 01 	lds	r26, 0x0120
    4c5a:	b0 91 21 01 	lds	r27, 0x0121
    4c5e:	8b 2f       	mov	r24, r27
    4c60:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    4c64:	60 91 1e 01 	lds	r22, 0x011E
    4c68:	70 91 1f 01 	lds	r23, 0x011F
    4c6c:	80 91 20 01 	lds	r24, 0x0120
    4c70:	90 91 21 01 	lds	r25, 0x0121
    4c74:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    4c78:	80 91 1e 01 	lds	r24, 0x011E
    4c7c:	90 91 1f 01 	lds	r25, 0x011F
    4c80:	a0 91 20 01 	lds	r26, 0x0120
    4c84:	b0 91 21 01 	lds	r27, 0x0121
    4c88:	89 2f       	mov	r24, r25
    4c8a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    4c8e:	80 91 1e 01 	lds	r24, 0x011E
    4c92:	90 91 1f 01 	lds	r25, 0x011F
    4c96:	a0 91 20 01 	lds	r26, 0x0120
    4c9a:	b0 91 21 01 	lds	r27, 0x0121
    4c9e:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    4ca2:	80 91 c1 05 	lds	r24, 0x05C1
    4ca6:	90 91 c2 05 	lds	r25, 0x05C2
    4caa:	04 97       	sbiw	r24, 0x04	; 4
    4cac:	90 93 c2 05 	sts	0x05C2, r25
    4cb0:	80 93 c1 05 	sts	0x05C1, r24
    4cb4:	0b c1       	rjmp	.+534    	; 0x4ecc <main+0x818>
    4cb6:	40 90 c1 05 	lds	r4, 0x05C1
    4cba:	50 90 c2 05 	lds	r5, 0x05C2
    4cbe:	81 e4       	ldi	r24, 0x41	; 65
    4cc0:	48 16       	cp	r4, r24
    4cc2:	51 04       	cpc	r5, r1
    4cc4:	18 f0       	brcs	.+6      	; 0x4ccc <main+0x618>
    4cc6:	80 e4       	ldi	r24, 0x40	; 64
    4cc8:	48 2e       	mov	r4, r24
    4cca:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4ccc:	31 2c       	mov	r3, r1
    4cce:	56 c0       	rjmp	.+172    	; 0x4d7c <main+0x6c8>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    4cd0:	80 91 1e 01 	lds	r24, 0x011E
    4cd4:	90 91 1f 01 	lds	r25, 0x011F
    4cd8:	a0 91 20 01 	lds	r26, 0x0120
    4cdc:	b0 91 21 01 	lds	r27, 0x0121
    4ce0:	89 2b       	or	r24, r25
    4ce2:	8a 2b       	or	r24, r26
    4ce4:	8b 2b       	or	r24, r27
    4ce6:	e9 f1       	breq	.+122    	; 0x4d62 <main+0x6ae>
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
    4ce8:	e0 91 2a 01 	lds	r30, 0x012A
    4cec:	f0 91 2b 01 	lds	r31, 0x012B
    4cf0:	e4 5d       	subi	r30, 0xD4	; 212
    4cf2:	fe 4f       	sbci	r31, 0xFE	; 254
    4cf4:	80 81       	ld	r24, Z
    4cf6:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    4cfa:	80 91 1e 01 	lds	r24, 0x011E
    4cfe:	90 91 1f 01 	lds	r25, 0x011F
    4d02:	a0 91 20 01 	lds	r26, 0x0120
    4d06:	b0 91 21 01 	lds	r27, 0x0121
    4d0a:	01 97       	sbiw	r24, 0x01	; 1
    4d0c:	a1 09       	sbc	r26, r1
    4d0e:	b1 09       	sbc	r27, r1
    4d10:	80 93 1e 01 	sts	0x011E, r24
    4d14:	90 93 1f 01 	sts	0x011F, r25
    4d18:	a0 93 20 01 	sts	0x0120, r26
    4d1c:	b0 93 21 01 	sts	0x0121, r27

					sdFifoReadPointer++;			// Move to next spot in fifo
    4d20:	80 91 2a 01 	lds	r24, 0x012A
    4d24:	90 91 2b 01 	lds	r25, 0x012B
    4d28:	01 96       	adiw	r24, 0x01	; 1
    4d2a:	90 93 2b 01 	sts	0x012B, r25
    4d2e:	80 93 2a 01 	sts	0x012A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    4d32:	80 91 2a 01 	lds	r24, 0x012A
    4d36:	90 91 2b 01 	lds	r25, 0x012B
    4d3a:	81 15       	cp	r24, r1
    4d3c:	93 40       	sbci	r25, 0x03	; 3
    4d3e:	20 f0       	brcs	.+8      	; 0x4d48 <main+0x694>
					{
						sdFifoReadPointer=0;
    4d40:	10 92 2b 01 	sts	0x012B, r1
    4d44:	10 92 2a 01 	sts	0x012A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    4d48:	2f b7       	in	r18, 0x3f	; 63
					cli();
    4d4a:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    4d4c:	80 91 26 01 	lds	r24, 0x0126
    4d50:	90 91 27 01 	lds	r25, 0x0127
    4d54:	01 97       	sbiw	r24, 0x01	; 1
    4d56:	90 93 27 01 	sts	0x0127, r25
    4d5a:	80 93 26 01 	sts	0x0126, r24
					SREG=sreg;
    4d5e:	2f bf       	out	0x3f, r18	; 63
    4d60:	03 c0       	rjmp	.+6      	; 0x4d68 <main+0x6b4>
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    4d62:	8f ef       	ldi	r24, 0xFF	; 255
    4d64:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    4d68:	80 91 c1 05 	lds	r24, 0x05C1
    4d6c:	90 91 c2 05 	lds	r25, 0x05C2
    4d70:	01 97       	sbiw	r24, 0x01	; 1
    4d72:	90 93 c2 05 	sts	0x05C2, r25
    4d76:	80 93 c1 05 	sts	0x05C1, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4d7a:	33 94       	inc	r3
    4d7c:	83 2d       	mov	r24, r3
    4d7e:	90 e0       	ldi	r25, 0x00	; 0
    4d80:	84 15       	cp	r24, r4
    4d82:	95 05       	cpc	r25, r5
    4d84:	08 f4       	brcc	.+2      	; 0x4d88 <main+0x6d4>
    4d86:	a4 cf       	rjmp	.-184    	; 0x4cd0 <main+0x61c>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    4d88:	80 91 c1 05 	lds	r24, 0x05C1
    4d8c:	90 91 c2 05 	lds	r25, 0x05C2
    4d90:	89 2b       	or	r24, r25
    4d92:	09 f0       	breq	.+2      	; 0x4d96 <main+0x6e2>
    4d94:	23 c3       	rjmp	.+1606   	; 0x53dc <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4d96:	8f ef       	ldi	r24, 0xFF	; 255
    4d98:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4d9c:	8f ef       	ldi	r24, 0xFF	; 255
    4d9e:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4da2:	8f ef       	ldi	r24, 0xFF	; 255
    4da4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4da8:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4daa:	85 30       	cpi	r24, 0x05	; 5
    4dac:	09 f0       	breq	.+2      	; 0x4db0 <main+0x6fc>
    4dae:	ff cd       	rjmp	.-1026   	; 0x49ae <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4db0:	62 e6       	ldi	r22, 0x62	; 98
    4db2:	72 e0       	ldi	r23, 0x02	; 2
    4db4:	83 e0       	ldi	r24, 0x03	; 3
    4db6:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    4dba:	84 e0       	ldi	r24, 0x04	; 4
    4dbc:	a1 c2       	rjmp	.+1346   	; 0x5300 <main+0xc4c>
				}
			}
			break;

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    4dbe:	83 e0       	ldi	r24, 0x03	; 3
    4dc0:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    4dc4:	81 11       	cpse	r24, r1
    4dc6:	f3 cd       	rjmp	.-1050   	; 0x49ae <main+0x2fa>
    4dc8:	b4 e0       	ldi	r27, 0x04	; 4
    4dca:	5b 2e       	mov	r5, r27
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4dcc:	8f ef       	ldi	r24, 0xFF	; 255
    4dce:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4dd2:	8f 3f       	cpi	r24, 0xFF	; 255
    4dd4:	09 f4       	brne	.+2      	; 0x4dd8 <main+0x724>
    4dd6:	1e c3       	rjmp	.+1596   	; 0x5414 <main+0xd60>
    4dd8:	5a 94       	dec	r5

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4dda:	c1 f7       	brne	.-16     	; 0x4dcc <main+0x718>
    4ddc:	ff c2       	rjmp	.+1534   	; 0x53dc <main+0xd28>

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4dde:	80 91 c8 00 	lds	r24, 0x00C8
    4de2:	86 ff       	sbrs	r24, 6
    4de4:	fc cf       	rjmp	.-8      	; 0x4dde <main+0x72a>
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    4de6:	80 91 1e 01 	lds	r24, 0x011E
    4dea:	90 91 1f 01 	lds	r25, 0x011F
    4dee:	a0 91 20 01 	lds	r26, 0x0120
    4df2:	b0 91 21 01 	lds	r27, 0x0121
    4df6:	89 2b       	or	r24, r25
    4df8:	8a 2b       	or	r24, r26
    4dfa:	8b 2b       	or	r24, r27
    4dfc:	11 f0       	breq	.+4      	; 0x4e02 <main+0x74e>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    4dfe:	85 e0       	ldi	r24, 0x05	; 5
    4e00:	7f c2       	rjmp	.+1278   	; 0x5300 <main+0xc4c>
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    4e02:	40 90 61 05 	lds	r4, 0x0561
    4e06:	50 90 62 05 	lds	r5, 0x0562
    4e0a:	c2 01       	movw	r24, r4
    4e0c:	0e 94 40 05 	call	0xa80	; 0xa80 <CheckSdSlotFull>
    4e10:	81 11       	cpse	r24, r1
    4e12:	2d c2       	rjmp	.+1114   	; 0x526e <main+0xbba>
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    4e14:	f2 01       	movw	r30, r4
    4e16:	a3 e0       	ldi	r26, 0x03	; 3
    4e18:	f6 95       	lsr	r31
    4e1a:	e7 95       	ror	r30
    4e1c:	aa 95       	dec	r26
    4e1e:	e1 f7       	brne	.-8      	; 0x4e18 <main+0x764>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    4e20:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    4e22:	e3 59       	subi	r30, 0x93	; 147
    4e24:	fa 4f       	sbci	r31, 0xFA	; 250
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    4e26:	27 e0       	ldi	r18, 0x07	; 7
    4e28:	42 22       	and	r4, r18
    4e2a:	55 24       	eor	r5, r5

	sampleToc[theByte]|=(1<<theBit);	// Set it
    4e2c:	a7 01       	movw	r20, r14
    4e2e:	02 c0       	rjmp	.+4      	; 0x4e34 <main+0x780>
    4e30:	44 0f       	add	r20, r20
    4e32:	55 1f       	adc	r21, r21
    4e34:	4a 94       	dec	r4
    4e36:	e2 f7       	brpl	.-8      	; 0x4e30 <main+0x77c>
    4e38:	80 81       	ld	r24, Z
    4e3a:	84 2b       	or	r24, r20
    4e3c:	80 83       	st	Z, r24
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    4e3e:	86 e0       	ldi	r24, 0x06	; 6
    4e40:	5f c2       	rjmp	.+1214   	; 0x5300 <main+0xc4c>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    4e42:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4e44:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    4e46:	80 91 26 01 	lds	r24, 0x0126
    4e4a:	90 91 27 01 	lds	r25, 0x0127
    4e4e:	81 15       	cp	r24, r1
    4e50:	92 40       	sbci	r25, 0x02	; 2
    4e52:	98 f4       	brcc	.+38     	; 0x4e7a <main+0x7c6>
    4e54:	80 91 26 01 	lds	r24, 0x0126
    4e58:	90 91 27 01 	lds	r25, 0x0127
    4e5c:	40 91 1e 01 	lds	r20, 0x011E
    4e60:	50 91 1f 01 	lds	r21, 0x011F
    4e64:	60 91 20 01 	lds	r22, 0x0120
    4e68:	70 91 21 01 	lds	r23, 0x0121
    4e6c:	a0 e0       	ldi	r26, 0x00	; 0
    4e6e:	b0 e0       	ldi	r27, 0x00	; 0
    4e70:	84 17       	cp	r24, r20
    4e72:	95 07       	cpc	r25, r21
    4e74:	a6 07       	cpc	r26, r22
    4e76:	b7 07       	cpc	r27, r23
    4e78:	58 f1       	brcs	.+86     	; 0x4ed0 <main+0x81c>
			{
				SREG=sreg;																	// Done reading ISR variables.
    4e7a:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;		// On to the next
    4e7c:	20 91 b4 05 	lds	r18, 0x05B4
    4e80:	30 91 b5 05 	lds	r19, 0x05B5
    4e84:	2f 5f       	subi	r18, 0xFF	; 255
    4e86:	3f 4f       	sbci	r19, 0xFF	; 255
    4e88:	30 93 b5 05 	sts	0x05B5, r19
    4e8c:	20 93 b4 05 	sts	0x05B4, r18

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    4e90:	60 91 b0 05 	lds	r22, 0x05B0
    4e94:	70 91 b1 05 	lds	r23, 0x05B1
    4e98:	80 91 b2 05 	lds	r24, 0x05B2
    4e9c:	90 91 b3 05 	lds	r25, 0x05B3
    4ea0:	62 0f       	add	r22, r18
    4ea2:	73 1f       	adc	r23, r19
    4ea4:	81 1d       	adc	r24, r1
    4ea6:	91 1d       	adc	r25, r1
    4ea8:	0e 94 49 23 	call	0x4692	; 0x4692 <SdBeginSingleBlockWrite>
    4eac:	81 30       	cpi	r24, 0x01	; 1
    4eae:	09 f0       	breq	.+2      	; 0x4eb2 <main+0x7fe>
    4eb0:	7e cd       	rjmp	.-1284   	; 0x49ae <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4eb2:	10 93 c2 05 	sts	0x05C2, r17
    4eb6:	00 93 c1 05 	sts	0x05C1, r16

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    4eba:	8f ef       	ldi	r24, 0xFF	; 255
    4ebc:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    4ec0:	8f ef       	ldi	r24, 0xFF	; 255
    4ec2:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    4ec6:	8e ef       	ldi	r24, 0xFE	; 254
    4ec8:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    4ecc:	83 e0       	ldi	r24, 0x03	; 3
    4ece:	18 c2       	rjmp	.+1072   	; 0x5300 <main+0xc4c>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// Bytes remaining in sample, but not enough in the fifo yet
			{
				SREG=sreg;			// Done reading ISR variables.
    4ed0:	2f bf       	out	0x3f, r18	; 63
    4ed2:	84 c2       	rjmp	.+1288   	; 0x53dc <main+0xd28>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    4ed4:	60 e0       	ldi	r22, 0x00	; 0
    4ed6:	70 e0       	ldi	r23, 0x00	; 0
    4ed8:	cb 01       	movw	r24, r22
    4eda:	0e 94 49 23 	call	0x4692	; 0x4692 <SdBeginSingleBlockWrite>
    4ede:	81 30       	cpi	r24, 0x01	; 1
    4ee0:	09 f0       	breq	.+2      	; 0x4ee4 <main+0x830>
    4ee2:	65 cd       	rjmp	.-1334   	; 0x49ae <main+0x2fa>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    4ee4:	10 93 c2 05 	sts	0x05C2, r17
    4ee8:	00 93 c1 05 	sts	0x05C1, r16

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4eec:	8f ef       	ldi	r24, 0xFF	; 255
    4eee:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    4ef2:	8f ef       	ldi	r24, 0xFF	; 255
    4ef4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    4ef8:	8e ef       	ldi	r24, 0xFE	; 254
    4efa:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
    4efe:	87 e5       	ldi	r24, 0x57	; 87
    4f00:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('T');
    4f04:	84 e5       	ldi	r24, 0x54	; 84
    4f06:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('P');
    4f0a:	80 e5       	ldi	r24, 0x50	; 80
    4f0c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('A');
    4f10:	81 e4       	ldi	r24, 0x41	; 65
    4f12:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('S');				// These four characters indicate this card holds sample data (as opposed to Nintendo DPCMs, or a boot image)
    4f16:	83 e5       	ldi	r24, 0x53	; 83
    4f18:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('A');
    4f1c:	81 e4       	ldi	r24, 0x41	; 65
    4f1e:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('M');
    4f22:	8d e4       	ldi	r24, 0x4D	; 77
    4f24:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte('P');
    4f28:	80 e5       	ldi	r24, 0x50	; 80
    4f2a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>

				bytesLeftInBlock-=8;
    4f2e:	80 91 c1 05 	lds	r24, 0x05C1
    4f32:	90 91 c2 05 	lds	r25, 0x05C2
    4f36:	08 97       	sbiw	r24, 0x08	; 8
    4f38:	90 93 c2 05 	sts	0x05C2, r25
    4f3c:	80 93 c1 05 	sts	0x05C1, r24
    4f40:	78 e0       	ldi	r23, 0x08	; 8
    4f42:	57 2e       	mov	r5, r23

				for(i=0;i<8;i++)					// 8 don't care bytes
				{
					TransferSdByte('x');
    4f44:	88 e7       	ldi	r24, 0x78	; 120
    4f46:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4f4a:	5a 94       	dec	r5
				TransferSdByte('M');
				TransferSdByte('P');

				bytesLeftInBlock-=8;

				for(i=0;i<8;i++)					// 8 don't care bytes
    4f4c:	d9 f7       	brne	.-10     	; 0x4f44 <main+0x890>
				{
					TransferSdByte('x');
				}

				bytesLeftInBlock-=8;
    4f4e:	80 91 c1 05 	lds	r24, 0x05C1
    4f52:	90 91 c2 05 	lds	r25, 0x05C2
    4f56:	08 97       	sbiw	r24, 0x08	; 8
    4f58:	90 93 c2 05 	sts	0x05C2, r25
    4f5c:	80 93 c1 05 	sts	0x05C1, r24
    4f60:	6d e6       	ldi	r22, 0x6D	; 109
    4f62:	46 2e       	mov	r4, r22
    4f64:	65 e0       	ldi	r22, 0x05	; 5
    4f66:	56 2e       	mov	r5, r22

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    4f68:	f2 01       	movw	r30, r4
    4f6a:	81 91       	ld	r24, Z+
    4f6c:	2f 01       	movw	r4, r30
    4f6e:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte('x');
				}

				bytesLeftInBlock-=8;

				for(i=0;i<64;i++)					// Write table of contents.
    4f72:	fd ea       	ldi	r31, 0xAD	; 173
    4f74:	4f 16       	cp	r4, r31
    4f76:	f5 e0       	ldi	r31, 0x05	; 5
    4f78:	5f 06       	cpc	r5, r31
    4f7a:	b1 f7       	brne	.-20     	; 0x4f68 <main+0x8b4>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    4f7c:	80 91 c1 05 	lds	r24, 0x05C1
    4f80:	90 91 c2 05 	lds	r25, 0x05C2
    4f84:	80 54       	subi	r24, 0x40	; 64
    4f86:	91 09       	sbc	r25, r1
    4f88:	90 93 c2 05 	sts	0x05C2, r25
    4f8c:	80 93 c1 05 	sts	0x05C1, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4f90:	70 92 57 05 	sts	0x0557, r7
    4f94:	23 c2       	rjmp	.+1094   	; 0x53dc <main+0xd28>
    4f96:	40 90 c1 05 	lds	r4, 0x05C1
    4f9a:	50 90 c2 05 	lds	r5, 0x05C2
    4f9e:	21 e4       	ldi	r18, 0x41	; 65
    4fa0:	42 16       	cp	r4, r18
    4fa2:	51 04       	cpc	r5, r1
    4fa4:	18 f0       	brcs	.+6      	; 0x4fac <main+0x8f8>
    4fa6:	50 e4       	ldi	r21, 0x40	; 64
    4fa8:	45 2e       	mov	r4, r21
    4faa:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4fac:	31 2c       	mov	r3, r1
    4fae:	0d c0       	rjmp	.+26     	; 0x4fca <main+0x916>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4fb0:	8f ef       	ldi	r24, 0xFF	; 255
    4fb2:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    4fb6:	80 91 c1 05 	lds	r24, 0x05C1
    4fba:	90 91 c2 05 	lds	r25, 0x05C2
    4fbe:	01 97       	sbiw	r24, 0x01	; 1
    4fc0:	90 93 c2 05 	sts	0x05C2, r25
    4fc4:	80 93 c1 05 	sts	0x05C1, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4fc8:	33 94       	inc	r3
    4fca:	83 2d       	mov	r24, r3
    4fcc:	90 e0       	ldi	r25, 0x00	; 0
    4fce:	84 15       	cp	r24, r4
    4fd0:	95 05       	cpc	r25, r5
    4fd2:	70 f3       	brcs	.-36     	; 0x4fb0 <main+0x8fc>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    4fd4:	80 91 c1 05 	lds	r24, 0x05C1
    4fd8:	90 91 c2 05 	lds	r25, 0x05C2
    4fdc:	89 2b       	or	r24, r25
    4fde:	09 f0       	breq	.+2      	; 0x4fe2 <main+0x92e>
    4fe0:	fd c1       	rjmp	.+1018   	; 0x53dc <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4fe2:	8f ef       	ldi	r24, 0xFF	; 255
    4fe4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4fe8:	8f ef       	ldi	r24, 0xFF	; 255
    4fea:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4fee:	8f ef       	ldi	r24, 0xFF	; 255
    4ff0:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    4ff4:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4ff6:	85 30       	cpi	r24, 0x05	; 5
    4ff8:	09 f0       	breq	.+2      	; 0x4ffc <main+0x948>
    4ffa:	d9 cc       	rjmp	.-1614   	; 0x49ae <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4ffc:	62 e6       	ldi	r22, 0x62	; 98
    4ffe:	72 e0       	ldi	r23, 0x02	; 2
    5000:	83 e0       	ldi	r24, 0x03	; 3
    5002:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    5006:	80 92 57 05 	sts	0x0557, r8
    500a:	e8 c1       	rjmp	.+976    	; 0x53dc <main+0xd28>
				}
			}
			break;

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    500c:	83 e0       	ldi	r24, 0x03	; 3
    500e:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    5012:	81 11       	cpse	r24, r1
    5014:	cc cc       	rjmp	.-1640   	; 0x49ae <main+0x2fa>
    5016:	44 e0       	ldi	r20, 0x04	; 4
    5018:	54 2e       	mov	r5, r20
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    501a:	8f ef       	ldi	r24, 0xFF	; 255
    501c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    5020:	8f 3f       	cpi	r24, 0xFF	; 255
    5022:	09 f4       	brne	.+2      	; 0x5026 <main+0x972>
    5024:	fd c1       	rjmp	.+1018   	; 0x5420 <main+0xd6c>
    5026:	5a 94       	dec	r5

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    5028:	c1 f7       	brne	.-16     	; 0x501a <main+0x966>
    502a:	d8 c1       	rjmp	.+944    	; 0x53dc <main+0xd28>

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    502c:	80 91 c8 00 	lds	r24, 0x00C8
    5030:	86 ff       	sbrs	r24, 6
    5032:	fc cf       	rjmp	.-8      	; 0x502c <main+0x978>
    5034:	1c c1       	rjmp	.+568    	; 0x526e <main+0xbba>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    5036:	83 e0       	ldi	r24, 0x03	; 3
    5038:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    503c:	81 11       	cpse	r24, r1
    503e:	b7 cc       	rjmp	.-1682   	; 0x49ae <main+0x2fa>
    5040:	34 e0       	ldi	r19, 0x04	; 4
    5042:	53 2e       	mov	r5, r19
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    5044:	8f ef       	ldi	r24, 0xFF	; 255
    5046:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    504a:	8f 3f       	cpi	r24, 0xFF	; 255
    504c:	19 f4       	brne	.+6      	; 0x5054 <main+0x9a0>
    504e:	5a 94       	dec	r5

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    5050:	c9 f7       	brne	.-14     	; 0x5044 <main+0x990>
    5052:	c4 c1       	rjmp	.+904    	; 0x53dc <main+0xd28>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    5054:	8e 3f       	cpi	r24, 0xFE	; 254
    5056:	09 f0       	breq	.+2      	; 0x505a <main+0x9a6>
    5058:	aa cc       	rjmp	.-1708   	; 0x49ae <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
    505a:	10 93 c2 05 	sts	0x05C2, r17
    505e:	00 93 c1 05 	sts	0x05C1, r16

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    5062:	8f ef       	ldi	r24, 0xFF	; 255
    5064:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    5068:	90 e0       	ldi	r25, 0x00	; 0
    506a:	a0 e0       	ldi	r26, 0x00	; 0
    506c:	b0 e0       	ldi	r27, 0x00	; 0
    506e:	b8 2f       	mov	r27, r24
    5070:	aa 27       	eor	r26, r26
    5072:	99 27       	eor	r25, r25
    5074:	88 27       	eor	r24, r24
    5076:	80 93 1e 01 	sts	0x011E, r24
    507a:	90 93 1f 01 	sts	0x011F, r25
    507e:	a0 93 20 01 	sts	0x0120, r26
    5082:	b0 93 21 01 	sts	0x0121, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    5086:	20 90 1e 01 	lds	r2, 0x011E
    508a:	30 90 1f 01 	lds	r3, 0x011F
    508e:	40 90 20 01 	lds	r4, 0x0120
    5092:	50 90 21 01 	lds	r5, 0x0121
    5096:	8f ef       	ldi	r24, 0xFF	; 255
    5098:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    509c:	b2 01       	movw	r22, r4
    509e:	a1 01       	movw	r20, r2
    50a0:	68 2b       	or	r22, r24
    50a2:	40 93 1e 01 	sts	0x011E, r20
    50a6:	50 93 1f 01 	sts	0x011F, r21
    50aa:	60 93 20 01 	sts	0x0120, r22
    50ae:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    50b2:	20 90 1e 01 	lds	r2, 0x011E
    50b6:	30 90 1f 01 	lds	r3, 0x011F
    50ba:	40 90 20 01 	lds	r4, 0x0120
    50be:	50 90 21 01 	lds	r5, 0x0121
    50c2:	8f ef       	ldi	r24, 0xFF	; 255
    50c4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    50c8:	a2 01       	movw	r20, r4
    50ca:	91 01       	movw	r18, r2
    50cc:	38 2b       	or	r19, r24
    50ce:	20 93 1e 01 	sts	0x011E, r18
    50d2:	30 93 1f 01 	sts	0x011F, r19
    50d6:	40 93 20 01 	sts	0x0120, r20
    50da:	50 93 21 01 	sts	0x0121, r21
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    50de:	20 90 1e 01 	lds	r2, 0x011E
    50e2:	30 90 1f 01 	lds	r3, 0x011F
    50e6:	40 90 20 01 	lds	r4, 0x0120
    50ea:	50 90 21 01 	lds	r5, 0x0121
    50ee:	8f ef       	ldi	r24, 0xFF	; 255
    50f0:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    50f4:	b2 01       	movw	r22, r4
    50f6:	a1 01       	movw	r20, r2
    50f8:	48 2b       	or	r20, r24
    50fa:	db 01       	movw	r26, r22
    50fc:	ca 01       	movw	r24, r20
    50fe:	80 93 1e 01 	sts	0x011E, r24
    5102:	90 93 1f 01 	sts	0x011F, r25
    5106:	a0 93 20 01 	sts	0x0120, r26
    510a:	b0 93 21 01 	sts	0x0121, r27

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    510e:	80 91 1e 01 	lds	r24, 0x011E
    5112:	90 91 1f 01 	lds	r25, 0x011F
    5116:	a0 91 20 01 	lds	r26, 0x0120
    511a:	b0 91 21 01 	lds	r27, 0x0121
    511e:	80 93 22 01 	sts	0x0122, r24
    5122:	90 93 23 01 	sts	0x0123, r25
    5126:	a0 93 24 01 	sts	0x0124, r26
    512a:	b0 93 25 01 	sts	0x0125, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    512e:	80 91 c1 05 	lds	r24, 0x05C1
    5132:	90 91 c2 05 	lds	r25, 0x05C2
    5136:	04 97       	sbiw	r24, 0x04	; 4
    5138:	90 93 c2 05 	sts	0x05C2, r25
    513c:	80 93 c1 05 	sts	0x05C1, r24
    5140:	fa c0       	rjmp	.+500    	; 0x5336 <main+0xc82>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    5142:	80 91 b6 05 	lds	r24, 0x05B6
    5146:	81 30       	cpi	r24, 0x01	; 1
    5148:	09 f4       	brne	.+2      	; 0x514c <main+0xa98>
    514a:	fd c0       	rjmp	.+506    	; 0x5346 <main+0xc92>
    514c:	40 90 c1 05 	lds	r4, 0x05C1
    5150:	50 90 c2 05 	lds	r5, 0x05C2
    5154:	51 e4       	ldi	r21, 0x41	; 65
    5156:	45 16       	cp	r4, r21
    5158:	51 04       	cpc	r5, r1
    515a:	18 f0       	brcs	.+6      	; 0x5162 <main+0xaae>
    515c:	b0 e4       	ldi	r27, 0x40	; 64
    515e:	4b 2e       	mov	r4, r27
    5160:	51 2c       	mov	r5, r1
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    5162:	31 2c       	mov	r3, r1
    5164:	55 c0       	rjmp	.+170    	; 0x5210 <main+0xb5c>
				{
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    5166:	8f ef       	ldi	r24, 0xFF	; 255
    5168:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					bytesLeftInBlock--;						// One less byte in the block read.
    516c:	20 91 c1 05 	lds	r18, 0x05C1
    5170:	30 91 c2 05 	lds	r19, 0x05C2
    5174:	21 50       	subi	r18, 0x01	; 1
    5176:	31 09       	sbc	r19, r1
    5178:	30 93 c2 05 	sts	0x05C2, r19
    517c:	20 93 c1 05 	sts	0x05C1, r18

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    5180:	40 91 1e 01 	lds	r20, 0x011E
    5184:	50 91 1f 01 	lds	r21, 0x011F
    5188:	60 91 20 01 	lds	r22, 0x0120
    518c:	70 91 21 01 	lds	r23, 0x0121
    5190:	45 2b       	or	r20, r21
    5192:	46 2b       	or	r20, r22
    5194:	47 2b       	or	r20, r23
    5196:	d9 f1       	breq	.+118    	; 0x520e <main+0xb5a>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    5198:	40 91 1e 01 	lds	r20, 0x011E
    519c:	50 91 1f 01 	lds	r21, 0x011F
    51a0:	60 91 20 01 	lds	r22, 0x0120
    51a4:	70 91 21 01 	lds	r23, 0x0121
    51a8:	41 50       	subi	r20, 0x01	; 1
    51aa:	51 09       	sbc	r21, r1
    51ac:	61 09       	sbc	r22, r1
    51ae:	71 09       	sbc	r23, r1
    51b0:	40 93 1e 01 	sts	0x011E, r20
    51b4:	50 93 1f 01 	sts	0x011F, r21
    51b8:	60 93 20 01 	sts	0x0120, r22
    51bc:	70 93 21 01 	sts	0x0121, r23

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    51c0:	e0 91 28 01 	lds	r30, 0x0128
    51c4:	f0 91 29 01 	lds	r31, 0x0129
    51c8:	e4 5d       	subi	r30, 0xD4	; 212
    51ca:	fe 4f       	sbci	r31, 0xFE	; 254
    51cc:	80 83       	st	Z, r24
						sdFifoWritePointer++;				// Move to next spot in fifo
    51ce:	80 91 28 01 	lds	r24, 0x0128
    51d2:	90 91 29 01 	lds	r25, 0x0129
    51d6:	01 96       	adiw	r24, 0x01	; 1
    51d8:	90 93 29 01 	sts	0x0129, r25
    51dc:	80 93 28 01 	sts	0x0128, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    51e0:	80 91 28 01 	lds	r24, 0x0128
    51e4:	90 91 29 01 	lds	r25, 0x0129
    51e8:	81 15       	cp	r24, r1
    51ea:	93 40       	sbci	r25, 0x03	; 3
    51ec:	20 f0       	brcs	.+8      	; 0x51f6 <main+0xb42>
						{
							sdFifoWritePointer=0;
    51ee:	10 92 29 01 	sts	0x0129, r1
    51f2:	10 92 28 01 	sts	0x0128, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    51f6:	2f b7       	in	r18, 0x3f	; 63
						cli();
    51f8:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    51fa:	80 91 26 01 	lds	r24, 0x0126
    51fe:	90 91 27 01 	lds	r25, 0x0127
    5202:	01 96       	adiw	r24, 0x01	; 1
    5204:	90 93 27 01 	sts	0x0127, r25
    5208:	80 93 26 01 	sts	0x0126, r24
						SREG=sreg;
    520c:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    520e:	33 94       	inc	r3
    5210:	83 2d       	mov	r24, r3
    5212:	90 e0       	ldi	r25, 0x00	; 0
    5214:	84 15       	cp	r24, r4
    5216:	95 05       	cpc	r25, r5
    5218:	08 f4       	brcc	.+2      	; 0x521c <main+0xb68>
    521a:	a5 cf       	rjmp	.-182    	; 0x5166 <main+0xab2>
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    521c:	80 91 c1 05 	lds	r24, 0x05C1
    5220:	90 91 c2 05 	lds	r25, 0x05C2
    5224:	89 2b       	or	r24, r25
    5226:	09 f0       	breq	.+2      	; 0x522a <main+0xb76>
    5228:	d9 c0       	rjmp	.+434    	; 0x53dc <main+0xd28>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    522a:	8f ef       	ldi	r24, 0xFF	; 255
    522c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5230:	8f ef       	ldi	r24, 0xFF	; 255
    5232:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5236:	80 91 c8 00 	lds	r24, 0x00C8
    523a:	86 ff       	sbrs	r24, 6
    523c:	fc cf       	rjmp	.-8      	; 0x5236 <main+0xb82>
						;

					EndSdTransfer();				// Bring CS high
    523e:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5242:	8f ef       	ldi	r24, 0xFF	; 255
    5244:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    5248:	60 92 57 05 	sts	0x0557, r6

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    524c:	80 91 1e 01 	lds	r24, 0x011E
    5250:	90 91 1f 01 	lds	r25, 0x011F
    5254:	a0 91 20 01 	lds	r26, 0x0120
    5258:	b0 91 21 01 	lds	r27, 0x0121
    525c:	89 2b       	or	r24, r25
    525e:	8a 2b       	or	r24, r26
    5260:	8b 2b       	or	r24, r27
    5262:	09 f0       	breq	.+2      	; 0x5266 <main+0xbb2>
    5264:	bb c0       	rjmp	.+374    	; 0x53dc <main+0xd28>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5266:	80 91 c8 00 	lds	r24, 0x00C8
    526a:	86 ff       	sbrs	r24, 6
    526c:	fc cf       	rjmp	.-8      	; 0x5266 <main+0xbb2>
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    526e:	b0 92 57 05 	sts	0x0557, r11
    5272:	b4 c0       	rjmp	.+360    	; 0x53dc <main+0xd28>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    5274:	ef b7       	in	r30, 0x3f	; 63
			cli();
    5276:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    5278:	20 91 26 01 	lds	r18, 0x0126
    527c:	30 91 27 01 	lds	r19, 0x0127
    5280:	80 e0       	ldi	r24, 0x00	; 0
    5282:	93 e0       	ldi	r25, 0x03	; 3
    5284:	ac 01       	movw	r20, r24
    5286:	42 1b       	sub	r20, r18
    5288:	53 0b       	sbc	r21, r19
    528a:	9a 01       	movw	r18, r20
    528c:	21 15       	cp	r18, r1
    528e:	32 40       	sbci	r19, 0x02	; 2
    5290:	a8 f4       	brcc	.+42     	; 0x52bc <main+0xc08>
    5292:	20 91 26 01 	lds	r18, 0x0126
    5296:	30 91 27 01 	lds	r19, 0x0127
    529a:	40 91 1e 01 	lds	r20, 0x011E
    529e:	50 91 1f 01 	lds	r21, 0x011F
    52a2:	60 91 20 01 	lds	r22, 0x0120
    52a6:	70 91 21 01 	lds	r23, 0x0121
    52aa:	82 1b       	sub	r24, r18
    52ac:	93 0b       	sbc	r25, r19
    52ae:	a0 e0       	ldi	r26, 0x00	; 0
    52b0:	b0 e0       	ldi	r27, 0x00	; 0
    52b2:	84 17       	cp	r24, r20
    52b4:	95 07       	cpc	r25, r21
    52b6:	a6 07       	cpc	r26, r22
    52b8:	b7 07       	cpc	r27, r23
    52ba:	28 f1       	brcs	.+74     	; 0x5306 <main+0xc52>
			{
				SREG=sreg;				// ISR back on.
    52bc:	ef bf       	out	0x3f, r30	; 63
				sdCurrentBlockOffset++;	// Point at next block
    52be:	20 91 b4 05 	lds	r18, 0x05B4
    52c2:	30 91 b5 05 	lds	r19, 0x05B5
    52c6:	2f 5f       	subi	r18, 0xFF	; 255
    52c8:	3f 4f       	sbci	r19, 0xFF	; 255
    52ca:	30 93 b5 05 	sts	0x05B5, r19
    52ce:	20 93 b4 05 	sts	0x05B4, r18

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    52d2:	60 91 b0 05 	lds	r22, 0x05B0
    52d6:	70 91 b1 05 	lds	r23, 0x05B1
    52da:	80 91 b2 05 	lds	r24, 0x05B2
    52de:	90 91 b3 05 	lds	r25, 0x05B3
    52e2:	62 0f       	add	r22, r18
    52e4:	73 1f       	adc	r23, r19
    52e6:	81 1d       	adc	r24, r1
    52e8:	91 1d       	adc	r25, r1
    52ea:	0e 94 38 23 	call	0x4670	; 0x4670 <SdBeginSingleBlockRead>
    52ee:	81 30       	cpi	r24, 0x01	; 1
    52f0:	09 f0       	breq	.+2      	; 0x52f4 <main+0xc40>
    52f2:	5d cb       	rjmp	.-2374   	; 0x49ae <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    52f4:	6a e7       	ldi	r22, 0x7A	; 122
    52f6:	70 e0       	ldi	r23, 0x00	; 0
    52f8:	83 e0       	ldi	r24, 0x03	; 3
    52fa:	0e 94 5e 1f 	call	0x3ebc	; 0x3ebc <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    52fe:	8c e0       	ldi	r24, 0x0C	; 12
    5300:	80 93 57 05 	sts	0x0557, r24
    5304:	6b c0       	rjmp	.+214    	; 0x53dc <main+0xd28>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    5306:	ef bf       	out	0x3f, r30	; 63
    5308:	69 c0       	rjmp	.+210    	; 0x53dc <main+0xd28>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    530a:	83 e0       	ldi	r24, 0x03	; 3
    530c:	0e 94 70 1f 	call	0x3ee0	; 0x3ee0 <CheckTimer>
    5310:	81 11       	cpse	r24, r1
    5312:	4d cb       	rjmp	.-2406   	; 0x49ae <main+0x2fa>
    5314:	a4 e0       	ldi	r26, 0x04	; 4
    5316:	5a 2e       	mov	r5, r26
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    5318:	8f ef       	ldi	r24, 0xFF	; 255
    531a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    531e:	8f 3f       	cpi	r24, 0xFF	; 255
    5320:	19 f4       	brne	.+6      	; 0x5328 <main+0xc74>
    5322:	5a 94       	dec	r5

			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    5324:	c9 f7       	brne	.-14     	; 0x5318 <main+0xc64>
    5326:	5a c0       	rjmp	.+180    	; 0x53dc <main+0xd28>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    5328:	8e 3f       	cpi	r24, 0xFE	; 254
    532a:	09 f0       	breq	.+2      	; 0x532e <main+0xc7a>
    532c:	40 cb       	rjmp	.-2432   	; 0x49ae <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
    532e:	10 93 c2 05 	sts	0x05C2, r17
    5332:	00 93 c1 05 	sts	0x05C1, r16

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    5336:	8a e0       	ldi	r24, 0x0A	; 10
    5338:	80 93 57 05 	sts	0x0557, r24
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    533c:	80 91 b6 05 	lds	r24, 0x05B6
    5340:	81 30       	cpi	r24, 0x01	; 1
    5342:	09 f0       	breq	.+2      	; 0x5346 <main+0xc92>
    5344:	4b c0       	rjmp	.+150    	; 0x53dc <main+0xd28>
					{
						cardState=SD_READ_ABORT;
    5346:	90 92 57 05 	sts	0x0557, r9
						sdAbortRead=false;
    534a:	10 92 b6 05 	sts	0x05B6, r1
    534e:	46 c0       	rjmp	.+140    	; 0x53dc <main+0xd28>
    5350:	40 90 c1 05 	lds	r4, 0x05C1
    5354:	50 90 c2 05 	lds	r5, 0x05C2
    5358:	61 e4       	ldi	r22, 0x41	; 65
    535a:	46 16       	cp	r4, r22
    535c:	51 04       	cpc	r5, r1
    535e:	18 f0       	brcs	.+6      	; 0x5366 <main+0xcb2>
    5360:	f0 e4       	ldi	r31, 0x40	; 64
    5362:	4f 2e       	mov	r4, r31
    5364:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    5366:	31 2c       	mov	r3, r1
    5368:	0d c0       	rjmp	.+26     	; 0x5384 <main+0xcd0>
			{
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    536a:	8f ef       	ldi	r24, 0xFF	; 255
    536c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    5370:	80 91 c1 05 	lds	r24, 0x05C1
    5374:	90 91 c2 05 	lds	r25, 0x05C2
    5378:	01 97       	sbiw	r24, 0x01	; 1
    537a:	90 93 c2 05 	sts	0x05C2, r25
    537e:	80 93 c1 05 	sts	0x05C1, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    5382:	33 94       	inc	r3
    5384:	83 2d       	mov	r24, r3
    5386:	90 e0       	ldi	r25, 0x00	; 0
    5388:	84 15       	cp	r24, r4
    538a:	95 05       	cpc	r25, r5
    538c:	70 f3       	brcs	.-36     	; 0x536a <main+0xcb6>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    538e:	80 91 c1 05 	lds	r24, 0x05C1
    5392:	90 91 c2 05 	lds	r25, 0x05C2
    5396:	89 2b       	or	r24, r25
    5398:	09 f5       	brne	.+66     	; 0x53dc <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    539a:	8f ef       	ldi	r24, 0xFF	; 255
    539c:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    53a0:	8f ef       	ldi	r24, 0xFF	; 255
    53a2:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    53a6:	80 91 c8 00 	lds	r24, 0x00C8
    53aa:	86 ff       	sbrs	r24, 6
    53ac:	fc cf       	rjmp	.-8      	; 0x53a6 <main+0xcf2>
					;

				EndSdTransfer();				// Bring CS high
    53ae:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    53b2:	8f ef       	ldi	r24, 0xFF	; 255
    53b4:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    53b8:	80 91 c8 00 	lds	r24, 0x00C8
    53bc:	86 ff       	sbrs	r24, 6
    53be:	fc cf       	rjmp	.-8      	; 0x53b8 <main+0xd04>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
    53c0:	b0 92 57 05 	sts	0x0557, r11

				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    53c4:	80 91 b9 05 	lds	r24, 0x05B9
    53c8:	81 30       	cpi	r24, 0x01	; 1
    53ca:	41 f4       	brne	.+16     	; 0x53dc <main+0xd28>
				{
					sdPlaybackQueued=false;
    53cc:	10 92 b9 05 	sts	0x05B9, r1
					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
    53d0:	80 91 b7 05 	lds	r24, 0x05B7
    53d4:	90 91 b8 05 	lds	r25, 0x05B8
    53d8:	0e 94 e7 0d 	call	0x1bce	; 0x1bce <PlaySampleFromSd>
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
		HandleLeds();			// Keep LEDs updated.
		UpdateCard();			// Keep the SD card state machine running.
		GetRandomLongInt();		// Keep random numbers rolling.
    53dc:	0e 94 6b 05 	call	0xad6	; 0xad6 <GetRandomLongInt>

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    53e0:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <Uart0GotByte>
    53e4:	88 23       	and	r24, r24
    53e6:	21 f0       	breq	.+8      	; 0x53f0 <main+0xd3c>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    53e8:	0e 94 3c 1f 	call	0x3e78	; 0x3e78 <Uart0GetByte>
    53ec:	0e 94 07 20 	call	0x400e	; 0x400e <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    53f0:	0e 94 c4 20 	call	0x4188	; 0x4188 <MidiTxBufferNotEmpty>
    53f4:	88 23       	and	r24, r24
    53f6:	41 f0       	breq	.+16     	; 0x5408 <main+0xd54>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    53f8:	80 91 c0 00 	lds	r24, 0x00C0
    53fc:	85 ff       	sbrs	r24, 5
    53fe:	04 c0       	rjmp	.+8      	; 0x5408 <main+0xd54>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    5400:	0e 94 d1 20 	call	0x41a2	; 0x41a2 <PopOutgoingMidiByte>
    5404:	80 93 c6 00 	sts	0x00C6, r24
			}
		}

		State();				// Execute the current program state.
    5408:	e0 91 e2 05 	lds	r30, 0x05E2
    540c:	f0 91 e3 05 	lds	r31, 0x05E3
    5410:	09 95       	icall
	}
    5412:	f4 c9       	rjmp	.-3096   	; 0x47fc <main+0x148>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    5414:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5418:	8f ef       	ldi	r24, 0xFF	; 255
    541a:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    541e:	df cc       	rjmp	.-1602   	; 0x4dde <main+0x72a>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    5420:	0e 94 95 21 	call	0x432a	; 0x432a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5424:	8f ef       	ldi	r24, 0xFF	; 255
    5426:	0e 94 9a 21 	call	0x4334	; 0x4334 <TransferSdByte>
    542a:	00 ce       	rjmp	.-1024   	; 0x502c <main+0x978>

0000542c <__udivmodqi4>:
    542c:	99 1b       	sub	r25, r25
    542e:	79 e0       	ldi	r23, 0x09	; 9
    5430:	04 c0       	rjmp	.+8      	; 0x543a <__udivmodqi4_ep>

00005432 <__udivmodqi4_loop>:
    5432:	99 1f       	adc	r25, r25
    5434:	96 17       	cp	r25, r22
    5436:	08 f0       	brcs	.+2      	; 0x543a <__udivmodqi4_ep>
    5438:	96 1b       	sub	r25, r22

0000543a <__udivmodqi4_ep>:
    543a:	88 1f       	adc	r24, r24
    543c:	7a 95       	dec	r23
    543e:	c9 f7       	brne	.-14     	; 0x5432 <__udivmodqi4_loop>
    5440:	80 95       	com	r24
    5442:	08 95       	ret

00005444 <__udivmodsi4>:
    5444:	a1 e2       	ldi	r26, 0x21	; 33
    5446:	1a 2e       	mov	r1, r26
    5448:	aa 1b       	sub	r26, r26
    544a:	bb 1b       	sub	r27, r27
    544c:	fd 01       	movw	r30, r26
    544e:	0d c0       	rjmp	.+26     	; 0x546a <__udivmodsi4_ep>

00005450 <__udivmodsi4_loop>:
    5450:	aa 1f       	adc	r26, r26
    5452:	bb 1f       	adc	r27, r27
    5454:	ee 1f       	adc	r30, r30
    5456:	ff 1f       	adc	r31, r31
    5458:	a2 17       	cp	r26, r18
    545a:	b3 07       	cpc	r27, r19
    545c:	e4 07       	cpc	r30, r20
    545e:	f5 07       	cpc	r31, r21
    5460:	20 f0       	brcs	.+8      	; 0x546a <__udivmodsi4_ep>
    5462:	a2 1b       	sub	r26, r18
    5464:	b3 0b       	sbc	r27, r19
    5466:	e4 0b       	sbc	r30, r20
    5468:	f5 0b       	sbc	r31, r21

0000546a <__udivmodsi4_ep>:
    546a:	66 1f       	adc	r22, r22
    546c:	77 1f       	adc	r23, r23
    546e:	88 1f       	adc	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	1a 94       	dec	r1
    5474:	69 f7       	brne	.-38     	; 0x5450 <__udivmodsi4_loop>
    5476:	60 95       	com	r22
    5478:	70 95       	com	r23
    547a:	80 95       	com	r24
    547c:	90 95       	com	r25
    547e:	9b 01       	movw	r18, r22
    5480:	ac 01       	movw	r20, r24
    5482:	bd 01       	movw	r22, r26
    5484:	cf 01       	movw	r24, r30
    5486:	08 95       	ret

00005488 <__tablejump2__>:
    5488:	ee 0f       	add	r30, r30
    548a:	ff 1f       	adc	r31, r31

0000548c <__tablejump__>:
    548c:	05 90       	lpm	r0, Z+
    548e:	f4 91       	lpm	r31, Z
    5490:	e0 2d       	mov	r30, r0
    5492:	09 94       	ijmp

00005494 <__umulhisi3>:
    5494:	a2 9f       	mul	r26, r18
    5496:	b0 01       	movw	r22, r0
    5498:	b3 9f       	mul	r27, r19
    549a:	c0 01       	movw	r24, r0
    549c:	a3 9f       	mul	r26, r19
    549e:	01 d0       	rcall	.+2      	; 0x54a2 <__umulhisi3+0xe>
    54a0:	b2 9f       	mul	r27, r18
    54a2:	70 0d       	add	r23, r0
    54a4:	81 1d       	adc	r24, r1
    54a6:	11 24       	eor	r1, r1
    54a8:	91 1d       	adc	r25, r1
    54aa:	08 95       	ret

000054ac <__muluhisi3>:
    54ac:	0e 94 4a 2a 	call	0x5494	; 0x5494 <__umulhisi3>
    54b0:	a5 9f       	mul	r26, r21
    54b2:	90 0d       	add	r25, r0
    54b4:	b4 9f       	mul	r27, r20
    54b6:	90 0d       	add	r25, r0
    54b8:	a4 9f       	mul	r26, r20
    54ba:	80 0d       	add	r24, r0
    54bc:	91 1d       	adc	r25, r1
    54be:	11 24       	eor	r1, r1
    54c0:	08 95       	ret

000054c2 <_exit>:
    54c2:	f8 94       	cli

000054c4 <__stop_program>:
    54c4:	ff cf       	rjmp	.-2      	; 0x54c4 <__stop_program>
