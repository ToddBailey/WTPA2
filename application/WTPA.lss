
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00006b5e  00006bf2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006b5e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000545  0080011e  0080011e  00006c10  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00006c10  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  000072dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00007373  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  000073a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00005b47  00000000  00000000  00007482  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000ad0  00000000  00000000  0000cfc9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001810  00000000  00000000  0000da99  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000072c  00000000  00000000  0000f2ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001417  00000000  00000000  0000f9d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00004154  00000000  00000000  00010def  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000ba0  00000000  00000000  00014f43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 67 23 	jmp	0x46ce	; 0x46ce <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 e0 26 	jmp	0x4dc0	; 0x4dc0 <__vector_9>
      28:	0c 94 e4 24 	jmp	0x49c8	; 0x49c8 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 1b 23 	jmp	0x4636	; 0x4636 <__vector_12>
      34:	0c 94 b1 23 	jmp	0x4762	; 0x4762 <__vector_13>
      38:	0c 94 4b 24 	jmp	0x4896	; 0x4896 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	e8 19       	sub	r30, r8
      7e:	23 13       	cpse	r18, r19
      80:	23 13       	cpse	r18, r19
      82:	23 13       	cpse	r18, r19
      84:	23 13       	cpse	r18, r19
      86:	23 13       	cpse	r18, r19
      88:	72 19       	sub	r23, r2
      8a:	23 13       	cpse	r18, r19
      8c:	23 13       	cpse	r18, r19
      8e:	23 13       	cpse	r18, r19
      90:	23 13       	cpse	r18, r19
      92:	4b 19       	sub	r20, r11
      94:	61 19       	sub	r22, r1
      96:	39 19       	sub	r19, r9
      98:	23 19       	sub	r18, r3
      9a:	08 19       	sub	r16, r8
      9c:	f7 18       	sub	r15, r7
      9e:	ee 18       	sub	r14, r14
      a0:	e0 18       	sub	r14, r0
      a2:	d0 18       	sub	r13, r0
      a4:	9c 18       	sub	r9, r12
      a6:	8c 18       	sub	r8, r12
      a8:	7c 18       	sub	r7, r12
      aa:	6c 18       	sub	r6, r12
      ac:	4b 18       	sub	r4, r11
      ae:	3a 18       	sub	r3, r10
      b0:	29 18       	sub	r2, r9
      b2:	18 18       	sub	r1, r8

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	ee e5       	ldi	r30, 0x5E	; 94
      c8:	fb e6       	ldi	r31, 0x6B	; 107
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	26 e0       	ldi	r18, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a3 36       	cpi	r26, 0x63	; 99
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 cd 2c 	call	0x599a	; 0x599a <main>
      ea:	0c 94 ad 35 	jmp	0x6b5a	; 0x6b5a <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 fb 26 	jmp	0x4df6	; 0x4df6 <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 e5 05 	lds	r24, 0x05E5
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	09 f4       	brne	.+2      	; 0xfc <UpdateAudioChannel0+0xa>
      fa:	11 c1       	rjmp	.+546    	; 0x31e <UpdateAudioChannel0+0x22c>
      fc:	38 f0       	brcs	.+14     	; 0x10c <UpdateAudioChannel0+0x1a>
      fe:	84 30       	cpi	r24, 0x04	; 4
     100:	09 f4       	brne	.+2      	; 0x104 <UpdateAudioChannel0+0x12>
     102:	91 c0       	rjmp	.+290    	; 0x226 <UpdateAudioChannel0+0x134>
     104:	85 30       	cpi	r24, 0x05	; 5
     106:	d1 f0       	breq	.+52     	; 0x13c <UpdateAudioChannel0+0x4a>
     108:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     10a:	08 95       	ret
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
     10c:	81 30       	cpi	r24, 0x01	; 1
     10e:	09 f4       	brne	.+2      	; 0x112 <UpdateAudioChannel0+0x20>
     110:	ff c0       	rjmp	.+510    	; 0x310 <UpdateAudioChannel0+0x21e>
     112:	82 30       	cpi	r24, 0x02	; 2
     114:	c9 f7       	brne	.-14     	; 0x108 <UpdateAudioChannel0+0x16>
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     116:	80 91 2c 04 	lds	r24, 0x042C

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     11a:	90 91 ee 05 	lds	r25, 0x05EE
     11e:	99 23       	and	r25, r25
     120:	a1 f3       	breq	.-24     	; 0x10a <UpdateAudioChannel0+0x18>
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     122:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     124:	90 91 ee 05 	lds	r25, 0x05EE
     128:	2f ef       	ldi	r18, 0xFF	; 255
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	09 2e       	mov	r0, r25
     12e:	01 c0       	rjmp	.+2      	; 0x132 <UpdateAudioChannel0+0x40>
     130:	22 0f       	add	r18, r18
     132:	0a 94       	dec	r0
     134:	ea f7       	brpl	.-6      	; 0x130 <UpdateAudioChannel0+0x3e>
     136:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     138:	80 58       	subi	r24, 0x80	; 128
     13a:	08 95       	ret
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     13c:	80 91 05 06 	lds	r24, 0x0605
     140:	90 91 06 06 	lds	r25, 0x0606
     144:	a0 91 07 06 	lds	r26, 0x0607
     148:	b0 91 08 06 	lds	r27, 0x0608
     14c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     14e:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     150:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     152:	80 91 05 06 	lds	r24, 0x0605
     156:	90 91 06 06 	lds	r25, 0x0606
     15a:	a0 91 07 06 	lds	r26, 0x0607
     15e:	b0 91 08 06 	lds	r27, 0x0608
     162:	89 2f       	mov	r24, r25
     164:	9a 2f       	mov	r25, r26
     166:	ab 2f       	mov	r26, r27
     168:	bb 27       	eor	r27, r27
     16a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     16c:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     16e:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC6 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     170:	80 91 05 06 	lds	r24, 0x0605
     174:	90 91 06 06 	lds	r25, 0x0606
     178:	a0 91 07 06 	lds	r26, 0x0607
     17c:	b0 91 08 06 	lds	r27, 0x0608
     180:	cd 01       	movw	r24, r26
     182:	aa 27       	eor	r26, r26
     184:	bb 27       	eor	r27, r27
     186:	87 70       	andi	r24, 0x07	; 7
     188:	99 27       	eor	r25, r25
     18a:	aa 27       	eor	r26, r26
     18c:	bb 27       	eor	r27, r27
     18e:	88 64       	ori	r24, 0x48	; 72
     190:	88 b9       	out	0x08, r24	; 8

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
//		PORTC&=~0x07;											// Clear PORTC bits 0-2
//		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     192:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     194:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     196:	80 91 ec 05 	lds	r24, 0x05EC
     19a:	88 23       	and	r24, r24
     19c:	09 f4       	brne	.+2      	; 0x1a0 <UpdateAudioChannel0+0xae>
     19e:	38 c1       	rjmp	.+624    	; 0x410 <UpdateAudioChannel0+0x31e>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     1a0:	80 91 2d 04 	lds	r24, 0x042D
     1a4:	90 91 2e 04 	lds	r25, 0x042E
     1a8:	a0 91 2f 04 	lds	r26, 0x042F
     1ac:	b0 91 30 04 	lds	r27, 0x0430
     1b0:	89 2b       	or	r24, r25
     1b2:	8a 2b       	or	r24, r26
     1b4:	8b 2b       	or	r24, r27
     1b6:	09 f0       	breq	.+2      	; 0x1ba <UpdateAudioChannel0+0xc8>
     1b8:	8a c2       	rjmp	.+1300   	; 0x6ce <UpdateAudioChannel0+0x5dc>
				bankStates[BANK_0].currentAddress++;
				sliceRemaining[BANK_0]--;
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     1ba:	80 91 35 04 	lds	r24, 0x0435
     1be:	90 91 36 04 	lds	r25, 0x0436
     1c2:	a0 91 37 04 	lds	r26, 0x0437
     1c6:	b0 91 38 04 	lds	r27, 0x0438
     1ca:	80 93 2d 04 	sts	0x042D, r24
     1ce:	90 93 2e 04 	sts	0x042E, r25
     1d2:	a0 93 2f 04 	sts	0x042F, r26
     1d6:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     1da:	80 91 3d 04 	lds	r24, 0x043D
     1de:	8f 5f       	subi	r24, 0xFF	; 255
     1e0:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     1e4:	90 91 3d 04 	lds	r25, 0x043D
     1e8:	80 91 ec 05 	lds	r24, 0x05EC
     1ec:	98 17       	cp	r25, r24
     1ee:	09 f4       	brne	.+2      	; 0x1f2 <UpdateAudioChannel0+0x100>
     1f0:	06 c3       	rjmp	.+1548   	; 0x7fe <UpdateAudioChannel0+0x70c>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     1f2:	e0 91 3d 04 	lds	r30, 0x043D
     1f6:	20 91 35 04 	lds	r18, 0x0435
     1fa:	30 91 36 04 	lds	r19, 0x0436
     1fe:	40 91 37 04 	lds	r20, 0x0437
     202:	50 91 38 04 	lds	r21, 0x0438
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	ec 5b       	subi	r30, 0xBC	; 188
     20a:	fb 4f       	sbci	r31, 0xFB	; 251
     20c:	a0 81       	ld	r26, Z
     20e:	b0 e0       	ldi	r27, 0x00	; 0
     210:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
     214:	60 93 05 06 	sts	0x0605, r22
     218:	70 93 06 06 	sts	0x0606, r23
     21c:	80 93 07 06 	sts	0x0607, r24
     220:	90 93 08 06 	sts	0x0608, r25
     224:	4f c1       	rjmp	.+670    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     226:	80 91 05 06 	lds	r24, 0x0605
     22a:	90 91 06 06 	lds	r25, 0x0606
     22e:	a0 91 07 06 	lds	r26, 0x0607
     232:	b0 91 08 06 	lds	r27, 0x0608
     236:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     238:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23a:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     23c:	80 91 05 06 	lds	r24, 0x0605
     240:	90 91 06 06 	lds	r25, 0x0606
     244:	a0 91 07 06 	lds	r26, 0x0607
     248:	b0 91 08 06 	lds	r27, 0x0608
     24c:	89 2f       	mov	r24, r25
     24e:	9a 2f       	mov	r25, r26
     250:	ab 2f       	mov	r26, r27
     252:	bb 27       	eor	r27, r27
     254:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     256:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     258:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC6 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25a:	80 91 05 06 	lds	r24, 0x0605
     25e:	90 91 06 06 	lds	r25, 0x0606
     262:	a0 91 07 06 	lds	r26, 0x0607
     266:	b0 91 08 06 	lds	r27, 0x0608
     26a:	cd 01       	movw	r24, r26
     26c:	aa 27       	eor	r26, r26
     26e:	bb 27       	eor	r27, r27
     270:	87 70       	andi	r24, 0x07	; 7
     272:	99 27       	eor	r25, r25
     274:	aa 27       	eor	r26, r26
     276:	bb 27       	eor	r27, r27
     278:	88 64       	ori	r24, 0x48	; 72
     27a:	88 b9       	out	0x08, r24	; 8

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
//		PORTC&=~0x07;											// Clear PORTC bits 0-2
//		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     27c:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     27e:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     280:	80 91 ec 05 	lds	r24, 0x05EC
     284:	88 23       	and	r24, r24
     286:	09 f4       	brne	.+2      	; 0x28a <UpdateAudioChannel0+0x198>
     288:	49 c1       	rjmp	.+658    	; 0x51c <UpdateAudioChannel0+0x42a>
		{
			// Slice first, only worry about forward ### @@@

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     28a:	80 91 2d 04 	lds	r24, 0x042D
     28e:	90 91 2e 04 	lds	r25, 0x042E
     292:	a0 91 2f 04 	lds	r26, 0x042F
     296:	b0 91 30 04 	lds	r27, 0x0430
     29a:	89 2b       	or	r24, r25
     29c:	8a 2b       	or	r24, r26
     29e:	8b 2b       	or	r24, r27
     2a0:	09 f0       	breq	.+2      	; 0x2a4 <UpdateAudioChannel0+0x1b2>
     2a2:	ee c1       	rjmp	.+988    	; 0x680 <UpdateAudioChannel0+0x58e>
				bankStates[BANK_0].currentAddress++;
				sliceRemaining[BANK_0]--;
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2a4:	80 91 35 04 	lds	r24, 0x0435
     2a8:	90 91 36 04 	lds	r25, 0x0436
     2ac:	a0 91 37 04 	lds	r26, 0x0437
     2b0:	b0 91 38 04 	lds	r27, 0x0438
     2b4:	80 93 2d 04 	sts	0x042D, r24
     2b8:	90 93 2e 04 	sts	0x042E, r25
     2bc:	a0 93 2f 04 	sts	0x042F, r26
     2c0:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     2c4:	80 91 3d 04 	lds	r24, 0x043D
     2c8:	8f 5f       	subi	r24, 0xFF	; 255
     2ca:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     2ce:	90 91 3d 04 	lds	r25, 0x043D
     2d2:	80 91 ec 05 	lds	r24, 0x05EC
     2d6:	98 17       	cp	r25, r24
     2d8:	09 f4       	brne	.+2      	; 0x2dc <UpdateAudioChannel0+0x1ea>
     2da:	8e c2       	rjmp	.+1308   	; 0x7f8 <UpdateAudioChannel0+0x706>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     2dc:	e0 91 3d 04 	lds	r30, 0x043D
     2e0:	20 91 35 04 	lds	r18, 0x0435
     2e4:	30 91 36 04 	lds	r19, 0x0436
     2e8:	40 91 37 04 	lds	r20, 0x0437
     2ec:	50 91 38 04 	lds	r21, 0x0438
     2f0:	f0 e0       	ldi	r31, 0x00	; 0
     2f2:	ec 5b       	subi	r30, 0xBC	; 188
     2f4:	fb 4f       	sbci	r31, 0xFB	; 251
     2f6:	a0 81       	ld	r26, Z
     2f8:	b0 e0       	ldi	r27, 0x00	; 0
     2fa:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
     2fe:	60 93 05 06 	sts	0x0605, r22
     302:	70 93 06 06 	sts	0x0606, r23
     306:	80 93 07 06 	sts	0x0607, r24
     30a:	90 93 08 06 	sts	0x0608, r25
     30e:	60 c1       	rjmp	.+704    	; 0x5d0 <UpdateAudioChannel0+0x4de>
	switch(bankStates[BANK_0].audioFunction)
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     310:	80 91 43 04 	lds	r24, 0x0443
     314:	98 2f       	mov	r25, r24
     316:	9f 5f       	subi	r25, 0xFF	; 255
     318:	90 93 43 04 	sts	0x0443, r25
		break;
     31c:	08 95       	ret
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     31e:	8f ef       	ldi	r24, 0xFF	; 255
     320:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     322:	80 91 05 06 	lds	r24, 0x0605
     326:	90 91 06 06 	lds	r25, 0x0606
     32a:	a0 91 07 06 	lds	r26, 0x0607
     32e:	b0 91 08 06 	lds	r27, 0x0608
     332:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     334:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     336:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     338:	80 91 05 06 	lds	r24, 0x0605
     33c:	90 91 06 06 	lds	r25, 0x0606
     340:	a0 91 07 06 	lds	r26, 0x0607
     344:	b0 91 08 06 	lds	r27, 0x0608
     348:	89 2f       	mov	r24, r25
     34a:	9a 2f       	mov	r25, r26
     34c:	ab 2f       	mov	r26, r27
     34e:	bb 27       	eor	r27, r27
     350:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     352:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     354:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x48|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC6 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     356:	80 91 05 06 	lds	r24, 0x0605
     35a:	90 91 06 06 	lds	r25, 0x0606
     35e:	a0 91 07 06 	lds	r26, 0x0607
     362:	b0 91 08 06 	lds	r27, 0x0608
     366:	cd 01       	movw	r24, r26
     368:	aa 27       	eor	r26, r26
     36a:	bb 27       	eor	r27, r27
     36c:	87 70       	andi	r24, 0x07	; 7
     36e:	99 27       	eor	r25, r25
     370:	aa 27       	eor	r26, r26
     372:	bb 27       	eor	r27, r27
     374:	88 64       	ori	r24, 0x48	; 72
     376:	88 b9       	out	0x08, r24	; 8

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
//		PORTC&=~0x07;											// Clear PORTC bits 0-2
//		PORTC|=((bankStates[BANK_0].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     378:	80 91 2c 04 	lds	r24, 0x042C
     37c:	85 b9       	out	0x05, r24	; 5
//			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
//			outOfRam=true;									// Signal mainline code that we're out of memory.
//		}

		// 6.6uS with this:
		bankStates[BANK_0].endAddress=++bankStates[BANK_0].currentAddress;			// Next address please, match ending address of the sample to the current memory address.
     37e:	80 91 05 06 	lds	r24, 0x0605
     382:	90 91 06 06 	lds	r25, 0x0606
     386:	a0 91 07 06 	lds	r26, 0x0607
     38a:	b0 91 08 06 	lds	r27, 0x0608
     38e:	01 96       	adiw	r24, 0x01	; 1
     390:	a1 1d       	adc	r26, r1
     392:	b1 1d       	adc	r27, r1
     394:	80 93 05 06 	sts	0x0605, r24
     398:	90 93 06 06 	sts	0x0606, r25
     39c:	a0 93 07 06 	sts	0x0607, r26
     3a0:	b0 93 08 06 	sts	0x0608, r27
     3a4:	80 93 f2 05 	sts	0x05F2, r24
     3a8:	90 93 f3 05 	sts	0x05F3, r25
     3ac:	a0 93 f4 05 	sts	0x05F4, r26
     3b0:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     3b4:	80 91 05 06 	lds	r24, 0x0605
     3b8:	90 91 06 06 	lds	r25, 0x0606
     3bc:	a0 91 07 06 	lds	r26, 0x0607
     3c0:	b0 91 08 06 	lds	r27, 0x0608
     3c4:	80 93 fa 05 	sts	0x05FA, r24
     3c8:	90 93 fb 05 	sts	0x05FB, r25
     3cc:	a0 93 fc 05 	sts	0x05FC, r26
     3d0:	b0 93 fd 05 	sts	0x05FD, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     3d4:	40 91 f2 05 	lds	r20, 0x05F2
     3d8:	50 91 f3 05 	lds	r21, 0x05F3
     3dc:	60 91 f4 05 	lds	r22, 0x05F4
     3e0:	70 91 f5 05 	lds	r23, 0x05F5
     3e4:	80 91 16 06 	lds	r24, 0x0616
     3e8:	90 91 17 06 	lds	r25, 0x0617
     3ec:	a0 91 18 06 	lds	r26, 0x0618
     3f0:	b0 91 19 06 	lds	r27, 0x0619
     3f4:	48 17       	cp	r20, r24
     3f6:	59 07       	cpc	r21, r25
     3f8:	6a 07       	cpc	r22, r26
     3fa:	7b 07       	cpc	r23, r27
     3fc:	28 f0       	brcs	.+10     	; 0x408 <UpdateAudioChannel0+0x316>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     3fe:	10 92 e5 05 	sts	0x05E5, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     402:	81 e0       	ldi	r24, 0x01	; 1
     404:	80 93 3f 04 	sts	0x043F, r24
		}		

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     408:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     40a:	11 9a       	sbi	0x02, 1	; 2
		break;
     40c:	80 e0       	ldi	r24, 0x00	; 0
     40e:	08 95       	ret
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     410:	80 91 e9 05 	lds	r24, 0x05E9
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     414:	40 91 05 06 	lds	r20, 0x0605
     418:	50 91 06 06 	lds	r21, 0x0606
     41c:	60 91 07 06 	lds	r22, 0x0607
     420:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     424:	88 23       	and	r24, r24
     426:	09 f4       	brne	.+2      	; 0x42a <UpdateAudioChannel0+0x338>
     428:	79 c1       	rjmp	.+754    	; 0x71c <UpdateAudioChannel0+0x62a>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42a:	80 91 fa 05 	lds	r24, 0x05FA
     42e:	90 91 fb 05 	lds	r25, 0x05FB
     432:	a0 91 fc 05 	lds	r26, 0x05FC
     436:	b0 91 fd 05 	lds	r27, 0x05FD
     43a:	48 17       	cp	r20, r24
     43c:	59 07       	cpc	r21, r25
     43e:	6a 07       	cpc	r22, r26
     440:	7b 07       	cpc	r23, r27
     442:	09 f4       	brne	.+2      	; 0x446 <UpdateAudioChannel0+0x354>
     444:	cd c1       	rjmp	.+922    	; 0x7e0 <UpdateAudioChannel0+0x6ee>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     446:	40 91 05 06 	lds	r20, 0x0605
     44a:	50 91 06 06 	lds	r21, 0x0606
     44e:	60 91 07 06 	lds	r22, 0x0607
     452:	70 91 08 06 	lds	r23, 0x0608
     456:	80 91 fa 05 	lds	r24, 0x05FA
     45a:	90 91 fb 05 	lds	r25, 0x05FB
     45e:	a0 91 fc 05 	lds	r26, 0x05FC
     462:	b0 91 fd 05 	lds	r27, 0x05FD
     466:	48 17       	cp	r20, r24
     468:	59 07       	cpc	r21, r25
     46a:	6a 07       	cpc	r22, r26
     46c:	7b 07       	cpc	r23, r27
     46e:	09 f4       	brne	.+2      	; 0x472 <UpdateAudioChannel0+0x380>
     470:	da c1       	rjmp	.+948    	; 0x826 <UpdateAudioChannel0+0x734>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     472:	40 91 05 06 	lds	r20, 0x0605
     476:	50 91 06 06 	lds	r21, 0x0606
     47a:	60 91 07 06 	lds	r22, 0x0607
     47e:	70 91 08 06 	lds	r23, 0x0608
     482:	80 91 f2 05 	lds	r24, 0x05F2
     486:	90 91 f3 05 	lds	r25, 0x05F3
     48a:	a0 91 f4 05 	lds	r26, 0x05F4
     48e:	b0 91 f5 05 	lds	r27, 0x05F5
     492:	48 17       	cp	r20, r24
     494:	59 07       	cpc	r21, r25
     496:	6a 07       	cpc	r22, r26
     498:	7b 07       	cpc	r23, r27
     49a:	09 f4       	brne	.+2      	; 0x49e <UpdateAudioChannel0+0x3ac>
     49c:	2a c2       	rjmp	.+1108   	; 0x8f2 <UpdateAudioChannel0+0x800>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     49e:	80 91 05 06 	lds	r24, 0x0605
     4a2:	90 91 06 06 	lds	r25, 0x0606
     4a6:	a0 91 07 06 	lds	r26, 0x0607
     4aa:	b0 91 08 06 	lds	r27, 0x0608
     4ae:	01 96       	adiw	r24, 0x01	; 1
     4b0:	a1 1d       	adc	r26, r1
     4b2:	b1 1d       	adc	r27, r1
     4b4:	80 93 05 06 	sts	0x0605, r24
     4b8:	90 93 06 06 	sts	0x0606, r25
     4bc:	a0 93 07 06 	sts	0x0607, r26
     4c0:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     4c4:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     4c6:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     4c8:	9f ef       	ldi	r25, 0xFF	; 255
     4ca:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     4cc:	90 91 ee 05 	lds	r25, 0x05EE
     4d0:	99 23       	and	r25, r25
     4d2:	61 f0       	breq	.+24     	; 0x4ec <UpdateAudioChannel0+0x3fa>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     4d4:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     4d6:	90 91 ee 05 	lds	r25, 0x05EE
     4da:	2f ef       	ldi	r18, 0xFF	; 255
     4dc:	30 e0       	ldi	r19, 0x00	; 0
     4de:	09 2e       	mov	r0, r25
     4e0:	01 c0       	rjmp	.+2      	; 0x4e4 <UpdateAudioChannel0+0x3f2>
     4e2:	22 0f       	add	r18, r18
     4e4:	0a 94       	dec	r0
     4e6:	ea f7       	brpl	.-6      	; 0x4e2 <UpdateAudioChannel0+0x3f0>
     4e8:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     4ea:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     4ec:	20 91 2c 04 	lds	r18, 0x042C
     4f0:	33 27       	eor	r19, r19
     4f2:	27 fd       	sbrc	r18, 7
     4f4:	30 95       	com	r19
     4f6:	28 0f       	add	r18, r24
     4f8:	31 1d       	adc	r19, r1
     4fa:	87 fd       	sbrc	r24, 7
     4fc:	3a 95       	dec	r19
     4fe:	20 38       	cpi	r18, 0x80	; 128
     500:	9f ef       	ldi	r25, 0xFF	; 255
     502:	39 07       	cpc	r19, r25
     504:	14 f4       	brge	.+4      	; 0x50a <UpdateAudioChannel0+0x418>
     506:	20 e8       	ldi	r18, 0x80	; 128
     508:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     50a:	20 38       	cpi	r18, 0x80	; 128
     50c:	31 05       	cpc	r19, r1
     50e:	14 f0       	brlt	.+4      	; 0x514 <UpdateAudioChannel0+0x422>
     510:	2f e7       	ldi	r18, 0x7F	; 127
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     516:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     518:	11 9a       	sbi	0x02, 1	; 2
		break;
     51a:	08 95       	ret
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     51c:	80 91 e9 05 	lds	r24, 0x05E9
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     520:	40 91 05 06 	lds	r20, 0x0605
     524:	50 91 06 06 	lds	r21, 0x0606
     528:	60 91 07 06 	lds	r22, 0x0607
     52c:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     530:	88 23       	and	r24, r24
     532:	09 f4       	brne	.+2      	; 0x536 <UpdateAudioChannel0+0x444>
     534:	57 c0       	rjmp	.+174    	; 0x5e4 <UpdateAudioChannel0+0x4f2>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     536:	80 91 fa 05 	lds	r24, 0x05FA
     53a:	90 91 fb 05 	lds	r25, 0x05FB
     53e:	a0 91 fc 05 	lds	r26, 0x05FC
     542:	b0 91 fd 05 	lds	r27, 0x05FD
     546:	48 17       	cp	r20, r24
     548:	59 07       	cpc	r21, r25
     54a:	6a 07       	cpc	r22, r26
     54c:	7b 07       	cpc	r23, r27
     54e:	09 f4       	brne	.+2      	; 0x552 <UpdateAudioChannel0+0x460>
     550:	4d c1       	rjmp	.+666    	; 0x7ec <UpdateAudioChannel0+0x6fa>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     552:	40 91 05 06 	lds	r20, 0x0605
     556:	50 91 06 06 	lds	r21, 0x0606
     55a:	60 91 07 06 	lds	r22, 0x0607
     55e:	70 91 08 06 	lds	r23, 0x0608
     562:	80 91 fa 05 	lds	r24, 0x05FA
     566:	90 91 fb 05 	lds	r25, 0x05FB
     56a:	a0 91 fc 05 	lds	r26, 0x05FC
     56e:	b0 91 fd 05 	lds	r27, 0x05FD
     572:	48 17       	cp	r20, r24
     574:	59 07       	cpc	r21, r25
     576:	6a 07       	cpc	r22, r26
     578:	7b 07       	cpc	r23, r27
     57a:	09 f4       	brne	.+2      	; 0x57e <UpdateAudioChannel0+0x48c>
     57c:	43 c1       	rjmp	.+646    	; 0x804 <UpdateAudioChannel0+0x712>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     57e:	40 91 05 06 	lds	r20, 0x0605
     582:	50 91 06 06 	lds	r21, 0x0606
     586:	60 91 07 06 	lds	r22, 0x0607
     58a:	70 91 08 06 	lds	r23, 0x0608
     58e:	80 91 f2 05 	lds	r24, 0x05F2
     592:	90 91 f3 05 	lds	r25, 0x05F3
     596:	a0 91 f4 05 	lds	r26, 0x05F4
     59a:	b0 91 f5 05 	lds	r27, 0x05F5
     59e:	48 17       	cp	r20, r24
     5a0:	59 07       	cpc	r21, r25
     5a2:	6a 07       	cpc	r22, r26
     5a4:	7b 07       	cpc	r23, r27
     5a6:	09 f4       	brne	.+2      	; 0x5aa <UpdateAudioChannel0+0x4b8>
     5a8:	93 c1       	rjmp	.+806    	; 0x8d0 <UpdateAudioChannel0+0x7de>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     5aa:	80 91 05 06 	lds	r24, 0x0605
     5ae:	90 91 06 06 	lds	r25, 0x0606
     5b2:	a0 91 07 06 	lds	r26, 0x0607
     5b6:	b0 91 08 06 	lds	r27, 0x0608
     5ba:	01 96       	adiw	r24, 0x01	; 1
     5bc:	a1 1d       	adc	r26, r1
     5be:	b1 1d       	adc	r27, r1
     5c0:	80 93 05 06 	sts	0x0605, r24
     5c4:	90 93 06 06 	sts	0x0606, r25
     5c8:	a0 93 07 06 	sts	0x0607, r26
     5cc:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     5d0:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     5d2:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     5d4:	9f ef       	ldi	r25, 0xFF	; 255
     5d6:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     5d8:	90 91 ee 05 	lds	r25, 0x05EE
     5dc:	99 23       	and	r25, r25
     5de:	09 f4       	brne	.+2      	; 0x5e2 <UpdateAudioChannel0+0x4f0>
     5e0:	94 cd       	rjmp	.-1240   	; 0x10a <UpdateAudioChannel0+0x18>
     5e2:	9f cd       	rjmp	.-1218   	; 0x122 <UpdateAudioChannel0+0x30>
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     5e4:	80 91 fe 05 	lds	r24, 0x05FE
     5e8:	90 91 ff 05 	lds	r25, 0x05FF
     5ec:	a0 91 00 06 	lds	r26, 0x0600
     5f0:	b0 91 01 06 	lds	r27, 0x0601
     5f4:	48 17       	cp	r20, r24
     5f6:	59 07       	cpc	r21, r25
     5f8:	6a 07       	cpc	r22, r26
     5fa:	7b 07       	cpc	r23, r27
     5fc:	09 f4       	brne	.+2      	; 0x600 <UpdateAudioChannel0+0x50e>
     5fe:	dc c0       	rjmp	.+440    	; 0x7b8 <UpdateAudioChannel0+0x6c6>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     600:	40 91 05 06 	lds	r20, 0x0605
     604:	50 91 06 06 	lds	r21, 0x0606
     608:	60 91 07 06 	lds	r22, 0x0607
     60c:	70 91 08 06 	lds	r23, 0x0608
     610:	80 91 fe 05 	lds	r24, 0x05FE
     614:	90 91 ff 05 	lds	r25, 0x05FF
     618:	a0 91 00 06 	lds	r26, 0x0600
     61c:	b0 91 01 06 	lds	r27, 0x0601
     620:	48 17       	cp	r20, r24
     622:	59 07       	cpc	r21, r25
     624:	6a 07       	cpc	r22, r26
     626:	7b 07       	cpc	r23, r27
     628:	09 f4       	brne	.+2      	; 0x62c <UpdateAudioChannel0+0x53a>
     62a:	1f c1       	rjmp	.+574    	; 0x86a <UpdateAudioChannel0+0x778>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     62c:	40 91 05 06 	lds	r20, 0x0605
     630:	50 91 06 06 	lds	r21, 0x0606
     634:	60 91 07 06 	lds	r22, 0x0607
     638:	70 91 08 06 	lds	r23, 0x0608
     63c:	80 91 f6 05 	lds	r24, 0x05F6
     640:	90 91 f7 05 	lds	r25, 0x05F7
     644:	a0 91 f8 05 	lds	r26, 0x05F8
     648:	b0 91 f9 05 	lds	r27, 0x05F9
     64c:	48 17       	cp	r20, r24
     64e:	59 07       	cpc	r21, r25
     650:	6a 07       	cpc	r22, r26
     652:	7b 07       	cpc	r23, r27
     654:	09 f4       	brne	.+2      	; 0x658 <UpdateAudioChannel0+0x566>
     656:	1a c1       	rjmp	.+564    	; 0x88c <UpdateAudioChannel0+0x79a>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     658:	80 91 05 06 	lds	r24, 0x0605
     65c:	90 91 06 06 	lds	r25, 0x0606
     660:	a0 91 07 06 	lds	r26, 0x0607
     664:	b0 91 08 06 	lds	r27, 0x0608
     668:	01 97       	sbiw	r24, 0x01	; 1
     66a:	a1 09       	sbc	r26, r1
     66c:	b1 09       	sbc	r27, r1
     66e:	80 93 05 06 	sts	0x0605, r24
     672:	90 93 06 06 	sts	0x0606, r25
     676:	a0 93 07 06 	sts	0x0607, r26
     67a:	b0 93 08 06 	sts	0x0608, r27
     67e:	a8 cf       	rjmp	.-176    	; 0x5d0 <UpdateAudioChannel0+0x4de>
		{
			// Slice first, only worry about forward ### @@@

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
			{
				bankStates[BANK_0].currentAddress++;
     680:	80 91 05 06 	lds	r24, 0x0605
     684:	90 91 06 06 	lds	r25, 0x0606
     688:	a0 91 07 06 	lds	r26, 0x0607
     68c:	b0 91 08 06 	lds	r27, 0x0608
     690:	01 96       	adiw	r24, 0x01	; 1
     692:	a1 1d       	adc	r26, r1
     694:	b1 1d       	adc	r27, r1
     696:	80 93 05 06 	sts	0x0605, r24
     69a:	90 93 06 06 	sts	0x0606, r25
     69e:	a0 93 07 06 	sts	0x0607, r26
     6a2:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     6a6:	80 91 2d 04 	lds	r24, 0x042D
     6aa:	90 91 2e 04 	lds	r25, 0x042E
     6ae:	a0 91 2f 04 	lds	r26, 0x042F
     6b2:	b0 91 30 04 	lds	r27, 0x0430
     6b6:	01 97       	sbiw	r24, 0x01	; 1
     6b8:	a1 09       	sbc	r26, r1
     6ba:	b1 09       	sbc	r27, r1
     6bc:	80 93 2d 04 	sts	0x042D, r24
     6c0:	90 93 2e 04 	sts	0x042E, r25
     6c4:	a0 93 2f 04 	sts	0x042F, r26
     6c8:	b0 93 30 04 	sts	0x0430, r27
     6cc:	81 cf       	rjmp	.-254    	; 0x5d0 <UpdateAudioChannel0+0x4de>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
			{
				bankStates[BANK_0].currentAddress++;
     6ce:	80 91 05 06 	lds	r24, 0x0605
     6d2:	90 91 06 06 	lds	r25, 0x0606
     6d6:	a0 91 07 06 	lds	r26, 0x0607
     6da:	b0 91 08 06 	lds	r27, 0x0608
     6de:	01 96       	adiw	r24, 0x01	; 1
     6e0:	a1 1d       	adc	r26, r1
     6e2:	b1 1d       	adc	r27, r1
     6e4:	80 93 05 06 	sts	0x0605, r24
     6e8:	90 93 06 06 	sts	0x0606, r25
     6ec:	a0 93 07 06 	sts	0x0607, r26
     6f0:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     6f4:	80 91 2d 04 	lds	r24, 0x042D
     6f8:	90 91 2e 04 	lds	r25, 0x042E
     6fc:	a0 91 2f 04 	lds	r26, 0x042F
     700:	b0 91 30 04 	lds	r27, 0x0430
     704:	01 97       	sbiw	r24, 0x01	; 1
     706:	a1 09       	sbc	r26, r1
     708:	b1 09       	sbc	r27, r1
     70a:	80 93 2d 04 	sts	0x042D, r24
     70e:	90 93 2e 04 	sts	0x042E, r25
     712:	a0 93 2f 04 	sts	0x042F, r26
     716:	b0 93 30 04 	sts	0x0430, r27
     71a:	d4 ce       	rjmp	.-600    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     71c:	80 91 fe 05 	lds	r24, 0x05FE
     720:	90 91 ff 05 	lds	r25, 0x05FF
     724:	a0 91 00 06 	lds	r26, 0x0600
     728:	b0 91 01 06 	lds	r27, 0x0601
     72c:	48 17       	cp	r20, r24
     72e:	59 07       	cpc	r21, r25
     730:	6a 07       	cpc	r22, r26
     732:	7b 07       	cpc	r23, r27
     734:	09 f4       	brne	.+2      	; 0x738 <UpdateAudioChannel0+0x646>
     736:	4a c0       	rjmp	.+148    	; 0x7cc <UpdateAudioChannel0+0x6da>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     738:	40 91 05 06 	lds	r20, 0x0605
     73c:	50 91 06 06 	lds	r21, 0x0606
     740:	60 91 07 06 	lds	r22, 0x0607
     744:	70 91 08 06 	lds	r23, 0x0608
     748:	80 91 fe 05 	lds	r24, 0x05FE
     74c:	90 91 ff 05 	lds	r25, 0x05FF
     750:	a0 91 00 06 	lds	r26, 0x0600
     754:	b0 91 01 06 	lds	r27, 0x0601
     758:	48 17       	cp	r20, r24
     75a:	59 07       	cpc	r21, r25
     75c:	6a 07       	cpc	r22, r26
     75e:	7b 07       	cpc	r23, r27
     760:	09 f4       	brne	.+2      	; 0x764 <UpdateAudioChannel0+0x672>
     762:	72 c0       	rjmp	.+228    	; 0x848 <UpdateAudioChannel0+0x756>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     764:	40 91 05 06 	lds	r20, 0x0605
     768:	50 91 06 06 	lds	r21, 0x0606
     76c:	60 91 07 06 	lds	r22, 0x0607
     770:	70 91 08 06 	lds	r23, 0x0608
     774:	80 91 f6 05 	lds	r24, 0x05F6
     778:	90 91 f7 05 	lds	r25, 0x05F7
     77c:	a0 91 f8 05 	lds	r26, 0x05F8
     780:	b0 91 f9 05 	lds	r27, 0x05F9
     784:	48 17       	cp	r20, r24
     786:	59 07       	cpc	r21, r25
     788:	6a 07       	cpc	r22, r26
     78a:	7b 07       	cpc	r23, r27
     78c:	09 f4       	brne	.+2      	; 0x790 <UpdateAudioChannel0+0x69e>
     78e:	8f c0       	rjmp	.+286    	; 0x8ae <UpdateAudioChannel0+0x7bc>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     790:	80 91 05 06 	lds	r24, 0x0605
     794:	90 91 06 06 	lds	r25, 0x0606
     798:	a0 91 07 06 	lds	r26, 0x0607
     79c:	b0 91 08 06 	lds	r27, 0x0608
     7a0:	01 97       	sbiw	r24, 0x01	; 1
     7a2:	a1 09       	sbc	r26, r1
     7a4:	b1 09       	sbc	r27, r1
     7a6:	80 93 05 06 	sts	0x0605, r24
     7aa:	90 93 06 06 	sts	0x0606, r25
     7ae:	a0 93 07 06 	sts	0x0607, r26
     7b2:	b0 93 08 06 	sts	0x0608, r27
     7b6:	86 ce       	rjmp	.-756    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     7b8:	80 91 e6 05 	lds	r24, 0x05E6
     7bc:	81 30       	cpi	r24, 0x01	; 1
     7be:	09 f0       	breq	.+2      	; 0x7c2 <UpdateAudioChannel0+0x6d0>
     7c0:	1f cf       	rjmp	.-450    	; 0x600 <UpdateAudioChannel0+0x50e>
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     7c2:	10 92 e5 05 	sts	0x05E5, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     7c6:	10 92 ef 05 	sts	0x05EF, r1
     7ca:	02 cf       	rjmp	.-508    	; 0x5d0 <UpdateAudioChannel0+0x4de>
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     7cc:	80 91 e6 05 	lds	r24, 0x05E6
     7d0:	81 30       	cpi	r24, 0x01	; 1
     7d2:	09 f0       	breq	.+2      	; 0x7d6 <UpdateAudioChannel0+0x6e4>
     7d4:	b1 cf       	rjmp	.-158    	; 0x738 <UpdateAudioChannel0+0x646>
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     7d6:	10 92 e5 05 	sts	0x05E5, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     7da:	10 92 ef 05 	sts	0x05EF, r1
     7de:	72 ce       	rjmp	.-796    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     7e0:	80 91 e6 05 	lds	r24, 0x05E6
     7e4:	81 30       	cpi	r24, 0x01	; 1
     7e6:	09 f0       	breq	.+2      	; 0x7ea <UpdateAudioChannel0+0x6f8>
     7e8:	2e ce       	rjmp	.-932    	; 0x446 <UpdateAudioChannel0+0x354>
     7ea:	f5 cf       	rjmp	.-22     	; 0x7d6 <UpdateAudioChannel0+0x6e4>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     7ec:	80 91 e6 05 	lds	r24, 0x05E6
     7f0:	81 30       	cpi	r24, 0x01	; 1
     7f2:	09 f0       	breq	.+2      	; 0x7f6 <UpdateAudioChannel0+0x704>
     7f4:	ae ce       	rjmp	.-676    	; 0x552 <UpdateAudioChannel0+0x460>
     7f6:	e5 cf       	rjmp	.-54     	; 0x7c2 <UpdateAudioChannel0+0x6d0>
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     7f8:	10 92 3d 04 	sts	0x043D, r1
     7fc:	6f cd       	rjmp	.-1314   	; 0x2dc <UpdateAudioChannel0+0x1ea>
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     7fe:	10 92 3d 04 	sts	0x043D, r1
     802:	f7 cc       	rjmp	.-1554   	; 0x1f2 <UpdateAudioChannel0+0x100>
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     804:	80 91 fe 05 	lds	r24, 0x05FE
     808:	90 91 ff 05 	lds	r25, 0x05FF
     80c:	a0 91 00 06 	lds	r26, 0x0600
     810:	b0 91 01 06 	lds	r27, 0x0601
     814:	80 93 05 06 	sts	0x0605, r24
     818:	90 93 06 06 	sts	0x0606, r25
     81c:	a0 93 07 06 	sts	0x0607, r26
     820:	b0 93 08 06 	sts	0x0608, r27
     824:	d5 ce       	rjmp	.-598    	; 0x5d0 <UpdateAudioChannel0+0x4de>
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     826:	80 91 fe 05 	lds	r24, 0x05FE
     82a:	90 91 ff 05 	lds	r25, 0x05FF
     82e:	a0 91 00 06 	lds	r26, 0x0600
     832:	b0 91 01 06 	lds	r27, 0x0601
     836:	80 93 05 06 	sts	0x0605, r24
     83a:	90 93 06 06 	sts	0x0606, r25
     83e:	a0 93 07 06 	sts	0x0607, r26
     842:	b0 93 08 06 	sts	0x0608, r27
     846:	3e ce       	rjmp	.-900    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     848:	80 91 fa 05 	lds	r24, 0x05FA
     84c:	90 91 fb 05 	lds	r25, 0x05FB
     850:	a0 91 fc 05 	lds	r26, 0x05FC
     854:	b0 91 fd 05 	lds	r27, 0x05FD
     858:	80 93 05 06 	sts	0x0605, r24
     85c:	90 93 06 06 	sts	0x0606, r25
     860:	a0 93 07 06 	sts	0x0607, r26
     864:	b0 93 08 06 	sts	0x0608, r27
     868:	2d ce       	rjmp	.-934    	; 0x4c4 <UpdateAudioChannel0+0x3d2>
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     86a:	80 91 fa 05 	lds	r24, 0x05FA
     86e:	90 91 fb 05 	lds	r25, 0x05FB
     872:	a0 91 fc 05 	lds	r26, 0x05FC
     876:	b0 91 fd 05 	lds	r27, 0x05FD
     87a:	80 93 05 06 	sts	0x0605, r24
     87e:	90 93 06 06 	sts	0x0606, r25
     882:	a0 93 07 06 	sts	0x0607, r26
     886:	b0 93 08 06 	sts	0x0608, r27
     88a:	a2 ce       	rjmp	.-700    	; 0x5d0 <UpdateAudioChannel0+0x4de>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     88c:	80 91 f2 05 	lds	r24, 0x05F2
     890:	90 91 f3 05 	lds	r25, 0x05F3
     894:	a0 91 f4 05 	lds	r26, 0x05F4
     898:	b0 91 f5 05 	lds	r27, 0x05F5
     89c:	80 93 05 06 	sts	0x0605, r24
     8a0:	90 93 06 06 	sts	0x0606, r25
     8a4:	a0 93 07 06 	sts	0x0607, r26
     8a8:	b0 93 08 06 	sts	0x0608, r27
     8ac:	91 ce       	rjmp	.-734    	; 0x5d0 <UpdateAudioChannel0+0x4de>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     8ae:	80 91 f2 05 	lds	r24, 0x05F2
     8b2:	90 91 f3 05 	lds	r25, 0x05F3
     8b6:	a0 91 f4 05 	lds	r26, 0x05F4
     8ba:	b0 91 f5 05 	lds	r27, 0x05F5
     8be:	80 93 05 06 	sts	0x0605, r24
     8c2:	90 93 06 06 	sts	0x0606, r25
     8c6:	a0 93 07 06 	sts	0x0607, r26
     8ca:	b0 93 08 06 	sts	0x0608, r27
     8ce:	fa cd       	rjmp	.-1036   	; 0x4c4 <UpdateAudioChannel0+0x3d2>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     8d0:	80 91 f6 05 	lds	r24, 0x05F6
     8d4:	90 91 f7 05 	lds	r25, 0x05F7
     8d8:	a0 91 f8 05 	lds	r26, 0x05F8
     8dc:	b0 91 f9 05 	lds	r27, 0x05F9
     8e0:	80 93 05 06 	sts	0x0605, r24
     8e4:	90 93 06 06 	sts	0x0606, r25
     8e8:	a0 93 07 06 	sts	0x0607, r26
     8ec:	b0 93 08 06 	sts	0x0608, r27
     8f0:	6f ce       	rjmp	.-802    	; 0x5d0 <UpdateAudioChannel0+0x4de>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     8f2:	80 91 f6 05 	lds	r24, 0x05F6
     8f6:	90 91 f7 05 	lds	r25, 0x05F7
     8fa:	a0 91 f8 05 	lds	r26, 0x05F8
     8fe:	b0 91 f9 05 	lds	r27, 0x05F9
     902:	80 93 05 06 	sts	0x0605, r24
     906:	90 93 06 06 	sts	0x0606, r25
     90a:	a0 93 07 06 	sts	0x0607, r26
     90e:	b0 93 08 06 	sts	0x0608, r27
     912:	d8 cd       	rjmp	.-1104   	; 0x4c4 <UpdateAudioChannel0+0x3d2>

00000914 <UpdateAudioChannel1>:
	return(outputByte);
}

static unsigned char UpdateAudioChannel1(void)
// New banked idea of the audio handler -- ONE FOR EACH BANK!
{
     914:	0f 93       	push	r16
     916:	1f 93       	push	r17
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     918:	80 91 09 06 	lds	r24, 0x0609
     91c:	83 30       	cpi	r24, 0x03	; 3
     91e:	09 f4       	brne	.+2      	; 0x922 <UpdateAudioChannel1+0xe>
     920:	25 c1       	rjmp	.+586    	; 0xb6c <UpdateAudioChannel1+0x258>
     922:	48 f0       	brcs	.+18     	; 0x936 <UpdateAudioChannel1+0x22>
     924:	84 30       	cpi	r24, 0x04	; 4
     926:	09 f4       	brne	.+2      	; 0x92a <UpdateAudioChannel1+0x16>
     928:	9c c0       	rjmp	.+312    	; 0xa62 <UpdateAudioChannel1+0x14e>
     92a:	85 30       	cpi	r24, 0x05	; 5
     92c:	f1 f0       	breq	.+60     	; 0x96a <UpdateAudioChannel1+0x56>
     92e:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	08 95       	ret
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     936:	81 30       	cpi	r24, 0x01	; 1
     938:	09 f4       	brne	.+2      	; 0x93c <UpdateAudioChannel1+0x28>
     93a:	0f c1       	rjmp	.+542    	; 0xb5a <UpdateAudioChannel1+0x246>
     93c:	82 30       	cpi	r24, 0x02	; 2
     93e:	b9 f7       	brne	.-18     	; 0x92e <UpdateAudioChannel1+0x1a>
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     940:	80 91 2c 04 	lds	r24, 0x042C

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     944:	90 91 12 06 	lds	r25, 0x0612
     948:	99 23       	and	r25, r25
     94a:	91 f3       	breq	.-28     	; 0x930 <UpdateAudioChannel1+0x1c>
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     94c:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     94e:	90 91 12 06 	lds	r25, 0x0612
     952:	2f ef       	ldi	r18, 0xFF	; 255
     954:	30 e0       	ldi	r19, 0x00	; 0
     956:	09 2e       	mov	r0, r25
     958:	01 c0       	rjmp	.+2      	; 0x95c <UpdateAudioChannel1+0x48>
     95a:	22 0f       	add	r18, r18
     95c:	0a 94       	dec	r0
     95e:	ea f7       	brpl	.-6      	; 0x95a <UpdateAudioChannel1+0x46>
     960:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     962:	80 58       	subi	r24, 0x80	; 128
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     964:	1f 91       	pop	r17
     966:	0f 91       	pop	r16
     968:	08 95       	ret
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     96a:	80 91 29 06 	lds	r24, 0x0629
     96e:	90 91 2a 06 	lds	r25, 0x062A
     972:	a0 91 2b 06 	lds	r26, 0x062B
     976:	b0 91 2c 06 	lds	r27, 0x062C
     97a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     97c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     97e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     980:	80 91 29 06 	lds	r24, 0x0629
     984:	90 91 2a 06 	lds	r25, 0x062A
     988:	a0 91 2b 06 	lds	r26, 0x062B
     98c:	b0 91 2c 06 	lds	r27, 0x062C
     990:	89 2f       	mov	r24, r25
     992:	9a 2f       	mov	r25, r26
     994:	ab 2f       	mov	r26, r27
     996:	bb 27       	eor	r27, r27
     998:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     99a:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     99c:	14 98       	cbi	0x02, 4	; 2

		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
		PORTC&=~0x07;											// Clear PORTC bits 0-2
     99e:	88 b1       	in	r24, 0x08	; 8
     9a0:	88 7f       	andi	r24, 0xF8	; 248
     9a2:	88 b9       	out	0x08, r24	; 8
		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
     9a4:	28 b1       	in	r18, 0x08	; 8
     9a6:	80 91 29 06 	lds	r24, 0x0629
     9aa:	90 91 2a 06 	lds	r25, 0x062A
     9ae:	a0 91 2b 06 	lds	r26, 0x062B
     9b2:	b0 91 2c 06 	lds	r27, 0x062C
     9b6:	8a 2f       	mov	r24, r26
     9b8:	87 70       	andi	r24, 0x07	; 7
     9ba:	82 2b       	or	r24, r18
     9bc:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9be:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9c0:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9c2:	80 91 10 06 	lds	r24, 0x0610
     9c6:	88 23       	and	r24, r24
     9c8:	09 f4       	brne	.+2      	; 0x9cc <UpdateAudioChannel1+0xb8>
     9ca:	52 c1       	rjmp	.+676    	; 0xc70 <UpdateAudioChannel1+0x35c>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     9cc:	80 91 31 04 	lds	r24, 0x0431
     9d0:	90 91 32 04 	lds	r25, 0x0432
     9d4:	a0 91 33 04 	lds	r26, 0x0433
     9d8:	b0 91 34 04 	lds	r27, 0x0434
     9dc:	89 2b       	or	r24, r25
     9de:	8a 2b       	or	r24, r26
     9e0:	8b 2b       	or	r24, r27
     9e2:	09 f0       	breq	.+2      	; 0x9e6 <UpdateAudioChannel1+0xd2>
     9e4:	a6 c2       	rjmp	.+1356   	; 0xf32 <UpdateAudioChannel1+0x61e>
				bankStates[BANK_1].currentAddress--;
				sliceRemaining[BANK_1]--;
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     9e6:	80 91 39 04 	lds	r24, 0x0439
     9ea:	90 91 3a 04 	lds	r25, 0x043A
     9ee:	a0 91 3b 04 	lds	r26, 0x043B
     9f2:	b0 91 3c 04 	lds	r27, 0x043C
     9f6:	80 93 31 04 	sts	0x0431, r24
     9fa:	90 93 32 04 	sts	0x0432, r25
     9fe:	a0 93 33 04 	sts	0x0433, r26
     a02:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a06:	80 91 3e 04 	lds	r24, 0x043E
     a0a:	8f 5f       	subi	r24, 0xFF	; 255
     a0c:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a10:	90 91 3e 04 	lds	r25, 0x043E
     a14:	80 91 10 06 	lds	r24, 0x0610
     a18:	98 17       	cp	r25, r24
     a1a:	09 f4       	brne	.+2      	; 0xa1e <UpdateAudioChannel1+0x10a>
     a1c:	22 c3       	rjmp	.+1604   	; 0x1062 <UpdateAudioChannel1+0x74e>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     a1e:	e0 91 3e 04 	lds	r30, 0x043E
     a22:	20 91 39 04 	lds	r18, 0x0439
     a26:	30 91 3a 04 	lds	r19, 0x043A
     a2a:	40 91 3b 04 	lds	r20, 0x043B
     a2e:	50 91 3c 04 	lds	r21, 0x043C
     a32:	f0 e0       	ldi	r31, 0x00	; 0
     a34:	ec 53       	subi	r30, 0x3C	; 60
     a36:	fb 4f       	sbci	r31, 0xFB	; 251
     a38:	a0 81       	ld	r26, Z
     a3a:	b0 e0       	ldi	r27, 0x00	; 0
     a3c:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
     a40:	0f ef       	ldi	r16, 0xFF	; 255
     a42:	1f ef       	ldi	r17, 0xFF	; 255
     a44:	27 e0       	ldi	r18, 0x07	; 7
     a46:	30 e0       	ldi	r19, 0x00	; 0
     a48:	06 1b       	sub	r16, r22
     a4a:	17 0b       	sbc	r17, r23
     a4c:	28 0b       	sbc	r18, r24
     a4e:	39 0b       	sbc	r19, r25
     a50:	00 93 29 06 	sts	0x0629, r16
     a54:	10 93 2a 06 	sts	0x062A, r17
     a58:	20 93 2b 06 	sts	0x062B, r18
     a5c:	30 93 2c 06 	sts	0x062C, r19
     a60:	61 c1       	rjmp	.+706    	; 0xd24 <UpdateAudioChannel1+0x410>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     a62:	80 91 29 06 	lds	r24, 0x0629
     a66:	90 91 2a 06 	lds	r25, 0x062A
     a6a:	a0 91 2b 06 	lds	r26, 0x062B
     a6e:	b0 91 2c 06 	lds	r27, 0x062C
     a72:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     a74:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     a76:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     a78:	80 91 29 06 	lds	r24, 0x0629
     a7c:	90 91 2a 06 	lds	r25, 0x062A
     a80:	a0 91 2b 06 	lds	r26, 0x062B
     a84:	b0 91 2c 06 	lds	r27, 0x062C
     a88:	89 2f       	mov	r24, r25
     a8a:	9a 2f       	mov	r25, r26
     a8c:	ab 2f       	mov	r26, r27
     a8e:	bb 27       	eor	r27, r27
     a90:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     a92:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     a94:	14 98       	cbi	0x02, 4	; 2

		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
		PORTC&=~0x07;											// Clear PORTC bits 0-2
     a96:	88 b1       	in	r24, 0x08	; 8
     a98:	88 7f       	andi	r24, 0xF8	; 248
     a9a:	88 b9       	out	0x08, r24	; 8
		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
     a9c:	28 b1       	in	r18, 0x08	; 8
     a9e:	80 91 29 06 	lds	r24, 0x0629
     aa2:	90 91 2a 06 	lds	r25, 0x062A
     aa6:	a0 91 2b 06 	lds	r26, 0x062B
     aaa:	b0 91 2c 06 	lds	r27, 0x062C
     aae:	8a 2f       	mov	r24, r26
     ab0:	87 70       	andi	r24, 0x07	; 7
     ab2:	82 2b       	or	r24, r18
     ab4:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     ab6:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     ab8:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     aba:	80 91 10 06 	lds	r24, 0x0610
     abe:	88 23       	and	r24, r24
     ac0:	09 f4       	brne	.+2      	; 0xac4 <UpdateAudioChannel1+0x1b0>
     ac2:	5e c1       	rjmp	.+700    	; 0xd80 <UpdateAudioChannel1+0x46c>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     ac4:	80 91 31 04 	lds	r24, 0x0431
     ac8:	90 91 32 04 	lds	r25, 0x0432
     acc:	a0 91 33 04 	lds	r26, 0x0433
     ad0:	b0 91 34 04 	lds	r27, 0x0434
     ad4:	89 2b       	or	r24, r25
     ad6:	8a 2b       	or	r24, r26
     ad8:	8b 2b       	or	r24, r27
     ada:	09 f0       	breq	.+2      	; 0xade <UpdateAudioChannel1+0x1ca>
     adc:	03 c2       	rjmp	.+1030   	; 0xee4 <UpdateAudioChannel1+0x5d0>
				bankStates[BANK_1].currentAddress--;
				sliceRemaining[BANK_1]--;
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     ade:	80 91 39 04 	lds	r24, 0x0439
     ae2:	90 91 3a 04 	lds	r25, 0x043A
     ae6:	a0 91 3b 04 	lds	r26, 0x043B
     aea:	b0 91 3c 04 	lds	r27, 0x043C
     aee:	80 93 31 04 	sts	0x0431, r24
     af2:	90 93 32 04 	sts	0x0432, r25
     af6:	a0 93 33 04 	sts	0x0433, r26
     afa:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     afe:	80 91 3e 04 	lds	r24, 0x043E
     b02:	8f 5f       	subi	r24, 0xFF	; 255
     b04:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     b08:	90 91 3e 04 	lds	r25, 0x043E
     b0c:	80 91 10 06 	lds	r24, 0x0610
     b10:	98 17       	cp	r25, r24
     b12:	09 f4       	brne	.+2      	; 0xb16 <UpdateAudioChannel1+0x202>
     b14:	a3 c2       	rjmp	.+1350   	; 0x105c <UpdateAudioChannel1+0x748>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     b16:	e0 91 3e 04 	lds	r30, 0x043E
     b1a:	20 91 39 04 	lds	r18, 0x0439
     b1e:	30 91 3a 04 	lds	r19, 0x043A
     b22:	40 91 3b 04 	lds	r20, 0x043B
     b26:	50 91 3c 04 	lds	r21, 0x043C
     b2a:	f0 e0       	ldi	r31, 0x00	; 0
     b2c:	ec 53       	subi	r30, 0x3C	; 60
     b2e:	fb 4f       	sbci	r31, 0xFB	; 251
     b30:	a0 81       	ld	r26, Z
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
     b38:	0f ef       	ldi	r16, 0xFF	; 255
     b3a:	1f ef       	ldi	r17, 0xFF	; 255
     b3c:	27 e0       	ldi	r18, 0x07	; 7
     b3e:	30 e0       	ldi	r19, 0x00	; 0
     b40:	06 1b       	sub	r16, r22
     b42:	17 0b       	sbc	r17, r23
     b44:	28 0b       	sbc	r18, r24
     b46:	39 0b       	sbc	r19, r25
     b48:	00 93 29 06 	sts	0x0629, r16
     b4c:	10 93 2a 06 	sts	0x062A, r17
     b50:	20 93 2b 06 	sts	0x062B, r18
     b54:	30 93 2c 06 	sts	0x062C, r19
     b58:	6d c1       	rjmp	.+730    	; 0xe34 <UpdateAudioChannel1+0x520>
	switch(bankStates[BANK_1].audioFunction)
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     b5a:	80 91 46 05 	lds	r24, 0x0546
     b5e:	98 2f       	mov	r25, r24
     b60:	9f 5f       	subi	r25, 0xFF	; 255
     b62:	90 93 46 05 	sts	0x0546, r25
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     b66:	1f 91       	pop	r17
     b68:	0f 91       	pop	r16
     b6a:	08 95       	ret
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     b6c:	8f ef       	ldi	r24, 0xFF	; 255
     b6e:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     b70:	80 91 29 06 	lds	r24, 0x0629
     b74:	90 91 2a 06 	lds	r25, 0x062A
     b78:	a0 91 2b 06 	lds	r26, 0x062B
     b7c:	b0 91 2c 06 	lds	r27, 0x062C
     b80:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     b82:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     b84:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     b86:	80 91 29 06 	lds	r24, 0x0629
     b8a:	90 91 2a 06 	lds	r25, 0x062A
     b8e:	a0 91 2b 06 	lds	r26, 0x062B
     b92:	b0 91 2c 06 	lds	r27, 0x062C
     b96:	89 2f       	mov	r24, r25
     b98:	9a 2f       	mov	r25, r26
     b9a:	ab 2f       	mov	r26, r27
     b9c:	bb 27       	eor	r27, r27
     b9e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     ba0:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     ba2:	14 98       	cbi	0x02, 4	; 2

		//PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.

		// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
		PORTC&=~0x07;											// Clear PORTC bits 0-2
     ba4:	88 b1       	in	r24, 0x08	; 8
     ba6:	88 7f       	andi	r24, 0xF8	; 248
     ba8:	88 b9       	out	0x08, r24	; 8
		PORTC|=((bankStates[BANK_1].currentAddress>>16)&0x07);	// Set high addy bits on PORTC0-2
     baa:	28 b1       	in	r18, 0x08	; 8
     bac:	80 91 29 06 	lds	r24, 0x0629
     bb0:	90 91 2a 06 	lds	r25, 0x062A
     bb4:	a0 91 2b 06 	lds	r26, 0x062B
     bb8:	b0 91 2c 06 	lds	r27, 0x062C
     bbc:	8a 2f       	mov	r24, r26
     bbe:	87 70       	andi	r24, 0x07	; 7
     bc0:	82 2b       	or	r24, r18
     bc2:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     bc4:	80 91 2c 04 	lds	r24, 0x042C
     bc8:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     bca:	80 91 29 06 	lds	r24, 0x0629
     bce:	90 91 2a 06 	lds	r25, 0x062A
     bd2:	a0 91 2b 06 	lds	r26, 0x062B
     bd6:	b0 91 2c 06 	lds	r27, 0x062C
     bda:	01 97       	sbiw	r24, 0x01	; 1
     bdc:	a1 09       	sbc	r26, r1
     bde:	b1 09       	sbc	r27, r1
     be0:	80 93 29 06 	sts	0x0629, r24
     be4:	90 93 2a 06 	sts	0x062A, r25
     be8:	a0 93 2b 06 	sts	0x062B, r26
     bec:	b0 93 2c 06 	sts	0x062C, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     bf0:	80 91 29 06 	lds	r24, 0x0629
     bf4:	90 91 2a 06 	lds	r25, 0x062A
     bf8:	a0 91 2b 06 	lds	r26, 0x062B
     bfc:	b0 91 2c 06 	lds	r27, 0x062C
     c00:	80 93 16 06 	sts	0x0616, r24
     c04:	90 93 17 06 	sts	0x0617, r25
     c08:	a0 93 18 06 	sts	0x0618, r26
     c0c:	b0 93 19 06 	sts	0x0619, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     c10:	80 91 29 06 	lds	r24, 0x0629
     c14:	90 91 2a 06 	lds	r25, 0x062A
     c18:	a0 91 2b 06 	lds	r26, 0x062B
     c1c:	b0 91 2c 06 	lds	r27, 0x062C
     c20:	80 93 1e 06 	sts	0x061E, r24
     c24:	90 93 1f 06 	sts	0x061F, r25
     c28:	a0 93 20 06 	sts	0x0620, r26
     c2c:	b0 93 21 06 	sts	0x0621, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     c30:	40 91 f2 05 	lds	r20, 0x05F2
     c34:	50 91 f3 05 	lds	r21, 0x05F3
     c38:	60 91 f4 05 	lds	r22, 0x05F4
     c3c:	70 91 f5 05 	lds	r23, 0x05F5
     c40:	80 91 16 06 	lds	r24, 0x0616
     c44:	90 91 17 06 	lds	r25, 0x0617
     c48:	a0 91 18 06 	lds	r26, 0x0618
     c4c:	b0 91 19 06 	lds	r27, 0x0619
     c50:	48 17       	cp	r20, r24
     c52:	59 07       	cpc	r21, r25
     c54:	6a 07       	cpc	r22, r26
     c56:	7b 07       	cpc	r23, r27
     c58:	28 f0       	brcs	.+10     	; 0xc64 <UpdateAudioChannel1+0x350>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     c5a:	10 92 09 06 	sts	0x0609, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     c5e:	81 e0       	ldi	r24, 0x01	; 1
     c60:	80 93 3f 04 	sts	0x043F, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     c64:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     c66:	11 9a       	sbi	0x02, 1	; 2
		break;
     c68:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     c6a:	1f 91       	pop	r17
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     c70:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     c74:	40 91 29 06 	lds	r20, 0x0629
     c78:	50 91 2a 06 	lds	r21, 0x062A
     c7c:	60 91 2b 06 	lds	r22, 0x062B
     c80:	70 91 2c 06 	lds	r23, 0x062C
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     c84:	88 23       	and	r24, r24
     c86:	09 f4       	brne	.+2      	; 0xc8a <UpdateAudioChannel1+0x376>
     c88:	7b c1       	rjmp	.+758    	; 0xf80 <UpdateAudioChannel1+0x66c>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     c8a:	80 91 1e 06 	lds	r24, 0x061E
     c8e:	90 91 1f 06 	lds	r25, 0x061F
     c92:	a0 91 20 06 	lds	r26, 0x0620
     c96:	b0 91 21 06 	lds	r27, 0x0621
     c9a:	48 17       	cp	r20, r24
     c9c:	59 07       	cpc	r21, r25
     c9e:	6a 07       	cpc	r22, r26
     ca0:	7b 07       	cpc	r23, r27
     ca2:	09 f4       	brne	.+2      	; 0xca6 <UpdateAudioChannel1+0x392>
     ca4:	cf c1       	rjmp	.+926    	; 0x1044 <UpdateAudioChannel1+0x730>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     ca6:	40 91 29 06 	lds	r20, 0x0629
     caa:	50 91 2a 06 	lds	r21, 0x062A
     cae:	60 91 2b 06 	lds	r22, 0x062B
     cb2:	70 91 2c 06 	lds	r23, 0x062C
     cb6:	80 91 1e 06 	lds	r24, 0x061E
     cba:	90 91 1f 06 	lds	r25, 0x061F
     cbe:	a0 91 20 06 	lds	r26, 0x0620
     cc2:	b0 91 21 06 	lds	r27, 0x0621
     cc6:	48 17       	cp	r20, r24
     cc8:	59 07       	cpc	r21, r25
     cca:	6a 07       	cpc	r22, r26
     ccc:	7b 07       	cpc	r23, r27
     cce:	09 f4       	brne	.+2      	; 0xcd2 <UpdateAudioChannel1+0x3be>
     cd0:	dc c1       	rjmp	.+952    	; 0x108a <UpdateAudioChannel1+0x776>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     cd2:	40 91 29 06 	lds	r20, 0x0629
     cd6:	50 91 2a 06 	lds	r21, 0x062A
     cda:	60 91 2b 06 	lds	r22, 0x062B
     cde:	70 91 2c 06 	lds	r23, 0x062C
     ce2:	80 91 16 06 	lds	r24, 0x0616
     ce6:	90 91 17 06 	lds	r25, 0x0617
     cea:	a0 91 18 06 	lds	r26, 0x0618
     cee:	b0 91 19 06 	lds	r27, 0x0619
     cf2:	48 17       	cp	r20, r24
     cf4:	59 07       	cpc	r21, r25
     cf6:	6a 07       	cpc	r22, r26
     cf8:	7b 07       	cpc	r23, r27
     cfa:	09 f4       	brne	.+2      	; 0xcfe <UpdateAudioChannel1+0x3ea>
     cfc:	2c c2       	rjmp	.+1112   	; 0x1156 <__stack+0x57>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     cfe:	80 91 29 06 	lds	r24, 0x0629
     d02:	90 91 2a 06 	lds	r25, 0x062A
     d06:	a0 91 2b 06 	lds	r26, 0x062B
     d0a:	b0 91 2c 06 	lds	r27, 0x062C
     d0e:	01 97       	sbiw	r24, 0x01	; 1
     d10:	a1 09       	sbc	r26, r1
     d12:	b1 09       	sbc	r27, r1
     d14:	80 93 29 06 	sts	0x0629, r24
     d18:	90 93 2a 06 	sts	0x062A, r25
     d1c:	a0 93 2b 06 	sts	0x062B, r26
     d20:	b0 93 2c 06 	sts	0x062C, r27
			}
		}

		// Finished with addy stuff, now finish data transfer

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     d24:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     d26:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     d28:	9f ef       	ldi	r25, 0xFF	; 255
     d2a:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     d2c:	90 91 12 06 	lds	r25, 0x0612
     d30:	99 23       	and	r25, r25
     d32:	61 f0       	breq	.+24     	; 0xd4c <UpdateAudioChannel1+0x438>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     d34:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     d36:	90 91 12 06 	lds	r25, 0x0612
     d3a:	2f ef       	ldi	r18, 0xFF	; 255
     d3c:	30 e0       	ldi	r19, 0x00	; 0
     d3e:	09 2e       	mov	r0, r25
     d40:	01 c0       	rjmp	.+2      	; 0xd44 <UpdateAudioChannel1+0x430>
     d42:	22 0f       	add	r18, r18
     d44:	0a 94       	dec	r0
     d46:	ea f7       	brpl	.-6      	; 0xd42 <UpdateAudioChannel1+0x42e>
     d48:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     d4a:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     d4c:	20 91 2c 04 	lds	r18, 0x042C
     d50:	33 27       	eor	r19, r19
     d52:	27 fd       	sbrc	r18, 7
     d54:	30 95       	com	r19
     d56:	28 0f       	add	r18, r24
     d58:	31 1d       	adc	r19, r1
     d5a:	87 fd       	sbrc	r24, 7
     d5c:	3a 95       	dec	r19
     d5e:	20 38       	cpi	r18, 0x80	; 128
     d60:	9f ef       	ldi	r25, 0xFF	; 255
     d62:	39 07       	cpc	r19, r25
     d64:	14 f4       	brge	.+4      	; 0xd6a <UpdateAudioChannel1+0x456>
     d66:	20 e8       	ldi	r18, 0x80	; 128
     d68:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     d6a:	20 38       	cpi	r18, 0x80	; 128
     d6c:	31 05       	cpc	r19, r1
     d6e:	14 f0       	brlt	.+4      	; 0xd74 <UpdateAudioChannel1+0x460>
     d70:	2f e7       	ldi	r18, 0x7F	; 127
     d72:	30 e0       	ldi	r19, 0x00	; 0
     d74:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     d76:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     d78:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	08 95       	ret
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     d80:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     d84:	40 91 29 06 	lds	r20, 0x0629
     d88:	50 91 2a 06 	lds	r21, 0x062A
     d8c:	60 91 2b 06 	lds	r22, 0x062B
     d90:	70 91 2c 06 	lds	r23, 0x062C
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     d94:	88 23       	and	r24, r24
     d96:	09 f4       	brne	.+2      	; 0xd9a <UpdateAudioChannel1+0x486>
     d98:	57 c0       	rjmp	.+174    	; 0xe48 <UpdateAudioChannel1+0x534>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     d9a:	80 91 1e 06 	lds	r24, 0x061E
     d9e:	90 91 1f 06 	lds	r25, 0x061F
     da2:	a0 91 20 06 	lds	r26, 0x0620
     da6:	b0 91 21 06 	lds	r27, 0x0621
     daa:	48 17       	cp	r20, r24
     dac:	59 07       	cpc	r21, r25
     dae:	6a 07       	cpc	r22, r26
     db0:	7b 07       	cpc	r23, r27
     db2:	09 f4       	brne	.+2      	; 0xdb6 <UpdateAudioChannel1+0x4a2>
     db4:	4d c1       	rjmp	.+666    	; 0x1050 <UpdateAudioChannel1+0x73c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     db6:	40 91 29 06 	lds	r20, 0x0629
     dba:	50 91 2a 06 	lds	r21, 0x062A
     dbe:	60 91 2b 06 	lds	r22, 0x062B
     dc2:	70 91 2c 06 	lds	r23, 0x062C
     dc6:	80 91 1e 06 	lds	r24, 0x061E
     dca:	90 91 1f 06 	lds	r25, 0x061F
     dce:	a0 91 20 06 	lds	r26, 0x0620
     dd2:	b0 91 21 06 	lds	r27, 0x0621
     dd6:	48 17       	cp	r20, r24
     dd8:	59 07       	cpc	r21, r25
     dda:	6a 07       	cpc	r22, r26
     ddc:	7b 07       	cpc	r23, r27
     dde:	09 f4       	brne	.+2      	; 0xde2 <UpdateAudioChannel1+0x4ce>
     de0:	43 c1       	rjmp	.+646    	; 0x1068 <UpdateAudioChannel1+0x754>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     de2:	40 91 29 06 	lds	r20, 0x0629
     de6:	50 91 2a 06 	lds	r21, 0x062A
     dea:	60 91 2b 06 	lds	r22, 0x062B
     dee:	70 91 2c 06 	lds	r23, 0x062C
     df2:	80 91 16 06 	lds	r24, 0x0616
     df6:	90 91 17 06 	lds	r25, 0x0617
     dfa:	a0 91 18 06 	lds	r26, 0x0618
     dfe:	b0 91 19 06 	lds	r27, 0x0619
     e02:	48 17       	cp	r20, r24
     e04:	59 07       	cpc	r21, r25
     e06:	6a 07       	cpc	r22, r26
     e08:	7b 07       	cpc	r23, r27
     e0a:	09 f4       	brne	.+2      	; 0xe0e <UpdateAudioChannel1+0x4fa>
     e0c:	93 c1       	rjmp	.+806    	; 0x1134 <__stack+0x35>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     e0e:	80 91 29 06 	lds	r24, 0x0629
     e12:	90 91 2a 06 	lds	r25, 0x062A
     e16:	a0 91 2b 06 	lds	r26, 0x062B
     e1a:	b0 91 2c 06 	lds	r27, 0x062C
     e1e:	01 97       	sbiw	r24, 0x01	; 1
     e20:	a1 09       	sbc	r26, r1
     e22:	b1 09       	sbc	r27, r1
     e24:	80 93 29 06 	sts	0x0629, r24
     e28:	90 93 2a 06 	sts	0x062A, r25
     e2c:	a0 93 2b 06 	sts	0x062B, r26
     e30:	b0 93 2c 06 	sts	0x062C, r27
			}
		}

		// Done with addy, read RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     e34:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     e36:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     e38:	9f ef       	ldi	r25, 0xFF	; 255
     e3a:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     e3c:	90 91 12 06 	lds	r25, 0x0612
     e40:	99 23       	and	r25, r25
     e42:	09 f4       	brne	.+2      	; 0xe46 <UpdateAudioChannel1+0x532>
     e44:	75 cd       	rjmp	.-1302   	; 0x930 <UpdateAudioChannel1+0x1c>
     e46:	82 cd       	rjmp	.-1276   	; 0x94c <UpdateAudioChannel1+0x38>
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     e48:	80 91 22 06 	lds	r24, 0x0622
     e4c:	90 91 23 06 	lds	r25, 0x0623
     e50:	a0 91 24 06 	lds	r26, 0x0624
     e54:	b0 91 25 06 	lds	r27, 0x0625
     e58:	48 17       	cp	r20, r24
     e5a:	59 07       	cpc	r21, r25
     e5c:	6a 07       	cpc	r22, r26
     e5e:	7b 07       	cpc	r23, r27
     e60:	09 f4       	brne	.+2      	; 0xe64 <UpdateAudioChannel1+0x550>
     e62:	dc c0       	rjmp	.+440    	; 0x101c <UpdateAudioChannel1+0x708>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e64:	40 91 29 06 	lds	r20, 0x0629
     e68:	50 91 2a 06 	lds	r21, 0x062A
     e6c:	60 91 2b 06 	lds	r22, 0x062B
     e70:	70 91 2c 06 	lds	r23, 0x062C
     e74:	80 91 22 06 	lds	r24, 0x0622
     e78:	90 91 23 06 	lds	r25, 0x0623
     e7c:	a0 91 24 06 	lds	r26, 0x0624
     e80:	b0 91 25 06 	lds	r27, 0x0625
     e84:	48 17       	cp	r20, r24
     e86:	59 07       	cpc	r21, r25
     e88:	6a 07       	cpc	r22, r26
     e8a:	7b 07       	cpc	r23, r27
     e8c:	09 f4       	brne	.+2      	; 0xe90 <UpdateAudioChannel1+0x57c>
     e8e:	1f c1       	rjmp	.+574    	; 0x10ce <UpdateAudioChannel1+0x7ba>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e90:	40 91 29 06 	lds	r20, 0x0629
     e94:	50 91 2a 06 	lds	r21, 0x062A
     e98:	60 91 2b 06 	lds	r22, 0x062B
     e9c:	70 91 2c 06 	lds	r23, 0x062C
     ea0:	80 91 1a 06 	lds	r24, 0x061A
     ea4:	90 91 1b 06 	lds	r25, 0x061B
     ea8:	a0 91 1c 06 	lds	r26, 0x061C
     eac:	b0 91 1d 06 	lds	r27, 0x061D
     eb0:	48 17       	cp	r20, r24
     eb2:	59 07       	cpc	r21, r25
     eb4:	6a 07       	cpc	r22, r26
     eb6:	7b 07       	cpc	r23, r27
     eb8:	09 f4       	brne	.+2      	; 0xebc <UpdateAudioChannel1+0x5a8>
     eba:	1a c1       	rjmp	.+564    	; 0x10f0 <UpdateAudioChannel1+0x7dc>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ebc:	80 91 29 06 	lds	r24, 0x0629
     ec0:	90 91 2a 06 	lds	r25, 0x062A
     ec4:	a0 91 2b 06 	lds	r26, 0x062B
     ec8:	b0 91 2c 06 	lds	r27, 0x062C
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	80 93 29 06 	sts	0x0629, r24
     ed6:	90 93 2a 06 	sts	0x062A, r25
     eda:	a0 93 2b 06 	sts	0x062B, r26
     ede:	b0 93 2c 06 	sts	0x062C, r27
     ee2:	a8 cf       	rjmp	.-176    	; 0xe34 <UpdateAudioChannel1+0x520>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
			{
				bankStates[BANK_1].currentAddress--;
     ee4:	80 91 29 06 	lds	r24, 0x0629
     ee8:	90 91 2a 06 	lds	r25, 0x062A
     eec:	a0 91 2b 06 	lds	r26, 0x062B
     ef0:	b0 91 2c 06 	lds	r27, 0x062C
     ef4:	01 97       	sbiw	r24, 0x01	; 1
     ef6:	a1 09       	sbc	r26, r1
     ef8:	b1 09       	sbc	r27, r1
     efa:	80 93 29 06 	sts	0x0629, r24
     efe:	90 93 2a 06 	sts	0x062A, r25
     f02:	a0 93 2b 06 	sts	0x062B, r26
     f06:	b0 93 2c 06 	sts	0x062C, r27
				sliceRemaining[BANK_1]--;
     f0a:	80 91 31 04 	lds	r24, 0x0431
     f0e:	90 91 32 04 	lds	r25, 0x0432
     f12:	a0 91 33 04 	lds	r26, 0x0433
     f16:	b0 91 34 04 	lds	r27, 0x0434
     f1a:	01 97       	sbiw	r24, 0x01	; 1
     f1c:	a1 09       	sbc	r26, r1
     f1e:	b1 09       	sbc	r27, r1
     f20:	80 93 31 04 	sts	0x0431, r24
     f24:	90 93 32 04 	sts	0x0432, r25
     f28:	a0 93 33 04 	sts	0x0433, r26
     f2c:	b0 93 34 04 	sts	0x0434, r27
     f30:	81 cf       	rjmp	.-254    	; 0xe34 <UpdateAudioChannel1+0x520>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
			{
				bankStates[BANK_1].currentAddress--;
     f32:	80 91 29 06 	lds	r24, 0x0629
     f36:	90 91 2a 06 	lds	r25, 0x062A
     f3a:	a0 91 2b 06 	lds	r26, 0x062B
     f3e:	b0 91 2c 06 	lds	r27, 0x062C
     f42:	01 97       	sbiw	r24, 0x01	; 1
     f44:	a1 09       	sbc	r26, r1
     f46:	b1 09       	sbc	r27, r1
     f48:	80 93 29 06 	sts	0x0629, r24
     f4c:	90 93 2a 06 	sts	0x062A, r25
     f50:	a0 93 2b 06 	sts	0x062B, r26
     f54:	b0 93 2c 06 	sts	0x062C, r27
				sliceRemaining[BANK_1]--;
     f58:	80 91 31 04 	lds	r24, 0x0431
     f5c:	90 91 32 04 	lds	r25, 0x0432
     f60:	a0 91 33 04 	lds	r26, 0x0433
     f64:	b0 91 34 04 	lds	r27, 0x0434
     f68:	01 97       	sbiw	r24, 0x01	; 1
     f6a:	a1 09       	sbc	r26, r1
     f6c:	b1 09       	sbc	r27, r1
     f6e:	80 93 31 04 	sts	0x0431, r24
     f72:	90 93 32 04 	sts	0x0432, r25
     f76:	a0 93 33 04 	sts	0x0433, r26
     f7a:	b0 93 34 04 	sts	0x0434, r27
     f7e:	d2 ce       	rjmp	.-604    	; 0xd24 <UpdateAudioChannel1+0x410>
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     f80:	80 91 22 06 	lds	r24, 0x0622
     f84:	90 91 23 06 	lds	r25, 0x0623
     f88:	a0 91 24 06 	lds	r26, 0x0624
     f8c:	b0 91 25 06 	lds	r27, 0x0625
     f90:	48 17       	cp	r20, r24
     f92:	59 07       	cpc	r21, r25
     f94:	6a 07       	cpc	r22, r26
     f96:	7b 07       	cpc	r23, r27
     f98:	09 f4       	brne	.+2      	; 0xf9c <UpdateAudioChannel1+0x688>
     f9a:	4a c0       	rjmp	.+148    	; 0x1030 <UpdateAudioChannel1+0x71c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     f9c:	40 91 29 06 	lds	r20, 0x0629
     fa0:	50 91 2a 06 	lds	r21, 0x062A
     fa4:	60 91 2b 06 	lds	r22, 0x062B
     fa8:	70 91 2c 06 	lds	r23, 0x062C
     fac:	80 91 22 06 	lds	r24, 0x0622
     fb0:	90 91 23 06 	lds	r25, 0x0623
     fb4:	a0 91 24 06 	lds	r26, 0x0624
     fb8:	b0 91 25 06 	lds	r27, 0x0625
     fbc:	48 17       	cp	r20, r24
     fbe:	59 07       	cpc	r21, r25
     fc0:	6a 07       	cpc	r22, r26
     fc2:	7b 07       	cpc	r23, r27
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <UpdateAudioChannel1+0x6b4>
     fc6:	72 c0       	rjmp	.+228    	; 0x10ac <UpdateAudioChannel1+0x798>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     fc8:	40 91 29 06 	lds	r20, 0x0629
     fcc:	50 91 2a 06 	lds	r21, 0x062A
     fd0:	60 91 2b 06 	lds	r22, 0x062B
     fd4:	70 91 2c 06 	lds	r23, 0x062C
     fd8:	80 91 1a 06 	lds	r24, 0x061A
     fdc:	90 91 1b 06 	lds	r25, 0x061B
     fe0:	a0 91 1c 06 	lds	r26, 0x061C
     fe4:	b0 91 1d 06 	lds	r27, 0x061D
     fe8:	48 17       	cp	r20, r24
     fea:	59 07       	cpc	r21, r25
     fec:	6a 07       	cpc	r22, r26
     fee:	7b 07       	cpc	r23, r27
     ff0:	09 f4       	brne	.+2      	; 0xff4 <UpdateAudioChannel1+0x6e0>
     ff2:	8f c0       	rjmp	.+286    	; 0x1112 <__stack+0x13>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ff4:	80 91 29 06 	lds	r24, 0x0629
     ff8:	90 91 2a 06 	lds	r25, 0x062A
     ffc:	a0 91 2b 06 	lds	r26, 0x062B
    1000:	b0 91 2c 06 	lds	r27, 0x062C
    1004:	01 96       	adiw	r24, 0x01	; 1
    1006:	a1 1d       	adc	r26, r1
    1008:	b1 1d       	adc	r27, r1
    100a:	80 93 29 06 	sts	0x0629, r24
    100e:	90 93 2a 06 	sts	0x062A, r25
    1012:	a0 93 2b 06 	sts	0x062B, r26
    1016:	b0 93 2c 06 	sts	0x062C, r27
    101a:	84 ce       	rjmp	.-760    	; 0xd24 <UpdateAudioChannel1+0x410>
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    101c:	80 91 0a 06 	lds	r24, 0x060A
    1020:	81 30       	cpi	r24, 0x01	; 1
    1022:	09 f0       	breq	.+2      	; 0x1026 <UpdateAudioChannel1+0x712>
    1024:	1f cf       	rjmp	.-450    	; 0xe64 <UpdateAudioChannel1+0x550>
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    1026:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
    102a:	10 92 13 06 	sts	0x0613, r1
    102e:	02 cf       	rjmp	.-508    	; 0xe34 <UpdateAudioChannel1+0x520>
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
    1030:	80 91 0a 06 	lds	r24, 0x060A
    1034:	81 30       	cpi	r24, 0x01	; 1
    1036:	09 f0       	breq	.+2      	; 0x103a <UpdateAudioChannel1+0x726>
    1038:	b1 cf       	rjmp	.-158    	; 0xf9c <UpdateAudioChannel1+0x688>
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    103a:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
    103e:	10 92 13 06 	sts	0x0613, r1
    1042:	70 ce       	rjmp	.-800    	; 0xd24 <UpdateAudioChannel1+0x410>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
    1044:	80 91 0a 06 	lds	r24, 0x060A
    1048:	81 30       	cpi	r24, 0x01	; 1
    104a:	09 f0       	breq	.+2      	; 0x104e <UpdateAudioChannel1+0x73a>
    104c:	2c ce       	rjmp	.-936    	; 0xca6 <UpdateAudioChannel1+0x392>
    104e:	f5 cf       	rjmp	.-22     	; 0x103a <UpdateAudioChannel1+0x726>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
    1050:	80 91 0a 06 	lds	r24, 0x060A
    1054:	81 30       	cpi	r24, 0x01	; 1
    1056:	09 f0       	breq	.+2      	; 0x105a <UpdateAudioChannel1+0x746>
    1058:	ae ce       	rjmp	.-676    	; 0xdb6 <UpdateAudioChannel1+0x4a2>
    105a:	e5 cf       	rjmp	.-54     	; 0x1026 <UpdateAudioChannel1+0x712>
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
    105c:	10 92 3e 04 	sts	0x043E, r1
    1060:	5a cd       	rjmp	.-1356   	; 0xb16 <UpdateAudioChannel1+0x202>
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
    1062:	10 92 3e 04 	sts	0x043E, r1
    1066:	db cc       	rjmp	.-1610   	; 0xa1e <UpdateAudioChannel1+0x10a>
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
    1068:	80 91 22 06 	lds	r24, 0x0622
    106c:	90 91 23 06 	lds	r25, 0x0623
    1070:	a0 91 24 06 	lds	r26, 0x0624
    1074:	b0 91 25 06 	lds	r27, 0x0625
    1078:	80 93 29 06 	sts	0x0629, r24
    107c:	90 93 2a 06 	sts	0x062A, r25
    1080:	a0 93 2b 06 	sts	0x062B, r26
    1084:	b0 93 2c 06 	sts	0x062C, r27
    1088:	d5 ce       	rjmp	.-598    	; 0xe34 <UpdateAudioChannel1+0x520>
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
    108a:	80 91 22 06 	lds	r24, 0x0622
    108e:	90 91 23 06 	lds	r25, 0x0623
    1092:	a0 91 24 06 	lds	r26, 0x0624
    1096:	b0 91 25 06 	lds	r27, 0x0625
    109a:	80 93 29 06 	sts	0x0629, r24
    109e:	90 93 2a 06 	sts	0x062A, r25
    10a2:	a0 93 2b 06 	sts	0x062B, r26
    10a6:	b0 93 2c 06 	sts	0x062C, r27
    10aa:	3c ce       	rjmp	.-904    	; 0xd24 <UpdateAudioChannel1+0x410>
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
    10ac:	80 91 1e 06 	lds	r24, 0x061E
    10b0:	90 91 1f 06 	lds	r25, 0x061F
    10b4:	a0 91 20 06 	lds	r26, 0x0620
    10b8:	b0 91 21 06 	lds	r27, 0x0621
    10bc:	80 93 29 06 	sts	0x0629, r24
    10c0:	90 93 2a 06 	sts	0x062A, r25
    10c4:	a0 93 2b 06 	sts	0x062B, r26
    10c8:	b0 93 2c 06 	sts	0x062C, r27
    10cc:	2b ce       	rjmp	.-938    	; 0xd24 <UpdateAudioChannel1+0x410>
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
    10ce:	80 91 1e 06 	lds	r24, 0x061E
    10d2:	90 91 1f 06 	lds	r25, 0x061F
    10d6:	a0 91 20 06 	lds	r26, 0x0620
    10da:	b0 91 21 06 	lds	r27, 0x0621
    10de:	80 93 29 06 	sts	0x0629, r24
    10e2:	90 93 2a 06 	sts	0x062A, r25
    10e6:	a0 93 2b 06 	sts	0x062B, r26
    10ea:	b0 93 2c 06 	sts	0x062C, r27
    10ee:	a2 ce       	rjmp	.-700    	; 0xe34 <UpdateAudioChannel1+0x520>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
    10f0:	80 91 16 06 	lds	r24, 0x0616
    10f4:	90 91 17 06 	lds	r25, 0x0617
    10f8:	a0 91 18 06 	lds	r26, 0x0618
    10fc:	b0 91 19 06 	lds	r27, 0x0619
    1100:	80 93 29 06 	sts	0x0629, r24
    1104:	90 93 2a 06 	sts	0x062A, r25
    1108:	a0 93 2b 06 	sts	0x062B, r26
    110c:	b0 93 2c 06 	sts	0x062C, r27
    1110:	91 ce       	rjmp	.-734    	; 0xe34 <UpdateAudioChannel1+0x520>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
    1112:	80 91 16 06 	lds	r24, 0x0616
    1116:	90 91 17 06 	lds	r25, 0x0617
    111a:	a0 91 18 06 	lds	r26, 0x0618
    111e:	b0 91 19 06 	lds	r27, 0x0619
    1122:	80 93 29 06 	sts	0x0629, r24
    1126:	90 93 2a 06 	sts	0x062A, r25
    112a:	a0 93 2b 06 	sts	0x062B, r26
    112e:	b0 93 2c 06 	sts	0x062C, r27
    1132:	f8 cd       	rjmp	.-1040   	; 0xd24 <UpdateAudioChannel1+0x410>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
    1134:	80 91 1a 06 	lds	r24, 0x061A
    1138:	90 91 1b 06 	lds	r25, 0x061B
    113c:	a0 91 1c 06 	lds	r26, 0x061C
    1140:	b0 91 1d 06 	lds	r27, 0x061D
    1144:	80 93 29 06 	sts	0x0629, r24
    1148:	90 93 2a 06 	sts	0x062A, r25
    114c:	a0 93 2b 06 	sts	0x062B, r26
    1150:	b0 93 2c 06 	sts	0x062C, r27
    1154:	6f ce       	rjmp	.-802    	; 0xe34 <UpdateAudioChannel1+0x520>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
    1156:	80 91 1a 06 	lds	r24, 0x061A
    115a:	90 91 1b 06 	lds	r25, 0x061B
    115e:	a0 91 1c 06 	lds	r26, 0x061C
    1162:	b0 91 1d 06 	lds	r27, 0x061D
    1166:	80 93 29 06 	sts	0x0629, r24
    116a:	90 93 2a 06 	sts	0x062A, r25
    116e:	a0 93 2b 06 	sts	0x062B, r26
    1172:	b0 93 2c 06 	sts	0x062C, r27
    1176:	d6 cd       	rjmp	.-1108   	; 0xd24 <UpdateAudioChannel1+0x410>

00001178 <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1178:	80 91 42 04 	lds	r24, 0x0442
    117c:	20 91 48 05 	lds	r18, 0x0548
    1180:	33 27       	eor	r19, r19
    1182:	27 fd       	sbrc	r18, 7
    1184:	30 95       	com	r19
    1186:	28 0f       	add	r18, r24
    1188:	31 1d       	adc	r19, r1
    118a:	87 fd       	sbrc	r24, 7
    118c:	3a 95       	dec	r19
    118e:	20 38       	cpi	r18, 0x80	; 128
    1190:	4f ef       	ldi	r20, 0xFF	; 255
    1192:	34 07       	cpc	r19, r20
    1194:	14 f4       	brge	.+4      	; 0x119a <OutputMultiplyBanks+0x22>
    1196:	20 e8       	ldi	r18, 0x80	; 128
    1198:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    119a:	40 91 45 05 	lds	r20, 0x0545
    119e:	80 91 4c 05 	lds	r24, 0x054C
    11a2:	99 27       	eor	r25, r25
    11a4:	87 fd       	sbrc	r24, 7
    11a6:	90 95       	com	r25
    11a8:	84 0f       	add	r24, r20
    11aa:	91 1d       	adc	r25, r1
    11ac:	47 fd       	sbrc	r20, 7
    11ae:	9a 95       	dec	r25
    11b0:	81 38       	cpi	r24, 0x81	; 129
    11b2:	4f ef       	ldi	r20, 0xFF	; 255
    11b4:	94 07       	cpc	r25, r20
    11b6:	14 f4       	brge	.+4      	; 0x11bc <OutputMultiplyBanks+0x44>
    11b8:	81 e8       	ldi	r24, 0x81	; 129
    11ba:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    11bc:	20 38       	cpi	r18, 0x80	; 128
    11be:	31 05       	cpc	r19, r1
    11c0:	14 f0       	brlt	.+4      	; 0x11c6 <OutputMultiplyBanks+0x4e>
    11c2:	2f e7       	ldi	r18, 0x7F	; 127
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	80 38       	cpi	r24, 0x80	; 128
    11c8:	91 05       	cpc	r25, r1
    11ca:	14 f0       	brlt	.+4      	; 0x11d0 <OutputMultiplyBanks+0x58>
    11cc:	8f e7       	ldi	r24, 0x7F	; 127
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	28 9f       	mul	r18, r24
    11d2:	a0 01       	movw	r20, r0
    11d4:	29 9f       	mul	r18, r25
    11d6:	50 0d       	add	r21, r0
    11d8:	38 9f       	mul	r19, r24
    11da:	50 0d       	add	r21, r0
    11dc:	11 24       	eor	r1, r1
    11de:	57 fd       	sbrc	r21, 7
    11e0:	18 c0       	rjmp	.+48     	; 0x1212 <OutputMultiplyBanks+0x9a>
    11e2:	ca 01       	movw	r24, r20
    11e4:	08 2e       	mov	r0, r24
    11e6:	89 2f       	mov	r24, r25
    11e8:	00 0c       	add	r0, r0
    11ea:	88 1f       	adc	r24, r24
    11ec:	99 0b       	sbc	r25, r25
    11ee:	00 0c       	add	r0, r0
    11f0:	88 1f       	adc	r24, r24
    11f2:	99 1f       	adc	r25, r25

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    11f4:	80 58       	subi	r24, 0x80	; 128
    11f6:	90 95       	com	r25
    11f8:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11fa:	30 91 6e 05 	lds	r19, 0x056E
    11fe:	83 17       	cp	r24, r19
    1200:	29 f0       	breq	.+10     	; 0x120c <OutputMultiplyBanks+0x94>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1202:	9f ef       	ldi	r25, 0xFF	; 255
    1204:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1206:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1208:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    120a:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    120c:	20 93 6e 05 	sts	0x056E, r18
    1210:	08 95       	ret
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    1212:	41 5c       	subi	r20, 0xC1	; 193
    1214:	5f 4f       	sbci	r21, 0xFF	; 255
    1216:	e5 cf       	rjmp	.-54     	; 0x11e2 <OutputMultiplyBanks+0x6a>

00001218 <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC

//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
    1218:	20 91 42 04 	lds	r18, 0x0442
    121c:	80 91 45 05 	lds	r24, 0x0545
    1220:	99 27       	eor	r25, r25
    1222:	87 fd       	sbrc	r24, 7
    1224:	90 95       	com	r25
    1226:	82 0f       	add	r24, r18
    1228:	91 1d       	adc	r25, r1
    122a:	27 fd       	sbrc	r18, 7
    122c:	9a 95       	dec	r25
    122e:	20 91 48 05 	lds	r18, 0x0548
    1232:	82 0f       	add	r24, r18
    1234:	91 1d       	adc	r25, r1
    1236:	27 fd       	sbrc	r18, 7
    1238:	9a 95       	dec	r25
    123a:	20 91 4c 05 	lds	r18, 0x054C
    123e:	82 0f       	add	r24, r18
    1240:	91 1d       	adc	r25, r1
    1242:	27 fd       	sbrc	r18, 7
    1244:	9a 95       	dec	r25
    1246:	20 91 55 05 	lds	r18, 0x0555
    124a:	82 0f       	add	r24, r18
    124c:	91 1d       	adc	r25, r1
    124e:	27 fd       	sbrc	r18, 7
    1250:	9a 95       	dec	r25
    1252:	80 38       	cpi	r24, 0x80	; 128
    1254:	2f ef       	ldi	r18, 0xFF	; 255
    1256:	92 07       	cpc	r25, r18
    1258:	14 f4       	brge	.+4      	; 0x125e <OutputAddBanks+0x46>
    125a:	80 e8       	ldi	r24, 0x80	; 128
    125c:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    125e:	80 38       	cpi	r24, 0x80	; 128
    1260:	91 05       	cpc	r25, r1
    1262:	14 f0       	brlt	.+4      	; 0x1268 <OutputAddBanks+0x50>
    1264:	8f e7       	ldi	r24, 0x7F	; 127
    1266:	90 e0       	ldi	r25, 0x00	; 0
    1268:	80 58       	subi	r24, 0x80	; 128
    126a:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    126c:	30 91 6e 05 	lds	r19, 0x056E
    1270:	83 17       	cp	r24, r19
    1272:	29 f0       	breq	.+10     	; 0x127e <OutputAddBanks+0x66>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1274:	9f ef       	ldi	r25, 0xFF	; 255
    1276:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1278:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    127a:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    127c:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    127e:	20 93 6e 05 	sts	0x056E, r18
    1282:	08 95       	ret

00001284 <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1284:	20 91 42 04 	lds	r18, 0x0442
    1288:	80 91 48 05 	lds	r24, 0x0548
    128c:	99 27       	eor	r25, r25
    128e:	87 fd       	sbrc	r24, 7
    1290:	90 95       	com	r25
    1292:	82 0f       	add	r24, r18
    1294:	91 1d       	adc	r25, r1
    1296:	27 fd       	sbrc	r18, 7
    1298:	9a 95       	dec	r25
    129a:	80 38       	cpi	r24, 0x80	; 128
    129c:	2f ef       	ldi	r18, 0xFF	; 255
    129e:	92 07       	cpc	r25, r18
    12a0:	14 f4       	brge	.+4      	; 0x12a6 <OutputXorBanks+0x22>
    12a2:	80 e8       	ldi	r24, 0x80	; 128
    12a4:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    12a6:	40 91 45 05 	lds	r20, 0x0545
    12aa:	20 91 4c 05 	lds	r18, 0x054C
    12ae:	33 27       	eor	r19, r19
    12b0:	27 fd       	sbrc	r18, 7
    12b2:	30 95       	com	r19
    12b4:	24 0f       	add	r18, r20
    12b6:	31 1d       	adc	r19, r1
    12b8:	47 fd       	sbrc	r20, 7
    12ba:	3a 95       	dec	r19
    12bc:	20 38       	cpi	r18, 0x80	; 128
    12be:	4f ef       	ldi	r20, 0xFF	; 255
    12c0:	34 07       	cpc	r19, r20
    12c2:	14 f4       	brge	.+4      	; 0x12c8 <OutputXorBanks+0x44>
    12c4:	20 e8       	ldi	r18, 0x80	; 128
    12c6:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.
    12c8:	20 38       	cpi	r18, 0x80	; 128
    12ca:	31 05       	cpc	r19, r1
    12cc:	14 f0       	brlt	.+4      	; 0x12d2 <OutputXorBanks+0x4e>
    12ce:	2f e7       	ldi	r18, 0x7F	; 127
    12d0:	30 e0       	ldi	r19, 0x00	; 0
    12d2:	20 58       	subi	r18, 0x80	; 128
    12d4:	30 95       	com	r19
    12d6:	80 38       	cpi	r24, 0x80	; 128
    12d8:	91 05       	cpc	r25, r1
    12da:	14 f0       	brlt	.+4      	; 0x12e0 <OutputXorBanks+0x5c>
    12dc:	8f e7       	ldi	r24, 0x7F	; 127
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	80 58       	subi	r24, 0x80	; 128
    12e2:	90 95       	com	r25
    12e4:	82 27       	eor	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    12e6:	90 91 6e 05 	lds	r25, 0x056E
    12ea:	89 17       	cp	r24, r25
    12ec:	29 f0       	breq	.+10     	; 0x12f8 <OutputXorBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    12ee:	9f ef       	ldi	r25, 0xFF	; 255
    12f0:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    12f2:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    12f4:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    12f6:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    12f8:	80 93 6e 05 	sts	0x056E, r24
    12fc:	08 95       	ret

000012fe <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    12fe:	20 91 42 04 	lds	r18, 0x0442
    1302:	80 91 48 05 	lds	r24, 0x0548
    1306:	99 27       	eor	r25, r25
    1308:	87 fd       	sbrc	r24, 7
    130a:	90 95       	com	r25
    130c:	82 0f       	add	r24, r18
    130e:	91 1d       	adc	r25, r1
    1310:	27 fd       	sbrc	r18, 7
    1312:	9a 95       	dec	r25
    1314:	80 38       	cpi	r24, 0x80	; 128
    1316:	2f ef       	ldi	r18, 0xFF	; 255
    1318:	92 07       	cpc	r25, r18
    131a:	14 f4       	brge	.+4      	; 0x1320 <OutputAndBanks+0x22>
    131c:	80 e8       	ldi	r24, 0x80	; 128
    131e:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1320:	40 91 45 05 	lds	r20, 0x0545
    1324:	20 91 4c 05 	lds	r18, 0x054C
    1328:	33 27       	eor	r19, r19
    132a:	27 fd       	sbrc	r18, 7
    132c:	30 95       	com	r19
    132e:	24 0f       	add	r18, r20
    1330:	31 1d       	adc	r19, r1
    1332:	47 fd       	sbrc	r20, 7
    1334:	3a 95       	dec	r19
    1336:	20 38       	cpi	r18, 0x80	; 128
    1338:	4f ef       	ldi	r20, 0xFF	; 255
    133a:	34 07       	cpc	r19, r20
    133c:	14 f4       	brge	.+4      	; 0x1342 <OutputAndBanks+0x44>
    133e:	20 e8       	ldi	r18, 0x80	; 128
    1340:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.
    1342:	20 38       	cpi	r18, 0x80	; 128
    1344:	31 05       	cpc	r19, r1
    1346:	14 f0       	brlt	.+4      	; 0x134c <OutputAndBanks+0x4e>
    1348:	2f e7       	ldi	r18, 0x7F	; 127
    134a:	30 e0       	ldi	r19, 0x00	; 0
    134c:	20 58       	subi	r18, 0x80	; 128
    134e:	30 95       	com	r19
    1350:	80 38       	cpi	r24, 0x80	; 128
    1352:	91 05       	cpc	r25, r1
    1354:	14 f0       	brlt	.+4      	; 0x135a <OutputAndBanks+0x5c>
    1356:	8f e7       	ldi	r24, 0x7F	; 127
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	80 58       	subi	r24, 0x80	; 128
    135c:	90 95       	com	r25
    135e:	82 23       	and	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1360:	90 91 6e 05 	lds	r25, 0x056E
    1364:	89 17       	cp	r24, r25
    1366:	29 f0       	breq	.+10     	; 0x1372 <OutputAndBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1368:	9f ef       	ldi	r25, 0xFF	; 255
    136a:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    136c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    136e:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1370:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1372:	80 93 6e 05 	sts	0x056E, r24
    1376:	08 95       	ret

00001378 <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM.
{
    1378:	2f 92       	push	r2
    137a:	3f 92       	push	r3
    137c:	4f 92       	push	r4
    137e:	5f 92       	push	r5
    1380:	6f 92       	push	r6
    1382:	7f 92       	push	r7
    1384:	8f 92       	push	r8
    1386:	9f 92       	push	r9
    1388:	af 92       	push	r10
    138a:	bf 92       	push	r11
    138c:	cf 92       	push	r12
    138e:	df 92       	push	r13
    1390:	ef 92       	push	r14
    1392:	ff 92       	push	r15
    1394:	0f 93       	push	r16
    1396:	1f 93       	push	r17
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
    13a0:	27 97       	sbiw	r28, 0x07	; 7
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	cd bf       	out	0x3d, r28	; 61
    13ac:	28 2e       	mov	r2, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    13ae:	62 30       	cpi	r22, 0x02	; 2
    13b0:	08 f4       	brcc	.+2      	; 0x13b4 <MakeNewGranularArray+0x3c>
    13b2:	1a c1       	rjmp	.+564    	; 0x15e8 <MakeNewGranularArray+0x270>
	{
		sreg=SREG;
    13b4:	2f b7       	in	r18, 0x3f	; 63
    13b6:	2d 83       	std	Y+5, r18	; 0x05
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    13b8:	f8 94       	cli
    13ba:	06 2f       	mov	r16, r22
    13bc:	61 38       	cpi	r22, 0x81	; 129
    13be:	08 f0       	brcs	.+2      	; 0x13c2 <MakeNewGranularArray+0x4a>
    13c0:	11 c1       	rjmp	.+546    	; 0x15e4 <MakeNewGranularArray+0x26c>
    13c2:	42 2d       	mov	r20, r2
    13c4:	50 e0       	ldi	r21, 0x00	; 0
    13c6:	5c 83       	std	Y+4, r21	; 0x04
    13c8:	4b 83       	std	Y+3, r20	; 0x03
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    13ca:	56 95       	lsr	r21
    13cc:	54 2f       	mov	r21, r20
    13ce:	44 27       	eor	r20, r20
    13d0:	57 95       	ror	r21
    13d2:	47 95       	ror	r20
    13d4:	5a 83       	std	Y+2, r21	; 0x02
    13d6:	49 83       	std	Y+1, r20	; 0x01
    13d8:	9a 01       	movw	r18, r20
    13da:	2c 5b       	subi	r18, 0xBC	; 188
    13dc:	3b 4f       	sbci	r19, 0xFB	; 251
    13de:	f9 01       	movw	r30, r18
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    13e0:	80 e0       	ldi	r24, 0x00	; 0
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    13e2:	81 93       	st	Z+, r24
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    13e4:	8f 5f       	subi	r24, 0xFF	; 255
    13e6:	80 17       	cp	r24, r16
    13e8:	e0 f3       	brcs	.-8      	; 0x13e2 <MakeNewGranularArray+0x6a>
    13ea:	40 2e       	mov	r4, r16
    13ec:	51 2c       	mov	r5, r1
    13ee:	61 2c       	mov	r6, r1
    13f0:	71 2c       	mov	r7, r1
    13f2:	c0 90 00 01 	lds	r12, 0x0100
    13f6:	d0 90 01 01 	lds	r13, 0x0101
    13fa:	e0 90 02 01 	lds	r14, 0x0102
    13fe:	f0 90 03 01 	lds	r15, 0x0103
    1402:	10 e0       	ldi	r17, 0x00	; 0
    1404:	3f 83       	std	Y+7, r19	; 0x07
    1406:	2e 83       	std	Y+6, r18	; 0x06
    1408:	d9 01       	movw	r26, r18
    140a:	19 c0       	rjmp	.+50     	; 0x143e <MakeNewGranularArray+0xc6>
    140c:	75 01       	movw	r14, r10
    140e:	64 01       	movw	r12, r8
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1410:	c5 01       	movw	r24, r10
    1412:	b4 01       	movw	r22, r8
    1414:	a3 01       	movw	r20, r6
    1416:	92 01       	movw	r18, r4
    1418:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    141c:	fb 01       	movw	r30, r22
    141e:	29 81       	ldd	r18, Y+1	; 0x01
    1420:	3a 81       	ldd	r19, Y+2	; 0x02
    1422:	e2 0f       	add	r30, r18
    1424:	f3 1f       	adc	r31, r19
    1426:	ec 5b       	subi	r30, 0xBC	; 188
    1428:	fb 4f       	sbci	r31, 0xFB	; 251
    142a:	80 81       	ld	r24, Z
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    142c:	ae 81       	ldd	r26, Y+6	; 0x06
    142e:	bf 81       	ldd	r27, Y+7	; 0x07
    1430:	8d 93       	st	X+, r24
    1432:	bf 83       	std	Y+7, r27	; 0x07
    1434:	ae 83       	std	Y+6, r26	; 0x06
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1436:	30 82       	st	Z, r3
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    1438:	1f 5f       	subi	r17, 0xFF	; 255
    143a:	10 17       	cp	r17, r16
    143c:	90 f4       	brcc	.+36     	; 0x1462 <MakeNewGranularArray+0xea>
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    143e:	3c 90       	ld	r3, X
    1440:	46 01       	movw	r8, r12
    1442:	57 01       	movw	r10, r14
    1444:	88 0c       	add	r8, r8
    1446:	99 1c       	adc	r9, r9
    1448:	aa 1c       	adc	r10, r10
    144a:	bb 1c       	adc	r11, r11
    144c:	f6 fe       	sbrs	r15, 6
    144e:	de cf       	rjmp	.-68     	; 0x140c <MakeNewGranularArray+0x94>
static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1450:	b5 eb       	ldi	r27, 0xB5	; 181
    1452:	8b 26       	eor	r8, r27
    1454:	b5 e9       	ldi	r27, 0x95	; 149
    1456:	9b 26       	eor	r9, r27
    1458:	ba ea       	ldi	r27, 0xAA	; 170
    145a:	ab 26       	eor	r10, r27
    145c:	b0 e2       	ldi	r27, 0x20	; 32
    145e:	bb 26       	eor	r11, r27
    1460:	d5 cf       	rjmp	.-86     	; 0x140c <MakeNewGranularArray+0x94>
    1462:	80 92 00 01 	sts	0x0100, r8
    1466:	90 92 01 01 	sts	0x0101, r9
    146a:	a0 92 02 01 	sts	0x0102, r10
    146e:	b0 92 03 01 	sts	0x0103, r11
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1472:	22 20       	and	r2, r2
    1474:	09 f4       	brne	.+2      	; 0x1478 <MakeNewGranularArray+0x100>
    1476:	78 c0       	rjmp	.+240    	; 0x1568 <MakeNewGranularArray+0x1f0>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
		}
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
    1478:	80 91 16 06 	lds	r24, 0x0616
    147c:	90 91 17 06 	lds	r25, 0x0617
    1480:	a0 91 18 06 	lds	r26, 0x0618
    1484:	b0 91 19 06 	lds	r27, 0x0619
    1488:	cc 24       	eor	r12, r12
    148a:	ca 94       	dec	r12
    148c:	dc 2c       	mov	r13, r12
    148e:	37 e0       	ldi	r19, 0x07	; 7
    1490:	e3 2e       	mov	r14, r19
    1492:	f1 2c       	mov	r15, r1
    1494:	a7 01       	movw	r20, r14
    1496:	96 01       	movw	r18, r12
    1498:	28 1b       	sub	r18, r24
    149a:	39 0b       	sbc	r19, r25
    149c:	4a 0b       	sbc	r20, r26
    149e:	5b 0b       	sbc	r21, r27
    14a0:	ca 01       	movw	r24, r20
    14a2:	b9 01       	movw	r22, r18
    14a4:	a3 01       	movw	r20, r6
    14a6:	92 01       	movw	r18, r4
    14a8:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
    14ac:	20 93 39 04 	sts	0x0439, r18
    14b0:	30 93 3a 04 	sts	0x043A, r19
    14b4:	40 93 3b 04 	sts	0x043B, r20
    14b8:	50 93 3c 04 	sts	0x043C, r21
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    14bc:	84 e2       	ldi	r24, 0x24	; 36
    14be:	4b 81       	ldd	r20, Y+3	; 0x03
    14c0:	5c 81       	ldd	r21, Y+4	; 0x04
    14c2:	84 9f       	mul	r24, r20
    14c4:	f0 01       	movw	r30, r0
    14c6:	85 9f       	mul	r24, r21
    14c8:	f0 0d       	add	r31, r0
    14ca:	11 24       	eor	r1, r1
    14cc:	eb 51       	subi	r30, 0x1B	; 27
    14ce:	fa 4f       	sbci	r31, 0xFA	; 250
    14d0:	07 83       	std	Z+7, r16	; 0x07
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    14d2:	fa 01       	movw	r30, r20
    14d4:	e3 5c       	subi	r30, 0xC3	; 195
    14d6:	fb 4f       	sbci	r31, 0xFB	; 251
    14d8:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    14da:	9a 01       	movw	r18, r20
    14dc:	22 0f       	add	r18, r18
    14de:	33 1f       	adc	r19, r19
    14e0:	22 0f       	add	r18, r18
    14e2:	33 1f       	adc	r19, r19
    14e4:	f9 01       	movw	r30, r18
    14e6:	eb 5c       	subi	r30, 0xCB	; 203
    14e8:	fb 4f       	sbci	r31, 0xFB	; 251
    14ea:	80 81       	ld	r24, Z
    14ec:	91 81       	ldd	r25, Z+1	; 0x01
    14ee:	a2 81       	ldd	r26, Z+2	; 0x02
    14f0:	b3 81       	ldd	r27, Z+3	; 0x03
    14f2:	f9 01       	movw	r30, r18
    14f4:	e3 5d       	subi	r30, 0xD3	; 211
    14f6:	fb 4f       	sbci	r31, 0xFB	; 251
    14f8:	80 83       	st	Z, r24
    14fa:	91 83       	std	Z+1, r25	; 0x01
    14fc:	a2 83       	std	Z+2, r26	; 0x02
    14fe:	b3 83       	std	Z+3, r27	; 0x03
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));
    1500:	20 91 39 04 	lds	r18, 0x0439
    1504:	30 91 3a 04 	lds	r19, 0x043A
    1508:	40 91 3b 04 	lds	r20, 0x043B
    150c:	50 91 3c 04 	lds	r21, 0x043C
    1510:	a0 91 c4 04 	lds	r26, 0x04C4
    1514:	b0 e0       	ldi	r27, 0x00	; 0
    1516:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    151a:	c6 1a       	sub	r12, r22
    151c:	d7 0a       	sbc	r13, r23
    151e:	e8 0a       	sbc	r14, r24
    1520:	f9 0a       	sbc	r15, r25
    1522:	c0 92 29 06 	sts	0x0629, r12
    1526:	d0 92 2a 06 	sts	0x062A, r13
    152a:	e0 92 2b 06 	sts	0x062B, r14
    152e:	f0 92 2c 06 	sts	0x062C, r15
		}

		SREG=sreg;		// Restore interrupts.
    1532:	5d 81       	ldd	r21, Y+5	; 0x05
    1534:	5f bf       	out	0x3f, r21	; 63
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
	}
}
    1536:	27 96       	adiw	r28, 0x07	; 7
    1538:	0f b6       	in	r0, 0x3f	; 63
    153a:	f8 94       	cli
    153c:	de bf       	out	0x3e, r29	; 62
    153e:	0f be       	out	0x3f, r0	; 63
    1540:	cd bf       	out	0x3d, r28	; 61
    1542:	df 91       	pop	r29
    1544:	cf 91       	pop	r28
    1546:	1f 91       	pop	r17
    1548:	0f 91       	pop	r16
    154a:	ff 90       	pop	r15
    154c:	ef 90       	pop	r14
    154e:	df 90       	pop	r13
    1550:	cf 90       	pop	r12
    1552:	bf 90       	pop	r11
    1554:	af 90       	pop	r10
    1556:	9f 90       	pop	r9
    1558:	8f 90       	pop	r8
    155a:	7f 90       	pop	r7
    155c:	6f 90       	pop	r6
    155e:	5f 90       	pop	r5
    1560:	4f 90       	pop	r4
    1562:	3f 90       	pop	r3
    1564:	2f 90       	pop	r2
    1566:	08 95       	ret
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1568:	60 91 f2 05 	lds	r22, 0x05F2
    156c:	70 91 f3 05 	lds	r23, 0x05F3
    1570:	80 91 f4 05 	lds	r24, 0x05F4
    1574:	90 91 f5 05 	lds	r25, 0x05F5
    1578:	a3 01       	movw	r20, r6
    157a:	92 01       	movw	r18, r4
    157c:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
    1580:	20 93 35 04 	sts	0x0435, r18
    1584:	30 93 36 04 	sts	0x0436, r19
    1588:	40 93 37 04 	sts	0x0437, r20
    158c:	50 93 38 04 	sts	0x0438, r21
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1590:	00 93 ec 05 	sts	0x05EC, r16
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1594:	10 92 3d 04 	sts	0x043D, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1598:	80 91 35 04 	lds	r24, 0x0435
    159c:	90 91 36 04 	lds	r25, 0x0436
    15a0:	a0 91 37 04 	lds	r26, 0x0437
    15a4:	b0 91 38 04 	lds	r27, 0x0438
    15a8:	80 93 2d 04 	sts	0x042D, r24
    15ac:	90 93 2e 04 	sts	0x042E, r25
    15b0:	a0 93 2f 04 	sts	0x042F, r26
    15b4:	b0 93 30 04 	sts	0x0430, r27

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    15b8:	20 91 35 04 	lds	r18, 0x0435
    15bc:	30 91 36 04 	lds	r19, 0x0436
    15c0:	40 91 37 04 	lds	r20, 0x0437
    15c4:	50 91 38 04 	lds	r21, 0x0438
    15c8:	a0 91 44 04 	lds	r26, 0x0444
    15cc:	b0 e0       	ldi	r27, 0x00	; 0
    15ce:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    15d2:	60 93 05 06 	sts	0x0605, r22
    15d6:	70 93 06 06 	sts	0x0606, r23
    15da:	80 93 07 06 	sts	0x0607, r24
    15de:	90 93 08 06 	sts	0x0608, r25
    15e2:	a7 cf       	rjmp	.-178    	; 0x1532 <MakeNewGranularArray+0x1ba>
    15e4:	00 e8       	ldi	r16, 0x80	; 128
    15e6:	ed ce       	rjmp	.-550    	; 0x13c2 <MakeNewGranularArray+0x4a>

		SREG=sreg;		// Restore interrupts.
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
    15e8:	84 e2       	ldi	r24, 0x24	; 36
    15ea:	28 9e       	mul	r2, r24
    15ec:	f0 01       	movw	r30, r0
    15ee:	11 24       	eor	r1, r1
    15f0:	eb 51       	subi	r30, 0x1B	; 27
    15f2:	fa 4f       	sbci	r31, 0xFA	; 250
    15f4:	17 82       	std	Z+7, r1	; 0x07
    15f6:	9f cf       	rjmp	.-194    	; 0x1536 <MakeNewGranularArray+0x1be>

000015f8 <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    15f8:	4f 92       	push	r4
    15fa:	5f 92       	push	r5
    15fc:	6f 92       	push	r6
    15fe:	7f 92       	push	r7
    1600:	8f 92       	push	r8
    1602:	9f 92       	push	r9
    1604:	af 92       	push	r10
    1606:	bf 92       	push	r11
    1608:	cf 92       	push	r12
    160a:	df 92       	push	r13
    160c:	ef 92       	push	r14
    160e:	ff 92       	push	r15
	unsigned char
		sreg;
	unsigned long
		chunkSize;

	sreg=SREG;
    1610:	ef b7       	in	r30, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1612:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1614:	81 11       	cpse	r24, r1
    1616:	9b c1       	rjmp	.+822    	; 0x194e <UpdateAdjustedSampleAddresses+0x356>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1618:	80 91 f2 05 	lds	r24, 0x05F2
    161c:	90 91 f3 05 	lds	r25, 0x05F3
    1620:	a0 91 f4 05 	lds	r26, 0x05F4
    1624:	b0 91 f5 05 	lds	r27, 0x05F5
    1628:	88 0f       	add	r24, r24
    162a:	99 1f       	adc	r25, r25
    162c:	aa 1f       	adc	r26, r26
    162e:	bb 1f       	adc	r27, r27
    1630:	88 0f       	add	r24, r24
    1632:	99 1f       	adc	r25, r25
    1634:	aa 1f       	adc	r26, r26
    1636:	bb 1f       	adc	r27, r27
    1638:	88 0f       	add	r24, r24
    163a:	99 1f       	adc	r25, r25
    163c:	aa 1f       	adc	r26, r26
    163e:	bb 1f       	adc	r27, r27
    1640:	89 2e       	mov	r8, r25
    1642:	9a 2e       	mov	r9, r26
    1644:	ab 2e       	mov	r10, r27
    1646:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1648:	a0 91 02 06 	lds	r26, 0x0602
    164c:	80 91 04 06 	lds	r24, 0x0604
    1650:	b0 e0       	ldi	r27, 0x00	; 0
    1652:	a8 0f       	add	r26, r24
    1654:	b1 1d       	adc	r27, r1
    1656:	a5 01       	movw	r20, r10
    1658:	94 01       	movw	r18, r8
    165a:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    165e:	f3 e0       	ldi	r31, 0x03	; 3
    1660:	96 95       	lsr	r25
    1662:	87 95       	ror	r24
    1664:	77 95       	ror	r23
    1666:	67 95       	ror	r22
    1668:	fa 95       	dec	r31
    166a:	d1 f7       	brne	.-12     	; 0x1660 <UpdateAdjustedSampleAddresses+0x68>
    166c:	60 93 fe 05 	sts	0x05FE, r22
    1670:	70 93 ff 05 	sts	0x05FF, r23
    1674:	80 93 00 06 	sts	0x0600, r24
    1678:	90 93 01 06 	sts	0x0601, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    167c:	40 90 f2 05 	lds	r4, 0x05F2
    1680:	50 90 f3 05 	lds	r5, 0x05F3
    1684:	60 90 f4 05 	lds	r6, 0x05F4
    1688:	70 90 f5 05 	lds	r7, 0x05F5
    168c:	f0 91 03 06 	lds	r31, 0x0603
    1690:	a0 91 04 06 	lds	r26, 0x0604
    1694:	b0 e0       	ldi	r27, 0x00	; 0
    1696:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    169a:	6b 01       	movw	r12, r22
    169c:	7c 01       	movw	r14, r24
    169e:	a3 e0       	ldi	r26, 0x03	; 3
    16a0:	f6 94       	lsr	r15
    16a2:	e7 94       	ror	r14
    16a4:	d7 94       	ror	r13
    16a6:	c7 94       	ror	r12
    16a8:	aa 95       	dec	r26
    16aa:	d1 f7       	brne	.-12     	; 0x16a0 <UpdateAdjustedSampleAddresses+0xa8>
    16ac:	c4 0c       	add	r12, r4
    16ae:	d5 1c       	adc	r13, r5
    16b0:	e6 1c       	adc	r14, r6
    16b2:	f7 1c       	adc	r15, r7
    16b4:	af 2f       	mov	r26, r31
    16b6:	b0 e0       	ldi	r27, 0x00	; 0
    16b8:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    16bc:	b3 e0       	ldi	r27, 0x03	; 3
    16be:	96 95       	lsr	r25
    16c0:	87 95       	ror	r24
    16c2:	77 95       	ror	r23
    16c4:	67 95       	ror	r22
    16c6:	ba 95       	dec	r27
    16c8:	d1 f7       	brne	.-12     	; 0x16be <UpdateAdjustedSampleAddresses+0xc6>
    16ca:	c6 1a       	sub	r12, r22
    16cc:	d7 0a       	sbc	r13, r23
    16ce:	e8 0a       	sbc	r14, r24
    16d0:	f9 0a       	sbc	r15, r25
    16d2:	c0 92 fa 05 	sts	0x05FA, r12
    16d6:	d0 92 fb 05 	sts	0x05FB, r13
    16da:	e0 92 fc 05 	sts	0x05FC, r14
    16de:	f0 92 fd 05 	sts	0x05FD, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    16e2:	40 91 fe 05 	lds	r20, 0x05FE
    16e6:	50 91 ff 05 	lds	r21, 0x05FF
    16ea:	60 91 00 06 	lds	r22, 0x0600
    16ee:	70 91 01 06 	lds	r23, 0x0601
    16f2:	80 91 fa 05 	lds	r24, 0x05FA
    16f6:	90 91 fb 05 	lds	r25, 0x05FB
    16fa:	a0 91 fc 05 	lds	r26, 0x05FC
    16fe:	b0 91 fd 05 	lds	r27, 0x05FD
    1702:	84 17       	cp	r24, r20
    1704:	95 07       	cpc	r25, r21
    1706:	a6 07       	cpc	r26, r22
    1708:	b7 07       	cpc	r27, r23
    170a:	08 f0       	brcs	.+2      	; 0x170e <UpdateAdjustedSampleAddresses+0x116>
    170c:	e7 c2       	rjmp	.+1486   	; 0x1cdc <UpdateAdjustedSampleAddresses+0x6e4>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    170e:	80 91 e8 05 	lds	r24, 0x05E8
    1712:	81 30       	cpi	r24, 0x01	; 1
    1714:	09 f4       	brne	.+2      	; 0x1718 <UpdateAdjustedSampleAddresses+0x120>
    1716:	f3 c2       	rjmp	.+1510   	; 0x1cfe <UpdateAdjustedSampleAddresses+0x706>
			{
				bankStates[BANK_0].sampleDirection=true;
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    1718:	10 92 e9 05 	sts	0x05E9, r1
			}

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    171c:	80 91 fe 05 	lds	r24, 0x05FE
    1720:	90 91 ff 05 	lds	r25, 0x05FF
    1724:	a0 91 00 06 	lds	r26, 0x0600
    1728:	b0 91 01 06 	lds	r27, 0x0601
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    172c:	40 91 fa 05 	lds	r20, 0x05FA
    1730:	50 91 fb 05 	lds	r21, 0x05FB
    1734:	60 91 fc 05 	lds	r22, 0x05FC
    1738:	70 91 fd 05 	lds	r23, 0x05FD
    173c:	40 93 fe 05 	sts	0x05FE, r20
    1740:	50 93 ff 05 	sts	0x05FF, r21
    1744:	60 93 00 06 	sts	0x0600, r22
    1748:	70 93 01 06 	sts	0x0601, r23
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    174c:	80 93 fa 05 	sts	0x05FA, r24
    1750:	90 93 fb 05 	sts	0x05FB, r25
    1754:	a0 93 fc 05 	sts	0x05FC, r26
    1758:	b0 93 fd 05 	sts	0x05FD, r27
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    175c:	40 91 fe 05 	lds	r20, 0x05FE
    1760:	50 91 ff 05 	lds	r21, 0x05FF
    1764:	60 91 00 06 	lds	r22, 0x0600
    1768:	70 91 01 06 	lds	r23, 0x0601
    176c:	80 91 f2 05 	lds	r24, 0x05F2
    1770:	90 91 f3 05 	lds	r25, 0x05F3
    1774:	a0 91 f4 05 	lds	r26, 0x05F4
    1778:	b0 91 f5 05 	lds	r27, 0x05F5
    177c:	84 17       	cp	r24, r20
    177e:	95 07       	cpc	r25, r21
    1780:	a6 07       	cpc	r26, r22
    1782:	b7 07       	cpc	r27, r23
    1784:	e0 f4       	brcc	.+56     	; 0x17be <UpdateAdjustedSampleAddresses+0x1c6>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1786:	80 91 fe 05 	lds	r24, 0x05FE
    178a:	90 91 ff 05 	lds	r25, 0x05FF
    178e:	a0 91 00 06 	lds	r26, 0x0600
    1792:	b0 91 01 06 	lds	r27, 0x0601
    1796:	40 91 f2 05 	lds	r20, 0x05F2
    179a:	50 91 f3 05 	lds	r21, 0x05F3
    179e:	60 91 f4 05 	lds	r22, 0x05F4
    17a2:	70 91 f5 05 	lds	r23, 0x05F5
    17a6:	84 1b       	sub	r24, r20
    17a8:	95 0b       	sbc	r25, r21
    17aa:	a6 0b       	sbc	r26, r22
    17ac:	b7 0b       	sbc	r27, r23
    17ae:	80 93 fe 05 	sts	0x05FE, r24
    17b2:	90 93 ff 05 	sts	0x05FF, r25
    17b6:	a0 93 00 06 	sts	0x0600, r26
    17ba:	b0 93 01 06 	sts	0x0601, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    17be:	40 91 fa 05 	lds	r20, 0x05FA
    17c2:	50 91 fb 05 	lds	r21, 0x05FB
    17c6:	60 91 fc 05 	lds	r22, 0x05FC
    17ca:	70 91 fd 05 	lds	r23, 0x05FD
    17ce:	80 91 f2 05 	lds	r24, 0x05F2
    17d2:	90 91 f3 05 	lds	r25, 0x05F3
    17d6:	a0 91 f4 05 	lds	r26, 0x05F4
    17da:	b0 91 f5 05 	lds	r27, 0x05F5
    17de:	84 17       	cp	r24, r20
    17e0:	95 07       	cpc	r25, r21
    17e2:	a6 07       	cpc	r26, r22
    17e4:	b7 07       	cpc	r27, r23
    17e6:	90 f5       	brcc	.+100    	; 0x184c <UpdateAdjustedSampleAddresses+0x254>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    17e8:	80 91 fa 05 	lds	r24, 0x05FA
    17ec:	90 91 fb 05 	lds	r25, 0x05FB
    17f0:	a0 91 fc 05 	lds	r26, 0x05FC
    17f4:	b0 91 fd 05 	lds	r27, 0x05FD
    17f8:	40 91 f2 05 	lds	r20, 0x05F2
    17fc:	50 91 f3 05 	lds	r21, 0x05F3
    1800:	60 91 f4 05 	lds	r22, 0x05F4
    1804:	70 91 f5 05 	lds	r23, 0x05F5
    1808:	84 1b       	sub	r24, r20
    180a:	95 0b       	sbc	r25, r21
    180c:	a6 0b       	sbc	r26, r22
    180e:	b7 0b       	sbc	r27, r23
    1810:	80 93 fa 05 	sts	0x05FA, r24
    1814:	90 93 fb 05 	sts	0x05FB, r25
    1818:	a0 93 fc 05 	sts	0x05FC, r26
    181c:	b0 93 fd 05 	sts	0x05FD, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    1820:	40 91 fa 05 	lds	r20, 0x05FA
    1824:	50 91 fb 05 	lds	r21, 0x05FB
    1828:	60 91 fc 05 	lds	r22, 0x05FC
    182c:	70 91 fd 05 	lds	r23, 0x05FD
    1830:	80 91 fe 05 	lds	r24, 0x05FE
    1834:	90 91 ff 05 	lds	r25, 0x05FF
    1838:	a0 91 00 06 	lds	r26, 0x0600
    183c:	b0 91 01 06 	lds	r27, 0x0601
    1840:	48 17       	cp	r20, r24
    1842:	59 07       	cpc	r21, r25
    1844:	6a 07       	cpc	r22, r26
    1846:	7b 07       	cpc	r23, r27
    1848:	09 f4       	brne	.+2      	; 0x184c <UpdateAdjustedSampleAddresses+0x254>
    184a:	ea c2       	rjmp	.+1492   	; 0x1e20 <UpdateAdjustedSampleAddresses+0x828>
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    184c:	40 91 fe 05 	lds	r20, 0x05FE
    1850:	50 91 ff 05 	lds	r21, 0x05FF
    1854:	60 91 00 06 	lds	r22, 0x0600
    1858:	70 91 01 06 	lds	r23, 0x0601
    185c:	80 91 fa 05 	lds	r24, 0x05FA
    1860:	90 91 fb 05 	lds	r25, 0x05FB
    1864:	a0 91 fc 05 	lds	r26, 0x05FC
    1868:	b0 91 fd 05 	lds	r27, 0x05FD
    186c:	84 17       	cp	r24, r20
    186e:	95 07       	cpc	r25, r21
    1870:	a6 07       	cpc	r26, r22
    1872:	b7 07       	cpc	r27, r23
    1874:	08 f0       	brcs	.+2      	; 0x1878 <UpdateAdjustedSampleAddresses+0x280>
    1876:	83 c2       	rjmp	.+1286   	; 0x1d7e <UpdateAdjustedSampleAddresses+0x786>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1878:	40 91 05 06 	lds	r20, 0x0605
    187c:	50 91 06 06 	lds	r21, 0x0606
    1880:	60 91 07 06 	lds	r22, 0x0607
    1884:	70 91 08 06 	lds	r23, 0x0608
    1888:	80 91 fe 05 	lds	r24, 0x05FE
    188c:	90 91 ff 05 	lds	r25, 0x05FF
    1890:	a0 91 00 06 	lds	r26, 0x0600
    1894:	b0 91 01 06 	lds	r27, 0x0601
    1898:	48 17       	cp	r20, r24
    189a:	59 07       	cpc	r21, r25
    189c:	6a 07       	cpc	r22, r26
    189e:	7b 07       	cpc	r23, r27
    18a0:	08 f0       	brcs	.+2      	; 0x18a4 <UpdateAdjustedSampleAddresses+0x2ac>
    18a2:	06 c2       	rjmp	.+1036   	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
    18a4:	40 91 05 06 	lds	r20, 0x0605
    18a8:	50 91 06 06 	lds	r21, 0x0606
    18ac:	60 91 07 06 	lds	r22, 0x0607
    18b0:	70 91 08 06 	lds	r23, 0x0608
    18b4:	80 91 fa 05 	lds	r24, 0x05FA
    18b8:	90 91 fb 05 	lds	r25, 0x05FB
    18bc:	a0 91 fc 05 	lds	r26, 0x05FC
    18c0:	b0 91 fd 05 	lds	r27, 0x05FD
    18c4:	84 17       	cp	r24, r20
    18c6:	95 07       	cpc	r25, r21
    18c8:	a6 07       	cpc	r26, r22
    18ca:	b7 07       	cpc	r27, r23
    18cc:	08 f0       	brcs	.+2      	; 0x18d0 <UpdateAdjustedSampleAddresses+0x2d8>
    18ce:	f0 c1       	rjmp	.+992    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?
    18d0:	40 91 fe 05 	lds	r20, 0x05FE
    18d4:	50 91 ff 05 	lds	r21, 0x05FF
    18d8:	60 91 00 06 	lds	r22, 0x0600
    18dc:	70 91 01 06 	lds	r23, 0x0601
    18e0:	80 90 05 06 	lds	r8, 0x0605
    18e4:	90 90 06 06 	lds	r9, 0x0606
    18e8:	a0 90 07 06 	lds	r10, 0x0607
    18ec:	b0 90 08 06 	lds	r11, 0x0608
    18f0:	80 91 05 06 	lds	r24, 0x0605
    18f4:	90 91 06 06 	lds	r25, 0x0606
    18f8:	a0 91 07 06 	lds	r26, 0x0607
    18fc:	b0 91 08 06 	lds	r27, 0x0608
    1900:	c0 90 fa 05 	lds	r12, 0x05FA
    1904:	d0 90 fb 05 	lds	r13, 0x05FB
    1908:	e0 90 fc 05 	lds	r14, 0x05FC
    190c:	f0 90 fd 05 	lds	r15, 0x05FD
    1910:	48 19       	sub	r20, r8
    1912:	59 09       	sbc	r21, r9
    1914:	6a 09       	sbc	r22, r10
    1916:	7b 09       	sbc	r23, r11
    1918:	8c 19       	sub	r24, r12
    191a:	9d 09       	sbc	r25, r13
    191c:	ae 09       	sbc	r26, r14
    191e:	bf 09       	sbc	r27, r15
    1920:	48 17       	cp	r20, r24
    1922:	59 07       	cpc	r21, r25
    1924:	6a 07       	cpc	r22, r26
    1926:	7b 07       	cpc	r23, r27
    1928:	08 f4       	brcc	.+2      	; 0x192c <UpdateAdjustedSampleAddresses+0x334>
    192a:	55 c2       	rjmp	.+1194   	; 0x1dd6 <UpdateAdjustedSampleAddresses+0x7de>
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    192c:	80 91 fe 05 	lds	r24, 0x05FE
    1930:	90 91 ff 05 	lds	r25, 0x05FF
    1934:	a0 91 00 06 	lds	r26, 0x0600
    1938:	b0 91 01 06 	lds	r27, 0x0601
    193c:	80 93 05 06 	sts	0x0605, r24
    1940:	90 93 06 06 	sts	0x0606, r25
    1944:	a0 93 07 06 	sts	0x0607, r26
    1948:	b0 93 08 06 	sts	0x0608, r27
    194c:	b1 c1       	rjmp	.+866    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
		}
	}
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    194e:	80 91 16 06 	lds	r24, 0x0616
    1952:	90 91 17 06 	lds	r25, 0x0617
    1956:	a0 91 18 06 	lds	r26, 0x0618
    195a:	b0 91 19 06 	lds	r27, 0x0619
    195e:	cc 24       	eor	r12, r12
    1960:	ca 94       	dec	r12
    1962:	dc 2c       	mov	r13, r12
    1964:	77 e0       	ldi	r23, 0x07	; 7
    1966:	e7 2e       	mov	r14, r23
    1968:	f1 2c       	mov	r15, r1
    196a:	a7 01       	movw	r20, r14
    196c:	96 01       	movw	r18, r12
    196e:	28 1b       	sub	r18, r24
    1970:	39 0b       	sbc	r19, r25
    1972:	4a 0b       	sbc	r20, r26
    1974:	5b 0b       	sbc	r21, r27
    1976:	da 01       	movw	r26, r20
    1978:	c9 01       	movw	r24, r18
    197a:	88 0f       	add	r24, r24
    197c:	99 1f       	adc	r25, r25
    197e:	aa 1f       	adc	r26, r26
    1980:	bb 1f       	adc	r27, r27
    1982:	88 0f       	add	r24, r24
    1984:	99 1f       	adc	r25, r25
    1986:	aa 1f       	adc	r26, r26
    1988:	bb 1f       	adc	r27, r27
    198a:	88 0f       	add	r24, r24
    198c:	99 1f       	adc	r25, r25
    198e:	aa 1f       	adc	r26, r26
    1990:	bb 1f       	adc	r27, r27
    1992:	89 2e       	mov	r8, r25
    1994:	9a 2e       	mov	r9, r26
    1996:	ab 2e       	mov	r10, r27
    1998:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    199a:	a0 91 26 06 	lds	r26, 0x0626
    199e:	80 91 28 06 	lds	r24, 0x0628
    19a2:	b0 e0       	ldi	r27, 0x00	; 0
    19a4:	a8 0f       	add	r26, r24
    19a6:	b1 1d       	adc	r27, r1
    19a8:	a5 01       	movw	r20, r10
    19aa:	94 01       	movw	r18, r8
    19ac:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    19b0:	f3 e0       	ldi	r31, 0x03	; 3
    19b2:	96 95       	lsr	r25
    19b4:	87 95       	ror	r24
    19b6:	77 95       	ror	r23
    19b8:	67 95       	ror	r22
    19ba:	fa 95       	dec	r31
    19bc:	d1 f7       	brne	.-12     	; 0x19b2 <UpdateAdjustedSampleAddresses+0x3ba>
    19be:	c6 1a       	sub	r12, r22
    19c0:	d7 0a       	sbc	r13, r23
    19c2:	e8 0a       	sbc	r14, r24
    19c4:	f9 0a       	sbc	r15, r25
    19c6:	c0 92 22 06 	sts	0x0622, r12
    19ca:	d0 92 23 06 	sts	0x0623, r13
    19ce:	e0 92 24 06 	sts	0x0624, r14
    19d2:	f0 92 25 06 	sts	0x0625, r15
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    19d6:	40 90 16 06 	lds	r4, 0x0616
    19da:	50 90 17 06 	lds	r5, 0x0617
    19de:	60 90 18 06 	lds	r6, 0x0618
    19e2:	70 90 19 06 	lds	r7, 0x0619
    19e6:	a0 91 27 06 	lds	r26, 0x0627
    19ea:	f0 91 28 06 	lds	r31, 0x0628
    19ee:	b0 e0       	ldi	r27, 0x00	; 0
    19f0:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    19f4:	6b 01       	movw	r12, r22
    19f6:	7c 01       	movw	r14, r24
    19f8:	a3 e0       	ldi	r26, 0x03	; 3
    19fa:	f6 94       	lsr	r15
    19fc:	e7 94       	ror	r14
    19fe:	d7 94       	ror	r13
    1a00:	c7 94       	ror	r12
    1a02:	aa 95       	dec	r26
    1a04:	d1 f7       	brne	.-12     	; 0x19fa <UpdateAdjustedSampleAddresses+0x402>
    1a06:	c4 0c       	add	r12, r4
    1a08:	d5 1c       	adc	r13, r5
    1a0a:	e6 1c       	adc	r14, r6
    1a0c:	f7 1c       	adc	r15, r7
    1a0e:	af 2f       	mov	r26, r31
    1a10:	b0 e0       	ldi	r27, 0x00	; 0
    1a12:	0e 94 a2 35 	call	0x6b44	; 0x6b44 <__muluhisi3>
    1a16:	b3 e0       	ldi	r27, 0x03	; 3
    1a18:	96 95       	lsr	r25
    1a1a:	87 95       	ror	r24
    1a1c:	77 95       	ror	r23
    1a1e:	67 95       	ror	r22
    1a20:	ba 95       	dec	r27
    1a22:	d1 f7       	brne	.-12     	; 0x1a18 <UpdateAdjustedSampleAddresses+0x420>
    1a24:	c6 1a       	sub	r12, r22
    1a26:	d7 0a       	sbc	r13, r23
    1a28:	e8 0a       	sbc	r14, r24
    1a2a:	f9 0a       	sbc	r15, r25
    1a2c:	c0 92 1e 06 	sts	0x061E, r12
    1a30:	d0 92 1f 06 	sts	0x061F, r13
    1a34:	e0 92 20 06 	sts	0x0620, r14
    1a38:	f0 92 21 06 	sts	0x0621, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1a3c:	40 91 22 06 	lds	r20, 0x0622
    1a40:	50 91 23 06 	lds	r21, 0x0623
    1a44:	60 91 24 06 	lds	r22, 0x0624
    1a48:	70 91 25 06 	lds	r23, 0x0625
    1a4c:	80 91 1e 06 	lds	r24, 0x061E
    1a50:	90 91 1f 06 	lds	r25, 0x061F
    1a54:	a0 91 20 06 	lds	r26, 0x0620
    1a58:	b0 91 21 06 	lds	r27, 0x0621
    1a5c:	48 17       	cp	r20, r24
    1a5e:	59 07       	cpc	r21, r25
    1a60:	6a 07       	cpc	r22, r26
    1a62:	7b 07       	cpc	r23, r27
    1a64:	08 f0       	brcs	.+2      	; 0x1a68 <UpdateAdjustedSampleAddresses+0x470>
    1a66:	32 c1       	rjmp	.+612    	; 0x1ccc <UpdateAdjustedSampleAddresses+0x6d4>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1a68:	80 91 0c 06 	lds	r24, 0x060C
    1a6c:	81 30       	cpi	r24, 0x01	; 1
    1a6e:	09 f4       	brne	.+2      	; 0x1a72 <UpdateAdjustedSampleAddresses+0x47a>
    1a70:	43 c1       	rjmp	.+646    	; 0x1cf8 <UpdateAdjustedSampleAddresses+0x700>
			{
				bankStates[BANK_1].sampleDirection=true;
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    1a72:	10 92 0d 06 	sts	0x060D, r1
			}

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    1a76:	80 91 22 06 	lds	r24, 0x0622
    1a7a:	90 91 23 06 	lds	r25, 0x0623
    1a7e:	a0 91 24 06 	lds	r26, 0x0624
    1a82:	b0 91 25 06 	lds	r27, 0x0625
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    1a86:	40 91 1e 06 	lds	r20, 0x061E
    1a8a:	50 91 1f 06 	lds	r21, 0x061F
    1a8e:	60 91 20 06 	lds	r22, 0x0620
    1a92:	70 91 21 06 	lds	r23, 0x0621
    1a96:	40 93 22 06 	sts	0x0622, r20
    1a9a:	50 93 23 06 	sts	0x0623, r21
    1a9e:	60 93 24 06 	sts	0x0624, r22
    1aa2:	70 93 25 06 	sts	0x0625, r23
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    1aa6:	80 93 1e 06 	sts	0x061E, r24
    1aaa:	90 93 1f 06 	sts	0x061F, r25
    1aae:	a0 93 20 06 	sts	0x0620, r26
    1ab2:	b0 93 21 06 	sts	0x0621, r27
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    1ab6:	40 91 22 06 	lds	r20, 0x0622
    1aba:	50 91 23 06 	lds	r21, 0x0623
    1abe:	60 91 24 06 	lds	r22, 0x0624
    1ac2:	70 91 25 06 	lds	r23, 0x0625
    1ac6:	80 91 16 06 	lds	r24, 0x0616
    1aca:	90 91 17 06 	lds	r25, 0x0617
    1ace:	a0 91 18 06 	lds	r26, 0x0618
    1ad2:	b0 91 19 06 	lds	r27, 0x0619
    1ad6:	48 17       	cp	r20, r24
    1ad8:	59 07       	cpc	r21, r25
    1ada:	6a 07       	cpc	r22, r26
    1adc:	7b 07       	cpc	r23, r27
    1ade:	f8 f4       	brcc	.+62     	; 0x1b1e <UpdateAdjustedSampleAddresses+0x526>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    1ae0:	80 91 22 06 	lds	r24, 0x0622
    1ae4:	90 91 23 06 	lds	r25, 0x0623
    1ae8:	a0 91 24 06 	lds	r26, 0x0624
    1aec:	b0 91 25 06 	lds	r27, 0x0625
    1af0:	40 91 16 06 	lds	r20, 0x0616
    1af4:	50 91 17 06 	lds	r21, 0x0617
    1af8:	60 91 18 06 	lds	r22, 0x0618
    1afc:	70 91 19 06 	lds	r23, 0x0619
    1b00:	01 97       	sbiw	r24, 0x01	; 1
    1b02:	a8 4f       	sbci	r26, 0xF8	; 248
    1b04:	bf 4f       	sbci	r27, 0xFF	; 255
    1b06:	84 1b       	sub	r24, r20
    1b08:	95 0b       	sbc	r25, r21
    1b0a:	a6 0b       	sbc	r26, r22
    1b0c:	b7 0b       	sbc	r27, r23
    1b0e:	80 93 22 06 	sts	0x0622, r24
    1b12:	90 93 23 06 	sts	0x0623, r25
    1b16:	a0 93 24 06 	sts	0x0624, r26
    1b1a:	b0 93 25 06 	sts	0x0625, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    1b1e:	40 91 1e 06 	lds	r20, 0x061E
    1b22:	50 91 1f 06 	lds	r21, 0x061F
    1b26:	60 91 20 06 	lds	r22, 0x0620
    1b2a:	70 91 21 06 	lds	r23, 0x0621
    1b2e:	80 91 16 06 	lds	r24, 0x0616
    1b32:	90 91 17 06 	lds	r25, 0x0617
    1b36:	a0 91 18 06 	lds	r26, 0x0618
    1b3a:	b0 91 19 06 	lds	r27, 0x0619
    1b3e:	48 17       	cp	r20, r24
    1b40:	59 07       	cpc	r21, r25
    1b42:	6a 07       	cpc	r22, r26
    1b44:	7b 07       	cpc	r23, r27
    1b46:	a8 f5       	brcc	.+106    	; 0x1bb2 <UpdateAdjustedSampleAddresses+0x5ba>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    1b48:	80 91 1e 06 	lds	r24, 0x061E
    1b4c:	90 91 1f 06 	lds	r25, 0x061F
    1b50:	a0 91 20 06 	lds	r26, 0x0620
    1b54:	b0 91 21 06 	lds	r27, 0x0621
    1b58:	40 91 16 06 	lds	r20, 0x0616
    1b5c:	50 91 17 06 	lds	r21, 0x0617
    1b60:	60 91 18 06 	lds	r22, 0x0618
    1b64:	70 91 19 06 	lds	r23, 0x0619
    1b68:	01 97       	sbiw	r24, 0x01	; 1
    1b6a:	a8 4f       	sbci	r26, 0xF8	; 248
    1b6c:	bf 4f       	sbci	r27, 0xFF	; 255
    1b6e:	84 1b       	sub	r24, r20
    1b70:	95 0b       	sbc	r25, r21
    1b72:	a6 0b       	sbc	r26, r22
    1b74:	b7 0b       	sbc	r27, r23
    1b76:	80 93 1e 06 	sts	0x061E, r24
    1b7a:	90 93 1f 06 	sts	0x061F, r25
    1b7e:	a0 93 20 06 	sts	0x0620, r26
    1b82:	b0 93 21 06 	sts	0x0621, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    1b86:	40 91 1e 06 	lds	r20, 0x061E
    1b8a:	50 91 1f 06 	lds	r21, 0x061F
    1b8e:	60 91 20 06 	lds	r22, 0x0620
    1b92:	70 91 21 06 	lds	r23, 0x0621
    1b96:	80 91 22 06 	lds	r24, 0x0622
    1b9a:	90 91 23 06 	lds	r25, 0x0623
    1b9e:	a0 91 24 06 	lds	r26, 0x0624
    1ba2:	b0 91 25 06 	lds	r27, 0x0625
    1ba6:	48 17       	cp	r20, r24
    1ba8:	59 07       	cpc	r21, r25
    1baa:	6a 07       	cpc	r22, r26
    1bac:	7b 07       	cpc	r23, r27
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <UpdateAdjustedSampleAddresses+0x5ba>
    1bb0:	23 c1       	rjmp	.+582    	; 0x1df8 <UpdateAdjustedSampleAddresses+0x800>
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    1bb2:	40 91 22 06 	lds	r20, 0x0622
    1bb6:	50 91 23 06 	lds	r21, 0x0623
    1bba:	60 91 24 06 	lds	r22, 0x0624
    1bbe:	70 91 25 06 	lds	r23, 0x0625
    1bc2:	80 91 1e 06 	lds	r24, 0x061E
    1bc6:	90 91 1f 06 	lds	r25, 0x061F
    1bca:	a0 91 20 06 	lds	r26, 0x0620
    1bce:	b0 91 21 06 	lds	r27, 0x0621
    1bd2:	48 17       	cp	r20, r24
    1bd4:	59 07       	cpc	r21, r25
    1bd6:	6a 07       	cpc	r22, r26
    1bd8:	7b 07       	cpc	r23, r27
    1bda:	08 f0       	brcs	.+2      	; 0x1bde <UpdateAdjustedSampleAddresses+0x5e6>
    1bdc:	93 c0       	rjmp	.+294    	; 0x1d04 <UpdateAdjustedSampleAddresses+0x70c>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1bde:	40 91 29 06 	lds	r20, 0x0629
    1be2:	50 91 2a 06 	lds	r21, 0x062A
    1be6:	60 91 2b 06 	lds	r22, 0x062B
    1bea:	70 91 2c 06 	lds	r23, 0x062C
    1bee:	80 91 22 06 	lds	r24, 0x0622
    1bf2:	90 91 23 06 	lds	r25, 0x0623
    1bf6:	a0 91 24 06 	lds	r26, 0x0624
    1bfa:	b0 91 25 06 	lds	r27, 0x0625
    1bfe:	84 17       	cp	r24, r20
    1c00:	95 07       	cpc	r25, r21
    1c02:	a6 07       	cpc	r26, r22
    1c04:	b7 07       	cpc	r27, r23
    1c06:	08 f0       	brcs	.+2      	; 0x1c0a <UpdateAdjustedSampleAddresses+0x612>
    1c08:	53 c0       	rjmp	.+166    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
    1c0a:	40 91 29 06 	lds	r20, 0x0629
    1c0e:	50 91 2a 06 	lds	r21, 0x062A
    1c12:	60 91 2b 06 	lds	r22, 0x062B
    1c16:	70 91 2c 06 	lds	r23, 0x062C
    1c1a:	80 91 1e 06 	lds	r24, 0x061E
    1c1e:	90 91 1f 06 	lds	r25, 0x061F
    1c22:	a0 91 20 06 	lds	r26, 0x0620
    1c26:	b0 91 21 06 	lds	r27, 0x0621
    1c2a:	48 17       	cp	r20, r24
    1c2c:	59 07       	cpc	r21, r25
    1c2e:	6a 07       	cpc	r22, r26
    1c30:	7b 07       	cpc	r23, r27
    1c32:	f0 f5       	brcc	.+124    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?
    1c34:	40 91 29 06 	lds	r20, 0x0629
    1c38:	50 91 2a 06 	lds	r21, 0x062A
    1c3c:	60 91 2b 06 	lds	r22, 0x062B
    1c40:	70 91 2c 06 	lds	r23, 0x062C
    1c44:	80 90 22 06 	lds	r8, 0x0622
    1c48:	90 90 23 06 	lds	r9, 0x0623
    1c4c:	a0 90 24 06 	lds	r10, 0x0624
    1c50:	b0 90 25 06 	lds	r11, 0x0625
    1c54:	80 91 1e 06 	lds	r24, 0x061E
    1c58:	90 91 1f 06 	lds	r25, 0x061F
    1c5c:	a0 91 20 06 	lds	r26, 0x0620
    1c60:	b0 91 21 06 	lds	r27, 0x0621
    1c64:	c0 90 29 06 	lds	r12, 0x0629
    1c68:	d0 90 2a 06 	lds	r13, 0x062A
    1c6c:	e0 90 2b 06 	lds	r14, 0x062B
    1c70:	f0 90 2c 06 	lds	r15, 0x062C
    1c74:	48 19       	sub	r20, r8
    1c76:	59 09       	sbc	r21, r9
    1c78:	6a 09       	sbc	r22, r10
    1c7a:	7b 09       	sbc	r23, r11
    1c7c:	8c 19       	sub	r24, r12
    1c7e:	9d 09       	sbc	r25, r13
    1c80:	ae 09       	sbc	r26, r14
    1c82:	bf 09       	sbc	r27, r15
    1c84:	84 17       	cp	r24, r20
    1c86:	95 07       	cpc	r25, r21
    1c88:	a6 07       	cpc	r26, r22
    1c8a:	b7 07       	cpc	r27, r23
    1c8c:	08 f4       	brcc	.+2      	; 0x1c90 <UpdateAdjustedSampleAddresses+0x698>
    1c8e:	66 c0       	rjmp	.+204    	; 0x1d5c <UpdateAdjustedSampleAddresses+0x764>
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    1c90:	80 91 22 06 	lds	r24, 0x0622
    1c94:	90 91 23 06 	lds	r25, 0x0623
    1c98:	a0 91 24 06 	lds	r26, 0x0624
    1c9c:	b0 91 25 06 	lds	r27, 0x0625
    1ca0:	80 93 29 06 	sts	0x0629, r24
    1ca4:	90 93 2a 06 	sts	0x062A, r25
    1ca8:	a0 93 2b 06 	sts	0x062B, r26
    1cac:	b0 93 2c 06 	sts	0x062C, r27
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    1cb0:	ef bf       	out	0x3f, r30	; 63
}
    1cb2:	ff 90       	pop	r15
    1cb4:	ef 90       	pop	r14
    1cb6:	df 90       	pop	r13
    1cb8:	cf 90       	pop	r12
    1cba:	bf 90       	pop	r11
    1cbc:	af 90       	pop	r10
    1cbe:	9f 90       	pop	r9
    1cc0:	8f 90       	pop	r8
    1cc2:	7f 90       	pop	r7
    1cc4:	6f 90       	pop	r6
    1cc6:	5f 90       	pop	r5
    1cc8:	4f 90       	pop	r4
    1cca:	08 95       	ret
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    1ccc:	80 91 0c 06 	lds	r24, 0x060C
    1cd0:	81 30       	cpi	r24, 0x01	; 1
    1cd2:	79 f0       	breq	.+30     	; 0x1cf2 <UpdateAdjustedSampleAddresses+0x6fa>
			{
				bankStates[BANK_1].sampleDirection=false;
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	80 93 0d 06 	sts	0x060D, r24
    1cda:	ed ce       	rjmp	.-550    	; 0x1ab6 <UpdateAdjustedSampleAddresses+0x4be>
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    1cdc:	80 91 e8 05 	lds	r24, 0x05E8
    1ce0:	81 30       	cpi	r24, 0x01	; 1
    1ce2:	21 f0       	breq	.+8      	; 0x1cec <UpdateAdjustedSampleAddresses+0x6f4>
			{
				bankStates[BANK_0].sampleDirection=false;
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    1ce4:	81 e0       	ldi	r24, 0x01	; 1
    1ce6:	80 93 e9 05 	sts	0x05E9, r24
    1cea:	38 cd       	rjmp	.-1424   	; 0x175c <UpdateAdjustedSampleAddresses+0x164>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
			{
				bankStates[BANK_0].sampleDirection=false;
    1cec:	10 92 e9 05 	sts	0x05E9, r1
    1cf0:	35 cd       	rjmp	.-1430   	; 0x175c <UpdateAdjustedSampleAddresses+0x164>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
			{
				bankStates[BANK_1].sampleDirection=false;
    1cf2:	10 92 0d 06 	sts	0x060D, r1
    1cf6:	df ce       	rjmp	.-578    	; 0x1ab6 <UpdateAdjustedSampleAddresses+0x4be>

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
			{
				bankStates[BANK_1].sampleDirection=true;
    1cf8:	80 93 0d 06 	sts	0x060D, r24
    1cfc:	bc ce       	rjmp	.-648    	; 0x1a76 <UpdateAdjustedSampleAddresses+0x47e>

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
			{
				bankStates[BANK_0].sampleDirection=true;
    1cfe:	80 93 e9 05 	sts	0x05E9, r24
    1d02:	0c cd       	rjmp	.-1512   	; 0x171c <UpdateAdjustedSampleAddresses+0x124>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    1d04:	40 91 29 06 	lds	r20, 0x0629
    1d08:	50 91 2a 06 	lds	r21, 0x062A
    1d0c:	60 91 2b 06 	lds	r22, 0x062B
    1d10:	70 91 2c 06 	lds	r23, 0x062C
    1d14:	80 91 22 06 	lds	r24, 0x0622
    1d18:	90 91 23 06 	lds	r25, 0x0623
    1d1c:	a0 91 24 06 	lds	r26, 0x0624
    1d20:	b0 91 25 06 	lds	r27, 0x0625
    1d24:	84 17       	cp	r24, r20
    1d26:	95 07       	cpc	r25, r21
    1d28:	a6 07       	cpc	r26, r22
    1d2a:	b7 07       	cpc	r27, r23
    1d2c:	08 f4       	brcc	.+2      	; 0x1d30 <UpdateAdjustedSampleAddresses+0x738>
    1d2e:	b0 cf       	rjmp	.-160    	; 0x1c90 <UpdateAdjustedSampleAddresses+0x698>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
			}
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    1d30:	40 91 29 06 	lds	r20, 0x0629
    1d34:	50 91 2a 06 	lds	r21, 0x062A
    1d38:	60 91 2b 06 	lds	r22, 0x062B
    1d3c:	70 91 2c 06 	lds	r23, 0x062C
    1d40:	80 91 1e 06 	lds	r24, 0x061E
    1d44:	90 91 1f 06 	lds	r25, 0x061F
    1d48:	a0 91 20 06 	lds	r26, 0x0620
    1d4c:	b0 91 21 06 	lds	r27, 0x0621
    1d50:	48 17       	cp	r20, r24
    1d52:	59 07       	cpc	r21, r25
    1d54:	6a 07       	cpc	r22, r26
    1d56:	7b 07       	cpc	r23, r27
    1d58:	08 f0       	brcs	.+2      	; 0x1d5c <UpdateAdjustedSampleAddresses+0x764>
    1d5a:	aa cf       	rjmp	.-172    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1d5c:	80 91 1e 06 	lds	r24, 0x061E
    1d60:	90 91 1f 06 	lds	r25, 0x061F
    1d64:	a0 91 20 06 	lds	r26, 0x0620
    1d68:	b0 91 21 06 	lds	r27, 0x0621
    1d6c:	80 93 29 06 	sts	0x0629, r24
    1d70:	90 93 2a 06 	sts	0x062A, r25
    1d74:	a0 93 2b 06 	sts	0x062B, r26
    1d78:	b0 93 2c 06 	sts	0x062C, r27
    1d7c:	99 cf       	rjmp	.-206    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    1d7e:	40 91 05 06 	lds	r20, 0x0605
    1d82:	50 91 06 06 	lds	r21, 0x0606
    1d86:	60 91 07 06 	lds	r22, 0x0607
    1d8a:	70 91 08 06 	lds	r23, 0x0608
    1d8e:	80 91 fe 05 	lds	r24, 0x05FE
    1d92:	90 91 ff 05 	lds	r25, 0x05FF
    1d96:	a0 91 00 06 	lds	r26, 0x0600
    1d9a:	b0 91 01 06 	lds	r27, 0x0601
    1d9e:	48 17       	cp	r20, r24
    1da0:	59 07       	cpc	r21, r25
    1da2:	6a 07       	cpc	r22, r26
    1da4:	7b 07       	cpc	r23, r27
    1da6:	08 f4       	brcc	.+2      	; 0x1daa <UpdateAdjustedSampleAddresses+0x7b2>
    1da8:	c1 cd       	rjmp	.-1150   	; 0x192c <UpdateAdjustedSampleAddresses+0x334>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
			}
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    1daa:	40 91 05 06 	lds	r20, 0x0605
    1dae:	50 91 06 06 	lds	r21, 0x0606
    1db2:	60 91 07 06 	lds	r22, 0x0607
    1db6:	70 91 08 06 	lds	r23, 0x0608
    1dba:	80 91 fa 05 	lds	r24, 0x05FA
    1dbe:	90 91 fb 05 	lds	r25, 0x05FB
    1dc2:	a0 91 fc 05 	lds	r26, 0x05FC
    1dc6:	b0 91 fd 05 	lds	r27, 0x05FD
    1dca:	84 17       	cp	r24, r20
    1dcc:	95 07       	cpc	r25, r21
    1dce:	a6 07       	cpc	r26, r22
    1dd0:	b7 07       	cpc	r27, r23
    1dd2:	08 f0       	brcs	.+2      	; 0x1dd6 <UpdateAdjustedSampleAddresses+0x7de>
    1dd4:	6d cf       	rjmp	.-294    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1dd6:	80 91 fa 05 	lds	r24, 0x05FA
    1dda:	90 91 fb 05 	lds	r25, 0x05FB
    1dde:	a0 91 fc 05 	lds	r26, 0x05FC
    1de2:	b0 91 fd 05 	lds	r27, 0x05FD
    1de6:	80 93 05 06 	sts	0x0605, r24
    1dea:	90 93 06 06 	sts	0x0606, r25
    1dee:	a0 93 07 06 	sts	0x0607, r26
    1df2:	b0 93 08 06 	sts	0x0608, r27
    1df6:	5c cf       	rjmp	.-328    	; 0x1cb0 <UpdateAdjustedSampleAddresses+0x6b8>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    1df8:	80 91 1e 06 	lds	r24, 0x061E
    1dfc:	90 91 1f 06 	lds	r25, 0x061F
    1e00:	a0 91 20 06 	lds	r26, 0x0620
    1e04:	b0 91 21 06 	lds	r27, 0x0621
    1e08:	01 96       	adiw	r24, 0x01	; 1
    1e0a:	a1 1d       	adc	r26, r1
    1e0c:	b1 1d       	adc	r27, r1
    1e0e:	80 93 1e 06 	sts	0x061E, r24
    1e12:	90 93 1f 06 	sts	0x061F, r25
    1e16:	a0 93 20 06 	sts	0x0620, r26
    1e1a:	b0 93 21 06 	sts	0x0621, r27
    1e1e:	c9 ce       	rjmp	.-622    	; 0x1bb2 <UpdateAdjustedSampleAddresses+0x5ba>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    1e20:	80 91 fa 05 	lds	r24, 0x05FA
    1e24:	90 91 fb 05 	lds	r25, 0x05FB
    1e28:	a0 91 fc 05 	lds	r26, 0x05FC
    1e2c:	b0 91 fd 05 	lds	r27, 0x05FD
    1e30:	01 97       	sbiw	r24, 0x01	; 1
    1e32:	a1 09       	sbc	r26, r1
    1e34:	b1 09       	sbc	r27, r1
    1e36:	80 93 fa 05 	sts	0x05FA, r24
    1e3a:	90 93 fb 05 	sts	0x05FB, r25
    1e3e:	a0 93 fc 05 	sts	0x05FC, r26
    1e42:	b0 93 fd 05 	sts	0x05FD, r27
    1e46:	02 cd       	rjmp	.-1532   	; 0x184c <UpdateAdjustedSampleAddresses+0x254>

00001e48 <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    1e48:	80 91 60 05 	lds	r24, 0x0560
    1e4c:	88 23       	and	r24, r24
    1e4e:	a1 f0       	breq	.+40     	; 0x1e78 <DoStartupSelect+0x30>
		SetTimer(TIMER_1,(SECOND/8));
		subState=SS_1;
	}
	else
	{
		if(CheckTimer(TIMER_1))
    1e50:	80 e0       	ldi	r24, 0x00	; 0
    1e52:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    1e56:	88 23       	and	r24, r24
    1e58:	71 f0       	breq	.+28     	; 0x1e76 <DoStartupSelect+0x2e>
		{
			if(keyState&Im_SWITCH_0)
    1e5a:	80 91 5d 05 	lds	r24, 0x055D
    1e5e:	80 fd       	sbrc	r24, 0
    1e60:	1c c0       	rjmp	.+56     	; 0x1e9a <DoStartupSelect+0x52>
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    1e62:	85 fd       	sbrc	r24, 5
    1e64:	11 c0       	rjmp	.+34     	; 0x1e88 <DoStartupSelect+0x40>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e66:	81 e6       	ldi	r24, 0x61	; 97
    1e68:	90 e1       	ldi	r25, 0x10	; 16
    1e6a:	90 93 e4 05 	sts	0x05E4, r25
    1e6e:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    1e72:	10 92 60 05 	sts	0x0560, r1
    1e76:	08 95       	ret
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
	{
		SetTimer(TIMER_1,(SECOND/8));
    1e78:	68 e9       	ldi	r22, 0x98	; 152
    1e7a:	70 e0       	ldi	r23, 0x00	; 0
    1e7c:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		subState=SS_1;
    1e80:	81 e0       	ldi	r24, 0x01	; 1
    1e82:	80 93 60 05 	sts	0x0560, r24
    1e86:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e88:	86 e5       	ldi	r24, 0x56	; 86
    1e8a:	9f e0       	ldi	r25, 0x0F	; 15
    1e8c:	90 93 e4 05 	sts	0x05E4, r25
    1e90:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    1e94:	10 92 60 05 	sts	0x0560, r1
    1e98:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e9a:	88 eb       	ldi	r24, 0xB8	; 184
    1e9c:	9d e1       	ldi	r25, 0x1D	; 29
    1e9e:	90 93 e4 05 	sts	0x05E4, r25
    1ea2:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    1ea6:	10 92 60 05 	sts	0x0560, r1
    1eaa:	08 95       	ret

00001eac <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
    1eac:	80 91 60 05 	lds	r24, 0x0560
    1eb0:	88 23       	and	r24, r24
    1eb2:	e1 f1       	breq	.+120    	; 0x1f2c <SetMidiChannels+0x80>
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
		subState=SS_1;
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    1eb4:	80 91 5c 05 	lds	r24, 0x055C
    1eb8:	80 ff       	sbrs	r24, 0
    1eba:	0e c0       	rjmp	.+28     	; 0x1ed8 <SetMidiChannels+0x2c>
		{
			midiChannelNumberA++;
    1ebc:	20 91 2f 06 	lds	r18, 0x062F
    1ec0:	2f 5f       	subi	r18, 0xFF	; 255
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    1ec2:	20 31       	cpi	r18, 0x10	; 16
    1ec4:	08 f0       	brcs	.+2      	; 0x1ec8 <SetMidiChannels+0x1c>
    1ec6:	4c c0       	rjmp	.+152    	; 0x1f60 <SetMidiChannels+0xb4>
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
    1ec8:	20 93 2f 06 	sts	0x062F, r18
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    1ecc:	90 91 62 05 	lds	r25, 0x0562
    1ed0:	90 7f       	andi	r25, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    1ed2:	92 2b       	or	r25, r18
    1ed4:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_1)
    1ed8:	81 ff       	sbrs	r24, 1
    1eda:	11 c0       	rjmp	.+34     	; 0x1efe <SetMidiChannels+0x52>
		{
			midiChannelNumberB++;
    1edc:	90 91 48 06 	lds	r25, 0x0648
    1ee0:	9f 5f       	subi	r25, 0xFF	; 255
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    1ee2:	90 31       	cpi	r25, 0x10	; 16
    1ee4:	08 f0       	brcs	.+2      	; 0x1ee8 <SetMidiChannels+0x3c>
    1ee6:	40 c0       	rjmp	.+128    	; 0x1f68 <SetMidiChannels+0xbc>
			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
		}
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
    1ee8:	90 93 48 06 	sts	0x0648, r25
    1eec:	29 2f       	mov	r18, r25
    1eee:	22 95       	swap	r18
    1ef0:	20 7f       	andi	r18, 0xF0	; 240
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    1ef2:	90 91 62 05 	lds	r25, 0x0562
    1ef6:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    1ef8:	92 2b       	or	r25, r18
    1efa:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    1efe:	82 ff       	sbrs	r24, 2
    1f00:	08 95       	ret
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    1f02:	60 91 2f 06 	lds	r22, 0x062F
    1f06:	84 e0       	ldi	r24, 0x04	; 4
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	0e 94 12 27 	call	0x4e24	; 0x4e24 <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    1f0e:	60 91 48 06 	lds	r22, 0x0648
    1f12:	88 e0       	ldi	r24, 0x08	; 8
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	0e 94 12 27 	call	0x4e24	; 0x4e24 <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1f1a:	81 e6       	ldi	r24, 0x61	; 97
    1f1c:	90 e1       	ldi	r25, 0x10	; 16
    1f1e:	90 93 e4 05 	sts	0x05E4, r25
    1f22:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    1f26:	10 92 60 05 	sts	0x0560, r1
    1f2a:	08 95       	ret

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    1f2c:	84 e0       	ldi	r24, 0x04	; 4
    1f2e:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    1f32:	80 31       	cpi	r24, 0x10	; 16
    1f34:	08 f0       	brcs	.+2      	; 0x1f38 <SetMidiChannels+0x8c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    1f36:	80 e0       	ldi	r24, 0x00	; 0
static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    1f38:	80 93 2f 06 	sts	0x062F, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    1f3c:	88 e0       	ldi	r24, 0x08	; 8
    1f3e:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	}

	if(x<16)					// Legit number?
    1f42:	80 31       	cpi	r24, 0x10	; 16
    1f44:	a8 f0       	brcs	.+42     	; 0x1f70 <SetMidiChannels+0xc4>
    1f46:	90 e1       	ldi	r25, 0x10	; 16
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    1f48:	81 e0       	ldi	r24, 0x01	; 1
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
		midiChannelNumberB=GetMidiChannel(BANK_1);
    1f4a:	80 93 48 06 	sts	0x0648, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    1f4e:	80 91 2f 06 	lds	r24, 0x062F
    1f52:	89 2b       	or	r24, r25
    1f54:	80 93 62 05 	sts	0x0562, r24
		subState=SS_1;
    1f58:	81 e0       	ldi	r24, 0x01	; 1
    1f5a:	80 93 60 05 	sts	0x0560, r24
    1f5e:	08 95       	ret
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
    1f60:	10 92 2f 06 	sts	0x062F, r1
    1f64:	20 e0       	ldi	r18, 0x00	; 0
    1f66:	b2 cf       	rjmp	.-156    	; 0x1ecc <SetMidiChannels+0x20>
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
    1f68:	10 92 48 06 	sts	0x0648, r1
    1f6c:	20 e0       	ldi	r18, 0x00	; 0
    1f6e:	c1 cf       	rjmp	.-126    	; 0x1ef2 <SetMidiChannels+0x46>
    1f70:	98 2f       	mov	r25, r24
    1f72:	92 95       	swap	r25
    1f74:	90 7f       	andi	r25, 0xF0	; 240
    1f76:	e9 cf       	rjmp	.-46     	; 0x1f4a <SetMidiChannels+0x9e>

00001f78 <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    1f78:	0f 93       	push	r16
    1f7a:	1f 93       	push	r17

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1f7c:	a8 2f       	mov	r26, r24
    1f7e:	b0 e0       	ldi	r27, 0x00	; 0
    1f80:	94 e2       	ldi	r25, 0x24	; 36
    1f82:	89 9f       	mul	r24, r25
    1f84:	f0 01       	movw	r30, r0
    1f86:	11 24       	eor	r1, r1
    1f88:	eb 51       	subi	r30, 0x1B	; 27
    1f8a:	fa 4f       	sbci	r31, 0xFA	; 250
    1f8c:	95 81       	ldd	r25, Z+5	; 0x05
    1f8e:	99 23       	and	r25, r25
    1f90:	31 f0       	breq	.+12     	; 0x1f9e <StartRecording+0x26>
    1f92:	90 91 4f 05 	lds	r25, 0x054F
    1f96:	91 50       	subi	r25, 0x01	; 1
    1f98:	92 30       	cpi	r25, 0x02	; 2
    1f9a:	08 f4       	brcc	.+2      	; 0x1f9e <StartRecording+0x26>
    1f9c:	4d c0       	rjmp	.+154    	; 0x2038 <StartRecording+0xc0>
	{

		sreg=SREG;	// Store global interrupt state.
    1f9e:	7f b7       	in	r23, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1fa0:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    1fa2:	94 e2       	ldi	r25, 0x24	; 36
    1fa4:	9a 9f       	mul	r25, r26
    1fa6:	f0 01       	movw	r30, r0
    1fa8:	9b 9f       	mul	r25, r27
    1faa:	f0 0d       	add	r31, r0
    1fac:	11 24       	eor	r1, r1
    1fae:	eb 51       	subi	r30, 0x1B	; 27
    1fb0:	fa 4f       	sbci	r31, 0xFA	; 250
    1fb2:	93 e0       	ldi	r25, 0x03	; 3
    1fb4:	90 83       	st	Z, r25

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    1fb6:	01 89       	ldd	r16, Z+17	; 0x11
    1fb8:	12 89       	ldd	r17, Z+18	; 0x12
    1fba:	23 89       	ldd	r18, Z+19	; 0x13
    1fbc:	34 89       	ldd	r19, Z+20	; 0x14
    1fbe:	00 a3       	std	Z+32, r16	; 0x20
    1fc0:	11 a3       	std	Z+33, r17	; 0x21
    1fc2:	22 a3       	std	Z+34, r18	; 0x22
    1fc4:	33 a3       	std	Z+35, r19	; 0x23
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    1fc6:	01 89       	ldd	r16, Z+17	; 0x11
    1fc8:	12 89       	ldd	r17, Z+18	; 0x12
    1fca:	23 89       	ldd	r18, Z+19	; 0x13
    1fcc:	34 89       	ldd	r19, Z+20	; 0x14
    1fce:	05 87       	std	Z+13, r16	; 0x0d
    1fd0:	16 87       	std	Z+14, r17	; 0x0e
    1fd2:	27 87       	std	Z+15, r18	; 0x0f
    1fd4:	30 8b       	std	Z+16, r19	; 0x10
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    1fd6:	01 89       	ldd	r16, Z+17	; 0x11
    1fd8:	12 89       	ldd	r17, Z+18	; 0x12
    1fda:	23 89       	ldd	r18, Z+19	; 0x13
    1fdc:	34 89       	ldd	r19, Z+20	; 0x14
    1fde:	01 8f       	std	Z+25, r16	; 0x19
    1fe0:	12 8f       	std	Z+26, r17	; 0x1a
    1fe2:	23 8f       	std	Z+27, r18	; 0x1b
    1fe4:	34 8f       	std	Z+28, r19	; 0x1c
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    1fe6:	01 89       	ldd	r16, Z+17	; 0x11
    1fe8:	12 89       	ldd	r17, Z+18	; 0x12
    1fea:	23 89       	ldd	r18, Z+19	; 0x13
    1fec:	34 89       	ldd	r19, Z+20	; 0x14
    1fee:	05 8b       	std	Z+21, r16	; 0x15
    1ff0:	16 8b       	std	Z+22, r17	; 0x16
    1ff2:	27 8b       	std	Z+23, r18	; 0x17
    1ff4:	30 8f       	std	Z+24, r19	; 0x18
		bankStates[theBank].sampleWindowOffset=0;									// "
    1ff6:	17 8e       	std	Z+31, r1	; 0x1f

		outOfRam=false;						// Plenty of ram left...
    1ff8:	10 92 3f 04 	sts	0x043F, r1

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    1ffc:	62 87       	std	Z+10, r22	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1ffe:	62 30       	cpi	r22, 0x02	; 2
    2000:	41 f1       	breq	.+80     	; 0x2052 <StartRecording+0xda>
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    2002:	61 30       	cpi	r22, 0x01	; 1
    2004:	e1 f0       	breq	.+56     	; 0x203e <StartRecording+0xc6>
		bankStates[theBank].sampleWindowOffset=0;									// "

		outOfRam=false;						// Plenty of ram left...

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2006:	84 e2       	ldi	r24, 0x24	; 36
    2008:	8a 9f       	mul	r24, r26
    200a:	f0 01       	movw	r30, r0
    200c:	8b 9f       	mul	r24, r27
    200e:	f0 0d       	add	r31, r0
    2010:	11 24       	eor	r1, r1
    2012:	eb 51       	subi	r30, 0x1B	; 27
    2014:	fa 4f       	sbci	r31, 0xFA	; 250
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	85 83       	std	Z+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    201a:	7f bf       	out	0x3f, r23	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    201c:	80 91 7a 00 	lds	r24, 0x007A
    2020:	86 fd       	sbrc	r24, 6
    2022:	0a c0       	rjmp	.+20     	; 0x2038 <StartRecording+0xc0>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    2024:	80 91 79 00 	lds	r24, 0x0079
    2028:	80 58       	subi	r24, 0x80	; 128
    202a:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    202e:	80 91 7a 00 	lds	r24, 0x007A
    2032:	80 64       	ori	r24, 0x40	; 64
    2034:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    2038:	1f 91       	pop	r17
    203a:	0f 91       	pop	r16
    203c:	08 95       	ret
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    203e:	88 23       	and	r24, r24
    2040:	a1 f1       	breq	.+104    	; 0x20aa <StartRecording+0x132>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    2042:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    2044:	84 e0       	ldi	r24, 0x04	; 4
    2046:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    204a:	80 e1       	ldi	r24, 0x10	; 16
    204c:	80 93 6d 00 	sts	0x006D, r24
    2050:	da cf       	rjmp	.-76     	; 0x2006 <StartRecording+0x8e>
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    2052:	54 87       	std	Z+12, r21	; 0x0c
    2054:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    2056:	81 11       	cpse	r24, r1
    2058:	14 c0       	rjmp	.+40     	; 0x2082 <StartRecording+0x10a>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    205a:	80 91 84 00 	lds	r24, 0x0084
    205e:	90 91 85 00 	lds	r25, 0x0085
    2062:	84 0f       	add	r24, r20
    2064:	95 1f       	adc	r25, r21
    2066:	90 93 89 00 	sts	0x0089, r25
    206a:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    206e:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    2070:	80 91 6f 00 	lds	r24, 0x006F
    2074:	82 60       	ori	r24, 0x02	; 2
    2076:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	80 93 81 00 	sts	0x0081, r24
    2080:	c2 cf       	rjmp	.-124    	; 0x2006 <StartRecording+0x8e>
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    2082:	80 91 84 00 	lds	r24, 0x0084
    2086:	90 91 85 00 	lds	r25, 0x0085
    208a:	84 0f       	add	r24, r20
    208c:	95 1f       	adc	r25, r21
    208e:	90 93 8b 00 	sts	0x008B, r25
    2092:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    2096:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    2098:	80 91 6f 00 	lds	r24, 0x006F
    209c:	84 60       	ori	r24, 0x04	; 4
    209e:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	80 93 81 00 	sts	0x0081, r24
    20a8:	ae cf       	rjmp	.-164    	; 0x2006 <StartRecording+0x8e>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    20aa:	80 91 81 00 	lds	r24, 0x0081
    20ae:	80 64       	ori	r24, 0x40	; 64
    20b0:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    20b4:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    20b6:	80 91 6f 00 	lds	r24, 0x006F
    20ba:	80 62       	ori	r24, 0x20	; 32
    20bc:	80 93 6f 00 	sts	0x006F, r24
    20c0:	a2 cf       	rjmp	.-188    	; 0x2006 <StartRecording+0x8e>

000020c2 <InitSampler>:

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    20c2:	84 e0       	ldi	r24, 0x04	; 4
    20c4:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    20c8:	80 31       	cpi	r24, 0x10	; 16
    20ca:	08 f0       	brcs	.+2      	; 0x20ce <InitSampler+0xc>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    20cc:	80 e0       	ldi	r24, 0x00	; 0
// Gets all variables and data structures read and set when the sampler starts up.
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    20ce:	80 93 2f 06 	sts	0x062F, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    20d2:	88 e0       	ldi	r24, 0x08	; 8
    20d4:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	}

	if(x<16)					// Legit number?
    20d8:	80 31       	cpi	r24, 0x10	; 16
    20da:	08 f0       	brcs	.+2      	; 0x20de <InitSampler+0x1c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    20dc:	81 e0       	ldi	r24, 0x01	; 1
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    20de:	80 93 48 06 	sts	0x0648, r24
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    20e2:	10 92 f6 05 	sts	0x05F6, r1
    20e6:	10 92 f7 05 	sts	0x05F7, r1
    20ea:	10 92 f8 05 	sts	0x05F8, r1
    20ee:	10 92 f9 05 	sts	0x05F9, r1
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    20f2:	8f ef       	ldi	r24, 0xFF	; 255
    20f4:	9f ef       	ldi	r25, 0xFF	; 255
    20f6:	a7 e0       	ldi	r26, 0x07	; 7
    20f8:	b0 e0       	ldi	r27, 0x00	; 0
    20fa:	80 93 1a 06 	sts	0x061A, r24
    20fe:	90 93 1b 06 	sts	0x061B, r25
    2102:	a0 93 1c 06 	sts	0x061C, r26
    2106:	b0 93 1d 06 	sts	0x061D, r27

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    210a:	10 92 e5 05 	sts	0x05E5, r1
		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    210e:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[i].loopOnce=false;
    2112:	10 92 e6 05 	sts	0x05E6, r1
		bankStates[i].bitReduction=0;				// No crusties yet.
    2116:	10 92 ee 05 	sts	0x05EE, r1
		bankStates[i].jitterValue=0;				// No hissies yet.
    211a:	10 92 ed 05 	sts	0x05ED, r1
		bankStates[i].granularSlices=0;				// No remix yet.
    211e:	10 92 ec 05 	sts	0x05EC, r1
		bankStates[i].halfSpeed=false;
    2122:	10 92 e7 05 	sts	0x05E7, r1
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	80 93 e9 05 	sts	0x05E9, r24
		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    212c:	10 92 e8 05 	sts	0x05E8, r1
		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2130:	80 91 f6 05 	lds	r24, 0x05F6
    2134:	90 91 f7 05 	lds	r25, 0x05F7
    2138:	a0 91 f8 05 	lds	r26, 0x05F8
    213c:	b0 91 f9 05 	lds	r27, 0x05F9
    2140:	80 93 05 06 	sts	0x0605, r24
    2144:	90 93 06 06 	sts	0x0606, r25
    2148:	a0 93 07 06 	sts	0x0607, r26
    214c:	b0 93 08 06 	sts	0x0608, r27
		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2150:	80 91 f6 05 	lds	r24, 0x05F6
    2154:	90 91 f7 05 	lds	r25, 0x05F7
    2158:	a0 91 f8 05 	lds	r26, 0x05F8
    215c:	b0 91 f9 05 	lds	r27, 0x05F9
    2160:	80 93 f2 05 	sts	0x05F2, r24
    2164:	90 93 f3 05 	sts	0x05F3, r25
    2168:	a0 93 f4 05 	sts	0x05F4, r26
    216c:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[i].realtimeOn=false;						// We'll default to playback.
    2170:	10 92 eb 05 	sts	0x05EB, r1
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    2174:	10 92 ea 05 	sts	0x05EA, r1
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    2178:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    217a:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    217c:	80 91 f6 05 	lds	r24, 0x05F6
    2180:	90 91 f7 05 	lds	r25, 0x05F7
    2184:	a0 91 f8 05 	lds	r26, 0x05F8
    2188:	b0 91 f9 05 	lds	r27, 0x05F9
    218c:	80 93 fe 05 	sts	0x05FE, r24
    2190:	90 93 ff 05 	sts	0x05FF, r25
    2194:	a0 93 00 06 	sts	0x0600, r26
    2198:	b0 93 01 06 	sts	0x0601, r27
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    219c:	80 91 f2 05 	lds	r24, 0x05F2
    21a0:	90 91 f3 05 	lds	r25, 0x05F3
    21a4:	a0 91 f4 05 	lds	r26, 0x05F4
    21a8:	b0 91 f5 05 	lds	r27, 0x05F5
    21ac:	80 93 fa 05 	sts	0x05FA, r24
    21b0:	90 93 fb 05 	sts	0x05FB, r25
    21b4:	a0 93 fc 05 	sts	0x05FC, r26
    21b8:	b0 93 fd 05 	sts	0x05FD, r27
	bankStates[theBank].sampleStartOffset=0;
    21bc:	10 92 02 06 	sts	0x0602, r1
	bankStates[theBank].sampleEndOffset=0;
    21c0:	10 92 03 06 	sts	0x0603, r1
	bankStates[theBank].sampleWindowOffset=0;
    21c4:	10 92 04 06 	sts	0x0604, r1
	SREG=sreg;		// Restore interrupts.
    21c8:	2f bf       	out	0x3f, r18	; 63

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    21ca:	87 e0       	ldi	r24, 0x07	; 7
    21cc:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
	}

	if(x<90)					// Legit number?
    21d0:	8a 35       	cpi	r24, 0x5A	; 90
    21d2:	08 f4       	brcc	.+2      	; 0x21d6 <InitSampler+0x114>
    21d4:	a9 c0       	rjmp	.+338    	; 0x2328 <InitSampler+0x266>
    21d6:	24 e0       	ldi	r18, 0x04	; 4
    21d8:	30 e0       	ldi	r19, 0x00	; 0
    21da:	e0 e0       	ldi	r30, 0x00	; 0
    21dc:	f0 e0       	ldi	r31, 0x00	; 0
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    21de:	ee 0f       	add	r30, r30
    21e0:	ff 1f       	adc	r31, r31
    21e2:	ea 5f       	subi	r30, 0xFA	; 250
    21e4:	fe 4f       	sbci	r31, 0xFE	; 254
    21e6:	80 81       	ld	r24, Z
    21e8:	91 81       	ldd	r25, Z+1	; 0x01
    21ea:	02 c0       	rjmp	.+4      	; 0x21f0 <InitSampler+0x12e>
    21ec:	96 95       	lsr	r25
    21ee:	87 95       	ror	r24
    21f0:	2a 95       	dec	r18
    21f2:	e2 f7       	brpl	.-8      	; 0x21ec <InitSampler+0x12a>
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    21f4:	90 93 64 05 	sts	0x0564, r25
    21f8:	80 93 63 05 	sts	0x0563, r24
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    21fc:	10 92 09 06 	sts	0x0609, r1
		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    2200:	10 92 13 06 	sts	0x0613, r1
		bankStates[i].loopOnce=false;
    2204:	10 92 0a 06 	sts	0x060A, r1
		bankStates[i].bitReduction=0;				// No crusties yet.
    2208:	10 92 12 06 	sts	0x0612, r1
		bankStates[i].jitterValue=0;				// No hissies yet.
    220c:	10 92 11 06 	sts	0x0611, r1
		bankStates[i].granularSlices=0;				// No remix yet.
    2210:	10 92 10 06 	sts	0x0610, r1
		bankStates[i].halfSpeed=false;
    2214:	10 92 0b 06 	sts	0x060B, r1
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	80 93 0d 06 	sts	0x060D, r24
		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    221e:	10 92 0c 06 	sts	0x060C, r1
		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2222:	80 91 1a 06 	lds	r24, 0x061A
    2226:	90 91 1b 06 	lds	r25, 0x061B
    222a:	a0 91 1c 06 	lds	r26, 0x061C
    222e:	b0 91 1d 06 	lds	r27, 0x061D
    2232:	80 93 29 06 	sts	0x0629, r24
    2236:	90 93 2a 06 	sts	0x062A, r25
    223a:	a0 93 2b 06 	sts	0x062B, r26
    223e:	b0 93 2c 06 	sts	0x062C, r27
		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2242:	80 91 1a 06 	lds	r24, 0x061A
    2246:	90 91 1b 06 	lds	r25, 0x061B
    224a:	a0 91 1c 06 	lds	r26, 0x061C
    224e:	b0 91 1d 06 	lds	r27, 0x061D
    2252:	80 93 16 06 	sts	0x0616, r24
    2256:	90 93 17 06 	sts	0x0617, r25
    225a:	a0 93 18 06 	sts	0x0618, r26
    225e:	b0 93 19 06 	sts	0x0619, r27
		bankStates[i].realtimeOn=false;						// We'll default to playback.
    2262:	10 92 0f 06 	sts	0x060F, r1
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    2266:	10 92 0e 06 	sts	0x060E, r1
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    226a:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    226c:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    226e:	80 91 1a 06 	lds	r24, 0x061A
    2272:	90 91 1b 06 	lds	r25, 0x061B
    2276:	a0 91 1c 06 	lds	r26, 0x061C
    227a:	b0 91 1d 06 	lds	r27, 0x061D
    227e:	80 93 22 06 	sts	0x0622, r24
    2282:	90 93 23 06 	sts	0x0623, r25
    2286:	a0 93 24 06 	sts	0x0624, r26
    228a:	b0 93 25 06 	sts	0x0625, r27
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    228e:	80 91 16 06 	lds	r24, 0x0616
    2292:	90 91 17 06 	lds	r25, 0x0617
    2296:	a0 91 18 06 	lds	r26, 0x0618
    229a:	b0 91 19 06 	lds	r27, 0x0619
    229e:	80 93 1e 06 	sts	0x061E, r24
    22a2:	90 93 1f 06 	sts	0x061F, r25
    22a6:	a0 93 20 06 	sts	0x0620, r26
    22aa:	b0 93 21 06 	sts	0x0621, r27
	bankStates[theBank].sampleStartOffset=0;
    22ae:	10 92 26 06 	sts	0x0626, r1
	bankStates[theBank].sampleEndOffset=0;
    22b2:	10 92 27 06 	sts	0x0627, r1
	bankStates[theBank].sampleWindowOffset=0;
    22b6:	10 92 28 06 	sts	0x0628, r1
	SREG=sreg;		// Restore interrupts.
    22ba:	2f bf       	out	0x3f, r18	; 63
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    22bc:	8b e0       	ldi	r24, 0x0B	; 11
    22be:	0e 94 1f 27 	call	0x4e3e	; 0x4e3e <EepromRead>
	}

	if(x<90)					// Legit number?
    22c2:	8a 35       	cpi	r24, 0x5A	; 90
    22c4:	c0 f1       	brcs	.+112    	; 0x2336 <InitSampler+0x274>
    22c6:	24 e0       	ldi	r18, 0x04	; 4
    22c8:	30 e0       	ldi	r19, 0x00	; 0
    22ca:	e0 e0       	ldi	r30, 0x00	; 0
    22cc:	f0 e0       	ldi	r31, 0x00	; 0
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    22ce:	ee 0f       	add	r30, r30
    22d0:	ff 1f       	adc	r31, r31
    22d2:	ea 5f       	subi	r30, 0xFA	; 250
    22d4:	fe 4f       	sbci	r31, 0xFE	; 254
    22d6:	80 81       	ld	r24, Z
    22d8:	91 81       	ldd	r25, Z+1	; 0x01
    22da:	02 c0       	rjmp	.+4      	; 0x22e0 <InitSampler+0x21e>
    22dc:	96 95       	lsr	r25
    22de:	87 95       	ror	r24
    22e0:	2a 95       	dec	r18
    22e2:	e2 f7       	brpl	.-8      	; 0x22dc <InitSampler+0x21a>
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    22e4:	90 93 66 05 	sts	0x0566, r25
    22e8:	80 93 65 05 	sts	0x0565, r24
	}

	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    22ec:	8c e0       	ldi	r24, 0x0C	; 12
    22ee:	99 e0       	ldi	r25, 0x09	; 9
    22f0:	90 93 e2 05 	sts	0x05E2, r25
    22f4:	80 93 e1 05 	sts	0x05E1, r24

	currentBank=BANK_0;			// Point at the first bank until we change banks.
    22f8:	10 92 67 05 	sts	0x0567, r1
	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
    22fc:	10 92 69 05 	sts	0x0569, r1
    2300:	10 92 68 05 	sts	0x0568, r1
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2304:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    2308:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    230c:	68 e9       	ldi	r22, 0x98	; 152
    230e:	70 e0       	ldi	r23, 0x00	; 0
    2310:	82 e0       	ldi	r24, 0x02	; 2
    2312:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2316:	83 e1       	ldi	r24, 0x13	; 19
    2318:	93 e1       	ldi	r25, 0x13	; 19
    231a:	90 93 e4 05 	sts	0x05E4, r25
    231e:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    2322:	10 92 60 05 	sts	0x0560, r1
    2326:	08 95       	ret
    2328:	6c e0       	ldi	r22, 0x0C	; 12
    232a:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <__udivmodqi4>
    232e:	e9 2f       	mov	r30, r25
    2330:	f0 e0       	ldi	r31, 0x00	; 0
    2332:	28 2f       	mov	r18, r24
    2334:	54 cf       	rjmp	.-344    	; 0x21de <InitSampler+0x11c>
    2336:	6c e0       	ldi	r22, 0x0C	; 12
    2338:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <__udivmodqi4>
    233c:	e9 2f       	mov	r30, r25
    233e:	f0 e0       	ldi	r31, 0x00	; 0
    2340:	28 2f       	mov	r18, r24
    2342:	c5 cf       	rjmp	.-118    	; 0x22ce <InitSampler+0x20c>

00002344 <PlaySampleFromSd>:
	}
}

static void PlaySampleFromSd(unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    2344:	cf 92       	push	r12
    2346:	df 92       	push	r13
    2348:	ef 92       	push	r14
    234a:	ff 92       	push	r15
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    2350:	20 91 5e 05 	lds	r18, 0x055E
    2354:	2e 30       	cpi	r18, 0x0E	; 14
    2356:	d1 f1       	breq	.+116    	; 0x23cc <PlaySampleFromSd+0x88>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    2358:	30 91 4f 05 	lds	r19, 0x054F
    235c:	33 30       	cpi	r19, 0x03	; 3
    235e:	39 f0       	breq	.+14     	; 0x236e <PlaySampleFromSd+0x2a>
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
			SREG=sreg;
		}
	}
}
    2360:	df 91       	pop	r29
    2362:	cf 91       	pop	r28
    2364:	ff 90       	pop	r15
    2366:	ef 90       	pop	r14
    2368:	df 90       	pop	r13
    236a:	cf 90       	pop	r12
    236c:	08 95       	ret
		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    236e:	2b 30       	cpi	r18, 0x0B	; 11
    2370:	69 f1       	breq	.+90     	; 0x23cc <PlaySampleFromSd+0x88>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

			SREG=sreg;	// resume isr
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    2372:	2d 30       	cpi	r18, 0x0D	; 13
    2374:	01 f1       	breq	.+64     	; 0x23b6 <PlaySampleFromSd+0x72>
    2376:	20 91 b8 05 	lds	r18, 0x05B8
    237a:	21 30       	cpi	r18, 0x01	; 1
    237c:	e1 f0       	breq	.+56     	; 0x23b6 <PlaySampleFromSd+0x72>
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    237e:	80 93 b9 05 	sts	0x05B9, r24
    2382:	90 93 ba 05 	sts	0x05BA, r25
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    2386:	81 e0       	ldi	r24, 0x01	; 1
    2388:	80 93 bb 05 	sts	0x05BB, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    238c:	80 93 b8 05 	sts	0x05B8, r24

			sreg=SREG;	 		// Pause ISRs
    2390:	9f b7       	in	r25, 0x3f	; 63
			cli();
    2392:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    2394:	10 92 27 01 	sts	0x0127, r1
    2398:	10 92 26 01 	sts	0x0126, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    239c:	80 91 70 00 	lds	r24, 0x0070
    23a0:	8b 7f       	andi	r24, 0xFB	; 251
    23a2:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;
    23a6:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	ff 90       	pop	r15
    23ae:	ef 90       	pop	r14
    23b0:	df 90       	pop	r13
    23b2:	cf 90       	pop	r12
    23b4:	08 95       	ret
			SREG=sreg;	// resume isr
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    23b6:	80 93 b9 05 	sts	0x05B9, r24
    23ba:	90 93 ba 05 	sts	0x05BA, r25
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
			SREG=sreg;
		}
	}
}
    23be:	df 91       	pop	r29
    23c0:	cf 91       	pop	r28
    23c2:	ff 90       	pop	r15
    23c4:	ef 90       	pop	r14
    23c6:	df 90       	pop	r13
    23c8:	cf 90       	pop	r12
    23ca:	08 95       	ret
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
		{
			sreg=SREG;	 // Pause ISRs
    23cc:	cf b7       	in	r28, 0x3f	; 63
			cli();
    23ce:	f8 94       	cli
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
	unsigned char
		sreg;

	sreg=SREG;
    23d0:	df b7       	in	r29, 0x3f	; 63
	cli();		// Pause ISR
    23d2:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    23d4:	d8 2e       	mov	r13, r24
    23d6:	dd 0c       	add	r13, r13
    23d8:	dd 0c       	add	r13, r13
    23da:	c1 2c       	mov	r12, r1
    23dc:	8f ef       	ldi	r24, 0xFF	; 255
    23de:	c8 1a       	sub	r12, r24
    23e0:	d8 0a       	sbc	r13, r24
    23e2:	e1 2c       	mov	r14, r1
    23e4:	f1 2c       	mov	r15, r1
    23e6:	c7 01       	movw	r24, r14
    23e8:	b6 01       	movw	r22, r12
    23ea:	0e 94 ab 2c 	call	0x5956	; 0x5956 <SdBeginSingleBlockRead>
    23ee:	81 30       	cpi	r24, 0x01	; 1
    23f0:	51 f1       	breq	.+84     	; 0x2446 <PlaySampleFromSd+0x102>

		SREG=sreg;	// Resume ISR

		return(true);
	}
	SREG=sreg;	// Resume ISR
    23f2:	df bf       	out	0x3f, r29	; 63
		{
			sreg=SREG;	 // Pause ISRs
			cli();

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    23f4:	81 e0       	ldi	r24, 0x01	; 1
    23f6:	90 e0       	ldi	r25, 0x00	; 0
    23f8:	a0 e0       	ldi	r26, 0x00	; 0
    23fa:	b0 e0       	ldi	r27, 0x00	; 0
    23fc:	80 93 22 01 	sts	0x0122, r24
    2400:	90 93 23 01 	sts	0x0123, r25
    2404:	a0 93 24 01 	sts	0x0124, r26
    2408:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;

	sreg=SREG;
    240c:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    240e:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    2410:	83 e0       	ldi	r24, 0x03	; 3
    2412:	80 93 4f 05 	sts	0x054F, r24

	TCNT2=0;			// Init counter reg
    2416:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
    241a:	81 e7       	ldi	r24, 0x71	; 113
    241c:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2420:	8f ef       	ldi	r24, 0xFF	; 255
    2422:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2424:	80 91 70 00 	lds	r24, 0x0070
    2428:	84 60       	ori	r24, 0x04	; 4
    242a:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    242e:	82 e0       	ldi	r24, 0x02	; 2
    2430:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    2434:	9f bf       	out	0x3f, r25	; 63

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

			SREG=sreg;	// resume isr
    2436:	cf bf       	out	0x3f, r28	; 63
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
			SREG=sreg;
		}
	}
}
    2438:	df 91       	pop	r29
    243a:	cf 91       	pop	r28
    243c:	ff 90       	pop	r15
    243e:	ef 90       	pop	r14
    2440:	df 90       	pop	r13
    2442:	cf 90       	pop	r12
    2444:	08 95       	ret
	sreg=SREG;
	cli();		// Pause ISR

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    2446:	c0 92 b2 05 	sts	0x05B2, r12
    244a:	d0 92 b3 05 	sts	0x05B3, r13
    244e:	e0 92 b4 05 	sts	0x05B4, r14
    2452:	f0 92 b5 05 	sts	0x05B5, r15
		sdCurrentBlockOffset=0;						// Read first block first
    2456:	10 92 b7 05 	sts	0x05B7, r1
    245a:	10 92 b6 05 	sts	0x05B6, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    245e:	10 92 2b 01 	sts	0x012B, r1
    2462:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    2466:	10 92 29 01 	sts	0x0129, r1
    246a:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    246e:	10 92 27 01 	sts	0x0127, r1
    2472:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    2476:	6a e7       	ldi	r22, 0x7A	; 122
    2478:	70 e0       	ldi	r23, 0x00	; 0
    247a:	83 e0       	ldi	r24, 0x03	; 3
    247c:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    2480:	89 e0       	ldi	r24, 0x09	; 9
    2482:	80 93 5e 05 	sts	0x055E, r24

		SREG=sreg;	// Resume ISR
    2486:	df bf       	out	0x3f, r29	; 63
    2488:	b5 cf       	rjmp	.-150    	; 0x23f4 <PlaySampleFromSd+0xb0>

0000248a <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    248a:	cf 93       	push	r28
	static unsigned char
		i;

	if(subState==SS_0)
    248c:	c0 91 60 05 	lds	r28, 0x0560
    2490:	cc 23       	and	r28, r28
    2492:	69 f0       	breq	.+26     	; 0x24ae <DoFruitcakeIntro+0x24>
		i=0;
		ledOnOffMask=0;
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
	}
	else if(subState==SS_1)
    2494:	c1 30       	cpi	r28, 0x01	; 1
    2496:	09 f4       	brne	.+2      	; 0x249a <DoFruitcakeIntro+0x10>
    2498:	47 c0       	rjmp	.+142    	; 0x2528 <DoFruitcakeIntro+0x9e>
			subState=SS_2;
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}

	else if(subState==SS_2)
    249a:	c2 30       	cpi	r28, 0x02	; 2
    249c:	01 f1       	breq	.+64     	; 0x24de <DoFruitcakeIntro+0x54>
				subState=SS_3;
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_3)
    249e:	c3 30       	cpi	r28, 0x03	; 3
    24a0:	09 f4       	brne	.+2      	; 0x24a4 <DoFruitcakeIntro+0x1a>
    24a2:	8a c0       	rjmp	.+276    	; 0x25b8 <DoFruitcakeIntro+0x12e>
				subState=SS_4;
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_4)
    24a4:	c4 30       	cpi	r28, 0x04	; 4
    24a6:	09 f4       	brne	.+2      	; 0x24aa <DoFruitcakeIntro+0x20>
    24a8:	70 c0       	rjmp	.+224    	; 0x258a <DoFruitcakeIntro+0x100>
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
}
    24aa:	cf 91       	pop	r28
    24ac:	08 95       	ret
	static unsigned char
		i;

	if(subState==SS_0)
	{
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    24ae:	10 92 5e 05 	sts	0x055E, r1
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    24b2:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    24b6:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    24ba:	68 e9       	ldi	r22, 0x98	; 152
    24bc:	70 e0       	ldi	r23, 0x00	; 0
    24be:	82 e0       	ldi	r24, 0x02	; 2
    24c0:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
	if(subState==SS_0)
	{
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus

		KillLeds();
		i=0;
    24c4:	10 92 61 05 	sts	0x0561, r1
		ledOnOffMask=0;
    24c8:	10 92 62 05 	sts	0x0562, r1
		subState=SS_1;
    24cc:	81 e0       	ldi	r24, 0x01	; 1
    24ce:	80 93 60 05 	sts	0x0560, r24
		SetTimer(TIMER_1,(SECOND/4));
    24d2:	61 e3       	ldi	r22, 0x31	; 49
    24d4:	71 e0       	ldi	r23, 0x01	; 1
    24d6:	80 e0       	ldi	r24, 0x00	; 0
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
}
    24d8:	cf 91       	pop	r28

		KillLeds();
		i=0;
		ledOnOffMask=0;
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
    24da:	0c 94 53 27 	jmp	0x4ea6	; 0x4ea6 <SetTimer>
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}

	else if(subState==SS_2)
	{
		if(i<NUM_LEDS)
    24de:	80 91 61 05 	lds	r24, 0x0561
    24e2:	88 30       	cpi	r24, 0x08	; 8
    24e4:	50 f5       	brcc	.+84     	; 0x253a <DoFruitcakeIntro+0xb0>
		{
			if(CheckTimer(TIMER_1))
    24e6:	80 e0       	ldi	r24, 0x00	; 0
    24e8:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    24ec:	88 23       	and	r24, r24
    24ee:	c1 f0       	breq	.+48     	; 0x2520 <DoFruitcakeIntro+0x96>
			{
				ledOnOffMask|=(1<<i);
    24f0:	81 e0       	ldi	r24, 0x01	; 1
    24f2:	90 e0       	ldi	r25, 0x00	; 0
    24f4:	00 90 61 05 	lds	r0, 0x0561
    24f8:	02 c0       	rjmp	.+4      	; 0x24fe <DoFruitcakeIntro+0x74>
    24fa:	88 0f       	add	r24, r24
    24fc:	99 1f       	adc	r25, r25
    24fe:	0a 94       	dec	r0
    2500:	e2 f7       	brpl	.-8      	; 0x24fa <DoFruitcakeIntro+0x70>
    2502:	90 91 62 05 	lds	r25, 0x0562
    2506:	98 2b       	or	r25, r24
    2508:	90 93 62 05 	sts	0x0562, r25
				SetTimer(TIMER_1,(SECOND/20));
    250c:	6d e3       	ldi	r22, 0x3D	; 61
    250e:	70 e0       	ldi	r23, 0x00	; 0
    2510:	80 e0       	ldi	r24, 0x00	; 0
    2512:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
				i++;
    2516:	80 91 61 05 	lds	r24, 0x0561
    251a:	8f 5f       	subi	r24, 0xFF	; 255
    251c:	80 93 61 05 	sts	0x0561, r24
		if(CheckTimer(TIMER_1))
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    2520:	10 92 5e 05 	sts	0x055E, r1
	}
}
    2524:	cf 91       	pop	r28
    2526:	08 95       	ret
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
	}
	else if(subState==SS_1)
	{
		if(CheckTimer(TIMER_1))
    2528:	80 e0       	ldi	r24, 0x00	; 0
    252a:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    252e:	88 23       	and	r24, r24
    2530:	b9 f3       	breq	.-18     	; 0x2520 <DoFruitcakeIntro+0x96>
		{
			subState=SS_2;
    2532:	82 e0       	ldi	r24, 0x02	; 2
    2534:	80 93 60 05 	sts	0x0560, r24
    2538:	f3 cf       	rjmp	.-26     	; 0x2520 <DoFruitcakeIntro+0x96>
				i++;
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    253a:	80 e0       	ldi	r24, 0x00	; 0
    253c:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    2540:	88 23       	and	r24, r24
    2542:	71 f3       	breq	.-36     	; 0x2520 <DoFruitcakeIntro+0x96>
			{
				SetTimer(TIMER_1,(SECOND/8));
    2544:	68 e9       	ldi	r22, 0x98	; 152
    2546:	70 e0       	ldi	r23, 0x00	; 0
    2548:	80 e0       	ldi	r24, 0x00	; 0
    254a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
				ledPwm=255;
    254e:	8f ef       	ldi	r24, 0xFF	; 255
    2550:	80 93 40 04 	sts	0x0440, r24
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    2554:	90 91 64 00 	lds	r25, 0x0064
    2558:	9f 7b       	andi	r25, 0xBF	; 191
    255a:	90 93 64 00 	sts	0x0064, r25

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    255e:	c0 93 b0 00 	sts	0x00B0, r28
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    2562:	91 e0       	ldi	r25, 0x01	; 1
    2564:	90 93 b1 00 	sts	0x00B1, r25
				TCNT2=0;			// Init counter reg
    2568:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    256c:	90 e8       	ldi	r25, 0x80	; 128
    256e:	90 93 b3 00 	sts	0x00B3, r25
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    2572:	87 bb       	out	0x17, r24	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    2574:	c0 93 70 00 	sts	0x0070, r28

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    2578:	92 b1       	in	r25, 0x02	; 2
    257a:	96 60       	ori	r25, 0x06	; 6
    257c:	92 b9       	out	0x02, r25	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    257e:	84 b9       	out	0x04, r24	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    2580:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;
    2582:	83 e0       	ldi	r24, 0x03	; 3
    2584:	80 93 60 05 	sts	0x0560, r24
    2588:	cb cf       	rjmp	.-106    	; 0x2520 <DoFruitcakeIntro+0x96>
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_4)
	{
		if(CheckTimer(TIMER_1))
    258a:	80 e0       	ldi	r24, 0x00	; 0
    258c:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    2590:	88 23       	and	r24, r24
    2592:	31 f2       	breq	.-116    	; 0x2520 <DoFruitcakeIntro+0x96>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2594:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    2598:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    259c:	68 e9       	ldi	r22, 0x98	; 152
    259e:	70 e0       	ldi	r23, 0x00	; 0
    25a0:	82 e0       	ldi	r24, 0x02	; 2
    25a2:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    25a6:	84 e2       	ldi	r24, 0x24	; 36
    25a8:	9f e0       	ldi	r25, 0x0F	; 15
    25aa:	90 93 e4 05 	sts	0x05E4, r25
    25ae:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    25b2:	10 92 60 05 	sts	0x0560, r1
    25b6:	b4 cf       	rjmp	.-152    	; 0x2520 <DoFruitcakeIntro+0x96>
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_3)
	{
		if(CheckTimer(TIMER_1))
    25b8:	80 e0       	ldi	r24, 0x00	; 0
    25ba:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    25be:	88 23       	and	r24, r24
    25c0:	09 f4       	brne	.+2      	; 0x25c4 <DoFruitcakeIntro+0x13a>
    25c2:	ae cf       	rjmp	.-164    	; 0x2520 <DoFruitcakeIntro+0x96>
		{
			if(ledPwm>1)
    25c4:	80 91 40 04 	lds	r24, 0x0440
    25c8:	82 30       	cpi	r24, 0x02	; 2
    25ca:	58 f0       	brcs	.+22     	; 0x25e2 <DoFruitcakeIntro+0x158>
			{
				ledPwm-=2;
    25cc:	80 91 40 04 	lds	r24, 0x0440
    25d0:	82 50       	subi	r24, 0x02	; 2
    25d2:	80 93 40 04 	sts	0x0440, r24
				SetTimer(TIMER_1,(SECOND/256));
    25d6:	64 e0       	ldi	r22, 0x04	; 4
    25d8:	70 e0       	ldi	r23, 0x00	; 0
    25da:	80 e0       	ldi	r24, 0x00	; 0
    25dc:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
    25e0:	9f cf       	rjmp	.-194    	; 0x2520 <DoFruitcakeIntro+0x96>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    25e2:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    25e6:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    25ea:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
    25ee:	80 91 64 00 	lds	r24, 0x0064
    25f2:	80 64       	ori	r24, 0x40	; 64
    25f4:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    25f8:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    25fa:	5f 98       	cbi	0x0b, 7	; 11
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    25fc:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    2600:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    2604:	68 e9       	ldi	r22, 0x98	; 152
    2606:	70 e0       	ldi	r23, 0x00	; 0
    2608:	82 e0       	ldi	r24, 0x02	; 2
    260a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>

				LATCH_PORT=0x00;		// LEDs off.
				PORTD&=~(Om_LED_LA);	// ...Keep them off.

				KillLeds();				// App knows leds are off.
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    260e:	82 e1       	ldi	r24, 0x12	; 18
    2610:	80 93 62 05 	sts	0x0562, r24
				SetTimer(TIMER_1,(SECOND/2));
    2614:	62 e6       	ldi	r22, 0x62	; 98
    2616:	72 e0       	ldi	r23, 0x02	; 2
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
				subState=SS_4;
    261e:	84 e0       	ldi	r24, 0x04	; 4
    2620:	80 93 60 05 	sts	0x0560, r24
    2624:	7d cf       	rjmp	.-262    	; 0x2520 <DoFruitcakeIntro+0x96>

00002626 <DoSampler>:
// Sampler main loop.  This handles getting switch inputs and MIDI and calling all the functions necessary to turn this stuff into audio.
// If we want to enter a "menu" we should leave this state and return when it's time to run normally again.
// An old note:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.
{
    2626:	cf 92       	push	r12
    2628:	df 92       	push	r13
    262a:	ef 92       	push	r14
    262c:	ff 92       	push	r15
    262e:	0f 93       	push	r16
    2630:	1f 93       	push	r17
    2632:	cf 93       	push	r28
    2634:	df 93       	push	r29
    2636:	1f 92       	push	r1
    2638:	cd b7       	in	r28, 0x3d	; 61
    263a:	de b7       	in	r29, 0x3e	; 62
		};

	unsigned int
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    263c:	80 91 60 05 	lds	r24, 0x0560
    2640:	88 23       	and	r24, r24
    2642:	09 f4       	brne	.+2      	; 0x2646 <DoSampler+0x20>
    2644:	f1 c0       	rjmp	.+482    	; 0x2828 <DoSampler+0x202>
    2646:	60 91 4f 05 	lds	r22, 0x054F
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    264a:	63 30       	cpi	r22, 0x03	; 3
    264c:	11 f0       	breq	.+4      	; 0x2652 <DoSampler+0x2c>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    264e:	10 92 55 05 	sts	0x0555, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    2652:	80 91 ef 05 	lds	r24, 0x05EF
    2656:	81 30       	cpi	r24, 0x01	; 1
    2658:	41 f0       	breq	.+16     	; 0x266a <DoSampler+0x44>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    265a:	10 92 42 04 	sts	0x0442, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    265e:	80 91 6f 00 	lds	r24, 0x006F
    2662:	8f 7d       	andi	r24, 0xDF	; 223
    2664:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
    2668:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    266a:	80 91 13 06 	lds	r24, 0x0613
    266e:	81 30       	cpi	r24, 0x01	; 1
    2670:	31 f0       	breq	.+12     	; 0x267e <DoSampler+0x58>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    2672:	10 92 45 05 	sts	0x0545, r1
		PCICR=0;			// No global PCINTS.
    2676:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    267a:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    267e:	80 91 ef 05 	lds	r24, 0x05EF
    2682:	82 30       	cpi	r24, 0x02	; 2
    2684:	41 f0       	breq	.+16     	; 0x2696 <DoSampler+0x70>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    2686:	10 92 48 05 	sts	0x0548, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    268a:	80 91 6f 00 	lds	r24, 0x006F
    268e:	8d 7f       	andi	r24, 0xFD	; 253
    2690:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
    2694:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    2696:	80 91 13 06 	lds	r24, 0x0613
    269a:	82 30       	cpi	r24, 0x02	; 2
    269c:	41 f0       	breq	.+16     	; 0x26ae <DoSampler+0x88>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    269e:	10 92 4c 05 	sts	0x054C, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    26a2:	80 91 6f 00 	lds	r24, 0x006F
    26a6:	8b 7f       	andi	r24, 0xFB	; 251
    26a8:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
    26ac:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    26ae:	80 91 ef 05 	lds	r24, 0x05EF
    26b2:	81 11       	cpse	r24, r1
    26b4:	04 c0       	rjmp	.+8      	; 0x26be <DoSampler+0x98>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    26b6:	61 11       	cpse	r22, r1
    26b8:	a3 c0       	rjmp	.+326    	; 0x2800 <DoSampler+0x1da>
		{
			bankStates[BANK_0].isLocked=false;
    26ba:	10 92 ea 05 	sts	0x05EA, r1
		}
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    26be:	80 91 13 06 	lds	r24, 0x0613
    26c2:	81 11       	cpse	r24, r1
    26c4:	0b c0       	rjmp	.+22     	; 0x26dc <DoSampler+0xb6>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    26c6:	66 23       	and	r22, r22
    26c8:	09 f4       	brne	.+2      	; 0x26cc <DoSampler+0xa6>
    26ca:	95 c0       	rjmp	.+298    	; 0x27f6 <DoSampler+0x1d0>
    26cc:	63 30       	cpi	r22, 0x03	; 3
    26ce:	09 f4       	brne	.+2      	; 0x26d2 <DoSampler+0xac>
    26d0:	92 c0       	rjmp	.+292    	; 0x27f6 <DoSampler+0x1d0>
    26d2:	80 91 54 05 	lds	r24, 0x0554
    26d6:	81 30       	cpi	r24, 0x01	; 1
    26d8:	09 f4       	brne	.+2      	; 0x26dc <DoSampler+0xb6>
    26da:	8d c0       	rjmp	.+282    	; 0x27f6 <DoSampler+0x1d0>
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    26dc:	80 91 58 05 	lds	r24, 0x0558
    26e0:	82 95       	swap	r24
    26e2:	86 95       	lsr	r24
    26e4:	87 70       	andi	r24, 0x07	; 7
    26e6:	80 93 70 05 	sts	0x0570, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    26ea:	20 91 62 05 	lds	r18, 0x0562
    26ee:	2f 71       	andi	r18, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    26f0:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    26f2:	20 68       	ori	r18, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    26f4:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    26f6:	20 64       	ori	r18, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    26f8:	84 70       	andi	r24, 0x04	; 4
    26fa:	09 f0       	breq	.+2      	; 0x26fe <DoSampler+0xd8>
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    26fc:	20 62       	ori	r18, 0x20	; 32
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    26fe:	30 91 67 05 	lds	r19, 0x0567
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    2702:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    2704:	83 2f       	mov	r24, r19
    2706:	90 e0       	ldi	r25, 0x00	; 0
    2708:	44 e2       	ldi	r20, 0x24	; 36
    270a:	34 9f       	mul	r19, r20
    270c:	f0 01       	movw	r30, r0
    270e:	11 24       	eor	r1, r1
    2710:	eb 51       	subi	r30, 0x1B	; 27
    2712:	fa 4f       	sbci	r31, 0xFA	; 250
    2714:	40 81       	ld	r20, Z
    2716:	43 30       	cpi	r20, 0x03	; 3
    2718:	09 f4       	brne	.+2      	; 0x271c <DoSampler+0xf6>
    271a:	61 c1       	rjmp	.+706    	; 0x29de <DoSampler+0x3b8>
	{
		temp|=Om_LED_REC;
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    271c:	44 e2       	ldi	r20, 0x24	; 36
    271e:	48 9f       	mul	r20, r24
    2720:	f0 01       	movw	r30, r0
    2722:	49 9f       	mul	r20, r25
    2724:	f0 0d       	add	r31, r0
    2726:	11 24       	eor	r1, r1
    2728:	eb 51       	subi	r30, 0x1B	; 27
    272a:	fa 4f       	sbci	r31, 0xFA	; 250
    272c:	40 81       	ld	r20, Z
    272e:	44 30       	cpi	r20, 0x04	; 4
    2730:	09 f4       	brne	.+2      	; 0x2734 <DoSampler+0x10e>
    2732:	59 c1       	rjmp	.+690    	; 0x29e6 <DoSampler+0x3c0>
	{
		temp|=Om_LED_PLAY;
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    2734:	44 e2       	ldi	r20, 0x24	; 36
    2736:	48 9f       	mul	r20, r24
    2738:	f0 01       	movw	r30, r0
    273a:	49 9f       	mul	r20, r25
    273c:	f0 0d       	add	r31, r0
    273e:	11 24       	eor	r1, r1
    2740:	eb 51       	subi	r30, 0x1B	; 27
    2742:	fa 4f       	sbci	r31, 0xFA	; 250
    2744:	40 81       	ld	r20, Z
    2746:	45 30       	cpi	r20, 0x05	; 5
    2748:	09 f4       	brne	.+2      	; 0x274c <DoSampler+0x126>
    274a:	4b c1       	rjmp	.+662    	; 0x29e2 <DoSampler+0x3bc>
	{
		temp|=Om_LED_ODUB;
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    274c:	44 e2       	ldi	r20, 0x24	; 36
    274e:	48 9f       	mul	r20, r24
    2750:	f0 01       	movw	r30, r0
    2752:	49 9f       	mul	r20, r25
    2754:	f0 0d       	add	r31, r0
    2756:	11 24       	eor	r1, r1
    2758:	eb 51       	subi	r30, 0x1B	; 27
    275a:	fa 4f       	sbci	r31, 0xFA	; 250
    275c:	40 81       	ld	r20, Z
    275e:	42 30       	cpi	r20, 0x02	; 2
    2760:	09 f4       	brne	.+2      	; 0x2764 <DoSampler+0x13e>
    2762:	3b c1       	rjmp	.+630    	; 0x29da <DoSampler+0x3b4>
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
	}

	if(outOfRam==true)
    2764:	40 91 3f 04 	lds	r20, 0x043F
    2768:	41 30       	cpi	r20, 0x01	; 1
    276a:	09 f4       	brne	.+2      	; 0x276e <DoSampler+0x148>
    276c:	30 c1       	rjmp	.+608    	; 0x29ce <DoSampler+0x3a8>
	{
		temp|=Om_LED_OUT_OF_MEM;
	}
	if(theBank==BANK_1)
    276e:	31 30       	cpi	r19, 0x01	; 1
    2770:	09 f4       	brne	.+2      	; 0x2774 <DoSampler+0x14e>
    2772:	31 c1       	rjmp	.+610    	; 0x29d6 <DoSampler+0x3b0>
	{
		temp|=Om_LED_BANK;
	}

	ledOnOffMask=temp;
    2774:	20 93 62 05 	sts	0x0562, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    2778:	34 e2       	ldi	r19, 0x24	; 36
    277a:	38 9f       	mul	r19, r24
    277c:	f0 01       	movw	r30, r0
    277e:	39 9f       	mul	r19, r25
    2780:	f0 0d       	add	r31, r0
    2782:	11 24       	eor	r1, r1
    2784:	eb 51       	subi	r30, 0x1B	; 27
    2786:	fa 4f       	sbci	r31, 0xFA	; 250
    2788:	41 89       	ldd	r20, Z+17	; 0x11
    278a:	52 89       	ldd	r21, Z+18	; 0x12
    278c:	63 89       	ldd	r22, Z+19	; 0x13
    278e:	74 89       	ldd	r23, Z+20	; 0x14
    2790:	85 85       	ldd	r24, Z+13	; 0x0d
    2792:	96 85       	ldd	r25, Z+14	; 0x0e
    2794:	a7 85       	ldd	r26, Z+15	; 0x0f
    2796:	b0 89       	ldd	r27, Z+16	; 0x10
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    2798:	30 91 b1 05 	lds	r19, 0x05B1
		temp|=Om_LED_BANK;
	}

	ledOnOffMask=temp;

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    279c:	48 17       	cp	r20, r24
    279e:	59 07       	cpc	r21, r25
    27a0:	6a 07       	cpc	r22, r26
    27a2:	7b 07       	cpc	r23, r27
    27a4:	a9 f1       	breq	.+106    	; 0x2810 <DoSampler+0x1ea>
    27a6:	83 2f       	mov	r24, r19
    27a8:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27aa:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27ac:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27ae:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27b0:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27b2:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27b4:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27b6:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27b8:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27ba:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27bc:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27be:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27c0:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27c2:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27c4:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27c6:	88 0f       	add	r24, r24
    27c8:	89 2f       	mov	r24, r25
    27ca:	88 1f       	adc	r24, r24
    27cc:	99 0b       	sbc	r25, r25
    27ce:	89 2b       	or	r24, r25
    27d0:	a9 f4       	brne	.+42     	; 0x27fc <DoSampler+0x1d6>
    27d2:	20 93 62 05 	sts	0x0562, r18
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    27d6:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    27da:	68 e9       	ldi	r22, 0x98	; 152
    27dc:	70 e0       	ldi	r23, 0x00	; 0
    27de:	82 e0       	ldi	r24, 0x02	; 2

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    27e0:	0f 90       	pop	r0
    27e2:	df 91       	pop	r29
    27e4:	cf 91       	pop	r28
    27e6:	1f 91       	pop	r17
    27e8:	0f 91       	pop	r16
    27ea:	ff 90       	pop	r15
    27ec:	ef 90       	pop	r14
    27ee:	df 90       	pop	r13
    27f0:	cf 90       	pop	r12
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    27f2:	0c 94 53 27 	jmp	0x4ea6	; 0x4ea6 <SetTimer>
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
		{
			bankStates[BANK_1].isLocked=false;
    27f6:	10 92 0e 06 	sts	0x060E, r1
    27fa:	70 cf       	rjmp	.-288    	; 0x26dc <DoSampler+0xb6>

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27fc:	2f 77       	andi	r18, 0x7F	; 127
    27fe:	e9 cf       	rjmp	.-46     	; 0x27d2 <DoSampler+0x1ac>
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    2800:	63 30       	cpi	r22, 0x03	; 3
    2802:	09 f4       	brne	.+2      	; 0x2806 <DoSampler+0x1e0>
    2804:	5a cf       	rjmp	.-332    	; 0x26ba <DoSampler+0x94>
    2806:	80 91 54 05 	lds	r24, 0x0554
    280a:	81 11       	cpse	r24, r1
    280c:	58 cf       	rjmp	.-336    	; 0x26be <DoSampler+0x98>
    280e:	55 cf       	rjmp	.-342    	; 0x26ba <DoSampler+0x94>

	ledOnOffMask=temp;

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    2810:	32 ff       	sbrs	r19, 2
    2812:	0c c1       	rjmp	.+536    	; 0x2a2c <DoSampler+0x406>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    2814:	0f 90       	pop	r0
    2816:	df 91       	pop	r29
    2818:	cf 91       	pop	r28
    281a:	1f 91       	pop	r17
    281c:	0f 91       	pop	r16
    281e:	ff 90       	pop	r15
    2820:	ef 90       	pop	r14
    2822:	df 90       	pop	r13
    2824:	cf 90       	pop	r12
    2826:	08 95       	ret
// Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
{
	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
    2828:	80 91 6f 05 	lds	r24, 0x056F
    282c:	86 ff       	sbrs	r24, 6
    282e:	dd c0       	rjmp	.+442    	; 0x29ea <DoSampler+0x3c4>
    2830:	87 fd       	sbrc	r24, 7
    2832:	7f c1       	rjmp	.+766    	; 0x2b32 <DoSampler+0x50c>
	// -----------------------------------------------------------------------------------
	// Shift 1:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    2834:	80 91 5d 05 	lds	r24, 0x055D
    2838:	80 ff       	sbrs	r24, 0
    283a:	17 c0       	rjmp	.+46     	; 0x286a <DoSampler+0x244>
		{
			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just got pressed
    283c:	80 91 59 05 	lds	r24, 0x0559
    2840:	81 11       	cpse	r24, r1
    2842:	04 c0       	rjmp	.+8      	; 0x284c <DoSampler+0x226>
    2844:	80 91 5c 05 	lds	r24, 0x055C
    2848:	80 ff       	sbrs	r24, 0
    284a:	11 c0       	rjmp	.+34     	; 0x286e <DoSampler+0x248>
			{
				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    284c:	80 91 67 05 	lds	r24, 0x0567
    2850:	20 91 70 05 	lds	r18, 0x0570
    2854:	34 e2       	ldi	r19, 0x24	; 36
    2856:	83 9f       	mul	r24, r19
    2858:	f0 01       	movw	r30, r0
    285a:	11 24       	eor	r1, r1
    285c:	eb 51       	subi	r30, 0x1B	; 27
    285e:	fa 4f       	sbci	r31, 0xFA	; 250
    2860:	21 87       	std	Z+9, r18	; 0x09
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    2862:	43 e1       	ldi	r20, 0x13	; 19
    2864:	64 e0       	ldi	r22, 0x04	; 4
    2866:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    286a:	80 91 5c 05 	lds	r24, 0x055C
			}
		}
		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
    286e:	81 ff       	sbrs	r24, 1
    2870:	14 c0       	rjmp	.+40     	; 0x289a <DoSampler+0x274>
		{
			if(bankStates[currentBank].halfSpeed==false)
    2872:	80 91 67 05 	lds	r24, 0x0567
    2876:	44 e2       	ldi	r20, 0x24	; 36
    2878:	84 9f       	mul	r24, r20
    287a:	f0 01       	movw	r30, r0
    287c:	11 24       	eor	r1, r1
    287e:	eb 51       	subi	r30, 0x1B	; 27
    2880:	fa 4f       	sbci	r31, 0xFA	; 250
    2882:	92 81       	ldd	r25, Z+2	; 0x02
    2884:	91 11       	cpse	r25, r1
    2886:	85 c1       	rjmp	.+778    	; 0x2b92 <DoSampler+0x56c>
			{
				bankStates[currentBank].halfSpeed=true;
    2888:	91 e0       	ldi	r25, 0x01	; 1
    288a:	92 83       	std	Z+2, r25	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    288c:	20 e4       	ldi	r18, 0x40	; 64
    288e:	40 e1       	ldi	r20, 0x10	; 16
    2890:	64 e0       	ldi	r22, 0x04	; 4
    2892:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2896:	80 91 5c 05 	lds	r24, 0x055C
			{
				bankStates[currentBank].halfSpeed=false;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
    289a:	82 fd       	sbrc	r24, 2
    289c:	95 c2       	rjmp	.+1322   	; 0x2dc8 <DoSampler+0x7a2>
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
		}
		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- reshuffle if the encoder moves OR we get a new button press, but not just while the button is held
    289e:	80 91 5d 05 	lds	r24, 0x055D
    28a2:	83 ff       	sbrs	r24, 3
    28a4:	04 c0       	rjmp	.+8      	; 0x28ae <DoSampler+0x288>
    28a6:	90 91 59 05 	lds	r25, 0x0559
    28aa:	91 11       	cpse	r25, r1
    28ac:	04 c0       	rjmp	.+8      	; 0x28b6 <DoSampler+0x290>
    28ae:	90 91 5c 05 	lds	r25, 0x055C
    28b2:	93 ff       	sbrs	r25, 3
    28b4:	12 c0       	rjmp	.+36     	; 0x28da <DoSampler+0x2b4>
		{
			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
    28b6:	20 91 58 05 	lds	r18, 0x0558
    28ba:	26 95       	lsr	r18
    28bc:	10 91 67 05 	lds	r17, 0x0567
    28c0:	62 2f       	mov	r22, r18
    28c2:	81 2f       	mov	r24, r17
    28c4:	29 83       	std	Y+1, r18	; 0x01
    28c6:	0e 94 bc 09 	call	0x1378	; 0x1378 <MakeNewGranularArray>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    28ca:	29 81       	ldd	r18, Y+1	; 0x01
    28cc:	44 e1       	ldi	r20, 0x14	; 20
    28ce:	64 e0       	ldi	r22, 0x04	; 4
    28d0:	81 2f       	mov	r24, r17
    28d2:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    28d6:	80 91 5d 05 	lds	r24, 0x055D
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
    28da:	84 ff       	sbrs	r24, 4
    28dc:	04 c0       	rjmp	.+8      	; 0x28e6 <DoSampler+0x2c0>
		{
			if(newEncoder)	// Only change to new values
    28de:	80 91 59 05 	lds	r24, 0x0559
    28e2:	81 11       	cpse	r24, r1
    28e4:	41 c1       	rjmp	.+642    	; 0x2b68 <DoSampler+0x542>
					default:
					break;
				}
			}
		}
		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
    28e6:	80 91 5c 05 	lds	r24, 0x055C
    28ea:	85 ff       	sbrs	r24, 5
    28ec:	16 c0       	rjmp	.+44     	; 0x291a <DoSampler+0x2f4>
		{
			if(bankStates[currentBank].backwardsPlayback==false)
    28ee:	80 91 67 05 	lds	r24, 0x0567
    28f2:	b4 e2       	ldi	r27, 0x24	; 36
    28f4:	8b 9f       	mul	r24, r27
    28f6:	f0 01       	movw	r30, r0
    28f8:	11 24       	eor	r1, r1
    28fa:	eb 51       	subi	r30, 0x1B	; 27
    28fc:	fa 4f       	sbci	r31, 0xFA	; 250
    28fe:	93 81       	ldd	r25, Z+3	; 0x03
    2900:	91 11       	cpse	r25, r1
    2902:	2b c1       	rjmp	.+598    	; 0x2b5a <DoSampler+0x534>
			{
				bankStates[currentBank].backwardsPlayback=true;
    2904:	91 e0       	ldi	r25, 0x01	; 1
    2906:	93 83       	std	Z+3, r25	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2908:	20 e4       	ldi	r18, 0x40	; 64
    290a:	41 e1       	ldi	r20, 0x11	; 17
    290c:	64 e0       	ldi	r22, 0x04	; 4
    290e:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
			{
				bankStates[currentBank].backwardsPlayback=false;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
			}

			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2912:	80 91 67 05 	lds	r24, 0x0567
    2916:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
	{
		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI

		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
    291a:	80 91 61 06 	lds	r24, 0x0661
    291e:	88 23       	and	r24, r24
    2920:	09 f4       	brne	.+2      	; 0x2924 <DoSampler+0x2fe>
    2922:	91 ce       	rjmp	.-734    	; 0x2646 <DoSampler+0x20>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    2924:	8a e6       	ldi	r24, 0x6A	; 106
    2926:	95 e0       	ldi	r25, 0x05	; 5
    2928:	0e 94 7e 27 	call	0x4efc	; 0x4efc <GetMidiMessageFromIncomingFifo>
//			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
//			{
//				// Do this here.
//			}

			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    292c:	40 91 6b 05 	lds	r20, 0x056B
    2930:	42 30       	cpi	r20, 0x02	; 2
    2932:	09 f4       	brne	.+2      	; 0x2936 <DoSampler+0x310>
    2934:	9f c2       	rjmp	.+1342   	; 0x2e74 <DoSampler+0x84e>
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    2936:	41 30       	cpi	r20, 0x01	; 1
    2938:	09 f4       	brne	.+2      	; 0x293c <DoSampler+0x316>
    293a:	c2 c2       	rjmp	.+1412   	; 0x2ec0 <DoSampler+0x89a>
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    293c:	44 30       	cpi	r20, 0x04	; 4
    293e:	09 f4       	brne	.+2      	; 0x2942 <DoSampler+0x31c>
    2940:	6a c3       	rjmp	.+1748   	; 0x3016 <DoSampler+0x9f0>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    2942:	47 30       	cpi	r20, 0x07	; 7
    2944:	09 f0       	breq	.+2      	; 0x2948 <DoSampler+0x322>
    2946:	7f ce       	rjmp	.-770    	; 0x2646 <DoSampler+0x20>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    2948:	20 91 6d 05 	lds	r18, 0x056D
    294c:	80 91 6c 05 	lds	r24, 0x056C
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	e0 e8       	ldi	r30, 0x80	; 128
    2954:	2e 9f       	mul	r18, r30
    2956:	80 0d       	add	r24, r0
    2958:	91 1d       	adc	r25, r1
    295a:	11 24       	eor	r1, r1

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    295c:	81 15       	cp	r24, r1
    295e:	f0 e2       	ldi	r31, 0x20	; 32
    2960:	9f 07       	cpc	r25, r31
    2962:	09 f4       	brne	.+2      	; 0x2966 <DoSampler+0x340>
    2964:	d4 c6       	rjmp	.+3496   	; 0x370e <DoSampler+0x10e8>
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    2966:	40 91 6a 05 	lds	r20, 0x056A
    296a:	50 e0       	ldi	r21, 0x00	; 0
    296c:	fa 01       	movw	r30, r20
    296e:	ec 5f       	subi	r30, 0xFC	; 252
    2970:	fe 4f       	sbci	r31, 0xFE	; 254
    2972:	70 81       	ld	r23, Z
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    2974:	20 e0       	ldi	r18, 0x00	; 0
    2976:	30 e2       	ldi	r19, 0x20	; 32
    2978:	28 1b       	sub	r18, r24
    297a:	39 0b       	sbc	r19, r25
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    297c:	6b ea       	ldi	r22, 0xAB	; 171
    297e:	76 9f       	mul	r23, r22
    2980:	61 2d       	mov	r22, r1
    2982:	11 24       	eor	r1, r1
    2984:	66 95       	lsr	r22
    2986:	66 95       	lsr	r22
    2988:	66 95       	lsr	r22
    298a:	86 2f       	mov	r24, r22
    298c:	88 0f       	add	r24, r24
    298e:	86 0f       	add	r24, r22
    2990:	88 0f       	add	r24, r24
    2992:	88 0f       	add	r24, r24
    2994:	78 1b       	sub	r23, r24

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2996:	e7 2f       	mov	r30, r23
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	ee 0f       	add	r30, r30
    299c:	ff 1f       	adc	r31, r31
    299e:	ea 5f       	subi	r30, 0xFA	; 250
    29a0:	fe 4f       	sbci	r31, 0xFE	; 254
    29a2:	80 81       	ld	r24, Z
    29a4:	91 81       	ldd	r25, Z+1	; 0x01
    29a6:	02 c0       	rjmp	.+4      	; 0x29ac <DoSampler+0x386>
    29a8:	96 95       	lsr	r25
    29aa:	87 95       	ror	r24
    29ac:	6a 95       	dec	r22
    29ae:	e2 f7       	brpl	.-8      	; 0x29a8 <DoSampler+0x382>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    29b0:	28 0f       	add	r18, r24
    29b2:	39 1f       	adc	r19, r25
    29b4:	84 e2       	ldi	r24, 0x24	; 36
    29b6:	84 9f       	mul	r24, r20
    29b8:	f0 01       	movw	r30, r0
    29ba:	85 9f       	mul	r24, r21
    29bc:	f0 0d       	add	r31, r0
    29be:	11 24       	eor	r1, r1
    29c0:	eb 51       	subi	r30, 0x1B	; 27
    29c2:	fa 4f       	sbci	r31, 0xFA	; 250
    29c4:	34 87       	std	Z+12, r19	; 0x0c
    29c6:	23 87       	std	Z+11, r18	; 0x0b
    29c8:	60 91 4f 05 	lds	r22, 0x054F
    29cc:	3e ce       	rjmp	.-900    	; 0x264a <DoSampler+0x24>
		temp|=Om_LED_ODUB;
	}

	if(outOfRam==true)
	{
		temp|=Om_LED_OUT_OF_MEM;
    29ce:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    29d0:	31 30       	cpi	r19, 0x01	; 1
    29d2:	09 f0       	breq	.+2      	; 0x29d6 <DoSampler+0x3b0>
    29d4:	cf ce       	rjmp	.-610    	; 0x2774 <DoSampler+0x14e>
	{
		temp|=Om_LED_BANK;
    29d6:	20 61       	ori	r18, 0x10	; 16
    29d8:	cd ce       	rjmp	.-614    	; 0x2774 <DoSampler+0x14e>
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    29da:	27 60       	ori	r18, 0x07	; 7
    29dc:	c3 ce       	rjmp	.-634    	; 0x2764 <DoSampler+0x13e>

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
	{
		temp|=Om_LED_REC;
    29de:	21 60       	ori	r18, 0x01	; 1
    29e0:	9d ce       	rjmp	.-710    	; 0x271c <DoSampler+0xf6>
	{
		temp|=Om_LED_PLAY;
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
	{
		temp|=Om_LED_ODUB;
    29e2:	22 60       	ori	r18, 0x02	; 2
    29e4:	b3 ce       	rjmp	.-666    	; 0x274c <DoSampler+0x126>
	{
		temp|=Om_LED_REC;
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
	{
		temp|=Om_LED_PLAY;
    29e6:	24 60       	ori	r18, 0x04	; 4
    29e8:	a5 ce       	rjmp	.-694    	; 0x2734 <DoSampler+0x10e>
		}
	}
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
    29ea:	87 fd       	sbrc	r24, 7
    29ec:	1c c2       	rjmp	.+1080   	; 0x2e26 <DoSampler+0x800>
	// -----------------------------------------------------------------------------------
	// No shift keys pressed:
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
    29ee:	80 91 5c 05 	lds	r24, 0x055C
    29f2:	80 ff       	sbrs	r24, 0
    29f4:	38 c0       	rjmp	.+112    	; 0x2a66 <DoSampler+0x440>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    29f6:	10 91 67 05 	lds	r17, 0x0567
    29fa:	21 2f       	mov	r18, r17
    29fc:	30 e0       	ldi	r19, 0x00	; 0
    29fe:	84 e2       	ldi	r24, 0x24	; 36
    2a00:	18 9f       	mul	r17, r24
    2a02:	f0 01       	movw	r30, r0
    2a04:	11 24       	eor	r1, r1
    2a06:	eb 51       	subi	r30, 0x1B	; 27
    2a08:	fa 4f       	sbci	r31, 0xFA	; 250
    2a0a:	80 81       	ld	r24, Z
    2a0c:	83 30       	cpi	r24, 0x03	; 3
    2a0e:	09 f4       	brne	.+2      	; 0x2a12 <DoSampler+0x3ec>
    2a10:	46 c1       	rjmp	.+652    	; 0x2c9e <DoSampler+0x678>
				bankStates[currentBank].loopOnce=false;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
			else											// We're not recording right now, so start doing it.
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2a12:	40 e0       	ldi	r20, 0x00	; 0
    2a14:	50 e0       	ldi	r21, 0x00	; 0
    2a16:	61 e0       	ldi	r22, 0x01	; 1
    2a18:	81 2f       	mov	r24, r17
    2a1a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <StartRecording>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2a1e:	20 e3       	ldi	r18, 0x30	; 48
    2a20:	43 e0       	ldi	r20, 0x03	; 3
    2a22:	64 e0       	ldi	r22, 0x04	; 4
    2a24:	81 2f       	mov	r24, r17
    2a26:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2a2a:	77 cf       	rjmp	.-274    	; 0x291a <DoSampler+0x2f4>
    2a2c:	83 2f       	mov	r24, r19
    2a2e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a30:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a32:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a34:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a36:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a38:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a3a:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a3c:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a3e:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a40:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a42:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a44:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a46:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a48:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a4a:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    2a4c:	88 0f       	add	r24, r24
    2a4e:	89 2f       	mov	r24, r25
    2a50:	88 1f       	adc	r24, r24
    2a52:	99 0b       	sbc	r25, r25
    2a54:	89 2b       	or	r24, r25
    2a56:	09 f0       	breq	.+2      	; 0x2a5a <DoSampler+0x434>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    2a58:	2f 77       	andi	r18, 0x7F	; 127
    2a5a:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    2a5e:	84 e0       	ldi	r24, 0x04	; 4
    2a60:	80 93 b1 05 	sts	0x05B1, r24
    2a64:	ba ce       	rjmp	.-652    	; 0x27da <DoSampler+0x1b4>
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2a66:	81 ff       	sbrs	r24, 1
    2a68:	9d c0       	rjmp	.+314    	; 0x2ba4 <DoSampler+0x57e>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    2a6a:	e0 91 67 05 	lds	r30, 0x0567
    2a6e:	8e 2f       	mov	r24, r30
    2a70:	ee 2e       	mov	r14, r30
    2a72:	f1 2c       	mov	r15, r1
    2a74:	94 e2       	ldi	r25, 0x24	; 36
    2a76:	e9 9f       	mul	r30, r25
    2a78:	d0 01       	movw	r26, r0
    2a7a:	11 24       	eor	r1, r1
    2a7c:	ab 51       	subi	r26, 0x1B	; 27
    2a7e:	ba 4f       	sbci	r27, 0xFA	; 250
    2a80:	9c 91       	ld	r25, X
    2a82:	95 30       	cpi	r25, 0x05	; 5
    2a84:	09 f4       	brne	.+2      	; 0x2a88 <DoSampler+0x462>
    2a86:	bf c6       	rjmp	.+3454   	; 0x3806 <DoSampler+0x11e0>
				bankStates[currentBank].loopOnce=false;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
			}
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2a88:	51 96       	adiw	r26, 0x11	; 17
    2a8a:	0d 91       	ld	r16, X+
    2a8c:	1d 91       	ld	r17, X+
    2a8e:	2d 91       	ld	r18, X+
    2a90:	3c 91       	ld	r19, X
    2a92:	54 97       	sbiw	r26, 0x14	; 20
    2a94:	1d 96       	adiw	r26, 0x0d	; 13
    2a96:	4d 91       	ld	r20, X+
    2a98:	5d 91       	ld	r21, X+
    2a9a:	6d 91       	ld	r22, X+
    2a9c:	7c 91       	ld	r23, X
    2a9e:	50 97       	sbiw	r26, 0x10	; 16
    2aa0:	04 17       	cp	r16, r20
    2aa2:	15 07       	cpc	r17, r21
    2aa4:	26 07       	cpc	r18, r22
    2aa6:	37 07       	cpc	r19, r23
    2aa8:	09 f4       	brne	.+2      	; 0x2aac <DoSampler+0x486>
    2aaa:	37 cf       	rjmp	.-402    	; 0x291a <DoSampler+0x2f4>
// Continue playing back from that address, too.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2aac:	15 96       	adiw	r26, 0x05	; 5
    2aae:	9c 91       	ld	r25, X
    2ab0:	99 23       	and	r25, r25
    2ab2:	29 f0       	breq	.+10     	; 0x2abe <DoSampler+0x498>
    2ab4:	90 91 4f 05 	lds	r25, 0x054F
    2ab8:	91 50       	subi	r25, 0x01	; 1
    2aba:	92 30       	cpi	r25, 0x02	; 2
    2abc:	a0 f1       	brcs	.+104    	; 0x2b26 <DoSampler+0x500>
	{
		sreg=SREG;	// Store global interrupt state.
    2abe:	8f b7       	in	r24, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2ac0:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    2ac2:	94 e2       	ldi	r25, 0x24	; 36
    2ac4:	9e 9d       	mul	r25, r14
    2ac6:	d0 01       	movw	r26, r0
    2ac8:	9f 9d       	mul	r25, r15
    2aca:	b0 0d       	add	r27, r0
    2acc:	11 24       	eor	r1, r1
    2ace:	ab 51       	subi	r26, 0x1B	; 27
    2ad0:	ba 4f       	sbci	r27, 0xFA	; 250
    2ad2:	95 e0       	ldi	r25, 0x05	; 5
    2ad4:	9c 93       	st	X, r25

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2ad6:	91 e0       	ldi	r25, 0x01	; 1
    2ad8:	1a 96       	adiw	r26, 0x0a	; 10
    2ada:	9c 93       	st	X, r25
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    2adc:	ee 23       	and	r30, r30
    2ade:	09 f4       	brne	.+2      	; 0x2ae2 <DoSampler+0x4bc>
    2ae0:	5c c6       	rjmp	.+3256   	; 0x379a <DoSampler+0x1174>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    2ae2:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    2ae4:	94 e0       	ldi	r25, 0x04	; 4
    2ae6:	90 93 68 00 	sts	0x0068, r25
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    2aea:	90 e1       	ldi	r25, 0x10	; 16
    2aec:	90 93 6d 00 	sts	0x006D, r25
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2af0:	94 e2       	ldi	r25, 0x24	; 36
    2af2:	9e 9d       	mul	r25, r14
    2af4:	f0 01       	movw	r30, r0
    2af6:	9f 9d       	mul	r25, r15
    2af8:	f0 0d       	add	r31, r0
    2afa:	11 24       	eor	r1, r1
    2afc:	eb 51       	subi	r30, 0x1B	; 27
    2afe:	fa 4f       	sbci	r31, 0xFA	; 250
    2b00:	91 e0       	ldi	r25, 0x01	; 1
    2b02:	95 83       	std	Z+5, r25	; 0x05
		SREG=sreg;		// Restore interrupts.
    2b04:	8f bf       	out	0x3f, r24	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2b06:	80 91 7a 00 	lds	r24, 0x007A
    2b0a:	86 fd       	sbrc	r24, 6
    2b0c:	0a c0       	rjmp	.+20     	; 0x2b22 <DoSampler+0x4fc>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    2b0e:	80 91 79 00 	lds	r24, 0x0079
    2b12:	80 58       	subi	r24, 0x80	; 128
    2b14:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2b18:	80 91 7a 00 	lds	r24, 0x007A
    2b1c:	80 64       	ori	r24, 0x40	; 64
    2b1e:	80 93 7a 00 	sts	0x007A, r24
    2b22:	80 91 67 05 	lds	r24, 0x0567
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
				{
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2b26:	20 e3       	ldi	r18, 0x30	; 48
    2b28:	49 e0       	ldi	r20, 0x09	; 9
    2b2a:	64 e0       	ldi	r22, 0x04	; 4
    2b2c:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2b30:	f4 ce       	rjmp	.-536    	; 0x291a <DoSampler+0x2f4>
	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
    2b32:	80 91 5c 05 	lds	r24, 0x055C
    2b36:	85 fd       	sbrc	r24, 5
    2b38:	06 c1       	rjmp	.+524    	; 0x2d46 <DoSampler+0x720>
			bankStates[currentBank].loopOnce=false;
			bankStates[currentBank].realtimeOn=false;
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
		}
		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
    2b3a:	80 ff       	sbrs	r24, 0
    2b3c:	ee ce       	rjmp	.-548    	; 0x291a <DoSampler+0x2f4>
		{
			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
    2b3e:	80 91 5e 05 	lds	r24, 0x055E
    2b42:	8e 30       	cpi	r24, 0x0E	; 14
    2b44:	09 f0       	breq	.+2      	; 0x2b48 <DoSampler+0x522>
    2b46:	e9 ce       	rjmp	.-558    	; 0x291a <DoSampler+0x2f4>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2b48:	8c ec       	ldi	r24, 0xCC	; 204
    2b4a:	9e e1       	ldi	r25, 0x1E	; 30
    2b4c:	90 93 e4 05 	sts	0x05E4, r25
    2b50:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    2b54:	10 92 60 05 	sts	0x0560, r1
    2b58:	e0 ce       	rjmp	.-576    	; 0x291a <DoSampler+0x2f4>
				bankStates[currentBank].backwardsPlayback=true;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
			else
			{
				bankStates[currentBank].backwardsPlayback=false;
    2b5a:	13 82       	std	Z+3, r1	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2b5c:	20 e0       	ldi	r18, 0x00	; 0
    2b5e:	41 e1       	ldi	r20, 0x11	; 17
    2b60:	64 e0       	ldi	r22, 0x04	; 4
    2b62:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2b66:	d5 ce       	rjmp	.-598    	; 0x2912 <DoSampler+0x2ec>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
		{
			if(newEncoder)	// Only change to new values
			{
				switch(scaledEncoderValue)
    2b68:	80 91 70 05 	lds	r24, 0x0570
    2b6c:	81 30       	cpi	r24, 0x01	; 1
    2b6e:	09 f4       	brne	.+2      	; 0x2b72 <DoSampler+0x54c>
    2b70:	fa c4       	rjmp	.+2548   	; 0x3566 <DoSampler+0xf40>
    2b72:	08 f0       	brcs	.+2      	; 0x2b76 <DoSampler+0x550>
    2b74:	c9 c4       	rjmp	.+2450   	; 0x3508 <DoSampler+0xee2>
				{
					case 0:
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2b76:	8c e0       	ldi	r24, 0x0C	; 12
    2b78:	99 e0       	ldi	r25, 0x09	; 9
    2b7a:	90 93 e2 05 	sts	0x05E2, r25
    2b7e:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2b82:	20 e0       	ldi	r18, 0x00	; 0
    2b84:	46 e1       	ldi	r20, 0x16	; 22
    2b86:	64 e0       	ldi	r22, 0x04	; 4
    2b88:	80 91 67 05 	lds	r24, 0x0567
    2b8c:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2b90:	aa ce       	rjmp	.-684    	; 0x28e6 <DoSampler+0x2c0>
				bankStates[currentBank].halfSpeed=true;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
			else
			{
				bankStates[currentBank].halfSpeed=false;
    2b92:	12 82       	std	Z+2, r1	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    2b94:	20 e0       	ldi	r18, 0x00	; 0
    2b96:	40 e1       	ldi	r20, 0x10	; 16
    2b98:	64 e0       	ldi	r22, 0x04	; 4
    2b9a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2b9e:	80 91 5c 05 	lds	r24, 0x055C
    2ba2:	7b ce       	rjmp	.-778    	; 0x289a <DoSampler+0x274>
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
				}
			}
		}
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
    2ba4:	82 ff       	sbrs	r24, 2
    2ba6:	35 c4       	rjmp	.+2154   	; 0x3412 <DoSampler+0xdec>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2ba8:	80 91 67 05 	lds	r24, 0x0567
    2bac:	e8 2f       	mov	r30, r24
    2bae:	f0 e0       	ldi	r31, 0x00	; 0
    2bb0:	24 e2       	ldi	r18, 0x24	; 36
    2bb2:	82 9f       	mul	r24, r18
    2bb4:	d0 01       	movw	r26, r0
    2bb6:	11 24       	eor	r1, r1
    2bb8:	ab 51       	subi	r26, 0x1B	; 27
    2bba:	ba 4f       	sbci	r27, 0xFA	; 250
    2bbc:	51 96       	adiw	r26, 0x11	; 17
    2bbe:	0d 91       	ld	r16, X+
    2bc0:	1d 91       	ld	r17, X+
    2bc2:	2d 91       	ld	r18, X+
    2bc4:	3c 91       	ld	r19, X
    2bc6:	54 97       	sbiw	r26, 0x14	; 20
    2bc8:	1d 96       	adiw	r26, 0x0d	; 13
    2bca:	4d 91       	ld	r20, X+
    2bcc:	5d 91       	ld	r21, X+
    2bce:	6d 91       	ld	r22, X+
    2bd0:	7c 91       	ld	r23, X
    2bd2:	50 97       	sbiw	r26, 0x10	; 16
    2bd4:	04 17       	cp	r16, r20
    2bd6:	15 07       	cpc	r17, r21
    2bd8:	26 07       	cpc	r18, r22
    2bda:	37 07       	cpc	r19, r23
    2bdc:	09 f4       	brne	.+2      	; 0x2be0 <DoSampler+0x5ba>
    2bde:	9d ce       	rjmp	.-710    	; 0x291a <DoSampler+0x2f4>
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2be0:	15 96       	adiw	r26, 0x05	; 5
    2be2:	9c 91       	ld	r25, X
    2be4:	99 23       	and	r25, r25
    2be6:	31 f0       	breq	.+12     	; 0x2bf4 <DoSampler+0x5ce>
    2be8:	90 91 4f 05 	lds	r25, 0x054F
    2bec:	91 50       	subi	r25, 0x01	; 1
    2bee:	92 30       	cpi	r25, 0x02	; 2
    2bf0:	08 f4       	brcc	.+2      	; 0x2bf4 <DoSampler+0x5ce>
    2bf2:	45 c0       	rjmp	.+138    	; 0x2c7e <DoSampler+0x658>
	{
		sreg=SREG;	// Store global interrupt state.
    2bf4:	9f b7       	in	r25, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2bf6:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    2bf8:	24 e2       	ldi	r18, 0x24	; 36
    2bfa:	2e 9f       	mul	r18, r30
    2bfc:	d0 01       	movw	r26, r0
    2bfe:	2f 9f       	mul	r18, r31
    2c00:	b0 0d       	add	r27, r0
    2c02:	11 24       	eor	r1, r1
    2c04:	ab 51       	subi	r26, 0x1B	; 27
    2c06:	ba 4f       	sbci	r27, 0xFA	; 250
    2c08:	24 e0       	ldi	r18, 0x04	; 4
    2c0a:	2c 93       	st	X, r18

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    2c0c:	13 96       	adiw	r26, 0x03	; 3
    2c0e:	2c 91       	ld	r18, X
    2c10:	13 97       	sbiw	r26, 0x03	; 3
    2c12:	22 23       	and	r18, r18
    2c14:	09 f4       	brne	.+2      	; 0x2c18 <DoSampler+0x5f2>
    2c16:	cd c5       	rjmp	.+2970   	; 0x37b2 <DoSampler+0x118c>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    2c18:	55 96       	adiw	r26, 0x15	; 21
    2c1a:	4d 91       	ld	r20, X+
    2c1c:	5d 91       	ld	r21, X+
    2c1e:	6d 91       	ld	r22, X+
    2c20:	7c 91       	ld	r23, X
    2c22:	58 97       	sbiw	r26, 0x18	; 24
    2c24:	90 96       	adiw	r26, 0x20	; 32
    2c26:	4d 93       	st	X+, r20
    2c28:	5d 93       	st	X+, r21
    2c2a:	6d 93       	st	X+, r22
    2c2c:	7c 93       	st	X, r23
    2c2e:	93 97       	sbiw	r26, 0x23	; 35
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    2c30:	14 96       	adiw	r26, 0x04	; 4
    2c32:	1c 92       	st	X, r1

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2c34:	24 e2       	ldi	r18, 0x24	; 36
    2c36:	2e 9f       	mul	r18, r30
    2c38:	d0 01       	movw	r26, r0
    2c3a:	2f 9f       	mul	r18, r31
    2c3c:	b0 0d       	add	r27, r0
    2c3e:	11 24       	eor	r1, r1
    2c40:	ab 51       	subi	r26, 0x1B	; 27
    2c42:	ba 4f       	sbci	r27, 0xFA	; 250
    2c44:	21 e0       	ldi	r18, 0x01	; 1
    2c46:	1a 96       	adiw	r26, 0x0a	; 10
    2c48:	2c 93       	st	X, r18
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    2c4a:	88 23       	and	r24, r24
    2c4c:	09 f4       	brne	.+2      	; 0x2c50 <DoSampler+0x62a>
    2c4e:	18 c6       	rjmp	.+3120   	; 0x3880 <DoSampler+0x125a>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    2c50:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    2c52:	84 e0       	ldi	r24, 0x04	; 4
    2c54:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    2c58:	80 e1       	ldi	r24, 0x10	; 16
    2c5a:	80 93 6d 00 	sts	0x006D, r24
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2c5e:	84 e2       	ldi	r24, 0x24	; 36
    2c60:	8e 9f       	mul	r24, r30
    2c62:	d0 01       	movw	r26, r0
    2c64:	8f 9f       	mul	r24, r31
    2c66:	b0 0d       	add	r27, r0
    2c68:	11 24       	eor	r1, r1
    2c6a:	ab 51       	subi	r26, 0x1B	; 27
    2c6c:	ba 4f       	sbci	r27, 0xFA	; 250
    2c6e:	81 e0       	ldi	r24, 0x01	; 1
    2c70:	15 96       	adiw	r26, 0x05	; 5
    2c72:	8c 93       	st	X, r24
		SREG=sreg;		// Restore interrupts.
    2c74:	9f bf       	out	0x3f, r25	; 63
    2c76:	80 91 67 05 	lds	r24, 0x0567
    2c7a:	e8 2f       	mov	r30, r24
    2c7c:	f0 e0       	ldi	r31, 0x00	; 0
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
				bankStates[currentBank].loopOnce=false;
    2c7e:	94 e2       	ldi	r25, 0x24	; 36
    2c80:	9e 9f       	mul	r25, r30
    2c82:	d0 01       	movw	r26, r0
    2c84:	9f 9f       	mul	r25, r31
    2c86:	b0 0d       	add	r27, r0
    2c88:	11 24       	eor	r1, r1
    2c8a:	ab 51       	subi	r26, 0x1B	; 27
    2c8c:	ba 4f       	sbci	r27, 0xFA	; 250
    2c8e:	11 96       	adiw	r26, 0x01	; 1
    2c90:	1c 92       	st	X, r1
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2c92:	20 e4       	ldi	r18, 0x40	; 64
    2c94:	40 e3       	ldi	r20, 0x30	; 48
    2c96:	61 e0       	ldi	r22, 0x01	; 1
    2c98:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2c9c:	3e ce       	rjmp	.-900    	; 0x291a <DoSampler+0x2f4>
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2c9e:	85 81       	ldd	r24, Z+5	; 0x05
    2ca0:	88 23       	and	r24, r24
    2ca2:	29 f0       	breq	.+10     	; 0x2cae <DoSampler+0x688>
    2ca4:	80 91 4f 05 	lds	r24, 0x054F
    2ca8:	81 50       	subi	r24, 0x01	; 1
    2caa:	82 30       	cpi	r24, 0x02	; 2
    2cac:	e0 f1       	brcs	.+120    	; 0x2d26 <DoSampler+0x700>
	{
		sreg=SREG;	// Store global interrupt state.
    2cae:	8f b7       	in	r24, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2cb0:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    2cb2:	94 e2       	ldi	r25, 0x24	; 36
    2cb4:	92 9f       	mul	r25, r18
    2cb6:	f0 01       	movw	r30, r0
    2cb8:	93 9f       	mul	r25, r19
    2cba:	f0 0d       	add	r31, r0
    2cbc:	11 24       	eor	r1, r1
    2cbe:	eb 51       	subi	r30, 0x1B	; 27
    2cc0:	fa 4f       	sbci	r31, 0xFA	; 250
    2cc2:	94 e0       	ldi	r25, 0x04	; 4
    2cc4:	90 83       	st	Z, r25

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    2cc6:	93 81       	ldd	r25, Z+3	; 0x03
    2cc8:	99 23       	and	r25, r25
    2cca:	09 f4       	brne	.+2      	; 0x2cce <DoSampler+0x6a8>
    2ccc:	68 c4       	rjmp	.+2256   	; 0x359e <DoSampler+0xf78>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    2cce:	45 89       	ldd	r20, Z+21	; 0x15
    2cd0:	56 89       	ldd	r21, Z+22	; 0x16
    2cd2:	67 89       	ldd	r22, Z+23	; 0x17
    2cd4:	70 8d       	ldd	r23, Z+24	; 0x18
    2cd6:	40 a3       	std	Z+32, r20	; 0x20
    2cd8:	51 a3       	std	Z+33, r21	; 0x21
    2cda:	62 a3       	std	Z+34, r22	; 0x22
    2cdc:	73 a3       	std	Z+35, r23	; 0x23
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    2cde:	14 82       	std	Z+4, r1	; 0x04

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2ce0:	94 e2       	ldi	r25, 0x24	; 36
    2ce2:	92 9f       	mul	r25, r18
    2ce4:	f0 01       	movw	r30, r0
    2ce6:	93 9f       	mul	r25, r19
    2ce8:	f0 0d       	add	r31, r0
    2cea:	11 24       	eor	r1, r1
    2cec:	eb 51       	subi	r30, 0x1B	; 27
    2cee:	fa 4f       	sbci	r31, 0xFA	; 250
    2cf0:	91 e0       	ldi	r25, 0x01	; 1
    2cf2:	92 87       	std	Z+10, r25	; 0x0a
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    2cf4:	11 23       	and	r17, r17
    2cf6:	09 f4       	brne	.+2      	; 0x2cfa <DoSampler+0x6d4>
    2cf8:	fe c4       	rjmp	.+2556   	; 0x36f6 <DoSampler+0x10d0>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    2cfa:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    2cfc:	94 e0       	ldi	r25, 0x04	; 4
    2cfe:	90 93 68 00 	sts	0x0068, r25
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    2d02:	90 e1       	ldi	r25, 0x10	; 16
    2d04:	90 93 6d 00 	sts	0x006D, r25
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2d08:	94 e2       	ldi	r25, 0x24	; 36
    2d0a:	92 9f       	mul	r25, r18
    2d0c:	f0 01       	movw	r30, r0
    2d0e:	93 9f       	mul	r25, r19
    2d10:	f0 0d       	add	r31, r0
    2d12:	11 24       	eor	r1, r1
    2d14:	eb 51       	subi	r30, 0x1B	; 27
    2d16:	fa 4f       	sbci	r31, 0xFA	; 250
    2d18:	91 e0       	ldi	r25, 0x01	; 1
    2d1a:	95 83       	std	Z+5, r25	; 0x05
		SREG=sreg;		// Restore interrupts.
    2d1c:	8f bf       	out	0x3f, r24	; 63
    2d1e:	10 91 67 05 	lds	r17, 0x0567
    2d22:	21 2f       	mov	r18, r17
    2d24:	30 e0       	ldi	r19, 0x00	; 0
		if(newKeys&Im_REC)										// Record switch pressed.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
				bankStates[currentBank].loopOnce=false;
    2d26:	84 e2       	ldi	r24, 0x24	; 36
    2d28:	82 9f       	mul	r24, r18
    2d2a:	f0 01       	movw	r30, r0
    2d2c:	83 9f       	mul	r24, r19
    2d2e:	f0 0d       	add	r31, r0
    2d30:	11 24       	eor	r1, r1
    2d32:	eb 51       	subi	r30, 0x1B	; 27
    2d34:	fa 4f       	sbci	r31, 0xFA	; 250
    2d36:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2d38:	20 e4       	ldi	r18, 0x40	; 64
    2d3a:	40 e3       	ldi	r20, 0x30	; 48
    2d3c:	61 e0       	ldi	r22, 0x01	; 1
    2d3e:	81 2f       	mov	r24, r17
    2d40:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2d44:	ea cd       	rjmp	.-1068   	; 0x291a <DoSampler+0x2f4>
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2d46:	8c e0       	ldi	r24, 0x0C	; 12
    2d48:	99 e0       	ldi	r25, 0x09	; 9
    2d4a:	90 93 e2 05 	sts	0x05E2, r25
    2d4e:	80 93 e1 05 	sts	0x05E1, r24
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    2d52:	e0 91 67 05 	lds	r30, 0x0567
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    2d56:	3f b7       	in	r19, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    2d58:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    2d5a:	24 e2       	ldi	r18, 0x24	; 36
    2d5c:	2e 9f       	mul	r18, r30
    2d5e:	f0 01       	movw	r30, r0
    2d60:	11 24       	eor	r1, r1
    2d62:	eb 51       	subi	r30, 0x1B	; 27
    2d64:	fa 4f       	sbci	r31, 0xFA	; 250
    2d66:	81 89       	ldd	r24, Z+17	; 0x11
    2d68:	92 89       	ldd	r25, Z+18	; 0x12
    2d6a:	a3 89       	ldd	r26, Z+19	; 0x13
    2d6c:	b4 89       	ldd	r27, Z+20	; 0x14
    2d6e:	81 8f       	std	Z+25, r24	; 0x19
    2d70:	92 8f       	std	Z+26, r25	; 0x1a
    2d72:	a3 8f       	std	Z+27, r26	; 0x1b
    2d74:	b4 8f       	std	Z+28, r27	; 0x1c
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    2d76:	85 85       	ldd	r24, Z+13	; 0x0d
    2d78:	96 85       	ldd	r25, Z+14	; 0x0e
    2d7a:	a7 85       	ldd	r26, Z+15	; 0x0f
    2d7c:	b0 89       	ldd	r27, Z+16	; 0x10
    2d7e:	85 8b       	std	Z+21, r24	; 0x15
    2d80:	96 8b       	std	Z+22, r25	; 0x16
    2d82:	a7 8b       	std	Z+23, r26	; 0x17
    2d84:	b0 8f       	std	Z+24, r27	; 0x18
	bankStates[theBank].sampleStartOffset=0;
    2d86:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleEndOffset=0;
    2d88:	16 8e       	std	Z+30, r1	; 0x1e
	bankStates[theBank].sampleWindowOffset=0;
    2d8a:	17 8e       	std	Z+31, r1	; 0x1f
	SREG=sreg;		// Restore interrupts.
    2d8c:	3f bf       	out	0x3f, r19	; 63
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
			bankStates[currentBank].bitReduction=0;			// No crusties yet.
    2d8e:	80 91 67 05 	lds	r24, 0x0567
    2d92:	28 9f       	mul	r18, r24
    2d94:	f0 01       	movw	r30, r0
    2d96:	11 24       	eor	r1, r1
    2d98:	eb 51       	subi	r30, 0x1B	; 27
    2d9a:	fa 4f       	sbci	r31, 0xFA	; 250
    2d9c:	11 86       	std	Z+9, r1	; 0x09
			bankStates[currentBank].jitterValue=0;			// No hissies yet.
    2d9e:	10 86       	std	Z+8, r1	; 0x08
			bankStates[currentBank].granularSlices=0;		// No remix yet.
    2da0:	17 82       	std	Z+7, r1	; 0x07
			bankStates[currentBank].halfSpeed=false;
    2da2:	12 82       	std	Z+2, r1	; 0x02
			bankStates[currentBank].backwardsPlayback=false;
    2da4:	13 82       	std	Z+3, r1	; 0x03
			bankStates[currentBank].sampleDirection=true;
    2da6:	91 e0       	ldi	r25, 0x01	; 1
    2da8:	94 83       	std	Z+4, r25	; 0x04
			bankStates[currentBank].loopOnce=false;
    2daa:	11 82       	std	Z+1, r1	; 0x01
			bankStates[currentBank].realtimeOn=false;
    2dac:	16 82       	std	Z+6, r1	; 0x06
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
    2dae:	20 e0       	ldi	r18, 0x00	; 0
    2db0:	42 e1       	ldi	r20, 0x12	; 18
    2db2:	64 e0       	ldi	r22, 0x04	; 4
    2db4:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
    2db8:	20 e0       	ldi	r18, 0x00	; 0
    2dba:	4b e1       	ldi	r20, 0x1B	; 27
    2dbc:	64 e0       	ldi	r22, 0x04	; 4
    2dbe:	80 91 67 05 	lds	r24, 0x0567
    2dc2:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2dc6:	a9 cd       	rjmp	.-1198   	; 0x291a <DoSampler+0x2f4>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
    2dc8:	80 91 67 05 	lds	r24, 0x0567
// OK to do realtime even when banks are locked since we don't use the RAM
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    2dcc:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    2dce:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    2dd0:	a4 e2       	ldi	r26, 0x24	; 36
    2dd2:	8a 9f       	mul	r24, r26
    2dd4:	f0 01       	movw	r30, r0
    2dd6:	11 24       	eor	r1, r1
    2dd8:	eb 51       	subi	r30, 0x1B	; 27
    2dda:	fa 4f       	sbci	r31, 0xFA	; 250
    2ddc:	22 e0       	ldi	r18, 0x02	; 2
    2dde:	20 83       	st	Z, r18

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2de0:	21 e0       	ldi	r18, 0x01	; 1
    2de2:	22 87       	std	Z+10, r18	; 0x0a
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    2de4:	88 23       	and	r24, r24
    2de6:	09 f4       	brne	.+2      	; 0x2dea <DoSampler+0x7c4>
    2de8:	08 c3       	rjmp	.+1552   	; 0x33fa <DoSampler+0xdd4>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    2dea:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    2dec:	84 e0       	ldi	r24, 0x04	; 4
    2dee:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    2df2:	80 e1       	ldi	r24, 0x10	; 16
    2df4:	80 93 6d 00 	sts	0x006D, r24
	cli();		// Disable interrupts while we muck with the settings.

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

	SREG=sreg;		// Restore interrupts.
    2df8:	9f bf       	out	0x3f, r25	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2dfa:	80 91 7a 00 	lds	r24, 0x007A
    2dfe:	86 fd       	sbrc	r24, 6
    2e00:	0a c0       	rjmp	.+20     	; 0x2e16 <DoSampler+0x7f0>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    2e02:	80 91 79 00 	lds	r24, 0x0079
    2e06:	80 58       	subi	r24, 0x80	; 128
    2e08:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2e0c:	80 91 7a 00 	lds	r24, 0x007A
    2e10:	80 64       	ori	r24, 0x40	; 64
    2e12:	80 93 7a 00 	sts	0x007A, r24
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2e16:	20 e3       	ldi	r18, 0x30	; 48
    2e18:	4e e0       	ldi	r20, 0x0E	; 14
    2e1a:	64 e0       	ldi	r22, 0x04	; 4
    2e1c:	80 91 67 05 	lds	r24, 0x0567
    2e20:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    2e24:	3c cd       	rjmp	.-1416   	; 0x289e <DoSampler+0x278>
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Adjust sample start
    2e26:	80 91 5d 05 	lds	r24, 0x055D
    2e2a:	80 ff       	sbrs	r24, 0
    2e2c:	d8 c0       	rjmp	.+432    	; 0x2fde <DoSampler+0x9b8>
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2e2e:	10 91 67 05 	lds	r17, 0x0567
    2e32:	24 e2       	ldi	r18, 0x24	; 36
    2e34:	12 9f       	mul	r17, r18
    2e36:	f0 01       	movw	r30, r0
    2e38:	11 24       	eor	r1, r1
    2e3a:	eb 51       	subi	r30, 0x1B	; 27
    2e3c:	fa 4f       	sbci	r31, 0xFA	; 250
    2e3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e40:	00 91 58 05 	lds	r16, 0x0558
    2e44:	80 17       	cp	r24, r16
    2e46:	59 f0       	breq	.+22     	; 0x2e5e <DoSampler+0x838>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2e48:	05 8f       	std	Z+29, r16	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    2e4a:	81 2f       	mov	r24, r17
    2e4c:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
		if(keyState&Im_SWITCH_0)		// Adjust sample start
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2e50:	20 2f       	mov	r18, r16
    2e52:	26 95       	lsr	r18
    2e54:	4c e1       	ldi	r20, 0x1C	; 28
    2e56:	64 e0       	ldi	r22, 0x04	; 4
    2e58:	81 2f       	mov	r24, r17
    2e5a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
			}
		}

		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
    2e5e:	80 91 5c 05 	lds	r24, 0x055C
    2e62:	83 ff       	sbrs	r24, 3
    2e64:	5a cd       	rjmp	.-1356   	; 0x291a <DoSampler+0x2f4>
		{
			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
    2e66:	80 91 68 05 	lds	r24, 0x0568
    2e6a:	90 91 69 05 	lds	r25, 0x0569
    2e6e:	0e 94 a2 11 	call	0x2344	; 0x2344 <PlaySampleFromSd>
    2e72:	53 cd       	rjmp	.-1370   	; 0x291a <DoSampler+0x2f4>
//				// Do this here.
//			}

			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    2e74:	e0 91 6a 05 	lds	r30, 0x056A
    2e78:	8e 2f       	mov	r24, r30
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	34 e2       	ldi	r19, 0x24	; 36
    2e7e:	e3 9f       	mul	r30, r19
    2e80:	f0 01       	movw	r30, r0
    2e82:	11 24       	eor	r1, r1
    2e84:	eb 51       	subi	r30, 0x1B	; 27
    2e86:	fa 4f       	sbci	r31, 0xFA	; 250
    2e88:	20 81       	ld	r18, Z
    2e8a:	24 30       	cpi	r18, 0x04	; 4
    2e8c:	21 f0       	breq	.+8      	; 0x2e96 <DoSampler+0x870>
    2e8e:	20 81       	ld	r18, Z
    2e90:	22 30       	cpi	r18, 0x02	; 2
    2e92:	09 f0       	breq	.+2      	; 0x2e96 <DoSampler+0x870>
    2e94:	d8 cb       	rjmp	.-2128   	; 0x2646 <DoSampler+0x20>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    2e96:	fc 01       	movw	r30, r24
    2e98:	ec 5f       	subi	r30, 0xFC	; 252
    2e9a:	fe 4f       	sbci	r31, 0xFE	; 254
    2e9c:	30 91 6c 05 	lds	r19, 0x056C
    2ea0:	20 81       	ld	r18, Z
    2ea2:	32 13       	cpse	r19, r18
    2ea4:	d0 cb       	rjmp	.-2144   	; 0x2646 <DoSampler+0x20>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    2ea6:	24 e2       	ldi	r18, 0x24	; 36
    2ea8:	28 9f       	mul	r18, r24
    2eaa:	f0 01       	movw	r30, r0
    2eac:	29 9f       	mul	r18, r25
    2eae:	f0 0d       	add	r31, r0
    2eb0:	11 24       	eor	r1, r1
    2eb2:	eb 51       	subi	r30, 0x1B	; 27
    2eb4:	fa 4f       	sbci	r31, 0xFA	; 250
    2eb6:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
    2eb8:	12 86       	std	Z+10, r1	; 0x0a
    2eba:	60 91 4f 05 	lds	r22, 0x054F
    2ebe:	c5 cb       	rjmp	.-2166   	; 0x264a <DoSampler+0x24>
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    2ec0:	10 91 6a 05 	lds	r17, 0x056A
    2ec4:	21 2f       	mov	r18, r17
    2ec6:	30 e0       	ldi	r19, 0x00	; 0
    2ec8:	00 91 6c 05 	lds	r16, 0x056C
    2ecc:	f9 01       	movw	r30, r18
    2ece:	ec 5f       	subi	r30, 0xFC	; 252
    2ed0:	fe 4f       	sbci	r31, 0xFE	; 254
    2ed2:	00 83       	st	Z, r16

				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
    2ed4:	84 e2       	ldi	r24, 0x24	; 36
    2ed6:	82 9f       	mul	r24, r18
    2ed8:	f0 01       	movw	r30, r0
    2eda:	83 9f       	mul	r24, r19
    2edc:	f0 0d       	add	r31, r0
    2ede:	11 24       	eor	r1, r1
    2ee0:	eb 51       	subi	r30, 0x1B	; 27
    2ee2:	fa 4f       	sbci	r31, 0xFA	; 250
    2ee4:	86 81       	ldd	r24, Z+6	; 0x06
    2ee6:	81 11       	cpse	r24, r1
    2ee8:	bc c3       	rjmp	.+1912   	; 0x3662 <DoSampler+0x103c>
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    2eea:	41 89       	ldd	r20, Z+17	; 0x11
    2eec:	52 89       	ldd	r21, Z+18	; 0x12
    2eee:	63 89       	ldd	r22, Z+19	; 0x13
    2ef0:	74 89       	ldd	r23, Z+20	; 0x14
    2ef2:	85 85       	ldd	r24, Z+13	; 0x0d
    2ef4:	96 85       	ldd	r25, Z+14	; 0x0e
    2ef6:	a7 85       	ldd	r26, Z+15	; 0x0f
    2ef8:	b0 89       	ldd	r27, Z+16	; 0x10
    2efa:	48 17       	cp	r20, r24
    2efc:	59 07       	cpc	r21, r25
    2efe:	6a 07       	cpc	r22, r26
    2f00:	7b 07       	cpc	r23, r27
    2f02:	09 f4       	brne	.+2      	; 0x2f06 <DoSampler+0x8e0>
    2f04:	a0 cb       	rjmp	.-2240   	; 0x2646 <DoSampler+0x20>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2f06:	8b ea       	ldi	r24, 0xAB	; 171
    2f08:	08 9f       	mul	r16, r24
    2f0a:	81 2d       	mov	r24, r1
    2f0c:	11 24       	eor	r1, r1
    2f0e:	86 95       	lsr	r24
    2f10:	86 95       	lsr	r24
    2f12:	86 95       	lsr	r24
    2f14:	98 2f       	mov	r25, r24
    2f16:	99 0f       	add	r25, r25
    2f18:	98 0f       	add	r25, r24
    2f1a:	99 0f       	add	r25, r25
    2f1c:	99 0f       	add	r25, r25
    2f1e:	09 1b       	sub	r16, r25

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2f20:	a0 2f       	mov	r26, r16
    2f22:	b0 e0       	ldi	r27, 0x00	; 0
    2f24:	aa 0f       	add	r26, r26
    2f26:	bb 1f       	adc	r27, r27
    2f28:	aa 5f       	subi	r26, 0xFA	; 250
    2f2a:	be 4f       	sbci	r27, 0xFE	; 254
    2f2c:	4d 91       	ld	r20, X+
    2f2e:	5c 91       	ld	r21, X
    2f30:	02 c0       	rjmp	.+4      	; 0x2f36 <DoSampler+0x910>
    2f32:	56 95       	lsr	r21
    2f34:	47 95       	ror	r20
    2f36:	8a 95       	dec	r24
    2f38:	e2 f7       	brpl	.-8      	; 0x2f32 <DoSampler+0x90c>
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2f3a:	85 81       	ldd	r24, Z+5	; 0x05
    2f3c:	88 23       	and	r24, r24
    2f3e:	39 f0       	breq	.+14     	; 0x2f4e <DoSampler+0x928>
    2f40:	60 91 4f 05 	lds	r22, 0x054F
    2f44:	86 2f       	mov	r24, r22
    2f46:	81 50       	subi	r24, 0x01	; 1
    2f48:	82 30       	cpi	r24, 0x02	; 2
    2f4a:	08 f4       	brcc	.+2      	; 0x2f4e <DoSampler+0x928>
    2f4c:	80 cb       	rjmp	.-2304   	; 0x264e <DoSampler+0x28>
	{
		sreg=SREG;	// Store global interrupt state.
    2f4e:	6f b7       	in	r22, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2f50:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    2f52:	84 e2       	ldi	r24, 0x24	; 36
    2f54:	82 9f       	mul	r24, r18
    2f56:	f0 01       	movw	r30, r0
    2f58:	83 9f       	mul	r24, r19
    2f5a:	f0 0d       	add	r31, r0
    2f5c:	11 24       	eor	r1, r1
    2f5e:	eb 51       	subi	r30, 0x1B	; 27
    2f60:	fa 4f       	sbci	r31, 0xFA	; 250
    2f62:	84 e0       	ldi	r24, 0x04	; 4
    2f64:	80 83       	st	Z, r24

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    2f66:	83 81       	ldd	r24, Z+3	; 0x03
    2f68:	88 23       	and	r24, r24
    2f6a:	09 f4       	brne	.+2      	; 0x2f6e <DoSampler+0x948>
    2f6c:	0b c4       	rjmp	.+2070   	; 0x3784 <DoSampler+0x115e>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    2f6e:	85 89       	ldd	r24, Z+21	; 0x15
    2f70:	96 89       	ldd	r25, Z+22	; 0x16
    2f72:	a7 89       	ldd	r26, Z+23	; 0x17
    2f74:	b0 8d       	ldd	r27, Z+24	; 0x18
    2f76:	80 a3       	std	Z+32, r24	; 0x20
    2f78:	91 a3       	std	Z+33, r25	; 0x21
    2f7a:	a2 a3       	std	Z+34, r26	; 0x22
    2f7c:	b3 a3       	std	Z+35, r27	; 0x23
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    2f7e:	14 82       	std	Z+4, r1	; 0x04

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2f80:	84 e2       	ldi	r24, 0x24	; 36
    2f82:	82 9f       	mul	r24, r18
    2f84:	f0 01       	movw	r30, r0
    2f86:	83 9f       	mul	r24, r19
    2f88:	f0 0d       	add	r31, r0
    2f8a:	11 24       	eor	r1, r1
    2f8c:	eb 51       	subi	r30, 0x1B	; 27
    2f8e:	fa 4f       	sbci	r31, 0xFA	; 250
    2f90:	82 e0       	ldi	r24, 0x02	; 2
    2f92:	82 87       	std	Z+10, r24	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    2f94:	54 87       	std	Z+12, r21	; 0x0c
    2f96:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    2f98:	80 91 84 00 	lds	r24, 0x0084
    2f9c:	90 91 85 00 	lds	r25, 0x0085
    2fa0:	84 0f       	add	r24, r20
    2fa2:	95 1f       	adc	r25, r21

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    2fa4:	11 11       	cpse	r17, r1
    2fa6:	e0 c3       	rjmp	.+1984   	; 0x3768 <DoSampler+0x1142>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    2fa8:	90 93 89 00 	sts	0x0089, r25
    2fac:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    2fb0:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    2fb2:	80 91 6f 00 	lds	r24, 0x006F
    2fb6:	82 60       	ori	r24, 0x02	; 2
    2fb8:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    2fbc:	81 e0       	ldi	r24, 0x01	; 1
    2fbe:	80 93 81 00 	sts	0x0081, r24
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2fc2:	84 e2       	ldi	r24, 0x24	; 36
    2fc4:	82 9f       	mul	r24, r18
    2fc6:	f0 01       	movw	r30, r0
    2fc8:	83 9f       	mul	r24, r19
    2fca:	f0 0d       	add	r31, r0
    2fcc:	11 24       	eor	r1, r1
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    2fce:	eb 51       	subi	r30, 0x1B	; 27
    2fd0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fd2:	81 e0       	ldi	r24, 0x01	; 1
    2fd4:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    2fd6:	6f bf       	out	0x3f, r22	; 63
    2fd8:	60 91 4f 05 	lds	r22, 0x054F
    2fdc:	36 cb       	rjmp	.-2452   	; 0x264a <DoSampler+0x24>
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
			}
		}
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
    2fde:	81 ff       	sbrs	r24, 1
    2fe0:	a6 c2       	rjmp	.+1356   	; 0x352e <DoSampler+0xf08>
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2fe2:	10 91 67 05 	lds	r17, 0x0567
    2fe6:	34 e2       	ldi	r19, 0x24	; 36
    2fe8:	13 9f       	mul	r17, r19
    2fea:	f0 01       	movw	r30, r0
    2fec:	11 24       	eor	r1, r1
    2fee:	eb 51       	subi	r30, 0x1B	; 27
    2ff0:	fa 4f       	sbci	r31, 0xFA	; 250
    2ff2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ff4:	00 91 58 05 	lds	r16, 0x0558
    2ff8:	80 17       	cp	r24, r16
    2ffa:	09 f4       	brne	.+2      	; 0x2ffe <DoSampler+0x9d8>
    2ffc:	30 cf       	rjmp	.-416    	; 0x2e5e <DoSampler+0x838>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2ffe:	06 8f       	std	Z+30, r16	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    3000:	81 2f       	mov	r24, r17
    3002:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    3006:	20 2f       	mov	r18, r16
    3008:	26 95       	lsr	r18
    300a:	4d e1       	ldi	r20, 0x1D	; 29
    300c:	64 e0       	ldi	r22, 0x04	; 4
    300e:	81 2f       	mov	r24, r17
    3010:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    3014:	24 cf       	rjmp	.-440    	; 0x2e5e <DoSampler+0x838>
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
			{
				switch(currentMidiMessage.dataByteOne)
    3016:	80 91 6c 05 	lds	r24, 0x056C
    301a:	90 e0       	ldi	r25, 0x00	; 0
    301c:	fc 01       	movw	r30, r24
    301e:	33 97       	sbiw	r30, 0x03	; 3
    3020:	ec 31       	cpi	r30, 0x1C	; 28
    3022:	f1 05       	cpc	r31, r1
    3024:	08 f0       	brcs	.+2      	; 0x3028 <DoSampler+0xa02>
    3026:	0f cb       	rjmp	.-2530   	; 0x2646 <DoSampler+0x20>
    3028:	e2 5c       	subi	r30, 0xC2	; 194
    302a:	ff 4f       	sbci	r31, 0xFF	; 255
    302c:	0c 94 90 35 	jmp	0x6b20	; 0x6b20 <__tablejump2__>
					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3030:	90 91 6d 05 	lds	r25, 0x056D
    3034:	99 0f       	add	r25, r25
    3036:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    303a:	b4 e2       	ldi	r27, 0x24	; 36
    303c:	8b 9f       	mul	r24, r27
    303e:	f0 01       	movw	r30, r0
    3040:	11 24       	eor	r1, r1
    3042:	eb 51       	subi	r30, 0x1B	; 27
    3044:	fa 4f       	sbci	r31, 0xFA	; 250
    3046:	97 8f       	std	Z+31, r25	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    3048:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    304c:	60 91 4f 05 	lds	r22, 0x054F
    3050:	fc ca       	rjmp	.-2568   	; 0x264a <DoSampler+0x24>
					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3052:	90 91 6d 05 	lds	r25, 0x056D
    3056:	99 0f       	add	r25, r25
    3058:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    305c:	a4 e2       	ldi	r26, 0x24	; 36
    305e:	8a 9f       	mul	r24, r26
    3060:	f0 01       	movw	r30, r0
    3062:	11 24       	eor	r1, r1
    3064:	eb 51       	subi	r30, 0x1B	; 27
    3066:	fa 4f       	sbci	r31, 0xFA	; 250
    3068:	96 8f       	std	Z+30, r25	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    306a:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    306e:	60 91 4f 05 	lds	r22, 0x054F
    3072:	eb ca       	rjmp	.-2602   	; 0x264a <DoSampler+0x24>
					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
					break;

					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3074:	90 91 6d 05 	lds	r25, 0x056D
    3078:	99 0f       	add	r25, r25
    307a:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    307e:	44 e2       	ldi	r20, 0x24	; 36
    3080:	84 9f       	mul	r24, r20
    3082:	f0 01       	movw	r30, r0
    3084:	11 24       	eor	r1, r1
    3086:	eb 51       	subi	r30, 0x1B	; 27
    3088:	fa 4f       	sbci	r31, 0xFA	; 250
    308a:	95 8f       	std	Z+29, r25	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    308c:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    3090:	60 91 4f 05 	lds	r22, 0x054F
    3094:	da ca       	rjmp	.-2636   	; 0x264a <DoSampler+0x24>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    3096:	e0 91 6a 05 	lds	r30, 0x056A
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    309a:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    309c:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    309e:	34 e2       	ldi	r19, 0x24	; 36
    30a0:	e3 9f       	mul	r30, r19
    30a2:	f0 01       	movw	r30, r0
    30a4:	11 24       	eor	r1, r1
    30a6:	eb 51       	subi	r30, 0x1B	; 27
    30a8:	fa 4f       	sbci	r31, 0xFA	; 250
    30aa:	81 89       	ldd	r24, Z+17	; 0x11
    30ac:	92 89       	ldd	r25, Z+18	; 0x12
    30ae:	a3 89       	ldd	r26, Z+19	; 0x13
    30b0:	b4 89       	ldd	r27, Z+20	; 0x14
    30b2:	81 8f       	std	Z+25, r24	; 0x19
    30b4:	92 8f       	std	Z+26, r25	; 0x1a
    30b6:	a3 8f       	std	Z+27, r26	; 0x1b
    30b8:	b4 8f       	std	Z+28, r27	; 0x1c
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    30ba:	85 85       	ldd	r24, Z+13	; 0x0d
    30bc:	96 85       	ldd	r25, Z+14	; 0x0e
    30be:	a7 85       	ldd	r26, Z+15	; 0x0f
    30c0:	b0 89       	ldd	r27, Z+16	; 0x10
    30c2:	85 8b       	std	Z+21, r24	; 0x15
    30c4:	96 8b       	std	Z+22, r25	; 0x16
    30c6:	a7 8b       	std	Z+23, r26	; 0x17
    30c8:	b0 8f       	std	Z+24, r27	; 0x18
	bankStates[theBank].sampleStartOffset=0;
    30ca:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleEndOffset=0;
    30cc:	16 8e       	std	Z+30, r1	; 0x1e
	bankStates[theBank].sampleWindowOffset=0;
    30ce:	17 8e       	std	Z+31, r1	; 0x1f
	SREG=sreg;		// Restore interrupts.
    30d0:	2f bf       	out	0x3f, r18	; 63
    30d2:	60 91 4f 05 	lds	r22, 0x054F
    30d6:	b9 ca       	rjmp	.-2702   	; 0x264a <DoSampler+0x24>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    30d8:	90 91 6d 05 	lds	r25, 0x056D
    30dc:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    30e0:	24 e2       	ldi	r18, 0x24	; 36
    30e2:	82 9f       	mul	r24, r18
    30e4:	f0 01       	movw	r30, r0
    30e6:	11 24       	eor	r1, r1
    30e8:	eb 51       	subi	r30, 0x1B	; 27
    30ea:	fa 4f       	sbci	r31, 0xFA	; 250
    30ec:	97 8f       	std	Z+31, r25	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    30ee:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    30f2:	60 91 4f 05 	lds	r22, 0x054F
    30f6:	a9 ca       	rjmp	.-2734   	; 0x264a <DoSampler+0x24>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    30f8:	90 91 6d 05 	lds	r25, 0x056D
    30fc:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3100:	b4 e2       	ldi	r27, 0x24	; 36
    3102:	8b 9f       	mul	r24, r27
    3104:	f0 01       	movw	r30, r0
    3106:	11 24       	eor	r1, r1
    3108:	eb 51       	subi	r30, 0x1B	; 27
    310a:	fa 4f       	sbci	r31, 0xFA	; 250
    310c:	96 8f       	std	Z+30, r25	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    310e:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    3112:	60 91 4f 05 	lds	r22, 0x054F
    3116:	99 ca       	rjmp	.-2766   	; 0x264a <DoSampler+0x24>
					break;

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3118:	90 91 6d 05 	lds	r25, 0x056D
    311c:	80 91 6a 05 	lds	r24, 0x056A
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3120:	a4 e2       	ldi	r26, 0x24	; 36
    3122:	8a 9f       	mul	r24, r26
    3124:	f0 01       	movw	r30, r0
    3126:	11 24       	eor	r1, r1
    3128:	eb 51       	subi	r30, 0x1B	; 27
    312a:	fa 4f       	sbci	r31, 0xFA	; 250
    312c:	95 8f       	std	Z+29, r25	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    312e:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    3132:	60 91 4f 05 	lds	r22, 0x054F
    3136:	89 ca       	rjmp	.-2798   	; 0x264a <DoSampler+0x24>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
    3138:	1f b7       	in	r17, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    313a:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    313c:	30 91 6a 05 	lds	r19, 0x056A
    3140:	a3 2f       	mov	r26, r19
    3142:	b0 e0       	ldi	r27, 0x00	; 0
    3144:	fd 01       	movw	r30, r26
    3146:	ec 5f       	subi	r30, 0xFC	; 252
    3148:	fe 4f       	sbci	r31, 0xFE	; 254
    314a:	60 81       	ld	r22, Z
    314c:	aa 0f       	add	r26, r26
    314e:	bb 1f       	adc	r27, r27
    3150:	ad 59       	subi	r26, 0x9D	; 157
    3152:	ba 4f       	sbci	r27, 0xFA	; 250
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    3154:	2b ea       	ldi	r18, 0xAB	; 171
    3156:	62 9f       	mul	r22, r18
    3158:	21 2d       	mov	r18, r1
    315a:	11 24       	eor	r1, r1
    315c:	26 95       	lsr	r18
    315e:	26 95       	lsr	r18
    3160:	26 95       	lsr	r18
    3162:	82 2f       	mov	r24, r18
    3164:	88 0f       	add	r24, r24
    3166:	82 0f       	add	r24, r18
    3168:	88 0f       	add	r24, r24
    316a:	88 0f       	add	r24, r24
    316c:	e6 2f       	mov	r30, r22
    316e:	e8 1b       	sub	r30, r24

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3170:	f0 e0       	ldi	r31, 0x00	; 0
    3172:	ee 0f       	add	r30, r30
    3174:	ff 1f       	adc	r31, r31
    3176:	ea 5f       	subi	r30, 0xFA	; 250
    3178:	fe 4f       	sbci	r31, 0xFE	; 254
    317a:	80 81       	ld	r24, Z
    317c:	91 81       	ldd	r25, Z+1	; 0x01
    317e:	02 c0       	rjmp	.+4      	; 0x3184 <DoSampler+0xb5e>
    3180:	96 95       	lsr	r25
    3182:	87 95       	ror	r24
    3184:	2a 95       	dec	r18
    3186:	e2 f7       	brpl	.-8      	; 0x3180 <DoSampler+0xb5a>
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    3188:	8d 93       	st	X+, r24
    318a:	9c 93       	st	X, r25
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    318c:	33 23       	and	r19, r19
    318e:	09 f4       	brne	.+2      	; 0x3192 <DoSampler+0xb6c>
    3190:	cc c4       	rjmp	.+2456   	; 0x3b2a <DoSampler+0x1504>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
	}
	else if(theBank==BANK_1)
    3192:	31 30       	cpi	r19, 0x01	; 1
    3194:	09 f4       	brne	.+2      	; 0x3198 <DoSampler+0xb72>
    3196:	c4 c4       	rjmp	.+2440   	; 0x3b20 <DoSampler+0x14fa>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=sreg;		// Re-enable interrupts.
    3198:	1f bf       	out	0x3f, r17	; 63
    319a:	60 91 4f 05 	lds	r22, 0x054F
					break;
    319e:	55 ca       	rjmp	.-2902   	; 0x264a <DoSampler+0x24>
					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
					break;

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    31a0:	80 91 6d 05 	lds	r24, 0x056D
    31a4:	81 30       	cpi	r24, 0x01	; 1
    31a6:	09 f4       	brne	.+2      	; 0x31aa <DoSampler+0xb84>
    31a8:	c5 c4       	rjmp	.+2442   	; 0x3b34 <DoSampler+0x150e>
    31aa:	08 f0       	brcs	.+2      	; 0x31ae <DoSampler+0xb88>
    31ac:	fd c3       	rjmp	.+2042   	; 0x39a8 <DoSampler+0x1382>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    31ae:	8c e0       	ldi	r24, 0x0C	; 12
    31b0:	99 e0       	ldi	r25, 0x09	; 9
    31b2:	90 93 e2 05 	sts	0x05E2, r25
    31b6:	80 93 e1 05 	sts	0x05E1, r24
    31ba:	60 91 4f 05 	lds	r22, 0x054F
						break;
    31be:	45 ca       	rjmp	.-2934   	; 0x264a <DoSampler+0x24>
					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
    31c0:	e0 91 6a 05 	lds	r30, 0x056A
    31c4:	80 91 6d 05 	lds	r24, 0x056D
    31c8:	94 e2       	ldi	r25, 0x24	; 36
    31ca:	e9 9f       	mul	r30, r25
    31cc:	f0 01       	movw	r30, r0
    31ce:	11 24       	eor	r1, r1
    31d0:	eb 51       	subi	r30, 0x1B	; 27
    31d2:	fa 4f       	sbci	r31, 0xFA	; 250
    31d4:	80 87       	std	Z+8, r24	; 0x08
    31d6:	60 91 4f 05 	lds	r22, 0x054F
					break;
    31da:	37 ca       	rjmp	.-2962   	; 0x264a <DoSampler+0x24>
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    31dc:	60 91 6d 05 	lds	r22, 0x056D
    31e0:	80 91 6a 05 	lds	r24, 0x056A
    31e4:	0e 94 bc 09 	call	0x1378	; 0x1378 <MakeNewGranularArray>
    31e8:	60 91 4f 05 	lds	r22, 0x054F
					break;
    31ec:	2e ca       	rjmp	.-2980   	; 0x264a <DoSampler+0x24>
					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    31ee:	80 91 6d 05 	lds	r24, 0x056D
    31f2:	88 30       	cpi	r24, 0x08	; 8
    31f4:	08 f0       	brcs	.+2      	; 0x31f8 <DoSampler+0xbd2>
    31f6:	27 ca       	rjmp	.-2994   	; 0x2646 <DoSampler+0x20>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
    31f8:	e0 91 6a 05 	lds	r30, 0x056A
    31fc:	44 e2       	ldi	r20, 0x24	; 36
    31fe:	e4 9f       	mul	r30, r20
    3200:	f0 01       	movw	r30, r0
    3202:	11 24       	eor	r1, r1
    3204:	eb 51       	subi	r30, 0x1B	; 27
    3206:	fa 4f       	sbci	r31, 0xFA	; 250
    3208:	81 87       	std	Z+9, r24	; 0x09
    320a:	60 91 4f 05 	lds	r22, 0x054F
    320e:	1d ca       	rjmp	.-3014   	; 0x264a <DoSampler+0x24>
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    3210:	e0 91 6a 05 	lds	r30, 0x056A
    3214:	34 e2       	ldi	r19, 0x24	; 36
    3216:	e3 9f       	mul	r30, r19
    3218:	f0 01       	movw	r30, r0
    321a:	11 24       	eor	r1, r1
    321c:	eb 51       	subi	r30, 0x1B	; 27
    321e:	fa 4f       	sbci	r31, 0xFA	; 250
    3220:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    3222:	11 86       	std	Z+9, r1	; 0x09
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    3224:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3226:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3228:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    322a:	81 e0       	ldi	r24, 0x01	; 1
    322c:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    322e:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    3230:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
    3232:	16 82       	std	Z+6, r1	; 0x06
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3234:	8c e0       	ldi	r24, 0x0C	; 12
    3236:	99 e0       	ldi	r25, 0x09	; 9
    3238:	90 93 e2 05 	sts	0x05E2, r25
    323c:	80 93 e1 05 	sts	0x05E1, r24
    3240:	60 91 4f 05 	lds	r22, 0x054F
					break;
    3244:	02 ca       	rjmp	.-3068   	; 0x264a <DoSampler+0x24>
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    3246:	80 91 6d 05 	lds	r24, 0x056D
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    324a:	e0 91 6a 05 	lds	r30, 0x056A
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    324e:	88 23       	and	r24, r24
    3250:	09 f4       	brne	.+2      	; 0x3254 <DoSampler+0xc2e>
    3252:	bb c3       	rjmp	.+1910   	; 0x39ca <DoSampler+0x13a4>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    3254:	b4 e2       	ldi	r27, 0x24	; 36
    3256:	eb 9f       	mul	r30, r27
    3258:	f0 01       	movw	r30, r0
    325a:	11 24       	eor	r1, r1
    325c:	eb 51       	subi	r30, 0x1B	; 27
    325e:	fa 4f       	sbci	r31, 0xFA	; 250
    3260:	81 e0       	ldi	r24, 0x01	; 1
    3262:	83 83       	std	Z+3, r24	; 0x03
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    3264:	80 91 6a 05 	lds	r24, 0x056A
    3268:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
    326c:	60 91 4f 05 	lds	r22, 0x054F
					break;
    3270:	ec c9       	rjmp	.-3112   	; 0x264a <DoSampler+0x24>
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    3272:	80 91 6d 05 	lds	r24, 0x056D
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    3276:	e0 91 6a 05 	lds	r30, 0x056A
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    327a:	88 23       	and	r24, r24
    327c:	09 f4       	brne	.+2      	; 0x3280 <DoSampler+0xc5a>
    327e:	ad c3       	rjmp	.+1882   	; 0x39da <DoSampler+0x13b4>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    3280:	94 e2       	ldi	r25, 0x24	; 36
    3282:	e9 9f       	mul	r30, r25
    3284:	f0 01       	movw	r30, r0
    3286:	11 24       	eor	r1, r1
    3288:	eb 51       	subi	r30, 0x1B	; 27
    328a:	fa 4f       	sbci	r31, 0xFA	; 250
    328c:	81 e0       	ldi	r24, 0x01	; 1
    328e:	82 83       	std	Z+2, r24	; 0x02
    3290:	60 91 4f 05 	lds	r22, 0x054F
    3294:	da c9       	rjmp	.-3148   	; 0x264a <DoSampler+0x24>
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3296:	80 91 6d 05 	lds	r24, 0x056D
    329a:	81 11       	cpse	r24, r1
    329c:	dd c3       	rjmp	.+1978   	; 0x3a58 <DoSampler+0x1432>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so that we don't stop realtime processing if we get a note off.
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    329e:	e0 91 6a 05 	lds	r30, 0x056A
    32a2:	34 e2       	ldi	r19, 0x24	; 36
    32a4:	e3 9f       	mul	r30, r19
    32a6:	f0 01       	movw	r30, r0
    32a8:	11 24       	eor	r1, r1
    32aa:	eb 51       	subi	r30, 0x1B	; 27
    32ac:	fa 4f       	sbci	r31, 0xFA	; 250
    32ae:	80 81       	ld	r24, Z
    32b0:	82 30       	cpi	r24, 0x02	; 2
    32b2:	09 f0       	breq	.+2      	; 0x32b6 <DoSampler+0xc90>
    32b4:	c8 c9       	rjmp	.-3184   	; 0x2646 <DoSampler+0x20>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    32b6:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    32b8:	12 86       	std	Z+10, r1	; 0x0a
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playback.
    32ba:	16 82       	std	Z+6, r1	; 0x06
    32bc:	60 91 4f 05 	lds	r22, 0x054F
    32c0:	c4 c9       	rjmp	.-3192   	; 0x264a <DoSampler+0x24>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    32c2:	80 91 6d 05 	lds	r24, 0x056D
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    32c6:	e0 91 6a 05 	lds	r30, 0x056A
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    32ca:	88 23       	and	r24, r24
    32cc:	09 f4       	brne	.+2      	; 0x32d0 <DoSampler+0xcaa>
    32ce:	90 c3       	rjmp	.+1824   	; 0x39f0 <DoSampler+0x13ca>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    32d0:	44 e2       	ldi	r20, 0x24	; 36
    32d2:	e4 9f       	mul	r30, r20
    32d4:	f0 01       	movw	r30, r0
    32d6:	11 24       	eor	r1, r1
    32d8:	eb 51       	subi	r30, 0x1B	; 27
    32da:	fa 4f       	sbci	r31, 0xFA	; 250
    32dc:	11 82       	std	Z+1, r1	; 0x01
    32de:	60 91 4f 05 	lds	r22, 0x054F
    32e2:	b3 c9       	rjmp	.-3226   	; 0x264a <DoSampler+0x24>
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    32e4:	80 91 6d 05 	lds	r24, 0x056D
    32e8:	88 23       	and	r24, r24
    32ea:	09 f4       	brne	.+2      	; 0x32ee <DoSampler+0xcc8>
    32ec:	12 c3       	rjmp	.+1572   	; 0x3912 <DoSampler+0x12ec>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    32ee:	10 91 6a 05 	lds	r17, 0x056A
    32f2:	21 2f       	mov	r18, r17
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	94 e2       	ldi	r25, 0x24	; 36
    32f8:	19 9f       	mul	r17, r25
    32fa:	f0 01       	movw	r30, r0
    32fc:	11 24       	eor	r1, r1
    32fe:	eb 51       	subi	r30, 0x1B	; 27
    3300:	fa 4f       	sbci	r31, 0xFA	; 250
    3302:	41 89       	ldd	r20, Z+17	; 0x11
    3304:	52 89       	ldd	r21, Z+18	; 0x12
    3306:	63 89       	ldd	r22, Z+19	; 0x13
    3308:	74 89       	ldd	r23, Z+20	; 0x14
    330a:	85 85       	ldd	r24, Z+13	; 0x0d
    330c:	96 85       	ldd	r25, Z+14	; 0x0e
    330e:	a7 85       	ldd	r26, Z+15	; 0x0f
    3310:	b0 89       	ldd	r27, Z+16	; 0x10
    3312:	48 17       	cp	r20, r24
    3314:	59 07       	cpc	r21, r25
    3316:	6a 07       	cpc	r22, r26
    3318:	7b 07       	cpc	r23, r27
    331a:	09 f4       	brne	.+2      	; 0x331e <DoSampler+0xcf8>
    331c:	94 c9       	rjmp	.-3288   	; 0x2646 <DoSampler+0x20>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    331e:	d9 01       	movw	r26, r18
    3320:	ac 5f       	subi	r26, 0xFC	; 252
    3322:	be 4f       	sbci	r27, 0xFE	; 254
    3324:	4c 91       	ld	r20, X
    3326:	50 e0       	ldi	r21, 0x00	; 0
// Continue playing back from that address, too.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    3328:	85 81       	ldd	r24, Z+5	; 0x05
    332a:	88 23       	and	r24, r24
    332c:	39 f0       	breq	.+14     	; 0x333c <DoSampler+0xd16>
    332e:	60 91 4f 05 	lds	r22, 0x054F
    3332:	86 2f       	mov	r24, r22
    3334:	81 50       	subi	r24, 0x01	; 1
    3336:	82 30       	cpi	r24, 0x02	; 2
    3338:	08 f4       	brcc	.+2      	; 0x333c <DoSampler+0xd16>
    333a:	42 c0       	rjmp	.+132    	; 0x33c0 <DoSampler+0xd9a>
	{
		sreg=SREG;	// Store global interrupt state.
    333c:	6f b7       	in	r22, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    333e:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    3340:	84 e2       	ldi	r24, 0x24	; 36
    3342:	82 9f       	mul	r24, r18
    3344:	f0 01       	movw	r30, r0
    3346:	83 9f       	mul	r24, r19
    3348:	f0 0d       	add	r31, r0
    334a:	11 24       	eor	r1, r1
    334c:	eb 51       	subi	r30, 0x1B	; 27
    334e:	fa 4f       	sbci	r31, 0xFA	; 250
    3350:	85 e0       	ldi	r24, 0x05	; 5
    3352:	80 83       	st	Z, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3354:	82 e0       	ldi	r24, 0x02	; 2
    3356:	82 87       	std	Z+10, r24	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    3358:	54 87       	std	Z+12, r21	; 0x0c
    335a:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    335c:	80 91 84 00 	lds	r24, 0x0084
    3360:	90 91 85 00 	lds	r25, 0x0085
    3364:	84 0f       	add	r24, r20
    3366:	95 1f       	adc	r25, r21

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    3368:	11 11       	cpse	r17, r1
    336a:	68 c3       	rjmp	.+1744   	; 0x3a3c <DoSampler+0x1416>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    336c:	90 93 89 00 	sts	0x0089, r25
    3370:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    3374:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    3376:	80 91 6f 00 	lds	r24, 0x006F
    337a:	82 60       	ori	r24, 0x02	; 2
    337c:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3380:	81 e0       	ldi	r24, 0x01	; 1
    3382:	80 93 81 00 	sts	0x0081, r24
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    3386:	84 e2       	ldi	r24, 0x24	; 36
    3388:	82 9f       	mul	r24, r18
    338a:	f0 01       	movw	r30, r0
    338c:	83 9f       	mul	r24, r19
    338e:	f0 0d       	add	r31, r0
    3390:	11 24       	eor	r1, r1
    3392:	eb 51       	subi	r30, 0x1B	; 27
    3394:	fa 4f       	sbci	r31, 0xFA	; 250
    3396:	81 e0       	ldi	r24, 0x01	; 1
    3398:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    339a:	6f bf       	out	0x3f, r22	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    339c:	80 91 7a 00 	lds	r24, 0x007A
    33a0:	86 fd       	sbrc	r24, 6
    33a2:	0a c0       	rjmp	.+20     	; 0x33b8 <DoSampler+0xd92>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    33a4:	80 91 79 00 	lds	r24, 0x0079
    33a8:	80 58       	subi	r24, 0x80	; 128
    33aa:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    33ae:	80 91 7a 00 	lds	r24, 0x007A
    33b2:	80 64       	ori	r24, 0x40	; 64
    33b4:	80 93 7a 00 	sts	0x007A, r24
    33b8:	60 91 4f 05 	lds	r22, 0x054F
    33bc:	10 91 6a 05 	lds	r17, 0x056A
					if(currentMidiMessage.dataByteTwo)
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll default to playback after a recording.
    33c0:	a4 e2       	ldi	r26, 0x24	; 36
    33c2:	1a 9f       	mul	r17, r26
    33c4:	f0 01       	movw	r30, r0
    33c6:	11 24       	eor	r1, r1
    33c8:	eb 51       	subi	r30, 0x1B	; 27
    33ca:	fa 4f       	sbci	r31, 0xFA	; 250
    33cc:	16 82       	std	Z+6, r1	; 0x06
    33ce:	3d c9       	rjmp	.-3462   	; 0x264a <DoSampler+0x24>
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
			{
				switch(currentMidiMessage.dataByteOne)
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    33d0:	80 91 6d 05 	lds	r24, 0x056D
    33d4:	81 11       	cpse	r24, r1
    33d6:	18 c3       	rjmp	.+1584   	; 0x3a08 <DoSampler+0x13e2>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll default to playback after a recording.
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    33d8:	e0 91 6a 05 	lds	r30, 0x056A
    33dc:	84 e2       	ldi	r24, 0x24	; 36
    33de:	e8 9f       	mul	r30, r24
    33e0:	f0 01       	movw	r30, r0
    33e2:	11 24       	eor	r1, r1
    33e4:	eb 51       	subi	r30, 0x1B	; 27
    33e6:	fa 4f       	sbci	r31, 0xFA	; 250
    33e8:	80 81       	ld	r24, Z
    33ea:	83 30       	cpi	r24, 0x03	; 3
    33ec:	09 f0       	breq	.+2      	; 0x33f0 <DoSampler+0xdca>
    33ee:	2b c9       	rjmp	.-3498   	; 0x2646 <DoSampler+0x20>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    33f0:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    33f2:	12 86       	std	Z+10, r1	; 0x0a
    33f4:	60 91 4f 05 	lds	r22, 0x054F
    33f8:	28 c9       	rjmp	.-3504   	; 0x264a <DoSampler+0x24>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    33fa:	80 91 81 00 	lds	r24, 0x0081
    33fe:	80 64       	ori	r24, 0x40	; 64
    3400:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    3404:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3406:	80 91 6f 00 	lds	r24, 0x006F
    340a:	80 62       	ori	r24, 0x20	; 32
    340c:	80 93 6f 00 	sts	0x006F, r24
    3410:	f3 cc       	rjmp	.-1562   	; 0x2df8 <DoSampler+0x7d2>
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
				bankStates[currentBank].loopOnce=false;
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    3412:	83 ff       	sbrs	r24, 3
    3414:	cf c0       	rjmp	.+414    	; 0x35b4 <DoSampler+0xf8e>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    3416:	e0 91 67 05 	lds	r30, 0x0567
    341a:	2e 2f       	mov	r18, r30
    341c:	30 e0       	ldi	r19, 0x00	; 0
    341e:	44 e2       	ldi	r20, 0x24	; 36
    3420:	e4 9f       	mul	r30, r20
    3422:	80 01       	movw	r16, r0
    3424:	11 24       	eor	r1, r1
    3426:	0b 51       	subi	r16, 0x1B	; 27
    3428:	1a 4f       	sbci	r17, 0xFA	; 250
    342a:	d8 01       	movw	r26, r16
    342c:	51 96       	adiw	r26, 0x11	; 17
    342e:	cd 90       	ld	r12, X+
    3430:	dd 90       	ld	r13, X+
    3432:	ed 90       	ld	r14, X+
    3434:	fc 90       	ld	r15, X
    3436:	54 97       	sbiw	r26, 0x14	; 20
    3438:	1d 96       	adiw	r26, 0x0d	; 13
    343a:	4d 91       	ld	r20, X+
    343c:	5d 91       	ld	r21, X+
    343e:	6d 91       	ld	r22, X+
    3440:	7c 91       	ld	r23, X
    3442:	50 97       	sbiw	r26, 0x10	; 16
    3444:	c4 16       	cp	r12, r20
    3446:	d5 06       	cpc	r13, r21
    3448:	e6 06       	cpc	r14, r22
    344a:	f7 06       	cpc	r15, r23
    344c:	09 f4       	brne	.+2      	; 0x3450 <DoSampler+0xe2a>
    344e:	65 ca       	rjmp	.-2870   	; 0x291a <DoSampler+0x2f4>
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    3450:	15 96       	adiw	r26, 0x05	; 5
    3452:	8c 91       	ld	r24, X
    3454:	88 23       	and	r24, r24
    3456:	31 f0       	breq	.+12     	; 0x3464 <DoSampler+0xe3e>
    3458:	80 91 4f 05 	lds	r24, 0x054F
    345c:	81 50       	subi	r24, 0x01	; 1
    345e:	82 30       	cpi	r24, 0x02	; 2
    3460:	08 f4       	brcc	.+2      	; 0x3464 <DoSampler+0xe3e>
    3462:	42 c0       	rjmp	.+132    	; 0x34e8 <DoSampler+0xec2>
	{
		sreg=SREG;	// Store global interrupt state.
    3464:	9f b7       	in	r25, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    3466:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    3468:	84 e2       	ldi	r24, 0x24	; 36
    346a:	82 9f       	mul	r24, r18
    346c:	d0 01       	movw	r26, r0
    346e:	83 9f       	mul	r24, r19
    3470:	b0 0d       	add	r27, r0
    3472:	11 24       	eor	r1, r1
    3474:	ab 51       	subi	r26, 0x1B	; 27
    3476:	ba 4f       	sbci	r27, 0xFA	; 250
    3478:	84 e0       	ldi	r24, 0x04	; 4
    347a:	8c 93       	st	X, r24

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    347c:	13 96       	adiw	r26, 0x03	; 3
    347e:	8c 91       	ld	r24, X
    3480:	13 97       	sbiw	r26, 0x03	; 3
    3482:	88 23       	and	r24, r24
    3484:	09 f4       	brne	.+2      	; 0x3488 <DoSampler+0xe62>
    3486:	08 c2       	rjmp	.+1040   	; 0x3898 <DoSampler+0x1272>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    3488:	55 96       	adiw	r26, 0x15	; 21
    348a:	4d 91       	ld	r20, X+
    348c:	5d 91       	ld	r21, X+
    348e:	6d 91       	ld	r22, X+
    3490:	7c 91       	ld	r23, X
    3492:	58 97       	sbiw	r26, 0x18	; 24
    3494:	90 96       	adiw	r26, 0x20	; 32
    3496:	4d 93       	st	X+, r20
    3498:	5d 93       	st	X+, r21
    349a:	6d 93       	st	X+, r22
    349c:	7c 93       	st	X, r23
    349e:	93 97       	sbiw	r26, 0x23	; 35
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    34a0:	14 96       	adiw	r26, 0x04	; 4
    34a2:	1c 92       	st	X, r1

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    34a4:	84 e2       	ldi	r24, 0x24	; 36
    34a6:	82 9f       	mul	r24, r18
    34a8:	d0 01       	movw	r26, r0
    34aa:	83 9f       	mul	r24, r19
    34ac:	b0 0d       	add	r27, r0
    34ae:	11 24       	eor	r1, r1
    34b0:	ab 51       	subi	r26, 0x1B	; 27
    34b2:	ba 4f       	sbci	r27, 0xFA	; 250
    34b4:	81 e0       	ldi	r24, 0x01	; 1
    34b6:	1a 96       	adiw	r26, 0x0a	; 10
    34b8:	8c 93       	st	X, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    34ba:	ee 23       	and	r30, r30
    34bc:	09 f4       	brne	.+2      	; 0x34c0 <DoSampler+0xe9a>
    34be:	fc c1       	rjmp	.+1016   	; 0x38b8 <DoSampler+0x1292>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    34c0:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    34c2:	84 e0       	ldi	r24, 0x04	; 4
    34c4:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    34c8:	80 e1       	ldi	r24, 0x10	; 16
    34ca:	80 93 6d 00 	sts	0x006D, r24
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    34ce:	84 e2       	ldi	r24, 0x24	; 36
    34d0:	82 9f       	mul	r24, r18
    34d2:	f0 01       	movw	r30, r0
    34d4:	83 9f       	mul	r24, r19
    34d6:	f0 0d       	add	r31, r0
    34d8:	11 24       	eor	r1, r1
    34da:	eb 51       	subi	r30, 0x1B	; 27
    34dc:	fa 4f       	sbci	r31, 0xFA	; 250
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    34e2:	9f bf       	out	0x3f, r25	; 63
    34e4:	e0 91 67 05 	lds	r30, 0x0567
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    34e8:	f4 e2       	ldi	r31, 0x24	; 36
    34ea:	ef 9f       	mul	r30, r31
    34ec:	d0 01       	movw	r26, r0
    34ee:	11 24       	eor	r1, r1
    34f0:	ab 51       	subi	r26, 0x1B	; 27
    34f2:	ba 4f       	sbci	r27, 0xFA	; 250
    34f4:	81 e0       	ldi	r24, 0x01	; 1
    34f6:	11 96       	adiw	r26, 0x01	; 1
    34f8:	8c 93       	st	X, r24
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    34fa:	20 e4       	ldi	r18, 0x40	; 64
    34fc:	40 e3       	ldi	r20, 0x30	; 48
    34fe:	61 e0       	ldi	r22, 0x01	; 1
    3500:	8e 2f       	mov	r24, r30
    3502:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    3506:	09 ca       	rjmp	.-3054   	; 0x291a <DoSampler+0x2f4>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
		{
			if(newEncoder)	// Only change to new values
			{
				switch(scaledEncoderValue)
    3508:	82 30       	cpi	r24, 0x02	; 2
    350a:	d9 f1       	breq	.+118    	; 0x3582 <DoSampler+0xf5c>
    350c:	83 30       	cpi	r24, 0x03	; 3
    350e:	09 f0       	breq	.+2      	; 0x3512 <DoSampler+0xeec>
    3510:	ea c9       	rjmp	.-3116   	; 0x28e6 <DoSampler+0x2c0>
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
					break;

					case 3:
					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    3512:	82 e4       	ldi	r24, 0x42	; 66
    3514:	99 e0       	ldi	r25, 0x09	; 9
    3516:	90 93 e2 05 	sts	0x05E2, r25
    351a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    351e:	23 e0       	ldi	r18, 0x03	; 3
    3520:	46 e1       	ldi	r20, 0x16	; 22
    3522:	64 e0       	ldi	r22, 0x04	; 4
    3524:	80 91 67 05 	lds	r24, 0x0567
    3528:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    352c:	dc c9       	rjmp	.-3144   	; 0x28e6 <DoSampler+0x2c0>
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
			}
		}
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
    352e:	82 ff       	sbrs	r24, 2
    3530:	96 cc       	rjmp	.-1748   	; 0x2e5e <DoSampler+0x838>
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    3532:	10 91 67 05 	lds	r17, 0x0567
    3536:	44 e2       	ldi	r20, 0x24	; 36
    3538:	14 9f       	mul	r17, r20
    353a:	f0 01       	movw	r30, r0
    353c:	11 24       	eor	r1, r1
    353e:	eb 51       	subi	r30, 0x1B	; 27
    3540:	fa 4f       	sbci	r31, 0xFA	; 250
    3542:	87 8d       	ldd	r24, Z+31	; 0x1f
    3544:	00 91 58 05 	lds	r16, 0x0558
    3548:	80 17       	cp	r24, r16
    354a:	09 f4       	brne	.+2      	; 0x354e <DoSampler+0xf28>
    354c:	88 cc       	rjmp	.-1776   	; 0x2e5e <DoSampler+0x838>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    354e:	07 8f       	std	Z+31, r16	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    3550:	81 2f       	mov	r24, r17
    3552:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    3556:	20 2f       	mov	r18, r16
    3558:	26 95       	lsr	r18
    355a:	4e e1       	ldi	r20, 0x1E	; 30
    355c:	64 e0       	ldi	r22, 0x04	; 4
    355e:	81 2f       	mov	r24, r17
    3560:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    3564:	7c cc       	rjmp	.-1800   	; 0x2e5e <DoSampler+0x838>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
					break;

					case 1:
					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3566:	8c eb       	ldi	r24, 0xBC	; 188
    3568:	98 e0       	ldi	r25, 0x08	; 8
    356a:	90 93 e2 05 	sts	0x05E2, r25
    356e:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3572:	21 e0       	ldi	r18, 0x01	; 1
    3574:	46 e1       	ldi	r20, 0x16	; 22
    3576:	64 e0       	ldi	r22, 0x04	; 4
    3578:	80 91 67 05 	lds	r24, 0x0567
    357c:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    3580:	b2 c9       	rjmp	.-3228   	; 0x28e6 <DoSampler+0x2c0>
					break;

					case 2:
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3582:	8f e7       	ldi	r24, 0x7F	; 127
    3584:	99 e0       	ldi	r25, 0x09	; 9
    3586:	90 93 e2 05 	sts	0x05E2, r25
    358a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    358e:	22 e0       	ldi	r18, 0x02	; 2
    3590:	46 e1       	ldi	r20, 0x16	; 22
    3592:	64 e0       	ldi	r22, 0x04	; 4
    3594:	80 91 67 05 	lds	r24, 0x0567
    3598:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    359c:	a4 c9       	rjmp	.-3256   	; 0x28e6 <DoSampler+0x2c0>
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    359e:	41 8d       	ldd	r20, Z+25	; 0x19
    35a0:	52 8d       	ldd	r21, Z+26	; 0x1a
    35a2:	63 8d       	ldd	r22, Z+27	; 0x1b
    35a4:	74 8d       	ldd	r23, Z+28	; 0x1c
    35a6:	40 a3       	std	Z+32, r20	; 0x20
    35a8:	51 a3       	std	Z+33, r21	; 0x21
    35aa:	62 a3       	std	Z+34, r22	; 0x22
    35ac:	73 a3       	std	Z+35, r23	; 0x23
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    35ae:	91 e0       	ldi	r25, 0x01	; 1
    35b0:	94 83       	std	Z+4, r25	; 0x04
    35b2:	96 cb       	rjmp	.-2260   	; 0x2ce0 <DoSampler+0x6ba>
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
			}
		}
		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this will stop it at the current sample location.  If playback is idle it will restart it.  This will not restart a playing sample from the beginning.
    35b4:	84 ff       	sbrs	r24, 4
    35b6:	0d c1       	rjmp	.+538    	; 0x37d2 <DoSampler+0x11ac>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    35b8:	80 91 67 05 	lds	r24, 0x0567
    35bc:	a8 2f       	mov	r26, r24
    35be:	b0 e0       	ldi	r27, 0x00	; 0
    35c0:	24 e2       	ldi	r18, 0x24	; 36
    35c2:	82 9f       	mul	r24, r18
    35c4:	f0 01       	movw	r30, r0
    35c6:	11 24       	eor	r1, r1
    35c8:	eb 51       	subi	r30, 0x1B	; 27
    35ca:	fa 4f       	sbci	r31, 0xFA	; 250
    35cc:	90 81       	ld	r25, Z
    35ce:	91 11       	cpse	r25, r1
    35d0:	8b c1       	rjmp	.+790    	; 0x38e8 <DoSampler+0x12c2>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    35d2:	01 89       	ldd	r16, Z+17	; 0x11
    35d4:	12 89       	ldd	r17, Z+18	; 0x12
    35d6:	23 89       	ldd	r18, Z+19	; 0x13
    35d8:	34 89       	ldd	r19, Z+20	; 0x14
    35da:	45 85       	ldd	r20, Z+13	; 0x0d
    35dc:	56 85       	ldd	r21, Z+14	; 0x0e
    35de:	67 85       	ldd	r22, Z+15	; 0x0f
    35e0:	70 89       	ldd	r23, Z+16	; 0x10
    35e2:	04 17       	cp	r16, r20
    35e4:	15 07       	cpc	r17, r21
    35e6:	26 07       	cpc	r18, r22
    35e8:	37 07       	cpc	r19, r23
    35ea:	09 f4       	brne	.+2      	; 0x35ee <DoSampler+0xfc8>
    35ec:	96 c9       	rjmp	.-3284   	; 0x291a <DoSampler+0x2f4>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    35ee:	94 e2       	ldi	r25, 0x24	; 36
    35f0:	9a 9f       	mul	r25, r26
    35f2:	f0 01       	movw	r30, r0
    35f4:	9b 9f       	mul	r25, r27
    35f6:	f0 0d       	add	r31, r0
    35f8:	11 24       	eor	r1, r1
    35fa:	eb 51       	subi	r30, 0x1B	; 27
    35fc:	fa 4f       	sbci	r31, 0xFA	; 250
    35fe:	95 81       	ldd	r25, Z+5	; 0x05
    3600:	99 23       	and	r25, r25
    3602:	29 f0       	breq	.+10     	; 0x360e <DoSampler+0xfe8>
    3604:	90 91 4f 05 	lds	r25, 0x054F
    3608:	91 50       	subi	r25, 0x01	; 1
    360a:	92 30       	cpi	r25, 0x02	; 2
    360c:	10 f1       	brcs	.+68     	; 0x3652 <DoSampler+0x102c>
	{
		sreg=SREG;	// Store global interrupt state.
    360e:	2f b7       	in	r18, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    3610:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    3612:	94 e2       	ldi	r25, 0x24	; 36
    3614:	9a 9f       	mul	r25, r26
    3616:	f0 01       	movw	r30, r0
    3618:	9b 9f       	mul	r25, r27
    361a:	f0 0d       	add	r31, r0
    361c:	11 24       	eor	r1, r1
    361e:	eb 51       	subi	r30, 0x1B	; 27
    3620:	fa 4f       	sbci	r31, 0xFA	; 250
    3622:	94 e0       	ldi	r25, 0x04	; 4
    3624:	90 83       	st	Z, r25

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3626:	31 e0       	ldi	r19, 0x01	; 1
    3628:	32 87       	std	Z+10, r19	; 0x0a
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    362a:	88 23       	and	r24, r24
    362c:	09 f4       	brne	.+2      	; 0x3630 <DoSampler+0x100a>
    362e:	65 c1       	rjmp	.+714    	; 0x38fa <DoSampler+0x12d4>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    3630:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    3632:	90 93 68 00 	sts	0x0068, r25
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    3636:	80 e1       	ldi	r24, 0x10	; 16
    3638:	80 93 6d 00 	sts	0x006D, r24
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    363c:	84 e2       	ldi	r24, 0x24	; 36
    363e:	8a 9f       	mul	r24, r26
    3640:	f0 01       	movw	r30, r0
    3642:	8b 9f       	mul	r24, r27
    3644:	f0 0d       	add	r31, r0
    3646:	11 24       	eor	r1, r1
    3648:	eb 51       	subi	r30, 0x1B	; 27
    364a:	fa 4f       	sbci	r31, 0xFA	; 250
    364c:	81 e0       	ldi	r24, 0x01	; 1
    364e:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    3650:	2f bf       	out	0x3f, r18	; 63
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
				{
					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    3652:	20 e4       	ldi	r18, 0x40	; 64
    3654:	40 e3       	ldi	r20, 0x30	; 48
    3656:	61 e0       	ldi	r22, 0x01	; 1
    3658:	80 91 67 05 	lds	r24, 0x0567
    365c:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    3660:	5c c9       	rjmp	.-3400   	; 0x291a <DoSampler+0x2f4>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    3662:	2b ea       	ldi	r18, 0xAB	; 171
    3664:	02 9f       	mul	r16, r18
    3666:	21 2d       	mov	r18, r1
    3668:	11 24       	eor	r1, r1
    366a:	26 95       	lsr	r18
    366c:	26 95       	lsr	r18
    366e:	26 95       	lsr	r18
    3670:	82 2f       	mov	r24, r18
    3672:	88 0f       	add	r24, r24
    3674:	82 0f       	add	r24, r18
    3676:	88 0f       	add	r24, r24
    3678:	88 0f       	add	r24, r24
    367a:	a0 2f       	mov	r26, r16
    367c:	a8 1b       	sub	r26, r24

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    367e:	b0 e0       	ldi	r27, 0x00	; 0
    3680:	aa 0f       	add	r26, r26
    3682:	bb 1f       	adc	r27, r27
    3684:	aa 5f       	subi	r26, 0xFA	; 250
    3686:	be 4f       	sbci	r27, 0xFE	; 254
    3688:	8d 91       	ld	r24, X+
    368a:	9c 91       	ld	r25, X
    368c:	02 c0       	rjmp	.+4      	; 0x3692 <DoSampler+0x106c>
    368e:	96 95       	lsr	r25
    3690:	87 95       	ror	r24
    3692:	2a 95       	dec	r18
    3694:	e2 f7       	brpl	.-8      	; 0x368e <DoSampler+0x1068>
// OK to do realtime even when banks are locked since we don't use the RAM
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3696:	5f b7       	in	r21, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    3698:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    369a:	22 e0       	ldi	r18, 0x02	; 2
    369c:	20 83       	st	Z, r18

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    369e:	22 87       	std	Z+10, r18	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    36a0:	94 87       	std	Z+12, r25	; 0x0c
    36a2:	83 87       	std	Z+11, r24	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    36a4:	20 91 84 00 	lds	r18, 0x0084
    36a8:	30 91 85 00 	lds	r19, 0x0085
    36ac:	28 0f       	add	r18, r24
    36ae:	39 1f       	adc	r19, r25

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    36b0:	11 11       	cpse	r17, r1
    36b2:	9c c0       	rjmp	.+312    	; 0x37ec <DoSampler+0x11c6>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    36b4:	30 93 89 00 	sts	0x0089, r19
    36b8:	20 93 88 00 	sts	0x0088, r18
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    36bc:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    36be:	80 91 6f 00 	lds	r24, 0x006F
    36c2:	82 60       	ori	r24, 0x02	; 2
    36c4:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    36c8:	40 93 81 00 	sts	0x0081, r20
	cli();		// Disable interrupts while we muck with the settings.

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

	SREG=sreg;		// Restore interrupts.
    36cc:	5f bf       	out	0x3f, r21	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    36ce:	80 91 7a 00 	lds	r24, 0x007A
    36d2:	86 ff       	sbrs	r24, 6
    36d4:	02 c0       	rjmp	.+4      	; 0x36da <DoSampler+0x10b4>
    36d6:	0c 94 23 13 	jmp	0x2646	; 0x2646 <DoSampler+0x20>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    36da:	80 91 79 00 	lds	r24, 0x0079
    36de:	80 58       	subi	r24, 0x80	; 128
    36e0:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    36e4:	80 91 7a 00 	lds	r24, 0x007A
    36e8:	80 64       	ori	r24, 0x40	; 64
    36ea:	80 93 7a 00 	sts	0x007A, r24
    36ee:	60 91 4f 05 	lds	r22, 0x054F
    36f2:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    36f6:	90 91 81 00 	lds	r25, 0x0081
    36fa:	90 64       	ori	r25, 0x40	; 64
    36fc:	90 93 81 00 	sts	0x0081, r25
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    3700:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3702:	90 91 6f 00 	lds	r25, 0x006F
    3706:	90 62       	ori	r25, 0x20	; 32
    3708:	90 93 6f 00 	sts	0x006F, r25
    370c:	fd ca       	rjmp	.-2566   	; 0x2d08 <DoSampler+0x6e2>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    370e:	20 91 6a 05 	lds	r18, 0x056A
    3712:	30 e0       	ldi	r19, 0x00	; 0
    3714:	f9 01       	movw	r30, r18
    3716:	ec 5f       	subi	r30, 0xFC	; 252
    3718:	fe 4f       	sbci	r31, 0xFE	; 254
    371a:	90 81       	ld	r25, Z
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    371c:	4b ea       	ldi	r20, 0xAB	; 171
    371e:	94 9f       	mul	r25, r20
    3720:	41 2d       	mov	r20, r1
    3722:	11 24       	eor	r1, r1
    3724:	46 95       	lsr	r20
    3726:	46 95       	lsr	r20
    3728:	46 95       	lsr	r20
    372a:	84 2f       	mov	r24, r20
    372c:	88 0f       	add	r24, r24
    372e:	84 0f       	add	r24, r20
    3730:	88 0f       	add	r24, r24
    3732:	88 0f       	add	r24, r24
    3734:	98 1b       	sub	r25, r24

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3736:	e9 2f       	mov	r30, r25
    3738:	f0 e0       	ldi	r31, 0x00	; 0
    373a:	ee 0f       	add	r30, r30
    373c:	ff 1f       	adc	r31, r31
    373e:	ea 5f       	subi	r30, 0xFA	; 250
    3740:	fe 4f       	sbci	r31, 0xFE	; 254
    3742:	80 81       	ld	r24, Z
    3744:	91 81       	ldd	r25, Z+1	; 0x01
    3746:	02 c0       	rjmp	.+4      	; 0x374c <DoSampler+0x1126>
    3748:	96 95       	lsr	r25
    374a:	87 95       	ror	r24
    374c:	4a 95       	dec	r20
    374e:	e2 f7       	brpl	.-8      	; 0x3748 <DoSampler+0x1122>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    3750:	44 e2       	ldi	r20, 0x24	; 36
    3752:	42 9f       	mul	r20, r18
    3754:	f0 01       	movw	r30, r0
    3756:	43 9f       	mul	r20, r19
    3758:	f0 0d       	add	r31, r0
    375a:	11 24       	eor	r1, r1
    375c:	eb 51       	subi	r30, 0x1B	; 27
    375e:	fa 4f       	sbci	r31, 0xFA	; 250
    3760:	94 87       	std	Z+12, r25	; 0x0c
    3762:	83 87       	std	Z+11, r24	; 0x0b
    3764:	0c 94 23 13 	jmp	0x2646	; 0x2646 <DoSampler+0x20>
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3768:	90 93 8b 00 	sts	0x008B, r25
    376c:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    3770:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    3772:	80 91 6f 00 	lds	r24, 0x006F
    3776:	84 60       	ori	r24, 0x04	; 4
    3778:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    377c:	81 e0       	ldi	r24, 0x01	; 1
    377e:	80 93 81 00 	sts	0x0081, r24
    3782:	1f cc       	rjmp	.-1986   	; 0x2fc2 <DoSampler+0x99c>
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    3784:	81 8d       	ldd	r24, Z+25	; 0x19
    3786:	92 8d       	ldd	r25, Z+26	; 0x1a
    3788:	a3 8d       	ldd	r26, Z+27	; 0x1b
    378a:	b4 8d       	ldd	r27, Z+28	; 0x1c
    378c:	80 a3       	std	Z+32, r24	; 0x20
    378e:	91 a3       	std	Z+33, r25	; 0x21
    3790:	a2 a3       	std	Z+34, r26	; 0x22
    3792:	b3 a3       	std	Z+35, r27	; 0x23
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    3794:	81 e0       	ldi	r24, 0x01	; 1
    3796:	84 83       	std	Z+4, r24	; 0x04
    3798:	f3 cb       	rjmp	.-2074   	; 0x2f80 <DoSampler+0x95a>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    379a:	90 91 81 00 	lds	r25, 0x0081
    379e:	90 64       	ori	r25, 0x40	; 64
    37a0:	90 93 81 00 	sts	0x0081, r25
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    37a4:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    37a6:	90 91 6f 00 	lds	r25, 0x006F
    37aa:	90 62       	ori	r25, 0x20	; 32
    37ac:	90 93 6f 00 	sts	0x006F, r25
    37b0:	9f c9       	rjmp	.-3266   	; 0x2af0 <DoSampler+0x4ca>
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    37b2:	59 96       	adiw	r26, 0x19	; 25
    37b4:	4d 91       	ld	r20, X+
    37b6:	5d 91       	ld	r21, X+
    37b8:	6d 91       	ld	r22, X+
    37ba:	7c 91       	ld	r23, X
    37bc:	5c 97       	sbiw	r26, 0x1c	; 28
    37be:	90 96       	adiw	r26, 0x20	; 32
    37c0:	4d 93       	st	X+, r20
    37c2:	5d 93       	st	X+, r21
    37c4:	6d 93       	st	X+, r22
    37c6:	7c 93       	st	X, r23
    37c8:	93 97       	sbiw	r26, 0x23	; 35
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    37ca:	21 e0       	ldi	r18, 0x01	; 1
    37cc:	14 96       	adiw	r26, 0x04	; 4
    37ce:	2c 93       	st	X, r18
    37d0:	31 ca       	rjmp	.-2974   	; 0x2c34 <DoSampler+0x60e>
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
			}

		}
		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
    37d2:	85 ff       	sbrs	r24, 5
    37d4:	a2 c8       	rjmp	.-3772   	; 0x291a <DoSampler+0x2f4>
		{
			currentBank++;
    37d6:	80 91 67 05 	lds	r24, 0x0567
    37da:	8f 5f       	subi	r24, 0xFF	; 255
    37dc:	80 93 67 05 	sts	0x0567, r24
			if(currentBank>=NUM_BANKS)
    37e0:	82 30       	cpi	r24, 0x02	; 2
    37e2:	08 f4       	brcc	.+2      	; 0x37e6 <DoSampler+0x11c0>
    37e4:	9a c8       	rjmp	.-3788   	; 0x291a <DoSampler+0x2f4>
			{
				currentBank=BANK_0;		// Loop around.
    37e6:	10 92 67 05 	sts	0x0567, r1
    37ea:	97 c8       	rjmp	.-3794   	; 0x291a <DoSampler+0x2f4>
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    37ec:	30 93 8b 00 	sts	0x008B, r19
    37f0:	20 93 8a 00 	sts	0x008A, r18
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    37f4:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    37f6:	80 91 6f 00 	lds	r24, 0x006F
    37fa:	84 60       	ori	r24, 0x04	; 4
    37fc:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3800:	40 93 81 00 	sts	0x0081, r20
    3804:	63 cf       	rjmp	.-314    	; 0x36cc <DoSampler+0x10a6>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    3806:	15 96       	adiw	r26, 0x05	; 5
    3808:	8c 91       	ld	r24, X
    380a:	88 23       	and	r24, r24
    380c:	29 f0       	breq	.+10     	; 0x3818 <DoSampler+0x11f2>
    380e:	80 91 4f 05 	lds	r24, 0x054F
    3812:	81 50       	subi	r24, 0x01	; 1
    3814:	82 30       	cpi	r24, 0x02	; 2
    3816:	28 f1       	brcs	.+74     	; 0x3862 <DoSampler+0x123c>
	{
		sreg=SREG;	// Store global interrupt state.
    3818:	9f b7       	in	r25, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    381a:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    381c:	84 e2       	ldi	r24, 0x24	; 36
    381e:	8e 9d       	mul	r24, r14
    3820:	d0 01       	movw	r26, r0
    3822:	8f 9d       	mul	r24, r15
    3824:	b0 0d       	add	r27, r0
    3826:	11 24       	eor	r1, r1
    3828:	ab 51       	subi	r26, 0x1B	; 27
    382a:	ba 4f       	sbci	r27, 0xFA	; 250
    382c:	84 e0       	ldi	r24, 0x04	; 4
    382e:	8c 93       	st	X, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3830:	21 e0       	ldi	r18, 0x01	; 1
    3832:	1a 96       	adiw	r26, 0x0a	; 10
    3834:	2c 93       	st	X, r18
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    3836:	ee 23       	and	r30, r30
    3838:	09 f4       	brne	.+2      	; 0x383c <DoSampler+0x1216>
    383a:	4a c0       	rjmp	.+148    	; 0x38d0 <DoSampler+0x12aa>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    383c:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    383e:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    3842:	80 e1       	ldi	r24, 0x10	; 16
    3844:	80 93 6d 00 	sts	0x006D, r24
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    3848:	84 e2       	ldi	r24, 0x24	; 36
    384a:	8e 9d       	mul	r24, r14
    384c:	f0 01       	movw	r30, r0
    384e:	8f 9d       	mul	r24, r15
    3850:	f0 0d       	add	r31, r0
    3852:	11 24       	eor	r1, r1
    3854:	eb 51       	subi	r30, 0x1B	; 27
    3856:	fa 4f       	sbci	r31, 0xFA	; 250
    3858:	81 e0       	ldi	r24, 0x01	; 1
    385a:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    385c:	9f bf       	out	0x3f, r25	; 63
    385e:	e0 91 67 05 	lds	r30, 0x0567
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
			{
				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
				bankStates[currentBank].loopOnce=false;
    3862:	f4 e2       	ldi	r31, 0x24	; 36
    3864:	ef 9f       	mul	r30, r31
    3866:	d0 01       	movw	r26, r0
    3868:	11 24       	eor	r1, r1
    386a:	ab 51       	subi	r26, 0x1B	; 27
    386c:	ba 4f       	sbci	r27, 0xFA	; 250
    386e:	11 96       	adiw	r26, 0x01	; 1
    3870:	1c 92       	st	X, r1
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    3872:	20 e0       	ldi	r18, 0x00	; 0
    3874:	49 e0       	ldi	r20, 0x09	; 9
    3876:	64 e0       	ldi	r22, 0x04	; 4
    3878:	8e 2f       	mov	r24, r30
    387a:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    387e:	4d c8       	rjmp	.-3942   	; 0x291a <DoSampler+0x2f4>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    3880:	80 91 81 00 	lds	r24, 0x0081
    3884:	80 64       	ori	r24, 0x40	; 64
    3886:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    388a:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    388c:	80 91 6f 00 	lds	r24, 0x006F
    3890:	80 62       	ori	r24, 0x20	; 32
    3892:	80 93 6f 00 	sts	0x006F, r24
    3896:	e3 c9       	rjmp	.-3130   	; 0x2c5e <DoSampler+0x638>
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    3898:	59 96       	adiw	r26, 0x19	; 25
    389a:	4d 91       	ld	r20, X+
    389c:	5d 91       	ld	r21, X+
    389e:	6d 91       	ld	r22, X+
    38a0:	7c 91       	ld	r23, X
    38a2:	5c 97       	sbiw	r26, 0x1c	; 28
    38a4:	90 96       	adiw	r26, 0x20	; 32
    38a6:	4d 93       	st	X+, r20
    38a8:	5d 93       	st	X+, r21
    38aa:	6d 93       	st	X+, r22
    38ac:	7c 93       	st	X, r23
    38ae:	93 97       	sbiw	r26, 0x23	; 35
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    38b0:	81 e0       	ldi	r24, 0x01	; 1
    38b2:	14 96       	adiw	r26, 0x04	; 4
    38b4:	8c 93       	st	X, r24
    38b6:	f6 cd       	rjmp	.-1044   	; 0x34a4 <DoSampler+0xe7e>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    38b8:	80 91 81 00 	lds	r24, 0x0081
    38bc:	80 64       	ori	r24, 0x40	; 64
    38be:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    38c2:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    38c4:	80 91 6f 00 	lds	r24, 0x006F
    38c8:	80 62       	ori	r24, 0x20	; 32
    38ca:	80 93 6f 00 	sts	0x006F, r24
    38ce:	ff cd       	rjmp	.-1026   	; 0x34ce <DoSampler+0xea8>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    38d0:	80 91 81 00 	lds	r24, 0x0081
    38d4:	80 64       	ori	r24, 0x40	; 64
    38d6:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    38da:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    38dc:	80 91 6f 00 	lds	r24, 0x006F
    38e0:	80 62       	ori	r24, 0x20	; 32
    38e2:	80 93 6f 00 	sts	0x006F, r24
    38e6:	b0 cf       	rjmp	.-160    	; 0x3848 <DoSampler+0x1222>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
				}
			}
			else		// Pause whatever we were doing.
			{
				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    38e8:	10 82       	st	Z, r1
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    38ea:	12 86       	std	Z+10, r1	; 0x0a
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    38ec:	20 e0       	ldi	r18, 0x00	; 0
    38ee:	40 e3       	ldi	r20, 0x30	; 48
    38f0:	62 e0       	ldi	r22, 0x02	; 2
    38f2:	0e 94 a7 27 	call	0x4f4e	; 0x4f4e <PutMidiMessageInOutgoingFifo>
    38f6:	0c 94 8d 14 	jmp	0x291a	; 0x291a <DoSampler+0x2f4>
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    38fa:	80 91 81 00 	lds	r24, 0x0081
    38fe:	80 64       	ori	r24, 0x40	; 64
    3900:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    3904:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3906:	80 91 6f 00 	lds	r24, 0x006F
    390a:	80 62       	ori	r24, 0x20	; 32
    390c:	80 93 6f 00 	sts	0x006F, r24
    3910:	95 ce       	rjmp	.-726    	; 0x363c <DoSampler+0x1016>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll default to playback after a recording.
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    3912:	20 91 6a 05 	lds	r18, 0x056A
    3916:	82 2f       	mov	r24, r18
    3918:	90 e0       	ldi	r25, 0x00	; 0
    391a:	b4 e2       	ldi	r27, 0x24	; 36
    391c:	2b 9f       	mul	r18, r27
    391e:	f0 01       	movw	r30, r0
    3920:	11 24       	eor	r1, r1
    3922:	eb 51       	subi	r30, 0x1B	; 27
    3924:	fa 4f       	sbci	r31, 0xFA	; 250
    3926:	30 81       	ld	r19, Z
    3928:	35 30       	cpi	r19, 0x05	; 5
    392a:	11 f0       	breq	.+4      	; 0x3930 <DoSampler+0x130a>
    392c:	0c 94 23 13 	jmp	0x2646	; 0x2646 <DoSampler+0x20>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    3930:	dc 01       	movw	r26, r24
    3932:	ac 5f       	subi	r26, 0xFC	; 252
    3934:	be 4f       	sbci	r27, 0xFE	; 254
    3936:	4c 91       	ld	r20, X
    3938:	50 e0       	ldi	r21, 0x00	; 0
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    393a:	35 81       	ldd	r19, Z+5	; 0x05
    393c:	33 23       	and	r19, r19
    393e:	41 f0       	breq	.+16     	; 0x3950 <DoSampler+0x132a>
    3940:	60 91 4f 05 	lds	r22, 0x054F
    3944:	36 2f       	mov	r19, r22
    3946:	31 50       	subi	r19, 0x01	; 1
    3948:	32 30       	cpi	r19, 0x02	; 2
    394a:	10 f4       	brcc	.+4      	; 0x3950 <DoSampler+0x132a>
    394c:	0c 94 27 13 	jmp	0x264e	; 0x264e <DoSampler+0x28>
	{
		sreg=SREG;	// Store global interrupt state.
    3950:	6f b7       	in	r22, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    3952:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    3954:	34 e2       	ldi	r19, 0x24	; 36
    3956:	38 9f       	mul	r19, r24
    3958:	f0 01       	movw	r30, r0
    395a:	39 9f       	mul	r19, r25
    395c:	f0 0d       	add	r31, r0
    395e:	11 24       	eor	r1, r1
    3960:	eb 51       	subi	r30, 0x1B	; 27
    3962:	fa 4f       	sbci	r31, 0xFA	; 250
    3964:	34 e0       	ldi	r19, 0x04	; 4
    3966:	30 83       	st	Z, r19

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3968:	32 e0       	ldi	r19, 0x02	; 2
    396a:	32 87       	std	Z+10, r19	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    396c:	54 87       	std	Z+12, r21	; 0x0c
    396e:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    3970:	21 11       	cpse	r18, r1
    3972:	ea c0       	rjmp	.+468    	; 0x3b48 <DoSampler+0x1522>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3974:	20 91 84 00 	lds	r18, 0x0084
    3978:	30 91 85 00 	lds	r19, 0x0085
    397c:	24 0f       	add	r18, r20
    397e:	35 1f       	adc	r19, r21
    3980:	30 93 89 00 	sts	0x0089, r19
    3984:	20 93 88 00 	sts	0x0088, r18
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    3988:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    398a:	20 91 6f 00 	lds	r18, 0x006F
    398e:	22 60       	ori	r18, 0x02	; 2
    3990:	20 93 6f 00 	sts	0x006F, r18
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3994:	21 e0       	ldi	r18, 0x01	; 1
    3996:	20 93 81 00 	sts	0x0081, r18
		cli();		// Disable interrupts while we muck with the settings.

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    399a:	24 e2       	ldi	r18, 0x24	; 36
    399c:	28 9f       	mul	r18, r24
    399e:	f0 01       	movw	r30, r0
    39a0:	29 9f       	mul	r18, r25
    39a2:	f0 0d       	add	r31, r0
    39a4:	11 24       	eor	r1, r1
    39a6:	13 cb       	rjmp	.-2522   	; 0x2fce <DoSampler+0x9a8>
					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
					break;

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    39a8:	82 30       	cpi	r24, 0x02	; 2
    39aa:	09 f4       	brne	.+2      	; 0x39ae <DoSampler+0x1388>
    39ac:	af c0       	rjmp	.+350    	; 0x3b0c <DoSampler+0x14e6>
    39ae:	83 30       	cpi	r24, 0x03	; 3
    39b0:	11 f0       	breq	.+4      	; 0x39b6 <DoSampler+0x1390>
    39b2:	0c 94 23 13 	jmp	0x2646	; 0x2646 <DoSampler+0x20>
						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
						break;

						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    39b6:	82 e4       	ldi	r24, 0x42	; 66
    39b8:	99 e0       	ldi	r25, 0x09	; 9
    39ba:	90 93 e2 05 	sts	0x05E2, r25
    39be:	80 93 e1 05 	sts	0x05E1, r24
    39c2:	60 91 4f 05 	lds	r22, 0x054F
						break;
    39c6:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    39ca:	24 e2       	ldi	r18, 0x24	; 36
    39cc:	e2 9f       	mul	r30, r18
    39ce:	f0 01       	movw	r30, r0
    39d0:	11 24       	eor	r1, r1
    39d2:	eb 51       	subi	r30, 0x1B	; 27
    39d4:	fa 4f       	sbci	r31, 0xFA	; 250
    39d6:	13 82       	std	Z+3, r1	; 0x03
    39d8:	45 cc       	rjmp	.-1910   	; 0x3264 <DoSampler+0xc3e>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    39da:	a4 e2       	ldi	r26, 0x24	; 36
    39dc:	ea 9f       	mul	r30, r26
    39de:	f0 01       	movw	r30, r0
    39e0:	11 24       	eor	r1, r1
    39e2:	eb 51       	subi	r30, 0x1B	; 27
    39e4:	fa 4f       	sbci	r31, 0xFA	; 250
    39e6:	12 82       	std	Z+2, r1	; 0x02
    39e8:	60 91 4f 05 	lds	r22, 0x054F
    39ec:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    39f0:	84 e2       	ldi	r24, 0x24	; 36
    39f2:	e8 9f       	mul	r30, r24
    39f4:	f0 01       	movw	r30, r0
    39f6:	11 24       	eor	r1, r1
    39f8:	eb 51       	subi	r30, 0x1B	; 27
    39fa:	fa 4f       	sbci	r31, 0xFA	; 250
    39fc:	81 e0       	ldi	r24, 0x01	; 1
    39fe:	81 83       	std	Z+1, r24	; 0x01
    3a00:	60 91 4f 05 	lds	r22, 0x054F
    3a04:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
				switch(currentMidiMessage.dataByteOne)
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    3a08:	80 91 6a 05 	lds	r24, 0x056A
    3a0c:	e8 2f       	mov	r30, r24
    3a0e:	f0 e0       	ldi	r31, 0x00	; 0
    3a10:	ee 0f       	add	r30, r30
    3a12:	ff 1f       	adc	r31, r31
    3a14:	ed 59       	subi	r30, 0x9D	; 157
    3a16:	fa 4f       	sbci	r31, 0xFA	; 250
    3a18:	40 81       	ld	r20, Z
    3a1a:	51 81       	ldd	r21, Z+1	; 0x01
    3a1c:	62 e0       	ldi	r22, 0x02	; 2
    3a1e:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <StartRecording>
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll default to playback after a recording.
    3a22:	e0 91 6a 05 	lds	r30, 0x056A
    3a26:	44 e2       	ldi	r20, 0x24	; 36
    3a28:	e4 9f       	mul	r30, r20
    3a2a:	f0 01       	movw	r30, r0
    3a2c:	11 24       	eor	r1, r1
    3a2e:	eb 51       	subi	r30, 0x1B	; 27
    3a30:	fa 4f       	sbci	r31, 0xFA	; 250
    3a32:	16 82       	std	Z+6, r1	; 0x06
    3a34:	60 91 4f 05 	lds	r22, 0x054F
    3a38:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3a3c:	90 93 8b 00 	sts	0x008B, r25
    3a40:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    3a44:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    3a46:	80 91 6f 00 	lds	r24, 0x006F
    3a4a:	84 60       	ori	r24, 0x04	; 4
    3a4c:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3a50:	81 e0       	ldi	r24, 0x01	; 1
    3a52:	80 93 81 00 	sts	0x0081, r24
    3a56:	97 cc       	rjmp	.-1746   	; 0x3386 <DoSampler+0xd60>
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    3a58:	40 91 6a 05 	lds	r20, 0x056A
    3a5c:	84 2f       	mov	r24, r20
    3a5e:	90 e0       	ldi	r25, 0x00	; 0
    3a60:	fc 01       	movw	r30, r24
    3a62:	ee 0f       	add	r30, r30
    3a64:	ff 1f       	adc	r31, r31
    3a66:	ed 59       	subi	r30, 0x9D	; 157
    3a68:	fa 4f       	sbci	r31, 0xFA	; 250
    3a6a:	20 81       	ld	r18, Z
    3a6c:	31 81       	ldd	r19, Z+1	; 0x01
// OK to do realtime even when banks are locked since we don't use the RAM
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3a6e:	5f b7       	in	r21, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    3a70:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    3a72:	64 e2       	ldi	r22, 0x24	; 36
    3a74:	68 9f       	mul	r22, r24
    3a76:	f0 01       	movw	r30, r0
    3a78:	69 9f       	mul	r22, r25
    3a7a:	f0 0d       	add	r31, r0
    3a7c:	11 24       	eor	r1, r1
    3a7e:	eb 51       	subi	r30, 0x1B	; 27
    3a80:	fa 4f       	sbci	r31, 0xFA	; 250
    3a82:	82 e0       	ldi	r24, 0x02	; 2
    3a84:	80 83       	st	Z, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3a86:	82 87       	std	Z+10, r24	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    3a88:	34 87       	std	Z+12, r19	; 0x0c
    3a8a:	23 87       	std	Z+11, r18	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3a8c:	80 91 84 00 	lds	r24, 0x0084
    3a90:	90 91 85 00 	lds	r25, 0x0085
    3a94:	82 0f       	add	r24, r18
    3a96:	93 1f       	adc	r25, r19

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    3a98:	41 11       	cpse	r20, r1
    3a9a:	2a c0       	rjmp	.+84     	; 0x3af0 <DoSampler+0x14ca>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3a9c:	90 93 89 00 	sts	0x0089, r25
    3aa0:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    3aa4:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    3aa6:	80 91 6f 00 	lds	r24, 0x006F
    3aaa:	82 60       	ori	r24, 0x02	; 2
    3aac:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3ab0:	81 e0       	ldi	r24, 0x01	; 1
    3ab2:	80 93 81 00 	sts	0x0081, r24
	cli();		// Disable interrupts while we muck with the settings.

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.

	SREG=sreg;		// Restore interrupts.
    3ab6:	5f bf       	out	0x3f, r21	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3ab8:	80 91 7a 00 	lds	r24, 0x007A
    3abc:	86 fd       	sbrc	r24, 6
    3abe:	0a c0       	rjmp	.+20     	; 0x3ad4 <DoSampler+0x14ae>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3ac0:	80 91 79 00 	lds	r24, 0x0079
    3ac4:	80 58       	subi	r24, 0x80	; 128
    3ac6:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    3aca:	80 91 7a 00 	lds	r24, 0x007A
    3ace:	80 64       	ori	r24, 0x40	; 64
    3ad0:	80 93 7a 00 	sts	0x007A, r24

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so that we don't stop realtime processing if we get a note off.
    3ad4:	e0 91 6a 05 	lds	r30, 0x056A
    3ad8:	24 e2       	ldi	r18, 0x24	; 36
    3ada:	e2 9f       	mul	r30, r18
    3adc:	f0 01       	movw	r30, r0
    3ade:	11 24       	eor	r1, r1
    3ae0:	eb 51       	subi	r30, 0x1B	; 27
    3ae2:	fa 4f       	sbci	r31, 0xFA	; 250
    3ae4:	81 e0       	ldi	r24, 0x01	; 1
    3ae6:	86 83       	std	Z+6, r24	; 0x06
    3ae8:	60 91 4f 05 	lds	r22, 0x054F
    3aec:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3af0:	90 93 8b 00 	sts	0x008B, r25
    3af4:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    3af8:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    3afa:	80 91 6f 00 	lds	r24, 0x006F
    3afe:	84 60       	ori	r24, 0x04	; 4
    3b00:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	80 93 81 00 	sts	0x0081, r24
    3b0a:	d5 cf       	rjmp	.-86     	; 0x3ab6 <DoSampler+0x1490>
						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
						break;

						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3b0c:	8f e7       	ldi	r24, 0x7F	; 127
    3b0e:	99 e0       	ldi	r25, 0x09	; 9
    3b10:	90 93 e2 05 	sts	0x05E2, r25
    3b14:	80 93 e1 05 	sts	0x05E1, r24
    3b18:	60 91 4f 05 	lds	r22, 0x054F
						break;
    3b1c:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    3b20:	8b e0       	ldi	r24, 0x0B	; 11
    3b22:	90 e0       	ldi	r25, 0x00	; 0
    3b24:	0e 94 12 27 	call	0x4e24	; 0x4e24 <EepromWrite>
    3b28:	37 cb       	rjmp	.-2450   	; 0x3198 <DoSampler+0xb72>
static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    3b2a:	87 e0       	ldi	r24, 0x07	; 7
    3b2c:	90 e0       	ldi	r25, 0x00	; 0
    3b2e:	0e 94 12 27 	call	0x4e24	; 0x4e24 <EepromWrite>
    3b32:	32 cb       	rjmp	.-2460   	; 0x3198 <DoSampler+0xb72>
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3b34:	8c eb       	ldi	r24, 0xBC	; 188
    3b36:	98 e0       	ldi	r25, 0x08	; 8
    3b38:	90 93 e2 05 	sts	0x05E2, r25
    3b3c:	80 93 e1 05 	sts	0x05E1, r24
    3b40:	60 91 4f 05 	lds	r22, 0x054F
						break;
    3b44:	0c 94 25 13 	jmp	0x264a	; 0x264a <DoSampler+0x24>
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    3b48:	20 91 84 00 	lds	r18, 0x0084
    3b4c:	30 91 85 00 	lds	r19, 0x0085
    3b50:	24 0f       	add	r18, r20
    3b52:	35 1f       	adc	r19, r21
    3b54:	30 93 8b 00 	sts	0x008B, r19
    3b58:	20 93 8a 00 	sts	0x008A, r18
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    3b5c:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    3b5e:	20 91 6f 00 	lds	r18, 0x006F
    3b62:	24 60       	ori	r18, 0x04	; 4
    3b64:	20 93 6f 00 	sts	0x006F, r18
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    3b68:	21 e0       	ldi	r18, 0x01	; 1
    3b6a:	20 93 81 00 	sts	0x0081, r18
    3b6e:	15 cf       	rjmp	.-470    	; 0x399a <DoSampler+0x1374>

00003b70 <DoSawtooth>:

static void DoSawtooth(void)
// See if we can get some audio out.  And look good doing it.
// Also test to see if our flash is present and working.
{
	if(subState==SS_0)
    3b70:	80 91 60 05 	lds	r24, 0x0560
    3b74:	88 23       	and	r24, r24
    3b76:	09 f4       	brne	.+2      	; 0x3b7a <DoSawtooth+0xa>
    3b78:	69 c0       	rjmp	.+210    	; 0x3c4c <DoSawtooth+0xdc>
	{
		KillLeds();							// Start with LEDs off.
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
		subState=SS_1;
	}
	else if(subState==SS_1)
    3b7a:	81 30       	cpi	r24, 0x01	; 1
    3b7c:	09 f4       	brne	.+2      	; 0x3b80 <DoSawtooth+0x10>
    3b7e:	c5 c0       	rjmp	.+394    	; 0x3d0a <DoSawtooth+0x19a>
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.

		subState=SS_2;					// And wait forever.
	}
	else if(subState==SS_2)
    3b80:	82 30       	cpi	r24, 0x02	; 2
    3b82:	09 f0       	breq	.+2      	; 0x3b86 <DoSawtooth+0x16>
    3b84:	08 95       	ret
	{

		if(newKeys&Im_SWITCH_0)
    3b86:	80 91 5c 05 	lds	r24, 0x055C
    3b8a:	80 ff       	sbrs	r24, 0
    3b8c:	06 c0       	rjmp	.+12     	; 0x3b9a <DoSawtooth+0x2a>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    3b8e:	90 91 62 05 	lds	r25, 0x0562
    3b92:	21 e0       	ldi	r18, 0x01	; 1
    3b94:	92 27       	eor	r25, r18
    3b96:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_1)
    3b9a:	81 ff       	sbrs	r24, 1
    3b9c:	06 c0       	rjmp	.+12     	; 0x3baa <DoSawtooth+0x3a>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    3b9e:	90 91 62 05 	lds	r25, 0x0562
    3ba2:	22 e0       	ldi	r18, 0x02	; 2
    3ba4:	92 27       	eor	r25, r18
    3ba6:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_2)
    3baa:	82 ff       	sbrs	r24, 2
    3bac:	06 c0       	rjmp	.+12     	; 0x3bba <DoSawtooth+0x4a>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    3bae:	90 91 62 05 	lds	r25, 0x0562
    3bb2:	24 e0       	ldi	r18, 0x04	; 4
    3bb4:	92 27       	eor	r25, r18
    3bb6:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_3)
    3bba:	83 ff       	sbrs	r24, 3
    3bbc:	06 c0       	rjmp	.+12     	; 0x3bca <DoSawtooth+0x5a>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    3bbe:	90 91 62 05 	lds	r25, 0x0562
    3bc2:	28 e0       	ldi	r18, 0x08	; 8
    3bc4:	92 27       	eor	r25, r18
    3bc6:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_4)
    3bca:	84 ff       	sbrs	r24, 4
    3bcc:	06 c0       	rjmp	.+12     	; 0x3bda <DoSawtooth+0x6a>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    3bce:	90 91 62 05 	lds	r25, 0x0562
    3bd2:	20 e1       	ldi	r18, 0x10	; 16
    3bd4:	92 27       	eor	r25, r18
    3bd6:	90 93 62 05 	sts	0x0562, r25
		}
		if(newKeys&Im_SWITCH_5)
    3bda:	85 ff       	sbrs	r24, 5
    3bdc:	06 c0       	rjmp	.+12     	; 0x3bea <DoSawtooth+0x7a>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    3bde:	90 91 62 05 	lds	r25, 0x0562
    3be2:	20 e2       	ldi	r18, 0x20	; 32
    3be4:	92 27       	eor	r25, r18
    3be6:	90 93 62 05 	sts	0x0562, r25
		}

		if(newKeys&Im_SWITCH_6)
    3bea:	86 fd       	sbrc	r24, 6
    3bec:	61 c0       	rjmp	.+194    	; 0x3cb0 <DoSawtooth+0x140>
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
    3bee:	87 fd       	sbrc	r24, 7
    3bf0:	a9 c0       	rjmp	.+338    	; 0x3d44 <DoSawtooth+0x1d4>
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
    3bf2:	80 91 59 05 	lds	r24, 0x0559
    3bf6:	88 23       	and	r24, r24
    3bf8:	29 f2       	breq	.-118    	; 0x3b84 <DoSawtooth+0x14>
    3bfa:	30 91 b1 05 	lds	r19, 0x05B1
    3bfe:	83 2f       	mov	r24, r19
    3c00:	90 e0       	ldi	r25, 0x00	; 0
    3c02:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c06:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c08:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c0a:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c0c:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c0e:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c10:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c12:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c14:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c16:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c18:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c1a:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c1c:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c1e:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c20:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c22:	88 0f       	add	r24, r24
    3c24:	89 2f       	mov	r24, r25
    3c26:	88 1f       	adc	r24, r24
    3c28:	99 0b       	sbc	r25, r25
    3c2a:	89 2b       	or	r24, r25
    3c2c:	09 f0       	breq	.+2      	; 0x3c30 <DoSawtooth+0xc0>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c2e:	2f 77       	andi	r18, 0x7F	; 127
    3c30:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3c34:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3c38:	68 e9       	ldi	r22, 0x98	; 152
    3c3a:	70 e0       	ldi	r23, 0x00	; 0
    3c3c:	82 e0       	ldi	r24, 0x02	; 2
    3c3e:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    3c42:	80 91 58 05 	lds	r24, 0x0558
    3c46:	80 93 62 05 	sts	0x0562, r24
    3c4a:	08 95       	ret
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    3c4c:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3c50:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3c54:	68 e9       	ldi	r22, 0x98	; 152
    3c56:	70 e0       	ldi	r23, 0x00	; 0
    3c58:	82 e0       	ldi	r24, 0x02	; 2
    3c5a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
    3c5e:	30 91 b1 05 	lds	r19, 0x05B1
    3c62:	83 2f       	mov	r24, r19
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c6a:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c6c:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c6e:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c70:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c72:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c74:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c76:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c78:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c7a:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c7c:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c7e:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c80:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c82:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c84:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3c86:	88 0f       	add	r24, r24
    3c88:	89 2f       	mov	r24, r25
    3c8a:	88 1f       	adc	r24, r24
    3c8c:	99 0b       	sbc	r25, r25
    3c8e:	89 2b       	or	r24, r25
    3c90:	09 f0       	breq	.+2      	; 0x3c94 <DoSawtooth+0x124>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3c92:	2f 77       	andi	r18, 0x7F	; 127
    3c94:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3c98:	80 ec       	ldi	r24, 0xC0	; 192
    3c9a:	80 93 b1 05 	sts	0x05B1, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3c9e:	68 e9       	ldi	r22, 0x98	; 152
    3ca0:	70 e0       	ldi	r23, 0x00	; 0
    3ca2:	82 e0       	ldi	r24, 0x02	; 2
    3ca4:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
{
	if(subState==SS_0)
	{
		KillLeds();							// Start with LEDs off.
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
		subState=SS_1;
    3ca8:	81 e0       	ldi	r24, 0x01	; 1
    3caa:	80 93 60 05 	sts	0x0560, r24
    3cae:	08 95       	ret
    3cb0:	30 91 b1 05 	lds	r19, 0x05B1
    3cb4:	83 2f       	mov	r24, r19
    3cb6:	90 e0       	ldi	r25, 0x00	; 0
    3cb8:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cbc:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cbe:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cc0:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cc2:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cc4:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cc6:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cc8:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cca:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3ccc:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cce:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cd0:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cd2:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cd4:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3cd6:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3cd8:	88 0f       	add	r24, r24
    3cda:	89 2f       	mov	r24, r25
    3cdc:	88 1f       	adc	r24, r24
    3cde:	99 0b       	sbc	r25, r25
    3ce0:	89 2b       	or	r24, r25
    3ce2:	09 f0       	breq	.+2      	; 0x3ce6 <DoSawtooth+0x176>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3ce4:	2f 77       	andi	r18, 0x7F	; 127
    3ce6:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3cea:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3cee:	68 e9       	ldi	r22, 0x98	; 152
    3cf0:	70 e0       	ldi	r23, 0x00	; 0
    3cf2:	82 e0       	ldi	r24, 0x02	; 2
    3cf4:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		}

		if(newKeys&Im_SWITCH_6)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    3cf8:	80 91 62 05 	lds	r24, 0x0562
    3cfc:	90 e4       	ldi	r25, 0x40	; 64
    3cfe:	89 27       	eor	r24, r25
    3d00:	80 93 62 05 	sts	0x0562, r24
    3d04:	80 91 5c 05 	lds	r24, 0x055C
    3d08:	72 cf       	rjmp	.-284    	; 0x3bee <DoSawtooth+0x7e>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
		subState=SS_1;
	}
	else if(subState==SS_1)
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    3d0a:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    3d0c:	80 93 e5 05 	sts	0x05E5, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    3d10:	80 93 ef 05 	sts	0x05EF, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    3d14:	80 93 ef 05 	sts	0x05EF, r24
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    3d18:	80 91 81 00 	lds	r24, 0x0081
    3d1c:	80 64       	ori	r24, 0x40	; 64
    3d1e:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    3d22:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3d24:	80 91 6f 00 	lds	r24, 0x006F
    3d28:	80 62       	ori	r24, 0x20	; 32
    3d2a:	80 93 6f 00 	sts	0x006F, r24
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3d2e:	8c e0       	ldi	r24, 0x0C	; 12
    3d30:	99 e0       	ldi	r25, 0x09	; 9
    3d32:	90 93 e2 05 	sts	0x05E2, r25
    3d36:	80 93 e1 05 	sts	0x05E1, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    3d3a:	78 94       	sei

		subState=SS_2;					// And wait forever.
    3d3c:	82 e0       	ldi	r24, 0x02	; 2
    3d3e:	80 93 60 05 	sts	0x0560, r24
    3d42:	08 95       	ret
    3d44:	30 91 b1 05 	lds	r19, 0x05B1
    3d48:	83 2f       	mov	r24, r19
    3d4a:	90 e0       	ldi	r25, 0x00	; 0
    3d4c:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d50:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d52:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d54:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d56:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d58:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d5a:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d5c:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d5e:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d60:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d62:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d64:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d66:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d68:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d6a:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3d6c:	88 0f       	add	r24, r24
    3d6e:	89 2f       	mov	r24, r25
    3d70:	88 1f       	adc	r24, r24
    3d72:	99 0b       	sbc	r25, r25
    3d74:	89 2b       	or	r24, r25
    3d76:	09 f0       	breq	.+2      	; 0x3d7a <DoSawtooth+0x20a>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3d78:	2f 77       	andi	r18, 0x7F	; 127
    3d7a:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3d7e:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3d82:	68 e9       	ldi	r22, 0x98	; 152
    3d84:	70 e0       	ldi	r23, 0x00	; 0
    3d86:	82 e0       	ldi	r24, 0x02	; 2
    3d88:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    3d8c:	80 91 62 05 	lds	r24, 0x0562
    3d90:	80 58       	subi	r24, 0x80	; 128
    3d92:	80 93 62 05 	sts	0x0562, r24
    3d96:	2d cf       	rjmp	.-422    	; 0x3bf2 <DoSawtooth+0x82>

00003d98 <SdCardMenu>:
// NOTE:  Load and Save functions apply to the bank currently selected.

// Button		0			1			2			3			4			5			6			7
// -------------------------------------------------------------------------------------------------------------------
// No Shift:	Play		Load		Save		Delete		Exit		Exit		Exit		Exit
{
    3d98:	bf 92       	push	r11
    3d9a:	cf 92       	push	r12
    3d9c:	df 92       	push	r13
    3d9e:	ef 92       	push	r14
    3da0:	ff 92       	push	r15
    3da2:	0f 93       	push	r16
    3da4:	1f 93       	push	r17
    3da6:	cf 93       	push	r28
    3da8:	df 93       	push	r29
	if(subState==SS_0)		// Initialize LEDs and slots
    3daa:	80 91 60 05 	lds	r24, 0x0560
    3dae:	81 11       	cpse	r24, r1
    3db0:	6e c0       	rjmp	.+220    	; 0x3e8e <SdCardMenu+0xf6>
	{		
		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
    3db2:	80 91 68 05 	lds	r24, 0x0568
    3db6:	90 91 69 05 	lds	r25, 0x0569
    3dba:	80 38       	cpi	r24, 0x80	; 128
    3dbc:	91 05       	cpc	r25, r1
    3dbe:	08 f0       	brcs	.+2      	; 0x3dc2 <SdCardMenu+0x2a>
    3dc0:	28 c2       	rjmp	.+1104   	; 0x4212 <SdCardMenu+0x47a>
    3dc2:	48 2f       	mov	r20, r24
    3dc4:	20 91 b1 05 	lds	r18, 0x05B1
    3dc8:	82 2f       	mov	r24, r18
    3dca:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3dcc:	20 fd       	sbrc	r18, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3dce:	4e 7f       	andi	r20, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3dd0:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3dd2:	4d 7f       	andi	r20, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3dd4:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3dd6:	4b 7f       	andi	r20, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3dd8:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3dda:	47 7f       	andi	r20, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3ddc:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3dde:	4f 7e       	andi	r20, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3de0:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3de2:	4f 7d       	andi	r20, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3de4:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3de6:	4f 7b       	andi	r20, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3de8:	9c 01       	movw	r18, r24
    3dea:	22 0f       	add	r18, r18
    3dec:	23 2f       	mov	r18, r19
    3dee:	22 1f       	adc	r18, r18
    3df0:	33 0b       	sbc	r19, r19
    3df2:	23 2b       	or	r18, r19
    3df4:	09 f0       	breq	.+2      	; 0x3df8 <SdCardMenu+0x60>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3df6:	4f 77       	andi	r20, 0x7F	; 127
    3df8:	40 93 62 05 	sts	0x0562, r20
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3dfc:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3e00:	68 e9       	ldi	r22, 0x98	; 152
    3e02:	70 e0       	ldi	r23, 0x00	; 0
    3e04:	82 e0       	ldi	r24, 0x02	; 2
    3e06:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		}		

		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently looking at
		StopBlinking();					// Make sure nothing is errantly blinking

		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
    3e0a:	20 91 68 05 	lds	r18, 0x0568
    3e0e:	30 91 69 05 	lds	r19, 0x0569
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    3e12:	f9 01       	movw	r30, r18
    3e14:	f6 95       	lsr	r31
    3e16:	e7 95       	ror	r30
    3e18:	f6 95       	lsr	r31
    3e1a:	e7 95       	ror	r30
    3e1c:	f6 95       	lsr	r31
    3e1e:	e7 95       	ror	r30
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    3e20:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3e22:	ef 58       	subi	r30, 0x8F	; 143
    3e24:	fa 4f       	sbci	r31, 0xFA	; 250
    3e26:	80 81       	ld	r24, Z
    3e28:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    3e2a:	27 70       	andi	r18, 0x07	; 7
    3e2c:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3e2e:	02 c0       	rjmp	.+4      	; 0x3e34 <SdCardMenu+0x9c>
    3e30:	95 95       	asr	r25
    3e32:	87 95       	ror	r24
    3e34:	2a 95       	dec	r18
    3e36:	e2 f7       	brpl	.-8      	; 0x3e30 <SdCardMenu+0x98>
    3e38:	80 ff       	sbrs	r24, 0
    3e3a:	25 c0       	rjmp	.+74     	; 0x3e86 <SdCardMenu+0xee>
    3e3c:	30 91 b1 05 	lds	r19, 0x05B1
    3e40:	83 2f       	mov	r24, r19
    3e42:	90 e0       	ldi	r25, 0x00	; 0
    3e44:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e48:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e4a:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e4c:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e4e:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e50:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e52:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e54:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e56:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e58:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e5a:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e5c:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e5e:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e60:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3e62:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3e64:	88 0f       	add	r24, r24
    3e66:	89 2f       	mov	r24, r25
    3e68:	88 1f       	adc	r24, r24
    3e6a:	99 0b       	sbc	r25, r25
    3e6c:	89 2b       	or	r24, r25
    3e6e:	09 f0       	breq	.+2      	; 0x3e72 <SdCardMenu+0xda>
    3e70:	d8 c1       	rjmp	.+944    	; 0x4222 <SdCardMenu+0x48a>
    3e72:	20 93 62 05 	sts	0x0562, r18
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3e76:	80 e8       	ldi	r24, 0x80	; 128
    3e78:	80 93 b1 05 	sts	0x05B1, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3e7c:	68 e9       	ldi	r22, 0x98	; 152
    3e7e:	70 e0       	ldi	r23, 0x00	; 0
    3e80:	82 e0       	ldi	r24, 0x02	; 2
    3e82:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
		{
			BlinkLeds(1<<LED_7);
		}	

		subState=SS_1;
    3e86:	81 e0       	ldi	r24, 0x01	; 1
    3e88:	80 93 60 05 	sts	0x0560, r24
    3e8c:	19 c0       	rjmp	.+50     	; 0x3ec0 <SdCardMenu+0x128>
	}
	else
	{
		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
    3e8e:	80 91 5f 05 	lds	r24, 0x055F
    3e92:	81 11       	cpse	r24, r1
    3e94:	1f c0       	rjmp	.+62     	; 0x3ed4 <SdCardMenu+0x13c>
		{
			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    3e96:	80 91 5e 05 	lds	r24, 0x055E
    3e9a:	81 11       	cpse	r24, r1
    3e9c:	c4 c1       	rjmp	.+904    	; 0x4226 <SdCardMenu+0x48e>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    3e9e:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3ea2:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3ea6:	68 e9       	ldi	r22, 0x98	; 152
    3ea8:	70 e0       	ldi	r23, 0x00	; 0
    3eaa:	82 e0       	ldi	r24, 0x02	; 2
    3eac:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    3eb0:	83 e1       	ldi	r24, 0x13	; 19
    3eb2:	93 e1       	ldi	r25, 0x13	; 19
    3eb4:	90 93 e4 05 	sts	0x05E4, r25
    3eb8:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    3ebc:	10 92 60 05 	sts	0x0560, r1
				KillLeds();
				SetState(DoSampler);
			}
		}
	}
}
    3ec0:	df 91       	pop	r29
    3ec2:	cf 91       	pop	r28
    3ec4:	1f 91       	pop	r17
    3ec6:	0f 91       	pop	r16
    3ec8:	ff 90       	pop	r15
    3eca:	ef 90       	pop	r14
    3ecc:	df 90       	pop	r13
    3ece:	cf 90       	pop	r12
    3ed0:	bf 90       	pop	r11
    3ed2:	08 95       	ret

		subState=SS_1;
	}
	else
	{
		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
    3ed4:	80 91 5e 05 	lds	r24, 0x055E
    3ed8:	8f 30       	cpi	r24, 0x0F	; 15
    3eda:	09 f4       	brne	.+2      	; 0x3ede <SdCardMenu+0x146>
    3edc:	a4 c1       	rjmp	.+840    	; 0x4226 <SdCardMenu+0x48e>
			KillLeds();				// Exit menu
			SetState(DoSampler);
		}
		else
		{
			if(newEncoder)		// Increment or decrement card slot if encoder moves
    3ede:	80 91 59 05 	lds	r24, 0x0559
    3ee2:	88 23       	and	r24, r24
    3ee4:	09 f4       	brne	.+2      	; 0x3ee8 <SdCardMenu+0x150>
    3ee6:	4b c0       	rjmp	.+150    	; 0x3f7e <SdCardMenu+0x1e6>
			{
				if(encoderCw)
    3ee8:	80 91 5a 05 	lds	r24, 0x055A
    3eec:	81 11       	cpse	r24, r1
    3eee:	c8 c1       	rjmp	.+912    	; 0x4280 <SdCardMenu+0x4e8>
					if(sdCurrentSlot>127)
					{
						sdCurrentSlot=0;
					}
				}
				else if(encoderCcw)
    3ef0:	80 91 5b 05 	lds	r24, 0x055B
				{
					if(sdCurrentSlot==0)
    3ef4:	40 91 68 05 	lds	r20, 0x0568
    3ef8:	50 91 69 05 	lds	r21, 0x0569
					if(sdCurrentSlot>127)
					{
						sdCurrentSlot=0;
					}
				}
				else if(encoderCcw)
    3efc:	88 23       	and	r24, r24
    3efe:	09 f4       	brne	.+2      	; 0x3f02 <SdCardMenu+0x16a>
    3f00:	04 c2       	rjmp	.+1032   	; 0x430a <SdCardMenu+0x572>
				{
					if(sdCurrentSlot==0)
    3f02:	41 15       	cp	r20, r1
    3f04:	51 05       	cpc	r21, r1
    3f06:	09 f0       	breq	.+2      	; 0x3f0a <SdCardMenu+0x172>
    3f08:	fa c1       	rjmp	.+1012   	; 0x42fe <SdCardMenu+0x566>
					{
						sdCurrentSlot=127;
    3f0a:	8f e7       	ldi	r24, 0x7F	; 127
    3f0c:	90 e0       	ldi	r25, 0x00	; 0
    3f0e:	90 93 69 05 	sts	0x0569, r25
    3f12:	80 93 68 05 	sts	0x0568, r24
    3f16:	47 e0       	ldi	r20, 0x07	; 7
    3f18:	50 e0       	ldi	r21, 0x00	; 0
    3f1a:	2f e0       	ldi	r18, 0x0F	; 15
    3f1c:	30 e0       	ldi	r19, 0x00	; 0
    3f1e:	6f e7       	ldi	r22, 0x7F	; 127
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3f20:	f9 01       	movw	r30, r18
    3f22:	ef 58       	subi	r30, 0x8F	; 143
    3f24:	fa 4f       	sbci	r31, 0xFA	; 250
    3f26:	80 81       	ld	r24, Z
    3f28:	90 e0       	ldi	r25, 0x00	; 0
    3f2a:	02 c0       	rjmp	.+4      	; 0x3f30 <SdCardMenu+0x198>
    3f2c:	95 95       	asr	r25
    3f2e:	87 95       	ror	r24
    3f30:	4a 95       	dec	r20
    3f32:	e2 f7       	brpl	.-8      	; 0x3f2c <SdCardMenu+0x194>
    3f34:	20 91 b1 05 	lds	r18, 0x05B1
    3f38:	80 ff       	sbrs	r24, 0
    3f3a:	bb c1       	rjmp	.+886    	; 0x42b2 <SdCardMenu+0x51a>
    3f3c:	82 2f       	mov	r24, r18
    3f3e:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f40:	20 fd       	sbrc	r18, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f42:	6e 7f       	andi	r22, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f44:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f46:	6d 7f       	andi	r22, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f48:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f4a:	6b 7f       	andi	r22, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f4c:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f4e:	67 7f       	andi	r22, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f50:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f52:	6f 7e       	andi	r22, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f54:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f56:	6f 7d       	andi	r22, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f58:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f5a:	6f 7b       	andi	r22, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    3f5c:	88 0f       	add	r24, r24
    3f5e:	89 2f       	mov	r24, r25
    3f60:	88 1f       	adc	r24, r24
    3f62:	99 0b       	sbc	r25, r25
    3f64:	89 2b       	or	r24, r25
    3f66:	09 f0       	breq	.+2      	; 0x3f6a <SdCardMenu+0x1d2>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    3f68:	6f 77       	andi	r22, 0x7F	; 127
    3f6a:	60 93 62 05 	sts	0x0562, r22
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    3f6e:	80 e8       	ldi	r24, 0x80	; 128
    3f70:	80 93 b1 05 	sts	0x05B1, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    3f74:	68 e9       	ldi	r22, 0x98	; 152
    3f76:	70 e0       	ldi	r23, 0x00	; 0
    3f78:	82 e0       	ldi	r24, 0x02	; 2
    3f7a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					StopBlinking();
					ledOnOffMask&=~(1<<LED_7);
				}
			}

			if(newKeys&Im_SWITCH_0)		// Stream sample
    3f7e:	10 91 5c 05 	lds	r17, 0x055C
    3f82:	10 ff       	sbrs	r17, 0
    3f84:	1a c0       	rjmp	.+52     	; 0x3fba <SdCardMenu+0x222>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    3f86:	80 91 68 05 	lds	r24, 0x0568
    3f8a:	90 91 69 05 	lds	r25, 0x0569
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    3f8e:	fc 01       	movw	r30, r24
    3f90:	f6 95       	lsr	r31
    3f92:	e7 95       	ror	r30
    3f94:	f6 95       	lsr	r31
    3f96:	e7 95       	ror	r30
    3f98:	f6 95       	lsr	r31
    3f9a:	e7 95       	ror	r30
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    3f9c:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3f9e:	ef 58       	subi	r30, 0x8F	; 143
    3fa0:	fa 4f       	sbci	r31, 0xFA	; 250
    3fa2:	20 81       	ld	r18, Z
    3fa4:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    3fa6:	ac 01       	movw	r20, r24
    3fa8:	47 70       	andi	r20, 0x07	; 7
    3faa:	55 27       	eor	r21, r21

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3fac:	02 c0       	rjmp	.+4      	; 0x3fb2 <SdCardMenu+0x21a>
    3fae:	35 95       	asr	r19
    3fb0:	27 95       	ror	r18
    3fb2:	4a 95       	dec	r20
    3fb4:	e2 f7       	brpl	.-8      	; 0x3fae <SdCardMenu+0x216>
    3fb6:	20 fd       	sbrc	r18, 0
    3fb8:	5e c1       	rjmp	.+700    	; 0x4276 <SdCardMenu+0x4de>
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					PlaySampleFromSd(sdCurrentSlot);
				}
			}		
			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
    3fba:	11 ff       	sbrs	r17, 1
    3fbc:	7f c0       	rjmp	.+254    	; 0x40bc <SdCardMenu+0x324>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    3fbe:	c0 90 68 05 	lds	r12, 0x0568
    3fc2:	d0 90 69 05 	lds	r13, 0x0569
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    3fc6:	f6 01       	movw	r30, r12
    3fc8:	f6 95       	lsr	r31
    3fca:	e7 95       	ror	r30
    3fcc:	f6 95       	lsr	r31
    3fce:	e7 95       	ror	r30
    3fd0:	f6 95       	lsr	r31
    3fd2:	e7 95       	ror	r30
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    3fd4:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3fd6:	ef 58       	subi	r30, 0x8F	; 143
    3fd8:	fa 4f       	sbci	r31, 0xFA	; 250
    3fda:	80 81       	ld	r24, Z
    3fdc:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    3fde:	96 01       	movw	r18, r12
    3fe0:	27 70       	andi	r18, 0x07	; 7
    3fe2:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3fe4:	02 c0       	rjmp	.+4      	; 0x3fea <SdCardMenu+0x252>
    3fe6:	95 95       	asr	r25
    3fe8:	87 95       	ror	r24
    3fea:	2a 95       	dec	r18
    3fec:	e2 f7       	brpl	.-8      	; 0x3fe6 <SdCardMenu+0x24e>
    3fee:	80 ff       	sbrs	r24, 0
    3ff0:	65 c0       	rjmp	.+202    	; 0x40bc <SdCardMenu+0x324>
			}		
			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
			{
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
    3ff2:	00 91 67 05 	lds	r16, 0x0567
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    3ff6:	80 91 5e 05 	lds	r24, 0x055E
    3ffa:	8e 30       	cpi	r24, 0x0E	; 14
    3ffc:	09 f0       	breq	.+2      	; 0x4000 <SdCardMenu+0x268>
    3ffe:	5e c0       	rjmp	.+188    	; 0x40bc <SdCardMenu+0x324>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    4000:	c0 2f       	mov	r28, r16
    4002:	d0 e0       	ldi	r29, 0x00	; 0
    4004:	84 e2       	ldi	r24, 0x24	; 36
    4006:	08 9f       	mul	r16, r24
    4008:	f0 01       	movw	r30, r0
    400a:	11 24       	eor	r1, r1
    400c:	eb 51       	subi	r30, 0x1B	; 27
    400e:	fa 4f       	sbci	r31, 0xFA	; 250
    4010:	85 81       	ldd	r24, Z+5	; 0x05
    4012:	81 11       	cpse	r24, r1
    4014:	53 c0       	rjmp	.+166    	; 0x40bc <SdCardMenu+0x324>
		{
			sreg=SREG;
    4016:	1f b7       	in	r17, 0x3f	; 63
			cli();		// Pause ISR
    4018:	f8 94       	cli
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
	unsigned char
		sreg;

	sreg=SREG;
    401a:	bf b6       	in	r11, 0x3f	; 63
	cli();		// Pause ISR
    401c:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    401e:	dc 2c       	mov	r13, r12
    4020:	cc 24       	eor	r12, r12
    4022:	dd 0c       	add	r13, r13
    4024:	dd 0c       	add	r13, r13
    4026:	4f ef       	ldi	r20, 0xFF	; 255
    4028:	c4 1a       	sub	r12, r20
    402a:	d4 0a       	sbc	r13, r20
    402c:	e1 2c       	mov	r14, r1
    402e:	f1 2c       	mov	r15, r1
    4030:	c7 01       	movw	r24, r14
    4032:	b6 01       	movw	r22, r12
    4034:	0e 94 ab 2c 	call	0x5956	; 0x5956 <SdBeginSingleBlockRead>
    4038:	81 30       	cpi	r24, 0x01	; 1
    403a:	09 f4       	brne	.+2      	; 0x403e <SdCardMenu+0x2a6>
    403c:	4c c2       	rjmp	.+1176   	; 0x44d6 <SdCardMenu+0x73e>

		SREG=sreg;	// Resume ISR

		return(true);
	}
	SREG=sreg;	// Resume ISR
    403e:	bf be       	out	0x3f, r11	; 63
		{
			sreg=SREG;
			cli();		// Pause ISR

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    4040:	81 e0       	ldi	r24, 0x01	; 1
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	a0 e0       	ldi	r26, 0x00	; 0
    4046:	b0 e0       	ldi	r27, 0x00	; 0
    4048:	80 93 22 01 	sts	0x0122, r24
    404c:	90 93 23 01 	sts	0x0123, r25
    4050:	a0 93 24 01 	sts	0x0124, r26
    4054:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;

	sreg=SREG;
    4058:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    405a:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    405c:	81 e0       	ldi	r24, 0x01	; 1
    405e:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    4062:	94 e2       	ldi	r25, 0x24	; 36
    4064:	9c 9f       	mul	r25, r28
    4066:	f0 01       	movw	r30, r0
    4068:	9d 9f       	mul	r25, r29
    406a:	f0 0d       	add	r31, r0
    406c:	11 24       	eor	r1, r1
    406e:	eb 51       	subi	r30, 0x1B	; 27
    4070:	fa 4f       	sbci	r31, 0xFA	; 250
    4072:	85 83       	std	Z+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    4074:	00 23       	and	r16, r16
    4076:	09 f4       	brne	.+2      	; 0x407a <SdCardMenu+0x2e2>
    4078:	0e c2       	rjmp	.+1052   	; 0x4496 <SdCardMenu+0x6fe>
		sdBank0=true;
		sdRamAddress=BANK_0_START_ADDRESS;
	}
	else
	{
		sdBank0=false;
    407a:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    407e:	8f ef       	ldi	r24, 0xFF	; 255
    4080:	9f ef       	ldi	r25, 0xFF	; 255
    4082:	a7 e0       	ldi	r26, 0x07	; 7
    4084:	b0 e0       	ldi	r27, 0x00	; 0
    4086:	80 93 50 05 	sts	0x0550, r24
    408a:	90 93 51 05 	sts	0x0551, r25
    408e:	a0 93 52 05 	sts	0x0552, r26
    4092:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    4096:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    409a:	81 e6       	ldi	r24, 0x61	; 97
    409c:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    40a0:	8f ef       	ldi	r24, 0xFF	; 255
    40a2:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    40a4:	80 91 70 00 	lds	r24, 0x0070
    40a8:	84 60       	ori	r24, 0x04	; 4
    40aa:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    40ae:	82 e0       	ldi	r24, 0x02	; 2
    40b0:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    40b4:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    40b6:	1f bf       	out	0x3f, r17	; 63
    40b8:	10 91 5c 05 	lds	r17, 0x055C
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
				}
			}		
			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
    40bc:	12 ff       	sbrs	r17, 2
    40be:	47 c0       	rjmp	.+142    	; 0x414e <SdCardMenu+0x3b6>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something in the bank?
    40c0:	f0 90 67 05 	lds	r15, 0x0567
    40c4:	2f 2d       	mov	r18, r15
    40c6:	30 e0       	ldi	r19, 0x00	; 0
    40c8:	84 e2       	ldi	r24, 0x24	; 36
    40ca:	f8 9e       	mul	r15, r24
    40cc:	f0 01       	movw	r30, r0
    40ce:	11 24       	eor	r1, r1
    40d0:	eb 51       	subi	r30, 0x1B	; 27
    40d2:	fa 4f       	sbci	r31, 0xFA	; 250
    40d4:	41 89       	ldd	r20, Z+17	; 0x11
    40d6:	52 89       	ldd	r21, Z+18	; 0x12
    40d8:	63 89       	ldd	r22, Z+19	; 0x13
    40da:	74 89       	ldd	r23, Z+20	; 0x14
    40dc:	85 85       	ldd	r24, Z+13	; 0x0d
    40de:	96 85       	ldd	r25, Z+14	; 0x0e
    40e0:	a7 85       	ldd	r26, Z+15	; 0x0f
    40e2:	b0 89       	ldd	r27, Z+16	; 0x10
    40e4:	48 17       	cp	r20, r24
    40e6:	59 07       	cpc	r21, r25
    40e8:	6a 07       	cpc	r22, r26
    40ea:	7b 07       	cpc	r23, r27
    40ec:	81 f1       	breq	.+96     	; 0x414e <SdCardMenu+0x3b6>
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
    40ee:	d0 91 68 05 	lds	r29, 0x0568
    40f2:	10 91 69 05 	lds	r17, 0x0569
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    40f6:	80 91 5e 05 	lds	r24, 0x055E
    40fa:	8e 30       	cpi	r24, 0x0E	; 14
    40fc:	09 f4       	brne	.+2      	; 0x4100 <SdCardMenu+0x368>
    40fe:	1b c1       	rjmp	.+566    	; 0x4336 <SdCardMenu+0x59e>
    4100:	30 91 b1 05 	lds	r19, 0x05B1
    4104:	83 2f       	mov	r24, r19
    4106:	90 e0       	ldi	r25, 0x00	; 0
    4108:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    410c:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    410e:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4110:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4112:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4114:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4116:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4118:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    411a:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    411c:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    411e:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4120:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4122:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4124:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4126:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    4128:	88 0f       	add	r24, r24
    412a:	89 2f       	mov	r24, r25
    412c:	88 1f       	adc	r24, r24
    412e:	99 0b       	sbc	r25, r25
    4130:	89 2b       	or	r24, r25
    4132:	09 f0       	breq	.+2      	; 0x4136 <SdCardMenu+0x39e>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4134:	2f 77       	andi	r18, 0x7F	; 127
    4136:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    413a:	80 e8       	ldi	r24, 0x80	; 128
    413c:	80 93 b1 05 	sts	0x05B1, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    4140:	68 e9       	ldi	r22, 0x98	; 152
    4142:	70 e0       	ldi	r23, 0x00	; 0
    4144:	82 e0       	ldi	r24, 0x02	; 2
    4146:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
    414a:	10 91 5c 05 	lds	r17, 0x055C
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
				}
			}		
			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like "freeing" a sample.
    414e:	13 ff       	sbrs	r17, 3
    4150:	57 c0       	rjmp	.+174    	; 0x4200 <SdCardMenu+0x468>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    4152:	80 91 68 05 	lds	r24, 0x0568
    4156:	90 91 69 05 	lds	r25, 0x0569
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    415a:	fc 01       	movw	r30, r24
    415c:	f6 95       	lsr	r31
    415e:	e7 95       	ror	r30
    4160:	f6 95       	lsr	r31
    4162:	e7 95       	ror	r30
    4164:	f6 95       	lsr	r31
    4166:	e7 95       	ror	r30
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    4168:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    416a:	ef 58       	subi	r30, 0x8F	; 143
    416c:	fa 4f       	sbci	r31, 0xFA	; 250
    416e:	40 81       	ld	r20, Z
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    4170:	9c 01       	movw	r18, r24
    4172:	27 70       	andi	r18, 0x07	; 7
    4174:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    4176:	84 2f       	mov	r24, r20
    4178:	90 e0       	ldi	r25, 0x00	; 0
    417a:	02 2e       	mov	r0, r18
    417c:	02 c0       	rjmp	.+4      	; 0x4182 <SdCardMenu+0x3ea>
    417e:	95 95       	asr	r25
    4180:	87 95       	ror	r24
    4182:	0a 94       	dec	r0
    4184:	e2 f7       	brpl	.-8      	; 0x417e <SdCardMenu+0x3e6>
    4186:	80 ff       	sbrs	r24, 0
    4188:	3b c0       	rjmp	.+118    	; 0x4200 <SdCardMenu+0x468>
			}		
			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like "freeing" a sample.
			{
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
    418a:	80 91 5e 05 	lds	r24, 0x055E
    418e:	8e 30       	cpi	r24, 0x0E	; 14
    4190:	b9 f5       	brne	.+110    	; 0x4200 <SdCardMenu+0x468>
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]&=~(1<<theBit);	// Clear it
    4192:	81 e0       	ldi	r24, 0x01	; 1
    4194:	90 e0       	ldi	r25, 0x00	; 0
    4196:	01 c0       	rjmp	.+2      	; 0x419a <SdCardMenu+0x402>
    4198:	88 0f       	add	r24, r24
    419a:	2a 95       	dec	r18
    419c:	ea f7       	brpl	.-6      	; 0x4198 <SdCardMenu+0x400>
    419e:	80 95       	com	r24
    41a0:	84 23       	and	r24, r20
    41a2:	80 83       	st	Z, r24
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
					{
						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
    41a4:	86 e0       	ldi	r24, 0x06	; 6
    41a6:	80 93 5e 05 	sts	0x055E, r24
    41aa:	30 91 b1 05 	lds	r19, 0x05B1
    41ae:	83 2f       	mov	r24, r19
    41b0:	90 e0       	ldi	r25, 0x00	; 0
    41b2:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41b6:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41b8:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41ba:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41bc:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41be:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41c0:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41c2:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41c4:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41c6:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41c8:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41ca:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41cc:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41ce:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41d0:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    41d2:	88 0f       	add	r24, r24
    41d4:	89 2f       	mov	r24, r25
    41d6:	88 1f       	adc	r24, r24
    41d8:	99 0b       	sbc	r25, r25
    41da:	89 2b       	or	r24, r25
    41dc:	09 f0       	breq	.+2      	; 0x41e0 <SdCardMenu+0x448>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    41de:	2f 77       	andi	r18, 0x7F	; 127
    41e0:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    41e4:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    41e8:	68 e9       	ldi	r22, 0x98	; 152
    41ea:	70 e0       	ldi	r23, 0x00	; 0
    41ec:	82 e0       	ldi	r24, 0x02	; 2
    41ee:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					if(cardState==SD_IDLE)	// Got what we wanted?
					{
						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
						StopBlinking();					// Update LED to reflect that this is now full
						ledOnOffMask&=~(1<<LED_7);
    41f2:	80 91 62 05 	lds	r24, 0x0562
    41f6:	8f 77       	andi	r24, 0x7F	; 127
    41f8:	80 93 62 05 	sts	0x0562, r24
    41fc:	10 91 5c 05 	lds	r17, 0x055C
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    4200:	14 fd       	sbrc	r17, 4
    4202:	4d ce       	rjmp	.-870    	; 0x3e9e <SdCardMenu+0x106>
//--------------------------------------

static unsigned char
	currentBank;					// Keeps track of the bank we're thinking about.

static void SdCardMenu(void)
    4204:	81 2f       	mov	r24, r17
    4206:	80 76       	andi	r24, 0x60	; 96
						ledOnOffMask&=~(1<<LED_7);
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    4208:	09 f0       	breq	.+2      	; 0x420c <SdCardMenu+0x474>
    420a:	49 ce       	rjmp	.-878    	; 0x3e9e <SdCardMenu+0x106>
    420c:	17 ff       	sbrs	r17, 7
    420e:	58 ce       	rjmp	.-848    	; 0x3ec0 <SdCardMenu+0x128>
    4210:	46 ce       	rjmp	.-884    	; 0x3e9e <SdCardMenu+0x106>
{
	if(subState==SS_0)		// Initialize LEDs and slots
	{		
		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
		{
			sdCurrentSlot=127;
    4212:	8f e7       	ldi	r24, 0x7F	; 127
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	90 93 69 05 	sts	0x0569, r25
    421a:	80 93 68 05 	sts	0x0568, r24
    421e:	4f e7       	ldi	r20, 0x7F	; 127
    4220:	d1 cd       	rjmp	.-1118   	; 0x3dc4 <SdCardMenu+0x2c>

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    4222:	2f 77       	andi	r18, 0x7F	; 127
    4224:	26 ce       	rjmp	.-948    	; 0x3e72 <SdCardMenu+0xda>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    4226:	cf b7       	in	r28, 0x3f	; 63
	cli();
    4228:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    422a:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    422e:	e1 e7       	ldi	r30, 0x71	; 113
    4230:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    4232:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    4234:	45 e0       	ldi	r20, 0x05	; 5
    4236:	e1 3b       	cpi	r30, 0xB1	; 177
    4238:	f4 07       	cpc	r31, r20
    423a:	d9 f7       	brne	.-10     	; 0x4232 <SdCardMenu+0x49a>
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
	ClearSampleToc();
	
	// Stop SD card ISR

	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    423c:	10 92 4f 05 	sts	0x054F, r1
	TCCR2B=0;					// Stop this timer
    4240:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    4244:	80 91 70 00 	lds	r24, 0x0070
    4248:	8b 7f       	andi	r24, 0xFB	; 251
    424a:	80 93 70 00 	sts	0x0070, r24

	// Set this contribution to the DAC to midscale (this output source is now quiet)
	sdStreamOutput=0;
    424e:	10 92 55 05 	sts	0x0555, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    4252:	10 92 2b 01 	sts	0x012B, r1
    4256:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    425a:	10 92 29 01 	sts	0x0129, r1
    425e:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    4262:	10 92 27 01 	sts	0x0127, r1
    4266:	10 92 26 01 	sts	0x0126, r1

	InitSdInterface();
    426a:	0e 94 1e 2a 	call	0x543c	; 0x543c <InitSdInterface>
	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
    426e:	10 92 5e 05 	sts	0x055E, r1

	SREG=sreg;
    4272:	cf bf       	out	0x3f, r28	; 63
    4274:	14 ce       	rjmp	.-984    	; 0x3e9e <SdCardMenu+0x106>

			if(newKeys&Im_SWITCH_0)		// Stream sample
			{
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					PlaySampleFromSd(sdCurrentSlot);
    4276:	0e 94 a2 11 	call	0x2344	; 0x2344 <PlaySampleFromSd>
    427a:	10 91 5c 05 	lds	r17, 0x055C
    427e:	9d ce       	rjmp	.-710    	; 0x3fba <SdCardMenu+0x222>
		{
			if(newEncoder)		// Increment or decrement card slot if encoder moves
			{
				if(encoderCw)
				{
					sdCurrentSlot++;
    4280:	80 91 68 05 	lds	r24, 0x0568
    4284:	90 91 69 05 	lds	r25, 0x0569
    4288:	01 96       	adiw	r24, 0x01	; 1
					if(sdCurrentSlot>127)
    428a:	80 38       	cpi	r24, 0x80	; 128
    428c:	91 05       	cpc	r25, r1
    428e:	08 f0       	brcs	.+2      	; 0x4292 <SdCardMenu+0x4fa>
    4290:	48 c0       	rjmp	.+144    	; 0x4322 <SdCardMenu+0x58a>
		{
			if(newEncoder)		// Increment or decrement card slot if encoder moves
			{
				if(encoderCw)
				{
					sdCurrentSlot++;
    4292:	90 93 69 05 	sts	0x0569, r25
    4296:	80 93 68 05 	sts	0x0568, r24
    429a:	68 2f       	mov	r22, r24
    429c:	9c 01       	movw	r18, r24
    429e:	36 95       	lsr	r19
    42a0:	27 95       	ror	r18
    42a2:	36 95       	lsr	r19
    42a4:	27 95       	ror	r18
    42a6:	36 95       	lsr	r19
    42a8:	27 95       	ror	r18
    42aa:	ac 01       	movw	r20, r24
    42ac:	47 70       	andi	r20, 0x07	; 7
    42ae:	55 27       	eor	r21, r21
    42b0:	37 ce       	rjmp	.-914    	; 0x3f20 <SdCardMenu+0x188>
    42b2:	82 2f       	mov	r24, r18
    42b4:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42b6:	20 fd       	sbrc	r18, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42b8:	6e 7f       	andi	r22, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42ba:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42bc:	6d 7f       	andi	r22, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42be:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42c0:	6b 7f       	andi	r22, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42c2:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42c4:	67 7f       	andi	r22, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42c6:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42c8:	6f 7e       	andi	r22, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42ca:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42cc:	6f 7d       	andi	r22, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42ce:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42d0:	6f 7b       	andi	r22, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    42d2:	88 0f       	add	r24, r24
    42d4:	89 2f       	mov	r24, r25
    42d6:	88 1f       	adc	r24, r24
    42d8:	99 0b       	sbc	r25, r25
    42da:	89 2b       	or	r24, r25
    42dc:	09 f0       	breq	.+2      	; 0x42e0 <SdCardMenu+0x548>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    42de:	6f 77       	andi	r22, 0x7F	; 127
    42e0:	60 93 62 05 	sts	0x0562, r22
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    42e4:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    42e8:	68 e9       	ldi	r22, 0x98	; 152
    42ea:	70 e0       	ldi	r23, 0x00	; 0
    42ec:	82 e0       	ldi	r24, 0x02	; 2
    42ee:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					BlinkLeds(1<<LED_7);
				}	
				else
				{
					StopBlinking();
					ledOnOffMask&=~(1<<LED_7);
    42f2:	80 91 62 05 	lds	r24, 0x0562
    42f6:	8f 77       	andi	r24, 0x7F	; 127
    42f8:	80 93 62 05 	sts	0x0562, r24
    42fc:	40 ce       	rjmp	.-896    	; 0x3f7e <SdCardMenu+0x1e6>
					{
						sdCurrentSlot=127;
					}
					else
					{
						sdCurrentSlot--;
    42fe:	41 50       	subi	r20, 0x01	; 1
    4300:	51 09       	sbc	r21, r1
    4302:	50 93 69 05 	sts	0x0569, r21
    4306:	40 93 68 05 	sts	0x0568, r20
    430a:	64 2f       	mov	r22, r20
    430c:	9a 01       	movw	r18, r20
    430e:	36 95       	lsr	r19
    4310:	27 95       	ror	r18
    4312:	36 95       	lsr	r19
    4314:	27 95       	ror	r18
    4316:	36 95       	lsr	r19
    4318:	27 95       	ror	r18
    431a:	33 27       	eor	r19, r19
    431c:	47 70       	andi	r20, 0x07	; 7
    431e:	55 27       	eor	r21, r21
    4320:	ff cd       	rjmp	.-1026   	; 0x3f20 <SdCardMenu+0x188>
				if(encoderCw)
				{
					sdCurrentSlot++;
					if(sdCurrentSlot>127)
					{
						sdCurrentSlot=0;
    4322:	10 92 69 05 	sts	0x0569, r1
    4326:	10 92 68 05 	sts	0x0568, r1
    432a:	40 e0       	ldi	r20, 0x00	; 0
    432c:	50 e0       	ldi	r21, 0x00	; 0
    432e:	20 e0       	ldi	r18, 0x00	; 0
    4330:	30 e0       	ldi	r19, 0x00	; 0
    4332:	60 e0       	ldi	r22, 0x00	; 0
    4334:	f5 cd       	rjmp	.-1046   	; 0x3f20 <SdCardMenu+0x188>
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    4336:	85 81       	ldd	r24, Z+5	; 0x05
    4338:	81 11       	cpse	r24, r1
    433a:	e2 ce       	rjmp	.-572    	; 0x4100 <SdCardMenu+0x368>
	unsigned long
		theLength;

	if(theBank==BANK_0)
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    433c:	87 81       	ldd	r24, Z+7	; 0x07
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    433e:	f1 10       	cpse	r15, r1
    4340:	90 c0       	rjmp	.+288    	; 0x4462 <SdCardMenu+0x6ca>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    4342:	81 11       	cpse	r24, r1
    4344:	b3 c0       	rjmp	.+358    	; 0x44ac <SdCardMenu+0x714>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    4346:	85 89       	ldd	r24, Z+21	; 0x15
    4348:	96 89       	ldd	r25, Z+22	; 0x16
    434a:	a7 89       	ldd	r26, Z+23	; 0x17
    434c:	b0 8d       	ldd	r27, Z+24	; 0x18
    434e:	41 8d       	ldd	r20, Z+25	; 0x19
    4350:	52 8d       	ldd	r21, Z+26	; 0x1a
    4352:	63 8d       	ldd	r22, Z+27	; 0x1b
    4354:	74 8d       	ldd	r23, Z+28	; 0x1c
    4356:	01 96       	adiw	r24, 0x01	; 1
    4358:	a1 1d       	adc	r26, r1
    435a:	b1 1d       	adc	r27, r1
    435c:	84 1b       	sub	r24, r20
    435e:	95 0b       	sbc	r25, r21
    4360:	a6 0b       	sbc	r26, r22
    4362:	b7 0b       	sbc	r27, r23
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    4364:	cf b7       	in	r28, 0x3f	; 63
			cli();		// Pause ISR
    4366:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    4368:	ef b7       	in	r30, 0x3f	; 63
	cli();		// Pause ISR
    436a:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    436c:	d0 93 68 05 	sts	0x0568, r29
    4370:	10 93 69 05 	sts	0x0569, r17
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    4374:	5d 2f       	mov	r21, r29
    4376:	55 0f       	add	r21, r21
    4378:	55 0f       	add	r21, r21
    437a:	40 e0       	ldi	r20, 0x00	; 0
    437c:	4f 5f       	subi	r20, 0xFF	; 255
    437e:	5f 4f       	sbci	r21, 0xFF	; 255
    4380:	60 e0       	ldi	r22, 0x00	; 0
    4382:	70 e0       	ldi	r23, 0x00	; 0
    4384:	40 93 b2 05 	sts	0x05B2, r20
    4388:	50 93 b3 05 	sts	0x05B3, r21
    438c:	60 93 b4 05 	sts	0x05B4, r22
    4390:	70 93 b5 05 	sts	0x05B5, r23
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    4394:	10 92 b7 05 	sts	0x05B7, r1
    4398:	10 92 b6 05 	sts	0x05B6, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    439c:	10 92 2b 01 	sts	0x012B, r1
    43a0:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    43a4:	10 92 29 01 	sts	0x0129, r1
    43a8:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    43ac:	10 92 27 01 	sts	0x0127, r1
    43b0:	10 92 26 01 	sts	0x0126, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    43b4:	8d 3f       	cpi	r24, 0xFD	; 253
    43b6:	4f ef       	ldi	r20, 0xFF	; 255
    43b8:	94 07       	cpc	r25, r20
    43ba:	47 e0       	ldi	r20, 0x07	; 7
    43bc:	a4 07       	cpc	r26, r20
    43be:	b1 05       	cpc	r27, r1
    43c0:	20 f0       	brcs	.+8      	; 0x43ca <SdCardMenu+0x632>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    43c2:	8c ef       	ldi	r24, 0xFC	; 252
    43c4:	9f ef       	ldi	r25, 0xFF	; 255
    43c6:	a7 e0       	ldi	r26, 0x07	; 7
    43c8:	b0 e0       	ldi	r27, 0x00	; 0
    43ca:	80 93 22 01 	sts	0x0122, r24
    43ce:	90 93 23 01 	sts	0x0123, r25
    43d2:	a0 93 24 01 	sts	0x0124, r26
    43d6:	b0 93 25 01 	sts	0x0125, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    43da:	80 91 22 01 	lds	r24, 0x0122
    43de:	90 91 23 01 	lds	r25, 0x0123
    43e2:	a0 91 24 01 	lds	r26, 0x0124
    43e6:	b0 91 25 01 	lds	r27, 0x0125
    43ea:	80 93 1e 01 	sts	0x011E, r24
    43ee:	90 93 1f 01 	sts	0x011F, r25
    43f2:	a0 93 20 01 	sts	0x0120, r26
    43f6:	b0 93 21 01 	sts	0x0121, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start
    43fa:	82 e0       	ldi	r24, 0x02	; 2
    43fc:	80 93 5e 05 	sts	0x055E, r24
	SREG=sreg;	// Resume ISR
    4400:	ef bf       	out	0x3f, r30	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;

	sreg=SREG;
    4402:	4f b7       	in	r20, 0x3f	; 63
	cli();		// Pause ISRs
    4404:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    4406:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    440a:	84 e2       	ldi	r24, 0x24	; 36
    440c:	82 9f       	mul	r24, r18
    440e:	f0 01       	movw	r30, r0
    4410:	83 9f       	mul	r24, r19
    4412:	f0 0d       	add	r31, r0
    4414:	11 24       	eor	r1, r1
    4416:	eb 51       	subi	r30, 0x1B	; 27
    4418:	fa 4f       	sbci	r31, 0xFA	; 250
    441a:	81 e0       	ldi	r24, 0x01	; 1
    441c:	85 83       	std	Z+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    441e:	ff 20       	and	r15, r15
    4420:	79 f1       	breq	.+94     	; 0x4480 <SdCardMenu+0x6e8>
		sdBank0=true;
		sdRamAddress=BANK_0_START_ADDRESS;
	}
	else
	{
		sdBank0=false;
    4422:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    4426:	8f ef       	ldi	r24, 0xFF	; 255
    4428:	9f ef       	ldi	r25, 0xFF	; 255
    442a:	a7 e0       	ldi	r26, 0x07	; 7
    442c:	b0 e0       	ldi	r27, 0x00	; 0
    442e:	80 93 50 05 	sts	0x0550, r24
    4432:	90 93 51 05 	sts	0x0551, r25
    4436:	a0 93 52 05 	sts	0x0552, r26
    443a:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    443e:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    4442:	81 e6       	ldi	r24, 0x61	; 97
    4444:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    4448:	8f ef       	ldi	r24, 0xFF	; 255
    444a:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    444c:	80 91 70 00 	lds	r24, 0x0070
    4450:	84 60       	ori	r24, 0x04	; 4
    4452:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    4456:	82 e0       	ldi	r24, 0x02	; 2
    4458:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    445c:	4f bf       	out	0x3f, r20	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    445e:	cf bf       	out	0x3f, r28	; 63
    4460:	4f ce       	rjmp	.-866    	; 0x4100 <SdCardMenu+0x368>
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    4462:	88 23       	and	r24, r24
    4464:	41 f1       	breq	.+80     	; 0x44b6 <SdCardMenu+0x71e>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    4466:	81 89       	ldd	r24, Z+17	; 0x11
    4468:	92 89       	ldd	r25, Z+18	; 0x12
    446a:	a3 89       	ldd	r26, Z+19	; 0x13
    446c:	b4 89       	ldd	r27, Z+20	; 0x14
    446e:	45 85       	ldd	r20, Z+13	; 0x0d
    4470:	56 85       	ldd	r21, Z+14	; 0x0e
    4472:	67 85       	ldd	r22, Z+15	; 0x0f
    4474:	70 89       	ldd	r23, Z+16	; 0x10
    4476:	84 1b       	sub	r24, r20
    4478:	95 0b       	sbc	r25, r21
    447a:	a6 0b       	sbc	r26, r22
    447c:	b7 0b       	sbc	r27, r23
    447e:	72 cf       	rjmp	.-284    	; 0x4364 <SdCardMenu+0x5cc>
	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.

	if(theBank==BANK_0)		// Pointing at this bank?
	{
		sdBank0=true;
    4480:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    4484:	10 92 50 05 	sts	0x0550, r1
    4488:	10 92 51 05 	sts	0x0551, r1
    448c:	10 92 52 05 	sts	0x0552, r1
    4490:	10 92 53 05 	sts	0x0553, r1
    4494:	d4 cf       	rjmp	.-88     	; 0x443e <SdCardMenu+0x6a6>
	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.

	if(theBank==BANK_0)		// Pointing at this bank?
	{
		sdBank0=true;
    4496:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    449a:	10 92 50 05 	sts	0x0550, r1
    449e:	10 92 51 05 	sts	0x0551, r1
    44a2:	10 92 52 05 	sts	0x0552, r1
    44a6:	10 92 53 05 	sts	0x0553, r1
    44aa:	f5 cd       	rjmp	.-1046   	; 0x4096 <SdCardMenu+0x2fe>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    44ac:	85 85       	ldd	r24, Z+13	; 0x0d
    44ae:	96 85       	ldd	r25, Z+14	; 0x0e
    44b0:	a7 85       	ldd	r26, Z+15	; 0x0f
    44b2:	b0 89       	ldd	r27, Z+16	; 0x10
    44b4:	57 cf       	rjmp	.-338    	; 0x4364 <SdCardMenu+0x5cc>
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    44b6:	81 8d       	ldd	r24, Z+25	; 0x19
    44b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    44ba:	a3 8d       	ldd	r26, Z+27	; 0x1b
    44bc:	b4 8d       	ldd	r27, Z+28	; 0x1c
    44be:	45 89       	ldd	r20, Z+21	; 0x15
    44c0:	56 89       	ldd	r21, Z+22	; 0x16
    44c2:	67 89       	ldd	r22, Z+23	; 0x17
    44c4:	70 8d       	ldd	r23, Z+24	; 0x18
    44c6:	01 96       	adiw	r24, 0x01	; 1
    44c8:	a1 1d       	adc	r26, r1
    44ca:	b1 1d       	adc	r27, r1
    44cc:	84 1b       	sub	r24, r20
    44ce:	95 0b       	sbc	r25, r21
    44d0:	a6 0b       	sbc	r26, r22
    44d2:	b7 0b       	sbc	r27, r23
    44d4:	47 cf       	rjmp	.-370    	; 0x4364 <SdCardMenu+0x5cc>
	sreg=SREG;
	cli();		// Pause ISR

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    44d6:	c0 92 b2 05 	sts	0x05B2, r12
    44da:	d0 92 b3 05 	sts	0x05B3, r13
    44de:	e0 92 b4 05 	sts	0x05B4, r14
    44e2:	f0 92 b5 05 	sts	0x05B5, r15
		sdCurrentBlockOffset=0;						// Read first block first
    44e6:	10 92 b7 05 	sts	0x05B7, r1
    44ea:	10 92 b6 05 	sts	0x05B6, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    44ee:	10 92 2b 01 	sts	0x012B, r1
    44f2:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    44f6:	10 92 29 01 	sts	0x0129, r1
    44fa:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    44fe:	10 92 27 01 	sts	0x0127, r1
    4502:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    4506:	6a e7       	ldi	r22, 0x7A	; 122
    4508:	70 e0       	ldi	r23, 0x00	; 0
    450a:	83 e0       	ldi	r24, 0x03	; 3
    450c:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    4510:	89 e0       	ldi	r24, 0x09	; 9
    4512:	80 93 5e 05 	sts	0x055E, r24

		SREG=sreg;	// Resume ISR
    4516:	bf be       	out	0x3f, r11	; 63
    4518:	93 cd       	rjmp	.-1242   	; 0x4040 <SdCardMenu+0x2a8>

0000451a <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    451a:	80 91 60 05 	lds	r24, 0x0560
    451e:	88 23       	and	r24, r24
    4520:	d9 f1       	breq	.+118    	; 0x4598 <DoFormatCard+0x7e>
		bankStates[BANK_1].clockMode=CLK_NONE;

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
		subState=SS_1;
	}
	else if(subState==SS_1)
    4522:	81 30       	cpi	r24, 0x01	; 1
    4524:	31 f1       	breq	.+76     	; 0x4572 <DoFormatCard+0x58>
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    4526:	82 30       	cpi	r24, 0x02	; 2
    4528:	09 f0       	breq	.+2      	; 0x452c <DoFormatCard+0x12>
    452a:	08 95       	ret
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    452c:	80 91 5e 05 	lds	r24, 0x055E
    4530:	8e 30       	cpi	r24, 0x0E	; 14
    4532:	d9 f7       	brne	.-10     	; 0x452a <DoFormatCard+0x10>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    4534:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    4538:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    453c:	68 e9       	ldi	r22, 0x98	; 152
    453e:	70 e0       	ldi	r23, 0x00	; 0
    4540:	82 e0       	ldi	r24, 0x02	; 2
    4542:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
	else if(subState==SS_2)
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
		{
			KillLeds();
			ledOnOffMask|=(1<<LED_1);
    4546:	80 91 62 05 	lds	r24, 0x0562
    454a:	82 60       	ori	r24, 0x02	; 2
    454c:	80 93 62 05 	sts	0x0562, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    4550:	80 91 5e 05 	lds	r24, 0x055E
    4554:	88 23       	and	r24, r24
    4556:	21 f0       	breq	.+8      	; 0x4560 <DoFormatCard+0x46>
    4558:	80 91 5c 05 	lds	r24, 0x055C
    455c:	88 23       	and	r24, r24
    455e:	29 f3       	breq	.-54     	; 0x452a <DoFormatCard+0x10>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4560:	85 e4       	ldi	r24, 0x45	; 69
    4562:	92 e1       	ldi	r25, 0x12	; 18
    4564:	90 93 e4 05 	sts	0x05E4, r25
    4568:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    456c:	10 92 60 05 	sts	0x0560, r1
    4570:	08 95       	ret
		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
		subState=SS_1;
	}
	else if(subState==SS_1)
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    4572:	80 91 5d 05 	lds	r24, 0x055D
    4576:	80 ff       	sbrs	r24, 0
    4578:	02 c0       	rjmp	.+4      	; 0x457e <DoFormatCard+0x64>
    457a:	87 fd       	sbrc	r24, 7
    457c:	47 c0       	rjmp	.+142    	; 0x460c <DoFormatCard+0xf2>
			cardState=SD_TOC_WRITE_START;	// Start TOC write
			KillLeds();
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
			subState=SS_2;
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    457e:	80 91 5e 05 	lds	r24, 0x055E
    4582:	81 11       	cpse	r24, r1
    4584:	d2 cf       	rjmp	.-92     	; 0x452a <DoFormatCard+0x10>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4586:	85 e4       	ldi	r24, 0x45	; 69
    4588:	92 e1       	ldi	r25, 0x12	; 18
    458a:	90 93 e4 05 	sts	0x05E4, r25
    458e:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    4592:	10 92 60 05 	sts	0x0560, r1
    4596:	ec cf       	rjmp	.-40     	; 0x4570 <DoFormatCard+0x56>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    4598:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    459c:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    45a0:	68 e9       	ldi	r22, 0x98	; 152
    45a2:	70 e0       	ldi	r23, 0x00	; 0
    45a4:	82 e0       	ldi	r24, 0x02	; 2
    45a6:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
{
	if(subState==SS_0)
	{
		KillLeds();		// Turn off LEDs

		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    45aa:	10 92 e5 05 	sts	0x05E5, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    45ae:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    45b2:	10 92 09 06 	sts	0x0609, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    45b6:	10 92 13 06 	sts	0x0613, r1
    45ba:	30 91 b1 05 	lds	r19, 0x05B1
    45be:	83 2f       	mov	r24, r19
    45c0:	90 e0       	ldi	r25, 0x00	; 0
    45c2:	20 91 62 05 	lds	r18, 0x0562
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45c6:	30 fd       	sbrc	r19, 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45c8:	2e 7f       	andi	r18, 0xFE	; 254
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45ca:	81 fd       	sbrc	r24, 1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45cc:	2d 7f       	andi	r18, 0xFD	; 253
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45ce:	82 fd       	sbrc	r24, 2
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45d0:	2b 7f       	andi	r18, 0xFB	; 251
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45d2:	83 fd       	sbrc	r24, 3
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45d4:	27 7f       	andi	r18, 0xF7	; 247
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45d6:	84 fd       	sbrc	r24, 4
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45d8:	2f 7e       	andi	r18, 0xEF	; 239
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45da:	85 fd       	sbrc	r24, 5
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45dc:	2f 7d       	andi	r18, 0xDF	; 223
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45de:	86 fd       	sbrc	r24, 6
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45e0:	2f 7b       	andi	r18, 0xBF	; 191
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    45e2:	88 0f       	add	r24, r24
    45e4:	89 2f       	mov	r24, r25
    45e6:	88 1f       	adc	r24, r24
    45e8:	99 0b       	sbc	r25, r25
    45ea:	89 2b       	or	r24, r25
    45ec:	09 f0       	breq	.+2      	; 0x45f0 <DoFormatCard+0xd6>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    45ee:	2f 77       	andi	r18, 0x7F	; 127
    45f0:	20 93 62 05 	sts	0x0562, r18
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    45f4:	81 e8       	ldi	r24, 0x81	; 129
    45f6:	80 93 b1 05 	sts	0x05B1, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    45fa:	68 e9       	ldi	r22, 0x98	; 152
    45fc:	70 e0       	ldi	r23, 0x00	; 0
    45fe:	82 e0       	ldi	r24, 0x02	; 2
    4600:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		bankStates[BANK_0].clockMode=CLK_NONE;
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
		bankStates[BANK_1].clockMode=CLK_NONE;

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
		subState=SS_1;
    4604:	81 e0       	ldi	r24, 0x01	; 1
    4606:	80 93 60 05 	sts	0x0560, r24
    460a:	08 95       	ret
	}
	else if(subState==SS_1)
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    460c:	86 e0       	ldi	r24, 0x06	; 6
    460e:	80 93 5e 05 	sts	0x055E, r24
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    4612:	10 92 62 05 	sts	0x0562, r1
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    4616:	10 92 b1 05 	sts	0x05B1, r1
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    461a:	68 e9       	ldi	r22, 0x98	; 152
    461c:	70 e0       	ldi	r23, 0x00	; 0
    461e:	82 e0       	ldi	r24, 0x02	; 2
    4620:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
			KillLeds();
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
    4624:	80 91 62 05 	lds	r24, 0x0562
    4628:	81 68       	ori	r24, 0x81	; 129
    462a:	80 93 62 05 	sts	0x0562, r24
			subState=SS_2;
    462e:	82 e0       	ldi	r24, 0x02	; 2
    4630:	80 93 60 05 	sts	0x0560, r24
    4634:	08 95       	ret

00004636 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    4636:	1f 92       	push	r1
    4638:	0f 92       	push	r0
    463a:	0f b6       	in	r0, 0x3f	; 63
    463c:	0f 92       	push	r0
    463e:	11 24       	eor	r1, r1
    4640:	2f 93       	push	r18
    4642:	3f 93       	push	r19
    4644:	4f 93       	push	r20
    4646:	5f 93       	push	r21
    4648:	6f 93       	push	r22
    464a:	7f 93       	push	r23
    464c:	8f 93       	push	r24
    464e:	9f 93       	push	r25
    4650:	af 93       	push	r26
    4652:	bf 93       	push	r27
    4654:	ef 93       	push	r30
    4656:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
    4658:	46 9a       	sbi	0x08, 6	; 8
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    465a:	80 91 e7 05 	lds	r24, 0x05E7
    465e:	88 23       	and	r24, r24
    4660:	79 f1       	breq	.+94     	; 0x46c0 <__vector_12+0x8a>
    4662:	80 91 e7 05 	lds	r24, 0x05E7
    4666:	81 11       	cpse	r24, r1
    4668:	27 c0       	rjmp	.+78     	; 0x46b8 <__vector_12+0x82>
	{
		UpdateAudioChannel0();							// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    466a:	10 92 41 04 	sts	0x0441, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    466e:	e0 91 e1 05 	lds	r30, 0x05E1
    4672:	f0 91 e2 05 	lds	r31, 0x05E2
    4676:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    4678:	80 91 7a 00 	lds	r24, 0x007A
    467c:	86 fd       	sbrc	r24, 6
    467e:	0a c0       	rjmp	.+20     	; 0x4694 <__vector_12+0x5e>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    4680:	80 91 79 00 	lds	r24, 0x0079
    4684:	80 58       	subi	r24, 0x80	; 128
    4686:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    468a:	80 91 7a 00 	lds	r24, 0x007A
    468e:	80 64       	ori	r24, 0x40	; 64
    4690:	80 93 7a 00 	sts	0x007A, r24
	}
	PORTC&=~Om_TEST_PIN_0;		// @@@ Used to time ISRs
    4694:	46 98       	cbi	0x08, 6	; 8
}
    4696:	ff 91       	pop	r31
    4698:	ef 91       	pop	r30
    469a:	bf 91       	pop	r27
    469c:	af 91       	pop	r26
    469e:	9f 91       	pop	r25
    46a0:	8f 91       	pop	r24
    46a2:	7f 91       	pop	r23
    46a4:	6f 91       	pop	r22
    46a6:	5f 91       	pop	r21
    46a8:	4f 91       	pop	r20
    46aa:	3f 91       	pop	r19
    46ac:	2f 91       	pop	r18
    46ae:	0f 90       	pop	r0
    46b0:	0f be       	out	0x3f, r0	; 63
    46b2:	0f 90       	pop	r0
    46b4:	1f 90       	pop	r1
    46b6:	18 95       	reti
{
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    46b8:	80 91 41 04 	lds	r24, 0x0441
    46bc:	88 23       	and	r24, r24
    46be:	a9 f2       	breq	.-86     	; 0x466a <__vector_12+0x34>
	{
		UpdateAudioChannel0();							// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    46c0:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    46c4:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    46c8:	80 93 42 04 	sts	0x0442, r24
    46cc:	ce cf       	rjmp	.-100    	; 0x466a <__vector_12+0x34>

000046ce <__vector_6>:
}

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    46ce:	1f 92       	push	r1
    46d0:	0f 92       	push	r0
    46d2:	0f b6       	in	r0, 0x3f	; 63
    46d4:	0f 92       	push	r0
    46d6:	11 24       	eor	r1, r1
    46d8:	2f 93       	push	r18
    46da:	3f 93       	push	r19
    46dc:	4f 93       	push	r20
    46de:	5f 93       	push	r21
    46e0:	6f 93       	push	r22
    46e2:	7f 93       	push	r23
    46e4:	8f 93       	push	r24
    46e6:	9f 93       	push	r25
    46e8:	af 93       	push	r26
    46ea:	bf 93       	push	r27
    46ec:	ef 93       	push	r30
    46ee:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
    46f0:	47 9a       	sbi	0x08, 7	; 8
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    46f2:	80 91 0b 06 	lds	r24, 0x060B
    46f6:	88 23       	and	r24, r24
    46f8:	79 f1       	breq	.+94     	; 0x4758 <__vector_6+0x8a>
    46fa:	80 91 0b 06 	lds	r24, 0x060B
    46fe:	81 11       	cpse	r24, r1
    4700:	27 c0       	rjmp	.+78     	; 0x4750 <__vector_6+0x82>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    4702:	10 92 44 05 	sts	0x0544, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    4706:	e0 91 e1 05 	lds	r30, 0x05E1
    470a:	f0 91 e2 05 	lds	r31, 0x05E2
    470e:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    4710:	80 91 7a 00 	lds	r24, 0x007A
    4714:	86 fd       	sbrc	r24, 6
    4716:	0a c0       	rjmp	.+20     	; 0x472c <__vector_6+0x5e>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    4718:	80 91 79 00 	lds	r24, 0x0079
    471c:	80 58       	subi	r24, 0x80	; 128
    471e:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    4722:	80 91 7a 00 	lds	r24, 0x007A
    4726:	80 64       	ori	r24, 0x40	; 64
    4728:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    472c:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    472e:	ff 91       	pop	r31
    4730:	ef 91       	pop	r30
    4732:	bf 91       	pop	r27
    4734:	af 91       	pop	r26
    4736:	9f 91       	pop	r25
    4738:	8f 91       	pop	r24
    473a:	7f 91       	pop	r23
    473c:	6f 91       	pop	r22
    473e:	5f 91       	pop	r21
    4740:	4f 91       	pop	r20
    4742:	3f 91       	pop	r19
    4744:	2f 91       	pop	r18
    4746:	0f 90       	pop	r0
    4748:	0f be       	out	0x3f, r0	; 63
    474a:	0f 90       	pop	r0
    474c:	1f 90       	pop	r1
    474e:	18 95       	reti
{
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    4750:	80 91 44 05 	lds	r24, 0x0544
    4754:	88 23       	and	r24, r24
    4756:	a9 f2       	breq	.-86     	; 0x4702 <__vector_6+0x34>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    4758:	0e 94 8a 04 	call	0x914	; 0x914 <UpdateAudioChannel1>
    475c:	80 93 45 05 	sts	0x0545, r24
    4760:	d0 cf       	rjmp	.-96     	; 0x4702 <__vector_6+0x34>

00004762 <__vector_13>:
// They're more like 5uS now, but still plenty short
}

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    4762:	1f 92       	push	r1
    4764:	0f 92       	push	r0
    4766:	0f b6       	in	r0, 0x3f	; 63
    4768:	0f 92       	push	r0
    476a:	11 24       	eor	r1, r1
    476c:	0f 93       	push	r16
    476e:	1f 93       	push	r17
    4770:	2f 93       	push	r18
    4772:	3f 93       	push	r19
    4774:	4f 93       	push	r20
    4776:	5f 93       	push	r21
    4778:	6f 93       	push	r22
    477a:	7f 93       	push	r23
    477c:	8f 93       	push	r24
    477e:	9f 93       	push	r25
    4780:	af 93       	push	r26
    4782:	bf 93       	push	r27
    4784:	cf 93       	push	r28
    4786:	df 93       	push	r29
    4788:	ef 93       	push	r30
    478a:	ff 93       	push	r31
	static unsigned int
		lastJitterValue;
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs
    478c:	46 9a       	sbi	0x08, 6	; 8

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    478e:	80 91 e7 05 	lds	r24, 0x05E7
    4792:	88 23       	and	r24, r24
    4794:	09 f4       	brne	.+2      	; 0x4798 <__vector_13+0x36>
    4796:	7a c0       	rjmp	.+244    	; 0x488c <__vector_13+0x12a>
    4798:	80 91 e7 05 	lds	r24, 0x05E7
    479c:	81 11       	cpse	r24, r1
    479e:	71 c0       	rjmp	.+226    	; 0x4882 <__vector_13+0x120>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    47a0:	80 91 ed 05 	lds	r24, 0x05ED
    47a4:	88 23       	and	r24, r24
    47a6:	09 f4       	brne	.+2      	; 0x47aa <__vector_13+0x48>
    47a8:	5d c0       	rjmp	.+186    	; 0x4864 <__vector_13+0x102>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    47aa:	a0 91 ed 05 	lds	r26, 0x05ED
    47ae:	20 91 f0 05 	lds	r18, 0x05F0
    47b2:	30 91 f1 05 	lds	r19, 0x05F1
    47b6:	b0 e0       	ldi	r27, 0x00	; 0
    47b8:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    47bc:	2f e7       	ldi	r18, 0x7F	; 127
    47be:	30 e0       	ldi	r19, 0x00	; 0
    47c0:	40 e0       	ldi	r20, 0x00	; 0
    47c2:	50 e0       	ldi	r21, 0x00	; 0
    47c4:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    47c8:	00 91 88 00 	lds	r16, 0x0088
    47cc:	10 91 89 00 	lds	r17, 0x0089
    47d0:	c0 91 f0 05 	lds	r28, 0x05F0
    47d4:	d0 91 f1 05 	lds	r29, 0x05F1
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    47d8:	60 91 00 01 	lds	r22, 0x0100
    47dc:	70 91 01 01 	lds	r23, 0x0101
    47e0:	80 91 02 01 	lds	r24, 0x0102
    47e4:	90 91 03 01 	lds	r25, 0x0103
    47e8:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    47ec:	c0 0f       	add	r28, r16
    47ee:	d1 1f       	adc	r29, r17
    47f0:	40 91 49 05 	lds	r20, 0x0549
    47f4:	50 91 4a 05 	lds	r21, 0x054A
    47f8:	c4 0f       	add	r28, r20
    47fa:	d5 1f       	adc	r29, r21
    47fc:	c6 1b       	sub	r28, r22
    47fe:	d7 0b       	sbc	r29, r23
    4800:	d0 93 89 00 	sts	0x0089, r29
    4804:	c0 93 88 00 	sts	0x0088, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    4808:	70 93 4a 05 	sts	0x054A, r23
    480c:	60 93 49 05 	sts	0x0549, r22
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    4810:	10 92 47 05 	sts	0x0547, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    4814:	e0 91 e1 05 	lds	r30, 0x05E1
    4818:	f0 91 e2 05 	lds	r31, 0x05E2
    481c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    481e:	80 91 7a 00 	lds	r24, 0x007A
    4822:	86 fd       	sbrc	r24, 6
    4824:	0a c0       	rjmp	.+20     	; 0x483a <__vector_13+0xd8>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    4826:	80 91 79 00 	lds	r24, 0x0079
    482a:	80 58       	subi	r24, 0x80	; 128
    482c:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    4830:	80 91 7a 00 	lds	r24, 0x007A
    4834:	80 64       	ori	r24, 0x40	; 64
    4836:	80 93 7a 00 	sts	0x007A, r24
	}
}
    483a:	ff 91       	pop	r31
    483c:	ef 91       	pop	r30
    483e:	df 91       	pop	r29
    4840:	cf 91       	pop	r28
    4842:	bf 91       	pop	r27
    4844:	af 91       	pop	r26
    4846:	9f 91       	pop	r25
    4848:	8f 91       	pop	r24
    484a:	7f 91       	pop	r23
    484c:	6f 91       	pop	r22
    484e:	5f 91       	pop	r21
    4850:	4f 91       	pop	r20
    4852:	3f 91       	pop	r19
    4854:	2f 91       	pop	r18
    4856:	1f 91       	pop	r17
    4858:	0f 91       	pop	r16
    485a:	0f 90       	pop	r0
    485c:	0f be       	out	0x3f, r0	; 63
    485e:	0f 90       	pop	r0
    4860:	1f 90       	pop	r1
    4862:	18 95       	reti
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    4864:	20 91 88 00 	lds	r18, 0x0088
    4868:	30 91 89 00 	lds	r19, 0x0089
    486c:	80 91 f0 05 	lds	r24, 0x05F0
    4870:	90 91 f1 05 	lds	r25, 0x05F1
    4874:	82 0f       	add	r24, r18
    4876:	93 1f       	adc	r25, r19
    4878:	90 93 89 00 	sts	0x0089, r25
    487c:	80 93 88 00 	sts	0x0088, r24
    4880:	c7 cf       	rjmp	.-114    	; 0x4810 <__vector_13+0xae>
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN_0;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    4882:	80 91 47 05 	lds	r24, 0x0547
    4886:	88 23       	and	r24, r24
    4888:	09 f4       	brne	.+2      	; 0x488c <__vector_13+0x12a>
    488a:	8a cf       	rjmp	.-236    	; 0x47a0 <__vector_13+0x3e>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    488c:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    4890:	80 93 48 05 	sts	0x0548, r24
    4894:	85 cf       	rjmp	.-246    	; 0x47a0 <__vector_13+0x3e>

00004896 <__vector_14>:
	}
}

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    4896:	1f 92       	push	r1
    4898:	0f 92       	push	r0
    489a:	0f b6       	in	r0, 0x3f	; 63
    489c:	0f 92       	push	r0
    489e:	11 24       	eor	r1, r1
    48a0:	0f 93       	push	r16
    48a2:	1f 93       	push	r17
    48a4:	2f 93       	push	r18
    48a6:	3f 93       	push	r19
    48a8:	4f 93       	push	r20
    48aa:	5f 93       	push	r21
    48ac:	6f 93       	push	r22
    48ae:	7f 93       	push	r23
    48b0:	8f 93       	push	r24
    48b2:	9f 93       	push	r25
    48b4:	af 93       	push	r26
    48b6:	bf 93       	push	r27
    48b8:	cf 93       	push	r28
    48ba:	df 93       	push	r29
    48bc:	ef 93       	push	r30
    48be:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    48c0:	80 91 0b 06 	lds	r24, 0x060B
    48c4:	88 23       	and	r24, r24
    48c6:	09 f4       	brne	.+2      	; 0x48ca <__vector_14+0x34>
    48c8:	7a c0       	rjmp	.+244    	; 0x49be <__vector_14+0x128>
    48ca:	80 91 0b 06 	lds	r24, 0x060B
    48ce:	81 11       	cpse	r24, r1
    48d0:	71 c0       	rjmp	.+226    	; 0x49b4 <__vector_14+0x11e>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    48d2:	80 91 11 06 	lds	r24, 0x0611
    48d6:	88 23       	and	r24, r24
    48d8:	09 f4       	brne	.+2      	; 0x48dc <__vector_14+0x46>
    48da:	5d c0       	rjmp	.+186    	; 0x4996 <__vector_14+0x100>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    48dc:	a0 91 11 06 	lds	r26, 0x0611
    48e0:	20 91 14 06 	lds	r18, 0x0614
    48e4:	30 91 15 06 	lds	r19, 0x0615
    48e8:	b0 e0       	ldi	r27, 0x00	; 0
    48ea:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    48ee:	2f e7       	ldi	r18, 0x7F	; 127
    48f0:	30 e0       	ldi	r19, 0x00	; 0
    48f2:	40 e0       	ldi	r20, 0x00	; 0
    48f4:	50 e0       	ldi	r21, 0x00	; 0
    48f6:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    48fa:	00 91 8a 00 	lds	r16, 0x008A
    48fe:	10 91 8b 00 	lds	r17, 0x008B
    4902:	c0 91 14 06 	lds	r28, 0x0614
    4906:	d0 91 15 06 	lds	r29, 0x0615
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    490a:	60 91 00 01 	lds	r22, 0x0100
    490e:	70 91 01 01 	lds	r23, 0x0101
    4912:	80 91 02 01 	lds	r24, 0x0102
    4916:	90 91 03 01 	lds	r25, 0x0103
    491a:	0e 94 6e 35 	call	0x6adc	; 0x6adc <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    491e:	c0 0f       	add	r28, r16
    4920:	d1 1f       	adc	r29, r17
    4922:	40 91 4d 05 	lds	r20, 0x054D
    4926:	50 91 4e 05 	lds	r21, 0x054E
    492a:	c4 0f       	add	r28, r20
    492c:	d5 1f       	adc	r29, r21
    492e:	c6 1b       	sub	r28, r22
    4930:	d7 0b       	sbc	r29, r23
    4932:	d0 93 8b 00 	sts	0x008B, r29
    4936:	c0 93 8a 00 	sts	0x008A, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    493a:	70 93 4e 05 	sts	0x054E, r23
    493e:	60 93 4d 05 	sts	0x054D, r22
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    4942:	10 92 4b 05 	sts	0x054B, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    4946:	e0 91 e1 05 	lds	r30, 0x05E1
    494a:	f0 91 e2 05 	lds	r31, 0x05E2
    494e:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    4950:	80 91 7a 00 	lds	r24, 0x007A
    4954:	86 fd       	sbrc	r24, 6
    4956:	0a c0       	rjmp	.+20     	; 0x496c <__vector_14+0xd6>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    4958:	80 91 79 00 	lds	r24, 0x0079
    495c:	80 58       	subi	r24, 0x80	; 128
    495e:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    4962:	80 91 7a 00 	lds	r24, 0x007A
    4966:	80 64       	ori	r24, 0x40	; 64
    4968:	80 93 7a 00 	sts	0x007A, r24
	}
}
    496c:	ff 91       	pop	r31
    496e:	ef 91       	pop	r30
    4970:	df 91       	pop	r29
    4972:	cf 91       	pop	r28
    4974:	bf 91       	pop	r27
    4976:	af 91       	pop	r26
    4978:	9f 91       	pop	r25
    497a:	8f 91       	pop	r24
    497c:	7f 91       	pop	r23
    497e:	6f 91       	pop	r22
    4980:	5f 91       	pop	r21
    4982:	4f 91       	pop	r20
    4984:	3f 91       	pop	r19
    4986:	2f 91       	pop	r18
    4988:	1f 91       	pop	r17
    498a:	0f 91       	pop	r16
    498c:	0f 90       	pop	r0
    498e:	0f be       	out	0x3f, r0	; 63
    4990:	0f 90       	pop	r0
    4992:	1f 90       	pop	r1
    4994:	18 95       	reti
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    4996:	20 91 8a 00 	lds	r18, 0x008A
    499a:	30 91 8b 00 	lds	r19, 0x008B
    499e:	80 91 14 06 	lds	r24, 0x0614
    49a2:	90 91 15 06 	lds	r25, 0x0615
    49a6:	82 0f       	add	r24, r18
    49a8:	93 1f       	adc	r25, r19
    49aa:	90 93 8b 00 	sts	0x008B, r25
    49ae:	80 93 8a 00 	sts	0x008A, r24
    49b2:	c7 cf       	rjmp	.-114    	; 0x4942 <__vector_14+0xac>
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    49b4:	80 91 4b 05 	lds	r24, 0x054B
    49b8:	88 23       	and	r24, r24
    49ba:	09 f4       	brne	.+2      	; 0x49be <__vector_14+0x128>
    49bc:	8a cf       	rjmp	.-236    	; 0x48d2 <__vector_14+0x3c>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    49be:	0e 94 8a 04 	call	0x914	; 0x914 <UpdateAudioChannel1>
    49c2:	80 93 4c 05 	sts	0x054C, r24
    49c6:	85 cf       	rjmp	.-246    	; 0x48d2 <__vector_14+0x3c>

000049c8 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    49c8:	1f 92       	push	r1
    49ca:	0f 92       	push	r0
    49cc:	0f b6       	in	r0, 0x3f	; 63
    49ce:	0f 92       	push	r0
    49d0:	11 24       	eor	r1, r1
    49d2:	2f 93       	push	r18
    49d4:	3f 93       	push	r19
    49d6:	4f 93       	push	r20
    49d8:	5f 93       	push	r21
    49da:	6f 93       	push	r22
    49dc:	7f 93       	push	r23
    49de:	8f 93       	push	r24
    49e0:	9f 93       	push	r25
    49e2:	af 93       	push	r26
    49e4:	bf 93       	push	r27
    49e6:	ef 93       	push	r30
    49e8:	ff 93       	push	r31
	unsigned char
		theByte;

//	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    49ea:	80 91 4f 05 	lds	r24, 0x054F
    49ee:	81 30       	cpi	r24, 0x01	; 1
    49f0:	b9 f0       	breq	.+46     	; 0x4a20 <__vector_10+0x58>
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
			}
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    49f2:	82 30       	cpi	r24, 0x02	; 2
    49f4:	09 f4       	brne	.+2      	; 0x49f8 <__vector_10+0x30>
    49f6:	8d c0       	rjmp	.+282    	; 0x4b12 <__vector_10+0x14a>
					bankStates[BANK_1].isLocked=false;					// Unlock bank
				}
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    49f8:	83 30       	cpi	r24, 0x03	; 3
    49fa:	09 f4       	brne	.+2      	; 0x49fe <__vector_10+0x36>
    49fc:	09 c1       	rjmp	.+530    	; 0x4c10 <__vector_10+0x248>
			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
			UpdateOutput();				// Update the DAC
		}
	}
}
    49fe:	ff 91       	pop	r31
    4a00:	ef 91       	pop	r30
    4a02:	bf 91       	pop	r27
    4a04:	af 91       	pop	r26
    4a06:	9f 91       	pop	r25
    4a08:	8f 91       	pop	r24
    4a0a:	7f 91       	pop	r23
    4a0c:	6f 91       	pop	r22
    4a0e:	5f 91       	pop	r21
    4a10:	4f 91       	pop	r20
    4a12:	3f 91       	pop	r19
    4a14:	2f 91       	pop	r18
    4a16:	0f 90       	pop	r0
    4a18:	0f be       	out	0x3f, r0	; 63
    4a1a:	0f 90       	pop	r0
    4a1c:	1f 90       	pop	r1
    4a1e:	18 95       	reti

//	PORTC|=Om_TEST_PIN_1;		// @@@ Used to time ISRs

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    4a20:	80 91 22 01 	lds	r24, 0x0122
    4a24:	90 91 23 01 	lds	r25, 0x0123
    4a28:	a0 91 24 01 	lds	r26, 0x0124
    4a2c:	b0 91 25 01 	lds	r27, 0x0125
    4a30:	89 2b       	or	r24, r25
    4a32:	8a 2b       	or	r24, r26
    4a34:	8b 2b       	or	r24, r27
    4a36:	09 f4       	brne	.+2      	; 0x4a3a <__vector_10+0x72>
    4a38:	3e c1       	rjmp	.+636    	; 0x4cb6 <__vector_10+0x2ee>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    4a3a:	80 91 26 01 	lds	r24, 0x0126
    4a3e:	90 91 27 01 	lds	r25, 0x0127
    4a42:	89 2b       	or	r24, r25
    4a44:	e1 f2       	breq	.-72     	; 0x49fe <__vector_10+0x36>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    4a46:	e0 91 2a 01 	lds	r30, 0x012A
    4a4a:	f0 91 2b 01 	lds	r31, 0x012B
    4a4e:	e4 5d       	subi	r30, 0xD4	; 212
    4a50:	fe 4f       	sbci	r31, 0xFE	; 254
    4a52:	30 81       	ld	r19, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    4a54:	80 91 2a 01 	lds	r24, 0x012A
    4a58:	90 91 2b 01 	lds	r25, 0x012B
    4a5c:	01 96       	adiw	r24, 0x01	; 1
    4a5e:	90 93 2b 01 	sts	0x012B, r25
    4a62:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    4a66:	80 91 2a 01 	lds	r24, 0x012A
    4a6a:	90 91 2b 01 	lds	r25, 0x012B
    4a6e:	81 15       	cp	r24, r1
    4a70:	93 40       	sbci	r25, 0x03	; 3
    4a72:	08 f0       	brcs	.+2      	; 0x4a76 <__vector_10+0xae>
    4a74:	6a c1       	rjmp	.+724    	; 0x4d4a <__vector_10+0x382>
				{
					sdFifoReadPointer=0;
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    4a76:	80 91 26 01 	lds	r24, 0x0126
    4a7a:	90 91 27 01 	lds	r25, 0x0127
    4a7e:	01 97       	sbiw	r24, 0x01	; 1
    4a80:	90 93 27 01 	sts	0x0127, r25
    4a84:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    4a88:	80 91 22 01 	lds	r24, 0x0122
    4a8c:	90 91 23 01 	lds	r25, 0x0123
    4a90:	a0 91 24 01 	lds	r26, 0x0124
    4a94:	b0 91 25 01 	lds	r27, 0x0125
    4a98:	01 97       	sbiw	r24, 0x01	; 1
    4a9a:	a1 09       	sbc	r26, r1
    4a9c:	b1 09       	sbc	r27, r1
    4a9e:	80 93 22 01 	sts	0x0122, r24
    4aa2:	90 93 23 01 	sts	0x0123, r25
    4aa6:	a0 93 24 01 	sts	0x0124, r26
    4aaa:	b0 93 25 01 	sts	0x0125, r27

				// Now put this byte into the RAM bank in the correct address.

				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    4aae:	8f ef       	ldi	r24, 0xFF	; 255
    4ab0:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    4ab2:	80 91 50 05 	lds	r24, 0x0550
    4ab6:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    4ab8:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    4aba:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    4abc:	80 91 50 05 	lds	r24, 0x0550
    4ac0:	90 91 51 05 	lds	r25, 0x0551
    4ac4:	a0 91 52 05 	lds	r26, 0x0552
    4ac8:	b0 91 53 05 	lds	r27, 0x0553
    4acc:	49 2f       	mov	r20, r25
    4ace:	5a 2f       	mov	r21, r26
    4ad0:	6b 2f       	mov	r22, r27
    4ad2:	77 27       	eor	r23, r23
    4ad4:	45 b9       	out	0x05, r20	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    4ad6:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    4ad8:	14 98       	cbi	0x02, 4	; 2
				//PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.

				// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
				PORTC&=~0x07;											// Clear PORTC bits 0-2
    4ada:	28 b1       	in	r18, 0x08	; 8
    4adc:	28 7f       	andi	r18, 0xF8	; 248
    4ade:	28 b9       	out	0x08, r18	; 8
				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
    4ae0:	48 b1       	in	r20, 0x08	; 8
    4ae2:	2a 2f       	mov	r18, r26
    4ae4:	27 70       	andi	r18, 0x07	; 7
    4ae6:	24 2b       	or	r18, r20
    4ae8:	28 b9       	out	0x08, r18	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    4aea:	35 b9       	out	0x05, r19	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    4aec:	20 91 54 05 	lds	r18, 0x0554
    4af0:	21 30       	cpi	r18, 0x01	; 1
    4af2:	09 f4       	brne	.+2      	; 0x4af6 <__vector_10+0x12e>
    4af4:	59 c1       	rjmp	.+690    	; 0x4da8 <__vector_10+0x3e0>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    4af6:	01 97       	sbiw	r24, 0x01	; 1
    4af8:	a1 09       	sbc	r26, r1
    4afa:	b1 09       	sbc	r27, r1
    4afc:	80 93 50 05 	sts	0x0550, r24
    4b00:	90 93 51 05 	sts	0x0551, r25
    4b04:	a0 93 52 05 	sts	0x0552, r26
    4b08:	b0 93 53 05 	sts	0x0553, r27
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    4b0c:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    4b0e:	11 9a       	sbi	0x02, 1	; 2
    4b10:	76 cf       	rjmp	.-276    	; 0x49fe <__vector_10+0x36>
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    4b12:	80 91 26 01 	lds	r24, 0x0126
    4b16:	90 91 27 01 	lds	r25, 0x0127
    4b1a:	81 15       	cp	r24, r1
    4b1c:	93 40       	sbci	r25, 0x03	; 3
    4b1e:	08 f0       	brcs	.+2      	; 0x4b22 <__vector_10+0x15a>
    4b20:	6e cf       	rjmp	.-292    	; 0x49fe <__vector_10+0x36>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    4b22:	80 91 22 01 	lds	r24, 0x0122
    4b26:	90 91 23 01 	lds	r25, 0x0123
    4b2a:	a0 91 24 01 	lds	r26, 0x0124
    4b2e:	b0 91 25 01 	lds	r27, 0x0125
    4b32:	89 2b       	or	r24, r25
    4b34:	8a 2b       	or	r24, r26
    4b36:	8b 2b       	or	r24, r27
    4b38:	09 f4       	brne	.+2      	; 0x4b3c <__vector_10+0x174>
    4b3a:	e6 c0       	rjmp	.+460    	; 0x4d08 <__vector_10+0x340>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    4b3c:	80 91 50 05 	lds	r24, 0x0550
    4b40:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    4b42:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    4b44:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    4b46:	80 91 50 05 	lds	r24, 0x0550
    4b4a:	90 91 51 05 	lds	r25, 0x0551
    4b4e:	a0 91 52 05 	lds	r26, 0x0552
    4b52:	b0 91 53 05 	lds	r27, 0x0553
    4b56:	49 2f       	mov	r20, r25
    4b58:	5a 2f       	mov	r21, r26
    4b5a:	6b 2f       	mov	r22, r27
    4b5c:	77 27       	eor	r23, r23
    4b5e:	45 b9       	out	0x05, r20	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    4b60:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    4b62:	14 98       	cbi	0x02, 4	; 2

				//PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.

				// @@@ Note, the below operations are needed to not mess with the TEST pins.  You can do an operation more like the above once testing is over to save a few cycles.
				PORTC&=~0x07;											// Clear PORTC bits 0-2
    4b64:	28 b1       	in	r18, 0x08	; 8
    4b66:	28 7f       	andi	r18, 0xF8	; 248
    4b68:	28 b9       	out	0x08, r18	; 8
				PORTC|=((sdRamAddress>>16)&0x07);						// Set high addy bits on PORTC0-2
    4b6a:	38 b1       	in	r19, 0x08	; 8
    4b6c:	2a 2f       	mov	r18, r26
    4b6e:	27 70       	andi	r18, 0x07	; 7
    4b70:	23 2b       	or	r18, r19
    4b72:	28 b9       	out	0x08, r18	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    4b74:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    4b76:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    4b78:	20 91 54 05 	lds	r18, 0x0554
    4b7c:	21 30       	cpi	r18, 0x01	; 1
    4b7e:	09 f4       	brne	.+2      	; 0x4b82 <__vector_10+0x1ba>
    4b80:	e9 c0       	rjmp	.+466    	; 0x4d54 <__vector_10+0x38c>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    4b82:	01 97       	sbiw	r24, 0x01	; 1
    4b84:	a1 09       	sbc	r26, r1
    4b86:	b1 09       	sbc	r27, r1
    4b88:	80 93 50 05 	sts	0x0550, r24
    4b8c:	90 93 51 05 	sts	0x0551, r25
    4b90:	a0 93 52 05 	sts	0x0552, r26
    4b94:	b0 93 53 05 	sts	0x0553, r27
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    4b98:	83 b1       	in	r24, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    4b9a:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    4b9c:	9f ef       	ldi	r25, 0xFF	; 255
    4b9e:	94 b9       	out	0x04, r25	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    4ba0:	e0 91 28 01 	lds	r30, 0x0128
    4ba4:	f0 91 29 01 	lds	r31, 0x0129
    4ba8:	e4 5d       	subi	r30, 0xD4	; 212
    4baa:	fe 4f       	sbci	r31, 0xFE	; 254
    4bac:	80 83       	st	Z, r24
				sdFifoWritePointer++;				// Move to next spot in fifo
    4bae:	80 91 28 01 	lds	r24, 0x0128
    4bb2:	90 91 29 01 	lds	r25, 0x0129
    4bb6:	01 96       	adiw	r24, 0x01	; 1
    4bb8:	90 93 29 01 	sts	0x0129, r25
    4bbc:	80 93 28 01 	sts	0x0128, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    4bc0:	80 91 28 01 	lds	r24, 0x0128
    4bc4:	90 91 29 01 	lds	r25, 0x0129
    4bc8:	81 15       	cp	r24, r1
    4bca:	93 40       	sbci	r25, 0x03	; 3
    4bcc:	20 f0       	brcs	.+8      	; 0x4bd6 <__vector_10+0x20e>
				{
					sdFifoWritePointer=0;
    4bce:	10 92 29 01 	sts	0x0129, r1
    4bd2:	10 92 28 01 	sts	0x0128, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    4bd6:	80 91 26 01 	lds	r24, 0x0126
    4bda:	90 91 27 01 	lds	r25, 0x0127
    4bde:	01 96       	adiw	r24, 0x01	; 1
    4be0:	90 93 27 01 	sts	0x0127, r25
    4be4:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;		// One less byte in the sample
    4be8:	80 91 22 01 	lds	r24, 0x0122
    4bec:	90 91 23 01 	lds	r25, 0x0123
    4bf0:	a0 91 24 01 	lds	r26, 0x0124
    4bf4:	b0 91 25 01 	lds	r27, 0x0125
    4bf8:	01 97       	sbiw	r24, 0x01	; 1
    4bfa:	a1 09       	sbc	r26, r1
    4bfc:	b1 09       	sbc	r27, r1
    4bfe:	80 93 22 01 	sts	0x0122, r24
    4c02:	90 93 23 01 	sts	0x0123, r25
    4c06:	a0 93 24 01 	sts	0x0124, r26
    4c0a:	b0 93 25 01 	sts	0x0125, r27
    4c0e:	f7 ce       	rjmp	.-530    	; 0x49fe <__vector_10+0x36>
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    4c10:	80 91 22 01 	lds	r24, 0x0122
    4c14:	90 91 23 01 	lds	r25, 0x0123
    4c18:	a0 91 24 01 	lds	r26, 0x0124
    4c1c:	b0 91 25 01 	lds	r27, 0x0125
    4c20:	89 2b       	or	r24, r25
    4c22:	8a 2b       	or	r24, r26
    4c24:	8b 2b       	or	r24, r27
    4c26:	09 f4       	brne	.+2      	; 0x4c2a <__vector_10+0x262>
    4c28:	7f c0       	rjmp	.+254    	; 0x4d28 <__vector_10+0x360>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    4c2a:	80 91 26 01 	lds	r24, 0x0126
    4c2e:	90 91 27 01 	lds	r25, 0x0127
    4c32:	89 2b       	or	r24, r25
    4c34:	09 f4       	brne	.+2      	; 0x4c38 <__vector_10+0x270>
    4c36:	e3 ce       	rjmp	.-570    	; 0x49fe <__vector_10+0x36>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    4c38:	e0 91 2a 01 	lds	r30, 0x012A
    4c3c:	f0 91 2b 01 	lds	r31, 0x012B
    4c40:	e4 5d       	subi	r30, 0xD4	; 212
    4c42:	fe 4f       	sbci	r31, 0xFE	; 254
    4c44:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    4c46:	80 91 2a 01 	lds	r24, 0x012A
    4c4a:	90 91 2b 01 	lds	r25, 0x012B
    4c4e:	01 96       	adiw	r24, 0x01	; 1
    4c50:	90 93 2b 01 	sts	0x012B, r25
    4c54:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    4c58:	80 91 2a 01 	lds	r24, 0x012A
    4c5c:	90 91 2b 01 	lds	r25, 0x012B
    4c60:	81 15       	cp	r24, r1
    4c62:	93 40       	sbci	r25, 0x03	; 3
    4c64:	20 f0       	brcs	.+8      	; 0x4c6e <__vector_10+0x2a6>
				{
					sdFifoReadPointer=0;
    4c66:	10 92 2b 01 	sts	0x012B, r1
    4c6a:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    4c6e:	80 91 26 01 	lds	r24, 0x0126
    4c72:	90 91 27 01 	lds	r25, 0x0127
    4c76:	01 97       	sbiw	r24, 0x01	; 1
    4c78:	90 93 27 01 	sts	0x0127, r25
    4c7c:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    4c80:	80 91 22 01 	lds	r24, 0x0122
    4c84:	90 91 23 01 	lds	r25, 0x0123
    4c88:	a0 91 24 01 	lds	r26, 0x0124
    4c8c:	b0 91 25 01 	lds	r27, 0x0125
    4c90:	01 97       	sbiw	r24, 0x01	; 1
    4c92:	a1 09       	sbc	r26, r1
    4c94:	b1 09       	sbc	r27, r1
    4c96:	80 93 22 01 	sts	0x0122, r24
    4c9a:	90 93 23 01 	sts	0x0123, r25
    4c9e:	a0 93 24 01 	sts	0x0124, r26
    4ca2:	b0 93 25 01 	sts	0x0125, r27

				// Now spit the byte out the DAC.

				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine
    4ca6:	20 93 55 05 	sts	0x0555, r18
				UpdateOutput();				// Update the DAC
    4caa:	e0 91 e1 05 	lds	r30, 0x05E1
    4cae:	f0 91 e2 05 	lds	r31, 0x05E2
    4cb2:	09 95       	icall
    4cb4:	a4 ce       	rjmp	.-696    	; 0x49fe <__vector_10+0x36>

			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    4cb6:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    4cba:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    4cbe:	80 91 70 00 	lds	r24, 0x0070
    4cc2:	8b 7f       	andi	r24, 0xFB	; 251
    4cc4:	80 93 70 00 	sts	0x0070, r24

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    4cc8:	80 91 54 05 	lds	r24, 0x0554
    4ccc:	81 30       	cpi	r24, 0x01	; 1
    4cce:	09 f4       	brne	.+2      	; 0x4cd2 <__vector_10+0x30a>
    4cd0:	50 c0       	rjmp	.+160    	; 0x4d72 <__vector_10+0x3aa>
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    4cd2:	10 92 0e 06 	sts	0x060E, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    4cd6:	80 91 50 05 	lds	r24, 0x0550
    4cda:	90 91 51 05 	lds	r25, 0x0551
    4cde:	a0 91 52 05 	lds	r26, 0x0552
    4ce2:	b0 91 53 05 	lds	r27, 0x0553
    4ce6:	80 93 16 06 	sts	0x0616, r24
    4cea:	90 93 17 06 	sts	0x0617, r25
    4cee:	a0 93 18 06 	sts	0x0618, r26
    4cf2:	b0 93 19 06 	sts	0x0619, r27
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    4cf6:	80 93 1e 06 	sts	0x061E, r24
    4cfa:	90 93 1f 06 	sts	0x061F, r25
    4cfe:	a0 93 20 06 	sts	0x0620, r26
    4d02:	b0 93 21 06 	sts	0x0621, r27
    4d06:	7b ce       	rjmp	.-778    	; 0x49fe <__vector_10+0x36>
				sdRamSampleRemaining--;		// One less byte in the sample

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    4d08:	10 92 4f 05 	sts	0x054F, r1
				TCCR2B=0;					// Stop this timer
    4d0c:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    4d10:	80 91 70 00 	lds	r24, 0x0070
    4d14:	8b 7f       	andi	r24, 0xFB	; 251
    4d16:	80 93 70 00 	sts	0x0070, r24

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    4d1a:	80 91 54 05 	lds	r24, 0x0554
    4d1e:	81 30       	cpi	r24, 0x01	; 1
    4d20:	29 f1       	breq	.+74     	; 0x4d6c <__vector_10+0x3a4>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    4d22:	10 92 0e 06 	sts	0x060E, r1
    4d26:	6b ce       	rjmp	.-810    	; 0x49fe <__vector_10+0x36>
				UpdateOutput();				// Update the DAC
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    4d28:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    4d2c:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    4d30:	80 91 70 00 	lds	r24, 0x0070
    4d34:	8b 7f       	andi	r24, 0xFB	; 251
    4d36:	80 93 70 00 	sts	0x0070, r24

			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    4d3a:	10 92 55 05 	sts	0x0555, r1
			UpdateOutput();				// Update the DAC
    4d3e:	e0 91 e1 05 	lds	r30, 0x05E1
    4d42:	f0 91 e2 05 	lds	r31, 0x05E2
    4d46:	09 95       	icall
    4d48:	5a ce       	rjmp	.-844    	; 0x49fe <__vector_10+0x36>
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.

				sdFifoReadPointer++;					// Move to next spot in fifo
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
				{
					sdFifoReadPointer=0;
    4d4a:	10 92 2b 01 	sts	0x012B, r1
    4d4e:	10 92 2a 01 	sts	0x012A, r1
    4d52:	91 ce       	rjmp	.-734    	; 0x4a76 <__vector_10+0xae>
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    4d54:	01 96       	adiw	r24, 0x01	; 1
    4d56:	a1 1d       	adc	r26, r1
    4d58:	b1 1d       	adc	r27, r1
    4d5a:	80 93 50 05 	sts	0x0550, r24
    4d5e:	90 93 51 05 	sts	0x0551, r25
    4d62:	a0 93 52 05 	sts	0x0552, r26
    4d66:	b0 93 53 05 	sts	0x0553, r27
    4d6a:	16 cf       	rjmp	.-468    	; 0x4b98 <__vector_10+0x1d0>
				TCCR2B=0;					// Stop this timer
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    4d6c:	10 92 ea 05 	sts	0x05EA, r1
    4d70:	46 ce       	rjmp	.-884    	; 0x49fe <__vector_10+0x36>
			TCCR2B=0;					// Stop this timer
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    4d72:	10 92 ea 05 	sts	0x05EA, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    4d76:	80 91 50 05 	lds	r24, 0x0550
    4d7a:	90 91 51 05 	lds	r25, 0x0551
    4d7e:	a0 91 52 05 	lds	r26, 0x0552
    4d82:	b0 91 53 05 	lds	r27, 0x0553
    4d86:	80 93 f2 05 	sts	0x05F2, r24
    4d8a:	90 93 f3 05 	sts	0x05F3, r25
    4d8e:	a0 93 f4 05 	sts	0x05F4, r26
    4d92:	b0 93 f5 05 	sts	0x05F5, r27
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    4d96:	80 93 fa 05 	sts	0x05FA, r24
    4d9a:	90 93 fb 05 	sts	0x05FB, r25
    4d9e:	a0 93 fc 05 	sts	0x05FC, r26
    4da2:	b0 93 fd 05 	sts	0x05FD, r27
    4da6:	2b ce       	rjmp	.-938    	; 0x49fe <__vector_10+0x36>
				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    4da8:	01 96       	adiw	r24, 0x01	; 1
    4daa:	a1 1d       	adc	r26, r1
    4dac:	b1 1d       	adc	r27, r1
    4dae:	80 93 50 05 	sts	0x0550, r24
    4db2:	90 93 51 05 	sts	0x0551, r25
    4db6:	a0 93 52 05 	sts	0x0552, r26
    4dba:	b0 93 53 05 	sts	0x0553, r27
    4dbe:	a6 ce       	rjmp	.-692    	; 0x4b0c <__vector_10+0x144>

00004dc0 <__vector_9>:
}

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our FABULOUS intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    4dc0:	1f 92       	push	r1
    4dc2:	0f 92       	push	r0
    4dc4:	0f b6       	in	r0, 0x3f	; 63
    4dc6:	0f 92       	push	r0
    4dc8:	11 24       	eor	r1, r1
    4dca:	8f 93       	push	r24
    4dcc:	9f 93       	push	r25
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
    4dce:	90 91 40 04 	lds	r25, 0x0440
    4dd2:	80 91 56 05 	lds	r24, 0x0556
    4dd6:	89 17       	cp	r24, r25
    4dd8:	58 f0       	brcs	.+22     	; 0x4df0 <__vector_9+0x30>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    4dda:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    4ddc:	8f 5f       	subi	r24, 0xFF	; 255
    4dde:	80 93 56 05 	sts	0x0556, r24
}
    4de2:	9f 91       	pop	r25
    4de4:	8f 91       	pop	r24
    4de6:	0f 90       	pop	r0
    4de8:	0f be       	out	0x3f, r0	; 63
    4dea:	0f 90       	pop	r0
    4dec:	1f 90       	pop	r1
    4dee:	18 95       	reti
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    4df0:	9f ef       	ldi	r25, 0xFF	; 255
    4df2:	95 b9       	out	0x05, r25	; 5
    4df4:	f3 cf       	rjmp	.-26     	; 0x4ddc <__vector_9+0x1c>

00004df6 <__vector_default>:
	}
	pwmCount++;
}

ISR(__vector_default)
{
    4df6:	1f 92       	push	r1
    4df8:	0f 92       	push	r0
    4dfa:	0f b6       	in	r0, 0x3f	; 63
    4dfc:	0f 92       	push	r0
    4dfe:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    4e00:	0f 90       	pop	r0
    4e02:	0f be       	out	0x3f, r0	; 63
    4e04:	0f 90       	pop	r0
    4e06:	1f 90       	pop	r1
    4e08:	18 95       	reti

00004e0a <HandleSoftclock>:

void HandleSoftclock(void)
// NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
// This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up our concept of time when we have a hang-ey loop.
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    4e0a:	a8 9b       	sbis	0x15, 0	; 21
    4e0c:	0a c0       	rjmp	.+20     	; 0x4e22 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    4e0e:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    4e10:	80 91 2d 06 	lds	r24, 0x062D
    4e14:	90 91 2e 06 	lds	r25, 0x062E
    4e18:	01 96       	adiw	r24, 0x01	; 1
    4e1a:	90 93 2e 06 	sts	0x062E, r25
    4e1e:	80 93 2d 06 	sts	0x062D, r24
    4e22:	08 95       	ret

00004e24 <EepromWrite>:
void EepromWrite(unsigned int theAddress, unsigned char theData)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    4e24:	f9 99       	sbic	0x1f, 1	; 31
    4e26:	fe cf       	rjmp	.-4      	; 0x4e24 <EepromWrite>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    4e28:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    4e2a:	f8 94       	cli

	EEAR=theAddress;
    4e2c:	92 bd       	out	0x22, r25	; 34
    4e2e:	81 bd       	out	0x21, r24	; 33
	EEDR=theData;
    4e30:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    4e32:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    4e34:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    4e36:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    4e38:	12 bc       	out	0x22, r1	; 34
    4e3a:	11 bc       	out	0x21, r1	; 33
    4e3c:	08 95       	ret

00004e3e <EepromRead>:
unsigned char EepromRead(unsigned char theAddress)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    4e3e:	f9 99       	sbic	0x1f, 1	; 31
    4e40:	fe cf       	rjmp	.-4      	; 0x4e3e <EepromRead>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    4e42:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    4e44:	f8 94       	cli

	EEAR=theAddress;
    4e46:	90 e0       	ldi	r25, 0x00	; 0
    4e48:	92 bd       	out	0x22, r25	; 34
    4e4a:	81 bd       	out	0x21, r24	; 33
	EECR|=(1<<EERE);	// Start reading.
    4e4c:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    4e4e:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    4e50:	12 bc       	out	0x22, r1	; 34
    4e52:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    4e54:	80 b5       	in	r24, 0x20	; 32
}
    4e56:	08 95       	ret

00004e58 <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4e58:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    4e5c:	88 1f       	adc	r24, r24
    4e5e:	88 27       	eor	r24, r24
    4e60:	88 1f       	adc	r24, r24
    4e62:	08 95       	ret

00004e64 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    4e64:	80 91 c6 00 	lds	r24, 0x00C6
}
    4e68:	08 95       	ret

00004e6a <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    4e6a:	80 91 64 00 	lds	r24, 0x0064
    4e6e:	8d 7f       	andi	r24, 0xFD	; 253
    4e70:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    4e74:	80 91 c0 00 	lds	r24, 0x00C0
    4e78:	8d 7f       	andi	r24, 0xFD	; 253
    4e7a:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    4e7e:	88 e1       	ldi	r24, 0x18	; 24
    4e80:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    4e84:	87 e2       	ldi	r24, 0x27	; 39
    4e86:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    4e8a:	86 e0       	ldi	r24, 0x06	; 6
    4e8c:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    4e90:	80 91 c0 00 	lds	r24, 0x00C0
    4e94:	85 ff       	sbrs	r24, 5
    4e96:	fc cf       	rjmp	.-8      	; 0x4e90 <InitUart0+0x26>
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4e98:	80 91 c0 00 	lds	r24, 0x00C0
    4e9c:	87 ff       	sbrs	r24, 7
    4e9e:	08 95       	ret
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    4ea0:	80 91 c6 00 	lds	r24, 0x00C6
    4ea4:	f9 cf       	rjmp	.-14     	; 0x4e98 <InitUart0+0x2e>

00004ea6 <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    4ea6:	90 e0       	ldi	r25, 0x00	; 0
    4ea8:	20 91 2d 06 	lds	r18, 0x062D
    4eac:	30 91 2e 06 	lds	r19, 0x062E
    4eb0:	88 0f       	add	r24, r24
    4eb2:	99 1f       	adc	r25, r25
    4eb4:	fc 01       	movw	r30, r24
    4eb6:	ec 53       	subi	r30, 0x3C	; 60
    4eb8:	fa 4f       	sbci	r31, 0xFA	; 250
    4eba:	31 83       	std	Z+1, r19	; 0x01
    4ebc:	20 83       	st	Z, r18
	delayTime[timerNum]=ticks_to_wait;
    4ebe:	fc 01       	movw	r30, r24
    4ec0:	e4 53       	subi	r30, 0x34	; 52
    4ec2:	fa 4f       	sbci	r31, 0xFA	; 250
    4ec4:	71 83       	std	Z+1, r23	; 0x01
    4ec6:	60 83       	st	Z, r22
    4ec8:	08 95       	ret

00004eca <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    4eca:	20 91 2d 06 	lds	r18, 0x062D
    4ece:	30 91 2e 06 	lds	r19, 0x062E
    4ed2:	90 e0       	ldi	r25, 0x00	; 0
    4ed4:	88 0f       	add	r24, r24
    4ed6:	99 1f       	adc	r25, r25
    4ed8:	fc 01       	movw	r30, r24
    4eda:	ec 53       	subi	r30, 0x3C	; 60
    4edc:	fa 4f       	sbci	r31, 0xFA	; 250
    4ede:	40 81       	ld	r20, Z
    4ee0:	51 81       	ldd	r21, Z+1	; 0x01
    4ee2:	24 1b       	sub	r18, r20
    4ee4:	35 0b       	sbc	r19, r21
    4ee6:	fc 01       	movw	r30, r24
    4ee8:	e4 53       	subi	r30, 0x34	; 52
    4eea:	fa 4f       	sbci	r31, 0xFA	; 250
    4eec:	81 e0       	ldi	r24, 0x01	; 1
    4eee:	40 81       	ld	r20, Z
    4ef0:	51 81       	ldd	r21, Z+1	; 0x01
    4ef2:	24 17       	cp	r18, r20
    4ef4:	35 07       	cpc	r19, r21
    4ef6:	08 f4       	brcc	.+2      	; 0x4efa <CheckTimer+0x30>
    4ef8:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    4efa:	08 95       	ret

00004efc <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    4efc:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    4efe:	80 91 61 06 	lds	r24, 0x0661
    4f02:	88 23       	and	r24, r24
    4f04:	01 f1       	breq	.+64     	; 0x4f46 <GetMidiMessageFromIncomingFifo+0x4a>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    4f06:	90 91 d4 05 	lds	r25, 0x05D4
    4f0a:	e9 2f       	mov	r30, r25
    4f0c:	f0 e0       	ldi	r31, 0x00	; 0
    4f0e:	ee 0f       	add	r30, r30
    4f10:	ff 1f       	adc	r31, r31
    4f12:	ee 0f       	add	r30, r30
    4f14:	ff 1f       	adc	r31, r31
    4f16:	e0 5d       	subi	r30, 0xD0	; 208
    4f18:	f9 4f       	sbci	r31, 0xF9	; 249
    4f1a:	21 81       	ldd	r18, Z+1	; 0x01
    4f1c:	11 96       	adiw	r26, 0x01	; 1
    4f1e:	2c 93       	st	X, r18
    4f20:	11 97       	sbiw	r26, 0x01	; 1
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    4f22:	22 81       	ldd	r18, Z+2	; 0x02
    4f24:	12 96       	adiw	r26, 0x02	; 2
    4f26:	2c 93       	st	X, r18
    4f28:	12 97       	sbiw	r26, 0x02	; 2
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    4f2a:	23 81       	ldd	r18, Z+3	; 0x03
    4f2c:	13 96       	adiw	r26, 0x03	; 3
    4f2e:	2c 93       	st	X, r18
    4f30:	13 97       	sbiw	r26, 0x03	; 3
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    4f32:	20 81       	ld	r18, Z
    4f34:	2c 93       	st	X, r18

		midiIncomingFifoReadPointer++;			// read from the next element next time
    4f36:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    4f38:	96 30       	cpi	r25, 0x06	; 6
    4f3a:	30 f4       	brcc	.+12     	; 0x4f48 <GetMidiMessageFromIncomingFifo+0x4c>
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
    4f3c:	90 93 d4 05 	sts	0x05D4, r25
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    4f40:	81 50       	subi	r24, 0x01	; 1
    4f42:	80 93 61 06 	sts	0x0661, r24
    4f46:	08 95       	ret
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
    4f48:	10 92 d4 05 	sts	0x05D4, r1
    4f4c:	f9 cf       	rjmp	.-14     	; 0x4f40 <GetMidiMessageFromIncomingFifo+0x44>

00004f4e <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    4f4e:	90 91 62 06 	lds	r25, 0x0662
    4f52:	96 30       	cpi	r25, 0x06	; 6
    4f54:	c0 f4       	brcc	.+48     	; 0x4f86 <PutMidiMessageInOutgoingFifo+0x38>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    4f56:	30 91 d5 05 	lds	r19, 0x05D5
    4f5a:	e3 2f       	mov	r30, r19
    4f5c:	f0 e0       	ldi	r31, 0x00	; 0
    4f5e:	ee 0f       	add	r30, r30
    4f60:	ff 1f       	adc	r31, r31
    4f62:	ee 0f       	add	r30, r30
    4f64:	ff 1f       	adc	r31, r31
    4f66:	e7 5b       	subi	r30, 0xB7	; 183
    4f68:	f9 4f       	sbci	r31, 0xF9	; 249
    4f6a:	61 83       	std	Z+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    4f6c:	42 83       	std	Z+2, r20	; 0x02
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    4f6e:	23 83       	std	Z+3, r18	; 0x03
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    4f70:	80 91 2f 06 	lds	r24, 0x062F
    4f74:	80 83       	st	Z, r24
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    4f76:	3f 5f       	subi	r19, 0xFF	; 255
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    4f78:	36 30       	cpi	r19, 0x06	; 6
    4f7a:	30 f4       	brcc	.+12     	; 0x4f88 <PutMidiMessageInOutgoingFifo+0x3a>
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    4f7c:	30 93 d5 05 	sts	0x05D5, r19
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    4f80:	9f 5f       	subi	r25, 0xFF	; 255
    4f82:	90 93 62 06 	sts	0x0662, r25
    4f86:	08 95       	ret
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
    4f88:	10 92 d5 05 	sts	0x05D5, r1
    4f8c:	f9 cf       	rjmp	.-14     	; 0x4f80 <PutMidiMessageInOutgoingFifo+0x32>

00004f8e <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    4f8e:	89 e0       	ldi	r24, 0x09	; 9
    4f90:	80 93 d6 05 	sts	0x05D6, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    4f94:	10 92 d7 05 	sts	0x05D7, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    4f98:	10 92 61 06 	sts	0x0661, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    4f9c:	10 92 d8 05 	sts	0x05D8, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    4fa0:	10 92 d4 05 	sts	0x05D4, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    4fa4:	10 92 62 06 	sts	0x0662, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    4fa8:	10 92 d5 05 	sts	0x05D5, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    4fac:	10 92 d9 05 	sts	0x05D9, r1
    4fb0:	08 95       	ret

00004fb2 <HandleIncomingMidiByte>:
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    4fb2:	87 fd       	sbrc	r24, 7
    4fb4:	3e c0       	rjmp	.+124    	; 0x5032 <HandleIncomingMidiByte+0x80>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    4fb6:	90 91 d6 05 	lds	r25, 0x05D6
    4fba:	94 30       	cpi	r25, 0x04	; 4
    4fbc:	09 f4       	brne	.+2      	; 0x4fc0 <HandleIncomingMidiByte+0xe>
    4fbe:	d2 c0       	rjmp	.+420    	; 0x5164 <HandleIncomingMidiByte+0x1b2>
    4fc0:	70 f1       	brcs	.+92     	; 0x501e <HandleIncomingMidiByte+0x6c>
    4fc2:	97 30       	cpi	r25, 0x07	; 7
    4fc4:	09 f4       	brne	.+2      	; 0x4fc8 <HandleIncomingMidiByte+0x16>
    4fc6:	93 c0       	rjmp	.+294    	; 0x50ee <HandleIncomingMidiByte+0x13c>
    4fc8:	08 f0       	brcs	.+2      	; 0x4fcc <HandleIncomingMidiByte+0x1a>
    4fca:	65 c0       	rjmp	.+202    	; 0x5096 <HandleIncomingMidiByte+0xe4>
    4fcc:	95 30       	cpi	r25, 0x05	; 5
    4fce:	09 f4       	brne	.+2      	; 0x4fd2 <HandleIncomingMidiByte+0x20>
    4fd0:	68 c0       	rjmp	.+208    	; 0x50a2 <HandleIncomingMidiByte+0xf0>
    4fd2:	96 30       	cpi	r25, 0x06	; 6
    4fd4:	c1 f5       	brne	.+112    	; 0x5046 <HandleIncomingMidiByte+0x94>
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4fd6:	40 91 db 05 	lds	r20, 0x05DB
				theMessage.dataByteTwo=theByte;						// And what velocity?
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    4fda:	30 91 da 05 	lds	r19, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    4fde:	90 91 61 06 	lds	r25, 0x0661
    4fe2:	96 30       	cpi	r25, 0x06	; 6
    4fe4:	c0 f4       	brcc	.+48     	; 0x5016 <HandleIncomingMidiByte+0x64>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    4fe6:	20 91 d8 05 	lds	r18, 0x05D8
    4fea:	e2 2f       	mov	r30, r18
    4fec:	f0 e0       	ldi	r31, 0x00	; 0
    4fee:	ee 0f       	add	r30, r30
    4ff0:	ff 1f       	adc	r31, r31
    4ff2:	ee 0f       	add	r30, r30
    4ff4:	ff 1f       	adc	r31, r31
    4ff6:	e0 5d       	subi	r30, 0xD0	; 208
    4ff8:	f9 4f       	sbci	r31, 0xF9	; 249
    4ffa:	52 e0       	ldi	r21, 0x02	; 2
    4ffc:	51 83       	std	Z+1, r21	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4ffe:	42 83       	std	Z+2, r20	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    5000:	83 83       	std	Z+3, r24	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    5002:	30 83       	st	Z, r19
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    5004:	2f 5f       	subi	r18, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    5006:	26 30       	cpi	r18, 0x06	; 6
    5008:	08 f0       	brcs	.+2      	; 0x500c <HandleIncomingMidiByte+0x5a>
    500a:	23 c1       	rjmp	.+582    	; 0x5252 <HandleIncomingMidiByte+0x2a0>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    500c:	20 93 d8 05 	sts	0x05D8, r18
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    5010:	9f 5f       	subi	r25, 0xFF	; 255
    5012:	90 93 61 06 	sts	0x0661, r25
				theMessage.dataByteTwo=theByte;						// And what velocity?
				theMessage.channelNumber=temporaryChannel;			// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    5016:	81 e0       	ldi	r24, 0x01	; 1
    5018:	80 93 d6 05 	sts	0x05D6, r24
    501c:	08 95       	ret
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    501e:	91 30       	cpi	r25, 0x01	; 1
    5020:	09 f4       	brne	.+2      	; 0x5024 <HandleIncomingMidiByte+0x72>
    5022:	6b c0       	rjmp	.+214    	; 0x50fa <HandleIncomingMidiByte+0x148>
    5024:	68 f5       	brcc	.+90     	; 0x5080 <HandleIncomingMidiByte+0xce>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    5026:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    502a:	85 e0       	ldi	r24, 0x05	; 5
    502c:	80 93 d6 05 	sts	0x05D6, r24
    5030:	08 95       	ret
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    5032:	98 2f       	mov	r25, r24
    5034:	9f 70       	andi	r25, 0x0F	; 15
    5036:	20 91 2f 06 	lds	r18, 0x062F
    503a:	29 17       	cp	r18, r25
    503c:	41 f0       	breq	.+16     	; 0x504e <HandleIncomingMidiByte+0x9c>
    503e:	30 91 48 06 	lds	r19, 0x0648
    5042:	39 17       	cp	r19, r25
    5044:	21 f0       	breq	.+8      	; 0x504e <HandleIncomingMidiByte+0x9c>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    5046:	89 e0       	ldi	r24, 0x09	; 9
    5048:	80 93 d6 05 	sts	0x05D6, r24
    504c:	08 95       	ret

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    504e:	80 7f       	andi	r24, 0xF0	; 240
    5050:	80 39       	cpi	r24, 0x90	; 144
    5052:	09 f4       	brne	.+2      	; 0x5056 <HandleIncomingMidiByte+0xa4>
    5054:	60 c0       	rjmp	.+192    	; 0x5116 <HandleIncomingMidiByte+0x164>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    5056:	80 38       	cpi	r24, 0x80	; 128
    5058:	09 f4       	brne	.+2      	; 0x505c <HandleIncomingMidiByte+0xaa>
    505a:	cb c0       	rjmp	.+406    	; 0x51f2 <HandleIncomingMidiByte+0x240>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    505c:	80 3c       	cpi	r24, 0xC0	; 192
    505e:	09 f4       	brne	.+2      	; 0x5062 <HandleIncomingMidiByte+0xb0>
    5060:	ce c0       	rjmp	.+412    	; 0x51fe <HandleIncomingMidiByte+0x24c>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    5062:	80 3e       	cpi	r24, 0xE0	; 224
    5064:	09 f4       	brne	.+2      	; 0x5068 <HandleIncomingMidiByte+0xb6>
    5066:	4f c0       	rjmp	.+158    	; 0x5106 <HandleIncomingMidiByte+0x154>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    5068:	80 3b       	cpi	r24, 0xB0	; 176
    506a:	69 f7       	brne	.-38     	; 0x5046 <HandleIncomingMidiByte+0x94>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    506c:	83 e0       	ldi	r24, 0x03	; 3
    506e:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    5072:	29 17       	cp	r18, r25
    5074:	09 f4       	brne	.+2      	; 0x5078 <HandleIncomingMidiByte+0xc6>
    5076:	4c c0       	rjmp	.+152    	; 0x5110 <HandleIncomingMidiByte+0x15e>
				{
					temporaryChannel=BANK_0;
				}
				else
				{
					temporaryChannel=BANK_1;
    5078:	81 e0       	ldi	r24, 0x01	; 1
    507a:	80 93 da 05 	sts	0x05DA, r24
    507e:	08 95       	ret
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    5080:	92 30       	cpi	r25, 0x02	; 2
    5082:	09 f4       	brne	.+2      	; 0x5086 <HandleIncomingMidiByte+0xd4>
    5084:	4d c0       	rjmp	.+154    	; 0x5120 <HandleIncomingMidiByte+0x16e>
    5086:	93 30       	cpi	r25, 0x03	; 3
    5088:	f1 f6       	brne	.-68     	; 0x5046 <HandleIncomingMidiByte+0x94>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    508a:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    508e:	84 e0       	ldi	r24, 0x04	; 4
    5090:	80 93 d6 05 	sts	0x05D6, r24
    5094:	08 95       	ret
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    5096:	98 30       	cpi	r25, 0x08	; 8
    5098:	09 f4       	brne	.+2      	; 0x509c <HandleIncomingMidiByte+0xea>
    509a:	87 c0       	rjmp	.+270    	; 0x51aa <HandleIncomingMidiByte+0x1f8>
    509c:	99 30       	cpi	r25, 0x09	; 9
    509e:	99 f6       	brne	.-90     	; 0x5046 <HandleIncomingMidiByte+0x94>
    50a0:	08 95       	ret
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    50a2:	88 23       	and	r24, r24
    50a4:	09 f4       	brne	.+2      	; 0x50a8 <HandleIncomingMidiByte+0xf6>
    50a6:	b1 c0       	rjmp	.+354    	; 0x520a <HandleIncomingMidiByte+0x258>
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;			// For what note?
    50a8:	40 91 db 05 	lds	r20, 0x05DB
				theMessage.dataByteTwo=theByte;					// And what velocity?
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    50ac:	30 91 da 05 	lds	r19, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    50b0:	90 91 61 06 	lds	r25, 0x0661
    50b4:	96 30       	cpi	r25, 0x06	; 6
    50b6:	c0 f4       	brcc	.+48     	; 0x50e8 <HandleIncomingMidiByte+0x136>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    50b8:	20 91 d8 05 	lds	r18, 0x05D8
    50bc:	e2 2f       	mov	r30, r18
    50be:	f0 e0       	ldi	r31, 0x00	; 0
    50c0:	ee 0f       	add	r30, r30
    50c2:	ff 1f       	adc	r31, r31
    50c4:	ee 0f       	add	r30, r30
    50c6:	ff 1f       	adc	r31, r31
    50c8:	e0 5d       	subi	r30, 0xD0	; 208
    50ca:	f9 4f       	sbci	r31, 0xF9	; 249
    50cc:	51 e0       	ldi	r21, 0x01	; 1
    50ce:	51 83       	std	Z+1, r21	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    50d0:	42 83       	std	Z+2, r20	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    50d2:	83 83       	std	Z+3, r24	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    50d4:	30 83       	st	Z, r19
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    50d6:	2f 5f       	subi	r18, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    50d8:	26 30       	cpi	r18, 0x06	; 6
    50da:	08 f0       	brcs	.+2      	; 0x50de <HandleIncomingMidiByte+0x12c>
    50dc:	c3 c0       	rjmp	.+390    	; 0x5264 <HandleIncomingMidiByte+0x2b2>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    50de:	20 93 d8 05 	sts	0x05D8, r18
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    50e2:	9f 5f       	subi	r25, 0xFF	; 255
    50e4:	90 93 61 06 	sts	0x0661, r25
				theMessage.dataByteTwo=theByte;					// And what velocity?
				theMessage.channelNumber=temporaryChannel;		// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    50e8:	10 92 d6 05 	sts	0x05D6, r1
    50ec:	08 95       	ret
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    50ee:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    50f2:	88 e0       	ldi	r24, 0x08	; 8
    50f4:	80 93 d6 05 	sts	0x05D6, r24
    50f8:	08 95       	ret
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    50fa:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    50fe:	86 e0       	ldi	r24, 0x06	; 6
    5100:	80 93 d6 05 	sts	0x05D6, r24
    5104:	08 95       	ret
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    5106:	87 e0       	ldi	r24, 0x07	; 7
    5108:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    510c:	29 13       	cpse	r18, r25
    510e:	b4 cf       	rjmp	.-152    	; 0x5078 <HandleIncomingMidiByte+0xc6>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
				{
					temporaryChannel=BANK_0;
    5110:	10 92 da 05 	sts	0x05DA, r1
    5114:	08 95       	ret
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    5116:	10 92 d6 05 	sts	0x05D6, r1

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    511a:	29 13       	cpse	r18, r25
    511c:	ad cf       	rjmp	.-166    	; 0x5078 <HandleIncomingMidiByte+0xc6>
    511e:	f8 cf       	rjmp	.-16     	; 0x5110 <HandleIncomingMidiByte+0x15e>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
				theMessage.dataByteOne=theByte;							// ...To this program
				theMessage.dataByteTwo=0;								// And no second data byte.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    5120:	30 91 da 05 	lds	r19, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    5124:	90 91 61 06 	lds	r25, 0x0661
    5128:	96 30       	cpi	r25, 0x06	; 6
    512a:	c0 f4       	brcc	.+48     	; 0x515c <HandleIncomingMidiByte+0x1aa>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    512c:	20 91 d8 05 	lds	r18, 0x05D8
    5130:	e2 2f       	mov	r30, r18
    5132:	f0 e0       	ldi	r31, 0x00	; 0
    5134:	ee 0f       	add	r30, r30
    5136:	ff 1f       	adc	r31, r31
    5138:	ee 0f       	add	r30, r30
    513a:	ff 1f       	adc	r31, r31
    513c:	e0 5d       	subi	r30, 0xD0	; 208
    513e:	f9 4f       	sbci	r31, 0xF9	; 249
    5140:	43 e0       	ldi	r20, 0x03	; 3
    5142:	41 83       	std	Z+1, r20	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    5144:	82 83       	std	Z+2, r24	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    5146:	13 82       	std	Z+3, r1	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    5148:	30 83       	st	Z, r19
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    514a:	2f 5f       	subi	r18, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    514c:	26 30       	cpi	r18, 0x06	; 6
    514e:	08 f0       	brcs	.+2      	; 0x5152 <HandleIncomingMidiByte+0x1a0>
    5150:	7d c0       	rjmp	.+250    	; 0x524c <HandleIncomingMidiByte+0x29a>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    5152:	20 93 d8 05 	sts	0x05D8, r18
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    5156:	9f 5f       	subi	r25, 0xFF	; 255
    5158:	90 93 61 06 	sts	0x0661, r25
				theMessage.dataByteTwo=0;								// And no second data byte.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
				
				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// AFAICT, theoretically, program changes are subject to running status.
    515c:	82 e0       	ldi	r24, 0x02	; 2
    515e:	80 93 d6 05 	sts	0x05D6, r24
    5162:	08 95       	ret
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    5164:	50 91 db 05 	lds	r21, 0x05DB
				theMessage.dataByteTwo=theByte;							// And the value.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    5168:	40 91 da 05 	lds	r20, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    516c:	20 91 61 06 	lds	r18, 0x0661
    5170:	26 30       	cpi	r18, 0x06	; 6
    5172:	b8 f4       	brcc	.+46     	; 0x51a2 <HandleIncomingMidiByte+0x1f0>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    5174:	30 91 d8 05 	lds	r19, 0x05D8
    5178:	e3 2f       	mov	r30, r19
    517a:	f0 e0       	ldi	r31, 0x00	; 0
    517c:	ee 0f       	add	r30, r30
    517e:	ff 1f       	adc	r31, r31
    5180:	ee 0f       	add	r30, r30
    5182:	ff 1f       	adc	r31, r31
    5184:	e0 5d       	subi	r30, 0xD0	; 208
    5186:	f9 4f       	sbci	r31, 0xF9	; 249
    5188:	91 83       	std	Z+1, r25	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    518a:	52 83       	std	Z+2, r21	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    518c:	83 83       	std	Z+3, r24	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    518e:	40 83       	st	Z, r20
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    5190:	3f 5f       	subi	r19, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    5192:	36 30       	cpi	r19, 0x06	; 6
    5194:	08 f0       	brcs	.+2      	; 0x5198 <HandleIncomingMidiByte+0x1e6>
    5196:	60 c0       	rjmp	.+192    	; 0x5258 <HandleIncomingMidiByte+0x2a6>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    5198:	30 93 d8 05 	sts	0x05D8, r19
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    519c:	2f 5f       	subi	r18, 0xFF	; 255
    519e:	20 93 61 06 	sts	0x0661, r18
				theMessage.dataByteTwo=theByte;							// And the value.
				theMessage.channelNumber=temporaryChannel;				// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    51a2:	83 e0       	ldi	r24, 0x03	; 3
    51a4:	80 93 d6 05 	sts	0x05D6, r24
    51a8:	08 95       	ret
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;				// LSB
    51aa:	40 91 db 05 	lds	r20, 0x05DB
				theMessage.dataByteTwo=theByte;						// MSB
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    51ae:	30 91 da 05 	lds	r19, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    51b2:	90 91 61 06 	lds	r25, 0x0661
    51b6:	96 30       	cpi	r25, 0x06	; 6
    51b8:	c0 f4       	brcc	.+48     	; 0x51ea <HandleIncomingMidiByte+0x238>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    51ba:	20 91 d8 05 	lds	r18, 0x05D8
    51be:	e2 2f       	mov	r30, r18
    51c0:	f0 e0       	ldi	r31, 0x00	; 0
    51c2:	ee 0f       	add	r30, r30
    51c4:	ff 1f       	adc	r31, r31
    51c6:	ee 0f       	add	r30, r30
    51c8:	ff 1f       	adc	r31, r31
    51ca:	e0 5d       	subi	r30, 0xD0	; 208
    51cc:	f9 4f       	sbci	r31, 0xF9	; 249
    51ce:	57 e0       	ldi	r21, 0x07	; 7
    51d0:	51 83       	std	Z+1, r21	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    51d2:	42 83       	std	Z+2, r20	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    51d4:	83 83       	std	Z+3, r24	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    51d6:	30 83       	st	Z, r19
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    51d8:	2f 5f       	subi	r18, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    51da:	26 30       	cpi	r18, 0x06	; 6
    51dc:	08 f0       	brcs	.+2      	; 0x51e0 <HandleIncomingMidiByte+0x22e>
    51de:	3f c0       	rjmp	.+126    	; 0x525e <HandleIncomingMidiByte+0x2ac>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    51e0:	20 93 d8 05 	sts	0x05D8, r18
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    51e4:	9f 5f       	subi	r25, 0xFF	; 255
    51e6:	90 93 61 06 	sts	0x0661, r25
				theMessage.dataByteTwo=theByte;						// MSB
				theMessage.channelNumber=temporaryChannel;			// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    51ea:	87 e0       	ldi	r24, 0x07	; 7
    51ec:	80 93 d6 05 	sts	0x05D6, r24
    51f0:	08 95       	ret
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    51f8:	29 13       	cpse	r18, r25
    51fa:	3f cf       	rjmp	.-386    	; 0x507a <HandleIncomingMidiByte+0xc8>
    51fc:	89 cf       	rjmp	.-238    	; 0x5110 <HandleIncomingMidiByte+0x15e>
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    51fe:	82 e0       	ldi	r24, 0x02	; 2
    5200:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    5204:	29 13       	cpse	r18, r25
    5206:	38 cf       	rjmp	.-400    	; 0x5078 <HandleIncomingMidiByte+0xc6>
    5208:	83 cf       	rjmp	.-250    	; 0x5110 <HandleIncomingMidiByte+0x15e>
			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;				// For what note?
    520a:	30 91 db 05 	lds	r19, 0x05DB
				theMessage.dataByteTwo=theByte;						// And what velocity?
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    520e:	20 91 da 05 	lds	r18, 0x05DA

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    5212:	80 91 61 06 	lds	r24, 0x0661
    5216:	86 30       	cpi	r24, 0x06	; 6
    5218:	08 f0       	brcs	.+2      	; 0x521c <HandleIncomingMidiByte+0x26a>
    521a:	66 cf       	rjmp	.-308    	; 0x50e8 <HandleIncomingMidiByte+0x136>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    521c:	90 91 d8 05 	lds	r25, 0x05D8
    5220:	e9 2f       	mov	r30, r25
    5222:	f0 e0       	ldi	r31, 0x00	; 0
    5224:	ee 0f       	add	r30, r30
    5226:	ff 1f       	adc	r31, r31
    5228:	ee 0f       	add	r30, r30
    522a:	ff 1f       	adc	r31, r31
    522c:	e0 5d       	subi	r30, 0xD0	; 208
    522e:	f9 4f       	sbci	r31, 0xF9	; 249
    5230:	42 e0       	ldi	r20, 0x02	; 2
    5232:	41 83       	std	Z+1, r20	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    5234:	32 83       	std	Z+2, r19	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    5236:	13 82       	std	Z+3, r1	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    5238:	20 83       	st	Z, r18
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    523a:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    523c:	96 30       	cpi	r25, 0x06	; 6
    523e:	a8 f4       	brcc	.+42     	; 0x526a <HandleIncomingMidiByte+0x2b8>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    5240:	90 93 d8 05 	sts	0x05D8, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    5244:	8f 5f       	subi	r24, 0xFF	; 255
    5246:	80 93 61 06 	sts	0x0661, r24
    524a:	4e cf       	rjmp	.-356    	; 0x50e8 <HandleIncomingMidiByte+0x136>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
    524c:	10 92 d8 05 	sts	0x05D8, r1
    5250:	82 cf       	rjmp	.-252    	; 0x5156 <HandleIncomingMidiByte+0x1a4>
    5252:	10 92 d8 05 	sts	0x05D8, r1
    5256:	dc ce       	rjmp	.-584    	; 0x5010 <HandleIncomingMidiByte+0x5e>
    5258:	10 92 d8 05 	sts	0x05D8, r1
    525c:	9f cf       	rjmp	.-194    	; 0x519c <HandleIncomingMidiByte+0x1ea>
    525e:	10 92 d8 05 	sts	0x05D8, r1
    5262:	c0 cf       	rjmp	.-128    	; 0x51e4 <HandleIncomingMidiByte+0x232>
    5264:	10 92 d8 05 	sts	0x05D8, r1
    5268:	3c cf       	rjmp	.-392    	; 0x50e2 <HandleIncomingMidiByte+0x130>
    526a:	10 92 d8 05 	sts	0x05D8, r1
    526e:	ea cf       	rjmp	.-44     	; 0x5244 <HandleIncomingMidiByte+0x292>

00005270 <MidiTxBufferNotEmpty>:
	}
}

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    5270:	80 91 62 06 	lds	r24, 0x0662
    5274:	81 11       	cpse	r24, r1
    5276:	07 c0       	rjmp	.+14     	; 0x5286 <MidiTxBufferNotEmpty+0x16>
    5278:	81 e0       	ldi	r24, 0x01	; 1
    527a:	90 91 d7 05 	lds	r25, 0x05D7
    527e:	91 11       	cpse	r25, r1
	}
	else
	{
		return(false);
	}
}
    5280:	08 95       	ret
	}
}

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    5282:	80 e0       	ldi	r24, 0x00	; 0
    5284:	08 95       	ret
	{
		return(true);
    5286:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    5288:	08 95       	ret

0000528a <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    528a:	80 91 d7 05 	lds	r24, 0x05D7
    528e:	83 30       	cpi	r24, 0x03	; 3
    5290:	09 f4       	brne	.+2      	; 0x5294 <PopOutgoingMidiByte+0xa>
    5292:	68 c0       	rjmp	.+208    	; 0x5364 <PopOutgoingMidiByte+0xda>
    5294:	68 f0       	brcs	.+26     	; 0x52b0 <PopOutgoingMidiByte+0x26>
    5296:	85 30       	cpi	r24, 0x05	; 5
    5298:	09 f4       	brne	.+2      	; 0x529c <PopOutgoingMidiByte+0x12>
    529a:	4e c0       	rjmp	.+156    	; 0x5338 <PopOutgoingMidiByte+0xae>
    529c:	08 f4       	brcc	.+2      	; 0x52a0 <PopOutgoingMidiByte+0x16>
    529e:	42 c0       	rjmp	.+132    	; 0x5324 <PopOutgoingMidiByte+0x9a>
    52a0:	86 30       	cpi	r24, 0x06	; 6
    52a2:	09 f4       	brne	.+2      	; 0x52a6 <PopOutgoingMidiByte+0x1c>
    52a4:	53 c0       	rjmp	.+166    	; 0x534c <PopOutgoingMidiByte+0xc2>
    52a6:	87 30       	cpi	r24, 0x07	; 7
    52a8:	09 f4       	brne	.+2      	; 0x52ac <PopOutgoingMidiByte+0x22>
    52aa:	4b c0       	rjmp	.+150    	; 0x5342 <PopOutgoingMidiByte+0xb8>

			}
			break;

			default:
			theByte=0;		// Make compiler happy.
    52ac:	80 e0       	ldi	r24, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    52ae:	08 95       	ret
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    52b0:	81 30       	cpi	r24, 0x01	; 1
    52b2:	09 f4       	brne	.+2      	; 0x52b6 <PopOutgoingMidiByte+0x2c>
    52b4:	51 c0       	rjmp	.+162    	; 0x5358 <PopOutgoingMidiByte+0xce>
    52b6:	d0 f5       	brcc	.+116    	; 0x532c <PopOutgoingMidiByte+0xa2>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    52b8:	80 91 62 06 	lds	r24, 0x0662
    52bc:	88 23       	and	r24, r24
    52be:	09 f4       	brne	.+2      	; 0x52c2 <PopOutgoingMidiByte+0x38>
    52c0:	58 c0       	rjmp	.+176    	; 0x5372 <PopOutgoingMidiByte+0xe8>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    52c2:	20 91 d9 05 	lds	r18, 0x05D9
    52c6:	e2 2f       	mov	r30, r18
    52c8:	f0 e0       	ldi	r31, 0x00	; 0
    52ca:	ee 0f       	add	r30, r30
    52cc:	ff 1f       	adc	r31, r31
    52ce:	ee 0f       	add	r30, r30
    52d0:	ff 1f       	adc	r31, r31
    52d2:	e7 5b       	subi	r30, 0xB7	; 183
    52d4:	f9 4f       	sbci	r31, 0xF9	; 249
    52d6:	91 81       	ldd	r25, Z+1	; 0x01
    52d8:	90 93 dd 05 	sts	0x05DD, r25
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    52dc:	32 81       	ldd	r19, Z+2	; 0x02
    52de:	30 93 de 05 	sts	0x05DE, r19
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    52e2:	33 81       	ldd	r19, Z+3	; 0x03
    52e4:	30 93 df 05 	sts	0x05DF, r19
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    52e8:	30 81       	ld	r19, Z
    52ea:	30 93 dc 05 	sts	0x05DC, r19

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    52ee:	2f 5f       	subi	r18, 0xFF	; 255
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    52f0:	26 30       	cpi	r18, 0x06	; 6
    52f2:	e0 f5       	brcc	.+120    	; 0x536c <PopOutgoingMidiByte+0xe2>
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    52f4:	20 93 d9 05 	sts	0x05D9, r18
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    52f8:	81 50       	subi	r24, 0x01	; 1
    52fa:	80 93 62 06 	sts	0x0662, r24
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    52fe:	92 30       	cpi	r25, 0x02	; 2
    5300:	09 f4       	brne	.+2      	; 0x5304 <PopOutgoingMidiByte+0x7a>
    5302:	4c c0       	rjmp	.+152    	; 0x539c <PopOutgoingMidiByte+0x112>
    5304:	c8 f5       	brcc	.+114    	; 0x5378 <PopOutgoingMidiByte+0xee>
    5306:	91 30       	cpi	r25, 0x01	; 1
    5308:	89 f6       	brne	.-94     	; 0x52ac <PopOutgoingMidiByte+0x22>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    530a:	80 91 dc 05 	lds	r24, 0x05DC
    530e:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    5310:	20 91 e0 05 	lds	r18, 0x05E0
    5314:	28 17       	cp	r18, r24
    5316:	09 f4       	brne	.+2      	; 0x531a <PopOutgoingMidiByte+0x90>
    5318:	5b c0       	rjmp	.+182    	; 0x53d0 <PopOutgoingMidiByte+0x146>
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    531a:	80 93 e0 05 	sts	0x05E0, r24
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
    531e:	90 93 d7 05 	sts	0x05D7, r25
    5322:	08 95       	ret
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5324:	10 92 d7 05 	sts	0x05D7, r1
		return(0);											// Return a velocity of 0 (this means a note off)
    5328:	80 e0       	ldi	r24, 0x00	; 0
    532a:	08 95       	ret
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    532c:	84 e0       	ldi	r24, 0x04	; 4
    532e:	80 93 d7 05 	sts	0x05D7, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    5332:	80 91 de 05 	lds	r24, 0x05DE
    5336:	08 95       	ret
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5338:	10 92 d7 05 	sts	0x05D7, r1
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
    533c:	80 91 de 05 	lds	r24, 0x05DE
    5340:	08 95       	ret
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
		return(theMessage.dataByteOne);								// Return the first data byte.
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5342:	10 92 d7 05 	sts	0x05D7, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    5346:	80 91 df 05 	lds	r24, 0x05DF
    534a:	08 95       	ret
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    534c:	87 e0       	ldi	r24, 0x07	; 7
    534e:	80 93 d7 05 	sts	0x05D7, r24
		return(theMessage.dataByteOne);								// Return the first data byte.
    5352:	80 91 de 05 	lds	r24, 0x05DE
    5356:	08 95       	ret
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    5358:	83 e0       	ldi	r24, 0x03	; 3
    535a:	80 93 d7 05 	sts	0x05D7, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    535e:	80 91 de 05 	lds	r24, 0x05DE
    5362:	08 95       	ret
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5364:	10 92 d7 05 	sts	0x05D7, r1
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
    5368:	80 e4       	ldi	r24, 0x40	; 64
    536a:	08 95       	ret
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
    536c:	10 92 d9 05 	sts	0x05D9, r1
    5370:	c3 cf       	rjmp	.-122    	; 0x52f8 <PopOutgoingMidiByte+0x6e>
    5372:	90 91 dd 05 	lds	r25, 0x05DD
    5376:	c3 cf       	rjmp	.-122    	; 0x52fe <PopOutgoingMidiByte+0x74>
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    5378:	93 30       	cpi	r25, 0x03	; 3
    537a:	e9 f0       	breq	.+58     	; 0x53b6 <PopOutgoingMidiByte+0x12c>
    537c:	94 30       	cpi	r25, 0x04	; 4
    537e:	09 f0       	breq	.+2      	; 0x5382 <PopOutgoingMidiByte+0xf8>
    5380:	95 cf       	rjmp	.-214    	; 0x52ac <PopOutgoingMidiByte+0x22>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    5382:	80 91 dc 05 	lds	r24, 0x05DC
    5386:	80 6b       	ori	r24, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    5388:	90 91 e0 05 	lds	r25, 0x05E0
    538c:	98 17       	cp	r25, r24
    538e:	31 f1       	breq	.+76     	; 0x53dc <PopOutgoingMidiByte+0x152>
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    5390:	80 93 e0 05 	sts	0x05E0, r24
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    5394:	96 e0       	ldi	r25, 0x06	; 6
    5396:	90 93 d7 05 	sts	0x05D7, r25
    539a:	08 95       	ret

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    539c:	80 91 dc 05 	lds	r24, 0x05DC
    53a0:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    53a2:	20 91 e0 05 	lds	r18, 0x05E0
    53a6:	28 13       	cpse	r18, r24
    53a8:	b8 cf       	rjmp	.-144    	; 0x531a <PopOutgoingMidiByte+0x90>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    53aa:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    53ae:	94 e0       	ldi	r25, 0x04	; 4
    53b0:	90 93 d7 05 	sts	0x05D7, r25
    53b4:	08 95       	ret

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    53b6:	80 91 dc 05 	lds	r24, 0x05DC
    53ba:	80 6c       	ori	r24, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    53bc:	90 91 e0 05 	lds	r25, 0x05E0
    53c0:	98 17       	cp	r25, r24
    53c2:	91 f0       	breq	.+36     	; 0x53e8 <PopOutgoingMidiByte+0x15e>
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    53c4:	80 93 e0 05 	sts	0x05E0, r24
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    53c8:	95 e0       	ldi	r25, 0x05	; 5
    53ca:	90 93 d7 05 	sts	0x05D7, r25
    53ce:	08 95       	ret
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
			if(lastStatusByte==theByte)								// Same status byte as last time?
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    53d0:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    53d4:	93 e0       	ldi	r25, 0x03	; 3
    53d6:	90 93 d7 05 	sts	0x05D7, r25
    53da:	08 95       	ret

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
			if(lastStatusByte==theByte)										// Same status byte as last time?
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    53dc:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    53e0:	97 e0       	ldi	r25, 0x07	; 7
    53e2:	90 93 d7 05 	sts	0x05D7, r25
    53e6:	08 95       	ret

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
			if(lastStatusByte==theByte)										// Same status byte as last time?
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    53e8:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    53ec:	10 92 d7 05 	sts	0x05D7, r1
    53f0:	08 95       	ret

000053f2 <SendDummyByte>:
}

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    53f2:	80 91 c8 00 	lds	r24, 0x00C8
    53f6:	80 64       	ori	r24, 0x40	; 64
    53f8:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    53fc:	80 91 c8 00 	lds	r24, 0x00C8
    5400:	85 ff       	sbrs	r24, 5
    5402:	fc cf       	rjmp	.-8      	; 0x53fc <SendDummyByte+0xa>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5404:	8f ef       	ldi	r24, 0xFF	; 255
    5406:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    540a:	80 91 c8 00 	lds	r24, 0x00C8
    540e:	87 ff       	sbrs	r24, 7
    5410:	fc cf       	rjmp	.-8      	; 0x540a <SendDummyByte+0x18>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5412:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5416:	80 91 c8 00 	lds	r24, 0x00C8
    541a:	86 ff       	sbrs	r24, 6
    541c:	fc cf       	rjmp	.-8      	; 0x5416 <SendDummyByte+0x24>
		;
}
    541e:	08 95       	ret

00005420 <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    5420:	8a b1       	in	r24, 0x0a	; 10
    5422:	8f 7c       	andi	r24, 0xCF	; 207
    5424:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    5426:	8b b1       	in	r24, 0x0b	; 11
    5428:	80 63       	ori	r24, 0x30	; 48
    542a:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    542c:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    5430:	e4 e6       	ldi	r30, 0x64	; 100
    5432:	f0 e0       	ldi	r31, 0x00	; 0
    5434:	80 81       	ld	r24, Z
    5436:	80 61       	ori	r24, 0x10	; 16
    5438:	80 83       	st	Z, r24
    543a:	08 95       	ret

0000543c <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    543c:	e4 e6       	ldi	r30, 0x64	; 100
    543e:	f0 e0       	ldi	r31, 0x00	; 0
    5440:	80 81       	ld	r24, Z
    5442:	8f 7e       	andi	r24, 0xEF	; 239
    5444:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    5446:	ec ec       	ldi	r30, 0xCC	; 204
    5448:	f0 e0       	ldi	r31, 0x00	; 0
    544a:	11 82       	std	Z+1, r1	; 0x01
    544c:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    544e:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    5450:	80 ec       	ldi	r24, 0xC0	; 192
    5452:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    5456:	88 e1       	ldi	r24, 0x18	; 24
    5458:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    545c:	81 e0       	ldi	r24, 0x01	; 1
    545e:	90 e0       	ldi	r25, 0x00	; 0
    5460:	91 83       	std	Z+1, r25	; 0x01
    5462:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    5464:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS high.
    5466:	5d 9a       	sbi	0x0b, 5	; 11
    5468:	08 95       	ret

0000546a <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    546a:	5d 9a       	sbi	0x0b, 5	; 11
    546c:	08 95       	ret

0000546e <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    546e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    5470:	5d 98       	cbi	0x0b, 5	; 11
    5472:	08 95       	ret

00005474 <TransferSdByte>:
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5474:	90 91 c8 00 	lds	r25, 0x00C8
    5478:	95 ff       	sbrs	r25, 5
    547a:	fc cf       	rjmp	.-8      	; 0x5474 <TransferSdByte>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    547c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5480:	80 91 c8 00 	lds	r24, 0x00C8
    5484:	87 ff       	sbrs	r24, 7
    5486:	fc cf       	rjmp	.-8      	; 0x5480 <TransferSdByte+0xc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5488:	80 91 ce 00 	lds	r24, 0x00CE
}
    548c:	08 95       	ret

0000548e <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    548e:	e8 2f       	mov	r30, r24

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5490:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    5492:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5494:	90 91 c8 00 	lds	r25, 0x00C8
    5498:	95 ff       	sbrs	r25, 5
    549a:	fc cf       	rjmp	.-8      	; 0x5494 <SendSdCommand+0x6>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    549c:	8f ef       	ldi	r24, 0xFF	; 255
    549e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54a2:	90 91 c8 00 	lds	r25, 0x00C8
    54a6:	97 ff       	sbrs	r25, 7
    54a8:	fc cf       	rjmp	.-8      	; 0x54a2 <SendSdCommand+0x14>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54aa:	80 91 ce 00 	lds	r24, 0x00CE
		tmpCrc;

	StartSdTransfer();		// Assert CS
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    54ae:	e7 fd       	sbrc	r30, 7
    54b0:	81 c0       	rjmp	.+258    	; 0x55b4 <SendSdCommand+0x126>
		StartSdTransfer();	// Assert CS
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    54b2:	8e 2f       	mov	r24, r30
    54b4:	80 64       	ori	r24, 0x40	; 64
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54b6:	90 91 c8 00 	lds	r25, 0x00C8
    54ba:	95 ff       	sbrs	r25, 5
    54bc:	fc cf       	rjmp	.-8      	; 0x54b6 <SendSdCommand+0x28>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54be:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54c2:	90 91 c8 00 	lds	r25, 0x00C8
    54c6:	97 ff       	sbrs	r25, 7
    54c8:	fc cf       	rjmp	.-8      	; 0x54c2 <SendSdCommand+0x34>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54ca:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54ce:	90 91 c8 00 	lds	r25, 0x00C8
    54d2:	95 ff       	sbrs	r25, 5
    54d4:	fc cf       	rjmp	.-8      	; 0x54ce <SendSdCommand+0x40>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54d6:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54da:	90 91 c8 00 	lds	r25, 0x00C8
    54de:	97 ff       	sbrs	r25, 7
    54e0:	fc cf       	rjmp	.-8      	; 0x54da <SendSdCommand+0x4c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54e2:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54e6:	90 91 c8 00 	lds	r25, 0x00C8
    54ea:	95 ff       	sbrs	r25, 5
    54ec:	fc cf       	rjmp	.-8      	; 0x54e6 <SendSdCommand+0x58>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54ee:	60 93 ce 00 	sts	0x00CE, r22

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54f2:	90 91 c8 00 	lds	r25, 0x00C8
    54f6:	97 ff       	sbrs	r25, 7
    54f8:	fc cf       	rjmp	.-8      	; 0x54f2 <SendSdCommand+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54fa:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54fe:	90 91 c8 00 	lds	r25, 0x00C8
    5502:	95 ff       	sbrs	r25, 5
    5504:	fc cf       	rjmp	.-8      	; 0x54fe <SendSdCommand+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5506:	50 93 ce 00 	sts	0x00CE, r21

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    550a:	90 91 c8 00 	lds	r25, 0x00C8
    550e:	97 ff       	sbrs	r25, 7
    5510:	fc cf       	rjmp	.-8      	; 0x550a <SendSdCommand+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5512:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5516:	90 91 c8 00 	lds	r25, 0x00C8
    551a:	95 ff       	sbrs	r25, 5
    551c:	fc cf       	rjmp	.-8      	; 0x5516 <SendSdCommand+0x88>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    551e:	40 93 ce 00 	sts	0x00CE, r20

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5522:	90 91 c8 00 	lds	r25, 0x00C8
    5526:	97 ff       	sbrs	r25, 7
    5528:	fc cf       	rjmp	.-8      	; 0x5522 <SendSdCommand+0x94>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    552a:	80 91 ce 00 	lds	r24, 0x00CE
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    552e:	ee 23       	and	r30, r30
    5530:	09 f4       	brne	.+2      	; 0x5534 <SendSdCommand+0xa6>
    5532:	c4 c0       	rjmp	.+392    	; 0x56bc <SendSdCommand+0x22e>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    5534:	e8 30       	cpi	r30, 0x08	; 8
    5536:	09 f0       	breq	.+2      	; 0x553a <SendSdCommand+0xac>
    5538:	c7 c0       	rjmp	.+398    	; 0x56c8 <SendSdCommand+0x23a>
	{
		tmpCrc=0x87;
    553a:	87 e8       	ldi	r24, 0x87	; 135
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    553c:	90 91 c8 00 	lds	r25, 0x00C8
    5540:	95 ff       	sbrs	r25, 5
    5542:	fc cf       	rjmp	.-8      	; 0x553c <SendSdCommand+0xae>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5544:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5548:	90 91 c8 00 	lds	r25, 0x00C8
    554c:	97 ff       	sbrs	r25, 7
    554e:	fc cf       	rjmp	.-8      	; 0x5548 <SendSdCommand+0xba>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5550:	80 91 ce 00 	lds	r24, 0x00CE
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    5554:	ec 30       	cpi	r30, 0x0C	; 12
    5556:	09 f4       	brne	.+2      	; 0x555a <SendSdCommand+0xcc>
    5558:	a3 c0       	rjmp	.+326    	; 0x56a0 <SendSdCommand+0x212>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    555a:	2a e0       	ldi	r18, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    555c:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    555e:	90 91 c8 00 	lds	r25, 0x00C8
    5562:	95 ff       	sbrs	r25, 5
    5564:	fc cf       	rjmp	.-8      	; 0x555e <SendSdCommand+0xd0>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5566:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    556a:	90 91 c8 00 	lds	r25, 0x00C8
    556e:	97 ff       	sbrs	r25, 7
    5570:	fc cf       	rjmp	.-8      	; 0x556a <SendSdCommand+0xdc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5572:	80 91 ce 00 	lds	r24, 0x00CE
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    5576:	8f 3f       	cpi	r24, 0xFF	; 255
    5578:	11 f4       	brne	.+4      	; 0x557e <SendSdCommand+0xf0>
    557a:	21 50       	subi	r18, 0x01	; 1
    557c:	81 f7       	brne	.-32     	; 0x555e <SendSdCommand+0xd0>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    557e:	e8 30       	cpi	r30, 0x08	; 8
    5580:	c1 f0       	breq	.+48     	; 0x55b2 <SendSdCommand+0x124>
    5582:	ea 33       	cpi	r30, 0x3A	; 58
    5584:	b1 f0       	breq	.+44     	; 0x55b2 <SendSdCommand+0x124>
}

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    5586:	90 91 c8 00 	lds	r25, 0x00C8
    558a:	90 64       	ori	r25, 0x40	; 64
    558c:	90 93 c8 00 	sts	0x00C8, r25
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5590:	90 91 c8 00 	lds	r25, 0x00C8
    5594:	95 ff       	sbrs	r25, 5
    5596:	fc cf       	rjmp	.-8      	; 0x5590 <SendSdCommand+0x102>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5598:	9f ef       	ldi	r25, 0xFF	; 255
    559a:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    559e:	90 91 c8 00 	lds	r25, 0x00C8
    55a2:	97 ff       	sbrs	r25, 7
    55a4:	fc cf       	rjmp	.-8      	; 0x559e <SendSdCommand+0x110>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    55a6:	90 91 ce 00 	lds	r25, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    55aa:	90 91 c8 00 	lds	r25, 0x00C8
    55ae:	96 ff       	sbrs	r25, 6
    55b0:	fc cf       	rjmp	.-8      	; 0x55aa <SendSdCommand+0x11c>
	{
		SendDummyByte();	
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    55b2:	08 95       	ret
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    55b4:	80 91 c8 00 	lds	r24, 0x00C8
    55b8:	85 ff       	sbrs	r24, 5
    55ba:	fc cf       	rjmp	.-8      	; 0x55b4 <SendSdCommand+0x126>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    55bc:	87 e7       	ldi	r24, 0x77	; 119
    55be:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    55c2:	80 91 c8 00 	lds	r24, 0x00C8
    55c6:	87 ff       	sbrs	r24, 7
    55c8:	fc cf       	rjmp	.-8      	; 0x55c2 <SendSdCommand+0x134>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    55ca:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    55ce:	80 91 c8 00 	lds	r24, 0x00C8
    55d2:	85 ff       	sbrs	r24, 5
    55d4:	fc cf       	rjmp	.-8      	; 0x55ce <SendSdCommand+0x140>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    55d6:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    55da:	80 91 c8 00 	lds	r24, 0x00C8
    55de:	87 ff       	sbrs	r24, 7
    55e0:	fc cf       	rjmp	.-8      	; 0x55da <SendSdCommand+0x14c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    55e2:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    55e6:	80 91 c8 00 	lds	r24, 0x00C8
    55ea:	85 ff       	sbrs	r24, 5
    55ec:	fc cf       	rjmp	.-8      	; 0x55e6 <SendSdCommand+0x158>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    55ee:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    55f2:	80 91 c8 00 	lds	r24, 0x00C8
    55f6:	87 ff       	sbrs	r24, 7
    55f8:	fc cf       	rjmp	.-8      	; 0x55f2 <SendSdCommand+0x164>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    55fa:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    55fe:	80 91 c8 00 	lds	r24, 0x00C8
    5602:	85 ff       	sbrs	r24, 5
    5604:	fc cf       	rjmp	.-8      	; 0x55fe <SendSdCommand+0x170>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5606:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    560a:	80 91 c8 00 	lds	r24, 0x00C8
    560e:	87 ff       	sbrs	r24, 7
    5610:	fc cf       	rjmp	.-8      	; 0x560a <SendSdCommand+0x17c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5612:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5616:	80 91 c8 00 	lds	r24, 0x00C8
    561a:	85 ff       	sbrs	r24, 5
    561c:	fc cf       	rjmp	.-8      	; 0x5616 <SendSdCommand+0x188>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    561e:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5622:	80 91 c8 00 	lds	r24, 0x00C8
    5626:	87 ff       	sbrs	r24, 7
    5628:	fc cf       	rjmp	.-8      	; 0x5622 <SendSdCommand+0x194>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    562a:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    562e:	80 91 c8 00 	lds	r24, 0x00C8
    5632:	85 ff       	sbrs	r24, 5
    5634:	fc cf       	rjmp	.-8      	; 0x562e <SendSdCommand+0x1a0>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5636:	81 e0       	ldi	r24, 0x01	; 1
    5638:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    563c:	80 91 c8 00 	lds	r24, 0x00C8
    5640:	87 ff       	sbrs	r24, 7
    5642:	fc cf       	rjmp	.-8      	; 0x563c <SendSdCommand+0x1ae>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5644:	80 91 ce 00 	lds	r24, 0x00CE
    5648:	2a e0       	ldi	r18, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    564a:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    564c:	90 91 c8 00 	lds	r25, 0x00C8
    5650:	95 ff       	sbrs	r25, 5
    5652:	fc cf       	rjmp	.-8      	; 0x564c <SendSdCommand+0x1be>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5654:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5658:	90 91 c8 00 	lds	r25, 0x00C8
    565c:	97 ff       	sbrs	r25, 7
    565e:	fc cf       	rjmp	.-8      	; 0x5658 <SendSdCommand+0x1ca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5660:	80 91 ce 00 	lds	r24, 0x00CE
		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    5664:	8f 3f       	cpi	r24, 0xFF	; 255
    5666:	11 f4       	brne	.+4      	; 0x566c <SendSdCommand+0x1de>
    5668:	21 50       	subi	r18, 0x01	; 1
    566a:	81 f7       	brne	.-32     	; 0x564c <SendSdCommand+0x1be>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    566c:	90 91 c8 00 	lds	r25, 0x00C8
    5670:	90 64       	ori	r25, 0x40	; 64
    5672:	90 93 c8 00 	sts	0x00C8, r25
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5676:	90 91 c8 00 	lds	r25, 0x00C8
    567a:	95 ff       	sbrs	r25, 5
    567c:	fc cf       	rjmp	.-8      	; 0x5676 <SendSdCommand+0x1e8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    567e:	9f ef       	ldi	r25, 0xFF	; 255
    5680:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5684:	90 91 c8 00 	lds	r25, 0x00C8
    5688:	97 ff       	sbrs	r25, 7
    568a:	fc cf       	rjmp	.-8      	; 0x5684 <SendSdCommand+0x1f6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    568c:	90 91 ce 00 	lds	r25, 0x00CE
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5690:	90 91 c8 00 	lds	r25, 0x00C8
    5694:	96 ff       	sbrs	r25, 6
    5696:	fc cf       	rjmp	.-8      	; 0x5690 <SendSdCommand+0x202>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5698:	5d 9a       	sbi	0x0b, 5	; 11
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
			;

		if(response>1)				// Something wrong?
    569a:	82 30       	cpi	r24, 0x02	; 2
    569c:	88 f0       	brcs	.+34     	; 0x56c0 <SendSdCommand+0x232>
		{
			EndSdTransfer();	// Bring CS high
			return(response);	// ACMD preambe returned something weird.  Bail.
    569e:	08 95       	ret
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    56a0:	80 91 c8 00 	lds	r24, 0x00C8
    56a4:	85 ff       	sbrs	r24, 5
    56a6:	fc cf       	rjmp	.-8      	; 0x56a0 <SendSdCommand+0x212>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    56a8:	8f ef       	ldi	r24, 0xFF	; 255
    56aa:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    56ae:	80 91 c8 00 	lds	r24, 0x00C8
    56b2:	87 ff       	sbrs	r24, 7
    56b4:	fc cf       	rjmp	.-8      	; 0x56ae <SendSdCommand+0x220>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    56b6:	80 91 ce 00 	lds	r24, 0x00CE
    56ba:	4f cf       	rjmp	.-354    	; 0x555a <SendSdCommand+0xcc>
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
	{
		tmpCrc=0x95;
    56bc:	85 e9       	ldi	r24, 0x95	; 149
    56be:	3e cf       	rjmp	.-388    	; 0x553c <SendSdCommand+0xae>
			EndSdTransfer();	// Bring CS high
			return(response);	// ACMD preambe returned something weird.  Bail.
		}

		EndSdTransfer();	// Bring CS high
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    56c0:	ef 77       	andi	r30, 0x7F	; 127

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    56c2:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    56c4:	5d 98       	cbi	0x0b, 5	; 11
    56c6:	f5 ce       	rjmp	.-534    	; 0x54b2 <SendSdCommand+0x24>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)
    56c8:	81 e0       	ldi	r24, 0x01	; 1
    56ca:	38 cf       	rjmp	.-400    	; 0x553c <SendSdCommand+0xae>

000056cc <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    56cc:	1f 93       	push	r17
    56ce:	cf 93       	push	r28
    56d0:	df 93       	push	r29
    56d2:	00 d0       	rcall	.+0      	; 0x56d4 <SdHandshake+0x8>
    56d4:	00 d0       	rcall	.+0      	; 0x56d6 <SdHandshake+0xa>
    56d6:	cd b7       	in	r28, 0x3d	; 61
    56d8:	de b7       	in	r29, 0x3e	; 62
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    56da:	5d 9a       	sbi	0x0b, 5	; 11
    56dc:	94 e1       	ldi	r25, 0x14	; 20
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    56de:	2f ef       	ldi	r18, 0xFF	; 255
	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    56e0:	80 91 c8 00 	lds	r24, 0x00C8
    56e4:	80 64       	ori	r24, 0x40	; 64
    56e6:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    56ea:	80 91 c8 00 	lds	r24, 0x00C8
    56ee:	85 ff       	sbrs	r24, 5
    56f0:	fc cf       	rjmp	.-8      	; 0x56ea <SdHandshake+0x1e>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    56f2:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    56f6:	80 91 c8 00 	lds	r24, 0x00C8
    56fa:	87 ff       	sbrs	r24, 7
    56fc:	fc cf       	rjmp	.-8      	; 0x56f6 <SdHandshake+0x2a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    56fe:	80 91 ce 00 	lds	r24, 0x00CE
    5702:	91 50       	subi	r25, 0x01	; 1
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    5704:	69 f7       	brne	.-38     	; 0x56e0 <SdHandshake+0x14>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5706:	80 91 c8 00 	lds	r24, 0x00C8
    570a:	86 ff       	sbrs	r24, 6
    570c:	fc cf       	rjmp	.-8      	; 0x5706 <SdHandshake+0x3a>

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    570e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    5710:	5d 98       	cbi	0x0b, 5	; 11
    5712:	80 e0       	ldi	r24, 0x00	; 0
    5714:	92 e0       	ldi	r25, 0x02	; 2
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5716:	3f ef       	ldi	r19, 0xFF	; 255
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    5718:	20 91 c8 00 	lds	r18, 0x00C8
    571c:	20 64       	ori	r18, 0x40	; 64
    571e:	20 93 c8 00 	sts	0x00C8, r18
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5722:	20 91 c8 00 	lds	r18, 0x00C8
    5726:	25 ff       	sbrs	r18, 5
    5728:	fc cf       	rjmp	.-8      	; 0x5722 <SdHandshake+0x56>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    572a:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    572e:	20 91 c8 00 	lds	r18, 0x00C8
    5732:	27 ff       	sbrs	r18, 7
    5734:	fc cf       	rjmp	.-8      	; 0x572e <SdHandshake+0x62>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5736:	20 91 ce 00 	lds	r18, 0x00CE
    573a:	01 97       	sbiw	r24, 0x01	; 1

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    573c:	69 f7       	brne	.-38     	; 0x5718 <SdHandshake+0x4c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    573e:	80 91 c8 00 	lds	r24, 0x00C8
    5742:	86 ff       	sbrs	r24, 6
    5744:	fc cf       	rjmp	.-8      	; 0x573e <SdHandshake+0x72>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5746:	5d 9a       	sbi	0x0b, 5	; 11
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    5748:	40 e0       	ldi	r20, 0x00	; 0
    574a:	50 e0       	ldi	r21, 0x00	; 0
    574c:	ba 01       	movw	r22, r20
    574e:	80 e0       	ldi	r24, 0x00	; 0
    5750:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5754:	80 91 c8 00 	lds	r24, 0x00C8
    5758:	86 ff       	sbrs	r24, 6
    575a:	fc cf       	rjmp	.-8      	; 0x5754 <SdHandshake+0x88>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    575c:	5d 9a       	sbi	0x0b, 5	; 11
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    575e:	40 e0       	ldi	r20, 0x00	; 0
    5760:	50 e0       	ldi	r21, 0x00	; 0
    5762:	ba 01       	movw	r22, r20
    5764:	80 e0       	ldi	r24, 0x00	; 0
    5766:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    576a:	81 30       	cpi	r24, 0x01	; 1
    576c:	51 f0       	breq	.+20     	; 0x5782 <SdHandshake+0xb6>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
    576e:	80 e0       	ldi	r24, 0x00	; 0
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5770:	5d 9a       	sbi	0x0b, 5	; 11
		}
	}

	EndSdTransfer();	// Bring CS high
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    5772:	0f 90       	pop	r0
    5774:	0f 90       	pop	r0
    5776:	0f 90       	pop	r0
    5778:	0f 90       	pop	r0
    577a:	df 91       	pop	r29
    577c:	cf 91       	pop	r28
    577e:	1f 91       	pop	r17
    5780:	08 95       	ret
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5782:	5d 9a       	sbi	0x0b, 5	; 11
	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    5784:	4a ea       	ldi	r20, 0xAA	; 170
    5786:	51 e0       	ldi	r21, 0x01	; 1
    5788:	60 e0       	ldi	r22, 0x00	; 0
    578a:	70 e0       	ldi	r23, 0x00	; 0
    578c:	88 e0       	ldi	r24, 0x08	; 8
    578e:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    5792:	81 30       	cpi	r24, 0x01	; 1
    5794:	09 f4       	brne	.+2      	; 0x5798 <SdHandshake+0xcc>
    5796:	45 c0       	rjmp	.+138    	; 0x5822 <SdHandshake+0x156>
}

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    5798:	80 91 c8 00 	lds	r24, 0x00C8
    579c:	80 64       	ori	r24, 0x40	; 64
    579e:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    57a2:	80 91 c8 00 	lds	r24, 0x00C8
    57a6:	85 ff       	sbrs	r24, 5
    57a8:	fc cf       	rjmp	.-8      	; 0x57a2 <SdHandshake+0xd6>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    57aa:	8f ef       	ldi	r24, 0xFF	; 255
    57ac:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    57b0:	80 91 c8 00 	lds	r24, 0x00C8
    57b4:	87 ff       	sbrs	r24, 7
    57b6:	fc cf       	rjmp	.-8      	; 0x57b0 <SdHandshake+0xe4>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    57b8:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    57bc:	80 91 c8 00 	lds	r24, 0x00C8
    57c0:	86 ff       	sbrs	r24, 6
    57c2:	fc cf       	rjmp	.-8      	; 0x57bc <SdHandshake+0xf0>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    57c4:	5d 9a       	sbi	0x0b, 5	; 11
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    57c6:	40 e0       	ldi	r20, 0x00	; 0
    57c8:	50 e0       	ldi	r21, 0x00	; 0
    57ca:	ba 01       	movw	r22, r20
    57cc:	89 ea       	ldi	r24, 0xA9	; 169
    57ce:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    57d2:	82 30       	cpi	r24, 0x02	; 2
    57d4:	60 f6       	brcc	.-104    	; 0x576e <SdHandshake+0xa2>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    57d6:	5d 9a       	sbi	0x0b, 5	; 11
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);
    57d8:	64 ec       	ldi	r22, 0xC4	; 196
    57da:	74 e0       	ldi	r23, 0x04	; 4
    57dc:	83 e0       	ldi	r24, 0x03	; 3
    57de:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    57e2:	0b c0       	rjmp	.+22     	; 0x57fa <SdHandshake+0x12e>
    57e4:	40 e0       	ldi	r20, 0x00	; 0
    57e6:	50 e0       	ldi	r21, 0x00	; 0
    57e8:	ba 01       	movw	r22, r20
    57ea:	89 ea       	ldi	r24, 0xA9	; 169
    57ec:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    57f0:	88 23       	and	r24, r24
    57f2:	41 f0       	breq	.+16     	; 0x5804 <SdHandshake+0x138>
				{
					HandleSoftclock();	// Keep the timer timing.
    57f4:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    57f8:	5d 9a       	sbi	0x0b, 5	; 11
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    57fa:	83 e0       	ldi	r24, 0x03	; 3
    57fc:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5800:	88 23       	and	r24, r24
    5802:	81 f3       	breq	.-32     	; 0x57e4 <SdHandshake+0x118>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    5804:	83 e0       	ldi	r24, 0x03	; 3
    5806:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    580a:	81 11       	cpse	r24, r1
    580c:	b0 cf       	rjmp	.-160    	; 0x576e <SdHandshake+0xa2>
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    580e:	40 e0       	ldi	r20, 0x00	; 0
    5810:	52 e0       	ldi	r21, 0x02	; 2
    5812:	60 e0       	ldi	r22, 0x00	; 0
    5814:	70 e0       	ldi	r23, 0x00	; 0
    5816:	80 e1       	ldi	r24, 0x10	; 16
    5818:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    581c:	5d 9a       	sbi	0x0b, 5	; 11

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
					EndSdTransfer();						// Bring CS high.
					cardValid=true;							// SDC v1 card, good to go
    581e:	81 e0       	ldi	r24, 0x01	; 1
    5820:	a7 cf       	rjmp	.-178    	; 0x5770 <SdHandshake+0xa4>
    5822:	fe 01       	movw	r30, r28
    5824:	31 96       	adiw	r30, 0x01	; 1
//-----------------------------------------------------------------------
// SD SPI Mode and Initialization Functions
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

bool SdHandshake(void)
    5826:	ce 01       	movw	r24, r28
    5828:	05 96       	adiw	r24, 0x05	; 5
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    582a:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    582c:	20 91 c8 00 	lds	r18, 0x00C8
    5830:	25 ff       	sbrs	r18, 5
    5832:	fc cf       	rjmp	.-8      	; 0x582c <SdHandshake+0x160>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5834:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5838:	20 91 c8 00 	lds	r18, 0x00C8
    583c:	27 ff       	sbrs	r18, 7
    583e:	fc cf       	rjmp	.-8      	; 0x5838 <SdHandshake+0x16c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5840:	20 91 ce 00 	lds	r18, 0x00CE

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    5844:	21 93       	st	Z+, r18
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    5846:	e8 17       	cp	r30, r24
    5848:	f9 07       	cpc	r31, r25
    584a:	81 f7       	brne	.-32     	; 0x582c <SdHandshake+0x160>
}

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    584c:	80 91 c8 00 	lds	r24, 0x00C8
    5850:	80 64       	ori	r24, 0x40	; 64
    5852:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5856:	80 91 c8 00 	lds	r24, 0x00C8
    585a:	85 ff       	sbrs	r24, 5
    585c:	fc cf       	rjmp	.-8      	; 0x5856 <SdHandshake+0x18a>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    585e:	8f ef       	ldi	r24, 0xFF	; 255
    5860:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5864:	80 91 c8 00 	lds	r24, 0x00C8
    5868:	87 ff       	sbrs	r24, 7
    586a:	fc cf       	rjmp	.-8      	; 0x5864 <SdHandshake+0x198>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    586c:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5870:	80 91 c8 00 	lds	r24, 0x00C8
    5874:	86 ff       	sbrs	r24, 6
    5876:	fc cf       	rjmp	.-8      	; 0x5870 <SdHandshake+0x1a4>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5878:	5d 9a       	sbi	0x0b, 5	; 11
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
			EndSdTransfer();		// Bring CS high

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    587a:	8b 81       	ldd	r24, Y+3	; 0x03
    587c:	81 30       	cpi	r24, 0x01	; 1
    587e:	09 f0       	breq	.+2      	; 0x5882 <SdHandshake+0x1b6>
    5880:	76 cf       	rjmp	.-276    	; 0x576e <SdHandshake+0xa2>
    5882:	8c 81       	ldd	r24, Y+4	; 0x04
    5884:	8a 3a       	cpi	r24, 0xAA	; 170
    5886:	09 f0       	breq	.+2      	; 0x588a <SdHandshake+0x1be>
    5888:	72 cf       	rjmp	.-284    	; 0x576e <SdHandshake+0xa2>
			{				
				SetTimer(TIMER_SD,SECOND);
    588a:	64 ec       	ldi	r22, 0xC4	; 196
    588c:	74 e0       	ldi	r23, 0x04	; 4
    588e:	83 e0       	ldi	r24, 0x03	; 3
    5890:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    5894:	0b c0       	rjmp	.+22     	; 0x58ac <SdHandshake+0x1e0>
    5896:	40 e0       	ldi	r20, 0x00	; 0
    5898:	50 e0       	ldi	r21, 0x00	; 0
    589a:	ba 01       	movw	r22, r20
    589c:	89 ea       	ldi	r24, 0xA9	; 169
    589e:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    58a2:	88 23       	and	r24, r24
    58a4:	41 f0       	breq	.+16     	; 0x58b6 <SdHandshake+0x1ea>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    58a6:	5d 9a       	sbi	0x0b, 5	; 11
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
    58a8:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    58ac:	83 e0       	ldi	r24, 0x03	; 3
    58ae:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    58b2:	88 23       	and	r24, r24
    58b4:	81 f3       	breq	.-32     	; 0x5896 <SdHandshake+0x1ca>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    58b6:	83 e0       	ldi	r24, 0x03	; 3
    58b8:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    58bc:	81 11       	cpse	r24, r1
    58be:	57 cf       	rjmp	.-338    	; 0x576e <SdHandshake+0xa2>
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    58c0:	1f ef       	ldi	r17, 0xFF	; 255
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    58c2:	83 e0       	ldi	r24, 0x03	; 3
    58c4:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    58c8:	81 11       	cpse	r24, r1
    58ca:	21 c0       	rjmp	.+66     	; 0x590e <SdHandshake+0x242>
    58cc:	40 e0       	ldi	r20, 0x00	; 0
    58ce:	50 e0       	ldi	r21, 0x00	; 0
    58d0:	ba 01       	movw	r22, r20
    58d2:	8a e3       	ldi	r24, 0x3A	; 58
    58d4:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    58d8:	88 23       	and	r24, r24
    58da:	c9 f0       	breq	.+50     	; 0x590e <SdHandshake+0x242>
}

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    58dc:	80 91 c8 00 	lds	r24, 0x00C8
    58e0:	80 64       	ori	r24, 0x40	; 64
    58e2:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    58e6:	80 91 c8 00 	lds	r24, 0x00C8
    58ea:	85 ff       	sbrs	r24, 5
    58ec:	fc cf       	rjmp	.-8      	; 0x58e6 <SdHandshake+0x21a>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    58ee:	10 93 ce 00 	sts	0x00CE, r17

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    58f2:	80 91 c8 00 	lds	r24, 0x00C8
    58f6:	87 ff       	sbrs	r24, 7
    58f8:	fc cf       	rjmp	.-8      	; 0x58f2 <SdHandshake+0x226>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    58fa:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    58fe:	80 91 c8 00 	lds	r24, 0x00C8
    5902:	86 ff       	sbrs	r24, 6
    5904:	fc cf       	rjmp	.-8      	; 0x58fe <SdHandshake+0x232>
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
    5906:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    590a:	5d 9a       	sbi	0x0b, 5	; 11
    590c:	da cf       	rjmp	.-76     	; 0x58c2 <SdHandshake+0x1f6>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    590e:	83 e0       	ldi	r24, 0x03	; 3
    5910:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5914:	81 11       	cpse	r24, r1
    5916:	2b cf       	rjmp	.-426    	; 0x576e <SdHandshake+0xa2>
    5918:	84 e0       	ldi	r24, 0x04	; 4
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    591a:	9f ef       	ldi	r25, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    591c:	20 91 c8 00 	lds	r18, 0x00C8
    5920:	25 ff       	sbrs	r18, 5
    5922:	fc cf       	rjmp	.-8      	; 0x591c <SdHandshake+0x250>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5924:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5928:	20 91 c8 00 	lds	r18, 0x00C8
    592c:	27 ff       	sbrs	r18, 7
    592e:	fc cf       	rjmp	.-8      	; 0x5928 <SdHandshake+0x25c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5930:	20 91 ce 00 	lds	r18, 0x00CE
    5934:	81 50       	subi	r24, 0x01	; 1
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
    5936:	91 f7       	brne	.-28     	; 0x591c <SdHandshake+0x250>
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    5938:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    593c:	5d 9a       	sbi	0x0b, 5	; 11
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    593e:	40 e0       	ldi	r20, 0x00	; 0
    5940:	52 e0       	ldi	r21, 0x02	; 2
    5942:	60 e0       	ldi	r22, 0x00	; 0
    5944:	70 e0       	ldi	r23, 0x00	; 0
    5946:	80 e1       	ldi	r24, 0x10	; 16
    5948:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    594c:	5d 9a       	sbi	0x0b, 5	; 11
						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
						EndSdTransfer();						// Bring CS high.
						SendDummyByte();						
    594e:	0e 94 f9 29 	call	0x53f2	; 0x53f2 <SendDummyByte>
						cardValid=true;				// SD card present, and standard capacity.
    5952:	81 e0       	ldi	r24, 0x01	; 1
    5954:	0d cf       	rjmp	.-486    	; 0x5770 <SdHandshake+0xa4>

00005956 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    5956:	ab 01       	movw	r20, r22
    5958:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    595a:	89 e0       	ldi	r24, 0x09	; 9
    595c:	44 0f       	add	r20, r20
    595e:	55 1f       	adc	r21, r21
    5960:	66 1f       	adc	r22, r22
    5962:	77 1f       	adc	r23, r23
    5964:	8a 95       	dec	r24
    5966:	d1 f7       	brne	.-12     	; 0x595c <SdBeginSingleBlockRead+0x6>

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    5968:	81 e1       	ldi	r24, 0x11	; 17
    596a:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    596e:	91 e0       	ldi	r25, 0x01	; 1
    5970:	81 11       	cpse	r24, r1
    5972:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    5974:	89 2f       	mov	r24, r25
    5976:	08 95       	ret

00005978 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    5978:	ab 01       	movw	r20, r22
    597a:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    597c:	99 e0       	ldi	r25, 0x09	; 9
    597e:	44 0f       	add	r20, r20
    5980:	55 1f       	adc	r21, r21
    5982:	66 1f       	adc	r22, r22
    5984:	77 1f       	adc	r23, r23
    5986:	9a 95       	dec	r25
    5988:	d1 f7       	brne	.-12     	; 0x597e <SdBeginSingleBlockWrite+0x6>

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    598a:	88 e1       	ldi	r24, 0x18	; 24
    598c:	0e 94 47 2a 	call	0x548e	; 0x548e <SendSdCommand>
    5990:	91 e0       	ldi	r25, 0x01	; 1
    5992:	81 11       	cpse	r24, r1
    5994:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    5996:	89 2f       	mov	r24, r25
    5998:	08 95       	ret

0000599a <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    599a:	cf 93       	push	r28
    599c:	df 93       	push	r29
    599e:	cd b7       	in	r28, 0x3d	; 61
    59a0:	de b7       	in	r29, 0x3e	; 62
    59a2:	2c 97       	sbiw	r28, 0x0c	; 12
    59a4:	0f b6       	in	r0, 0x3f	; 63
    59a6:	f8 94       	cli
    59a8:	de bf       	out	0x3e, r29	; 62
    59aa:	0f be       	out	0x3f, r0	; 63
    59ac:	cd bf       	out	0x3d, r28	; 61
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    59ae:	1f ef       	ldi	r17, 0xFF	; 255
    59b0:	10 93 64 00 	sts	0x0064, r17
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    59b4:	85 b7       	in	r24, 0x35	; 53
    59b6:	8f 7e       	andi	r24, 0xEF	; 239
    59b8:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    59ba:	8f ee       	ldi	r24, 0xEF	; 239
    59bc:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    59be:	88 e0       	ldi	r24, 0x08	; 8
    59c0:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    59c2:	80 e8       	ldi	r24, 0x80	; 128
    59c4:	8a b9       	out	0x0a, r24	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    59c6:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    59c8:	96 e0       	ldi	r25, 0x06	; 6
    59ca:	92 b9       	out	0x02, r25	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    59cc:	9e e3       	ldi	r25, 0x3E	; 62
    59ce:	91 b9       	out	0x01, r25	; 1

	DDRB=0xFF;			// Latch port to OP.
    59d0:	14 b9       	out	0x04, r17	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    59d2:	85 b9       	out	0x05, r24	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    59d4:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    59d6:	14 b9       	out	0x04, r17	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    59d8:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    59da:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    59dc:	0e 94 1e 2a 	call	0x543c	; 0x543c <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    59e0:	66 e2       	ldi	r22, 0x26	; 38
    59e2:	70 e0       	ldi	r23, 0x00	; 0
    59e4:	81 e0       	ldi	r24, 0x01	; 1
    59e6:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    59ea:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    59ec:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    59ee:	80 b1       	in	r24, 0x00	; 0
    59f0:	80 7c       	andi	r24, 0xC0	; 192
    59f2:	80 93 57 05 	sts	0x0557, r24
	encoderValue=0;							// zero our relative position.
    59f6:	10 92 58 05 	sts	0x0558, r1
	newEncoder=false;
    59fa:	10 92 59 05 	sts	0x0559, r1
	encoderCw=false;
    59fe:	10 92 5a 05 	sts	0x055A, r1
	encoderCcw=false;
    5a02:	10 92 5b 05 	sts	0x055B, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    5a06:	10 92 62 05 	sts	0x0562, r1
	ledBlinkMask=0;
    5a0a:	10 92 b1 05 	sts	0x05B1, r1
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    5a0e:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    5a10:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    5a12:	15 b8       	out	0x05, r1	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    5a14:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    5a16:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    5a18:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    5a1a:	8f bf       	out	0x3f, r24	; 63

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    5a1c:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <InitMidi>
	InitUart0();
    5a20:	0e 94 35 27 	call	0x4e6a	; 0x4e6a <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    5a24:	80 91 64 00 	lds	r24, 0x0064
    5a28:	8e 7f       	andi	r24, 0xFE	; 254
    5a2a:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    5a2e:	80 e6       	ldi	r24, 0x60	; 96
    5a30:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    5a34:	81 e0       	ldi	r24, 0x01	; 1
    5a36:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    5a3a:	85 e9       	ldi	r24, 0x95	; 149
    5a3c:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    5a40:	80 91 7a 00 	lds	r24, 0x007A
    5a44:	80 64       	ori	r24, 0x40	; 64
    5a46:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    5a4a:	80 91 64 00 	lds	r24, 0x0064
    5a4e:	8f 7d       	andi	r24, 0xDF	; 223
    5a50:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    5a54:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    5a58:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    5a5a:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    5a5c:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    5a5e:	10 92 2e 06 	sts	0x062E, r1
    5a62:	10 92 2d 06 	sts	0x062D, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    5a66:	83 e0       	ldi	r24, 0x03	; 3
    5a68:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    5a6a:	80 91 64 00 	lds	r24, 0x0064
    5a6e:	87 7f       	andi	r24, 0xF7	; 247
    5a70:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    5a74:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    5a78:	8f ef       	ldi	r24, 0xFF	; 255
    5a7a:	9f ef       	ldi	r25, 0xFF	; 255
    5a7c:	90 93 89 00 	sts	0x0089, r25
    5a80:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    5a84:	90 93 8b 00 	sts	0x008B, r25
    5a88:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    5a8c:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    5a90:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    5a94:	10 92 85 00 	sts	0x0085, r1
    5a98:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    5a9c:	16 bb       	out	0x16, r17	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    5a9e:	10 92 5c 05 	sts	0x055C, r1
	keyState=0;
    5aa2:	10 92 5d 05 	sts	0x055D, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    5aa6:	10 92 5e 05 	sts	0x055E, r1
	cardDetect=false;
    5aaa:	10 92 5f 05 	sts	0x055F, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    5aae:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    5ab0:	85 e4       	ldi	r24, 0x45	; 69
    5ab2:	92 e1       	ldi	r25, 0x12	; 18
    5ab4:	90 93 e4 05 	sts	0x05E4, r25
    5ab8:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    5abc:	10 92 60 05 	sts	0x0560, r1
    5ac0:	0d e8       	ldi	r16, 0x8D	; 141
    5ac2:	20 2e       	mov	r2, r16
    5ac4:	02 e2       	ldi	r16, 0x22	; 34
    5ac6:	30 2e       	mov	r3, r16
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    5ac8:	99 24       	eor	r9, r9
    5aca:	9a 94       	dec	r9
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    5acc:	c1 2c       	mov	r12, r1
    5ace:	82 e0       	ldi	r24, 0x02	; 2
    5ad0:	d8 2e       	mov	r13, r24

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    5ad2:	9e e0       	ldi	r25, 0x0E	; 14
    5ad4:	89 2e       	mov	r8, r25
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    5ad6:	2d e0       	ldi	r18, 0x0D	; 13
    5ad8:	72 2e       	mov	r7, r18
				}
				if(theByte==0xFE)	// Got a start token!
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    5ada:	3a e0       	ldi	r19, 0x0A	; 10
    5adc:	53 2e       	mov	r5, r19

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
			cli();

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    5ade:	e1 2c       	mov	r14, r1
    5ae0:	43 e0       	ldi	r20, 0x03	; 3
    5ae2:	f4 2e       	mov	r15, r20
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    5ae4:	aa 24       	eor	r10, r10
    5ae6:	a3 94       	inc	r10
    5ae8:	b1 2c       	mov	r11, r1
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    5aea:	66 e0       	ldi	r22, 0x06	; 6
    5aec:	46 2e       	mov	r4, r22
    5aee:	2d c0       	rjmp	.+90     	; 0x5b4a <main+0x1b0>
	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    5af0:	80 91 5e 05 	lds	r24, 0x055E
    5af4:	81 11       	cpse	r24, r1
    5af6:	b3 c1       	rjmp	.+870    	; 0x5e5e <main+0x4c4>
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    5af8:	80 91 00 01 	lds	r24, 0x0100
    5afc:	90 91 01 01 	lds	r25, 0x0101
    5b00:	a0 91 02 01 	lds	r26, 0x0102
    5b04:	b0 91 03 01 	lds	r27, 0x0103
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    5b08:	ac 01       	movw	r20, r24
    5b0a:	bd 01       	movw	r22, r26
    5b0c:	44 0f       	add	r20, r20
    5b0e:	55 1f       	adc	r21, r21
    5b10:	66 1f       	adc	r22, r22
    5b12:	77 1f       	adc	r23, r23
    5b14:	b6 fd       	sbrc	r27, 6
    5b16:	47 c1       	rjmp	.+654    	; 0x5da6 <main+0x40c>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    5b18:	40 93 00 01 	sts	0x0100, r20
    5b1c:	50 93 01 01 	sts	0x0101, r21
    5b20:	60 93 02 01 	sts	0x0102, r22
    5b24:	70 93 03 01 	sts	0x0103, r23
		GetRandomLongInt();		// Keep random numbers rolling.

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    5b28:	0e 94 2c 27 	call	0x4e58	; 0x4e58 <Uart0GotByte>
    5b2c:	81 11       	cpse	r24, r1
    5b2e:	ca c0       	rjmp	.+404    	; 0x5cc4 <main+0x32a>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    5b30:	0e 94 38 29 	call	0x5270	; 0x5270 <MidiTxBufferNotEmpty>
    5b34:	88 23       	and	r24, r24
    5b36:	21 f0       	breq	.+8      	; 0x5b40 <main+0x1a6>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    5b38:	80 91 c0 00 	lds	r24, 0x00C0
    5b3c:	85 fd       	sbrc	r24, 5
    5b3e:	8a c1       	rjmp	.+788    	; 0x5e54 <main+0x4ba>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
			}
		}

		State();				// Execute the current program state.
    5b40:	e0 91 e3 05 	lds	r30, 0x05E3
    5b44:	f0 91 e4 05 	lds	r31, 0x05E4
    5b48:	09 95       	icall
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    5b4a:	81 e0       	ldi	r24, 0x01	; 1
    5b4c:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5b50:	88 23       	and	r24, r24
    5b52:	c1 f0       	breq	.+48     	; 0x5b84 <main+0x1ea>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    5b54:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    5b56:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    5b58:	95 b8       	out	0x05, r9	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    5b5a:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    5b5c:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    5b5e:	00 00       	nop
		asm volatile("nop"::);
    5b60:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    5b62:	83 b1       	in	r24, 0x03	; 3
    5b64:	80 95       	com	r24
    5b66:	80 93 5d 05 	sts	0x055D, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    5b6a:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    5b6c:	94 b8       	out	0x04, r9	; 4
		SREG=sreg;					// Stop tying up interrupts
    5b6e:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    5b70:	35 99       	sbic	0x06, 5	; 6
    5b72:	a5 c0       	rjmp	.+330    	; 0x5cbe <main+0x324>
		{
			cardDetect=true;
    5b74:	81 e0       	ldi	r24, 0x01	; 1
    5b76:	80 93 5f 05 	sts	0x055F, r24
		else
		{
			cardDetect=false;
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
    5b7a:	66 e2       	ldi	r22, 0x26	; 38
    5b7c:	70 e0       	ldi	r23, 0x00	; 0
    5b7e:	81 e0       	ldi	r24, 0x01	; 1
    5b80:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    5b84:	90 91 5d 05 	lds	r25, 0x055D
    5b88:	80 91 bc 05 	lds	r24, 0x05BC
    5b8c:	80 95       	com	r24
    5b8e:	89 23       	and	r24, r25
    5b90:	80 93 5c 05 	sts	0x055C, r24
	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been held for more than one debounce loop.
    5b94:	80 95       	com	r24
    5b96:	89 23       	and	r24, r25
    5b98:	80 93 6f 05 	sts	0x056F, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    5b9c:	90 93 bc 05 	sts	0x05BC, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;

	newEncoder=false;	// Clear variables which indicate changes in encoder readings
    5ba0:	10 92 59 05 	sts	0x0559, r1
	encoderCw=false;
    5ba4:	10 92 5a 05 	sts	0x055A, r1
	encoderCcw=false;
    5ba8:	10 92 5b 05 	sts	0x055B, r1

	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    5bac:	20 91 2d 06 	lds	r18, 0x062D
    5bb0:	30 91 2e 06 	lds	r19, 0x062E
    5bb4:	80 91 bd 05 	lds	r24, 0x05BD
    5bb8:	90 91 be 05 	lds	r25, 0x05BE
    5bbc:	28 17       	cp	r18, r24
    5bbe:	39 07       	cpc	r19, r25
    5bc0:	d1 f0       	breq	.+52     	; 0x5bf6 <main+0x25c>
	{
		lastEncTime=systemTicks;					// update last read time.
    5bc2:	80 91 2d 06 	lds	r24, 0x062D
    5bc6:	90 91 2e 06 	lds	r25, 0x062E
    5bca:	90 93 be 05 	sts	0x05BE, r25
    5bce:	80 93 bd 05 	sts	0x05BD, r24

		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    5bd2:	80 b1       	in	r24, 0x00	; 0
    5bd4:	80 7c       	andi	r24, 0xC0	; 192
    5bd6:	80 93 57 05 	sts	0x0557, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    5bda:	90 91 bf 05 	lds	r25, 0x05BF
    5bde:	89 17       	cp	r24, r25
    5be0:	51 f0       	breq	.+20     	; 0x5bf6 <main+0x25c>
		{
			if(encoderState==ENC_POS_A)
    5be2:	81 11       	cpse	r24, r1
    5be4:	53 c0       	rjmp	.+166    	; 0x5c8c <main+0x2f2>
			{
				if(lastEncoderState==ENC_POS_D)
    5be6:	90 38       	cpi	r25, 0x80	; 128
    5be8:	09 f4       	brne	.+2      	; 0x5bec <main+0x252>
    5bea:	29 c1       	rjmp	.+594    	; 0x5e3e <main+0x4a4>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_B)
    5bec:	90 34       	cpi	r25, 0x40	; 64
    5bee:	09 f4       	brne	.+2      	; 0x5bf2 <main+0x258>
    5bf0:	5b c0       	rjmp	.+182    	; 0x5ca8 <main+0x30e>
					encoderCw=true;
					newEncoder=true;
				}
			}

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    5bf2:	80 93 bf 05 	sts	0x05BF, r24

void HandleSoftclock(void)
// NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
// This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up our concept of time when we have a hang-ey loop.
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    5bf6:	a8 9b       	sbis	0x15, 0	; 21
    5bf8:	0a c0       	rjmp	.+20     	; 0x5c0e <main+0x274>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    5bfa:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    5bfc:	80 91 2d 06 	lds	r24, 0x062D
    5c00:	90 91 2e 06 	lds	r25, 0x062E
    5c04:	01 96       	adiw	r24, 0x01	; 1
    5c06:	90 93 2e 06 	sts	0x062E, r25
    5c0a:	80 93 2d 06 	sts	0x062D, r24
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    5c0e:	80 91 b1 05 	lds	r24, 0x05B1
    5c12:	81 11       	cpse	r24, r1
    5c14:	5c c0       	rjmp	.+184    	; 0x5cce <main+0x334>

		toggle=(!toggle);						// flip the sign of the led for next time.
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    5c16:	80 91 62 05 	lds	r24, 0x0562
    5c1a:	90 91 c1 05 	lds	r25, 0x05C1
    5c1e:	98 17       	cp	r25, r24
    5c20:	59 f0       	breq	.+22     	; 0x5c38 <main+0x29e>
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    5c22:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    5c24:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    5c26:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    5c28:	94 b8       	out	0x04, r9	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    5c2a:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    5c2c:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    5c2e:	9f bf       	out	0x3f, r25	; 63
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    5c30:	80 91 62 05 	lds	r24, 0x0562
    5c34:	80 93 c1 05 	sts	0x05C1, r24
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    5c38:	80 91 5f 05 	lds	r24, 0x055F
    5c3c:	88 23       	and	r24, r24
    5c3e:	09 f4       	brne	.+2      	; 0x5c42 <main+0x2a8>
    5c40:	57 cf       	rjmp	.-338    	; 0x5af0 <main+0x156>
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    5c42:	80 91 5e 05 	lds	r24, 0x055E
    5c46:	86 30       	cpi	r24, 0x06	; 6
    5c48:	09 f4       	brne	.+2      	; 0x5c4c <main+0x2b2>
    5c4a:	bb c3       	rjmp	.+1910   	; 0x63c2 <main+0xa28>
    5c4c:	08 f0       	brcs	.+2      	; 0x5c50 <main+0x2b6>
    5c4e:	b4 c0       	rjmp	.+360    	; 0x5db8 <main+0x41e>
    5c50:	82 30       	cpi	r24, 0x02	; 2
    5c52:	09 f4       	brne	.+2      	; 0x5c56 <main+0x2bc>
    5c54:	7f c3       	rjmp	.+1790   	; 0x6354 <main+0x9ba>
    5c56:	08 f0       	brcs	.+2      	; 0x5c5a <main+0x2c0>
    5c58:	1a c1       	rjmp	.+564    	; 0x5e8e <main+0x4f4>
    5c5a:	88 23       	and	r24, r24
    5c5c:	09 f4       	brne	.+2      	; 0x5c60 <main+0x2c6>
    5c5e:	61 c4       	rjmp	.+2242   	; 0x6522 <main+0xb88>
    5c60:	81 30       	cpi	r24, 0x01	; 1
    5c62:	09 f0       	breq	.+2      	; 0x5c66 <main+0x2cc>
    5c64:	49 cf       	rjmp	.-366    	; 0x5af8 <main+0x15e>
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    5c66:	83 e0       	ldi	r24, 0x03	; 3
    5c68:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5c6c:	88 23       	and	r24, r24
    5c6e:	09 f4       	brne	.+2      	; 0x5c72 <main+0x2d8>
    5c70:	43 cf       	rjmp	.-378    	; 0x5af8 <main+0x15e>
			{
				sdPlaybackQueued=false;
    5c72:	10 92 bb 05 	sts	0x05BB, r1
				sdAbortRead=false;
    5c76:	10 92 b8 05 	sts	0x05B8, r1

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
    5c7a:	0e 94 66 2b 	call	0x56cc	; 0x56cc <SdHandshake>
    5c7e:	81 30       	cpi	r24, 0x01	; 1
    5c80:	09 f4       	brne	.+2      	; 0x5c84 <main+0x2ea>
    5c82:	0b c6       	rjmp	.+3094   	; 0x689a <main+0xf00>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    5c84:	8f e0       	ldi	r24, 0x0F	; 15
    5c86:	80 93 5e 05 	sts	0x055E, r24
    5c8a:	36 cf       	rjmp	.-404    	; 0x5af8 <main+0x15e>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_B)
    5c8c:	80 34       	cpi	r24, 0x40	; 64
    5c8e:	09 f4       	brne	.+2      	; 0x5c92 <main+0x2f8>
    5c90:	f2 c0       	rjmp	.+484    	; 0x5e76 <main+0x4dc>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_C)
    5c92:	80 3c       	cpi	r24, 0xC0	; 192
    5c94:	09 f4       	brne	.+2      	; 0x5c98 <main+0x2fe>
    5c96:	f5 c0       	rjmp	.+490    	; 0x5e82 <main+0x4e8>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_D)
    5c98:	80 38       	cpi	r24, 0x80	; 128
    5c9a:	09 f0       	breq	.+2      	; 0x5c9e <main+0x304>
    5c9c:	aa cf       	rjmp	.-172    	; 0x5bf2 <main+0x258>
			{
				if(lastEncoderState==ENC_POS_C)
    5c9e:	90 3c       	cpi	r25, 0xC0	; 192
    5ca0:	09 f4       	brne	.+2      	; 0x5ca4 <main+0x30a>
    5ca2:	cd c0       	rjmp	.+410    	; 0x5e3e <main+0x4a4>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_A)
    5ca4:	91 11       	cpse	r25, r1
    5ca6:	a5 cf       	rjmp	.-182    	; 0x5bf2 <main+0x258>
				{
//					encoderValue--;
					encoderValue++;
    5ca8:	90 91 58 05 	lds	r25, 0x0558
    5cac:	9f 5f       	subi	r25, 0xFF	; 255
    5cae:	90 93 58 05 	sts	0x0558, r25
					encoderCw=true;
    5cb2:	91 e0       	ldi	r25, 0x01	; 1
    5cb4:	90 93 5a 05 	sts	0x055A, r25
					newEncoder=true;
    5cb8:	90 93 59 05 	sts	0x0559, r25
    5cbc:	9a cf       	rjmp	.-204    	; 0x5bf2 <main+0x258>
		{
			cardDetect=true;
		}
		else
		{
			cardDetect=false;
    5cbe:	10 92 5f 05 	sts	0x055F, r1
    5cc2:	5b cf       	rjmp	.-330    	; 0x5b7a <main+0x1e0>
//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    5cc4:	0e 94 32 27 	call	0x4e64	; 0x4e64 <Uart0GetByte>
    5cc8:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <HandleIncomingMidiByte>
    5ccc:	31 cf       	rjmp	.-414    	; 0x5b30 <main+0x196>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    5cce:	82 e0       	ldi	r24, 0x02	; 2
    5cd0:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5cd4:	88 23       	and	r24, r24
    5cd6:	09 f4       	brne	.+2      	; 0x5cda <main+0x340>
    5cd8:	9e cf       	rjmp	.-196    	; 0x5c16 <main+0x27c>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5cda:	20 91 b1 05 	lds	r18, 0x05B1
    5cde:	82 2f       	mov	r24, r18
    5ce0:	90 e0       	ldi	r25, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5ce2:	30 91 c0 05 	lds	r19, 0x05C0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5ce6:	20 ff       	sbrs	r18, 0
    5ce8:	07 c0       	rjmp	.+14     	; 0x5cf8 <main+0x35e>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5cea:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5cee:	31 11       	cpse	r19, r1
    5cf0:	76 c1       	rjmp	.+748    	; 0x5fde <main+0x644>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5cf2:	4e 7f       	andi	r20, 0xFE	; 254
    5cf4:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5cf8:	21 ff       	sbrs	r18, 1
    5cfa:	07 c0       	rjmp	.+14     	; 0x5d0a <main+0x370>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5cfc:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d00:	31 11       	cpse	r19, r1
    5d02:	71 c1       	rjmp	.+738    	; 0x5fe6 <main+0x64c>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d04:	4d 7f       	andi	r20, 0xFD	; 253
    5d06:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d0a:	22 ff       	sbrs	r18, 2
    5d0c:	07 c0       	rjmp	.+14     	; 0x5d1c <main+0x382>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d0e:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d12:	31 11       	cpse	r19, r1
    5d14:	6c c1       	rjmp	.+728    	; 0x5fee <main+0x654>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d16:	4b 7f       	andi	r20, 0xFB	; 251
    5d18:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d1c:	23 ff       	sbrs	r18, 3
    5d1e:	07 c0       	rjmp	.+14     	; 0x5d2e <main+0x394>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d20:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d24:	31 11       	cpse	r19, r1
    5d26:	67 c1       	rjmp	.+718    	; 0x5ff6 <main+0x65c>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d28:	47 7f       	andi	r20, 0xF7	; 247
    5d2a:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d2e:	24 ff       	sbrs	r18, 4
    5d30:	07 c0       	rjmp	.+14     	; 0x5d40 <main+0x3a6>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d32:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d36:	31 11       	cpse	r19, r1
    5d38:	42 c1       	rjmp	.+644    	; 0x5fbe <main+0x624>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d3a:	4f 7e       	andi	r20, 0xEF	; 239
    5d3c:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d40:	25 ff       	sbrs	r18, 5
    5d42:	07 c0       	rjmp	.+14     	; 0x5d52 <main+0x3b8>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d44:	40 91 62 05 	lds	r20, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d48:	31 11       	cpse	r19, r1
    5d4a:	3d c1       	rjmp	.+634    	; 0x5fc6 <main+0x62c>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d4c:	4f 7d       	andi	r20, 0xDF	; 223
    5d4e:	40 93 62 05 	sts	0x0562, r20

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d52:	26 ff       	sbrs	r18, 6
    5d54:	07 c0       	rjmp	.+14     	; 0x5d64 <main+0x3ca>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d56:	20 91 62 05 	lds	r18, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d5a:	31 11       	cpse	r19, r1
    5d5c:	38 c1       	rjmp	.+624    	; 0x5fce <main+0x634>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d5e:	2f 7b       	andi	r18, 0xBF	; 191
    5d60:	20 93 62 05 	sts	0x0562, r18

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    5d64:	88 0f       	add	r24, r24
    5d66:	89 2f       	mov	r24, r25
    5d68:	88 1f       	adc	r24, r24
    5d6a:	99 0b       	sbc	r25, r25
    5d6c:	89 2b       	or	r24, r25
    5d6e:	39 f0       	breq	.+14     	; 0x5d7e <main+0x3e4>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5d70:	80 91 62 05 	lds	r24, 0x0562
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    5d74:	31 11       	cpse	r19, r1
    5d76:	2f c1       	rjmp	.+606    	; 0x5fd6 <main+0x63c>
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    5d78:	8f 77       	andi	r24, 0x7F	; 127
    5d7a:	80 93 62 05 	sts	0x0562, r24
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    5d7e:	81 e0       	ldi	r24, 0x01	; 1
    5d80:	31 11       	cpse	r19, r1
    5d82:	80 e0       	ldi	r24, 0x00	; 0
    5d84:	80 93 c0 05 	sts	0x05C0, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    5d88:	68 e9       	ldi	r22, 0x98	; 152
    5d8a:	70 e0       	ldi	r23, 0x00	; 0
    5d8c:	82 e0       	ldi	r24, 0x02	; 2
    5d8e:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    5d92:	90 91 62 05 	lds	r25, 0x0562
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    5d96:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    5d98:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    5d9a:	95 b9       	out	0x05, r25	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    5d9c:	94 b8       	out	0x04, r9	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    5d9e:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    5da0:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    5da2:	8f bf       	out	0x3f, r24	; 63
    5da4:	49 cf       	rjmp	.-366    	; 0x5c38 <main+0x29e>
static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    5da6:	85 eb       	ldi	r24, 0xB5	; 181
    5da8:	48 27       	eor	r20, r24
    5daa:	85 e9       	ldi	r24, 0x95	; 149
    5dac:	58 27       	eor	r21, r24
    5dae:	8a ea       	ldi	r24, 0xAA	; 170
    5db0:	68 27       	eor	r22, r24
    5db2:	80 e2       	ldi	r24, 0x20	; 32
    5db4:	78 27       	eor	r23, r24
    5db6:	b0 ce       	rjmp	.-672    	; 0x5b18 <main+0x17e>
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    5db8:	8a 30       	cpi	r24, 0x0A	; 10
    5dba:	09 f4       	brne	.+2      	; 0x5dbe <main+0x424>
    5dbc:	16 c3       	rjmp	.+1580   	; 0x63ea <main+0xa50>
    5dbe:	08 f0       	brcs	.+2      	; 0x5dc2 <main+0x428>
    5dc0:	b0 c0       	rjmp	.+352    	; 0x5f22 <main+0x588>
    5dc2:	88 30       	cpi	r24, 0x08	; 8
    5dc4:	09 f4       	brne	.+2      	; 0x5dc8 <main+0x42e>
    5dc6:	a0 c2       	rjmp	.+1344   	; 0x6308 <main+0x96e>
    5dc8:	08 f4       	brcc	.+2      	; 0x5dcc <main+0x432>
    5dca:	62 c2       	rjmp	.+1220   	; 0x6290 <main+0x8f6>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    5dcc:	83 e0       	ldi	r24, 0x03	; 3
    5dce:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    5dd2:	81 11       	cpse	r24, r1
    5dd4:	df c4       	rjmp	.+2494   	; 0x6794 <main+0xdfa>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    5dd6:	8f ef       	ldi	r24, 0xFF	; 255
    5dd8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    5ddc:	8f 3f       	cpi	r24, 0xFF	; 255
    5dde:	09 f4       	brne	.+2      	; 0x5de2 <main+0x448>
    5de0:	33 c4       	rjmp	.+2150   	; 0x6648 <main+0xcae>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    5de2:	8e 3f       	cpi	r24, 0xFE	; 254
    5de4:	09 f4       	brne	.+2      	; 0x5de8 <main+0x44e>
    5de6:	42 c4       	rjmp	.+2180   	; 0x666c <main+0xcd2>
					{
						cardState=SD_READ_ABORT;
						sdAbortRead=false;
					}
				}
				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
    5de8:	8f 3f       	cpi	r24, 0xFF	; 255
    5dea:	09 f4       	brne	.+2      	; 0x5dee <main+0x454>
    5dec:	85 ce       	rjmp	.-758    	; 0x5af8 <main+0x15e>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    5dee:	1f b7       	in	r17, 0x3f	; 63
	cli();
    5df0:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    5df2:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    5df6:	e1 e7       	ldi	r30, 0x71	; 113
    5df8:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    5dfa:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    5dfc:	95 e0       	ldi	r25, 0x05	; 5
    5dfe:	e1 3b       	cpi	r30, 0xB1	; 177
    5e00:	f9 07       	cpc	r31, r25
    5e02:	d9 f7       	brne	.-10     	; 0x5dfa <main+0x460>
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
	ClearSampleToc();
	
	// Stop SD card ISR

	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    5e04:	10 92 4f 05 	sts	0x054F, r1
	TCCR2B=0;					// Stop this timer
    5e08:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    5e0c:	80 91 70 00 	lds	r24, 0x0070
    5e10:	8b 7f       	andi	r24, 0xFB	; 251
    5e12:	80 93 70 00 	sts	0x0070, r24

	// Set this contribution to the DAC to midscale (this output source is now quiet)
	sdStreamOutput=0;
    5e16:	10 92 55 05 	sts	0x0555, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    5e1a:	10 92 2b 01 	sts	0x012B, r1
    5e1e:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    5e22:	10 92 29 01 	sts	0x0129, r1
    5e26:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    5e2a:	10 92 27 01 	sts	0x0127, r1
    5e2e:	10 92 26 01 	sts	0x0126, r1

	InitSdInterface();
    5e32:	0e 94 1e 2a 	call	0x543c	; 0x543c <InitSdInterface>
	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
    5e36:	10 92 5e 05 	sts	0x055E, r1

	SREG=sreg;
    5e3a:	1f bf       	out	0x3f, r17	; 63
    5e3c:	5d ce       	rjmp	.-838    	; 0x5af8 <main+0x15e>
			else if(encoderState==ENC_POS_D)
			{
				if(lastEncoderState==ENC_POS_C)
				{
//					encoderValue++;
					encoderValue--;
    5e3e:	90 91 58 05 	lds	r25, 0x0558
    5e42:	91 50       	subi	r25, 0x01	; 1
    5e44:	90 93 58 05 	sts	0x0558, r25
					encoderCcw=true;
    5e48:	91 e0       	ldi	r25, 0x01	; 1
    5e4a:	90 93 5b 05 	sts	0x055B, r25
					newEncoder=true;
    5e4e:	90 93 59 05 	sts	0x0559, r25
    5e52:	cf ce       	rjmp	.-610    	; 0x5bf2 <main+0x258>

		if(MidiTxBufferNotEmpty())			// Got something to say?
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    5e54:	0e 94 45 29 	call	0x528a	; 0x528a <PopOutgoingMidiByte>
    5e58:	80 93 c6 00 	sts	0x00C6, r24
    5e5c:	71 ce       	rjmp	.-798    	; 0x5b40 <main+0x1a6>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    5e5e:	1f b7       	in	r17, 0x3f	; 63
	cli();
    5e60:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    5e62:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    5e66:	e1 e7       	ldi	r30, 0x71	; 113
    5e68:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    5e6a:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    5e6c:	25 e0       	ldi	r18, 0x05	; 5
    5e6e:	e1 3b       	cpi	r30, 0xB1	; 177
    5e70:	f2 07       	cpc	r31, r18
    5e72:	d9 f7       	brne	.-10     	; 0x5e6a <main+0x4d0>
    5e74:	c7 cf       	rjmp	.-114    	; 0x5e04 <main+0x46a>
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_B)
			{
				if(lastEncoderState==ENC_POS_A)
    5e76:	99 23       	and	r25, r25
    5e78:	11 f3       	breq	.-60     	; 0x5e3e <main+0x4a4>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_C)
    5e7a:	90 3c       	cpi	r25, 0xC0	; 192
    5e7c:	09 f0       	breq	.+2      	; 0x5e80 <main+0x4e6>
    5e7e:	b9 ce       	rjmp	.-654    	; 0x5bf2 <main+0x258>
    5e80:	13 cf       	rjmp	.-474    	; 0x5ca8 <main+0x30e>
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_C)
			{
				if(lastEncoderState==ENC_POS_B)
    5e82:	90 34       	cpi	r25, 0x40	; 64
    5e84:	e1 f2       	breq	.-72     	; 0x5e3e <main+0x4a4>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_D)
    5e86:	90 38       	cpi	r25, 0x80	; 128
    5e88:	09 f0       	breq	.+2      	; 0x5e8c <main+0x4f2>
    5e8a:	b3 ce       	rjmp	.-666    	; 0x5bf2 <main+0x258>
    5e8c:	0d cf       	rjmp	.-486    	; 0x5ca8 <main+0x30e>
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    5e8e:	84 30       	cpi	r24, 0x04	; 4
    5e90:	09 f4       	brne	.+2      	; 0x5e94 <main+0x4fa>
    5e92:	a7 c1       	rjmp	.+846    	; 0x61e2 <main+0x848>
    5e94:	08 f4       	brcc	.+2      	; 0x5e98 <main+0x4fe>
    5e96:	1d c1       	rjmp	.+570    	; 0x60d2 <main+0x738>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    5e98:	2f b7       	in	r18, 0x3f	; 63
			cli();
    5e9a:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    5e9c:	80 91 26 01 	lds	r24, 0x0126
    5ea0:	90 91 27 01 	lds	r25, 0x0127
    5ea4:	81 15       	cp	r24, r1
    5ea6:	92 40       	sbci	r25, 0x02	; 2
    5ea8:	a0 f4       	brcc	.+40     	; 0x5ed2 <main+0x538>
    5eaa:	80 91 26 01 	lds	r24, 0x0126
    5eae:	90 91 27 01 	lds	r25, 0x0127
    5eb2:	40 91 1e 01 	lds	r20, 0x011E
    5eb6:	50 91 1f 01 	lds	r21, 0x011F
    5eba:	60 91 20 01 	lds	r22, 0x0120
    5ebe:	70 91 21 01 	lds	r23, 0x0121
    5ec2:	a0 e0       	ldi	r26, 0x00	; 0
    5ec4:	b0 e0       	ldi	r27, 0x00	; 0
    5ec6:	84 17       	cp	r24, r20
    5ec8:	95 07       	cpc	r25, r21
    5eca:	a6 07       	cpc	r26, r22
    5ecc:	b7 07       	cpc	r27, r23
    5ece:	08 f4       	brcc	.+2      	; 0x5ed2 <main+0x538>
    5ed0:	31 c3       	rjmp	.+1634   	; 0x6534 <main+0xb9a>
			{
				SREG=sreg;																	// Done reading ISR variables.
    5ed2:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;		// On to the next
    5ed4:	20 91 b6 05 	lds	r18, 0x05B6
    5ed8:	30 91 b7 05 	lds	r19, 0x05B7
    5edc:	2f 5f       	subi	r18, 0xFF	; 255
    5ede:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee0:	30 93 b7 05 	sts	0x05B7, r19
    5ee4:	20 93 b6 05 	sts	0x05B6, r18

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    5ee8:	60 91 b2 05 	lds	r22, 0x05B2
    5eec:	70 91 b3 05 	lds	r23, 0x05B3
    5ef0:	80 91 b4 05 	lds	r24, 0x05B4
    5ef4:	90 91 b5 05 	lds	r25, 0x05B5
    5ef8:	62 0f       	add	r22, r18
    5efa:	73 1f       	adc	r23, r19
    5efc:	81 1d       	adc	r24, r1
    5efe:	91 1d       	adc	r25, r1
    5f00:	0e 94 bc 2c 	call	0x5978	; 0x5978 <SdBeginSingleBlockWrite>
    5f04:	81 30       	cpi	r24, 0x01	; 1
    5f06:	09 f4       	brne	.+2      	; 0x5f0a <main+0x570>
    5f08:	28 c4       	rjmp	.+2128   	; 0x675a <main+0xdc0>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    5f0a:	1f b7       	in	r17, 0x3f	; 63
	cli();
    5f0c:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    5f0e:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    5f12:	e1 e7       	ldi	r30, 0x71	; 113
    5f14:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    5f16:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    5f18:	55 e0       	ldi	r21, 0x05	; 5
    5f1a:	e1 3b       	cpi	r30, 0xB1	; 177
    5f1c:	f5 07       	cpc	r31, r21
    5f1e:	d9 f7       	brne	.-10     	; 0x5f16 <main+0x57c>
    5f20:	71 cf       	rjmp	.-286    	; 0x5e04 <main+0x46a>
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    5f22:	8c 30       	cpi	r24, 0x0C	; 12
    5f24:	09 f4       	brne	.+2      	; 0x5f28 <main+0x58e>
    5f26:	b8 c0       	rjmp	.+368    	; 0x6098 <main+0x6fe>
    5f28:	08 f4       	brcc	.+2      	; 0x5f2c <main+0x592>
    5f2a:	69 c0       	rjmp	.+210    	; 0x5ffe <main+0x664>
    5f2c:	8d 30       	cpi	r24, 0x0D	; 13
    5f2e:	09 f0       	breq	.+2      	; 0x5f32 <main+0x598>
    5f30:	e3 cd       	rjmp	.-1082   	; 0x5af8 <main+0x15e>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_READ_ABORT:				// We've been asked to start a new playback stream from the SD while a block is open for reading.  Finish reading the block and then start the new stream.
			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block, read a chunk.
    5f32:	80 91 c2 05 	lds	r24, 0x05C2
    5f36:	90 91 c3 05 	lds	r25, 0x05C3
    5f3a:	8c 01       	movw	r16, r24
    5f3c:	81 34       	cpi	r24, 0x41	; 65
    5f3e:	91 05       	cpc	r25, r1
    5f40:	10 f0       	brcs	.+4      	; 0x5f46 <main+0x5ac>
    5f42:	00 e4       	ldi	r16, 0x40	; 64
    5f44:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    5f46:	01 15       	cp	r16, r1
    5f48:	11 05       	cpc	r17, r1
    5f4a:	99 f0       	breq	.+38     	; 0x5f72 <main+0x5d8>
    5f4c:	61 2c       	mov	r6, r1
			{
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    5f4e:	8f ef       	ldi	r24, 0xFF	; 255
    5f50:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    5f54:	80 91 c2 05 	lds	r24, 0x05C2
    5f58:	90 91 c3 05 	lds	r25, 0x05C3
    5f5c:	01 97       	sbiw	r24, 0x01	; 1
    5f5e:	90 93 c3 05 	sts	0x05C3, r25
    5f62:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    5f66:	63 94       	inc	r6
    5f68:	26 2d       	mov	r18, r6
    5f6a:	30 e0       	ldi	r19, 0x00	; 0
    5f6c:	20 17       	cp	r18, r16
    5f6e:	31 07       	cpc	r19, r17
    5f70:	70 f3       	brcs	.-36     	; 0x5f4e <main+0x5b4>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    5f72:	89 2b       	or	r24, r25
    5f74:	09 f0       	breq	.+2      	; 0x5f78 <main+0x5de>
    5f76:	c0 cd       	rjmp	.-1152   	; 0x5af8 <main+0x15e>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5f78:	8f ef       	ldi	r24, 0xFF	; 255
    5f7a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5f7e:	8f ef       	ldi	r24, 0xFF	; 255
    5f80:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5f84:	80 91 c8 00 	lds	r24, 0x00C8
    5f88:	86 ff       	sbrs	r24, 6
    5f8a:	fc cf       	rjmp	.-8      	; 0x5f84 <main+0x5ea>
					;

				EndSdTransfer();				// Bring CS high
    5f8c:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5f90:	8f ef       	ldi	r24, 0xFF	; 255
    5f92:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5f96:	80 91 c8 00 	lds	r24, 0x00C8
    5f9a:	86 ff       	sbrs	r24, 6
    5f9c:	fc cf       	rjmp	.-8      	; 0x5f96 <main+0x5fc>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
    5f9e:	80 92 5e 05 	sts	0x055E, r8

				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    5fa2:	80 91 bb 05 	lds	r24, 0x05BB
    5fa6:	81 30       	cpi	r24, 0x01	; 1
    5fa8:	09 f0       	breq	.+2      	; 0x5fac <main+0x612>
    5faa:	a6 cd       	rjmp	.-1204   	; 0x5af8 <main+0x15e>
				{
					sdPlaybackQueued=false;
    5fac:	10 92 bb 05 	sts	0x05BB, r1
					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
    5fb0:	80 91 b9 05 	lds	r24, 0x05B9
    5fb4:	90 91 ba 05 	lds	r25, 0x05BA
    5fb8:	0e 94 a2 11 	call	0x2344	; 0x2344 <PlaySampleFromSd>
    5fbc:	9d cd       	rjmp	.-1222   	; 0x5af8 <main+0x15e>
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    5fbe:	40 61       	ori	r20, 0x10	; 16
    5fc0:	40 93 62 05 	sts	0x0562, r20
    5fc4:	bd ce       	rjmp	.-646    	; 0x5d40 <main+0x3a6>
    5fc6:	40 62       	ori	r20, 0x20	; 32
    5fc8:	40 93 62 05 	sts	0x0562, r20
    5fcc:	c2 ce       	rjmp	.-636    	; 0x5d52 <main+0x3b8>
    5fce:	20 64       	ori	r18, 0x40	; 64
    5fd0:	20 93 62 05 	sts	0x0562, r18
    5fd4:	c7 ce       	rjmp	.-626    	; 0x5d64 <main+0x3ca>
    5fd6:	80 68       	ori	r24, 0x80	; 128
    5fd8:	80 93 62 05 	sts	0x0562, r24
    5fdc:	d0 ce       	rjmp	.-608    	; 0x5d7e <main+0x3e4>
    5fde:	41 60       	ori	r20, 0x01	; 1
    5fe0:	40 93 62 05 	sts	0x0562, r20
    5fe4:	89 ce       	rjmp	.-750    	; 0x5cf8 <main+0x35e>
    5fe6:	42 60       	ori	r20, 0x02	; 2
    5fe8:	40 93 62 05 	sts	0x0562, r20
    5fec:	8e ce       	rjmp	.-740    	; 0x5d0a <main+0x370>
    5fee:	44 60       	ori	r20, 0x04	; 4
    5ff0:	40 93 62 05 	sts	0x0562, r20
    5ff4:	93 ce       	rjmp	.-730    	; 0x5d1c <main+0x382>
    5ff6:	48 60       	ori	r20, 0x08	; 8
    5ff8:	40 93 62 05 	sts	0x0562, r20
    5ffc:	98 ce       	rjmp	.-720    	; 0x5d2e <main+0x394>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    5ffe:	2f b7       	in	r18, 0x3f	; 63
			cli();
    6000:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    6002:	80 91 26 01 	lds	r24, 0x0126
    6006:	90 91 27 01 	lds	r25, 0x0127
    600a:	f7 01       	movw	r30, r14
    600c:	e8 1b       	sub	r30, r24
    600e:	f9 0b       	sbc	r31, r25
    6010:	cf 01       	movw	r24, r30
    6012:	81 15       	cp	r24, r1
    6014:	92 40       	sbci	r25, 0x02	; 2
    6016:	c0 f4       	brcc	.+48     	; 0x6048 <main+0x6ae>
    6018:	80 91 26 01 	lds	r24, 0x0126
    601c:	90 91 27 01 	lds	r25, 0x0127
    6020:	40 91 1e 01 	lds	r20, 0x011E
    6024:	50 91 1f 01 	lds	r21, 0x011F
    6028:	60 91 20 01 	lds	r22, 0x0120
    602c:	70 91 21 01 	lds	r23, 0x0121
    6030:	f7 01       	movw	r30, r14
    6032:	e8 1b       	sub	r30, r24
    6034:	f9 0b       	sbc	r31, r25
    6036:	cf 01       	movw	r24, r30
    6038:	a0 e0       	ldi	r26, 0x00	; 0
    603a:	b0 e0       	ldi	r27, 0x00	; 0
    603c:	84 17       	cp	r24, r20
    603e:	95 07       	cpc	r25, r21
    6040:	a6 07       	cpc	r26, r22
    6042:	b7 07       	cpc	r27, r23
    6044:	08 f4       	brcc	.+2      	; 0x6048 <main+0x6ae>
    6046:	76 c2       	rjmp	.+1260   	; 0x6534 <main+0xb9a>
			{
				SREG=sreg;				// ISR back on.
    6048:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;	// Point at next block
    604a:	20 91 b6 05 	lds	r18, 0x05B6
    604e:	30 91 b7 05 	lds	r19, 0x05B7
    6052:	2f 5f       	subi	r18, 0xFF	; 255
    6054:	3f 4f       	sbci	r19, 0xFF	; 255
    6056:	30 93 b7 05 	sts	0x05B7, r19
    605a:	20 93 b6 05 	sts	0x05B6, r18

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    605e:	60 91 b2 05 	lds	r22, 0x05B2
    6062:	70 91 b3 05 	lds	r23, 0x05B3
    6066:	80 91 b4 05 	lds	r24, 0x05B4
    606a:	90 91 b5 05 	lds	r25, 0x05B5
    606e:	62 0f       	add	r22, r18
    6070:	73 1f       	adc	r23, r19
    6072:	81 1d       	adc	r24, r1
    6074:	91 1d       	adc	r25, r1
    6076:	0e 94 ab 2c 	call	0x5956	; 0x5956 <SdBeginSingleBlockRead>
    607a:	81 30       	cpi	r24, 0x01	; 1
    607c:	09 f4       	brne	.+2      	; 0x6080 <main+0x6e6>
    607e:	f2 c3       	rjmp	.+2020   	; 0x6864 <main+0xeca>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    6080:	1f b7       	in	r17, 0x3f	; 63
	cli();
    6082:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    6084:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    6088:	e1 e7       	ldi	r30, 0x71	; 113
    608a:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    608c:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    608e:	25 e0       	ldi	r18, 0x05	; 5
    6090:	e1 3b       	cpi	r30, 0xB1	; 177
    6092:	f2 07       	cpc	r31, r18
    6094:	d9 f7       	brne	.-10     	; 0x608c <main+0x6f2>
    6096:	b6 ce       	rjmp	.-660    	; 0x5e04 <main+0x46a>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    6098:	83 e0       	ldi	r24, 0x03	; 3
    609a:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    609e:	81 11       	cpse	r24, r1
    60a0:	6d c3       	rjmp	.+1754   	; 0x677c <main+0xde2>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    60a2:	8f ef       	ldi	r24, 0xFF	; 255
    60a4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    60a8:	8f 3f       	cpi	r24, 0xFF	; 255
    60aa:	09 f4       	brne	.+2      	; 0x60ae <main+0x714>
    60ac:	bd c2       	rjmp	.+1402   	; 0x6628 <main+0xc8e>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    60ae:	8e 3f       	cpi	r24, 0xFE	; 254
    60b0:	09 f4       	brne	.+2      	; 0x60b4 <main+0x71a>
    60b2:	aa c2       	rjmp	.+1364   	; 0x6608 <main+0xc6e>
					{
						cardState=SD_READ_ABORT;
						sdAbortRead=false;
					}
				}
				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
    60b4:	8f 3f       	cpi	r24, 0xFF	; 255
    60b6:	09 f4       	brne	.+2      	; 0x60ba <main+0x720>
    60b8:	1f cd       	rjmp	.-1474   	; 0x5af8 <main+0x15e>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    60ba:	1f b7       	in	r17, 0x3f	; 63
	cli();
    60bc:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    60be:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    60c2:	e1 e7       	ldi	r30, 0x71	; 113
    60c4:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    60c6:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    60c8:	35 e0       	ldi	r19, 0x05	; 5
    60ca:	e1 3b       	cpi	r30, 0xB1	; 177
    60cc:	f3 07       	cpc	r31, r19
    60ce:	d9 f7       	brne	.-10     	; 0x60c6 <main+0x72c>
    60d0:	99 ce       	rjmp	.-718    	; 0x5e04 <main+0x46a>
				SREG=sreg;	// Turn ISR back on
			}
			break;

			case SD_WRITING_BLOCK:										// The SD card is open and we're currently writing a block.
			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block, send a chunk.
    60d2:	80 91 c2 05 	lds	r24, 0x05C2
    60d6:	90 91 c3 05 	lds	r25, 0x05C3
    60da:	8c 01       	movw	r16, r24
    60dc:	81 34       	cpi	r24, 0x41	; 65
    60de:	91 05       	cpc	r25, r1
    60e0:	10 f0       	brcs	.+4      	; 0x60e6 <main+0x74c>
    60e2:	00 e4       	ldi	r16, 0x40	; 64
    60e4:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    60e6:	01 15       	cp	r16, r1
    60e8:	11 05       	cpc	r17, r1
    60ea:	09 f4       	brne	.+2      	; 0x60ee <main+0x754>
    60ec:	5e c0       	rjmp	.+188    	; 0x61aa <main+0x810>
    60ee:	61 2c       	mov	r6, r1
    60f0:	4b c0       	rjmp	.+150    	; 0x6188 <main+0x7ee>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
    60f2:	e0 91 2a 01 	lds	r30, 0x012A
    60f6:	f0 91 2b 01 	lds	r31, 0x012B
    60fa:	e4 5d       	subi	r30, 0xD4	; 212
    60fc:	fe 4f       	sbci	r31, 0xFE	; 254
    60fe:	80 81       	ld	r24, Z
    6100:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    6104:	80 91 1e 01 	lds	r24, 0x011E
    6108:	90 91 1f 01 	lds	r25, 0x011F
    610c:	a0 91 20 01 	lds	r26, 0x0120
    6110:	b0 91 21 01 	lds	r27, 0x0121
    6114:	01 97       	sbiw	r24, 0x01	; 1
    6116:	a1 09       	sbc	r26, r1
    6118:	b1 09       	sbc	r27, r1
    611a:	80 93 1e 01 	sts	0x011E, r24
    611e:	90 93 1f 01 	sts	0x011F, r25
    6122:	a0 93 20 01 	sts	0x0120, r26
    6126:	b0 93 21 01 	sts	0x0121, r27

					sdFifoReadPointer++;			// Move to next spot in fifo
    612a:	80 91 2a 01 	lds	r24, 0x012A
    612e:	90 91 2b 01 	lds	r25, 0x012B
    6132:	01 96       	adiw	r24, 0x01	; 1
    6134:	90 93 2b 01 	sts	0x012B, r25
    6138:	80 93 2a 01 	sts	0x012A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    613c:	80 91 2a 01 	lds	r24, 0x012A
    6140:	90 91 2b 01 	lds	r25, 0x012B
    6144:	81 15       	cp	r24, r1
    6146:	93 40       	sbci	r25, 0x03	; 3
    6148:	20 f0       	brcs	.+8      	; 0x6152 <main+0x7b8>
					{
						sdFifoReadPointer=0;
    614a:	10 92 2b 01 	sts	0x012B, r1
    614e:	10 92 2a 01 	sts	0x012A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    6152:	2f b7       	in	r18, 0x3f	; 63
					cli();
    6154:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    6156:	80 91 26 01 	lds	r24, 0x0126
    615a:	90 91 27 01 	lds	r25, 0x0127
    615e:	01 97       	sbiw	r24, 0x01	; 1
    6160:	90 93 27 01 	sts	0x0127, r25
    6164:	80 93 26 01 	sts	0x0126, r24
					SREG=sreg;
    6168:	2f bf       	out	0x3f, r18	; 63
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    616a:	80 91 c2 05 	lds	r24, 0x05C2
    616e:	90 91 c3 05 	lds	r25, 0x05C3
    6172:	01 97       	sbiw	r24, 0x01	; 1
    6174:	90 93 c3 05 	sts	0x05C3, r25
    6178:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    617c:	63 94       	inc	r6
    617e:	26 2d       	mov	r18, r6
    6180:	30 e0       	ldi	r19, 0x00	; 0
    6182:	20 17       	cp	r18, r16
    6184:	31 07       	cpc	r19, r17
    6186:	88 f4       	brcc	.+34     	; 0x61aa <main+0x810>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    6188:	80 91 1e 01 	lds	r24, 0x011E
    618c:	90 91 1f 01 	lds	r25, 0x011F
    6190:	a0 91 20 01 	lds	r26, 0x0120
    6194:	b0 91 21 01 	lds	r27, 0x0121
    6198:	89 2b       	or	r24, r25
    619a:	8a 2b       	or	r24, r26
    619c:	8b 2b       	or	r24, r27
    619e:	09 f0       	breq	.+2      	; 0x61a2 <main+0x808>
    61a0:	a8 cf       	rjmp	.-176    	; 0x60f2 <main+0x758>
					sdBytesInFifo--;	// Stored one more byte.
					SREG=sreg;
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    61a2:	8f ef       	ldi	r24, 0xFF	; 255
    61a4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    61a8:	e0 cf       	rjmp	.-64     	; 0x616a <main+0x7d0>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    61aa:	89 2b       	or	r24, r25
    61ac:	09 f0       	breq	.+2      	; 0x61b0 <main+0x816>
    61ae:	a4 cc       	rjmp	.-1720   	; 0x5af8 <main+0x15e>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    61b0:	8f ef       	ldi	r24, 0xFF	; 255
    61b2:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    61b6:	8f ef       	ldi	r24, 0xFF	; 255
    61b8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    61bc:	8f ef       	ldi	r24, 0xFF	; 255
    61be:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    61c2:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    61c4:	85 30       	cpi	r24, 0x05	; 5
    61c6:	09 f4       	brne	.+2      	; 0x61ca <main+0x830>
    61c8:	5f c3       	rjmp	.+1726   	; 0x6888 <main+0xeee>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    61ca:	1f b7       	in	r17, 0x3f	; 63
	cli();
    61cc:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    61ce:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    61d2:	e1 e7       	ldi	r30, 0x71	; 113
    61d4:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    61d6:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    61d8:	25 e0       	ldi	r18, 0x05	; 5
    61da:	e1 3b       	cpi	r30, 0xB1	; 177
    61dc:	f2 07       	cpc	r31, r18
    61de:	d9 f7       	brne	.-10     	; 0x61d6 <main+0x83c>
    61e0:	11 ce       	rjmp	.-990    	; 0x5e04 <main+0x46a>
				}
			}
			break;

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    61e2:	83 e0       	ldi	r24, 0x03	; 3
    61e4:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    61e8:	81 11       	cpse	r24, r1
    61ea:	30 c3       	rjmp	.+1632   	; 0x684c <main+0xeb2>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    61ec:	8f ef       	ldi	r24, 0xFF	; 255
    61ee:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    61f2:	8f 3f       	cpi	r24, 0xFF	; 255
    61f4:	81 f0       	breq	.+32     	; 0x6216 <main+0x87c>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    61f6:	8f ef       	ldi	r24, 0xFF	; 255
    61f8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    61fc:	8f 3f       	cpi	r24, 0xFF	; 255
    61fe:	59 f0       	breq	.+22     	; 0x6216 <main+0x87c>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6200:	8f ef       	ldi	r24, 0xFF	; 255
    6202:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    6206:	8f 3f       	cpi	r24, 0xFF	; 255
    6208:	31 f0       	breq	.+12     	; 0x6216 <main+0x87c>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    620a:	8f ef       	ldi	r24, 0xFF	; 255
    620c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    6210:	8f 3f       	cpi	r24, 0xFF	; 255
    6212:	09 f0       	breq	.+2      	; 0x6216 <main+0x87c>
    6214:	71 cc       	rjmp	.-1822   	; 0x5af8 <main+0x15e>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    6216:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    621a:	8f ef       	ldi	r24, 0xFF	; 255
    621c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    6220:	80 91 c8 00 	lds	r24, 0x00C8
    6224:	86 ff       	sbrs	r24, 6
    6226:	fc cf       	rjmp	.-8      	; 0x6220 <main+0x886>
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    6228:	80 91 1e 01 	lds	r24, 0x011E
    622c:	90 91 1f 01 	lds	r25, 0x011F
    6230:	a0 91 20 01 	lds	r26, 0x0120
    6234:	b0 91 21 01 	lds	r27, 0x0121
    6238:	89 2b       	or	r24, r25
    623a:	8a 2b       	or	r24, r26
    623c:	8b 2b       	or	r24, r27
    623e:	09 f0       	breq	.+2      	; 0x6242 <main+0x8a8>
    6240:	56 c3       	rjmp	.+1708   	; 0x68ee <main+0xf54>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    6242:	20 91 68 05 	lds	r18, 0x0568
    6246:	30 91 69 05 	lds	r19, 0x0569
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    624a:	f9 01       	movw	r30, r18
    624c:	f6 95       	lsr	r31
    624e:	e7 95       	ror	r30
    6250:	f6 95       	lsr	r31
    6252:	e7 95       	ror	r30
    6254:	f6 95       	lsr	r31
    6256:	e7 95       	ror	r30
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    6258:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    625a:	ef 58       	subi	r30, 0x8F	; 143
    625c:	fa 4f       	sbci	r31, 0xFA	; 250
    625e:	40 81       	ld	r20, Z
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    6260:	27 70       	andi	r18, 0x07	; 7
    6262:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    6264:	84 2f       	mov	r24, r20
    6266:	90 e0       	ldi	r25, 0x00	; 0
    6268:	02 2e       	mov	r0, r18
    626a:	02 c0       	rjmp	.+4      	; 0x6270 <main+0x8d6>
    626c:	95 95       	asr	r25
    626e:	87 95       	ror	r24
    6270:	0a 94       	dec	r0
    6272:	e2 f7       	brpl	.-8      	; 0x626c <main+0x8d2>
    6274:	80 fd       	sbrc	r24, 0
    6276:	6b c0       	rjmp	.+214    	; 0x634e <main+0x9b4>
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    6278:	c5 01       	movw	r24, r10
    627a:	02 c0       	rjmp	.+4      	; 0x6280 <main+0x8e6>
    627c:	88 0f       	add	r24, r24
    627e:	99 1f       	adc	r25, r25
    6280:	2a 95       	dec	r18
    6282:	e2 f7       	brpl	.-8      	; 0x627c <main+0x8e2>
    6284:	9c 01       	movw	r18, r24
    6286:	24 2b       	or	r18, r20
    6288:	20 83       	st	Z, r18
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    628a:	40 92 5e 05 	sts	0x055E, r4
    628e:	34 cc       	rjmp	.-1944   	; 0x5af8 <main+0x15e>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_TOC_WRITE_CONTINUE:				// Keep writing don't cares to the block until we're done.
			if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block, send a chunk.
    6290:	80 91 c2 05 	lds	r24, 0x05C2
    6294:	90 91 c3 05 	lds	r25, 0x05C3
    6298:	8c 01       	movw	r16, r24
    629a:	81 34       	cpi	r24, 0x41	; 65
    629c:	91 05       	cpc	r25, r1
    629e:	10 f0       	brcs	.+4      	; 0x62a4 <main+0x90a>
    62a0:	00 e4       	ldi	r16, 0x40	; 64
    62a2:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    62a4:	01 15       	cp	r16, r1
    62a6:	11 05       	cpc	r17, r1
    62a8:	99 f0       	breq	.+38     	; 0x62d0 <main+0x936>
    62aa:	61 2c       	mov	r6, r1
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    62ac:	8f ef       	ldi	r24, 0xFF	; 255
    62ae:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    62b2:	80 91 c2 05 	lds	r24, 0x05C2
    62b6:	90 91 c3 05 	lds	r25, 0x05C3
    62ba:	01 97       	sbiw	r24, 0x01	; 1
    62bc:	90 93 c3 05 	sts	0x05C3, r25
    62c0:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    62c4:	63 94       	inc	r6
    62c6:	26 2d       	mov	r18, r6
    62c8:	30 e0       	ldi	r19, 0x00	; 0
    62ca:	20 17       	cp	r18, r16
    62cc:	31 07       	cpc	r19, r17
    62ce:	70 f3       	brcs	.-36     	; 0x62ac <main+0x912>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    62d0:	89 2b       	or	r24, r25
    62d2:	09 f0       	breq	.+2      	; 0x62d6 <main+0x93c>
    62d4:	11 cc       	rjmp	.-2014   	; 0x5af8 <main+0x15e>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    62d6:	8f ef       	ldi	r24, 0xFF	; 255
    62d8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    62dc:	8f ef       	ldi	r24, 0xFF	; 255
    62de:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    62e2:	8f ef       	ldi	r24, 0xFF	; 255
    62e4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    62e8:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    62ea:	85 30       	cpi	r24, 0x05	; 5
    62ec:	09 f4       	brne	.+2      	; 0x62f0 <main+0x956>
    62ee:	c3 c2       	rjmp	.+1414   	; 0x6876 <main+0xedc>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    62f0:	1f b7       	in	r17, 0x3f	; 63
	cli();
    62f2:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    62f4:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    62f8:	e1 e7       	ldi	r30, 0x71	; 113
    62fa:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    62fc:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    62fe:	55 e0       	ldi	r21, 0x05	; 5
    6300:	e1 3b       	cpi	r30, 0xB1	; 177
    6302:	f5 07       	cpc	r31, r21
    6304:	d9 f7       	brne	.-10     	; 0x62fc <main+0x962>
    6306:	7e cd       	rjmp	.-1284   	; 0x5e04 <main+0x46a>
				}
			}
			break;

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    6308:	83 e0       	ldi	r24, 0x03	; 3
    630a:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    630e:	81 11       	cpse	r24, r1
    6310:	91 c2       	rjmp	.+1314   	; 0x6834 <main+0xe9a>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6312:	8f ef       	ldi	r24, 0xFF	; 255
    6314:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    6318:	8f 3f       	cpi	r24, 0xFF	; 255
    631a:	81 f0       	breq	.+32     	; 0x633c <main+0x9a2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    631c:	8f ef       	ldi	r24, 0xFF	; 255
    631e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    6322:	8f 3f       	cpi	r24, 0xFF	; 255
    6324:	59 f0       	breq	.+22     	; 0x633c <main+0x9a2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6326:	8f ef       	ldi	r24, 0xFF	; 255
    6328:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    632c:	8f 3f       	cpi	r24, 0xFF	; 255
    632e:	31 f0       	breq	.+12     	; 0x633c <main+0x9a2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6330:	8f ef       	ldi	r24, 0xFF	; 255
    6332:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    6336:	8f 3f       	cpi	r24, 0xFF	; 255
    6338:	09 f0       	breq	.+2      	; 0x633c <main+0x9a2>
    633a:	de cb       	rjmp	.-2116   	; 0x5af8 <main+0x15e>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    633c:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    6340:	8f ef       	ldi	r24, 0xFF	; 255
    6342:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    6346:	80 91 c8 00 	lds	r24, 0x00C8
    634a:	86 ff       	sbrs	r24, 6
    634c:	fc cf       	rjmp	.-8      	; 0x6346 <main+0x9ac>
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
						}
						else
						{
							cardState=SD_IDLE;				// DONE!
    634e:	80 92 5e 05 	sts	0x055E, r8
    6352:	d2 cb       	rjmp	.-2140   	; 0x5af8 <main+0x15e>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    6354:	2f b7       	in	r18, 0x3f	; 63
			cli();
    6356:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    6358:	80 91 26 01 	lds	r24, 0x0126
    635c:	90 91 27 01 	lds	r25, 0x0127
    6360:	81 15       	cp	r24, r1
    6362:	92 40       	sbci	r25, 0x02	; 2
    6364:	a0 f4       	brcc	.+40     	; 0x638e <main+0x9f4>
    6366:	80 91 26 01 	lds	r24, 0x0126
    636a:	90 91 27 01 	lds	r25, 0x0127
    636e:	40 91 1e 01 	lds	r20, 0x011E
    6372:	50 91 1f 01 	lds	r21, 0x011F
    6376:	60 91 20 01 	lds	r22, 0x0120
    637a:	70 91 21 01 	lds	r23, 0x0121
    637e:	a0 e0       	ldi	r26, 0x00	; 0
    6380:	b0 e0       	ldi	r27, 0x00	; 0
    6382:	84 17       	cp	r24, r20
    6384:	95 07       	cpc	r25, r21
    6386:	a6 07       	cpc	r26, r22
    6388:	b7 07       	cpc	r27, r23
    638a:	08 f4       	brcc	.+2      	; 0x638e <main+0x9f4>
    638c:	d3 c0       	rjmp	.+422    	; 0x6534 <main+0xb9a>
			{
				SREG=sreg;	// Done reading ISR variables.
    638e:	2f bf       	out	0x3f, r18	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    6390:	60 91 b2 05 	lds	r22, 0x05B2
    6394:	70 91 b3 05 	lds	r23, 0x05B3
    6398:	80 91 b4 05 	lds	r24, 0x05B4
    639c:	90 91 b5 05 	lds	r25, 0x05B5
    63a0:	0e 94 bc 2c 	call	0x5978	; 0x5978 <SdBeginSingleBlockWrite>
    63a4:	81 30       	cpi	r24, 0x01	; 1
    63a6:	09 f4       	brne	.+2      	; 0x63aa <main+0xa10>
    63a8:	01 c2       	rjmp	.+1026   	; 0x67ac <main+0xe12>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    63aa:	1f b7       	in	r17, 0x3f	; 63
	cli();
    63ac:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    63ae:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    63b2:	e1 e7       	ldi	r30, 0x71	; 113
    63b4:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    63b6:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    63b8:	85 e0       	ldi	r24, 0x05	; 5
    63ba:	e1 3b       	cpi	r30, 0xB1	; 177
    63bc:	f8 07       	cpc	r31, r24
    63be:	d9 f7       	brne	.-10     	; 0x63b6 <main+0xa1c>
    63c0:	21 cd       	rjmp	.-1470   	; 0x5e04 <main+0x46a>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    63c2:	60 e0       	ldi	r22, 0x00	; 0
    63c4:	70 e0       	ldi	r23, 0x00	; 0
    63c6:	cb 01       	movw	r24, r22
    63c8:	0e 94 bc 2c 	call	0x5978	; 0x5978 <SdBeginSingleBlockWrite>
    63cc:	81 30       	cpi	r24, 0x01	; 1
    63ce:	09 f4       	brne	.+2      	; 0x63d2 <main+0xa38>
    63d0:	b3 c0       	rjmp	.+358    	; 0x6538 <main+0xb9e>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    63d2:	1f b7       	in	r17, 0x3f	; 63
	cli();
    63d4:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    63d6:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    63da:	e1 e7       	ldi	r30, 0x71	; 113
    63dc:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    63de:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    63e0:	35 e0       	ldi	r19, 0x05	; 5
    63e2:	e1 3b       	cpi	r30, 0xB1	; 177
    63e4:	f3 07       	cpc	r31, r19
    63e6:	d9 f7       	brne	.-10     	; 0x63de <main+0xa44>
    63e8:	0d cd       	rjmp	.-1510   	; 0x5e04 <main+0x46a>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    63ea:	80 91 b8 05 	lds	r24, 0x05B8
    63ee:	81 30       	cpi	r24, 0x01	; 1
    63f0:	09 f4       	brne	.+2      	; 0x63f4 <main+0xa5a>
    63f2:	15 c1       	rjmp	.+554    	; 0x661e <main+0xc84>
				cardState=SD_READ_ABORT;
				sdAbortRead=false;
			}
			else
			{
				if(bytesLeftInBlock>SD_BYTES_PER_PARTIAL_BLOCK_TRANSFER)	// More than a chunk left in the block, read a chunk.
    63f4:	80 91 c2 05 	lds	r24, 0x05C2
    63f8:	90 91 c3 05 	lds	r25, 0x05C3
    63fc:	8c 01       	movw	r16, r24
    63fe:	81 34       	cpi	r24, 0x41	; 65
    6400:	91 05       	cpc	r25, r1
    6402:	10 f0       	brcs	.+4      	; 0x6408 <main+0xa6e>
    6404:	00 e4       	ldi	r16, 0x40	; 64
    6406:	10 e0       	ldi	r17, 0x00	; 0
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    6408:	01 15       	cp	r16, r1
    640a:	11 05       	cpc	r17, r1
    640c:	09 f4       	brne	.+2      	; 0x6410 <main+0xa76>
    640e:	60 c0       	rjmp	.+192    	; 0x64d0 <main+0xb36>
    6410:	61 2c       	mov	r6, r1
				{
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    6412:	8f ef       	ldi	r24, 0xFF	; 255
    6414:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					bytesLeftInBlock--;						// One less byte in the block read.
    6418:	20 91 c2 05 	lds	r18, 0x05C2
    641c:	30 91 c3 05 	lds	r19, 0x05C3
    6420:	21 50       	subi	r18, 0x01	; 1
    6422:	31 09       	sbc	r19, r1
    6424:	30 93 c3 05 	sts	0x05C3, r19
    6428:	20 93 c2 05 	sts	0x05C2, r18

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    642c:	40 91 1e 01 	lds	r20, 0x011E
    6430:	50 91 1f 01 	lds	r21, 0x011F
    6434:	60 91 20 01 	lds	r22, 0x0120
    6438:	70 91 21 01 	lds	r23, 0x0121
    643c:	45 2b       	or	r20, r21
    643e:	46 2b       	or	r20, r22
    6440:	47 2b       	or	r20, r23
    6442:	d9 f1       	breq	.+118    	; 0x64ba <main+0xb20>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    6444:	40 91 1e 01 	lds	r20, 0x011E
    6448:	50 91 1f 01 	lds	r21, 0x011F
    644c:	60 91 20 01 	lds	r22, 0x0120
    6450:	70 91 21 01 	lds	r23, 0x0121
    6454:	41 50       	subi	r20, 0x01	; 1
    6456:	51 09       	sbc	r21, r1
    6458:	61 09       	sbc	r22, r1
    645a:	71 09       	sbc	r23, r1
    645c:	40 93 1e 01 	sts	0x011E, r20
    6460:	50 93 1f 01 	sts	0x011F, r21
    6464:	60 93 20 01 	sts	0x0120, r22
    6468:	70 93 21 01 	sts	0x0121, r23

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    646c:	e0 91 28 01 	lds	r30, 0x0128
    6470:	f0 91 29 01 	lds	r31, 0x0129
    6474:	e4 5d       	subi	r30, 0xD4	; 212
    6476:	fe 4f       	sbci	r31, 0xFE	; 254
    6478:	80 83       	st	Z, r24
						sdFifoWritePointer++;				// Move to next spot in fifo
    647a:	80 91 28 01 	lds	r24, 0x0128
    647e:	90 91 29 01 	lds	r25, 0x0129
    6482:	01 96       	adiw	r24, 0x01	; 1
    6484:	90 93 29 01 	sts	0x0129, r25
    6488:	80 93 28 01 	sts	0x0128, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    648c:	80 91 28 01 	lds	r24, 0x0128
    6490:	90 91 29 01 	lds	r25, 0x0129
    6494:	81 15       	cp	r24, r1
    6496:	93 40       	sbci	r25, 0x03	; 3
    6498:	20 f0       	brcs	.+8      	; 0x64a2 <main+0xb08>
						{
							sdFifoWritePointer=0;
    649a:	10 92 29 01 	sts	0x0129, r1
    649e:	10 92 28 01 	sts	0x0128, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    64a2:	2f b7       	in	r18, 0x3f	; 63
						cli();
    64a4:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    64a6:	80 91 26 01 	lds	r24, 0x0126
    64aa:	90 91 27 01 	lds	r25, 0x0127
    64ae:	01 96       	adiw	r24, 0x01	; 1
    64b0:	90 93 27 01 	sts	0x0127, r25
    64b4:	80 93 26 01 	sts	0x0126, r24
						SREG=sreg;
    64b8:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    64ba:	63 94       	inc	r6
    64bc:	86 2d       	mov	r24, r6
    64be:	90 e0       	ldi	r25, 0x00	; 0
    64c0:	80 17       	cp	r24, r16
    64c2:	91 07       	cpc	r25, r17
    64c4:	08 f4       	brcc	.+2      	; 0x64c8 <main+0xb2e>
    64c6:	a5 cf       	rjmp	.-182    	; 0x6412 <main+0xa78>
    64c8:	80 91 c2 05 	lds	r24, 0x05C2
    64cc:	90 91 c3 05 	lds	r25, 0x05C3
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    64d0:	89 2b       	or	r24, r25
    64d2:	09 f0       	breq	.+2      	; 0x64d6 <main+0xb3c>
    64d4:	11 cb       	rjmp	.-2526   	; 0x5af8 <main+0x15e>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    64d6:	8f ef       	ldi	r24, 0xFF	; 255
    64d8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    64dc:	8f ef       	ldi	r24, 0xFF	; 255
    64de:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    64e2:	80 91 c8 00 	lds	r24, 0x00C8
    64e6:	86 ff       	sbrs	r24, 6
    64e8:	fc cf       	rjmp	.-8      	; 0x64e2 <main+0xb48>
						;

					EndSdTransfer();				// Bring CS high
    64ea:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    64ee:	8f ef       	ldi	r24, 0xFF	; 255
    64f0:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    64f4:	4b e0       	ldi	r20, 0x0B	; 11
    64f6:	40 93 5e 05 	sts	0x055E, r20

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    64fa:	80 91 1e 01 	lds	r24, 0x011E
    64fe:	90 91 1f 01 	lds	r25, 0x011F
    6502:	a0 91 20 01 	lds	r26, 0x0120
    6506:	b0 91 21 01 	lds	r27, 0x0121
    650a:	89 2b       	or	r24, r25
    650c:	8a 2b       	or	r24, r26
    650e:	8b 2b       	or	r24, r27
    6510:	09 f0       	breq	.+2      	; 0x6514 <main+0xb7a>
    6512:	f2 ca       	rjmp	.-2588   	; 0x5af8 <main+0x15e>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    6514:	80 91 c8 00 	lds	r24, 0x00C8
    6518:	86 ff       	sbrs	r24, 6
    651a:	fc cf       	rjmp	.-8      	; 0x6514 <main+0xb7a>
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
						}
						else
						{
							cardState=SD_IDLE;				// DONE!
    651c:	80 92 5e 05 	sts	0x055E, r8
    6520:	eb ca       	rjmp	.-2602   	; 0x5af8 <main+0x15e>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    6522:	81 e0       	ldi	r24, 0x01	; 1
    6524:	80 93 5e 05 	sts	0x055E, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    6528:	64 ec       	ldi	r22, 0xC4	; 196
    652a:	74 e0       	ldi	r23, 0x04	; 4
    652c:	83 e0       	ldi	r24, 0x03	; 3
    652e:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
    6532:	e2 ca       	rjmp	.-2620   	; 0x5af8 <main+0x15e>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    6534:	2f bf       	out	0x3f, r18	; 63
    6536:	e0 ca       	rjmp	.-2624   	; 0x5af8 <main+0x15e>
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    6538:	d0 92 c3 05 	sts	0x05C3, r13
    653c:	c0 92 c2 05 	sts	0x05C2, r12

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    6540:	8f ef       	ldi	r24, 0xFF	; 255
    6542:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    6546:	8f ef       	ldi	r24, 0xFF	; 255
    6548:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    654c:	8e ef       	ldi	r24, 0xFE	; 254
    654e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
    6552:	87 e5       	ldi	r24, 0x57	; 87
    6554:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('T');
    6558:	84 e5       	ldi	r24, 0x54	; 84
    655a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('P');
    655e:	80 e5       	ldi	r24, 0x50	; 80
    6560:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('A');
    6564:	81 e4       	ldi	r24, 0x41	; 65
    6566:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('S');				// These four characters indicate this card holds sample data (as opposed to Nintendo DPCMs, or a boot image)
    656a:	83 e5       	ldi	r24, 0x53	; 83
    656c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('A');
    6570:	81 e4       	ldi	r24, 0x41	; 65
    6572:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('M');
    6576:	8d e4       	ldi	r24, 0x4D	; 77
    6578:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				TransferSdByte('P');
    657c:	80 e5       	ldi	r24, 0x50	; 80
    657e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>

				bytesLeftInBlock-=8;
    6582:	80 91 c2 05 	lds	r24, 0x05C2
    6586:	90 91 c3 05 	lds	r25, 0x05C3
    658a:	08 97       	sbiw	r24, 0x08	; 8
    658c:	90 93 c3 05 	sts	0x05C3, r25
    6590:	80 93 c2 05 	sts	0x05C2, r24

				for(i=0;i<8;i++)					// 8 don't care bytes
				{
					TransferSdByte('x');
    6594:	88 e7       	ldi	r24, 0x78	; 120
    6596:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    659a:	88 e7       	ldi	r24, 0x78	; 120
    659c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65a0:	88 e7       	ldi	r24, 0x78	; 120
    65a2:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65a6:	88 e7       	ldi	r24, 0x78	; 120
    65a8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65ac:	88 e7       	ldi	r24, 0x78	; 120
    65ae:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65b2:	88 e7       	ldi	r24, 0x78	; 120
    65b4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65b8:	88 e7       	ldi	r24, 0x78	; 120
    65ba:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    65be:	88 e7       	ldi	r24, 0x78	; 120
    65c0:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
				}

				bytesLeftInBlock-=8;
    65c4:	80 91 c2 05 	lds	r24, 0x05C2
    65c8:	90 91 c3 05 	lds	r25, 0x05C3
    65cc:	08 97       	sbiw	r24, 0x08	; 8
    65ce:	90 93 c3 05 	sts	0x05C3, r25
    65d2:	80 93 c2 05 	sts	0x05C2, r24
    65d6:	01 e7       	ldi	r16, 0x71	; 113
    65d8:	15 e0       	ldi	r17, 0x05	; 5

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    65da:	f8 01       	movw	r30, r16
    65dc:	81 91       	ld	r24, Z+
    65de:	8f 01       	movw	r16, r30
    65e0:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte('x');
				}

				bytesLeftInBlock-=8;

				for(i=0;i<64;i++)					// Write table of contents.
    65e4:	f5 e0       	ldi	r31, 0x05	; 5
    65e6:	01 3b       	cpi	r16, 0xB1	; 177
    65e8:	1f 07       	cpc	r17, r31
    65ea:	b9 f7       	brne	.-18     	; 0x65da <main+0xc40>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    65ec:	80 91 c2 05 	lds	r24, 0x05C2
    65f0:	90 91 c3 05 	lds	r25, 0x05C3
    65f4:	80 54       	subi	r24, 0x40	; 64
    65f6:	91 09       	sbc	r25, r1
    65f8:	90 93 c3 05 	sts	0x05C3, r25
    65fc:	80 93 c2 05 	sts	0x05C2, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    6600:	27 e0       	ldi	r18, 0x07	; 7
    6602:	20 93 5e 05 	sts	0x055E, r18
    6606:	78 ca       	rjmp	.-2832   	; 0x5af8 <main+0x15e>
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
    6608:	d0 92 c3 05 	sts	0x05C3, r13
    660c:	c0 92 c2 05 	sts	0x05C2, r12

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    6610:	50 92 5e 05 	sts	0x055E, r5
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    6614:	80 91 b8 05 	lds	r24, 0x05B8
    6618:	81 30       	cpi	r24, 0x01	; 1
    661a:	09 f0       	breq	.+2      	; 0x661e <main+0xc84>
    661c:	6d ca       	rjmp	.-2854   	; 0x5af8 <main+0x15e>
					{
						cardState=SD_READ_ABORT;
    661e:	70 92 5e 05 	sts	0x055E, r7
						sdAbortRead=false;
    6622:	10 92 b8 05 	sts	0x05B8, r1
    6626:	68 ca       	rjmp	.-2864   	; 0x5af8 <main+0x15e>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6628:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    662c:	8f 3f       	cpi	r24, 0xFF	; 255
    662e:	09 f0       	breq	.+2      	; 0x6632 <main+0xc98>
    6630:	3e cd       	rjmp	.-1412   	; 0x60ae <main+0x714>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6632:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    6636:	8f 3f       	cpi	r24, 0xFF	; 255
    6638:	09 f0       	breq	.+2      	; 0x663c <main+0xca2>
    663a:	39 cd       	rjmp	.-1422   	; 0x60ae <main+0x714>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    663c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    6640:	8f 3f       	cpi	r24, 0xFF	; 255
    6642:	09 f0       	breq	.+2      	; 0x6646 <main+0xcac>
    6644:	34 cd       	rjmp	.-1432   	; 0x60ae <main+0x714>
    6646:	58 ca       	rjmp	.-2896   	; 0x5af8 <main+0x15e>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6648:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    664c:	8f 3f       	cpi	r24, 0xFF	; 255
    664e:	09 f0       	breq	.+2      	; 0x6652 <main+0xcb8>
    6650:	c8 cb       	rjmp	.-2160   	; 0x5de2 <main+0x448>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    6652:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    6656:	8f 3f       	cpi	r24, 0xFF	; 255
    6658:	09 f0       	breq	.+2      	; 0x665c <main+0xcc2>
    665a:	c3 cb       	rjmp	.-2170   	; 0x5de2 <main+0x448>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    665c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    6660:	8f 3f       	cpi	r24, 0xFF	; 255
    6662:	09 f4       	brne	.+2      	; 0x6666 <main+0xccc>
    6664:	49 ca       	rjmp	.-2926   	; 0x5af8 <main+0x15e>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    6666:	8e 3f       	cpi	r24, 0xFE	; 254
    6668:	09 f0       	breq	.+2      	; 0x666c <main+0xcd2>
    666a:	be cb       	rjmp	.-2180   	; 0x5de8 <main+0x44e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
    666c:	d0 92 c3 05 	sts	0x05C3, r13
    6670:	c0 92 c2 05 	sts	0x05C2, r12

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    6674:	8f ef       	ldi	r24, 0xFF	; 255
    6676:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    667a:	90 e0       	ldi	r25, 0x00	; 0
    667c:	a0 e0       	ldi	r26, 0x00	; 0
    667e:	b0 e0       	ldi	r27, 0x00	; 0
    6680:	b8 2f       	mov	r27, r24
    6682:	aa 27       	eor	r26, r26
    6684:	99 27       	eor	r25, r25
    6686:	88 27       	eor	r24, r24
    6688:	80 93 1e 01 	sts	0x011E, r24
    668c:	90 93 1f 01 	sts	0x011F, r25
    6690:	a0 93 20 01 	sts	0x0120, r26
    6694:	b0 93 21 01 	sts	0x0121, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    6698:	8f ef       	ldi	r24, 0xFF	; 255
    669a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    669e:	40 91 1e 01 	lds	r20, 0x011E
    66a2:	50 91 1f 01 	lds	r21, 0x011F
    66a6:	60 91 20 01 	lds	r22, 0x0120
    66aa:	70 91 21 01 	lds	r23, 0x0121
    66ae:	68 2b       	or	r22, r24
    66b0:	40 93 1e 01 	sts	0x011E, r20
    66b4:	50 93 1f 01 	sts	0x011F, r21
    66b8:	60 93 20 01 	sts	0x0120, r22
    66bc:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    66c0:	8f ef       	ldi	r24, 0xFF	; 255
    66c2:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    66c6:	40 91 1e 01 	lds	r20, 0x011E
    66ca:	50 91 1f 01 	lds	r21, 0x011F
    66ce:	60 91 20 01 	lds	r22, 0x0120
    66d2:	70 91 21 01 	lds	r23, 0x0121
    66d6:	58 2b       	or	r21, r24
    66d8:	40 93 1e 01 	sts	0x011E, r20
    66dc:	50 93 1f 01 	sts	0x011F, r21
    66e0:	60 93 20 01 	sts	0x0120, r22
    66e4:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    66e8:	8f ef       	ldi	r24, 0xFF	; 255
    66ea:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    66ee:	40 91 1e 01 	lds	r20, 0x011E
    66f2:	50 91 1f 01 	lds	r21, 0x011F
    66f6:	60 91 20 01 	lds	r22, 0x0120
    66fa:	70 91 21 01 	lds	r23, 0x0121
    66fe:	48 2b       	or	r20, r24
    6700:	40 93 1e 01 	sts	0x011E, r20
    6704:	50 93 1f 01 	sts	0x011F, r21
    6708:	60 93 20 01 	sts	0x0120, r22
    670c:	70 93 21 01 	sts	0x0121, r23

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    6710:	80 91 1e 01 	lds	r24, 0x011E
    6714:	90 91 1f 01 	lds	r25, 0x011F
    6718:	a0 91 20 01 	lds	r26, 0x0120
    671c:	b0 91 21 01 	lds	r27, 0x0121
    6720:	80 93 22 01 	sts	0x0122, r24
    6724:	90 93 23 01 	sts	0x0123, r25
    6728:	a0 93 24 01 	sts	0x0124, r26
    672c:	b0 93 25 01 	sts	0x0125, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    6730:	80 91 c2 05 	lds	r24, 0x05C2
    6734:	90 91 c3 05 	lds	r25, 0x05C3
    6738:	04 97       	sbiw	r24, 0x04	; 4
    673a:	90 93 c3 05 	sts	0x05C3, r25
    673e:	80 93 c2 05 	sts	0x05C2, r24
					cardState=SD_READING_BLOCK;			// Got data that is specific to the first block.  Now just handle reading sample data.
    6742:	50 92 5e 05 	sts	0x055E, r5

					if(sdAbortRead==true)				// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    6746:	80 91 b8 05 	lds	r24, 0x05B8
    674a:	81 30       	cpi	r24, 0x01	; 1
    674c:	09 f0       	breq	.+2      	; 0x6750 <main+0xdb6>
    674e:	d4 c9       	rjmp	.-3160   	; 0x5af8 <main+0x15e>
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
					{
						cardState=SD_READ_ABORT;
    6750:	70 92 5e 05 	sts	0x055E, r7
						sdAbortRead=false;
    6754:	10 92 b8 05 	sts	0x05B8, r1
    6758:	cf c9       	rjmp	.-3170   	; 0x5af8 <main+0x15e>
				SREG=sreg;																	// Done reading ISR variables.
				sdCurrentBlockOffset++;		// On to the next

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    675a:	d0 92 c3 05 	sts	0x05C3, r13
    675e:	c0 92 c2 05 	sts	0x05C2, r12

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    6762:	8f ef       	ldi	r24, 0xFF	; 255
    6764:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    6768:	8f ef       	ldi	r24, 0xFF	; 255
    676a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    676e:	8e ef       	ldi	r24, 0xFE	; 254
    6770:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    6774:	83 e0       	ldi	r24, 0x03	; 3
    6776:	80 93 5e 05 	sts	0x055E, r24
    677a:	be c9       	rjmp	.-3204   	; 0x5af8 <main+0x15e>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    677c:	1f b7       	in	r17, 0x3f	; 63
	cli();
    677e:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    6780:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    6784:	e1 e7       	ldi	r30, 0x71	; 113
    6786:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    6788:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    678a:	45 e0       	ldi	r20, 0x05	; 5
    678c:	e1 3b       	cpi	r30, 0xB1	; 177
    678e:	f4 07       	cpc	r31, r20
    6790:	d9 f7       	brne	.-10     	; 0x6788 <main+0xdee>
    6792:	38 cb       	rjmp	.-2448   	; 0x5e04 <main+0x46a>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    6794:	1f b7       	in	r17, 0x3f	; 63
	cli();
    6796:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    6798:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    679c:	e1 e7       	ldi	r30, 0x71	; 113
    679e:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    67a0:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    67a2:	25 e0       	ldi	r18, 0x05	; 5
    67a4:	e1 3b       	cpi	r30, 0xB1	; 177
    67a6:	f2 07       	cpc	r31, r18
    67a8:	d9 f7       	brne	.-10     	; 0x67a0 <main+0xe06>
    67aa:	2c cb       	rjmp	.-2472   	; 0x5e04 <main+0x46a>
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
			{
				SREG=sreg;	// Done reading ISR variables.
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    67ac:	d0 92 c3 05 	sts	0x05C3, r13
    67b0:	c0 92 c2 05 	sts	0x05C2, r12

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    67b4:	8f ef       	ldi	r24, 0xFF	; 255
    67b6:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    67ba:	8f ef       	ldi	r24, 0xFF	; 255
    67bc:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    67c0:	8e ef       	ldi	r24, 0xFE	; 254
    67c2:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    67c6:	80 91 1e 01 	lds	r24, 0x011E
    67ca:	90 91 1f 01 	lds	r25, 0x011F
    67ce:	a0 91 20 01 	lds	r26, 0x0120
    67d2:	b0 91 21 01 	lds	r27, 0x0121
    67d6:	8b 2f       	mov	r24, r27
    67d8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    67dc:	60 91 1e 01 	lds	r22, 0x011E
    67e0:	70 91 1f 01 	lds	r23, 0x011F
    67e4:	80 91 20 01 	lds	r24, 0x0120
    67e8:	90 91 21 01 	lds	r25, 0x0121
    67ec:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    67f0:	80 91 1e 01 	lds	r24, 0x011E
    67f4:	90 91 1f 01 	lds	r25, 0x011F
    67f8:	a0 91 20 01 	lds	r26, 0x0120
    67fc:	b0 91 21 01 	lds	r27, 0x0121
    6800:	89 2f       	mov	r24, r25
    6802:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    6806:	80 91 1e 01 	lds	r24, 0x011E
    680a:	90 91 1f 01 	lds	r25, 0x011F
    680e:	a0 91 20 01 	lds	r26, 0x0120
    6812:	b0 91 21 01 	lds	r27, 0x0121
    6816:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    681a:	80 91 c2 05 	lds	r24, 0x05C2
    681e:	90 91 c3 05 	lds	r25, 0x05C3
    6822:	04 97       	sbiw	r24, 0x04	; 4
    6824:	90 93 c3 05 	sts	0x05C3, r25
    6828:	80 93 c2 05 	sts	0x05C2, r24

					cardState=SD_WRITING_BLOCK;				// Took care of weird first transfer, now worry about writing out sample data
    682c:	83 e0       	ldi	r24, 0x03	; 3
    682e:	80 93 5e 05 	sts	0x055E, r24
    6832:	62 c9       	rjmp	.-3388   	; 0x5af8 <main+0x15e>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    6834:	1f b7       	in	r17, 0x3f	; 63
	cli();
    6836:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    6838:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    683c:	e1 e7       	ldi	r30, 0x71	; 113
    683e:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    6840:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    6842:	85 e0       	ldi	r24, 0x05	; 5
    6844:	e1 3b       	cpi	r30, 0xB1	; 177
    6846:	f8 07       	cpc	r31, r24
    6848:	d9 f7       	brne	.-10     	; 0x6840 <main+0xea6>
    684a:	dc ca       	rjmp	.-2632   	; 0x5e04 <main+0x46a>
// If we unceremoniously pull a card, do this.
{
	unsigned char
		sreg;

	sreg=SREG;
    684c:	1f b7       	in	r17, 0x3f	; 63
	cli();
    684e:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    6850:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
    6854:	e1 e7       	ldi	r30, 0x71	; 113
    6856:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    6858:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    685a:	35 e0       	ldi	r19, 0x05	; 5
    685c:	e1 3b       	cpi	r30, 0xB1	; 177
    685e:	f3 07       	cpc	r31, r19
    6860:	d9 f7       	brne	.-10     	; 0x6858 <main+0xebe>
    6862:	d0 ca       	rjmp	.-2656   	; 0x5e04 <main+0x46a>
				SREG=sreg;				// ISR back on.
				sdCurrentBlockOffset++;	// Point at next block

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    6864:	6a e7       	ldi	r22, 0x7A	; 122
    6866:	70 e0       	ldi	r23, 0x00	; 0
    6868:	83 e0       	ldi	r24, 0x03	; 3
    686a:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    686e:	fc e0       	ldi	r31, 0x0C	; 12
    6870:	f0 93 5e 05 	sts	0x055E, r31
    6874:	41 c9       	rjmp	.-3454   	; 0x5af8 <main+0x15e>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    6876:	62 e6       	ldi	r22, 0x62	; 98
    6878:	72 e0       	ldi	r23, 0x02	; 2
    687a:	83 e0       	ldi	r24, 0x03	; 3
    687c:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    6880:	48 e0       	ldi	r20, 0x08	; 8
    6882:	40 93 5e 05 	sts	0x055E, r20
    6886:	38 c9       	rjmp	.-3472   	; 0x5af8 <main+0x15e>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    6888:	62 e6       	ldi	r22, 0x62	; 98
    688a:	72 e0       	ldi	r23, 0x02	; 2
    688c:	83 e0       	ldi	r24, 0x03	; 3
    688e:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    6892:	84 e0       	ldi	r24, 0x04	; 4
    6894:	80 93 5e 05 	sts	0x055E, r24
    6898:	2f c9       	rjmp	.-3490   	; 0x5af8 <main+0x15e>
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    689a:	60 e0       	ldi	r22, 0x00	; 0
    689c:	70 e0       	ldi	r23, 0x00	; 0
    689e:	cb 01       	movw	r24, r22
    68a0:	0e 94 ab 2c 	call	0x5956	; 0x5956 <SdBeginSingleBlockRead>
    68a4:	81 30       	cpi	r24, 0x01	; 1
    68a6:	09 f4       	brne	.+2      	; 0x68aa <main+0xf10>
    68a8:	3f c0       	rjmp	.+126    	; 0x6928 <main+0xf8e>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    68aa:	61 2c       	mov	r6, r1
		{
			TransferSdByte(0xFF);
		}
	}

	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    68ac:	80 91 c8 00 	lds	r24, 0x00C8
    68b0:	86 ff       	sbrs	r24, 6
    68b2:	fc cf       	rjmp	.-8      	; 0x68ac <main+0xf12>
		;

	EndSdTransfer();				// Bring CS high
    68b4:	0e 94 35 2a 	call	0x546a	; 0x546a <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    68b8:	8f ef       	ldi	r24, 0xFF	; 255
    68ba:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
				{
					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that might be on the card.

					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
    68be:	21 e0       	ldi	r18, 0x01	; 1
    68c0:	62 16       	cp	r6, r18
    68c2:	c9 f0       	breq	.+50     	; 0x68f6 <main+0xf5c>
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
						InitSdIsr();				// Enable the timers necessary to give the SD card its own IRQ
					}
					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler routines and get that going.
    68c4:	32 e0       	ldi	r19, 0x02	; 2
    68c6:	63 16       	cp	r6, r19
    68c8:	09 f4       	brne	.+2      	; 0x68cc <main+0xf32>
    68ca:	16 c9       	rjmp	.-3540   	; 0x5af8 <main+0x15e>
						// @@@ Load up DPCM stuff
					}

					else	// Valid card, but either invalid filesystem or BOOT card.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    68cc:	8f e0       	ldi	r24, 0x0F	; 15
    68ce:	80 93 5e 05 	sts	0x055E, r24
    68d2:	e1 e7       	ldi	r30, 0x71	; 113
    68d4:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    68d6:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    68d8:	45 e0       	ldi	r20, 0x05	; 5
    68da:	e1 3b       	cpi	r30, 0xB1	; 177
    68dc:	f4 07       	cpc	r31, r20
    68de:	d9 f7       	brne	.-10     	; 0x68d6 <main+0xf3c>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    68e0:	30 92 e4 05 	sts	0x05E4, r3
    68e4:	20 92 e3 05 	sts	0x05E3, r2
	subState=SS_0;
    68e8:	10 92 60 05 	sts	0x0560, r1
    68ec:	05 c9       	rjmp	.-3574   	; 0x5af8 <main+0x15e>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    68ee:	85 e0       	ldi	r24, 0x05	; 5
    68f0:	80 93 5e 05 	sts	0x055E, r24
    68f4:	01 c9       	rjmp	.-3582   	; 0x5af8 <main+0x15e>
				{
					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that might be on the card.

					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
    68f6:	80 92 5e 05 	sts	0x055E, r8
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    68fa:	80 91 64 00 	lds	r24, 0x0064
    68fe:	8f 7b       	andi	r24, 0xBF	; 191
    6900:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    6904:	82 e0       	ldi	r24, 0x02	; 2
    6906:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    690a:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    690e:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    6912:	81 e7       	ldi	r24, 0x71	; 113
    6914:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    6918:	97 ba       	out	0x17, r9	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    691a:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    691e:	10 92 4f 05 	sts	0x054F, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    6922:	10 92 55 05 	sts	0x0555, r1
    6926:	e8 c8       	rjmp	.-3632   	; 0x5af8 <main+0x15e>
 		// Tue Jun 21 17:11:28 EDT 2011
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    6928:	6a e7       	ldi	r22, 0x7A	; 122
    692a:	70 e0       	ldi	r23, 0x00	; 0
    692c:	83 e0       	ldi	r24, 0x03	; 3
    692e:	0e 94 53 27 	call	0x4ea6	; 0x4ea6 <SetTimer>

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    6932:	83 e0       	ldi	r24, 0x03	; 3
    6934:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    6938:	81 11       	cpse	r24, r1
    693a:	16 c0       	rjmp	.+44     	; 0x6968 <main+0xfce>
    693c:	8f ef       	ldi	r24, 0xFF	; 255
    693e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6942:	8e 3f       	cpi	r24, 0xFE	; 254
    6944:	89 f0       	breq	.+34     	; 0x6968 <main+0xfce>

void HandleSoftclock(void)
// NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
// This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up our concept of time when we have a hang-ey loop.
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    6946:	a8 9b       	sbis	0x15, 0	; 21
    6948:	f4 cf       	rjmp	.-24     	; 0x6932 <main+0xf98>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    694a:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    694c:	80 91 2d 06 	lds	r24, 0x062D
    6950:	90 91 2e 06 	lds	r25, 0x062E
    6954:	01 96       	adiw	r24, 0x01	; 1
    6956:	90 93 2e 06 	sts	0x062E, r25
    695a:	80 93 2d 06 	sts	0x062D, r24
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    695e:	83 e0       	ldi	r24, 0x03	; 3
    6960:	0e 94 65 27 	call	0x4eca	; 0x4eca <CheckTimer>
    6964:	88 23       	and	r24, r24
    6966:	51 f3       	breq	.-44     	; 0x693c <main+0xfa2>
			HandleSoftclock();	// Kludgy
		}

		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
    6968:	8f ef       	ldi	r24, 0xFF	; 255
    696a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    696e:	48 2f       	mov	r20, r24
    6970:	89 83       	std	Y+1, r24	; 0x01
    6972:	8f ef       	ldi	r24, 0xFF	; 255
    6974:	4c 87       	std	Y+12, r20	; 0x0c
    6976:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    697a:	38 2f       	mov	r19, r24
    697c:	8a 83       	std	Y+2, r24	; 0x02
    697e:	8f ef       	ldi	r24, 0xFF	; 255
    6980:	3b 87       	std	Y+11, r19	; 0x0b
    6982:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6986:	28 2f       	mov	r18, r24
    6988:	8b 83       	std	Y+3, r24	; 0x03
    698a:	8f ef       	ldi	r24, 0xFF	; 255
    698c:	2a 87       	std	Y+10, r18	; 0x0a
    698e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6992:	68 2e       	mov	r6, r24
    6994:	8c 83       	std	Y+4, r24	; 0x04
    6996:	8f ef       	ldi	r24, 0xFF	; 255
    6998:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    699c:	98 2f       	mov	r25, r24
    699e:	8d 83       	std	Y+5, r24	; 0x05
    69a0:	8f ef       	ldi	r24, 0xFF	; 255
    69a2:	99 87       	std	Y+9, r25	; 0x09
    69a4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69a8:	08 2f       	mov	r16, r24
    69aa:	8e 83       	std	Y+6, r24	; 0x06
    69ac:	8f ef       	ldi	r24, 0xFF	; 255
    69ae:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69b2:	18 2f       	mov	r17, r24
    69b4:	8f 83       	std	Y+7, r24	; 0x07
    69b6:	8f ef       	ldi	r24, 0xFF	; 255
    69b8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69bc:	88 87       	std	Y+8, r24	; 0x08
		}

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
    69be:	4c 85       	ldd	r20, Y+12	; 0x0c
    69c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    69c2:	3b 85       	ldd	r19, Y+11	; 0x0b
    69c4:	99 85       	ldd	r25, Y+9	; 0x09
    69c6:	47 35       	cpi	r20, 0x57	; 87
    69c8:	51 f1       	breq	.+84     	; 0x6a1e <main+0x1084>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    69ca:	61 2c       	mov	r6, r1
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
    69cc:	8f ef       	ldi	r24, 0xFF	; 255
    69ce:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69d2:	8f ef       	ldi	r24, 0xFF	; 255
    69d4:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69d8:	8f ef       	ldi	r24, 0xFF	; 255
    69da:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69de:	8f ef       	ldi	r24, 0xFF	; 255
    69e0:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69e4:	8f ef       	ldi	r24, 0xFF	; 255
    69e6:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69ea:	8f ef       	ldi	r24, 0xFF	; 255
    69ec:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69f0:	8f ef       	ldi	r24, 0xFF	; 255
    69f2:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69f6:	8f ef       	ldi	r24, 0xFF	; 255
    69f8:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    69fc:	00 e4       	ldi	r16, 0x40	; 64
    69fe:	10 e0       	ldi	r17, 0x00	; 0
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    6a00:	8f ef       	ldi	r24, 0xFF	; 255
    6a02:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a06:	01 50       	subi	r16, 0x01	; 1
    6a08:	11 09       	sbc	r17, r1
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    6a0a:	d1 f7       	brne	.-12     	; 0x6a00 <main+0x1066>

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
			{
				filesystemType=SD_TYPE_SAMPLES;
    6a0c:	02 eb       	ldi	r16, 0xB2	; 178
    6a0e:	11 e0       	ldi	r17, 0x01	; 1
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    6a10:	8f ef       	ldi	r24, 0xFF	; 255
    6a12:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a16:	01 50       	subi	r16, 0x01	; 1
    6a18:	11 09       	sbc	r17, r1
			{
				TransferSdByte(0xFF);
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    6a1a:	d1 f7       	brne	.-12     	; 0x6a10 <main+0x1076>
    6a1c:	47 cf       	rjmp	.-370    	; 0x68ac <main+0xf12>
		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
		}

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
    6a1e:	34 35       	cpi	r19, 0x54	; 84
    6a20:	a1 f6       	brne	.-88     	; 0x69ca <main+0x1030>
    6a22:	20 35       	cpi	r18, 0x50	; 80
    6a24:	91 f6       	brne	.-92     	; 0x69ca <main+0x1030>
    6a26:	31 e4       	ldi	r19, 0x41	; 65
    6a28:	63 12       	cpse	r6, r19
    6a2a:	cf cf       	rjmp	.-98     	; 0x69ca <main+0x1030>
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
    6a2c:	93 35       	cpi	r25, 0x53	; 83
    6a2e:	71 f0       	breq	.+28     	; 0x6a4c <main+0x10b2>
			{
				filesystemType=SD_TYPE_SAMPLES;
			}
			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]=='M'))	// Andrew's Nintendo DPCM samples?
    6a30:	94 34       	cpi	r25, 0x44	; 68
    6a32:	e1 f1       	breq	.+120    	; 0x6aac <main+0x1112>
			{
				filesystemType=SD_TYPE_DPCM;			
			}
			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]=='T'))	// Program image for bootloader?
    6a34:	92 34       	cpi	r25, 0x42	; 66
    6a36:	49 f6       	brne	.-110    	; 0x69ca <main+0x1030>
    6a38:	0f 34       	cpi	r16, 0x4F	; 79
    6a3a:	39 f6       	brne	.-114    	; 0x69ca <main+0x1030>
    6a3c:	1f 34       	cpi	r17, 0x4F	; 79
    6a3e:	29 f6       	brne	.-118    	; 0x69ca <main+0x1030>
    6a40:	84 35       	cpi	r24, 0x54	; 84
    6a42:	09 f0       	breq	.+2      	; 0x6a46 <main+0x10ac>
    6a44:	c2 cf       	rjmp	.-124    	; 0x69ca <main+0x1030>
			{
				filesystemType=SD_TYPE_BOOT;						
    6a46:	63 e0       	ldi	r22, 0x03	; 3
    6a48:	66 2e       	mov	r6, r22
    6a4a:	c0 cf       	rjmp	.-128    	; 0x69cc <main+0x1032>
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
		}

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
    6a4c:	01 34       	cpi	r16, 0x41	; 65
    6a4e:	09 f0       	breq	.+2      	; 0x6a52 <main+0x10b8>
    6a50:	bc cf       	rjmp	.-136    	; 0x69ca <main+0x1030>
    6a52:	1d 34       	cpi	r17, 0x4D	; 77
    6a54:	09 f0       	breq	.+2      	; 0x6a58 <main+0x10be>
    6a56:	b9 cf       	rjmp	.-142    	; 0x69ca <main+0x1030>
    6a58:	80 35       	cpi	r24, 0x50	; 80
    6a5a:	09 f0       	breq	.+2      	; 0x6a5e <main+0x10c4>
    6a5c:	b6 cf       	rjmp	.-148    	; 0x69ca <main+0x1030>
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
    6a5e:	8f ef       	ldi	r24, 0xFF	; 255
    6a60:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a64:	8f ef       	ldi	r24, 0xFF	; 255
    6a66:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a6a:	8f ef       	ldi	r24, 0xFF	; 255
    6a6c:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a70:	8f ef       	ldi	r24, 0xFF	; 255
    6a72:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a76:	8f ef       	ldi	r24, 0xFF	; 255
    6a78:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a7c:	8f ef       	ldi	r24, 0xFF	; 255
    6a7e:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a82:	8f ef       	ldi	r24, 0xFF	; 255
    6a84:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a88:	8f ef       	ldi	r24, 0xFF	; 255
    6a8a:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a8e:	01 e7       	ldi	r16, 0x71	; 113
    6a90:	15 e0       	ldi	r17, 0x05	; 5

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    6a92:	8f ef       	ldi	r24, 0xFF	; 255
    6a94:	0e 94 3a 2a 	call	0x5474	; 0x5474 <TransferSdByte>
    6a98:	f8 01       	movw	r30, r16
    6a9a:	81 93       	st	Z+, r24
    6a9c:	8f 01       	movw	r16, r30
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    6a9e:	f5 e0       	ldi	r31, 0x05	; 5
    6aa0:	01 3b       	cpi	r16, 0xB1	; 177
    6aa2:	1f 07       	cpc	r17, r31
    6aa4:	b1 f7       	brne	.-20     	; 0x6a92 <main+0x10f8>

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
			{
				filesystemType=SD_TYPE_SAMPLES;
    6aa6:	66 24       	eor	r6, r6
    6aa8:	63 94       	inc	r6
    6aaa:	b0 cf       	rjmp	.-160    	; 0x6a0c <main+0x1072>
			}
			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]=='M'))	// Andrew's Nintendo DPCM samples?
    6aac:	00 35       	cpi	r16, 0x50	; 80
    6aae:	09 f0       	breq	.+2      	; 0x6ab2 <main+0x1118>
    6ab0:	8c cf       	rjmp	.-232    	; 0x69ca <main+0x1030>
    6ab2:	13 34       	cpi	r17, 0x43	; 67
    6ab4:	09 f0       	breq	.+2      	; 0x6ab8 <main+0x111e>
    6ab6:	89 cf       	rjmp	.-238    	; 0x69ca <main+0x1030>
    6ab8:	8d 34       	cpi	r24, 0x4D	; 77
    6aba:	09 f0       	breq	.+2      	; 0x6abe <main+0x1124>
    6abc:	86 cf       	rjmp	.-244    	; 0x69ca <main+0x1030>
			{
				filesystemType=SD_TYPE_DPCM;			
    6abe:	b2 e0       	ldi	r27, 0x02	; 2
    6ac0:	6b 2e       	mov	r6, r27
    6ac2:	84 cf       	rjmp	.-248    	; 0x69cc <main+0x1032>

00006ac4 <__udivmodqi4>:
    6ac4:	99 1b       	sub	r25, r25
    6ac6:	79 e0       	ldi	r23, 0x09	; 9
    6ac8:	04 c0       	rjmp	.+8      	; 0x6ad2 <__udivmodqi4_ep>

00006aca <__udivmodqi4_loop>:
    6aca:	99 1f       	adc	r25, r25
    6acc:	96 17       	cp	r25, r22
    6ace:	08 f0       	brcs	.+2      	; 0x6ad2 <__udivmodqi4_ep>
    6ad0:	96 1b       	sub	r25, r22

00006ad2 <__udivmodqi4_ep>:
    6ad2:	88 1f       	adc	r24, r24
    6ad4:	7a 95       	dec	r23
    6ad6:	c9 f7       	brne	.-14     	; 0x6aca <__udivmodqi4_loop>
    6ad8:	80 95       	com	r24
    6ada:	08 95       	ret

00006adc <__udivmodsi4>:
    6adc:	a1 e2       	ldi	r26, 0x21	; 33
    6ade:	1a 2e       	mov	r1, r26
    6ae0:	aa 1b       	sub	r26, r26
    6ae2:	bb 1b       	sub	r27, r27
    6ae4:	fd 01       	movw	r30, r26
    6ae6:	0d c0       	rjmp	.+26     	; 0x6b02 <__udivmodsi4_ep>

00006ae8 <__udivmodsi4_loop>:
    6ae8:	aa 1f       	adc	r26, r26
    6aea:	bb 1f       	adc	r27, r27
    6aec:	ee 1f       	adc	r30, r30
    6aee:	ff 1f       	adc	r31, r31
    6af0:	a2 17       	cp	r26, r18
    6af2:	b3 07       	cpc	r27, r19
    6af4:	e4 07       	cpc	r30, r20
    6af6:	f5 07       	cpc	r31, r21
    6af8:	20 f0       	brcs	.+8      	; 0x6b02 <__udivmodsi4_ep>
    6afa:	a2 1b       	sub	r26, r18
    6afc:	b3 0b       	sbc	r27, r19
    6afe:	e4 0b       	sbc	r30, r20
    6b00:	f5 0b       	sbc	r31, r21

00006b02 <__udivmodsi4_ep>:
    6b02:	66 1f       	adc	r22, r22
    6b04:	77 1f       	adc	r23, r23
    6b06:	88 1f       	adc	r24, r24
    6b08:	99 1f       	adc	r25, r25
    6b0a:	1a 94       	dec	r1
    6b0c:	69 f7       	brne	.-38     	; 0x6ae8 <__udivmodsi4_loop>
    6b0e:	60 95       	com	r22
    6b10:	70 95       	com	r23
    6b12:	80 95       	com	r24
    6b14:	90 95       	com	r25
    6b16:	9b 01       	movw	r18, r22
    6b18:	ac 01       	movw	r20, r24
    6b1a:	bd 01       	movw	r22, r26
    6b1c:	cf 01       	movw	r24, r30
    6b1e:	08 95       	ret

00006b20 <__tablejump2__>:
    6b20:	ee 0f       	add	r30, r30
    6b22:	ff 1f       	adc	r31, r31

00006b24 <__tablejump__>:
    6b24:	05 90       	lpm	r0, Z+
    6b26:	f4 91       	lpm	r31, Z
    6b28:	e0 2d       	mov	r30, r0
    6b2a:	09 94       	ijmp

00006b2c <__umulhisi3>:
    6b2c:	a2 9f       	mul	r26, r18
    6b2e:	b0 01       	movw	r22, r0
    6b30:	b3 9f       	mul	r27, r19
    6b32:	c0 01       	movw	r24, r0
    6b34:	a3 9f       	mul	r26, r19
    6b36:	01 d0       	rcall	.+2      	; 0x6b3a <__umulhisi3+0xe>
    6b38:	b2 9f       	mul	r27, r18
    6b3a:	70 0d       	add	r23, r0
    6b3c:	81 1d       	adc	r24, r1
    6b3e:	11 24       	eor	r1, r1
    6b40:	91 1d       	adc	r25, r1
    6b42:	08 95       	ret

00006b44 <__muluhisi3>:
    6b44:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <__umulhisi3>
    6b48:	a5 9f       	mul	r26, r21
    6b4a:	90 0d       	add	r25, r0
    6b4c:	b4 9f       	mul	r27, r20
    6b4e:	90 0d       	add	r25, r0
    6b50:	a4 9f       	mul	r26, r20
    6b52:	80 0d       	add	r24, r0
    6b54:	91 1d       	adc	r25, r1
    6b56:	11 24       	eor	r1, r1
    6b58:	08 95       	ret

00006b5a <_exit>:
    6b5a:	f8 94       	cli

00006b5c <__stop_program>:
    6b5c:	ff cf       	rjmp	.-2      	; 0x6b5c <__stop_program>
