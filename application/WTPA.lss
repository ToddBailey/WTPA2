
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00005150  000051e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005150  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000544  0080011e  0080011e  00005202  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005204  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  000058d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00005967  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  00005996  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004191  00000000  00000000  00005a76  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a5c  00000000  00000000  00009c07  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f79  00000000  00000000  0000a663  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000870  00000000  00000000  0000b5dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000139a  00000000  00000000  0000be4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000245a  00000000  00000000  0000d1e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c8  00000000  00000000  0000f640  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 4e 1a 	jmp	0x349c	; 0x349c <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 a1 1d 	jmp	0x3b42	; 0x3b42 <__vector_9>
      28:	0c 94 c0 1b 	jmp	0x3780	; 0x3780 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 07 1a 	jmp	0x340e	; 0x340e <__vector_12>
      34:	0c 94 96 1a 	jmp	0x352c	; 0x352c <__vector_13>
      38:	0c 94 2b 1b 	jmp	0x3656	; 0x3656 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	35 17       	cp	r19, r21
      7e:	2a 19       	sub	r18, r10
      80:	2a 19       	sub	r18, r10
      82:	2a 19       	sub	r18, r10
      84:	2a 19       	sub	r18, r10
      86:	2a 19       	sub	r18, r10
      88:	54 17       	cp	r21, r20
      8a:	2a 19       	sub	r18, r10
      8c:	2a 19       	sub	r18, r10
      8e:	2a 19       	sub	r18, r10
      90:	2a 19       	sub	r18, r10
      92:	91 17       	cp	r25, r17
      94:	bd 17       	cp	r27, r29
      96:	d4 17       	cp	r29, r20
      98:	eb 17       	cp	r30, r27
      9a:	04 18       	sub	r0, r4
      9c:	1b 18       	sub	r1, r11
      9e:	2a 18       	sub	r2, r10
      a0:	31 18       	sub	r3, r1
      a2:	3d 18       	sub	r3, r13
      a4:	58 18       	sub	r5, r8
      a6:	88 18       	sub	r8, r8
      a8:	91 18       	sub	r9, r1
      aa:	9a 18       	sub	r9, r10
      ac:	a3 18       	sub	r10, r3
      ae:	a8 18       	sub	r10, r8
      b0:	b5 18       	sub	r11, r5
      b2:	c2 18       	sub	r12, r2

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e0 e5       	ldi	r30, 0x50	; 80
      c8:	f1 e5       	ldi	r31, 0x51	; 81
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	26 e0       	ldi	r18, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a2 36       	cpi	r26, 0x62	; 98
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 11 22 	call	0x4422	; 0x4422 <main>
      ea:	0c 94 a6 28 	jmp	0x514c	; 0x514c <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 bc 1d 	jmp	0x3b78	; 0x3b78 <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 e6 05 	lds	r24, 0x05E6
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c1 f0       	breq	.+48     	; 0x12a <UpdateAudioChannel0+0x38>
      fa:	30 f4       	brcc	.+12     	; 0x108 <UpdateAudioChannel0+0x16>
      fc:	81 30       	cpi	r24, 0x01	; 1
      fe:	59 f0       	breq	.+22     	; 0x116 <UpdateAudioChannel0+0x24>
     100:	82 30       	cpi	r24, 0x02	; 2
     102:	09 f0       	breq	.+2      	; 0x106 <UpdateAudioChannel0+0x14>
     104:	a2 c3       	rjmp	.+1860   	; 0x84a <UpdateAudioChannel0+0x758>
     106:	0e c0       	rjmp	.+28     	; 0x124 <UpdateAudioChannel0+0x32>
     108:	84 30       	cpi	r24, 0x04	; 4
     10a:	09 f4       	brne	.+2      	; 0x10e <UpdateAudioChannel0+0x1c>
     10c:	8e c0       	rjmp	.+284    	; 0x22a <UpdateAudioChannel0+0x138>
     10e:	85 30       	cpi	r24, 0x05	; 5
     110:	09 f0       	breq	.+2      	; 0x114 <UpdateAudioChannel0+0x22>
     112:	9b c3       	rjmp	.+1846   	; 0x84a <UpdateAudioChannel0+0x758>
     114:	07 c2       	rjmp	.+1038   	; 0x524 <UpdateAudioChannel0+0x432>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     116:	80 91 43 04 	lds	r24, 0x0443
     11a:	98 2f       	mov	r25, r24
     11c:	9f 5f       	subi	r25, 0xFF	; 255
     11e:	90 93 43 04 	sts	0x0443, r25
		break;
     122:	08 95       	ret

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     124:	80 91 2c 04 	lds	r24, 0x042C
     128:	eb c1       	rjmp	.+982    	; 0x500 <UpdateAudioChannel0+0x40e>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12a:	8f ef       	ldi	r24, 0xFF	; 255
     12c:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     12e:	80 91 05 06 	lds	r24, 0x0605
     132:	90 91 06 06 	lds	r25, 0x0606
     136:	a0 91 07 06 	lds	r26, 0x0607
     13a:	b0 91 08 06 	lds	r27, 0x0608
     13e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     140:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     142:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     144:	80 91 05 06 	lds	r24, 0x0605
     148:	90 91 06 06 	lds	r25, 0x0606
     14c:	a0 91 07 06 	lds	r26, 0x0607
     150:	b0 91 08 06 	lds	r27, 0x0608
     154:	89 2f       	mov	r24, r25
     156:	9a 2f       	mov	r25, r26
     158:	ab 2f       	mov	r26, r27
     15a:	bb 27       	eor	r27, r27
     15c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     15e:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     160:	14 98       	cbi	0x02, 4	; 2
		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     162:	80 91 05 06 	lds	r24, 0x0605
     166:	90 91 06 06 	lds	r25, 0x0606
     16a:	a0 91 07 06 	lds	r26, 0x0607
     16e:	b0 91 08 06 	lds	r27, 0x0608
     172:	cd 01       	movw	r24, r26
     174:	aa 27       	eor	r26, r26
     176:	bb 27       	eor	r27, r27
     178:	87 70       	andi	r24, 0x07	; 7
     17a:	99 27       	eor	r25, r25
     17c:	aa 27       	eor	r26, r26
     17e:	bb 27       	eor	r27, r27
     180:	88 68       	ori	r24, 0x88	; 136
     182:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     184:	80 91 2c 04 	lds	r24, 0x042C
     188:	85 b9       	out	0x05, r24	; 5
		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     18a:	80 91 05 06 	lds	r24, 0x0605
     18e:	90 91 06 06 	lds	r25, 0x0606
     192:	a0 91 07 06 	lds	r26, 0x0607
     196:	b0 91 08 06 	lds	r27, 0x0608
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	a1 1d       	adc	r26, r1
     19e:	b1 1d       	adc	r27, r1
     1a0:	80 93 05 06 	sts	0x0605, r24
     1a4:	90 93 06 06 	sts	0x0606, r25
     1a8:	a0 93 07 06 	sts	0x0607, r26
     1ac:	b0 93 08 06 	sts	0x0608, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1b0:	80 91 05 06 	lds	r24, 0x0605
     1b4:	90 91 06 06 	lds	r25, 0x0606
     1b8:	a0 91 07 06 	lds	r26, 0x0607
     1bc:	b0 91 08 06 	lds	r27, 0x0608
     1c0:	80 93 f2 05 	sts	0x05F2, r24
     1c4:	90 93 f3 05 	sts	0x05F3, r25
     1c8:	a0 93 f4 05 	sts	0x05F4, r26
     1cc:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1d0:	80 91 05 06 	lds	r24, 0x0605
     1d4:	90 91 06 06 	lds	r25, 0x0606
     1d8:	a0 91 07 06 	lds	r26, 0x0607
     1dc:	b0 91 08 06 	lds	r27, 0x0608
     1e0:	80 93 fa 05 	sts	0x05FA, r24
     1e4:	90 93 fb 05 	sts	0x05FB, r25
     1e8:	a0 93 fc 05 	sts	0x05FC, r26
     1ec:	b0 93 fd 05 	sts	0x05FD, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1f0:	40 91 f2 05 	lds	r20, 0x05F2
     1f4:	50 91 f3 05 	lds	r21, 0x05F3
     1f8:	60 91 f4 05 	lds	r22, 0x05F4
     1fc:	70 91 f5 05 	lds	r23, 0x05F5
     200:	80 91 15 06 	lds	r24, 0x0615
     204:	90 91 16 06 	lds	r25, 0x0616
     208:	a0 91 17 06 	lds	r26, 0x0617
     20c:	b0 91 18 06 	lds	r27, 0x0618
     210:	48 17       	cp	r20, r24
     212:	59 07       	cpc	r21, r25
     214:	6a 07       	cpc	r22, r26
     216:	7b 07       	cpc	r23, r27
     218:	28 f0       	brcs	.+10     	; 0x224 <UpdateAudioChannel0+0x132>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     21a:	10 92 e6 05 	sts	0x05E6, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	80 93 3f 04 	sts	0x043F, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     224:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     226:	11 9a       	sbi	0x02, 1	; 2
     228:	10 c3       	rjmp	.+1568   	; 0x84a <UpdateAudioChannel0+0x758>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     22a:	80 91 05 06 	lds	r24, 0x0605
     22e:	90 91 06 06 	lds	r25, 0x0606
     232:	a0 91 07 06 	lds	r26, 0x0607
     236:	b0 91 08 06 	lds	r27, 0x0608
     23a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     240:	80 91 05 06 	lds	r24, 0x0605
     244:	90 91 06 06 	lds	r25, 0x0606
     248:	a0 91 07 06 	lds	r26, 0x0607
     24c:	b0 91 08 06 	lds	r27, 0x0608
     250:	89 2f       	mov	r24, r25
     252:	9a 2f       	mov	r25, r26
     254:	ab 2f       	mov	r26, r27
     256:	bb 27       	eor	r27, r27
     258:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     25a:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25c:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25e:	80 91 05 06 	lds	r24, 0x0605
     262:	90 91 06 06 	lds	r25, 0x0606
     266:	a0 91 07 06 	lds	r26, 0x0607
     26a:	b0 91 08 06 	lds	r27, 0x0608
     26e:	cd 01       	movw	r24, r26
     270:	aa 27       	eor	r26, r26
     272:	bb 27       	eor	r27, r27
     274:	87 70       	andi	r24, 0x07	; 7
     276:	99 27       	eor	r25, r25
     278:	aa 27       	eor	r26, r26
     27a:	bb 27       	eor	r27, r27
     27c:	88 68       	ori	r24, 0x88	; 136
     27e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     280:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     282:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     284:	80 91 ec 05 	lds	r24, 0x05EC
     288:	88 23       	and	r24, r24
     28a:	09 f4       	brne	.+2      	; 0x28e <UpdateAudioChannel0+0x19c>
     28c:	6a c0       	rjmp	.+212    	; 0x362 <UpdateAudioChannel0+0x270>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     28e:	80 91 2d 04 	lds	r24, 0x042D
     292:	90 91 2e 04 	lds	r25, 0x042E
     296:	a0 91 2f 04 	lds	r26, 0x042F
     29a:	b0 91 30 04 	lds	r27, 0x0430
     29e:	89 2b       	or	r24, r25
     2a0:	8a 2b       	or	r24, r26
     2a2:	8b 2b       	or	r24, r27
     2a4:	39 f1       	breq	.+78     	; 0x2f4 <UpdateAudioChannel0+0x202>
			{
				bankStates[BANK_0].currentAddress++;
     2a6:	80 91 05 06 	lds	r24, 0x0605
     2aa:	90 91 06 06 	lds	r25, 0x0606
     2ae:	a0 91 07 06 	lds	r26, 0x0607
     2b2:	b0 91 08 06 	lds	r27, 0x0608
     2b6:	01 96       	adiw	r24, 0x01	; 1
     2b8:	a1 1d       	adc	r26, r1
     2ba:	b1 1d       	adc	r27, r1
     2bc:	80 93 05 06 	sts	0x0605, r24
     2c0:	90 93 06 06 	sts	0x0606, r25
     2c4:	a0 93 07 06 	sts	0x0607, r26
     2c8:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     2cc:	80 91 2d 04 	lds	r24, 0x042D
     2d0:	90 91 2e 04 	lds	r25, 0x042E
     2d4:	a0 91 2f 04 	lds	r26, 0x042F
     2d8:	b0 91 30 04 	lds	r27, 0x0430
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	a1 09       	sbc	r26, r1
     2e0:	b1 09       	sbc	r27, r1
     2e2:	80 93 2d 04 	sts	0x042D, r24
     2e6:	90 93 2e 04 	sts	0x042E, r25
     2ea:	a0 93 2f 04 	sts	0x042F, r26
     2ee:	b0 93 30 04 	sts	0x0430, r27
     2f2:	02 c1       	rjmp	.+516    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2f4:	80 91 35 04 	lds	r24, 0x0435
     2f8:	90 91 36 04 	lds	r25, 0x0436
     2fc:	a0 91 37 04 	lds	r26, 0x0437
     300:	b0 91 38 04 	lds	r27, 0x0438
     304:	80 93 2d 04 	sts	0x042D, r24
     308:	90 93 2e 04 	sts	0x042E, r25
     30c:	a0 93 2f 04 	sts	0x042F, r26
     310:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     314:	80 91 3d 04 	lds	r24, 0x043D
     318:	8f 5f       	subi	r24, 0xFF	; 255
     31a:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     31e:	90 91 3d 04 	lds	r25, 0x043D
     322:	80 91 ec 05 	lds	r24, 0x05EC
     326:	98 13       	cpse	r25, r24
     328:	02 c0       	rjmp	.+4      	; 0x32e <UpdateAudioChannel0+0x23c>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     32a:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     32e:	e0 91 3d 04 	lds	r30, 0x043D
     332:	20 91 35 04 	lds	r18, 0x0435
     336:	30 91 36 04 	lds	r19, 0x0436
     33a:	40 91 37 04 	lds	r20, 0x0437
     33e:	50 91 38 04 	lds	r21, 0x0438
     342:	f0 e0       	ldi	r31, 0x00	; 0
     344:	ec 5b       	subi	r30, 0xBC	; 188
     346:	fb 4f       	sbci	r31, 0xFB	; 251
     348:	a0 81       	ld	r26, Z
     34a:	b0 e0       	ldi	r27, 0x00	; 0
     34c:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
     350:	60 93 05 06 	sts	0x0605, r22
     354:	70 93 06 06 	sts	0x0606, r23
     358:	80 93 07 06 	sts	0x0607, r24
     35c:	90 93 08 06 	sts	0x0608, r25
     360:	cb c0       	rjmp	.+406    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     362:	80 91 ea 05 	lds	r24, 0x05EA
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     366:	40 91 05 06 	lds	r20, 0x0605
     36a:	50 91 06 06 	lds	r21, 0x0606
     36e:	60 91 07 06 	lds	r22, 0x0607
     372:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     376:	81 11       	cpse	r24, r1
     378:	5a c0       	rjmp	.+180    	; 0x42e <UpdateAudioChannel0+0x33c>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     37a:	80 91 fe 05 	lds	r24, 0x05FE
     37e:	90 91 ff 05 	lds	r25, 0x05FF
     382:	a0 91 00 06 	lds	r26, 0x0600
     386:	b0 91 01 06 	lds	r27, 0x0601
     38a:	48 17       	cp	r20, r24
     38c:	59 07       	cpc	r21, r25
     38e:	6a 07       	cpc	r22, r26
     390:	7b 07       	cpc	r23, r27
     392:	29 f4       	brne	.+10     	; 0x39e <UpdateAudioChannel0+0x2ac>
     394:	80 91 e7 05 	lds	r24, 0x05E7
     398:	81 30       	cpi	r24, 0x01	; 1
     39a:	09 f4       	brne	.+2      	; 0x39e <UpdateAudioChannel0+0x2ac>
     39c:	59 c0       	rjmp	.+178    	; 0x450 <UpdateAudioChannel0+0x35e>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39e:	40 91 05 06 	lds	r20, 0x0605
     3a2:	50 91 06 06 	lds	r21, 0x0606
     3a6:	60 91 07 06 	lds	r22, 0x0607
     3aa:	70 91 08 06 	lds	r23, 0x0608
     3ae:	80 91 fe 05 	lds	r24, 0x05FE
     3b2:	90 91 ff 05 	lds	r25, 0x05FF
     3b6:	a0 91 00 06 	lds	r26, 0x0600
     3ba:	b0 91 01 06 	lds	r27, 0x0601
     3be:	48 17       	cp	r20, r24
     3c0:	59 07       	cpc	r21, r25
     3c2:	6a 07       	cpc	r22, r26
     3c4:	7b 07       	cpc	r23, r27
     3c6:	49 f4       	brne	.+18     	; 0x3da <UpdateAudioChannel0+0x2e8>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c8:	80 91 fa 05 	lds	r24, 0x05FA
     3cc:	90 91 fb 05 	lds	r25, 0x05FB
     3d0:	a0 91 fc 05 	lds	r26, 0x05FC
     3d4:	b0 91 fd 05 	lds	r27, 0x05FD
     3d8:	87 c0       	rjmp	.+270    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3da:	40 91 05 06 	lds	r20, 0x0605
     3de:	50 91 06 06 	lds	r21, 0x0606
     3e2:	60 91 07 06 	lds	r22, 0x0607
     3e6:	70 91 08 06 	lds	r23, 0x0608
     3ea:	80 91 f6 05 	lds	r24, 0x05F6
     3ee:	90 91 f7 05 	lds	r25, 0x05F7
     3f2:	a0 91 f8 05 	lds	r26, 0x05F8
     3f6:	b0 91 f9 05 	lds	r27, 0x05F9
     3fa:	48 17       	cp	r20, r24
     3fc:	59 07       	cpc	r21, r25
     3fe:	6a 07       	cpc	r22, r26
     400:	7b 07       	cpc	r23, r27
     402:	49 f4       	brne	.+18     	; 0x416 <UpdateAudioChannel0+0x324>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     404:	80 91 f2 05 	lds	r24, 0x05F2
     408:	90 91 f3 05 	lds	r25, 0x05F3
     40c:	a0 91 f4 05 	lds	r26, 0x05F4
     410:	b0 91 f5 05 	lds	r27, 0x05F5
     414:	69 c0       	rjmp	.+210    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     416:	80 91 05 06 	lds	r24, 0x0605
     41a:	90 91 06 06 	lds	r25, 0x0606
     41e:	a0 91 07 06 	lds	r26, 0x0607
     422:	b0 91 08 06 	lds	r27, 0x0608
     426:	01 97       	sbiw	r24, 0x01	; 1
     428:	a1 09       	sbc	r26, r1
     42a:	b1 09       	sbc	r27, r1
     42c:	5d c0       	rjmp	.+186    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42e:	80 91 fa 05 	lds	r24, 0x05FA
     432:	90 91 fb 05 	lds	r25, 0x05FB
     436:	a0 91 fc 05 	lds	r26, 0x05FC
     43a:	b0 91 fd 05 	lds	r27, 0x05FD
     43e:	48 17       	cp	r20, r24
     440:	59 07       	cpc	r21, r25
     442:	6a 07       	cpc	r22, r26
     444:	7b 07       	cpc	r23, r27
     446:	49 f4       	brne	.+18     	; 0x45a <UpdateAudioChannel0+0x368>
     448:	80 91 e7 05 	lds	r24, 0x05E7
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	29 f4       	brne	.+10     	; 0x45a <UpdateAudioChannel0+0x368>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     450:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     454:	10 92 ef 05 	sts	0x05EF, r1
     458:	4f c0       	rjmp	.+158    	; 0x4f8 <UpdateAudioChannel0+0x406>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     45a:	40 91 05 06 	lds	r20, 0x0605
     45e:	50 91 06 06 	lds	r21, 0x0606
     462:	60 91 07 06 	lds	r22, 0x0607
     466:	70 91 08 06 	lds	r23, 0x0608
     46a:	80 91 fa 05 	lds	r24, 0x05FA
     46e:	90 91 fb 05 	lds	r25, 0x05FB
     472:	a0 91 fc 05 	lds	r26, 0x05FC
     476:	b0 91 fd 05 	lds	r27, 0x05FD
     47a:	48 17       	cp	r20, r24
     47c:	59 07       	cpc	r21, r25
     47e:	6a 07       	cpc	r22, r26
     480:	7b 07       	cpc	r23, r27
     482:	49 f4       	brne	.+18     	; 0x496 <UpdateAudioChannel0+0x3a4>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     484:	80 91 fe 05 	lds	r24, 0x05FE
     488:	90 91 ff 05 	lds	r25, 0x05FF
     48c:	a0 91 00 06 	lds	r26, 0x0600
     490:	b0 91 01 06 	lds	r27, 0x0601
     494:	29 c0       	rjmp	.+82     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     496:	40 91 05 06 	lds	r20, 0x0605
     49a:	50 91 06 06 	lds	r21, 0x0606
     49e:	60 91 07 06 	lds	r22, 0x0607
     4a2:	70 91 08 06 	lds	r23, 0x0608
     4a6:	80 91 f2 05 	lds	r24, 0x05F2
     4aa:	90 91 f3 05 	lds	r25, 0x05F3
     4ae:	a0 91 f4 05 	lds	r26, 0x05F4
     4b2:	b0 91 f5 05 	lds	r27, 0x05F5
     4b6:	48 17       	cp	r20, r24
     4b8:	59 07       	cpc	r21, r25
     4ba:	6a 07       	cpc	r22, r26
     4bc:	7b 07       	cpc	r23, r27
     4be:	49 f4       	brne	.+18     	; 0x4d2 <UpdateAudioChannel0+0x3e0>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4c0:	80 91 f6 05 	lds	r24, 0x05F6
     4c4:	90 91 f7 05 	lds	r25, 0x05F7
     4c8:	a0 91 f8 05 	lds	r26, 0x05F8
     4cc:	b0 91 f9 05 	lds	r27, 0x05F9
     4d0:	0b c0       	rjmp	.+22     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4d2:	80 91 05 06 	lds	r24, 0x0605
     4d6:	90 91 06 06 	lds	r25, 0x0606
     4da:	a0 91 07 06 	lds	r26, 0x0607
     4de:	b0 91 08 06 	lds	r27, 0x0608
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	a1 1d       	adc	r26, r1
     4e6:	b1 1d       	adc	r27, r1
     4e8:	80 93 05 06 	sts	0x0605, r24
     4ec:	90 93 06 06 	sts	0x0606, r25
     4f0:	a0 93 07 06 	sts	0x0607, r26
     4f4:	b0 93 08 06 	sts	0x0608, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     4f8:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     4fa:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     4fc:	9f ef       	ldi	r25, 0xFF	; 255
     4fe:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     500:	90 91 ee 05 	lds	r25, 0x05EE
     504:	99 23       	and	r25, r25
     506:	09 f4       	brne	.+2      	; 0x50a <UpdateAudioChannel0+0x418>
     508:	a1 c1       	rjmp	.+834    	; 0x84c <UpdateAudioChannel0+0x75a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     50a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     50c:	90 91 ee 05 	lds	r25, 0x05EE
     510:	2f ef       	ldi	r18, 0xFF	; 255
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	09 2e       	mov	r0, r25
     516:	01 c0       	rjmp	.+2      	; 0x51a <UpdateAudioChannel0+0x428>
     518:	22 0f       	add	r18, r18
     51a:	0a 94       	dec	r0
     51c:	ea f7       	brpl	.-6      	; 0x518 <UpdateAudioChannel0+0x426>
     51e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     520:	80 58       	subi	r24, 0x80	; 128
     522:	08 95       	ret
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     524:	80 91 05 06 	lds	r24, 0x0605
     528:	90 91 06 06 	lds	r25, 0x0606
     52c:	a0 91 07 06 	lds	r26, 0x0607
     530:	b0 91 08 06 	lds	r27, 0x0608
     534:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     536:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     538:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     53a:	80 91 05 06 	lds	r24, 0x0605
     53e:	90 91 06 06 	lds	r25, 0x0606
     542:	a0 91 07 06 	lds	r26, 0x0607
     546:	b0 91 08 06 	lds	r27, 0x0608
     54a:	89 2f       	mov	r24, r25
     54c:	9a 2f       	mov	r25, r26
     54e:	ab 2f       	mov	r26, r27
     550:	bb 27       	eor	r27, r27
     552:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     554:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     556:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     558:	80 91 05 06 	lds	r24, 0x0605
     55c:	90 91 06 06 	lds	r25, 0x0606
     560:	a0 91 07 06 	lds	r26, 0x0607
     564:	b0 91 08 06 	lds	r27, 0x0608
     568:	cd 01       	movw	r24, r26
     56a:	aa 27       	eor	r26, r26
     56c:	bb 27       	eor	r27, r27
     56e:	87 70       	andi	r24, 0x07	; 7
     570:	99 27       	eor	r25, r25
     572:	aa 27       	eor	r26, r26
     574:	bb 27       	eor	r27, r27
     576:	88 68       	ori	r24, 0x88	; 136
     578:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     57a:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     57c:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     57e:	80 91 ec 05 	lds	r24, 0x05EC
     582:	88 23       	and	r24, r24
     584:	09 f4       	brne	.+2      	; 0x588 <UpdateAudioChannel0+0x496>
     586:	6a c0       	rjmp	.+212    	; 0x65c <UpdateAudioChannel0+0x56a>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     588:	80 91 2d 04 	lds	r24, 0x042D
     58c:	90 91 2e 04 	lds	r25, 0x042E
     590:	a0 91 2f 04 	lds	r26, 0x042F
     594:	b0 91 30 04 	lds	r27, 0x0430
     598:	89 2b       	or	r24, r25
     59a:	8a 2b       	or	r24, r26
     59c:	8b 2b       	or	r24, r27
     59e:	39 f1       	breq	.+78     	; 0x5ee <UpdateAudioChannel0+0x4fc>
			{
				bankStates[BANK_0].currentAddress++;
     5a0:	80 91 05 06 	lds	r24, 0x0605
     5a4:	90 91 06 06 	lds	r25, 0x0606
     5a8:	a0 91 07 06 	lds	r26, 0x0607
     5ac:	b0 91 08 06 	lds	r27, 0x0608
     5b0:	01 96       	adiw	r24, 0x01	; 1
     5b2:	a1 1d       	adc	r26, r1
     5b4:	b1 1d       	adc	r27, r1
     5b6:	80 93 05 06 	sts	0x0605, r24
     5ba:	90 93 06 06 	sts	0x0606, r25
     5be:	a0 93 07 06 	sts	0x0607, r26
     5c2:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     5c6:	80 91 2d 04 	lds	r24, 0x042D
     5ca:	90 91 2e 04 	lds	r25, 0x042E
     5ce:	a0 91 2f 04 	lds	r26, 0x042F
     5d2:	b0 91 30 04 	lds	r27, 0x0430
     5d6:	01 97       	sbiw	r24, 0x01	; 1
     5d8:	a1 09       	sbc	r26, r1
     5da:	b1 09       	sbc	r27, r1
     5dc:	80 93 2d 04 	sts	0x042D, r24
     5e0:	90 93 2e 04 	sts	0x042E, r25
     5e4:	a0 93 2f 04 	sts	0x042F, r26
     5e8:	b0 93 30 04 	sts	0x0430, r27
     5ec:	02 c1       	rjmp	.+516    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5ee:	80 91 35 04 	lds	r24, 0x0435
     5f2:	90 91 36 04 	lds	r25, 0x0436
     5f6:	a0 91 37 04 	lds	r26, 0x0437
     5fa:	b0 91 38 04 	lds	r27, 0x0438
     5fe:	80 93 2d 04 	sts	0x042D, r24
     602:	90 93 2e 04 	sts	0x042E, r25
     606:	a0 93 2f 04 	sts	0x042F, r26
     60a:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     60e:	80 91 3d 04 	lds	r24, 0x043D
     612:	8f 5f       	subi	r24, 0xFF	; 255
     614:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     618:	90 91 3d 04 	lds	r25, 0x043D
     61c:	80 91 ec 05 	lds	r24, 0x05EC
     620:	98 13       	cpse	r25, r24
     622:	02 c0       	rjmp	.+4      	; 0x628 <UpdateAudioChannel0+0x536>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     624:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     628:	e0 91 3d 04 	lds	r30, 0x043D
     62c:	20 91 35 04 	lds	r18, 0x0435
     630:	30 91 36 04 	lds	r19, 0x0436
     634:	40 91 37 04 	lds	r20, 0x0437
     638:	50 91 38 04 	lds	r21, 0x0438
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 5b       	subi	r30, 0xBC	; 188
     640:	fb 4f       	sbci	r31, 0xFB	; 251
     642:	a0 81       	ld	r26, Z
     644:	b0 e0       	ldi	r27, 0x00	; 0
     646:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
     64a:	60 93 05 06 	sts	0x0605, r22
     64e:	70 93 06 06 	sts	0x0606, r23
     652:	80 93 07 06 	sts	0x0607, r24
     656:	90 93 08 06 	sts	0x0608, r25
     65a:	cb c0       	rjmp	.+406    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     65c:	80 91 ea 05 	lds	r24, 0x05EA
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     660:	40 91 05 06 	lds	r20, 0x0605
     664:	50 91 06 06 	lds	r21, 0x0606
     668:	60 91 07 06 	lds	r22, 0x0607
     66c:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     670:	81 11       	cpse	r24, r1
     672:	5a c0       	rjmp	.+180    	; 0x728 <UpdateAudioChannel0+0x636>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     674:	80 91 fe 05 	lds	r24, 0x05FE
     678:	90 91 ff 05 	lds	r25, 0x05FF
     67c:	a0 91 00 06 	lds	r26, 0x0600
     680:	b0 91 01 06 	lds	r27, 0x0601
     684:	48 17       	cp	r20, r24
     686:	59 07       	cpc	r21, r25
     688:	6a 07       	cpc	r22, r26
     68a:	7b 07       	cpc	r23, r27
     68c:	29 f4       	brne	.+10     	; 0x698 <UpdateAudioChannel0+0x5a6>
     68e:	80 91 e7 05 	lds	r24, 0x05E7
     692:	81 30       	cpi	r24, 0x01	; 1
     694:	09 f4       	brne	.+2      	; 0x698 <UpdateAudioChannel0+0x5a6>
     696:	59 c0       	rjmp	.+178    	; 0x74a <UpdateAudioChannel0+0x658>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     698:	40 91 05 06 	lds	r20, 0x0605
     69c:	50 91 06 06 	lds	r21, 0x0606
     6a0:	60 91 07 06 	lds	r22, 0x0607
     6a4:	70 91 08 06 	lds	r23, 0x0608
     6a8:	80 91 fe 05 	lds	r24, 0x05FE
     6ac:	90 91 ff 05 	lds	r25, 0x05FF
     6b0:	a0 91 00 06 	lds	r26, 0x0600
     6b4:	b0 91 01 06 	lds	r27, 0x0601
     6b8:	48 17       	cp	r20, r24
     6ba:	59 07       	cpc	r21, r25
     6bc:	6a 07       	cpc	r22, r26
     6be:	7b 07       	cpc	r23, r27
     6c0:	49 f4       	brne	.+18     	; 0x6d4 <UpdateAudioChannel0+0x5e2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6c2:	80 91 fa 05 	lds	r24, 0x05FA
     6c6:	90 91 fb 05 	lds	r25, 0x05FB
     6ca:	a0 91 fc 05 	lds	r26, 0x05FC
     6ce:	b0 91 fd 05 	lds	r27, 0x05FD
     6d2:	87 c0       	rjmp	.+270    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6d4:	40 91 05 06 	lds	r20, 0x0605
     6d8:	50 91 06 06 	lds	r21, 0x0606
     6dc:	60 91 07 06 	lds	r22, 0x0607
     6e0:	70 91 08 06 	lds	r23, 0x0608
     6e4:	80 91 f6 05 	lds	r24, 0x05F6
     6e8:	90 91 f7 05 	lds	r25, 0x05F7
     6ec:	a0 91 f8 05 	lds	r26, 0x05F8
     6f0:	b0 91 f9 05 	lds	r27, 0x05F9
     6f4:	48 17       	cp	r20, r24
     6f6:	59 07       	cpc	r21, r25
     6f8:	6a 07       	cpc	r22, r26
     6fa:	7b 07       	cpc	r23, r27
     6fc:	49 f4       	brne	.+18     	; 0x710 <UpdateAudioChannel0+0x61e>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     6fe:	80 91 f2 05 	lds	r24, 0x05F2
     702:	90 91 f3 05 	lds	r25, 0x05F3
     706:	a0 91 f4 05 	lds	r26, 0x05F4
     70a:	b0 91 f5 05 	lds	r27, 0x05F5
     70e:	69 c0       	rjmp	.+210    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     710:	80 91 05 06 	lds	r24, 0x0605
     714:	90 91 06 06 	lds	r25, 0x0606
     718:	a0 91 07 06 	lds	r26, 0x0607
     71c:	b0 91 08 06 	lds	r27, 0x0608
     720:	01 97       	sbiw	r24, 0x01	; 1
     722:	a1 09       	sbc	r26, r1
     724:	b1 09       	sbc	r27, r1
     726:	5d c0       	rjmp	.+186    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     728:	80 91 fa 05 	lds	r24, 0x05FA
     72c:	90 91 fb 05 	lds	r25, 0x05FB
     730:	a0 91 fc 05 	lds	r26, 0x05FC
     734:	b0 91 fd 05 	lds	r27, 0x05FD
     738:	48 17       	cp	r20, r24
     73a:	59 07       	cpc	r21, r25
     73c:	6a 07       	cpc	r22, r26
     73e:	7b 07       	cpc	r23, r27
     740:	49 f4       	brne	.+18     	; 0x754 <UpdateAudioChannel0+0x662>
     742:	80 91 e7 05 	lds	r24, 0x05E7
     746:	81 30       	cpi	r24, 0x01	; 1
     748:	29 f4       	brne	.+10     	; 0x754 <UpdateAudioChannel0+0x662>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     74a:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     74e:	10 92 ef 05 	sts	0x05EF, r1
     752:	4f c0       	rjmp	.+158    	; 0x7f2 <UpdateAudioChannel0+0x700>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     754:	40 91 05 06 	lds	r20, 0x0605
     758:	50 91 06 06 	lds	r21, 0x0606
     75c:	60 91 07 06 	lds	r22, 0x0607
     760:	70 91 08 06 	lds	r23, 0x0608
     764:	80 91 fa 05 	lds	r24, 0x05FA
     768:	90 91 fb 05 	lds	r25, 0x05FB
     76c:	a0 91 fc 05 	lds	r26, 0x05FC
     770:	b0 91 fd 05 	lds	r27, 0x05FD
     774:	48 17       	cp	r20, r24
     776:	59 07       	cpc	r21, r25
     778:	6a 07       	cpc	r22, r26
     77a:	7b 07       	cpc	r23, r27
     77c:	49 f4       	brne	.+18     	; 0x790 <UpdateAudioChannel0+0x69e>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     77e:	80 91 fe 05 	lds	r24, 0x05FE
     782:	90 91 ff 05 	lds	r25, 0x05FF
     786:	a0 91 00 06 	lds	r26, 0x0600
     78a:	b0 91 01 06 	lds	r27, 0x0601
     78e:	29 c0       	rjmp	.+82     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     790:	40 91 05 06 	lds	r20, 0x0605
     794:	50 91 06 06 	lds	r21, 0x0606
     798:	60 91 07 06 	lds	r22, 0x0607
     79c:	70 91 08 06 	lds	r23, 0x0608
     7a0:	80 91 f2 05 	lds	r24, 0x05F2
     7a4:	90 91 f3 05 	lds	r25, 0x05F3
     7a8:	a0 91 f4 05 	lds	r26, 0x05F4
     7ac:	b0 91 f5 05 	lds	r27, 0x05F5
     7b0:	48 17       	cp	r20, r24
     7b2:	59 07       	cpc	r21, r25
     7b4:	6a 07       	cpc	r22, r26
     7b6:	7b 07       	cpc	r23, r27
     7b8:	49 f4       	brne	.+18     	; 0x7cc <UpdateAudioChannel0+0x6da>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7ba:	80 91 f6 05 	lds	r24, 0x05F6
     7be:	90 91 f7 05 	lds	r25, 0x05F7
     7c2:	a0 91 f8 05 	lds	r26, 0x05F8
     7c6:	b0 91 f9 05 	lds	r27, 0x05F9
     7ca:	0b c0       	rjmp	.+22     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7cc:	80 91 05 06 	lds	r24, 0x0605
     7d0:	90 91 06 06 	lds	r25, 0x0606
     7d4:	a0 91 07 06 	lds	r26, 0x0607
     7d8:	b0 91 08 06 	lds	r27, 0x0608
     7dc:	01 96       	adiw	r24, 0x01	; 1
     7de:	a1 1d       	adc	r26, r1
     7e0:	b1 1d       	adc	r27, r1
     7e2:	80 93 05 06 	sts	0x0605, r24
     7e6:	90 93 06 06 	sts	0x0606, r25
     7ea:	a0 93 07 06 	sts	0x0607, r26
     7ee:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     7f2:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     7f4:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     7f6:	9f ef       	ldi	r25, 0xFF	; 255
     7f8:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     7fa:	90 91 ee 05 	lds	r25, 0x05EE
     7fe:	99 23       	and	r25, r25
     800:	61 f0       	breq	.+24     	; 0x81a <UpdateAudioChannel0+0x728>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     802:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     804:	90 91 ee 05 	lds	r25, 0x05EE
     808:	2f ef       	ldi	r18, 0xFF	; 255
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	09 2e       	mov	r0, r25
     80e:	01 c0       	rjmp	.+2      	; 0x812 <UpdateAudioChannel0+0x720>
     810:	22 0f       	add	r18, r18
     812:	0a 94       	dec	r0
     814:	ea f7       	brpl	.-6      	; 0x810 <UpdateAudioChannel0+0x71e>
     816:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     818:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     81a:	20 91 2c 04 	lds	r18, 0x042C
     81e:	33 27       	eor	r19, r19
     820:	27 fd       	sbrc	r18, 7
     822:	30 95       	com	r19
     824:	28 0f       	add	r18, r24
     826:	31 1d       	adc	r19, r1
     828:	87 fd       	sbrc	r24, 7
     82a:	3a 95       	dec	r19
     82c:	20 38       	cpi	r18, 0x80	; 128
     82e:	9f ef       	ldi	r25, 0xFF	; 255
     830:	39 07       	cpc	r19, r25
     832:	14 f4       	brge	.+4      	; 0x838 <UpdateAudioChannel0+0x746>
     834:	20 e8       	ldi	r18, 0x80	; 128
     836:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     838:	20 38       	cpi	r18, 0x80	; 128
     83a:	31 05       	cpc	r19, r1
     83c:	14 f0       	brlt	.+4      	; 0x842 <UpdateAudioChannel0+0x750>
     83e:	2f e7       	ldi	r18, 0x7F	; 127
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     844:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     846:	11 9a       	sbi	0x02, 1	; 2
		break;
     848:	08 95       	ret
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     84a:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     84c:	08 95       	ret

0000084e <UpdateAudioChannel1>:

static unsigned char UpdateAudioChannel1(void)
// New banked idea of the audio handler -- ONE FOR EACH BANK!
{
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     852:	80 91 09 06 	lds	r24, 0x0609
     856:	83 30       	cpi	r24, 0x03	; 3
     858:	c1 f0       	breq	.+48     	; 0x88a <UpdateAudioChannel1+0x3c>
     85a:	30 f4       	brcc	.+12     	; 0x868 <UpdateAudioChannel1+0x1a>
     85c:	81 30       	cpi	r24, 0x01	; 1
     85e:	59 f0       	breq	.+22     	; 0x876 <UpdateAudioChannel1+0x28>
     860:	82 30       	cpi	r24, 0x02	; 2
     862:	09 f0       	breq	.+2      	; 0x866 <UpdateAudioChannel1+0x18>
     864:	b2 c3       	rjmp	.+1892   	; 0xfca <UpdateAudioChannel1+0x77c>
     866:	0e c0       	rjmp	.+28     	; 0x884 <UpdateAudioChannel1+0x36>
     868:	84 30       	cpi	r24, 0x04	; 4
     86a:	09 f4       	brne	.+2      	; 0x86e <UpdateAudioChannel1+0x20>
     86c:	8e c0       	rjmp	.+284    	; 0x98a <UpdateAudioChannel1+0x13c>
     86e:	85 30       	cpi	r24, 0x05	; 5
     870:	09 f0       	breq	.+2      	; 0x874 <UpdateAudioChannel1+0x26>
     872:	ab c3       	rjmp	.+1878   	; 0xfca <UpdateAudioChannel1+0x77c>
     874:	0f c2       	rjmp	.+1054   	; 0xc94 <UpdateAudioChannel1+0x446>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     876:	80 91 46 05 	lds	r24, 0x0546
     87a:	98 2f       	mov	r25, r24
     87c:	9f 5f       	subi	r25, 0xFF	; 255
     87e:	90 93 46 05 	sts	0x0546, r25
		break;
     882:	a4 c3       	rjmp	.+1864   	; 0xfcc <UpdateAudioChannel1+0x77e>

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     884:	80 91 2c 04 	lds	r24, 0x042C
     888:	f3 c1       	rjmp	.+998    	; 0xc70 <UpdateAudioChannel1+0x422>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     88e:	80 91 28 06 	lds	r24, 0x0628
     892:	90 91 29 06 	lds	r25, 0x0629
     896:	a0 91 2a 06 	lds	r26, 0x062A
     89a:	b0 91 2b 06 	lds	r27, 0x062B
     89e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8a0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8a2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8a4:	80 91 28 06 	lds	r24, 0x0628
     8a8:	90 91 29 06 	lds	r25, 0x0629
     8ac:	a0 91 2a 06 	lds	r26, 0x062A
     8b0:	b0 91 2b 06 	lds	r27, 0x062B
     8b4:	89 2f       	mov	r24, r25
     8b6:	9a 2f       	mov	r25, r26
     8b8:	ab 2f       	mov	r26, r27
     8ba:	bb 27       	eor	r27, r27
     8bc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8be:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8c0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8c2:	80 91 28 06 	lds	r24, 0x0628
     8c6:	90 91 29 06 	lds	r25, 0x0629
     8ca:	a0 91 2a 06 	lds	r26, 0x062A
     8ce:	b0 91 2b 06 	lds	r27, 0x062B
     8d2:	cd 01       	movw	r24, r26
     8d4:	aa 27       	eor	r26, r26
     8d6:	bb 27       	eor	r27, r27
     8d8:	87 70       	andi	r24, 0x07	; 7
     8da:	99 27       	eor	r25, r25
     8dc:	aa 27       	eor	r26, r26
     8de:	bb 27       	eor	r27, r27
     8e0:	88 68       	ori	r24, 0x88	; 136
     8e2:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8e4:	80 91 2c 04 	lds	r24, 0x042C
     8e8:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     8ea:	80 91 28 06 	lds	r24, 0x0628
     8ee:	90 91 29 06 	lds	r25, 0x0629
     8f2:	a0 91 2a 06 	lds	r26, 0x062A
     8f6:	b0 91 2b 06 	lds	r27, 0x062B
     8fa:	01 97       	sbiw	r24, 0x01	; 1
     8fc:	a1 09       	sbc	r26, r1
     8fe:	b1 09       	sbc	r27, r1
     900:	80 93 28 06 	sts	0x0628, r24
     904:	90 93 29 06 	sts	0x0629, r25
     908:	a0 93 2a 06 	sts	0x062A, r26
     90c:	b0 93 2b 06 	sts	0x062B, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     910:	80 91 28 06 	lds	r24, 0x0628
     914:	90 91 29 06 	lds	r25, 0x0629
     918:	a0 91 2a 06 	lds	r26, 0x062A
     91c:	b0 91 2b 06 	lds	r27, 0x062B
     920:	80 93 15 06 	sts	0x0615, r24
     924:	90 93 16 06 	sts	0x0616, r25
     928:	a0 93 17 06 	sts	0x0617, r26
     92c:	b0 93 18 06 	sts	0x0618, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     930:	80 91 28 06 	lds	r24, 0x0628
     934:	90 91 29 06 	lds	r25, 0x0629
     938:	a0 91 2a 06 	lds	r26, 0x062A
     93c:	b0 91 2b 06 	lds	r27, 0x062B
     940:	80 93 1d 06 	sts	0x061D, r24
     944:	90 93 1e 06 	sts	0x061E, r25
     948:	a0 93 1f 06 	sts	0x061F, r26
     94c:	b0 93 20 06 	sts	0x0620, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     950:	40 91 f2 05 	lds	r20, 0x05F2
     954:	50 91 f3 05 	lds	r21, 0x05F3
     958:	60 91 f4 05 	lds	r22, 0x05F4
     95c:	70 91 f5 05 	lds	r23, 0x05F5
     960:	80 91 15 06 	lds	r24, 0x0615
     964:	90 91 16 06 	lds	r25, 0x0616
     968:	a0 91 17 06 	lds	r26, 0x0617
     96c:	b0 91 18 06 	lds	r27, 0x0618
     970:	48 17       	cp	r20, r24
     972:	59 07       	cpc	r21, r25
     974:	6a 07       	cpc	r22, r26
     976:	7b 07       	cpc	r23, r27
     978:	28 f0       	brcs	.+10     	; 0x984 <UpdateAudioChannel1+0x136>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     97a:	10 92 09 06 	sts	0x0609, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	80 93 3f 04 	sts	0x043F, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     984:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     986:	11 9a       	sbi	0x02, 1	; 2
     988:	20 c3       	rjmp	.+1600   	; 0xfca <UpdateAudioChannel1+0x77c>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     98a:	80 91 28 06 	lds	r24, 0x0628
     98e:	90 91 29 06 	lds	r25, 0x0629
     992:	a0 91 2a 06 	lds	r26, 0x062A
     996:	b0 91 2b 06 	lds	r27, 0x062B
     99a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     99c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     99e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9a0:	80 91 28 06 	lds	r24, 0x0628
     9a4:	90 91 29 06 	lds	r25, 0x0629
     9a8:	a0 91 2a 06 	lds	r26, 0x062A
     9ac:	b0 91 2b 06 	lds	r27, 0x062B
     9b0:	89 2f       	mov	r24, r25
     9b2:	9a 2f       	mov	r25, r26
     9b4:	ab 2f       	mov	r26, r27
     9b6:	bb 27       	eor	r27, r27
     9b8:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9ba:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9bc:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9be:	80 91 28 06 	lds	r24, 0x0628
     9c2:	90 91 29 06 	lds	r25, 0x0629
     9c6:	a0 91 2a 06 	lds	r26, 0x062A
     9ca:	b0 91 2b 06 	lds	r27, 0x062B
     9ce:	cd 01       	movw	r24, r26
     9d0:	aa 27       	eor	r26, r26
     9d2:	bb 27       	eor	r27, r27
     9d4:	87 70       	andi	r24, 0x07	; 7
     9d6:	99 27       	eor	r25, r25
     9d8:	aa 27       	eor	r26, r26
     9da:	bb 27       	eor	r27, r27
     9dc:	88 68       	ori	r24, 0x88	; 136
     9de:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9e0:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9e2:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9e4:	80 91 0f 06 	lds	r24, 0x060F
     9e8:	88 23       	and	r24, r24
     9ea:	09 f4       	brne	.+2      	; 0x9ee <UpdateAudioChannel1+0x1a0>
     9ec:	72 c0       	rjmp	.+228    	; 0xad2 <UpdateAudioChannel1+0x284>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     9ee:	80 91 31 04 	lds	r24, 0x0431
     9f2:	90 91 32 04 	lds	r25, 0x0432
     9f6:	a0 91 33 04 	lds	r26, 0x0433
     9fa:	b0 91 34 04 	lds	r27, 0x0434
     9fe:	89 2b       	or	r24, r25
     a00:	8a 2b       	or	r24, r26
     a02:	8b 2b       	or	r24, r27
     a04:	39 f1       	breq	.+78     	; 0xa54 <UpdateAudioChannel1+0x206>
			{
				bankStates[BANK_1].currentAddress--;
     a06:	80 91 28 06 	lds	r24, 0x0628
     a0a:	90 91 29 06 	lds	r25, 0x0629
     a0e:	a0 91 2a 06 	lds	r26, 0x062A
     a12:	b0 91 2b 06 	lds	r27, 0x062B
     a16:	01 97       	sbiw	r24, 0x01	; 1
     a18:	a1 09       	sbc	r26, r1
     a1a:	b1 09       	sbc	r27, r1
     a1c:	80 93 28 06 	sts	0x0628, r24
     a20:	90 93 29 06 	sts	0x0629, r25
     a24:	a0 93 2a 06 	sts	0x062A, r26
     a28:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     a2c:	80 91 31 04 	lds	r24, 0x0431
     a30:	90 91 32 04 	lds	r25, 0x0432
     a34:	a0 91 33 04 	lds	r26, 0x0433
     a38:	b0 91 34 04 	lds	r27, 0x0434
     a3c:	01 97       	sbiw	r24, 0x01	; 1
     a3e:	a1 09       	sbc	r26, r1
     a40:	b1 09       	sbc	r27, r1
     a42:	80 93 31 04 	sts	0x0431, r24
     a46:	90 93 32 04 	sts	0x0432, r25
     a4a:	a0 93 33 04 	sts	0x0433, r26
     a4e:	b0 93 34 04 	sts	0x0434, r27
     a52:	0a c1       	rjmp	.+532    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a54:	80 91 39 04 	lds	r24, 0x0439
     a58:	90 91 3a 04 	lds	r25, 0x043A
     a5c:	a0 91 3b 04 	lds	r26, 0x043B
     a60:	b0 91 3c 04 	lds	r27, 0x043C
     a64:	80 93 31 04 	sts	0x0431, r24
     a68:	90 93 32 04 	sts	0x0432, r25
     a6c:	a0 93 33 04 	sts	0x0433, r26
     a70:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a74:	80 91 3e 04 	lds	r24, 0x043E
     a78:	8f 5f       	subi	r24, 0xFF	; 255
     a7a:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a7e:	90 91 3e 04 	lds	r25, 0x043E
     a82:	80 91 0f 06 	lds	r24, 0x060F
     a86:	98 13       	cpse	r25, r24
     a88:	02 c0       	rjmp	.+4      	; 0xa8e <UpdateAudioChannel1+0x240>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     a8a:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     a8e:	e0 91 3e 04 	lds	r30, 0x043E
     a92:	20 91 39 04 	lds	r18, 0x0439
     a96:	30 91 3a 04 	lds	r19, 0x043A
     a9a:	40 91 3b 04 	lds	r20, 0x043B
     a9e:	50 91 3c 04 	lds	r21, 0x043C
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	ec 53       	subi	r30, 0x3C	; 60
     aa6:	fb 4f       	sbci	r31, 0xFB	; 251
     aa8:	a0 81       	ld	r26, Z
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
     ab0:	0f ef       	ldi	r16, 0xFF	; 255
     ab2:	1f ef       	ldi	r17, 0xFF	; 255
     ab4:	27 e0       	ldi	r18, 0x07	; 7
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	06 1b       	sub	r16, r22
     aba:	17 0b       	sbc	r17, r23
     abc:	28 0b       	sbc	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	00 93 28 06 	sts	0x0628, r16
     ac4:	10 93 29 06 	sts	0x0629, r17
     ac8:	20 93 2a 06 	sts	0x062A, r18
     acc:	30 93 2b 06 	sts	0x062B, r19
     ad0:	cb c0       	rjmp	.+406    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ad2:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     ad6:	40 91 28 06 	lds	r20, 0x0628
     ada:	50 91 29 06 	lds	r21, 0x0629
     ade:	60 91 2a 06 	lds	r22, 0x062A
     ae2:	70 91 2b 06 	lds	r23, 0x062B
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ae6:	81 11       	cpse	r24, r1
     ae8:	5a c0       	rjmp	.+180    	; 0xb9e <UpdateAudioChannel1+0x350>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     aea:	80 91 21 06 	lds	r24, 0x0621
     aee:	90 91 22 06 	lds	r25, 0x0622
     af2:	a0 91 23 06 	lds	r26, 0x0623
     af6:	b0 91 24 06 	lds	r27, 0x0624
     afa:	48 17       	cp	r20, r24
     afc:	59 07       	cpc	r21, r25
     afe:	6a 07       	cpc	r22, r26
     b00:	7b 07       	cpc	r23, r27
     b02:	29 f4       	brne	.+10     	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b04:	80 91 0a 06 	lds	r24, 0x060A
     b08:	81 30       	cpi	r24, 0x01	; 1
     b0a:	09 f4       	brne	.+2      	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b0c:	59 c0       	rjmp	.+178    	; 0xbc0 <UpdateAudioChannel1+0x372>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b0e:	40 91 28 06 	lds	r20, 0x0628
     b12:	50 91 29 06 	lds	r21, 0x0629
     b16:	60 91 2a 06 	lds	r22, 0x062A
     b1a:	70 91 2b 06 	lds	r23, 0x062B
     b1e:	80 91 21 06 	lds	r24, 0x0621
     b22:	90 91 22 06 	lds	r25, 0x0622
     b26:	a0 91 23 06 	lds	r26, 0x0623
     b2a:	b0 91 24 06 	lds	r27, 0x0624
     b2e:	48 17       	cp	r20, r24
     b30:	59 07       	cpc	r21, r25
     b32:	6a 07       	cpc	r22, r26
     b34:	7b 07       	cpc	r23, r27
     b36:	49 f4       	brne	.+18     	; 0xb4a <UpdateAudioChannel1+0x2fc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b38:	80 91 1d 06 	lds	r24, 0x061D
     b3c:	90 91 1e 06 	lds	r25, 0x061E
     b40:	a0 91 1f 06 	lds	r26, 0x061F
     b44:	b0 91 20 06 	lds	r27, 0x0620
     b48:	87 c0       	rjmp	.+270    	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b4a:	40 91 28 06 	lds	r20, 0x0628
     b4e:	50 91 29 06 	lds	r21, 0x0629
     b52:	60 91 2a 06 	lds	r22, 0x062A
     b56:	70 91 2b 06 	lds	r23, 0x062B
     b5a:	80 91 19 06 	lds	r24, 0x0619
     b5e:	90 91 1a 06 	lds	r25, 0x061A
     b62:	a0 91 1b 06 	lds	r26, 0x061B
     b66:	b0 91 1c 06 	lds	r27, 0x061C
     b6a:	48 17       	cp	r20, r24
     b6c:	59 07       	cpc	r21, r25
     b6e:	6a 07       	cpc	r22, r26
     b70:	7b 07       	cpc	r23, r27
     b72:	49 f4       	brne	.+18     	; 0xb86 <UpdateAudioChannel1+0x338>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b74:	80 91 15 06 	lds	r24, 0x0615
     b78:	90 91 16 06 	lds	r25, 0x0616
     b7c:	a0 91 17 06 	lds	r26, 0x0617
     b80:	b0 91 18 06 	lds	r27, 0x0618
     b84:	69 c0       	rjmp	.+210    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     b86:	80 91 28 06 	lds	r24, 0x0628
     b8a:	90 91 29 06 	lds	r25, 0x0629
     b8e:	a0 91 2a 06 	lds	r26, 0x062A
     b92:	b0 91 2b 06 	lds	r27, 0x062B
     b96:	01 96       	adiw	r24, 0x01	; 1
     b98:	a1 1d       	adc	r26, r1
     b9a:	b1 1d       	adc	r27, r1
     b9c:	5d c0       	rjmp	.+186    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     b9e:	80 91 1d 06 	lds	r24, 0x061D
     ba2:	90 91 1e 06 	lds	r25, 0x061E
     ba6:	a0 91 1f 06 	lds	r26, 0x061F
     baa:	b0 91 20 06 	lds	r27, 0x0620
     bae:	48 17       	cp	r20, r24
     bb0:	59 07       	cpc	r21, r25
     bb2:	6a 07       	cpc	r22, r26
     bb4:	7b 07       	cpc	r23, r27
     bb6:	49 f4       	brne	.+18     	; 0xbca <UpdateAudioChannel1+0x37c>
     bb8:	80 91 0a 06 	lds	r24, 0x060A
     bbc:	81 30       	cpi	r24, 0x01	; 1
     bbe:	29 f4       	brne	.+10     	; 0xbca <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bc0:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bc4:	10 92 12 06 	sts	0x0612, r1
     bc8:	4f c0       	rjmp	.+158    	; 0xc68 <UpdateAudioChannel1+0x41a>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bca:	40 91 28 06 	lds	r20, 0x0628
     bce:	50 91 29 06 	lds	r21, 0x0629
     bd2:	60 91 2a 06 	lds	r22, 0x062A
     bd6:	70 91 2b 06 	lds	r23, 0x062B
     bda:	80 91 1d 06 	lds	r24, 0x061D
     bde:	90 91 1e 06 	lds	r25, 0x061E
     be2:	a0 91 1f 06 	lds	r26, 0x061F
     be6:	b0 91 20 06 	lds	r27, 0x0620
     bea:	48 17       	cp	r20, r24
     bec:	59 07       	cpc	r21, r25
     bee:	6a 07       	cpc	r22, r26
     bf0:	7b 07       	cpc	r23, r27
     bf2:	49 f4       	brne	.+18     	; 0xc06 <UpdateAudioChannel1+0x3b8>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     bf4:	80 91 21 06 	lds	r24, 0x0621
     bf8:	90 91 22 06 	lds	r25, 0x0622
     bfc:	a0 91 23 06 	lds	r26, 0x0623
     c00:	b0 91 24 06 	lds	r27, 0x0624
     c04:	29 c0       	rjmp	.+82     	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c06:	40 91 28 06 	lds	r20, 0x0628
     c0a:	50 91 29 06 	lds	r21, 0x0629
     c0e:	60 91 2a 06 	lds	r22, 0x062A
     c12:	70 91 2b 06 	lds	r23, 0x062B
     c16:	80 91 15 06 	lds	r24, 0x0615
     c1a:	90 91 16 06 	lds	r25, 0x0616
     c1e:	a0 91 17 06 	lds	r26, 0x0617
     c22:	b0 91 18 06 	lds	r27, 0x0618
     c26:	48 17       	cp	r20, r24
     c28:	59 07       	cpc	r21, r25
     c2a:	6a 07       	cpc	r22, r26
     c2c:	7b 07       	cpc	r23, r27
     c2e:	49 f4       	brne	.+18     	; 0xc42 <UpdateAudioChannel1+0x3f4>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c30:	80 91 19 06 	lds	r24, 0x0619
     c34:	90 91 1a 06 	lds	r25, 0x061A
     c38:	a0 91 1b 06 	lds	r26, 0x061B
     c3c:	b0 91 1c 06 	lds	r27, 0x061C
     c40:	0b c0       	rjmp	.+22     	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c42:	80 91 28 06 	lds	r24, 0x0628
     c46:	90 91 29 06 	lds	r25, 0x0629
     c4a:	a0 91 2a 06 	lds	r26, 0x062A
     c4e:	b0 91 2b 06 	lds	r27, 0x062B
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	a1 09       	sbc	r26, r1
     c56:	b1 09       	sbc	r27, r1
     c58:	80 93 28 06 	sts	0x0628, r24
     c5c:	90 93 29 06 	sts	0x0629, r25
     c60:	a0 93 2a 06 	sts	0x062A, r26
     c64:	b0 93 2b 06 	sts	0x062B, r27
			}
		}

		// Done with addy, read RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c68:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c6a:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c6c:	9f ef       	ldi	r25, 0xFF	; 255
     c6e:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c70:	90 91 11 06 	lds	r25, 0x0611
     c74:	99 23       	and	r25, r25
     c76:	09 f4       	brne	.+2      	; 0xc7a <UpdateAudioChannel1+0x42c>
     c78:	a9 c1       	rjmp	.+850    	; 0xfcc <UpdateAudioChannel1+0x77e>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     c7a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     c7c:	90 91 11 06 	lds	r25, 0x0611
     c80:	2f ef       	ldi	r18, 0xFF	; 255
     c82:	30 e0       	ldi	r19, 0x00	; 0
     c84:	09 2e       	mov	r0, r25
     c86:	01 c0       	rjmp	.+2      	; 0xc8a <UpdateAudioChannel1+0x43c>
     c88:	22 0f       	add	r18, r18
     c8a:	0a 94       	dec	r0
     c8c:	ea f7       	brpl	.-6      	; 0xc88 <UpdateAudioChannel1+0x43a>
     c8e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     c90:	80 58       	subi	r24, 0x80	; 128
     c92:	9c c1       	rjmp	.+824    	; 0xfcc <UpdateAudioChannel1+0x77e>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     c94:	80 91 28 06 	lds	r24, 0x0628
     c98:	90 91 29 06 	lds	r25, 0x0629
     c9c:	a0 91 2a 06 	lds	r26, 0x062A
     ca0:	b0 91 2b 06 	lds	r27, 0x062B
     ca4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     ca6:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     ca8:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     caa:	80 91 28 06 	lds	r24, 0x0628
     cae:	90 91 29 06 	lds	r25, 0x0629
     cb2:	a0 91 2a 06 	lds	r26, 0x062A
     cb6:	b0 91 2b 06 	lds	r27, 0x062B
     cba:	89 2f       	mov	r24, r25
     cbc:	9a 2f       	mov	r25, r26
     cbe:	ab 2f       	mov	r26, r27
     cc0:	bb 27       	eor	r27, r27
     cc2:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cc4:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cc6:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cc8:	80 91 28 06 	lds	r24, 0x0628
     ccc:	90 91 29 06 	lds	r25, 0x0629
     cd0:	a0 91 2a 06 	lds	r26, 0x062A
     cd4:	b0 91 2b 06 	lds	r27, 0x062B
     cd8:	cd 01       	movw	r24, r26
     cda:	aa 27       	eor	r26, r26
     cdc:	bb 27       	eor	r27, r27
     cde:	87 70       	andi	r24, 0x07	; 7
     ce0:	99 27       	eor	r25, r25
     ce2:	aa 27       	eor	r26, r26
     ce4:	bb 27       	eor	r27, r27
     ce6:	88 68       	ori	r24, 0x88	; 136
     ce8:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     cea:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     cec:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     cee:	80 91 0f 06 	lds	r24, 0x060F
     cf2:	88 23       	and	r24, r24
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <UpdateAudioChannel1+0x4aa>
     cf6:	72 c0       	rjmp	.+228    	; 0xddc <UpdateAudioChannel1+0x58e>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     cf8:	80 91 31 04 	lds	r24, 0x0431
     cfc:	90 91 32 04 	lds	r25, 0x0432
     d00:	a0 91 33 04 	lds	r26, 0x0433
     d04:	b0 91 34 04 	lds	r27, 0x0434
     d08:	89 2b       	or	r24, r25
     d0a:	8a 2b       	or	r24, r26
     d0c:	8b 2b       	or	r24, r27
     d0e:	39 f1       	breq	.+78     	; 0xd5e <UpdateAudioChannel1+0x510>
			{
				bankStates[BANK_1].currentAddress--;
     d10:	80 91 28 06 	lds	r24, 0x0628
     d14:	90 91 29 06 	lds	r25, 0x0629
     d18:	a0 91 2a 06 	lds	r26, 0x062A
     d1c:	b0 91 2b 06 	lds	r27, 0x062B
     d20:	01 97       	sbiw	r24, 0x01	; 1
     d22:	a1 09       	sbc	r26, r1
     d24:	b1 09       	sbc	r27, r1
     d26:	80 93 28 06 	sts	0x0628, r24
     d2a:	90 93 29 06 	sts	0x0629, r25
     d2e:	a0 93 2a 06 	sts	0x062A, r26
     d32:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     d36:	80 91 31 04 	lds	r24, 0x0431
     d3a:	90 91 32 04 	lds	r25, 0x0432
     d3e:	a0 91 33 04 	lds	r26, 0x0433
     d42:	b0 91 34 04 	lds	r27, 0x0434
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 31 04 	sts	0x0431, r24
     d50:	90 93 32 04 	sts	0x0432, r25
     d54:	a0 93 33 04 	sts	0x0433, r26
     d58:	b0 93 34 04 	sts	0x0434, r27
     d5c:	0a c1       	rjmp	.+532    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d5e:	80 91 39 04 	lds	r24, 0x0439
     d62:	90 91 3a 04 	lds	r25, 0x043A
     d66:	a0 91 3b 04 	lds	r26, 0x043B
     d6a:	b0 91 3c 04 	lds	r27, 0x043C
     d6e:	80 93 31 04 	sts	0x0431, r24
     d72:	90 93 32 04 	sts	0x0432, r25
     d76:	a0 93 33 04 	sts	0x0433, r26
     d7a:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     d7e:	80 91 3e 04 	lds	r24, 0x043E
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     d88:	90 91 3e 04 	lds	r25, 0x043E
     d8c:	80 91 0f 06 	lds	r24, 0x060F
     d90:	98 13       	cpse	r25, r24
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <UpdateAudioChannel1+0x54a>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     d94:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     d98:	e0 91 3e 04 	lds	r30, 0x043E
     d9c:	20 91 39 04 	lds	r18, 0x0439
     da0:	30 91 3a 04 	lds	r19, 0x043A
     da4:	40 91 3b 04 	lds	r20, 0x043B
     da8:	50 91 3c 04 	lds	r21, 0x043C
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	ec 53       	subi	r30, 0x3C	; 60
     db0:	fb 4f       	sbci	r31, 0xFB	; 251
     db2:	a0 81       	ld	r26, Z
     db4:	b0 e0       	ldi	r27, 0x00	; 0
     db6:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
     dba:	0f ef       	ldi	r16, 0xFF	; 255
     dbc:	1f ef       	ldi	r17, 0xFF	; 255
     dbe:	27 e0       	ldi	r18, 0x07	; 7
     dc0:	30 e0       	ldi	r19, 0x00	; 0
     dc2:	06 1b       	sub	r16, r22
     dc4:	17 0b       	sbc	r17, r23
     dc6:	28 0b       	sbc	r18, r24
     dc8:	39 0b       	sbc	r19, r25
     dca:	00 93 28 06 	sts	0x0628, r16
     dce:	10 93 29 06 	sts	0x0629, r17
     dd2:	20 93 2a 06 	sts	0x062A, r18
     dd6:	30 93 2b 06 	sts	0x062B, r19
     dda:	cb c0       	rjmp	.+406    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ddc:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     de0:	40 91 28 06 	lds	r20, 0x0628
     de4:	50 91 29 06 	lds	r21, 0x0629
     de8:	60 91 2a 06 	lds	r22, 0x062A
     dec:	70 91 2b 06 	lds	r23, 0x062B
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     df0:	81 11       	cpse	r24, r1
     df2:	5a c0       	rjmp	.+180    	; 0xea8 <UpdateAudioChannel1+0x65a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     df4:	80 91 21 06 	lds	r24, 0x0621
     df8:	90 91 22 06 	lds	r25, 0x0622
     dfc:	a0 91 23 06 	lds	r26, 0x0623
     e00:	b0 91 24 06 	lds	r27, 0x0624
     e04:	48 17       	cp	r20, r24
     e06:	59 07       	cpc	r21, r25
     e08:	6a 07       	cpc	r22, r26
     e0a:	7b 07       	cpc	r23, r27
     e0c:	29 f4       	brne	.+10     	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e0e:	80 91 0a 06 	lds	r24, 0x060A
     e12:	81 30       	cpi	r24, 0x01	; 1
     e14:	09 f4       	brne	.+2      	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e16:	59 c0       	rjmp	.+178    	; 0xeca <UpdateAudioChannel1+0x67c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e18:	40 91 28 06 	lds	r20, 0x0628
     e1c:	50 91 29 06 	lds	r21, 0x0629
     e20:	60 91 2a 06 	lds	r22, 0x062A
     e24:	70 91 2b 06 	lds	r23, 0x062B
     e28:	80 91 21 06 	lds	r24, 0x0621
     e2c:	90 91 22 06 	lds	r25, 0x0622
     e30:	a0 91 23 06 	lds	r26, 0x0623
     e34:	b0 91 24 06 	lds	r27, 0x0624
     e38:	48 17       	cp	r20, r24
     e3a:	59 07       	cpc	r21, r25
     e3c:	6a 07       	cpc	r22, r26
     e3e:	7b 07       	cpc	r23, r27
     e40:	49 f4       	brne	.+18     	; 0xe54 <UpdateAudioChannel1+0x606>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e42:	80 91 1d 06 	lds	r24, 0x061D
     e46:	90 91 1e 06 	lds	r25, 0x061E
     e4a:	a0 91 1f 06 	lds	r26, 0x061F
     e4e:	b0 91 20 06 	lds	r27, 0x0620
     e52:	87 c0       	rjmp	.+270    	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e54:	40 91 28 06 	lds	r20, 0x0628
     e58:	50 91 29 06 	lds	r21, 0x0629
     e5c:	60 91 2a 06 	lds	r22, 0x062A
     e60:	70 91 2b 06 	lds	r23, 0x062B
     e64:	80 91 19 06 	lds	r24, 0x0619
     e68:	90 91 1a 06 	lds	r25, 0x061A
     e6c:	a0 91 1b 06 	lds	r26, 0x061B
     e70:	b0 91 1c 06 	lds	r27, 0x061C
     e74:	48 17       	cp	r20, r24
     e76:	59 07       	cpc	r21, r25
     e78:	6a 07       	cpc	r22, r26
     e7a:	7b 07       	cpc	r23, r27
     e7c:	49 f4       	brne	.+18     	; 0xe90 <UpdateAudioChannel1+0x642>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     e7e:	80 91 15 06 	lds	r24, 0x0615
     e82:	90 91 16 06 	lds	r25, 0x0616
     e86:	a0 91 17 06 	lds	r26, 0x0617
     e8a:	b0 91 18 06 	lds	r27, 0x0618
     e8e:	69 c0       	rjmp	.+210    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     e90:	80 91 28 06 	lds	r24, 0x0628
     e94:	90 91 29 06 	lds	r25, 0x0629
     e98:	a0 91 2a 06 	lds	r26, 0x062A
     e9c:	b0 91 2b 06 	lds	r27, 0x062B
     ea0:	01 96       	adiw	r24, 0x01	; 1
     ea2:	a1 1d       	adc	r26, r1
     ea4:	b1 1d       	adc	r27, r1
     ea6:	5d c0       	rjmp	.+186    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ea8:	80 91 1d 06 	lds	r24, 0x061D
     eac:	90 91 1e 06 	lds	r25, 0x061E
     eb0:	a0 91 1f 06 	lds	r26, 0x061F
     eb4:	b0 91 20 06 	lds	r27, 0x0620
     eb8:	48 17       	cp	r20, r24
     eba:	59 07       	cpc	r21, r25
     ebc:	6a 07       	cpc	r22, r26
     ebe:	7b 07       	cpc	r23, r27
     ec0:	49 f4       	brne	.+18     	; 0xed4 <UpdateAudioChannel1+0x686>
     ec2:	80 91 0a 06 	lds	r24, 0x060A
     ec6:	81 30       	cpi	r24, 0x01	; 1
     ec8:	29 f4       	brne	.+10     	; 0xed4 <UpdateAudioChannel1+0x686>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     eca:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     ece:	10 92 12 06 	sts	0x0612, r1
     ed2:	4f c0       	rjmp	.+158    	; 0xf72 <UpdateAudioChannel1+0x724>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     ed4:	40 91 28 06 	lds	r20, 0x0628
     ed8:	50 91 29 06 	lds	r21, 0x0629
     edc:	60 91 2a 06 	lds	r22, 0x062A
     ee0:	70 91 2b 06 	lds	r23, 0x062B
     ee4:	80 91 1d 06 	lds	r24, 0x061D
     ee8:	90 91 1e 06 	lds	r25, 0x061E
     eec:	a0 91 1f 06 	lds	r26, 0x061F
     ef0:	b0 91 20 06 	lds	r27, 0x0620
     ef4:	48 17       	cp	r20, r24
     ef6:	59 07       	cpc	r21, r25
     ef8:	6a 07       	cpc	r22, r26
     efa:	7b 07       	cpc	r23, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     efe:	80 91 21 06 	lds	r24, 0x0621
     f02:	90 91 22 06 	lds	r25, 0x0622
     f06:	a0 91 23 06 	lds	r26, 0x0623
     f0a:	b0 91 24 06 	lds	r27, 0x0624
     f0e:	29 c0       	rjmp	.+82     	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f10:	40 91 28 06 	lds	r20, 0x0628
     f14:	50 91 29 06 	lds	r21, 0x0629
     f18:	60 91 2a 06 	lds	r22, 0x062A
     f1c:	70 91 2b 06 	lds	r23, 0x062B
     f20:	80 91 15 06 	lds	r24, 0x0615
     f24:	90 91 16 06 	lds	r25, 0x0616
     f28:	a0 91 17 06 	lds	r26, 0x0617
     f2c:	b0 91 18 06 	lds	r27, 0x0618
     f30:	48 17       	cp	r20, r24
     f32:	59 07       	cpc	r21, r25
     f34:	6a 07       	cpc	r22, r26
     f36:	7b 07       	cpc	r23, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f3a:	80 91 19 06 	lds	r24, 0x0619
     f3e:	90 91 1a 06 	lds	r25, 0x061A
     f42:	a0 91 1b 06 	lds	r26, 0x061B
     f46:	b0 91 1c 06 	lds	r27, 0x061C
     f4a:	0b c0       	rjmp	.+22     	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f4c:	80 91 28 06 	lds	r24, 0x0628
     f50:	90 91 29 06 	lds	r25, 0x0629
     f54:	a0 91 2a 06 	lds	r26, 0x062A
     f58:	b0 91 2b 06 	lds	r27, 0x062B
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	a1 09       	sbc	r26, r1
     f60:	b1 09       	sbc	r27, r1
     f62:	80 93 28 06 	sts	0x0628, r24
     f66:	90 93 29 06 	sts	0x0629, r25
     f6a:	a0 93 2a 06 	sts	0x062A, r26
     f6e:	b0 93 2b 06 	sts	0x062B, r27
			}
		}

		// Finished with addy stuff, now finish data transfer

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     f72:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     f74:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     f76:	9f ef       	ldi	r25, 0xFF	; 255
     f78:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     f7a:	90 91 11 06 	lds	r25, 0x0611
     f7e:	99 23       	and	r25, r25
     f80:	61 f0       	breq	.+24     	; 0xf9a <UpdateAudioChannel1+0x74c>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     f82:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     f84:	90 91 11 06 	lds	r25, 0x0611
     f88:	2f ef       	ldi	r18, 0xFF	; 255
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	09 2e       	mov	r0, r25
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <UpdateAudioChannel1+0x744>
     f90:	22 0f       	add	r18, r18
     f92:	0a 94       	dec	r0
     f94:	ea f7       	brpl	.-6      	; 0xf90 <UpdateAudioChannel1+0x742>
     f96:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     f98:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     f9a:	20 91 2c 04 	lds	r18, 0x042C
     f9e:	33 27       	eor	r19, r19
     fa0:	27 fd       	sbrc	r18, 7
     fa2:	30 95       	com	r19
     fa4:	28 0f       	add	r18, r24
     fa6:	31 1d       	adc	r19, r1
     fa8:	87 fd       	sbrc	r24, 7
     faa:	3a 95       	dec	r19
     fac:	20 38       	cpi	r18, 0x80	; 128
     fae:	9f ef       	ldi	r25, 0xFF	; 255
     fb0:	39 07       	cpc	r19, r25
     fb2:	14 f4       	brge	.+4      	; 0xfb8 <UpdateAudioChannel1+0x76a>
     fb4:	20 e8       	ldi	r18, 0x80	; 128
     fb6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     fb8:	20 38       	cpi	r18, 0x80	; 128
     fba:	31 05       	cpc	r19, r1
     fbc:	14 f0       	brlt	.+4      	; 0xfc2 <UpdateAudioChannel1+0x774>
     fbe:	2f e7       	ldi	r18, 0x7F	; 127
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     fc4:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     fc6:	11 9a       	sbi	0x02, 1	; 2
		break;
     fc8:	01 c0       	rjmp	.+2      	; 0xfcc <UpdateAudioChannel1+0x77e>
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     fca:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	08 95       	ret

00000fd2 <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     fd2:	80 91 42 04 	lds	r24, 0x0442
     fd6:	20 91 48 05 	lds	r18, 0x0548
     fda:	33 27       	eor	r19, r19
     fdc:	27 fd       	sbrc	r18, 7
     fde:	30 95       	com	r19
     fe0:	28 0f       	add	r18, r24
     fe2:	31 1d       	adc	r19, r1
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	3a 95       	dec	r19
     fe8:	20 38       	cpi	r18, 0x80	; 128
     fea:	4f ef       	ldi	r20, 0xFF	; 255
     fec:	34 07       	cpc	r19, r20
     fee:	14 f4       	brge	.+4      	; 0xff4 <OutputMultiplyBanks+0x22>
     ff0:	20 e8       	ldi	r18, 0x80	; 128
     ff2:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     ff4:	40 91 45 05 	lds	r20, 0x0545
     ff8:	80 91 4c 05 	lds	r24, 0x054C
     ffc:	99 27       	eor	r25, r25
     ffe:	87 fd       	sbrc	r24, 7
    1000:	90 95       	com	r25
    1002:	84 0f       	add	r24, r20
    1004:	91 1d       	adc	r25, r1
    1006:	47 fd       	sbrc	r20, 7
    1008:	9a 95       	dec	r25
    100a:	81 38       	cpi	r24, 0x81	; 129
    100c:	4f ef       	ldi	r20, 0xFF	; 255
    100e:	94 07       	cpc	r25, r20
    1010:	14 f4       	brge	.+4      	; 0x1016 <OutputMultiplyBanks+0x44>
    1012:	81 e8       	ldi	r24, 0x81	; 129
    1014:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    1016:	20 38       	cpi	r18, 0x80	; 128
    1018:	31 05       	cpc	r19, r1
    101a:	14 f0       	brlt	.+4      	; 0x1020 <OutputMultiplyBanks+0x4e>
    101c:	2f e7       	ldi	r18, 0x7F	; 127
    101e:	30 e0       	ldi	r19, 0x00	; 0
    1020:	80 38       	cpi	r24, 0x80	; 128
    1022:	91 05       	cpc	r25, r1
    1024:	14 f0       	brlt	.+4      	; 0x102a <OutputMultiplyBanks+0x58>
    1026:	8f e7       	ldi	r24, 0x7F	; 127
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	28 9f       	mul	r18, r24
    102c:	a0 01       	movw	r20, r0
    102e:	29 9f       	mul	r18, r25
    1030:	50 0d       	add	r21, r0
    1032:	38 9f       	mul	r19, r24
    1034:	50 0d       	add	r21, r0
    1036:	11 24       	eor	r1, r1
    1038:	57 ff       	sbrs	r21, 7
    103a:	02 c0       	rjmp	.+4      	; 0x1040 <OutputMultiplyBanks+0x6e>
    103c:	41 5c       	subi	r20, 0xC1	; 193
    103e:	5f 4f       	sbci	r21, 0xFF	; 255
    1040:	ca 01       	movw	r24, r20
    1042:	46 e0       	ldi	r20, 0x06	; 6
    1044:	95 95       	asr	r25
    1046:	87 95       	ror	r24
    1048:	4a 95       	dec	r20
    104a:	e1 f7       	brne	.-8      	; 0x1044 <OutputMultiplyBanks+0x72>

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    104c:	80 58       	subi	r24, 0x80	; 128
    104e:	90 95       	com	r25
    1050:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1052:	30 91 69 05 	lds	r19, 0x0569
    1056:	83 17       	cp	r24, r19
    1058:	29 f0       	breq	.+10     	; 0x1064 <OutputMultiplyBanks+0x92>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    105a:	9f ef       	ldi	r25, 0xFF	; 255
    105c:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    105e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1060:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1062:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1064:	20 93 69 05 	sts	0x0569, r18
    1068:	08 95       	ret

0000106a <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC

//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
    106a:	20 91 42 04 	lds	r18, 0x0442
    106e:	80 91 45 05 	lds	r24, 0x0545
    1072:	99 27       	eor	r25, r25
    1074:	87 fd       	sbrc	r24, 7
    1076:	90 95       	com	r25
    1078:	82 0f       	add	r24, r18
    107a:	91 1d       	adc	r25, r1
    107c:	27 fd       	sbrc	r18, 7
    107e:	9a 95       	dec	r25
    1080:	20 91 48 05 	lds	r18, 0x0548
    1084:	82 0f       	add	r24, r18
    1086:	91 1d       	adc	r25, r1
    1088:	27 fd       	sbrc	r18, 7
    108a:	9a 95       	dec	r25
    108c:	20 91 4c 05 	lds	r18, 0x054C
    1090:	82 0f       	add	r24, r18
    1092:	91 1d       	adc	r25, r1
    1094:	27 fd       	sbrc	r18, 7
    1096:	9a 95       	dec	r25
    1098:	20 91 55 05 	lds	r18, 0x0555
    109c:	82 0f       	add	r24, r18
    109e:	91 1d       	adc	r25, r1
    10a0:	27 fd       	sbrc	r18, 7
    10a2:	9a 95       	dec	r25
    10a4:	80 38       	cpi	r24, 0x80	; 128
    10a6:	2f ef       	ldi	r18, 0xFF	; 255
    10a8:	92 07       	cpc	r25, r18
    10aa:	14 f4       	brge	.+4      	; 0x10b0 <OutputAddBanks+0x46>
    10ac:	80 e8       	ldi	r24, 0x80	; 128
    10ae:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10b0:	80 38       	cpi	r24, 0x80	; 128
    10b2:	91 05       	cpc	r25, r1
    10b4:	14 f0       	brlt	.+4      	; 0x10ba <OutputAddBanks+0x50>
    10b6:	8f e7       	ldi	r24, 0x7F	; 127
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	80 58       	subi	r24, 0x80	; 128
    10bc:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    10be:	30 91 69 05 	lds	r19, 0x0569
    10c2:	83 17       	cp	r24, r19
    10c4:	29 f0       	breq	.+10     	; 0x10d0 <OutputAddBanks+0x66>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    10c6:	9f ef       	ldi	r25, 0xFF	; 255
    10c8:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    10ca:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    10cc:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    10ce:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    10d0:	20 93 69 05 	sts	0x0569, r18
    10d4:	08 95       	ret

000010d6 <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    10d6:	20 91 42 04 	lds	r18, 0x0442
    10da:	80 91 48 05 	lds	r24, 0x0548
    10de:	99 27       	eor	r25, r25
    10e0:	87 fd       	sbrc	r24, 7
    10e2:	90 95       	com	r25
    10e4:	82 0f       	add	r24, r18
    10e6:	91 1d       	adc	r25, r1
    10e8:	27 fd       	sbrc	r18, 7
    10ea:	9a 95       	dec	r25
    10ec:	80 38       	cpi	r24, 0x80	; 128
    10ee:	2f ef       	ldi	r18, 0xFF	; 255
    10f0:	92 07       	cpc	r25, r18
    10f2:	14 f4       	brge	.+4      	; 0x10f8 <OutputXorBanks+0x22>
    10f4:	80 e8       	ldi	r24, 0x80	; 128
    10f6:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    10f8:	40 91 45 05 	lds	r20, 0x0545
    10fc:	20 91 4c 05 	lds	r18, 0x054C
    1100:	33 27       	eor	r19, r19
    1102:	27 fd       	sbrc	r18, 7
    1104:	30 95       	com	r19
    1106:	24 0f       	add	r18, r20
    1108:	31 1d       	adc	r19, r1
    110a:	47 fd       	sbrc	r20, 7
    110c:	3a 95       	dec	r19
    110e:	20 38       	cpi	r18, 0x80	; 128
    1110:	4f ef       	ldi	r20, 0xFF	; 255
    1112:	34 07       	cpc	r19, r20
    1114:	14 f4       	brge	.+4      	; 0x111a <__stack+0x1b>
    1116:	20 e8       	ldi	r18, 0x80	; 128
    1118:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.
    111a:	20 38       	cpi	r18, 0x80	; 128
    111c:	31 05       	cpc	r19, r1
    111e:	14 f0       	brlt	.+4      	; 0x1124 <__stack+0x25>
    1120:	2f e7       	ldi	r18, 0x7F	; 127
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	20 58       	subi	r18, 0x80	; 128
    1126:	30 95       	com	r19
    1128:	80 38       	cpi	r24, 0x80	; 128
    112a:	91 05       	cpc	r25, r1
    112c:	14 f0       	brlt	.+4      	; 0x1132 <__stack+0x33>
    112e:	8f e7       	ldi	r24, 0x7F	; 127
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	80 58       	subi	r24, 0x80	; 128
    1134:	90 95       	com	r25
    1136:	82 27       	eor	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1138:	90 91 69 05 	lds	r25, 0x0569
    113c:	89 17       	cp	r24, r25
    113e:	29 f0       	breq	.+10     	; 0x114a <__stack+0x4b>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1140:	9f ef       	ldi	r25, 0xFF	; 255
    1142:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1144:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1146:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1148:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    114a:	80 93 69 05 	sts	0x0569, r24
    114e:	08 95       	ret

00001150 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1150:	20 91 42 04 	lds	r18, 0x0442
    1154:	80 91 48 05 	lds	r24, 0x0548
    1158:	99 27       	eor	r25, r25
    115a:	87 fd       	sbrc	r24, 7
    115c:	90 95       	com	r25
    115e:	82 0f       	add	r24, r18
    1160:	91 1d       	adc	r25, r1
    1162:	27 fd       	sbrc	r18, 7
    1164:	9a 95       	dec	r25
    1166:	80 38       	cpi	r24, 0x80	; 128
    1168:	2f ef       	ldi	r18, 0xFF	; 255
    116a:	92 07       	cpc	r25, r18
    116c:	14 f4       	brge	.+4      	; 0x1172 <OutputAndBanks+0x22>
    116e:	80 e8       	ldi	r24, 0x80	; 128
    1170:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1172:	40 91 45 05 	lds	r20, 0x0545
    1176:	20 91 4c 05 	lds	r18, 0x054C
    117a:	33 27       	eor	r19, r19
    117c:	27 fd       	sbrc	r18, 7
    117e:	30 95       	com	r19
    1180:	24 0f       	add	r18, r20
    1182:	31 1d       	adc	r19, r1
    1184:	47 fd       	sbrc	r20, 7
    1186:	3a 95       	dec	r19
    1188:	20 38       	cpi	r18, 0x80	; 128
    118a:	4f ef       	ldi	r20, 0xFF	; 255
    118c:	34 07       	cpc	r19, r20
    118e:	14 f4       	brge	.+4      	; 0x1194 <OutputAndBanks+0x44>
    1190:	20 e8       	ldi	r18, 0x80	; 128
    1192:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.
    1194:	20 38       	cpi	r18, 0x80	; 128
    1196:	31 05       	cpc	r19, r1
    1198:	14 f0       	brlt	.+4      	; 0x119e <OutputAndBanks+0x4e>
    119a:	2f e7       	ldi	r18, 0x7F	; 127
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	20 58       	subi	r18, 0x80	; 128
    11a0:	30 95       	com	r19
    11a2:	80 38       	cpi	r24, 0x80	; 128
    11a4:	91 05       	cpc	r25, r1
    11a6:	14 f0       	brlt	.+4      	; 0x11ac <OutputAndBanks+0x5c>
    11a8:	8f e7       	ldi	r24, 0x7F	; 127
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	80 58       	subi	r24, 0x80	; 128
    11ae:	90 95       	com	r25
    11b0:	82 23       	and	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11b2:	90 91 69 05 	lds	r25, 0x0569
    11b6:	89 17       	cp	r24, r25
    11b8:	29 f0       	breq	.+10     	; 0x11c4 <OutputAndBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    11ba:	9f ef       	ldi	r25, 0xFF	; 255
    11bc:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    11be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    11c0:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    11c2:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    11c4:	80 93 69 05 	sts	0x0569, r24
    11c8:	08 95       	ret

000011ca <WriteLedLatch>:
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    11ca:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    11cc:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    11ce:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	84 b9       	out	0x04, r24	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    11d4:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    11d6:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    11d8:	9f bf       	out	0x3f, r25	; 63
    11da:	08 95       	ret

000011dc <SdIsrStartStreamingAudio>:
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;

	sreg=SREG;
    11dc:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    11de:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    11e0:	83 e0       	ldi	r24, 0x03	; 3
    11e2:	80 93 4f 05 	sts	0x054F, r24

	TCNT2=0;			// Init counter reg
    11e6:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
    11ea:	81 e7       	ldi	r24, 0x71	; 113
    11ec:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    11f0:	8f ef       	ldi	r24, 0xFF	; 255
    11f2:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    11f4:	e0 e7       	ldi	r30, 0x70	; 112
    11f6:	f0 e0       	ldi	r31, 0x00	; 0
    11f8:	80 81       	ld	r24, Z
    11fa:	84 60       	ori	r24, 0x04	; 4
    11fc:	80 83       	st	Z, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    11fe:	82 e0       	ldi	r24, 0x02	; 2
    1200:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    1204:	9f bf       	out	0x3f, r25	; 63
    1206:	08 95       	ret

00001208 <GetRandomLongInt>:
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1208:	40 91 00 01 	lds	r20, 0x0100
    120c:	50 91 01 01 	lds	r21, 0x0101
    1210:	60 91 02 01 	lds	r22, 0x0102
    1214:	70 91 03 01 	lds	r23, 0x0103
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1218:	db 01       	movw	r26, r22
    121a:	ca 01       	movw	r24, r20
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	aa 1f       	adc	r26, r26
    1222:	bb 1f       	adc	r27, r27
    1224:	76 ff       	sbrs	r23, 6
    1226:	08 c0       	rjmp	.+16     	; 0x1238 <GetRandomLongInt+0x30>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1228:	25 eb       	ldi	r18, 0xB5	; 181
    122a:	82 27       	eor	r24, r18
    122c:	25 e9       	ldi	r18, 0x95	; 149
    122e:	92 27       	eor	r25, r18
    1230:	2a ea       	ldi	r18, 0xAA	; 170
    1232:	a2 27       	eor	r26, r18
    1234:	20 e2       	ldi	r18, 0x20	; 32
    1236:	b2 27       	eor	r27, r18
    1238:	80 93 00 01 	sts	0x0100, r24
    123c:	90 93 01 01 	sts	0x0101, r25
    1240:	a0 93 02 01 	sts	0x0102, r26
    1244:	b0 93 03 01 	sts	0x0103, r27
	}
	return(random31);
    1248:	60 91 00 01 	lds	r22, 0x0100
    124c:	70 91 01 01 	lds	r23, 0x0101
}
    1250:	80 91 02 01 	lds	r24, 0x0102
    1254:	90 91 03 01 	lds	r25, 0x0103
    1258:	08 95       	ret

0000125a <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM.
{
    125a:	2f 92       	push	r2
    125c:	3f 92       	push	r3
    125e:	4f 92       	push	r4
    1260:	5f 92       	push	r5
    1262:	6f 92       	push	r6
    1264:	7f 92       	push	r7
    1266:	8f 92       	push	r8
    1268:	9f 92       	push	r9
    126a:	af 92       	push	r10
    126c:	bf 92       	push	r11
    126e:	cf 92       	push	r12
    1270:	df 92       	push	r13
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	38 2e       	mov	r3, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    1280:	62 30       	cpi	r22, 0x02	; 2
    1282:	08 f4       	brcc	.+2      	; 0x1286 <MakeNewGranularArray+0x2c>
    1284:	cd c0       	rjmp	.+410    	; 0x1420 <MakeNewGranularArray+0x1c6>
	{
		sreg=SREG;
    1286:	9f b6       	in	r9, 0x3f	; 63
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    1288:	f8 94       	cli
    128a:	86 2e       	mov	r8, r22
    128c:	80 e8       	ldi	r24, 0x80	; 128
    128e:	86 17       	cp	r24, r22
    1290:	10 f4       	brcc	.+4      	; 0x1296 <MakeNewGranularArray+0x3c>
    1292:	00 e8       	ldi	r16, 0x80	; 128
    1294:	80 2e       	mov	r8, r16
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    1296:	c3 2d       	mov	r28, r3
    1298:	d0 e0       	ldi	r29, 0x00	; 0
    129a:	9e 01       	movw	r18, r28
    129c:	36 95       	lsr	r19
    129e:	32 2f       	mov	r19, r18
    12a0:	22 27       	eor	r18, r18
    12a2:	37 95       	ror	r19
    12a4:	27 95       	ror	r18
    12a6:	2c 5b       	subi	r18, 0xBC	; 188
    12a8:	3b 4f       	sbci	r19, 0xFB	; 251
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	f9 01       	movw	r30, r18
    12b0:	e8 0f       	add	r30, r24
    12b2:	f9 1f       	adc	r31, r25
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    12b4:	80 83       	st	Z, r24
    12b6:	01 96       	adiw	r24, 0x01	; 1
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    12b8:	88 15       	cp	r24, r8
    12ba:	c8 f3       	brcs	.-14     	; 0x12ae <MakeNewGranularArray+0x54>
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12bc:	6e 01       	movw	r12, r28
    12be:	d6 94       	lsr	r13
    12c0:	dc 2c       	mov	r13, r12
    12c2:	cc 24       	eor	r12, r12
    12c4:	d7 94       	ror	r13
    12c6:	c7 94       	ror	r12
    12c8:	b4 e4       	ldi	r27, 0x44	; 68
    12ca:	ab 2e       	mov	r10, r27
    12cc:	b4 e0       	ldi	r27, 0x04	; 4
    12ce:	bb 2e       	mov	r11, r27
    12d0:	ac 0c       	add	r10, r12
    12d2:	bd 1c       	adc	r11, r13
    12d4:	00 e0       	ldi	r16, 0x00	; 0
    12d6:	10 e0       	ldi	r17, 0x00	; 0
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    12d8:	48 2c       	mov	r4, r8
    12da:	51 2c       	mov	r5, r1
    12dc:	61 2c       	mov	r6, r1
    12de:	71 2c       	mov	r7, r1
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12e0:	75 01       	movw	r14, r10
    12e2:	e0 0e       	add	r14, r16
    12e4:	f1 1e       	adc	r15, r17
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    12e6:	d7 01       	movw	r26, r14
    12e8:	2c 90       	ld	r2, X
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    12ea:	0e 94 04 09 	call	0x1208	; 0x1208 <GetRandomLongInt>
    12ee:	a3 01       	movw	r20, r6
    12f0:	92 01       	movw	r18, r4
    12f2:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    12f6:	fb 01       	movw	r30, r22
    12f8:	ec 0d       	add	r30, r12
    12fa:	fd 1d       	adc	r31, r13
    12fc:	ec 5b       	subi	r30, 0xBC	; 188
    12fe:	fb 4f       	sbci	r31, 0xFB	; 251
    1300:	80 81       	ld	r24, Z
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1302:	d7 01       	movw	r26, r14
    1304:	8c 93       	st	X, r24
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1306:	20 82       	st	Z, r2
    1308:	0f 5f       	subi	r16, 0xFF	; 255
    130a:	1f 4f       	sbci	r17, 0xFF	; 255
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    130c:	08 15       	cp	r16, r8
    130e:	40 f3       	brcs	.-48     	; 0x12e0 <MakeNewGranularArray+0x86>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1310:	31 10       	cpse	r3, r1
    1312:	15 c0       	rjmp	.+42     	; 0x133e <MakeNewGranularArray+0xe4>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1314:	60 91 f2 05 	lds	r22, 0x05F2
    1318:	70 91 f3 05 	lds	r23, 0x05F3
    131c:	80 91 f4 05 	lds	r24, 0x05F4
    1320:	90 91 f5 05 	lds	r25, 0x05F5
    1324:	a3 01       	movw	r20, r6
    1326:	92 01       	movw	r18, r4
    1328:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
    132c:	20 93 35 04 	sts	0x0435, r18
    1330:	30 93 36 04 	sts	0x0436, r19
    1334:	40 93 37 04 	sts	0x0437, r20
    1338:	50 93 38 04 	sts	0x0438, r21
    133c:	1c c0       	rjmp	.+56     	; 0x1376 <MakeNewGranularArray+0x11c>
		}
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
    133e:	00 91 15 06 	lds	r16, 0x0615
    1342:	10 91 16 06 	lds	r17, 0x0616
    1346:	20 91 17 06 	lds	r18, 0x0617
    134a:	30 91 18 06 	lds	r19, 0x0618
    134e:	6f ef       	ldi	r22, 0xFF	; 255
    1350:	7f ef       	ldi	r23, 0xFF	; 255
    1352:	87 e0       	ldi	r24, 0x07	; 7
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	60 1b       	sub	r22, r16
    1358:	71 0b       	sbc	r23, r17
    135a:	82 0b       	sbc	r24, r18
    135c:	93 0b       	sbc	r25, r19
    135e:	a3 01       	movw	r20, r6
    1360:	92 01       	movw	r18, r4
    1362:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
    1366:	20 93 39 04 	sts	0x0439, r18
    136a:	30 93 3a 04 	sts	0x043A, r19
    136e:	40 93 3b 04 	sts	0x043B, r20
    1372:	50 93 3c 04 	sts	0x043C, r21
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1376:	83 e2       	ldi	r24, 0x23	; 35
    1378:	8c 9f       	mul	r24, r28
    137a:	f0 01       	movw	r30, r0
    137c:	8d 9f       	mul	r24, r29
    137e:	f0 0d       	add	r31, r0
    1380:	11 24       	eor	r1, r1
    1382:	ea 51       	subi	r30, 0x1A	; 26
    1384:	fa 4f       	sbci	r31, 0xFA	; 250
    1386:	86 82       	std	Z+6, r8	; 0x06
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1388:	fe 01       	movw	r30, r28
    138a:	e3 5c       	subi	r30, 0xC3	; 195
    138c:	fb 4f       	sbci	r31, 0xFB	; 251
    138e:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1390:	cc 0f       	add	r28, r28
    1392:	dd 1f       	adc	r29, r29
    1394:	cc 0f       	add	r28, r28
    1396:	dd 1f       	adc	r29, r29
    1398:	fe 01       	movw	r30, r28
    139a:	eb 5c       	subi	r30, 0xCB	; 203
    139c:	fb 4f       	sbci	r31, 0xFB	; 251
    139e:	80 81       	ld	r24, Z
    13a0:	91 81       	ldd	r25, Z+1	; 0x01
    13a2:	a2 81       	ldd	r26, Z+2	; 0x02
    13a4:	b3 81       	ldd	r27, Z+3	; 0x03
    13a6:	c3 5d       	subi	r28, 0xD3	; 211
    13a8:	db 4f       	sbci	r29, 0xFB	; 251
    13aa:	88 83       	st	Y, r24
    13ac:	99 83       	std	Y+1, r25	; 0x01
    13ae:	aa 83       	std	Y+2, r26	; 0x02
    13b0:	bb 83       	std	Y+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    13b2:	31 10       	cpse	r3, r1
    13b4:	16 c0       	rjmp	.+44     	; 0x13e2 <MakeNewGranularArray+0x188>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    13b6:	20 91 35 04 	lds	r18, 0x0435
    13ba:	30 91 36 04 	lds	r19, 0x0436
    13be:	40 91 37 04 	lds	r20, 0x0437
    13c2:	50 91 38 04 	lds	r21, 0x0438
    13c6:	a0 91 44 04 	lds	r26, 0x0444
    13ca:	b0 e0       	ldi	r27, 0x00	; 0
    13cc:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    13d0:	60 93 05 06 	sts	0x0605, r22
    13d4:	70 93 06 06 	sts	0x0606, r23
    13d8:	80 93 07 06 	sts	0x0607, r24
    13dc:	90 93 08 06 	sts	0x0608, r25
    13e0:	1d c0       	rjmp	.+58     	; 0x141c <MakeNewGranularArray+0x1c2>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));
    13e2:	20 91 39 04 	lds	r18, 0x0439
    13e6:	30 91 3a 04 	lds	r19, 0x043A
    13ea:	40 91 3b 04 	lds	r20, 0x043B
    13ee:	50 91 3c 04 	lds	r21, 0x043C
    13f2:	a0 91 c4 04 	lds	r26, 0x04C4
    13f6:	b0 e0       	ldi	r27, 0x00	; 0
    13f8:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    13fc:	0f ef       	ldi	r16, 0xFF	; 255
    13fe:	1f ef       	ldi	r17, 0xFF	; 255
    1400:	27 e0       	ldi	r18, 0x07	; 7
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	06 1b       	sub	r16, r22
    1406:	17 0b       	sbc	r17, r23
    1408:	28 0b       	sbc	r18, r24
    140a:	39 0b       	sbc	r19, r25
    140c:	00 93 28 06 	sts	0x0628, r16
    1410:	10 93 29 06 	sts	0x0629, r17
    1414:	20 93 2a 06 	sts	0x062A, r18
    1418:	30 93 2b 06 	sts	0x062B, r19
		}

		SREG=sreg;		// Restore interrupts.
    141c:	9f be       	out	0x3f, r9	; 63
    141e:	07 c0       	rjmp	.+14     	; 0x142e <MakeNewGranularArray+0x1d4>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
    1420:	b3 e2       	ldi	r27, 0x23	; 35
    1422:	8b 9f       	mul	r24, r27
    1424:	f0 01       	movw	r30, r0
    1426:	11 24       	eor	r1, r1
    1428:	ea 51       	subi	r30, 0x1A	; 26
    142a:	fa 4f       	sbci	r31, 0xFA	; 250
    142c:	16 82       	std	Z+6, r1	; 0x06
	}
}
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	ff 90       	pop	r15
    1438:	ef 90       	pop	r14
    143a:	df 90       	pop	r13
    143c:	cf 90       	pop	r12
    143e:	bf 90       	pop	r11
    1440:	af 90       	pop	r10
    1442:	9f 90       	pop	r9
    1444:	8f 90       	pop	r8
    1446:	7f 90       	pop	r7
    1448:	6f 90       	pop	r6
    144a:	5f 90       	pop	r5
    144c:	4f 90       	pop	r4
    144e:	3f 90       	pop	r3
    1450:	2f 90       	pop	r2
    1452:	08 95       	ret

00001454 <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    1454:	4f 92       	push	r4
    1456:	5f 92       	push	r5
    1458:	6f 92       	push	r6
    145a:	7f 92       	push	r7
    145c:	8f 92       	push	r8
    145e:	9f 92       	push	r9
    1460:	af 92       	push	r10
    1462:	bf 92       	push	r11
    1464:	cf 92       	push	r12
    1466:	df 92       	push	r13
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
	unsigned char
		sreg;
	unsigned long
		chunkSize;

	sreg=SREG;
    146c:	ef b7       	in	r30, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    146e:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1470:	81 11       	cpse	r24, r1
    1472:	e9 c1       	rjmp	.+978    	; 0x1846 <UpdateAdjustedSampleAddresses+0x3f2>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1474:	80 90 f2 05 	lds	r8, 0x05F2
    1478:	90 90 f3 05 	lds	r9, 0x05F3
    147c:	a0 90 f4 05 	lds	r10, 0x05F4
    1480:	b0 90 f5 05 	lds	r11, 0x05F5
    1484:	83 e0       	ldi	r24, 0x03	; 3
    1486:	88 0c       	add	r8, r8
    1488:	99 1c       	adc	r9, r9
    148a:	aa 1c       	adc	r10, r10
    148c:	bb 1c       	adc	r11, r11
    148e:	8a 95       	dec	r24
    1490:	d1 f7       	brne	.-12     	; 0x1486 <UpdateAdjustedSampleAddresses+0x32>
    1492:	89 2c       	mov	r8, r9
    1494:	9a 2c       	mov	r9, r10
    1496:	ab 2c       	mov	r10, r11
    1498:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    149a:	a0 91 02 06 	lds	r26, 0x0602
    149e:	80 91 04 06 	lds	r24, 0x0604
    14a2:	b0 e0       	ldi	r27, 0x00	; 0
    14a4:	a8 0f       	add	r26, r24
    14a6:	b1 1d       	adc	r27, r1
    14a8:	a5 01       	movw	r20, r10
    14aa:	94 01       	movw	r18, r8
    14ac:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    14b0:	f3 e0       	ldi	r31, 0x03	; 3
    14b2:	96 95       	lsr	r25
    14b4:	87 95       	ror	r24
    14b6:	77 95       	ror	r23
    14b8:	67 95       	ror	r22
    14ba:	fa 95       	dec	r31
    14bc:	d1 f7       	brne	.-12     	; 0x14b2 <UpdateAdjustedSampleAddresses+0x5e>
    14be:	60 93 fe 05 	sts	0x05FE, r22
    14c2:	70 93 ff 05 	sts	0x05FF, r23
    14c6:	80 93 00 06 	sts	0x0600, r24
    14ca:	90 93 01 06 	sts	0x0601, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    14ce:	40 90 f2 05 	lds	r4, 0x05F2
    14d2:	50 90 f3 05 	lds	r5, 0x05F3
    14d6:	60 90 f4 05 	lds	r6, 0x05F4
    14da:	70 90 f5 05 	lds	r7, 0x05F5
    14de:	f0 91 03 06 	lds	r31, 0x0603
    14e2:	a0 91 04 06 	lds	r26, 0x0604
    14e6:	b0 e0       	ldi	r27, 0x00	; 0
    14e8:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    14ec:	6b 01       	movw	r12, r22
    14ee:	7c 01       	movw	r14, r24
    14f0:	a3 e0       	ldi	r26, 0x03	; 3
    14f2:	f6 94       	lsr	r15
    14f4:	e7 94       	ror	r14
    14f6:	d7 94       	ror	r13
    14f8:	c7 94       	ror	r12
    14fa:	aa 95       	dec	r26
    14fc:	d1 f7       	brne	.-12     	; 0x14f2 <UpdateAdjustedSampleAddresses+0x9e>
    14fe:	c4 0c       	add	r12, r4
    1500:	d5 1c       	adc	r13, r5
    1502:	e6 1c       	adc	r14, r6
    1504:	f7 1c       	adc	r15, r7
    1506:	af 2f       	mov	r26, r31
    1508:	b0 e0       	ldi	r27, 0x00	; 0
    150a:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    150e:	b3 e0       	ldi	r27, 0x03	; 3
    1510:	96 95       	lsr	r25
    1512:	87 95       	ror	r24
    1514:	77 95       	ror	r23
    1516:	67 95       	ror	r22
    1518:	ba 95       	dec	r27
    151a:	d1 f7       	brne	.-12     	; 0x1510 <UpdateAdjustedSampleAddresses+0xbc>
    151c:	c6 1a       	sub	r12, r22
    151e:	d7 0a       	sbc	r13, r23
    1520:	e8 0a       	sbc	r14, r24
    1522:	f9 0a       	sbc	r15, r25
    1524:	c0 92 fa 05 	sts	0x05FA, r12
    1528:	d0 92 fb 05 	sts	0x05FB, r13
    152c:	e0 92 fc 05 	sts	0x05FC, r14
    1530:	f0 92 fd 05 	sts	0x05FD, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1534:	40 91 fe 05 	lds	r20, 0x05FE
    1538:	50 91 ff 05 	lds	r21, 0x05FF
    153c:	60 91 00 06 	lds	r22, 0x0600
    1540:	70 91 01 06 	lds	r23, 0x0601
    1544:	80 91 fa 05 	lds	r24, 0x05FA
    1548:	90 91 fb 05 	lds	r25, 0x05FB
    154c:	a0 91 fc 05 	lds	r26, 0x05FC
    1550:	b0 91 fd 05 	lds	r27, 0x05FD
    1554:	84 17       	cp	r24, r20
    1556:	95 07       	cpc	r25, r21
    1558:	a6 07       	cpc	r26, r22
    155a:	b7 07       	cpc	r27, r23
    155c:	50 f5       	brcc	.+84     	; 0x15b2 <UpdateAdjustedSampleAddresses+0x15e>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    155e:	80 91 e9 05 	lds	r24, 0x05E9
    1562:	81 30       	cpi	r24, 0x01	; 1
    1564:	19 f4       	brne	.+6      	; 0x156c <UpdateAdjustedSampleAddresses+0x118>
			{
				bankStates[BANK_0].sampleDirection=true;
    1566:	80 93 ea 05 	sts	0x05EA, r24
    156a:	02 c0       	rjmp	.+4      	; 0x1570 <UpdateAdjustedSampleAddresses+0x11c>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    156c:	10 92 ea 05 	sts	0x05EA, r1
			}

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    1570:	80 91 fe 05 	lds	r24, 0x05FE
    1574:	90 91 ff 05 	lds	r25, 0x05FF
    1578:	a0 91 00 06 	lds	r26, 0x0600
    157c:	b0 91 01 06 	lds	r27, 0x0601
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    1580:	40 91 fa 05 	lds	r20, 0x05FA
    1584:	50 91 fb 05 	lds	r21, 0x05FB
    1588:	60 91 fc 05 	lds	r22, 0x05FC
    158c:	70 91 fd 05 	lds	r23, 0x05FD
    1590:	40 93 fe 05 	sts	0x05FE, r20
    1594:	50 93 ff 05 	sts	0x05FF, r21
    1598:	60 93 00 06 	sts	0x0600, r22
    159c:	70 93 01 06 	sts	0x0601, r23
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    15a0:	80 93 fa 05 	sts	0x05FA, r24
    15a4:	90 93 fb 05 	sts	0x05FB, r25
    15a8:	a0 93 fc 05 	sts	0x05FC, r26
    15ac:	b0 93 fd 05 	sts	0x05FD, r27
    15b0:	0a c0       	rjmp	.+20     	; 0x15c6 <UpdateAdjustedSampleAddresses+0x172>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    15b2:	80 91 e9 05 	lds	r24, 0x05E9
    15b6:	81 30       	cpi	r24, 0x01	; 1
    15b8:	19 f4       	brne	.+6      	; 0x15c0 <UpdateAdjustedSampleAddresses+0x16c>
			{
				bankStates[BANK_0].sampleDirection=false;
    15ba:	10 92 ea 05 	sts	0x05EA, r1
    15be:	03 c0       	rjmp	.+6      	; 0x15c6 <UpdateAdjustedSampleAddresses+0x172>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	80 93 ea 05 	sts	0x05EA, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    15c6:	40 91 fe 05 	lds	r20, 0x05FE
    15ca:	50 91 ff 05 	lds	r21, 0x05FF
    15ce:	60 91 00 06 	lds	r22, 0x0600
    15d2:	70 91 01 06 	lds	r23, 0x0601
    15d6:	80 91 f2 05 	lds	r24, 0x05F2
    15da:	90 91 f3 05 	lds	r25, 0x05F3
    15de:	a0 91 f4 05 	lds	r26, 0x05F4
    15e2:	b0 91 f5 05 	lds	r27, 0x05F5
    15e6:	84 17       	cp	r24, r20
    15e8:	95 07       	cpc	r25, r21
    15ea:	a6 07       	cpc	r26, r22
    15ec:	b7 07       	cpc	r27, r23
    15ee:	e0 f4       	brcc	.+56     	; 0x1628 <UpdateAdjustedSampleAddresses+0x1d4>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    15f0:	80 91 fe 05 	lds	r24, 0x05FE
    15f4:	90 91 ff 05 	lds	r25, 0x05FF
    15f8:	a0 91 00 06 	lds	r26, 0x0600
    15fc:	b0 91 01 06 	lds	r27, 0x0601
    1600:	40 91 f2 05 	lds	r20, 0x05F2
    1604:	50 91 f3 05 	lds	r21, 0x05F3
    1608:	60 91 f4 05 	lds	r22, 0x05F4
    160c:	70 91 f5 05 	lds	r23, 0x05F5
    1610:	84 1b       	sub	r24, r20
    1612:	95 0b       	sbc	r25, r21
    1614:	a6 0b       	sbc	r26, r22
    1616:	b7 0b       	sbc	r27, r23
    1618:	80 93 fe 05 	sts	0x05FE, r24
    161c:	90 93 ff 05 	sts	0x05FF, r25
    1620:	a0 93 00 06 	sts	0x0600, r26
    1624:	b0 93 01 06 	sts	0x0601, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    1628:	40 91 fa 05 	lds	r20, 0x05FA
    162c:	50 91 fb 05 	lds	r21, 0x05FB
    1630:	60 91 fc 05 	lds	r22, 0x05FC
    1634:	70 91 fd 05 	lds	r23, 0x05FD
    1638:	80 91 f2 05 	lds	r24, 0x05F2
    163c:	90 91 f3 05 	lds	r25, 0x05F3
    1640:	a0 91 f4 05 	lds	r26, 0x05F4
    1644:	b0 91 f5 05 	lds	r27, 0x05F5
    1648:	84 17       	cp	r24, r20
    164a:	95 07       	cpc	r25, r21
    164c:	a6 07       	cpc	r26, r22
    164e:	b7 07       	cpc	r27, r23
    1650:	08 f0       	brcs	.+2      	; 0x1654 <UpdateAdjustedSampleAddresses+0x200>
    1652:	44 c0       	rjmp	.+136    	; 0x16dc <UpdateAdjustedSampleAddresses+0x288>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1654:	80 91 fa 05 	lds	r24, 0x05FA
    1658:	90 91 fb 05 	lds	r25, 0x05FB
    165c:	a0 91 fc 05 	lds	r26, 0x05FC
    1660:	b0 91 fd 05 	lds	r27, 0x05FD
    1664:	40 91 f2 05 	lds	r20, 0x05F2
    1668:	50 91 f3 05 	lds	r21, 0x05F3
    166c:	60 91 f4 05 	lds	r22, 0x05F4
    1670:	70 91 f5 05 	lds	r23, 0x05F5
    1674:	84 1b       	sub	r24, r20
    1676:	95 0b       	sbc	r25, r21
    1678:	a6 0b       	sbc	r26, r22
    167a:	b7 0b       	sbc	r27, r23
    167c:	80 93 fa 05 	sts	0x05FA, r24
    1680:	90 93 fb 05 	sts	0x05FB, r25
    1684:	a0 93 fc 05 	sts	0x05FC, r26
    1688:	b0 93 fd 05 	sts	0x05FD, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    168c:	40 91 fa 05 	lds	r20, 0x05FA
    1690:	50 91 fb 05 	lds	r21, 0x05FB
    1694:	60 91 fc 05 	lds	r22, 0x05FC
    1698:	70 91 fd 05 	lds	r23, 0x05FD
    169c:	80 91 fe 05 	lds	r24, 0x05FE
    16a0:	90 91 ff 05 	lds	r25, 0x05FF
    16a4:	a0 91 00 06 	lds	r26, 0x0600
    16a8:	b0 91 01 06 	lds	r27, 0x0601
    16ac:	48 17       	cp	r20, r24
    16ae:	59 07       	cpc	r21, r25
    16b0:	6a 07       	cpc	r22, r26
    16b2:	7b 07       	cpc	r23, r27
    16b4:	99 f4       	brne	.+38     	; 0x16dc <UpdateAdjustedSampleAddresses+0x288>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    16b6:	80 91 fa 05 	lds	r24, 0x05FA
    16ba:	90 91 fb 05 	lds	r25, 0x05FB
    16be:	a0 91 fc 05 	lds	r26, 0x05FC
    16c2:	b0 91 fd 05 	lds	r27, 0x05FD
    16c6:	01 97       	sbiw	r24, 0x01	; 1
    16c8:	a1 09       	sbc	r26, r1
    16ca:	b1 09       	sbc	r27, r1
    16cc:	80 93 fa 05 	sts	0x05FA, r24
    16d0:	90 93 fb 05 	sts	0x05FB, r25
    16d4:	a0 93 fc 05 	sts	0x05FC, r26
    16d8:	b0 93 fd 05 	sts	0x05FD, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    16dc:	40 91 fe 05 	lds	r20, 0x05FE
    16e0:	50 91 ff 05 	lds	r21, 0x05FF
    16e4:	60 91 00 06 	lds	r22, 0x0600
    16e8:	70 91 01 06 	lds	r23, 0x0601
    16ec:	80 91 fa 05 	lds	r24, 0x05FA
    16f0:	90 91 fb 05 	lds	r25, 0x05FB
    16f4:	a0 91 fc 05 	lds	r26, 0x05FC
    16f8:	b0 91 fd 05 	lds	r27, 0x05FD
    16fc:	84 17       	cp	r24, r20
    16fe:	95 07       	cpc	r25, r21
    1700:	a6 07       	cpc	r26, r22
    1702:	b7 07       	cpc	r27, r23
    1704:	08 f0       	brcs	.+2      	; 0x1708 <UpdateAdjustedSampleAddresses+0x2b4>
    1706:	5a c0       	rjmp	.+180    	; 0x17bc <UpdateAdjustedSampleAddresses+0x368>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1708:	40 91 05 06 	lds	r20, 0x0605
    170c:	50 91 06 06 	lds	r21, 0x0606
    1710:	60 91 07 06 	lds	r22, 0x0607
    1714:	70 91 08 06 	lds	r23, 0x0608
    1718:	80 91 fe 05 	lds	r24, 0x05FE
    171c:	90 91 ff 05 	lds	r25, 0x05FF
    1720:	a0 91 00 06 	lds	r26, 0x0600
    1724:	b0 91 01 06 	lds	r27, 0x0601
    1728:	48 17       	cp	r20, r24
    172a:	59 07       	cpc	r21, r25
    172c:	6a 07       	cpc	r22, r26
    172e:	7b 07       	cpc	r23, r27
    1730:	08 f0       	brcs	.+2      	; 0x1734 <UpdateAdjustedSampleAddresses+0x2e0>
    1732:	86 c2       	rjmp	.+1292   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
    1734:	40 91 05 06 	lds	r20, 0x0605
    1738:	50 91 06 06 	lds	r21, 0x0606
    173c:	60 91 07 06 	lds	r22, 0x0607
    1740:	70 91 08 06 	lds	r23, 0x0608
    1744:	80 91 fa 05 	lds	r24, 0x05FA
    1748:	90 91 fb 05 	lds	r25, 0x05FB
    174c:	a0 91 fc 05 	lds	r26, 0x05FC
    1750:	b0 91 fd 05 	lds	r27, 0x05FD
    1754:	84 17       	cp	r24, r20
    1756:	95 07       	cpc	r25, r21
    1758:	a6 07       	cpc	r26, r22
    175a:	b7 07       	cpc	r27, r23
    175c:	08 f0       	brcs	.+2      	; 0x1760 <UpdateAdjustedSampleAddresses+0x30c>
    175e:	70 c2       	rjmp	.+1248   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?
    1760:	40 91 fe 05 	lds	r20, 0x05FE
    1764:	50 91 ff 05 	lds	r21, 0x05FF
    1768:	60 91 00 06 	lds	r22, 0x0600
    176c:	70 91 01 06 	lds	r23, 0x0601
    1770:	80 90 05 06 	lds	r8, 0x0605
    1774:	90 90 06 06 	lds	r9, 0x0606
    1778:	a0 90 07 06 	lds	r10, 0x0607
    177c:	b0 90 08 06 	lds	r11, 0x0608
    1780:	80 91 05 06 	lds	r24, 0x0605
    1784:	90 91 06 06 	lds	r25, 0x0606
    1788:	a0 91 07 06 	lds	r26, 0x0607
    178c:	b0 91 08 06 	lds	r27, 0x0608
    1790:	c0 90 fa 05 	lds	r12, 0x05FA
    1794:	d0 90 fb 05 	lds	r13, 0x05FB
    1798:	e0 90 fc 05 	lds	r14, 0x05FC
    179c:	f0 90 fd 05 	lds	r15, 0x05FD
    17a0:	48 19       	sub	r20, r8
    17a2:	59 09       	sbc	r21, r9
    17a4:	6a 09       	sbc	r22, r10
    17a6:	7b 09       	sbc	r23, r11
    17a8:	8c 19       	sub	r24, r12
    17aa:	9d 09       	sbc	r25, r13
    17ac:	ae 09       	sbc	r26, r14
    17ae:	bf 09       	sbc	r27, r15
    17b0:	48 17       	cp	r20, r24
    17b2:	59 07       	cpc	r21, r25
    17b4:	6a 07       	cpc	r22, r26
    17b6:	7b 07       	cpc	r23, r27
    17b8:	e8 f1       	brcs	.+122    	; 0x1834 <UpdateAdjustedSampleAddresses+0x3e0>
    17ba:	15 c0       	rjmp	.+42     	; 0x17e6 <UpdateAdjustedSampleAddresses+0x392>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    17bc:	40 91 05 06 	lds	r20, 0x0605
    17c0:	50 91 06 06 	lds	r21, 0x0606
    17c4:	60 91 07 06 	lds	r22, 0x0607
    17c8:	70 91 08 06 	lds	r23, 0x0608
    17cc:	80 91 fe 05 	lds	r24, 0x05FE
    17d0:	90 91 ff 05 	lds	r25, 0x05FF
    17d4:	a0 91 00 06 	lds	r26, 0x0600
    17d8:	b0 91 01 06 	lds	r27, 0x0601
    17dc:	48 17       	cp	r20, r24
    17de:	59 07       	cpc	r21, r25
    17e0:	6a 07       	cpc	r22, r26
    17e2:	7b 07       	cpc	r23, r27
    17e4:	88 f4       	brcc	.+34     	; 0x1808 <UpdateAdjustedSampleAddresses+0x3b4>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    17e6:	80 91 fe 05 	lds	r24, 0x05FE
    17ea:	90 91 ff 05 	lds	r25, 0x05FF
    17ee:	a0 91 00 06 	lds	r26, 0x0600
    17f2:	b0 91 01 06 	lds	r27, 0x0601
    17f6:	80 93 05 06 	sts	0x0605, r24
    17fa:	90 93 06 06 	sts	0x0606, r25
    17fe:	a0 93 07 06 	sts	0x0607, r26
    1802:	b0 93 08 06 	sts	0x0608, r27
    1806:	1c c2       	rjmp	.+1080   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			}
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    1808:	40 91 05 06 	lds	r20, 0x0605
    180c:	50 91 06 06 	lds	r21, 0x0606
    1810:	60 91 07 06 	lds	r22, 0x0607
    1814:	70 91 08 06 	lds	r23, 0x0608
    1818:	80 91 fa 05 	lds	r24, 0x05FA
    181c:	90 91 fb 05 	lds	r25, 0x05FB
    1820:	a0 91 fc 05 	lds	r26, 0x05FC
    1824:	b0 91 fd 05 	lds	r27, 0x05FD
    1828:	84 17       	cp	r24, r20
    182a:	95 07       	cpc	r25, r21
    182c:	a6 07       	cpc	r26, r22
    182e:	b7 07       	cpc	r27, r23
    1830:	08 f0       	brcs	.+2      	; 0x1834 <UpdateAdjustedSampleAddresses+0x3e0>
    1832:	06 c2       	rjmp	.+1036   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1834:	80 91 fa 05 	lds	r24, 0x05FA
    1838:	90 91 fb 05 	lds	r25, 0x05FB
    183c:	a0 91 fc 05 	lds	r26, 0x05FC
    1840:	b0 91 fd 05 	lds	r27, 0x05FD
    1844:	d8 cf       	rjmp	.-80     	; 0x17f6 <UpdateAdjustedSampleAddresses+0x3a2>
		}
	}
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    1846:	80 91 15 06 	lds	r24, 0x0615
    184a:	90 91 16 06 	lds	r25, 0x0616
    184e:	a0 91 17 06 	lds	r26, 0x0617
    1852:	b0 91 18 06 	lds	r27, 0x0618
    1856:	cc 24       	eor	r12, r12
    1858:	ca 94       	dec	r12
    185a:	dc 2c       	mov	r13, r12
    185c:	27 e0       	ldi	r18, 0x07	; 7
    185e:	e2 2e       	mov	r14, r18
    1860:	f1 2c       	mov	r15, r1
    1862:	46 01       	movw	r8, r12
    1864:	57 01       	movw	r10, r14
    1866:	88 1a       	sub	r8, r24
    1868:	99 0a       	sbc	r9, r25
    186a:	aa 0a       	sbc	r10, r26
    186c:	bb 0a       	sbc	r11, r27
    186e:	33 e0       	ldi	r19, 0x03	; 3
    1870:	88 0c       	add	r8, r8
    1872:	99 1c       	adc	r9, r9
    1874:	aa 1c       	adc	r10, r10
    1876:	bb 1c       	adc	r11, r11
    1878:	3a 95       	dec	r19
    187a:	d1 f7       	brne	.-12     	; 0x1870 <UpdateAdjustedSampleAddresses+0x41c>
    187c:	89 2c       	mov	r8, r9
    187e:	9a 2c       	mov	r9, r10
    1880:	ab 2c       	mov	r10, r11
    1882:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1884:	a0 91 25 06 	lds	r26, 0x0625
    1888:	80 91 27 06 	lds	r24, 0x0627
    188c:	b0 e0       	ldi	r27, 0x00	; 0
    188e:	a8 0f       	add	r26, r24
    1890:	b1 1d       	adc	r27, r1
    1892:	a5 01       	movw	r20, r10
    1894:	94 01       	movw	r18, r8
    1896:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    189a:	f3 e0       	ldi	r31, 0x03	; 3
    189c:	96 95       	lsr	r25
    189e:	87 95       	ror	r24
    18a0:	77 95       	ror	r23
    18a2:	67 95       	ror	r22
    18a4:	fa 95       	dec	r31
    18a6:	d1 f7       	brne	.-12     	; 0x189c <UpdateAdjustedSampleAddresses+0x448>
    18a8:	c6 1a       	sub	r12, r22
    18aa:	d7 0a       	sbc	r13, r23
    18ac:	e8 0a       	sbc	r14, r24
    18ae:	f9 0a       	sbc	r15, r25
    18b0:	c0 92 21 06 	sts	0x0621, r12
    18b4:	d0 92 22 06 	sts	0x0622, r13
    18b8:	e0 92 23 06 	sts	0x0623, r14
    18bc:	f0 92 24 06 	sts	0x0624, r15
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    18c0:	40 90 15 06 	lds	r4, 0x0615
    18c4:	50 90 16 06 	lds	r5, 0x0616
    18c8:	60 90 17 06 	lds	r6, 0x0617
    18cc:	70 90 18 06 	lds	r7, 0x0618
    18d0:	a0 91 26 06 	lds	r26, 0x0626
    18d4:	f0 91 27 06 	lds	r31, 0x0627
    18d8:	b0 e0       	ldi	r27, 0x00	; 0
    18da:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    18de:	6b 01       	movw	r12, r22
    18e0:	7c 01       	movw	r14, r24
    18e2:	a3 e0       	ldi	r26, 0x03	; 3
    18e4:	f6 94       	lsr	r15
    18e6:	e7 94       	ror	r14
    18e8:	d7 94       	ror	r13
    18ea:	c7 94       	ror	r12
    18ec:	aa 95       	dec	r26
    18ee:	d1 f7       	brne	.-12     	; 0x18e4 <UpdateAdjustedSampleAddresses+0x490>
    18f0:	c4 0c       	add	r12, r4
    18f2:	d5 1c       	adc	r13, r5
    18f4:	e6 1c       	adc	r14, r6
    18f6:	f7 1c       	adc	r15, r7
    18f8:	af 2f       	mov	r26, r31
    18fa:	b0 e0       	ldi	r27, 0x00	; 0
    18fc:	0e 94 9b 28 	call	0x5136	; 0x5136 <__muluhisi3>
    1900:	b3 e0       	ldi	r27, 0x03	; 3
    1902:	96 95       	lsr	r25
    1904:	87 95       	ror	r24
    1906:	77 95       	ror	r23
    1908:	67 95       	ror	r22
    190a:	ba 95       	dec	r27
    190c:	d1 f7       	brne	.-12     	; 0x1902 <UpdateAdjustedSampleAddresses+0x4ae>
    190e:	c6 1a       	sub	r12, r22
    1910:	d7 0a       	sbc	r13, r23
    1912:	e8 0a       	sbc	r14, r24
    1914:	f9 0a       	sbc	r15, r25
    1916:	c0 92 1d 06 	sts	0x061D, r12
    191a:	d0 92 1e 06 	sts	0x061E, r13
    191e:	e0 92 1f 06 	sts	0x061F, r14
    1922:	f0 92 20 06 	sts	0x0620, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1926:	40 91 21 06 	lds	r20, 0x0621
    192a:	50 91 22 06 	lds	r21, 0x0622
    192e:	60 91 23 06 	lds	r22, 0x0623
    1932:	70 91 24 06 	lds	r23, 0x0624
    1936:	80 91 1d 06 	lds	r24, 0x061D
    193a:	90 91 1e 06 	lds	r25, 0x061E
    193e:	a0 91 1f 06 	lds	r26, 0x061F
    1942:	b0 91 20 06 	lds	r27, 0x0620
    1946:	48 17       	cp	r20, r24
    1948:	59 07       	cpc	r21, r25
    194a:	6a 07       	cpc	r22, r26
    194c:	7b 07       	cpc	r23, r27
    194e:	50 f5       	brcc	.+84     	; 0x19a4 <UpdateAdjustedSampleAddresses+0x550>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1950:	80 91 0c 06 	lds	r24, 0x060C
    1954:	81 30       	cpi	r24, 0x01	; 1
    1956:	19 f4       	brne	.+6      	; 0x195e <UpdateAdjustedSampleAddresses+0x50a>
			{
				bankStates[BANK_1].sampleDirection=true;
    1958:	80 93 0d 06 	sts	0x060D, r24
    195c:	02 c0       	rjmp	.+4      	; 0x1962 <UpdateAdjustedSampleAddresses+0x50e>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    195e:	10 92 0d 06 	sts	0x060D, r1
			}

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    1962:	80 91 21 06 	lds	r24, 0x0621
    1966:	90 91 22 06 	lds	r25, 0x0622
    196a:	a0 91 23 06 	lds	r26, 0x0623
    196e:	b0 91 24 06 	lds	r27, 0x0624
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    1972:	40 91 1d 06 	lds	r20, 0x061D
    1976:	50 91 1e 06 	lds	r21, 0x061E
    197a:	60 91 1f 06 	lds	r22, 0x061F
    197e:	70 91 20 06 	lds	r23, 0x0620
    1982:	40 93 21 06 	sts	0x0621, r20
    1986:	50 93 22 06 	sts	0x0622, r21
    198a:	60 93 23 06 	sts	0x0623, r22
    198e:	70 93 24 06 	sts	0x0624, r23
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    1992:	80 93 1d 06 	sts	0x061D, r24
    1996:	90 93 1e 06 	sts	0x061E, r25
    199a:	a0 93 1f 06 	sts	0x061F, r26
    199e:	b0 93 20 06 	sts	0x0620, r27
    19a2:	0a c0       	rjmp	.+20     	; 0x19b8 <UpdateAdjustedSampleAddresses+0x564>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    19a4:	80 91 0c 06 	lds	r24, 0x060C
    19a8:	81 30       	cpi	r24, 0x01	; 1
    19aa:	19 f4       	brne	.+6      	; 0x19b2 <UpdateAdjustedSampleAddresses+0x55e>
			{
				bankStates[BANK_1].sampleDirection=false;
    19ac:	10 92 0d 06 	sts	0x060D, r1
    19b0:	03 c0       	rjmp	.+6      	; 0x19b8 <UpdateAdjustedSampleAddresses+0x564>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    19b2:	81 e0       	ldi	r24, 0x01	; 1
    19b4:	80 93 0d 06 	sts	0x060D, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    19b8:	40 91 21 06 	lds	r20, 0x0621
    19bc:	50 91 22 06 	lds	r21, 0x0622
    19c0:	60 91 23 06 	lds	r22, 0x0623
    19c4:	70 91 24 06 	lds	r23, 0x0624
    19c8:	80 91 15 06 	lds	r24, 0x0615
    19cc:	90 91 16 06 	lds	r25, 0x0616
    19d0:	a0 91 17 06 	lds	r26, 0x0617
    19d4:	b0 91 18 06 	lds	r27, 0x0618
    19d8:	48 17       	cp	r20, r24
    19da:	59 07       	cpc	r21, r25
    19dc:	6a 07       	cpc	r22, r26
    19de:	7b 07       	cpc	r23, r27
    19e0:	f8 f4       	brcc	.+62     	; 0x1a20 <UpdateAdjustedSampleAddresses+0x5cc>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    19e2:	80 91 21 06 	lds	r24, 0x0621
    19e6:	90 91 22 06 	lds	r25, 0x0622
    19ea:	a0 91 23 06 	lds	r26, 0x0623
    19ee:	b0 91 24 06 	lds	r27, 0x0624
    19f2:	40 91 15 06 	lds	r20, 0x0615
    19f6:	50 91 16 06 	lds	r21, 0x0616
    19fa:	60 91 17 06 	lds	r22, 0x0617
    19fe:	70 91 18 06 	lds	r23, 0x0618
    1a02:	01 97       	sbiw	r24, 0x01	; 1
    1a04:	a8 4f       	sbci	r26, 0xF8	; 248
    1a06:	bf 4f       	sbci	r27, 0xFF	; 255
    1a08:	84 1b       	sub	r24, r20
    1a0a:	95 0b       	sbc	r25, r21
    1a0c:	a6 0b       	sbc	r26, r22
    1a0e:	b7 0b       	sbc	r27, r23
    1a10:	80 93 21 06 	sts	0x0621, r24
    1a14:	90 93 22 06 	sts	0x0622, r25
    1a18:	a0 93 23 06 	sts	0x0623, r26
    1a1c:	b0 93 24 06 	sts	0x0624, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    1a20:	40 91 1d 06 	lds	r20, 0x061D
    1a24:	50 91 1e 06 	lds	r21, 0x061E
    1a28:	60 91 1f 06 	lds	r22, 0x061F
    1a2c:	70 91 20 06 	lds	r23, 0x0620
    1a30:	80 91 15 06 	lds	r24, 0x0615
    1a34:	90 91 16 06 	lds	r25, 0x0616
    1a38:	a0 91 17 06 	lds	r26, 0x0617
    1a3c:	b0 91 18 06 	lds	r27, 0x0618
    1a40:	48 17       	cp	r20, r24
    1a42:	59 07       	cpc	r21, r25
    1a44:	6a 07       	cpc	r22, r26
    1a46:	7b 07       	cpc	r23, r27
    1a48:	08 f0       	brcs	.+2      	; 0x1a4c <UpdateAdjustedSampleAddresses+0x5f8>
    1a4a:	47 c0       	rjmp	.+142    	; 0x1ada <UpdateAdjustedSampleAddresses+0x686>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    1a4c:	80 91 1d 06 	lds	r24, 0x061D
    1a50:	90 91 1e 06 	lds	r25, 0x061E
    1a54:	a0 91 1f 06 	lds	r26, 0x061F
    1a58:	b0 91 20 06 	lds	r27, 0x0620
    1a5c:	40 91 15 06 	lds	r20, 0x0615
    1a60:	50 91 16 06 	lds	r21, 0x0616
    1a64:	60 91 17 06 	lds	r22, 0x0617
    1a68:	70 91 18 06 	lds	r23, 0x0618
    1a6c:	01 97       	sbiw	r24, 0x01	; 1
    1a6e:	a8 4f       	sbci	r26, 0xF8	; 248
    1a70:	bf 4f       	sbci	r27, 0xFF	; 255
    1a72:	84 1b       	sub	r24, r20
    1a74:	95 0b       	sbc	r25, r21
    1a76:	a6 0b       	sbc	r26, r22
    1a78:	b7 0b       	sbc	r27, r23
    1a7a:	80 93 1d 06 	sts	0x061D, r24
    1a7e:	90 93 1e 06 	sts	0x061E, r25
    1a82:	a0 93 1f 06 	sts	0x061F, r26
    1a86:	b0 93 20 06 	sts	0x0620, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    1a8a:	40 91 1d 06 	lds	r20, 0x061D
    1a8e:	50 91 1e 06 	lds	r21, 0x061E
    1a92:	60 91 1f 06 	lds	r22, 0x061F
    1a96:	70 91 20 06 	lds	r23, 0x0620
    1a9a:	80 91 21 06 	lds	r24, 0x0621
    1a9e:	90 91 22 06 	lds	r25, 0x0622
    1aa2:	a0 91 23 06 	lds	r26, 0x0623
    1aa6:	b0 91 24 06 	lds	r27, 0x0624
    1aaa:	48 17       	cp	r20, r24
    1aac:	59 07       	cpc	r21, r25
    1aae:	6a 07       	cpc	r22, r26
    1ab0:	7b 07       	cpc	r23, r27
    1ab2:	99 f4       	brne	.+38     	; 0x1ada <UpdateAdjustedSampleAddresses+0x686>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    1ab4:	80 91 1d 06 	lds	r24, 0x061D
    1ab8:	90 91 1e 06 	lds	r25, 0x061E
    1abc:	a0 91 1f 06 	lds	r26, 0x061F
    1ac0:	b0 91 20 06 	lds	r27, 0x0620
    1ac4:	01 96       	adiw	r24, 0x01	; 1
    1ac6:	a1 1d       	adc	r26, r1
    1ac8:	b1 1d       	adc	r27, r1
    1aca:	80 93 1d 06 	sts	0x061D, r24
    1ace:	90 93 1e 06 	sts	0x061E, r25
    1ad2:	a0 93 1f 06 	sts	0x061F, r26
    1ad6:	b0 93 20 06 	sts	0x0620, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    1ada:	40 91 21 06 	lds	r20, 0x0621
    1ade:	50 91 22 06 	lds	r21, 0x0622
    1ae2:	60 91 23 06 	lds	r22, 0x0623
    1ae6:	70 91 24 06 	lds	r23, 0x0624
    1aea:	80 91 1d 06 	lds	r24, 0x061D
    1aee:	90 91 1e 06 	lds	r25, 0x061E
    1af2:	a0 91 1f 06 	lds	r26, 0x061F
    1af6:	b0 91 20 06 	lds	r27, 0x0620
    1afa:	48 17       	cp	r20, r24
    1afc:	59 07       	cpc	r21, r25
    1afe:	6a 07       	cpc	r22, r26
    1b00:	7b 07       	cpc	r23, r27
    1b02:	08 f0       	brcs	.+2      	; 0x1b06 <UpdateAdjustedSampleAddresses+0x6b2>
    1b04:	5a c0       	rjmp	.+180    	; 0x1bba <UpdateAdjustedSampleAddresses+0x766>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1b06:	40 91 28 06 	lds	r20, 0x0628
    1b0a:	50 91 29 06 	lds	r21, 0x0629
    1b0e:	60 91 2a 06 	lds	r22, 0x062A
    1b12:	70 91 2b 06 	lds	r23, 0x062B
    1b16:	80 91 21 06 	lds	r24, 0x0621
    1b1a:	90 91 22 06 	lds	r25, 0x0622
    1b1e:	a0 91 23 06 	lds	r26, 0x0623
    1b22:	b0 91 24 06 	lds	r27, 0x0624
    1b26:	84 17       	cp	r24, r20
    1b28:	95 07       	cpc	r25, r21
    1b2a:	a6 07       	cpc	r26, r22
    1b2c:	b7 07       	cpc	r27, r23
    1b2e:	08 f0       	brcs	.+2      	; 0x1b32 <UpdateAdjustedSampleAddresses+0x6de>
    1b30:	87 c0       	rjmp	.+270    	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
    1b32:	40 91 28 06 	lds	r20, 0x0628
    1b36:	50 91 29 06 	lds	r21, 0x0629
    1b3a:	60 91 2a 06 	lds	r22, 0x062A
    1b3e:	70 91 2b 06 	lds	r23, 0x062B
    1b42:	80 91 1d 06 	lds	r24, 0x061D
    1b46:	90 91 1e 06 	lds	r25, 0x061E
    1b4a:	a0 91 1f 06 	lds	r26, 0x061F
    1b4e:	b0 91 20 06 	lds	r27, 0x0620
    1b52:	48 17       	cp	r20, r24
    1b54:	59 07       	cpc	r21, r25
    1b56:	6a 07       	cpc	r22, r26
    1b58:	7b 07       	cpc	r23, r27
    1b5a:	08 f0       	brcs	.+2      	; 0x1b5e <UpdateAdjustedSampleAddresses+0x70a>
    1b5c:	71 c0       	rjmp	.+226    	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?
    1b5e:	40 91 28 06 	lds	r20, 0x0628
    1b62:	50 91 29 06 	lds	r21, 0x0629
    1b66:	60 91 2a 06 	lds	r22, 0x062A
    1b6a:	70 91 2b 06 	lds	r23, 0x062B
    1b6e:	80 90 21 06 	lds	r8, 0x0621
    1b72:	90 90 22 06 	lds	r9, 0x0622
    1b76:	a0 90 23 06 	lds	r10, 0x0623
    1b7a:	b0 90 24 06 	lds	r11, 0x0624
    1b7e:	80 91 1d 06 	lds	r24, 0x061D
    1b82:	90 91 1e 06 	lds	r25, 0x061E
    1b86:	a0 91 1f 06 	lds	r26, 0x061F
    1b8a:	b0 91 20 06 	lds	r27, 0x0620
    1b8e:	c0 90 28 06 	lds	r12, 0x0628
    1b92:	d0 90 29 06 	lds	r13, 0x0629
    1b96:	e0 90 2a 06 	lds	r14, 0x062A
    1b9a:	f0 90 2b 06 	lds	r15, 0x062B
    1b9e:	48 19       	sub	r20, r8
    1ba0:	59 09       	sbc	r21, r9
    1ba2:	6a 09       	sbc	r22, r10
    1ba4:	7b 09       	sbc	r23, r11
    1ba6:	8c 19       	sub	r24, r12
    1ba8:	9d 09       	sbc	r25, r13
    1baa:	ae 09       	sbc	r26, r14
    1bac:	bf 09       	sbc	r27, r15
    1bae:	84 17       	cp	r24, r20
    1bb0:	95 07       	cpc	r25, r21
    1bb2:	a6 07       	cpc	r26, r22
    1bb4:	b7 07       	cpc	r27, r23
    1bb6:	a0 f1       	brcs	.+104    	; 0x1c20 <UpdateAdjustedSampleAddresses+0x7cc>
    1bb8:	15 c0       	rjmp	.+42     	; 0x1be4 <UpdateAdjustedSampleAddresses+0x790>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    1bba:	40 91 28 06 	lds	r20, 0x0628
    1bbe:	50 91 29 06 	lds	r21, 0x0629
    1bc2:	60 91 2a 06 	lds	r22, 0x062A
    1bc6:	70 91 2b 06 	lds	r23, 0x062B
    1bca:	80 91 21 06 	lds	r24, 0x0621
    1bce:	90 91 22 06 	lds	r25, 0x0622
    1bd2:	a0 91 23 06 	lds	r26, 0x0623
    1bd6:	b0 91 24 06 	lds	r27, 0x0624
    1bda:	84 17       	cp	r24, r20
    1bdc:	95 07       	cpc	r25, r21
    1bde:	a6 07       	cpc	r26, r22
    1be0:	b7 07       	cpc	r27, r23
    1be2:	48 f4       	brcc	.+18     	; 0x1bf6 <UpdateAdjustedSampleAddresses+0x7a2>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    1be4:	80 91 21 06 	lds	r24, 0x0621
    1be8:	90 91 22 06 	lds	r25, 0x0622
    1bec:	a0 91 23 06 	lds	r26, 0x0623
    1bf0:	b0 91 24 06 	lds	r27, 0x0624
    1bf4:	1d c0       	rjmp	.+58     	; 0x1c30 <UpdateAdjustedSampleAddresses+0x7dc>
			}
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    1bf6:	40 91 28 06 	lds	r20, 0x0628
    1bfa:	50 91 29 06 	lds	r21, 0x0629
    1bfe:	60 91 2a 06 	lds	r22, 0x062A
    1c02:	70 91 2b 06 	lds	r23, 0x062B
    1c06:	80 91 1d 06 	lds	r24, 0x061D
    1c0a:	90 91 1e 06 	lds	r25, 0x061E
    1c0e:	a0 91 1f 06 	lds	r26, 0x061F
    1c12:	b0 91 20 06 	lds	r27, 0x0620
    1c16:	48 17       	cp	r20, r24
    1c18:	59 07       	cpc	r21, r25
    1c1a:	6a 07       	cpc	r22, r26
    1c1c:	7b 07       	cpc	r23, r27
    1c1e:	80 f4       	brcc	.+32     	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1c20:	80 91 1d 06 	lds	r24, 0x061D
    1c24:	90 91 1e 06 	lds	r25, 0x061E
    1c28:	a0 91 1f 06 	lds	r26, 0x061F
    1c2c:	b0 91 20 06 	lds	r27, 0x0620
    1c30:	80 93 28 06 	sts	0x0628, r24
    1c34:	90 93 29 06 	sts	0x0629, r25
    1c38:	a0 93 2a 06 	sts	0x062A, r26
    1c3c:	b0 93 2b 06 	sts	0x062B, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    1c40:	ef bf       	out	0x3f, r30	; 63
}
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	bf 90       	pop	r11
    1c4c:	af 90       	pop	r10
    1c4e:	9f 90       	pop	r9
    1c50:	8f 90       	pop	r8
    1c52:	7f 90       	pop	r7
    1c54:	6f 90       	pop	r6
    1c56:	5f 90       	pop	r5
    1c58:	4f 90       	pop	r4
    1c5a:	08 95       	ret

00001c5c <RevertSampleToUnadjusted>:
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    1c5c:	9f b7       	in	r25, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1c5e:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    1c60:	23 e2       	ldi	r18, 0x23	; 35
    1c62:	82 9f       	mul	r24, r18
    1c64:	f0 01       	movw	r30, r0
    1c66:	11 24       	eor	r1, r1
    1c68:	ea 51       	subi	r30, 0x1A	; 26
    1c6a:	fa 4f       	sbci	r31, 0xFA	; 250
    1c6c:	40 89       	ldd	r20, Z+16	; 0x10
    1c6e:	51 89       	ldd	r21, Z+17	; 0x11
    1c70:	62 89       	ldd	r22, Z+18	; 0x12
    1c72:	73 89       	ldd	r23, Z+19	; 0x13
    1c74:	40 8f       	std	Z+24, r20	; 0x18
    1c76:	51 8f       	std	Z+25, r21	; 0x19
    1c78:	62 8f       	std	Z+26, r22	; 0x1a
    1c7a:	73 8f       	std	Z+27, r23	; 0x1b
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    1c7c:	44 85       	ldd	r20, Z+12	; 0x0c
    1c7e:	55 85       	ldd	r21, Z+13	; 0x0d
    1c80:	66 85       	ldd	r22, Z+14	; 0x0e
    1c82:	77 85       	ldd	r23, Z+15	; 0x0f
    1c84:	44 8b       	std	Z+20, r20	; 0x14
    1c86:	55 8b       	std	Z+21, r21	; 0x15
    1c88:	66 8b       	std	Z+22, r22	; 0x16
    1c8a:	77 8b       	std	Z+23, r23	; 0x17
	bankStates[theBank].sampleStartOffset=0;
    1c8c:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleEndOffset=0;
    1c8e:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleWindowOffset=0;
    1c90:	16 8e       	std	Z+30, r1	; 0x1e
	SREG=sreg;		// Restore interrupts.
    1c92:	9f bf       	out	0x3f, r25	; 63
    1c94:	08 95       	ret

00001c96 <BlinkLeds>:
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1c96:	40 91 7a 05 	lds	r20, 0x057A
    1c9a:	50 e0       	ldi	r21, 0x00	; 0
    1c9c:	90 91 5d 05 	lds	r25, 0x055D
    1ca0:	20 e0       	ldi	r18, 0x00	; 0
    1ca2:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	70 e0       	ldi	r23, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1ca8:	da 01       	movw	r26, r20
    1caa:	02 2e       	mov	r0, r18
    1cac:	02 c0       	rjmp	.+4      	; 0x1cb2 <BlinkLeds+0x1c>
    1cae:	b5 95       	asr	r27
    1cb0:	a7 95       	ror	r26
    1cb2:	0a 94       	dec	r0
    1cb4:	e2 f7       	brpl	.-8      	; 0x1cae <BlinkLeds+0x18>
    1cb6:	a0 ff       	sbrs	r26, 0
    1cb8:	0a c0       	rjmp	.+20     	; 0x1cce <BlinkLeds+0x38>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1cba:	db 01       	movw	r26, r22
    1cbc:	02 2e       	mov	r0, r18
    1cbe:	02 c0       	rjmp	.+4      	; 0x1cc4 <BlinkLeds+0x2e>
    1cc0:	aa 0f       	add	r26, r26
    1cc2:	bb 1f       	adc	r27, r27
    1cc4:	0a 94       	dec	r0
    1cc6:	e2 f7       	brpl	.-8      	; 0x1cc0 <BlinkLeds+0x2a>
    1cc8:	fd 01       	movw	r30, r26
    1cca:	e0 95       	com	r30
    1ccc:	9e 23       	and	r25, r30
    1cce:	2f 5f       	subi	r18, 0xFF	; 255
    1cd0:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    1cd2:	28 30       	cpi	r18, 0x08	; 8
    1cd4:	31 05       	cpc	r19, r1
    1cd6:	41 f7       	brne	.-48     	; 0x1ca8 <BlinkLeds+0x12>
    1cd8:	90 93 5d 05 	sts	0x055D, r25
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    1cdc:	80 93 7a 05 	sts	0x057A, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    1ce0:	68 e9       	ldi	r22, 0x98	; 152
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	82 e0       	ldi	r24, 0x02	; 2
    1ce6:	0c 94 15 1e 	jmp	0x3c2a	; 0x3c2a <SetTimer>

00001cea <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    1cea:	10 92 5d 05 	sts	0x055D, r1
	BlinkLeds(0);		// Durrrr.....
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <BlinkLeds>

00001cf6 <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    1cf6:	cf 93       	push	r28
	static unsigned char
		i;

	if(subState==SS_0)
    1cf8:	c0 91 5b 05 	lds	r28, 0x055B
    1cfc:	c1 11       	cpse	r28, r1
    1cfe:	0c c0       	rjmp	.+24     	; 0x1d18 <DoFruitcakeIntro+0x22>
	{
		KillLeds();
    1d00:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		i=0;
    1d04:	10 92 5c 05 	sts	0x055C, r1
		ledOnOffMask=0;
    1d08:	10 92 5d 05 	sts	0x055D, r1
		subState=SS_1;
    1d0c:	81 e0       	ldi	r24, 0x01	; 1
    1d0e:	80 93 5b 05 	sts	0x055B, r24
		SetTimer(TIMER_1,(SECOND/4));
    1d12:	61 e3       	ldi	r22, 0x31	; 49
    1d14:	71 e0       	ldi	r23, 0x01	; 1
    1d16:	6b c0       	rjmp	.+214    	; 0x1dee <DoFruitcakeIntro+0xf8>
	}
	else if(subState==SS_1)
    1d18:	c1 30       	cpi	r28, 0x01	; 1
    1d1a:	41 f4       	brne	.+16     	; 0x1d2c <DoFruitcakeIntro+0x36>
	{
		if(CheckTimer(TIMER_1))
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    1d22:	88 23       	and	r24, r24
    1d24:	09 f4       	brne	.+2      	; 0x1d28 <DoFruitcakeIntro+0x32>
    1d26:	91 c0       	rjmp	.+290    	; 0x1e4a <DoFruitcakeIntro+0x154>
		{
			subState=SS_2;
    1d28:	82 e0       	ldi	r24, 0x02	; 2
    1d2a:	4c c0       	rjmp	.+152    	; 0x1dc4 <DoFruitcakeIntro+0xce>
		}
	}

	else if(subState==SS_2)
    1d2c:	c2 30       	cpi	r28, 0x02	; 2
    1d2e:	09 f0       	breq	.+2      	; 0x1d32 <DoFruitcakeIntro+0x3c>
    1d30:	4c c0       	rjmp	.+152    	; 0x1dca <DoFruitcakeIntro+0xd4>
	{
		if(i<NUM_LEDS)
    1d32:	80 91 5c 05 	lds	r24, 0x055C
    1d36:	88 30       	cpi	r24, 0x08	; 8
    1d38:	f8 f4       	brcc	.+62     	; 0x1d78 <DoFruitcakeIntro+0x82>
		{
			if(CheckTimer(TIMER_1))
    1d3a:	80 e0       	ldi	r24, 0x00	; 0
    1d3c:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    1d40:	88 23       	and	r24, r24
    1d42:	09 f4       	brne	.+2      	; 0x1d46 <DoFruitcakeIntro+0x50>
    1d44:	82 c0       	rjmp	.+260    	; 0x1e4a <DoFruitcakeIntro+0x154>
			{
				ledOnOffMask|=(1<<i);
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	00 90 5c 05 	lds	r0, 0x055C
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <DoFruitcakeIntro+0x5e>
    1d50:	88 0f       	add	r24, r24
    1d52:	99 1f       	adc	r25, r25
    1d54:	0a 94       	dec	r0
    1d56:	e2 f7       	brpl	.-8      	; 0x1d50 <DoFruitcakeIntro+0x5a>
    1d58:	90 91 5d 05 	lds	r25, 0x055D
    1d5c:	98 2b       	or	r25, r24
    1d5e:	90 93 5d 05 	sts	0x055D, r25
				SetTimer(TIMER_1,(SECOND/20));
    1d62:	6d e3       	ldi	r22, 0x3D	; 61
    1d64:	70 e0       	ldi	r23, 0x00	; 0
    1d66:	80 e0       	ldi	r24, 0x00	; 0
    1d68:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
				i++;
    1d6c:	80 91 5c 05 	lds	r24, 0x055C
    1d70:	8f 5f       	subi	r24, 0xFF	; 255
    1d72:	80 93 5c 05 	sts	0x055C, r24
    1d76:	69 c0       	rjmp	.+210    	; 0x1e4a <DoFruitcakeIntro+0x154>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    1d7e:	88 23       	and	r24, r24
    1d80:	09 f4       	brne	.+2      	; 0x1d84 <DoFruitcakeIntro+0x8e>
    1d82:	63 c0       	rjmp	.+198    	; 0x1e4a <DoFruitcakeIntro+0x154>
			{
				SetTimer(TIMER_1,(SECOND/8));
    1d84:	68 e9       	ldi	r22, 0x98	; 152
    1d86:	70 e0       	ldi	r23, 0x00	; 0
    1d88:	80 e0       	ldi	r24, 0x00	; 0
    1d8a:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
				ledPwm=255;
    1d8e:	8f ef       	ldi	r24, 0xFF	; 255
    1d90:	80 93 40 04 	sts	0x0440, r24
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    1d94:	90 91 64 00 	lds	r25, 0x0064
    1d98:	9f 7b       	andi	r25, 0xBF	; 191
    1d9a:	90 93 64 00 	sts	0x0064, r25

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    1d9e:	c0 93 b0 00 	sts	0x00B0, r28
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    1da2:	91 e0       	ldi	r25, 0x01	; 1
    1da4:	90 93 b1 00 	sts	0x00B1, r25
				TCNT2=0;			// Init counter reg
    1da8:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    1dac:	90 e8       	ldi	r25, 0x80	; 128
    1dae:	90 93 b3 00 	sts	0x00B3, r25
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    1db2:	87 bb       	out	0x17, r24	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    1db4:	c0 93 70 00 	sts	0x0070, r28

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    1db8:	92 b1       	in	r25, 0x02	; 2
    1dba:	96 60       	ori	r25, 0x06	; 6
    1dbc:	92 b9       	out	0x02, r25	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    1dbe:	84 b9       	out	0x04, r24	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    1dc0:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;
    1dc2:	83 e0       	ldi	r24, 0x03	; 3
    1dc4:	80 93 5b 05 	sts	0x055B, r24
    1dc8:	40 c0       	rjmp	.+128    	; 0x1e4a <DoFruitcakeIntro+0x154>
			}
		}
	}
	else if(subState==SS_3)
    1dca:	c3 30       	cpi	r28, 0x03	; 3
    1dcc:	69 f5       	brne	.+90     	; 0x1e28 <DoFruitcakeIntro+0x132>
	{
		if(CheckTimer(TIMER_1))
    1dce:	80 e0       	ldi	r24, 0x00	; 0
    1dd0:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    1dd4:	88 23       	and	r24, r24
    1dd6:	c9 f1       	breq	.+114    	; 0x1e4a <DoFruitcakeIntro+0x154>
		{
			if(ledPwm>1)
    1dd8:	80 91 40 04 	lds	r24, 0x0440
    1ddc:	82 30       	cpi	r24, 0x02	; 2
    1dde:	58 f0       	brcs	.+22     	; 0x1df6 <DoFruitcakeIntro+0x100>
			{
				ledPwm-=2;
    1de0:	80 91 40 04 	lds	r24, 0x0440
    1de4:	82 50       	subi	r24, 0x02	; 2
    1de6:	80 93 40 04 	sts	0x0440, r24
				SetTimer(TIMER_1,(SECOND/256));
    1dea:	64 e0       	ldi	r22, 0x04	; 4
    1dec:	70 e0       	ldi	r23, 0x00	; 0
    1dee:	80 e0       	ldi	r24, 0x00	; 0
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
	}
}
    1df0:	cf 91       	pop	r28
		if(CheckTimer(TIMER_1))
		{
			if(ledPwm>1)
			{
				ledPwm-=2;
				SetTimer(TIMER_1,(SECOND/256));
    1df2:	0c 94 15 1e 	jmp	0x3c2a	; 0x3c2a <SetTimer>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    1df6:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    1dfa:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    1dfe:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
    1e02:	80 91 64 00 	lds	r24, 0x0064
    1e06:	80 64       	ori	r24, 0x40	; 64
    1e08:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    1e0c:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    1e0e:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    1e10:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    1e14:	82 e1       	ldi	r24, 0x12	; 18
    1e16:	80 93 5d 05 	sts	0x055D, r24
				SetTimer(TIMER_1,(SECOND/2));
    1e1a:	62 e6       	ldi	r22, 0x62	; 98
    1e1c:	72 e0       	ldi	r23, 0x02	; 2
    1e1e:	80 e0       	ldi	r24, 0x00	; 0
    1e20:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
				subState=SS_4;
    1e24:	84 e0       	ldi	r24, 0x04	; 4
    1e26:	ce cf       	rjmp	.-100    	; 0x1dc4 <DoFruitcakeIntro+0xce>
			}
		}
	}
	else if(subState==SS_4)
    1e28:	c4 30       	cpi	r28, 0x04	; 4
    1e2a:	79 f4       	brne	.+30     	; 0x1e4a <DoFruitcakeIntro+0x154>
	{
		if(CheckTimer(TIMER_1))
    1e2c:	80 e0       	ldi	r24, 0x00	; 0
    1e2e:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    1e32:	88 23       	and	r24, r24
    1e34:	51 f0       	breq	.+20     	; 0x1e4a <DoFruitcakeIntro+0x154>
		{
			KillLeds();
    1e36:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e3a:	85 e2       	ldi	r24, 0x25	; 37
    1e3c:	91 e1       	ldi	r25, 0x11	; 17
    1e3e:	90 93 e5 05 	sts	0x05E5, r25
    1e42:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    1e46:	10 92 5b 05 	sts	0x055B, r1
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
	}
}
    1e4a:	cf 91       	pop	r28
    1e4c:	08 95       	ret

00001e4e <SdStartSampleRead>:

static bool SdStartSampleRead(unsigned int sampleSlot)
// Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
// Begins a sample read in the correct spot.
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
    1e4e:	cf 92       	push	r12
    1e50:	df 92       	push	r13
    1e52:	ef 92       	push	r14
    1e54:	ff 92       	push	r15
    1e56:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1e58:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    1e5a:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    1e5c:	38 2f       	mov	r19, r24
    1e5e:	33 0f       	add	r19, r19
    1e60:	33 0f       	add	r19, r19
    1e62:	20 e0       	ldi	r18, 0x00	; 0
    1e64:	69 01       	movw	r12, r18
    1e66:	8f ef       	ldi	r24, 0xFF	; 255
    1e68:	c8 1a       	sub	r12, r24
    1e6a:	d8 0a       	sbc	r13, r24
    1e6c:	e1 2c       	mov	r14, r1
    1e6e:	f1 2c       	mov	r15, r1
    1e70:	c7 01       	movw	r24, r14
    1e72:	b6 01       	movw	r22, r12
    1e74:	0e 94 ef 21 	call	0x43de	; 0x43de <SdBeginSingleBlockRead>
    1e78:	81 30       	cpi	r24, 0x01	; 1
    1e7a:	19 f5       	brne	.+70     	; 0x1ec2 <SdStartSampleRead+0x74>
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    1e7c:	c0 92 70 05 	sts	0x0570, r12
    1e80:	d0 92 71 05 	sts	0x0571, r13
    1e84:	e0 92 72 05 	sts	0x0572, r14
    1e88:	f0 92 73 05 	sts	0x0573, r15
		sdCurrentBlockOffset=0;						// Read first block first
    1e8c:	10 92 75 05 	sts	0x0575, r1
    1e90:	10 92 74 05 	sts	0x0574, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    1e94:	10 92 2b 01 	sts	0x012B, r1
    1e98:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    1e9c:	10 92 29 01 	sts	0x0129, r1
    1ea0:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    1ea4:	10 92 27 01 	sts	0x0127, r1
    1ea8:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    1eac:	6a e7       	ldi	r22, 0x7A	; 122
    1eae:	70 e0       	ldi	r23, 0x00	; 0
    1eb0:	83 e0       	ldi	r24, 0x03	; 3
    1eb2:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    1eb6:	89 e0       	ldi	r24, 0x09	; 9
    1eb8:	80 93 59 05 	sts	0x0559, r24

		SREG=sreg;	// Resume ISR
    1ebc:	cf bf       	out	0x3f, r28	; 63

		return(true);
    1ebe:	81 e0       	ldi	r24, 0x01	; 1
    1ec0:	02 c0       	rjmp	.+4      	; 0x1ec6 <SdStartSampleRead+0x78>
	}
	SREG=sreg;	// Resume ISR
    1ec2:	cf bf       	out	0x3f, r28	; 63
	return(false);
    1ec4:	80 e0       	ldi	r24, 0x00	; 0
}
    1ec6:	cf 91       	pop	r28
    1ec8:	ff 90       	pop	r15
    1eca:	ef 90       	pop	r14
    1ecc:	df 90       	pop	r13
    1ece:	cf 90       	pop	r12
    1ed0:	08 95       	ret

00001ed2 <SetSampleClock.part.0>:
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    1ed2:	e1 e8       	ldi	r30, 0x81	; 129
    1ed4:	f0 e0       	ldi	r31, 0x00	; 0
    1ed6:	80 81       	ld	r24, Z
    1ed8:	80 64       	ori	r24, 0x40	; 64
    1eda:	80 83       	st	Z, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1edc:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1ede:	ef e6       	ldi	r30, 0x6F	; 111
    1ee0:	f0 e0       	ldi	r31, 0x00	; 0
    1ee2:	80 81       	ld	r24, Z
    1ee4:	80 62       	ori	r24, 0x20	; 32
    1ee6:	80 83       	st	Z, r24
    1ee8:	08 95       	ret

00001eea <SetSampleClock>:

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    1eea:	93 e2       	ldi	r25, 0x23	; 35
    1eec:	89 9f       	mul	r24, r25
    1eee:	f0 01       	movw	r30, r0
    1ef0:	11 24       	eor	r1, r1
    1ef2:	ea 51       	subi	r30, 0x1A	; 26
    1ef4:	fa 4f       	sbci	r31, 0xFA	; 250
    1ef6:	61 87       	std	Z+9, r22	; 0x09

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1ef8:	62 30       	cpi	r22, 0x02	; 2
    1efa:	39 f5       	brne	.+78     	; 0x1f4a <SetSampleClock+0x60>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1efc:	53 87       	std	Z+11, r21	; 0x0b
    1efe:	42 87       	std	Z+10, r20	; 0x0a

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1f00:	81 11       	cpse	r24, r1
    1f02:	0f c0       	rjmp	.+30     	; 0x1f22 <SetSampleClock+0x38>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1f04:	80 91 84 00 	lds	r24, 0x0084
    1f08:	90 91 85 00 	lds	r25, 0x0085
    1f0c:	84 0f       	add	r24, r20
    1f0e:	95 1f       	adc	r25, r21
    1f10:	90 93 89 00 	sts	0x0089, r25
    1f14:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1f18:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    1f1a:	80 91 6f 00 	lds	r24, 0x006F
    1f1e:	82 60       	ori	r24, 0x02	; 2
    1f20:	0e c0       	rjmp	.+28     	; 0x1f3e <SetSampleClock+0x54>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1f22:	80 91 84 00 	lds	r24, 0x0084
    1f26:	90 91 85 00 	lds	r25, 0x0085
    1f2a:	84 0f       	add	r24, r20
    1f2c:	95 1f       	adc	r25, r21
    1f2e:	90 93 8b 00 	sts	0x008B, r25
    1f32:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    1f36:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1f38:	80 91 6f 00 	lds	r24, 0x006F
    1f3c:	84 60       	ori	r24, 0x04	; 4
    1f3e:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	80 93 81 00 	sts	0x0081, r24
    1f48:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1f4a:	61 30       	cpi	r22, 0x01	; 1
    1f4c:	59 f4       	brne	.+22     	; 0x1f64 <SetSampleClock+0x7a>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1f4e:	81 11       	cpse	r24, r1
    1f50:	02 c0       	rjmp	.+4      	; 0x1f56 <SetSampleClock+0x6c>
    1f52:	0c 94 69 0f 	jmp	0x1ed2	; 0x1ed2 <SetSampleClock.part.0>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    1f56:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    1f58:	84 e0       	ldi	r24, 0x04	; 4
    1f5a:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    1f5e:	80 e1       	ldi	r24, 0x10	; 16
    1f60:	80 93 6d 00 	sts	0x006D, r24
    1f64:	08 95       	ret

00001f66 <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1f66:	ff 92       	push	r15
    1f68:	0f 93       	push	r16
    1f6a:	1f 93       	push	r17
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1f70:	c8 2f       	mov	r28, r24
    1f72:	d0 e0       	ldi	r29, 0x00	; 0
    1f74:	93 e2       	ldi	r25, 0x23	; 35
    1f76:	89 9f       	mul	r24, r25
    1f78:	f0 01       	movw	r30, r0
    1f7a:	11 24       	eor	r1, r1
    1f7c:	ea 51       	subi	r30, 0x1A	; 26
    1f7e:	fa 4f       	sbci	r31, 0xFA	; 250
    1f80:	95 81       	ldd	r25, Z+5	; 0x05
    1f82:	99 23       	and	r25, r25
    1f84:	29 f0       	breq	.+10     	; 0x1f90 <StartPlayback+0x2a>
    1f86:	90 91 4f 05 	lds	r25, 0x054F
    1f8a:	91 50       	subi	r25, 0x01	; 1
    1f8c:	92 30       	cpi	r25, 0x02	; 2
    1f8e:	80 f1       	brcs	.+96     	; 0x1ff0 <StartPlayback+0x8a>
	{
		sreg=SREG;	// Store global interrupt state.
    1f90:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1f92:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    1f94:	93 e2       	ldi	r25, 0x23	; 35
    1f96:	9c 9f       	mul	r25, r28
    1f98:	f0 01       	movw	r30, r0
    1f9a:	9d 9f       	mul	r25, r29
    1f9c:	f0 0d       	add	r31, r0
    1f9e:	11 24       	eor	r1, r1
    1fa0:	ea 51       	subi	r30, 0x1A	; 26
    1fa2:	fa 4f       	sbci	r31, 0xFA	; 250
    1fa4:	94 e0       	ldi	r25, 0x04	; 4
    1fa6:	90 83       	st	Z, r25

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    1fa8:	93 81       	ldd	r25, Z+3	; 0x03
    1faa:	99 23       	and	r25, r25
    1fac:	51 f0       	breq	.+20     	; 0x1fc2 <StartPlayback+0x5c>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    1fae:	04 89       	ldd	r16, Z+20	; 0x14
    1fb0:	15 89       	ldd	r17, Z+21	; 0x15
    1fb2:	26 89       	ldd	r18, Z+22	; 0x16
    1fb4:	37 89       	ldd	r19, Z+23	; 0x17
    1fb6:	07 8f       	std	Z+31, r16	; 0x1f
    1fb8:	10 a3       	std	Z+32, r17	; 0x20
    1fba:	21 a3       	std	Z+33, r18	; 0x21
    1fbc:	32 a3       	std	Z+34, r19	; 0x22
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    1fbe:	14 82       	std	Z+4, r1	; 0x04
    1fc0:	0a c0       	rjmp	.+20     	; 0x1fd6 <StartPlayback+0x70>
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    1fc2:	00 8d       	ldd	r16, Z+24	; 0x18
    1fc4:	11 8d       	ldd	r17, Z+25	; 0x19
    1fc6:	22 8d       	ldd	r18, Z+26	; 0x1a
    1fc8:	33 8d       	ldd	r19, Z+27	; 0x1b
    1fca:	07 8f       	std	Z+31, r16	; 0x1f
    1fcc:	10 a3       	std	Z+32, r17	; 0x20
    1fce:	21 a3       	std	Z+33, r18	; 0x21
    1fd0:	32 a3       	std	Z+34, r19	; 0x22
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    1fd2:	91 e0       	ldi	r25, 0x01	; 1
    1fd4:	94 83       	std	Z+4, r25	; 0x04
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    1fd6:	0e 94 75 0f 	call	0x1eea	; 0x1eea <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    1fda:	83 e2       	ldi	r24, 0x23	; 35
    1fdc:	8c 9f       	mul	r24, r28
    1fde:	f0 01       	movw	r30, r0
    1fe0:	8d 9f       	mul	r24, r29
    1fe2:	f0 0d       	add	r31, r0
    1fe4:	11 24       	eor	r1, r1
    1fe6:	ea 51       	subi	r30, 0x1A	; 26
    1fe8:	fa 4f       	sbci	r31, 0xFA	; 250
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1fee:	ff be       	out	0x3f, r15	; 63
	}
}
    1ff0:	df 91       	pop	r29
    1ff2:	cf 91       	pop	r28
    1ff4:	1f 91       	pop	r17
    1ff6:	0f 91       	pop	r16
    1ff8:	ff 90       	pop	r15
    1ffa:	08 95       	ret

00001ffc <ContinuePlayback>:

static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2002:	28 2f       	mov	r18, r24
    2004:	30 e0       	ldi	r19, 0x00	; 0
    2006:	93 e2       	ldi	r25, 0x23	; 35
    2008:	89 9f       	mul	r24, r25
    200a:	f0 01       	movw	r30, r0
    200c:	11 24       	eor	r1, r1
    200e:	ea 51       	subi	r30, 0x1A	; 26
    2010:	fa 4f       	sbci	r31, 0xFA	; 250
    2012:	95 81       	ldd	r25, Z+5	; 0x05
    2014:	99 23       	and	r25, r25
    2016:	29 f0       	breq	.+10     	; 0x2022 <ContinuePlayback+0x26>
    2018:	90 91 4f 05 	lds	r25, 0x054F
    201c:	91 50       	subi	r25, 0x01	; 1
    201e:	92 30       	cpi	r25, 0x02	; 2
    2020:	88 f0       	brcs	.+34     	; 0x2044 <ContinuePlayback+0x48>
	{
		sreg=SREG;	// Store global interrupt state.
    2022:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2024:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    2026:	93 e2       	ldi	r25, 0x23	; 35
    2028:	92 9f       	mul	r25, r18
    202a:	e0 01       	movw	r28, r0
    202c:	93 9f       	mul	r25, r19
    202e:	d0 0d       	add	r29, r0
    2030:	11 24       	eor	r1, r1
    2032:	ca 51       	subi	r28, 0x1A	; 26
    2034:	da 4f       	sbci	r29, 0xFA	; 250
    2036:	94 e0       	ldi	r25, 0x04	; 4
    2038:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    203a:	0e 94 75 0f 	call	0x1eea	; 0x1eea <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    2042:	1f bf       	out	0x3f, r17	; 63
	}
}
    2044:	df 91       	pop	r29
    2046:	cf 91       	pop	r28
    2048:	1f 91       	pop	r17
    204a:	08 95       	ret

0000204c <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    204c:	ff 92       	push	r15
    204e:	0f 93       	push	r16
    2050:	1f 93       	push	r17
    2052:	cf 93       	push	r28
    2054:	df 93       	push	r29

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2056:	28 2f       	mov	r18, r24
    2058:	30 e0       	ldi	r19, 0x00	; 0
    205a:	93 e2       	ldi	r25, 0x23	; 35
    205c:	89 9f       	mul	r24, r25
    205e:	f0 01       	movw	r30, r0
    2060:	11 24       	eor	r1, r1
    2062:	ea 51       	subi	r30, 0x1A	; 26
    2064:	fa 4f       	sbci	r31, 0xFA	; 250
    2066:	95 81       	ldd	r25, Z+5	; 0x05
    2068:	99 23       	and	r25, r25
    206a:	31 f0       	breq	.+12     	; 0x2078 <StartRecording+0x2c>
    206c:	90 91 4f 05 	lds	r25, 0x054F
    2070:	91 50       	subi	r25, 0x01	; 1
    2072:	92 30       	cpi	r25, 0x02	; 2
    2074:	08 f4       	brcc	.+2      	; 0x2078 <StartRecording+0x2c>
    2076:	42 c0       	rjmp	.+132    	; 0x20fc <StartRecording+0xb0>
	{

		sreg=SREG;	// Store global interrupt state.
    2078:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    207a:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    207c:	93 e2       	ldi	r25, 0x23	; 35
    207e:	92 9f       	mul	r25, r18
    2080:	e0 01       	movw	r28, r0
    2082:	93 9f       	mul	r25, r19
    2084:	d0 0d       	add	r29, r0
    2086:	11 24       	eor	r1, r1
    2088:	ca 51       	subi	r28, 0x1A	; 26
    208a:	da 4f       	sbci	r29, 0xFA	; 250
    208c:	93 e0       	ldi	r25, 0x03	; 3
    208e:	98 83       	st	Y, r25

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    2090:	08 89       	ldd	r16, Y+16	; 0x10
    2092:	19 89       	ldd	r17, Y+17	; 0x11
    2094:	2a 89       	ldd	r18, Y+18	; 0x12
    2096:	3b 89       	ldd	r19, Y+19	; 0x13
    2098:	0f 8f       	std	Y+31, r16	; 0x1f
    209a:	18 a3       	std	Y+32, r17	; 0x20
    209c:	29 a3       	std	Y+33, r18	; 0x21
    209e:	3a a3       	std	Y+34, r19	; 0x22
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    20a0:	08 89       	ldd	r16, Y+16	; 0x10
    20a2:	19 89       	ldd	r17, Y+17	; 0x11
    20a4:	2a 89       	ldd	r18, Y+18	; 0x12
    20a6:	3b 89       	ldd	r19, Y+19	; 0x13
    20a8:	0c 87       	std	Y+12, r16	; 0x0c
    20aa:	1d 87       	std	Y+13, r17	; 0x0d
    20ac:	2e 87       	std	Y+14, r18	; 0x0e
    20ae:	3f 87       	std	Y+15, r19	; 0x0f
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    20b0:	08 89       	ldd	r16, Y+16	; 0x10
    20b2:	19 89       	ldd	r17, Y+17	; 0x11
    20b4:	2a 89       	ldd	r18, Y+18	; 0x12
    20b6:	3b 89       	ldd	r19, Y+19	; 0x13
    20b8:	08 8f       	std	Y+24, r16	; 0x18
    20ba:	19 8f       	std	Y+25, r17	; 0x19
    20bc:	2a 8f       	std	Y+26, r18	; 0x1a
    20be:	3b 8f       	std	Y+27, r19	; 0x1b
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    20c0:	08 89       	ldd	r16, Y+16	; 0x10
    20c2:	19 89       	ldd	r17, Y+17	; 0x11
    20c4:	2a 89       	ldd	r18, Y+18	; 0x12
    20c6:	3b 89       	ldd	r19, Y+19	; 0x13
    20c8:	0c 8b       	std	Y+20, r16	; 0x14
    20ca:	1d 8b       	std	Y+21, r17	; 0x15
    20cc:	2e 8b       	std	Y+22, r18	; 0x16
    20ce:	3f 8b       	std	Y+23, r19	; 0x17
		bankStates[theBank].sampleWindowOffset=0;									// "
    20d0:	1e 8e       	std	Y+30, r1	; 0x1e

		outOfRam=false;						// Plenty of ram left...
    20d2:	10 92 3f 04 	sts	0x043F, r1

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    20d6:	0e 94 75 0f 	call	0x1eea	; 0x1eea <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	8d 83       	std	Y+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    20de:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    20e0:	80 91 7a 00 	lds	r24, 0x007A
    20e4:	86 fd       	sbrc	r24, 6
    20e6:	0a c0       	rjmp	.+20     	; 0x20fc <StartRecording+0xb0>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    20e8:	80 91 79 00 	lds	r24, 0x0079
    20ec:	80 58       	subi	r24, 0x80	; 128
    20ee:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    20f2:	80 91 7a 00 	lds	r24, 0x007A
    20f6:	80 64       	ori	r24, 0x40	; 64
    20f8:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    20fc:	df 91       	pop	r29
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	ff 90       	pop	r15
    2106:	08 95       	ret

00002108 <StartOverdub>:
}

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    2108:	1f 93       	push	r17
    210a:	cf 93       	push	r28
    210c:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    210e:	28 2f       	mov	r18, r24
    2110:	30 e0       	ldi	r19, 0x00	; 0
    2112:	93 e2       	ldi	r25, 0x23	; 35
    2114:	89 9f       	mul	r24, r25
    2116:	f0 01       	movw	r30, r0
    2118:	11 24       	eor	r1, r1
    211a:	ea 51       	subi	r30, 0x1A	; 26
    211c:	fa 4f       	sbci	r31, 0xFA	; 250
    211e:	95 81       	ldd	r25, Z+5	; 0x05
    2120:	99 23       	and	r25, r25
    2122:	29 f0       	breq	.+10     	; 0x212e <StartOverdub+0x26>
    2124:	90 91 4f 05 	lds	r25, 0x054F
    2128:	91 50       	subi	r25, 0x01	; 1
    212a:	92 30       	cpi	r25, 0x02	; 2
    212c:	f8 f0       	brcs	.+62     	; 0x216c <StartOverdub+0x64>
	{
		sreg=SREG;	// Store global interrupt state.
    212e:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2130:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    2132:	93 e2       	ldi	r25, 0x23	; 35
    2134:	92 9f       	mul	r25, r18
    2136:	e0 01       	movw	r28, r0
    2138:	93 9f       	mul	r25, r19
    213a:	d0 0d       	add	r29, r0
    213c:	11 24       	eor	r1, r1
    213e:	ca 51       	subi	r28, 0x1A	; 26
    2140:	da 4f       	sbci	r29, 0xFA	; 250
    2142:	95 e0       	ldi	r25, 0x05	; 5
    2144:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    2146:	0e 94 75 0f 	call	0x1eea	; 0x1eea <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    214a:	81 e0       	ldi	r24, 0x01	; 1
    214c:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    214e:	1f bf       	out	0x3f, r17	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2150:	80 91 7a 00 	lds	r24, 0x007A
    2154:	86 fd       	sbrc	r24, 6
    2156:	0a c0       	rjmp	.+20     	; 0x216c <StartOverdub+0x64>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    2158:	80 91 79 00 	lds	r24, 0x0079
    215c:	80 58       	subi	r24, 0x80	; 128
    215e:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2162:	80 91 7a 00 	lds	r24, 0x007A
    2166:	80 64       	ori	r24, 0x40	; 64
    2168:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    216c:	df 91       	pop	r29
    216e:	cf 91       	pop	r28
    2170:	1f 91       	pop	r17
    2172:	08 95       	ret

00002174 <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
// Thu Nov 24 19:40:21 CST 2011
// OK to do realtime even when banks are locked since we don't use the RAM
{
    2174:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    2176:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    2178:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    217a:	93 e2       	ldi	r25, 0x23	; 35
    217c:	89 9f       	mul	r24, r25
    217e:	f0 01       	movw	r30, r0
    2180:	11 24       	eor	r1, r1
    2182:	ea 51       	subi	r30, 0x1A	; 26
    2184:	fa 4f       	sbci	r31, 0xFA	; 250
    2186:	92 e0       	ldi	r25, 0x02	; 2
    2188:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    218a:	0e 94 75 0f 	call	0x1eea	; 0x1eea <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    218e:	cf bf       	out	0x3f, r28	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2190:	80 91 7a 00 	lds	r24, 0x007A
    2194:	86 fd       	sbrc	r24, 6
    2196:	0a c0       	rjmp	.+20     	; 0x21ac <StartRealtime+0x38>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    2198:	80 91 79 00 	lds	r24, 0x0079
    219c:	80 58       	subi	r24, 0x80	; 128
    219e:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    21a2:	80 91 7a 00 	lds	r24, 0x007A
    21a6:	80 64       	ori	r24, 0x40	; 64
    21a8:	80 93 7a 00 	sts	0x007A, r24
	}
}
    21ac:	cf 91       	pop	r28
    21ae:	08 95       	ret

000021b0 <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    21b0:	80 91 5b 05 	lds	r24, 0x055B
    21b4:	81 11       	cpse	r24, r1
    21b6:	10 c0       	rjmp	.+32     	; 0x21d8 <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs
    21b8:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>

		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    21bc:	10 92 e6 05 	sts	0x05E6, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    21c0:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    21c4:	10 92 09 06 	sts	0x0609, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    21c8:	10 92 12 06 	sts	0x0612, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    21cc:	81 e8       	ldi	r24, 0x81	; 129
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		subState=SS_1;
    21d4:	81 e0       	ldi	r24, 0x01	; 1
    21d6:	13 c0       	rjmp	.+38     	; 0x21fe <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    21d8:	81 30       	cpi	r24, 0x01	; 1
    21da:	c9 f4       	brne	.+50     	; 0x220e <DoFormatCard+0x5e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    21dc:	80 91 58 05 	lds	r24, 0x0558
    21e0:	80 ff       	sbrs	r24, 0
    21e2:	10 c0       	rjmp	.+32     	; 0x2204 <DoFormatCard+0x54>
    21e4:	87 ff       	sbrs	r24, 7
    21e6:	0e c0       	rjmp	.+28     	; 0x2204 <DoFormatCard+0x54>
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    21e8:	86 e0       	ldi	r24, 0x06	; 6
    21ea:	80 93 59 05 	sts	0x0559, r24
			KillLeds();
    21ee:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
    21f2:	80 91 5d 05 	lds	r24, 0x055D
    21f6:	81 68       	ori	r24, 0x81	; 129
    21f8:	80 93 5d 05 	sts	0x055D, r24
			subState=SS_2;
    21fc:	82 e0       	ldi	r24, 0x02	; 2
    21fe:	80 93 5b 05 	sts	0x055B, r24
    2202:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    2204:	80 91 59 05 	lds	r24, 0x0559
    2208:	81 11       	cpse	r24, r1
    220a:	1e c0       	rjmp	.+60     	; 0x2248 <DoFormatCard+0x98>
    220c:	15 c0       	rjmp	.+42     	; 0x2238 <DoFormatCard+0x88>
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    220e:	82 30       	cpi	r24, 0x02	; 2
    2210:	d9 f4       	brne	.+54     	; 0x2248 <DoFormatCard+0x98>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    2212:	80 91 59 05 	lds	r24, 0x0559
    2216:	8e 30       	cpi	r24, 0x0E	; 14
    2218:	b9 f4       	brne	.+46     	; 0x2248 <DoFormatCard+0x98>
		{
			KillLeds();
    221a:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    221e:	80 91 5d 05 	lds	r24, 0x055D
    2222:	82 60       	ori	r24, 0x02	; 2
    2224:	80 93 5d 05 	sts	0x055D, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    2228:	80 91 59 05 	lds	r24, 0x0559
    222c:	88 23       	and	r24, r24
    222e:	21 f0       	breq	.+8      	; 0x2238 <DoFormatCard+0x88>
    2230:	80 91 57 05 	lds	r24, 0x0557
    2234:	88 23       	and	r24, r24
    2236:	41 f0       	breq	.+16     	; 0x2248 <DoFormatCard+0x98>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2238:	8b e7       	ldi	r24, 0x7B	; 123
    223a:	9e e0       	ldi	r25, 0x0E	; 14
    223c:	90 93 e5 05 	sts	0x05E5, r25
    2240:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2244:	10 92 5b 05 	sts	0x055B, r1
    2248:	08 95       	ret

0000224a <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    224a:	80 91 5b 05 	lds	r24, 0x055B
    224e:	81 11       	cpse	r24, r1
    2250:	08 c0       	rjmp	.+16     	; 0x2262 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    2252:	68 e9       	ldi	r22, 0x98	; 152
    2254:	70 e0       	ldi	r23, 0x00	; 0
    2256:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
		subState=SS_1;
    225a:	81 e0       	ldi	r24, 0x01	; 1
    225c:	80 93 5b 05 	sts	0x055B, r24
    2260:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    2262:	80 e0       	ldi	r24, 0x00	; 0
    2264:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    2268:	88 23       	and	r24, r24
    226a:	a1 f0       	breq	.+40     	; 0x2294 <DoStartupSelect+0x4a>
		{
			if(keyState&Im_SWITCH_0)
    226c:	80 91 58 05 	lds	r24, 0x0558
    2270:	80 ff       	sbrs	r24, 0
    2272:	03 c0       	rjmp	.+6      	; 0x227a <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2274:	8d e8       	ldi	r24, 0x8D	; 141
    2276:	91 e1       	ldi	r25, 0x11	; 17
    2278:	07 c0       	rjmp	.+14     	; 0x2288 <DoStartupSelect+0x3e>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    227a:	85 ff       	sbrs	r24, 5
    227c:	03 c0       	rjmp	.+6      	; 0x2284 <DoStartupSelect+0x3a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    227e:	82 e1       	ldi	r24, 0x12	; 18
    2280:	92 e1       	ldi	r25, 0x12	; 18
    2282:	02 c0       	rjmp	.+4      	; 0x2288 <DoStartupSelect+0x3e>
    2284:	88 e7       	ldi	r24, 0x78	; 120
    2286:	92 e1       	ldi	r25, 0x12	; 18
    2288:	90 93 e5 05 	sts	0x05E5, r25
    228c:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2290:	10 92 5b 05 	sts	0x055B, r1
    2294:	08 95       	ret

00002296 <PlaySampleFromSd>:
}

//static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot)
static void PlaySampleFromSd(unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    2296:	cf 93       	push	r28
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    2298:	20 91 59 05 	lds	r18, 0x0559
    229c:	2e 30       	cpi	r18, 0x0E	; 14
    229e:	09 f4       	brne	.+2      	; 0x22a2 <PlaySampleFromSd+0xc>
    22a0:	06 c0       	rjmp	.+12     	; 0x22ae <PlaySampleFromSd+0x18>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    22a2:	30 91 4f 05 	lds	r19, 0x054F
    22a6:	33 30       	cpi	r19, 0x03	; 3
    22a8:	b1 f5       	brne	.+108    	; 0x2316 <PlaySampleFromSd+0x80>
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    22aa:	2b 30       	cpi	r18, 0x0B	; 11
    22ac:	a1 f4       	brne	.+40     	; 0x22d6 <PlaySampleFromSd+0x40>
		{
			sreg=SREG;	 // Pause ISRs
    22ae:	cf b7       	in	r28, 0x3f	; 63
			cli();
    22b0:	f8 94       	cli

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    22b2:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <SdStartSampleRead>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    22b6:	81 e0       	ldi	r24, 0x01	; 1
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	a0 e0       	ldi	r26, 0x00	; 0
    22bc:	b0 e0       	ldi	r27, 0x00	; 0
    22be:	80 93 22 01 	sts	0x0122, r24
    22c2:	90 93 23 01 	sts	0x0123, r25
    22c6:	a0 93 24 01 	sts	0x0124, r26
    22ca:	b0 93 25 01 	sts	0x0125, r27
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
    22ce:	0e 94 ee 08 	call	0x11dc	; 0x11dc <SdIsrStartStreamingAudio>

			SREG=sreg;	// resume isr
    22d2:	cf bf       	out	0x3f, r28	; 63
    22d4:	20 c0       	rjmp	.+64     	; 0x2316 <PlaySampleFromSd+0x80>
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    22d6:	2d 30       	cpi	r18, 0x0D	; 13
    22d8:	21 f0       	breq	.+8      	; 0x22e2 <PlaySampleFromSd+0x4c>
    22da:	20 91 76 05 	lds	r18, 0x0576
    22de:	21 30       	cpi	r18, 0x01	; 1
    22e0:	29 f4       	brne	.+10     	; 0x22ec <PlaySampleFromSd+0x56>
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    22e2:	90 93 78 05 	sts	0x0578, r25
    22e6:	80 93 77 05 	sts	0x0577, r24
    22ea:	15 c0       	rjmp	.+42     	; 0x2316 <PlaySampleFromSd+0x80>
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    22ec:	90 93 78 05 	sts	0x0578, r25
    22f0:	80 93 77 05 	sts	0x0577, r24
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	80 93 79 05 	sts	0x0579, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    22fa:	80 93 76 05 	sts	0x0576, r24

			sreg=SREG;	 		// Pause ISRs
    22fe:	9f b7       	in	r25, 0x3f	; 63
			cli();
    2300:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    2302:	10 92 27 01 	sts	0x0127, r1
    2306:	10 92 26 01 	sts	0x0126, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    230a:	80 91 70 00 	lds	r24, 0x0070
    230e:	8b 7f       	andi	r24, 0xFB	; 251
    2310:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;
    2314:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    2316:	cf 91       	pop	r28
    2318:	08 95       	ret

0000231a <DoSawtooth>:
// Also test to see if our flash is present and working.
{
	static unsigned char
		lastShuttleRead;

	if(subState==SS_0)
    231a:	80 91 5b 05 	lds	r24, 0x055B
    231e:	81 11       	cpse	r24, r1
    2320:	08 c0       	rjmp	.+16     	; 0x2332 <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    2322:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    2326:	80 ec       	ldi	r24, 0xC0	; 192
    2328:	90 e0       	ldi	r25, 0x00	; 0
    232a:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		subState=SS_1;
    232e:	81 e0       	ldi	r24, 0x01	; 1
    2330:	17 c0       	rjmp	.+46     	; 0x2360 <DoSawtooth+0x46>
	}
	else if(subState==SS_1)
    2332:	81 30       	cpi	r24, 0x01	; 1
    2334:	c1 f4       	brne	.+48     	; 0x2366 <DoSawtooth+0x4c>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2336:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    2338:	80 93 e6 05 	sts	0x05E6, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    233c:	80 93 ef 05 	sts	0x05EF, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2340:	80 93 ef 05 	sts	0x05EF, r24
    2344:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <SetSampleClock.part.0>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2348:	85 e3       	ldi	r24, 0x35	; 53
    234a:	98 e0       	ldi	r25, 0x08	; 8
    234c:	90 93 e3 05 	sts	0x05E3, r25
    2350:	80 93 e2 05 	sts	0x05E2, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2354:	78 94       	sei

		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the leds when it changes.
    2356:	80 91 6b 05 	lds	r24, 0x056B
    235a:	80 93 7b 05 	sts	0x057B, r24

		subState=SS_2;					// And wait forever.
    235e:	82 e0       	ldi	r24, 0x02	; 2
    2360:	80 93 5b 05 	sts	0x055B, r24
    2364:	08 95       	ret
	}
	else if(subState==SS_2)
    2366:	82 30       	cpi	r24, 0x02	; 2
    2368:	09 f0       	breq	.+2      	; 0x236c <DoSawtooth+0x52>
    236a:	5b c0       	rjmp	.+182    	; 0x2422 <DoSawtooth+0x108>
	{

		if(newKeys&Im_SWITCH_0)
    236c:	80 91 57 05 	lds	r24, 0x0557
    2370:	80 ff       	sbrs	r24, 0
    2372:	06 c0       	rjmp	.+12     	; 0x2380 <DoSawtooth+0x66>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    2374:	90 91 5d 05 	lds	r25, 0x055D
    2378:	21 e0       	ldi	r18, 0x01	; 1
    237a:	92 27       	eor	r25, r18
    237c:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_1)
    2380:	81 ff       	sbrs	r24, 1
    2382:	06 c0       	rjmp	.+12     	; 0x2390 <DoSawtooth+0x76>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    2384:	90 91 5d 05 	lds	r25, 0x055D
    2388:	22 e0       	ldi	r18, 0x02	; 2
    238a:	92 27       	eor	r25, r18
    238c:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)
    2390:	82 ff       	sbrs	r24, 2
    2392:	06 c0       	rjmp	.+12     	; 0x23a0 <DoSawtooth+0x86>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    2394:	90 91 5d 05 	lds	r25, 0x055D
    2398:	24 e0       	ldi	r18, 0x04	; 4
    239a:	92 27       	eor	r25, r18
    239c:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_3)
    23a0:	83 ff       	sbrs	r24, 3
    23a2:	06 c0       	rjmp	.+12     	; 0x23b0 <DoSawtooth+0x96>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    23a4:	90 91 5d 05 	lds	r25, 0x055D
    23a8:	28 e0       	ldi	r18, 0x08	; 8
    23aa:	92 27       	eor	r25, r18
    23ac:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_4)
    23b0:	84 ff       	sbrs	r24, 4
    23b2:	06 c0       	rjmp	.+12     	; 0x23c0 <DoSawtooth+0xa6>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    23b4:	90 91 5d 05 	lds	r25, 0x055D
    23b8:	20 e1       	ldi	r18, 0x10	; 16
    23ba:	92 27       	eor	r25, r18
    23bc:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_5)
    23c0:	85 ff       	sbrs	r24, 5
    23c2:	06 c0       	rjmp	.+12     	; 0x23d0 <DoSawtooth+0xb6>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    23c4:	90 91 5d 05 	lds	r25, 0x055D
    23c8:	20 e2       	ldi	r18, 0x20	; 32
    23ca:	92 27       	eor	r25, r18
    23cc:	90 93 5d 05 	sts	0x055D, r25
		}

		if(newKeys&Im_SWITCH_6)
    23d0:	86 ff       	sbrs	r24, 6
    23d2:	0a c0       	rjmp	.+20     	; 0x23e8 <DoSawtooth+0xce>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    23d4:	80 e0       	ldi	r24, 0x00	; 0
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		}

		if(newKeys&Im_SWITCH_6)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    23dc:	80 91 5d 05 	lds	r24, 0x055D
    23e0:	90 e4       	ldi	r25, 0x40	; 64
    23e2:	89 27       	eor	r24, r25
    23e4:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_7)
    23e8:	80 91 57 05 	lds	r24, 0x0557
    23ec:	87 ff       	sbrs	r24, 7
    23ee:	09 c0       	rjmp	.+18     	; 0x2402 <DoSawtooth+0xe8>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    23f0:	80 e0       	ldi	r24, 0x00	; 0
    23f2:	90 e0       	ldi	r25, 0x00	; 0
    23f4:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    23f8:	80 91 5d 05 	lds	r24, 0x055D
    23fc:	80 58       	subi	r24, 0x80	; 128
    23fe:	80 93 5d 05 	sts	0x055D, r24
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
    2402:	90 91 7b 05 	lds	r25, 0x057B
    2406:	80 91 6b 05 	lds	r24, 0x056B
    240a:	98 17       	cp	r25, r24
    240c:	51 f0       	breq	.+20     	; 0x2422 <DoSawtooth+0x108>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    240e:	80 e0       	ldi	r24, 0x00	; 0
    2410:	90 e0       	ldi	r25, 0x00	; 0
    2412:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    2416:	80 91 6b 05 	lds	r24, 0x056B
    241a:	80 93 5d 05 	sts	0x055D, r24
			lastShuttleRead=encoderValue;
    241e:	80 93 7b 05 	sts	0x057B, r24
    2422:	08 95       	ret

00002424 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
    2424:	80 91 5b 05 	lds	r24, 0x055B
    2428:	81 11       	cpse	r24, r1
    242a:	1d c0       	rjmp	.+58     	; 0x2466 <SetMidiChannels+0x42>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    242c:	84 e0       	ldi	r24, 0x04	; 4
    242e:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    2432:	80 31       	cpi	r24, 0x10	; 16
    2434:	08 f0       	brcs	.+2      	; 0x2438 <SetMidiChannels+0x14>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2436:	80 e0       	ldi	r24, 0x00	; 0
static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    2438:	80 93 2e 06 	sts	0x062E, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    243c:	88 e0       	ldi	r24, 0x08	; 8
    243e:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <EepromRead>
	}

	if(x<16)					// Legit number?
    2442:	80 31       	cpi	r24, 0x10	; 16
    2444:	08 f0       	brcs	.+2      	; 0x2448 <SetMidiChannels+0x24>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2446:	81 e0       	ldi	r24, 0x01	; 1
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
		midiChannelNumberB=GetMidiChannel(BANK_1);
    2448:	80 93 47 06 	sts	0x0647, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    244c:	20 e1       	ldi	r18, 0x10	; 16
    244e:	82 9f       	mul	r24, r18
    2450:	c0 01       	movw	r24, r0
    2452:	11 24       	eor	r1, r1
    2454:	90 91 2e 06 	lds	r25, 0x062E
    2458:	98 2b       	or	r25, r24
    245a:	90 93 5d 05 	sts	0x055D, r25
		subState=SS_1;
    245e:	81 e0       	ldi	r24, 0x01	; 1
    2460:	80 93 5b 05 	sts	0x055B, r24
    2464:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    2466:	20 91 57 05 	lds	r18, 0x0557
    246a:	20 ff       	sbrs	r18, 0
    246c:	12 c0       	rjmp	.+36     	; 0x2492 <SetMidiChannels+0x6e>
		{
			midiChannelNumberA++;
    246e:	80 91 2e 06 	lds	r24, 0x062E
    2472:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    2474:	80 31       	cpi	r24, 0x10	; 16
    2476:	18 f4       	brcc	.+6      	; 0x247e <SetMidiChannels+0x5a>
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
    2478:	80 93 2e 06 	sts	0x062E, r24
    247c:	02 c0       	rjmp	.+4      	; 0x2482 <SetMidiChannels+0x5e>
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
    247e:	10 92 2e 06 	sts	0x062E, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    2482:	80 91 5d 05 	lds	r24, 0x055D
    2486:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    2488:	90 91 2e 06 	lds	r25, 0x062E
    248c:	89 2b       	or	r24, r25
    248e:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_1)
    2492:	21 ff       	sbrs	r18, 1
    2494:	16 c0       	rjmp	.+44     	; 0x24c2 <SetMidiChannels+0x9e>
		{
			midiChannelNumberB++;
    2496:	80 91 47 06 	lds	r24, 0x0647
    249a:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    249c:	80 31       	cpi	r24, 0x10	; 16
    249e:	18 f4       	brcc	.+6      	; 0x24a6 <SetMidiChannels+0x82>
			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
		}
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
    24a0:	80 93 47 06 	sts	0x0647, r24
    24a4:	02 c0       	rjmp	.+4      	; 0x24aa <SetMidiChannels+0x86>
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
    24a6:	10 92 47 06 	sts	0x0647, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    24aa:	80 91 47 06 	lds	r24, 0x0647
    24ae:	30 e1       	ldi	r19, 0x10	; 16
    24b0:	83 9f       	mul	r24, r19
    24b2:	c0 01       	movw	r24, r0
    24b4:	11 24       	eor	r1, r1
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    24b6:	90 91 5d 05 	lds	r25, 0x055D
    24ba:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    24bc:	98 2b       	or	r25, r24
    24be:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    24c2:	22 ff       	sbrs	r18, 2
    24c4:	14 c0       	rjmp	.+40     	; 0x24ee <SetMidiChannels+0xca>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    24c6:	60 91 2e 06 	lds	r22, 0x062E
    24ca:	84 e0       	ldi	r24, 0x04	; 4
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    24d2:	60 91 47 06 	lds	r22, 0x0647
    24d6:	88 e0       	ldi	r24, 0x08	; 8
    24d8:	90 e0       	ldi	r25, 0x00	; 0
    24da:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    24de:	88 e7       	ldi	r24, 0x78	; 120
    24e0:	92 e1       	ldi	r25, 0x12	; 18
    24e2:	90 93 e5 05 	sts	0x05E5, r25
    24e6:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    24ea:	10 92 5b 05 	sts	0x055B, r1
    24ee:	08 95       	ret

000024f0 <DoSampler>:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.

// Wed Apr  8 11:42:07 CDT 2009
// This state is based on the idea that playing, recording, and overdubbing are all discrete things and that if you're doing one you can't be doing another.
{
    24f0:	8f 92       	push	r8
    24f2:	9f 92       	push	r9
    24f4:	af 92       	push	r10
    24f6:	bf 92       	push	r11
    24f8:	cf 92       	push	r12
    24fa:	df 92       	push	r13
    24fc:	ef 92       	push	r14
    24fe:	ff 92       	push	r15
    2500:	0f 93       	push	r16
    2502:	1f 93       	push	r17
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	1f 92       	push	r1
    250a:	cd b7       	in	r28, 0x3d	; 61
    250c:	de b7       	in	r29, 0x3e	; 62
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

//	static bool
//		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
    250e:	f0 90 5b 05 	lds	r15, 0x055B
    2512:	f1 10       	cpse	r15, r1
    2514:	8d c0       	rjmp	.+282    	; 0x2630 <DoSampler+0x140>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    2516:	84 e0       	ldi	r24, 0x04	; 4
    2518:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    251c:	80 31       	cpi	r24, 0x10	; 16
    251e:	08 f0       	brcs	.+2      	; 0x2522 <DoSampler+0x32>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2520:	80 e0       	ldi	r24, 0x00	; 0
//		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    2522:	80 93 2e 06 	sts	0x062E, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    2526:	88 e0       	ldi	r24, 0x08	; 8
    2528:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <EepromRead>
	}

	if(x<16)					// Legit number?
    252c:	80 31       	cpi	r24, 0x10	; 16
    252e:	08 f0       	brcs	.+2      	; 0x2532 <DoSampler+0x42>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2530:	81 e0       	ldi	r24, 0x01	; 1

	if(subState==SS_0)
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    2532:	80 93 47 06 	sts	0x0647, r24
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    2536:	10 92 f6 05 	sts	0x05F6, r1
    253a:	10 92 f7 05 	sts	0x05F7, r1
    253e:	10 92 f8 05 	sts	0x05F8, r1
    2542:	10 92 f9 05 	sts	0x05F9, r1
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    2546:	8f ef       	ldi	r24, 0xFF	; 255
    2548:	9f ef       	ldi	r25, 0xFF	; 255
    254a:	a7 e0       	ldi	r26, 0x07	; 7
    254c:	b0 e0       	ldi	r27, 0x00	; 0
    254e:	80 93 19 06 	sts	0x0619, r24
    2552:	90 93 1a 06 	sts	0x061A, r25
    2556:	a0 93 1b 06 	sts	0x061B, r26
    255a:	b0 93 1c 06 	sts	0x061C, r27
    255e:	0e e5       	ldi	r16, 0x5E	; 94
    2560:	15 e0       	ldi	r17, 0x05	; 5
    2562:	70 e6       	ldi	r23, 0x60	; 96
    2564:	87 2e       	mov	r8, r23
    2566:	75 e0       	ldi	r23, 0x05	; 5
    2568:	97 2e       	mov	r9, r23
    256a:	e1 2c       	mov	r14, r1
    256c:	f1 2c       	mov	r15, r1

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    256e:	e3 e2       	ldi	r30, 0x23	; 35
    2570:	ce 2e       	mov	r12, r30
			bankStates[i].loopOnce=false;
			bankStates[i].bitReduction=0;				// No crusties yet.
			bankStates[i].jitterValue=0;				// No hissies yet.
			bankStates[i].granularSlices=0;				// No remix yet.
			bankStates[i].halfSpeed=false;
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2572:	bb 24       	eor	r11, r11
    2574:	b3 94       	inc	r11
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2576:	fc e0       	ldi	r31, 0x0C	; 12
    2578:	df 2e       	mov	r13, r31
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    257a:	ce 9c       	mul	r12, r14
    257c:	f0 01       	movw	r30, r0
    257e:	cf 9c       	mul	r12, r15
    2580:	f0 0d       	add	r31, r0
    2582:	11 24       	eor	r1, r1
    2584:	ea 51       	subi	r30, 0x1A	; 26
    2586:	fa 4f       	sbci	r31, 0xFA	; 250
    2588:	10 82       	st	Z, r1
			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    258a:	11 86       	std	Z+9, r1	; 0x09
			bankStates[i].loopOnce=false;
    258c:	11 82       	std	Z+1, r1	; 0x01
			bankStates[i].bitReduction=0;				// No crusties yet.
    258e:	10 86       	std	Z+8, r1	; 0x08
			bankStates[i].jitterValue=0;				// No hissies yet.
    2590:	17 82       	std	Z+7, r1	; 0x07
			bankStates[i].granularSlices=0;				// No remix yet.
    2592:	16 82       	std	Z+6, r1	; 0x06
			bankStates[i].halfSpeed=false;
    2594:	12 82       	std	Z+2, r1	; 0x02
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2596:	b4 82       	std	Z+4, r11	; 0x04
			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    2598:	13 82       	std	Z+3, r1	; 0x03
			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    259a:	80 89       	ldd	r24, Z+16	; 0x10
    259c:	91 89       	ldd	r25, Z+17	; 0x11
    259e:	a2 89       	ldd	r26, Z+18	; 0x12
    25a0:	b3 89       	ldd	r27, Z+19	; 0x13
    25a2:	87 8f       	std	Z+31, r24	; 0x1f
    25a4:	90 a3       	std	Z+32, r25	; 0x20
    25a6:	a1 a3       	std	Z+33, r26	; 0x21
    25a8:	b2 a3       	std	Z+34, r27	; 0x22
			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    25aa:	80 89       	ldd	r24, Z+16	; 0x10
    25ac:	91 89       	ldd	r25, Z+17	; 0x11
    25ae:	a2 89       	ldd	r26, Z+18	; 0x12
    25b0:	b3 89       	ldd	r27, Z+19	; 0x13
    25b2:	84 87       	std	Z+12, r24	; 0x0c
    25b4:	95 87       	std	Z+13, r25	; 0x0d
    25b6:	a6 87       	std	Z+14, r26	; 0x0e
    25b8:	b7 87       	std	Z+15, r27	; 0x0f
			realtimeOn[i]=false;								// We'll default to playback.
    25ba:	d8 01       	movw	r26, r16
    25bc:	1d 92       	st	X+, r1
    25be:	8d 01       	movw	r16, r26
			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    25c0:	15 82       	std	Z+5, r1	; 0x05
//			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
    25c2:	8e 2d       	mov	r24, r14
    25c4:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    25c8:	e1 10       	cpse	r14, r1
    25ca:	02 c0       	rjmp	.+4      	; 0x25d0 <DoSampler+0xe0>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    25cc:	87 e0       	ldi	r24, 0x07	; 7
    25ce:	01 c0       	rjmp	.+2      	; 0x25d2 <DoSampler+0xe2>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    25d0:	8b e0       	ldi	r24, 0x0B	; 11
    25d2:	0e 94 e0 1d 	call	0x3bc0	; 0x3bc0 <EepromRead>
	}

	if(x<90)					// Legit number?
    25d6:	8a 35       	cpi	r24, 0x5A	; 90
    25d8:	08 f0       	brcs	.+2      	; 0x25dc <DoSampler+0xec>
		return(x);
	}
	else
	{
		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or whatever).
		return(x);
    25da:	80 e3       	ldi	r24, 0x30	; 48
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    25dc:	6d 2d       	mov	r22, r13
    25de:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    25e2:	e9 2f       	mov	r30, r25
    25e4:	f0 e0       	ldi	r31, 0x00	; 0
    25e6:	ee 0f       	add	r30, r30
    25e8:	ff 1f       	adc	r31, r31
    25ea:	ea 5f       	subi	r30, 0xFA	; 250
    25ec:	fe 4f       	sbci	r31, 0xFE	; 254
    25ee:	20 81       	ld	r18, Z
    25f0:	31 81       	ldd	r19, Z+1	; 0x01
    25f2:	02 c0       	rjmp	.+4      	; 0x25f8 <DoSampler+0x108>
    25f4:	36 95       	lsr	r19
    25f6:	27 95       	ror	r18
    25f8:	8a 95       	dec	r24
    25fa:	e2 f7       	brpl	.-8      	; 0x25f4 <DoSampler+0x104>
//			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    25fc:	f4 01       	movw	r30, r8
    25fe:	21 93       	st	Z+, r18
    2600:	31 93       	st	Z+, r19
    2602:	4f 01       	movw	r8, r30
    2604:	ff ef       	ldi	r31, 0xFF	; 255
    2606:	ef 1a       	sub	r14, r31
    2608:	ff 0a       	sbc	r15, r31
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    260a:	22 e0       	ldi	r18, 0x02	; 2
    260c:	e2 16       	cp	r14, r18
    260e:	f1 04       	cpc	r15, r1
    2610:	09 f0       	breq	.+2      	; 0x2614 <DoSampler+0x124>
    2612:	b3 cf       	rjmp	.-154    	; 0x257a <DoSampler+0x8a>

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
		}

		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2614:	85 e3       	ldi	r24, 0x35	; 53
    2616:	98 e0       	ldi	r25, 0x08	; 8
    2618:	90 93 e3 05 	sts	0x05E3, r25
    261c:	80 93 e2 05 	sts	0x05E2, r24

		currentBank=BANK_0;			// Point at the first bank until we change banks.
    2620:	10 92 64 05 	sts	0x0564, r1

		KillLeds();					// All leds off, and no blinking.
    2624:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		subState=SS_1;
    2628:	81 e0       	ldi	r24, 0x01	; 1
    262a:	80 93 5b 05 	sts	0x055B, r24
    262e:	12 c6       	rjmp	.+3108   	; 0x3254 <DoSampler+0xd64>
	}

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    2630:	41 e0       	ldi	r20, 0x01	; 1
    2632:	f4 12       	cpse	r15, r20
    2634:	0f c6       	rjmp	.+3102   	; 0x3254 <DoSampler+0xd64>
			lastEncoderValue;

	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
    2636:	80 91 6a 05 	lds	r24, 0x056A
    263a:	86 ff       	sbrs	r24, 6
    263c:	30 c2       	rjmp	.+1120   	; 0x2a9e <DoSampler+0x5ae>
    263e:	87 ff       	sbrs	r24, 7
    2640:	75 c1       	rjmp	.+746    	; 0x292c <DoSampler+0x43c>
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
    2642:	80 91 57 05 	lds	r24, 0x0557
    2646:	85 ff       	sbrs	r24, 5
    2648:	24 c0       	rjmp	.+72     	; 0x2692 <DoSampler+0x1a2>
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    264a:	85 e3       	ldi	r24, 0x35	; 53
    264c:	98 e0       	ldi	r25, 0x08	; 8
    264e:	90 93 e3 05 	sts	0x05E3, r25
    2652:	80 93 e2 05 	sts	0x05E2, r24
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    2656:	10 91 64 05 	lds	r17, 0x0564
    265a:	81 2f       	mov	r24, r17
    265c:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
			bankStates[currentBank].bitReduction=0;			// No crusties yet.
    2660:	83 e2       	ldi	r24, 0x23	; 35
    2662:	18 9f       	mul	r17, r24
    2664:	f0 01       	movw	r30, r0
    2666:	11 24       	eor	r1, r1
    2668:	ea 51       	subi	r30, 0x1A	; 26
    266a:	fa 4f       	sbci	r31, 0xFA	; 250
    266c:	10 86       	std	Z+8, r1	; 0x08
			bankStates[currentBank].jitterValue=0;			// No hissies yet.
    266e:	17 82       	std	Z+7, r1	; 0x07
			bankStates[currentBank].granularSlices=0;		// No remix yet.
    2670:	16 82       	std	Z+6, r1	; 0x06
			bankStates[currentBank].halfSpeed=false;
    2672:	12 82       	std	Z+2, r1	; 0x02
			bankStates[currentBank].backwardsPlayback=false;
    2674:	13 82       	std	Z+3, r1	; 0x03
			bankStates[currentBank].sampleDirection=true;
    2676:	f4 82       	std	Z+4, r15	; 0x04
			bankStates[currentBank].loopOnce=false;
    2678:	11 82       	std	Z+1, r1	; 0x01
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
    267a:	20 e0       	ldi	r18, 0x00	; 0
    267c:	42 e1       	ldi	r20, 0x12	; 18
    267e:	64 e0       	ldi	r22, 0x04	; 4
    2680:	81 2f       	mov	r24, r17
    2682:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
    2686:	20 e0       	ldi	r18, 0x00	; 0
    2688:	4b e1       	ldi	r20, 0x1B	; 27
    268a:	64 e0       	ldi	r22, 0x04	; 4
    268c:	80 91 64 05 	lds	r24, 0x0564
    2690:	0b c3       	rjmp	.+1558   	; 0x2ca8 <DoSampler+0x7b8>
		}
		else if(newKeys&Im_SWITCH_0)
    2692:	80 ff       	sbrs	r24, 0
    2694:	ef c0       	rjmp	.+478    	; 0x2874 <DoSampler+0x384>
		{
			// Enter SD card menu
			WriteSampleToSd(currentBank,0);		// @@@ test
    2696:	10 91 64 05 	lds	r17, 0x0564
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    269a:	80 91 59 05 	lds	r24, 0x0559
    269e:	8e 30       	cpi	r24, 0x0E	; 14
    26a0:	09 f0       	breq	.+2      	; 0x26a4 <DoSampler+0x1b4>
    26a2:	4d c3       	rjmp	.+1690   	; 0x2d3e <DoSampler+0x84e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    26a4:	21 2f       	mov	r18, r17
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    26a8:	93 e2       	ldi	r25, 0x23	; 35
    26aa:	19 9f       	mul	r17, r25
    26ac:	d0 01       	movw	r26, r0
    26ae:	11 24       	eor	r1, r1
    26b0:	aa 51       	subi	r26, 0x1A	; 26
    26b2:	ba 4f       	sbci	r27, 0xFA	; 250
    26b4:	15 96       	adiw	r26, 0x05	; 5
    26b6:	8c 91       	ld	r24, X
    26b8:	15 97       	sbiw	r26, 0x05	; 5
    26ba:	81 11       	cpse	r24, r1
    26bc:	40 c3       	rjmp	.+1664   	; 0x2d3e <DoSampler+0x84e>
	unsigned long
		theLength;

	if(theBank==BANK_0)
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    26be:	16 96       	adiw	r26, 0x06	; 6
    26c0:	8c 91       	ld	r24, X
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    26c2:	11 11       	cpse	r17, r1
    26c4:	23 c0       	rjmp	.+70     	; 0x270c <DoSampler+0x21c>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    26c6:	81 11       	cpse	r24, r1
    26c8:	12 c0       	rjmp	.+36     	; 0x26ee <DoSampler+0x1fe>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    26ca:	83 e2       	ldi	r24, 0x23	; 35
    26cc:	82 9f       	mul	r24, r18
    26ce:	a0 01       	movw	r20, r0
    26d0:	83 9f       	mul	r24, r19
    26d2:	50 0d       	add	r21, r0
    26d4:	11 24       	eor	r1, r1
    26d6:	4a 51       	subi	r20, 0x1A	; 26
    26d8:	5a 4f       	sbci	r21, 0xFA	; 250
    26da:	fa 01       	movw	r30, r20
    26dc:	84 89       	ldd	r24, Z+20	; 0x14
    26de:	95 89       	ldd	r25, Z+21	; 0x15
    26e0:	a6 89       	ldd	r26, Z+22	; 0x16
    26e2:	b7 89       	ldd	r27, Z+23	; 0x17
    26e4:	40 8d       	ldd	r20, Z+24	; 0x18
    26e6:	51 8d       	ldd	r21, Z+25	; 0x19
    26e8:	62 8d       	ldd	r22, Z+26	; 0x1a
    26ea:	73 8d       	ldd	r23, Z+27	; 0x1b
    26ec:	22 c0       	rjmp	.+68     	; 0x2732 <DoSampler+0x242>
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    26ee:	83 e2       	ldi	r24, 0x23	; 35
    26f0:	82 9f       	mul	r24, r18
    26f2:	d0 01       	movw	r26, r0
    26f4:	83 9f       	mul	r24, r19
    26f6:	b0 0d       	add	r27, r0
    26f8:	11 24       	eor	r1, r1
    26fa:	aa 51       	subi	r26, 0x1A	; 26
    26fc:	ba 4f       	sbci	r27, 0xFA	; 250
    26fe:	1c 96       	adiw	r26, 0x0c	; 12
    2700:	8d 91       	ld	r24, X+
    2702:	9d 91       	ld	r25, X+
    2704:	0d 90       	ld	r0, X+
    2706:	bc 91       	ld	r27, X
    2708:	a0 2d       	mov	r26, r0
    270a:	2c c0       	rjmp	.+88     	; 0x2764 <DoSampler+0x274>
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    270c:	81 11       	cpse	r24, r1
    270e:	15 c0       	rjmp	.+42     	; 0x273a <DoSampler+0x24a>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    2710:	83 e2       	ldi	r24, 0x23	; 35
    2712:	82 9f       	mul	r24, r18
    2714:	a0 01       	movw	r20, r0
    2716:	83 9f       	mul	r24, r19
    2718:	50 0d       	add	r21, r0
    271a:	11 24       	eor	r1, r1
    271c:	4a 51       	subi	r20, 0x1A	; 26
    271e:	5a 4f       	sbci	r21, 0xFA	; 250
    2720:	fa 01       	movw	r30, r20
    2722:	80 8d       	ldd	r24, Z+24	; 0x18
    2724:	91 8d       	ldd	r25, Z+25	; 0x19
    2726:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2728:	b3 8d       	ldd	r27, Z+27	; 0x1b
    272a:	44 89       	ldd	r20, Z+20	; 0x14
    272c:	55 89       	ldd	r21, Z+21	; 0x15
    272e:	66 89       	ldd	r22, Z+22	; 0x16
    2730:	77 89       	ldd	r23, Z+23	; 0x17
    2732:	01 96       	adiw	r24, 0x01	; 1
    2734:	a1 1d       	adc	r26, r1
    2736:	b1 1d       	adc	r27, r1
    2738:	11 c0       	rjmp	.+34     	; 0x275c <DoSampler+0x26c>
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    273a:	83 e2       	ldi	r24, 0x23	; 35
    273c:	82 9f       	mul	r24, r18
    273e:	a0 01       	movw	r20, r0
    2740:	83 9f       	mul	r24, r19
    2742:	50 0d       	add	r21, r0
    2744:	11 24       	eor	r1, r1
    2746:	4a 51       	subi	r20, 0x1A	; 26
    2748:	5a 4f       	sbci	r21, 0xFA	; 250
    274a:	fa 01       	movw	r30, r20
    274c:	80 89       	ldd	r24, Z+16	; 0x10
    274e:	91 89       	ldd	r25, Z+17	; 0x11
    2750:	a2 89       	ldd	r26, Z+18	; 0x12
    2752:	b3 89       	ldd	r27, Z+19	; 0x13
    2754:	44 85       	ldd	r20, Z+12	; 0x0c
    2756:	55 85       	ldd	r21, Z+13	; 0x0d
    2758:	66 85       	ldd	r22, Z+14	; 0x0e
    275a:	77 85       	ldd	r23, Z+15	; 0x0f
    275c:	84 1b       	sub	r24, r20
    275e:	95 0b       	sbc	r25, r21
    2760:	a6 0b       	sbc	r26, r22
    2762:	b7 0b       	sbc	r27, r23
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    2764:	ff b7       	in	r31, 0x3f	; 63
			cli();		// Pause ISR
    2766:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    2768:	ef b7       	in	r30, 0x3f	; 63
	cli();		// Pause ISR
    276a:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    276c:	10 92 6f 05 	sts	0x056F, r1
    2770:	10 92 6e 05 	sts	0x056E, r1
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    2774:	41 e0       	ldi	r20, 0x01	; 1
    2776:	50 e0       	ldi	r21, 0x00	; 0
    2778:	60 e0       	ldi	r22, 0x00	; 0
    277a:	70 e0       	ldi	r23, 0x00	; 0
    277c:	40 93 70 05 	sts	0x0570, r20
    2780:	50 93 71 05 	sts	0x0571, r21
    2784:	60 93 72 05 	sts	0x0572, r22
    2788:	70 93 73 05 	sts	0x0573, r23
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    278c:	10 92 75 05 	sts	0x0575, r1
    2790:	10 92 74 05 	sts	0x0574, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    2794:	10 92 2b 01 	sts	0x012B, r1
    2798:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    279c:	10 92 29 01 	sts	0x0129, r1
    27a0:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    27a4:	10 92 27 01 	sts	0x0127, r1
    27a8:	10 92 26 01 	sts	0x0126, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    27ac:	8d 3f       	cpi	r24, 0xFD	; 253
    27ae:	4f ef       	ldi	r20, 0xFF	; 255
    27b0:	94 07       	cpc	r25, r20
    27b2:	47 e0       	ldi	r20, 0x07	; 7
    27b4:	a4 07       	cpc	r26, r20
    27b6:	b1 05       	cpc	r27, r1
    27b8:	08 f4       	brcc	.+2      	; 0x27bc <DoSampler+0x2cc>
    27ba:	04 c0       	rjmp	.+8      	; 0x27c4 <DoSampler+0x2d4>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    27bc:	8c ef       	ldi	r24, 0xFC	; 252
    27be:	9f ef       	ldi	r25, 0xFF	; 255
    27c0:	a7 e0       	ldi	r26, 0x07	; 7
    27c2:	b0 e0       	ldi	r27, 0x00	; 0
    27c4:	80 93 22 01 	sts	0x0122, r24
    27c8:	90 93 23 01 	sts	0x0123, r25
    27cc:	a0 93 24 01 	sts	0x0124, r26
    27d0:	b0 93 25 01 	sts	0x0125, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    27d4:	80 91 22 01 	lds	r24, 0x0122
    27d8:	90 91 23 01 	lds	r25, 0x0123
    27dc:	a0 91 24 01 	lds	r26, 0x0124
    27e0:	b0 91 25 01 	lds	r27, 0x0125
    27e4:	80 93 1e 01 	sts	0x011E, r24
    27e8:	90 93 1f 01 	sts	0x011F, r25
    27ec:	a0 93 20 01 	sts	0x0120, r26
    27f0:	b0 93 21 01 	sts	0x0121, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start
    27f4:	82 e0       	ldi	r24, 0x02	; 2
    27f6:	80 93 59 05 	sts	0x0559, r24
	SREG=sreg;	// Resume ISR
    27fa:	ef bf       	out	0x3f, r30	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;

	sreg=SREG;
    27fc:	4f b7       	in	r20, 0x3f	; 63
	cli();		// Pause ISRs
    27fe:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    2800:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    2804:	83 e2       	ldi	r24, 0x23	; 35
    2806:	82 9f       	mul	r24, r18
    2808:	d0 01       	movw	r26, r0
    280a:	83 9f       	mul	r24, r19
    280c:	b0 0d       	add	r27, r0
    280e:	11 24       	eor	r1, r1
    2810:	aa 51       	subi	r26, 0x1A	; 26
    2812:	ba 4f       	sbci	r27, 0xFA	; 250
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	15 96       	adiw	r26, 0x05	; 5
    2818:	8c 93       	st	X, r24

	if(theBank==BANK_0)		// Pointing at this bank?
    281a:	11 11       	cpse	r17, r1
    281c:	0b c0       	rjmp	.+22     	; 0x2834 <DoSampler+0x344>
	{
		sdBank0=true;
    281e:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    2822:	10 92 50 05 	sts	0x0550, r1
    2826:	10 92 51 05 	sts	0x0551, r1
    282a:	10 92 52 05 	sts	0x0552, r1
    282e:	10 92 53 05 	sts	0x0553, r1
    2832:	0e c0       	rjmp	.+28     	; 0x2850 <DoSampler+0x360>
	}
	else
	{
		sdBank0=false;
    2834:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    2838:	8f ef       	ldi	r24, 0xFF	; 255
    283a:	9f ef       	ldi	r25, 0xFF	; 255
    283c:	a7 e0       	ldi	r26, 0x07	; 7
    283e:	b0 e0       	ldi	r27, 0x00	; 0
    2840:	80 93 50 05 	sts	0x0550, r24
    2844:	90 93 51 05 	sts	0x0551, r25
    2848:	a0 93 52 05 	sts	0x0552, r26
    284c:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    2850:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    2854:	81 e6       	ldi	r24, 0x61	; 97
    2856:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    285a:	8f ef       	ldi	r24, 0xFF	; 255
    285c:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    285e:	80 91 70 00 	lds	r24, 0x0070
    2862:	84 60       	ori	r24, 0x04	; 4
    2864:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2868:	82 e0       	ldi	r24, 0x02	; 2
    286a:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    286e:	4f bf       	out	0x3f, r20	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    2870:	ff bf       	out	0x3f, r31	; 63
    2872:	65 c2       	rjmp	.+1226   	; 0x2d3e <DoSampler+0x84e>
		else if(newKeys&Im_SWITCH_0)
		{
			// Enter SD card menu
			WriteSampleToSd(currentBank,0);		// @@@ test
		}
		else if(newKeys&Im_SWITCH_1)
    2874:	81 ff       	sbrs	r24, 1
    2876:	63 c2       	rjmp	.+1222   	; 0x2d3e <DoSampler+0x84e>
		{
			// Enter SD card menu
			ReadSampleFromSd(currentBank,0);	// @@@ test
    2878:	10 91 64 05 	lds	r17, 0x0564
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    287c:	80 91 59 05 	lds	r24, 0x0559
    2880:	8e 30       	cpi	r24, 0x0E	; 14
    2882:	09 f0       	breq	.+2      	; 0x2886 <DoSampler+0x396>
    2884:	5c c2       	rjmp	.+1208   	; 0x2d3e <DoSampler+0x84e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    2886:	83 e2       	ldi	r24, 0x23	; 35
    2888:	18 9f       	mul	r17, r24
    288a:	60 01       	movw	r12, r0
    288c:	11 24       	eor	r1, r1
    288e:	a6 ee       	ldi	r26, 0xE6	; 230
    2890:	b5 e0       	ldi	r27, 0x05	; 5
    2892:	ca 0e       	add	r12, r26
    2894:	db 1e       	adc	r13, r27
    2896:	f6 01       	movw	r30, r12
    2898:	85 81       	ldd	r24, Z+5	; 0x05
    289a:	81 11       	cpse	r24, r1
    289c:	50 c2       	rjmp	.+1184   	; 0x2d3e <DoSampler+0x84e>
		{
			sreg=SREG;
    289e:	0f b7       	in	r16, 0x3f	; 63
			cli();		// Pause ISR
    28a0:	f8 94       	cli

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
    28a2:	80 e0       	ldi	r24, 0x00	; 0
    28a4:	90 e0       	ldi	r25, 0x00	; 0
    28a6:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <SdStartSampleRead>
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    28aa:	81 e0       	ldi	r24, 0x01	; 1
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	a0 e0       	ldi	r26, 0x00	; 0
    28b0:	b0 e0       	ldi	r27, 0x00	; 0
    28b2:	80 93 22 01 	sts	0x0122, r24
    28b6:	90 93 23 01 	sts	0x0123, r25
    28ba:	a0 93 24 01 	sts	0x0124, r26
    28be:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;

	sreg=SREG;
    28c2:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    28c4:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    28c6:	f0 92 4f 05 	sts	0x054F, r15
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    28ca:	d6 01       	movw	r26, r12
    28cc:	15 96       	adiw	r26, 0x05	; 5
    28ce:	fc 92       	st	X, r15

	if(theBank==BANK_0)		// Pointing at this bank?
    28d0:	11 11       	cpse	r17, r1
    28d2:	0c c0       	rjmp	.+24     	; 0x28ec <DoSampler+0x3fc>
	{
		sdBank0=true;
    28d4:	81 e0       	ldi	r24, 0x01	; 1
    28d6:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    28da:	10 92 50 05 	sts	0x0550, r1
    28de:	10 92 51 05 	sts	0x0551, r1
    28e2:	10 92 52 05 	sts	0x0552, r1
    28e6:	10 92 53 05 	sts	0x0553, r1
    28ea:	0e c0       	rjmp	.+28     	; 0x2908 <DoSampler+0x418>
	}
	else
	{
		sdBank0=false;
    28ec:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    28f0:	8f ef       	ldi	r24, 0xFF	; 255
    28f2:	9f ef       	ldi	r25, 0xFF	; 255
    28f4:	a7 e0       	ldi	r26, 0x07	; 7
    28f6:	b0 e0       	ldi	r27, 0x00	; 0
    28f8:	80 93 50 05 	sts	0x0550, r24
    28fc:	90 93 51 05 	sts	0x0551, r25
    2900:	a0 93 52 05 	sts	0x0552, r26
    2904:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    2908:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    290c:	81 e6       	ldi	r24, 0x61	; 97
    290e:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2912:	8f ef       	ldi	r24, 0xFF	; 255
    2914:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2916:	80 91 70 00 	lds	r24, 0x0070
    291a:	84 60       	ori	r24, 0x04	; 4
    291c:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2920:	82 e0       	ldi	r24, 0x02	; 2
    2922:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    2926:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    2928:	0f bf       	out	0x3f, r16	; 63
    292a:	09 c2       	rjmp	.+1042   	; 0x2d3e <DoSampler+0x84e>
	// -----------------------------------------------------------------------------------
	// Shift 1:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    292c:	80 91 58 05 	lds	r24, 0x0558
    2930:	80 ff       	sbrs	r24, 0
    2932:	15 c0       	rjmp	.+42     	; 0x295e <DoSampler+0x46e>
		{
			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pressed
    2934:	90 91 6b 05 	lds	r25, 0x056B
    2938:	80 91 6c 05 	lds	r24, 0x056C
    293c:	98 17       	cp	r25, r24
    293e:	79 f0       	breq	.+30     	; 0x295e <DoSampler+0x46e>
			{
				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    2940:	80 91 64 05 	lds	r24, 0x0564
    2944:	20 91 6d 05 	lds	r18, 0x056D
    2948:	b3 e2       	ldi	r27, 0x23	; 35
    294a:	8b 9f       	mul	r24, r27
    294c:	f0 01       	movw	r30, r0
    294e:	11 24       	eor	r1, r1
    2950:	ea 51       	subi	r30, 0x1A	; 26
    2952:	fa 4f       	sbci	r31, 0xFA	; 250
    2954:	20 87       	std	Z+8, r18	; 0x08
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    2956:	43 e1       	ldi	r20, 0x13	; 19
    2958:	64 e0       	ldi	r22, 0x04	; 4
    295a:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
    295e:	80 91 57 05 	lds	r24, 0x0557
    2962:	81 ff       	sbrs	r24, 1
    2964:	15 c0       	rjmp	.+42     	; 0x2990 <DoSampler+0x4a0>
		{
			if(bankStates[currentBank].halfSpeed==false)
    2966:	80 91 64 05 	lds	r24, 0x0564
    296a:	23 e2       	ldi	r18, 0x23	; 35
    296c:	82 9f       	mul	r24, r18
    296e:	f0 01       	movw	r30, r0
    2970:	11 24       	eor	r1, r1
    2972:	ea 51       	subi	r30, 0x1A	; 26
    2974:	fa 4f       	sbci	r31, 0xFA	; 250
    2976:	92 81       	ldd	r25, Z+2	; 0x02
    2978:	91 11       	cpse	r25, r1
    297a:	04 c0       	rjmp	.+8      	; 0x2984 <DoSampler+0x494>
			{
				bankStates[currentBank].halfSpeed=true;
    297c:	91 e0       	ldi	r25, 0x01	; 1
    297e:	92 83       	std	Z+2, r25	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2980:	20 e4       	ldi	r18, 0x40	; 64
    2982:	02 c0       	rjmp	.+4      	; 0x2988 <DoSampler+0x498>
			}
			else
			{
				bankStates[currentBank].halfSpeed=false;
    2984:	12 82       	std	Z+2, r1	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    2986:	20 e0       	ldi	r18, 0x00	; 0
    2988:	40 e1       	ldi	r20, 0x10	; 16
    298a:	64 e0       	ldi	r22, 0x04	; 4
    298c:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
    2990:	80 91 57 05 	lds	r24, 0x0557
    2994:	82 ff       	sbrs	r24, 2
    2996:	0e c0       	rjmp	.+28     	; 0x29b4 <DoSampler+0x4c4>
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
    2998:	10 91 64 05 	lds	r17, 0x0564
    299c:	40 e0       	ldi	r20, 0x00	; 0
    299e:	50 e0       	ldi	r21, 0x00	; 0
    29a0:	61 e0       	ldi	r22, 0x01	; 1
    29a2:	81 2f       	mov	r24, r17
    29a4:	0e 94 ba 10 	call	0x2174	; 0x2174 <StartRealtime>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    29a8:	20 e3       	ldi	r18, 0x30	; 48
    29aa:	4e e0       	ldi	r20, 0x0E	; 14
    29ac:	64 e0       	ldi	r22, 0x04	; 4
    29ae:	81 2f       	mov	r24, r17
    29b0:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
		}
		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granularize the sample -- reshuffle if the encoder moves OR we get a new button press, but not just while the button is held
    29b4:	80 91 58 05 	lds	r24, 0x0558
    29b8:	83 ff       	sbrs	r24, 3
    29ba:	06 c0       	rjmp	.+12     	; 0x29c8 <DoSampler+0x4d8>
    29bc:	90 91 6b 05 	lds	r25, 0x056B
    29c0:	80 91 6c 05 	lds	r24, 0x056C
    29c4:	98 13       	cpse	r25, r24
    29c6:	04 c0       	rjmp	.+8      	; 0x29d0 <DoSampler+0x4e0>
    29c8:	80 91 57 05 	lds	r24, 0x0557
    29cc:	83 ff       	sbrs	r24, 3
    29ce:	10 c0       	rjmp	.+32     	; 0x29f0 <DoSampler+0x500>
		{
			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
    29d0:	20 91 6b 05 	lds	r18, 0x056B
    29d4:	26 95       	lsr	r18
    29d6:	10 91 64 05 	lds	r17, 0x0564
    29da:	62 2f       	mov	r22, r18
    29dc:	81 2f       	mov	r24, r17
    29de:	29 83       	std	Y+1, r18	; 0x01
    29e0:	0e 94 2d 09 	call	0x125a	; 0x125a <MakeNewGranularArray>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    29e4:	29 81       	ldd	r18, Y+1	; 0x01
    29e6:	44 e1       	ldi	r20, 0x14	; 20
    29e8:	64 e0       	ldi	r22, 0x04	; 4
    29ea:	81 2f       	mov	r24, r17
    29ec:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
    29f0:	80 91 58 05 	lds	r24, 0x0558
    29f4:	84 ff       	sbrs	r24, 4
    29f6:	35 c0       	rjmp	.+106    	; 0x2a62 <DoSampler+0x572>
		{
			if(encoderValue!=lastEncoderValue)	// Only change to new values
    29f8:	90 91 6b 05 	lds	r25, 0x056B
    29fc:	80 91 6c 05 	lds	r24, 0x056C
    2a00:	98 17       	cp	r25, r24
    2a02:	79 f1       	breq	.+94     	; 0x2a62 <DoSampler+0x572>
			{
				switch(scaledEncoderValue)
    2a04:	80 91 6d 05 	lds	r24, 0x056D
    2a08:	81 30       	cpi	r24, 0x01	; 1
    2a0a:	71 f0       	breq	.+28     	; 0x2a28 <DoSampler+0x538>
    2a0c:	28 f0       	brcs	.+10     	; 0x2a18 <DoSampler+0x528>
    2a0e:	82 30       	cpi	r24, 0x02	; 2
    2a10:	99 f0       	breq	.+38     	; 0x2a38 <DoSampler+0x548>
    2a12:	83 30       	cpi	r24, 0x03	; 3
    2a14:	31 f5       	brne	.+76     	; 0x2a62 <DoSampler+0x572>
    2a16:	18 c0       	rjmp	.+48     	; 0x2a48 <DoSampler+0x558>
				{
					case 0:
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2a18:	85 e3       	ldi	r24, 0x35	; 53
    2a1a:	98 e0       	ldi	r25, 0x08	; 8
    2a1c:	90 93 e3 05 	sts	0x05E3, r25
    2a20:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a24:	20 e0       	ldi	r18, 0x00	; 0
    2a26:	17 c0       	rjmp	.+46     	; 0x2a56 <DoSampler+0x566>
					break;

					case 1:
					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2a28:	89 ee       	ldi	r24, 0xE9	; 233
    2a2a:	97 e0       	ldi	r25, 0x07	; 7
    2a2c:	90 93 e3 05 	sts	0x05E3, r25
    2a30:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a34:	21 e0       	ldi	r18, 0x01	; 1
    2a36:	0f c0       	rjmp	.+30     	; 0x2a56 <DoSampler+0x566>
					break;

					case 2:
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2a38:	88 ea       	ldi	r24, 0xA8	; 168
    2a3a:	98 e0       	ldi	r25, 0x08	; 8
    2a3c:	90 93 e3 05 	sts	0x05E3, r25
    2a40:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a44:	22 e0       	ldi	r18, 0x02	; 2
    2a46:	07 c0       	rjmp	.+14     	; 0x2a56 <DoSampler+0x566>
					break;

					case 3:
					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2a48:	8b e6       	ldi	r24, 0x6B	; 107
    2a4a:	98 e0       	ldi	r25, 0x08	; 8
    2a4c:	90 93 e3 05 	sts	0x05E3, r25
    2a50:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a54:	23 e0       	ldi	r18, 0x03	; 3
    2a56:	46 e1       	ldi	r20, 0x16	; 22
    2a58:	64 e0       	ldi	r22, 0x04	; 4
    2a5a:	80 91 64 05 	lds	r24, 0x0564
    2a5e:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
					default:
					break;
				}
			}
		}
		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
    2a62:	80 91 57 05 	lds	r24, 0x0557
    2a66:	85 ff       	sbrs	r24, 5
    2a68:	6a c1       	rjmp	.+724    	; 0x2d3e <DoSampler+0x84e>
		{
			if(bankStates[currentBank].backwardsPlayback==false)
    2a6a:	80 91 64 05 	lds	r24, 0x0564
    2a6e:	43 e2       	ldi	r20, 0x23	; 35
    2a70:	84 9f       	mul	r24, r20
    2a72:	f0 01       	movw	r30, r0
    2a74:	11 24       	eor	r1, r1
    2a76:	ea 51       	subi	r30, 0x1A	; 26
    2a78:	fa 4f       	sbci	r31, 0xFA	; 250
    2a7a:	93 81       	ldd	r25, Z+3	; 0x03
    2a7c:	91 11       	cpse	r25, r1
    2a7e:	04 c0       	rjmp	.+8      	; 0x2a88 <DoSampler+0x598>
			{
				bankStates[currentBank].backwardsPlayback=true;
    2a80:	91 e0       	ldi	r25, 0x01	; 1
    2a82:	93 83       	std	Z+3, r25	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2a84:	20 e4       	ldi	r18, 0x40	; 64
    2a86:	02 c0       	rjmp	.+4      	; 0x2a8c <DoSampler+0x59c>
			}
			else
			{
				bankStates[currentBank].backwardsPlayback=false;
    2a88:	13 82       	std	Z+3, r1	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2a8a:	20 e0       	ldi	r18, 0x00	; 0
    2a8c:	41 e1       	ldi	r20, 0x11	; 17
    2a8e:	64 e0       	ldi	r22, 0x04	; 4
    2a90:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
			}

			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2a94:	80 91 64 05 	lds	r24, 0x0564
    2a98:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
    2a9c:	50 c1       	rjmp	.+672    	; 0x2d3e <DoSampler+0x84e>
		}
	}
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
    2a9e:	87 ff       	sbrs	r24, 7
    2aa0:	53 c0       	rjmp	.+166    	; 0x2b48 <DoSampler+0x658>
	{
		if(keyState&Im_SWITCH_0)		// Adjust sample start
    2aa2:	80 91 58 05 	lds	r24, 0x0558
    2aa6:	80 ff       	sbrs	r24, 0
    2aa8:	15 c0       	rjmp	.+42     	; 0x2ad4 <DoSampler+0x5e4>
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2aaa:	10 91 64 05 	lds	r17, 0x0564
    2aae:	83 e2       	ldi	r24, 0x23	; 35
    2ab0:	18 9f       	mul	r17, r24
    2ab2:	f0 01       	movw	r30, r0
    2ab4:	11 24       	eor	r1, r1
    2ab6:	ea 51       	subi	r30, 0x1A	; 26
    2ab8:	fa 4f       	sbci	r31, 0xFA	; 250
    2aba:	84 8d       	ldd	r24, Z+28	; 0x1c
    2abc:	00 91 6b 05 	lds	r16, 0x056B
    2ac0:	80 17       	cp	r24, r16
    2ac2:	c9 f1       	breq	.+114    	; 0x2b36 <DoSampler+0x646>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2ac4:	04 8f       	std	Z+28, r16	; 0x1c
	UpdateAdjustedSampleAddresses(theBank);
    2ac6:	81 2f       	mov	r24, r17
    2ac8:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		if(keyState&Im_SWITCH_0)		// Adjust sample start
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2acc:	20 2f       	mov	r18, r16
    2ace:	26 95       	lsr	r18
    2ad0:	4c e1       	ldi	r20, 0x1C	; 28
    2ad2:	2d c0       	rjmp	.+90     	; 0x2b2e <DoSampler+0x63e>
			}
		}
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
    2ad4:	81 ff       	sbrs	r24, 1
    2ad6:	15 c0       	rjmp	.+42     	; 0x2b02 <DoSampler+0x612>
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2ad8:	10 91 64 05 	lds	r17, 0x0564
    2adc:	93 e2       	ldi	r25, 0x23	; 35
    2ade:	19 9f       	mul	r17, r25
    2ae0:	f0 01       	movw	r30, r0
    2ae2:	11 24       	eor	r1, r1
    2ae4:	ea 51       	subi	r30, 0x1A	; 26
    2ae6:	fa 4f       	sbci	r31, 0xFA	; 250
    2ae8:	85 8d       	ldd	r24, Z+29	; 0x1d
    2aea:	00 91 6b 05 	lds	r16, 0x056B
    2aee:	80 17       	cp	r24, r16
    2af0:	11 f1       	breq	.+68     	; 0x2b36 <DoSampler+0x646>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2af2:	05 8f       	std	Z+29, r16	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    2af4:	81 2f       	mov	r24, r17
    2af6:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2afa:	20 2f       	mov	r18, r16
    2afc:	26 95       	lsr	r18
    2afe:	4d e1       	ldi	r20, 0x1D	; 29
    2b00:	16 c0       	rjmp	.+44     	; 0x2b2e <DoSampler+0x63e>
			}
		}
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
    2b02:	82 ff       	sbrs	r24, 2
    2b04:	18 c0       	rjmp	.+48     	; 0x2b36 <DoSampler+0x646>
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2b06:	10 91 64 05 	lds	r17, 0x0564
    2b0a:	a3 e2       	ldi	r26, 0x23	; 35
    2b0c:	1a 9f       	mul	r17, r26
    2b0e:	f0 01       	movw	r30, r0
    2b10:	11 24       	eor	r1, r1
    2b12:	ea 51       	subi	r30, 0x1A	; 26
    2b14:	fa 4f       	sbci	r31, 0xFA	; 250
    2b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b18:	00 91 6b 05 	lds	r16, 0x056B
    2b1c:	80 17       	cp	r24, r16
    2b1e:	59 f0       	breq	.+22     	; 0x2b36 <DoSampler+0x646>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    2b20:	06 8f       	std	Z+30, r16	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    2b22:	81 2f       	mov	r24, r17
    2b24:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2b28:	20 2f       	mov	r18, r16
    2b2a:	26 95       	lsr	r18
    2b2c:	4e e1       	ldi	r20, 0x1E	; 30
    2b2e:	64 e0       	ldi	r22, 0x04	; 4
    2b30:	81 2f       	mov	r24, r17
    2b32:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
			}
		}

		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
    2b36:	80 91 57 05 	lds	r24, 0x0557
    2b3a:	83 ff       	sbrs	r24, 3
    2b3c:	00 c1       	rjmp	.+512    	; 0x2d3e <DoSampler+0x84e>
		{
//			PlaySampleFromSd(BANK_0,0);		// @@@
			PlaySampleFromSd(0);			// @@@ stream from slot 0
    2b3e:	80 e0       	ldi	r24, 0x00	; 0
    2b40:	90 e0       	ldi	r25, 0x00	; 0
    2b42:	0e 94 4b 11 	call	0x2296	; 0x2296 <PlaySampleFromSd>
    2b46:	fb c0       	rjmp	.+502    	; 0x2d3e <DoSampler+0x84e>
	// -----------------------------------------------------------------------------------
	// No shift keys pressed:
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
    2b48:	80 91 57 05 	lds	r24, 0x0557
    2b4c:	80 ff       	sbrs	r24, 0
    2b4e:	22 c0       	rjmp	.+68     	; 0x2b94 <DoSampler+0x6a4>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2b50:	10 91 64 05 	lds	r17, 0x0564
    2b54:	b3 e2       	ldi	r27, 0x23	; 35
    2b56:	1b 9f       	mul	r17, r27
    2b58:	70 01       	movw	r14, r0
    2b5a:	11 24       	eor	r1, r1
    2b5c:	e6 ee       	ldi	r30, 0xE6	; 230
    2b5e:	f5 e0       	ldi	r31, 0x05	; 5
    2b60:	ee 0e       	add	r14, r30
    2b62:	ff 1e       	adc	r15, r31
    2b64:	d7 01       	movw	r26, r14
    2b66:	8c 91       	ld	r24, X
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2b68:	40 e0       	ldi	r20, 0x00	; 0
    2b6a:	50 e0       	ldi	r21, 0x00	; 0
    2b6c:	61 e0       	ldi	r22, 0x01	; 1
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2b6e:	83 30       	cpi	r24, 0x03	; 3
    2b70:	49 f4       	brne	.+18     	; 0x2b84 <DoSampler+0x694>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2b72:	81 2f       	mov	r24, r17
    2b74:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2b78:	f7 01       	movw	r30, r14
    2b7a:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2b7c:	20 e4       	ldi	r18, 0x40	; 64
    2b7e:	40 e3       	ldi	r20, 0x30	; 48
    2b80:	61 e0       	ldi	r22, 0x01	; 1
    2b82:	06 c0       	rjmp	.+12     	; 0x2b90 <DoSampler+0x6a0>
			}
			else											// We're not recording right now, so start doing it.
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2b84:	81 2f       	mov	r24, r17
    2b86:	0e 94 26 10 	call	0x204c	; 0x204c <StartRecording>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2b8a:	20 e3       	ldi	r18, 0x30	; 48
    2b8c:	43 e0       	ldi	r20, 0x03	; 3
    2b8e:	64 e0       	ldi	r22, 0x04	; 4
    2b90:	81 2f       	mov	r24, r17
    2b92:	8a c0       	rjmp	.+276    	; 0x2ca8 <DoSampler+0x7b8>
			}
		}
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2b94:	81 ff       	sbrs	r24, 1
    2b96:	35 c0       	rjmp	.+106    	; 0x2c02 <DoSampler+0x712>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    2b98:	f0 90 64 05 	lds	r15, 0x0564
    2b9c:	f3 e2       	ldi	r31, 0x23	; 35
    2b9e:	ff 9e       	mul	r15, r31
    2ba0:	60 01       	movw	r12, r0
    2ba2:	11 24       	eor	r1, r1
    2ba4:	86 ee       	ldi	r24, 0xE6	; 230
    2ba6:	95 e0       	ldi	r25, 0x05	; 5
    2ba8:	c8 0e       	add	r12, r24
    2baa:	d9 1e       	adc	r13, r25
    2bac:	d6 01       	movw	r26, r12
    2bae:	8c 91       	ld	r24, X
    2bb0:	85 30       	cpi	r24, 0x05	; 5
    2bb2:	51 f4       	brne	.+20     	; 0x2bc8 <DoSampler+0x6d8>
			{
				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
    2bb4:	40 e0       	ldi	r20, 0x00	; 0
    2bb6:	50 e0       	ldi	r21, 0x00	; 0
    2bb8:	61 e0       	ldi	r22, 0x01	; 1
    2bba:	8f 2d       	mov	r24, r15
    2bbc:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <ContinuePlayback>
				bankStates[currentBank].loopOnce=false;
    2bc0:	f6 01       	movw	r30, r12
    2bc2:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    2bc4:	20 e0       	ldi	r18, 0x00	; 0
    2bc6:	1a c0       	rjmp	.+52     	; 0x2bfc <DoSampler+0x70c>
			}
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2bc8:	d6 01       	movw	r26, r12
    2bca:	50 96       	adiw	r26, 0x10	; 16
    2bcc:	0d 91       	ld	r16, X+
    2bce:	1d 91       	ld	r17, X+
    2bd0:	2d 91       	ld	r18, X+
    2bd2:	3c 91       	ld	r19, X
    2bd4:	53 97       	sbiw	r26, 0x13	; 19
    2bd6:	1c 96       	adiw	r26, 0x0c	; 12
    2bd8:	4d 91       	ld	r20, X+
    2bda:	5d 91       	ld	r21, X+
    2bdc:	6d 91       	ld	r22, X+
    2bde:	7c 91       	ld	r23, X
    2be0:	1f 97       	sbiw	r26, 0x0f	; 15
    2be2:	04 17       	cp	r16, r20
    2be4:	15 07       	cpc	r17, r21
    2be6:	26 07       	cpc	r18, r22
    2be8:	37 07       	cpc	r19, r23
    2bea:	09 f4       	brne	.+2      	; 0x2bee <DoSampler+0x6fe>
    2bec:	a8 c0       	rjmp	.+336    	; 0x2d3e <DoSampler+0x84e>
				{
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    2bee:	40 e0       	ldi	r20, 0x00	; 0
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	61 e0       	ldi	r22, 0x01	; 1
    2bf4:	8f 2d       	mov	r24, r15
    2bf6:	0e 94 84 10 	call	0x2108	; 0x2108 <StartOverdub>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2bfa:	20 e3       	ldi	r18, 0x30	; 48
    2bfc:	49 e0       	ldi	r20, 0x09	; 9
    2bfe:	64 e0       	ldi	r22, 0x04	; 4
    2c00:	91 c0       	rjmp	.+290    	; 0x2d24 <DoSampler+0x834>
				}
			}
		}
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
    2c02:	82 ff       	sbrs	r24, 2
    2c04:	26 c0       	rjmp	.+76     	; 0x2c52 <DoSampler+0x762>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2c06:	f0 90 64 05 	lds	r15, 0x0564
    2c0a:	b3 e2       	ldi	r27, 0x23	; 35
    2c0c:	fb 9e       	mul	r15, r27
    2c0e:	60 01       	movw	r12, r0
    2c10:	11 24       	eor	r1, r1
    2c12:	e6 ee       	ldi	r30, 0xE6	; 230
    2c14:	f5 e0       	ldi	r31, 0x05	; 5
    2c16:	ce 0e       	add	r12, r30
    2c18:	df 1e       	adc	r13, r31
    2c1a:	d6 01       	movw	r26, r12
    2c1c:	50 96       	adiw	r26, 0x10	; 16
    2c1e:	0d 91       	ld	r16, X+
    2c20:	1d 91       	ld	r17, X+
    2c22:	2d 91       	ld	r18, X+
    2c24:	3c 91       	ld	r19, X
    2c26:	53 97       	sbiw	r26, 0x13	; 19
    2c28:	1c 96       	adiw	r26, 0x0c	; 12
    2c2a:	4d 91       	ld	r20, X+
    2c2c:	5d 91       	ld	r21, X+
    2c2e:	6d 91       	ld	r22, X+
    2c30:	7c 91       	ld	r23, X
    2c32:	1f 97       	sbiw	r26, 0x0f	; 15
    2c34:	04 17       	cp	r16, r20
    2c36:	15 07       	cpc	r17, r21
    2c38:	26 07       	cpc	r18, r22
    2c3a:	37 07       	cpc	r19, r23
    2c3c:	09 f4       	brne	.+2      	; 0x2c40 <DoSampler+0x750>
    2c3e:	7f c0       	rjmp	.+254    	; 0x2d3e <DoSampler+0x84e>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2c40:	40 e0       	ldi	r20, 0x00	; 0
    2c42:	50 e0       	ldi	r21, 0x00	; 0
    2c44:	61 e0       	ldi	r22, 0x01	; 1
    2c46:	8f 2d       	mov	r24, r15
    2c48:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2c4c:	f6 01       	movw	r30, r12
    2c4e:	11 82       	std	Z+1, r1	; 0x01
    2c50:	58 c0       	rjmp	.+176    	; 0x2d02 <DoSampler+0x812>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    2c52:	83 ff       	sbrs	r24, 3
    2c54:	2c c0       	rjmp	.+88     	; 0x2cae <DoSampler+0x7be>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2c56:	e0 90 64 05 	lds	r14, 0x0564
    2c5a:	f3 e2       	ldi	r31, 0x23	; 35
    2c5c:	ef 9e       	mul	r14, r31
    2c5e:	60 01       	movw	r12, r0
    2c60:	11 24       	eor	r1, r1
    2c62:	86 ee       	ldi	r24, 0xE6	; 230
    2c64:	95 e0       	ldi	r25, 0x05	; 5
    2c66:	c8 0e       	add	r12, r24
    2c68:	d9 1e       	adc	r13, r25
    2c6a:	d6 01       	movw	r26, r12
    2c6c:	50 96       	adiw	r26, 0x10	; 16
    2c6e:	0d 91       	ld	r16, X+
    2c70:	1d 91       	ld	r17, X+
    2c72:	2d 91       	ld	r18, X+
    2c74:	3c 91       	ld	r19, X
    2c76:	53 97       	sbiw	r26, 0x13	; 19
    2c78:	1c 96       	adiw	r26, 0x0c	; 12
    2c7a:	4d 91       	ld	r20, X+
    2c7c:	5d 91       	ld	r21, X+
    2c7e:	6d 91       	ld	r22, X+
    2c80:	7c 91       	ld	r23, X
    2c82:	1f 97       	sbiw	r26, 0x0f	; 15
    2c84:	04 17       	cp	r16, r20
    2c86:	15 07       	cpc	r17, r21
    2c88:	26 07       	cpc	r18, r22
    2c8a:	37 07       	cpc	r19, r23
    2c8c:	09 f4       	brne	.+2      	; 0x2c90 <DoSampler+0x7a0>
    2c8e:	57 c0       	rjmp	.+174    	; 0x2d3e <DoSampler+0x84e>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    2c90:	40 e0       	ldi	r20, 0x00	; 0
    2c92:	50 e0       	ldi	r21, 0x00	; 0
    2c94:	61 e0       	ldi	r22, 0x01	; 1
    2c96:	8e 2d       	mov	r24, r14
    2c98:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <StartPlayback>
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    2c9c:	f6 01       	movw	r30, r12
    2c9e:	f1 82       	std	Z+1, r15	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2ca0:	20 e4       	ldi	r18, 0x40	; 64
    2ca2:	40 e3       	ldi	r20, 0x30	; 48
    2ca4:	61 e0       	ldi	r22, 0x01	; 1
    2ca6:	8e 2d       	mov	r24, r14
    2ca8:	0e 94 8e 1e 	call	0x3d1c	; 0x3d1c <PutMidiMessageInOutgoingFifo>
    2cac:	48 c0       	rjmp	.+144    	; 0x2d3e <DoSampler+0x84e>
			}
		}
		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this will stop it at the current sample location.  If playback is idle it will restart it.  This will not restart a playing sample from the beginning.
    2cae:	84 ff       	sbrs	r24, 4
    2cb0:	3b c0       	rjmp	.+118    	; 0x2d28 <DoSampler+0x838>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    2cb2:	f0 90 64 05 	lds	r15, 0x0564
    2cb6:	2f 2d       	mov	r18, r15
    2cb8:	30 e0       	ldi	r19, 0x00	; 0
    2cba:	43 e2       	ldi	r20, 0x23	; 35
    2cbc:	f4 9e       	mul	r15, r20
    2cbe:	f0 01       	movw	r30, r0
    2cc0:	11 24       	eor	r1, r1
    2cc2:	ea 51       	subi	r30, 0x1A	; 26
    2cc4:	fa 4f       	sbci	r31, 0xFA	; 250
    2cc6:	80 81       	ld	r24, Z
    2cc8:	81 11       	cpse	r24, r1
    2cca:	1f c0       	rjmp	.+62     	; 0x2d0a <DoSampler+0x81a>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2ccc:	83 e2       	ldi	r24, 0x23	; 35
    2cce:	82 9f       	mul	r24, r18
    2cd0:	f0 01       	movw	r30, r0
    2cd2:	83 9f       	mul	r24, r19
    2cd4:	f0 0d       	add	r31, r0
    2cd6:	11 24       	eor	r1, r1
    2cd8:	ea 51       	subi	r30, 0x1A	; 26
    2cda:	fa 4f       	sbci	r31, 0xFA	; 250
    2cdc:	00 89       	ldd	r16, Z+16	; 0x10
    2cde:	11 89       	ldd	r17, Z+17	; 0x11
    2ce0:	22 89       	ldd	r18, Z+18	; 0x12
    2ce2:	33 89       	ldd	r19, Z+19	; 0x13
    2ce4:	44 85       	ldd	r20, Z+12	; 0x0c
    2ce6:	55 85       	ldd	r21, Z+13	; 0x0d
    2ce8:	66 85       	ldd	r22, Z+14	; 0x0e
    2cea:	77 85       	ldd	r23, Z+15	; 0x0f
    2cec:	04 17       	cp	r16, r20
    2cee:	15 07       	cpc	r17, r21
    2cf0:	26 07       	cpc	r18, r22
    2cf2:	37 07       	cpc	r19, r23
    2cf4:	21 f1       	breq	.+72     	; 0x2d3e <DoSampler+0x84e>
				{
					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
    2cf6:	40 e0       	ldi	r20, 0x00	; 0
    2cf8:	50 e0       	ldi	r21, 0x00	; 0
    2cfa:	61 e0       	ldi	r22, 0x01	; 1
    2cfc:	8f 2d       	mov	r24, r15
    2cfe:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <ContinuePlayback>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2d02:	20 e4       	ldi	r18, 0x40	; 64
    2d04:	40 e3       	ldi	r20, 0x30	; 48
    2d06:	61 e0       	ldi	r22, 0x01	; 1
    2d08:	0d c0       	rjmp	.+26     	; 0x2d24 <DoSampler+0x834>
				}
			}
			else		// Pause whatever we were doing.
			{
				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    2d0a:	83 e2       	ldi	r24, 0x23	; 35
    2d0c:	82 9f       	mul	r24, r18
    2d0e:	f0 01       	movw	r30, r0
    2d10:	83 9f       	mul	r24, r19
    2d12:	f0 0d       	add	r31, r0
    2d14:	11 24       	eor	r1, r1
    2d16:	ea 51       	subi	r30, 0x1A	; 26
    2d18:	fa 4f       	sbci	r31, 0xFA	; 250
    2d1a:	10 82       	st	Z, r1
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    2d1c:	11 86       	std	Z+9, r1	; 0x09
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2d1e:	20 e0       	ldi	r18, 0x00	; 0
    2d20:	40 e3       	ldi	r20, 0x30	; 48
    2d22:	62 e0       	ldi	r22, 0x02	; 2
    2d24:	8f 2d       	mov	r24, r15
    2d26:	c0 cf       	rjmp	.-128    	; 0x2ca8 <DoSampler+0x7b8>
			}

		}
		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
    2d28:	85 ff       	sbrs	r24, 5
    2d2a:	09 c0       	rjmp	.+18     	; 0x2d3e <DoSampler+0x84e>
		{
			currentBank++;
    2d2c:	80 91 64 05 	lds	r24, 0x0564
    2d30:	8f 5f       	subi	r24, 0xFF	; 255
    2d32:	80 93 64 05 	sts	0x0564, r24
			if(currentBank>=NUM_BANKS)
    2d36:	82 30       	cpi	r24, 0x02	; 2
    2d38:	10 f0       	brcs	.+4      	; 0x2d3e <DoSampler+0x84e>
			{
				currentBank=BANK_0;		// Loop around.
    2d3a:	10 92 64 05 	sts	0x0564, r1
			}
		}
	}

	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
    2d3e:	80 91 6b 05 	lds	r24, 0x056B
    2d42:	80 93 6c 05 	sts	0x056C, r24

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
	{
		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI

		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
    2d46:	80 91 60 06 	lds	r24, 0x0660
    2d4a:	88 23       	and	r24, r24
    2d4c:	09 f4       	brne	.+2      	; 0x2d50 <DoSampler+0x860>
    2d4e:	82 c2       	rjmp	.+1284   	; 0x3254 <DoSampler+0xd64>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    2d50:	85 e6       	ldi	r24, 0x65	; 101
    2d52:	95 e0       	ldi	r25, 0x05	; 5
    2d54:	0e 94 67 1e 	call	0x3cce	; 0x3cce <GetMidiMessageFromIncomingFifo>
			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
			{
				// Do this here.
			}
*/
			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    2d58:	80 91 66 05 	lds	r24, 0x0566
    2d5c:	82 30       	cpi	r24, 0x02	; 2
    2d5e:	11 f5       	brne	.+68     	; 0x2da4 <DoSampler+0x8b4>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    2d60:	e0 91 65 05 	lds	r30, 0x0565
    2d64:	8e 2f       	mov	r24, r30
    2d66:	90 e0       	ldi	r25, 0x00	; 0
    2d68:	a3 e2       	ldi	r26, 0x23	; 35
    2d6a:	ea 9f       	mul	r30, r26
    2d6c:	f0 01       	movw	r30, r0
    2d6e:	11 24       	eor	r1, r1
    2d70:	ea 51       	subi	r30, 0x1A	; 26
    2d72:	fa 4f       	sbci	r31, 0xFA	; 250
    2d74:	20 81       	ld	r18, Z
    2d76:	24 30       	cpi	r18, 0x04	; 4
    2d78:	21 f0       	breq	.+8      	; 0x2d82 <DoSampler+0x892>
    2d7a:	20 81       	ld	r18, Z
    2d7c:	22 30       	cpi	r18, 0x02	; 2
    2d7e:	09 f0       	breq	.+2      	; 0x2d82 <DoSampler+0x892>
    2d80:	69 c2       	rjmp	.+1234   	; 0x3254 <DoSampler+0xd64>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    2d82:	fc 01       	movw	r30, r24
    2d84:	ec 5f       	subi	r30, 0xFC	; 252
    2d86:	fe 4f       	sbci	r31, 0xFE	; 254
    2d88:	30 91 67 05 	lds	r19, 0x0567
    2d8c:	20 81       	ld	r18, Z
    2d8e:	32 13       	cpse	r19, r18
    2d90:	61 c2       	rjmp	.+1218   	; 0x3254 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    2d92:	23 e2       	ldi	r18, 0x23	; 35
    2d94:	28 9f       	mul	r18, r24
    2d96:	f0 01       	movw	r30, r0
    2d98:	29 9f       	mul	r18, r25
    2d9a:	f0 0d       	add	r31, r0
    2d9c:	11 24       	eor	r1, r1
    2d9e:	ea 51       	subi	r30, 0x1A	; 26
    2da0:	fa 4f       	sbci	r31, 0xFA	; 250
    2da2:	7f c0       	rjmp	.+254    	; 0x2ea2 <DoSampler+0x9b2>
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    2da4:	81 30       	cpi	r24, 0x01	; 1
    2da6:	09 f0       	breq	.+2      	; 0x2daa <DoSampler+0x8ba>
    2da8:	50 c0       	rjmp	.+160    	; 0x2e4a <DoSampler+0x95a>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    2daa:	a0 91 65 05 	lds	r26, 0x0565
    2dae:	2a 2f       	mov	r18, r26
    2db0:	30 e0       	ldi	r19, 0x00	; 0
    2db2:	80 91 67 05 	lds	r24, 0x0567
    2db6:	f9 01       	movw	r30, r18
    2db8:	ec 5f       	subi	r30, 0xFC	; 252
    2dba:	fe 4f       	sbci	r31, 0xFE	; 254
    2dbc:	80 83       	st	Z, r24

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
    2dbe:	f9 01       	movw	r30, r18
    2dc0:	e2 5a       	subi	r30, 0xA2	; 162
    2dc2:	fa 4f       	sbci	r31, 0xFA	; 250
    2dc4:	90 81       	ld	r25, Z
    2dc6:	99 23       	and	r25, r25
    2dc8:	a9 f0       	breq	.+42     	; 0x2df4 <DoSampler+0x904>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2dca:	6c e0       	ldi	r22, 0x0C	; 12
    2dcc:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2dd0:	e9 2f       	mov	r30, r25
    2dd2:	f0 e0       	ldi	r31, 0x00	; 0
    2dd4:	ee 0f       	add	r30, r30
    2dd6:	ff 1f       	adc	r31, r31
    2dd8:	ea 5f       	subi	r30, 0xFA	; 250
    2dda:	fe 4f       	sbci	r31, 0xFE	; 254
    2ddc:	40 81       	ld	r20, Z
    2dde:	51 81       	ldd	r21, Z+1	; 0x01
    2de0:	02 c0       	rjmp	.+4      	; 0x2de6 <DoSampler+0x8f6>
    2de2:	56 95       	lsr	r21
    2de4:	47 95       	ror	r20
    2de6:	8a 95       	dec	r24
    2de8:	e2 f7       	brpl	.-8      	; 0x2de2 <DoSampler+0x8f2>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.
    2dea:	62 e0       	ldi	r22, 0x02	; 2
    2dec:	8a 2f       	mov	r24, r26
    2dee:	0e 94 ba 10 	call	0x2174	; 0x2174 <StartRealtime>
    2df2:	30 c2       	rjmp	.+1120   	; 0x3254 <DoSampler+0xd64>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    2df4:	93 e2       	ldi	r25, 0x23	; 35
    2df6:	92 9f       	mul	r25, r18
    2df8:	f0 01       	movw	r30, r0
    2dfa:	93 9f       	mul	r25, r19
    2dfc:	f0 0d       	add	r31, r0
    2dfe:	11 24       	eor	r1, r1
    2e00:	ea 51       	subi	r30, 0x1A	; 26
    2e02:	fa 4f       	sbci	r31, 0xFA	; 250
    2e04:	00 89       	ldd	r16, Z+16	; 0x10
    2e06:	11 89       	ldd	r17, Z+17	; 0x11
    2e08:	22 89       	ldd	r18, Z+18	; 0x12
    2e0a:	33 89       	ldd	r19, Z+19	; 0x13
    2e0c:	44 85       	ldd	r20, Z+12	; 0x0c
    2e0e:	55 85       	ldd	r21, Z+13	; 0x0d
    2e10:	66 85       	ldd	r22, Z+14	; 0x0e
    2e12:	77 85       	ldd	r23, Z+15	; 0x0f
    2e14:	04 17       	cp	r16, r20
    2e16:	15 07       	cpc	r17, r21
    2e18:	26 07       	cpc	r18, r22
    2e1a:	37 07       	cpc	r19, r23
    2e1c:	09 f4       	brne	.+2      	; 0x2e20 <DoSampler+0x930>
    2e1e:	1a c2       	rjmp	.+1076   	; 0x3254 <DoSampler+0xd64>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2e20:	6c e0       	ldi	r22, 0x0C	; 12
    2e22:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2e26:	e9 2f       	mov	r30, r25
    2e28:	f0 e0       	ldi	r31, 0x00	; 0
    2e2a:	ee 0f       	add	r30, r30
    2e2c:	ff 1f       	adc	r31, r31
    2e2e:	ea 5f       	subi	r30, 0xFA	; 250
    2e30:	fe 4f       	sbci	r31, 0xFE	; 254
    2e32:	40 81       	ld	r20, Z
    2e34:	51 81       	ldd	r21, Z+1	; 0x01
    2e36:	02 c0       	rjmp	.+4      	; 0x2e3c <DoSampler+0x94c>
    2e38:	56 95       	lsr	r21
    2e3a:	47 95       	ror	r20
    2e3c:	8a 95       	dec	r24
    2e3e:	e2 f7       	brpl	.-8      	; 0x2e38 <DoSampler+0x948>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    2e40:	62 e0       	ldi	r22, 0x02	; 2
    2e42:	8a 2f       	mov	r24, r26
    2e44:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <StartPlayback>
    2e48:	05 c2       	rjmp	.+1034   	; 0x3254 <DoSampler+0xd64>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    2e4a:	84 30       	cpi	r24, 0x04	; 4
    2e4c:	09 f0       	breq	.+2      	; 0x2e50 <DoSampler+0x960>
    2e4e:	a9 c1       	rjmp	.+850    	; 0x31a2 <DoSampler+0xcb2>
			{
				switch(currentMidiMessage.dataByteOne)
    2e50:	80 91 67 05 	lds	r24, 0x0567
    2e54:	90 e0       	ldi	r25, 0x00	; 0
    2e56:	fc 01       	movw	r30, r24
    2e58:	33 97       	sbiw	r30, 0x03	; 3
    2e5a:	ec 31       	cpi	r30, 0x1C	; 28
    2e5c:	f1 05       	cpc	r31, r1
    2e5e:	08 f0       	brcs	.+2      	; 0x2e62 <DoSampler+0x972>
    2e60:	f9 c1       	rjmp	.+1010   	; 0x3254 <DoSampler+0xd64>
    2e62:	e2 5c       	subi	r30, 0xC2	; 194
    2e64:	ff 4f       	sbci	r31, 0xFF	; 255
    2e66:	0c 94 89 28 	jmp	0x5112	; 0x5112 <__tablejump2__>
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2e6a:	90 91 68 05 	lds	r25, 0x0568
    2e6e:	80 91 65 05 	lds	r24, 0x0565
    2e72:	99 23       	and	r25, r25
    2e74:	61 f0       	breq	.+24     	; 0x2e8e <DoSampler+0x99e>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    2e76:	a8 2f       	mov	r26, r24
    2e78:	b0 e0       	ldi	r27, 0x00	; 0
    2e7a:	aa 0f       	add	r26, r26
    2e7c:	bb 1f       	adc	r27, r27
    2e7e:	a0 5a       	subi	r26, 0xA0	; 160
    2e80:	ba 4f       	sbci	r27, 0xFA	; 250
    2e82:	4d 91       	ld	r20, X+
    2e84:	5c 91       	ld	r21, X
    2e86:	62 e0       	ldi	r22, 0x02	; 2
    2e88:	0e 94 26 10 	call	0x204c	; 0x204c <StartRecording>
    2e8c:	31 c0       	rjmp	.+98     	; 0x2ef0 <DoSampler+0xa00>
						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback after a recording.
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    2e8e:	b3 e2       	ldi	r27, 0x23	; 35
    2e90:	8b 9f       	mul	r24, r27
    2e92:	f0 01       	movw	r30, r0
    2e94:	11 24       	eor	r1, r1
    2e96:	ea 51       	subi	r30, 0x1A	; 26
    2e98:	fa 4f       	sbci	r31, 0xFA	; 250
    2e9a:	80 81       	ld	r24, Z
    2e9c:	83 30       	cpi	r24, 0x03	; 3
    2e9e:	09 f0       	breq	.+2      	; 0x2ea2 <DoSampler+0x9b2>
    2ea0:	d9 c1       	rjmp	.+946    	; 0x3254 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2ea2:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2ea4:	11 86       	std	Z+9, r1	; 0x09
    2ea6:	d6 c1       	rjmp	.+940    	; 0x3254 <DoSampler+0xd64>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2ea8:	90 91 68 05 	lds	r25, 0x0568
    2eac:	80 91 65 05 	lds	r24, 0x0565
    2eb0:	99 23       	and	r25, r25
    2eb2:	11 f1       	breq	.+68     	; 0x2ef8 <DoSampler+0xa08>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2eb4:	a8 2f       	mov	r26, r24
    2eb6:	b0 e0       	ldi	r27, 0x00	; 0
    2eb8:	23 e2       	ldi	r18, 0x23	; 35
    2eba:	82 9f       	mul	r24, r18
    2ebc:	f0 01       	movw	r30, r0
    2ebe:	11 24       	eor	r1, r1
    2ec0:	ea 51       	subi	r30, 0x1A	; 26
    2ec2:	fa 4f       	sbci	r31, 0xFA	; 250
    2ec4:	00 89       	ldd	r16, Z+16	; 0x10
    2ec6:	11 89       	ldd	r17, Z+17	; 0x11
    2ec8:	22 89       	ldd	r18, Z+18	; 0x12
    2eca:	33 89       	ldd	r19, Z+19	; 0x13
    2ecc:	44 85       	ldd	r20, Z+12	; 0x0c
    2ece:	55 85       	ldd	r21, Z+13	; 0x0d
    2ed0:	66 85       	ldd	r22, Z+14	; 0x0e
    2ed2:	77 85       	ldd	r23, Z+15	; 0x0f
    2ed4:	04 17       	cp	r16, r20
    2ed6:	15 07       	cpc	r17, r21
    2ed8:	26 07       	cpc	r18, r22
    2eda:	37 07       	cpc	r19, r23
    2edc:	09 f4       	brne	.+2      	; 0x2ee0 <DoSampler+0x9f0>
    2ede:	ba c1       	rjmp	.+884    	; 0x3254 <DoSampler+0xd64>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    2ee0:	fd 01       	movw	r30, r26
    2ee2:	ec 5f       	subi	r30, 0xFC	; 252
    2ee4:	fe 4f       	sbci	r31, 0xFE	; 254
    2ee6:	40 81       	ld	r20, Z
    2ee8:	50 e0       	ldi	r21, 0x00	; 0
    2eea:	62 e0       	ldi	r22, 0x02	; 2
    2eec:	0e 94 84 10 	call	0x2108	; 0x2108 <StartOverdub>
							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to playback after a recording.
    2ef0:	e0 91 65 05 	lds	r30, 0x0565
    2ef4:	f0 e0       	ldi	r31, 0x00	; 0
    2ef6:	3d c0       	rjmp	.+122    	; 0x2f72 <DoSampler+0xa82>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    2ef8:	28 2f       	mov	r18, r24
    2efa:	30 e0       	ldi	r19, 0x00	; 0
    2efc:	43 e2       	ldi	r20, 0x23	; 35
    2efe:	84 9f       	mul	r24, r20
    2f00:	f0 01       	movw	r30, r0
    2f02:	11 24       	eor	r1, r1
    2f04:	ea 51       	subi	r30, 0x1A	; 26
    2f06:	fa 4f       	sbci	r31, 0xFA	; 250
    2f08:	90 81       	ld	r25, Z
    2f0a:	95 30       	cpi	r25, 0x05	; 5
    2f0c:	09 f0       	breq	.+2      	; 0x2f10 <DoSampler+0xa20>
    2f0e:	a2 c1       	rjmp	.+836    	; 0x3254 <DoSampler+0xd64>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    2f10:	f9 01       	movw	r30, r18
    2f12:	ec 5f       	subi	r30, 0xFC	; 252
    2f14:	fe 4f       	sbci	r31, 0xFE	; 254
    2f16:	40 81       	ld	r20, Z
    2f18:	50 e0       	ldi	r21, 0x00	; 0
    2f1a:	62 e0       	ldi	r22, 0x02	; 2
    2f1c:	0e 94 fe 0f 	call	0x1ffc	; 0x1ffc <ContinuePlayback>
    2f20:	99 c1       	rjmp	.+818    	; 0x3254 <DoSampler+0xd64>
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2f22:	90 91 68 05 	lds	r25, 0x0568
    2f26:	80 91 65 05 	lds	r24, 0x0565
    2f2a:	99 23       	and	r25, r25
    2f2c:	99 f0       	breq	.+38     	; 0x2f54 <DoSampler+0xa64>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    2f2e:	a8 2f       	mov	r26, r24
    2f30:	b0 e0       	ldi	r27, 0x00	; 0
    2f32:	aa 0f       	add	r26, r26
    2f34:	bb 1f       	adc	r27, r27
    2f36:	a0 5a       	subi	r26, 0xA0	; 160
    2f38:	ba 4f       	sbci	r27, 0xFA	; 250
    2f3a:	4d 91       	ld	r20, X+
    2f3c:	5c 91       	ld	r21, X
    2f3e:	62 e0       	ldi	r22, 0x02	; 2
    2f40:	0e 94 ba 10 	call	0x2174	; 0x2174 <StartRealtime>
						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop realtime processing if we get a note off.
    2f44:	e0 91 65 05 	lds	r30, 0x0565
    2f48:	f0 e0       	ldi	r31, 0x00	; 0
    2f4a:	e2 5a       	subi	r30, 0xA2	; 162
    2f4c:	fa 4f       	sbci	r31, 0xFA	; 250
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	80 83       	st	Z, r24
    2f52:	80 c1       	rjmp	.+768    	; 0x3254 <DoSampler+0xd64>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    2f54:	28 2f       	mov	r18, r24
    2f56:	30 e0       	ldi	r19, 0x00	; 0
    2f58:	93 e2       	ldi	r25, 0x23	; 35
    2f5a:	89 9f       	mul	r24, r25
    2f5c:	f0 01       	movw	r30, r0
    2f5e:	11 24       	eor	r1, r1
    2f60:	ea 51       	subi	r30, 0x1A	; 26
    2f62:	fa 4f       	sbci	r31, 0xFA	; 250
    2f64:	80 81       	ld	r24, Z
    2f66:	82 30       	cpi	r24, 0x02	; 2
    2f68:	09 f0       	breq	.+2      	; 0x2f6c <DoSampler+0xa7c>
    2f6a:	74 c1       	rjmp	.+744    	; 0x3254 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2f6c:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2f6e:	11 86       	std	Z+9, r1	; 0x09
						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
    2f70:	f9 01       	movw	r30, r18
    2f72:	e2 5a       	subi	r30, 0xA2	; 162
    2f74:	fa 4f       	sbci	r31, 0xFA	; 250
    2f76:	10 82       	st	Z, r1
    2f78:	6d c1       	rjmp	.+730    	; 0x3254 <DoSampler+0xd64>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    2f7a:	80 91 68 05 	lds	r24, 0x0568
    2f7e:	e0 91 65 05 	lds	r30, 0x0565
    2f82:	88 23       	and	r24, r24
    2f84:	41 f0       	breq	.+16     	; 0x2f96 <DoSampler+0xaa6>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    2f86:	a3 e2       	ldi	r26, 0x23	; 35
    2f88:	ea 9f       	mul	r30, r26
    2f8a:	f0 01       	movw	r30, r0
    2f8c:	11 24       	eor	r1, r1
    2f8e:	ea 51       	subi	r30, 0x1A	; 26
    2f90:	fa 4f       	sbci	r31, 0xFA	; 250
    2f92:	11 82       	std	Z+1, r1	; 0x01
    2f94:	5f c1       	rjmp	.+702    	; 0x3254 <DoSampler+0xd64>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    2f96:	b3 e2       	ldi	r27, 0x23	; 35
    2f98:	eb 9f       	mul	r30, r27
    2f9a:	f0 01       	movw	r30, r0
    2f9c:	11 24       	eor	r1, r1
    2f9e:	ea 51       	subi	r30, 0x1A	; 26
    2fa0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fa2:	81 e0       	ldi	r24, 0x01	; 1
    2fa4:	81 83       	std	Z+1, r24	; 0x01
    2fa6:	56 c1       	rjmp	.+684    	; 0x3254 <DoSampler+0xd64>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    2fa8:	80 91 68 05 	lds	r24, 0x0568
    2fac:	e0 91 65 05 	lds	r30, 0x0565
    2fb0:	88 23       	and	r24, r24
    2fb2:	49 f0       	breq	.+18     	; 0x2fc6 <DoSampler+0xad6>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    2fb4:	23 e2       	ldi	r18, 0x23	; 35
    2fb6:	e2 9f       	mul	r30, r18
    2fb8:	f0 01       	movw	r30, r0
    2fba:	11 24       	eor	r1, r1
    2fbc:	ea 51       	subi	r30, 0x1A	; 26
    2fbe:	fa 4f       	sbci	r31, 0xFA	; 250
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	82 83       	std	Z+2, r24	; 0x02
    2fc4:	47 c1       	rjmp	.+654    	; 0x3254 <DoSampler+0xd64>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    2fc6:	43 e2       	ldi	r20, 0x23	; 35
    2fc8:	e4 9f       	mul	r30, r20
    2fca:	f0 01       	movw	r30, r0
    2fcc:	11 24       	eor	r1, r1
    2fce:	ea 51       	subi	r30, 0x1A	; 26
    2fd0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fd2:	12 82       	std	Z+2, r1	; 0x02
    2fd4:	3f c1       	rjmp	.+638    	; 0x3254 <DoSampler+0xd64>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    2fd6:	80 91 68 05 	lds	r24, 0x0568
    2fda:	e0 91 65 05 	lds	r30, 0x0565
    2fde:	88 23       	and	r24, r24
    2fe0:	49 f0       	breq	.+18     	; 0x2ff4 <DoSampler+0xb04>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    2fe2:	83 e2       	ldi	r24, 0x23	; 35
    2fe4:	e8 9f       	mul	r30, r24
    2fe6:	f0 01       	movw	r30, r0
    2fe8:	11 24       	eor	r1, r1
    2fea:	ea 51       	subi	r30, 0x1A	; 26
    2fec:	fa 4f       	sbci	r31, 0xFA	; 250
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	83 83       	std	Z+3, r24	; 0x03
    2ff2:	07 c0       	rjmp	.+14     	; 0x3002 <DoSampler+0xb12>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    2ff4:	93 e2       	ldi	r25, 0x23	; 35
    2ff6:	e9 9f       	mul	r30, r25
    2ff8:	f0 01       	movw	r30, r0
    2ffa:	11 24       	eor	r1, r1
    2ffc:	ea 51       	subi	r30, 0x1A	; 26
    2ffe:	fa 4f       	sbci	r31, 0xFA	; 250
    3000:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    3002:	80 91 65 05 	lds	r24, 0x0565
    3006:	ca c0       	rjmp	.+404    	; 0x319c <DoSampler+0xcac>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    3008:	e0 91 65 05 	lds	r30, 0x0565
    300c:	ae 2f       	mov	r26, r30
    300e:	b0 e0       	ldi	r27, 0x00	; 0
    3010:	23 e2       	ldi	r18, 0x23	; 35
    3012:	e2 9f       	mul	r30, r18
    3014:	f0 01       	movw	r30, r0
    3016:	11 24       	eor	r1, r1
    3018:	ea 51       	subi	r30, 0x1A	; 26
    301a:	fa 4f       	sbci	r31, 0xFA	; 250
    301c:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    301e:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    3020:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3022:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3024:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    3026:	81 e0       	ldi	r24, 0x01	; 1
    3028:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    302a:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    302c:	84 83       	std	Z+4, r24	; 0x04
					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
    302e:	a2 5a       	subi	r26, 0xA2	; 162
    3030:	ba 4f       	sbci	r27, 0xFA	; 250
    3032:	1c 92       	st	X, r1
    3034:	2d c0       	rjmp	.+90     	; 0x3090 <DoSampler+0xba0>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    3036:	80 91 68 05 	lds	r24, 0x0568
    303a:	88 30       	cpi	r24, 0x08	; 8
    303c:	08 f0       	brcs	.+2      	; 0x3040 <DoSampler+0xb50>
    303e:	0a c1       	rjmp	.+532    	; 0x3254 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
    3040:	e0 91 65 05 	lds	r30, 0x0565
    3044:	43 e2       	ldi	r20, 0x23	; 35
    3046:	e4 9f       	mul	r30, r20
    3048:	f0 01       	movw	r30, r0
    304a:	11 24       	eor	r1, r1
    304c:	ea 51       	subi	r30, 0x1A	; 26
    304e:	fa 4f       	sbci	r31, 0xFA	; 250
    3050:	80 87       	std	Z+8, r24	; 0x08
    3052:	00 c1       	rjmp	.+512    	; 0x3254 <DoSampler+0xd64>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3054:	60 91 68 05 	lds	r22, 0x0568
    3058:	80 91 65 05 	lds	r24, 0x0565
    305c:	0e 94 2d 09 	call	0x125a	; 0x125a <MakeNewGranularArray>
					break;
    3060:	f9 c0       	rjmp	.+498    	; 0x3254 <DoSampler+0xd64>

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
    3062:	e0 91 65 05 	lds	r30, 0x0565
    3066:	80 91 68 05 	lds	r24, 0x0568
    306a:	93 e2       	ldi	r25, 0x23	; 35
    306c:	e9 9f       	mul	r30, r25
    306e:	f0 01       	movw	r30, r0
    3070:	11 24       	eor	r1, r1
    3072:	ea 51       	subi	r30, 0x1A	; 26
    3074:	fa 4f       	sbci	r31, 0xFA	; 250
    3076:	87 83       	std	Z+7, r24	; 0x07
					break;
    3078:	ed c0       	rjmp	.+474    	; 0x3254 <DoSampler+0xd64>

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    307a:	80 91 68 05 	lds	r24, 0x0568
    307e:	81 30       	cpi	r24, 0x01	; 1
    3080:	51 f0       	breq	.+20     	; 0x3096 <DoSampler+0xba6>
    3082:	30 f0       	brcs	.+12     	; 0x3090 <DoSampler+0xba0>
    3084:	82 30       	cpi	r24, 0x02	; 2
    3086:	71 f0       	breq	.+28     	; 0x30a4 <DoSampler+0xbb4>
    3088:	83 30       	cpi	r24, 0x03	; 3
    308a:	09 f0       	breq	.+2      	; 0x308e <DoSampler+0xb9e>
    308c:	e3 c0       	rjmp	.+454    	; 0x3254 <DoSampler+0xd64>
    308e:	0d c0       	rjmp	.+26     	; 0x30aa <DoSampler+0xbba>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3090:	85 e3       	ldi	r24, 0x35	; 53
    3092:	98 e0       	ldi	r25, 0x08	; 8
    3094:	02 c0       	rjmp	.+4      	; 0x309a <DoSampler+0xbaa>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3096:	89 ee       	ldi	r24, 0xE9	; 233
    3098:	97 e0       	ldi	r25, 0x07	; 7
    309a:	90 93 e3 05 	sts	0x05E3, r25
    309e:	80 93 e2 05 	sts	0x05E2, r24
						break;
    30a2:	d8 c0       	rjmp	.+432    	; 0x3254 <DoSampler+0xd64>

						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    30a4:	88 ea       	ldi	r24, 0xA8	; 168
    30a6:	98 e0       	ldi	r25, 0x08	; 8
    30a8:	f8 cf       	rjmp	.-16     	; 0x309a <DoSampler+0xbaa>
						break;

						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    30aa:	8b e6       	ldi	r24, 0x6B	; 107
    30ac:	98 e0       	ldi	r25, 0x08	; 8
    30ae:	f5 cf       	rjmp	.-22     	; 0x309a <DoSampler+0xbaa>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
    30b0:	1f b7       	in	r17, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    30b2:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    30b4:	50 91 65 05 	lds	r21, 0x0565
    30b8:	a5 2f       	mov	r26, r21
    30ba:	b0 e0       	ldi	r27, 0x00	; 0
    30bc:	fd 01       	movw	r30, r26
    30be:	ec 5f       	subi	r30, 0xFC	; 252
    30c0:	fe 4f       	sbci	r31, 0xFE	; 254
    30c2:	40 81       	ld	r20, Z
    30c4:	aa 0f       	add	r26, r26
    30c6:	bb 1f       	adc	r27, r27
    30c8:	a0 5a       	subi	r26, 0xA0	; 160
    30ca:	ba 4f       	sbci	r27, 0xFA	; 250
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    30cc:	84 2f       	mov	r24, r20
    30ce:	6c e0       	ldi	r22, 0x0C	; 12
    30d0:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    30d4:	e9 2f       	mov	r30, r25
    30d6:	f0 e0       	ldi	r31, 0x00	; 0
    30d8:	ee 0f       	add	r30, r30
    30da:	ff 1f       	adc	r31, r31
    30dc:	ea 5f       	subi	r30, 0xFA	; 250
    30de:	fe 4f       	sbci	r31, 0xFE	; 254
    30e0:	20 81       	ld	r18, Z
    30e2:	31 81       	ldd	r19, Z+1	; 0x01
    30e4:	02 c0       	rjmp	.+4      	; 0x30ea <DoSampler+0xbfa>
    30e6:	36 95       	lsr	r19
    30e8:	27 95       	ror	r18
    30ea:	8a 95       	dec	r24
    30ec:	e2 f7       	brpl	.-8      	; 0x30e6 <DoSampler+0xbf6>
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    30ee:	2d 93       	st	X+, r18
    30f0:	3c 93       	st	X, r19
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    30f2:	51 11       	cpse	r21, r1
    30f4:	04 c0       	rjmp	.+8      	; 0x30fe <DoSampler+0xc0e>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    30f6:	64 2f       	mov	r22, r20
    30f8:	87 e0       	ldi	r24, 0x07	; 7
    30fa:	90 e0       	ldi	r25, 0x00	; 0
    30fc:	05 c0       	rjmp	.+10     	; 0x3108 <DoSampler+0xc18>
	}
	else if(theBank==BANK_1)
    30fe:	51 30       	cpi	r21, 0x01	; 1
    3100:	29 f4       	brne	.+10     	; 0x310c <DoSampler+0xc1c>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    3102:	64 2f       	mov	r22, r20
    3104:	8b e0       	ldi	r24, 0x0B	; 11
    3106:	90 e0       	ldi	r25, 0x00	; 0
    3108:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=i;		// Re-enable interrupts.
    310c:	1f bf       	out	0x3f, r17	; 63
					break;
    310e:	a2 c0       	rjmp	.+324    	; 0x3254 <DoSampler+0xd64>

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3110:	90 91 68 05 	lds	r25, 0x0568
    3114:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3118:	a3 e2       	ldi	r26, 0x23	; 35
    311a:	8a 9f       	mul	r24, r26
    311c:	f0 01       	movw	r30, r0
    311e:	11 24       	eor	r1, r1
    3120:	20 c0       	rjmp	.+64     	; 0x3162 <DoSampler+0xc72>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3122:	90 91 68 05 	lds	r25, 0x0568
    3126:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    312a:	b3 e2       	ldi	r27, 0x23	; 35
    312c:	8b 9f       	mul	r24, r27
    312e:	f0 01       	movw	r30, r0
    3130:	11 24       	eor	r1, r1
    3132:	24 c0       	rjmp	.+72     	; 0x317c <DoSampler+0xc8c>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3134:	90 91 68 05 	lds	r25, 0x0568
    3138:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    313c:	23 e2       	ldi	r18, 0x23	; 35
    313e:	82 9f       	mul	r24, r18
    3140:	f0 01       	movw	r30, r0
    3142:	11 24       	eor	r1, r1
    3144:	28 c0       	rjmp	.+80     	; 0x3196 <DoSampler+0xca6>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    3146:	80 91 65 05 	lds	r24, 0x0565
    314a:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
					break;
    314e:	82 c0       	rjmp	.+260    	; 0x3254 <DoSampler+0xd64>

					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3150:	90 91 68 05 	lds	r25, 0x0568
    3154:	99 0f       	add	r25, r25
    3156:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    315a:	43 e2       	ldi	r20, 0x23	; 35
    315c:	84 9f       	mul	r24, r20
    315e:	f0 01       	movw	r30, r0
    3160:	11 24       	eor	r1, r1
    3162:	ea 51       	subi	r30, 0x1A	; 26
    3164:	fa 4f       	sbci	r31, 0xFA	; 250
    3166:	94 8f       	std	Z+28, r25	; 0x1c
    3168:	19 c0       	rjmp	.+50     	; 0x319c <DoSampler+0xcac>
					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    316a:	90 91 68 05 	lds	r25, 0x0568
    316e:	99 0f       	add	r25, r25
    3170:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3174:	a3 e2       	ldi	r26, 0x23	; 35
    3176:	8a 9f       	mul	r24, r26
    3178:	f0 01       	movw	r30, r0
    317a:	11 24       	eor	r1, r1
    317c:	ea 51       	subi	r30, 0x1A	; 26
    317e:	fa 4f       	sbci	r31, 0xFA	; 250
    3180:	95 8f       	std	Z+29, r25	; 0x1d
    3182:	0c c0       	rjmp	.+24     	; 0x319c <DoSampler+0xcac>
					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3184:	90 91 68 05 	lds	r25, 0x0568
    3188:	99 0f       	add	r25, r25
    318a:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    318e:	b3 e2       	ldi	r27, 0x23	; 35
    3190:	8b 9f       	mul	r24, r27
    3192:	f0 01       	movw	r30, r0
    3194:	11 24       	eor	r1, r1
    3196:	ea 51       	subi	r30, 0x1A	; 26
    3198:	fa 4f       	sbci	r31, 0xFA	; 250
    319a:	96 8f       	std	Z+30, r25	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    319c:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
    31a0:	59 c0       	rjmp	.+178    	; 0x3254 <DoSampler+0xd64>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    31a2:	87 30       	cpi	r24, 0x07	; 7
    31a4:	09 f0       	breq	.+2      	; 0x31a8 <DoSampler+0xcb8>
    31a6:	56 c0       	rjmp	.+172    	; 0x3254 <DoSampler+0xd64>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    31a8:	80 91 68 05 	lds	r24, 0x0568
    31ac:	20 91 67 05 	lds	r18, 0x0567
    31b0:	30 e0       	ldi	r19, 0x00	; 0
    31b2:	e0 e8       	ldi	r30, 0x80	; 128
    31b4:	8e 9f       	mul	r24, r30
    31b6:	20 0d       	add	r18, r0
    31b8:	31 1d       	adc	r19, r1
    31ba:	11 24       	eor	r1, r1
    31bc:	a0 91 65 05 	lds	r26, 0x0565

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    31c0:	21 15       	cp	r18, r1
    31c2:	f0 e2       	ldi	r31, 0x20	; 32
    31c4:	3f 07       	cpc	r19, r31
    31c6:	31 f1       	breq	.+76     	; 0x3214 <DoSampler+0xd24>
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    31c8:	b0 e0       	ldi	r27, 0x00	; 0
    31ca:	fd 01       	movw	r30, r26
    31cc:	ec 5f       	subi	r30, 0xFC	; 252
    31ce:	fe 4f       	sbci	r31, 0xFE	; 254
    31d0:	80 81       	ld	r24, Z
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    31d2:	40 e0       	ldi	r20, 0x00	; 0
    31d4:	50 e2       	ldi	r21, 0x20	; 32
    31d6:	42 1b       	sub	r20, r18
    31d8:	53 0b       	sbc	r21, r19
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    31da:	6c e0       	ldi	r22, 0x0C	; 12
    31dc:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    31e0:	e9 2f       	mov	r30, r25
    31e2:	f0 e0       	ldi	r31, 0x00	; 0
    31e4:	ee 0f       	add	r30, r30
    31e6:	ff 1f       	adc	r31, r31
    31e8:	ea 5f       	subi	r30, 0xFA	; 250
    31ea:	fe 4f       	sbci	r31, 0xFE	; 254
    31ec:	20 81       	ld	r18, Z
    31ee:	31 81       	ldd	r19, Z+1	; 0x01
    31f0:	02 c0       	rjmp	.+4      	; 0x31f6 <DoSampler+0xd06>
    31f2:	36 95       	lsr	r19
    31f4:	27 95       	ror	r18
    31f6:	8a 95       	dec	r24
    31f8:	e2 f7       	brpl	.-8      	; 0x31f2 <DoSampler+0xd02>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    31fa:	42 0f       	add	r20, r18
    31fc:	53 1f       	adc	r21, r19
    31fe:	83 e2       	ldi	r24, 0x23	; 35
    3200:	8a 9f       	mul	r24, r26
    3202:	f0 01       	movw	r30, r0
    3204:	8b 9f       	mul	r24, r27
    3206:	f0 0d       	add	r31, r0
    3208:	11 24       	eor	r1, r1
    320a:	ea 51       	subi	r30, 0x1A	; 26
    320c:	fa 4f       	sbci	r31, 0xFA	; 250
    320e:	53 87       	std	Z+11, r21	; 0x0b
    3210:	42 87       	std	Z+10, r20	; 0x0a
    3212:	20 c0       	rjmp	.+64     	; 0x3254 <DoSampler+0xd64>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    3214:	4a 2f       	mov	r20, r26
    3216:	50 e0       	ldi	r21, 0x00	; 0
    3218:	fa 01       	movw	r30, r20
    321a:	ec 5f       	subi	r30, 0xFC	; 252
    321c:	fe 4f       	sbci	r31, 0xFE	; 254
    321e:	80 81       	ld	r24, Z
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    3220:	6c e0       	ldi	r22, 0x0C	; 12
    3222:	0e 94 5b 28 	call	0x50b6	; 0x50b6 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3226:	e9 2f       	mov	r30, r25
    3228:	f0 e0       	ldi	r31, 0x00	; 0
    322a:	ee 0f       	add	r30, r30
    322c:	ff 1f       	adc	r31, r31
    322e:	ea 5f       	subi	r30, 0xFA	; 250
    3230:	fe 4f       	sbci	r31, 0xFE	; 254
    3232:	20 81       	ld	r18, Z
    3234:	31 81       	ldd	r19, Z+1	; 0x01
    3236:	02 c0       	rjmp	.+4      	; 0x323c <DoSampler+0xd4c>
    3238:	36 95       	lsr	r19
    323a:	27 95       	ror	r18
    323c:	8a 95       	dec	r24
    323e:	e2 f7       	brpl	.-8      	; 0x3238 <DoSampler+0xd48>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    3240:	83 e2       	ldi	r24, 0x23	; 35
    3242:	84 9f       	mul	r24, r20
    3244:	f0 01       	movw	r30, r0
    3246:	85 9f       	mul	r24, r21
    3248:	f0 0d       	add	r31, r0
    324a:	11 24       	eor	r1, r1
    324c:	ea 51       	subi	r30, 0x1A	; 26
    324e:	fa 4f       	sbci	r31, 0xFA	; 250
    3250:	33 87       	std	Z+11, r19	; 0x0b
    3252:	22 87       	std	Z+10, r18	; 0x0a
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    3254:	80 91 4f 05 	lds	r24, 0x054F
    3258:	83 30       	cpi	r24, 0x03	; 3
    325a:	11 f0       	breq	.+4      	; 0x3260 <DoSampler+0xd70>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    325c:	10 92 55 05 	sts	0x0555, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    3260:	80 91 ef 05 	lds	r24, 0x05EF
    3264:	81 30       	cpi	r24, 0x01	; 1
    3266:	41 f0       	breq	.+16     	; 0x3278 <DoSampler+0xd88>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    3268:	10 92 42 04 	sts	0x0442, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    326c:	80 91 6f 00 	lds	r24, 0x006F
    3270:	8f 7d       	andi	r24, 0xDF	; 223
    3272:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
    3276:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    3278:	80 91 12 06 	lds	r24, 0x0612
    327c:	81 30       	cpi	r24, 0x01	; 1
    327e:	31 f0       	breq	.+12     	; 0x328c <DoSampler+0xd9c>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    3280:	10 92 45 05 	sts	0x0545, r1
		PCICR=0;			// No global PCINTS.
    3284:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    3288:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    328c:	80 91 ef 05 	lds	r24, 0x05EF
    3290:	82 30       	cpi	r24, 0x02	; 2
    3292:	41 f0       	breq	.+16     	; 0x32a4 <DoSampler+0xdb4>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    3294:	10 92 48 05 	sts	0x0548, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    3298:	80 91 6f 00 	lds	r24, 0x006F
    329c:	8d 7f       	andi	r24, 0xFD	; 253
    329e:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
    32a2:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    32a4:	80 91 12 06 	lds	r24, 0x0612
    32a8:	82 30       	cpi	r24, 0x02	; 2
    32aa:	41 f0       	breq	.+16     	; 0x32bc <DoSampler+0xdcc>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    32ac:	10 92 4c 05 	sts	0x054C, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    32b0:	80 91 6f 00 	lds	r24, 0x006F
    32b4:	8b 7f       	andi	r24, 0xFB	; 251
    32b6:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
    32ba:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    32bc:	80 91 ef 05 	lds	r24, 0x05EF
    32c0:	81 11       	cpse	r24, r1
    32c2:	0c c0       	rjmp	.+24     	; 0x32dc <DoSampler+0xdec>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    32c4:	80 91 4f 05 	lds	r24, 0x054F
    32c8:	88 23       	and	r24, r24
    32ca:	31 f0       	breq	.+12     	; 0x32d8 <DoSampler+0xde8>
    32cc:	83 30       	cpi	r24, 0x03	; 3
    32ce:	21 f0       	breq	.+8      	; 0x32d8 <DoSampler+0xde8>
    32d0:	80 91 54 05 	lds	r24, 0x0554
    32d4:	81 11       	cpse	r24, r1
    32d6:	02 c0       	rjmp	.+4      	; 0x32dc <DoSampler+0xdec>
		{
			bankStates[BANK_0].isLocked=false;
    32d8:	10 92 eb 05 	sts	0x05EB, r1
		}
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    32dc:	80 91 12 06 	lds	r24, 0x0612
    32e0:	81 11       	cpse	r24, r1
    32e2:	0c c0       	rjmp	.+24     	; 0x32fc <DoSampler+0xe0c>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    32e4:	80 91 4f 05 	lds	r24, 0x054F
    32e8:	88 23       	and	r24, r24
    32ea:	31 f0       	breq	.+12     	; 0x32f8 <DoSampler+0xe08>
    32ec:	83 30       	cpi	r24, 0x03	; 3
    32ee:	21 f0       	breq	.+8      	; 0x32f8 <DoSampler+0xe08>
    32f0:	80 91 54 05 	lds	r24, 0x0554
    32f4:	81 30       	cpi	r24, 0x01	; 1
    32f6:	11 f4       	brne	.+4      	; 0x32fc <DoSampler+0xe0c>
		{
			bankStates[BANK_1].isLocked=false;
    32f8:	10 92 0e 06 	sts	0x060E, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    32fc:	80 91 6b 05 	lds	r24, 0x056B
    3300:	82 95       	swap	r24
    3302:	86 95       	lsr	r24
    3304:	87 70       	andi	r24, 0x07	; 7
    3306:	80 93 6d 05 	sts	0x056D, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    330a:	20 91 5d 05 	lds	r18, 0x055D
    330e:	2f 71       	andi	r18, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    3310:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    3312:	20 68       	ori	r18, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    3314:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    3316:	20 64       	ori	r18, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    3318:	84 70       	andi	r24, 0x04	; 4
    331a:	09 f0       	breq	.+2      	; 0x331e <DoSampler+0xe2e>
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    331c:	20 62       	ori	r18, 0x20	; 32
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    331e:	30 91 64 05 	lds	r19, 0x0564
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    3322:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    3324:	83 2f       	mov	r24, r19
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	a3 e2       	ldi	r26, 0x23	; 35
    332a:	3a 9f       	mul	r19, r26
    332c:	f0 01       	movw	r30, r0
    332e:	11 24       	eor	r1, r1
    3330:	ea 51       	subi	r30, 0x1A	; 26
    3332:	fa 4f       	sbci	r31, 0xFA	; 250
    3334:	40 81       	ld	r20, Z
    3336:	43 30       	cpi	r20, 0x03	; 3
    3338:	09 f4       	brne	.+2      	; 0x333c <DoSampler+0xe4c>
	{
		temp|=Om_LED_REC;
    333a:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    333c:	43 e2       	ldi	r20, 0x23	; 35
    333e:	48 9f       	mul	r20, r24
    3340:	f0 01       	movw	r30, r0
    3342:	49 9f       	mul	r20, r25
    3344:	f0 0d       	add	r31, r0
    3346:	11 24       	eor	r1, r1
    3348:	ea 51       	subi	r30, 0x1A	; 26
    334a:	fa 4f       	sbci	r31, 0xFA	; 250
    334c:	40 81       	ld	r20, Z
    334e:	44 30       	cpi	r20, 0x04	; 4
    3350:	09 f4       	brne	.+2      	; 0x3354 <DoSampler+0xe64>
	{
		temp|=Om_LED_PLAY;
    3352:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    3354:	43 e2       	ldi	r20, 0x23	; 35
    3356:	48 9f       	mul	r20, r24
    3358:	f0 01       	movw	r30, r0
    335a:	49 9f       	mul	r20, r25
    335c:	f0 0d       	add	r31, r0
    335e:	11 24       	eor	r1, r1
    3360:	ea 51       	subi	r30, 0x1A	; 26
    3362:	fa 4f       	sbci	r31, 0xFA	; 250
    3364:	40 81       	ld	r20, Z
    3366:	45 30       	cpi	r20, 0x05	; 5
    3368:	09 f4       	brne	.+2      	; 0x336c <DoSampler+0xe7c>
	{
		temp|=Om_LED_ODUB;
    336a:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    336c:	43 e2       	ldi	r20, 0x23	; 35
    336e:	48 9f       	mul	r20, r24
    3370:	f0 01       	movw	r30, r0
    3372:	49 9f       	mul	r20, r25
    3374:	f0 0d       	add	r31, r0
    3376:	11 24       	eor	r1, r1
    3378:	ea 51       	subi	r30, 0x1A	; 26
    337a:	fa 4f       	sbci	r31, 0xFA	; 250
    337c:	40 81       	ld	r20, Z
    337e:	42 30       	cpi	r20, 0x02	; 2
    3380:	09 f4       	brne	.+2      	; 0x3384 <DoSampler+0xe94>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    3382:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    3384:	40 91 3f 04 	lds	r20, 0x043F
    3388:	41 30       	cpi	r20, 0x01	; 1
    338a:	09 f4       	brne	.+2      	; 0x338e <DoSampler+0xe9e>
	{
		temp|=Om_LED_OUT_OF_MEM;
    338c:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    338e:	31 30       	cpi	r19, 0x01	; 1
    3390:	09 f4       	brne	.+2      	; 0x3394 <DoSampler+0xea4>
	{
		temp|=Om_LED_BANK;
    3392:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    3394:	20 93 5d 05 	sts	0x055D, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    3398:	23 e2       	ldi	r18, 0x23	; 35
    339a:	28 9f       	mul	r18, r24
    339c:	f0 01       	movw	r30, r0
    339e:	29 9f       	mul	r18, r25
    33a0:	f0 0d       	add	r31, r0
    33a2:	11 24       	eor	r1, r1
    33a4:	ea 51       	subi	r30, 0x1A	; 26
    33a6:	fa 4f       	sbci	r31, 0xFA	; 250
    33a8:	40 89       	ldd	r20, Z+16	; 0x10
    33aa:	51 89       	ldd	r21, Z+17	; 0x11
    33ac:	62 89       	ldd	r22, Z+18	; 0x12
    33ae:	73 89       	ldd	r23, Z+19	; 0x13
    33b0:	84 85       	ldd	r24, Z+12	; 0x0c
    33b2:	95 85       	ldd	r25, Z+13	; 0x0d
    33b4:	a6 85       	ldd	r26, Z+14	; 0x0e
    33b6:	b7 85       	ldd	r27, Z+15	; 0x0f
    33b8:	48 17       	cp	r20, r24
    33ba:	59 07       	cpc	r21, r25
    33bc:	6a 07       	cpc	r22, r26
    33be:	7b 07       	cpc	r23, r27
    33c0:	39 f4       	brne	.+14     	; 0x33d0 <DoSampler+0xee0>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    33c2:	80 91 7a 05 	lds	r24, 0x057A
    33c6:	82 fd       	sbrc	r24, 2
    33c8:	14 c0       	rjmp	.+40     	; 0x33f2 <DoSampler+0xf02>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    33ca:	84 e0       	ldi	r24, 0x04	; 4
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	02 c0       	rjmp	.+4      	; 0x33d4 <DoSampler+0xee4>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    33d0:	80 e0       	ldi	r24, 0x00	; 0
    33d2:	90 e0       	ldi	r25, 0x00	; 0

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    33d4:	0f 90       	pop	r0
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
    33da:	1f 91       	pop	r17
    33dc:	0f 91       	pop	r16
    33de:	ff 90       	pop	r15
    33e0:	ef 90       	pop	r14
    33e2:	df 90       	pop	r13
    33e4:	cf 90       	pop	r12
    33e6:	bf 90       	pop	r11
    33e8:	af 90       	pop	r10
    33ea:	9f 90       	pop	r9
    33ec:	8f 90       	pop	r8
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    33ee:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <BlinkLeds>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    33f2:	0f 90       	pop	r0
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	1f 91       	pop	r17
    33fa:	0f 91       	pop	r16
    33fc:	ff 90       	pop	r15
    33fe:	ef 90       	pop	r14
    3400:	df 90       	pop	r13
    3402:	cf 90       	pop	r12
    3404:	bf 90       	pop	r11
    3406:	af 90       	pop	r10
    3408:	9f 90       	pop	r9
    340a:	8f 90       	pop	r8
    340c:	08 95       	ret

0000340e <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    340e:	1f 92       	push	r1
    3410:	0f 92       	push	r0
    3412:	0f b6       	in	r0, 0x3f	; 63
    3414:	0f 92       	push	r0
    3416:	11 24       	eor	r1, r1
    3418:	2f 93       	push	r18
    341a:	3f 93       	push	r19
    341c:	4f 93       	push	r20
    341e:	5f 93       	push	r21
    3420:	6f 93       	push	r22
    3422:	7f 93       	push	r23
    3424:	8f 93       	push	r24
    3426:	9f 93       	push	r25
    3428:	af 93       	push	r26
    342a:	bf 93       	push	r27
    342c:	ef 93       	push	r30
    342e:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3430:	80 91 e8 05 	lds	r24, 0x05E8
    3434:	88 23       	and	r24, r24
    3436:	41 f0       	breq	.+16     	; 0x3448 <__vector_12+0x3a>
    3438:	80 91 e8 05 	lds	r24, 0x05E8
    343c:	88 23       	and	r24, r24
    343e:	41 f0       	breq	.+16     	; 0x3450 <__vector_12+0x42>
    3440:	80 91 41 04 	lds	r24, 0x0441
    3444:	88 23       	and	r24, r24
    3446:	21 f0       	breq	.+8      	; 0x3450 <__vector_12+0x42>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    3448:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    344c:	80 93 42 04 	sts	0x0442, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3450:	10 92 41 04 	sts	0x0441, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3454:	e0 91 e2 05 	lds	r30, 0x05E2
    3458:	f0 91 e3 05 	lds	r31, 0x05E3
    345c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    345e:	80 91 7a 00 	lds	r24, 0x007A
    3462:	86 fd       	sbrc	r24, 6
    3464:	0a c0       	rjmp	.+20     	; 0x347a <__vector_12+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3466:	80 91 79 00 	lds	r24, 0x0079
    346a:	80 58       	subi	r24, 0x80	; 128
    346c:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3470:	80 91 7a 00 	lds	r24, 0x007A
    3474:	80 64       	ori	r24, 0x40	; 64
    3476:	80 93 7a 00 	sts	0x007A, r24
	}
}
    347a:	ff 91       	pop	r31
    347c:	ef 91       	pop	r30
    347e:	bf 91       	pop	r27
    3480:	af 91       	pop	r26
    3482:	9f 91       	pop	r25
    3484:	8f 91       	pop	r24
    3486:	7f 91       	pop	r23
    3488:	6f 91       	pop	r22
    348a:	5f 91       	pop	r21
    348c:	4f 91       	pop	r20
    348e:	3f 91       	pop	r19
    3490:	2f 91       	pop	r18
    3492:	0f 90       	pop	r0
    3494:	0f be       	out	0x3f, r0	; 63
    3496:	0f 90       	pop	r0
    3498:	1f 90       	pop	r1
    349a:	18 95       	reti

0000349c <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    349c:	1f 92       	push	r1
    349e:	0f 92       	push	r0
    34a0:	0f b6       	in	r0, 0x3f	; 63
    34a2:	0f 92       	push	r0
    34a4:	11 24       	eor	r1, r1
    34a6:	2f 93       	push	r18
    34a8:	3f 93       	push	r19
    34aa:	4f 93       	push	r20
    34ac:	5f 93       	push	r21
    34ae:	6f 93       	push	r22
    34b0:	7f 93       	push	r23
    34b2:	8f 93       	push	r24
    34b4:	9f 93       	push	r25
    34b6:	af 93       	push	r26
    34b8:	bf 93       	push	r27
    34ba:	ef 93       	push	r30
    34bc:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    34be:	80 91 0b 06 	lds	r24, 0x060B
    34c2:	88 23       	and	r24, r24
    34c4:	41 f0       	breq	.+16     	; 0x34d6 <__vector_6+0x3a>
    34c6:	80 91 0b 06 	lds	r24, 0x060B
    34ca:	88 23       	and	r24, r24
    34cc:	41 f0       	breq	.+16     	; 0x34de <__vector_6+0x42>
    34ce:	80 91 44 05 	lds	r24, 0x0544
    34d2:	88 23       	and	r24, r24
    34d4:	21 f0       	breq	.+8      	; 0x34de <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    34d6:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    34da:	80 93 45 05 	sts	0x0545, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    34de:	10 92 44 05 	sts	0x0544, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    34e2:	e0 91 e2 05 	lds	r30, 0x05E2
    34e6:	f0 91 e3 05 	lds	r31, 0x05E3
    34ea:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    34ec:	80 91 7a 00 	lds	r24, 0x007A
    34f0:	86 fd       	sbrc	r24, 6
    34f2:	0a c0       	rjmp	.+20     	; 0x3508 <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    34f4:	80 91 79 00 	lds	r24, 0x0079
    34f8:	80 58       	subi	r24, 0x80	; 128
    34fa:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    34fe:	80 91 7a 00 	lds	r24, 0x007A
    3502:	80 64       	ori	r24, 0x40	; 64
    3504:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    3508:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    350a:	ff 91       	pop	r31
    350c:	ef 91       	pop	r30
    350e:	bf 91       	pop	r27
    3510:	af 91       	pop	r26
    3512:	9f 91       	pop	r25
    3514:	8f 91       	pop	r24
    3516:	7f 91       	pop	r23
    3518:	6f 91       	pop	r22
    351a:	5f 91       	pop	r21
    351c:	4f 91       	pop	r20
    351e:	3f 91       	pop	r19
    3520:	2f 91       	pop	r18
    3522:	0f 90       	pop	r0
    3524:	0f be       	out	0x3f, r0	; 63
    3526:	0f 90       	pop	r0
    3528:	1f 90       	pop	r1
    352a:	18 95       	reti

0000352c <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    352c:	1f 92       	push	r1
    352e:	0f 92       	push	r0
    3530:	0f b6       	in	r0, 0x3f	; 63
    3532:	0f 92       	push	r0
    3534:	11 24       	eor	r1, r1
    3536:	0f 93       	push	r16
    3538:	1f 93       	push	r17
    353a:	2f 93       	push	r18
    353c:	3f 93       	push	r19
    353e:	4f 93       	push	r20
    3540:	5f 93       	push	r21
    3542:	6f 93       	push	r22
    3544:	7f 93       	push	r23
    3546:	8f 93       	push	r24
    3548:	9f 93       	push	r25
    354a:	af 93       	push	r26
    354c:	bf 93       	push	r27
    354e:	cf 93       	push	r28
    3550:	df 93       	push	r29
    3552:	ef 93       	push	r30
    3554:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3556:	80 91 e8 05 	lds	r24, 0x05E8
    355a:	88 23       	and	r24, r24
    355c:	41 f0       	breq	.+16     	; 0x356e <__vector_13+0x42>
    355e:	80 91 e8 05 	lds	r24, 0x05E8
    3562:	88 23       	and	r24, r24
    3564:	41 f0       	breq	.+16     	; 0x3576 <__vector_13+0x4a>
    3566:	80 91 47 05 	lds	r24, 0x0547
    356a:	88 23       	and	r24, r24
    356c:	21 f0       	breq	.+8      	; 0x3576 <__vector_13+0x4a>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    356e:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    3572:	80 93 48 05 	sts	0x0548, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    3576:	80 91 ed 05 	lds	r24, 0x05ED
    357a:	88 23       	and	r24, r24
    357c:	a1 f1       	breq	.+104    	; 0x35e6 <__vector_13+0xba>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    357e:	a0 91 ed 05 	lds	r26, 0x05ED
    3582:	20 91 f0 05 	lds	r18, 0x05F0
    3586:	30 91 f1 05 	lds	r19, 0x05F1
    358a:	b0 e0       	ldi	r27, 0x00	; 0
    358c:	0e 94 8f 28 	call	0x511e	; 0x511e <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    3590:	2f e7       	ldi	r18, 0x7F	; 127
    3592:	30 e0       	ldi	r19, 0x00	; 0
    3594:	40 e0       	ldi	r20, 0x00	; 0
    3596:	50 e0       	ldi	r21, 0x00	; 0
    3598:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    359c:	00 91 88 00 	lds	r16, 0x0088
    35a0:	10 91 89 00 	lds	r17, 0x0089
    35a4:	c0 91 f0 05 	lds	r28, 0x05F0
    35a8:	d0 91 f1 05 	lds	r29, 0x05F1
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    35ac:	60 91 00 01 	lds	r22, 0x0100
    35b0:	70 91 01 01 	lds	r23, 0x0101
    35b4:	80 91 02 01 	lds	r24, 0x0102
    35b8:	90 91 03 01 	lds	r25, 0x0103
    35bc:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    35c0:	c0 0f       	add	r28, r16
    35c2:	d1 1f       	adc	r29, r17
    35c4:	40 91 49 05 	lds	r20, 0x0549
    35c8:	50 91 4a 05 	lds	r21, 0x054A
    35cc:	c4 0f       	add	r28, r20
    35ce:	d5 1f       	adc	r29, r21
    35d0:	c6 1b       	sub	r28, r22
    35d2:	d7 0b       	sbc	r29, r23
    35d4:	d0 93 89 00 	sts	0x0089, r29
    35d8:	c0 93 88 00 	sts	0x0088, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    35dc:	70 93 4a 05 	sts	0x054A, r23
    35e0:	60 93 49 05 	sts	0x0549, r22
    35e4:	0e c0       	rjmp	.+28     	; 0x3602 <__vector_13+0xd6>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    35e6:	20 91 88 00 	lds	r18, 0x0088
    35ea:	30 91 89 00 	lds	r19, 0x0089
    35ee:	80 91 f0 05 	lds	r24, 0x05F0
    35f2:	90 91 f1 05 	lds	r25, 0x05F1
    35f6:	82 0f       	add	r24, r18
    35f8:	93 1f       	adc	r25, r19
    35fa:	90 93 89 00 	sts	0x0089, r25
    35fe:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3602:	10 92 47 05 	sts	0x0547, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3606:	e0 91 e2 05 	lds	r30, 0x05E2
    360a:	f0 91 e3 05 	lds	r31, 0x05E3
    360e:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3610:	80 91 7a 00 	lds	r24, 0x007A
    3614:	86 fd       	sbrc	r24, 6
    3616:	0a c0       	rjmp	.+20     	; 0x362c <__vector_13+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3618:	80 91 79 00 	lds	r24, 0x0079
    361c:	80 58       	subi	r24, 0x80	; 128
    361e:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3622:	80 91 7a 00 	lds	r24, 0x007A
    3626:	80 64       	ori	r24, 0x40	; 64
    3628:	80 93 7a 00 	sts	0x007A, r24
	}
}
    362c:	ff 91       	pop	r31
    362e:	ef 91       	pop	r30
    3630:	df 91       	pop	r29
    3632:	cf 91       	pop	r28
    3634:	bf 91       	pop	r27
    3636:	af 91       	pop	r26
    3638:	9f 91       	pop	r25
    363a:	8f 91       	pop	r24
    363c:	7f 91       	pop	r23
    363e:	6f 91       	pop	r22
    3640:	5f 91       	pop	r21
    3642:	4f 91       	pop	r20
    3644:	3f 91       	pop	r19
    3646:	2f 91       	pop	r18
    3648:	1f 91       	pop	r17
    364a:	0f 91       	pop	r16
    364c:	0f 90       	pop	r0
    364e:	0f be       	out	0x3f, r0	; 63
    3650:	0f 90       	pop	r0
    3652:	1f 90       	pop	r1
    3654:	18 95       	reti

00003656 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    3656:	1f 92       	push	r1
    3658:	0f 92       	push	r0
    365a:	0f b6       	in	r0, 0x3f	; 63
    365c:	0f 92       	push	r0
    365e:	11 24       	eor	r1, r1
    3660:	0f 93       	push	r16
    3662:	1f 93       	push	r17
    3664:	2f 93       	push	r18
    3666:	3f 93       	push	r19
    3668:	4f 93       	push	r20
    366a:	5f 93       	push	r21
    366c:	6f 93       	push	r22
    366e:	7f 93       	push	r23
    3670:	8f 93       	push	r24
    3672:	9f 93       	push	r25
    3674:	af 93       	push	r26
    3676:	bf 93       	push	r27
    3678:	cf 93       	push	r28
    367a:	df 93       	push	r29
    367c:	ef 93       	push	r30
    367e:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3680:	80 91 0b 06 	lds	r24, 0x060B
    3684:	88 23       	and	r24, r24
    3686:	41 f0       	breq	.+16     	; 0x3698 <__vector_14+0x42>
    3688:	80 91 0b 06 	lds	r24, 0x060B
    368c:	88 23       	and	r24, r24
    368e:	41 f0       	breq	.+16     	; 0x36a0 <__vector_14+0x4a>
    3690:	80 91 4b 05 	lds	r24, 0x054B
    3694:	88 23       	and	r24, r24
    3696:	21 f0       	breq	.+8      	; 0x36a0 <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    3698:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    369c:	80 93 4c 05 	sts	0x054C, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    36a0:	80 91 10 06 	lds	r24, 0x0610
    36a4:	88 23       	and	r24, r24
    36a6:	a1 f1       	breq	.+104    	; 0x3710 <__vector_14+0xba>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    36a8:	a0 91 10 06 	lds	r26, 0x0610
    36ac:	20 91 13 06 	lds	r18, 0x0613
    36b0:	30 91 14 06 	lds	r19, 0x0614
    36b4:	b0 e0       	ldi	r27, 0x00	; 0
    36b6:	0e 94 8f 28 	call	0x511e	; 0x511e <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    36ba:	2f e7       	ldi	r18, 0x7F	; 127
    36bc:	30 e0       	ldi	r19, 0x00	; 0
    36be:	40 e0       	ldi	r20, 0x00	; 0
    36c0:	50 e0       	ldi	r21, 0x00	; 0
    36c2:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    36c6:	00 91 8a 00 	lds	r16, 0x008A
    36ca:	10 91 8b 00 	lds	r17, 0x008B
    36ce:	c0 91 13 06 	lds	r28, 0x0613
    36d2:	d0 91 14 06 	lds	r29, 0x0614
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    36d6:	60 91 00 01 	lds	r22, 0x0100
    36da:	70 91 01 01 	lds	r23, 0x0101
    36de:	80 91 02 01 	lds	r24, 0x0102
    36e2:	90 91 03 01 	lds	r25, 0x0103
    36e6:	0e 94 67 28 	call	0x50ce	; 0x50ce <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    36ea:	c0 0f       	add	r28, r16
    36ec:	d1 1f       	adc	r29, r17
    36ee:	40 91 4d 05 	lds	r20, 0x054D
    36f2:	50 91 4e 05 	lds	r21, 0x054E
    36f6:	c4 0f       	add	r28, r20
    36f8:	d5 1f       	adc	r29, r21
    36fa:	c6 1b       	sub	r28, r22
    36fc:	d7 0b       	sbc	r29, r23
    36fe:	d0 93 8b 00 	sts	0x008B, r29
    3702:	c0 93 8a 00 	sts	0x008A, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    3706:	70 93 4e 05 	sts	0x054E, r23
    370a:	60 93 4d 05 	sts	0x054D, r22
    370e:	0e c0       	rjmp	.+28     	; 0x372c <__vector_14+0xd6>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    3710:	20 91 8a 00 	lds	r18, 0x008A
    3714:	30 91 8b 00 	lds	r19, 0x008B
    3718:	80 91 13 06 	lds	r24, 0x0613
    371c:	90 91 14 06 	lds	r25, 0x0614
    3720:	82 0f       	add	r24, r18
    3722:	93 1f       	adc	r25, r19
    3724:	90 93 8b 00 	sts	0x008B, r25
    3728:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    372c:	10 92 4b 05 	sts	0x054B, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3730:	e0 91 e2 05 	lds	r30, 0x05E2
    3734:	f0 91 e3 05 	lds	r31, 0x05E3
    3738:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    373a:	80 91 7a 00 	lds	r24, 0x007A
    373e:	86 fd       	sbrc	r24, 6
    3740:	0a c0       	rjmp	.+20     	; 0x3756 <__vector_14+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3742:	80 91 79 00 	lds	r24, 0x0079
    3746:	80 58       	subi	r24, 0x80	; 128
    3748:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    374c:	80 91 7a 00 	lds	r24, 0x007A
    3750:	80 64       	ori	r24, 0x40	; 64
    3752:	80 93 7a 00 	sts	0x007A, r24
	}
}
    3756:	ff 91       	pop	r31
    3758:	ef 91       	pop	r30
    375a:	df 91       	pop	r29
    375c:	cf 91       	pop	r28
    375e:	bf 91       	pop	r27
    3760:	af 91       	pop	r26
    3762:	9f 91       	pop	r25
    3764:	8f 91       	pop	r24
    3766:	7f 91       	pop	r23
    3768:	6f 91       	pop	r22
    376a:	5f 91       	pop	r21
    376c:	4f 91       	pop	r20
    376e:	3f 91       	pop	r19
    3770:	2f 91       	pop	r18
    3772:	1f 91       	pop	r17
    3774:	0f 91       	pop	r16
    3776:	0f 90       	pop	r0
    3778:	0f be       	out	0x3f, r0	; 63
    377a:	0f 90       	pop	r0
    377c:	1f 90       	pop	r1
    377e:	18 95       	reti

00003780 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    3780:	1f 92       	push	r1
    3782:	0f 92       	push	r0
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	0f 92       	push	r0
    3788:	11 24       	eor	r1, r1
    378a:	2f 93       	push	r18
    378c:	3f 93       	push	r19
    378e:	4f 93       	push	r20
    3790:	5f 93       	push	r21
    3792:	6f 93       	push	r22
    3794:	7f 93       	push	r23
    3796:	8f 93       	push	r24
    3798:	9f 93       	push	r25
    379a:	af 93       	push	r26
    379c:	bf 93       	push	r27
    379e:	ef 93       	push	r30
    37a0:	ff 93       	push	r31
	unsigned char
		theByte;

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    37a2:	80 91 4f 05 	lds	r24, 0x054F
    37a6:	81 30       	cpi	r24, 0x01	; 1
    37a8:	09 f0       	breq	.+2      	; 0x37ac <__vector_10+0x2c>
    37aa:	be c0       	rjmp	.+380    	; 0x3928 <__vector_10+0x1a8>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    37ac:	80 91 22 01 	lds	r24, 0x0122
    37b0:	90 91 23 01 	lds	r25, 0x0123
    37b4:	a0 91 24 01 	lds	r26, 0x0124
    37b8:	b0 91 25 01 	lds	r27, 0x0125
    37bc:	89 2b       	or	r24, r25
    37be:	8a 2b       	or	r24, r26
    37c0:	8b 2b       	or	r24, r27
    37c2:	09 f4       	brne	.+2      	; 0x37c6 <__vector_10+0x46>
    37c4:	76 c0       	rjmp	.+236    	; 0x38b2 <__vector_10+0x132>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    37c6:	80 91 26 01 	lds	r24, 0x0126
    37ca:	90 91 27 01 	lds	r25, 0x0127
    37ce:	89 2b       	or	r24, r25
    37d0:	09 f4       	brne	.+2      	; 0x37d4 <__vector_10+0x54>
    37d2:	a6 c1       	rjmp	.+844    	; 0x3b20 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    37d4:	e0 91 2a 01 	lds	r30, 0x012A
    37d8:	f0 91 2b 01 	lds	r31, 0x012B
    37dc:	e4 5d       	subi	r30, 0xD4	; 212
    37de:	fe 4f       	sbci	r31, 0xFE	; 254
    37e0:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    37e2:	80 91 2a 01 	lds	r24, 0x012A
    37e6:	90 91 2b 01 	lds	r25, 0x012B
    37ea:	01 96       	adiw	r24, 0x01	; 1
    37ec:	90 93 2b 01 	sts	0x012B, r25
    37f0:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    37f4:	80 91 2a 01 	lds	r24, 0x012A
    37f8:	90 91 2b 01 	lds	r25, 0x012B
    37fc:	81 15       	cp	r24, r1
    37fe:	93 40       	sbci	r25, 0x03	; 3
    3800:	20 f0       	brcs	.+8      	; 0x380a <__vector_10+0x8a>
				{
					sdFifoReadPointer=0;
    3802:	10 92 2b 01 	sts	0x012B, r1
    3806:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    380a:	80 91 26 01 	lds	r24, 0x0126
    380e:	90 91 27 01 	lds	r25, 0x0127
    3812:	01 97       	sbiw	r24, 0x01	; 1
    3814:	90 93 27 01 	sts	0x0127, r25
    3818:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    381c:	80 91 22 01 	lds	r24, 0x0122
    3820:	90 91 23 01 	lds	r25, 0x0123
    3824:	a0 91 24 01 	lds	r26, 0x0124
    3828:	b0 91 25 01 	lds	r27, 0x0125
    382c:	01 97       	sbiw	r24, 0x01	; 1
    382e:	a1 09       	sbc	r26, r1
    3830:	b1 09       	sbc	r27, r1
    3832:	80 93 22 01 	sts	0x0122, r24
    3836:	90 93 23 01 	sts	0x0123, r25
    383a:	a0 93 24 01 	sts	0x0124, r26
    383e:	b0 93 25 01 	sts	0x0125, r27

				// Now put this byte into the RAM bank in the correct address.

				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    3842:	8f ef       	ldi	r24, 0xFF	; 255
    3844:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    3846:	80 91 50 05 	lds	r24, 0x0550
    384a:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    384c:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    384e:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    3850:	40 91 50 05 	lds	r20, 0x0550
    3854:	50 91 51 05 	lds	r21, 0x0551
    3858:	60 91 52 05 	lds	r22, 0x0552
    385c:	70 91 53 05 	lds	r23, 0x0553
    3860:	bb 27       	eor	r27, r27
    3862:	a7 2f       	mov	r26, r23
    3864:	96 2f       	mov	r25, r22
    3866:	85 2f       	mov	r24, r21
    3868:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    386a:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    386c:	14 98       	cbi	0x02, 4	; 2
				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    386e:	cb 01       	movw	r24, r22
    3870:	aa 27       	eor	r26, r26
    3872:	bb 27       	eor	r27, r27
    3874:	87 70       	andi	r24, 0x07	; 7
    3876:	99 27       	eor	r25, r25
    3878:	aa 27       	eor	r26, r26
    387a:	bb 27       	eor	r27, r27
    387c:	88 68       	ori	r24, 0x88	; 136
    387e:	88 b9       	out	0x08, r24	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    3880:	25 b9       	out	0x05, r18	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    3882:	80 91 54 05 	lds	r24, 0x0554
    3886:	81 30       	cpi	r24, 0x01	; 1
    3888:	29 f4       	brne	.+10     	; 0x3894 <__vector_10+0x114>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    388a:	4f 5f       	subi	r20, 0xFF	; 255
    388c:	5f 4f       	sbci	r21, 0xFF	; 255
    388e:	6f 4f       	sbci	r22, 0xFF	; 255
    3890:	7f 4f       	sbci	r23, 0xFF	; 255
    3892:	04 c0       	rjmp	.+8      	; 0x389c <__vector_10+0x11c>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3894:	41 50       	subi	r20, 0x01	; 1
    3896:	51 09       	sbc	r21, r1
    3898:	61 09       	sbc	r22, r1
    389a:	71 09       	sbc	r23, r1
    389c:	40 93 50 05 	sts	0x0550, r20
    38a0:	50 93 51 05 	sts	0x0551, r21
    38a4:	60 93 52 05 	sts	0x0552, r22
    38a8:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    38ac:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    38ae:	11 9a       	sbi	0x02, 1	; 2
    38b0:	37 c1       	rjmp	.+622    	; 0x3b20 <__vector_10+0x3a0>

			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    38b2:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    38b6:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    38ba:	80 91 70 00 	lds	r24, 0x0070
    38be:	8b 7f       	andi	r24, 0xFB	; 251
    38c0:	80 93 70 00 	sts	0x0070, r24

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    38c4:	20 91 54 05 	lds	r18, 0x0554
    38c8:	80 91 50 05 	lds	r24, 0x0550
    38cc:	90 91 51 05 	lds	r25, 0x0551
    38d0:	a0 91 52 05 	lds	r26, 0x0552
    38d4:	b0 91 53 05 	lds	r27, 0x0553
    38d8:	21 30       	cpi	r18, 0x01	; 1
    38da:	99 f4       	brne	.+38     	; 0x3902 <__vector_10+0x182>
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    38dc:	10 92 eb 05 	sts	0x05EB, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    38e0:	80 93 f2 05 	sts	0x05F2, r24
    38e4:	90 93 f3 05 	sts	0x05F3, r25
    38e8:	a0 93 f4 05 	sts	0x05F4, r26
    38ec:	b0 93 f5 05 	sts	0x05F5, r27
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    38f0:	80 93 fa 05 	sts	0x05FA, r24
    38f4:	90 93 fb 05 	sts	0x05FB, r25
    38f8:	a0 93 fc 05 	sts	0x05FC, r26
    38fc:	b0 93 fd 05 	sts	0x05FD, r27
    3900:	0f c1       	rjmp	.+542    	; 0x3b20 <__vector_10+0x3a0>
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    3902:	10 92 0e 06 	sts	0x060E, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3906:	80 93 15 06 	sts	0x0615, r24
    390a:	90 93 16 06 	sts	0x0616, r25
    390e:	a0 93 17 06 	sts	0x0617, r26
    3912:	b0 93 18 06 	sts	0x0618, r27
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3916:	80 93 1d 06 	sts	0x061D, r24
    391a:	90 93 1e 06 	sts	0x061E, r25
    391e:	a0 93 1f 06 	sts	0x061F, r26
    3922:	b0 93 20 06 	sts	0x0620, r27
    3926:	fc c0       	rjmp	.+504    	; 0x3b20 <__vector_10+0x3a0>
			}
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    3928:	82 30       	cpi	r24, 0x02	; 2
    392a:	09 f0       	breq	.+2      	; 0x392e <__vector_10+0x1ae>
    392c:	98 c0       	rjmp	.+304    	; 0x3a5e <__vector_10+0x2de>
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    392e:	80 91 26 01 	lds	r24, 0x0126
    3932:	90 91 27 01 	lds	r25, 0x0127
    3936:	81 15       	cp	r24, r1
    3938:	93 40       	sbci	r25, 0x03	; 3
    393a:	08 f0       	brcs	.+2      	; 0x393e <__vector_10+0x1be>
    393c:	f1 c0       	rjmp	.+482    	; 0x3b20 <__vector_10+0x3a0>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    393e:	80 91 22 01 	lds	r24, 0x0122
    3942:	90 91 23 01 	lds	r25, 0x0123
    3946:	a0 91 24 01 	lds	r26, 0x0124
    394a:	b0 91 25 01 	lds	r27, 0x0125
    394e:	89 2b       	or	r24, r25
    3950:	8a 2b       	or	r24, r26
    3952:	8b 2b       	or	r24, r27
    3954:	09 f4       	brne	.+2      	; 0x3958 <__vector_10+0x1d8>
    3956:	70 c0       	rjmp	.+224    	; 0x3a38 <__vector_10+0x2b8>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    3958:	80 91 50 05 	lds	r24, 0x0550
    395c:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    395e:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    3960:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    3962:	40 91 50 05 	lds	r20, 0x0550
    3966:	50 91 51 05 	lds	r21, 0x0551
    396a:	60 91 52 05 	lds	r22, 0x0552
    396e:	70 91 53 05 	lds	r23, 0x0553
    3972:	bb 27       	eor	r27, r27
    3974:	a7 2f       	mov	r26, r23
    3976:	96 2f       	mov	r25, r22
    3978:	85 2f       	mov	r24, r21
    397a:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    397c:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    397e:	14 98       	cbi	0x02, 4	; 2

				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3980:	cb 01       	movw	r24, r22
    3982:	aa 27       	eor	r26, r26
    3984:	bb 27       	eor	r27, r27
    3986:	87 70       	andi	r24, 0x07	; 7
    3988:	99 27       	eor	r25, r25
    398a:	aa 27       	eor	r26, r26
    398c:	bb 27       	eor	r27, r27
    398e:	88 68       	ori	r24, 0x88	; 136
    3990:	88 b9       	out	0x08, r24	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    3992:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    3994:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    3996:	80 91 54 05 	lds	r24, 0x0554
    399a:	81 30       	cpi	r24, 0x01	; 1
    399c:	29 f4       	brne	.+10     	; 0x39a8 <__vector_10+0x228>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    399e:	4f 5f       	subi	r20, 0xFF	; 255
    39a0:	5f 4f       	sbci	r21, 0xFF	; 255
    39a2:	6f 4f       	sbci	r22, 0xFF	; 255
    39a4:	7f 4f       	sbci	r23, 0xFF	; 255
    39a6:	04 c0       	rjmp	.+8      	; 0x39b0 <__vector_10+0x230>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    39a8:	41 50       	subi	r20, 0x01	; 1
    39aa:	51 09       	sbc	r21, r1
    39ac:	61 09       	sbc	r22, r1
    39ae:	71 09       	sbc	r23, r1
    39b0:	40 93 50 05 	sts	0x0550, r20
    39b4:	50 93 51 05 	sts	0x0551, r21
    39b8:	60 93 52 05 	sts	0x0552, r22
    39bc:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    39c0:	83 b1       	in	r24, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    39c2:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    39c4:	9f ef       	ldi	r25, 0xFF	; 255
    39c6:	94 b9       	out	0x04, r25	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    39c8:	e0 91 28 01 	lds	r30, 0x0128
    39cc:	f0 91 29 01 	lds	r31, 0x0129
    39d0:	e4 5d       	subi	r30, 0xD4	; 212
    39d2:	fe 4f       	sbci	r31, 0xFE	; 254
    39d4:	80 83       	st	Z, r24
				sdFifoWritePointer++;				// Move to next spot in fifo
    39d6:	80 91 28 01 	lds	r24, 0x0128
    39da:	90 91 29 01 	lds	r25, 0x0129
    39de:	01 96       	adiw	r24, 0x01	; 1
    39e0:	90 93 29 01 	sts	0x0129, r25
    39e4:	80 93 28 01 	sts	0x0128, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    39e8:	80 91 28 01 	lds	r24, 0x0128
    39ec:	90 91 29 01 	lds	r25, 0x0129
    39f0:	81 15       	cp	r24, r1
    39f2:	93 40       	sbci	r25, 0x03	; 3
    39f4:	20 f0       	brcs	.+8      	; 0x39fe <__vector_10+0x27e>
				{
					sdFifoWritePointer=0;
    39f6:	10 92 29 01 	sts	0x0129, r1
    39fa:	10 92 28 01 	sts	0x0128, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    39fe:	80 91 26 01 	lds	r24, 0x0126
    3a02:	90 91 27 01 	lds	r25, 0x0127
    3a06:	01 96       	adiw	r24, 0x01	; 1
    3a08:	90 93 27 01 	sts	0x0127, r25
    3a0c:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;		// One less byte in the sample
    3a10:	80 91 22 01 	lds	r24, 0x0122
    3a14:	90 91 23 01 	lds	r25, 0x0123
    3a18:	a0 91 24 01 	lds	r26, 0x0124
    3a1c:	b0 91 25 01 	lds	r27, 0x0125
    3a20:	01 97       	sbiw	r24, 0x01	; 1
    3a22:	a1 09       	sbc	r26, r1
    3a24:	b1 09       	sbc	r27, r1
    3a26:	80 93 22 01 	sts	0x0122, r24
    3a2a:	90 93 23 01 	sts	0x0123, r25
    3a2e:	a0 93 24 01 	sts	0x0124, r26
    3a32:	b0 93 25 01 	sts	0x0125, r27
    3a36:	74 c0       	rjmp	.+232    	; 0x3b20 <__vector_10+0x3a0>

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3a38:	10 92 4f 05 	sts	0x054F, r1
				TCCR2B=0;					// Stop this timer
    3a3c:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3a40:	80 91 70 00 	lds	r24, 0x0070
    3a44:	8b 7f       	andi	r24, 0xFB	; 251
    3a46:	80 93 70 00 	sts	0x0070, r24

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    3a4a:	80 91 54 05 	lds	r24, 0x0554
    3a4e:	81 30       	cpi	r24, 0x01	; 1
    3a50:	19 f4       	brne	.+6      	; 0x3a58 <__vector_10+0x2d8>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    3a52:	10 92 eb 05 	sts	0x05EB, r1
    3a56:	64 c0       	rjmp	.+200    	; 0x3b20 <__vector_10+0x3a0>
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    3a58:	10 92 0e 06 	sts	0x060E, r1
    3a5c:	61 c0       	rjmp	.+194    	; 0x3b20 <__vector_10+0x3a0>
				}
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    3a5e:	83 30       	cpi	r24, 0x03	; 3
    3a60:	09 f0       	breq	.+2      	; 0x3a64 <__vector_10+0x2e4>
    3a62:	5e c0       	rjmp	.+188    	; 0x3b20 <__vector_10+0x3a0>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    3a64:	80 91 22 01 	lds	r24, 0x0122
    3a68:	90 91 23 01 	lds	r25, 0x0123
    3a6c:	a0 91 24 01 	lds	r26, 0x0124
    3a70:	b0 91 25 01 	lds	r27, 0x0125
    3a74:	89 2b       	or	r24, r25
    3a76:	8a 2b       	or	r24, r26
    3a78:	8b 2b       	or	r24, r27
    3a7a:	09 f4       	brne	.+2      	; 0x3a7e <__vector_10+0x2fe>
    3a7c:	46 c0       	rjmp	.+140    	; 0x3b0a <__vector_10+0x38a>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3a7e:	80 91 26 01 	lds	r24, 0x0126
    3a82:	90 91 27 01 	lds	r25, 0x0127
    3a86:	89 2b       	or	r24, r25
    3a88:	09 f4       	brne	.+2      	; 0x3a8c <__vector_10+0x30c>
    3a8a:	4a c0       	rjmp	.+148    	; 0x3b20 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3a8c:	e0 91 2a 01 	lds	r30, 0x012A
    3a90:	f0 91 2b 01 	lds	r31, 0x012B
    3a94:	e4 5d       	subi	r30, 0xD4	; 212
    3a96:	fe 4f       	sbci	r31, 0xFE	; 254
    3a98:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3a9a:	80 91 2a 01 	lds	r24, 0x012A
    3a9e:	90 91 2b 01 	lds	r25, 0x012B
    3aa2:	01 96       	adiw	r24, 0x01	; 1
    3aa4:	90 93 2b 01 	sts	0x012B, r25
    3aa8:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3aac:	80 91 2a 01 	lds	r24, 0x012A
    3ab0:	90 91 2b 01 	lds	r25, 0x012B
    3ab4:	81 15       	cp	r24, r1
    3ab6:	93 40       	sbci	r25, 0x03	; 3
    3ab8:	20 f0       	brcs	.+8      	; 0x3ac2 <__vector_10+0x342>
				{
					sdFifoReadPointer=0;
    3aba:	10 92 2b 01 	sts	0x012B, r1
    3abe:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3ac2:	80 91 26 01 	lds	r24, 0x0126
    3ac6:	90 91 27 01 	lds	r25, 0x0127
    3aca:	01 97       	sbiw	r24, 0x01	; 1
    3acc:	90 93 27 01 	sts	0x0127, r25
    3ad0:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3ad4:	80 91 22 01 	lds	r24, 0x0122
    3ad8:	90 91 23 01 	lds	r25, 0x0123
    3adc:	a0 91 24 01 	lds	r26, 0x0124
    3ae0:	b0 91 25 01 	lds	r27, 0x0125
    3ae4:	01 97       	sbiw	r24, 0x01	; 1
    3ae6:	a1 09       	sbc	r26, r1
    3ae8:	b1 09       	sbc	r27, r1
    3aea:	80 93 22 01 	sts	0x0122, r24
    3aee:	90 93 23 01 	sts	0x0123, r25
    3af2:	a0 93 24 01 	sts	0x0124, r26
    3af6:	b0 93 25 01 	sts	0x0125, r27

				// Now spit the byte out the DAC.

				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine
    3afa:	20 93 55 05 	sts	0x0555, r18
				UpdateOutput();				// Update the DAC
    3afe:	e0 91 e2 05 	lds	r30, 0x05E2
    3b02:	f0 91 e3 05 	lds	r31, 0x05E3
    3b06:	09 95       	icall
    3b08:	0b c0       	rjmp	.+22     	; 0x3b20 <__vector_10+0x3a0>
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3b0a:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    3b0e:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3b12:	80 91 70 00 	lds	r24, 0x0070
    3b16:	8b 7f       	andi	r24, 0xFB	; 251
    3b18:	80 93 70 00 	sts	0x0070, r24

			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    3b1c:	10 92 55 05 	sts	0x0555, r1
		}
	}
}
    3b20:	ff 91       	pop	r31
    3b22:	ef 91       	pop	r30
    3b24:	bf 91       	pop	r27
    3b26:	af 91       	pop	r26
    3b28:	9f 91       	pop	r25
    3b2a:	8f 91       	pop	r24
    3b2c:	7f 91       	pop	r23
    3b2e:	6f 91       	pop	r22
    3b30:	5f 91       	pop	r21
    3b32:	4f 91       	pop	r20
    3b34:	3f 91       	pop	r19
    3b36:	2f 91       	pop	r18
    3b38:	0f 90       	pop	r0
    3b3a:	0f be       	out	0x3f, r0	; 63
    3b3c:	0f 90       	pop	r0
    3b3e:	1f 90       	pop	r1
    3b40:	18 95       	reti

00003b42 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    3b42:	1f 92       	push	r1
    3b44:	0f 92       	push	r0
    3b46:	0f b6       	in	r0, 0x3f	; 63
    3b48:	0f 92       	push	r0
    3b4a:	11 24       	eor	r1, r1
    3b4c:	8f 93       	push	r24
    3b4e:	9f 93       	push	r25
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
    3b50:	90 91 40 04 	lds	r25, 0x0440
    3b54:	80 91 56 05 	lds	r24, 0x0556
    3b58:	89 17       	cp	r24, r25
    3b5a:	18 f4       	brcc	.+6      	; 0x3b62 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    3b5c:	9f ef       	ldi	r25, 0xFF	; 255
    3b5e:	95 b9       	out	0x05, r25	; 5
    3b60:	01 c0       	rjmp	.+2      	; 0x3b64 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    3b62:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    3b64:	8f 5f       	subi	r24, 0xFF	; 255
    3b66:	80 93 56 05 	sts	0x0556, r24
}
    3b6a:	9f 91       	pop	r25
    3b6c:	8f 91       	pop	r24
    3b6e:	0f 90       	pop	r0
    3b70:	0f be       	out	0x3f, r0	; 63
    3b72:	0f 90       	pop	r0
    3b74:	1f 90       	pop	r1
    3b76:	18 95       	reti

00003b78 <__vector_default>:

ISR(__vector_default)
{
    3b78:	1f 92       	push	r1
    3b7a:	0f 92       	push	r0
    3b7c:	0f b6       	in	r0, 0x3f	; 63
    3b7e:	0f 92       	push	r0
    3b80:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	0f 90       	pop	r0
    3b88:	1f 90       	pop	r1
    3b8a:	18 95       	reti

00003b8c <HandleSoftclock>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    3b8c:	a8 9b       	sbis	0x15, 0	; 21
    3b8e:	0a c0       	rjmp	.+20     	; 0x3ba4 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    3b90:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    3b92:	80 91 2c 06 	lds	r24, 0x062C
    3b96:	90 91 2d 06 	lds	r25, 0x062D
    3b9a:	01 96       	adiw	r24, 0x01	; 1
    3b9c:	90 93 2d 06 	sts	0x062D, r25
    3ba0:	80 93 2c 06 	sts	0x062C, r24
    3ba4:	08 95       	ret

00003ba6 <EepromWrite>:
void EepromWrite(unsigned int theAddress, unsigned char theData)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3ba6:	f9 99       	sbic	0x1f, 1	; 31
    3ba8:	fe cf       	rjmp	.-4      	; 0x3ba6 <EepromWrite>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3baa:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3bac:	f8 94       	cli

	EEAR=theAddress;
    3bae:	92 bd       	out	0x22, r25	; 34
    3bb0:	81 bd       	out	0x21, r24	; 33
	EEDR=theData;
    3bb2:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    3bb4:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    3bb6:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    3bb8:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3bba:	12 bc       	out	0x22, r1	; 34
    3bbc:	11 bc       	out	0x21, r1	; 33
    3bbe:	08 95       	ret

00003bc0 <EepromRead>:
unsigned char EepromRead(unsigned char theAddress)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3bc0:	f9 99       	sbic	0x1f, 1	; 31
    3bc2:	fe cf       	rjmp	.-4      	; 0x3bc0 <EepromRead>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3bc4:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3bc6:	f8 94       	cli

	EEAR=theAddress;
    3bc8:	90 e0       	ldi	r25, 0x00	; 0
    3bca:	92 bd       	out	0x22, r25	; 34
    3bcc:	81 bd       	out	0x21, r24	; 33
	EECR|=(1<<EERE);	// Start reading.
    3bce:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    3bd0:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3bd2:	12 bc       	out	0x22, r1	; 34
    3bd4:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    3bd6:	80 b5       	in	r24, 0x20	; 32
}
    3bd8:	08 95       	ret

00003bda <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    3bda:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    3bde:	88 1f       	adc	r24, r24
    3be0:	88 27       	eor	r24, r24
    3be2:	88 1f       	adc	r24, r24
    3be4:	08 95       	ret

00003be6 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3be6:	80 91 c6 00 	lds	r24, 0x00C6
}
    3bea:	08 95       	ret

00003bec <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    3bec:	80 91 64 00 	lds	r24, 0x0064
    3bf0:	8d 7f       	andi	r24, 0xFD	; 253
    3bf2:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    3bf6:	80 91 c0 00 	lds	r24, 0x00C0
    3bfa:	8d 7f       	andi	r24, 0xFD	; 253
    3bfc:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    3c00:	88 e1       	ldi	r24, 0x18	; 24
    3c02:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    3c06:	87 e2       	ldi	r24, 0x27	; 39
    3c08:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    3c0c:	86 e0       	ldi	r24, 0x06	; 6
    3c0e:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    3c12:	80 91 c0 00 	lds	r24, 0x00C0
    3c16:	85 ff       	sbrs	r24, 5
    3c18:	fc cf       	rjmp	.-8      	; 0x3c12 <InitUart0+0x26>
    3c1a:	02 c0       	rjmp	.+4      	; 0x3c20 <InitUart0+0x34>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3c1c:	80 91 c6 00 	lds	r24, 0x00C6
	{
		;
	}

//	Uart0FlushBuffer();						// Get rid of any poo poo hanging out in the input buffer.
	while(Uart0GotByte())
    3c20:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <Uart0GotByte>
    3c24:	81 11       	cpse	r24, r1
    3c26:	fa cf       	rjmp	.-12     	; 0x3c1c <InitUart0+0x30>
	{
		Uart0GetByte();
	}		
}
    3c28:	08 95       	ret

00003c2a <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    3c2a:	90 e0       	ldi	r25, 0x00	; 0
    3c2c:	20 91 2c 06 	lds	r18, 0x062C
    3c30:	30 91 2d 06 	lds	r19, 0x062D
    3c34:	88 0f       	add	r24, r24
    3c36:	99 1f       	adc	r25, r25
    3c38:	fc 01       	movw	r30, r24
    3c3a:	eb 53       	subi	r30, 0x3B	; 59
    3c3c:	fa 4f       	sbci	r31, 0xFA	; 250
    3c3e:	31 83       	std	Z+1, r19	; 0x01
    3c40:	20 83       	st	Z, r18
	delayTime[timerNum]=ticks_to_wait;
    3c42:	fc 01       	movw	r30, r24
    3c44:	e3 53       	subi	r30, 0x33	; 51
    3c46:	fa 4f       	sbci	r31, 0xFA	; 250
    3c48:	71 83       	std	Z+1, r23	; 0x01
    3c4a:	60 83       	st	Z, r22
    3c4c:	08 95       	ret

00003c4e <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    3c4e:	20 91 2c 06 	lds	r18, 0x062C
    3c52:	30 91 2d 06 	lds	r19, 0x062D
    3c56:	90 e0       	ldi	r25, 0x00	; 0
    3c58:	88 0f       	add	r24, r24
    3c5a:	99 1f       	adc	r25, r25
    3c5c:	fc 01       	movw	r30, r24
    3c5e:	eb 53       	subi	r30, 0x3B	; 59
    3c60:	fa 4f       	sbci	r31, 0xFA	; 250
    3c62:	40 81       	ld	r20, Z
    3c64:	51 81       	ldd	r21, Z+1	; 0x01
    3c66:	24 1b       	sub	r18, r20
    3c68:	35 0b       	sbc	r19, r21
    3c6a:	fc 01       	movw	r30, r24
    3c6c:	e3 53       	subi	r30, 0x33	; 51
    3c6e:	fa 4f       	sbci	r31, 0xFA	; 250
    3c70:	81 e0       	ldi	r24, 0x01	; 1
    3c72:	40 81       	ld	r20, Z
    3c74:	51 81       	ldd	r21, Z+1	; 0x01
    3c76:	24 17       	cp	r18, r20
    3c78:	35 07       	cpc	r19, r21
    3c7a:	08 f4       	brcc	.+2      	; 0x3c7e <CheckTimer+0x30>
    3c7c:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    3c7e:	08 95       	ret

00003c80 <PutMidiMessageInIncomingFifo>:
}

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    3c80:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    3c82:	80 91 60 06 	lds	r24, 0x0660
    3c86:	86 30       	cpi	r24, 0x06	; 6
    3c88:	08 f5       	brcc	.+66     	; 0x3ccc <PutMidiMessageInIncomingFifo+0x4c>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    3c8a:	90 91 d9 05 	lds	r25, 0x05D9
    3c8e:	11 96       	adiw	r26, 0x01	; 1
    3c90:	2c 91       	ld	r18, X
    3c92:	11 97       	sbiw	r26, 0x01	; 1
    3c94:	34 e0       	ldi	r19, 0x04	; 4
    3c96:	93 9f       	mul	r25, r19
    3c98:	f0 01       	movw	r30, r0
    3c9a:	11 24       	eor	r1, r1
    3c9c:	e1 5d       	subi	r30, 0xD1	; 209
    3c9e:	f9 4f       	sbci	r31, 0xF9	; 249
    3ca0:	21 83       	std	Z+1, r18	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    3ca2:	12 96       	adiw	r26, 0x02	; 2
    3ca4:	2c 91       	ld	r18, X
    3ca6:	12 97       	sbiw	r26, 0x02	; 2
    3ca8:	22 83       	std	Z+2, r18	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    3caa:	13 96       	adiw	r26, 0x03	; 3
    3cac:	2c 91       	ld	r18, X
    3cae:	13 97       	sbiw	r26, 0x03	; 3
    3cb0:	23 83       	std	Z+3, r18	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    3cb2:	2c 91       	ld	r18, X
    3cb4:	20 83       	st	Z, r18
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3cb6:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3cb8:	96 30       	cpi	r25, 0x06	; 6
    3cba:	18 f4       	brcc	.+6      	; 0x3cc2 <PutMidiMessageInIncomingFifo+0x42>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3cbc:	90 93 d9 05 	sts	0x05D9, r25
    3cc0:	02 c0       	rjmp	.+4      	; 0x3cc6 <PutMidiMessageInIncomingFifo+0x46>
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
    3cc2:	10 92 d9 05 	sts	0x05D9, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    3cc6:	8f 5f       	subi	r24, 0xFF	; 255
    3cc8:	80 93 60 06 	sts	0x0660, r24
    3ccc:	08 95       	ret

00003cce <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    3cce:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    3cd0:	80 91 60 06 	lds	r24, 0x0660
    3cd4:	88 23       	and	r24, r24
    3cd6:	09 f1       	breq	.+66     	; 0x3d1a <GetMidiMessageFromIncomingFifo+0x4c>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3cd8:	90 91 d5 05 	lds	r25, 0x05D5
    3cdc:	24 e0       	ldi	r18, 0x04	; 4
    3cde:	92 9f       	mul	r25, r18
    3ce0:	f0 01       	movw	r30, r0
    3ce2:	11 24       	eor	r1, r1
    3ce4:	e1 5d       	subi	r30, 0xD1	; 209
    3ce6:	f9 4f       	sbci	r31, 0xF9	; 249
    3ce8:	21 81       	ldd	r18, Z+1	; 0x01
    3cea:	11 96       	adiw	r26, 0x01	; 1
    3cec:	2c 93       	st	X, r18
    3cee:	11 97       	sbiw	r26, 0x01	; 1
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    3cf0:	22 81       	ldd	r18, Z+2	; 0x02
    3cf2:	12 96       	adiw	r26, 0x02	; 2
    3cf4:	2c 93       	st	X, r18
    3cf6:	12 97       	sbiw	r26, 0x02	; 2
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    3cf8:	23 81       	ldd	r18, Z+3	; 0x03
    3cfa:	13 96       	adiw	r26, 0x03	; 3
    3cfc:	2c 93       	st	X, r18
    3cfe:	13 97       	sbiw	r26, 0x03	; 3
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    3d00:	20 81       	ld	r18, Z
    3d02:	2c 93       	st	X, r18

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3d04:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3d06:	96 30       	cpi	r25, 0x06	; 6
    3d08:	18 f4       	brcc	.+6      	; 0x3d10 <GetMidiMessageFromIncomingFifo+0x42>
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3d0a:	90 93 d5 05 	sts	0x05D5, r25
    3d0e:	02 c0       	rjmp	.+4      	; 0x3d14 <GetMidiMessageFromIncomingFifo+0x46>
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
    3d10:	10 92 d5 05 	sts	0x05D5, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    3d14:	81 50       	subi	r24, 0x01	; 1
    3d16:	80 93 60 06 	sts	0x0660, r24
    3d1a:	08 95       	ret

00003d1c <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    3d1c:	80 91 61 06 	lds	r24, 0x0661
    3d20:	86 30       	cpi	r24, 0x06	; 6
    3d22:	c8 f4       	brcc	.+50     	; 0x3d56 <PutMidiMessageInOutgoingFifo+0x3a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    3d24:	90 91 d6 05 	lds	r25, 0x05D6
    3d28:	34 e0       	ldi	r19, 0x04	; 4
    3d2a:	93 9f       	mul	r25, r19
    3d2c:	f0 01       	movw	r30, r0
    3d2e:	11 24       	eor	r1, r1
    3d30:	e8 5b       	subi	r30, 0xB8	; 184
    3d32:	f9 4f       	sbci	r31, 0xF9	; 249
    3d34:	61 83       	std	Z+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    3d36:	42 83       	std	Z+2, r20	; 0x02
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    3d38:	23 83       	std	Z+3, r18	; 0x03
    3d3a:	20 91 2e 06 	lds	r18, 0x062E
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    3d3e:	20 83       	st	Z, r18
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3d40:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3d42:	96 30       	cpi	r25, 0x06	; 6
    3d44:	18 f4       	brcc	.+6      	; 0x3d4c <PutMidiMessageInOutgoingFifo+0x30>
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3d46:	90 93 d6 05 	sts	0x05D6, r25
    3d4a:	02 c0       	rjmp	.+4      	; 0x3d50 <PutMidiMessageInOutgoingFifo+0x34>
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
    3d4c:	10 92 d6 05 	sts	0x05D6, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    3d50:	8f 5f       	subi	r24, 0xFF	; 255
    3d52:	80 93 61 06 	sts	0x0661, r24
    3d56:	08 95       	ret

00003d58 <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    3d58:	89 e0       	ldi	r24, 0x09	; 9
    3d5a:	80 93 d7 05 	sts	0x05D7, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    3d5e:	10 92 d8 05 	sts	0x05D8, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    3d62:	10 92 60 06 	sts	0x0660, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    3d66:	10 92 d9 05 	sts	0x05D9, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    3d6a:	10 92 d5 05 	sts	0x05D5, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    3d6e:	10 92 61 06 	sts	0x0661, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    3d72:	10 92 d6 05 	sts	0x05D6, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    3d76:	10 92 da 05 	sts	0x05DA, r1
    3d7a:	08 95       	ret

00003d7c <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    3d7c:	1f 93       	push	r17
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	00 d0       	rcall	.+0      	; 0x3d84 <HandleIncomingMidiByte+0x8>
    3d84:	00 d0       	rcall	.+0      	; 0x3d86 <HandleIncomingMidiByte+0xa>
    3d86:	cd b7       	in	r28, 0x3d	; 61
    3d88:	de b7       	in	r29, 0x3e	; 62
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    3d8a:	87 ff       	sbrs	r24, 7
    3d8c:	2f c0       	rjmp	.+94     	; 0x3dec <HandleIncomingMidiByte+0x70>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    3d8e:	98 2f       	mov	r25, r24
    3d90:	9f 70       	andi	r25, 0x0F	; 15
    3d92:	20 91 2e 06 	lds	r18, 0x062E
    3d96:	92 17       	cp	r25, r18
    3d98:	21 f0       	breq	.+8      	; 0x3da2 <HandleIncomingMidiByte+0x26>
    3d9a:	30 91 47 06 	lds	r19, 0x0647
    3d9e:	93 13       	cpse	r25, r19
    3da0:	9f c0       	rjmp	.+318    	; 0x3ee0 <HandleIncomingMidiByte+0x164>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    3da2:	80 7f       	andi	r24, 0xF0	; 240
    3da4:	80 39       	cpi	r24, 0x90	; 144
    3da6:	19 f4       	brne	.+6      	; 0x3dae <HandleIncomingMidiByte+0x32>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    3da8:	10 92 d7 05 	sts	0x05D7, r1
    3dac:	16 c0       	rjmp	.+44     	; 0x3dda <HandleIncomingMidiByte+0x5e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    3dae:	80 38       	cpi	r24, 0x80	; 128
    3db0:	31 f4       	brne	.+12     	; 0x3dbe <HandleIncomingMidiByte+0x42>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    3db2:	81 e0       	ldi	r24, 0x01	; 1
    3db4:	80 93 d7 05 	sts	0x05D7, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3db8:	92 13       	cpse	r25, r18
    3dba:	15 c0       	rjmp	.+42     	; 0x3de6 <HandleIncomingMidiByte+0x6a>
    3dbc:	10 c0       	rjmp	.+32     	; 0x3dde <HandleIncomingMidiByte+0x62>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    3dbe:	80 3c       	cpi	r24, 0xC0	; 192
    3dc0:	11 f4       	brne	.+4      	; 0x3dc6 <HandleIncomingMidiByte+0x4a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    3dc2:	82 e0       	ldi	r24, 0x02	; 2
    3dc4:	08 c0       	rjmp	.+16     	; 0x3dd6 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    3dc6:	80 3e       	cpi	r24, 0xE0	; 224
    3dc8:	11 f4       	brne	.+4      	; 0x3dce <HandleIncomingMidiByte+0x52>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    3dca:	87 e0       	ldi	r24, 0x07	; 7
    3dcc:	04 c0       	rjmp	.+8      	; 0x3dd6 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    3dce:	80 3b       	cpi	r24, 0xB0	; 176
    3dd0:	09 f0       	breq	.+2      	; 0x3dd4 <HandleIncomingMidiByte+0x58>
    3dd2:	86 c0       	rjmp	.+268    	; 0x3ee0 <HandleIncomingMidiByte+0x164>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    3dd4:	83 e0       	ldi	r24, 0x03	; 3
    3dd6:	80 93 d7 05 	sts	0x05D7, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3dda:	92 13       	cpse	r25, r18
    3ddc:	03 c0       	rjmp	.+6      	; 0x3de4 <HandleIncomingMidiByte+0x68>
				{
					temporaryChannel=BANK_0;
    3dde:	10 92 db 05 	sts	0x05DB, r1
    3de2:	81 c0       	rjmp	.+258    	; 0x3ee6 <HandleIncomingMidiByte+0x16a>
				}
				else
				{
					temporaryChannel=BANK_1;
    3de4:	81 e0       	ldi	r24, 0x01	; 1
    3de6:	80 93 db 05 	sts	0x05DB, r24
    3dea:	7d c0       	rjmp	.+250    	; 0x3ee6 <HandleIncomingMidiByte+0x16a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    3dec:	10 91 d7 05 	lds	r17, 0x05D7
    3df0:	14 30       	cpi	r17, 0x04	; 4
    3df2:	09 f4       	brne	.+2      	; 0x3df6 <HandleIncomingMidiByte+0x7a>
    3df4:	53 c0       	rjmp	.+166    	; 0x3e9c <HandleIncomingMidiByte+0x120>
    3df6:	50 f4       	brcc	.+20     	; 0x3e0c <HandleIncomingMidiByte+0x90>
    3df8:	11 30       	cpi	r17, 0x01	; 1
    3dfa:	a1 f1       	breq	.+104    	; 0x3e64 <HandleIncomingMidiByte+0xe8>
    3dfc:	c0 f0       	brcs	.+48     	; 0x3e2e <HandleIncomingMidiByte+0xb2>
    3dfe:	12 30       	cpi	r17, 0x02	; 2
    3e00:	09 f4       	brne	.+2      	; 0x3e04 <HandleIncomingMidiByte+0x88>
    3e02:	43 c0       	rjmp	.+134    	; 0x3e8a <HandleIncomingMidiByte+0x10e>
    3e04:	13 30       	cpi	r17, 0x03	; 3
    3e06:	09 f0       	breq	.+2      	; 0x3e0a <HandleIncomingMidiByte+0x8e>
    3e08:	6b c0       	rjmp	.+214    	; 0x3ee0 <HandleIncomingMidiByte+0x164>
    3e0a:	44 c0       	rjmp	.+136    	; 0x3e94 <HandleIncomingMidiByte+0x118>
    3e0c:	17 30       	cpi	r17, 0x07	; 7
    3e0e:	09 f4       	brne	.+2      	; 0x3e12 <HandleIncomingMidiByte+0x96>
    3e10:	53 c0       	rjmp	.+166    	; 0x3eb8 <HandleIncomingMidiByte+0x13c>
    3e12:	30 f4       	brcc	.+12     	; 0x3e20 <HandleIncomingMidiByte+0xa4>
    3e14:	15 30       	cpi	r17, 0x05	; 5
    3e16:	79 f0       	breq	.+30     	; 0x3e36 <HandleIncomingMidiByte+0xba>
    3e18:	16 30       	cpi	r17, 0x06	; 6
    3e1a:	09 f0       	breq	.+2      	; 0x3e1e <HandleIncomingMidiByte+0xa2>
    3e1c:	61 c0       	rjmp	.+194    	; 0x3ee0 <HandleIncomingMidiByte+0x164>
    3e1e:	26 c0       	rjmp	.+76     	; 0x3e6c <HandleIncomingMidiByte+0xf0>
    3e20:	18 30       	cpi	r17, 0x08	; 8
    3e22:	09 f4       	brne	.+2      	; 0x3e26 <HandleIncomingMidiByte+0xaa>
    3e24:	4d c0       	rjmp	.+154    	; 0x3ec0 <HandleIncomingMidiByte+0x144>
    3e26:	19 30       	cpi	r17, 0x09	; 9
    3e28:	09 f0       	breq	.+2      	; 0x3e2c <HandleIncomingMidiByte+0xb0>
    3e2a:	5a c0       	rjmp	.+180    	; 0x3ee0 <HandleIncomingMidiByte+0x164>
    3e2c:	5c c0       	rjmp	.+184    	; 0x3ee6 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    3e2e:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    3e32:	85 e0       	ldi	r24, 0x05	; 5
    3e34:	56 c0       	rjmp	.+172    	; 0x3ee2 <HandleIncomingMidiByte+0x166>
    3e36:	90 91 dc 05 	lds	r25, 0x05DC
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    3e3a:	81 11       	cpse	r24, r1
    3e3c:	05 c0       	rjmp	.+10     	; 0x3e48 <HandleIncomingMidiByte+0xcc>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    3e3e:	82 e0       	ldi	r24, 0x02	; 2
    3e40:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    3e42:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    3e44:	1c 82       	std	Y+4, r1	; 0x04
    3e46:	04 c0       	rjmp	.+8      	; 0x3e50 <HandleIncomingMidiByte+0xd4>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    3e48:	21 e0       	ldi	r18, 0x01	; 1
    3e4a:	2a 83       	std	Y+2, r18	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    3e4c:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    3e4e:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    3e50:	80 91 db 05 	lds	r24, 0x05DB
    3e54:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    3e56:	ce 01       	movw	r24, r28
    3e58:	01 96       	adiw	r24, 0x01	; 1
    3e5a:	0e 94 40 1e 	call	0x3c80	; 0x3c80 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    3e5e:	10 92 d7 05 	sts	0x05D7, r1
    3e62:	41 c0       	rjmp	.+130    	; 0x3ee6 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    3e64:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    3e68:	86 e0       	ldi	r24, 0x06	; 6
    3e6a:	3b c0       	rjmp	.+118    	; 0x3ee2 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    3e6c:	92 e0       	ldi	r25, 0x02	; 2
    3e6e:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    3e70:	90 91 dc 05 	lds	r25, 0x05DC
    3e74:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    3e76:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    3e78:	80 91 db 05 	lds	r24, 0x05DB
    3e7c:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    3e7e:	ce 01       	movw	r24, r28
    3e80:	01 96       	adiw	r24, 0x01	; 1
    3e82:	0e 94 40 1e 	call	0x3c80	; 0x3c80 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    3e86:	81 e0       	ldi	r24, 0x01	; 1
    3e88:	2c c0       	rjmp	.+88     	; 0x3ee2 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    3e8a:	93 e0       	ldi	r25, 0x03	; 3
    3e8c:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    3e8e:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    3e90:	1c 82       	std	Y+4, r1	; 0x04
    3e92:	1c c0       	rjmp	.+56     	; 0x3ecc <HandleIncomingMidiByte+0x150>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    3e94:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    3e98:	84 e0       	ldi	r24, 0x04	; 4
    3e9a:	23 c0       	rjmp	.+70     	; 0x3ee2 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    3e9c:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    3e9e:	90 91 dc 05 	lds	r25, 0x05DC
    3ea2:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    3ea4:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    3ea6:	80 91 db 05 	lds	r24, 0x05DB
    3eaa:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    3eac:	ce 01       	movw	r24, r28
    3eae:	01 96       	adiw	r24, 0x01	; 1
    3eb0:	0e 94 40 1e 	call	0x3c80	; 0x3c80 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    3eb4:	83 e0       	ldi	r24, 0x03	; 3
    3eb6:	15 c0       	rjmp	.+42     	; 0x3ee2 <HandleIncomingMidiByte+0x166>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    3eb8:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    3ebc:	88 e0       	ldi	r24, 0x08	; 8
    3ebe:	11 c0       	rjmp	.+34     	; 0x3ee2 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    3ec0:	17 e0       	ldi	r17, 0x07	; 7
    3ec2:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    3ec4:	90 91 dc 05 	lds	r25, 0x05DC
    3ec8:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    3eca:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    3ecc:	80 91 db 05 	lds	r24, 0x05DB
    3ed0:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    3ed2:	ce 01       	movw	r24, r28
    3ed4:	01 96       	adiw	r24, 0x01	; 1
    3ed6:	0e 94 40 1e 	call	0x3c80	; 0x3c80 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    3eda:	10 93 d7 05 	sts	0x05D7, r17
    3ede:	03 c0       	rjmp	.+6      	; 0x3ee6 <HandleIncomingMidiByte+0x16a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    3ee0:	89 e0       	ldi	r24, 0x09	; 9
    3ee2:	80 93 d7 05 	sts	0x05D7, r24
			break;
		}	
	}
}
    3ee6:	0f 90       	pop	r0
    3ee8:	0f 90       	pop	r0
    3eea:	0f 90       	pop	r0
    3eec:	0f 90       	pop	r0
    3eee:	df 91       	pop	r29
    3ef0:	cf 91       	pop	r28
    3ef2:	1f 91       	pop	r17
    3ef4:	08 95       	ret

00003ef6 <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    3ef6:	80 91 61 06 	lds	r24, 0x0661
    3efa:	81 11       	cpse	r24, r1
    3efc:	07 c0       	rjmp	.+14     	; 0x3f0c <MidiTxBufferNotEmpty+0x16>
    3efe:	81 e0       	ldi	r24, 0x01	; 1
    3f00:	90 91 d8 05 	lds	r25, 0x05D8
    3f04:	91 11       	cpse	r25, r1
    3f06:	03 c0       	rjmp	.+6      	; 0x3f0e <MidiTxBufferNotEmpty+0x18>
    3f08:	80 e0       	ldi	r24, 0x00	; 0
    3f0a:	08 95       	ret
	{
		return(true);
    3f0c:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    3f0e:	08 95       	ret

00003f10 <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    3f10:	80 91 d8 05 	lds	r24, 0x05D8
    3f14:	83 30       	cpi	r24, 0x03	; 3
    3f16:	09 f4       	brne	.+2      	; 0x3f1a <PopOutgoingMidiByte+0xa>
    3f18:	87 c0       	rjmp	.+270    	; 0x4028 <PopOutgoingMidiByte+0x118>
    3f1a:	30 f4       	brcc	.+12     	; 0x3f28 <PopOutgoingMidiByte+0x18>
    3f1c:	81 30       	cpi	r24, 0x01	; 1
    3f1e:	09 f4       	brne	.+2      	; 0x3f22 <PopOutgoingMidiByte+0x12>
    3f20:	7b c0       	rjmp	.+246    	; 0x4018 <PopOutgoingMidiByte+0x108>
    3f22:	08 f0       	brcs	.+2      	; 0x3f26 <PopOutgoingMidiByte+0x16>
    3f24:	7b c0       	rjmp	.+246    	; 0x401c <PopOutgoingMidiByte+0x10c>
    3f26:	0c c0       	rjmp	.+24     	; 0x3f40 <PopOutgoingMidiByte+0x30>
    3f28:	85 30       	cpi	r24, 0x05	; 5
    3f2a:	09 f4       	brne	.+2      	; 0x3f2e <PopOutgoingMidiByte+0x1e>
    3f2c:	84 c0       	rjmp	.+264    	; 0x4036 <PopOutgoingMidiByte+0x126>
    3f2e:	08 f4       	brcc	.+2      	; 0x3f32 <PopOutgoingMidiByte+0x22>
    3f30:	7f c0       	rjmp	.+254    	; 0x4030 <PopOutgoingMidiByte+0x120>
    3f32:	86 30       	cpi	r24, 0x06	; 6
    3f34:	09 f4       	brne	.+2      	; 0x3f38 <PopOutgoingMidiByte+0x28>
    3f36:	82 c0       	rjmp	.+260    	; 0x403c <PopOutgoingMidiByte+0x12c>
    3f38:	87 30       	cpi	r24, 0x07	; 7
    3f3a:	09 f0       	breq	.+2      	; 0x3f3e <PopOutgoingMidiByte+0x2e>
    3f3c:	86 c0       	rjmp	.+268    	; 0x404a <PopOutgoingMidiByte+0x13a>
    3f3e:	80 c0       	rjmp	.+256    	; 0x4040 <PopOutgoingMidiByte+0x130>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    3f40:	80 91 61 06 	lds	r24, 0x0661
    3f44:	88 23       	and	r24, r24
    3f46:	f9 f0       	breq	.+62     	; 0x3f86 <PopOutgoingMidiByte+0x76>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3f48:	90 91 da 05 	lds	r25, 0x05DA
    3f4c:	24 e0       	ldi	r18, 0x04	; 4
    3f4e:	92 9f       	mul	r25, r18
    3f50:	f0 01       	movw	r30, r0
    3f52:	11 24       	eor	r1, r1
    3f54:	e8 5b       	subi	r30, 0xB8	; 184
    3f56:	f9 4f       	sbci	r31, 0xF9	; 249
    3f58:	21 81       	ldd	r18, Z+1	; 0x01
    3f5a:	20 93 de 05 	sts	0x05DE, r18
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    3f5e:	22 81       	ldd	r18, Z+2	; 0x02
    3f60:	20 93 df 05 	sts	0x05DF, r18
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    3f64:	23 81       	ldd	r18, Z+3	; 0x03
    3f66:	20 93 e0 05 	sts	0x05E0, r18
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    3f6a:	20 81       	ld	r18, Z
    3f6c:	20 93 dd 05 	sts	0x05DD, r18

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    3f70:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3f72:	96 30       	cpi	r25, 0x06	; 6
    3f74:	18 f4       	brcc	.+6      	; 0x3f7c <PopOutgoingMidiByte+0x6c>
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    3f76:	90 93 da 05 	sts	0x05DA, r25
    3f7a:	02 c0       	rjmp	.+4      	; 0x3f80 <PopOutgoingMidiByte+0x70>
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
    3f7c:	10 92 da 05 	sts	0x05DA, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    3f80:	81 50       	subi	r24, 0x01	; 1
    3f82:	80 93 61 06 	sts	0x0661, r24
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    3f86:	90 91 de 05 	lds	r25, 0x05DE
    3f8a:	92 30       	cpi	r25, 0x02	; 2
    3f8c:	b1 f0       	breq	.+44     	; 0x3fba <PopOutgoingMidiByte+0xaa>
    3f8e:	20 f4       	brcc	.+8      	; 0x3f98 <PopOutgoingMidiByte+0x88>
    3f90:	91 30       	cpi	r25, 0x01	; 1
    3f92:	09 f0       	breq	.+2      	; 0x3f96 <PopOutgoingMidiByte+0x86>
    3f94:	5a c0       	rjmp	.+180    	; 0x404a <PopOutgoingMidiByte+0x13a>
    3f96:	06 c0       	rjmp	.+12     	; 0x3fa4 <PopOutgoingMidiByte+0x94>
    3f98:	93 30       	cpi	r25, 0x03	; 3
    3f9a:	e9 f0       	breq	.+58     	; 0x3fd6 <PopOutgoingMidiByte+0xc6>
    3f9c:	94 30       	cpi	r25, 0x04	; 4
    3f9e:	09 f0       	breq	.+2      	; 0x3fa2 <PopOutgoingMidiByte+0x92>
    3fa0:	54 c0       	rjmp	.+168    	; 0x404a <PopOutgoingMidiByte+0x13a>
    3fa2:	29 c0       	rjmp	.+82     	; 0x3ff6 <PopOutgoingMidiByte+0xe6>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    3fa4:	80 91 dd 05 	lds	r24, 0x05DD
    3fa8:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    3faa:	20 91 e1 05 	lds	r18, 0x05E1
    3fae:	28 13       	cpse	r18, r24
    3fb0:	0f c0       	rjmp	.+30     	; 0x3fd0 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    3fb2:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    3fb6:	93 e0       	ldi	r25, 0x03	; 3
    3fb8:	2c c0       	rjmp	.+88     	; 0x4012 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    3fba:	80 91 dd 05 	lds	r24, 0x05DD
    3fbe:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    3fc0:	20 91 e1 05 	lds	r18, 0x05E1
    3fc4:	28 13       	cpse	r18, r24
    3fc6:	04 c0       	rjmp	.+8      	; 0x3fd0 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    3fc8:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    3fcc:	94 e0       	ldi	r25, 0x04	; 4
    3fce:	21 c0       	rjmp	.+66     	; 0x4012 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    3fd0:	80 93 e1 05 	sts	0x05E1, r24
    3fd4:	1e c0       	rjmp	.+60     	; 0x4012 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    3fd6:	80 91 dd 05 	lds	r24, 0x05DD
    3fda:	80 6c       	ori	r24, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    3fdc:	90 91 e1 05 	lds	r25, 0x05E1
    3fe0:	98 13       	cpse	r25, r24
    3fe2:	05 c0       	rjmp	.+10     	; 0x3fee <PopOutgoingMidiByte+0xde>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    3fe4:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    3fe8:	10 92 d8 05 	sts	0x05D8, r1
    3fec:	08 95       	ret
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    3fee:	80 93 e1 05 	sts	0x05E1, r24
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    3ff2:	95 e0       	ldi	r25, 0x05	; 5
    3ff4:	0e c0       	rjmp	.+28     	; 0x4012 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    3ff6:	80 91 dd 05 	lds	r24, 0x05DD
    3ffa:	80 6b       	ori	r24, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    3ffc:	90 91 e1 05 	lds	r25, 0x05E1
    4000:	98 13       	cpse	r25, r24
    4002:	04 c0       	rjmp	.+8      	; 0x400c <PopOutgoingMidiByte+0xfc>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    4004:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4008:	97 e0       	ldi	r25, 0x07	; 7
    400a:	03 c0       	rjmp	.+6      	; 0x4012 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    400c:	80 93 e1 05 	sts	0x05E1, r24
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    4010:	96 e0       	ldi	r25, 0x06	; 6
    4012:	90 93 d8 05 	sts	0x05D8, r25
    4016:	08 95       	ret
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4018:	83 e0       	ldi	r24, 0x03	; 3
    401a:	01 c0       	rjmp	.+2      	; 0x401e <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    401c:	84 e0       	ldi	r24, 0x04	; 4
    401e:	80 93 d8 05 	sts	0x05D8, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    4022:	80 91 df 05 	lds	r24, 0x05DF
    4026:	08 95       	ret
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4028:	10 92 d8 05 	sts	0x05D8, r1
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
    402c:	80 e4       	ldi	r24, 0x40	; 64
    402e:	08 95       	ret
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4030:	10 92 d8 05 	sts	0x05D8, r1
    4034:	0a c0       	rjmp	.+20     	; 0x404a <PopOutgoingMidiByte+0x13a>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4036:	10 92 d8 05 	sts	0x05D8, r1
    403a:	f3 cf       	rjmp	.-26     	; 0x4022 <PopOutgoingMidiByte+0x112>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    403c:	87 e0       	ldi	r24, 0x07	; 7
    403e:	ef cf       	rjmp	.-34     	; 0x401e <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);								// Return the first data byte.
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4040:	10 92 d8 05 	sts	0x05D8, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    4044:	80 91 e0 05 	lds	r24, 0x05E0
    4048:	08 95       	ret

			}
			break;

			default:
			theByte=0;		// Make compiler happy.
    404a:	80 e0       	ldi	r24, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    404c:	08 95       	ret

0000404e <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    404e:	8a b1       	in	r24, 0x0a	; 10
    4050:	8f 7c       	andi	r24, 0xCF	; 207
    4052:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    4054:	8b b1       	in	r24, 0x0b	; 11
    4056:	80 63       	ori	r24, 0x30	; 48
    4058:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    405a:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    405e:	e4 e6       	ldi	r30, 0x64	; 100
    4060:	f0 e0       	ldi	r31, 0x00	; 0
    4062:	80 81       	ld	r24, Z
    4064:	80 61       	ori	r24, 0x10	; 16
    4066:	80 83       	st	Z, r24
    4068:	08 95       	ret

0000406a <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    406a:	e4 e6       	ldi	r30, 0x64	; 100
    406c:	f0 e0       	ldi	r31, 0x00	; 0
    406e:	80 81       	ld	r24, Z
    4070:	8f 7e       	andi	r24, 0xEF	; 239
    4072:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    4074:	ec ec       	ldi	r30, 0xCC	; 204
    4076:	f0 e0       	ldi	r31, 0x00	; 0
    4078:	11 82       	std	Z+1, r1	; 0x01
    407a:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    407c:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    407e:	80 ec       	ldi	r24, 0xC0	; 192
    4080:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    4084:	88 e1       	ldi	r24, 0x18	; 24
    4086:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    408a:	81 e0       	ldi	r24, 0x01	; 1
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	91 83       	std	Z+1, r25	; 0x01
    4090:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    4092:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS low.
    4094:	5d 9a       	sbi	0x0b, 5	; 11
    4096:	08 95       	ret

00004098 <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    4098:	5d 9a       	sbi	0x0b, 5	; 11
    409a:	08 95       	ret

0000409c <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    409c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    409e:	5d 98       	cbi	0x0b, 5	; 11
    40a0:	08 95       	ret

000040a2 <TransferSdByte>:
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    40a2:	90 91 c8 00 	lds	r25, 0x00C8
    40a6:	95 ff       	sbrs	r25, 5
    40a8:	fc cf       	rjmp	.-8      	; 0x40a2 <TransferSdByte>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    40aa:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    40ae:	80 91 c8 00 	lds	r24, 0x00C8
    40b2:	87 ff       	sbrs	r24, 7
    40b4:	fc cf       	rjmp	.-8      	; 0x40ae <TransferSdByte+0xc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    40b6:	80 91 ce 00 	lds	r24, 0x00CE
}
    40ba:	08 95       	ret

000040bc <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    40bc:	80 91 c8 00 	lds	r24, 0x00C8
    40c0:	80 64       	ori	r24, 0x40	; 64
    40c2:	80 93 c8 00 	sts	0x00C8, r24
	TransferSdByte(0xFF);	
    40c6:	8f ef       	ldi	r24, 0xFF	; 255
    40c8:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    40cc:	80 91 c8 00 	lds	r24, 0x00C8
    40d0:	86 ff       	sbrs	r24, 6
    40d2:	fc cf       	rjmp	.-8      	; 0x40cc <SendDummyByte+0x10>
		;
}
    40d4:	08 95       	ret

000040d6 <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    40d6:	df 92       	push	r13
    40d8:	ef 92       	push	r14
    40da:	ff 92       	push	r15
    40dc:	0f 93       	push	r16
    40de:	1f 93       	push	r17
    40e0:	cf 93       	push	r28
    40e2:	df 93       	push	r29
    40e4:	c8 2f       	mov	r28, r24
    40e6:	04 2f       	mov	r16, r20
    40e8:	f5 2e       	mov	r15, r21
    40ea:	e6 2e       	mov	r14, r22
    40ec:	d7 2e       	mov	r13, r23
	unsigned char
		i,
		response,
		tmpCrc;

	StartSdTransfer();		// Assert CS
    40ee:	0e 94 4e 20 	call	0x409c	; 0x409c <StartSdTransfer>
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.
    40f2:	8f ef       	ldi	r24, 0xFF	; 255
    40f4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    40f8:	c7 ff       	sbrs	r28, 7
    40fa:	31 c0       	rjmp	.+98     	; 0x415e <SendSdCommand+0x88>
	{
		TransferSdByte(0x40|CMD55);		// Put the start and transmission bits on the front of the command index
    40fc:	87 e7       	ldi	r24, 0x77	; 119
    40fe:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4102:	80 e0       	ldi	r24, 0x00	; 0
    4104:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4108:	80 e0       	ldi	r24, 0x00	; 0
    410a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    410e:	80 e0       	ldi	r24, 0x00	; 0
    4110:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		TransferSdByte(0);				// No argument					
    4114:	80 e0       	ldi	r24, 0x00	; 0
    4116:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		TransferSdByte(0x01);			// Send the CRC7 byte (and stop bit)
    411a:	81 e0       	ldi	r24, 0x01	; 1
    411c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4120:	1a e0       	ldi	r17, 0x0A	; 10

		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    4122:	8f ef       	ldi	r24, 0xFF	; 255
    4124:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4128:	d8 2f       	mov	r29, r24
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    412a:	8f 3f       	cpi	r24, 0xFF	; 255
    412c:	11 f4       	brne	.+4      	; 0x4132 <SendSdCommand+0x5c>
    412e:	11 50       	subi	r17, 0x01	; 1
    4130:	c1 f7       	brne	.-16     	; 0x4122 <SendSdCommand+0x4c>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4132:	90 91 c8 00 	lds	r25, 0x00C8
    4136:	90 64       	ori	r25, 0x40	; 64
    4138:	90 93 c8 00 	sts	0x00C8, r25
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
    413c:	8f ef       	ldi	r24, 0xFF	; 255
    413e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4142:	80 91 c8 00 	lds	r24, 0x00C8
    4146:	86 ff       	sbrs	r24, 6
    4148:	fc cf       	rjmp	.-8      	; 0x4142 <SendSdCommand+0x6c>
			;

		if(response>1)				// Something wrong?
    414a:	d2 30       	cpi	r29, 0x02	; 2
    414c:	18 f0       	brcs	.+6      	; 0x4154 <SendSdCommand+0x7e>
		{
			EndSdTransfer();	// Bring CS high
    414e:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
			return(response);	// ACMD preambe returned something weird.  Bail.
    4152:	34 c0       	rjmp	.+104    	; 0x41bc <SendSdCommand+0xe6>
		}

		EndSdTransfer();	// Bring CS high
    4154:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    4158:	cf 77       	andi	r28, 0x7F	; 127
		StartSdTransfer();	// Assert CS
    415a:	0e 94 4e 20 	call	0x409c	; 0x409c <StartSdTransfer>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    415e:	8c 2f       	mov	r24, r28
    4160:	80 64       	ori	r24, 0x40	; 64
    4162:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    4166:	8d 2d       	mov	r24, r13
    4168:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    416c:	8e 2d       	mov	r24, r14
    416e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    4172:	8f 2d       	mov	r24, r15
    4174:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	TransferSdByte((unsigned char)argument);			// LSB of argument
    4178:	80 2f       	mov	r24, r16
    417a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    417e:	cc 23       	and	r28, r28
    4180:	21 f0       	breq	.+8      	; 0x418a <SendSdCommand+0xb4>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    4182:	c8 30       	cpi	r28, 0x08	; 8
    4184:	21 f0       	breq	.+8      	; 0x418e <SendSdCommand+0xb8>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)
    4186:	81 e0       	ldi	r24, 0x01	; 1
    4188:	03 c0       	rjmp	.+6      	; 0x4190 <SendSdCommand+0xba>

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
	{
		tmpCrc=0x95;
    418a:	85 e9       	ldi	r24, 0x95	; 149
    418c:	01 c0       	rjmp	.+2      	; 0x4190 <SendSdCommand+0xba>
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    418e:	87 e8       	ldi	r24, 0x87	; 135
	}
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
    4190:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    4194:	cc 30       	cpi	r28, 0x0C	; 12
    4196:	19 f4       	brne	.+6      	; 0x419e <SendSdCommand+0xc8>
	{
		TransferSdByte(DUMMY_BYTE);		// Skip "stuff byte".
    4198:	8f ef       	ldi	r24, 0xFF	; 255
    419a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    419e:	1a e0       	ldi	r17, 0x0A	; 10
	
	i=10;		// Give the SD card a 10 byte timeout in which to respond.
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    41a0:	8f ef       	ldi	r24, 0xFF	; 255
    41a2:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    41a6:	d8 2f       	mov	r29, r24
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    41a8:	8f 3f       	cpi	r24, 0xFF	; 255
    41aa:	11 f4       	brne	.+4      	; 0x41b0 <SendSdCommand+0xda>
    41ac:	11 50       	subi	r17, 0x01	; 1
    41ae:	c1 f7       	brne	.-16     	; 0x41a0 <SendSdCommand+0xca>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    41b0:	c8 30       	cpi	r28, 0x08	; 8
    41b2:	21 f0       	breq	.+8      	; 0x41bc <SendSdCommand+0xe6>
    41b4:	ca 33       	cpi	r28, 0x3A	; 58
    41b6:	11 f0       	breq	.+4      	; 0x41bc <SendSdCommand+0xe6>
	{
		SendDummyByte();	
    41b8:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    41bc:	8d 2f       	mov	r24, r29
    41be:	df 91       	pop	r29
    41c0:	cf 91       	pop	r28
    41c2:	1f 91       	pop	r17
    41c4:	0f 91       	pop	r16
    41c6:	ff 90       	pop	r15
    41c8:	ef 90       	pop	r14
    41ca:	df 90       	pop	r13
    41cc:	08 95       	ret

000041ce <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    41ce:	ef 92       	push	r14
    41d0:	ff 92       	push	r15
    41d2:	0f 93       	push	r16
    41d4:	1f 93       	push	r17
    41d6:	cf 93       	push	r28
    41d8:	df 93       	push	r29
    41da:	00 d0       	rcall	.+0      	; 0x41dc <SdHandshake+0xe>
    41dc:	00 d0       	rcall	.+0      	; 0x41de <SdHandshake+0x10>
    41de:	1f 92       	push	r1
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
	bool
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
    41e4:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
    41e8:	14 e1       	ldi	r17, 0x14	; 20
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    41ea:	80 91 c8 00 	lds	r24, 0x00C8
    41ee:	80 64       	ori	r24, 0x40	; 64
    41f0:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
    41f4:	8f ef       	ldi	r24, 0xFF	; 255
    41f6:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    41fa:	11 50       	subi	r17, 0x01	; 1
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    41fc:	b1 f7       	brne	.-20     	; 0x41ea <SdHandshake+0x1c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    41fe:	80 91 c8 00 	lds	r24, 0x00C8
    4202:	86 ff       	sbrs	r24, 6
    4204:	fc cf       	rjmp	.-8      	; 0x41fe <SdHandshake+0x30>


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
    4206:	0e 94 4e 20 	call	0x409c	; 0x409c <StartSdTransfer>
    420a:	00 e0       	ldi	r16, 0x00	; 0
    420c:	12 e0       	ldi	r17, 0x02	; 2
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    420e:	80 91 c8 00 	lds	r24, 0x00C8
    4212:	80 64       	ori	r24, 0x40	; 64
    4214:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(0xFF);	
    4218:	8f ef       	ldi	r24, 0xFF	; 255
    421a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    421e:	01 50       	subi	r16, 0x01	; 1
    4220:	11 09       	sbc	r17, r1

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    4222:	a9 f7       	brne	.-22     	; 0x420e <SdHandshake+0x40>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4224:	80 91 c8 00 	lds	r24, 0x00C8
    4228:	86 ff       	sbrs	r24, 6
    422a:	fc cf       	rjmp	.-8      	; 0x4224 <SdHandshake+0x56>
		;
	EndSdTransfer();
    422c:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    4230:	40 e0       	ldi	r20, 0x00	; 0
    4232:	50 e0       	ldi	r21, 0x00	; 0
    4234:	ba 01       	movw	r22, r20
    4236:	80 e0       	ldi	r24, 0x00	; 0
    4238:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    423c:	80 91 c8 00 	lds	r24, 0x00C8
    4240:	86 ff       	sbrs	r24, 6
    4242:	fc cf       	rjmp	.-8      	; 0x423c <SdHandshake+0x6e>
		;
	EndSdTransfer();
    4244:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    4248:	40 e0       	ldi	r20, 0x00	; 0
    424a:	50 e0       	ldi	r21, 0x00	; 0
    424c:	ba 01       	movw	r22, r20
    424e:	80 e0       	ldi	r24, 0x00	; 0
    4250:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    4254:	81 30       	cpi	r24, 0x01	; 1
    4256:	11 f0       	breq	.+4      	; 0x425c <SdHandshake+0x8e>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
    4258:	80 e0       	ldi	r24, 0x00	; 0
    425a:	b1 c0       	rjmp	.+354    	; 0x43be <SdHandshake+0x1f0>
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high
    425c:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    4260:	4a ea       	ldi	r20, 0xAA	; 170
    4262:	51 e0       	ldi	r21, 0x01	; 1
    4264:	60 e0       	ldi	r22, 0x00	; 0
    4266:	70 e0       	ldi	r23, 0x00	; 0
    4268:	88 e0       	ldi	r24, 0x08	; 8
    426a:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    426e:	81 30       	cpi	r24, 0x01	; 1
    4270:	09 f0       	breq	.+2      	; 0x4274 <SdHandshake+0xa6>
    4272:	6e c0       	rjmp	.+220    	; 0x4350 <SdHandshake+0x182>
    4274:	8e 01       	movw	r16, r28
    4276:	0f 5f       	subi	r16, 0xFF	; 255
    4278:	1f 4f       	sbci	r17, 0xFF	; 255
//-----------------------------------------------------------------------
// SD SPI Mode and Initialization Functions
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

bool SdHandshake(void)
    427a:	7e 01       	movw	r14, r28
    427c:	85 e0       	ldi	r24, 0x05	; 5
    427e:	e8 0e       	add	r14, r24
    4280:	f1 1c       	adc	r15, r1

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    4282:	8f ef       	ldi	r24, 0xFF	; 255
    4284:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4288:	f8 01       	movw	r30, r16
    428a:	81 93       	st	Z+, r24
    428c:	8f 01       	movw	r16, r30
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    428e:	ee 15       	cp	r30, r14
    4290:	ff 05       	cpc	r31, r15
    4292:	b9 f7       	brne	.-18     	; 0x4282 <SdHandshake+0xb4>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    4294:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
			EndSdTransfer();		// Bring CS high
    4298:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    429c:	8b 81       	ldd	r24, Y+3	; 0x03
    429e:	81 30       	cpi	r24, 0x01	; 1
    42a0:	d9 f6       	brne	.-74     	; 0x4258 <SdHandshake+0x8a>
    42a2:	8c 81       	ldd	r24, Y+4	; 0x04
    42a4:	8a 3a       	cpi	r24, 0xAA	; 170
    42a6:	c1 f6       	brne	.-80     	; 0x4258 <SdHandshake+0x8a>
			{				
				SetTimer(TIMER_SD,SECOND);
    42a8:	64 ec       	ldi	r22, 0xC4	; 196
    42aa:	74 e0       	ldi	r23, 0x04	; 4
    42ac:	83 e0       	ldi	r24, 0x03	; 3
    42ae:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    42b2:	04 c0       	rjmp	.+8      	; 0x42bc <SdHandshake+0xee>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    42b4:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
    42b8:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    42bc:	83 e0       	ldi	r24, 0x03	; 3
    42be:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    42c2:	88 23       	and	r24, r24
    42c4:	31 f0       	breq	.+12     	; 0x42d2 <SdHandshake+0x104>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    42c6:	83 e0       	ldi	r24, 0x03	; 3
    42c8:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    42cc:	88 23       	and	r24, r24
    42ce:	81 f0       	breq	.+32     	; 0x42f0 <SdHandshake+0x122>
    42d0:	c3 cf       	rjmp	.-122    	; 0x4258 <SdHandshake+0x8a>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    42d2:	40 e0       	ldi	r20, 0x00	; 0
    42d4:	50 e0       	ldi	r21, 0x00	; 0
    42d6:	ba 01       	movw	r22, r20
    42d8:	89 ea       	ldi	r24, 0xA9	; 169
    42da:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    42de:	81 11       	cpse	r24, r1
    42e0:	e9 cf       	rjmp	.-46     	; 0x42b4 <SdHandshake+0xe6>
    42e2:	f1 cf       	rjmp	.-30     	; 0x42c6 <SdHandshake+0xf8>
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    42e4:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    42e8:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <HandleSoftclock>
						EndSdTransfer();		// Bring CS high.
    42ec:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    42f0:	83 e0       	ldi	r24, 0x03	; 3
    42f2:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    42f6:	88 23       	and	r24, r24
    42f8:	31 f0       	breq	.+12     	; 0x4306 <SdHandshake+0x138>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    42fa:	83 e0       	ldi	r24, 0x03	; 3
    42fc:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4300:	88 23       	and	r24, r24
    4302:	51 f0       	breq	.+20     	; 0x4318 <SdHandshake+0x14a>
    4304:	a9 cf       	rjmp	.-174    	; 0x4258 <SdHandshake+0x8a>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4306:	40 e0       	ldi	r20, 0x00	; 0
    4308:	50 e0       	ldi	r21, 0x00	; 0
    430a:	ba 01       	movw	r22, r20
    430c:	8a e3       	ldi	r24, 0x3A	; 58
    430e:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    4312:	81 11       	cpse	r24, r1
    4314:	e7 cf       	rjmp	.-50     	; 0x42e4 <SdHandshake+0x116>
    4316:	f1 cf       	rjmp	.-30     	; 0x42fa <SdHandshake+0x12c>
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    4318:	8f ef       	ldi	r24, 0xFF	; 255
    431a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    431e:	8f ef       	ldi	r24, 0xFF	; 255
    4320:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4324:	8f ef       	ldi	r24, 0xFF	; 255
    4326:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    432a:	8f ef       	ldi	r24, 0xFF	; 255
    432c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    4330:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
						EndSdTransfer();			// Bring CS high.
    4334:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    4338:	40 e0       	ldi	r20, 0x00	; 0
    433a:	52 e0       	ldi	r21, 0x02	; 2
    433c:	60 e0       	ldi	r22, 0x00	; 0
    433e:	70 e0       	ldi	r23, 0x00	; 0
    4340:	80 e1       	ldi	r24, 0x10	; 16
    4342:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
						EndSdTransfer();						// Bring CS high.
    4346:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
						SendDummyByte();						
    434a:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
    434e:	36 c0       	rjmp	.+108    	; 0x43bc <SdHandshake+0x1ee>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    4350:	0e 94 5e 20 	call	0x40bc	; 0x40bc <SendDummyByte>
			EndSdTransfer();					// Bring CS high
    4354:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    4358:	40 e0       	ldi	r20, 0x00	; 0
    435a:	50 e0       	ldi	r21, 0x00	; 0
    435c:	ba 01       	movw	r22, r20
    435e:	89 ea       	ldi	r24, 0xA9	; 169
    4360:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    4364:	82 30       	cpi	r24, 0x02	; 2
    4366:	08 f0       	brcs	.+2      	; 0x436a <SdHandshake+0x19c>
    4368:	77 cf       	rjmp	.-274    	; 0x4258 <SdHandshake+0x8a>
			{
				EndSdTransfer();			// Bring CS high.
    436a:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
				SetTimer(TIMER_SD,SECOND);
    436e:	64 ec       	ldi	r22, 0xC4	; 196
    4370:	74 e0       	ldi	r23, 0x04	; 4
    4372:	83 e0       	ldi	r24, 0x03	; 3
    4374:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4378:	04 c0       	rjmp	.+8      	; 0x4382 <SdHandshake+0x1b4>
				{
					HandleSoftclock();	// Keep the timer timing.
    437a:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <HandleSoftclock>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    437e:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4382:	83 e0       	ldi	r24, 0x03	; 3
    4384:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4388:	88 23       	and	r24, r24
    438a:	31 f0       	breq	.+12     	; 0x4398 <SdHandshake+0x1ca>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    438c:	83 e0       	ldi	r24, 0x03	; 3
    438e:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4392:	81 11       	cpse	r24, r1
    4394:	61 cf       	rjmp	.-318    	; 0x4258 <SdHandshake+0x8a>
    4396:	09 c0       	rjmp	.+18     	; 0x43aa <SdHandshake+0x1dc>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4398:	40 e0       	ldi	r20, 0x00	; 0
    439a:	50 e0       	ldi	r21, 0x00	; 0
    439c:	ba 01       	movw	r22, r20
    439e:	89 ea       	ldi	r24, 0xA9	; 169
    43a0:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    43a4:	81 11       	cpse	r24, r1
    43a6:	e9 cf       	rjmp	.-46     	; 0x437a <SdHandshake+0x1ac>
    43a8:	f1 cf       	rjmp	.-30     	; 0x438c <SdHandshake+0x1be>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    43aa:	40 e0       	ldi	r20, 0x00	; 0
    43ac:	52 e0       	ldi	r21, 0x02	; 2
    43ae:	60 e0       	ldi	r22, 0x00	; 0
    43b0:	70 e0       	ldi	r23, 0x00	; 0
    43b2:	80 e1       	ldi	r24, 0x10	; 16
    43b4:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
					EndSdTransfer();						// Bring CS high.
    43b8:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					cardValid=true;							// SDC v1 card, good to go
    43bc:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}

	EndSdTransfer();	// Bring CS high
    43be:	8d 83       	std	Y+5, r24	; 0x05
    43c0:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    43c4:	8d 81       	ldd	r24, Y+5	; 0x05
    43c6:	0f 90       	pop	r0
    43c8:	0f 90       	pop	r0
    43ca:	0f 90       	pop	r0
    43cc:	0f 90       	pop	r0
    43ce:	0f 90       	pop	r0
    43d0:	df 91       	pop	r29
    43d2:	cf 91       	pop	r28
    43d4:	1f 91       	pop	r17
    43d6:	0f 91       	pop	r16
    43d8:	ff 90       	pop	r15
    43da:	ef 90       	pop	r14
    43dc:	08 95       	ret

000043de <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    43de:	ab 01       	movw	r20, r22
    43e0:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    43e2:	89 e0       	ldi	r24, 0x09	; 9
    43e4:	44 0f       	add	r20, r20
    43e6:	55 1f       	adc	r21, r21
    43e8:	66 1f       	adc	r22, r22
    43ea:	77 1f       	adc	r23, r23
    43ec:	8a 95       	dec	r24
    43ee:	d1 f7       	brne	.-12     	; 0x43e4 <SdBeginSingleBlockRead+0x6>

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    43f0:	81 e1       	ldi	r24, 0x11	; 17
    43f2:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    43f6:	91 e0       	ldi	r25, 0x01	; 1
    43f8:	81 11       	cpse	r24, r1
    43fa:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    43fc:	89 2f       	mov	r24, r25
    43fe:	08 95       	ret

00004400 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    4400:	ab 01       	movw	r20, r22
    4402:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4404:	99 e0       	ldi	r25, 0x09	; 9
    4406:	44 0f       	add	r20, r20
    4408:	55 1f       	adc	r21, r21
    440a:	66 1f       	adc	r22, r22
    440c:	77 1f       	adc	r23, r23
    440e:	9a 95       	dec	r25
    4410:	d1 f7       	brne	.-12     	; 0x4406 <SdBeginSingleBlockWrite+0x6>

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    4412:	88 e1       	ldi	r24, 0x18	; 24
    4414:	0e 94 6b 20 	call	0x40d6	; 0x40d6 <SendSdCommand>
    4418:	91 e0       	ldi	r25, 0x01	; 1
    441a:	81 11       	cpse	r24, r1
    441c:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    441e:	89 2f       	mov	r24, r25
    4420:	08 95       	ret

00004422 <main>:
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    4422:	cf ef       	ldi	r28, 0xFF	; 255
    4424:	c0 93 64 00 	sts	0x0064, r28
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    4428:	85 b7       	in	r24, 0x35	; 53
    442a:	8f 7e       	andi	r24, 0xEF	; 239
    442c:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    442e:	8f ee       	ldi	r24, 0xEF	; 239
    4430:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    4432:	88 e0       	ldi	r24, 0x08	; 8
    4434:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    4436:	80 e8       	ldi	r24, 0x80	; 128
    4438:	8a b9       	out	0x0a, r24	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    443a:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    443c:	96 e0       	ldi	r25, 0x06	; 6
    443e:	92 b9       	out	0x02, r25	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    4440:	9e e3       	ldi	r25, 0x3E	; 62
    4442:	91 b9       	out	0x01, r25	; 1

	DDRB=0xFF;			// Latch port to OP.
    4444:	c4 b9       	out	0x04, r28	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    4446:	85 b9       	out	0x05, r24	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    4448:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    444a:	c4 b9       	out	0x04, r28	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    444c:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    444e:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    4450:	0e 94 35 20 	call	0x406a	; 0x406a <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    4454:	66 e2       	ldi	r22, 0x26	; 38
    4456:	70 e0       	ldi	r23, 0x00	; 0
    4458:	81 e0       	ldi	r24, 0x01	; 1
    445a:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    445e:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    4460:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    4462:	80 b1       	in	r24, 0x00	; 0
    4464:	80 7c       	andi	r24, 0xC0	; 192
    4466:	80 93 7c 05 	sts	0x057C, r24
	encoderValue=0;							// zero our relative position.
    446a:	10 92 6b 05 	sts	0x056B, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    446e:	10 92 5d 05 	sts	0x055D, r1
	ledBlinkMask=0;
    4472:	10 92 7a 05 	sts	0x057A, r1
	WriteLedLatch(0);	// ...send the LED value to the latch.
    4476:	80 e0       	ldi	r24, 0x00	; 0
    4478:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    447c:	0e 94 ac 1e 	call	0x3d58	; 0x3d58 <InitMidi>
	InitUart0();
    4480:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    4484:	80 91 64 00 	lds	r24, 0x0064
    4488:	8e 7f       	andi	r24, 0xFE	; 254
    448a:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    448e:	80 e6       	ldi	r24, 0x60	; 96
    4490:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    4494:	81 e0       	ldi	r24, 0x01	; 1
    4496:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    449a:	85 e9       	ldi	r24, 0x95	; 149
    449c:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    44a0:	80 91 7a 00 	lds	r24, 0x007A
    44a4:	80 64       	ori	r24, 0x40	; 64
    44a6:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    44aa:	80 91 64 00 	lds	r24, 0x0064
    44ae:	8f 7d       	andi	r24, 0xDF	; 223
    44b0:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    44b4:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    44b8:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    44ba:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    44bc:	c5 bb       	out	0x15, r28	; 21
	systemTicks=0;
    44be:	10 92 2d 06 	sts	0x062D, r1
    44c2:	10 92 2c 06 	sts	0x062C, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    44c6:	83 e0       	ldi	r24, 0x03	; 3
    44c8:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    44ca:	80 91 64 00 	lds	r24, 0x0064
    44ce:	87 7f       	andi	r24, 0xF7	; 247
    44d0:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    44d4:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    44d8:	8f ef       	ldi	r24, 0xFF	; 255
    44da:	9f ef       	ldi	r25, 0xFF	; 255
    44dc:	90 93 89 00 	sts	0x0089, r25
    44e0:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    44e4:	90 93 8b 00 	sts	0x008B, r25
    44e8:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    44ec:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    44f0:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    44f4:	10 92 85 00 	sts	0x0085, r1
    44f8:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    44fc:	c6 bb       	out	0x16, r28	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    44fe:	10 92 57 05 	sts	0x0557, r1
	keyState=0;
    4502:	10 92 58 05 	sts	0x0558, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    4506:	10 92 59 05 	sts	0x0559, r1
	cardDetect=false;
    450a:	10 92 5a 05 	sts	0x055A, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    450e:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4510:	8b e7       	ldi	r24, 0x7B	; 123
    4512:	9e e0       	ldi	r25, 0x0E	; 14
    4514:	90 93 e5 05 	sts	0x05E5, r25
    4518:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    451c:	10 92 5b 05 	sts	0x055B, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    4520:	cc 24       	eor	r12, r12
    4522:	ca 94       	dec	r12
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    4524:	ee 24       	eor	r14, r14
    4526:	e3 94       	inc	r14
    4528:	f1 2c       	mov	r15, r1
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    452a:	c0 e0       	ldi	r28, 0x00	; 0
    452c:	d2 e0       	ldi	r29, 0x02	; 2
				TransferSdByte('W');				// Send flag that this is a WTPA card
				TransferSdByte('T');
				TransferSdByte('P');
				TransferSdByte('A');

				bytesLeftInBlock-=4;
    452e:	6c e0       	ldi	r22, 0x0C	; 12
    4530:	36 2e       	mov	r3, r22
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4532:	77 e0       	ldi	r23, 0x07	; 7
    4534:	97 2e       	mov	r9, r23
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
						;

					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    4536:	eb e0       	ldi	r30, 0x0B	; 11
    4538:	8e 2e       	mov	r8, r30

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    453a:	fe e0       	ldi	r31, 0x0E	; 14
    453c:	df 2e       	mov	r13, r31
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    453e:	ad e0       	ldi	r26, 0x0D	; 13
    4540:	ba 2e       	mov	r11, r26
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    4542:	b4 e0       	ldi	r27, 0x04	; 4
    4544:	2b 2e       	mov	r2, r27
				}
				if(theByte==0xFE)	// Got a start token!
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    4546:	1a e0       	ldi	r17, 0x0A	; 10
    4548:	a1 2e       	mov	r10, r17
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    454a:	81 e0       	ldi	r24, 0x01	; 1
    454c:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4550:	88 23       	and	r24, r24
    4552:	d9 f0       	breq	.+54     	; 0x458a <main+0x168>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    4554:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    4556:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    4558:	c5 b8       	out	0x05, r12	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    455a:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    455c:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    455e:	00 00       	nop
		asm volatile("nop"::);
    4560:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    4562:	83 b1       	in	r24, 0x03	; 3
    4564:	80 95       	com	r24
    4566:	80 93 58 05 	sts	0x0558, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    456a:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    456c:	c4 b8       	out	0x04, r12	; 4
		SREG=sreg;					// Stop tying up interrupts
    456e:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    4570:	35 99       	sbic	0x06, 5	; 6
    4572:	04 c0       	rjmp	.+8      	; 0x457c <main+0x15a>
		{
			cardDetect=true;
    4574:	81 e0       	ldi	r24, 0x01	; 1
    4576:	80 93 5a 05 	sts	0x055A, r24
    457a:	02 c0       	rjmp	.+4      	; 0x4580 <main+0x15e>
		}
		else
		{
			cardDetect=false;
    457c:	10 92 5a 05 	sts	0x055A, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
    4580:	66 e2       	ldi	r22, 0x26	; 38
    4582:	70 e0       	ldi	r23, 0x00	; 0
    4584:	81 e0       	ldi	r24, 0x01	; 1
    4586:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    458a:	90 91 58 05 	lds	r25, 0x0558
    458e:	80 91 7d 05 	lds	r24, 0x057D
    4592:	80 95       	com	r24
    4594:	89 23       	and	r24, r25
    4596:	80 93 57 05 	sts	0x0557, r24
	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been held for more than one debounce loop.
    459a:	80 95       	com	r24
    459c:	89 23       	and	r24, r25
    459e:	80 93 6a 05 	sts	0x056A, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    45a2:	90 93 7d 05 	sts	0x057D, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;

	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    45a6:	20 91 2c 06 	lds	r18, 0x062C
    45aa:	30 91 2d 06 	lds	r19, 0x062D
    45ae:	80 91 7e 05 	lds	r24, 0x057E
    45b2:	90 91 7f 05 	lds	r25, 0x057F
    45b6:	28 17       	cp	r18, r24
    45b8:	39 07       	cpc	r19, r25
    45ba:	c9 f1       	breq	.+114    	; 0x462e <main+0x20c>
	{
		lastEncTime=systemTicks;					// update last read time.
    45bc:	80 91 2c 06 	lds	r24, 0x062C
    45c0:	90 91 2d 06 	lds	r25, 0x062D
    45c4:	90 93 7f 05 	sts	0x057F, r25
    45c8:	80 93 7e 05 	sts	0x057E, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    45cc:	80 b1       	in	r24, 0x00	; 0
    45ce:	80 7c       	andi	r24, 0xC0	; 192
    45d0:	80 93 7c 05 	sts	0x057C, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    45d4:	90 91 80 05 	lds	r25, 0x0580
    45d8:	89 17       	cp	r24, r25
    45da:	49 f1       	breq	.+82     	; 0x462e <main+0x20c>
		{
			if(encoderState==ENC_POS_A)
    45dc:	81 11       	cpse	r24, r1
    45de:	06 c0       	rjmp	.+12     	; 0x45ec <main+0x1ca>
			{
				if(lastEncoderState==ENC_POS_D)
    45e0:	90 38       	cpi	r25, 0x80	; 128
    45e2:	09 f4       	brne	.+2      	; 0x45e6 <main+0x1c4>
    45e4:	17 c0       	rjmp	.+46     	; 0x4614 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_B)
    45e6:	90 34       	cpi	r25, 0x40	; 64
    45e8:	01 f5       	brne	.+64     	; 0x462a <main+0x208>
    45ea:	1a c0       	rjmp	.+52     	; 0x4620 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_B)
    45ec:	80 34       	cpi	r24, 0x40	; 64
    45ee:	31 f4       	brne	.+12     	; 0x45fc <main+0x1da>
			{
				if(lastEncoderState==ENC_POS_A)
    45f0:	91 11       	cpse	r25, r1
    45f2:	01 c0       	rjmp	.+2      	; 0x45f6 <main+0x1d4>
    45f4:	0f c0       	rjmp	.+30     	; 0x4614 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_C)
    45f6:	90 3c       	cpi	r25, 0xC0	; 192
    45f8:	c1 f4       	brne	.+48     	; 0x462a <main+0x208>
    45fa:	12 c0       	rjmp	.+36     	; 0x4620 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_C)
    45fc:	80 3c       	cpi	r24, 0xC0	; 192
    45fe:	31 f4       	brne	.+12     	; 0x460c <main+0x1ea>
			{
				if(lastEncoderState==ENC_POS_B)
    4600:	90 34       	cpi	r25, 0x40	; 64
    4602:	09 f4       	brne	.+2      	; 0x4606 <main+0x1e4>
    4604:	07 c0       	rjmp	.+14     	; 0x4614 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_D)
    4606:	90 38       	cpi	r25, 0x80	; 128
    4608:	81 f4       	brne	.+32     	; 0x462a <main+0x208>
    460a:	0a c0       	rjmp	.+20     	; 0x4620 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_D)
    460c:	80 38       	cpi	r24, 0x80	; 128
    460e:	69 f4       	brne	.+26     	; 0x462a <main+0x208>
			{
				if(lastEncoderState==ENC_POS_C)
    4610:	90 3c       	cpi	r25, 0xC0	; 192
    4612:	21 f4       	brne	.+8      	; 0x461c <main+0x1fa>
				{
//					encoderValue++;
					encoderValue--;
    4614:	90 91 6b 05 	lds	r25, 0x056B
    4618:	91 50       	subi	r25, 0x01	; 1
    461a:	05 c0       	rjmp	.+10     	; 0x4626 <main+0x204>
				}
				else if(lastEncoderState==ENC_POS_A)
    461c:	91 11       	cpse	r25, r1
    461e:	05 c0       	rjmp	.+10     	; 0x462a <main+0x208>
				{
//					encoderValue--;
					encoderValue++;
    4620:	90 91 6b 05 	lds	r25, 0x056B
    4624:	9f 5f       	subi	r25, 0xFF	; 255
    4626:	90 93 6b 05 	sts	0x056B, r25
				}
			}

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    462a:	80 93 80 05 	sts	0x0580, r24

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    462e:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    4632:	80 91 7a 05 	lds	r24, 0x057A
    4636:	88 23       	and	r24, r24
    4638:	e1 f1       	breq	.+120    	; 0x46b2 <main+0x290>
    463a:	82 e0       	ldi	r24, 0x02	; 2
    463c:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4640:	88 23       	and	r24, r24
    4642:	b9 f1       	breq	.+110    	; 0x46b2 <main+0x290>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    4644:	20 91 7a 05 	lds	r18, 0x057A
    4648:	30 e0       	ldi	r19, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    464a:	f0 91 81 05 	lds	r31, 0x0581
    464e:	e0 91 5d 05 	lds	r30, 0x055D
    4652:	80 e0       	ldi	r24, 0x00	; 0
    4654:	90 e0       	ldi	r25, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    4656:	b9 01       	movw	r22, r18
    4658:	08 2e       	mov	r0, r24
    465a:	02 c0       	rjmp	.+4      	; 0x4660 <main+0x23e>
    465c:	75 95       	asr	r23
    465e:	67 95       	ror	r22
    4660:	0a 94       	dec	r0
    4662:	e2 f7       	brpl	.-8      	; 0x465c <main+0x23a>
    4664:	60 ff       	sbrs	r22, 0
    4666:	0e c0       	rjmp	.+28     	; 0x4684 <main+0x262>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    4668:	b7 01       	movw	r22, r14
    466a:	08 2e       	mov	r0, r24
    466c:	02 c0       	rjmp	.+4      	; 0x4672 <main+0x250>
    466e:	66 0f       	add	r22, r22
    4670:	77 1f       	adc	r23, r23
    4672:	0a 94       	dec	r0
    4674:	e2 f7       	brpl	.-8      	; 0x466e <main+0x24c>
    4676:	ab 01       	movw	r20, r22
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    4678:	ff 23       	and	r31, r31
    467a:	11 f0       	breq	.+4      	; 0x4680 <main+0x25e>
				{
					ledOnOffMask|=(1<<i);
    467c:	e6 2b       	or	r30, r22
    467e:	02 c0       	rjmp	.+4      	; 0x4684 <main+0x262>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    4680:	40 95       	com	r20
    4682:	e4 23       	and	r30, r20
    4684:	01 96       	adiw	r24, 0x01	; 1
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    4686:	88 30       	cpi	r24, 0x08	; 8
    4688:	91 05       	cpc	r25, r1
    468a:	29 f7       	brne	.-54     	; 0x4656 <main+0x234>
    468c:	e0 93 5d 05 	sts	0x055D, r30
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    4690:	81 e0       	ldi	r24, 0x01	; 1
    4692:	90 91 81 05 	lds	r25, 0x0581
    4696:	91 11       	cpse	r25, r1
    4698:	80 e0       	ldi	r24, 0x00	; 0
    469a:	80 93 81 05 	sts	0x0581, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    469e:	68 e9       	ldi	r22, 0x98	; 152
    46a0:	70 e0       	ldi	r23, 0x00	; 0
    46a2:	82 e0       	ldi	r24, 0x02	; 2
    46a4:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    46a8:	80 91 5d 05 	lds	r24, 0x055D
    46ac:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
    46b0:	0b c0       	rjmp	.+22     	; 0x46c8 <main+0x2a6>
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    46b2:	10 91 5d 05 	lds	r17, 0x055D
    46b6:	80 91 82 05 	lds	r24, 0x0582
    46ba:	81 17       	cp	r24, r17
    46bc:	29 f0       	breq	.+10     	; 0x46c8 <main+0x2a6>
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
    46be:	81 2f       	mov	r24, r17
    46c0:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    46c4:	10 93 82 05 	sts	0x0582, r17
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    46c8:	90 91 5a 05 	lds	r25, 0x055A
    46cc:	80 91 59 05 	lds	r24, 0x0559
    46d0:	91 11       	cpse	r25, r1
    46d2:	04 c0       	rjmp	.+8      	; 0x46dc <main+0x2ba>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    46d4:	88 23       	and	r24, r24
    46d6:	09 f4       	brne	.+2      	; 0x46da <main+0x2b8>
    46d8:	b5 c4       	rjmp	.+2410   	; 0x5044 <main+0xc22>
    46da:	ea c4       	rjmp	.+2516   	; 0x50b0 <main+0xc8e>
			cardState=SD_NOT_PRESENT;		// Mark the card as st elsewhere
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    46dc:	86 30       	cpi	r24, 0x06	; 6
    46de:	09 f4       	brne	.+2      	; 0x46e2 <main+0x2c0>
    46e0:	4b c2       	rjmp	.+1174   	; 0x4b78 <main+0x756>
    46e2:	80 f4       	brcc	.+32     	; 0x4704 <main+0x2e2>
    46e4:	82 30       	cpi	r24, 0x02	; 2
    46e6:	09 f4       	brne	.+2      	; 0x46ea <main+0x2c8>
    46e8:	d3 c0       	rjmp	.+422    	; 0x4890 <main+0x46e>
    46ea:	30 f4       	brcc	.+12     	; 0x46f8 <main+0x2d6>
    46ec:	88 23       	and	r24, r24
    46ee:	e9 f0       	breq	.+58     	; 0x472a <main+0x308>
    46f0:	81 30       	cpi	r24, 0x01	; 1
    46f2:	09 f0       	breq	.+2      	; 0x46f6 <main+0x2d4>
    46f4:	a7 c4       	rjmp	.+2382   	; 0x5044 <main+0xc22>
    46f6:	22 c0       	rjmp	.+68     	; 0x473c <main+0x31a>
    46f8:	84 30       	cpi	r24, 0x04	; 4
    46fa:	09 f4       	brne	.+2      	; 0x46fe <main+0x2dc>
    46fc:	b8 c1       	rjmp	.+880    	; 0x4a6e <main+0x64c>
    46fe:	08 f0       	brcs	.+2      	; 0x4702 <main+0x2e0>
    4700:	f2 c1       	rjmp	.+996    	; 0x4ae6 <main+0x6c4>
    4702:	32 c1       	rjmp	.+612    	; 0x4968 <main+0x546>
    4704:	8a 30       	cpi	r24, 0x0A	; 10
    4706:	09 f4       	brne	.+2      	; 0x470a <main+0x2e8>
    4708:	59 c3       	rjmp	.+1714   	; 0x4dbc <main+0x99a>
    470a:	30 f4       	brcc	.+12     	; 0x4718 <main+0x2f6>
    470c:	88 30       	cpi	r24, 0x08	; 8
    470e:	09 f4       	brne	.+2      	; 0x4712 <main+0x2f0>
    4710:	be c2       	rjmp	.+1404   	; 0x4c8e <main+0x86c>
    4712:	08 f0       	brcs	.+2      	; 0x4716 <main+0x2f4>
    4714:	d0 c2       	rjmp	.+1440   	; 0x4cb6 <main+0x894>
    4716:	81 c2       	rjmp	.+1282   	; 0x4c1a <main+0x7f8>
    4718:	8c 30       	cpi	r24, 0x0C	; 12
    471a:	09 f4       	brne	.+2      	; 0x471e <main+0x2fc>
    471c:	2e c4       	rjmp	.+2140   	; 0x4f7a <main+0xb58>
    471e:	08 f4       	brcc	.+2      	; 0x4722 <main+0x300>
    4720:	e2 c3       	rjmp	.+1988   	; 0x4ee6 <main+0xac4>
    4722:	8d 30       	cpi	r24, 0x0D	; 13
    4724:	09 f0       	breq	.+2      	; 0x4728 <main+0x306>
    4726:	8e c4       	rjmp	.+2332   	; 0x5044 <main+0xc22>
    4728:	49 c4       	rjmp	.+2194   	; 0x4fbc <main+0xb9a>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    472a:	81 e0       	ldi	r24, 0x01	; 1
    472c:	80 93 59 05 	sts	0x0559, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    4730:	64 ec       	ldi	r22, 0xC4	; 196
    4732:	74 e0       	ldi	r23, 0x04	; 4
    4734:	83 e0       	ldi	r24, 0x03	; 3
    4736:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
    473a:	84 c4       	rjmp	.+2312   	; 0x5044 <main+0xc22>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    473c:	83 e0       	ldi	r24, 0x03	; 3
    473e:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4742:	88 23       	and	r24, r24
    4744:	09 f4       	brne	.+2      	; 0x4748 <main+0x326>
    4746:	7e c4       	rjmp	.+2300   	; 0x5044 <main+0xc22>
			{
				sdPlaybackQueued=false;
    4748:	10 92 79 05 	sts	0x0579, r1
				sdAbortRead=false;
    474c:	10 92 76 05 	sts	0x0576, r1

				if(SdHandshake()==true)	// Give it a shot...
    4750:	0e 94 e7 20 	call	0x41ce	; 0x41ce <SdHandshake>
    4754:	81 30       	cpi	r24, 0x01	; 1
    4756:	09 f0       	breq	.+2      	; 0x475a <main+0x338>
    4758:	99 c0       	rjmp	.+306    	; 0x488c <main+0x46a>
	// Are the first 4 chars WTPA?
	// Stop reading, return true or false based on answer.

	filesystemGood=true;					// Start assuming a good filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    475a:	60 e0       	ldi	r22, 0x00	; 0
    475c:	70 e0       	ldi	r23, 0x00	; 0
    475e:	cb 01       	movw	r24, r22
    4760:	0e 94 ef 21 	call	0x43de	; 0x43de <SdBeginSingleBlockRead>
    4764:	81 30       	cpi	r24, 0x01	; 1
    4766:	09 f0       	breq	.+2      	; 0x476a <main+0x348>
    4768:	58 c0       	rjmp	.+176    	; 0x481a <main+0x3f8>
 		// Tue Jun 21 17:11:28 EDT 2011
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    476a:	6a e7       	ldi	r22, 0x7A	; 122
    476c:	70 e0       	ldi	r23, 0x00	; 0
    476e:	83 e0       	ldi	r24, 0x03	; 3
    4770:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
    4774:	02 c0       	rjmp	.+4      	; 0x477a <main+0x358>

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    4776:	0e 94 c6 1d 	call	0x3b8c	; 0x3b8c <HandleSoftclock>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    477a:	83 e0       	ldi	r24, 0x03	; 3
    477c:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4780:	88 23       	and	r24, r24
    4782:	51 f0       	breq	.+20     	; 0x4798 <main+0x376>
		{
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
    4784:	8f ef       	ldi	r24, 0xFF	; 255
    4786:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    478a:	18 2f       	mov	r17, r24
		if(theByte!='W')
		{
			filesystemGood=false;
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    478c:	8f ef       	ldi	r24, 0xFF	; 255
    478e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		if(theByte!='T')
    4792:	84 35       	cpi	r24, 0x54	; 84
    4794:	59 f4       	brne	.+22     	; 0x47ac <main+0x38a>
    4796:	06 c0       	rjmp	.+12     	; 0x47a4 <main+0x382>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    4798:	8f ef       	ldi	r24, 0xFF	; 255
    479a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    479e:	8e 3f       	cpi	r24, 0xFE	; 254
    47a0:	51 f7       	brne	.-44     	; 0x4776 <main+0x354>
    47a2:	f0 cf       	rjmp	.-32     	; 0x4784 <main+0x362>
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
		if(theByte!='W')
    47a4:	66 24       	eor	r6, r6
    47a6:	63 94       	inc	r6
    47a8:	17 35       	cpi	r17, 0x57	; 87
    47aa:	09 f0       	breq	.+2      	; 0x47ae <main+0x38c>
		}

		theByte=TransferSdByte(DUMMY_BYTE);
		if(theByte!='T')
		{
			filesystemGood=false;
    47ac:	61 2c       	mov	r6, r1
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    47ae:	8f ef       	ldi	r24, 0xFF	; 255
    47b0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		if(theByte!='P')
    47b4:	80 35       	cpi	r24, 0x50	; 80
    47b6:	09 f0       	breq	.+2      	; 0x47ba <main+0x398>
		{
			filesystemGood=false;
    47b8:	61 2c       	mov	r6, r1
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    47ba:	8f ef       	ldi	r24, 0xFF	; 255
    47bc:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
		if(theByte!='A')
    47c0:	81 34       	cpi	r24, 0x41	; 65
    47c2:	09 f0       	breq	.+2      	; 0x47c6 <main+0x3a4>
		{
			filesystemGood=false;
    47c4:	61 2c       	mov	r6, r1
    47c6:	0c e0       	ldi	r16, 0x0C	; 12
    47c8:	10 e0       	ldi	r17, 0x00	; 0
// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
    47ca:	8f ef       	ldi	r24, 0xFF	; 255
    47cc:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    47d0:	01 50       	subi	r16, 0x01	; 1
    47d2:	11 09       	sbc	r17, r1
		}

// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
    47d4:	d1 f7       	brne	.-12     	; 0x47ca <main+0x3a8>
		{
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
    47d6:	71 e0       	ldi	r23, 0x01	; 1
    47d8:	67 12       	cpse	r6, r23
    47da:	0f c0       	rjmp	.+30     	; 0x47fa <main+0x3d8>
    47dc:	05 e8       	ldi	r16, 0x85	; 133
    47de:	15 e0       	ldi	r17, 0x05	; 5
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    47e0:	8f ef       	ldi	r24, 0xFF	; 255
    47e2:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    47e6:	f8 01       	movw	r30, r16
    47e8:	81 93       	st	Z+, r24
    47ea:	8f 01       	movw	r16, r30
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    47ec:	f5 e0       	ldi	r31, 0x05	; 5
    47ee:	05 3c       	cpi	r16, 0xC5	; 197
    47f0:	1f 07       	cpc	r17, r31
    47f2:	b1 f7       	brne	.-20     	; 0x47e0 <main+0x3be>
		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
    47f4:	02 eb       	ldi	r16, 0xB2	; 178
    47f6:	11 e0       	ldi	r17, 0x01	; 1
    47f8:	09 c0       	rjmp	.+18     	; 0x480c <main+0x3ea>
    47fa:	00 e4       	ldi	r16, 0x40	; 64
    47fc:	10 e0       	ldi	r17, 0x00	; 0
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    47fe:	8f ef       	ldi	r24, 0xFF	; 255
    4800:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4804:	01 50       	subi	r16, 0x01	; 1
    4806:	11 09       	sbc	r17, r1
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    4808:	d1 f7       	brne	.-12     	; 0x47fe <main+0x3dc>
    480a:	f4 cf       	rjmp	.-24     	; 0x47f4 <main+0x3d2>
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    480c:	8f ef       	ldi	r24, 0xFF	; 255
    480e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4812:	01 50       	subi	r16, 0x01	; 1
    4814:	11 09       	sbc	r17, r1
			{
				TransferSdByte(0xFF);
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    4816:	d1 f7       	brne	.-12     	; 0x480c <main+0x3ea>
    4818:	01 c0       	rjmp	.+2      	; 0x481c <main+0x3fa>
			TransferSdByte(0xFF);
		}
	}
	else
	{
		filesystemGood=false;	// Error issuing read command
    481a:	61 2c       	mov	r6, r1
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    481c:	80 91 c8 00 	lds	r24, 0x00C8
    4820:	86 ff       	sbrs	r24, 6
    4822:	fc cf       	rjmp	.-8      	; 0x481c <main+0x3fa>
		;

	EndSdTransfer();				// Bring CS high
    4824:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    4828:	8f ef       	ldi	r24, 0xFF	; 255
    482a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				sdPlaybackQueued=false;
				sdAbortRead=false;

				if(SdHandshake()==true)	// Give it a shot...
				{
					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct filesystem, and if so, get the TOC as well.
    482e:	21 e0       	ldi	r18, 0x01	; 1
    4830:	62 12       	cpse	r6, r18
    4832:	19 c0       	rjmp	.+50     	; 0x4866 <main+0x444>
					{
						cardState=SD_IDLE;		// Card is legit and ready to go.
    4834:	d0 92 59 05 	sts	0x0559, r13
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    4838:	80 91 64 00 	lds	r24, 0x0064
    483c:	8f 7b       	andi	r24, 0xBF	; 191
    483e:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    4842:	82 e0       	ldi	r24, 0x02	; 2
    4844:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    4848:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    484c:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    4850:	81 e7       	ldi	r24, 0x71	; 113
    4852:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    4856:	c7 ba       	out	0x17, r12	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    4858:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    485c:	10 92 4f 05 	sts	0x054F, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    4860:	10 92 55 05 	sts	0x0555, r1
    4864:	ef c3       	rjmp	.+2014   	; 0x5044 <main+0xc22>
						cardState=SD_IDLE;		// Card is legit and ready to go.
						InitSdIsr();			// Enable the timers necessary to give the SD card its own IRQ
					}
					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    4866:	8f e0       	ldi	r24, 0x0F	; 15
    4868:	80 93 59 05 	sts	0x0559, r24
    486c:	e5 e8       	ldi	r30, 0x85	; 133
    486e:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    4870:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    4872:	35 e0       	ldi	r19, 0x05	; 5
    4874:	e5 3c       	cpi	r30, 0xC5	; 197
    4876:	f3 07       	cpc	r31, r19
    4878:	d9 f7       	brne	.-10     	; 0x4870 <main+0x44e>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    487a:	88 ed       	ldi	r24, 0xD8	; 216
    487c:	90 e1       	ldi	r25, 0x10	; 16
    487e:	90 93 e5 05 	sts	0x05E5, r25
    4882:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    4886:	10 92 5b 05 	sts	0x055B, r1
    488a:	dc c3       	rjmp	.+1976   	; 0x5044 <main+0xc22>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    488c:	8f e0       	ldi	r24, 0x0F	; 15
    488e:	fc c1       	rjmp	.+1016   	; 0x4c88 <main+0x866>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    4890:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4892:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    4894:	80 91 26 01 	lds	r24, 0x0126
    4898:	90 91 27 01 	lds	r25, 0x0127
    489c:	81 15       	cp	r24, r1
    489e:	92 40       	sbci	r25, 0x02	; 2
    48a0:	a0 f4       	brcc	.+40     	; 0x48ca <main+0x4a8>
    48a2:	80 91 26 01 	lds	r24, 0x0126
    48a6:	90 91 27 01 	lds	r25, 0x0127
    48aa:	40 91 1e 01 	lds	r20, 0x011E
    48ae:	50 91 1f 01 	lds	r21, 0x011F
    48b2:	60 91 20 01 	lds	r22, 0x0120
    48b6:	70 91 21 01 	lds	r23, 0x0121
    48ba:	a0 e0       	ldi	r26, 0x00	; 0
    48bc:	b0 e0       	ldi	r27, 0x00	; 0
    48be:	84 17       	cp	r24, r20
    48c0:	95 07       	cpc	r25, r21
    48c2:	a6 07       	cpc	r26, r22
    48c4:	b7 07       	cpc	r27, r23
    48c6:	08 f4       	brcc	.+2      	; 0x48ca <main+0x4a8>
    48c8:	55 c1       	rjmp	.+682    	; 0x4b74 <main+0x752>
			{
				SREG=sreg;	// Done reading ISR variables.
    48ca:	2f bf       	out	0x3f, r18	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    48cc:	60 91 70 05 	lds	r22, 0x0570
    48d0:	70 91 71 05 	lds	r23, 0x0571
    48d4:	80 91 72 05 	lds	r24, 0x0572
    48d8:	90 91 73 05 	lds	r25, 0x0573
    48dc:	0e 94 00 22 	call	0x4400	; 0x4400 <SdBeginSingleBlockWrite>
    48e0:	81 30       	cpi	r24, 0x01	; 1
    48e2:	09 f0       	breq	.+2      	; 0x48e6 <main+0x4c4>
    48e4:	e5 c3       	rjmp	.+1994   	; 0x50b0 <main+0xc8e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    48e6:	d0 93 84 05 	sts	0x0584, r29
    48ea:	c0 93 83 05 	sts	0x0583, r28

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    48ee:	8f ef       	ldi	r24, 0xFF	; 255
    48f0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    48f4:	8f ef       	ldi	r24, 0xFF	; 255
    48f6:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    48fa:	8e ef       	ldi	r24, 0xFE	; 254
    48fc:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    4900:	80 91 1e 01 	lds	r24, 0x011E
    4904:	90 91 1f 01 	lds	r25, 0x011F
    4908:	a0 91 20 01 	lds	r26, 0x0120
    490c:	b0 91 21 01 	lds	r27, 0x0121
    4910:	8b 2f       	mov	r24, r27
    4912:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    4916:	60 91 1e 01 	lds	r22, 0x011E
    491a:	70 91 1f 01 	lds	r23, 0x011F
    491e:	80 91 20 01 	lds	r24, 0x0120
    4922:	90 91 21 01 	lds	r25, 0x0121
    4926:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    492a:	80 91 1e 01 	lds	r24, 0x011E
    492e:	90 91 1f 01 	lds	r25, 0x011F
    4932:	a0 91 20 01 	lds	r26, 0x0120
    4936:	b0 91 21 01 	lds	r27, 0x0121
    493a:	89 2f       	mov	r24, r25
    493c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    4940:	80 91 1e 01 	lds	r24, 0x011E
    4944:	90 91 1f 01 	lds	r25, 0x011F
    4948:	a0 91 20 01 	lds	r26, 0x0120
    494c:	b0 91 21 01 	lds	r27, 0x0121
    4950:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    4954:	80 91 83 05 	lds	r24, 0x0583
    4958:	90 91 84 05 	lds	r25, 0x0584
    495c:	04 97       	sbiw	r24, 0x04	; 4
    495e:	90 93 84 05 	sts	0x0584, r25
    4962:	80 93 83 05 	sts	0x0583, r24
    4966:	04 c1       	rjmp	.+520    	; 0x4b70 <main+0x74e>
    4968:	00 91 83 05 	lds	r16, 0x0583
    496c:	10 91 84 05 	lds	r17, 0x0584
    4970:	01 34       	cpi	r16, 0x41	; 65
    4972:	11 05       	cpc	r17, r1
    4974:	10 f0       	brcs	.+4      	; 0x497a <main+0x558>
    4976:	00 e4       	ldi	r16, 0x40	; 64
    4978:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    497a:	61 2c       	mov	r6, r1
    497c:	56 c0       	rjmp	.+172    	; 0x4a2a <main+0x608>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    497e:	80 91 1e 01 	lds	r24, 0x011E
    4982:	90 91 1f 01 	lds	r25, 0x011F
    4986:	a0 91 20 01 	lds	r26, 0x0120
    498a:	b0 91 21 01 	lds	r27, 0x0121
    498e:	89 2b       	or	r24, r25
    4990:	8a 2b       	or	r24, r26
    4992:	8b 2b       	or	r24, r27
    4994:	e9 f1       	breq	.+122    	; 0x4a10 <main+0x5ee>
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
    4996:	e0 91 2a 01 	lds	r30, 0x012A
    499a:	f0 91 2b 01 	lds	r31, 0x012B
    499e:	e4 5d       	subi	r30, 0xD4	; 212
    49a0:	fe 4f       	sbci	r31, 0xFE	; 254
    49a2:	80 81       	ld	r24, Z
    49a4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    49a8:	80 91 1e 01 	lds	r24, 0x011E
    49ac:	90 91 1f 01 	lds	r25, 0x011F
    49b0:	a0 91 20 01 	lds	r26, 0x0120
    49b4:	b0 91 21 01 	lds	r27, 0x0121
    49b8:	01 97       	sbiw	r24, 0x01	; 1
    49ba:	a1 09       	sbc	r26, r1
    49bc:	b1 09       	sbc	r27, r1
    49be:	80 93 1e 01 	sts	0x011E, r24
    49c2:	90 93 1f 01 	sts	0x011F, r25
    49c6:	a0 93 20 01 	sts	0x0120, r26
    49ca:	b0 93 21 01 	sts	0x0121, r27

					sdFifoReadPointer++;			// Move to next spot in fifo
    49ce:	80 91 2a 01 	lds	r24, 0x012A
    49d2:	90 91 2b 01 	lds	r25, 0x012B
    49d6:	01 96       	adiw	r24, 0x01	; 1
    49d8:	90 93 2b 01 	sts	0x012B, r25
    49dc:	80 93 2a 01 	sts	0x012A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    49e0:	80 91 2a 01 	lds	r24, 0x012A
    49e4:	90 91 2b 01 	lds	r25, 0x012B
    49e8:	81 15       	cp	r24, r1
    49ea:	93 40       	sbci	r25, 0x03	; 3
    49ec:	20 f0       	brcs	.+8      	; 0x49f6 <main+0x5d4>
					{
						sdFifoReadPointer=0;
    49ee:	10 92 2b 01 	sts	0x012B, r1
    49f2:	10 92 2a 01 	sts	0x012A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    49f6:	2f b7       	in	r18, 0x3f	; 63
					cli();
    49f8:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    49fa:	80 91 26 01 	lds	r24, 0x0126
    49fe:	90 91 27 01 	lds	r25, 0x0127
    4a02:	01 97       	sbiw	r24, 0x01	; 1
    4a04:	90 93 27 01 	sts	0x0127, r25
    4a08:	80 93 26 01 	sts	0x0126, r24
					SREG=sreg;
    4a0c:	2f bf       	out	0x3f, r18	; 63
    4a0e:	03 c0       	rjmp	.+6      	; 0x4a16 <main+0x5f4>
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    4a10:	8f ef       	ldi	r24, 0xFF	; 255
    4a12:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    4a16:	80 91 83 05 	lds	r24, 0x0583
    4a1a:	90 91 84 05 	lds	r25, 0x0584
    4a1e:	01 97       	sbiw	r24, 0x01	; 1
    4a20:	90 93 84 05 	sts	0x0584, r25
    4a24:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4a28:	63 94       	inc	r6
    4a2a:	86 2d       	mov	r24, r6
    4a2c:	90 e0       	ldi	r25, 0x00	; 0
    4a2e:	80 17       	cp	r24, r16
    4a30:	91 07       	cpc	r25, r17
    4a32:	08 f4       	brcc	.+2      	; 0x4a36 <main+0x614>
    4a34:	a4 cf       	rjmp	.-184    	; 0x497e <main+0x55c>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    4a36:	80 91 83 05 	lds	r24, 0x0583
    4a3a:	90 91 84 05 	lds	r25, 0x0584
    4a3e:	89 2b       	or	r24, r25
    4a40:	09 f0       	breq	.+2      	; 0x4a44 <main+0x622>
    4a42:	00 c3       	rjmp	.+1536   	; 0x5044 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4a44:	8f ef       	ldi	r24, 0xFF	; 255
    4a46:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4a4a:	8f ef       	ldi	r24, 0xFF	; 255
    4a4c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4a50:	8f ef       	ldi	r24, 0xFF	; 255
    4a52:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4a56:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4a58:	85 30       	cpi	r24, 0x05	; 5
    4a5a:	09 f0       	breq	.+2      	; 0x4a5e <main+0x63c>
    4a5c:	29 c3       	rjmp	.+1618   	; 0x50b0 <main+0xc8e>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4a5e:	62 e6       	ldi	r22, 0x62	; 98
    4a60:	72 e0       	ldi	r23, 0x02	; 2
    4a62:	83 e0       	ldi	r24, 0x03	; 3
    4a64:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    4a68:	20 92 59 05 	sts	0x0559, r2
    4a6c:	eb c2       	rjmp	.+1494   	; 0x5044 <main+0xc22>
				}
			}
			break;

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    4a6e:	83 e0       	ldi	r24, 0x03	; 3
    4a70:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4a74:	81 11       	cpse	r24, r1
    4a76:	1c c3       	rjmp	.+1592   	; 0x50b0 <main+0xc8e>
    4a78:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4a7a:	8f ef       	ldi	r24, 0xFF	; 255
    4a7c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4a80:	8f 3f       	cpi	r24, 0xFF	; 255
    4a82:	09 f4       	brne	.+2      	; 0x4a86 <main+0x664>
    4a84:	09 c3       	rjmp	.+1554   	; 0x5098 <main+0xc76>
    4a86:	11 50       	subi	r17, 0x01	; 1

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4a88:	c1 f7       	brne	.-16     	; 0x4a7a <main+0x658>
    4a8a:	dc c2       	rjmp	.+1464   	; 0x5044 <main+0xc22>

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4a8c:	80 91 c8 00 	lds	r24, 0x00C8
    4a90:	86 ff       	sbrs	r24, 6
    4a92:	fc cf       	rjmp	.-8      	; 0x4a8c <main+0x66a>
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    4a94:	80 91 1e 01 	lds	r24, 0x011E
    4a98:	90 91 1f 01 	lds	r25, 0x011F
    4a9c:	a0 91 20 01 	lds	r26, 0x0120
    4aa0:	b0 91 21 01 	lds	r27, 0x0121
    4aa4:	89 2b       	or	r24, r25
    4aa6:	8a 2b       	or	r24, r26
    4aa8:	8b 2b       	or	r24, r27
    4aaa:	11 f0       	breq	.+4      	; 0x4ab0 <main+0x68e>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    4aac:	85 e0       	ldi	r24, 0x05	; 5
    4aae:	ec c0       	rjmp	.+472    	; 0x4c88 <main+0x866>
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    4ab0:	20 91 6e 05 	lds	r18, 0x056E
    4ab4:	30 91 6f 05 	lds	r19, 0x056F
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    4ab8:	f9 01       	movw	r30, r18
    4aba:	43 e0       	ldi	r20, 0x03	; 3
    4abc:	f6 95       	lsr	r31
    4abe:	e7 95       	ror	r30
    4ac0:	4a 95       	dec	r20
    4ac2:	e1 f7       	brne	.-8      	; 0x4abc <main+0x69a>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    4ac4:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    4ac6:	eb 57       	subi	r30, 0x7B	; 123
    4ac8:	fa 4f       	sbci	r31, 0xFA	; 250
    4aca:	40 81       	ld	r20, Z
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    4acc:	27 70       	andi	r18, 0x07	; 7
    4ace:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    4ad0:	84 2f       	mov	r24, r20
    4ad2:	90 e0       	ldi	r25, 0x00	; 0
    4ad4:	02 2e       	mov	r0, r18
    4ad6:	02 c0       	rjmp	.+4      	; 0x4adc <main+0x6ba>
    4ad8:	95 95       	asr	r25
    4ada:	87 95       	ror	r24
    4adc:	0a 94       	dec	r0
    4ade:	e2 f7       	brpl	.-8      	; 0x4ad8 <main+0x6b6>
    4ae0:	80 ff       	sbrs	r24, 0
    4ae2:	cc c2       	rjmp	.+1432   	; 0x507c <main+0xc5a>
    4ae4:	d6 c2       	rjmp	.+1452   	; 0x5092 <main+0xc70>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    4ae6:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4ae8:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    4aea:	80 91 26 01 	lds	r24, 0x0126
    4aee:	90 91 27 01 	lds	r25, 0x0127
    4af2:	81 15       	cp	r24, r1
    4af4:	92 40       	sbci	r25, 0x02	; 2
    4af6:	98 f4       	brcc	.+38     	; 0x4b1e <main+0x6fc>
    4af8:	80 91 26 01 	lds	r24, 0x0126
    4afc:	90 91 27 01 	lds	r25, 0x0127
    4b00:	40 91 1e 01 	lds	r20, 0x011E
    4b04:	50 91 1f 01 	lds	r21, 0x011F
    4b08:	60 91 20 01 	lds	r22, 0x0120
    4b0c:	70 91 21 01 	lds	r23, 0x0121
    4b10:	a0 e0       	ldi	r26, 0x00	; 0
    4b12:	b0 e0       	ldi	r27, 0x00	; 0
    4b14:	84 17       	cp	r24, r20
    4b16:	95 07       	cpc	r25, r21
    4b18:	a6 07       	cpc	r26, r22
    4b1a:	b7 07       	cpc	r27, r23
    4b1c:	58 f1       	brcs	.+86     	; 0x4b74 <main+0x752>
			{
				SREG=sreg;																	// Done reading ISR variables.
    4b1e:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;		// On to the next
    4b20:	20 91 74 05 	lds	r18, 0x0574
    4b24:	30 91 75 05 	lds	r19, 0x0575
    4b28:	2f 5f       	subi	r18, 0xFF	; 255
    4b2a:	3f 4f       	sbci	r19, 0xFF	; 255
    4b2c:	30 93 75 05 	sts	0x0575, r19
    4b30:	20 93 74 05 	sts	0x0574, r18

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    4b34:	60 91 70 05 	lds	r22, 0x0570
    4b38:	70 91 71 05 	lds	r23, 0x0571
    4b3c:	80 91 72 05 	lds	r24, 0x0572
    4b40:	90 91 73 05 	lds	r25, 0x0573
    4b44:	62 0f       	add	r22, r18
    4b46:	73 1f       	adc	r23, r19
    4b48:	81 1d       	adc	r24, r1
    4b4a:	91 1d       	adc	r25, r1
    4b4c:	0e 94 00 22 	call	0x4400	; 0x4400 <SdBeginSingleBlockWrite>
    4b50:	81 30       	cpi	r24, 0x01	; 1
    4b52:	09 f0       	breq	.+2      	; 0x4b56 <main+0x734>
    4b54:	ad c2       	rjmp	.+1370   	; 0x50b0 <main+0xc8e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4b56:	d0 93 84 05 	sts	0x0584, r29
    4b5a:	c0 93 83 05 	sts	0x0583, r28

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    4b5e:	8f ef       	ldi	r24, 0xFF	; 255
    4b60:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    4b64:	8f ef       	ldi	r24, 0xFF	; 255
    4b66:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    4b6a:	8e ef       	ldi	r24, 0xFE	; 254
    4b6c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    4b70:	83 e0       	ldi	r24, 0x03	; 3
    4b72:	8a c0       	rjmp	.+276    	; 0x4c88 <main+0x866>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
				}
			}
			else	// Bytes remaining in sample, but not enough in the fifo yet
			{
				SREG=sreg;			// Done reading ISR variables.
    4b74:	2f bf       	out	0x3f, r18	; 63
    4b76:	66 c2       	rjmp	.+1228   	; 0x5044 <main+0xc22>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    4b78:	60 e0       	ldi	r22, 0x00	; 0
    4b7a:	70 e0       	ldi	r23, 0x00	; 0
    4b7c:	cb 01       	movw	r24, r22
    4b7e:	0e 94 00 22 	call	0x4400	; 0x4400 <SdBeginSingleBlockWrite>
    4b82:	81 30       	cpi	r24, 0x01	; 1
    4b84:	09 f0       	breq	.+2      	; 0x4b88 <main+0x766>
    4b86:	94 c2       	rjmp	.+1320   	; 0x50b0 <main+0xc8e>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    4b88:	d0 93 84 05 	sts	0x0584, r29
    4b8c:	c0 93 83 05 	sts	0x0583, r28

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4b90:	8f ef       	ldi	r24, 0xFF	; 255
    4b92:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    4b96:	8f ef       	ldi	r24, 0xFF	; 255
    4b98:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    4b9c:	8e ef       	ldi	r24, 0xFE	; 254
    4b9e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte('W');				// Send flag that this is a WTPA card
    4ba2:	87 e5       	ldi	r24, 0x57	; 87
    4ba4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte('T');
    4ba8:	84 e5       	ldi	r24, 0x54	; 84
    4baa:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte('P');
    4bae:	80 e5       	ldi	r24, 0x50	; 80
    4bb0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte('A');
    4bb4:	81 e4       	ldi	r24, 0x41	; 65
    4bb6:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>

				bytesLeftInBlock-=4;
    4bba:	80 91 83 05 	lds	r24, 0x0583
    4bbe:	90 91 84 05 	lds	r25, 0x0584
    4bc2:	04 97       	sbiw	r24, 0x04	; 4
    4bc4:	90 93 84 05 	sts	0x0584, r25
    4bc8:	80 93 83 05 	sts	0x0583, r24
    4bcc:	1c e0       	ldi	r17, 0x0C	; 12

				for(i=0;i<12;i++)					// 12 don't care bytes
				{
					TransferSdByte('x');
    4bce:	88 e7       	ldi	r24, 0x78	; 120
    4bd0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4bd4:	11 50       	subi	r17, 0x01	; 1
				TransferSdByte('P');
				TransferSdByte('A');

				bytesLeftInBlock-=4;

				for(i=0;i<12;i++)					// 12 don't care bytes
    4bd6:	d9 f7       	brne	.-10     	; 0x4bce <main+0x7ac>
				{
					TransferSdByte('x');
				}

				bytesLeftInBlock-=12;
    4bd8:	80 91 83 05 	lds	r24, 0x0583
    4bdc:	90 91 84 05 	lds	r25, 0x0584
    4be0:	0c 97       	sbiw	r24, 0x0c	; 12
    4be2:	90 93 84 05 	sts	0x0584, r25
    4be6:	80 93 83 05 	sts	0x0583, r24
    4bea:	05 e8       	ldi	r16, 0x85	; 133
    4bec:	15 e0       	ldi	r17, 0x05	; 5

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    4bee:	f8 01       	movw	r30, r16
    4bf0:	81 91       	ld	r24, Z+
    4bf2:	8f 01       	movw	r16, r30
    4bf4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte('x');
				}

				bytesLeftInBlock-=12;

				for(i=0;i<64;i++)					// Write table of contents.
    4bf8:	f5 e0       	ldi	r31, 0x05	; 5
    4bfa:	05 3c       	cpi	r16, 0xC5	; 197
    4bfc:	1f 07       	cpc	r17, r31
    4bfe:	b9 f7       	brne	.-18     	; 0x4bee <main+0x7cc>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    4c00:	80 91 83 05 	lds	r24, 0x0583
    4c04:	90 91 84 05 	lds	r25, 0x0584
    4c08:	80 54       	subi	r24, 0x40	; 64
    4c0a:	91 09       	sbc	r25, r1
    4c0c:	90 93 84 05 	sts	0x0584, r25
    4c10:	80 93 83 05 	sts	0x0583, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4c14:	90 92 59 05 	sts	0x0559, r9
    4c18:	15 c2       	rjmp	.+1066   	; 0x5044 <main+0xc22>
    4c1a:	00 91 83 05 	lds	r16, 0x0583
    4c1e:	10 91 84 05 	lds	r17, 0x0584
    4c22:	01 34       	cpi	r16, 0x41	; 65
    4c24:	11 05       	cpc	r17, r1
    4c26:	10 f0       	brcs	.+4      	; 0x4c2c <main+0x80a>
    4c28:	00 e4       	ldi	r16, 0x40	; 64
    4c2a:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4c2c:	61 2c       	mov	r6, r1
    4c2e:	0d c0       	rjmp	.+26     	; 0x4c4a <main+0x828>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4c30:	8f ef       	ldi	r24, 0xFF	; 255
    4c32:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    4c36:	80 91 83 05 	lds	r24, 0x0583
    4c3a:	90 91 84 05 	lds	r25, 0x0584
    4c3e:	01 97       	sbiw	r24, 0x01	; 1
    4c40:	90 93 84 05 	sts	0x0584, r25
    4c44:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4c48:	63 94       	inc	r6
    4c4a:	86 2d       	mov	r24, r6
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
    4c4e:	80 17       	cp	r24, r16
    4c50:	91 07       	cpc	r25, r17
    4c52:	70 f3       	brcs	.-36     	; 0x4c30 <main+0x80e>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    4c54:	80 91 83 05 	lds	r24, 0x0583
    4c58:	90 91 84 05 	lds	r25, 0x0584
    4c5c:	89 2b       	or	r24, r25
    4c5e:	09 f0       	breq	.+2      	; 0x4c62 <main+0x840>
    4c60:	f1 c1       	rjmp	.+994    	; 0x5044 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4c62:	8f ef       	ldi	r24, 0xFF	; 255
    4c64:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4c68:	8f ef       	ldi	r24, 0xFF	; 255
    4c6a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4c6e:	8f ef       	ldi	r24, 0xFF	; 255
    4c70:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4c74:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4c76:	85 30       	cpi	r24, 0x05	; 5
    4c78:	09 f0       	breq	.+2      	; 0x4c7c <main+0x85a>
    4c7a:	1a c2       	rjmp	.+1076   	; 0x50b0 <main+0xc8e>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4c7c:	62 e6       	ldi	r22, 0x62	; 98
    4c7e:	72 e0       	ldi	r23, 0x02	; 2
    4c80:	83 e0       	ldi	r24, 0x03	; 3
    4c82:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    4c86:	88 e0       	ldi	r24, 0x08	; 8
    4c88:	80 93 59 05 	sts	0x0559, r24
    4c8c:	db c1       	rjmp	.+950    	; 0x5044 <main+0xc22>
				}
			}
			break;

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4c8e:	83 e0       	ldi	r24, 0x03	; 3
    4c90:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4c94:	81 11       	cpse	r24, r1
    4c96:	0c c2       	rjmp	.+1048   	; 0x50b0 <main+0xc8e>
    4c98:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4c9a:	8f ef       	ldi	r24, 0xFF	; 255
    4c9c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4ca0:	8f 3f       	cpi	r24, 0xFF	; 255
    4ca2:	09 f4       	brne	.+2      	; 0x4ca6 <main+0x884>
    4ca4:	ff c1       	rjmp	.+1022   	; 0x50a4 <main+0xc82>
    4ca6:	11 50       	subi	r17, 0x01	; 1

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4ca8:	c1 f7       	brne	.-16     	; 0x4c9a <main+0x878>
    4caa:	cc c1       	rjmp	.+920    	; 0x5044 <main+0xc22>

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4cac:	80 91 c8 00 	lds	r24, 0x00C8
    4cb0:	86 ff       	sbrs	r24, 6
    4cb2:	fc cf       	rjmp	.-8      	; 0x4cac <main+0x88a>
    4cb4:	ee c1       	rjmp	.+988    	; 0x5092 <main+0xc70>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4cb6:	83 e0       	ldi	r24, 0x03	; 3
    4cb8:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4cbc:	81 11       	cpse	r24, r1
    4cbe:	f8 c1       	rjmp	.+1008   	; 0x50b0 <main+0xc8e>
    4cc0:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4cc2:	8f ef       	ldi	r24, 0xFF	; 255
    4cc4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    4cc8:	8f 3f       	cpi	r24, 0xFF	; 255
    4cca:	19 f4       	brne	.+6      	; 0x4cd2 <main+0x8b0>
    4ccc:	11 50       	subi	r17, 0x01	; 1

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    4cce:	c9 f7       	brne	.-14     	; 0x4cc2 <main+0x8a0>
    4cd0:	b9 c1       	rjmp	.+882    	; 0x5044 <main+0xc22>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    4cd2:	8e 3f       	cpi	r24, 0xFE	; 254
    4cd4:	09 f0       	breq	.+2      	; 0x4cd8 <main+0x8b6>
    4cd6:	ec c1       	rjmp	.+984    	; 0x50b0 <main+0xc8e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
    4cd8:	d0 93 84 05 	sts	0x0584, r29
    4cdc:	c0 93 83 05 	sts	0x0583, r28

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    4ce0:	8f ef       	ldi	r24, 0xFF	; 255
    4ce2:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4ce6:	90 e0       	ldi	r25, 0x00	; 0
    4ce8:	a0 e0       	ldi	r26, 0x00	; 0
    4cea:	b0 e0       	ldi	r27, 0x00	; 0
    4cec:	b8 2f       	mov	r27, r24
    4cee:	aa 27       	eor	r26, r26
    4cf0:	99 27       	eor	r25, r25
    4cf2:	88 27       	eor	r24, r24
    4cf4:	80 93 1e 01 	sts	0x011E, r24
    4cf8:	90 93 1f 01 	sts	0x011F, r25
    4cfc:	a0 93 20 01 	sts	0x0120, r26
    4d00:	b0 93 21 01 	sts	0x0121, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    4d04:	40 90 1e 01 	lds	r4, 0x011E
    4d08:	50 90 1f 01 	lds	r5, 0x011F
    4d0c:	60 90 20 01 	lds	r6, 0x0120
    4d10:	70 90 21 01 	lds	r7, 0x0121
    4d14:	8f ef       	ldi	r24, 0xFF	; 255
    4d16:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4d1a:	b3 01       	movw	r22, r6
    4d1c:	a2 01       	movw	r20, r4
    4d1e:	68 2b       	or	r22, r24
    4d20:	40 93 1e 01 	sts	0x011E, r20
    4d24:	50 93 1f 01 	sts	0x011F, r21
    4d28:	60 93 20 01 	sts	0x0120, r22
    4d2c:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    4d30:	40 90 1e 01 	lds	r4, 0x011E
    4d34:	50 90 1f 01 	lds	r5, 0x011F
    4d38:	60 90 20 01 	lds	r6, 0x0120
    4d3c:	70 90 21 01 	lds	r7, 0x0121
    4d40:	8f ef       	ldi	r24, 0xFF	; 255
    4d42:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4d46:	b3 01       	movw	r22, r6
    4d48:	a2 01       	movw	r20, r4
    4d4a:	58 2b       	or	r21, r24
    4d4c:	40 93 1e 01 	sts	0x011E, r20
    4d50:	50 93 1f 01 	sts	0x011F, r21
    4d54:	60 93 20 01 	sts	0x0120, r22
    4d58:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    4d5c:	40 90 1e 01 	lds	r4, 0x011E
    4d60:	50 90 1f 01 	lds	r5, 0x011F
    4d64:	60 90 20 01 	lds	r6, 0x0120
    4d68:	70 90 21 01 	lds	r7, 0x0121
    4d6c:	8f ef       	ldi	r24, 0xFF	; 255
    4d6e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    4d72:	b3 01       	movw	r22, r6
    4d74:	a2 01       	movw	r20, r4
    4d76:	48 2b       	or	r20, r24
    4d78:	40 93 1e 01 	sts	0x011E, r20
    4d7c:	50 93 1f 01 	sts	0x011F, r21
    4d80:	60 93 20 01 	sts	0x0120, r22
    4d84:	70 93 21 01 	sts	0x0121, r23

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    4d88:	80 91 1e 01 	lds	r24, 0x011E
    4d8c:	90 91 1f 01 	lds	r25, 0x011F
    4d90:	a0 91 20 01 	lds	r26, 0x0120
    4d94:	b0 91 21 01 	lds	r27, 0x0121
    4d98:	80 93 22 01 	sts	0x0122, r24
    4d9c:	90 93 23 01 	sts	0x0123, r25
    4da0:	a0 93 24 01 	sts	0x0124, r26
    4da4:	b0 93 25 01 	sts	0x0125, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    4da8:	80 91 83 05 	lds	r24, 0x0583
    4dac:	90 91 84 05 	lds	r25, 0x0584
    4db0:	04 97       	sbiw	r24, 0x04	; 4
    4db2:	90 93 84 05 	sts	0x0584, r25
    4db6:	80 93 83 05 	sts	0x0583, r24
    4dba:	f4 c0       	rjmp	.+488    	; 0x4fa4 <main+0xb82>
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    4dbc:	80 91 76 05 	lds	r24, 0x0576
    4dc0:	81 30       	cpi	r24, 0x01	; 1
    4dc2:	09 f4       	brne	.+2      	; 0x4dc6 <main+0x9a4>
    4dc4:	f6 c0       	rjmp	.+492    	; 0x4fb2 <main+0xb90>
    4dc6:	00 91 83 05 	lds	r16, 0x0583
    4dca:	10 91 84 05 	lds	r17, 0x0584
    4dce:	01 34       	cpi	r16, 0x41	; 65
    4dd0:	11 05       	cpc	r17, r1
    4dd2:	10 f0       	brcs	.+4      	; 0x4dd8 <main+0x9b6>
    4dd4:	00 e4       	ldi	r16, 0x40	; 64
    4dd6:	10 e0       	ldi	r17, 0x00	; 0
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    4dd8:	61 2c       	mov	r6, r1
    4dda:	55 c0       	rjmp	.+170    	; 0x4e86 <main+0xa64>
				{
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    4ddc:	8f ef       	ldi	r24, 0xFF	; 255
    4dde:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					bytesLeftInBlock--;						// One less byte in the block read.
    4de2:	20 91 83 05 	lds	r18, 0x0583
    4de6:	30 91 84 05 	lds	r19, 0x0584
    4dea:	21 50       	subi	r18, 0x01	; 1
    4dec:	31 09       	sbc	r19, r1
    4dee:	30 93 84 05 	sts	0x0584, r19
    4df2:	20 93 83 05 	sts	0x0583, r18

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    4df6:	40 91 1e 01 	lds	r20, 0x011E
    4dfa:	50 91 1f 01 	lds	r21, 0x011F
    4dfe:	60 91 20 01 	lds	r22, 0x0120
    4e02:	70 91 21 01 	lds	r23, 0x0121
    4e06:	45 2b       	or	r20, r21
    4e08:	46 2b       	or	r20, r22
    4e0a:	47 2b       	or	r20, r23
    4e0c:	d9 f1       	breq	.+118    	; 0x4e84 <main+0xa62>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    4e0e:	40 91 1e 01 	lds	r20, 0x011E
    4e12:	50 91 1f 01 	lds	r21, 0x011F
    4e16:	60 91 20 01 	lds	r22, 0x0120
    4e1a:	70 91 21 01 	lds	r23, 0x0121
    4e1e:	41 50       	subi	r20, 0x01	; 1
    4e20:	51 09       	sbc	r21, r1
    4e22:	61 09       	sbc	r22, r1
    4e24:	71 09       	sbc	r23, r1
    4e26:	40 93 1e 01 	sts	0x011E, r20
    4e2a:	50 93 1f 01 	sts	0x011F, r21
    4e2e:	60 93 20 01 	sts	0x0120, r22
    4e32:	70 93 21 01 	sts	0x0121, r23

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    4e36:	e0 91 28 01 	lds	r30, 0x0128
    4e3a:	f0 91 29 01 	lds	r31, 0x0129
    4e3e:	e4 5d       	subi	r30, 0xD4	; 212
    4e40:	fe 4f       	sbci	r31, 0xFE	; 254
    4e42:	80 83       	st	Z, r24
						sdFifoWritePointer++;				// Move to next spot in fifo
    4e44:	80 91 28 01 	lds	r24, 0x0128
    4e48:	90 91 29 01 	lds	r25, 0x0129
    4e4c:	01 96       	adiw	r24, 0x01	; 1
    4e4e:	90 93 29 01 	sts	0x0129, r25
    4e52:	80 93 28 01 	sts	0x0128, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    4e56:	80 91 28 01 	lds	r24, 0x0128
    4e5a:	90 91 29 01 	lds	r25, 0x0129
    4e5e:	81 15       	cp	r24, r1
    4e60:	93 40       	sbci	r25, 0x03	; 3
    4e62:	20 f0       	brcs	.+8      	; 0x4e6c <main+0xa4a>
						{
							sdFifoWritePointer=0;
    4e64:	10 92 29 01 	sts	0x0129, r1
    4e68:	10 92 28 01 	sts	0x0128, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    4e6c:	2f b7       	in	r18, 0x3f	; 63
						cli();
    4e6e:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    4e70:	80 91 26 01 	lds	r24, 0x0126
    4e74:	90 91 27 01 	lds	r25, 0x0127
    4e78:	01 96       	adiw	r24, 0x01	; 1
    4e7a:	90 93 27 01 	sts	0x0127, r25
    4e7e:	80 93 26 01 	sts	0x0126, r24
						SREG=sreg;
    4e82:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    4e84:	63 94       	inc	r6
    4e86:	86 2d       	mov	r24, r6
    4e88:	90 e0       	ldi	r25, 0x00	; 0
    4e8a:	80 17       	cp	r24, r16
    4e8c:	91 07       	cpc	r25, r17
    4e8e:	08 f4       	brcc	.+2      	; 0x4e92 <main+0xa70>
    4e90:	a5 cf       	rjmp	.-182    	; 0x4ddc <main+0x9ba>
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    4e92:	80 91 83 05 	lds	r24, 0x0583
    4e96:	90 91 84 05 	lds	r25, 0x0584
    4e9a:	89 2b       	or	r24, r25
    4e9c:	09 f0       	breq	.+2      	; 0x4ea0 <main+0xa7e>
    4e9e:	d2 c0       	rjmp	.+420    	; 0x5044 <main+0xc22>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    4ea0:	8f ef       	ldi	r24, 0xFF	; 255
    4ea2:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    4ea6:	8f ef       	ldi	r24, 0xFF	; 255
    4ea8:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4eac:	80 91 c8 00 	lds	r24, 0x00C8
    4eb0:	86 ff       	sbrs	r24, 6
    4eb2:	fc cf       	rjmp	.-8      	; 0x4eac <main+0xa8a>
						;

					EndSdTransfer();				// Bring CS high
    4eb4:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    4eb8:	8f ef       	ldi	r24, 0xFF	; 255
    4eba:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    4ebe:	80 92 59 05 	sts	0x0559, r8

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    4ec2:	80 91 1e 01 	lds	r24, 0x011E
    4ec6:	90 91 1f 01 	lds	r25, 0x011F
    4eca:	a0 91 20 01 	lds	r26, 0x0120
    4ece:	b0 91 21 01 	lds	r27, 0x0121
    4ed2:	89 2b       	or	r24, r25
    4ed4:	8a 2b       	or	r24, r26
    4ed6:	8b 2b       	or	r24, r27
    4ed8:	09 f0       	breq	.+2      	; 0x4edc <main+0xaba>
    4eda:	b4 c0       	rjmp	.+360    	; 0x5044 <main+0xc22>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4edc:	80 91 c8 00 	lds	r24, 0x00C8
    4ee0:	86 ff       	sbrs	r24, 6
    4ee2:	fc cf       	rjmp	.-8      	; 0x4edc <main+0xaba>
    4ee4:	d6 c0       	rjmp	.+428    	; 0x5092 <main+0xc70>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    4ee6:	ef b7       	in	r30, 0x3f	; 63
			cli();
    4ee8:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    4eea:	20 91 26 01 	lds	r18, 0x0126
    4eee:	30 91 27 01 	lds	r19, 0x0127
    4ef2:	80 e0       	ldi	r24, 0x00	; 0
    4ef4:	93 e0       	ldi	r25, 0x03	; 3
    4ef6:	ac 01       	movw	r20, r24
    4ef8:	42 1b       	sub	r20, r18
    4efa:	53 0b       	sbc	r21, r19
    4efc:	9a 01       	movw	r18, r20
    4efe:	21 15       	cp	r18, r1
    4f00:	32 40       	sbci	r19, 0x02	; 2
    4f02:	a8 f4       	brcc	.+42     	; 0x4f2e <main+0xb0c>
    4f04:	20 91 26 01 	lds	r18, 0x0126
    4f08:	30 91 27 01 	lds	r19, 0x0127
    4f0c:	40 91 1e 01 	lds	r20, 0x011E
    4f10:	50 91 1f 01 	lds	r21, 0x011F
    4f14:	60 91 20 01 	lds	r22, 0x0120
    4f18:	70 91 21 01 	lds	r23, 0x0121
    4f1c:	82 1b       	sub	r24, r18
    4f1e:	93 0b       	sbc	r25, r19
    4f20:	a0 e0       	ldi	r26, 0x00	; 0
    4f22:	b0 e0       	ldi	r27, 0x00	; 0
    4f24:	84 17       	cp	r24, r20
    4f26:	95 07       	cpc	r25, r21
    4f28:	a6 07       	cpc	r26, r22
    4f2a:	b7 07       	cpc	r27, r23
    4f2c:	20 f1       	brcs	.+72     	; 0x4f76 <main+0xb54>
			{
				SREG=sreg;				// ISR back on.
    4f2e:	ef bf       	out	0x3f, r30	; 63
				sdCurrentBlockOffset++;	// Point at next block
    4f30:	20 91 74 05 	lds	r18, 0x0574
    4f34:	30 91 75 05 	lds	r19, 0x0575
    4f38:	2f 5f       	subi	r18, 0xFF	; 255
    4f3a:	3f 4f       	sbci	r19, 0xFF	; 255
    4f3c:	30 93 75 05 	sts	0x0575, r19
    4f40:	20 93 74 05 	sts	0x0574, r18

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    4f44:	60 91 70 05 	lds	r22, 0x0570
    4f48:	70 91 71 05 	lds	r23, 0x0571
    4f4c:	80 91 72 05 	lds	r24, 0x0572
    4f50:	90 91 73 05 	lds	r25, 0x0573
    4f54:	62 0f       	add	r22, r18
    4f56:	73 1f       	adc	r23, r19
    4f58:	81 1d       	adc	r24, r1
    4f5a:	91 1d       	adc	r25, r1
    4f5c:	0e 94 ef 21 	call	0x43de	; 0x43de <SdBeginSingleBlockRead>
    4f60:	81 30       	cpi	r24, 0x01	; 1
    4f62:	09 f0       	breq	.+2      	; 0x4f66 <main+0xb44>
    4f64:	a5 c0       	rjmp	.+330    	; 0x50b0 <main+0xc8e>
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    4f66:	6a e7       	ldi	r22, 0x7A	; 122
    4f68:	70 e0       	ldi	r23, 0x00	; 0
    4f6a:	83 e0       	ldi	r24, 0x03	; 3
    4f6c:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    4f70:	30 92 59 05 	sts	0x0559, r3
    4f74:	67 c0       	rjmp	.+206    	; 0x5044 <main+0xc22>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
				}
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    4f76:	ef bf       	out	0x3f, r30	; 63
    4f78:	65 c0       	rjmp	.+202    	; 0x5044 <main+0xc22>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    4f7a:	83 e0       	ldi	r24, 0x03	; 3
    4f7c:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <CheckTimer>
    4f80:	81 11       	cpse	r24, r1
    4f82:	96 c0       	rjmp	.+300    	; 0x50b0 <main+0xc8e>
    4f84:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4f86:	8f ef       	ldi	r24, 0xFF	; 255
    4f88:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    4f8c:	8f 3f       	cpi	r24, 0xFF	; 255
    4f8e:	19 f4       	brne	.+6      	; 0x4f96 <main+0xb74>
    4f90:	11 50       	subi	r17, 0x01	; 1

			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    4f92:	c9 f7       	brne	.-14     	; 0x4f86 <main+0xb64>
    4f94:	57 c0       	rjmp	.+174    	; 0x5044 <main+0xc22>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    4f96:	8e 3f       	cpi	r24, 0xFE	; 254
    4f98:	09 f0       	breq	.+2      	; 0x4f9c <main+0xb7a>
    4f9a:	8a c0       	rjmp	.+276    	; 0x50b0 <main+0xc8e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
    4f9c:	d0 93 84 05 	sts	0x0584, r29
    4fa0:	c0 93 83 05 	sts	0x0583, r28

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    4fa4:	a0 92 59 05 	sts	0x0559, r10
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    4fa8:	80 91 76 05 	lds	r24, 0x0576
    4fac:	81 30       	cpi	r24, 0x01	; 1
    4fae:	09 f0       	breq	.+2      	; 0x4fb2 <main+0xb90>
    4fb0:	49 c0       	rjmp	.+146    	; 0x5044 <main+0xc22>
					{
						cardState=SD_READ_ABORT;
    4fb2:	b0 92 59 05 	sts	0x0559, r11
						sdAbortRead=false;
    4fb6:	10 92 76 05 	sts	0x0576, r1
    4fba:	44 c0       	rjmp	.+136    	; 0x5044 <main+0xc22>
    4fbc:	00 91 83 05 	lds	r16, 0x0583
    4fc0:	10 91 84 05 	lds	r17, 0x0584
    4fc4:	01 34       	cpi	r16, 0x41	; 65
    4fc6:	11 05       	cpc	r17, r1
    4fc8:	10 f0       	brcs	.+4      	; 0x4fce <main+0xbac>
    4fca:	00 e4       	ldi	r16, 0x40	; 64
    4fcc:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    4fce:	61 2c       	mov	r6, r1
    4fd0:	0d c0       	rjmp	.+26     	; 0x4fec <main+0xbca>
			{
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    4fd2:	8f ef       	ldi	r24, 0xFF	; 255
    4fd4:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    4fd8:	80 91 83 05 	lds	r24, 0x0583
    4fdc:	90 91 84 05 	lds	r25, 0x0584
    4fe0:	01 97       	sbiw	r24, 0x01	; 1
    4fe2:	90 93 84 05 	sts	0x0584, r25
    4fe6:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    4fea:	63 94       	inc	r6
    4fec:	86 2d       	mov	r24, r6
    4fee:	90 e0       	ldi	r25, 0x00	; 0
    4ff0:	80 17       	cp	r24, r16
    4ff2:	91 07       	cpc	r25, r17
    4ff4:	70 f3       	brcs	.-36     	; 0x4fd2 <main+0xbb0>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    4ff6:	80 91 83 05 	lds	r24, 0x0583
    4ffa:	90 91 84 05 	lds	r25, 0x0584
    4ffe:	89 2b       	or	r24, r25
    5000:	09 f5       	brne	.+66     	; 0x5044 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5002:	8f ef       	ldi	r24, 0xFF	; 255
    5004:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5008:	8f ef       	ldi	r24, 0xFF	; 255
    500a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    500e:	80 91 c8 00 	lds	r24, 0x00C8
    5012:	86 ff       	sbrs	r24, 6
    5014:	fc cf       	rjmp	.-8      	; 0x500e <main+0xbec>
					;

				EndSdTransfer();				// Bring CS high
    5016:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    501a:	8f ef       	ldi	r24, 0xFF	; 255
    501c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5020:	80 91 c8 00 	lds	r24, 0x00C8
    5024:	86 ff       	sbrs	r24, 6
    5026:	fc cf       	rjmp	.-8      	; 0x5020 <main+0xbfe>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
    5028:	d0 92 59 05 	sts	0x0559, r13

				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    502c:	80 91 79 05 	lds	r24, 0x0579
    5030:	81 30       	cpi	r24, 0x01	; 1
    5032:	41 f4       	brne	.+16     	; 0x5044 <main+0xc22>
				{
					sdPlaybackQueued=false;
    5034:	10 92 79 05 	sts	0x0579, r1
//					PlaySampleFromSd(sdQueuedBank,sdQueuedSlot);	// Trigger the next stream immediately
					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
    5038:	80 91 77 05 	lds	r24, 0x0577
    503c:	90 91 78 05 	lds	r25, 0x0578
    5040:	0e 94 4b 11 	call	0x2296	; 0x2296 <PlaySampleFromSd>
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
		HandleLeds();			// Keep LEDs updated.
		UpdateCard();			// Keep the SD card state machine running.
		GetRandomLongInt();		// Keep random numbers rolling.
    5044:	0e 94 04 09 	call	0x1208	; 0x1208 <GetRandomLongInt>

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    5048:	0e 94 ed 1d 	call	0x3bda	; 0x3bda <Uart0GotByte>
    504c:	88 23       	and	r24, r24
    504e:	21 f0       	breq	.+8      	; 0x5058 <main+0xc36>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    5050:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <Uart0GetByte>
    5054:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    5058:	0e 94 7b 1f 	call	0x3ef6	; 0x3ef6 <MidiTxBufferNotEmpty>
    505c:	88 23       	and	r24, r24
    505e:	41 f0       	breq	.+16     	; 0x5070 <main+0xc4e>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    5060:	80 91 c0 00 	lds	r24, 0x00C0
    5064:	85 ff       	sbrs	r24, 5
    5066:	04 c0       	rjmp	.+8      	; 0x5070 <main+0xc4e>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    5068:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <PopOutgoingMidiByte>
    506c:	80 93 c6 00 	sts	0x00C6, r24
			}
		}

		State();				// Execute the current program state.
    5070:	e0 91 e4 05 	lds	r30, 0x05E4
    5074:	f0 91 e5 05 	lds	r31, 0x05E5
    5078:	09 95       	icall
	}
    507a:	67 ca       	rjmp	.-2866   	; 0x454a <main+0x128>
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    507c:	b7 01       	movw	r22, r14
    507e:	02 c0       	rjmp	.+4      	; 0x5084 <main+0xc62>
    5080:	66 0f       	add	r22, r22
    5082:	77 1f       	adc	r23, r23
    5084:	2a 95       	dec	r18
    5086:	e2 f7       	brpl	.-8      	; 0x5080 <main+0xc5e>
    5088:	9b 01       	movw	r18, r22
    508a:	24 2b       	or	r18, r20
    508c:	20 83       	st	Z, r18
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    508e:	86 e0       	ldi	r24, 0x06	; 6
    5090:	fb cd       	rjmp	.-1034   	; 0x4c88 <main+0x866>
						}
						else
						{
							cardState=SD_IDLE;				// DONE!
    5092:	d0 92 59 05 	sts	0x0559, r13
    5096:	d6 cf       	rjmp	.-84     	; 0x5044 <main+0xc22>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    5098:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    509c:	8f ef       	ldi	r24, 0xFF	; 255
    509e:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    50a2:	f4 cc       	rjmp	.-1560   	; 0x4a8c <main+0x66a>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    50a4:	0e 94 4c 20 	call	0x4098	; 0x4098 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    50a8:	8f ef       	ldi	r24, 0xFF	; 255
    50aa:	0e 94 51 20 	call	0x40a2	; 0x40a2 <TransferSdByte>
    50ae:	fe cd       	rjmp	.-1028   	; 0x4cac <main+0x88a>
						sdAbortRead=false;
					}
				}
				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
				{
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
    50b0:	10 92 59 05 	sts	0x0559, r1
    50b4:	c7 cf       	rjmp	.-114    	; 0x5044 <main+0xc22>

000050b6 <__udivmodqi4>:
    50b6:	99 1b       	sub	r25, r25
    50b8:	79 e0       	ldi	r23, 0x09	; 9
    50ba:	04 c0       	rjmp	.+8      	; 0x50c4 <__udivmodqi4_ep>

000050bc <__udivmodqi4_loop>:
    50bc:	99 1f       	adc	r25, r25
    50be:	96 17       	cp	r25, r22
    50c0:	08 f0       	brcs	.+2      	; 0x50c4 <__udivmodqi4_ep>
    50c2:	96 1b       	sub	r25, r22

000050c4 <__udivmodqi4_ep>:
    50c4:	88 1f       	adc	r24, r24
    50c6:	7a 95       	dec	r23
    50c8:	c9 f7       	brne	.-14     	; 0x50bc <__udivmodqi4_loop>
    50ca:	80 95       	com	r24
    50cc:	08 95       	ret

000050ce <__udivmodsi4>:
    50ce:	a1 e2       	ldi	r26, 0x21	; 33
    50d0:	1a 2e       	mov	r1, r26
    50d2:	aa 1b       	sub	r26, r26
    50d4:	bb 1b       	sub	r27, r27
    50d6:	fd 01       	movw	r30, r26
    50d8:	0d c0       	rjmp	.+26     	; 0x50f4 <__udivmodsi4_ep>

000050da <__udivmodsi4_loop>:
    50da:	aa 1f       	adc	r26, r26
    50dc:	bb 1f       	adc	r27, r27
    50de:	ee 1f       	adc	r30, r30
    50e0:	ff 1f       	adc	r31, r31
    50e2:	a2 17       	cp	r26, r18
    50e4:	b3 07       	cpc	r27, r19
    50e6:	e4 07       	cpc	r30, r20
    50e8:	f5 07       	cpc	r31, r21
    50ea:	20 f0       	brcs	.+8      	; 0x50f4 <__udivmodsi4_ep>
    50ec:	a2 1b       	sub	r26, r18
    50ee:	b3 0b       	sbc	r27, r19
    50f0:	e4 0b       	sbc	r30, r20
    50f2:	f5 0b       	sbc	r31, r21

000050f4 <__udivmodsi4_ep>:
    50f4:	66 1f       	adc	r22, r22
    50f6:	77 1f       	adc	r23, r23
    50f8:	88 1f       	adc	r24, r24
    50fa:	99 1f       	adc	r25, r25
    50fc:	1a 94       	dec	r1
    50fe:	69 f7       	brne	.-38     	; 0x50da <__udivmodsi4_loop>
    5100:	60 95       	com	r22
    5102:	70 95       	com	r23
    5104:	80 95       	com	r24
    5106:	90 95       	com	r25
    5108:	9b 01       	movw	r18, r22
    510a:	ac 01       	movw	r20, r24
    510c:	bd 01       	movw	r22, r26
    510e:	cf 01       	movw	r24, r30
    5110:	08 95       	ret

00005112 <__tablejump2__>:
    5112:	ee 0f       	add	r30, r30
    5114:	ff 1f       	adc	r31, r31

00005116 <__tablejump__>:
    5116:	05 90       	lpm	r0, Z+
    5118:	f4 91       	lpm	r31, Z
    511a:	e0 2d       	mov	r30, r0
    511c:	09 94       	ijmp

0000511e <__umulhisi3>:
    511e:	a2 9f       	mul	r26, r18
    5120:	b0 01       	movw	r22, r0
    5122:	b3 9f       	mul	r27, r19
    5124:	c0 01       	movw	r24, r0
    5126:	a3 9f       	mul	r26, r19
    5128:	01 d0       	rcall	.+2      	; 0x512c <__umulhisi3+0xe>
    512a:	b2 9f       	mul	r27, r18
    512c:	70 0d       	add	r23, r0
    512e:	81 1d       	adc	r24, r1
    5130:	11 24       	eor	r1, r1
    5132:	91 1d       	adc	r25, r1
    5134:	08 95       	ret

00005136 <__muluhisi3>:
    5136:	0e 94 8f 28 	call	0x511e	; 0x511e <__umulhisi3>
    513a:	a5 9f       	mul	r26, r21
    513c:	90 0d       	add	r25, r0
    513e:	b4 9f       	mul	r27, r20
    5140:	90 0d       	add	r25, r0
    5142:	a4 9f       	mul	r26, r20
    5144:	80 0d       	add	r24, r0
    5146:	91 1d       	adc	r25, r1
    5148:	11 24       	eor	r1, r1
    514a:	08 95       	ret

0000514c <_exit>:
    514c:	f8 94       	cli

0000514e <__stop_program>:
    514e:	ff cf       	rjmp	.-2      	; 0x514e <__stop_program>
