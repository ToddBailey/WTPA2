
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000051b0  00005244  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000051b0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000544  0080011e  0080011e  00005262  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005264  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00005930  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000059c7  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  000059f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004224  00000000  00000000  00005ad6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a4f  00000000  00000000  00009cfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f94  00000000  00000000  0000a749  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000888  00000000  00000000  0000b6e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000013a6  00000000  00000000  0000bf68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000024af  00000000  00000000  0000d30e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c8  00000000  00000000  0000f7bd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 7f 1a 	jmp	0x34fe	; 0x34fe <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 d2 1d 	jmp	0x3ba4	; 0x3ba4 <__vector_9>
      28:	0c 94 f1 1b 	jmp	0x37e2	; 0x37e2 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <__vector_12>
      34:	0c 94 c7 1a 	jmp	0x358e	; 0x358e <__vector_13>
      38:	0c 94 5c 1b 	jmp	0x36b8	; 0x36b8 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	66 17       	cp	r22, r22
      7e:	5b 19       	sub	r21, r11
      80:	5b 19       	sub	r21, r11
      82:	5b 19       	sub	r21, r11
      84:	5b 19       	sub	r21, r11
      86:	5b 19       	sub	r21, r11
      88:	85 17       	cp	r24, r21
      8a:	5b 19       	sub	r21, r11
      8c:	5b 19       	sub	r21, r11
      8e:	5b 19       	sub	r21, r11
      90:	5b 19       	sub	r21, r11
      92:	c2 17       	cp	r28, r18
      94:	ee 17       	cp	r30, r30
      96:	05 18       	sub	r0, r5
      98:	1c 18       	sub	r1, r12
      9a:	35 18       	sub	r3, r5
      9c:	4c 18       	sub	r4, r12
      9e:	5b 18       	sub	r5, r11
      a0:	62 18       	sub	r6, r2
      a2:	6e 18       	sub	r6, r14
      a4:	89 18       	sub	r8, r9
      a6:	b9 18       	sub	r11, r9
      a8:	c2 18       	sub	r12, r2
      aa:	cb 18       	sub	r12, r11
      ac:	d4 18       	sub	r13, r4
      ae:	d9 18       	sub	r13, r9
      b0:	e6 18       	sub	r14, r6
      b2:	f3 18       	sub	r15, r3

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e0 eb       	ldi	r30, 0xB0	; 176
      c8:	f1 e5       	ldi	r31, 0x51	; 81
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	26 e0       	ldi	r18, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a2 36       	cpi	r26, 0x62	; 98
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 42 22 	call	0x4484	; 0x4484 <main>
      ea:	0c 94 d6 28 	jmp	0x51ac	; 0x51ac <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 ed 1d 	jmp	0x3bda	; 0x3bda <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 e6 05 	lds	r24, 0x05E6
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c1 f0       	breq	.+48     	; 0x12a <UpdateAudioChannel0+0x38>
      fa:	30 f4       	brcc	.+12     	; 0x108 <UpdateAudioChannel0+0x16>
      fc:	81 30       	cpi	r24, 0x01	; 1
      fe:	59 f0       	breq	.+22     	; 0x116 <UpdateAudioChannel0+0x24>
     100:	82 30       	cpi	r24, 0x02	; 2
     102:	09 f0       	breq	.+2      	; 0x106 <UpdateAudioChannel0+0x14>
     104:	a2 c3       	rjmp	.+1860   	; 0x84a <UpdateAudioChannel0+0x758>
     106:	0e c0       	rjmp	.+28     	; 0x124 <UpdateAudioChannel0+0x32>
     108:	84 30       	cpi	r24, 0x04	; 4
     10a:	09 f4       	brne	.+2      	; 0x10e <UpdateAudioChannel0+0x1c>
     10c:	8e c0       	rjmp	.+284    	; 0x22a <UpdateAudioChannel0+0x138>
     10e:	85 30       	cpi	r24, 0x05	; 5
     110:	09 f0       	breq	.+2      	; 0x114 <UpdateAudioChannel0+0x22>
     112:	9b c3       	rjmp	.+1846   	; 0x84a <UpdateAudioChannel0+0x758>
     114:	07 c2       	rjmp	.+1038   	; 0x524 <UpdateAudioChannel0+0x432>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     116:	80 91 43 04 	lds	r24, 0x0443
     11a:	98 2f       	mov	r25, r24
     11c:	9f 5f       	subi	r25, 0xFF	; 255
     11e:	90 93 43 04 	sts	0x0443, r25
		break;
     122:	08 95       	ret

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     124:	80 91 2c 04 	lds	r24, 0x042C
     128:	eb c1       	rjmp	.+982    	; 0x500 <UpdateAudioChannel0+0x40e>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12a:	8f ef       	ldi	r24, 0xFF	; 255
     12c:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     12e:	80 91 05 06 	lds	r24, 0x0605
     132:	90 91 06 06 	lds	r25, 0x0606
     136:	a0 91 07 06 	lds	r26, 0x0607
     13a:	b0 91 08 06 	lds	r27, 0x0608
     13e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     140:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     142:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     144:	80 91 05 06 	lds	r24, 0x0605
     148:	90 91 06 06 	lds	r25, 0x0606
     14c:	a0 91 07 06 	lds	r26, 0x0607
     150:	b0 91 08 06 	lds	r27, 0x0608
     154:	89 2f       	mov	r24, r25
     156:	9a 2f       	mov	r25, r26
     158:	ab 2f       	mov	r26, r27
     15a:	bb 27       	eor	r27, r27
     15c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     15e:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     160:	14 98       	cbi	0x02, 4	; 2
		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     162:	80 91 05 06 	lds	r24, 0x0605
     166:	90 91 06 06 	lds	r25, 0x0606
     16a:	a0 91 07 06 	lds	r26, 0x0607
     16e:	b0 91 08 06 	lds	r27, 0x0608
     172:	cd 01       	movw	r24, r26
     174:	aa 27       	eor	r26, r26
     176:	bb 27       	eor	r27, r27
     178:	87 70       	andi	r24, 0x07	; 7
     17a:	99 27       	eor	r25, r25
     17c:	aa 27       	eor	r26, r26
     17e:	bb 27       	eor	r27, r27
     180:	88 68       	ori	r24, 0x88	; 136
     182:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     184:	80 91 2c 04 	lds	r24, 0x042C
     188:	85 b9       	out	0x05, r24	; 5
		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     18a:	80 91 05 06 	lds	r24, 0x0605
     18e:	90 91 06 06 	lds	r25, 0x0606
     192:	a0 91 07 06 	lds	r26, 0x0607
     196:	b0 91 08 06 	lds	r27, 0x0608
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	a1 1d       	adc	r26, r1
     19e:	b1 1d       	adc	r27, r1
     1a0:	80 93 05 06 	sts	0x0605, r24
     1a4:	90 93 06 06 	sts	0x0606, r25
     1a8:	a0 93 07 06 	sts	0x0607, r26
     1ac:	b0 93 08 06 	sts	0x0608, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1b0:	80 91 05 06 	lds	r24, 0x0605
     1b4:	90 91 06 06 	lds	r25, 0x0606
     1b8:	a0 91 07 06 	lds	r26, 0x0607
     1bc:	b0 91 08 06 	lds	r27, 0x0608
     1c0:	80 93 f2 05 	sts	0x05F2, r24
     1c4:	90 93 f3 05 	sts	0x05F3, r25
     1c8:	a0 93 f4 05 	sts	0x05F4, r26
     1cc:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1d0:	80 91 05 06 	lds	r24, 0x0605
     1d4:	90 91 06 06 	lds	r25, 0x0606
     1d8:	a0 91 07 06 	lds	r26, 0x0607
     1dc:	b0 91 08 06 	lds	r27, 0x0608
     1e0:	80 93 fa 05 	sts	0x05FA, r24
     1e4:	90 93 fb 05 	sts	0x05FB, r25
     1e8:	a0 93 fc 05 	sts	0x05FC, r26
     1ec:	b0 93 fd 05 	sts	0x05FD, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1f0:	40 91 f2 05 	lds	r20, 0x05F2
     1f4:	50 91 f3 05 	lds	r21, 0x05F3
     1f8:	60 91 f4 05 	lds	r22, 0x05F4
     1fc:	70 91 f5 05 	lds	r23, 0x05F5
     200:	80 91 15 06 	lds	r24, 0x0615
     204:	90 91 16 06 	lds	r25, 0x0616
     208:	a0 91 17 06 	lds	r26, 0x0617
     20c:	b0 91 18 06 	lds	r27, 0x0618
     210:	48 17       	cp	r20, r24
     212:	59 07       	cpc	r21, r25
     214:	6a 07       	cpc	r22, r26
     216:	7b 07       	cpc	r23, r27
     218:	28 f0       	brcs	.+10     	; 0x224 <UpdateAudioChannel0+0x132>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     21a:	10 92 e6 05 	sts	0x05E6, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	80 93 3f 04 	sts	0x043F, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     224:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     226:	11 9a       	sbi	0x02, 1	; 2
     228:	10 c3       	rjmp	.+1568   	; 0x84a <UpdateAudioChannel0+0x758>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     22a:	80 91 05 06 	lds	r24, 0x0605
     22e:	90 91 06 06 	lds	r25, 0x0606
     232:	a0 91 07 06 	lds	r26, 0x0607
     236:	b0 91 08 06 	lds	r27, 0x0608
     23a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     240:	80 91 05 06 	lds	r24, 0x0605
     244:	90 91 06 06 	lds	r25, 0x0606
     248:	a0 91 07 06 	lds	r26, 0x0607
     24c:	b0 91 08 06 	lds	r27, 0x0608
     250:	89 2f       	mov	r24, r25
     252:	9a 2f       	mov	r25, r26
     254:	ab 2f       	mov	r26, r27
     256:	bb 27       	eor	r27, r27
     258:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     25a:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25c:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25e:	80 91 05 06 	lds	r24, 0x0605
     262:	90 91 06 06 	lds	r25, 0x0606
     266:	a0 91 07 06 	lds	r26, 0x0607
     26a:	b0 91 08 06 	lds	r27, 0x0608
     26e:	cd 01       	movw	r24, r26
     270:	aa 27       	eor	r26, r26
     272:	bb 27       	eor	r27, r27
     274:	87 70       	andi	r24, 0x07	; 7
     276:	99 27       	eor	r25, r25
     278:	aa 27       	eor	r26, r26
     27a:	bb 27       	eor	r27, r27
     27c:	88 68       	ori	r24, 0x88	; 136
     27e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     280:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     282:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     284:	80 91 ec 05 	lds	r24, 0x05EC
     288:	88 23       	and	r24, r24
     28a:	09 f4       	brne	.+2      	; 0x28e <UpdateAudioChannel0+0x19c>
     28c:	6a c0       	rjmp	.+212    	; 0x362 <UpdateAudioChannel0+0x270>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     28e:	80 91 2d 04 	lds	r24, 0x042D
     292:	90 91 2e 04 	lds	r25, 0x042E
     296:	a0 91 2f 04 	lds	r26, 0x042F
     29a:	b0 91 30 04 	lds	r27, 0x0430
     29e:	89 2b       	or	r24, r25
     2a0:	8a 2b       	or	r24, r26
     2a2:	8b 2b       	or	r24, r27
     2a4:	39 f1       	breq	.+78     	; 0x2f4 <UpdateAudioChannel0+0x202>
			{
				bankStates[BANK_0].currentAddress++;
     2a6:	80 91 05 06 	lds	r24, 0x0605
     2aa:	90 91 06 06 	lds	r25, 0x0606
     2ae:	a0 91 07 06 	lds	r26, 0x0607
     2b2:	b0 91 08 06 	lds	r27, 0x0608
     2b6:	01 96       	adiw	r24, 0x01	; 1
     2b8:	a1 1d       	adc	r26, r1
     2ba:	b1 1d       	adc	r27, r1
     2bc:	80 93 05 06 	sts	0x0605, r24
     2c0:	90 93 06 06 	sts	0x0606, r25
     2c4:	a0 93 07 06 	sts	0x0607, r26
     2c8:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     2cc:	80 91 2d 04 	lds	r24, 0x042D
     2d0:	90 91 2e 04 	lds	r25, 0x042E
     2d4:	a0 91 2f 04 	lds	r26, 0x042F
     2d8:	b0 91 30 04 	lds	r27, 0x0430
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	a1 09       	sbc	r26, r1
     2e0:	b1 09       	sbc	r27, r1
     2e2:	80 93 2d 04 	sts	0x042D, r24
     2e6:	90 93 2e 04 	sts	0x042E, r25
     2ea:	a0 93 2f 04 	sts	0x042F, r26
     2ee:	b0 93 30 04 	sts	0x0430, r27
     2f2:	02 c1       	rjmp	.+516    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2f4:	80 91 35 04 	lds	r24, 0x0435
     2f8:	90 91 36 04 	lds	r25, 0x0436
     2fc:	a0 91 37 04 	lds	r26, 0x0437
     300:	b0 91 38 04 	lds	r27, 0x0438
     304:	80 93 2d 04 	sts	0x042D, r24
     308:	90 93 2e 04 	sts	0x042E, r25
     30c:	a0 93 2f 04 	sts	0x042F, r26
     310:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     314:	80 91 3d 04 	lds	r24, 0x043D
     318:	8f 5f       	subi	r24, 0xFF	; 255
     31a:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     31e:	90 91 3d 04 	lds	r25, 0x043D
     322:	80 91 ec 05 	lds	r24, 0x05EC
     326:	98 13       	cpse	r25, r24
     328:	02 c0       	rjmp	.+4      	; 0x32e <UpdateAudioChannel0+0x23c>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     32a:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     32e:	e0 91 3d 04 	lds	r30, 0x043D
     332:	20 91 35 04 	lds	r18, 0x0435
     336:	30 91 36 04 	lds	r19, 0x0436
     33a:	40 91 37 04 	lds	r20, 0x0437
     33e:	50 91 38 04 	lds	r21, 0x0438
     342:	f0 e0       	ldi	r31, 0x00	; 0
     344:	ec 5b       	subi	r30, 0xBC	; 188
     346:	fb 4f       	sbci	r31, 0xFB	; 251
     348:	a0 81       	ld	r26, Z
     34a:	b0 e0       	ldi	r27, 0x00	; 0
     34c:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
     350:	60 93 05 06 	sts	0x0605, r22
     354:	70 93 06 06 	sts	0x0606, r23
     358:	80 93 07 06 	sts	0x0607, r24
     35c:	90 93 08 06 	sts	0x0608, r25
     360:	cb c0       	rjmp	.+406    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     362:	80 91 ea 05 	lds	r24, 0x05EA
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     366:	40 91 05 06 	lds	r20, 0x0605
     36a:	50 91 06 06 	lds	r21, 0x0606
     36e:	60 91 07 06 	lds	r22, 0x0607
     372:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     376:	81 11       	cpse	r24, r1
     378:	5a c0       	rjmp	.+180    	; 0x42e <UpdateAudioChannel0+0x33c>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     37a:	80 91 fe 05 	lds	r24, 0x05FE
     37e:	90 91 ff 05 	lds	r25, 0x05FF
     382:	a0 91 00 06 	lds	r26, 0x0600
     386:	b0 91 01 06 	lds	r27, 0x0601
     38a:	48 17       	cp	r20, r24
     38c:	59 07       	cpc	r21, r25
     38e:	6a 07       	cpc	r22, r26
     390:	7b 07       	cpc	r23, r27
     392:	29 f4       	brne	.+10     	; 0x39e <UpdateAudioChannel0+0x2ac>
     394:	80 91 e7 05 	lds	r24, 0x05E7
     398:	81 30       	cpi	r24, 0x01	; 1
     39a:	09 f4       	brne	.+2      	; 0x39e <UpdateAudioChannel0+0x2ac>
     39c:	59 c0       	rjmp	.+178    	; 0x450 <UpdateAudioChannel0+0x35e>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39e:	40 91 05 06 	lds	r20, 0x0605
     3a2:	50 91 06 06 	lds	r21, 0x0606
     3a6:	60 91 07 06 	lds	r22, 0x0607
     3aa:	70 91 08 06 	lds	r23, 0x0608
     3ae:	80 91 fe 05 	lds	r24, 0x05FE
     3b2:	90 91 ff 05 	lds	r25, 0x05FF
     3b6:	a0 91 00 06 	lds	r26, 0x0600
     3ba:	b0 91 01 06 	lds	r27, 0x0601
     3be:	48 17       	cp	r20, r24
     3c0:	59 07       	cpc	r21, r25
     3c2:	6a 07       	cpc	r22, r26
     3c4:	7b 07       	cpc	r23, r27
     3c6:	49 f4       	brne	.+18     	; 0x3da <UpdateAudioChannel0+0x2e8>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c8:	80 91 fa 05 	lds	r24, 0x05FA
     3cc:	90 91 fb 05 	lds	r25, 0x05FB
     3d0:	a0 91 fc 05 	lds	r26, 0x05FC
     3d4:	b0 91 fd 05 	lds	r27, 0x05FD
     3d8:	87 c0       	rjmp	.+270    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3da:	40 91 05 06 	lds	r20, 0x0605
     3de:	50 91 06 06 	lds	r21, 0x0606
     3e2:	60 91 07 06 	lds	r22, 0x0607
     3e6:	70 91 08 06 	lds	r23, 0x0608
     3ea:	80 91 f6 05 	lds	r24, 0x05F6
     3ee:	90 91 f7 05 	lds	r25, 0x05F7
     3f2:	a0 91 f8 05 	lds	r26, 0x05F8
     3f6:	b0 91 f9 05 	lds	r27, 0x05F9
     3fa:	48 17       	cp	r20, r24
     3fc:	59 07       	cpc	r21, r25
     3fe:	6a 07       	cpc	r22, r26
     400:	7b 07       	cpc	r23, r27
     402:	49 f4       	brne	.+18     	; 0x416 <UpdateAudioChannel0+0x324>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     404:	80 91 f2 05 	lds	r24, 0x05F2
     408:	90 91 f3 05 	lds	r25, 0x05F3
     40c:	a0 91 f4 05 	lds	r26, 0x05F4
     410:	b0 91 f5 05 	lds	r27, 0x05F5
     414:	69 c0       	rjmp	.+210    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     416:	80 91 05 06 	lds	r24, 0x0605
     41a:	90 91 06 06 	lds	r25, 0x0606
     41e:	a0 91 07 06 	lds	r26, 0x0607
     422:	b0 91 08 06 	lds	r27, 0x0608
     426:	01 97       	sbiw	r24, 0x01	; 1
     428:	a1 09       	sbc	r26, r1
     42a:	b1 09       	sbc	r27, r1
     42c:	5d c0       	rjmp	.+186    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42e:	80 91 fa 05 	lds	r24, 0x05FA
     432:	90 91 fb 05 	lds	r25, 0x05FB
     436:	a0 91 fc 05 	lds	r26, 0x05FC
     43a:	b0 91 fd 05 	lds	r27, 0x05FD
     43e:	48 17       	cp	r20, r24
     440:	59 07       	cpc	r21, r25
     442:	6a 07       	cpc	r22, r26
     444:	7b 07       	cpc	r23, r27
     446:	49 f4       	brne	.+18     	; 0x45a <UpdateAudioChannel0+0x368>
     448:	80 91 e7 05 	lds	r24, 0x05E7
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	29 f4       	brne	.+10     	; 0x45a <UpdateAudioChannel0+0x368>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     450:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     454:	10 92 ef 05 	sts	0x05EF, r1
     458:	4f c0       	rjmp	.+158    	; 0x4f8 <UpdateAudioChannel0+0x406>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     45a:	40 91 05 06 	lds	r20, 0x0605
     45e:	50 91 06 06 	lds	r21, 0x0606
     462:	60 91 07 06 	lds	r22, 0x0607
     466:	70 91 08 06 	lds	r23, 0x0608
     46a:	80 91 fa 05 	lds	r24, 0x05FA
     46e:	90 91 fb 05 	lds	r25, 0x05FB
     472:	a0 91 fc 05 	lds	r26, 0x05FC
     476:	b0 91 fd 05 	lds	r27, 0x05FD
     47a:	48 17       	cp	r20, r24
     47c:	59 07       	cpc	r21, r25
     47e:	6a 07       	cpc	r22, r26
     480:	7b 07       	cpc	r23, r27
     482:	49 f4       	brne	.+18     	; 0x496 <UpdateAudioChannel0+0x3a4>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     484:	80 91 fe 05 	lds	r24, 0x05FE
     488:	90 91 ff 05 	lds	r25, 0x05FF
     48c:	a0 91 00 06 	lds	r26, 0x0600
     490:	b0 91 01 06 	lds	r27, 0x0601
     494:	29 c0       	rjmp	.+82     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     496:	40 91 05 06 	lds	r20, 0x0605
     49a:	50 91 06 06 	lds	r21, 0x0606
     49e:	60 91 07 06 	lds	r22, 0x0607
     4a2:	70 91 08 06 	lds	r23, 0x0608
     4a6:	80 91 f2 05 	lds	r24, 0x05F2
     4aa:	90 91 f3 05 	lds	r25, 0x05F3
     4ae:	a0 91 f4 05 	lds	r26, 0x05F4
     4b2:	b0 91 f5 05 	lds	r27, 0x05F5
     4b6:	48 17       	cp	r20, r24
     4b8:	59 07       	cpc	r21, r25
     4ba:	6a 07       	cpc	r22, r26
     4bc:	7b 07       	cpc	r23, r27
     4be:	49 f4       	brne	.+18     	; 0x4d2 <UpdateAudioChannel0+0x3e0>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4c0:	80 91 f6 05 	lds	r24, 0x05F6
     4c4:	90 91 f7 05 	lds	r25, 0x05F7
     4c8:	a0 91 f8 05 	lds	r26, 0x05F8
     4cc:	b0 91 f9 05 	lds	r27, 0x05F9
     4d0:	0b c0       	rjmp	.+22     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4d2:	80 91 05 06 	lds	r24, 0x0605
     4d6:	90 91 06 06 	lds	r25, 0x0606
     4da:	a0 91 07 06 	lds	r26, 0x0607
     4de:	b0 91 08 06 	lds	r27, 0x0608
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	a1 1d       	adc	r26, r1
     4e6:	b1 1d       	adc	r27, r1
     4e8:	80 93 05 06 	sts	0x0605, r24
     4ec:	90 93 06 06 	sts	0x0606, r25
     4f0:	a0 93 07 06 	sts	0x0607, r26
     4f4:	b0 93 08 06 	sts	0x0608, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     4f8:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     4fa:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     4fc:	9f ef       	ldi	r25, 0xFF	; 255
     4fe:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     500:	90 91 ee 05 	lds	r25, 0x05EE
     504:	99 23       	and	r25, r25
     506:	09 f4       	brne	.+2      	; 0x50a <UpdateAudioChannel0+0x418>
     508:	a1 c1       	rjmp	.+834    	; 0x84c <UpdateAudioChannel0+0x75a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     50a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     50c:	90 91 ee 05 	lds	r25, 0x05EE
     510:	2f ef       	ldi	r18, 0xFF	; 255
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	09 2e       	mov	r0, r25
     516:	01 c0       	rjmp	.+2      	; 0x51a <UpdateAudioChannel0+0x428>
     518:	22 0f       	add	r18, r18
     51a:	0a 94       	dec	r0
     51c:	ea f7       	brpl	.-6      	; 0x518 <UpdateAudioChannel0+0x426>
     51e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     520:	80 58       	subi	r24, 0x80	; 128
     522:	08 95       	ret
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     524:	80 91 05 06 	lds	r24, 0x0605
     528:	90 91 06 06 	lds	r25, 0x0606
     52c:	a0 91 07 06 	lds	r26, 0x0607
     530:	b0 91 08 06 	lds	r27, 0x0608
     534:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     536:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     538:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     53a:	80 91 05 06 	lds	r24, 0x0605
     53e:	90 91 06 06 	lds	r25, 0x0606
     542:	a0 91 07 06 	lds	r26, 0x0607
     546:	b0 91 08 06 	lds	r27, 0x0608
     54a:	89 2f       	mov	r24, r25
     54c:	9a 2f       	mov	r25, r26
     54e:	ab 2f       	mov	r26, r27
     550:	bb 27       	eor	r27, r27
     552:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     554:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     556:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     558:	80 91 05 06 	lds	r24, 0x0605
     55c:	90 91 06 06 	lds	r25, 0x0606
     560:	a0 91 07 06 	lds	r26, 0x0607
     564:	b0 91 08 06 	lds	r27, 0x0608
     568:	cd 01       	movw	r24, r26
     56a:	aa 27       	eor	r26, r26
     56c:	bb 27       	eor	r27, r27
     56e:	87 70       	andi	r24, 0x07	; 7
     570:	99 27       	eor	r25, r25
     572:	aa 27       	eor	r26, r26
     574:	bb 27       	eor	r27, r27
     576:	88 68       	ori	r24, 0x88	; 136
     578:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     57a:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     57c:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     57e:	80 91 ec 05 	lds	r24, 0x05EC
     582:	88 23       	and	r24, r24
     584:	09 f4       	brne	.+2      	; 0x588 <UpdateAudioChannel0+0x496>
     586:	6a c0       	rjmp	.+212    	; 0x65c <UpdateAudioChannel0+0x56a>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     588:	80 91 2d 04 	lds	r24, 0x042D
     58c:	90 91 2e 04 	lds	r25, 0x042E
     590:	a0 91 2f 04 	lds	r26, 0x042F
     594:	b0 91 30 04 	lds	r27, 0x0430
     598:	89 2b       	or	r24, r25
     59a:	8a 2b       	or	r24, r26
     59c:	8b 2b       	or	r24, r27
     59e:	39 f1       	breq	.+78     	; 0x5ee <UpdateAudioChannel0+0x4fc>
			{
				bankStates[BANK_0].currentAddress++;
     5a0:	80 91 05 06 	lds	r24, 0x0605
     5a4:	90 91 06 06 	lds	r25, 0x0606
     5a8:	a0 91 07 06 	lds	r26, 0x0607
     5ac:	b0 91 08 06 	lds	r27, 0x0608
     5b0:	01 96       	adiw	r24, 0x01	; 1
     5b2:	a1 1d       	adc	r26, r1
     5b4:	b1 1d       	adc	r27, r1
     5b6:	80 93 05 06 	sts	0x0605, r24
     5ba:	90 93 06 06 	sts	0x0606, r25
     5be:	a0 93 07 06 	sts	0x0607, r26
     5c2:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     5c6:	80 91 2d 04 	lds	r24, 0x042D
     5ca:	90 91 2e 04 	lds	r25, 0x042E
     5ce:	a0 91 2f 04 	lds	r26, 0x042F
     5d2:	b0 91 30 04 	lds	r27, 0x0430
     5d6:	01 97       	sbiw	r24, 0x01	; 1
     5d8:	a1 09       	sbc	r26, r1
     5da:	b1 09       	sbc	r27, r1
     5dc:	80 93 2d 04 	sts	0x042D, r24
     5e0:	90 93 2e 04 	sts	0x042E, r25
     5e4:	a0 93 2f 04 	sts	0x042F, r26
     5e8:	b0 93 30 04 	sts	0x0430, r27
     5ec:	02 c1       	rjmp	.+516    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5ee:	80 91 35 04 	lds	r24, 0x0435
     5f2:	90 91 36 04 	lds	r25, 0x0436
     5f6:	a0 91 37 04 	lds	r26, 0x0437
     5fa:	b0 91 38 04 	lds	r27, 0x0438
     5fe:	80 93 2d 04 	sts	0x042D, r24
     602:	90 93 2e 04 	sts	0x042E, r25
     606:	a0 93 2f 04 	sts	0x042F, r26
     60a:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     60e:	80 91 3d 04 	lds	r24, 0x043D
     612:	8f 5f       	subi	r24, 0xFF	; 255
     614:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     618:	90 91 3d 04 	lds	r25, 0x043D
     61c:	80 91 ec 05 	lds	r24, 0x05EC
     620:	98 13       	cpse	r25, r24
     622:	02 c0       	rjmp	.+4      	; 0x628 <UpdateAudioChannel0+0x536>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     624:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     628:	e0 91 3d 04 	lds	r30, 0x043D
     62c:	20 91 35 04 	lds	r18, 0x0435
     630:	30 91 36 04 	lds	r19, 0x0436
     634:	40 91 37 04 	lds	r20, 0x0437
     638:	50 91 38 04 	lds	r21, 0x0438
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 5b       	subi	r30, 0xBC	; 188
     640:	fb 4f       	sbci	r31, 0xFB	; 251
     642:	a0 81       	ld	r26, Z
     644:	b0 e0       	ldi	r27, 0x00	; 0
     646:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
     64a:	60 93 05 06 	sts	0x0605, r22
     64e:	70 93 06 06 	sts	0x0606, r23
     652:	80 93 07 06 	sts	0x0607, r24
     656:	90 93 08 06 	sts	0x0608, r25
     65a:	cb c0       	rjmp	.+406    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     65c:	80 91 ea 05 	lds	r24, 0x05EA
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     660:	40 91 05 06 	lds	r20, 0x0605
     664:	50 91 06 06 	lds	r21, 0x0606
     668:	60 91 07 06 	lds	r22, 0x0607
     66c:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     670:	81 11       	cpse	r24, r1
     672:	5a c0       	rjmp	.+180    	; 0x728 <UpdateAudioChannel0+0x636>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     674:	80 91 fe 05 	lds	r24, 0x05FE
     678:	90 91 ff 05 	lds	r25, 0x05FF
     67c:	a0 91 00 06 	lds	r26, 0x0600
     680:	b0 91 01 06 	lds	r27, 0x0601
     684:	48 17       	cp	r20, r24
     686:	59 07       	cpc	r21, r25
     688:	6a 07       	cpc	r22, r26
     68a:	7b 07       	cpc	r23, r27
     68c:	29 f4       	brne	.+10     	; 0x698 <UpdateAudioChannel0+0x5a6>
     68e:	80 91 e7 05 	lds	r24, 0x05E7
     692:	81 30       	cpi	r24, 0x01	; 1
     694:	09 f4       	brne	.+2      	; 0x698 <UpdateAudioChannel0+0x5a6>
     696:	59 c0       	rjmp	.+178    	; 0x74a <UpdateAudioChannel0+0x658>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     698:	40 91 05 06 	lds	r20, 0x0605
     69c:	50 91 06 06 	lds	r21, 0x0606
     6a0:	60 91 07 06 	lds	r22, 0x0607
     6a4:	70 91 08 06 	lds	r23, 0x0608
     6a8:	80 91 fe 05 	lds	r24, 0x05FE
     6ac:	90 91 ff 05 	lds	r25, 0x05FF
     6b0:	a0 91 00 06 	lds	r26, 0x0600
     6b4:	b0 91 01 06 	lds	r27, 0x0601
     6b8:	48 17       	cp	r20, r24
     6ba:	59 07       	cpc	r21, r25
     6bc:	6a 07       	cpc	r22, r26
     6be:	7b 07       	cpc	r23, r27
     6c0:	49 f4       	brne	.+18     	; 0x6d4 <UpdateAudioChannel0+0x5e2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6c2:	80 91 fa 05 	lds	r24, 0x05FA
     6c6:	90 91 fb 05 	lds	r25, 0x05FB
     6ca:	a0 91 fc 05 	lds	r26, 0x05FC
     6ce:	b0 91 fd 05 	lds	r27, 0x05FD
     6d2:	87 c0       	rjmp	.+270    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6d4:	40 91 05 06 	lds	r20, 0x0605
     6d8:	50 91 06 06 	lds	r21, 0x0606
     6dc:	60 91 07 06 	lds	r22, 0x0607
     6e0:	70 91 08 06 	lds	r23, 0x0608
     6e4:	80 91 f6 05 	lds	r24, 0x05F6
     6e8:	90 91 f7 05 	lds	r25, 0x05F7
     6ec:	a0 91 f8 05 	lds	r26, 0x05F8
     6f0:	b0 91 f9 05 	lds	r27, 0x05F9
     6f4:	48 17       	cp	r20, r24
     6f6:	59 07       	cpc	r21, r25
     6f8:	6a 07       	cpc	r22, r26
     6fa:	7b 07       	cpc	r23, r27
     6fc:	49 f4       	brne	.+18     	; 0x710 <UpdateAudioChannel0+0x61e>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     6fe:	80 91 f2 05 	lds	r24, 0x05F2
     702:	90 91 f3 05 	lds	r25, 0x05F3
     706:	a0 91 f4 05 	lds	r26, 0x05F4
     70a:	b0 91 f5 05 	lds	r27, 0x05F5
     70e:	69 c0       	rjmp	.+210    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     710:	80 91 05 06 	lds	r24, 0x0605
     714:	90 91 06 06 	lds	r25, 0x0606
     718:	a0 91 07 06 	lds	r26, 0x0607
     71c:	b0 91 08 06 	lds	r27, 0x0608
     720:	01 97       	sbiw	r24, 0x01	; 1
     722:	a1 09       	sbc	r26, r1
     724:	b1 09       	sbc	r27, r1
     726:	5d c0       	rjmp	.+186    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     728:	80 91 fa 05 	lds	r24, 0x05FA
     72c:	90 91 fb 05 	lds	r25, 0x05FB
     730:	a0 91 fc 05 	lds	r26, 0x05FC
     734:	b0 91 fd 05 	lds	r27, 0x05FD
     738:	48 17       	cp	r20, r24
     73a:	59 07       	cpc	r21, r25
     73c:	6a 07       	cpc	r22, r26
     73e:	7b 07       	cpc	r23, r27
     740:	49 f4       	brne	.+18     	; 0x754 <UpdateAudioChannel0+0x662>
     742:	80 91 e7 05 	lds	r24, 0x05E7
     746:	81 30       	cpi	r24, 0x01	; 1
     748:	29 f4       	brne	.+10     	; 0x754 <UpdateAudioChannel0+0x662>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     74a:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     74e:	10 92 ef 05 	sts	0x05EF, r1
     752:	4f c0       	rjmp	.+158    	; 0x7f2 <UpdateAudioChannel0+0x700>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     754:	40 91 05 06 	lds	r20, 0x0605
     758:	50 91 06 06 	lds	r21, 0x0606
     75c:	60 91 07 06 	lds	r22, 0x0607
     760:	70 91 08 06 	lds	r23, 0x0608
     764:	80 91 fa 05 	lds	r24, 0x05FA
     768:	90 91 fb 05 	lds	r25, 0x05FB
     76c:	a0 91 fc 05 	lds	r26, 0x05FC
     770:	b0 91 fd 05 	lds	r27, 0x05FD
     774:	48 17       	cp	r20, r24
     776:	59 07       	cpc	r21, r25
     778:	6a 07       	cpc	r22, r26
     77a:	7b 07       	cpc	r23, r27
     77c:	49 f4       	brne	.+18     	; 0x790 <UpdateAudioChannel0+0x69e>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     77e:	80 91 fe 05 	lds	r24, 0x05FE
     782:	90 91 ff 05 	lds	r25, 0x05FF
     786:	a0 91 00 06 	lds	r26, 0x0600
     78a:	b0 91 01 06 	lds	r27, 0x0601
     78e:	29 c0       	rjmp	.+82     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     790:	40 91 05 06 	lds	r20, 0x0605
     794:	50 91 06 06 	lds	r21, 0x0606
     798:	60 91 07 06 	lds	r22, 0x0607
     79c:	70 91 08 06 	lds	r23, 0x0608
     7a0:	80 91 f2 05 	lds	r24, 0x05F2
     7a4:	90 91 f3 05 	lds	r25, 0x05F3
     7a8:	a0 91 f4 05 	lds	r26, 0x05F4
     7ac:	b0 91 f5 05 	lds	r27, 0x05F5
     7b0:	48 17       	cp	r20, r24
     7b2:	59 07       	cpc	r21, r25
     7b4:	6a 07       	cpc	r22, r26
     7b6:	7b 07       	cpc	r23, r27
     7b8:	49 f4       	brne	.+18     	; 0x7cc <UpdateAudioChannel0+0x6da>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7ba:	80 91 f6 05 	lds	r24, 0x05F6
     7be:	90 91 f7 05 	lds	r25, 0x05F7
     7c2:	a0 91 f8 05 	lds	r26, 0x05F8
     7c6:	b0 91 f9 05 	lds	r27, 0x05F9
     7ca:	0b c0       	rjmp	.+22     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7cc:	80 91 05 06 	lds	r24, 0x0605
     7d0:	90 91 06 06 	lds	r25, 0x0606
     7d4:	a0 91 07 06 	lds	r26, 0x0607
     7d8:	b0 91 08 06 	lds	r27, 0x0608
     7dc:	01 96       	adiw	r24, 0x01	; 1
     7de:	a1 1d       	adc	r26, r1
     7e0:	b1 1d       	adc	r27, r1
     7e2:	80 93 05 06 	sts	0x0605, r24
     7e6:	90 93 06 06 	sts	0x0606, r25
     7ea:	a0 93 07 06 	sts	0x0607, r26
     7ee:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     7f2:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     7f4:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     7f6:	9f ef       	ldi	r25, 0xFF	; 255
     7f8:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     7fa:	90 91 ee 05 	lds	r25, 0x05EE
     7fe:	99 23       	and	r25, r25
     800:	61 f0       	breq	.+24     	; 0x81a <UpdateAudioChannel0+0x728>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     802:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     804:	90 91 ee 05 	lds	r25, 0x05EE
     808:	2f ef       	ldi	r18, 0xFF	; 255
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	09 2e       	mov	r0, r25
     80e:	01 c0       	rjmp	.+2      	; 0x812 <UpdateAudioChannel0+0x720>
     810:	22 0f       	add	r18, r18
     812:	0a 94       	dec	r0
     814:	ea f7       	brpl	.-6      	; 0x810 <UpdateAudioChannel0+0x71e>
     816:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     818:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     81a:	20 91 2c 04 	lds	r18, 0x042C
     81e:	33 27       	eor	r19, r19
     820:	27 fd       	sbrc	r18, 7
     822:	30 95       	com	r19
     824:	28 0f       	add	r18, r24
     826:	31 1d       	adc	r19, r1
     828:	87 fd       	sbrc	r24, 7
     82a:	3a 95       	dec	r19
     82c:	20 38       	cpi	r18, 0x80	; 128
     82e:	9f ef       	ldi	r25, 0xFF	; 255
     830:	39 07       	cpc	r19, r25
     832:	14 f4       	brge	.+4      	; 0x838 <UpdateAudioChannel0+0x746>
     834:	20 e8       	ldi	r18, 0x80	; 128
     836:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     838:	20 38       	cpi	r18, 0x80	; 128
     83a:	31 05       	cpc	r19, r1
     83c:	14 f0       	brlt	.+4      	; 0x842 <UpdateAudioChannel0+0x750>
     83e:	2f e7       	ldi	r18, 0x7F	; 127
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     844:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     846:	11 9a       	sbi	0x02, 1	; 2
		break;
     848:	08 95       	ret
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     84a:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     84c:	08 95       	ret

0000084e <UpdateAudioChannel1>:

static unsigned char UpdateAudioChannel1(void)
// New banked idea of the audio handler -- ONE FOR EACH BANK!
{
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     852:	80 91 09 06 	lds	r24, 0x0609
     856:	83 30       	cpi	r24, 0x03	; 3
     858:	c1 f0       	breq	.+48     	; 0x88a <UpdateAudioChannel1+0x3c>
     85a:	30 f4       	brcc	.+12     	; 0x868 <UpdateAudioChannel1+0x1a>
     85c:	81 30       	cpi	r24, 0x01	; 1
     85e:	59 f0       	breq	.+22     	; 0x876 <UpdateAudioChannel1+0x28>
     860:	82 30       	cpi	r24, 0x02	; 2
     862:	09 f0       	breq	.+2      	; 0x866 <UpdateAudioChannel1+0x18>
     864:	b2 c3       	rjmp	.+1892   	; 0xfca <UpdateAudioChannel1+0x77c>
     866:	0e c0       	rjmp	.+28     	; 0x884 <UpdateAudioChannel1+0x36>
     868:	84 30       	cpi	r24, 0x04	; 4
     86a:	09 f4       	brne	.+2      	; 0x86e <UpdateAudioChannel1+0x20>
     86c:	8e c0       	rjmp	.+284    	; 0x98a <UpdateAudioChannel1+0x13c>
     86e:	85 30       	cpi	r24, 0x05	; 5
     870:	09 f0       	breq	.+2      	; 0x874 <UpdateAudioChannel1+0x26>
     872:	ab c3       	rjmp	.+1878   	; 0xfca <UpdateAudioChannel1+0x77c>
     874:	0f c2       	rjmp	.+1054   	; 0xc94 <UpdateAudioChannel1+0x446>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     876:	80 91 46 05 	lds	r24, 0x0546
     87a:	98 2f       	mov	r25, r24
     87c:	9f 5f       	subi	r25, 0xFF	; 255
     87e:	90 93 46 05 	sts	0x0546, r25
		break;
     882:	a4 c3       	rjmp	.+1864   	; 0xfcc <UpdateAudioChannel1+0x77e>

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     884:	80 91 2c 04 	lds	r24, 0x042C
     888:	f3 c1       	rjmp	.+998    	; 0xc70 <UpdateAudioChannel1+0x422>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     88e:	80 91 28 06 	lds	r24, 0x0628
     892:	90 91 29 06 	lds	r25, 0x0629
     896:	a0 91 2a 06 	lds	r26, 0x062A
     89a:	b0 91 2b 06 	lds	r27, 0x062B
     89e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8a0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8a2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8a4:	80 91 28 06 	lds	r24, 0x0628
     8a8:	90 91 29 06 	lds	r25, 0x0629
     8ac:	a0 91 2a 06 	lds	r26, 0x062A
     8b0:	b0 91 2b 06 	lds	r27, 0x062B
     8b4:	89 2f       	mov	r24, r25
     8b6:	9a 2f       	mov	r25, r26
     8b8:	ab 2f       	mov	r26, r27
     8ba:	bb 27       	eor	r27, r27
     8bc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8be:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8c0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8c2:	80 91 28 06 	lds	r24, 0x0628
     8c6:	90 91 29 06 	lds	r25, 0x0629
     8ca:	a0 91 2a 06 	lds	r26, 0x062A
     8ce:	b0 91 2b 06 	lds	r27, 0x062B
     8d2:	cd 01       	movw	r24, r26
     8d4:	aa 27       	eor	r26, r26
     8d6:	bb 27       	eor	r27, r27
     8d8:	87 70       	andi	r24, 0x07	; 7
     8da:	99 27       	eor	r25, r25
     8dc:	aa 27       	eor	r26, r26
     8de:	bb 27       	eor	r27, r27
     8e0:	88 68       	ori	r24, 0x88	; 136
     8e2:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8e4:	80 91 2c 04 	lds	r24, 0x042C
     8e8:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     8ea:	80 91 28 06 	lds	r24, 0x0628
     8ee:	90 91 29 06 	lds	r25, 0x0629
     8f2:	a0 91 2a 06 	lds	r26, 0x062A
     8f6:	b0 91 2b 06 	lds	r27, 0x062B
     8fa:	01 97       	sbiw	r24, 0x01	; 1
     8fc:	a1 09       	sbc	r26, r1
     8fe:	b1 09       	sbc	r27, r1
     900:	80 93 28 06 	sts	0x0628, r24
     904:	90 93 29 06 	sts	0x0629, r25
     908:	a0 93 2a 06 	sts	0x062A, r26
     90c:	b0 93 2b 06 	sts	0x062B, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     910:	80 91 28 06 	lds	r24, 0x0628
     914:	90 91 29 06 	lds	r25, 0x0629
     918:	a0 91 2a 06 	lds	r26, 0x062A
     91c:	b0 91 2b 06 	lds	r27, 0x062B
     920:	80 93 15 06 	sts	0x0615, r24
     924:	90 93 16 06 	sts	0x0616, r25
     928:	a0 93 17 06 	sts	0x0617, r26
     92c:	b0 93 18 06 	sts	0x0618, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     930:	80 91 28 06 	lds	r24, 0x0628
     934:	90 91 29 06 	lds	r25, 0x0629
     938:	a0 91 2a 06 	lds	r26, 0x062A
     93c:	b0 91 2b 06 	lds	r27, 0x062B
     940:	80 93 1d 06 	sts	0x061D, r24
     944:	90 93 1e 06 	sts	0x061E, r25
     948:	a0 93 1f 06 	sts	0x061F, r26
     94c:	b0 93 20 06 	sts	0x0620, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     950:	40 91 f2 05 	lds	r20, 0x05F2
     954:	50 91 f3 05 	lds	r21, 0x05F3
     958:	60 91 f4 05 	lds	r22, 0x05F4
     95c:	70 91 f5 05 	lds	r23, 0x05F5
     960:	80 91 15 06 	lds	r24, 0x0615
     964:	90 91 16 06 	lds	r25, 0x0616
     968:	a0 91 17 06 	lds	r26, 0x0617
     96c:	b0 91 18 06 	lds	r27, 0x0618
     970:	48 17       	cp	r20, r24
     972:	59 07       	cpc	r21, r25
     974:	6a 07       	cpc	r22, r26
     976:	7b 07       	cpc	r23, r27
     978:	28 f0       	brcs	.+10     	; 0x984 <UpdateAudioChannel1+0x136>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     97a:	10 92 09 06 	sts	0x0609, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	80 93 3f 04 	sts	0x043F, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     984:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     986:	11 9a       	sbi	0x02, 1	; 2
     988:	20 c3       	rjmp	.+1600   	; 0xfca <UpdateAudioChannel1+0x77c>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     98a:	80 91 28 06 	lds	r24, 0x0628
     98e:	90 91 29 06 	lds	r25, 0x0629
     992:	a0 91 2a 06 	lds	r26, 0x062A
     996:	b0 91 2b 06 	lds	r27, 0x062B
     99a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     99c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     99e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9a0:	80 91 28 06 	lds	r24, 0x0628
     9a4:	90 91 29 06 	lds	r25, 0x0629
     9a8:	a0 91 2a 06 	lds	r26, 0x062A
     9ac:	b0 91 2b 06 	lds	r27, 0x062B
     9b0:	89 2f       	mov	r24, r25
     9b2:	9a 2f       	mov	r25, r26
     9b4:	ab 2f       	mov	r26, r27
     9b6:	bb 27       	eor	r27, r27
     9b8:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9ba:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9bc:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9be:	80 91 28 06 	lds	r24, 0x0628
     9c2:	90 91 29 06 	lds	r25, 0x0629
     9c6:	a0 91 2a 06 	lds	r26, 0x062A
     9ca:	b0 91 2b 06 	lds	r27, 0x062B
     9ce:	cd 01       	movw	r24, r26
     9d0:	aa 27       	eor	r26, r26
     9d2:	bb 27       	eor	r27, r27
     9d4:	87 70       	andi	r24, 0x07	; 7
     9d6:	99 27       	eor	r25, r25
     9d8:	aa 27       	eor	r26, r26
     9da:	bb 27       	eor	r27, r27
     9dc:	88 68       	ori	r24, 0x88	; 136
     9de:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9e0:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9e2:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9e4:	80 91 0f 06 	lds	r24, 0x060F
     9e8:	88 23       	and	r24, r24
     9ea:	09 f4       	brne	.+2      	; 0x9ee <UpdateAudioChannel1+0x1a0>
     9ec:	72 c0       	rjmp	.+228    	; 0xad2 <UpdateAudioChannel1+0x284>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     9ee:	80 91 31 04 	lds	r24, 0x0431
     9f2:	90 91 32 04 	lds	r25, 0x0432
     9f6:	a0 91 33 04 	lds	r26, 0x0433
     9fa:	b0 91 34 04 	lds	r27, 0x0434
     9fe:	89 2b       	or	r24, r25
     a00:	8a 2b       	or	r24, r26
     a02:	8b 2b       	or	r24, r27
     a04:	39 f1       	breq	.+78     	; 0xa54 <UpdateAudioChannel1+0x206>
			{
				bankStates[BANK_1].currentAddress--;
     a06:	80 91 28 06 	lds	r24, 0x0628
     a0a:	90 91 29 06 	lds	r25, 0x0629
     a0e:	a0 91 2a 06 	lds	r26, 0x062A
     a12:	b0 91 2b 06 	lds	r27, 0x062B
     a16:	01 97       	sbiw	r24, 0x01	; 1
     a18:	a1 09       	sbc	r26, r1
     a1a:	b1 09       	sbc	r27, r1
     a1c:	80 93 28 06 	sts	0x0628, r24
     a20:	90 93 29 06 	sts	0x0629, r25
     a24:	a0 93 2a 06 	sts	0x062A, r26
     a28:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     a2c:	80 91 31 04 	lds	r24, 0x0431
     a30:	90 91 32 04 	lds	r25, 0x0432
     a34:	a0 91 33 04 	lds	r26, 0x0433
     a38:	b0 91 34 04 	lds	r27, 0x0434
     a3c:	01 97       	sbiw	r24, 0x01	; 1
     a3e:	a1 09       	sbc	r26, r1
     a40:	b1 09       	sbc	r27, r1
     a42:	80 93 31 04 	sts	0x0431, r24
     a46:	90 93 32 04 	sts	0x0432, r25
     a4a:	a0 93 33 04 	sts	0x0433, r26
     a4e:	b0 93 34 04 	sts	0x0434, r27
     a52:	0a c1       	rjmp	.+532    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a54:	80 91 39 04 	lds	r24, 0x0439
     a58:	90 91 3a 04 	lds	r25, 0x043A
     a5c:	a0 91 3b 04 	lds	r26, 0x043B
     a60:	b0 91 3c 04 	lds	r27, 0x043C
     a64:	80 93 31 04 	sts	0x0431, r24
     a68:	90 93 32 04 	sts	0x0432, r25
     a6c:	a0 93 33 04 	sts	0x0433, r26
     a70:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a74:	80 91 3e 04 	lds	r24, 0x043E
     a78:	8f 5f       	subi	r24, 0xFF	; 255
     a7a:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a7e:	90 91 3e 04 	lds	r25, 0x043E
     a82:	80 91 0f 06 	lds	r24, 0x060F
     a86:	98 13       	cpse	r25, r24
     a88:	02 c0       	rjmp	.+4      	; 0xa8e <UpdateAudioChannel1+0x240>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     a8a:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     a8e:	e0 91 3e 04 	lds	r30, 0x043E
     a92:	20 91 39 04 	lds	r18, 0x0439
     a96:	30 91 3a 04 	lds	r19, 0x043A
     a9a:	40 91 3b 04 	lds	r20, 0x043B
     a9e:	50 91 3c 04 	lds	r21, 0x043C
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	ec 53       	subi	r30, 0x3C	; 60
     aa6:	fb 4f       	sbci	r31, 0xFB	; 251
     aa8:	a0 81       	ld	r26, Z
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
     ab0:	0f ef       	ldi	r16, 0xFF	; 255
     ab2:	1f ef       	ldi	r17, 0xFF	; 255
     ab4:	27 e0       	ldi	r18, 0x07	; 7
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	06 1b       	sub	r16, r22
     aba:	17 0b       	sbc	r17, r23
     abc:	28 0b       	sbc	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	00 93 28 06 	sts	0x0628, r16
     ac4:	10 93 29 06 	sts	0x0629, r17
     ac8:	20 93 2a 06 	sts	0x062A, r18
     acc:	30 93 2b 06 	sts	0x062B, r19
     ad0:	cb c0       	rjmp	.+406    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ad2:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     ad6:	40 91 28 06 	lds	r20, 0x0628
     ada:	50 91 29 06 	lds	r21, 0x0629
     ade:	60 91 2a 06 	lds	r22, 0x062A
     ae2:	70 91 2b 06 	lds	r23, 0x062B
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ae6:	81 11       	cpse	r24, r1
     ae8:	5a c0       	rjmp	.+180    	; 0xb9e <UpdateAudioChannel1+0x350>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     aea:	80 91 21 06 	lds	r24, 0x0621
     aee:	90 91 22 06 	lds	r25, 0x0622
     af2:	a0 91 23 06 	lds	r26, 0x0623
     af6:	b0 91 24 06 	lds	r27, 0x0624
     afa:	48 17       	cp	r20, r24
     afc:	59 07       	cpc	r21, r25
     afe:	6a 07       	cpc	r22, r26
     b00:	7b 07       	cpc	r23, r27
     b02:	29 f4       	brne	.+10     	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b04:	80 91 0a 06 	lds	r24, 0x060A
     b08:	81 30       	cpi	r24, 0x01	; 1
     b0a:	09 f4       	brne	.+2      	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b0c:	59 c0       	rjmp	.+178    	; 0xbc0 <UpdateAudioChannel1+0x372>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b0e:	40 91 28 06 	lds	r20, 0x0628
     b12:	50 91 29 06 	lds	r21, 0x0629
     b16:	60 91 2a 06 	lds	r22, 0x062A
     b1a:	70 91 2b 06 	lds	r23, 0x062B
     b1e:	80 91 21 06 	lds	r24, 0x0621
     b22:	90 91 22 06 	lds	r25, 0x0622
     b26:	a0 91 23 06 	lds	r26, 0x0623
     b2a:	b0 91 24 06 	lds	r27, 0x0624
     b2e:	48 17       	cp	r20, r24
     b30:	59 07       	cpc	r21, r25
     b32:	6a 07       	cpc	r22, r26
     b34:	7b 07       	cpc	r23, r27
     b36:	49 f4       	brne	.+18     	; 0xb4a <UpdateAudioChannel1+0x2fc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b38:	80 91 1d 06 	lds	r24, 0x061D
     b3c:	90 91 1e 06 	lds	r25, 0x061E
     b40:	a0 91 1f 06 	lds	r26, 0x061F
     b44:	b0 91 20 06 	lds	r27, 0x0620
     b48:	87 c0       	rjmp	.+270    	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b4a:	40 91 28 06 	lds	r20, 0x0628
     b4e:	50 91 29 06 	lds	r21, 0x0629
     b52:	60 91 2a 06 	lds	r22, 0x062A
     b56:	70 91 2b 06 	lds	r23, 0x062B
     b5a:	80 91 19 06 	lds	r24, 0x0619
     b5e:	90 91 1a 06 	lds	r25, 0x061A
     b62:	a0 91 1b 06 	lds	r26, 0x061B
     b66:	b0 91 1c 06 	lds	r27, 0x061C
     b6a:	48 17       	cp	r20, r24
     b6c:	59 07       	cpc	r21, r25
     b6e:	6a 07       	cpc	r22, r26
     b70:	7b 07       	cpc	r23, r27
     b72:	49 f4       	brne	.+18     	; 0xb86 <UpdateAudioChannel1+0x338>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b74:	80 91 15 06 	lds	r24, 0x0615
     b78:	90 91 16 06 	lds	r25, 0x0616
     b7c:	a0 91 17 06 	lds	r26, 0x0617
     b80:	b0 91 18 06 	lds	r27, 0x0618
     b84:	69 c0       	rjmp	.+210    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     b86:	80 91 28 06 	lds	r24, 0x0628
     b8a:	90 91 29 06 	lds	r25, 0x0629
     b8e:	a0 91 2a 06 	lds	r26, 0x062A
     b92:	b0 91 2b 06 	lds	r27, 0x062B
     b96:	01 96       	adiw	r24, 0x01	; 1
     b98:	a1 1d       	adc	r26, r1
     b9a:	b1 1d       	adc	r27, r1
     b9c:	5d c0       	rjmp	.+186    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     b9e:	80 91 1d 06 	lds	r24, 0x061D
     ba2:	90 91 1e 06 	lds	r25, 0x061E
     ba6:	a0 91 1f 06 	lds	r26, 0x061F
     baa:	b0 91 20 06 	lds	r27, 0x0620
     bae:	48 17       	cp	r20, r24
     bb0:	59 07       	cpc	r21, r25
     bb2:	6a 07       	cpc	r22, r26
     bb4:	7b 07       	cpc	r23, r27
     bb6:	49 f4       	brne	.+18     	; 0xbca <UpdateAudioChannel1+0x37c>
     bb8:	80 91 0a 06 	lds	r24, 0x060A
     bbc:	81 30       	cpi	r24, 0x01	; 1
     bbe:	29 f4       	brne	.+10     	; 0xbca <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bc0:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bc4:	10 92 12 06 	sts	0x0612, r1
     bc8:	4f c0       	rjmp	.+158    	; 0xc68 <UpdateAudioChannel1+0x41a>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bca:	40 91 28 06 	lds	r20, 0x0628
     bce:	50 91 29 06 	lds	r21, 0x0629
     bd2:	60 91 2a 06 	lds	r22, 0x062A
     bd6:	70 91 2b 06 	lds	r23, 0x062B
     bda:	80 91 1d 06 	lds	r24, 0x061D
     bde:	90 91 1e 06 	lds	r25, 0x061E
     be2:	a0 91 1f 06 	lds	r26, 0x061F
     be6:	b0 91 20 06 	lds	r27, 0x0620
     bea:	48 17       	cp	r20, r24
     bec:	59 07       	cpc	r21, r25
     bee:	6a 07       	cpc	r22, r26
     bf0:	7b 07       	cpc	r23, r27
     bf2:	49 f4       	brne	.+18     	; 0xc06 <UpdateAudioChannel1+0x3b8>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     bf4:	80 91 21 06 	lds	r24, 0x0621
     bf8:	90 91 22 06 	lds	r25, 0x0622
     bfc:	a0 91 23 06 	lds	r26, 0x0623
     c00:	b0 91 24 06 	lds	r27, 0x0624
     c04:	29 c0       	rjmp	.+82     	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c06:	40 91 28 06 	lds	r20, 0x0628
     c0a:	50 91 29 06 	lds	r21, 0x0629
     c0e:	60 91 2a 06 	lds	r22, 0x062A
     c12:	70 91 2b 06 	lds	r23, 0x062B
     c16:	80 91 15 06 	lds	r24, 0x0615
     c1a:	90 91 16 06 	lds	r25, 0x0616
     c1e:	a0 91 17 06 	lds	r26, 0x0617
     c22:	b0 91 18 06 	lds	r27, 0x0618
     c26:	48 17       	cp	r20, r24
     c28:	59 07       	cpc	r21, r25
     c2a:	6a 07       	cpc	r22, r26
     c2c:	7b 07       	cpc	r23, r27
     c2e:	49 f4       	brne	.+18     	; 0xc42 <UpdateAudioChannel1+0x3f4>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c30:	80 91 19 06 	lds	r24, 0x0619
     c34:	90 91 1a 06 	lds	r25, 0x061A
     c38:	a0 91 1b 06 	lds	r26, 0x061B
     c3c:	b0 91 1c 06 	lds	r27, 0x061C
     c40:	0b c0       	rjmp	.+22     	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c42:	80 91 28 06 	lds	r24, 0x0628
     c46:	90 91 29 06 	lds	r25, 0x0629
     c4a:	a0 91 2a 06 	lds	r26, 0x062A
     c4e:	b0 91 2b 06 	lds	r27, 0x062B
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	a1 09       	sbc	r26, r1
     c56:	b1 09       	sbc	r27, r1
     c58:	80 93 28 06 	sts	0x0628, r24
     c5c:	90 93 29 06 	sts	0x0629, r25
     c60:	a0 93 2a 06 	sts	0x062A, r26
     c64:	b0 93 2b 06 	sts	0x062B, r27
			}
		}

		// Done with addy, read RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c68:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c6a:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c6c:	9f ef       	ldi	r25, 0xFF	; 255
     c6e:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c70:	90 91 11 06 	lds	r25, 0x0611
     c74:	99 23       	and	r25, r25
     c76:	09 f4       	brne	.+2      	; 0xc7a <UpdateAudioChannel1+0x42c>
     c78:	a9 c1       	rjmp	.+850    	; 0xfcc <UpdateAudioChannel1+0x77e>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     c7a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     c7c:	90 91 11 06 	lds	r25, 0x0611
     c80:	2f ef       	ldi	r18, 0xFF	; 255
     c82:	30 e0       	ldi	r19, 0x00	; 0
     c84:	09 2e       	mov	r0, r25
     c86:	01 c0       	rjmp	.+2      	; 0xc8a <UpdateAudioChannel1+0x43c>
     c88:	22 0f       	add	r18, r18
     c8a:	0a 94       	dec	r0
     c8c:	ea f7       	brpl	.-6      	; 0xc88 <UpdateAudioChannel1+0x43a>
     c8e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     c90:	80 58       	subi	r24, 0x80	; 128
     c92:	9c c1       	rjmp	.+824    	; 0xfcc <UpdateAudioChannel1+0x77e>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     c94:	80 91 28 06 	lds	r24, 0x0628
     c98:	90 91 29 06 	lds	r25, 0x0629
     c9c:	a0 91 2a 06 	lds	r26, 0x062A
     ca0:	b0 91 2b 06 	lds	r27, 0x062B
     ca4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     ca6:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     ca8:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     caa:	80 91 28 06 	lds	r24, 0x0628
     cae:	90 91 29 06 	lds	r25, 0x0629
     cb2:	a0 91 2a 06 	lds	r26, 0x062A
     cb6:	b0 91 2b 06 	lds	r27, 0x062B
     cba:	89 2f       	mov	r24, r25
     cbc:	9a 2f       	mov	r25, r26
     cbe:	ab 2f       	mov	r26, r27
     cc0:	bb 27       	eor	r27, r27
     cc2:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cc4:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cc6:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cc8:	80 91 28 06 	lds	r24, 0x0628
     ccc:	90 91 29 06 	lds	r25, 0x0629
     cd0:	a0 91 2a 06 	lds	r26, 0x062A
     cd4:	b0 91 2b 06 	lds	r27, 0x062B
     cd8:	cd 01       	movw	r24, r26
     cda:	aa 27       	eor	r26, r26
     cdc:	bb 27       	eor	r27, r27
     cde:	87 70       	andi	r24, 0x07	; 7
     ce0:	99 27       	eor	r25, r25
     ce2:	aa 27       	eor	r26, r26
     ce4:	bb 27       	eor	r27, r27
     ce6:	88 68       	ori	r24, 0x88	; 136
     ce8:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     cea:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     cec:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     cee:	80 91 0f 06 	lds	r24, 0x060F
     cf2:	88 23       	and	r24, r24
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <UpdateAudioChannel1+0x4aa>
     cf6:	72 c0       	rjmp	.+228    	; 0xddc <UpdateAudioChannel1+0x58e>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     cf8:	80 91 31 04 	lds	r24, 0x0431
     cfc:	90 91 32 04 	lds	r25, 0x0432
     d00:	a0 91 33 04 	lds	r26, 0x0433
     d04:	b0 91 34 04 	lds	r27, 0x0434
     d08:	89 2b       	or	r24, r25
     d0a:	8a 2b       	or	r24, r26
     d0c:	8b 2b       	or	r24, r27
     d0e:	39 f1       	breq	.+78     	; 0xd5e <UpdateAudioChannel1+0x510>
			{
				bankStates[BANK_1].currentAddress--;
     d10:	80 91 28 06 	lds	r24, 0x0628
     d14:	90 91 29 06 	lds	r25, 0x0629
     d18:	a0 91 2a 06 	lds	r26, 0x062A
     d1c:	b0 91 2b 06 	lds	r27, 0x062B
     d20:	01 97       	sbiw	r24, 0x01	; 1
     d22:	a1 09       	sbc	r26, r1
     d24:	b1 09       	sbc	r27, r1
     d26:	80 93 28 06 	sts	0x0628, r24
     d2a:	90 93 29 06 	sts	0x0629, r25
     d2e:	a0 93 2a 06 	sts	0x062A, r26
     d32:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     d36:	80 91 31 04 	lds	r24, 0x0431
     d3a:	90 91 32 04 	lds	r25, 0x0432
     d3e:	a0 91 33 04 	lds	r26, 0x0433
     d42:	b0 91 34 04 	lds	r27, 0x0434
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 31 04 	sts	0x0431, r24
     d50:	90 93 32 04 	sts	0x0432, r25
     d54:	a0 93 33 04 	sts	0x0433, r26
     d58:	b0 93 34 04 	sts	0x0434, r27
     d5c:	0a c1       	rjmp	.+532    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d5e:	80 91 39 04 	lds	r24, 0x0439
     d62:	90 91 3a 04 	lds	r25, 0x043A
     d66:	a0 91 3b 04 	lds	r26, 0x043B
     d6a:	b0 91 3c 04 	lds	r27, 0x043C
     d6e:	80 93 31 04 	sts	0x0431, r24
     d72:	90 93 32 04 	sts	0x0432, r25
     d76:	a0 93 33 04 	sts	0x0433, r26
     d7a:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     d7e:	80 91 3e 04 	lds	r24, 0x043E
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     d88:	90 91 3e 04 	lds	r25, 0x043E
     d8c:	80 91 0f 06 	lds	r24, 0x060F
     d90:	98 13       	cpse	r25, r24
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <UpdateAudioChannel1+0x54a>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     d94:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     d98:	e0 91 3e 04 	lds	r30, 0x043E
     d9c:	20 91 39 04 	lds	r18, 0x0439
     da0:	30 91 3a 04 	lds	r19, 0x043A
     da4:	40 91 3b 04 	lds	r20, 0x043B
     da8:	50 91 3c 04 	lds	r21, 0x043C
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	ec 53       	subi	r30, 0x3C	; 60
     db0:	fb 4f       	sbci	r31, 0xFB	; 251
     db2:	a0 81       	ld	r26, Z
     db4:	b0 e0       	ldi	r27, 0x00	; 0
     db6:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
     dba:	0f ef       	ldi	r16, 0xFF	; 255
     dbc:	1f ef       	ldi	r17, 0xFF	; 255
     dbe:	27 e0       	ldi	r18, 0x07	; 7
     dc0:	30 e0       	ldi	r19, 0x00	; 0
     dc2:	06 1b       	sub	r16, r22
     dc4:	17 0b       	sbc	r17, r23
     dc6:	28 0b       	sbc	r18, r24
     dc8:	39 0b       	sbc	r19, r25
     dca:	00 93 28 06 	sts	0x0628, r16
     dce:	10 93 29 06 	sts	0x0629, r17
     dd2:	20 93 2a 06 	sts	0x062A, r18
     dd6:	30 93 2b 06 	sts	0x062B, r19
     dda:	cb c0       	rjmp	.+406    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ddc:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     de0:	40 91 28 06 	lds	r20, 0x0628
     de4:	50 91 29 06 	lds	r21, 0x0629
     de8:	60 91 2a 06 	lds	r22, 0x062A
     dec:	70 91 2b 06 	lds	r23, 0x062B
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     df0:	81 11       	cpse	r24, r1
     df2:	5a c0       	rjmp	.+180    	; 0xea8 <UpdateAudioChannel1+0x65a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     df4:	80 91 21 06 	lds	r24, 0x0621
     df8:	90 91 22 06 	lds	r25, 0x0622
     dfc:	a0 91 23 06 	lds	r26, 0x0623
     e00:	b0 91 24 06 	lds	r27, 0x0624
     e04:	48 17       	cp	r20, r24
     e06:	59 07       	cpc	r21, r25
     e08:	6a 07       	cpc	r22, r26
     e0a:	7b 07       	cpc	r23, r27
     e0c:	29 f4       	brne	.+10     	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e0e:	80 91 0a 06 	lds	r24, 0x060A
     e12:	81 30       	cpi	r24, 0x01	; 1
     e14:	09 f4       	brne	.+2      	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e16:	59 c0       	rjmp	.+178    	; 0xeca <UpdateAudioChannel1+0x67c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e18:	40 91 28 06 	lds	r20, 0x0628
     e1c:	50 91 29 06 	lds	r21, 0x0629
     e20:	60 91 2a 06 	lds	r22, 0x062A
     e24:	70 91 2b 06 	lds	r23, 0x062B
     e28:	80 91 21 06 	lds	r24, 0x0621
     e2c:	90 91 22 06 	lds	r25, 0x0622
     e30:	a0 91 23 06 	lds	r26, 0x0623
     e34:	b0 91 24 06 	lds	r27, 0x0624
     e38:	48 17       	cp	r20, r24
     e3a:	59 07       	cpc	r21, r25
     e3c:	6a 07       	cpc	r22, r26
     e3e:	7b 07       	cpc	r23, r27
     e40:	49 f4       	brne	.+18     	; 0xe54 <UpdateAudioChannel1+0x606>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e42:	80 91 1d 06 	lds	r24, 0x061D
     e46:	90 91 1e 06 	lds	r25, 0x061E
     e4a:	a0 91 1f 06 	lds	r26, 0x061F
     e4e:	b0 91 20 06 	lds	r27, 0x0620
     e52:	87 c0       	rjmp	.+270    	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e54:	40 91 28 06 	lds	r20, 0x0628
     e58:	50 91 29 06 	lds	r21, 0x0629
     e5c:	60 91 2a 06 	lds	r22, 0x062A
     e60:	70 91 2b 06 	lds	r23, 0x062B
     e64:	80 91 19 06 	lds	r24, 0x0619
     e68:	90 91 1a 06 	lds	r25, 0x061A
     e6c:	a0 91 1b 06 	lds	r26, 0x061B
     e70:	b0 91 1c 06 	lds	r27, 0x061C
     e74:	48 17       	cp	r20, r24
     e76:	59 07       	cpc	r21, r25
     e78:	6a 07       	cpc	r22, r26
     e7a:	7b 07       	cpc	r23, r27
     e7c:	49 f4       	brne	.+18     	; 0xe90 <UpdateAudioChannel1+0x642>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     e7e:	80 91 15 06 	lds	r24, 0x0615
     e82:	90 91 16 06 	lds	r25, 0x0616
     e86:	a0 91 17 06 	lds	r26, 0x0617
     e8a:	b0 91 18 06 	lds	r27, 0x0618
     e8e:	69 c0       	rjmp	.+210    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     e90:	80 91 28 06 	lds	r24, 0x0628
     e94:	90 91 29 06 	lds	r25, 0x0629
     e98:	a0 91 2a 06 	lds	r26, 0x062A
     e9c:	b0 91 2b 06 	lds	r27, 0x062B
     ea0:	01 96       	adiw	r24, 0x01	; 1
     ea2:	a1 1d       	adc	r26, r1
     ea4:	b1 1d       	adc	r27, r1
     ea6:	5d c0       	rjmp	.+186    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ea8:	80 91 1d 06 	lds	r24, 0x061D
     eac:	90 91 1e 06 	lds	r25, 0x061E
     eb0:	a0 91 1f 06 	lds	r26, 0x061F
     eb4:	b0 91 20 06 	lds	r27, 0x0620
     eb8:	48 17       	cp	r20, r24
     eba:	59 07       	cpc	r21, r25
     ebc:	6a 07       	cpc	r22, r26
     ebe:	7b 07       	cpc	r23, r27
     ec0:	49 f4       	brne	.+18     	; 0xed4 <UpdateAudioChannel1+0x686>
     ec2:	80 91 0a 06 	lds	r24, 0x060A
     ec6:	81 30       	cpi	r24, 0x01	; 1
     ec8:	29 f4       	brne	.+10     	; 0xed4 <UpdateAudioChannel1+0x686>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     eca:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     ece:	10 92 12 06 	sts	0x0612, r1
     ed2:	4f c0       	rjmp	.+158    	; 0xf72 <UpdateAudioChannel1+0x724>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     ed4:	40 91 28 06 	lds	r20, 0x0628
     ed8:	50 91 29 06 	lds	r21, 0x0629
     edc:	60 91 2a 06 	lds	r22, 0x062A
     ee0:	70 91 2b 06 	lds	r23, 0x062B
     ee4:	80 91 1d 06 	lds	r24, 0x061D
     ee8:	90 91 1e 06 	lds	r25, 0x061E
     eec:	a0 91 1f 06 	lds	r26, 0x061F
     ef0:	b0 91 20 06 	lds	r27, 0x0620
     ef4:	48 17       	cp	r20, r24
     ef6:	59 07       	cpc	r21, r25
     ef8:	6a 07       	cpc	r22, r26
     efa:	7b 07       	cpc	r23, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     efe:	80 91 21 06 	lds	r24, 0x0621
     f02:	90 91 22 06 	lds	r25, 0x0622
     f06:	a0 91 23 06 	lds	r26, 0x0623
     f0a:	b0 91 24 06 	lds	r27, 0x0624
     f0e:	29 c0       	rjmp	.+82     	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f10:	40 91 28 06 	lds	r20, 0x0628
     f14:	50 91 29 06 	lds	r21, 0x0629
     f18:	60 91 2a 06 	lds	r22, 0x062A
     f1c:	70 91 2b 06 	lds	r23, 0x062B
     f20:	80 91 15 06 	lds	r24, 0x0615
     f24:	90 91 16 06 	lds	r25, 0x0616
     f28:	a0 91 17 06 	lds	r26, 0x0617
     f2c:	b0 91 18 06 	lds	r27, 0x0618
     f30:	48 17       	cp	r20, r24
     f32:	59 07       	cpc	r21, r25
     f34:	6a 07       	cpc	r22, r26
     f36:	7b 07       	cpc	r23, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f3a:	80 91 19 06 	lds	r24, 0x0619
     f3e:	90 91 1a 06 	lds	r25, 0x061A
     f42:	a0 91 1b 06 	lds	r26, 0x061B
     f46:	b0 91 1c 06 	lds	r27, 0x061C
     f4a:	0b c0       	rjmp	.+22     	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f4c:	80 91 28 06 	lds	r24, 0x0628
     f50:	90 91 29 06 	lds	r25, 0x0629
     f54:	a0 91 2a 06 	lds	r26, 0x062A
     f58:	b0 91 2b 06 	lds	r27, 0x062B
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	a1 09       	sbc	r26, r1
     f60:	b1 09       	sbc	r27, r1
     f62:	80 93 28 06 	sts	0x0628, r24
     f66:	90 93 29 06 	sts	0x0629, r25
     f6a:	a0 93 2a 06 	sts	0x062A, r26
     f6e:	b0 93 2b 06 	sts	0x062B, r27
			}
		}

		// Finished with addy stuff, now finish data transfer

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     f72:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     f74:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     f76:	9f ef       	ldi	r25, 0xFF	; 255
     f78:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     f7a:	90 91 11 06 	lds	r25, 0x0611
     f7e:	99 23       	and	r25, r25
     f80:	61 f0       	breq	.+24     	; 0xf9a <UpdateAudioChannel1+0x74c>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     f82:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     f84:	90 91 11 06 	lds	r25, 0x0611
     f88:	2f ef       	ldi	r18, 0xFF	; 255
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	09 2e       	mov	r0, r25
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <UpdateAudioChannel1+0x744>
     f90:	22 0f       	add	r18, r18
     f92:	0a 94       	dec	r0
     f94:	ea f7       	brpl	.-6      	; 0xf90 <UpdateAudioChannel1+0x742>
     f96:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     f98:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     f9a:	20 91 2c 04 	lds	r18, 0x042C
     f9e:	33 27       	eor	r19, r19
     fa0:	27 fd       	sbrc	r18, 7
     fa2:	30 95       	com	r19
     fa4:	28 0f       	add	r18, r24
     fa6:	31 1d       	adc	r19, r1
     fa8:	87 fd       	sbrc	r24, 7
     faa:	3a 95       	dec	r19
     fac:	20 38       	cpi	r18, 0x80	; 128
     fae:	9f ef       	ldi	r25, 0xFF	; 255
     fb0:	39 07       	cpc	r19, r25
     fb2:	14 f4       	brge	.+4      	; 0xfb8 <UpdateAudioChannel1+0x76a>
     fb4:	20 e8       	ldi	r18, 0x80	; 128
     fb6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     fb8:	20 38       	cpi	r18, 0x80	; 128
     fba:	31 05       	cpc	r19, r1
     fbc:	14 f0       	brlt	.+4      	; 0xfc2 <UpdateAudioChannel1+0x774>
     fbe:	2f e7       	ldi	r18, 0x7F	; 127
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     fc4:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     fc6:	11 9a       	sbi	0x02, 1	; 2
		break;
     fc8:	01 c0       	rjmp	.+2      	; 0xfcc <UpdateAudioChannel1+0x77e>
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     fca:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	08 95       	ret

00000fd2 <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     fd2:	80 91 42 04 	lds	r24, 0x0442
     fd6:	20 91 48 05 	lds	r18, 0x0548
     fda:	33 27       	eor	r19, r19
     fdc:	27 fd       	sbrc	r18, 7
     fde:	30 95       	com	r19
     fe0:	28 0f       	add	r18, r24
     fe2:	31 1d       	adc	r19, r1
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	3a 95       	dec	r19
     fe8:	20 38       	cpi	r18, 0x80	; 128
     fea:	4f ef       	ldi	r20, 0xFF	; 255
     fec:	34 07       	cpc	r19, r20
     fee:	14 f4       	brge	.+4      	; 0xff4 <OutputMultiplyBanks+0x22>
     ff0:	20 e8       	ldi	r18, 0x80	; 128
     ff2:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     ff4:	40 91 45 05 	lds	r20, 0x0545
     ff8:	80 91 4c 05 	lds	r24, 0x054C
     ffc:	99 27       	eor	r25, r25
     ffe:	87 fd       	sbrc	r24, 7
    1000:	90 95       	com	r25
    1002:	84 0f       	add	r24, r20
    1004:	91 1d       	adc	r25, r1
    1006:	47 fd       	sbrc	r20, 7
    1008:	9a 95       	dec	r25
    100a:	81 38       	cpi	r24, 0x81	; 129
    100c:	4f ef       	ldi	r20, 0xFF	; 255
    100e:	94 07       	cpc	r25, r20
    1010:	14 f4       	brge	.+4      	; 0x1016 <OutputMultiplyBanks+0x44>
    1012:	81 e8       	ldi	r24, 0x81	; 129
    1014:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    1016:	20 38       	cpi	r18, 0x80	; 128
    1018:	31 05       	cpc	r19, r1
    101a:	14 f0       	brlt	.+4      	; 0x1020 <OutputMultiplyBanks+0x4e>
    101c:	2f e7       	ldi	r18, 0x7F	; 127
    101e:	30 e0       	ldi	r19, 0x00	; 0
    1020:	80 38       	cpi	r24, 0x80	; 128
    1022:	91 05       	cpc	r25, r1
    1024:	14 f0       	brlt	.+4      	; 0x102a <OutputMultiplyBanks+0x58>
    1026:	8f e7       	ldi	r24, 0x7F	; 127
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	28 9f       	mul	r18, r24
    102c:	a0 01       	movw	r20, r0
    102e:	29 9f       	mul	r18, r25
    1030:	50 0d       	add	r21, r0
    1032:	38 9f       	mul	r19, r24
    1034:	50 0d       	add	r21, r0
    1036:	11 24       	eor	r1, r1
    1038:	57 ff       	sbrs	r21, 7
    103a:	02 c0       	rjmp	.+4      	; 0x1040 <OutputMultiplyBanks+0x6e>
    103c:	41 5c       	subi	r20, 0xC1	; 193
    103e:	5f 4f       	sbci	r21, 0xFF	; 255
    1040:	ca 01       	movw	r24, r20
    1042:	46 e0       	ldi	r20, 0x06	; 6
    1044:	95 95       	asr	r25
    1046:	87 95       	ror	r24
    1048:	4a 95       	dec	r20
    104a:	e1 f7       	brne	.-8      	; 0x1044 <OutputMultiplyBanks+0x72>

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    104c:	80 58       	subi	r24, 0x80	; 128
    104e:	90 95       	com	r25
    1050:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1052:	30 91 69 05 	lds	r19, 0x0569
    1056:	83 17       	cp	r24, r19
    1058:	29 f0       	breq	.+10     	; 0x1064 <OutputMultiplyBanks+0x92>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    105a:	9f ef       	ldi	r25, 0xFF	; 255
    105c:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    105e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1060:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1062:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1064:	20 93 69 05 	sts	0x0569, r18
    1068:	08 95       	ret

0000106a <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC

//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
    106a:	20 91 42 04 	lds	r18, 0x0442
    106e:	80 91 45 05 	lds	r24, 0x0545
    1072:	99 27       	eor	r25, r25
    1074:	87 fd       	sbrc	r24, 7
    1076:	90 95       	com	r25
    1078:	82 0f       	add	r24, r18
    107a:	91 1d       	adc	r25, r1
    107c:	27 fd       	sbrc	r18, 7
    107e:	9a 95       	dec	r25
    1080:	20 91 48 05 	lds	r18, 0x0548
    1084:	82 0f       	add	r24, r18
    1086:	91 1d       	adc	r25, r1
    1088:	27 fd       	sbrc	r18, 7
    108a:	9a 95       	dec	r25
    108c:	20 91 4c 05 	lds	r18, 0x054C
    1090:	82 0f       	add	r24, r18
    1092:	91 1d       	adc	r25, r1
    1094:	27 fd       	sbrc	r18, 7
    1096:	9a 95       	dec	r25
    1098:	20 91 55 05 	lds	r18, 0x0555
    109c:	82 0f       	add	r24, r18
    109e:	91 1d       	adc	r25, r1
    10a0:	27 fd       	sbrc	r18, 7
    10a2:	9a 95       	dec	r25
    10a4:	80 38       	cpi	r24, 0x80	; 128
    10a6:	2f ef       	ldi	r18, 0xFF	; 255
    10a8:	92 07       	cpc	r25, r18
    10aa:	14 f4       	brge	.+4      	; 0x10b0 <OutputAddBanks+0x46>
    10ac:	80 e8       	ldi	r24, 0x80	; 128
    10ae:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10b0:	80 38       	cpi	r24, 0x80	; 128
    10b2:	91 05       	cpc	r25, r1
    10b4:	14 f0       	brlt	.+4      	; 0x10ba <OutputAddBanks+0x50>
    10b6:	8f e7       	ldi	r24, 0x7F	; 127
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	80 58       	subi	r24, 0x80	; 128
    10bc:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    10be:	30 91 69 05 	lds	r19, 0x0569
    10c2:	83 17       	cp	r24, r19
    10c4:	29 f0       	breq	.+10     	; 0x10d0 <OutputAddBanks+0x66>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    10c6:	9f ef       	ldi	r25, 0xFF	; 255
    10c8:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    10ca:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    10cc:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    10ce:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    10d0:	20 93 69 05 	sts	0x0569, r18
    10d4:	08 95       	ret

000010d6 <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    10d6:	20 91 42 04 	lds	r18, 0x0442
    10da:	80 91 48 05 	lds	r24, 0x0548
    10de:	99 27       	eor	r25, r25
    10e0:	87 fd       	sbrc	r24, 7
    10e2:	90 95       	com	r25
    10e4:	82 0f       	add	r24, r18
    10e6:	91 1d       	adc	r25, r1
    10e8:	27 fd       	sbrc	r18, 7
    10ea:	9a 95       	dec	r25
    10ec:	80 38       	cpi	r24, 0x80	; 128
    10ee:	2f ef       	ldi	r18, 0xFF	; 255
    10f0:	92 07       	cpc	r25, r18
    10f2:	14 f4       	brge	.+4      	; 0x10f8 <OutputXorBanks+0x22>
    10f4:	80 e8       	ldi	r24, 0x80	; 128
    10f6:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    10f8:	40 91 45 05 	lds	r20, 0x0545
    10fc:	20 91 4c 05 	lds	r18, 0x054C
    1100:	33 27       	eor	r19, r19
    1102:	27 fd       	sbrc	r18, 7
    1104:	30 95       	com	r19
    1106:	24 0f       	add	r18, r20
    1108:	31 1d       	adc	r19, r1
    110a:	47 fd       	sbrc	r20, 7
    110c:	3a 95       	dec	r19
    110e:	20 38       	cpi	r18, 0x80	; 128
    1110:	4f ef       	ldi	r20, 0xFF	; 255
    1112:	34 07       	cpc	r19, r20
    1114:	14 f4       	brge	.+4      	; 0x111a <__stack+0x1b>
    1116:	20 e8       	ldi	r18, 0x80	; 128
    1118:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.
    111a:	20 38       	cpi	r18, 0x80	; 128
    111c:	31 05       	cpc	r19, r1
    111e:	14 f0       	brlt	.+4      	; 0x1124 <__stack+0x25>
    1120:	2f e7       	ldi	r18, 0x7F	; 127
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	20 58       	subi	r18, 0x80	; 128
    1126:	30 95       	com	r19
    1128:	80 38       	cpi	r24, 0x80	; 128
    112a:	91 05       	cpc	r25, r1
    112c:	14 f0       	brlt	.+4      	; 0x1132 <__stack+0x33>
    112e:	8f e7       	ldi	r24, 0x7F	; 127
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	80 58       	subi	r24, 0x80	; 128
    1134:	90 95       	com	r25
    1136:	82 27       	eor	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1138:	90 91 69 05 	lds	r25, 0x0569
    113c:	89 17       	cp	r24, r25
    113e:	29 f0       	breq	.+10     	; 0x114a <__stack+0x4b>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1140:	9f ef       	ldi	r25, 0xFF	; 255
    1142:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1144:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1146:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1148:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    114a:	80 93 69 05 	sts	0x0569, r24
    114e:	08 95       	ret

00001150 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1150:	20 91 42 04 	lds	r18, 0x0442
    1154:	80 91 48 05 	lds	r24, 0x0548
    1158:	99 27       	eor	r25, r25
    115a:	87 fd       	sbrc	r24, 7
    115c:	90 95       	com	r25
    115e:	82 0f       	add	r24, r18
    1160:	91 1d       	adc	r25, r1
    1162:	27 fd       	sbrc	r18, 7
    1164:	9a 95       	dec	r25
    1166:	80 38       	cpi	r24, 0x80	; 128
    1168:	2f ef       	ldi	r18, 0xFF	; 255
    116a:	92 07       	cpc	r25, r18
    116c:	14 f4       	brge	.+4      	; 0x1172 <OutputAndBanks+0x22>
    116e:	80 e8       	ldi	r24, 0x80	; 128
    1170:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1172:	40 91 45 05 	lds	r20, 0x0545
    1176:	20 91 4c 05 	lds	r18, 0x054C
    117a:	33 27       	eor	r19, r19
    117c:	27 fd       	sbrc	r18, 7
    117e:	30 95       	com	r19
    1180:	24 0f       	add	r18, r20
    1182:	31 1d       	adc	r19, r1
    1184:	47 fd       	sbrc	r20, 7
    1186:	3a 95       	dec	r19
    1188:	20 38       	cpi	r18, 0x80	; 128
    118a:	4f ef       	ldi	r20, 0xFF	; 255
    118c:	34 07       	cpc	r19, r20
    118e:	14 f4       	brge	.+4      	; 0x1194 <OutputAndBanks+0x44>
    1190:	20 e8       	ldi	r18, 0x80	; 128
    1192:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.
    1194:	20 38       	cpi	r18, 0x80	; 128
    1196:	31 05       	cpc	r19, r1
    1198:	14 f0       	brlt	.+4      	; 0x119e <OutputAndBanks+0x4e>
    119a:	2f e7       	ldi	r18, 0x7F	; 127
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	20 58       	subi	r18, 0x80	; 128
    11a0:	30 95       	com	r19
    11a2:	80 38       	cpi	r24, 0x80	; 128
    11a4:	91 05       	cpc	r25, r1
    11a6:	14 f0       	brlt	.+4      	; 0x11ac <OutputAndBanks+0x5c>
    11a8:	8f e7       	ldi	r24, 0x7F	; 127
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	80 58       	subi	r24, 0x80	; 128
    11ae:	90 95       	com	r25
    11b0:	82 23       	and	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11b2:	90 91 69 05 	lds	r25, 0x0569
    11b6:	89 17       	cp	r24, r25
    11b8:	29 f0       	breq	.+10     	; 0x11c4 <OutputAndBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    11ba:	9f ef       	ldi	r25, 0xFF	; 255
    11bc:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    11be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    11c0:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    11c2:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    11c4:	80 93 69 05 	sts	0x0569, r24
    11c8:	08 95       	ret

000011ca <WriteLedLatch>:
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    11ca:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    11cc:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    11ce:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	84 b9       	out	0x04, r24	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    11d4:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    11d6:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    11d8:	9f bf       	out	0x3f, r25	; 63
    11da:	08 95       	ret

000011dc <SdIsrStartStreamingAudio>:
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;

	sreg=SREG;
    11dc:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    11de:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    11e0:	83 e0       	ldi	r24, 0x03	; 3
    11e2:	80 93 4f 05 	sts	0x054F, r24

	TCNT2=0;			// Init counter reg
    11e6:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
    11ea:	81 e7       	ldi	r24, 0x71	; 113
    11ec:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    11f0:	8f ef       	ldi	r24, 0xFF	; 255
    11f2:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    11f4:	e0 e7       	ldi	r30, 0x70	; 112
    11f6:	f0 e0       	ldi	r31, 0x00	; 0
    11f8:	80 81       	ld	r24, Z
    11fa:	84 60       	ori	r24, 0x04	; 4
    11fc:	80 83       	st	Z, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    11fe:	82 e0       	ldi	r24, 0x02	; 2
    1200:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    1204:	9f bf       	out	0x3f, r25	; 63
    1206:	08 95       	ret

00001208 <GetRandomLongInt>:
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1208:	40 91 00 01 	lds	r20, 0x0100
    120c:	50 91 01 01 	lds	r21, 0x0101
    1210:	60 91 02 01 	lds	r22, 0x0102
    1214:	70 91 03 01 	lds	r23, 0x0103
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1218:	db 01       	movw	r26, r22
    121a:	ca 01       	movw	r24, r20
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	aa 1f       	adc	r26, r26
    1222:	bb 1f       	adc	r27, r27
    1224:	76 ff       	sbrs	r23, 6
    1226:	08 c0       	rjmp	.+16     	; 0x1238 <GetRandomLongInt+0x30>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1228:	25 eb       	ldi	r18, 0xB5	; 181
    122a:	82 27       	eor	r24, r18
    122c:	25 e9       	ldi	r18, 0x95	; 149
    122e:	92 27       	eor	r25, r18
    1230:	2a ea       	ldi	r18, 0xAA	; 170
    1232:	a2 27       	eor	r26, r18
    1234:	20 e2       	ldi	r18, 0x20	; 32
    1236:	b2 27       	eor	r27, r18
    1238:	80 93 00 01 	sts	0x0100, r24
    123c:	90 93 01 01 	sts	0x0101, r25
    1240:	a0 93 02 01 	sts	0x0102, r26
    1244:	b0 93 03 01 	sts	0x0103, r27
	}
	return(random31);
    1248:	60 91 00 01 	lds	r22, 0x0100
    124c:	70 91 01 01 	lds	r23, 0x0101
}
    1250:	80 91 02 01 	lds	r24, 0x0102
    1254:	90 91 03 01 	lds	r25, 0x0103
    1258:	08 95       	ret

0000125a <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM.
{
    125a:	2f 92       	push	r2
    125c:	3f 92       	push	r3
    125e:	4f 92       	push	r4
    1260:	5f 92       	push	r5
    1262:	6f 92       	push	r6
    1264:	7f 92       	push	r7
    1266:	8f 92       	push	r8
    1268:	9f 92       	push	r9
    126a:	af 92       	push	r10
    126c:	bf 92       	push	r11
    126e:	cf 92       	push	r12
    1270:	df 92       	push	r13
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	38 2e       	mov	r3, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    1280:	62 30       	cpi	r22, 0x02	; 2
    1282:	08 f4       	brcc	.+2      	; 0x1286 <MakeNewGranularArray+0x2c>
    1284:	cd c0       	rjmp	.+410    	; 0x1420 <MakeNewGranularArray+0x1c6>
	{
		sreg=SREG;
    1286:	9f b6       	in	r9, 0x3f	; 63
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    1288:	f8 94       	cli
    128a:	86 2e       	mov	r8, r22
    128c:	80 e8       	ldi	r24, 0x80	; 128
    128e:	86 17       	cp	r24, r22
    1290:	10 f4       	brcc	.+4      	; 0x1296 <MakeNewGranularArray+0x3c>
    1292:	00 e8       	ldi	r16, 0x80	; 128
    1294:	80 2e       	mov	r8, r16
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    1296:	c3 2d       	mov	r28, r3
    1298:	d0 e0       	ldi	r29, 0x00	; 0
    129a:	9e 01       	movw	r18, r28
    129c:	36 95       	lsr	r19
    129e:	32 2f       	mov	r19, r18
    12a0:	22 27       	eor	r18, r18
    12a2:	37 95       	ror	r19
    12a4:	27 95       	ror	r18
    12a6:	2c 5b       	subi	r18, 0xBC	; 188
    12a8:	3b 4f       	sbci	r19, 0xFB	; 251
    12aa:	80 e0       	ldi	r24, 0x00	; 0
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	f9 01       	movw	r30, r18
    12b0:	e8 0f       	add	r30, r24
    12b2:	f9 1f       	adc	r31, r25
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    12b4:	80 83       	st	Z, r24
    12b6:	01 96       	adiw	r24, 0x01	; 1
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    12b8:	88 15       	cp	r24, r8
    12ba:	c8 f3       	brcs	.-14     	; 0x12ae <MakeNewGranularArray+0x54>
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12bc:	6e 01       	movw	r12, r28
    12be:	d6 94       	lsr	r13
    12c0:	dc 2c       	mov	r13, r12
    12c2:	cc 24       	eor	r12, r12
    12c4:	d7 94       	ror	r13
    12c6:	c7 94       	ror	r12
    12c8:	b4 e4       	ldi	r27, 0x44	; 68
    12ca:	ab 2e       	mov	r10, r27
    12cc:	b4 e0       	ldi	r27, 0x04	; 4
    12ce:	bb 2e       	mov	r11, r27
    12d0:	ac 0c       	add	r10, r12
    12d2:	bd 1c       	adc	r11, r13
    12d4:	00 e0       	ldi	r16, 0x00	; 0
    12d6:	10 e0       	ldi	r17, 0x00	; 0
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    12d8:	48 2c       	mov	r4, r8
    12da:	51 2c       	mov	r5, r1
    12dc:	61 2c       	mov	r6, r1
    12de:	71 2c       	mov	r7, r1
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12e0:	75 01       	movw	r14, r10
    12e2:	e0 0e       	add	r14, r16
    12e4:	f1 1e       	adc	r15, r17
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    12e6:	d7 01       	movw	r26, r14
    12e8:	2c 90       	ld	r2, X
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    12ea:	0e 94 04 09 	call	0x1208	; 0x1208 <GetRandomLongInt>
    12ee:	a3 01       	movw	r20, r6
    12f0:	92 01       	movw	r18, r4
    12f2:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    12f6:	fb 01       	movw	r30, r22
    12f8:	ec 0d       	add	r30, r12
    12fa:	fd 1d       	adc	r31, r13
    12fc:	ec 5b       	subi	r30, 0xBC	; 188
    12fe:	fb 4f       	sbci	r31, 0xFB	; 251
    1300:	80 81       	ld	r24, Z
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1302:	d7 01       	movw	r26, r14
    1304:	8c 93       	st	X, r24
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1306:	20 82       	st	Z, r2
    1308:	0f 5f       	subi	r16, 0xFF	; 255
    130a:	1f 4f       	sbci	r17, 0xFF	; 255
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    130c:	08 15       	cp	r16, r8
    130e:	40 f3       	brcs	.-48     	; 0x12e0 <MakeNewGranularArray+0x86>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1310:	31 10       	cpse	r3, r1
    1312:	15 c0       	rjmp	.+42     	; 0x133e <MakeNewGranularArray+0xe4>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1314:	60 91 f2 05 	lds	r22, 0x05F2
    1318:	70 91 f3 05 	lds	r23, 0x05F3
    131c:	80 91 f4 05 	lds	r24, 0x05F4
    1320:	90 91 f5 05 	lds	r25, 0x05F5
    1324:	a3 01       	movw	r20, r6
    1326:	92 01       	movw	r18, r4
    1328:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
    132c:	20 93 35 04 	sts	0x0435, r18
    1330:	30 93 36 04 	sts	0x0436, r19
    1334:	40 93 37 04 	sts	0x0437, r20
    1338:	50 93 38 04 	sts	0x0438, r21
    133c:	1c c0       	rjmp	.+56     	; 0x1376 <MakeNewGranularArray+0x11c>
		}
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
    133e:	00 91 15 06 	lds	r16, 0x0615
    1342:	10 91 16 06 	lds	r17, 0x0616
    1346:	20 91 17 06 	lds	r18, 0x0617
    134a:	30 91 18 06 	lds	r19, 0x0618
    134e:	6f ef       	ldi	r22, 0xFF	; 255
    1350:	7f ef       	ldi	r23, 0xFF	; 255
    1352:	87 e0       	ldi	r24, 0x07	; 7
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	60 1b       	sub	r22, r16
    1358:	71 0b       	sbc	r23, r17
    135a:	82 0b       	sbc	r24, r18
    135c:	93 0b       	sbc	r25, r19
    135e:	a3 01       	movw	r20, r6
    1360:	92 01       	movw	r18, r4
    1362:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
    1366:	20 93 39 04 	sts	0x0439, r18
    136a:	30 93 3a 04 	sts	0x043A, r19
    136e:	40 93 3b 04 	sts	0x043B, r20
    1372:	50 93 3c 04 	sts	0x043C, r21
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1376:	83 e2       	ldi	r24, 0x23	; 35
    1378:	8c 9f       	mul	r24, r28
    137a:	f0 01       	movw	r30, r0
    137c:	8d 9f       	mul	r24, r29
    137e:	f0 0d       	add	r31, r0
    1380:	11 24       	eor	r1, r1
    1382:	ea 51       	subi	r30, 0x1A	; 26
    1384:	fa 4f       	sbci	r31, 0xFA	; 250
    1386:	86 82       	std	Z+6, r8	; 0x06
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1388:	fe 01       	movw	r30, r28
    138a:	e3 5c       	subi	r30, 0xC3	; 195
    138c:	fb 4f       	sbci	r31, 0xFB	; 251
    138e:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1390:	cc 0f       	add	r28, r28
    1392:	dd 1f       	adc	r29, r29
    1394:	cc 0f       	add	r28, r28
    1396:	dd 1f       	adc	r29, r29
    1398:	fe 01       	movw	r30, r28
    139a:	eb 5c       	subi	r30, 0xCB	; 203
    139c:	fb 4f       	sbci	r31, 0xFB	; 251
    139e:	80 81       	ld	r24, Z
    13a0:	91 81       	ldd	r25, Z+1	; 0x01
    13a2:	a2 81       	ldd	r26, Z+2	; 0x02
    13a4:	b3 81       	ldd	r27, Z+3	; 0x03
    13a6:	c3 5d       	subi	r28, 0xD3	; 211
    13a8:	db 4f       	sbci	r29, 0xFB	; 251
    13aa:	88 83       	st	Y, r24
    13ac:	99 83       	std	Y+1, r25	; 0x01
    13ae:	aa 83       	std	Y+2, r26	; 0x02
    13b0:	bb 83       	std	Y+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    13b2:	31 10       	cpse	r3, r1
    13b4:	16 c0       	rjmp	.+44     	; 0x13e2 <MakeNewGranularArray+0x188>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    13b6:	20 91 35 04 	lds	r18, 0x0435
    13ba:	30 91 36 04 	lds	r19, 0x0436
    13be:	40 91 37 04 	lds	r20, 0x0437
    13c2:	50 91 38 04 	lds	r21, 0x0438
    13c6:	a0 91 44 04 	lds	r26, 0x0444
    13ca:	b0 e0       	ldi	r27, 0x00	; 0
    13cc:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    13d0:	60 93 05 06 	sts	0x0605, r22
    13d4:	70 93 06 06 	sts	0x0606, r23
    13d8:	80 93 07 06 	sts	0x0607, r24
    13dc:	90 93 08 06 	sts	0x0608, r25
    13e0:	1d c0       	rjmp	.+58     	; 0x141c <MakeNewGranularArray+0x1c2>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));
    13e2:	20 91 39 04 	lds	r18, 0x0439
    13e6:	30 91 3a 04 	lds	r19, 0x043A
    13ea:	40 91 3b 04 	lds	r20, 0x043B
    13ee:	50 91 3c 04 	lds	r21, 0x043C
    13f2:	a0 91 c4 04 	lds	r26, 0x04C4
    13f6:	b0 e0       	ldi	r27, 0x00	; 0
    13f8:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    13fc:	0f ef       	ldi	r16, 0xFF	; 255
    13fe:	1f ef       	ldi	r17, 0xFF	; 255
    1400:	27 e0       	ldi	r18, 0x07	; 7
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	06 1b       	sub	r16, r22
    1406:	17 0b       	sbc	r17, r23
    1408:	28 0b       	sbc	r18, r24
    140a:	39 0b       	sbc	r19, r25
    140c:	00 93 28 06 	sts	0x0628, r16
    1410:	10 93 29 06 	sts	0x0629, r17
    1414:	20 93 2a 06 	sts	0x062A, r18
    1418:	30 93 2b 06 	sts	0x062B, r19
		}

		SREG=sreg;		// Restore interrupts.
    141c:	9f be       	out	0x3f, r9	; 63
    141e:	07 c0       	rjmp	.+14     	; 0x142e <MakeNewGranularArray+0x1d4>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
    1420:	b3 e2       	ldi	r27, 0x23	; 35
    1422:	8b 9f       	mul	r24, r27
    1424:	f0 01       	movw	r30, r0
    1426:	11 24       	eor	r1, r1
    1428:	ea 51       	subi	r30, 0x1A	; 26
    142a:	fa 4f       	sbci	r31, 0xFA	; 250
    142c:	16 82       	std	Z+6, r1	; 0x06
	}
}
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	ff 90       	pop	r15
    1438:	ef 90       	pop	r14
    143a:	df 90       	pop	r13
    143c:	cf 90       	pop	r12
    143e:	bf 90       	pop	r11
    1440:	af 90       	pop	r10
    1442:	9f 90       	pop	r9
    1444:	8f 90       	pop	r8
    1446:	7f 90       	pop	r7
    1448:	6f 90       	pop	r6
    144a:	5f 90       	pop	r5
    144c:	4f 90       	pop	r4
    144e:	3f 90       	pop	r3
    1450:	2f 90       	pop	r2
    1452:	08 95       	ret

00001454 <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    1454:	4f 92       	push	r4
    1456:	5f 92       	push	r5
    1458:	6f 92       	push	r6
    145a:	7f 92       	push	r7
    145c:	8f 92       	push	r8
    145e:	9f 92       	push	r9
    1460:	af 92       	push	r10
    1462:	bf 92       	push	r11
    1464:	cf 92       	push	r12
    1466:	df 92       	push	r13
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
	unsigned char
		sreg;
	unsigned long
		chunkSize;

	sreg=SREG;
    146c:	ef b7       	in	r30, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    146e:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1470:	81 11       	cpse	r24, r1
    1472:	e9 c1       	rjmp	.+978    	; 0x1846 <UpdateAdjustedSampleAddresses+0x3f2>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1474:	80 90 f2 05 	lds	r8, 0x05F2
    1478:	90 90 f3 05 	lds	r9, 0x05F3
    147c:	a0 90 f4 05 	lds	r10, 0x05F4
    1480:	b0 90 f5 05 	lds	r11, 0x05F5
    1484:	83 e0       	ldi	r24, 0x03	; 3
    1486:	88 0c       	add	r8, r8
    1488:	99 1c       	adc	r9, r9
    148a:	aa 1c       	adc	r10, r10
    148c:	bb 1c       	adc	r11, r11
    148e:	8a 95       	dec	r24
    1490:	d1 f7       	brne	.-12     	; 0x1486 <UpdateAdjustedSampleAddresses+0x32>
    1492:	89 2c       	mov	r8, r9
    1494:	9a 2c       	mov	r9, r10
    1496:	ab 2c       	mov	r10, r11
    1498:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    149a:	a0 91 02 06 	lds	r26, 0x0602
    149e:	80 91 04 06 	lds	r24, 0x0604
    14a2:	b0 e0       	ldi	r27, 0x00	; 0
    14a4:	a8 0f       	add	r26, r24
    14a6:	b1 1d       	adc	r27, r1
    14a8:	a5 01       	movw	r20, r10
    14aa:	94 01       	movw	r18, r8
    14ac:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    14b0:	f3 e0       	ldi	r31, 0x03	; 3
    14b2:	96 95       	lsr	r25
    14b4:	87 95       	ror	r24
    14b6:	77 95       	ror	r23
    14b8:	67 95       	ror	r22
    14ba:	fa 95       	dec	r31
    14bc:	d1 f7       	brne	.-12     	; 0x14b2 <UpdateAdjustedSampleAddresses+0x5e>
    14be:	60 93 fe 05 	sts	0x05FE, r22
    14c2:	70 93 ff 05 	sts	0x05FF, r23
    14c6:	80 93 00 06 	sts	0x0600, r24
    14ca:	90 93 01 06 	sts	0x0601, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    14ce:	40 90 f2 05 	lds	r4, 0x05F2
    14d2:	50 90 f3 05 	lds	r5, 0x05F3
    14d6:	60 90 f4 05 	lds	r6, 0x05F4
    14da:	70 90 f5 05 	lds	r7, 0x05F5
    14de:	f0 91 03 06 	lds	r31, 0x0603
    14e2:	a0 91 04 06 	lds	r26, 0x0604
    14e6:	b0 e0       	ldi	r27, 0x00	; 0
    14e8:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    14ec:	6b 01       	movw	r12, r22
    14ee:	7c 01       	movw	r14, r24
    14f0:	a3 e0       	ldi	r26, 0x03	; 3
    14f2:	f6 94       	lsr	r15
    14f4:	e7 94       	ror	r14
    14f6:	d7 94       	ror	r13
    14f8:	c7 94       	ror	r12
    14fa:	aa 95       	dec	r26
    14fc:	d1 f7       	brne	.-12     	; 0x14f2 <UpdateAdjustedSampleAddresses+0x9e>
    14fe:	c4 0c       	add	r12, r4
    1500:	d5 1c       	adc	r13, r5
    1502:	e6 1c       	adc	r14, r6
    1504:	f7 1c       	adc	r15, r7
    1506:	af 2f       	mov	r26, r31
    1508:	b0 e0       	ldi	r27, 0x00	; 0
    150a:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    150e:	b3 e0       	ldi	r27, 0x03	; 3
    1510:	96 95       	lsr	r25
    1512:	87 95       	ror	r24
    1514:	77 95       	ror	r23
    1516:	67 95       	ror	r22
    1518:	ba 95       	dec	r27
    151a:	d1 f7       	brne	.-12     	; 0x1510 <UpdateAdjustedSampleAddresses+0xbc>
    151c:	c6 1a       	sub	r12, r22
    151e:	d7 0a       	sbc	r13, r23
    1520:	e8 0a       	sbc	r14, r24
    1522:	f9 0a       	sbc	r15, r25
    1524:	c0 92 fa 05 	sts	0x05FA, r12
    1528:	d0 92 fb 05 	sts	0x05FB, r13
    152c:	e0 92 fc 05 	sts	0x05FC, r14
    1530:	f0 92 fd 05 	sts	0x05FD, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1534:	40 91 fe 05 	lds	r20, 0x05FE
    1538:	50 91 ff 05 	lds	r21, 0x05FF
    153c:	60 91 00 06 	lds	r22, 0x0600
    1540:	70 91 01 06 	lds	r23, 0x0601
    1544:	80 91 fa 05 	lds	r24, 0x05FA
    1548:	90 91 fb 05 	lds	r25, 0x05FB
    154c:	a0 91 fc 05 	lds	r26, 0x05FC
    1550:	b0 91 fd 05 	lds	r27, 0x05FD
    1554:	84 17       	cp	r24, r20
    1556:	95 07       	cpc	r25, r21
    1558:	a6 07       	cpc	r26, r22
    155a:	b7 07       	cpc	r27, r23
    155c:	50 f5       	brcc	.+84     	; 0x15b2 <UpdateAdjustedSampleAddresses+0x15e>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    155e:	80 91 e9 05 	lds	r24, 0x05E9
    1562:	81 30       	cpi	r24, 0x01	; 1
    1564:	19 f4       	brne	.+6      	; 0x156c <UpdateAdjustedSampleAddresses+0x118>
			{
				bankStates[BANK_0].sampleDirection=true;
    1566:	80 93 ea 05 	sts	0x05EA, r24
    156a:	02 c0       	rjmp	.+4      	; 0x1570 <UpdateAdjustedSampleAddresses+0x11c>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    156c:	10 92 ea 05 	sts	0x05EA, r1
			}

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    1570:	80 91 fe 05 	lds	r24, 0x05FE
    1574:	90 91 ff 05 	lds	r25, 0x05FF
    1578:	a0 91 00 06 	lds	r26, 0x0600
    157c:	b0 91 01 06 	lds	r27, 0x0601
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    1580:	40 91 fa 05 	lds	r20, 0x05FA
    1584:	50 91 fb 05 	lds	r21, 0x05FB
    1588:	60 91 fc 05 	lds	r22, 0x05FC
    158c:	70 91 fd 05 	lds	r23, 0x05FD
    1590:	40 93 fe 05 	sts	0x05FE, r20
    1594:	50 93 ff 05 	sts	0x05FF, r21
    1598:	60 93 00 06 	sts	0x0600, r22
    159c:	70 93 01 06 	sts	0x0601, r23
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    15a0:	80 93 fa 05 	sts	0x05FA, r24
    15a4:	90 93 fb 05 	sts	0x05FB, r25
    15a8:	a0 93 fc 05 	sts	0x05FC, r26
    15ac:	b0 93 fd 05 	sts	0x05FD, r27
    15b0:	0a c0       	rjmp	.+20     	; 0x15c6 <UpdateAdjustedSampleAddresses+0x172>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    15b2:	80 91 e9 05 	lds	r24, 0x05E9
    15b6:	81 30       	cpi	r24, 0x01	; 1
    15b8:	19 f4       	brne	.+6      	; 0x15c0 <UpdateAdjustedSampleAddresses+0x16c>
			{
				bankStates[BANK_0].sampleDirection=false;
    15ba:	10 92 ea 05 	sts	0x05EA, r1
    15be:	03 c0       	rjmp	.+6      	; 0x15c6 <UpdateAdjustedSampleAddresses+0x172>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	80 93 ea 05 	sts	0x05EA, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    15c6:	40 91 fe 05 	lds	r20, 0x05FE
    15ca:	50 91 ff 05 	lds	r21, 0x05FF
    15ce:	60 91 00 06 	lds	r22, 0x0600
    15d2:	70 91 01 06 	lds	r23, 0x0601
    15d6:	80 91 f2 05 	lds	r24, 0x05F2
    15da:	90 91 f3 05 	lds	r25, 0x05F3
    15de:	a0 91 f4 05 	lds	r26, 0x05F4
    15e2:	b0 91 f5 05 	lds	r27, 0x05F5
    15e6:	84 17       	cp	r24, r20
    15e8:	95 07       	cpc	r25, r21
    15ea:	a6 07       	cpc	r26, r22
    15ec:	b7 07       	cpc	r27, r23
    15ee:	e0 f4       	brcc	.+56     	; 0x1628 <UpdateAdjustedSampleAddresses+0x1d4>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    15f0:	80 91 fe 05 	lds	r24, 0x05FE
    15f4:	90 91 ff 05 	lds	r25, 0x05FF
    15f8:	a0 91 00 06 	lds	r26, 0x0600
    15fc:	b0 91 01 06 	lds	r27, 0x0601
    1600:	40 91 f2 05 	lds	r20, 0x05F2
    1604:	50 91 f3 05 	lds	r21, 0x05F3
    1608:	60 91 f4 05 	lds	r22, 0x05F4
    160c:	70 91 f5 05 	lds	r23, 0x05F5
    1610:	84 1b       	sub	r24, r20
    1612:	95 0b       	sbc	r25, r21
    1614:	a6 0b       	sbc	r26, r22
    1616:	b7 0b       	sbc	r27, r23
    1618:	80 93 fe 05 	sts	0x05FE, r24
    161c:	90 93 ff 05 	sts	0x05FF, r25
    1620:	a0 93 00 06 	sts	0x0600, r26
    1624:	b0 93 01 06 	sts	0x0601, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    1628:	40 91 fa 05 	lds	r20, 0x05FA
    162c:	50 91 fb 05 	lds	r21, 0x05FB
    1630:	60 91 fc 05 	lds	r22, 0x05FC
    1634:	70 91 fd 05 	lds	r23, 0x05FD
    1638:	80 91 f2 05 	lds	r24, 0x05F2
    163c:	90 91 f3 05 	lds	r25, 0x05F3
    1640:	a0 91 f4 05 	lds	r26, 0x05F4
    1644:	b0 91 f5 05 	lds	r27, 0x05F5
    1648:	84 17       	cp	r24, r20
    164a:	95 07       	cpc	r25, r21
    164c:	a6 07       	cpc	r26, r22
    164e:	b7 07       	cpc	r27, r23
    1650:	08 f0       	brcs	.+2      	; 0x1654 <UpdateAdjustedSampleAddresses+0x200>
    1652:	44 c0       	rjmp	.+136    	; 0x16dc <UpdateAdjustedSampleAddresses+0x288>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1654:	80 91 fa 05 	lds	r24, 0x05FA
    1658:	90 91 fb 05 	lds	r25, 0x05FB
    165c:	a0 91 fc 05 	lds	r26, 0x05FC
    1660:	b0 91 fd 05 	lds	r27, 0x05FD
    1664:	40 91 f2 05 	lds	r20, 0x05F2
    1668:	50 91 f3 05 	lds	r21, 0x05F3
    166c:	60 91 f4 05 	lds	r22, 0x05F4
    1670:	70 91 f5 05 	lds	r23, 0x05F5
    1674:	84 1b       	sub	r24, r20
    1676:	95 0b       	sbc	r25, r21
    1678:	a6 0b       	sbc	r26, r22
    167a:	b7 0b       	sbc	r27, r23
    167c:	80 93 fa 05 	sts	0x05FA, r24
    1680:	90 93 fb 05 	sts	0x05FB, r25
    1684:	a0 93 fc 05 	sts	0x05FC, r26
    1688:	b0 93 fd 05 	sts	0x05FD, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    168c:	40 91 fa 05 	lds	r20, 0x05FA
    1690:	50 91 fb 05 	lds	r21, 0x05FB
    1694:	60 91 fc 05 	lds	r22, 0x05FC
    1698:	70 91 fd 05 	lds	r23, 0x05FD
    169c:	80 91 fe 05 	lds	r24, 0x05FE
    16a0:	90 91 ff 05 	lds	r25, 0x05FF
    16a4:	a0 91 00 06 	lds	r26, 0x0600
    16a8:	b0 91 01 06 	lds	r27, 0x0601
    16ac:	48 17       	cp	r20, r24
    16ae:	59 07       	cpc	r21, r25
    16b0:	6a 07       	cpc	r22, r26
    16b2:	7b 07       	cpc	r23, r27
    16b4:	99 f4       	brne	.+38     	; 0x16dc <UpdateAdjustedSampleAddresses+0x288>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    16b6:	80 91 fa 05 	lds	r24, 0x05FA
    16ba:	90 91 fb 05 	lds	r25, 0x05FB
    16be:	a0 91 fc 05 	lds	r26, 0x05FC
    16c2:	b0 91 fd 05 	lds	r27, 0x05FD
    16c6:	01 97       	sbiw	r24, 0x01	; 1
    16c8:	a1 09       	sbc	r26, r1
    16ca:	b1 09       	sbc	r27, r1
    16cc:	80 93 fa 05 	sts	0x05FA, r24
    16d0:	90 93 fb 05 	sts	0x05FB, r25
    16d4:	a0 93 fc 05 	sts	0x05FC, r26
    16d8:	b0 93 fd 05 	sts	0x05FD, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    16dc:	40 91 fe 05 	lds	r20, 0x05FE
    16e0:	50 91 ff 05 	lds	r21, 0x05FF
    16e4:	60 91 00 06 	lds	r22, 0x0600
    16e8:	70 91 01 06 	lds	r23, 0x0601
    16ec:	80 91 fa 05 	lds	r24, 0x05FA
    16f0:	90 91 fb 05 	lds	r25, 0x05FB
    16f4:	a0 91 fc 05 	lds	r26, 0x05FC
    16f8:	b0 91 fd 05 	lds	r27, 0x05FD
    16fc:	84 17       	cp	r24, r20
    16fe:	95 07       	cpc	r25, r21
    1700:	a6 07       	cpc	r26, r22
    1702:	b7 07       	cpc	r27, r23
    1704:	08 f0       	brcs	.+2      	; 0x1708 <UpdateAdjustedSampleAddresses+0x2b4>
    1706:	5a c0       	rjmp	.+180    	; 0x17bc <UpdateAdjustedSampleAddresses+0x368>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1708:	40 91 05 06 	lds	r20, 0x0605
    170c:	50 91 06 06 	lds	r21, 0x0606
    1710:	60 91 07 06 	lds	r22, 0x0607
    1714:	70 91 08 06 	lds	r23, 0x0608
    1718:	80 91 fe 05 	lds	r24, 0x05FE
    171c:	90 91 ff 05 	lds	r25, 0x05FF
    1720:	a0 91 00 06 	lds	r26, 0x0600
    1724:	b0 91 01 06 	lds	r27, 0x0601
    1728:	48 17       	cp	r20, r24
    172a:	59 07       	cpc	r21, r25
    172c:	6a 07       	cpc	r22, r26
    172e:	7b 07       	cpc	r23, r27
    1730:	08 f0       	brcs	.+2      	; 0x1734 <UpdateAdjustedSampleAddresses+0x2e0>
    1732:	86 c2       	rjmp	.+1292   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
    1734:	40 91 05 06 	lds	r20, 0x0605
    1738:	50 91 06 06 	lds	r21, 0x0606
    173c:	60 91 07 06 	lds	r22, 0x0607
    1740:	70 91 08 06 	lds	r23, 0x0608
    1744:	80 91 fa 05 	lds	r24, 0x05FA
    1748:	90 91 fb 05 	lds	r25, 0x05FB
    174c:	a0 91 fc 05 	lds	r26, 0x05FC
    1750:	b0 91 fd 05 	lds	r27, 0x05FD
    1754:	84 17       	cp	r24, r20
    1756:	95 07       	cpc	r25, r21
    1758:	a6 07       	cpc	r26, r22
    175a:	b7 07       	cpc	r27, r23
    175c:	08 f0       	brcs	.+2      	; 0x1760 <UpdateAdjustedSampleAddresses+0x30c>
    175e:	70 c2       	rjmp	.+1248   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?
    1760:	40 91 fe 05 	lds	r20, 0x05FE
    1764:	50 91 ff 05 	lds	r21, 0x05FF
    1768:	60 91 00 06 	lds	r22, 0x0600
    176c:	70 91 01 06 	lds	r23, 0x0601
    1770:	80 90 05 06 	lds	r8, 0x0605
    1774:	90 90 06 06 	lds	r9, 0x0606
    1778:	a0 90 07 06 	lds	r10, 0x0607
    177c:	b0 90 08 06 	lds	r11, 0x0608
    1780:	80 91 05 06 	lds	r24, 0x0605
    1784:	90 91 06 06 	lds	r25, 0x0606
    1788:	a0 91 07 06 	lds	r26, 0x0607
    178c:	b0 91 08 06 	lds	r27, 0x0608
    1790:	c0 90 fa 05 	lds	r12, 0x05FA
    1794:	d0 90 fb 05 	lds	r13, 0x05FB
    1798:	e0 90 fc 05 	lds	r14, 0x05FC
    179c:	f0 90 fd 05 	lds	r15, 0x05FD
    17a0:	48 19       	sub	r20, r8
    17a2:	59 09       	sbc	r21, r9
    17a4:	6a 09       	sbc	r22, r10
    17a6:	7b 09       	sbc	r23, r11
    17a8:	8c 19       	sub	r24, r12
    17aa:	9d 09       	sbc	r25, r13
    17ac:	ae 09       	sbc	r26, r14
    17ae:	bf 09       	sbc	r27, r15
    17b0:	48 17       	cp	r20, r24
    17b2:	59 07       	cpc	r21, r25
    17b4:	6a 07       	cpc	r22, r26
    17b6:	7b 07       	cpc	r23, r27
    17b8:	e8 f1       	brcs	.+122    	; 0x1834 <UpdateAdjustedSampleAddresses+0x3e0>
    17ba:	15 c0       	rjmp	.+42     	; 0x17e6 <UpdateAdjustedSampleAddresses+0x392>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    17bc:	40 91 05 06 	lds	r20, 0x0605
    17c0:	50 91 06 06 	lds	r21, 0x0606
    17c4:	60 91 07 06 	lds	r22, 0x0607
    17c8:	70 91 08 06 	lds	r23, 0x0608
    17cc:	80 91 fe 05 	lds	r24, 0x05FE
    17d0:	90 91 ff 05 	lds	r25, 0x05FF
    17d4:	a0 91 00 06 	lds	r26, 0x0600
    17d8:	b0 91 01 06 	lds	r27, 0x0601
    17dc:	48 17       	cp	r20, r24
    17de:	59 07       	cpc	r21, r25
    17e0:	6a 07       	cpc	r22, r26
    17e2:	7b 07       	cpc	r23, r27
    17e4:	88 f4       	brcc	.+34     	; 0x1808 <UpdateAdjustedSampleAddresses+0x3b4>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    17e6:	80 91 fe 05 	lds	r24, 0x05FE
    17ea:	90 91 ff 05 	lds	r25, 0x05FF
    17ee:	a0 91 00 06 	lds	r26, 0x0600
    17f2:	b0 91 01 06 	lds	r27, 0x0601
    17f6:	80 93 05 06 	sts	0x0605, r24
    17fa:	90 93 06 06 	sts	0x0606, r25
    17fe:	a0 93 07 06 	sts	0x0607, r26
    1802:	b0 93 08 06 	sts	0x0608, r27
    1806:	1c c2       	rjmp	.+1080   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			}
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    1808:	40 91 05 06 	lds	r20, 0x0605
    180c:	50 91 06 06 	lds	r21, 0x0606
    1810:	60 91 07 06 	lds	r22, 0x0607
    1814:	70 91 08 06 	lds	r23, 0x0608
    1818:	80 91 fa 05 	lds	r24, 0x05FA
    181c:	90 91 fb 05 	lds	r25, 0x05FB
    1820:	a0 91 fc 05 	lds	r26, 0x05FC
    1824:	b0 91 fd 05 	lds	r27, 0x05FD
    1828:	84 17       	cp	r24, r20
    182a:	95 07       	cpc	r25, r21
    182c:	a6 07       	cpc	r26, r22
    182e:	b7 07       	cpc	r27, r23
    1830:	08 f0       	brcs	.+2      	; 0x1834 <UpdateAdjustedSampleAddresses+0x3e0>
    1832:	06 c2       	rjmp	.+1036   	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1834:	80 91 fa 05 	lds	r24, 0x05FA
    1838:	90 91 fb 05 	lds	r25, 0x05FB
    183c:	a0 91 fc 05 	lds	r26, 0x05FC
    1840:	b0 91 fd 05 	lds	r27, 0x05FD
    1844:	d8 cf       	rjmp	.-80     	; 0x17f6 <UpdateAdjustedSampleAddresses+0x3a2>
		}
	}
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    1846:	80 91 15 06 	lds	r24, 0x0615
    184a:	90 91 16 06 	lds	r25, 0x0616
    184e:	a0 91 17 06 	lds	r26, 0x0617
    1852:	b0 91 18 06 	lds	r27, 0x0618
    1856:	cc 24       	eor	r12, r12
    1858:	ca 94       	dec	r12
    185a:	dc 2c       	mov	r13, r12
    185c:	27 e0       	ldi	r18, 0x07	; 7
    185e:	e2 2e       	mov	r14, r18
    1860:	f1 2c       	mov	r15, r1
    1862:	46 01       	movw	r8, r12
    1864:	57 01       	movw	r10, r14
    1866:	88 1a       	sub	r8, r24
    1868:	99 0a       	sbc	r9, r25
    186a:	aa 0a       	sbc	r10, r26
    186c:	bb 0a       	sbc	r11, r27
    186e:	33 e0       	ldi	r19, 0x03	; 3
    1870:	88 0c       	add	r8, r8
    1872:	99 1c       	adc	r9, r9
    1874:	aa 1c       	adc	r10, r10
    1876:	bb 1c       	adc	r11, r11
    1878:	3a 95       	dec	r19
    187a:	d1 f7       	brne	.-12     	; 0x1870 <UpdateAdjustedSampleAddresses+0x41c>
    187c:	89 2c       	mov	r8, r9
    187e:	9a 2c       	mov	r9, r10
    1880:	ab 2c       	mov	r10, r11
    1882:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1884:	a0 91 25 06 	lds	r26, 0x0625
    1888:	80 91 27 06 	lds	r24, 0x0627
    188c:	b0 e0       	ldi	r27, 0x00	; 0
    188e:	a8 0f       	add	r26, r24
    1890:	b1 1d       	adc	r27, r1
    1892:	a5 01       	movw	r20, r10
    1894:	94 01       	movw	r18, r8
    1896:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    189a:	f3 e0       	ldi	r31, 0x03	; 3
    189c:	96 95       	lsr	r25
    189e:	87 95       	ror	r24
    18a0:	77 95       	ror	r23
    18a2:	67 95       	ror	r22
    18a4:	fa 95       	dec	r31
    18a6:	d1 f7       	brne	.-12     	; 0x189c <UpdateAdjustedSampleAddresses+0x448>
    18a8:	c6 1a       	sub	r12, r22
    18aa:	d7 0a       	sbc	r13, r23
    18ac:	e8 0a       	sbc	r14, r24
    18ae:	f9 0a       	sbc	r15, r25
    18b0:	c0 92 21 06 	sts	0x0621, r12
    18b4:	d0 92 22 06 	sts	0x0622, r13
    18b8:	e0 92 23 06 	sts	0x0623, r14
    18bc:	f0 92 24 06 	sts	0x0624, r15
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    18c0:	40 90 15 06 	lds	r4, 0x0615
    18c4:	50 90 16 06 	lds	r5, 0x0616
    18c8:	60 90 17 06 	lds	r6, 0x0617
    18cc:	70 90 18 06 	lds	r7, 0x0618
    18d0:	a0 91 26 06 	lds	r26, 0x0626
    18d4:	f0 91 27 06 	lds	r31, 0x0627
    18d8:	b0 e0       	ldi	r27, 0x00	; 0
    18da:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    18de:	6b 01       	movw	r12, r22
    18e0:	7c 01       	movw	r14, r24
    18e2:	a3 e0       	ldi	r26, 0x03	; 3
    18e4:	f6 94       	lsr	r15
    18e6:	e7 94       	ror	r14
    18e8:	d7 94       	ror	r13
    18ea:	c7 94       	ror	r12
    18ec:	aa 95       	dec	r26
    18ee:	d1 f7       	brne	.-12     	; 0x18e4 <UpdateAdjustedSampleAddresses+0x490>
    18f0:	c4 0c       	add	r12, r4
    18f2:	d5 1c       	adc	r13, r5
    18f4:	e6 1c       	adc	r14, r6
    18f6:	f7 1c       	adc	r15, r7
    18f8:	af 2f       	mov	r26, r31
    18fa:	b0 e0       	ldi	r27, 0x00	; 0
    18fc:	0e 94 cb 28 	call	0x5196	; 0x5196 <__muluhisi3>
    1900:	b3 e0       	ldi	r27, 0x03	; 3
    1902:	96 95       	lsr	r25
    1904:	87 95       	ror	r24
    1906:	77 95       	ror	r23
    1908:	67 95       	ror	r22
    190a:	ba 95       	dec	r27
    190c:	d1 f7       	brne	.-12     	; 0x1902 <UpdateAdjustedSampleAddresses+0x4ae>
    190e:	c6 1a       	sub	r12, r22
    1910:	d7 0a       	sbc	r13, r23
    1912:	e8 0a       	sbc	r14, r24
    1914:	f9 0a       	sbc	r15, r25
    1916:	c0 92 1d 06 	sts	0x061D, r12
    191a:	d0 92 1e 06 	sts	0x061E, r13
    191e:	e0 92 1f 06 	sts	0x061F, r14
    1922:	f0 92 20 06 	sts	0x0620, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1926:	40 91 21 06 	lds	r20, 0x0621
    192a:	50 91 22 06 	lds	r21, 0x0622
    192e:	60 91 23 06 	lds	r22, 0x0623
    1932:	70 91 24 06 	lds	r23, 0x0624
    1936:	80 91 1d 06 	lds	r24, 0x061D
    193a:	90 91 1e 06 	lds	r25, 0x061E
    193e:	a0 91 1f 06 	lds	r26, 0x061F
    1942:	b0 91 20 06 	lds	r27, 0x0620
    1946:	48 17       	cp	r20, r24
    1948:	59 07       	cpc	r21, r25
    194a:	6a 07       	cpc	r22, r26
    194c:	7b 07       	cpc	r23, r27
    194e:	50 f5       	brcc	.+84     	; 0x19a4 <UpdateAdjustedSampleAddresses+0x550>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1950:	80 91 0c 06 	lds	r24, 0x060C
    1954:	81 30       	cpi	r24, 0x01	; 1
    1956:	19 f4       	brne	.+6      	; 0x195e <UpdateAdjustedSampleAddresses+0x50a>
			{
				bankStates[BANK_1].sampleDirection=true;
    1958:	80 93 0d 06 	sts	0x060D, r24
    195c:	02 c0       	rjmp	.+4      	; 0x1962 <UpdateAdjustedSampleAddresses+0x50e>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    195e:	10 92 0d 06 	sts	0x060D, r1
			}

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    1962:	80 91 21 06 	lds	r24, 0x0621
    1966:	90 91 22 06 	lds	r25, 0x0622
    196a:	a0 91 23 06 	lds	r26, 0x0623
    196e:	b0 91 24 06 	lds	r27, 0x0624
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    1972:	40 91 1d 06 	lds	r20, 0x061D
    1976:	50 91 1e 06 	lds	r21, 0x061E
    197a:	60 91 1f 06 	lds	r22, 0x061F
    197e:	70 91 20 06 	lds	r23, 0x0620
    1982:	40 93 21 06 	sts	0x0621, r20
    1986:	50 93 22 06 	sts	0x0622, r21
    198a:	60 93 23 06 	sts	0x0623, r22
    198e:	70 93 24 06 	sts	0x0624, r23
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    1992:	80 93 1d 06 	sts	0x061D, r24
    1996:	90 93 1e 06 	sts	0x061E, r25
    199a:	a0 93 1f 06 	sts	0x061F, r26
    199e:	b0 93 20 06 	sts	0x0620, r27
    19a2:	0a c0       	rjmp	.+20     	; 0x19b8 <UpdateAdjustedSampleAddresses+0x564>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    19a4:	80 91 0c 06 	lds	r24, 0x060C
    19a8:	81 30       	cpi	r24, 0x01	; 1
    19aa:	19 f4       	brne	.+6      	; 0x19b2 <UpdateAdjustedSampleAddresses+0x55e>
			{
				bankStates[BANK_1].sampleDirection=false;
    19ac:	10 92 0d 06 	sts	0x060D, r1
    19b0:	03 c0       	rjmp	.+6      	; 0x19b8 <UpdateAdjustedSampleAddresses+0x564>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    19b2:	81 e0       	ldi	r24, 0x01	; 1
    19b4:	80 93 0d 06 	sts	0x060D, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    19b8:	40 91 21 06 	lds	r20, 0x0621
    19bc:	50 91 22 06 	lds	r21, 0x0622
    19c0:	60 91 23 06 	lds	r22, 0x0623
    19c4:	70 91 24 06 	lds	r23, 0x0624
    19c8:	80 91 15 06 	lds	r24, 0x0615
    19cc:	90 91 16 06 	lds	r25, 0x0616
    19d0:	a0 91 17 06 	lds	r26, 0x0617
    19d4:	b0 91 18 06 	lds	r27, 0x0618
    19d8:	48 17       	cp	r20, r24
    19da:	59 07       	cpc	r21, r25
    19dc:	6a 07       	cpc	r22, r26
    19de:	7b 07       	cpc	r23, r27
    19e0:	f8 f4       	brcc	.+62     	; 0x1a20 <UpdateAdjustedSampleAddresses+0x5cc>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    19e2:	80 91 21 06 	lds	r24, 0x0621
    19e6:	90 91 22 06 	lds	r25, 0x0622
    19ea:	a0 91 23 06 	lds	r26, 0x0623
    19ee:	b0 91 24 06 	lds	r27, 0x0624
    19f2:	40 91 15 06 	lds	r20, 0x0615
    19f6:	50 91 16 06 	lds	r21, 0x0616
    19fa:	60 91 17 06 	lds	r22, 0x0617
    19fe:	70 91 18 06 	lds	r23, 0x0618
    1a02:	01 97       	sbiw	r24, 0x01	; 1
    1a04:	a8 4f       	sbci	r26, 0xF8	; 248
    1a06:	bf 4f       	sbci	r27, 0xFF	; 255
    1a08:	84 1b       	sub	r24, r20
    1a0a:	95 0b       	sbc	r25, r21
    1a0c:	a6 0b       	sbc	r26, r22
    1a0e:	b7 0b       	sbc	r27, r23
    1a10:	80 93 21 06 	sts	0x0621, r24
    1a14:	90 93 22 06 	sts	0x0622, r25
    1a18:	a0 93 23 06 	sts	0x0623, r26
    1a1c:	b0 93 24 06 	sts	0x0624, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    1a20:	40 91 1d 06 	lds	r20, 0x061D
    1a24:	50 91 1e 06 	lds	r21, 0x061E
    1a28:	60 91 1f 06 	lds	r22, 0x061F
    1a2c:	70 91 20 06 	lds	r23, 0x0620
    1a30:	80 91 15 06 	lds	r24, 0x0615
    1a34:	90 91 16 06 	lds	r25, 0x0616
    1a38:	a0 91 17 06 	lds	r26, 0x0617
    1a3c:	b0 91 18 06 	lds	r27, 0x0618
    1a40:	48 17       	cp	r20, r24
    1a42:	59 07       	cpc	r21, r25
    1a44:	6a 07       	cpc	r22, r26
    1a46:	7b 07       	cpc	r23, r27
    1a48:	08 f0       	brcs	.+2      	; 0x1a4c <UpdateAdjustedSampleAddresses+0x5f8>
    1a4a:	47 c0       	rjmp	.+142    	; 0x1ada <UpdateAdjustedSampleAddresses+0x686>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    1a4c:	80 91 1d 06 	lds	r24, 0x061D
    1a50:	90 91 1e 06 	lds	r25, 0x061E
    1a54:	a0 91 1f 06 	lds	r26, 0x061F
    1a58:	b0 91 20 06 	lds	r27, 0x0620
    1a5c:	40 91 15 06 	lds	r20, 0x0615
    1a60:	50 91 16 06 	lds	r21, 0x0616
    1a64:	60 91 17 06 	lds	r22, 0x0617
    1a68:	70 91 18 06 	lds	r23, 0x0618
    1a6c:	01 97       	sbiw	r24, 0x01	; 1
    1a6e:	a8 4f       	sbci	r26, 0xF8	; 248
    1a70:	bf 4f       	sbci	r27, 0xFF	; 255
    1a72:	84 1b       	sub	r24, r20
    1a74:	95 0b       	sbc	r25, r21
    1a76:	a6 0b       	sbc	r26, r22
    1a78:	b7 0b       	sbc	r27, r23
    1a7a:	80 93 1d 06 	sts	0x061D, r24
    1a7e:	90 93 1e 06 	sts	0x061E, r25
    1a82:	a0 93 1f 06 	sts	0x061F, r26
    1a86:	b0 93 20 06 	sts	0x0620, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    1a8a:	40 91 1d 06 	lds	r20, 0x061D
    1a8e:	50 91 1e 06 	lds	r21, 0x061E
    1a92:	60 91 1f 06 	lds	r22, 0x061F
    1a96:	70 91 20 06 	lds	r23, 0x0620
    1a9a:	80 91 21 06 	lds	r24, 0x0621
    1a9e:	90 91 22 06 	lds	r25, 0x0622
    1aa2:	a0 91 23 06 	lds	r26, 0x0623
    1aa6:	b0 91 24 06 	lds	r27, 0x0624
    1aaa:	48 17       	cp	r20, r24
    1aac:	59 07       	cpc	r21, r25
    1aae:	6a 07       	cpc	r22, r26
    1ab0:	7b 07       	cpc	r23, r27
    1ab2:	99 f4       	brne	.+38     	; 0x1ada <UpdateAdjustedSampleAddresses+0x686>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    1ab4:	80 91 1d 06 	lds	r24, 0x061D
    1ab8:	90 91 1e 06 	lds	r25, 0x061E
    1abc:	a0 91 1f 06 	lds	r26, 0x061F
    1ac0:	b0 91 20 06 	lds	r27, 0x0620
    1ac4:	01 96       	adiw	r24, 0x01	; 1
    1ac6:	a1 1d       	adc	r26, r1
    1ac8:	b1 1d       	adc	r27, r1
    1aca:	80 93 1d 06 	sts	0x061D, r24
    1ace:	90 93 1e 06 	sts	0x061E, r25
    1ad2:	a0 93 1f 06 	sts	0x061F, r26
    1ad6:	b0 93 20 06 	sts	0x0620, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    1ada:	40 91 21 06 	lds	r20, 0x0621
    1ade:	50 91 22 06 	lds	r21, 0x0622
    1ae2:	60 91 23 06 	lds	r22, 0x0623
    1ae6:	70 91 24 06 	lds	r23, 0x0624
    1aea:	80 91 1d 06 	lds	r24, 0x061D
    1aee:	90 91 1e 06 	lds	r25, 0x061E
    1af2:	a0 91 1f 06 	lds	r26, 0x061F
    1af6:	b0 91 20 06 	lds	r27, 0x0620
    1afa:	48 17       	cp	r20, r24
    1afc:	59 07       	cpc	r21, r25
    1afe:	6a 07       	cpc	r22, r26
    1b00:	7b 07       	cpc	r23, r27
    1b02:	08 f0       	brcs	.+2      	; 0x1b06 <UpdateAdjustedSampleAddresses+0x6b2>
    1b04:	5a c0       	rjmp	.+180    	; 0x1bba <UpdateAdjustedSampleAddresses+0x766>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1b06:	40 91 28 06 	lds	r20, 0x0628
    1b0a:	50 91 29 06 	lds	r21, 0x0629
    1b0e:	60 91 2a 06 	lds	r22, 0x062A
    1b12:	70 91 2b 06 	lds	r23, 0x062B
    1b16:	80 91 21 06 	lds	r24, 0x0621
    1b1a:	90 91 22 06 	lds	r25, 0x0622
    1b1e:	a0 91 23 06 	lds	r26, 0x0623
    1b22:	b0 91 24 06 	lds	r27, 0x0624
    1b26:	84 17       	cp	r24, r20
    1b28:	95 07       	cpc	r25, r21
    1b2a:	a6 07       	cpc	r26, r22
    1b2c:	b7 07       	cpc	r27, r23
    1b2e:	08 f0       	brcs	.+2      	; 0x1b32 <UpdateAdjustedSampleAddresses+0x6de>
    1b30:	87 c0       	rjmp	.+270    	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
    1b32:	40 91 28 06 	lds	r20, 0x0628
    1b36:	50 91 29 06 	lds	r21, 0x0629
    1b3a:	60 91 2a 06 	lds	r22, 0x062A
    1b3e:	70 91 2b 06 	lds	r23, 0x062B
    1b42:	80 91 1d 06 	lds	r24, 0x061D
    1b46:	90 91 1e 06 	lds	r25, 0x061E
    1b4a:	a0 91 1f 06 	lds	r26, 0x061F
    1b4e:	b0 91 20 06 	lds	r27, 0x0620
    1b52:	48 17       	cp	r20, r24
    1b54:	59 07       	cpc	r21, r25
    1b56:	6a 07       	cpc	r22, r26
    1b58:	7b 07       	cpc	r23, r27
    1b5a:	08 f0       	brcs	.+2      	; 0x1b5e <UpdateAdjustedSampleAddresses+0x70a>
    1b5c:	71 c0       	rjmp	.+226    	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?
    1b5e:	40 91 28 06 	lds	r20, 0x0628
    1b62:	50 91 29 06 	lds	r21, 0x0629
    1b66:	60 91 2a 06 	lds	r22, 0x062A
    1b6a:	70 91 2b 06 	lds	r23, 0x062B
    1b6e:	80 90 21 06 	lds	r8, 0x0621
    1b72:	90 90 22 06 	lds	r9, 0x0622
    1b76:	a0 90 23 06 	lds	r10, 0x0623
    1b7a:	b0 90 24 06 	lds	r11, 0x0624
    1b7e:	80 91 1d 06 	lds	r24, 0x061D
    1b82:	90 91 1e 06 	lds	r25, 0x061E
    1b86:	a0 91 1f 06 	lds	r26, 0x061F
    1b8a:	b0 91 20 06 	lds	r27, 0x0620
    1b8e:	c0 90 28 06 	lds	r12, 0x0628
    1b92:	d0 90 29 06 	lds	r13, 0x0629
    1b96:	e0 90 2a 06 	lds	r14, 0x062A
    1b9a:	f0 90 2b 06 	lds	r15, 0x062B
    1b9e:	48 19       	sub	r20, r8
    1ba0:	59 09       	sbc	r21, r9
    1ba2:	6a 09       	sbc	r22, r10
    1ba4:	7b 09       	sbc	r23, r11
    1ba6:	8c 19       	sub	r24, r12
    1ba8:	9d 09       	sbc	r25, r13
    1baa:	ae 09       	sbc	r26, r14
    1bac:	bf 09       	sbc	r27, r15
    1bae:	84 17       	cp	r24, r20
    1bb0:	95 07       	cpc	r25, r21
    1bb2:	a6 07       	cpc	r26, r22
    1bb4:	b7 07       	cpc	r27, r23
    1bb6:	a0 f1       	brcs	.+104    	; 0x1c20 <UpdateAdjustedSampleAddresses+0x7cc>
    1bb8:	15 c0       	rjmp	.+42     	; 0x1be4 <UpdateAdjustedSampleAddresses+0x790>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    1bba:	40 91 28 06 	lds	r20, 0x0628
    1bbe:	50 91 29 06 	lds	r21, 0x0629
    1bc2:	60 91 2a 06 	lds	r22, 0x062A
    1bc6:	70 91 2b 06 	lds	r23, 0x062B
    1bca:	80 91 21 06 	lds	r24, 0x0621
    1bce:	90 91 22 06 	lds	r25, 0x0622
    1bd2:	a0 91 23 06 	lds	r26, 0x0623
    1bd6:	b0 91 24 06 	lds	r27, 0x0624
    1bda:	84 17       	cp	r24, r20
    1bdc:	95 07       	cpc	r25, r21
    1bde:	a6 07       	cpc	r26, r22
    1be0:	b7 07       	cpc	r27, r23
    1be2:	48 f4       	brcc	.+18     	; 0x1bf6 <UpdateAdjustedSampleAddresses+0x7a2>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    1be4:	80 91 21 06 	lds	r24, 0x0621
    1be8:	90 91 22 06 	lds	r25, 0x0622
    1bec:	a0 91 23 06 	lds	r26, 0x0623
    1bf0:	b0 91 24 06 	lds	r27, 0x0624
    1bf4:	1d c0       	rjmp	.+58     	; 0x1c30 <UpdateAdjustedSampleAddresses+0x7dc>
			}
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    1bf6:	40 91 28 06 	lds	r20, 0x0628
    1bfa:	50 91 29 06 	lds	r21, 0x0629
    1bfe:	60 91 2a 06 	lds	r22, 0x062A
    1c02:	70 91 2b 06 	lds	r23, 0x062B
    1c06:	80 91 1d 06 	lds	r24, 0x061D
    1c0a:	90 91 1e 06 	lds	r25, 0x061E
    1c0e:	a0 91 1f 06 	lds	r26, 0x061F
    1c12:	b0 91 20 06 	lds	r27, 0x0620
    1c16:	48 17       	cp	r20, r24
    1c18:	59 07       	cpc	r21, r25
    1c1a:	6a 07       	cpc	r22, r26
    1c1c:	7b 07       	cpc	r23, r27
    1c1e:	80 f4       	brcc	.+32     	; 0x1c40 <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1c20:	80 91 1d 06 	lds	r24, 0x061D
    1c24:	90 91 1e 06 	lds	r25, 0x061E
    1c28:	a0 91 1f 06 	lds	r26, 0x061F
    1c2c:	b0 91 20 06 	lds	r27, 0x0620
    1c30:	80 93 28 06 	sts	0x0628, r24
    1c34:	90 93 29 06 	sts	0x0629, r25
    1c38:	a0 93 2a 06 	sts	0x062A, r26
    1c3c:	b0 93 2b 06 	sts	0x062B, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    1c40:	ef bf       	out	0x3f, r30	; 63
}
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	bf 90       	pop	r11
    1c4c:	af 90       	pop	r10
    1c4e:	9f 90       	pop	r9
    1c50:	8f 90       	pop	r8
    1c52:	7f 90       	pop	r7
    1c54:	6f 90       	pop	r6
    1c56:	5f 90       	pop	r5
    1c58:	4f 90       	pop	r4
    1c5a:	08 95       	ret

00001c5c <RevertSampleToUnadjusted>:
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    1c5c:	9f b7       	in	r25, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1c5e:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    1c60:	23 e2       	ldi	r18, 0x23	; 35
    1c62:	82 9f       	mul	r24, r18
    1c64:	f0 01       	movw	r30, r0
    1c66:	11 24       	eor	r1, r1
    1c68:	ea 51       	subi	r30, 0x1A	; 26
    1c6a:	fa 4f       	sbci	r31, 0xFA	; 250
    1c6c:	40 89       	ldd	r20, Z+16	; 0x10
    1c6e:	51 89       	ldd	r21, Z+17	; 0x11
    1c70:	62 89       	ldd	r22, Z+18	; 0x12
    1c72:	73 89       	ldd	r23, Z+19	; 0x13
    1c74:	40 8f       	std	Z+24, r20	; 0x18
    1c76:	51 8f       	std	Z+25, r21	; 0x19
    1c78:	62 8f       	std	Z+26, r22	; 0x1a
    1c7a:	73 8f       	std	Z+27, r23	; 0x1b
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    1c7c:	44 85       	ldd	r20, Z+12	; 0x0c
    1c7e:	55 85       	ldd	r21, Z+13	; 0x0d
    1c80:	66 85       	ldd	r22, Z+14	; 0x0e
    1c82:	77 85       	ldd	r23, Z+15	; 0x0f
    1c84:	44 8b       	std	Z+20, r20	; 0x14
    1c86:	55 8b       	std	Z+21, r21	; 0x15
    1c88:	66 8b       	std	Z+22, r22	; 0x16
    1c8a:	77 8b       	std	Z+23, r23	; 0x17
	bankStates[theBank].sampleStartOffset=0;
    1c8c:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleEndOffset=0;
    1c8e:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleWindowOffset=0;
    1c90:	16 8e       	std	Z+30, r1	; 0x1e
	SREG=sreg;		// Restore interrupts.
    1c92:	9f bf       	out	0x3f, r25	; 63
    1c94:	08 95       	ret

00001c96 <BlinkLeds>:
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1c96:	40 91 7a 05 	lds	r20, 0x057A
    1c9a:	50 e0       	ldi	r21, 0x00	; 0
    1c9c:	90 91 5d 05 	lds	r25, 0x055D
    1ca0:	20 e0       	ldi	r18, 0x00	; 0
    1ca2:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	70 e0       	ldi	r23, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1ca8:	da 01       	movw	r26, r20
    1caa:	02 2e       	mov	r0, r18
    1cac:	02 c0       	rjmp	.+4      	; 0x1cb2 <BlinkLeds+0x1c>
    1cae:	b5 95       	asr	r27
    1cb0:	a7 95       	ror	r26
    1cb2:	0a 94       	dec	r0
    1cb4:	e2 f7       	brpl	.-8      	; 0x1cae <BlinkLeds+0x18>
    1cb6:	a0 ff       	sbrs	r26, 0
    1cb8:	0a c0       	rjmp	.+20     	; 0x1cce <BlinkLeds+0x38>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1cba:	db 01       	movw	r26, r22
    1cbc:	02 2e       	mov	r0, r18
    1cbe:	02 c0       	rjmp	.+4      	; 0x1cc4 <BlinkLeds+0x2e>
    1cc0:	aa 0f       	add	r26, r26
    1cc2:	bb 1f       	adc	r27, r27
    1cc4:	0a 94       	dec	r0
    1cc6:	e2 f7       	brpl	.-8      	; 0x1cc0 <BlinkLeds+0x2a>
    1cc8:	fd 01       	movw	r30, r26
    1cca:	e0 95       	com	r30
    1ccc:	9e 23       	and	r25, r30
    1cce:	2f 5f       	subi	r18, 0xFF	; 255
    1cd0:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    1cd2:	28 30       	cpi	r18, 0x08	; 8
    1cd4:	31 05       	cpc	r19, r1
    1cd6:	41 f7       	brne	.-48     	; 0x1ca8 <BlinkLeds+0x12>
    1cd8:	90 93 5d 05 	sts	0x055D, r25
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    1cdc:	80 93 7a 05 	sts	0x057A, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    1ce0:	68 e9       	ldi	r22, 0x98	; 152
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	82 e0       	ldi	r24, 0x02	; 2
    1ce6:	0c 94 46 1e 	jmp	0x3c8c	; 0x3c8c <SetTimer>

00001cea <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    1cea:	10 92 5d 05 	sts	0x055D, r1
	BlinkLeds(0);		// Durrrr.....
    1cee:	80 e0       	ldi	r24, 0x00	; 0
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <BlinkLeds>

00001cf6 <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    1cf6:	cf 93       	push	r28
	static unsigned char
		i;

	if(subState==SS_0)
    1cf8:	c0 91 5b 05 	lds	r28, 0x055B
    1cfc:	c1 11       	cpse	r28, r1
    1cfe:	11 c0       	rjmp	.+34     	; 0x1d22 <DoFruitcakeIntro+0x2c>
	{
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    1d00:	10 92 59 05 	sts	0x0559, r1

		KillLeds();
    1d04:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		i=0;
    1d08:	10 92 5c 05 	sts	0x055C, r1
		ledOnOffMask=0;
    1d0c:	10 92 5d 05 	sts	0x055D, r1
		subState=SS_1;
    1d10:	81 e0       	ldi	r24, 0x01	; 1
    1d12:	80 93 5b 05 	sts	0x055B, r24
		SetTimer(TIMER_1,(SECOND/4));
    1d16:	61 e3       	ldi	r22, 0x31	; 49
    1d18:	71 e0       	ldi	r23, 0x01	; 1
    1d1a:	80 e0       	ldi	r24, 0x00	; 0
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
}
    1d1c:	cf 91       	pop	r28

		KillLeds();
		i=0;
		ledOnOffMask=0;
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
    1d1e:	0c 94 46 1e 	jmp	0x3c8c	; 0x3c8c <SetTimer>
	}
	else if(subState==SS_1)
    1d22:	c1 30       	cpi	r28, 0x01	; 1
    1d24:	41 f4       	brne	.+16     	; 0x1d36 <DoFruitcakeIntro+0x40>
	{
		if(CheckTimer(TIMER_1))
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    1d2c:	88 23       	and	r24, r24
    1d2e:	09 f4       	brne	.+2      	; 0x1d32 <DoFruitcakeIntro+0x3c>
    1d30:	91 c0       	rjmp	.+290    	; 0x1e54 <DoFruitcakeIntro+0x15e>
		{
			subState=SS_2;
    1d32:	82 e0       	ldi	r24, 0x02	; 2
    1d34:	7b c0       	rjmp	.+246    	; 0x1e2c <DoFruitcakeIntro+0x136>
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}

	else if(subState==SS_2)
    1d36:	c2 30       	cpi	r28, 0x02	; 2
    1d38:	09 f0       	breq	.+2      	; 0x1d3c <DoFruitcakeIntro+0x46>
    1d3a:	4a c0       	rjmp	.+148    	; 0x1dd0 <DoFruitcakeIntro+0xda>
	{
		if(i<NUM_LEDS)
    1d3c:	80 91 5c 05 	lds	r24, 0x055C
    1d40:	88 30       	cpi	r24, 0x08	; 8
    1d42:	f8 f4       	brcc	.+62     	; 0x1d82 <DoFruitcakeIntro+0x8c>
		{
			if(CheckTimer(TIMER_1))
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    1d4a:	88 23       	and	r24, r24
    1d4c:	09 f4       	brne	.+2      	; 0x1d50 <DoFruitcakeIntro+0x5a>
    1d4e:	82 c0       	rjmp	.+260    	; 0x1e54 <DoFruitcakeIntro+0x15e>
			{
				ledOnOffMask|=(1<<i);
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	90 e0       	ldi	r25, 0x00	; 0
    1d54:	00 90 5c 05 	lds	r0, 0x055C
    1d58:	02 c0       	rjmp	.+4      	; 0x1d5e <DoFruitcakeIntro+0x68>
    1d5a:	88 0f       	add	r24, r24
    1d5c:	99 1f       	adc	r25, r25
    1d5e:	0a 94       	dec	r0
    1d60:	e2 f7       	brpl	.-8      	; 0x1d5a <DoFruitcakeIntro+0x64>
    1d62:	90 91 5d 05 	lds	r25, 0x055D
    1d66:	98 2b       	or	r25, r24
    1d68:	90 93 5d 05 	sts	0x055D, r25
				SetTimer(TIMER_1,(SECOND/20));
    1d6c:	6d e3       	ldi	r22, 0x3D	; 61
    1d6e:	70 e0       	ldi	r23, 0x00	; 0
    1d70:	80 e0       	ldi	r24, 0x00	; 0
    1d72:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
				i++;
    1d76:	80 91 5c 05 	lds	r24, 0x055C
    1d7a:	8f 5f       	subi	r24, 0xFF	; 255
    1d7c:	80 93 5c 05 	sts	0x055C, r24
    1d80:	69 c0       	rjmp	.+210    	; 0x1e54 <DoFruitcakeIntro+0x15e>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    1d88:	88 23       	and	r24, r24
    1d8a:	09 f4       	brne	.+2      	; 0x1d8e <DoFruitcakeIntro+0x98>
    1d8c:	63 c0       	rjmp	.+198    	; 0x1e54 <DoFruitcakeIntro+0x15e>
			{
				SetTimer(TIMER_1,(SECOND/8));
    1d8e:	68 e9       	ldi	r22, 0x98	; 152
    1d90:	70 e0       	ldi	r23, 0x00	; 0
    1d92:	80 e0       	ldi	r24, 0x00	; 0
    1d94:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
				ledPwm=255;
    1d98:	8f ef       	ldi	r24, 0xFF	; 255
    1d9a:	80 93 40 04 	sts	0x0440, r24
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    1d9e:	90 91 64 00 	lds	r25, 0x0064
    1da2:	9f 7b       	andi	r25, 0xBF	; 191
    1da4:	90 93 64 00 	sts	0x0064, r25

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    1da8:	c0 93 b0 00 	sts	0x00B0, r28
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    1dac:	91 e0       	ldi	r25, 0x01	; 1
    1dae:	90 93 b1 00 	sts	0x00B1, r25
				TCNT2=0;			// Init counter reg
    1db2:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    1db6:	90 e8       	ldi	r25, 0x80	; 128
    1db8:	90 93 b3 00 	sts	0x00B3, r25
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    1dbc:	87 bb       	out	0x17, r24	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    1dbe:	c0 93 70 00 	sts	0x0070, r28

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    1dc2:	92 b1       	in	r25, 0x02	; 2
    1dc4:	96 60       	ori	r25, 0x06	; 6
    1dc6:	92 b9       	out	0x02, r25	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    1dc8:	84 b9       	out	0x04, r24	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    1dca:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;
    1dcc:	83 e0       	ldi	r24, 0x03	; 3
    1dce:	2e c0       	rjmp	.+92     	; 0x1e2c <DoFruitcakeIntro+0x136>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_3)
    1dd0:	c3 30       	cpi	r28, 0x03	; 3
    1dd2:	79 f5       	brne	.+94     	; 0x1e32 <DoFruitcakeIntro+0x13c>
	{
		if(CheckTimer(TIMER_1))
    1dd4:	80 e0       	ldi	r24, 0x00	; 0
    1dd6:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    1dda:	88 23       	and	r24, r24
    1ddc:	d9 f1       	breq	.+118    	; 0x1e54 <DoFruitcakeIntro+0x15e>
		{
			if(ledPwm>1)
    1dde:	80 91 40 04 	lds	r24, 0x0440
    1de2:	82 30       	cpi	r24, 0x02	; 2
    1de4:	58 f0       	brcs	.+22     	; 0x1dfc <DoFruitcakeIntro+0x106>
			{
				ledPwm-=2;
    1de6:	80 91 40 04 	lds	r24, 0x0440
    1dea:	82 50       	subi	r24, 0x02	; 2
    1dec:	80 93 40 04 	sts	0x0440, r24
				SetTimer(TIMER_1,(SECOND/256));
    1df0:	64 e0       	ldi	r22, 0x04	; 4
    1df2:	70 e0       	ldi	r23, 0x00	; 0
    1df4:	80 e0       	ldi	r24, 0x00	; 0
    1df6:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
    1dfa:	2c c0       	rjmp	.+88     	; 0x1e54 <DoFruitcakeIntro+0x15e>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    1dfc:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    1e00:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    1e04:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
    1e08:	80 91 64 00 	lds	r24, 0x0064
    1e0c:	80 64       	ori	r24, 0x40	; 64
    1e0e:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    1e12:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    1e14:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    1e16:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    1e1a:	82 e1       	ldi	r24, 0x12	; 18
    1e1c:	80 93 5d 05 	sts	0x055D, r24
				SetTimer(TIMER_1,(SECOND/2));
    1e20:	62 e6       	ldi	r22, 0x62	; 98
    1e22:	72 e0       	ldi	r23, 0x02	; 2
    1e24:	80 e0       	ldi	r24, 0x00	; 0
    1e26:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
				subState=SS_4;
    1e2a:	84 e0       	ldi	r24, 0x04	; 4
    1e2c:	80 93 5b 05 	sts	0x055B, r24
    1e30:	11 c0       	rjmp	.+34     	; 0x1e54 <DoFruitcakeIntro+0x15e>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_4)
    1e32:	c4 30       	cpi	r28, 0x04	; 4
    1e34:	89 f4       	brne	.+34     	; 0x1e58 <DoFruitcakeIntro+0x162>
	{
		if(CheckTimer(TIMER_1))
    1e36:	80 e0       	ldi	r24, 0x00	; 0
    1e38:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    1e3c:	88 23       	and	r24, r24
    1e3e:	51 f0       	breq	.+20     	; 0x1e54 <DoFruitcakeIntro+0x15e>
		{
			KillLeds();
    1e40:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e44:	86 e5       	ldi	r24, 0x56	; 86
    1e46:	91 e1       	ldi	r25, 0x11	; 17
    1e48:	90 93 e5 05 	sts	0x05E5, r25
    1e4c:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    1e50:	10 92 5b 05 	sts	0x055B, r1
		if(CheckTimer(TIMER_1))
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    1e54:	10 92 59 05 	sts	0x0559, r1
	}
}
    1e58:	cf 91       	pop	r28
    1e5a:	08 95       	ret

00001e5c <ResetSdCard>:
	SREG=sreg;	// Resume ISR
}

static void ResetSdCard(void)
// If we unceremoniously pull a card, do this.
{
    1e5c:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1e5e:	cf b7       	in	r28, 0x3f	; 63
	cli();
    1e60:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    1e62:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
    1e66:	e5 e8       	ldi	r30, 0x85	; 133
    1e68:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    1e6a:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    1e6c:	85 e0       	ldi	r24, 0x05	; 5
    1e6e:	e5 3c       	cpi	r30, 0xC5	; 197
    1e70:	f8 07       	cpc	r31, r24
    1e72:	d9 f7       	brne	.-10     	; 0x1e6a <ResetSdCard+0xe>
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
	ClearSampleToc();
	
	// Stop SD card ISR

	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    1e74:	10 92 4f 05 	sts	0x054F, r1
	TCCR2B=0;					// Stop this timer
    1e78:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    1e7c:	80 91 70 00 	lds	r24, 0x0070
    1e80:	8b 7f       	andi	r24, 0xFB	; 251
    1e82:	80 93 70 00 	sts	0x0070, r24

	// Set this contribution to the DAC to midscale (this output source is now quiet)
	sdStreamOutput=0;
    1e86:	10 92 55 05 	sts	0x0555, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    1e8a:	10 92 2b 01 	sts	0x012B, r1
    1e8e:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    1e92:	10 92 29 01 	sts	0x0129, r1
    1e96:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    1e9a:	10 92 27 01 	sts	0x0127, r1
    1e9e:	10 92 26 01 	sts	0x0126, r1

	InitSdInterface();
    1ea2:	0e 94 66 20 	call	0x40cc	; 0x40cc <InitSdInterface>
	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
    1ea6:	10 92 59 05 	sts	0x0559, r1

	SREG=sreg;
    1eaa:	cf bf       	out	0x3f, r28	; 63
}
    1eac:	cf 91       	pop	r28
    1eae:	08 95       	ret

00001eb0 <SdStartSampleRead>:

static bool SdStartSampleRead(unsigned int sampleSlot)
// Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
// Begins a sample read in the correct spot.
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
    1eb0:	cf 92       	push	r12
    1eb2:	df 92       	push	r13
    1eb4:	ef 92       	push	r14
    1eb6:	ff 92       	push	r15
    1eb8:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1eba:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    1ebc:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    1ebe:	38 2f       	mov	r19, r24
    1ec0:	33 0f       	add	r19, r19
    1ec2:	33 0f       	add	r19, r19
    1ec4:	20 e0       	ldi	r18, 0x00	; 0
    1ec6:	69 01       	movw	r12, r18
    1ec8:	8f ef       	ldi	r24, 0xFF	; 255
    1eca:	c8 1a       	sub	r12, r24
    1ecc:	d8 0a       	sbc	r13, r24
    1ece:	e1 2c       	mov	r14, r1
    1ed0:	f1 2c       	mov	r15, r1
    1ed2:	c7 01       	movw	r24, r14
    1ed4:	b6 01       	movw	r22, r12
    1ed6:	0e 94 20 22 	call	0x4440	; 0x4440 <SdBeginSingleBlockRead>
    1eda:	81 30       	cpi	r24, 0x01	; 1
    1edc:	19 f5       	brne	.+70     	; 0x1f24 <SdStartSampleRead+0x74>
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    1ede:	c0 92 70 05 	sts	0x0570, r12
    1ee2:	d0 92 71 05 	sts	0x0571, r13
    1ee6:	e0 92 72 05 	sts	0x0572, r14
    1eea:	f0 92 73 05 	sts	0x0573, r15
		sdCurrentBlockOffset=0;						// Read first block first
    1eee:	10 92 75 05 	sts	0x0575, r1
    1ef2:	10 92 74 05 	sts	0x0574, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    1ef6:	10 92 2b 01 	sts	0x012B, r1
    1efa:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    1efe:	10 92 29 01 	sts	0x0129, r1
    1f02:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    1f06:	10 92 27 01 	sts	0x0127, r1
    1f0a:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    1f0e:	6a e7       	ldi	r22, 0x7A	; 122
    1f10:	70 e0       	ldi	r23, 0x00	; 0
    1f12:	83 e0       	ldi	r24, 0x03	; 3
    1f14:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    1f18:	89 e0       	ldi	r24, 0x09	; 9
    1f1a:	80 93 59 05 	sts	0x0559, r24

		SREG=sreg;	// Resume ISR
    1f1e:	cf bf       	out	0x3f, r28	; 63

		return(true);
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	02 c0       	rjmp	.+4      	; 0x1f28 <SdStartSampleRead+0x78>
	}
	SREG=sreg;	// Resume ISR
    1f24:	cf bf       	out	0x3f, r28	; 63
	return(false);
    1f26:	80 e0       	ldi	r24, 0x00	; 0
}
    1f28:	cf 91       	pop	r28
    1f2a:	ff 90       	pop	r15
    1f2c:	ef 90       	pop	r14
    1f2e:	df 90       	pop	r13
    1f30:	cf 90       	pop	r12
    1f32:	08 95       	ret

00001f34 <SetSampleClock.part.0>:
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    1f34:	e1 e8       	ldi	r30, 0x81	; 129
    1f36:	f0 e0       	ldi	r31, 0x00	; 0
    1f38:	80 81       	ld	r24, Z
    1f3a:	80 64       	ori	r24, 0x40	; 64
    1f3c:	80 83       	st	Z, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1f3e:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1f40:	ef e6       	ldi	r30, 0x6F	; 111
    1f42:	f0 e0       	ldi	r31, 0x00	; 0
    1f44:	80 81       	ld	r24, Z
    1f46:	80 62       	ori	r24, 0x20	; 32
    1f48:	80 83       	st	Z, r24
    1f4a:	08 95       	ret

00001f4c <SetSampleClock>:

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    1f4c:	93 e2       	ldi	r25, 0x23	; 35
    1f4e:	89 9f       	mul	r24, r25
    1f50:	f0 01       	movw	r30, r0
    1f52:	11 24       	eor	r1, r1
    1f54:	ea 51       	subi	r30, 0x1A	; 26
    1f56:	fa 4f       	sbci	r31, 0xFA	; 250
    1f58:	61 87       	std	Z+9, r22	; 0x09

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1f5a:	62 30       	cpi	r22, 0x02	; 2
    1f5c:	39 f5       	brne	.+78     	; 0x1fac <SetSampleClock+0x60>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1f5e:	53 87       	std	Z+11, r21	; 0x0b
    1f60:	42 87       	std	Z+10, r20	; 0x0a

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1f62:	81 11       	cpse	r24, r1
    1f64:	0f c0       	rjmp	.+30     	; 0x1f84 <SetSampleClock+0x38>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1f66:	80 91 84 00 	lds	r24, 0x0084
    1f6a:	90 91 85 00 	lds	r25, 0x0085
    1f6e:	84 0f       	add	r24, r20
    1f70:	95 1f       	adc	r25, r21
    1f72:	90 93 89 00 	sts	0x0089, r25
    1f76:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1f7a:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    1f7c:	80 91 6f 00 	lds	r24, 0x006F
    1f80:	82 60       	ori	r24, 0x02	; 2
    1f82:	0e c0       	rjmp	.+28     	; 0x1fa0 <SetSampleClock+0x54>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1f84:	80 91 84 00 	lds	r24, 0x0084
    1f88:	90 91 85 00 	lds	r25, 0x0085
    1f8c:	84 0f       	add	r24, r20
    1f8e:	95 1f       	adc	r25, r21
    1f90:	90 93 8b 00 	sts	0x008B, r25
    1f94:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    1f98:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1f9a:	80 91 6f 00 	lds	r24, 0x006F
    1f9e:	84 60       	ori	r24, 0x04	; 4
    1fa0:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    1fa4:	81 e0       	ldi	r24, 0x01	; 1
    1fa6:	80 93 81 00 	sts	0x0081, r24
    1faa:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1fac:	61 30       	cpi	r22, 0x01	; 1
    1fae:	59 f4       	brne	.+22     	; 0x1fc6 <SetSampleClock+0x7a>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1fb0:	81 11       	cpse	r24, r1
    1fb2:	02 c0       	rjmp	.+4      	; 0x1fb8 <SetSampleClock+0x6c>
    1fb4:	0c 94 9a 0f 	jmp	0x1f34	; 0x1f34 <SetSampleClock.part.0>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    1fb8:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    1fba:	84 e0       	ldi	r24, 0x04	; 4
    1fbc:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    1fc0:	80 e1       	ldi	r24, 0x10	; 16
    1fc2:	80 93 6d 00 	sts	0x006D, r24
    1fc6:	08 95       	ret

00001fc8 <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1fc8:	ff 92       	push	r15
    1fca:	0f 93       	push	r16
    1fcc:	1f 93       	push	r17
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1fd2:	c8 2f       	mov	r28, r24
    1fd4:	d0 e0       	ldi	r29, 0x00	; 0
    1fd6:	93 e2       	ldi	r25, 0x23	; 35
    1fd8:	89 9f       	mul	r24, r25
    1fda:	f0 01       	movw	r30, r0
    1fdc:	11 24       	eor	r1, r1
    1fde:	ea 51       	subi	r30, 0x1A	; 26
    1fe0:	fa 4f       	sbci	r31, 0xFA	; 250
    1fe2:	95 81       	ldd	r25, Z+5	; 0x05
    1fe4:	99 23       	and	r25, r25
    1fe6:	29 f0       	breq	.+10     	; 0x1ff2 <StartPlayback+0x2a>
    1fe8:	90 91 4f 05 	lds	r25, 0x054F
    1fec:	91 50       	subi	r25, 0x01	; 1
    1fee:	92 30       	cpi	r25, 0x02	; 2
    1ff0:	80 f1       	brcs	.+96     	; 0x2052 <StartPlayback+0x8a>
	{
		sreg=SREG;	// Store global interrupt state.
    1ff2:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1ff4:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    1ff6:	93 e2       	ldi	r25, 0x23	; 35
    1ff8:	9c 9f       	mul	r25, r28
    1ffa:	f0 01       	movw	r30, r0
    1ffc:	9d 9f       	mul	r25, r29
    1ffe:	f0 0d       	add	r31, r0
    2000:	11 24       	eor	r1, r1
    2002:	ea 51       	subi	r30, 0x1A	; 26
    2004:	fa 4f       	sbci	r31, 0xFA	; 250
    2006:	94 e0       	ldi	r25, 0x04	; 4
    2008:	90 83       	st	Z, r25

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    200a:	93 81       	ldd	r25, Z+3	; 0x03
    200c:	99 23       	and	r25, r25
    200e:	51 f0       	breq	.+20     	; 0x2024 <StartPlayback+0x5c>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    2010:	04 89       	ldd	r16, Z+20	; 0x14
    2012:	15 89       	ldd	r17, Z+21	; 0x15
    2014:	26 89       	ldd	r18, Z+22	; 0x16
    2016:	37 89       	ldd	r19, Z+23	; 0x17
    2018:	07 8f       	std	Z+31, r16	; 0x1f
    201a:	10 a3       	std	Z+32, r17	; 0x20
    201c:	21 a3       	std	Z+33, r18	; 0x21
    201e:	32 a3       	std	Z+34, r19	; 0x22
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    2020:	14 82       	std	Z+4, r1	; 0x04
    2022:	0a c0       	rjmp	.+20     	; 0x2038 <StartPlayback+0x70>
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    2024:	00 8d       	ldd	r16, Z+24	; 0x18
    2026:	11 8d       	ldd	r17, Z+25	; 0x19
    2028:	22 8d       	ldd	r18, Z+26	; 0x1a
    202a:	33 8d       	ldd	r19, Z+27	; 0x1b
    202c:	07 8f       	std	Z+31, r16	; 0x1f
    202e:	10 a3       	std	Z+32, r17	; 0x20
    2030:	21 a3       	std	Z+33, r18	; 0x21
    2032:	32 a3       	std	Z+34, r19	; 0x22
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    2034:	91 e0       	ldi	r25, 0x01	; 1
    2036:	94 83       	std	Z+4, r25	; 0x04
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    2038:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    203c:	83 e2       	ldi	r24, 0x23	; 35
    203e:	8c 9f       	mul	r24, r28
    2040:	f0 01       	movw	r30, r0
    2042:	8d 9f       	mul	r24, r29
    2044:	f0 0d       	add	r31, r0
    2046:	11 24       	eor	r1, r1
    2048:	ea 51       	subi	r30, 0x1A	; 26
    204a:	fa 4f       	sbci	r31, 0xFA	; 250
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    2050:	ff be       	out	0x3f, r15	; 63
	}
}
    2052:	df 91       	pop	r29
    2054:	cf 91       	pop	r28
    2056:	1f 91       	pop	r17
    2058:	0f 91       	pop	r16
    205a:	ff 90       	pop	r15
    205c:	08 95       	ret

0000205e <ContinuePlayback>:

static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
    205e:	1f 93       	push	r17
    2060:	cf 93       	push	r28
    2062:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2064:	28 2f       	mov	r18, r24
    2066:	30 e0       	ldi	r19, 0x00	; 0
    2068:	93 e2       	ldi	r25, 0x23	; 35
    206a:	89 9f       	mul	r24, r25
    206c:	f0 01       	movw	r30, r0
    206e:	11 24       	eor	r1, r1
    2070:	ea 51       	subi	r30, 0x1A	; 26
    2072:	fa 4f       	sbci	r31, 0xFA	; 250
    2074:	95 81       	ldd	r25, Z+5	; 0x05
    2076:	99 23       	and	r25, r25
    2078:	29 f0       	breq	.+10     	; 0x2084 <ContinuePlayback+0x26>
    207a:	90 91 4f 05 	lds	r25, 0x054F
    207e:	91 50       	subi	r25, 0x01	; 1
    2080:	92 30       	cpi	r25, 0x02	; 2
    2082:	88 f0       	brcs	.+34     	; 0x20a6 <ContinuePlayback+0x48>
	{
		sreg=SREG;	// Store global interrupt state.
    2084:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2086:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    2088:	93 e2       	ldi	r25, 0x23	; 35
    208a:	92 9f       	mul	r25, r18
    208c:	e0 01       	movw	r28, r0
    208e:	93 9f       	mul	r25, r19
    2090:	d0 0d       	add	r29, r0
    2092:	11 24       	eor	r1, r1
    2094:	ca 51       	subi	r28, 0x1A	; 26
    2096:	da 4f       	sbci	r29, 0xFA	; 250
    2098:	94 e0       	ldi	r25, 0x04	; 4
    209a:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    209c:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    20a0:	81 e0       	ldi	r24, 0x01	; 1
    20a2:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    20a4:	1f bf       	out	0x3f, r17	; 63
	}
}
    20a6:	df 91       	pop	r29
    20a8:	cf 91       	pop	r28
    20aa:	1f 91       	pop	r17
    20ac:	08 95       	ret

000020ae <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    20ae:	ff 92       	push	r15
    20b0:	0f 93       	push	r16
    20b2:	1f 93       	push	r17
    20b4:	cf 93       	push	r28
    20b6:	df 93       	push	r29

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    20b8:	28 2f       	mov	r18, r24
    20ba:	30 e0       	ldi	r19, 0x00	; 0
    20bc:	93 e2       	ldi	r25, 0x23	; 35
    20be:	89 9f       	mul	r24, r25
    20c0:	f0 01       	movw	r30, r0
    20c2:	11 24       	eor	r1, r1
    20c4:	ea 51       	subi	r30, 0x1A	; 26
    20c6:	fa 4f       	sbci	r31, 0xFA	; 250
    20c8:	95 81       	ldd	r25, Z+5	; 0x05
    20ca:	99 23       	and	r25, r25
    20cc:	31 f0       	breq	.+12     	; 0x20da <StartRecording+0x2c>
    20ce:	90 91 4f 05 	lds	r25, 0x054F
    20d2:	91 50       	subi	r25, 0x01	; 1
    20d4:	92 30       	cpi	r25, 0x02	; 2
    20d6:	08 f4       	brcc	.+2      	; 0x20da <StartRecording+0x2c>
    20d8:	42 c0       	rjmp	.+132    	; 0x215e <StartRecording+0xb0>
	{

		sreg=SREG;	// Store global interrupt state.
    20da:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    20dc:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    20de:	93 e2       	ldi	r25, 0x23	; 35
    20e0:	92 9f       	mul	r25, r18
    20e2:	e0 01       	movw	r28, r0
    20e4:	93 9f       	mul	r25, r19
    20e6:	d0 0d       	add	r29, r0
    20e8:	11 24       	eor	r1, r1
    20ea:	ca 51       	subi	r28, 0x1A	; 26
    20ec:	da 4f       	sbci	r29, 0xFA	; 250
    20ee:	93 e0       	ldi	r25, 0x03	; 3
    20f0:	98 83       	st	Y, r25

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    20f2:	08 89       	ldd	r16, Y+16	; 0x10
    20f4:	19 89       	ldd	r17, Y+17	; 0x11
    20f6:	2a 89       	ldd	r18, Y+18	; 0x12
    20f8:	3b 89       	ldd	r19, Y+19	; 0x13
    20fa:	0f 8f       	std	Y+31, r16	; 0x1f
    20fc:	18 a3       	std	Y+32, r17	; 0x20
    20fe:	29 a3       	std	Y+33, r18	; 0x21
    2100:	3a a3       	std	Y+34, r19	; 0x22
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    2102:	08 89       	ldd	r16, Y+16	; 0x10
    2104:	19 89       	ldd	r17, Y+17	; 0x11
    2106:	2a 89       	ldd	r18, Y+18	; 0x12
    2108:	3b 89       	ldd	r19, Y+19	; 0x13
    210a:	0c 87       	std	Y+12, r16	; 0x0c
    210c:	1d 87       	std	Y+13, r17	; 0x0d
    210e:	2e 87       	std	Y+14, r18	; 0x0e
    2110:	3f 87       	std	Y+15, r19	; 0x0f
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    2112:	08 89       	ldd	r16, Y+16	; 0x10
    2114:	19 89       	ldd	r17, Y+17	; 0x11
    2116:	2a 89       	ldd	r18, Y+18	; 0x12
    2118:	3b 89       	ldd	r19, Y+19	; 0x13
    211a:	08 8f       	std	Y+24, r16	; 0x18
    211c:	19 8f       	std	Y+25, r17	; 0x19
    211e:	2a 8f       	std	Y+26, r18	; 0x1a
    2120:	3b 8f       	std	Y+27, r19	; 0x1b
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    2122:	08 89       	ldd	r16, Y+16	; 0x10
    2124:	19 89       	ldd	r17, Y+17	; 0x11
    2126:	2a 89       	ldd	r18, Y+18	; 0x12
    2128:	3b 89       	ldd	r19, Y+19	; 0x13
    212a:	0c 8b       	std	Y+20, r16	; 0x14
    212c:	1d 8b       	std	Y+21, r17	; 0x15
    212e:	2e 8b       	std	Y+22, r18	; 0x16
    2130:	3f 8b       	std	Y+23, r19	; 0x17
		bankStates[theBank].sampleWindowOffset=0;									// "
    2132:	1e 8e       	std	Y+30, r1	; 0x1e

		outOfRam=false;						// Plenty of ram left...
    2134:	10 92 3f 04 	sts	0x043F, r1

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    2138:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	8d 83       	std	Y+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    2140:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2142:	80 91 7a 00 	lds	r24, 0x007A
    2146:	86 fd       	sbrc	r24, 6
    2148:	0a c0       	rjmp	.+20     	; 0x215e <StartRecording+0xb0>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    214a:	80 91 79 00 	lds	r24, 0x0079
    214e:	80 58       	subi	r24, 0x80	; 128
    2150:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2154:	80 91 7a 00 	lds	r24, 0x007A
    2158:	80 64       	ori	r24, 0x40	; 64
    215a:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    215e:	df 91       	pop	r29
    2160:	cf 91       	pop	r28
    2162:	1f 91       	pop	r17
    2164:	0f 91       	pop	r16
    2166:	ff 90       	pop	r15
    2168:	08 95       	ret

0000216a <StartOverdub>:
}

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    216a:	1f 93       	push	r17
    216c:	cf 93       	push	r28
    216e:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2170:	28 2f       	mov	r18, r24
    2172:	30 e0       	ldi	r19, 0x00	; 0
    2174:	93 e2       	ldi	r25, 0x23	; 35
    2176:	89 9f       	mul	r24, r25
    2178:	f0 01       	movw	r30, r0
    217a:	11 24       	eor	r1, r1
    217c:	ea 51       	subi	r30, 0x1A	; 26
    217e:	fa 4f       	sbci	r31, 0xFA	; 250
    2180:	95 81       	ldd	r25, Z+5	; 0x05
    2182:	99 23       	and	r25, r25
    2184:	29 f0       	breq	.+10     	; 0x2190 <StartOverdub+0x26>
    2186:	90 91 4f 05 	lds	r25, 0x054F
    218a:	91 50       	subi	r25, 0x01	; 1
    218c:	92 30       	cpi	r25, 0x02	; 2
    218e:	f8 f0       	brcs	.+62     	; 0x21ce <StartOverdub+0x64>
	{
		sreg=SREG;	// Store global interrupt state.
    2190:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2192:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    2194:	93 e2       	ldi	r25, 0x23	; 35
    2196:	92 9f       	mul	r25, r18
    2198:	e0 01       	movw	r28, r0
    219a:	93 9f       	mul	r25, r19
    219c:	d0 0d       	add	r29, r0
    219e:	11 24       	eor	r1, r1
    21a0:	ca 51       	subi	r28, 0x1A	; 26
    21a2:	da 4f       	sbci	r29, 0xFA	; 250
    21a4:	95 e0       	ldi	r25, 0x05	; 5
    21a6:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    21a8:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    21ac:	81 e0       	ldi	r24, 0x01	; 1
    21ae:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    21b0:	1f bf       	out	0x3f, r17	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    21b2:	80 91 7a 00 	lds	r24, 0x007A
    21b6:	86 fd       	sbrc	r24, 6
    21b8:	0a c0       	rjmp	.+20     	; 0x21ce <StartOverdub+0x64>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    21ba:	80 91 79 00 	lds	r24, 0x0079
    21be:	80 58       	subi	r24, 0x80	; 128
    21c0:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    21c4:	80 91 7a 00 	lds	r24, 0x007A
    21c8:	80 64       	ori	r24, 0x40	; 64
    21ca:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    21ce:	df 91       	pop	r29
    21d0:	cf 91       	pop	r28
    21d2:	1f 91       	pop	r17
    21d4:	08 95       	ret

000021d6 <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
// Thu Nov 24 19:40:21 CST 2011
// OK to do realtime even when banks are locked since we don't use the RAM
{
    21d6:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    21d8:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    21da:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    21dc:	93 e2       	ldi	r25, 0x23	; 35
    21de:	89 9f       	mul	r24, r25
    21e0:	f0 01       	movw	r30, r0
    21e2:	11 24       	eor	r1, r1
    21e4:	ea 51       	subi	r30, 0x1A	; 26
    21e6:	fa 4f       	sbci	r31, 0xFA	; 250
    21e8:	92 e0       	ldi	r25, 0x02	; 2
    21ea:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    21ec:	0e 94 a6 0f 	call	0x1f4c	; 0x1f4c <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    21f0:	cf bf       	out	0x3f, r28	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    21f2:	80 91 7a 00 	lds	r24, 0x007A
    21f6:	86 fd       	sbrc	r24, 6
    21f8:	0a c0       	rjmp	.+20     	; 0x220e <StartRealtime+0x38>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    21fa:	80 91 79 00 	lds	r24, 0x0079
    21fe:	80 58       	subi	r24, 0x80	; 128
    2200:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2204:	80 91 7a 00 	lds	r24, 0x007A
    2208:	80 64       	ori	r24, 0x40	; 64
    220a:	80 93 7a 00 	sts	0x007A, r24
	}
}
    220e:	cf 91       	pop	r28
    2210:	08 95       	ret

00002212 <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    2212:	80 91 5b 05 	lds	r24, 0x055B
    2216:	81 11       	cpse	r24, r1
    2218:	10 c0       	rjmp	.+32     	; 0x223a <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs
    221a:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>

		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    221e:	10 92 e6 05 	sts	0x05E6, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    2222:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    2226:	10 92 09 06 	sts	0x0609, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    222a:	10 92 12 06 	sts	0x0612, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    222e:	81 e8       	ldi	r24, 0x81	; 129
    2230:	90 e0       	ldi	r25, 0x00	; 0
    2232:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		subState=SS_1;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	13 c0       	rjmp	.+38     	; 0x2260 <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    223a:	81 30       	cpi	r24, 0x01	; 1
    223c:	c9 f4       	brne	.+50     	; 0x2270 <DoFormatCard+0x5e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    223e:	80 91 58 05 	lds	r24, 0x0558
    2242:	80 ff       	sbrs	r24, 0
    2244:	10 c0       	rjmp	.+32     	; 0x2266 <DoFormatCard+0x54>
    2246:	87 ff       	sbrs	r24, 7
    2248:	0e c0       	rjmp	.+28     	; 0x2266 <DoFormatCard+0x54>
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    224a:	86 e0       	ldi	r24, 0x06	; 6
    224c:	80 93 59 05 	sts	0x0559, r24
			KillLeds();
    2250:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
    2254:	80 91 5d 05 	lds	r24, 0x055D
    2258:	81 68       	ori	r24, 0x81	; 129
    225a:	80 93 5d 05 	sts	0x055D, r24
			subState=SS_2;
    225e:	82 e0       	ldi	r24, 0x02	; 2
    2260:	80 93 5b 05 	sts	0x055B, r24
    2264:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    2266:	80 91 59 05 	lds	r24, 0x0559
    226a:	81 11       	cpse	r24, r1
    226c:	1e c0       	rjmp	.+60     	; 0x22aa <DoFormatCard+0x98>
    226e:	15 c0       	rjmp	.+42     	; 0x229a <DoFormatCard+0x88>
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    2270:	82 30       	cpi	r24, 0x02	; 2
    2272:	d9 f4       	brne	.+54     	; 0x22aa <DoFormatCard+0x98>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    2274:	80 91 59 05 	lds	r24, 0x0559
    2278:	8e 30       	cpi	r24, 0x0E	; 14
    227a:	b9 f4       	brne	.+46     	; 0x22aa <DoFormatCard+0x98>
		{
			KillLeds();
    227c:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    2280:	80 91 5d 05 	lds	r24, 0x055D
    2284:	82 60       	ori	r24, 0x02	; 2
    2286:	80 93 5d 05 	sts	0x055D, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    228a:	80 91 59 05 	lds	r24, 0x0559
    228e:	88 23       	and	r24, r24
    2290:	21 f0       	breq	.+8      	; 0x229a <DoFormatCard+0x88>
    2292:	80 91 57 05 	lds	r24, 0x0557
    2296:	88 23       	and	r24, r24
    2298:	41 f0       	breq	.+16     	; 0x22aa <DoFormatCard+0x98>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    229a:	8b e7       	ldi	r24, 0x7B	; 123
    229c:	9e e0       	ldi	r25, 0x0E	; 14
    229e:	90 93 e5 05 	sts	0x05E5, r25
    22a2:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    22a6:	10 92 5b 05 	sts	0x055B, r1
    22aa:	08 95       	ret

000022ac <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    22ac:	80 91 5b 05 	lds	r24, 0x055B
    22b0:	81 11       	cpse	r24, r1
    22b2:	08 c0       	rjmp	.+16     	; 0x22c4 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    22b4:	68 e9       	ldi	r22, 0x98	; 152
    22b6:	70 e0       	ldi	r23, 0x00	; 0
    22b8:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
		subState=SS_1;
    22bc:	81 e0       	ldi	r24, 0x01	; 1
    22be:	80 93 5b 05 	sts	0x055B, r24
    22c2:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    22c4:	80 e0       	ldi	r24, 0x00	; 0
    22c6:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    22ca:	88 23       	and	r24, r24
    22cc:	a1 f0       	breq	.+40     	; 0x22f6 <DoStartupSelect+0x4a>
		{
			if(keyState&Im_SWITCH_0)
    22ce:	80 91 58 05 	lds	r24, 0x0558
    22d2:	80 ff       	sbrs	r24, 0
    22d4:	03 c0       	rjmp	.+6      	; 0x22dc <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    22d6:	8e eb       	ldi	r24, 0xBE	; 190
    22d8:	91 e1       	ldi	r25, 0x11	; 17
    22da:	07 c0       	rjmp	.+14     	; 0x22ea <DoStartupSelect+0x3e>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    22dc:	85 ff       	sbrs	r24, 5
    22de:	03 c0       	rjmp	.+6      	; 0x22e6 <DoStartupSelect+0x3a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    22e0:	83 e4       	ldi	r24, 0x43	; 67
    22e2:	92 e1       	ldi	r25, 0x12	; 18
    22e4:	02 c0       	rjmp	.+4      	; 0x22ea <DoStartupSelect+0x3e>
    22e6:	89 ea       	ldi	r24, 0xA9	; 169
    22e8:	92 e1       	ldi	r25, 0x12	; 18
    22ea:	90 93 e5 05 	sts	0x05E5, r25
    22ee:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    22f2:	10 92 5b 05 	sts	0x055B, r1
    22f6:	08 95       	ret

000022f8 <PlaySampleFromSd>:
}

//static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot)
static void PlaySampleFromSd(unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    22f8:	cf 93       	push	r28
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    22fa:	20 91 59 05 	lds	r18, 0x0559
    22fe:	2e 30       	cpi	r18, 0x0E	; 14
    2300:	09 f4       	brne	.+2      	; 0x2304 <PlaySampleFromSd+0xc>
    2302:	06 c0       	rjmp	.+12     	; 0x2310 <PlaySampleFromSd+0x18>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    2304:	30 91 4f 05 	lds	r19, 0x054F
    2308:	33 30       	cpi	r19, 0x03	; 3
    230a:	b1 f5       	brne	.+108    	; 0x2378 <PlaySampleFromSd+0x80>
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    230c:	2b 30       	cpi	r18, 0x0B	; 11
    230e:	a1 f4       	brne	.+40     	; 0x2338 <PlaySampleFromSd+0x40>
		{
			sreg=SREG;	 // Pause ISRs
    2310:	cf b7       	in	r28, 0x3f	; 63
			cli();
    2312:	f8 94       	cli

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    2314:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	a0 e0       	ldi	r26, 0x00	; 0
    231e:	b0 e0       	ldi	r27, 0x00	; 0
    2320:	80 93 22 01 	sts	0x0122, r24
    2324:	90 93 23 01 	sts	0x0123, r25
    2328:	a0 93 24 01 	sts	0x0124, r26
    232c:	b0 93 25 01 	sts	0x0125, r27
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
    2330:	0e 94 ee 08 	call	0x11dc	; 0x11dc <SdIsrStartStreamingAudio>

			SREG=sreg;	// resume isr
    2334:	cf bf       	out	0x3f, r28	; 63
    2336:	20 c0       	rjmp	.+64     	; 0x2378 <PlaySampleFromSd+0x80>
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    2338:	2d 30       	cpi	r18, 0x0D	; 13
    233a:	21 f0       	breq	.+8      	; 0x2344 <PlaySampleFromSd+0x4c>
    233c:	20 91 76 05 	lds	r18, 0x0576
    2340:	21 30       	cpi	r18, 0x01	; 1
    2342:	29 f4       	brne	.+10     	; 0x234e <PlaySampleFromSd+0x56>
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    2344:	90 93 78 05 	sts	0x0578, r25
    2348:	80 93 77 05 	sts	0x0577, r24
    234c:	15 c0       	rjmp	.+42     	; 0x2378 <PlaySampleFromSd+0x80>
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    234e:	90 93 78 05 	sts	0x0578, r25
    2352:	80 93 77 05 	sts	0x0577, r24
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    2356:	81 e0       	ldi	r24, 0x01	; 1
    2358:	80 93 79 05 	sts	0x0579, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    235c:	80 93 76 05 	sts	0x0576, r24

			sreg=SREG;	 		// Pause ISRs
    2360:	9f b7       	in	r25, 0x3f	; 63
			cli();
    2362:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    2364:	10 92 27 01 	sts	0x0127, r1
    2368:	10 92 26 01 	sts	0x0126, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    236c:	80 91 70 00 	lds	r24, 0x0070
    2370:	8b 7f       	andi	r24, 0xFB	; 251
    2372:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;
    2376:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    2378:	cf 91       	pop	r28
    237a:	08 95       	ret

0000237c <DoSawtooth>:
// Also test to see if our flash is present and working.
{
	static unsigned char
		lastShuttleRead;

	if(subState==SS_0)
    237c:	80 91 5b 05 	lds	r24, 0x055B
    2380:	81 11       	cpse	r24, r1
    2382:	08 c0       	rjmp	.+16     	; 0x2394 <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    2384:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    2388:	80 ec       	ldi	r24, 0xC0	; 192
    238a:	90 e0       	ldi	r25, 0x00	; 0
    238c:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		subState=SS_1;
    2390:	81 e0       	ldi	r24, 0x01	; 1
    2392:	17 c0       	rjmp	.+46     	; 0x23c2 <DoSawtooth+0x46>
	}
	else if(subState==SS_1)
    2394:	81 30       	cpi	r24, 0x01	; 1
    2396:	c1 f4       	brne	.+48     	; 0x23c8 <DoSawtooth+0x4c>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2398:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    239a:	80 93 e6 05 	sts	0x05E6, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    239e:	80 93 ef 05 	sts	0x05EF, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    23a2:	80 93 ef 05 	sts	0x05EF, r24
    23a6:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <SetSampleClock.part.0>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    23aa:	85 e3       	ldi	r24, 0x35	; 53
    23ac:	98 e0       	ldi	r25, 0x08	; 8
    23ae:	90 93 e3 05 	sts	0x05E3, r25
    23b2:	80 93 e2 05 	sts	0x05E2, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    23b6:	78 94       	sei

		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the leds when it changes.
    23b8:	80 91 6b 05 	lds	r24, 0x056B
    23bc:	80 93 7b 05 	sts	0x057B, r24

		subState=SS_2;					// And wait forever.
    23c0:	82 e0       	ldi	r24, 0x02	; 2
    23c2:	80 93 5b 05 	sts	0x055B, r24
    23c6:	08 95       	ret
	}
	else if(subState==SS_2)
    23c8:	82 30       	cpi	r24, 0x02	; 2
    23ca:	09 f0       	breq	.+2      	; 0x23ce <DoSawtooth+0x52>
    23cc:	5b c0       	rjmp	.+182    	; 0x2484 <DoSawtooth+0x108>
	{

		if(newKeys&Im_SWITCH_0)
    23ce:	80 91 57 05 	lds	r24, 0x0557
    23d2:	80 ff       	sbrs	r24, 0
    23d4:	06 c0       	rjmp	.+12     	; 0x23e2 <DoSawtooth+0x66>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    23d6:	90 91 5d 05 	lds	r25, 0x055D
    23da:	21 e0       	ldi	r18, 0x01	; 1
    23dc:	92 27       	eor	r25, r18
    23de:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_1)
    23e2:	81 ff       	sbrs	r24, 1
    23e4:	06 c0       	rjmp	.+12     	; 0x23f2 <DoSawtooth+0x76>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    23e6:	90 91 5d 05 	lds	r25, 0x055D
    23ea:	22 e0       	ldi	r18, 0x02	; 2
    23ec:	92 27       	eor	r25, r18
    23ee:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)
    23f2:	82 ff       	sbrs	r24, 2
    23f4:	06 c0       	rjmp	.+12     	; 0x2402 <DoSawtooth+0x86>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    23f6:	90 91 5d 05 	lds	r25, 0x055D
    23fa:	24 e0       	ldi	r18, 0x04	; 4
    23fc:	92 27       	eor	r25, r18
    23fe:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_3)
    2402:	83 ff       	sbrs	r24, 3
    2404:	06 c0       	rjmp	.+12     	; 0x2412 <DoSawtooth+0x96>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    2406:	90 91 5d 05 	lds	r25, 0x055D
    240a:	28 e0       	ldi	r18, 0x08	; 8
    240c:	92 27       	eor	r25, r18
    240e:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_4)
    2412:	84 ff       	sbrs	r24, 4
    2414:	06 c0       	rjmp	.+12     	; 0x2422 <DoSawtooth+0xa6>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    2416:	90 91 5d 05 	lds	r25, 0x055D
    241a:	20 e1       	ldi	r18, 0x10	; 16
    241c:	92 27       	eor	r25, r18
    241e:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_5)
    2422:	85 ff       	sbrs	r24, 5
    2424:	06 c0       	rjmp	.+12     	; 0x2432 <DoSawtooth+0xb6>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    2426:	90 91 5d 05 	lds	r25, 0x055D
    242a:	20 e2       	ldi	r18, 0x20	; 32
    242c:	92 27       	eor	r25, r18
    242e:	90 93 5d 05 	sts	0x055D, r25
		}

		if(newKeys&Im_SWITCH_6)
    2432:	86 ff       	sbrs	r24, 6
    2434:	0a c0       	rjmp	.+20     	; 0x244a <DoSawtooth+0xce>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    2436:	80 e0       	ldi	r24, 0x00	; 0
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
		}

		if(newKeys&Im_SWITCH_6)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    243e:	80 91 5d 05 	lds	r24, 0x055D
    2442:	90 e4       	ldi	r25, 0x40	; 64
    2444:	89 27       	eor	r24, r25
    2446:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_7)
    244a:	80 91 57 05 	lds	r24, 0x0557
    244e:	87 ff       	sbrs	r24, 7
    2450:	09 c0       	rjmp	.+18     	; 0x2464 <DoSawtooth+0xe8>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    2452:	80 e0       	ldi	r24, 0x00	; 0
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    245a:	80 91 5d 05 	lds	r24, 0x055D
    245e:	80 58       	subi	r24, 0x80	; 128
    2460:	80 93 5d 05 	sts	0x055D, r24
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
    2464:	90 91 7b 05 	lds	r25, 0x057B
    2468:	80 91 6b 05 	lds	r24, 0x056B
    246c:	98 17       	cp	r25, r24
    246e:	51 f0       	breq	.+20     	; 0x2484 <DoSawtooth+0x108>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    2470:	80 e0       	ldi	r24, 0x00	; 0
    2472:	90 e0       	ldi	r25, 0x00	; 0
    2474:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <BlinkLeds>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    2478:	80 91 6b 05 	lds	r24, 0x056B
    247c:	80 93 5d 05 	sts	0x055D, r24
			lastShuttleRead=encoderValue;
    2480:	80 93 7b 05 	sts	0x057B, r24
    2484:	08 95       	ret

00002486 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
    2486:	80 91 5b 05 	lds	r24, 0x055B
    248a:	81 11       	cpse	r24, r1
    248c:	1d c0       	rjmp	.+58     	; 0x24c8 <SetMidiChannels+0x42>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    248e:	84 e0       	ldi	r24, 0x04	; 4
    2490:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    2494:	80 31       	cpi	r24, 0x10	; 16
    2496:	08 f0       	brcs	.+2      	; 0x249a <SetMidiChannels+0x14>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2498:	80 e0       	ldi	r24, 0x00	; 0
static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    249a:	80 93 2e 06 	sts	0x062E, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    249e:	88 e0       	ldi	r24, 0x08	; 8
    24a0:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <EepromRead>
	}

	if(x<16)					// Legit number?
    24a4:	80 31       	cpi	r24, 0x10	; 16
    24a6:	08 f0       	brcs	.+2      	; 0x24aa <SetMidiChannels+0x24>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    24a8:	81 e0       	ldi	r24, 0x01	; 1
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
		midiChannelNumberB=GetMidiChannel(BANK_1);
    24aa:	80 93 47 06 	sts	0x0647, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    24ae:	20 e1       	ldi	r18, 0x10	; 16
    24b0:	82 9f       	mul	r24, r18
    24b2:	c0 01       	movw	r24, r0
    24b4:	11 24       	eor	r1, r1
    24b6:	90 91 2e 06 	lds	r25, 0x062E
    24ba:	98 2b       	or	r25, r24
    24bc:	90 93 5d 05 	sts	0x055D, r25
		subState=SS_1;
    24c0:	81 e0       	ldi	r24, 0x01	; 1
    24c2:	80 93 5b 05 	sts	0x055B, r24
    24c6:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    24c8:	20 91 57 05 	lds	r18, 0x0557
    24cc:	20 ff       	sbrs	r18, 0
    24ce:	12 c0       	rjmp	.+36     	; 0x24f4 <SetMidiChannels+0x6e>
		{
			midiChannelNumberA++;
    24d0:	80 91 2e 06 	lds	r24, 0x062E
    24d4:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    24d6:	80 31       	cpi	r24, 0x10	; 16
    24d8:	18 f4       	brcc	.+6      	; 0x24e0 <SetMidiChannels+0x5a>
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
    24da:	80 93 2e 06 	sts	0x062E, r24
    24de:	02 c0       	rjmp	.+4      	; 0x24e4 <SetMidiChannels+0x5e>
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
    24e0:	10 92 2e 06 	sts	0x062E, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    24e4:	80 91 5d 05 	lds	r24, 0x055D
    24e8:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    24ea:	90 91 2e 06 	lds	r25, 0x062E
    24ee:	89 2b       	or	r24, r25
    24f0:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_1)
    24f4:	21 ff       	sbrs	r18, 1
    24f6:	16 c0       	rjmp	.+44     	; 0x2524 <SetMidiChannels+0x9e>
		{
			midiChannelNumberB++;
    24f8:	80 91 47 06 	lds	r24, 0x0647
    24fc:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    24fe:	80 31       	cpi	r24, 0x10	; 16
    2500:	18 f4       	brcc	.+6      	; 0x2508 <SetMidiChannels+0x82>
			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
		}
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
    2502:	80 93 47 06 	sts	0x0647, r24
    2506:	02 c0       	rjmp	.+4      	; 0x250c <SetMidiChannels+0x86>
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
    2508:	10 92 47 06 	sts	0x0647, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    250c:	80 91 47 06 	lds	r24, 0x0647
    2510:	30 e1       	ldi	r19, 0x10	; 16
    2512:	83 9f       	mul	r24, r19
    2514:	c0 01       	movw	r24, r0
    2516:	11 24       	eor	r1, r1
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    2518:	90 91 5d 05 	lds	r25, 0x055D
    251c:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    251e:	98 2b       	or	r25, r24
    2520:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    2524:	22 ff       	sbrs	r18, 2
    2526:	14 c0       	rjmp	.+40     	; 0x2550 <SetMidiChannels+0xca>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    2528:	60 91 2e 06 	lds	r22, 0x062E
    252c:	84 e0       	ldi	r24, 0x04	; 4
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	0e 94 04 1e 	call	0x3c08	; 0x3c08 <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    2534:	60 91 47 06 	lds	r22, 0x0647
    2538:	88 e0       	ldi	r24, 0x08	; 8
    253a:	90 e0       	ldi	r25, 0x00	; 0
    253c:	0e 94 04 1e 	call	0x3c08	; 0x3c08 <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2540:	89 ea       	ldi	r24, 0xA9	; 169
    2542:	92 e1       	ldi	r25, 0x12	; 18
    2544:	90 93 e5 05 	sts	0x05E5, r25
    2548:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    254c:	10 92 5b 05 	sts	0x055B, r1
    2550:	08 95       	ret

00002552 <DoSampler>:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.

// Wed Apr  8 11:42:07 CDT 2009
// This state is based on the idea that playing, recording, and overdubbing are all discrete things and that if you're doing one you can't be doing another.
{
    2552:	8f 92       	push	r8
    2554:	9f 92       	push	r9
    2556:	af 92       	push	r10
    2558:	bf 92       	push	r11
    255a:	cf 92       	push	r12
    255c:	df 92       	push	r13
    255e:	ef 92       	push	r14
    2560:	ff 92       	push	r15
    2562:	0f 93       	push	r16
    2564:	1f 93       	push	r17
    2566:	cf 93       	push	r28
    2568:	df 93       	push	r29
    256a:	1f 92       	push	r1
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

//	static bool
//		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
    2570:	f0 90 5b 05 	lds	r15, 0x055B
    2574:	f1 10       	cpse	r15, r1
    2576:	8d c0       	rjmp	.+282    	; 0x2692 <DoSampler+0x140>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    2578:	84 e0       	ldi	r24, 0x04	; 4
    257a:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    257e:	80 31       	cpi	r24, 0x10	; 16
    2580:	08 f0       	brcs	.+2      	; 0x2584 <DoSampler+0x32>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2582:	80 e0       	ldi	r24, 0x00	; 0
//		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    2584:	80 93 2e 06 	sts	0x062E, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    2588:	88 e0       	ldi	r24, 0x08	; 8
    258a:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <EepromRead>
	}

	if(x<16)					// Legit number?
    258e:	80 31       	cpi	r24, 0x10	; 16
    2590:	08 f0       	brcs	.+2      	; 0x2594 <DoSampler+0x42>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2592:	81 e0       	ldi	r24, 0x01	; 1

	if(subState==SS_0)
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    2594:	80 93 47 06 	sts	0x0647, r24
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    2598:	10 92 f6 05 	sts	0x05F6, r1
    259c:	10 92 f7 05 	sts	0x05F7, r1
    25a0:	10 92 f8 05 	sts	0x05F8, r1
    25a4:	10 92 f9 05 	sts	0x05F9, r1
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    25a8:	8f ef       	ldi	r24, 0xFF	; 255
    25aa:	9f ef       	ldi	r25, 0xFF	; 255
    25ac:	a7 e0       	ldi	r26, 0x07	; 7
    25ae:	b0 e0       	ldi	r27, 0x00	; 0
    25b0:	80 93 19 06 	sts	0x0619, r24
    25b4:	90 93 1a 06 	sts	0x061A, r25
    25b8:	a0 93 1b 06 	sts	0x061B, r26
    25bc:	b0 93 1c 06 	sts	0x061C, r27
    25c0:	0e e5       	ldi	r16, 0x5E	; 94
    25c2:	15 e0       	ldi	r17, 0x05	; 5
    25c4:	70 e6       	ldi	r23, 0x60	; 96
    25c6:	87 2e       	mov	r8, r23
    25c8:	75 e0       	ldi	r23, 0x05	; 5
    25ca:	97 2e       	mov	r9, r23
    25cc:	e1 2c       	mov	r14, r1
    25ce:	f1 2c       	mov	r15, r1

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    25d0:	e3 e2       	ldi	r30, 0x23	; 35
    25d2:	ce 2e       	mov	r12, r30
			bankStates[i].loopOnce=false;
			bankStates[i].bitReduction=0;				// No crusties yet.
			bankStates[i].jitterValue=0;				// No hissies yet.
			bankStates[i].granularSlices=0;				// No remix yet.
			bankStates[i].halfSpeed=false;
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    25d4:	bb 24       	eor	r11, r11
    25d6:	b3 94       	inc	r11
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    25d8:	fc e0       	ldi	r31, 0x0C	; 12
    25da:	df 2e       	mov	r13, r31
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    25dc:	ce 9c       	mul	r12, r14
    25de:	f0 01       	movw	r30, r0
    25e0:	cf 9c       	mul	r12, r15
    25e2:	f0 0d       	add	r31, r0
    25e4:	11 24       	eor	r1, r1
    25e6:	ea 51       	subi	r30, 0x1A	; 26
    25e8:	fa 4f       	sbci	r31, 0xFA	; 250
    25ea:	10 82       	st	Z, r1
			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    25ec:	11 86       	std	Z+9, r1	; 0x09
			bankStates[i].loopOnce=false;
    25ee:	11 82       	std	Z+1, r1	; 0x01
			bankStates[i].bitReduction=0;				// No crusties yet.
    25f0:	10 86       	std	Z+8, r1	; 0x08
			bankStates[i].jitterValue=0;				// No hissies yet.
    25f2:	17 82       	std	Z+7, r1	; 0x07
			bankStates[i].granularSlices=0;				// No remix yet.
    25f4:	16 82       	std	Z+6, r1	; 0x06
			bankStates[i].halfSpeed=false;
    25f6:	12 82       	std	Z+2, r1	; 0x02
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    25f8:	b4 82       	std	Z+4, r11	; 0x04
			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    25fa:	13 82       	std	Z+3, r1	; 0x03
			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    25fc:	80 89       	ldd	r24, Z+16	; 0x10
    25fe:	91 89       	ldd	r25, Z+17	; 0x11
    2600:	a2 89       	ldd	r26, Z+18	; 0x12
    2602:	b3 89       	ldd	r27, Z+19	; 0x13
    2604:	87 8f       	std	Z+31, r24	; 0x1f
    2606:	90 a3       	std	Z+32, r25	; 0x20
    2608:	a1 a3       	std	Z+33, r26	; 0x21
    260a:	b2 a3       	std	Z+34, r27	; 0x22
			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    260c:	80 89       	ldd	r24, Z+16	; 0x10
    260e:	91 89       	ldd	r25, Z+17	; 0x11
    2610:	a2 89       	ldd	r26, Z+18	; 0x12
    2612:	b3 89       	ldd	r27, Z+19	; 0x13
    2614:	84 87       	std	Z+12, r24	; 0x0c
    2616:	95 87       	std	Z+13, r25	; 0x0d
    2618:	a6 87       	std	Z+14, r26	; 0x0e
    261a:	b7 87       	std	Z+15, r27	; 0x0f
			realtimeOn[i]=false;								// We'll default to playback.
    261c:	d8 01       	movw	r26, r16
    261e:	1d 92       	st	X+, r1
    2620:	8d 01       	movw	r16, r26
			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    2622:	15 82       	std	Z+5, r1	; 0x05
//			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
    2624:	8e 2d       	mov	r24, r14
    2626:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    262a:	e1 10       	cpse	r14, r1
    262c:	02 c0       	rjmp	.+4      	; 0x2632 <DoSampler+0xe0>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    262e:	87 e0       	ldi	r24, 0x07	; 7
    2630:	01 c0       	rjmp	.+2      	; 0x2634 <DoSampler+0xe2>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    2632:	8b e0       	ldi	r24, 0x0B	; 11
    2634:	0e 94 11 1e 	call	0x3c22	; 0x3c22 <EepromRead>
	}

	if(x<90)					// Legit number?
    2638:	8a 35       	cpi	r24, 0x5A	; 90
    263a:	08 f0       	brcs	.+2      	; 0x263e <DoSampler+0xec>
		return(x);
	}
	else
	{
		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or whatever).
		return(x);
    263c:	80 e3       	ldi	r24, 0x30	; 48
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    263e:	6d 2d       	mov	r22, r13
    2640:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2644:	e9 2f       	mov	r30, r25
    2646:	f0 e0       	ldi	r31, 0x00	; 0
    2648:	ee 0f       	add	r30, r30
    264a:	ff 1f       	adc	r31, r31
    264c:	ea 5f       	subi	r30, 0xFA	; 250
    264e:	fe 4f       	sbci	r31, 0xFE	; 254
    2650:	20 81       	ld	r18, Z
    2652:	31 81       	ldd	r19, Z+1	; 0x01
    2654:	02 c0       	rjmp	.+4      	; 0x265a <DoSampler+0x108>
    2656:	36 95       	lsr	r19
    2658:	27 95       	ror	r18
    265a:	8a 95       	dec	r24
    265c:	e2 f7       	brpl	.-8      	; 0x2656 <DoSampler+0x104>
//			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    265e:	f4 01       	movw	r30, r8
    2660:	21 93       	st	Z+, r18
    2662:	31 93       	st	Z+, r19
    2664:	4f 01       	movw	r8, r30
    2666:	ff ef       	ldi	r31, 0xFF	; 255
    2668:	ef 1a       	sub	r14, r31
    266a:	ff 0a       	sbc	r15, r31
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    266c:	22 e0       	ldi	r18, 0x02	; 2
    266e:	e2 16       	cp	r14, r18
    2670:	f1 04       	cpc	r15, r1
    2672:	09 f0       	breq	.+2      	; 0x2676 <DoSampler+0x124>
    2674:	b3 cf       	rjmp	.-154    	; 0x25dc <DoSampler+0x8a>

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
		}

		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2676:	85 e3       	ldi	r24, 0x35	; 53
    2678:	98 e0       	ldi	r25, 0x08	; 8
    267a:	90 93 e3 05 	sts	0x05E3, r25
    267e:	80 93 e2 05 	sts	0x05E2, r24

		currentBank=BANK_0;			// Point at the first bank until we change banks.
    2682:	10 92 64 05 	sts	0x0564, r1

		KillLeds();					// All leds off, and no blinking.
    2686:	0e 94 75 0e 	call	0x1cea	; 0x1cea <KillLeds>
		subState=SS_1;
    268a:	81 e0       	ldi	r24, 0x01	; 1
    268c:	80 93 5b 05 	sts	0x055B, r24
    2690:	12 c6       	rjmp	.+3108   	; 0x32b6 <DoSampler+0xd64>
	}

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    2692:	41 e0       	ldi	r20, 0x01	; 1
    2694:	f4 12       	cpse	r15, r20
    2696:	0f c6       	rjmp	.+3102   	; 0x32b6 <DoSampler+0xd64>
			lastEncoderValue;

	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
    2698:	80 91 6a 05 	lds	r24, 0x056A
    269c:	86 ff       	sbrs	r24, 6
    269e:	30 c2       	rjmp	.+1120   	; 0x2b00 <DoSampler+0x5ae>
    26a0:	87 ff       	sbrs	r24, 7
    26a2:	75 c1       	rjmp	.+746    	; 0x298e <DoSampler+0x43c>
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
    26a4:	80 91 57 05 	lds	r24, 0x0557
    26a8:	85 ff       	sbrs	r24, 5
    26aa:	24 c0       	rjmp	.+72     	; 0x26f4 <DoSampler+0x1a2>
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    26ac:	85 e3       	ldi	r24, 0x35	; 53
    26ae:	98 e0       	ldi	r25, 0x08	; 8
    26b0:	90 93 e3 05 	sts	0x05E3, r25
    26b4:	80 93 e2 05 	sts	0x05E2, r24
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    26b8:	10 91 64 05 	lds	r17, 0x0564
    26bc:	81 2f       	mov	r24, r17
    26be:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
			bankStates[currentBank].bitReduction=0;			// No crusties yet.
    26c2:	83 e2       	ldi	r24, 0x23	; 35
    26c4:	18 9f       	mul	r17, r24
    26c6:	f0 01       	movw	r30, r0
    26c8:	11 24       	eor	r1, r1
    26ca:	ea 51       	subi	r30, 0x1A	; 26
    26cc:	fa 4f       	sbci	r31, 0xFA	; 250
    26ce:	10 86       	std	Z+8, r1	; 0x08
			bankStates[currentBank].jitterValue=0;			// No hissies yet.
    26d0:	17 82       	std	Z+7, r1	; 0x07
			bankStates[currentBank].granularSlices=0;		// No remix yet.
    26d2:	16 82       	std	Z+6, r1	; 0x06
			bankStates[currentBank].halfSpeed=false;
    26d4:	12 82       	std	Z+2, r1	; 0x02
			bankStates[currentBank].backwardsPlayback=false;
    26d6:	13 82       	std	Z+3, r1	; 0x03
			bankStates[currentBank].sampleDirection=true;
    26d8:	f4 82       	std	Z+4, r15	; 0x04
			bankStates[currentBank].loopOnce=false;
    26da:	11 82       	std	Z+1, r1	; 0x01
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
    26dc:	20 e0       	ldi	r18, 0x00	; 0
    26de:	42 e1       	ldi	r20, 0x12	; 18
    26e0:	64 e0       	ldi	r22, 0x04	; 4
    26e2:	81 2f       	mov	r24, r17
    26e4:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
    26e8:	20 e0       	ldi	r18, 0x00	; 0
    26ea:	4b e1       	ldi	r20, 0x1B	; 27
    26ec:	64 e0       	ldi	r22, 0x04	; 4
    26ee:	80 91 64 05 	lds	r24, 0x0564
    26f2:	0b c3       	rjmp	.+1558   	; 0x2d0a <DoSampler+0x7b8>
		}
		else if(newKeys&Im_SWITCH_0)
    26f4:	80 ff       	sbrs	r24, 0
    26f6:	ef c0       	rjmp	.+478    	; 0x28d6 <DoSampler+0x384>
		{
			// Enter SD card menu
			WriteSampleToSd(currentBank,0);		// @@@ test
    26f8:	10 91 64 05 	lds	r17, 0x0564
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    26fc:	80 91 59 05 	lds	r24, 0x0559
    2700:	8e 30       	cpi	r24, 0x0E	; 14
    2702:	09 f0       	breq	.+2      	; 0x2706 <DoSampler+0x1b4>
    2704:	4d c3       	rjmp	.+1690   	; 0x2da0 <DoSampler+0x84e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    2706:	21 2f       	mov	r18, r17
    2708:	30 e0       	ldi	r19, 0x00	; 0
    270a:	93 e2       	ldi	r25, 0x23	; 35
    270c:	19 9f       	mul	r17, r25
    270e:	d0 01       	movw	r26, r0
    2710:	11 24       	eor	r1, r1
    2712:	aa 51       	subi	r26, 0x1A	; 26
    2714:	ba 4f       	sbci	r27, 0xFA	; 250
    2716:	15 96       	adiw	r26, 0x05	; 5
    2718:	8c 91       	ld	r24, X
    271a:	15 97       	sbiw	r26, 0x05	; 5
    271c:	81 11       	cpse	r24, r1
    271e:	40 c3       	rjmp	.+1664   	; 0x2da0 <DoSampler+0x84e>
	unsigned long
		theLength;

	if(theBank==BANK_0)
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    2720:	16 96       	adiw	r26, 0x06	; 6
    2722:	8c 91       	ld	r24, X
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    2724:	11 11       	cpse	r17, r1
    2726:	23 c0       	rjmp	.+70     	; 0x276e <DoSampler+0x21c>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    2728:	81 11       	cpse	r24, r1
    272a:	12 c0       	rjmp	.+36     	; 0x2750 <DoSampler+0x1fe>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    272c:	83 e2       	ldi	r24, 0x23	; 35
    272e:	82 9f       	mul	r24, r18
    2730:	a0 01       	movw	r20, r0
    2732:	83 9f       	mul	r24, r19
    2734:	50 0d       	add	r21, r0
    2736:	11 24       	eor	r1, r1
    2738:	4a 51       	subi	r20, 0x1A	; 26
    273a:	5a 4f       	sbci	r21, 0xFA	; 250
    273c:	fa 01       	movw	r30, r20
    273e:	84 89       	ldd	r24, Z+20	; 0x14
    2740:	95 89       	ldd	r25, Z+21	; 0x15
    2742:	a6 89       	ldd	r26, Z+22	; 0x16
    2744:	b7 89       	ldd	r27, Z+23	; 0x17
    2746:	40 8d       	ldd	r20, Z+24	; 0x18
    2748:	51 8d       	ldd	r21, Z+25	; 0x19
    274a:	62 8d       	ldd	r22, Z+26	; 0x1a
    274c:	73 8d       	ldd	r23, Z+27	; 0x1b
    274e:	22 c0       	rjmp	.+68     	; 0x2794 <DoSampler+0x242>
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    2750:	83 e2       	ldi	r24, 0x23	; 35
    2752:	82 9f       	mul	r24, r18
    2754:	d0 01       	movw	r26, r0
    2756:	83 9f       	mul	r24, r19
    2758:	b0 0d       	add	r27, r0
    275a:	11 24       	eor	r1, r1
    275c:	aa 51       	subi	r26, 0x1A	; 26
    275e:	ba 4f       	sbci	r27, 0xFA	; 250
    2760:	1c 96       	adiw	r26, 0x0c	; 12
    2762:	8d 91       	ld	r24, X+
    2764:	9d 91       	ld	r25, X+
    2766:	0d 90       	ld	r0, X+
    2768:	bc 91       	ld	r27, X
    276a:	a0 2d       	mov	r26, r0
    276c:	2c c0       	rjmp	.+88     	; 0x27c6 <DoSampler+0x274>
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    276e:	81 11       	cpse	r24, r1
    2770:	15 c0       	rjmp	.+42     	; 0x279c <DoSampler+0x24a>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    2772:	83 e2       	ldi	r24, 0x23	; 35
    2774:	82 9f       	mul	r24, r18
    2776:	a0 01       	movw	r20, r0
    2778:	83 9f       	mul	r24, r19
    277a:	50 0d       	add	r21, r0
    277c:	11 24       	eor	r1, r1
    277e:	4a 51       	subi	r20, 0x1A	; 26
    2780:	5a 4f       	sbci	r21, 0xFA	; 250
    2782:	fa 01       	movw	r30, r20
    2784:	80 8d       	ldd	r24, Z+24	; 0x18
    2786:	91 8d       	ldd	r25, Z+25	; 0x19
    2788:	a2 8d       	ldd	r26, Z+26	; 0x1a
    278a:	b3 8d       	ldd	r27, Z+27	; 0x1b
    278c:	44 89       	ldd	r20, Z+20	; 0x14
    278e:	55 89       	ldd	r21, Z+21	; 0x15
    2790:	66 89       	ldd	r22, Z+22	; 0x16
    2792:	77 89       	ldd	r23, Z+23	; 0x17
    2794:	01 96       	adiw	r24, 0x01	; 1
    2796:	a1 1d       	adc	r26, r1
    2798:	b1 1d       	adc	r27, r1
    279a:	11 c0       	rjmp	.+34     	; 0x27be <DoSampler+0x26c>
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    279c:	83 e2       	ldi	r24, 0x23	; 35
    279e:	82 9f       	mul	r24, r18
    27a0:	a0 01       	movw	r20, r0
    27a2:	83 9f       	mul	r24, r19
    27a4:	50 0d       	add	r21, r0
    27a6:	11 24       	eor	r1, r1
    27a8:	4a 51       	subi	r20, 0x1A	; 26
    27aa:	5a 4f       	sbci	r21, 0xFA	; 250
    27ac:	fa 01       	movw	r30, r20
    27ae:	80 89       	ldd	r24, Z+16	; 0x10
    27b0:	91 89       	ldd	r25, Z+17	; 0x11
    27b2:	a2 89       	ldd	r26, Z+18	; 0x12
    27b4:	b3 89       	ldd	r27, Z+19	; 0x13
    27b6:	44 85       	ldd	r20, Z+12	; 0x0c
    27b8:	55 85       	ldd	r21, Z+13	; 0x0d
    27ba:	66 85       	ldd	r22, Z+14	; 0x0e
    27bc:	77 85       	ldd	r23, Z+15	; 0x0f
    27be:	84 1b       	sub	r24, r20
    27c0:	95 0b       	sbc	r25, r21
    27c2:	a6 0b       	sbc	r26, r22
    27c4:	b7 0b       	sbc	r27, r23
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    27c6:	ff b7       	in	r31, 0x3f	; 63
			cli();		// Pause ISR
    27c8:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    27ca:	ef b7       	in	r30, 0x3f	; 63
	cli();		// Pause ISR
    27cc:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    27ce:	10 92 6f 05 	sts	0x056F, r1
    27d2:	10 92 6e 05 	sts	0x056E, r1
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    27d6:	41 e0       	ldi	r20, 0x01	; 1
    27d8:	50 e0       	ldi	r21, 0x00	; 0
    27da:	60 e0       	ldi	r22, 0x00	; 0
    27dc:	70 e0       	ldi	r23, 0x00	; 0
    27de:	40 93 70 05 	sts	0x0570, r20
    27e2:	50 93 71 05 	sts	0x0571, r21
    27e6:	60 93 72 05 	sts	0x0572, r22
    27ea:	70 93 73 05 	sts	0x0573, r23
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    27ee:	10 92 75 05 	sts	0x0575, r1
    27f2:	10 92 74 05 	sts	0x0574, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    27f6:	10 92 2b 01 	sts	0x012B, r1
    27fa:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    27fe:	10 92 29 01 	sts	0x0129, r1
    2802:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    2806:	10 92 27 01 	sts	0x0127, r1
    280a:	10 92 26 01 	sts	0x0126, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    280e:	8d 3f       	cpi	r24, 0xFD	; 253
    2810:	4f ef       	ldi	r20, 0xFF	; 255
    2812:	94 07       	cpc	r25, r20
    2814:	47 e0       	ldi	r20, 0x07	; 7
    2816:	a4 07       	cpc	r26, r20
    2818:	b1 05       	cpc	r27, r1
    281a:	08 f4       	brcc	.+2      	; 0x281e <DoSampler+0x2cc>
    281c:	04 c0       	rjmp	.+8      	; 0x2826 <DoSampler+0x2d4>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    281e:	8c ef       	ldi	r24, 0xFC	; 252
    2820:	9f ef       	ldi	r25, 0xFF	; 255
    2822:	a7 e0       	ldi	r26, 0x07	; 7
    2824:	b0 e0       	ldi	r27, 0x00	; 0
    2826:	80 93 22 01 	sts	0x0122, r24
    282a:	90 93 23 01 	sts	0x0123, r25
    282e:	a0 93 24 01 	sts	0x0124, r26
    2832:	b0 93 25 01 	sts	0x0125, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    2836:	80 91 22 01 	lds	r24, 0x0122
    283a:	90 91 23 01 	lds	r25, 0x0123
    283e:	a0 91 24 01 	lds	r26, 0x0124
    2842:	b0 91 25 01 	lds	r27, 0x0125
    2846:	80 93 1e 01 	sts	0x011E, r24
    284a:	90 93 1f 01 	sts	0x011F, r25
    284e:	a0 93 20 01 	sts	0x0120, r26
    2852:	b0 93 21 01 	sts	0x0121, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start
    2856:	82 e0       	ldi	r24, 0x02	; 2
    2858:	80 93 59 05 	sts	0x0559, r24
	SREG=sreg;	// Resume ISR
    285c:	ef bf       	out	0x3f, r30	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;

	sreg=SREG;
    285e:	4f b7       	in	r20, 0x3f	; 63
	cli();		// Pause ISRs
    2860:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    2862:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    2866:	83 e2       	ldi	r24, 0x23	; 35
    2868:	82 9f       	mul	r24, r18
    286a:	d0 01       	movw	r26, r0
    286c:	83 9f       	mul	r24, r19
    286e:	b0 0d       	add	r27, r0
    2870:	11 24       	eor	r1, r1
    2872:	aa 51       	subi	r26, 0x1A	; 26
    2874:	ba 4f       	sbci	r27, 0xFA	; 250
    2876:	81 e0       	ldi	r24, 0x01	; 1
    2878:	15 96       	adiw	r26, 0x05	; 5
    287a:	8c 93       	st	X, r24

	if(theBank==BANK_0)		// Pointing at this bank?
    287c:	11 11       	cpse	r17, r1
    287e:	0b c0       	rjmp	.+22     	; 0x2896 <DoSampler+0x344>
	{
		sdBank0=true;
    2880:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    2884:	10 92 50 05 	sts	0x0550, r1
    2888:	10 92 51 05 	sts	0x0551, r1
    288c:	10 92 52 05 	sts	0x0552, r1
    2890:	10 92 53 05 	sts	0x0553, r1
    2894:	0e c0       	rjmp	.+28     	; 0x28b2 <DoSampler+0x360>
	}
	else
	{
		sdBank0=false;
    2896:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    289a:	8f ef       	ldi	r24, 0xFF	; 255
    289c:	9f ef       	ldi	r25, 0xFF	; 255
    289e:	a7 e0       	ldi	r26, 0x07	; 7
    28a0:	b0 e0       	ldi	r27, 0x00	; 0
    28a2:	80 93 50 05 	sts	0x0550, r24
    28a6:	90 93 51 05 	sts	0x0551, r25
    28aa:	a0 93 52 05 	sts	0x0552, r26
    28ae:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    28b2:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    28b6:	81 e6       	ldi	r24, 0x61	; 97
    28b8:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    28bc:	8f ef       	ldi	r24, 0xFF	; 255
    28be:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    28c0:	80 91 70 00 	lds	r24, 0x0070
    28c4:	84 60       	ori	r24, 0x04	; 4
    28c6:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    28ca:	82 e0       	ldi	r24, 0x02	; 2
    28cc:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    28d0:	4f bf       	out	0x3f, r20	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    28d2:	ff bf       	out	0x3f, r31	; 63
    28d4:	65 c2       	rjmp	.+1226   	; 0x2da0 <DoSampler+0x84e>
		else if(newKeys&Im_SWITCH_0)
		{
			// Enter SD card menu
			WriteSampleToSd(currentBank,0);		// @@@ test
		}
		else if(newKeys&Im_SWITCH_1)
    28d6:	81 ff       	sbrs	r24, 1
    28d8:	63 c2       	rjmp	.+1222   	; 0x2da0 <DoSampler+0x84e>
		{
			// Enter SD card menu
			ReadSampleFromSd(currentBank,0);	// @@@ test
    28da:	10 91 64 05 	lds	r17, 0x0564
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    28de:	80 91 59 05 	lds	r24, 0x0559
    28e2:	8e 30       	cpi	r24, 0x0E	; 14
    28e4:	09 f0       	breq	.+2      	; 0x28e8 <DoSampler+0x396>
    28e6:	5c c2       	rjmp	.+1208   	; 0x2da0 <DoSampler+0x84e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    28e8:	83 e2       	ldi	r24, 0x23	; 35
    28ea:	18 9f       	mul	r17, r24
    28ec:	60 01       	movw	r12, r0
    28ee:	11 24       	eor	r1, r1
    28f0:	a6 ee       	ldi	r26, 0xE6	; 230
    28f2:	b5 e0       	ldi	r27, 0x05	; 5
    28f4:	ca 0e       	add	r12, r26
    28f6:	db 1e       	adc	r13, r27
    28f8:	f6 01       	movw	r30, r12
    28fa:	85 81       	ldd	r24, Z+5	; 0x05
    28fc:	81 11       	cpse	r24, r1
    28fe:	50 c2       	rjmp	.+1184   	; 0x2da0 <DoSampler+0x84e>
		{
			sreg=SREG;
    2900:	0f b7       	in	r16, 0x3f	; 63
			cli();		// Pause ISR
    2902:	f8 94       	cli

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
    2904:	80 e0       	ldi	r24, 0x00	; 0
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    290c:	81 e0       	ldi	r24, 0x01	; 1
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	a0 e0       	ldi	r26, 0x00	; 0
    2912:	b0 e0       	ldi	r27, 0x00	; 0
    2914:	80 93 22 01 	sts	0x0122, r24
    2918:	90 93 23 01 	sts	0x0123, r25
    291c:	a0 93 24 01 	sts	0x0124, r26
    2920:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;

	sreg=SREG;
    2924:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    2926:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    2928:	f0 92 4f 05 	sts	0x054F, r15
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    292c:	d6 01       	movw	r26, r12
    292e:	15 96       	adiw	r26, 0x05	; 5
    2930:	fc 92       	st	X, r15

	if(theBank==BANK_0)		// Pointing at this bank?
    2932:	11 11       	cpse	r17, r1
    2934:	0c c0       	rjmp	.+24     	; 0x294e <DoSampler+0x3fc>
	{
		sdBank0=true;
    2936:	81 e0       	ldi	r24, 0x01	; 1
    2938:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    293c:	10 92 50 05 	sts	0x0550, r1
    2940:	10 92 51 05 	sts	0x0551, r1
    2944:	10 92 52 05 	sts	0x0552, r1
    2948:	10 92 53 05 	sts	0x0553, r1
    294c:	0e c0       	rjmp	.+28     	; 0x296a <DoSampler+0x418>
	}
	else
	{
		sdBank0=false;
    294e:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    2952:	8f ef       	ldi	r24, 0xFF	; 255
    2954:	9f ef       	ldi	r25, 0xFF	; 255
    2956:	a7 e0       	ldi	r26, 0x07	; 7
    2958:	b0 e0       	ldi	r27, 0x00	; 0
    295a:	80 93 50 05 	sts	0x0550, r24
    295e:	90 93 51 05 	sts	0x0551, r25
    2962:	a0 93 52 05 	sts	0x0552, r26
    2966:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    296a:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    296e:	81 e6       	ldi	r24, 0x61	; 97
    2970:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2974:	8f ef       	ldi	r24, 0xFF	; 255
    2976:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2978:	80 91 70 00 	lds	r24, 0x0070
    297c:	84 60       	ori	r24, 0x04	; 4
    297e:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2982:	82 e0       	ldi	r24, 0x02	; 2
    2984:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    2988:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    298a:	0f bf       	out	0x3f, r16	; 63
    298c:	09 c2       	rjmp	.+1042   	; 0x2da0 <DoSampler+0x84e>
	// -----------------------------------------------------------------------------------
	// Shift 1:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    298e:	80 91 58 05 	lds	r24, 0x0558
    2992:	80 ff       	sbrs	r24, 0
    2994:	15 c0       	rjmp	.+42     	; 0x29c0 <DoSampler+0x46e>
		{
			if(encoderValue!=lastEncoderValue)	// Only update when the encoder changes AND the switch is pressed
    2996:	90 91 6b 05 	lds	r25, 0x056B
    299a:	80 91 6c 05 	lds	r24, 0x056C
    299e:	98 17       	cp	r25, r24
    29a0:	79 f0       	breq	.+30     	; 0x29c0 <DoSampler+0x46e>
			{
				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    29a2:	80 91 64 05 	lds	r24, 0x0564
    29a6:	20 91 6d 05 	lds	r18, 0x056D
    29aa:	b3 e2       	ldi	r27, 0x23	; 35
    29ac:	8b 9f       	mul	r24, r27
    29ae:	f0 01       	movw	r30, r0
    29b0:	11 24       	eor	r1, r1
    29b2:	ea 51       	subi	r30, 0x1A	; 26
    29b4:	fa 4f       	sbci	r31, 0xFA	; 250
    29b6:	20 87       	std	Z+8, r18	; 0x08
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    29b8:	43 e1       	ldi	r20, 0x13	; 19
    29ba:	64 e0       	ldi	r22, 0x04	; 4
    29bc:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
    29c0:	80 91 57 05 	lds	r24, 0x0557
    29c4:	81 ff       	sbrs	r24, 1
    29c6:	15 c0       	rjmp	.+42     	; 0x29f2 <DoSampler+0x4a0>
		{
			if(bankStates[currentBank].halfSpeed==false)
    29c8:	80 91 64 05 	lds	r24, 0x0564
    29cc:	23 e2       	ldi	r18, 0x23	; 35
    29ce:	82 9f       	mul	r24, r18
    29d0:	f0 01       	movw	r30, r0
    29d2:	11 24       	eor	r1, r1
    29d4:	ea 51       	subi	r30, 0x1A	; 26
    29d6:	fa 4f       	sbci	r31, 0xFA	; 250
    29d8:	92 81       	ldd	r25, Z+2	; 0x02
    29da:	91 11       	cpse	r25, r1
    29dc:	04 c0       	rjmp	.+8      	; 0x29e6 <DoSampler+0x494>
			{
				bankStates[currentBank].halfSpeed=true;
    29de:	91 e0       	ldi	r25, 0x01	; 1
    29e0:	92 83       	std	Z+2, r25	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    29e2:	20 e4       	ldi	r18, 0x40	; 64
    29e4:	02 c0       	rjmp	.+4      	; 0x29ea <DoSampler+0x498>
			}
			else
			{
				bankStates[currentBank].halfSpeed=false;
    29e6:	12 82       	std	Z+2, r1	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    29e8:	20 e0       	ldi	r18, 0x00	; 0
    29ea:	40 e1       	ldi	r20, 0x10	; 16
    29ec:	64 e0       	ldi	r22, 0x04	; 4
    29ee:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
    29f2:	80 91 57 05 	lds	r24, 0x0557
    29f6:	82 ff       	sbrs	r24, 2
    29f8:	0e c0       	rjmp	.+28     	; 0x2a16 <DoSampler+0x4c4>
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
    29fa:	10 91 64 05 	lds	r17, 0x0564
    29fe:	40 e0       	ldi	r20, 0x00	; 0
    2a00:	50 e0       	ldi	r21, 0x00	; 0
    2a02:	61 e0       	ldi	r22, 0x01	; 1
    2a04:	81 2f       	mov	r24, r17
    2a06:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <StartRealtime>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2a0a:	20 e3       	ldi	r18, 0x30	; 48
    2a0c:	4e e0       	ldi	r20, 0x0E	; 14
    2a0e:	64 e0       	ldi	r22, 0x04	; 4
    2a10:	81 2f       	mov	r24, r17
    2a12:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
		}
		if(((keyState&Im_SWITCH_3)&&(encoderValue!=lastEncoderValue))||(newKeys&Im_SWITCH_3))		// Granularize the sample -- reshuffle if the encoder moves OR we get a new button press, but not just while the button is held
    2a16:	80 91 58 05 	lds	r24, 0x0558
    2a1a:	83 ff       	sbrs	r24, 3
    2a1c:	06 c0       	rjmp	.+12     	; 0x2a2a <DoSampler+0x4d8>
    2a1e:	90 91 6b 05 	lds	r25, 0x056B
    2a22:	80 91 6c 05 	lds	r24, 0x056C
    2a26:	98 13       	cpse	r25, r24
    2a28:	04 c0       	rjmp	.+8      	; 0x2a32 <DoSampler+0x4e0>
    2a2a:	80 91 57 05 	lds	r24, 0x0557
    2a2e:	83 ff       	sbrs	r24, 3
    2a30:	10 c0       	rjmp	.+32     	; 0x2a52 <DoSampler+0x500>
		{
			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
    2a32:	20 91 6b 05 	lds	r18, 0x056B
    2a36:	26 95       	lsr	r18
    2a38:	10 91 64 05 	lds	r17, 0x0564
    2a3c:	62 2f       	mov	r22, r18
    2a3e:	81 2f       	mov	r24, r17
    2a40:	29 83       	std	Y+1, r18	; 0x01
    2a42:	0e 94 2d 09 	call	0x125a	; 0x125a <MakeNewGranularArray>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    2a46:	29 81       	ldd	r18, Y+1	; 0x01
    2a48:	44 e1       	ldi	r20, 0x14	; 20
    2a4a:	64 e0       	ldi	r22, 0x04	; 4
    2a4c:	81 2f       	mov	r24, r17
    2a4e:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
    2a52:	80 91 58 05 	lds	r24, 0x0558
    2a56:	84 ff       	sbrs	r24, 4
    2a58:	35 c0       	rjmp	.+106    	; 0x2ac4 <DoSampler+0x572>
		{
			if(encoderValue!=lastEncoderValue)	// Only change to new values
    2a5a:	90 91 6b 05 	lds	r25, 0x056B
    2a5e:	80 91 6c 05 	lds	r24, 0x056C
    2a62:	98 17       	cp	r25, r24
    2a64:	79 f1       	breq	.+94     	; 0x2ac4 <DoSampler+0x572>
			{
				switch(scaledEncoderValue)
    2a66:	80 91 6d 05 	lds	r24, 0x056D
    2a6a:	81 30       	cpi	r24, 0x01	; 1
    2a6c:	71 f0       	breq	.+28     	; 0x2a8a <DoSampler+0x538>
    2a6e:	28 f0       	brcs	.+10     	; 0x2a7a <DoSampler+0x528>
    2a70:	82 30       	cpi	r24, 0x02	; 2
    2a72:	99 f0       	breq	.+38     	; 0x2a9a <DoSampler+0x548>
    2a74:	83 30       	cpi	r24, 0x03	; 3
    2a76:	31 f5       	brne	.+76     	; 0x2ac4 <DoSampler+0x572>
    2a78:	18 c0       	rjmp	.+48     	; 0x2aaa <DoSampler+0x558>
				{
					case 0:
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2a7a:	85 e3       	ldi	r24, 0x35	; 53
    2a7c:	98 e0       	ldi	r25, 0x08	; 8
    2a7e:	90 93 e3 05 	sts	0x05E3, r25
    2a82:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a86:	20 e0       	ldi	r18, 0x00	; 0
    2a88:	17 c0       	rjmp	.+46     	; 0x2ab8 <DoSampler+0x566>
					break;

					case 1:
					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2a8a:	89 ee       	ldi	r24, 0xE9	; 233
    2a8c:	97 e0       	ldi	r25, 0x07	; 7
    2a8e:	90 93 e3 05 	sts	0x05E3, r25
    2a92:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2a96:	21 e0       	ldi	r18, 0x01	; 1
    2a98:	0f c0       	rjmp	.+30     	; 0x2ab8 <DoSampler+0x566>
					break;

					case 2:
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2a9a:	88 ea       	ldi	r24, 0xA8	; 168
    2a9c:	98 e0       	ldi	r25, 0x08	; 8
    2a9e:	90 93 e3 05 	sts	0x05E3, r25
    2aa2:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2aa6:	22 e0       	ldi	r18, 0x02	; 2
    2aa8:	07 c0       	rjmp	.+14     	; 0x2ab8 <DoSampler+0x566>
					break;

					case 3:
					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2aaa:	8b e6       	ldi	r24, 0x6B	; 107
    2aac:	98 e0       	ldi	r25, 0x08	; 8
    2aae:	90 93 e3 05 	sts	0x05E3, r25
    2ab2:	80 93 e2 05 	sts	0x05E2, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2ab6:	23 e0       	ldi	r18, 0x03	; 3
    2ab8:	46 e1       	ldi	r20, 0x16	; 22
    2aba:	64 e0       	ldi	r22, 0x04	; 4
    2abc:	80 91 64 05 	lds	r24, 0x0564
    2ac0:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
					default:
					break;
				}
			}
		}
		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
    2ac4:	80 91 57 05 	lds	r24, 0x0557
    2ac8:	85 ff       	sbrs	r24, 5
    2aca:	6a c1       	rjmp	.+724    	; 0x2da0 <DoSampler+0x84e>
		{
			if(bankStates[currentBank].backwardsPlayback==false)
    2acc:	80 91 64 05 	lds	r24, 0x0564
    2ad0:	43 e2       	ldi	r20, 0x23	; 35
    2ad2:	84 9f       	mul	r24, r20
    2ad4:	f0 01       	movw	r30, r0
    2ad6:	11 24       	eor	r1, r1
    2ad8:	ea 51       	subi	r30, 0x1A	; 26
    2ada:	fa 4f       	sbci	r31, 0xFA	; 250
    2adc:	93 81       	ldd	r25, Z+3	; 0x03
    2ade:	91 11       	cpse	r25, r1
    2ae0:	04 c0       	rjmp	.+8      	; 0x2aea <DoSampler+0x598>
			{
				bankStates[currentBank].backwardsPlayback=true;
    2ae2:	91 e0       	ldi	r25, 0x01	; 1
    2ae4:	93 83       	std	Z+3, r25	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2ae6:	20 e4       	ldi	r18, 0x40	; 64
    2ae8:	02 c0       	rjmp	.+4      	; 0x2aee <DoSampler+0x59c>
			}
			else
			{
				bankStates[currentBank].backwardsPlayback=false;
    2aea:	13 82       	std	Z+3, r1	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2aec:	20 e0       	ldi	r18, 0x00	; 0
    2aee:	41 e1       	ldi	r20, 0x11	; 17
    2af0:	64 e0       	ldi	r22, 0x04	; 4
    2af2:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
			}

			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2af6:	80 91 64 05 	lds	r24, 0x0564
    2afa:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
    2afe:	50 c1       	rjmp	.+672    	; 0x2da0 <DoSampler+0x84e>
		}
	}
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
    2b00:	87 ff       	sbrs	r24, 7
    2b02:	53 c0       	rjmp	.+166    	; 0x2baa <DoSampler+0x658>
	{
		if(keyState&Im_SWITCH_0)		// Adjust sample start
    2b04:	80 91 58 05 	lds	r24, 0x0558
    2b08:	80 ff       	sbrs	r24, 0
    2b0a:	15 c0       	rjmp	.+42     	; 0x2b36 <DoSampler+0x5e4>
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2b0c:	10 91 64 05 	lds	r17, 0x0564
    2b10:	83 e2       	ldi	r24, 0x23	; 35
    2b12:	18 9f       	mul	r17, r24
    2b14:	f0 01       	movw	r30, r0
    2b16:	11 24       	eor	r1, r1
    2b18:	ea 51       	subi	r30, 0x1A	; 26
    2b1a:	fa 4f       	sbci	r31, 0xFA	; 250
    2b1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b1e:	00 91 6b 05 	lds	r16, 0x056B
    2b22:	80 17       	cp	r24, r16
    2b24:	c9 f1       	breq	.+114    	; 0x2b98 <DoSampler+0x646>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2b26:	04 8f       	std	Z+28, r16	; 0x1c
	UpdateAdjustedSampleAddresses(theBank);
    2b28:	81 2f       	mov	r24, r17
    2b2a:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		if(keyState&Im_SWITCH_0)		// Adjust sample start
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2b2e:	20 2f       	mov	r18, r16
    2b30:	26 95       	lsr	r18
    2b32:	4c e1       	ldi	r20, 0x1C	; 28
    2b34:	2d c0       	rjmp	.+90     	; 0x2b90 <DoSampler+0x63e>
			}
		}
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
    2b36:	81 ff       	sbrs	r24, 1
    2b38:	15 c0       	rjmp	.+42     	; 0x2b64 <DoSampler+0x612>
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2b3a:	10 91 64 05 	lds	r17, 0x0564
    2b3e:	93 e2       	ldi	r25, 0x23	; 35
    2b40:	19 9f       	mul	r17, r25
    2b42:	f0 01       	movw	r30, r0
    2b44:	11 24       	eor	r1, r1
    2b46:	ea 51       	subi	r30, 0x1A	; 26
    2b48:	fa 4f       	sbci	r31, 0xFA	; 250
    2b4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b4c:	00 91 6b 05 	lds	r16, 0x056B
    2b50:	80 17       	cp	r24, r16
    2b52:	11 f1       	breq	.+68     	; 0x2b98 <DoSampler+0x646>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2b54:	05 8f       	std	Z+29, r16	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    2b56:	81 2f       	mov	r24, r17
    2b58:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2b5c:	20 2f       	mov	r18, r16
    2b5e:	26 95       	lsr	r18
    2b60:	4d e1       	ldi	r20, 0x1D	; 29
    2b62:	16 c0       	rjmp	.+44     	; 0x2b90 <DoSampler+0x63e>
			}
		}
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
    2b64:	82 ff       	sbrs	r24, 2
    2b66:	18 c0       	rjmp	.+48     	; 0x2b98 <DoSampler+0x646>
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2b68:	10 91 64 05 	lds	r17, 0x0564
    2b6c:	a3 e2       	ldi	r26, 0x23	; 35
    2b6e:	1a 9f       	mul	r17, r26
    2b70:	f0 01       	movw	r30, r0
    2b72:	11 24       	eor	r1, r1
    2b74:	ea 51       	subi	r30, 0x1A	; 26
    2b76:	fa 4f       	sbci	r31, 0xFA	; 250
    2b78:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b7a:	00 91 6b 05 	lds	r16, 0x056B
    2b7e:	80 17       	cp	r24, r16
    2b80:	59 f0       	breq	.+22     	; 0x2b98 <DoSampler+0x646>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    2b82:	06 8f       	std	Z+30, r16	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    2b84:	81 2f       	mov	r24, r17
    2b86:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2b8a:	20 2f       	mov	r18, r16
    2b8c:	26 95       	lsr	r18
    2b8e:	4e e1       	ldi	r20, 0x1E	; 30
    2b90:	64 e0       	ldi	r22, 0x04	; 4
    2b92:	81 2f       	mov	r24, r17
    2b94:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
			}
		}

		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
    2b98:	80 91 57 05 	lds	r24, 0x0557
    2b9c:	83 ff       	sbrs	r24, 3
    2b9e:	00 c1       	rjmp	.+512    	; 0x2da0 <DoSampler+0x84e>
		{
//			PlaySampleFromSd(BANK_0,0);		// @@@
			PlaySampleFromSd(0);			// @@@ stream from slot 0
    2ba0:	80 e0       	ldi	r24, 0x00	; 0
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <PlaySampleFromSd>
    2ba8:	fb c0       	rjmp	.+502    	; 0x2da0 <DoSampler+0x84e>
	// -----------------------------------------------------------------------------------
	// No shift keys pressed:
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
    2baa:	80 91 57 05 	lds	r24, 0x0557
    2bae:	80 ff       	sbrs	r24, 0
    2bb0:	22 c0       	rjmp	.+68     	; 0x2bf6 <DoSampler+0x6a4>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2bb2:	10 91 64 05 	lds	r17, 0x0564
    2bb6:	b3 e2       	ldi	r27, 0x23	; 35
    2bb8:	1b 9f       	mul	r17, r27
    2bba:	70 01       	movw	r14, r0
    2bbc:	11 24       	eor	r1, r1
    2bbe:	e6 ee       	ldi	r30, 0xE6	; 230
    2bc0:	f5 e0       	ldi	r31, 0x05	; 5
    2bc2:	ee 0e       	add	r14, r30
    2bc4:	ff 1e       	adc	r15, r31
    2bc6:	d7 01       	movw	r26, r14
    2bc8:	8c 91       	ld	r24, X
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2bca:	40 e0       	ldi	r20, 0x00	; 0
    2bcc:	50 e0       	ldi	r21, 0x00	; 0
    2bce:	61 e0       	ldi	r22, 0x01	; 1
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2bd0:	83 30       	cpi	r24, 0x03	; 3
    2bd2:	49 f4       	brne	.+18     	; 0x2be6 <DoSampler+0x694>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2bd4:	81 2f       	mov	r24, r17
    2bd6:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2bda:	f7 01       	movw	r30, r14
    2bdc:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2bde:	20 e4       	ldi	r18, 0x40	; 64
    2be0:	40 e3       	ldi	r20, 0x30	; 48
    2be2:	61 e0       	ldi	r22, 0x01	; 1
    2be4:	06 c0       	rjmp	.+12     	; 0x2bf2 <DoSampler+0x6a0>
			}
			else											// We're not recording right now, so start doing it.
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2be6:	81 2f       	mov	r24, r17
    2be8:	0e 94 57 10 	call	0x20ae	; 0x20ae <StartRecording>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2bec:	20 e3       	ldi	r18, 0x30	; 48
    2bee:	43 e0       	ldi	r20, 0x03	; 3
    2bf0:	64 e0       	ldi	r22, 0x04	; 4
    2bf2:	81 2f       	mov	r24, r17
    2bf4:	8a c0       	rjmp	.+276    	; 0x2d0a <DoSampler+0x7b8>
			}
		}
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2bf6:	81 ff       	sbrs	r24, 1
    2bf8:	35 c0       	rjmp	.+106    	; 0x2c64 <DoSampler+0x712>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    2bfa:	f0 90 64 05 	lds	r15, 0x0564
    2bfe:	f3 e2       	ldi	r31, 0x23	; 35
    2c00:	ff 9e       	mul	r15, r31
    2c02:	60 01       	movw	r12, r0
    2c04:	11 24       	eor	r1, r1
    2c06:	86 ee       	ldi	r24, 0xE6	; 230
    2c08:	95 e0       	ldi	r25, 0x05	; 5
    2c0a:	c8 0e       	add	r12, r24
    2c0c:	d9 1e       	adc	r13, r25
    2c0e:	d6 01       	movw	r26, r12
    2c10:	8c 91       	ld	r24, X
    2c12:	85 30       	cpi	r24, 0x05	; 5
    2c14:	51 f4       	brne	.+20     	; 0x2c2a <DoSampler+0x6d8>
			{
				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
    2c16:	40 e0       	ldi	r20, 0x00	; 0
    2c18:	50 e0       	ldi	r21, 0x00	; 0
    2c1a:	61 e0       	ldi	r22, 0x01	; 1
    2c1c:	8f 2d       	mov	r24, r15
    2c1e:	0e 94 2f 10 	call	0x205e	; 0x205e <ContinuePlayback>
				bankStates[currentBank].loopOnce=false;
    2c22:	f6 01       	movw	r30, r12
    2c24:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    2c26:	20 e0       	ldi	r18, 0x00	; 0
    2c28:	1a c0       	rjmp	.+52     	; 0x2c5e <DoSampler+0x70c>
			}
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2c2a:	d6 01       	movw	r26, r12
    2c2c:	50 96       	adiw	r26, 0x10	; 16
    2c2e:	0d 91       	ld	r16, X+
    2c30:	1d 91       	ld	r17, X+
    2c32:	2d 91       	ld	r18, X+
    2c34:	3c 91       	ld	r19, X
    2c36:	53 97       	sbiw	r26, 0x13	; 19
    2c38:	1c 96       	adiw	r26, 0x0c	; 12
    2c3a:	4d 91       	ld	r20, X+
    2c3c:	5d 91       	ld	r21, X+
    2c3e:	6d 91       	ld	r22, X+
    2c40:	7c 91       	ld	r23, X
    2c42:	1f 97       	sbiw	r26, 0x0f	; 15
    2c44:	04 17       	cp	r16, r20
    2c46:	15 07       	cpc	r17, r21
    2c48:	26 07       	cpc	r18, r22
    2c4a:	37 07       	cpc	r19, r23
    2c4c:	09 f4       	brne	.+2      	; 0x2c50 <DoSampler+0x6fe>
    2c4e:	a8 c0       	rjmp	.+336    	; 0x2da0 <DoSampler+0x84e>
				{
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    2c50:	40 e0       	ldi	r20, 0x00	; 0
    2c52:	50 e0       	ldi	r21, 0x00	; 0
    2c54:	61 e0       	ldi	r22, 0x01	; 1
    2c56:	8f 2d       	mov	r24, r15
    2c58:	0e 94 b5 10 	call	0x216a	; 0x216a <StartOverdub>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2c5c:	20 e3       	ldi	r18, 0x30	; 48
    2c5e:	49 e0       	ldi	r20, 0x09	; 9
    2c60:	64 e0       	ldi	r22, 0x04	; 4
    2c62:	91 c0       	rjmp	.+290    	; 0x2d86 <DoSampler+0x834>
				}
			}
		}
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
    2c64:	82 ff       	sbrs	r24, 2
    2c66:	26 c0       	rjmp	.+76     	; 0x2cb4 <DoSampler+0x762>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2c68:	f0 90 64 05 	lds	r15, 0x0564
    2c6c:	b3 e2       	ldi	r27, 0x23	; 35
    2c6e:	fb 9e       	mul	r15, r27
    2c70:	60 01       	movw	r12, r0
    2c72:	11 24       	eor	r1, r1
    2c74:	e6 ee       	ldi	r30, 0xE6	; 230
    2c76:	f5 e0       	ldi	r31, 0x05	; 5
    2c78:	ce 0e       	add	r12, r30
    2c7a:	df 1e       	adc	r13, r31
    2c7c:	d6 01       	movw	r26, r12
    2c7e:	50 96       	adiw	r26, 0x10	; 16
    2c80:	0d 91       	ld	r16, X+
    2c82:	1d 91       	ld	r17, X+
    2c84:	2d 91       	ld	r18, X+
    2c86:	3c 91       	ld	r19, X
    2c88:	53 97       	sbiw	r26, 0x13	; 19
    2c8a:	1c 96       	adiw	r26, 0x0c	; 12
    2c8c:	4d 91       	ld	r20, X+
    2c8e:	5d 91       	ld	r21, X+
    2c90:	6d 91       	ld	r22, X+
    2c92:	7c 91       	ld	r23, X
    2c94:	1f 97       	sbiw	r26, 0x0f	; 15
    2c96:	04 17       	cp	r16, r20
    2c98:	15 07       	cpc	r17, r21
    2c9a:	26 07       	cpc	r18, r22
    2c9c:	37 07       	cpc	r19, r23
    2c9e:	09 f4       	brne	.+2      	; 0x2ca2 <DoSampler+0x750>
    2ca0:	7f c0       	rjmp	.+254    	; 0x2da0 <DoSampler+0x84e>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2ca2:	40 e0       	ldi	r20, 0x00	; 0
    2ca4:	50 e0       	ldi	r21, 0x00	; 0
    2ca6:	61 e0       	ldi	r22, 0x01	; 1
    2ca8:	8f 2d       	mov	r24, r15
    2caa:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2cae:	f6 01       	movw	r30, r12
    2cb0:	11 82       	std	Z+1, r1	; 0x01
    2cb2:	58 c0       	rjmp	.+176    	; 0x2d64 <DoSampler+0x812>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    2cb4:	83 ff       	sbrs	r24, 3
    2cb6:	2c c0       	rjmp	.+88     	; 0x2d10 <DoSampler+0x7be>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2cb8:	e0 90 64 05 	lds	r14, 0x0564
    2cbc:	f3 e2       	ldi	r31, 0x23	; 35
    2cbe:	ef 9e       	mul	r14, r31
    2cc0:	60 01       	movw	r12, r0
    2cc2:	11 24       	eor	r1, r1
    2cc4:	86 ee       	ldi	r24, 0xE6	; 230
    2cc6:	95 e0       	ldi	r25, 0x05	; 5
    2cc8:	c8 0e       	add	r12, r24
    2cca:	d9 1e       	adc	r13, r25
    2ccc:	d6 01       	movw	r26, r12
    2cce:	50 96       	adiw	r26, 0x10	; 16
    2cd0:	0d 91       	ld	r16, X+
    2cd2:	1d 91       	ld	r17, X+
    2cd4:	2d 91       	ld	r18, X+
    2cd6:	3c 91       	ld	r19, X
    2cd8:	53 97       	sbiw	r26, 0x13	; 19
    2cda:	1c 96       	adiw	r26, 0x0c	; 12
    2cdc:	4d 91       	ld	r20, X+
    2cde:	5d 91       	ld	r21, X+
    2ce0:	6d 91       	ld	r22, X+
    2ce2:	7c 91       	ld	r23, X
    2ce4:	1f 97       	sbiw	r26, 0x0f	; 15
    2ce6:	04 17       	cp	r16, r20
    2ce8:	15 07       	cpc	r17, r21
    2cea:	26 07       	cpc	r18, r22
    2cec:	37 07       	cpc	r19, r23
    2cee:	09 f4       	brne	.+2      	; 0x2cf2 <DoSampler+0x7a0>
    2cf0:	57 c0       	rjmp	.+174    	; 0x2da0 <DoSampler+0x84e>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    2cf2:	40 e0       	ldi	r20, 0x00	; 0
    2cf4:	50 e0       	ldi	r21, 0x00	; 0
    2cf6:	61 e0       	ldi	r22, 0x01	; 1
    2cf8:	8e 2d       	mov	r24, r14
    2cfa:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <StartPlayback>
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    2cfe:	f6 01       	movw	r30, r12
    2d00:	f1 82       	std	Z+1, r15	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2d02:	20 e4       	ldi	r18, 0x40	; 64
    2d04:	40 e3       	ldi	r20, 0x30	; 48
    2d06:	61 e0       	ldi	r22, 0x01	; 1
    2d08:	8e 2d       	mov	r24, r14
    2d0a:	0e 94 bf 1e 	call	0x3d7e	; 0x3d7e <PutMidiMessageInOutgoingFifo>
    2d0e:	48 c0       	rjmp	.+144    	; 0x2da0 <DoSampler+0x84e>
			}
		}
		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this will stop it at the current sample location.  If playback is idle it will restart it.  This will not restart a playing sample from the beginning.
    2d10:	84 ff       	sbrs	r24, 4
    2d12:	3b c0       	rjmp	.+118    	; 0x2d8a <DoSampler+0x838>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    2d14:	f0 90 64 05 	lds	r15, 0x0564
    2d18:	2f 2d       	mov	r18, r15
    2d1a:	30 e0       	ldi	r19, 0x00	; 0
    2d1c:	43 e2       	ldi	r20, 0x23	; 35
    2d1e:	f4 9e       	mul	r15, r20
    2d20:	f0 01       	movw	r30, r0
    2d22:	11 24       	eor	r1, r1
    2d24:	ea 51       	subi	r30, 0x1A	; 26
    2d26:	fa 4f       	sbci	r31, 0xFA	; 250
    2d28:	80 81       	ld	r24, Z
    2d2a:	81 11       	cpse	r24, r1
    2d2c:	1f c0       	rjmp	.+62     	; 0x2d6c <DoSampler+0x81a>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2d2e:	83 e2       	ldi	r24, 0x23	; 35
    2d30:	82 9f       	mul	r24, r18
    2d32:	f0 01       	movw	r30, r0
    2d34:	83 9f       	mul	r24, r19
    2d36:	f0 0d       	add	r31, r0
    2d38:	11 24       	eor	r1, r1
    2d3a:	ea 51       	subi	r30, 0x1A	; 26
    2d3c:	fa 4f       	sbci	r31, 0xFA	; 250
    2d3e:	00 89       	ldd	r16, Z+16	; 0x10
    2d40:	11 89       	ldd	r17, Z+17	; 0x11
    2d42:	22 89       	ldd	r18, Z+18	; 0x12
    2d44:	33 89       	ldd	r19, Z+19	; 0x13
    2d46:	44 85       	ldd	r20, Z+12	; 0x0c
    2d48:	55 85       	ldd	r21, Z+13	; 0x0d
    2d4a:	66 85       	ldd	r22, Z+14	; 0x0e
    2d4c:	77 85       	ldd	r23, Z+15	; 0x0f
    2d4e:	04 17       	cp	r16, r20
    2d50:	15 07       	cpc	r17, r21
    2d52:	26 07       	cpc	r18, r22
    2d54:	37 07       	cpc	r19, r23
    2d56:	21 f1       	breq	.+72     	; 0x2da0 <DoSampler+0x84e>
				{
					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
    2d58:	40 e0       	ldi	r20, 0x00	; 0
    2d5a:	50 e0       	ldi	r21, 0x00	; 0
    2d5c:	61 e0       	ldi	r22, 0x01	; 1
    2d5e:	8f 2d       	mov	r24, r15
    2d60:	0e 94 2f 10 	call	0x205e	; 0x205e <ContinuePlayback>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2d64:	20 e4       	ldi	r18, 0x40	; 64
    2d66:	40 e3       	ldi	r20, 0x30	; 48
    2d68:	61 e0       	ldi	r22, 0x01	; 1
    2d6a:	0d c0       	rjmp	.+26     	; 0x2d86 <DoSampler+0x834>
				}
			}
			else		// Pause whatever we were doing.
			{
				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    2d6c:	83 e2       	ldi	r24, 0x23	; 35
    2d6e:	82 9f       	mul	r24, r18
    2d70:	f0 01       	movw	r30, r0
    2d72:	83 9f       	mul	r24, r19
    2d74:	f0 0d       	add	r31, r0
    2d76:	11 24       	eor	r1, r1
    2d78:	ea 51       	subi	r30, 0x1A	; 26
    2d7a:	fa 4f       	sbci	r31, 0xFA	; 250
    2d7c:	10 82       	st	Z, r1
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    2d7e:	11 86       	std	Z+9, r1	; 0x09
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2d80:	20 e0       	ldi	r18, 0x00	; 0
    2d82:	40 e3       	ldi	r20, 0x30	; 48
    2d84:	62 e0       	ldi	r22, 0x02	; 2
    2d86:	8f 2d       	mov	r24, r15
    2d88:	c0 cf       	rjmp	.-128    	; 0x2d0a <DoSampler+0x7b8>
			}

		}
		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
    2d8a:	85 ff       	sbrs	r24, 5
    2d8c:	09 c0       	rjmp	.+18     	; 0x2da0 <DoSampler+0x84e>
		{
			currentBank++;
    2d8e:	80 91 64 05 	lds	r24, 0x0564
    2d92:	8f 5f       	subi	r24, 0xFF	; 255
    2d94:	80 93 64 05 	sts	0x0564, r24
			if(currentBank>=NUM_BANKS)
    2d98:	82 30       	cpi	r24, 0x02	; 2
    2d9a:	10 f0       	brcs	.+4      	; 0x2da0 <DoSampler+0x84e>
			{
				currentBank=BANK_0;		// Loop around.
    2d9c:	10 92 64 05 	sts	0x0564, r1
			}
		}
	}

	lastEncoderValue=encoderValue;		// Only update some of these if the encoder value changes
    2da0:	80 91 6b 05 	lds	r24, 0x056B
    2da4:	80 93 6c 05 	sts	0x056C, r24

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
	{
		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI

		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
    2da8:	80 91 60 06 	lds	r24, 0x0660
    2dac:	88 23       	and	r24, r24
    2dae:	09 f4       	brne	.+2      	; 0x2db2 <DoSampler+0x860>
    2db0:	82 c2       	rjmp	.+1284   	; 0x32b6 <DoSampler+0xd64>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    2db2:	85 e6       	ldi	r24, 0x65	; 101
    2db4:	95 e0       	ldi	r25, 0x05	; 5
    2db6:	0e 94 98 1e 	call	0x3d30	; 0x3d30 <GetMidiMessageFromIncomingFifo>
			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
			{
				// Do this here.
			}
*/
			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    2dba:	80 91 66 05 	lds	r24, 0x0566
    2dbe:	82 30       	cpi	r24, 0x02	; 2
    2dc0:	11 f5       	brne	.+68     	; 0x2e06 <DoSampler+0x8b4>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    2dc2:	e0 91 65 05 	lds	r30, 0x0565
    2dc6:	8e 2f       	mov	r24, r30
    2dc8:	90 e0       	ldi	r25, 0x00	; 0
    2dca:	a3 e2       	ldi	r26, 0x23	; 35
    2dcc:	ea 9f       	mul	r30, r26
    2dce:	f0 01       	movw	r30, r0
    2dd0:	11 24       	eor	r1, r1
    2dd2:	ea 51       	subi	r30, 0x1A	; 26
    2dd4:	fa 4f       	sbci	r31, 0xFA	; 250
    2dd6:	20 81       	ld	r18, Z
    2dd8:	24 30       	cpi	r18, 0x04	; 4
    2dda:	21 f0       	breq	.+8      	; 0x2de4 <DoSampler+0x892>
    2ddc:	20 81       	ld	r18, Z
    2dde:	22 30       	cpi	r18, 0x02	; 2
    2de0:	09 f0       	breq	.+2      	; 0x2de4 <DoSampler+0x892>
    2de2:	69 c2       	rjmp	.+1234   	; 0x32b6 <DoSampler+0xd64>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    2de4:	fc 01       	movw	r30, r24
    2de6:	ec 5f       	subi	r30, 0xFC	; 252
    2de8:	fe 4f       	sbci	r31, 0xFE	; 254
    2dea:	30 91 67 05 	lds	r19, 0x0567
    2dee:	20 81       	ld	r18, Z
    2df0:	32 13       	cpse	r19, r18
    2df2:	61 c2       	rjmp	.+1218   	; 0x32b6 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    2df4:	23 e2       	ldi	r18, 0x23	; 35
    2df6:	28 9f       	mul	r18, r24
    2df8:	f0 01       	movw	r30, r0
    2dfa:	29 9f       	mul	r18, r25
    2dfc:	f0 0d       	add	r31, r0
    2dfe:	11 24       	eor	r1, r1
    2e00:	ea 51       	subi	r30, 0x1A	; 26
    2e02:	fa 4f       	sbci	r31, 0xFA	; 250
    2e04:	7f c0       	rjmp	.+254    	; 0x2f04 <DoSampler+0x9b2>
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    2e06:	81 30       	cpi	r24, 0x01	; 1
    2e08:	09 f0       	breq	.+2      	; 0x2e0c <DoSampler+0x8ba>
    2e0a:	50 c0       	rjmp	.+160    	; 0x2eac <DoSampler+0x95a>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    2e0c:	a0 91 65 05 	lds	r26, 0x0565
    2e10:	2a 2f       	mov	r18, r26
    2e12:	30 e0       	ldi	r19, 0x00	; 0
    2e14:	80 91 67 05 	lds	r24, 0x0567
    2e18:	f9 01       	movw	r30, r18
    2e1a:	ec 5f       	subi	r30, 0xFC	; 252
    2e1c:	fe 4f       	sbci	r31, 0xFE	; 254
    2e1e:	80 83       	st	Z, r24

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
    2e20:	f9 01       	movw	r30, r18
    2e22:	e2 5a       	subi	r30, 0xA2	; 162
    2e24:	fa 4f       	sbci	r31, 0xFA	; 250
    2e26:	90 81       	ld	r25, Z
    2e28:	99 23       	and	r25, r25
    2e2a:	a9 f0       	breq	.+42     	; 0x2e56 <DoSampler+0x904>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2e2c:	6c e0       	ldi	r22, 0x0C	; 12
    2e2e:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2e32:	e9 2f       	mov	r30, r25
    2e34:	f0 e0       	ldi	r31, 0x00	; 0
    2e36:	ee 0f       	add	r30, r30
    2e38:	ff 1f       	adc	r31, r31
    2e3a:	ea 5f       	subi	r30, 0xFA	; 250
    2e3c:	fe 4f       	sbci	r31, 0xFE	; 254
    2e3e:	40 81       	ld	r20, Z
    2e40:	51 81       	ldd	r21, Z+1	; 0x01
    2e42:	02 c0       	rjmp	.+4      	; 0x2e48 <DoSampler+0x8f6>
    2e44:	56 95       	lsr	r21
    2e46:	47 95       	ror	r20
    2e48:	8a 95       	dec	r24
    2e4a:	e2 f7       	brpl	.-8      	; 0x2e44 <DoSampler+0x8f2>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.
    2e4c:	62 e0       	ldi	r22, 0x02	; 2
    2e4e:	8a 2f       	mov	r24, r26
    2e50:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <StartRealtime>
    2e54:	30 c2       	rjmp	.+1120   	; 0x32b6 <DoSampler+0xd64>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    2e56:	93 e2       	ldi	r25, 0x23	; 35
    2e58:	92 9f       	mul	r25, r18
    2e5a:	f0 01       	movw	r30, r0
    2e5c:	93 9f       	mul	r25, r19
    2e5e:	f0 0d       	add	r31, r0
    2e60:	11 24       	eor	r1, r1
    2e62:	ea 51       	subi	r30, 0x1A	; 26
    2e64:	fa 4f       	sbci	r31, 0xFA	; 250
    2e66:	00 89       	ldd	r16, Z+16	; 0x10
    2e68:	11 89       	ldd	r17, Z+17	; 0x11
    2e6a:	22 89       	ldd	r18, Z+18	; 0x12
    2e6c:	33 89       	ldd	r19, Z+19	; 0x13
    2e6e:	44 85       	ldd	r20, Z+12	; 0x0c
    2e70:	55 85       	ldd	r21, Z+13	; 0x0d
    2e72:	66 85       	ldd	r22, Z+14	; 0x0e
    2e74:	77 85       	ldd	r23, Z+15	; 0x0f
    2e76:	04 17       	cp	r16, r20
    2e78:	15 07       	cpc	r17, r21
    2e7a:	26 07       	cpc	r18, r22
    2e7c:	37 07       	cpc	r19, r23
    2e7e:	09 f4       	brne	.+2      	; 0x2e82 <DoSampler+0x930>
    2e80:	1a c2       	rjmp	.+1076   	; 0x32b6 <DoSampler+0xd64>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2e82:	6c e0       	ldi	r22, 0x0C	; 12
    2e84:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2e88:	e9 2f       	mov	r30, r25
    2e8a:	f0 e0       	ldi	r31, 0x00	; 0
    2e8c:	ee 0f       	add	r30, r30
    2e8e:	ff 1f       	adc	r31, r31
    2e90:	ea 5f       	subi	r30, 0xFA	; 250
    2e92:	fe 4f       	sbci	r31, 0xFE	; 254
    2e94:	40 81       	ld	r20, Z
    2e96:	51 81       	ldd	r21, Z+1	; 0x01
    2e98:	02 c0       	rjmp	.+4      	; 0x2e9e <DoSampler+0x94c>
    2e9a:	56 95       	lsr	r21
    2e9c:	47 95       	ror	r20
    2e9e:	8a 95       	dec	r24
    2ea0:	e2 f7       	brpl	.-8      	; 0x2e9a <DoSampler+0x948>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    2ea2:	62 e0       	ldi	r22, 0x02	; 2
    2ea4:	8a 2f       	mov	r24, r26
    2ea6:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <StartPlayback>
    2eaa:	05 c2       	rjmp	.+1034   	; 0x32b6 <DoSampler+0xd64>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    2eac:	84 30       	cpi	r24, 0x04	; 4
    2eae:	09 f0       	breq	.+2      	; 0x2eb2 <DoSampler+0x960>
    2eb0:	a9 c1       	rjmp	.+850    	; 0x3204 <DoSampler+0xcb2>
			{
				switch(currentMidiMessage.dataByteOne)
    2eb2:	80 91 67 05 	lds	r24, 0x0567
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	fc 01       	movw	r30, r24
    2eba:	33 97       	sbiw	r30, 0x03	; 3
    2ebc:	ec 31       	cpi	r30, 0x1C	; 28
    2ebe:	f1 05       	cpc	r31, r1
    2ec0:	08 f0       	brcs	.+2      	; 0x2ec4 <DoSampler+0x972>
    2ec2:	f9 c1       	rjmp	.+1010   	; 0x32b6 <DoSampler+0xd64>
    2ec4:	e2 5c       	subi	r30, 0xC2	; 194
    2ec6:	ff 4f       	sbci	r31, 0xFF	; 255
    2ec8:	0c 94 b9 28 	jmp	0x5172	; 0x5172 <__tablejump2__>
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2ecc:	90 91 68 05 	lds	r25, 0x0568
    2ed0:	80 91 65 05 	lds	r24, 0x0565
    2ed4:	99 23       	and	r25, r25
    2ed6:	61 f0       	breq	.+24     	; 0x2ef0 <DoSampler+0x99e>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    2ed8:	a8 2f       	mov	r26, r24
    2eda:	b0 e0       	ldi	r27, 0x00	; 0
    2edc:	aa 0f       	add	r26, r26
    2ede:	bb 1f       	adc	r27, r27
    2ee0:	a0 5a       	subi	r26, 0xA0	; 160
    2ee2:	ba 4f       	sbci	r27, 0xFA	; 250
    2ee4:	4d 91       	ld	r20, X+
    2ee6:	5c 91       	ld	r21, X
    2ee8:	62 e0       	ldi	r22, 0x02	; 2
    2eea:	0e 94 57 10 	call	0x20ae	; 0x20ae <StartRecording>
    2eee:	31 c0       	rjmp	.+98     	; 0x2f52 <DoSampler+0xa00>
						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback after a recording.
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    2ef0:	b3 e2       	ldi	r27, 0x23	; 35
    2ef2:	8b 9f       	mul	r24, r27
    2ef4:	f0 01       	movw	r30, r0
    2ef6:	11 24       	eor	r1, r1
    2ef8:	ea 51       	subi	r30, 0x1A	; 26
    2efa:	fa 4f       	sbci	r31, 0xFA	; 250
    2efc:	80 81       	ld	r24, Z
    2efe:	83 30       	cpi	r24, 0x03	; 3
    2f00:	09 f0       	breq	.+2      	; 0x2f04 <DoSampler+0x9b2>
    2f02:	d9 c1       	rjmp	.+946    	; 0x32b6 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2f04:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2f06:	11 86       	std	Z+9, r1	; 0x09
    2f08:	d6 c1       	rjmp	.+940    	; 0x32b6 <DoSampler+0xd64>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2f0a:	90 91 68 05 	lds	r25, 0x0568
    2f0e:	80 91 65 05 	lds	r24, 0x0565
    2f12:	99 23       	and	r25, r25
    2f14:	11 f1       	breq	.+68     	; 0x2f5a <DoSampler+0xa08>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2f16:	a8 2f       	mov	r26, r24
    2f18:	b0 e0       	ldi	r27, 0x00	; 0
    2f1a:	23 e2       	ldi	r18, 0x23	; 35
    2f1c:	82 9f       	mul	r24, r18
    2f1e:	f0 01       	movw	r30, r0
    2f20:	11 24       	eor	r1, r1
    2f22:	ea 51       	subi	r30, 0x1A	; 26
    2f24:	fa 4f       	sbci	r31, 0xFA	; 250
    2f26:	00 89       	ldd	r16, Z+16	; 0x10
    2f28:	11 89       	ldd	r17, Z+17	; 0x11
    2f2a:	22 89       	ldd	r18, Z+18	; 0x12
    2f2c:	33 89       	ldd	r19, Z+19	; 0x13
    2f2e:	44 85       	ldd	r20, Z+12	; 0x0c
    2f30:	55 85       	ldd	r21, Z+13	; 0x0d
    2f32:	66 85       	ldd	r22, Z+14	; 0x0e
    2f34:	77 85       	ldd	r23, Z+15	; 0x0f
    2f36:	04 17       	cp	r16, r20
    2f38:	15 07       	cpc	r17, r21
    2f3a:	26 07       	cpc	r18, r22
    2f3c:	37 07       	cpc	r19, r23
    2f3e:	09 f4       	brne	.+2      	; 0x2f42 <DoSampler+0x9f0>
    2f40:	ba c1       	rjmp	.+884    	; 0x32b6 <DoSampler+0xd64>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    2f42:	fd 01       	movw	r30, r26
    2f44:	ec 5f       	subi	r30, 0xFC	; 252
    2f46:	fe 4f       	sbci	r31, 0xFE	; 254
    2f48:	40 81       	ld	r20, Z
    2f4a:	50 e0       	ldi	r21, 0x00	; 0
    2f4c:	62 e0       	ldi	r22, 0x02	; 2
    2f4e:	0e 94 b5 10 	call	0x216a	; 0x216a <StartOverdub>
							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to playback after a recording.
    2f52:	e0 91 65 05 	lds	r30, 0x0565
    2f56:	f0 e0       	ldi	r31, 0x00	; 0
    2f58:	3d c0       	rjmp	.+122    	; 0x2fd4 <DoSampler+0xa82>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    2f5a:	28 2f       	mov	r18, r24
    2f5c:	30 e0       	ldi	r19, 0x00	; 0
    2f5e:	43 e2       	ldi	r20, 0x23	; 35
    2f60:	84 9f       	mul	r24, r20
    2f62:	f0 01       	movw	r30, r0
    2f64:	11 24       	eor	r1, r1
    2f66:	ea 51       	subi	r30, 0x1A	; 26
    2f68:	fa 4f       	sbci	r31, 0xFA	; 250
    2f6a:	90 81       	ld	r25, Z
    2f6c:	95 30       	cpi	r25, 0x05	; 5
    2f6e:	09 f0       	breq	.+2      	; 0x2f72 <DoSampler+0xa20>
    2f70:	a2 c1       	rjmp	.+836    	; 0x32b6 <DoSampler+0xd64>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    2f72:	f9 01       	movw	r30, r18
    2f74:	ec 5f       	subi	r30, 0xFC	; 252
    2f76:	fe 4f       	sbci	r31, 0xFE	; 254
    2f78:	40 81       	ld	r20, Z
    2f7a:	50 e0       	ldi	r21, 0x00	; 0
    2f7c:	62 e0       	ldi	r22, 0x02	; 2
    2f7e:	0e 94 2f 10 	call	0x205e	; 0x205e <ContinuePlayback>
    2f82:	99 c1       	rjmp	.+818    	; 0x32b6 <DoSampler+0xd64>
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    2f84:	90 91 68 05 	lds	r25, 0x0568
    2f88:	80 91 65 05 	lds	r24, 0x0565
    2f8c:	99 23       	and	r25, r25
    2f8e:	99 f0       	breq	.+38     	; 0x2fb6 <DoSampler+0xa64>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    2f90:	a8 2f       	mov	r26, r24
    2f92:	b0 e0       	ldi	r27, 0x00	; 0
    2f94:	aa 0f       	add	r26, r26
    2f96:	bb 1f       	adc	r27, r27
    2f98:	a0 5a       	subi	r26, 0xA0	; 160
    2f9a:	ba 4f       	sbci	r27, 0xFA	; 250
    2f9c:	4d 91       	ld	r20, X+
    2f9e:	5c 91       	ld	r21, X
    2fa0:	62 e0       	ldi	r22, 0x02	; 2
    2fa2:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <StartRealtime>
						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop realtime processing if we get a note off.
    2fa6:	e0 91 65 05 	lds	r30, 0x0565
    2faa:	f0 e0       	ldi	r31, 0x00	; 0
    2fac:	e2 5a       	subi	r30, 0xA2	; 162
    2fae:	fa 4f       	sbci	r31, 0xFA	; 250
    2fb0:	81 e0       	ldi	r24, 0x01	; 1
    2fb2:	80 83       	st	Z, r24
    2fb4:	80 c1       	rjmp	.+768    	; 0x32b6 <DoSampler+0xd64>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    2fb6:	28 2f       	mov	r18, r24
    2fb8:	30 e0       	ldi	r19, 0x00	; 0
    2fba:	93 e2       	ldi	r25, 0x23	; 35
    2fbc:	89 9f       	mul	r24, r25
    2fbe:	f0 01       	movw	r30, r0
    2fc0:	11 24       	eor	r1, r1
    2fc2:	ea 51       	subi	r30, 0x1A	; 26
    2fc4:	fa 4f       	sbci	r31, 0xFA	; 250
    2fc6:	80 81       	ld	r24, Z
    2fc8:	82 30       	cpi	r24, 0x02	; 2
    2fca:	09 f0       	breq	.+2      	; 0x2fce <DoSampler+0xa7c>
    2fcc:	74 c1       	rjmp	.+744    	; 0x32b6 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    2fce:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    2fd0:	11 86       	std	Z+9, r1	; 0x09
						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
    2fd2:	f9 01       	movw	r30, r18
    2fd4:	e2 5a       	subi	r30, 0xA2	; 162
    2fd6:	fa 4f       	sbci	r31, 0xFA	; 250
    2fd8:	10 82       	st	Z, r1
    2fda:	6d c1       	rjmp	.+730    	; 0x32b6 <DoSampler+0xd64>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    2fdc:	80 91 68 05 	lds	r24, 0x0568
    2fe0:	e0 91 65 05 	lds	r30, 0x0565
    2fe4:	88 23       	and	r24, r24
    2fe6:	41 f0       	breq	.+16     	; 0x2ff8 <DoSampler+0xaa6>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    2fe8:	a3 e2       	ldi	r26, 0x23	; 35
    2fea:	ea 9f       	mul	r30, r26
    2fec:	f0 01       	movw	r30, r0
    2fee:	11 24       	eor	r1, r1
    2ff0:	ea 51       	subi	r30, 0x1A	; 26
    2ff2:	fa 4f       	sbci	r31, 0xFA	; 250
    2ff4:	11 82       	std	Z+1, r1	; 0x01
    2ff6:	5f c1       	rjmp	.+702    	; 0x32b6 <DoSampler+0xd64>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    2ff8:	b3 e2       	ldi	r27, 0x23	; 35
    2ffa:	eb 9f       	mul	r30, r27
    2ffc:	f0 01       	movw	r30, r0
    2ffe:	11 24       	eor	r1, r1
    3000:	ea 51       	subi	r30, 0x1A	; 26
    3002:	fa 4f       	sbci	r31, 0xFA	; 250
    3004:	81 e0       	ldi	r24, 0x01	; 1
    3006:	81 83       	std	Z+1, r24	; 0x01
    3008:	56 c1       	rjmp	.+684    	; 0x32b6 <DoSampler+0xd64>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    300a:	80 91 68 05 	lds	r24, 0x0568
    300e:	e0 91 65 05 	lds	r30, 0x0565
    3012:	88 23       	and	r24, r24
    3014:	49 f0       	breq	.+18     	; 0x3028 <DoSampler+0xad6>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    3016:	23 e2       	ldi	r18, 0x23	; 35
    3018:	e2 9f       	mul	r30, r18
    301a:	f0 01       	movw	r30, r0
    301c:	11 24       	eor	r1, r1
    301e:	ea 51       	subi	r30, 0x1A	; 26
    3020:	fa 4f       	sbci	r31, 0xFA	; 250
    3022:	81 e0       	ldi	r24, 0x01	; 1
    3024:	82 83       	std	Z+2, r24	; 0x02
    3026:	47 c1       	rjmp	.+654    	; 0x32b6 <DoSampler+0xd64>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3028:	43 e2       	ldi	r20, 0x23	; 35
    302a:	e4 9f       	mul	r30, r20
    302c:	f0 01       	movw	r30, r0
    302e:	11 24       	eor	r1, r1
    3030:	ea 51       	subi	r30, 0x1A	; 26
    3032:	fa 4f       	sbci	r31, 0xFA	; 250
    3034:	12 82       	std	Z+2, r1	; 0x02
    3036:	3f c1       	rjmp	.+638    	; 0x32b6 <DoSampler+0xd64>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    3038:	80 91 68 05 	lds	r24, 0x0568
    303c:	e0 91 65 05 	lds	r30, 0x0565
    3040:	88 23       	and	r24, r24
    3042:	49 f0       	breq	.+18     	; 0x3056 <DoSampler+0xb04>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    3044:	83 e2       	ldi	r24, 0x23	; 35
    3046:	e8 9f       	mul	r30, r24
    3048:	f0 01       	movw	r30, r0
    304a:	11 24       	eor	r1, r1
    304c:	ea 51       	subi	r30, 0x1A	; 26
    304e:	fa 4f       	sbci	r31, 0xFA	; 250
    3050:	81 e0       	ldi	r24, 0x01	; 1
    3052:	83 83       	std	Z+3, r24	; 0x03
    3054:	07 c0       	rjmp	.+14     	; 0x3064 <DoSampler+0xb12>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    3056:	93 e2       	ldi	r25, 0x23	; 35
    3058:	e9 9f       	mul	r30, r25
    305a:	f0 01       	movw	r30, r0
    305c:	11 24       	eor	r1, r1
    305e:	ea 51       	subi	r30, 0x1A	; 26
    3060:	fa 4f       	sbci	r31, 0xFA	; 250
    3062:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    3064:	80 91 65 05 	lds	r24, 0x0565
    3068:	ca c0       	rjmp	.+404    	; 0x31fe <DoSampler+0xcac>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    306a:	e0 91 65 05 	lds	r30, 0x0565
    306e:	ae 2f       	mov	r26, r30
    3070:	b0 e0       	ldi	r27, 0x00	; 0
    3072:	23 e2       	ldi	r18, 0x23	; 35
    3074:	e2 9f       	mul	r30, r18
    3076:	f0 01       	movw	r30, r0
    3078:	11 24       	eor	r1, r1
    307a:	ea 51       	subi	r30, 0x1A	; 26
    307c:	fa 4f       	sbci	r31, 0xFA	; 250
    307e:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    3080:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    3082:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3084:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3086:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    3088:	81 e0       	ldi	r24, 0x01	; 1
    308a:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    308c:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    308e:	84 83       	std	Z+4, r24	; 0x04
					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.
    3090:	a2 5a       	subi	r26, 0xA2	; 162
    3092:	ba 4f       	sbci	r27, 0xFA	; 250
    3094:	1c 92       	st	X, r1
    3096:	2d c0       	rjmp	.+90     	; 0x30f2 <DoSampler+0xba0>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    3098:	80 91 68 05 	lds	r24, 0x0568
    309c:	88 30       	cpi	r24, 0x08	; 8
    309e:	08 f0       	brcs	.+2      	; 0x30a2 <DoSampler+0xb50>
    30a0:	0a c1       	rjmp	.+532    	; 0x32b6 <DoSampler+0xd64>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
    30a2:	e0 91 65 05 	lds	r30, 0x0565
    30a6:	43 e2       	ldi	r20, 0x23	; 35
    30a8:	e4 9f       	mul	r30, r20
    30aa:	f0 01       	movw	r30, r0
    30ac:	11 24       	eor	r1, r1
    30ae:	ea 51       	subi	r30, 0x1A	; 26
    30b0:	fa 4f       	sbci	r31, 0xFA	; 250
    30b2:	80 87       	std	Z+8, r24	; 0x08
    30b4:	00 c1       	rjmp	.+512    	; 0x32b6 <DoSampler+0xd64>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    30b6:	60 91 68 05 	lds	r22, 0x0568
    30ba:	80 91 65 05 	lds	r24, 0x0565
    30be:	0e 94 2d 09 	call	0x125a	; 0x125a <MakeNewGranularArray>
					break;
    30c2:	f9 c0       	rjmp	.+498    	; 0x32b6 <DoSampler+0xd64>

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
    30c4:	e0 91 65 05 	lds	r30, 0x0565
    30c8:	80 91 68 05 	lds	r24, 0x0568
    30cc:	93 e2       	ldi	r25, 0x23	; 35
    30ce:	e9 9f       	mul	r30, r25
    30d0:	f0 01       	movw	r30, r0
    30d2:	11 24       	eor	r1, r1
    30d4:	ea 51       	subi	r30, 0x1A	; 26
    30d6:	fa 4f       	sbci	r31, 0xFA	; 250
    30d8:	87 83       	std	Z+7, r24	; 0x07
					break;
    30da:	ed c0       	rjmp	.+474    	; 0x32b6 <DoSampler+0xd64>

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    30dc:	80 91 68 05 	lds	r24, 0x0568
    30e0:	81 30       	cpi	r24, 0x01	; 1
    30e2:	51 f0       	breq	.+20     	; 0x30f8 <DoSampler+0xba6>
    30e4:	30 f0       	brcs	.+12     	; 0x30f2 <DoSampler+0xba0>
    30e6:	82 30       	cpi	r24, 0x02	; 2
    30e8:	71 f0       	breq	.+28     	; 0x3106 <DoSampler+0xbb4>
    30ea:	83 30       	cpi	r24, 0x03	; 3
    30ec:	09 f0       	breq	.+2      	; 0x30f0 <DoSampler+0xb9e>
    30ee:	e3 c0       	rjmp	.+454    	; 0x32b6 <DoSampler+0xd64>
    30f0:	0d c0       	rjmp	.+26     	; 0x310c <DoSampler+0xbba>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    30f2:	85 e3       	ldi	r24, 0x35	; 53
    30f4:	98 e0       	ldi	r25, 0x08	; 8
    30f6:	02 c0       	rjmp	.+4      	; 0x30fc <DoSampler+0xbaa>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    30f8:	89 ee       	ldi	r24, 0xE9	; 233
    30fa:	97 e0       	ldi	r25, 0x07	; 7
    30fc:	90 93 e3 05 	sts	0x05E3, r25
    3100:	80 93 e2 05 	sts	0x05E2, r24
						break;
    3104:	d8 c0       	rjmp	.+432    	; 0x32b6 <DoSampler+0xd64>

						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3106:	88 ea       	ldi	r24, 0xA8	; 168
    3108:	98 e0       	ldi	r25, 0x08	; 8
    310a:	f8 cf       	rjmp	.-16     	; 0x30fc <DoSampler+0xbaa>
						break;

						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    310c:	8b e6       	ldi	r24, 0x6B	; 107
    310e:	98 e0       	ldi	r25, 0x08	; 8
    3110:	f5 cf       	rjmp	.-22     	; 0x30fc <DoSampler+0xbaa>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
    3112:	1f b7       	in	r17, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    3114:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    3116:	50 91 65 05 	lds	r21, 0x0565
    311a:	a5 2f       	mov	r26, r21
    311c:	b0 e0       	ldi	r27, 0x00	; 0
    311e:	fd 01       	movw	r30, r26
    3120:	ec 5f       	subi	r30, 0xFC	; 252
    3122:	fe 4f       	sbci	r31, 0xFE	; 254
    3124:	40 81       	ld	r20, Z
    3126:	aa 0f       	add	r26, r26
    3128:	bb 1f       	adc	r27, r27
    312a:	a0 5a       	subi	r26, 0xA0	; 160
    312c:	ba 4f       	sbci	r27, 0xFA	; 250
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    312e:	84 2f       	mov	r24, r20
    3130:	6c e0       	ldi	r22, 0x0C	; 12
    3132:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3136:	e9 2f       	mov	r30, r25
    3138:	f0 e0       	ldi	r31, 0x00	; 0
    313a:	ee 0f       	add	r30, r30
    313c:	ff 1f       	adc	r31, r31
    313e:	ea 5f       	subi	r30, 0xFA	; 250
    3140:	fe 4f       	sbci	r31, 0xFE	; 254
    3142:	20 81       	ld	r18, Z
    3144:	31 81       	ldd	r19, Z+1	; 0x01
    3146:	02 c0       	rjmp	.+4      	; 0x314c <DoSampler+0xbfa>
    3148:	36 95       	lsr	r19
    314a:	27 95       	ror	r18
    314c:	8a 95       	dec	r24
    314e:	e2 f7       	brpl	.-8      	; 0x3148 <DoSampler+0xbf6>
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    3150:	2d 93       	st	X+, r18
    3152:	3c 93       	st	X, r19
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    3154:	51 11       	cpse	r21, r1
    3156:	04 c0       	rjmp	.+8      	; 0x3160 <DoSampler+0xc0e>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    3158:	64 2f       	mov	r22, r20
    315a:	87 e0       	ldi	r24, 0x07	; 7
    315c:	90 e0       	ldi	r25, 0x00	; 0
    315e:	05 c0       	rjmp	.+10     	; 0x316a <DoSampler+0xc18>
	}
	else if(theBank==BANK_1)
    3160:	51 30       	cpi	r21, 0x01	; 1
    3162:	29 f4       	brne	.+10     	; 0x316e <DoSampler+0xc1c>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    3164:	64 2f       	mov	r22, r20
    3166:	8b e0       	ldi	r24, 0x0B	; 11
    3168:	90 e0       	ldi	r25, 0x00	; 0
    316a:	0e 94 04 1e 	call	0x3c08	; 0x3c08 <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=i;		// Re-enable interrupts.
    316e:	1f bf       	out	0x3f, r17	; 63
					break;
    3170:	a2 c0       	rjmp	.+324    	; 0x32b6 <DoSampler+0xd64>

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3172:	90 91 68 05 	lds	r25, 0x0568
    3176:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    317a:	a3 e2       	ldi	r26, 0x23	; 35
    317c:	8a 9f       	mul	r24, r26
    317e:	f0 01       	movw	r30, r0
    3180:	11 24       	eor	r1, r1
    3182:	20 c0       	rjmp	.+64     	; 0x31c4 <DoSampler+0xc72>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3184:	90 91 68 05 	lds	r25, 0x0568
    3188:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    318c:	b3 e2       	ldi	r27, 0x23	; 35
    318e:	8b 9f       	mul	r24, r27
    3190:	f0 01       	movw	r30, r0
    3192:	11 24       	eor	r1, r1
    3194:	24 c0       	rjmp	.+72     	; 0x31de <DoSampler+0xc8c>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3196:	90 91 68 05 	lds	r25, 0x0568
    319a:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    319e:	23 e2       	ldi	r18, 0x23	; 35
    31a0:	82 9f       	mul	r24, r18
    31a2:	f0 01       	movw	r30, r0
    31a4:	11 24       	eor	r1, r1
    31a6:	28 c0       	rjmp	.+80     	; 0x31f8 <DoSampler+0xca6>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    31a8:	80 91 65 05 	lds	r24, 0x0565
    31ac:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <RevertSampleToUnadjusted>
					break;
    31b0:	82 c0       	rjmp	.+260    	; 0x32b6 <DoSampler+0xd64>

					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    31b2:	90 91 68 05 	lds	r25, 0x0568
    31b6:	99 0f       	add	r25, r25
    31b8:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    31bc:	43 e2       	ldi	r20, 0x23	; 35
    31be:	84 9f       	mul	r24, r20
    31c0:	f0 01       	movw	r30, r0
    31c2:	11 24       	eor	r1, r1
    31c4:	ea 51       	subi	r30, 0x1A	; 26
    31c6:	fa 4f       	sbci	r31, 0xFA	; 250
    31c8:	94 8f       	std	Z+28, r25	; 0x1c
    31ca:	19 c0       	rjmp	.+50     	; 0x31fe <DoSampler+0xcac>
					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    31cc:	90 91 68 05 	lds	r25, 0x0568
    31d0:	99 0f       	add	r25, r25
    31d2:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    31d6:	a3 e2       	ldi	r26, 0x23	; 35
    31d8:	8a 9f       	mul	r24, r26
    31da:	f0 01       	movw	r30, r0
    31dc:	11 24       	eor	r1, r1
    31de:	ea 51       	subi	r30, 0x1A	; 26
    31e0:	fa 4f       	sbci	r31, 0xFA	; 250
    31e2:	95 8f       	std	Z+29, r25	; 0x1d
    31e4:	0c c0       	rjmp	.+24     	; 0x31fe <DoSampler+0xcac>
					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    31e6:	90 91 68 05 	lds	r25, 0x0568
    31ea:	99 0f       	add	r25, r25
    31ec:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    31f0:	b3 e2       	ldi	r27, 0x23	; 35
    31f2:	8b 9f       	mul	r24, r27
    31f4:	f0 01       	movw	r30, r0
    31f6:	11 24       	eor	r1, r1
    31f8:	ea 51       	subi	r30, 0x1A	; 26
    31fa:	fa 4f       	sbci	r31, 0xFA	; 250
    31fc:	96 8f       	std	Z+30, r25	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    31fe:	0e 94 2a 0a 	call	0x1454	; 0x1454 <UpdateAdjustedSampleAddresses>
    3202:	59 c0       	rjmp	.+178    	; 0x32b6 <DoSampler+0xd64>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    3204:	87 30       	cpi	r24, 0x07	; 7
    3206:	09 f0       	breq	.+2      	; 0x320a <DoSampler+0xcb8>
    3208:	56 c0       	rjmp	.+172    	; 0x32b6 <DoSampler+0xd64>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    320a:	80 91 68 05 	lds	r24, 0x0568
    320e:	20 91 67 05 	lds	r18, 0x0567
    3212:	30 e0       	ldi	r19, 0x00	; 0
    3214:	e0 e8       	ldi	r30, 0x80	; 128
    3216:	8e 9f       	mul	r24, r30
    3218:	20 0d       	add	r18, r0
    321a:	31 1d       	adc	r19, r1
    321c:	11 24       	eor	r1, r1
    321e:	a0 91 65 05 	lds	r26, 0x0565

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    3222:	21 15       	cp	r18, r1
    3224:	f0 e2       	ldi	r31, 0x20	; 32
    3226:	3f 07       	cpc	r19, r31
    3228:	31 f1       	breq	.+76     	; 0x3276 <DoSampler+0xd24>
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    322a:	b0 e0       	ldi	r27, 0x00	; 0
    322c:	fd 01       	movw	r30, r26
    322e:	ec 5f       	subi	r30, 0xFC	; 252
    3230:	fe 4f       	sbci	r31, 0xFE	; 254
    3232:	80 81       	ld	r24, Z
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    3234:	40 e0       	ldi	r20, 0x00	; 0
    3236:	50 e2       	ldi	r21, 0x20	; 32
    3238:	42 1b       	sub	r20, r18
    323a:	53 0b       	sbc	r21, r19
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    323c:	6c e0       	ldi	r22, 0x0C	; 12
    323e:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3242:	e9 2f       	mov	r30, r25
    3244:	f0 e0       	ldi	r31, 0x00	; 0
    3246:	ee 0f       	add	r30, r30
    3248:	ff 1f       	adc	r31, r31
    324a:	ea 5f       	subi	r30, 0xFA	; 250
    324c:	fe 4f       	sbci	r31, 0xFE	; 254
    324e:	20 81       	ld	r18, Z
    3250:	31 81       	ldd	r19, Z+1	; 0x01
    3252:	02 c0       	rjmp	.+4      	; 0x3258 <DoSampler+0xd06>
    3254:	36 95       	lsr	r19
    3256:	27 95       	ror	r18
    3258:	8a 95       	dec	r24
    325a:	e2 f7       	brpl	.-8      	; 0x3254 <DoSampler+0xd02>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    325c:	42 0f       	add	r20, r18
    325e:	53 1f       	adc	r21, r19
    3260:	83 e2       	ldi	r24, 0x23	; 35
    3262:	8a 9f       	mul	r24, r26
    3264:	f0 01       	movw	r30, r0
    3266:	8b 9f       	mul	r24, r27
    3268:	f0 0d       	add	r31, r0
    326a:	11 24       	eor	r1, r1
    326c:	ea 51       	subi	r30, 0x1A	; 26
    326e:	fa 4f       	sbci	r31, 0xFA	; 250
    3270:	53 87       	std	Z+11, r21	; 0x0b
    3272:	42 87       	std	Z+10, r20	; 0x0a
    3274:	20 c0       	rjmp	.+64     	; 0x32b6 <DoSampler+0xd64>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    3276:	4a 2f       	mov	r20, r26
    3278:	50 e0       	ldi	r21, 0x00	; 0
    327a:	fa 01       	movw	r30, r20
    327c:	ec 5f       	subi	r30, 0xFC	; 252
    327e:	fe 4f       	sbci	r31, 0xFE	; 254
    3280:	80 81       	ld	r24, Z
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    3282:	6c e0       	ldi	r22, 0x0C	; 12
    3284:	0e 94 8b 28 	call	0x5116	; 0x5116 <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3288:	e9 2f       	mov	r30, r25
    328a:	f0 e0       	ldi	r31, 0x00	; 0
    328c:	ee 0f       	add	r30, r30
    328e:	ff 1f       	adc	r31, r31
    3290:	ea 5f       	subi	r30, 0xFA	; 250
    3292:	fe 4f       	sbci	r31, 0xFE	; 254
    3294:	20 81       	ld	r18, Z
    3296:	31 81       	ldd	r19, Z+1	; 0x01
    3298:	02 c0       	rjmp	.+4      	; 0x329e <DoSampler+0xd4c>
    329a:	36 95       	lsr	r19
    329c:	27 95       	ror	r18
    329e:	8a 95       	dec	r24
    32a0:	e2 f7       	brpl	.-8      	; 0x329a <DoSampler+0xd48>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    32a2:	83 e2       	ldi	r24, 0x23	; 35
    32a4:	84 9f       	mul	r24, r20
    32a6:	f0 01       	movw	r30, r0
    32a8:	85 9f       	mul	r24, r21
    32aa:	f0 0d       	add	r31, r0
    32ac:	11 24       	eor	r1, r1
    32ae:	ea 51       	subi	r30, 0x1A	; 26
    32b0:	fa 4f       	sbci	r31, 0xFA	; 250
    32b2:	33 87       	std	Z+11, r19	; 0x0b
    32b4:	22 87       	std	Z+10, r18	; 0x0a
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    32b6:	80 91 4f 05 	lds	r24, 0x054F
    32ba:	83 30       	cpi	r24, 0x03	; 3
    32bc:	11 f0       	breq	.+4      	; 0x32c2 <DoSampler+0xd70>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    32be:	10 92 55 05 	sts	0x0555, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    32c2:	80 91 ef 05 	lds	r24, 0x05EF
    32c6:	81 30       	cpi	r24, 0x01	; 1
    32c8:	41 f0       	breq	.+16     	; 0x32da <DoSampler+0xd88>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    32ca:	10 92 42 04 	sts	0x0442, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    32ce:	80 91 6f 00 	lds	r24, 0x006F
    32d2:	8f 7d       	andi	r24, 0xDF	; 223
    32d4:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
    32d8:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    32da:	80 91 12 06 	lds	r24, 0x0612
    32de:	81 30       	cpi	r24, 0x01	; 1
    32e0:	31 f0       	breq	.+12     	; 0x32ee <DoSampler+0xd9c>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    32e2:	10 92 45 05 	sts	0x0545, r1
		PCICR=0;			// No global PCINTS.
    32e6:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    32ea:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    32ee:	80 91 ef 05 	lds	r24, 0x05EF
    32f2:	82 30       	cpi	r24, 0x02	; 2
    32f4:	41 f0       	breq	.+16     	; 0x3306 <DoSampler+0xdb4>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    32f6:	10 92 48 05 	sts	0x0548, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    32fa:	80 91 6f 00 	lds	r24, 0x006F
    32fe:	8d 7f       	andi	r24, 0xFD	; 253
    3300:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
    3304:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    3306:	80 91 12 06 	lds	r24, 0x0612
    330a:	82 30       	cpi	r24, 0x02	; 2
    330c:	41 f0       	breq	.+16     	; 0x331e <DoSampler+0xdcc>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    330e:	10 92 4c 05 	sts	0x054C, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    3312:	80 91 6f 00 	lds	r24, 0x006F
    3316:	8b 7f       	andi	r24, 0xFB	; 251
    3318:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
    331c:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    331e:	80 91 ef 05 	lds	r24, 0x05EF
    3322:	81 11       	cpse	r24, r1
    3324:	0c c0       	rjmp	.+24     	; 0x333e <DoSampler+0xdec>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    3326:	80 91 4f 05 	lds	r24, 0x054F
    332a:	88 23       	and	r24, r24
    332c:	31 f0       	breq	.+12     	; 0x333a <DoSampler+0xde8>
    332e:	83 30       	cpi	r24, 0x03	; 3
    3330:	21 f0       	breq	.+8      	; 0x333a <DoSampler+0xde8>
    3332:	80 91 54 05 	lds	r24, 0x0554
    3336:	81 11       	cpse	r24, r1
    3338:	02 c0       	rjmp	.+4      	; 0x333e <DoSampler+0xdec>
		{
			bankStates[BANK_0].isLocked=false;
    333a:	10 92 eb 05 	sts	0x05EB, r1
		}
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    333e:	80 91 12 06 	lds	r24, 0x0612
    3342:	81 11       	cpse	r24, r1
    3344:	0c c0       	rjmp	.+24     	; 0x335e <DoSampler+0xe0c>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    3346:	80 91 4f 05 	lds	r24, 0x054F
    334a:	88 23       	and	r24, r24
    334c:	31 f0       	breq	.+12     	; 0x335a <DoSampler+0xe08>
    334e:	83 30       	cpi	r24, 0x03	; 3
    3350:	21 f0       	breq	.+8      	; 0x335a <DoSampler+0xe08>
    3352:	80 91 54 05 	lds	r24, 0x0554
    3356:	81 30       	cpi	r24, 0x01	; 1
    3358:	11 f4       	brne	.+4      	; 0x335e <DoSampler+0xe0c>
		{
			bankStates[BANK_1].isLocked=false;
    335a:	10 92 0e 06 	sts	0x060E, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    335e:	80 91 6b 05 	lds	r24, 0x056B
    3362:	82 95       	swap	r24
    3364:	86 95       	lsr	r24
    3366:	87 70       	andi	r24, 0x07	; 7
    3368:	80 93 6d 05 	sts	0x056D, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    336c:	20 91 5d 05 	lds	r18, 0x055D
    3370:	2f 71       	andi	r18, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    3372:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    3374:	20 68       	ori	r18, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    3376:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    3378:	20 64       	ori	r18, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    337a:	84 70       	andi	r24, 0x04	; 4
    337c:	09 f0       	breq	.+2      	; 0x3380 <DoSampler+0xe2e>
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    337e:	20 62       	ori	r18, 0x20	; 32
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    3380:	30 91 64 05 	lds	r19, 0x0564
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    3384:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    3386:	83 2f       	mov	r24, r19
    3388:	90 e0       	ldi	r25, 0x00	; 0
    338a:	a3 e2       	ldi	r26, 0x23	; 35
    338c:	3a 9f       	mul	r19, r26
    338e:	f0 01       	movw	r30, r0
    3390:	11 24       	eor	r1, r1
    3392:	ea 51       	subi	r30, 0x1A	; 26
    3394:	fa 4f       	sbci	r31, 0xFA	; 250
    3396:	40 81       	ld	r20, Z
    3398:	43 30       	cpi	r20, 0x03	; 3
    339a:	09 f4       	brne	.+2      	; 0x339e <DoSampler+0xe4c>
	{
		temp|=Om_LED_REC;
    339c:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    339e:	43 e2       	ldi	r20, 0x23	; 35
    33a0:	48 9f       	mul	r20, r24
    33a2:	f0 01       	movw	r30, r0
    33a4:	49 9f       	mul	r20, r25
    33a6:	f0 0d       	add	r31, r0
    33a8:	11 24       	eor	r1, r1
    33aa:	ea 51       	subi	r30, 0x1A	; 26
    33ac:	fa 4f       	sbci	r31, 0xFA	; 250
    33ae:	40 81       	ld	r20, Z
    33b0:	44 30       	cpi	r20, 0x04	; 4
    33b2:	09 f4       	brne	.+2      	; 0x33b6 <DoSampler+0xe64>
	{
		temp|=Om_LED_PLAY;
    33b4:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    33b6:	43 e2       	ldi	r20, 0x23	; 35
    33b8:	48 9f       	mul	r20, r24
    33ba:	f0 01       	movw	r30, r0
    33bc:	49 9f       	mul	r20, r25
    33be:	f0 0d       	add	r31, r0
    33c0:	11 24       	eor	r1, r1
    33c2:	ea 51       	subi	r30, 0x1A	; 26
    33c4:	fa 4f       	sbci	r31, 0xFA	; 250
    33c6:	40 81       	ld	r20, Z
    33c8:	45 30       	cpi	r20, 0x05	; 5
    33ca:	09 f4       	brne	.+2      	; 0x33ce <DoSampler+0xe7c>
	{
		temp|=Om_LED_ODUB;
    33cc:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    33ce:	43 e2       	ldi	r20, 0x23	; 35
    33d0:	48 9f       	mul	r20, r24
    33d2:	f0 01       	movw	r30, r0
    33d4:	49 9f       	mul	r20, r25
    33d6:	f0 0d       	add	r31, r0
    33d8:	11 24       	eor	r1, r1
    33da:	ea 51       	subi	r30, 0x1A	; 26
    33dc:	fa 4f       	sbci	r31, 0xFA	; 250
    33de:	40 81       	ld	r20, Z
    33e0:	42 30       	cpi	r20, 0x02	; 2
    33e2:	09 f4       	brne	.+2      	; 0x33e6 <DoSampler+0xe94>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    33e4:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    33e6:	40 91 3f 04 	lds	r20, 0x043F
    33ea:	41 30       	cpi	r20, 0x01	; 1
    33ec:	09 f4       	brne	.+2      	; 0x33f0 <DoSampler+0xe9e>
	{
		temp|=Om_LED_OUT_OF_MEM;
    33ee:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    33f0:	31 30       	cpi	r19, 0x01	; 1
    33f2:	09 f4       	brne	.+2      	; 0x33f6 <DoSampler+0xea4>
	{
		temp|=Om_LED_BANK;
    33f4:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    33f6:	20 93 5d 05 	sts	0x055D, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    33fa:	23 e2       	ldi	r18, 0x23	; 35
    33fc:	28 9f       	mul	r18, r24
    33fe:	f0 01       	movw	r30, r0
    3400:	29 9f       	mul	r18, r25
    3402:	f0 0d       	add	r31, r0
    3404:	11 24       	eor	r1, r1
    3406:	ea 51       	subi	r30, 0x1A	; 26
    3408:	fa 4f       	sbci	r31, 0xFA	; 250
    340a:	40 89       	ldd	r20, Z+16	; 0x10
    340c:	51 89       	ldd	r21, Z+17	; 0x11
    340e:	62 89       	ldd	r22, Z+18	; 0x12
    3410:	73 89       	ldd	r23, Z+19	; 0x13
    3412:	84 85       	ldd	r24, Z+12	; 0x0c
    3414:	95 85       	ldd	r25, Z+13	; 0x0d
    3416:	a6 85       	ldd	r26, Z+14	; 0x0e
    3418:	b7 85       	ldd	r27, Z+15	; 0x0f
    341a:	48 17       	cp	r20, r24
    341c:	59 07       	cpc	r21, r25
    341e:	6a 07       	cpc	r22, r26
    3420:	7b 07       	cpc	r23, r27
    3422:	39 f4       	brne	.+14     	; 0x3432 <DoSampler+0xee0>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    3424:	80 91 7a 05 	lds	r24, 0x057A
    3428:	82 fd       	sbrc	r24, 2
    342a:	14 c0       	rjmp	.+40     	; 0x3454 <DoSampler+0xf02>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    342c:	84 e0       	ldi	r24, 0x04	; 4
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	02 c0       	rjmp	.+4      	; 0x3436 <DoSampler+0xee4>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    3432:	80 e0       	ldi	r24, 0x00	; 0
    3434:	90 e0       	ldi	r25, 0x00	; 0

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    3436:	0f 90       	pop	r0
    3438:	df 91       	pop	r29
    343a:	cf 91       	pop	r28
    343c:	1f 91       	pop	r17
    343e:	0f 91       	pop	r16
    3440:	ff 90       	pop	r15
    3442:	ef 90       	pop	r14
    3444:	df 90       	pop	r13
    3446:	cf 90       	pop	r12
    3448:	bf 90       	pop	r11
    344a:	af 90       	pop	r10
    344c:	9f 90       	pop	r9
    344e:	8f 90       	pop	r8
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    3450:	0c 94 4b 0e 	jmp	0x1c96	; 0x1c96 <BlinkLeds>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    3454:	0f 90       	pop	r0
    3456:	df 91       	pop	r29
    3458:	cf 91       	pop	r28
    345a:	1f 91       	pop	r17
    345c:	0f 91       	pop	r16
    345e:	ff 90       	pop	r15
    3460:	ef 90       	pop	r14
    3462:	df 90       	pop	r13
    3464:	cf 90       	pop	r12
    3466:	bf 90       	pop	r11
    3468:	af 90       	pop	r10
    346a:	9f 90       	pop	r9
    346c:	8f 90       	pop	r8
    346e:	08 95       	ret

00003470 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    3470:	1f 92       	push	r1
    3472:	0f 92       	push	r0
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	0f 92       	push	r0
    3478:	11 24       	eor	r1, r1
    347a:	2f 93       	push	r18
    347c:	3f 93       	push	r19
    347e:	4f 93       	push	r20
    3480:	5f 93       	push	r21
    3482:	6f 93       	push	r22
    3484:	7f 93       	push	r23
    3486:	8f 93       	push	r24
    3488:	9f 93       	push	r25
    348a:	af 93       	push	r26
    348c:	bf 93       	push	r27
    348e:	ef 93       	push	r30
    3490:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3492:	80 91 e8 05 	lds	r24, 0x05E8
    3496:	88 23       	and	r24, r24
    3498:	41 f0       	breq	.+16     	; 0x34aa <__vector_12+0x3a>
    349a:	80 91 e8 05 	lds	r24, 0x05E8
    349e:	88 23       	and	r24, r24
    34a0:	41 f0       	breq	.+16     	; 0x34b2 <__vector_12+0x42>
    34a2:	80 91 41 04 	lds	r24, 0x0441
    34a6:	88 23       	and	r24, r24
    34a8:	21 f0       	breq	.+8      	; 0x34b2 <__vector_12+0x42>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    34aa:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    34ae:	80 93 42 04 	sts	0x0442, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    34b2:	10 92 41 04 	sts	0x0441, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    34b6:	e0 91 e2 05 	lds	r30, 0x05E2
    34ba:	f0 91 e3 05 	lds	r31, 0x05E3
    34be:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    34c0:	80 91 7a 00 	lds	r24, 0x007A
    34c4:	86 fd       	sbrc	r24, 6
    34c6:	0a c0       	rjmp	.+20     	; 0x34dc <__vector_12+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    34c8:	80 91 79 00 	lds	r24, 0x0079
    34cc:	80 58       	subi	r24, 0x80	; 128
    34ce:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    34d2:	80 91 7a 00 	lds	r24, 0x007A
    34d6:	80 64       	ori	r24, 0x40	; 64
    34d8:	80 93 7a 00 	sts	0x007A, r24
	}
}
    34dc:	ff 91       	pop	r31
    34de:	ef 91       	pop	r30
    34e0:	bf 91       	pop	r27
    34e2:	af 91       	pop	r26
    34e4:	9f 91       	pop	r25
    34e6:	8f 91       	pop	r24
    34e8:	7f 91       	pop	r23
    34ea:	6f 91       	pop	r22
    34ec:	5f 91       	pop	r21
    34ee:	4f 91       	pop	r20
    34f0:	3f 91       	pop	r19
    34f2:	2f 91       	pop	r18
    34f4:	0f 90       	pop	r0
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	0f 90       	pop	r0
    34fa:	1f 90       	pop	r1
    34fc:	18 95       	reti

000034fe <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    34fe:	1f 92       	push	r1
    3500:	0f 92       	push	r0
    3502:	0f b6       	in	r0, 0x3f	; 63
    3504:	0f 92       	push	r0
    3506:	11 24       	eor	r1, r1
    3508:	2f 93       	push	r18
    350a:	3f 93       	push	r19
    350c:	4f 93       	push	r20
    350e:	5f 93       	push	r21
    3510:	6f 93       	push	r22
    3512:	7f 93       	push	r23
    3514:	8f 93       	push	r24
    3516:	9f 93       	push	r25
    3518:	af 93       	push	r26
    351a:	bf 93       	push	r27
    351c:	ef 93       	push	r30
    351e:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3520:	80 91 0b 06 	lds	r24, 0x060B
    3524:	88 23       	and	r24, r24
    3526:	41 f0       	breq	.+16     	; 0x3538 <__vector_6+0x3a>
    3528:	80 91 0b 06 	lds	r24, 0x060B
    352c:	88 23       	and	r24, r24
    352e:	41 f0       	breq	.+16     	; 0x3540 <__vector_6+0x42>
    3530:	80 91 44 05 	lds	r24, 0x0544
    3534:	88 23       	and	r24, r24
    3536:	21 f0       	breq	.+8      	; 0x3540 <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    3538:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    353c:	80 93 45 05 	sts	0x0545, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3540:	10 92 44 05 	sts	0x0544, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3544:	e0 91 e2 05 	lds	r30, 0x05E2
    3548:	f0 91 e3 05 	lds	r31, 0x05E3
    354c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    354e:	80 91 7a 00 	lds	r24, 0x007A
    3552:	86 fd       	sbrc	r24, 6
    3554:	0a c0       	rjmp	.+20     	; 0x356a <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3556:	80 91 79 00 	lds	r24, 0x0079
    355a:	80 58       	subi	r24, 0x80	; 128
    355c:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3560:	80 91 7a 00 	lds	r24, 0x007A
    3564:	80 64       	ori	r24, 0x40	; 64
    3566:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    356a:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    356c:	ff 91       	pop	r31
    356e:	ef 91       	pop	r30
    3570:	bf 91       	pop	r27
    3572:	af 91       	pop	r26
    3574:	9f 91       	pop	r25
    3576:	8f 91       	pop	r24
    3578:	7f 91       	pop	r23
    357a:	6f 91       	pop	r22
    357c:	5f 91       	pop	r21
    357e:	4f 91       	pop	r20
    3580:	3f 91       	pop	r19
    3582:	2f 91       	pop	r18
    3584:	0f 90       	pop	r0
    3586:	0f be       	out	0x3f, r0	; 63
    3588:	0f 90       	pop	r0
    358a:	1f 90       	pop	r1
    358c:	18 95       	reti

0000358e <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    358e:	1f 92       	push	r1
    3590:	0f 92       	push	r0
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	0f 92       	push	r0
    3596:	11 24       	eor	r1, r1
    3598:	0f 93       	push	r16
    359a:	1f 93       	push	r17
    359c:	2f 93       	push	r18
    359e:	3f 93       	push	r19
    35a0:	4f 93       	push	r20
    35a2:	5f 93       	push	r21
    35a4:	6f 93       	push	r22
    35a6:	7f 93       	push	r23
    35a8:	8f 93       	push	r24
    35aa:	9f 93       	push	r25
    35ac:	af 93       	push	r26
    35ae:	bf 93       	push	r27
    35b0:	cf 93       	push	r28
    35b2:	df 93       	push	r29
    35b4:	ef 93       	push	r30
    35b6:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    35b8:	80 91 e8 05 	lds	r24, 0x05E8
    35bc:	88 23       	and	r24, r24
    35be:	41 f0       	breq	.+16     	; 0x35d0 <__vector_13+0x42>
    35c0:	80 91 e8 05 	lds	r24, 0x05E8
    35c4:	88 23       	and	r24, r24
    35c6:	41 f0       	breq	.+16     	; 0x35d8 <__vector_13+0x4a>
    35c8:	80 91 47 05 	lds	r24, 0x0547
    35cc:	88 23       	and	r24, r24
    35ce:	21 f0       	breq	.+8      	; 0x35d8 <__vector_13+0x4a>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    35d0:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    35d4:	80 93 48 05 	sts	0x0548, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    35d8:	80 91 ed 05 	lds	r24, 0x05ED
    35dc:	88 23       	and	r24, r24
    35de:	a1 f1       	breq	.+104    	; 0x3648 <__vector_13+0xba>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    35e0:	a0 91 ed 05 	lds	r26, 0x05ED
    35e4:	20 91 f0 05 	lds	r18, 0x05F0
    35e8:	30 91 f1 05 	lds	r19, 0x05F1
    35ec:	b0 e0       	ldi	r27, 0x00	; 0
    35ee:	0e 94 bf 28 	call	0x517e	; 0x517e <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    35f2:	2f e7       	ldi	r18, 0x7F	; 127
    35f4:	30 e0       	ldi	r19, 0x00	; 0
    35f6:	40 e0       	ldi	r20, 0x00	; 0
    35f8:	50 e0       	ldi	r21, 0x00	; 0
    35fa:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    35fe:	00 91 88 00 	lds	r16, 0x0088
    3602:	10 91 89 00 	lds	r17, 0x0089
    3606:	c0 91 f0 05 	lds	r28, 0x05F0
    360a:	d0 91 f1 05 	lds	r29, 0x05F1
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    360e:	60 91 00 01 	lds	r22, 0x0100
    3612:	70 91 01 01 	lds	r23, 0x0101
    3616:	80 91 02 01 	lds	r24, 0x0102
    361a:	90 91 03 01 	lds	r25, 0x0103
    361e:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    3622:	c0 0f       	add	r28, r16
    3624:	d1 1f       	adc	r29, r17
    3626:	40 91 49 05 	lds	r20, 0x0549
    362a:	50 91 4a 05 	lds	r21, 0x054A
    362e:	c4 0f       	add	r28, r20
    3630:	d5 1f       	adc	r29, r21
    3632:	c6 1b       	sub	r28, r22
    3634:	d7 0b       	sbc	r29, r23
    3636:	d0 93 89 00 	sts	0x0089, r29
    363a:	c0 93 88 00 	sts	0x0088, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    363e:	70 93 4a 05 	sts	0x054A, r23
    3642:	60 93 49 05 	sts	0x0549, r22
    3646:	0e c0       	rjmp	.+28     	; 0x3664 <__vector_13+0xd6>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    3648:	20 91 88 00 	lds	r18, 0x0088
    364c:	30 91 89 00 	lds	r19, 0x0089
    3650:	80 91 f0 05 	lds	r24, 0x05F0
    3654:	90 91 f1 05 	lds	r25, 0x05F1
    3658:	82 0f       	add	r24, r18
    365a:	93 1f       	adc	r25, r19
    365c:	90 93 89 00 	sts	0x0089, r25
    3660:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3664:	10 92 47 05 	sts	0x0547, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3668:	e0 91 e2 05 	lds	r30, 0x05E2
    366c:	f0 91 e3 05 	lds	r31, 0x05E3
    3670:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3672:	80 91 7a 00 	lds	r24, 0x007A
    3676:	86 fd       	sbrc	r24, 6
    3678:	0a c0       	rjmp	.+20     	; 0x368e <__vector_13+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    367a:	80 91 79 00 	lds	r24, 0x0079
    367e:	80 58       	subi	r24, 0x80	; 128
    3680:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3684:	80 91 7a 00 	lds	r24, 0x007A
    3688:	80 64       	ori	r24, 0x40	; 64
    368a:	80 93 7a 00 	sts	0x007A, r24
	}
}
    368e:	ff 91       	pop	r31
    3690:	ef 91       	pop	r30
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	bf 91       	pop	r27
    3698:	af 91       	pop	r26
    369a:	9f 91       	pop	r25
    369c:	8f 91       	pop	r24
    369e:	7f 91       	pop	r23
    36a0:	6f 91       	pop	r22
    36a2:	5f 91       	pop	r21
    36a4:	4f 91       	pop	r20
    36a6:	3f 91       	pop	r19
    36a8:	2f 91       	pop	r18
    36aa:	1f 91       	pop	r17
    36ac:	0f 91       	pop	r16
    36ae:	0f 90       	pop	r0
    36b0:	0f be       	out	0x3f, r0	; 63
    36b2:	0f 90       	pop	r0
    36b4:	1f 90       	pop	r1
    36b6:	18 95       	reti

000036b8 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    36b8:	1f 92       	push	r1
    36ba:	0f 92       	push	r0
    36bc:	0f b6       	in	r0, 0x3f	; 63
    36be:	0f 92       	push	r0
    36c0:	11 24       	eor	r1, r1
    36c2:	0f 93       	push	r16
    36c4:	1f 93       	push	r17
    36c6:	2f 93       	push	r18
    36c8:	3f 93       	push	r19
    36ca:	4f 93       	push	r20
    36cc:	5f 93       	push	r21
    36ce:	6f 93       	push	r22
    36d0:	7f 93       	push	r23
    36d2:	8f 93       	push	r24
    36d4:	9f 93       	push	r25
    36d6:	af 93       	push	r26
    36d8:	bf 93       	push	r27
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	ef 93       	push	r30
    36e0:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    36e2:	80 91 0b 06 	lds	r24, 0x060B
    36e6:	88 23       	and	r24, r24
    36e8:	41 f0       	breq	.+16     	; 0x36fa <__vector_14+0x42>
    36ea:	80 91 0b 06 	lds	r24, 0x060B
    36ee:	88 23       	and	r24, r24
    36f0:	41 f0       	breq	.+16     	; 0x3702 <__vector_14+0x4a>
    36f2:	80 91 4b 05 	lds	r24, 0x054B
    36f6:	88 23       	and	r24, r24
    36f8:	21 f0       	breq	.+8      	; 0x3702 <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    36fa:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    36fe:	80 93 4c 05 	sts	0x054C, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    3702:	80 91 10 06 	lds	r24, 0x0610
    3706:	88 23       	and	r24, r24
    3708:	a1 f1       	breq	.+104    	; 0x3772 <__vector_14+0xba>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    370a:	a0 91 10 06 	lds	r26, 0x0610
    370e:	20 91 13 06 	lds	r18, 0x0613
    3712:	30 91 14 06 	lds	r19, 0x0614
    3716:	b0 e0       	ldi	r27, 0x00	; 0
    3718:	0e 94 bf 28 	call	0x517e	; 0x517e <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    371c:	2f e7       	ldi	r18, 0x7F	; 127
    371e:	30 e0       	ldi	r19, 0x00	; 0
    3720:	40 e0       	ldi	r20, 0x00	; 0
    3722:	50 e0       	ldi	r21, 0x00	; 0
    3724:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    3728:	00 91 8a 00 	lds	r16, 0x008A
    372c:	10 91 8b 00 	lds	r17, 0x008B
    3730:	c0 91 13 06 	lds	r28, 0x0613
    3734:	d0 91 14 06 	lds	r29, 0x0614
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    3738:	60 91 00 01 	lds	r22, 0x0100
    373c:	70 91 01 01 	lds	r23, 0x0101
    3740:	80 91 02 01 	lds	r24, 0x0102
    3744:	90 91 03 01 	lds	r25, 0x0103
    3748:	0e 94 97 28 	call	0x512e	; 0x512e <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    374c:	c0 0f       	add	r28, r16
    374e:	d1 1f       	adc	r29, r17
    3750:	40 91 4d 05 	lds	r20, 0x054D
    3754:	50 91 4e 05 	lds	r21, 0x054E
    3758:	c4 0f       	add	r28, r20
    375a:	d5 1f       	adc	r29, r21
    375c:	c6 1b       	sub	r28, r22
    375e:	d7 0b       	sbc	r29, r23
    3760:	d0 93 8b 00 	sts	0x008B, r29
    3764:	c0 93 8a 00 	sts	0x008A, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    3768:	70 93 4e 05 	sts	0x054E, r23
    376c:	60 93 4d 05 	sts	0x054D, r22
    3770:	0e c0       	rjmp	.+28     	; 0x378e <__vector_14+0xd6>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    3772:	20 91 8a 00 	lds	r18, 0x008A
    3776:	30 91 8b 00 	lds	r19, 0x008B
    377a:	80 91 13 06 	lds	r24, 0x0613
    377e:	90 91 14 06 	lds	r25, 0x0614
    3782:	82 0f       	add	r24, r18
    3784:	93 1f       	adc	r25, r19
    3786:	90 93 8b 00 	sts	0x008B, r25
    378a:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    378e:	10 92 4b 05 	sts	0x054B, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3792:	e0 91 e2 05 	lds	r30, 0x05E2
    3796:	f0 91 e3 05 	lds	r31, 0x05E3
    379a:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    379c:	80 91 7a 00 	lds	r24, 0x007A
    37a0:	86 fd       	sbrc	r24, 6
    37a2:	0a c0       	rjmp	.+20     	; 0x37b8 <__vector_14+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    37a4:	80 91 79 00 	lds	r24, 0x0079
    37a8:	80 58       	subi	r24, 0x80	; 128
    37aa:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    37ae:	80 91 7a 00 	lds	r24, 0x007A
    37b2:	80 64       	ori	r24, 0x40	; 64
    37b4:	80 93 7a 00 	sts	0x007A, r24
	}
}
    37b8:	ff 91       	pop	r31
    37ba:	ef 91       	pop	r30
    37bc:	df 91       	pop	r29
    37be:	cf 91       	pop	r28
    37c0:	bf 91       	pop	r27
    37c2:	af 91       	pop	r26
    37c4:	9f 91       	pop	r25
    37c6:	8f 91       	pop	r24
    37c8:	7f 91       	pop	r23
    37ca:	6f 91       	pop	r22
    37cc:	5f 91       	pop	r21
    37ce:	4f 91       	pop	r20
    37d0:	3f 91       	pop	r19
    37d2:	2f 91       	pop	r18
    37d4:	1f 91       	pop	r17
    37d6:	0f 91       	pop	r16
    37d8:	0f 90       	pop	r0
    37da:	0f be       	out	0x3f, r0	; 63
    37dc:	0f 90       	pop	r0
    37de:	1f 90       	pop	r1
    37e0:	18 95       	reti

000037e2 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    37e2:	1f 92       	push	r1
    37e4:	0f 92       	push	r0
    37e6:	0f b6       	in	r0, 0x3f	; 63
    37e8:	0f 92       	push	r0
    37ea:	11 24       	eor	r1, r1
    37ec:	2f 93       	push	r18
    37ee:	3f 93       	push	r19
    37f0:	4f 93       	push	r20
    37f2:	5f 93       	push	r21
    37f4:	6f 93       	push	r22
    37f6:	7f 93       	push	r23
    37f8:	8f 93       	push	r24
    37fa:	9f 93       	push	r25
    37fc:	af 93       	push	r26
    37fe:	bf 93       	push	r27
    3800:	ef 93       	push	r30
    3802:	ff 93       	push	r31
	unsigned char
		theByte;

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    3804:	80 91 4f 05 	lds	r24, 0x054F
    3808:	81 30       	cpi	r24, 0x01	; 1
    380a:	09 f0       	breq	.+2      	; 0x380e <__vector_10+0x2c>
    380c:	be c0       	rjmp	.+380    	; 0x398a <__vector_10+0x1a8>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    380e:	80 91 22 01 	lds	r24, 0x0122
    3812:	90 91 23 01 	lds	r25, 0x0123
    3816:	a0 91 24 01 	lds	r26, 0x0124
    381a:	b0 91 25 01 	lds	r27, 0x0125
    381e:	89 2b       	or	r24, r25
    3820:	8a 2b       	or	r24, r26
    3822:	8b 2b       	or	r24, r27
    3824:	09 f4       	brne	.+2      	; 0x3828 <__vector_10+0x46>
    3826:	76 c0       	rjmp	.+236    	; 0x3914 <__vector_10+0x132>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3828:	80 91 26 01 	lds	r24, 0x0126
    382c:	90 91 27 01 	lds	r25, 0x0127
    3830:	89 2b       	or	r24, r25
    3832:	09 f4       	brne	.+2      	; 0x3836 <__vector_10+0x54>
    3834:	a6 c1       	rjmp	.+844    	; 0x3b82 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3836:	e0 91 2a 01 	lds	r30, 0x012A
    383a:	f0 91 2b 01 	lds	r31, 0x012B
    383e:	e4 5d       	subi	r30, 0xD4	; 212
    3840:	fe 4f       	sbci	r31, 0xFE	; 254
    3842:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3844:	80 91 2a 01 	lds	r24, 0x012A
    3848:	90 91 2b 01 	lds	r25, 0x012B
    384c:	01 96       	adiw	r24, 0x01	; 1
    384e:	90 93 2b 01 	sts	0x012B, r25
    3852:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3856:	80 91 2a 01 	lds	r24, 0x012A
    385a:	90 91 2b 01 	lds	r25, 0x012B
    385e:	81 15       	cp	r24, r1
    3860:	93 40       	sbci	r25, 0x03	; 3
    3862:	20 f0       	brcs	.+8      	; 0x386c <__vector_10+0x8a>
				{
					sdFifoReadPointer=0;
    3864:	10 92 2b 01 	sts	0x012B, r1
    3868:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    386c:	80 91 26 01 	lds	r24, 0x0126
    3870:	90 91 27 01 	lds	r25, 0x0127
    3874:	01 97       	sbiw	r24, 0x01	; 1
    3876:	90 93 27 01 	sts	0x0127, r25
    387a:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    387e:	80 91 22 01 	lds	r24, 0x0122
    3882:	90 91 23 01 	lds	r25, 0x0123
    3886:	a0 91 24 01 	lds	r26, 0x0124
    388a:	b0 91 25 01 	lds	r27, 0x0125
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	a1 09       	sbc	r26, r1
    3892:	b1 09       	sbc	r27, r1
    3894:	80 93 22 01 	sts	0x0122, r24
    3898:	90 93 23 01 	sts	0x0123, r25
    389c:	a0 93 24 01 	sts	0x0124, r26
    38a0:	b0 93 25 01 	sts	0x0125, r27

				// Now put this byte into the RAM bank in the correct address.

				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    38a4:	8f ef       	ldi	r24, 0xFF	; 255
    38a6:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    38a8:	80 91 50 05 	lds	r24, 0x0550
    38ac:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    38ae:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    38b0:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    38b2:	40 91 50 05 	lds	r20, 0x0550
    38b6:	50 91 51 05 	lds	r21, 0x0551
    38ba:	60 91 52 05 	lds	r22, 0x0552
    38be:	70 91 53 05 	lds	r23, 0x0553
    38c2:	bb 27       	eor	r27, r27
    38c4:	a7 2f       	mov	r26, r23
    38c6:	96 2f       	mov	r25, r22
    38c8:	85 2f       	mov	r24, r21
    38ca:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    38cc:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    38ce:	14 98       	cbi	0x02, 4	; 2
				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    38d0:	cb 01       	movw	r24, r22
    38d2:	aa 27       	eor	r26, r26
    38d4:	bb 27       	eor	r27, r27
    38d6:	87 70       	andi	r24, 0x07	; 7
    38d8:	99 27       	eor	r25, r25
    38da:	aa 27       	eor	r26, r26
    38dc:	bb 27       	eor	r27, r27
    38de:	88 68       	ori	r24, 0x88	; 136
    38e0:	88 b9       	out	0x08, r24	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    38e2:	25 b9       	out	0x05, r18	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    38e4:	80 91 54 05 	lds	r24, 0x0554
    38e8:	81 30       	cpi	r24, 0x01	; 1
    38ea:	29 f4       	brne	.+10     	; 0x38f6 <__vector_10+0x114>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    38ec:	4f 5f       	subi	r20, 0xFF	; 255
    38ee:	5f 4f       	sbci	r21, 0xFF	; 255
    38f0:	6f 4f       	sbci	r22, 0xFF	; 255
    38f2:	7f 4f       	sbci	r23, 0xFF	; 255
    38f4:	04 c0       	rjmp	.+8      	; 0x38fe <__vector_10+0x11c>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    38f6:	41 50       	subi	r20, 0x01	; 1
    38f8:	51 09       	sbc	r21, r1
    38fa:	61 09       	sbc	r22, r1
    38fc:	71 09       	sbc	r23, r1
    38fe:	40 93 50 05 	sts	0x0550, r20
    3902:	50 93 51 05 	sts	0x0551, r21
    3906:	60 93 52 05 	sts	0x0552, r22
    390a:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    390e:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    3910:	11 9a       	sbi	0x02, 1	; 2
    3912:	37 c1       	rjmp	.+622    	; 0x3b82 <__vector_10+0x3a0>

			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3914:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    3918:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    391c:	80 91 70 00 	lds	r24, 0x0070
    3920:	8b 7f       	andi	r24, 0xFB	; 251
    3922:	80 93 70 00 	sts	0x0070, r24

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    3926:	20 91 54 05 	lds	r18, 0x0554
    392a:	80 91 50 05 	lds	r24, 0x0550
    392e:	90 91 51 05 	lds	r25, 0x0551
    3932:	a0 91 52 05 	lds	r26, 0x0552
    3936:	b0 91 53 05 	lds	r27, 0x0553
    393a:	21 30       	cpi	r18, 0x01	; 1
    393c:	99 f4       	brne	.+38     	; 0x3964 <__vector_10+0x182>
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    393e:	10 92 eb 05 	sts	0x05EB, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3942:	80 93 f2 05 	sts	0x05F2, r24
    3946:	90 93 f3 05 	sts	0x05F3, r25
    394a:	a0 93 f4 05 	sts	0x05F4, r26
    394e:	b0 93 f5 05 	sts	0x05F5, r27
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3952:	80 93 fa 05 	sts	0x05FA, r24
    3956:	90 93 fb 05 	sts	0x05FB, r25
    395a:	a0 93 fc 05 	sts	0x05FC, r26
    395e:	b0 93 fd 05 	sts	0x05FD, r27
    3962:	0f c1       	rjmp	.+542    	; 0x3b82 <__vector_10+0x3a0>
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    3964:	10 92 0e 06 	sts	0x060E, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3968:	80 93 15 06 	sts	0x0615, r24
    396c:	90 93 16 06 	sts	0x0616, r25
    3970:	a0 93 17 06 	sts	0x0617, r26
    3974:	b0 93 18 06 	sts	0x0618, r27
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3978:	80 93 1d 06 	sts	0x061D, r24
    397c:	90 93 1e 06 	sts	0x061E, r25
    3980:	a0 93 1f 06 	sts	0x061F, r26
    3984:	b0 93 20 06 	sts	0x0620, r27
    3988:	fc c0       	rjmp	.+504    	; 0x3b82 <__vector_10+0x3a0>
			}
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    398a:	82 30       	cpi	r24, 0x02	; 2
    398c:	09 f0       	breq	.+2      	; 0x3990 <__vector_10+0x1ae>
    398e:	98 c0       	rjmp	.+304    	; 0x3ac0 <__vector_10+0x2de>
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    3990:	80 91 26 01 	lds	r24, 0x0126
    3994:	90 91 27 01 	lds	r25, 0x0127
    3998:	81 15       	cp	r24, r1
    399a:	93 40       	sbci	r25, 0x03	; 3
    399c:	08 f0       	brcs	.+2      	; 0x39a0 <__vector_10+0x1be>
    399e:	f1 c0       	rjmp	.+482    	; 0x3b82 <__vector_10+0x3a0>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    39a0:	80 91 22 01 	lds	r24, 0x0122
    39a4:	90 91 23 01 	lds	r25, 0x0123
    39a8:	a0 91 24 01 	lds	r26, 0x0124
    39ac:	b0 91 25 01 	lds	r27, 0x0125
    39b0:	89 2b       	or	r24, r25
    39b2:	8a 2b       	or	r24, r26
    39b4:	8b 2b       	or	r24, r27
    39b6:	09 f4       	brne	.+2      	; 0x39ba <__vector_10+0x1d8>
    39b8:	70 c0       	rjmp	.+224    	; 0x3a9a <__vector_10+0x2b8>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    39ba:	80 91 50 05 	lds	r24, 0x0550
    39be:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    39c0:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    39c2:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    39c4:	40 91 50 05 	lds	r20, 0x0550
    39c8:	50 91 51 05 	lds	r21, 0x0551
    39cc:	60 91 52 05 	lds	r22, 0x0552
    39d0:	70 91 53 05 	lds	r23, 0x0553
    39d4:	bb 27       	eor	r27, r27
    39d6:	a7 2f       	mov	r26, r23
    39d8:	96 2f       	mov	r25, r22
    39da:	85 2f       	mov	r24, r21
    39dc:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    39de:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    39e0:	14 98       	cbi	0x02, 4	; 2

				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    39e2:	cb 01       	movw	r24, r22
    39e4:	aa 27       	eor	r26, r26
    39e6:	bb 27       	eor	r27, r27
    39e8:	87 70       	andi	r24, 0x07	; 7
    39ea:	99 27       	eor	r25, r25
    39ec:	aa 27       	eor	r26, r26
    39ee:	bb 27       	eor	r27, r27
    39f0:	88 68       	ori	r24, 0x88	; 136
    39f2:	88 b9       	out	0x08, r24	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    39f4:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    39f6:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    39f8:	80 91 54 05 	lds	r24, 0x0554
    39fc:	81 30       	cpi	r24, 0x01	; 1
    39fe:	29 f4       	brne	.+10     	; 0x3a0a <__vector_10+0x228>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    3a00:	4f 5f       	subi	r20, 0xFF	; 255
    3a02:	5f 4f       	sbci	r21, 0xFF	; 255
    3a04:	6f 4f       	sbci	r22, 0xFF	; 255
    3a06:	7f 4f       	sbci	r23, 0xFF	; 255
    3a08:	04 c0       	rjmp	.+8      	; 0x3a12 <__vector_10+0x230>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3a0a:	41 50       	subi	r20, 0x01	; 1
    3a0c:	51 09       	sbc	r21, r1
    3a0e:	61 09       	sbc	r22, r1
    3a10:	71 09       	sbc	r23, r1
    3a12:	40 93 50 05 	sts	0x0550, r20
    3a16:	50 93 51 05 	sts	0x0551, r21
    3a1a:	60 93 52 05 	sts	0x0552, r22
    3a1e:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    3a22:	83 b1       	in	r24, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    3a24:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    3a26:	9f ef       	ldi	r25, 0xFF	; 255
    3a28:	94 b9       	out	0x04, r25	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    3a2a:	e0 91 28 01 	lds	r30, 0x0128
    3a2e:	f0 91 29 01 	lds	r31, 0x0129
    3a32:	e4 5d       	subi	r30, 0xD4	; 212
    3a34:	fe 4f       	sbci	r31, 0xFE	; 254
    3a36:	80 83       	st	Z, r24
				sdFifoWritePointer++;				// Move to next spot in fifo
    3a38:	80 91 28 01 	lds	r24, 0x0128
    3a3c:	90 91 29 01 	lds	r25, 0x0129
    3a40:	01 96       	adiw	r24, 0x01	; 1
    3a42:	90 93 29 01 	sts	0x0129, r25
    3a46:	80 93 28 01 	sts	0x0128, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    3a4a:	80 91 28 01 	lds	r24, 0x0128
    3a4e:	90 91 29 01 	lds	r25, 0x0129
    3a52:	81 15       	cp	r24, r1
    3a54:	93 40       	sbci	r25, 0x03	; 3
    3a56:	20 f0       	brcs	.+8      	; 0x3a60 <__vector_10+0x27e>
				{
					sdFifoWritePointer=0;
    3a58:	10 92 29 01 	sts	0x0129, r1
    3a5c:	10 92 28 01 	sts	0x0128, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    3a60:	80 91 26 01 	lds	r24, 0x0126
    3a64:	90 91 27 01 	lds	r25, 0x0127
    3a68:	01 96       	adiw	r24, 0x01	; 1
    3a6a:	90 93 27 01 	sts	0x0127, r25
    3a6e:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;		// One less byte in the sample
    3a72:	80 91 22 01 	lds	r24, 0x0122
    3a76:	90 91 23 01 	lds	r25, 0x0123
    3a7a:	a0 91 24 01 	lds	r26, 0x0124
    3a7e:	b0 91 25 01 	lds	r27, 0x0125
    3a82:	01 97       	sbiw	r24, 0x01	; 1
    3a84:	a1 09       	sbc	r26, r1
    3a86:	b1 09       	sbc	r27, r1
    3a88:	80 93 22 01 	sts	0x0122, r24
    3a8c:	90 93 23 01 	sts	0x0123, r25
    3a90:	a0 93 24 01 	sts	0x0124, r26
    3a94:	b0 93 25 01 	sts	0x0125, r27
    3a98:	74 c0       	rjmp	.+232    	; 0x3b82 <__vector_10+0x3a0>

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3a9a:	10 92 4f 05 	sts	0x054F, r1
				TCCR2B=0;					// Stop this timer
    3a9e:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3aa2:	80 91 70 00 	lds	r24, 0x0070
    3aa6:	8b 7f       	andi	r24, 0xFB	; 251
    3aa8:	80 93 70 00 	sts	0x0070, r24

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    3aac:	80 91 54 05 	lds	r24, 0x0554
    3ab0:	81 30       	cpi	r24, 0x01	; 1
    3ab2:	19 f4       	brne	.+6      	; 0x3aba <__vector_10+0x2d8>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    3ab4:	10 92 eb 05 	sts	0x05EB, r1
    3ab8:	64 c0       	rjmp	.+200    	; 0x3b82 <__vector_10+0x3a0>
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    3aba:	10 92 0e 06 	sts	0x060E, r1
    3abe:	61 c0       	rjmp	.+194    	; 0x3b82 <__vector_10+0x3a0>
				}
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    3ac0:	83 30       	cpi	r24, 0x03	; 3
    3ac2:	09 f0       	breq	.+2      	; 0x3ac6 <__vector_10+0x2e4>
    3ac4:	5e c0       	rjmp	.+188    	; 0x3b82 <__vector_10+0x3a0>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    3ac6:	80 91 22 01 	lds	r24, 0x0122
    3aca:	90 91 23 01 	lds	r25, 0x0123
    3ace:	a0 91 24 01 	lds	r26, 0x0124
    3ad2:	b0 91 25 01 	lds	r27, 0x0125
    3ad6:	89 2b       	or	r24, r25
    3ad8:	8a 2b       	or	r24, r26
    3ada:	8b 2b       	or	r24, r27
    3adc:	09 f4       	brne	.+2      	; 0x3ae0 <__vector_10+0x2fe>
    3ade:	46 c0       	rjmp	.+140    	; 0x3b6c <__vector_10+0x38a>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3ae0:	80 91 26 01 	lds	r24, 0x0126
    3ae4:	90 91 27 01 	lds	r25, 0x0127
    3ae8:	89 2b       	or	r24, r25
    3aea:	09 f4       	brne	.+2      	; 0x3aee <__vector_10+0x30c>
    3aec:	4a c0       	rjmp	.+148    	; 0x3b82 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3aee:	e0 91 2a 01 	lds	r30, 0x012A
    3af2:	f0 91 2b 01 	lds	r31, 0x012B
    3af6:	e4 5d       	subi	r30, 0xD4	; 212
    3af8:	fe 4f       	sbci	r31, 0xFE	; 254
    3afa:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3afc:	80 91 2a 01 	lds	r24, 0x012A
    3b00:	90 91 2b 01 	lds	r25, 0x012B
    3b04:	01 96       	adiw	r24, 0x01	; 1
    3b06:	90 93 2b 01 	sts	0x012B, r25
    3b0a:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3b0e:	80 91 2a 01 	lds	r24, 0x012A
    3b12:	90 91 2b 01 	lds	r25, 0x012B
    3b16:	81 15       	cp	r24, r1
    3b18:	93 40       	sbci	r25, 0x03	; 3
    3b1a:	20 f0       	brcs	.+8      	; 0x3b24 <__vector_10+0x342>
				{
					sdFifoReadPointer=0;
    3b1c:	10 92 2b 01 	sts	0x012B, r1
    3b20:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3b24:	80 91 26 01 	lds	r24, 0x0126
    3b28:	90 91 27 01 	lds	r25, 0x0127
    3b2c:	01 97       	sbiw	r24, 0x01	; 1
    3b2e:	90 93 27 01 	sts	0x0127, r25
    3b32:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3b36:	80 91 22 01 	lds	r24, 0x0122
    3b3a:	90 91 23 01 	lds	r25, 0x0123
    3b3e:	a0 91 24 01 	lds	r26, 0x0124
    3b42:	b0 91 25 01 	lds	r27, 0x0125
    3b46:	01 97       	sbiw	r24, 0x01	; 1
    3b48:	a1 09       	sbc	r26, r1
    3b4a:	b1 09       	sbc	r27, r1
    3b4c:	80 93 22 01 	sts	0x0122, r24
    3b50:	90 93 23 01 	sts	0x0123, r25
    3b54:	a0 93 24 01 	sts	0x0124, r26
    3b58:	b0 93 25 01 	sts	0x0125, r27

				// Now spit the byte out the DAC.

				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine
    3b5c:	20 93 55 05 	sts	0x0555, r18
				UpdateOutput();				// Update the DAC
    3b60:	e0 91 e2 05 	lds	r30, 0x05E2
    3b64:	f0 91 e3 05 	lds	r31, 0x05E3
    3b68:	09 95       	icall
    3b6a:	0b c0       	rjmp	.+22     	; 0x3b82 <__vector_10+0x3a0>
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3b6c:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    3b70:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3b74:	80 91 70 00 	lds	r24, 0x0070
    3b78:	8b 7f       	andi	r24, 0xFB	; 251
    3b7a:	80 93 70 00 	sts	0x0070, r24

			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    3b7e:	10 92 55 05 	sts	0x0555, r1
		}
	}
}
    3b82:	ff 91       	pop	r31
    3b84:	ef 91       	pop	r30
    3b86:	bf 91       	pop	r27
    3b88:	af 91       	pop	r26
    3b8a:	9f 91       	pop	r25
    3b8c:	8f 91       	pop	r24
    3b8e:	7f 91       	pop	r23
    3b90:	6f 91       	pop	r22
    3b92:	5f 91       	pop	r21
    3b94:	4f 91       	pop	r20
    3b96:	3f 91       	pop	r19
    3b98:	2f 91       	pop	r18
    3b9a:	0f 90       	pop	r0
    3b9c:	0f be       	out	0x3f, r0	; 63
    3b9e:	0f 90       	pop	r0
    3ba0:	1f 90       	pop	r1
    3ba2:	18 95       	reti

00003ba4 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    3ba4:	1f 92       	push	r1
    3ba6:	0f 92       	push	r0
    3ba8:	0f b6       	in	r0, 0x3f	; 63
    3baa:	0f 92       	push	r0
    3bac:	11 24       	eor	r1, r1
    3bae:	8f 93       	push	r24
    3bb0:	9f 93       	push	r25
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
    3bb2:	90 91 40 04 	lds	r25, 0x0440
    3bb6:	80 91 56 05 	lds	r24, 0x0556
    3bba:	89 17       	cp	r24, r25
    3bbc:	18 f4       	brcc	.+6      	; 0x3bc4 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    3bbe:	9f ef       	ldi	r25, 0xFF	; 255
    3bc0:	95 b9       	out	0x05, r25	; 5
    3bc2:	01 c0       	rjmp	.+2      	; 0x3bc6 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    3bc4:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    3bc6:	8f 5f       	subi	r24, 0xFF	; 255
    3bc8:	80 93 56 05 	sts	0x0556, r24
}
    3bcc:	9f 91       	pop	r25
    3bce:	8f 91       	pop	r24
    3bd0:	0f 90       	pop	r0
    3bd2:	0f be       	out	0x3f, r0	; 63
    3bd4:	0f 90       	pop	r0
    3bd6:	1f 90       	pop	r1
    3bd8:	18 95       	reti

00003bda <__vector_default>:

ISR(__vector_default)
{
    3bda:	1f 92       	push	r1
    3bdc:	0f 92       	push	r0
    3bde:	0f b6       	in	r0, 0x3f	; 63
    3be0:	0f 92       	push	r0
    3be2:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    3be4:	0f 90       	pop	r0
    3be6:	0f be       	out	0x3f, r0	; 63
    3be8:	0f 90       	pop	r0
    3bea:	1f 90       	pop	r1
    3bec:	18 95       	reti

00003bee <HandleSoftclock>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    3bee:	a8 9b       	sbis	0x15, 0	; 21
    3bf0:	0a c0       	rjmp	.+20     	; 0x3c06 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    3bf2:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    3bf4:	80 91 2c 06 	lds	r24, 0x062C
    3bf8:	90 91 2d 06 	lds	r25, 0x062D
    3bfc:	01 96       	adiw	r24, 0x01	; 1
    3bfe:	90 93 2d 06 	sts	0x062D, r25
    3c02:	80 93 2c 06 	sts	0x062C, r24
    3c06:	08 95       	ret

00003c08 <EepromWrite>:
void EepromWrite(unsigned int theAddress, unsigned char theData)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3c08:	f9 99       	sbic	0x1f, 1	; 31
    3c0a:	fe cf       	rjmp	.-4      	; 0x3c08 <EepromWrite>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3c0c:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3c0e:	f8 94       	cli

	EEAR=theAddress;
    3c10:	92 bd       	out	0x22, r25	; 34
    3c12:	81 bd       	out	0x21, r24	; 33
	EEDR=theData;
    3c14:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    3c16:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    3c18:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    3c1a:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3c1c:	12 bc       	out	0x22, r1	; 34
    3c1e:	11 bc       	out	0x21, r1	; 33
    3c20:	08 95       	ret

00003c22 <EepromRead>:
unsigned char EepromRead(unsigned char theAddress)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3c22:	f9 99       	sbic	0x1f, 1	; 31
    3c24:	fe cf       	rjmp	.-4      	; 0x3c22 <EepromRead>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3c26:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3c28:	f8 94       	cli

	EEAR=theAddress;
    3c2a:	90 e0       	ldi	r25, 0x00	; 0
    3c2c:	92 bd       	out	0x22, r25	; 34
    3c2e:	81 bd       	out	0x21, r24	; 33
	EECR|=(1<<EERE);	// Start reading.
    3c30:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    3c32:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3c34:	12 bc       	out	0x22, r1	; 34
    3c36:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    3c38:	80 b5       	in	r24, 0x20	; 32
}
    3c3a:	08 95       	ret

00003c3c <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    3c3c:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    3c40:	88 1f       	adc	r24, r24
    3c42:	88 27       	eor	r24, r24
    3c44:	88 1f       	adc	r24, r24
    3c46:	08 95       	ret

00003c48 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3c48:	80 91 c6 00 	lds	r24, 0x00C6
}
    3c4c:	08 95       	ret

00003c4e <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    3c4e:	80 91 64 00 	lds	r24, 0x0064
    3c52:	8d 7f       	andi	r24, 0xFD	; 253
    3c54:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    3c58:	80 91 c0 00 	lds	r24, 0x00C0
    3c5c:	8d 7f       	andi	r24, 0xFD	; 253
    3c5e:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    3c62:	88 e1       	ldi	r24, 0x18	; 24
    3c64:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    3c68:	87 e2       	ldi	r24, 0x27	; 39
    3c6a:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    3c6e:	86 e0       	ldi	r24, 0x06	; 6
    3c70:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    3c74:	80 91 c0 00 	lds	r24, 0x00C0
    3c78:	85 ff       	sbrs	r24, 5
    3c7a:	fc cf       	rjmp	.-8      	; 0x3c74 <InitUart0+0x26>
    3c7c:	02 c0       	rjmp	.+4      	; 0x3c82 <InitUart0+0x34>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3c7e:	80 91 c6 00 	lds	r24, 0x00C6
	{
		;
	}

//	Uart0FlushBuffer();						// Get rid of any poo poo hanging out in the input buffer.
	while(Uart0GotByte())
    3c82:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Uart0GotByte>
    3c86:	81 11       	cpse	r24, r1
    3c88:	fa cf       	rjmp	.-12     	; 0x3c7e <InitUart0+0x30>
	{
		Uart0GetByte();
	}		
}
    3c8a:	08 95       	ret

00003c8c <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	20 91 2c 06 	lds	r18, 0x062C
    3c92:	30 91 2d 06 	lds	r19, 0x062D
    3c96:	88 0f       	add	r24, r24
    3c98:	99 1f       	adc	r25, r25
    3c9a:	fc 01       	movw	r30, r24
    3c9c:	eb 53       	subi	r30, 0x3B	; 59
    3c9e:	fa 4f       	sbci	r31, 0xFA	; 250
    3ca0:	31 83       	std	Z+1, r19	; 0x01
    3ca2:	20 83       	st	Z, r18
	delayTime[timerNum]=ticks_to_wait;
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	e3 53       	subi	r30, 0x33	; 51
    3ca8:	fa 4f       	sbci	r31, 0xFA	; 250
    3caa:	71 83       	std	Z+1, r23	; 0x01
    3cac:	60 83       	st	Z, r22
    3cae:	08 95       	ret

00003cb0 <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    3cb0:	20 91 2c 06 	lds	r18, 0x062C
    3cb4:	30 91 2d 06 	lds	r19, 0x062D
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	88 0f       	add	r24, r24
    3cbc:	99 1f       	adc	r25, r25
    3cbe:	fc 01       	movw	r30, r24
    3cc0:	eb 53       	subi	r30, 0x3B	; 59
    3cc2:	fa 4f       	sbci	r31, 0xFA	; 250
    3cc4:	40 81       	ld	r20, Z
    3cc6:	51 81       	ldd	r21, Z+1	; 0x01
    3cc8:	24 1b       	sub	r18, r20
    3cca:	35 0b       	sbc	r19, r21
    3ccc:	fc 01       	movw	r30, r24
    3cce:	e3 53       	subi	r30, 0x33	; 51
    3cd0:	fa 4f       	sbci	r31, 0xFA	; 250
    3cd2:	81 e0       	ldi	r24, 0x01	; 1
    3cd4:	40 81       	ld	r20, Z
    3cd6:	51 81       	ldd	r21, Z+1	; 0x01
    3cd8:	24 17       	cp	r18, r20
    3cda:	35 07       	cpc	r19, r21
    3cdc:	08 f4       	brcc	.+2      	; 0x3ce0 <CheckTimer+0x30>
    3cde:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    3ce0:	08 95       	ret

00003ce2 <PutMidiMessageInIncomingFifo>:
}

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    3ce2:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    3ce4:	80 91 60 06 	lds	r24, 0x0660
    3ce8:	86 30       	cpi	r24, 0x06	; 6
    3cea:	08 f5       	brcc	.+66     	; 0x3d2e <PutMidiMessageInIncomingFifo+0x4c>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    3cec:	90 91 d9 05 	lds	r25, 0x05D9
    3cf0:	11 96       	adiw	r26, 0x01	; 1
    3cf2:	2c 91       	ld	r18, X
    3cf4:	11 97       	sbiw	r26, 0x01	; 1
    3cf6:	34 e0       	ldi	r19, 0x04	; 4
    3cf8:	93 9f       	mul	r25, r19
    3cfa:	f0 01       	movw	r30, r0
    3cfc:	11 24       	eor	r1, r1
    3cfe:	e1 5d       	subi	r30, 0xD1	; 209
    3d00:	f9 4f       	sbci	r31, 0xF9	; 249
    3d02:	21 83       	std	Z+1, r18	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    3d04:	12 96       	adiw	r26, 0x02	; 2
    3d06:	2c 91       	ld	r18, X
    3d08:	12 97       	sbiw	r26, 0x02	; 2
    3d0a:	22 83       	std	Z+2, r18	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    3d0c:	13 96       	adiw	r26, 0x03	; 3
    3d0e:	2c 91       	ld	r18, X
    3d10:	13 97       	sbiw	r26, 0x03	; 3
    3d12:	23 83       	std	Z+3, r18	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    3d14:	2c 91       	ld	r18, X
    3d16:	20 83       	st	Z, r18
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3d18:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3d1a:	96 30       	cpi	r25, 0x06	; 6
    3d1c:	18 f4       	brcc	.+6      	; 0x3d24 <PutMidiMessageInIncomingFifo+0x42>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3d1e:	90 93 d9 05 	sts	0x05D9, r25
    3d22:	02 c0       	rjmp	.+4      	; 0x3d28 <PutMidiMessageInIncomingFifo+0x46>
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
    3d24:	10 92 d9 05 	sts	0x05D9, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    3d28:	8f 5f       	subi	r24, 0xFF	; 255
    3d2a:	80 93 60 06 	sts	0x0660, r24
    3d2e:	08 95       	ret

00003d30 <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    3d30:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    3d32:	80 91 60 06 	lds	r24, 0x0660
    3d36:	88 23       	and	r24, r24
    3d38:	09 f1       	breq	.+66     	; 0x3d7c <GetMidiMessageFromIncomingFifo+0x4c>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3d3a:	90 91 d5 05 	lds	r25, 0x05D5
    3d3e:	24 e0       	ldi	r18, 0x04	; 4
    3d40:	92 9f       	mul	r25, r18
    3d42:	f0 01       	movw	r30, r0
    3d44:	11 24       	eor	r1, r1
    3d46:	e1 5d       	subi	r30, 0xD1	; 209
    3d48:	f9 4f       	sbci	r31, 0xF9	; 249
    3d4a:	21 81       	ldd	r18, Z+1	; 0x01
    3d4c:	11 96       	adiw	r26, 0x01	; 1
    3d4e:	2c 93       	st	X, r18
    3d50:	11 97       	sbiw	r26, 0x01	; 1
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    3d52:	22 81       	ldd	r18, Z+2	; 0x02
    3d54:	12 96       	adiw	r26, 0x02	; 2
    3d56:	2c 93       	st	X, r18
    3d58:	12 97       	sbiw	r26, 0x02	; 2
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    3d5a:	23 81       	ldd	r18, Z+3	; 0x03
    3d5c:	13 96       	adiw	r26, 0x03	; 3
    3d5e:	2c 93       	st	X, r18
    3d60:	13 97       	sbiw	r26, 0x03	; 3
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    3d62:	20 81       	ld	r18, Z
    3d64:	2c 93       	st	X, r18

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3d66:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3d68:	96 30       	cpi	r25, 0x06	; 6
    3d6a:	18 f4       	brcc	.+6      	; 0x3d72 <GetMidiMessageFromIncomingFifo+0x42>
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3d6c:	90 93 d5 05 	sts	0x05D5, r25
    3d70:	02 c0       	rjmp	.+4      	; 0x3d76 <GetMidiMessageFromIncomingFifo+0x46>
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
    3d72:	10 92 d5 05 	sts	0x05D5, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    3d76:	81 50       	subi	r24, 0x01	; 1
    3d78:	80 93 60 06 	sts	0x0660, r24
    3d7c:	08 95       	ret

00003d7e <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    3d7e:	80 91 61 06 	lds	r24, 0x0661
    3d82:	86 30       	cpi	r24, 0x06	; 6
    3d84:	c8 f4       	brcc	.+50     	; 0x3db8 <PutMidiMessageInOutgoingFifo+0x3a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    3d86:	90 91 d6 05 	lds	r25, 0x05D6
    3d8a:	34 e0       	ldi	r19, 0x04	; 4
    3d8c:	93 9f       	mul	r25, r19
    3d8e:	f0 01       	movw	r30, r0
    3d90:	11 24       	eor	r1, r1
    3d92:	e8 5b       	subi	r30, 0xB8	; 184
    3d94:	f9 4f       	sbci	r31, 0xF9	; 249
    3d96:	61 83       	std	Z+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    3d98:	42 83       	std	Z+2, r20	; 0x02
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    3d9a:	23 83       	std	Z+3, r18	; 0x03
    3d9c:	20 91 2e 06 	lds	r18, 0x062E
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    3da0:	20 83       	st	Z, r18
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3da2:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3da4:	96 30       	cpi	r25, 0x06	; 6
    3da6:	18 f4       	brcc	.+6      	; 0x3dae <PutMidiMessageInOutgoingFifo+0x30>
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3da8:	90 93 d6 05 	sts	0x05D6, r25
    3dac:	02 c0       	rjmp	.+4      	; 0x3db2 <PutMidiMessageInOutgoingFifo+0x34>
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
    3dae:	10 92 d6 05 	sts	0x05D6, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    3db2:	8f 5f       	subi	r24, 0xFF	; 255
    3db4:	80 93 61 06 	sts	0x0661, r24
    3db8:	08 95       	ret

00003dba <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    3dba:	89 e0       	ldi	r24, 0x09	; 9
    3dbc:	80 93 d7 05 	sts	0x05D7, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    3dc0:	10 92 d8 05 	sts	0x05D8, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    3dc4:	10 92 60 06 	sts	0x0660, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    3dc8:	10 92 d9 05 	sts	0x05D9, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    3dcc:	10 92 d5 05 	sts	0x05D5, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    3dd0:	10 92 61 06 	sts	0x0661, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    3dd4:	10 92 d6 05 	sts	0x05D6, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    3dd8:	10 92 da 05 	sts	0x05DA, r1
    3ddc:	08 95       	ret

00003dde <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    3dde:	1f 93       	push	r17
    3de0:	cf 93       	push	r28
    3de2:	df 93       	push	r29
    3de4:	00 d0       	rcall	.+0      	; 0x3de6 <HandleIncomingMidiByte+0x8>
    3de6:	00 d0       	rcall	.+0      	; 0x3de8 <HandleIncomingMidiByte+0xa>
    3de8:	cd b7       	in	r28, 0x3d	; 61
    3dea:	de b7       	in	r29, 0x3e	; 62
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    3dec:	87 ff       	sbrs	r24, 7
    3dee:	2f c0       	rjmp	.+94     	; 0x3e4e <HandleIncomingMidiByte+0x70>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    3df0:	98 2f       	mov	r25, r24
    3df2:	9f 70       	andi	r25, 0x0F	; 15
    3df4:	20 91 2e 06 	lds	r18, 0x062E
    3df8:	92 17       	cp	r25, r18
    3dfa:	21 f0       	breq	.+8      	; 0x3e04 <HandleIncomingMidiByte+0x26>
    3dfc:	30 91 47 06 	lds	r19, 0x0647
    3e00:	93 13       	cpse	r25, r19
    3e02:	9f c0       	rjmp	.+318    	; 0x3f42 <HandleIncomingMidiByte+0x164>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    3e04:	80 7f       	andi	r24, 0xF0	; 240
    3e06:	80 39       	cpi	r24, 0x90	; 144
    3e08:	19 f4       	brne	.+6      	; 0x3e10 <HandleIncomingMidiByte+0x32>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    3e0a:	10 92 d7 05 	sts	0x05D7, r1
    3e0e:	16 c0       	rjmp	.+44     	; 0x3e3c <HandleIncomingMidiByte+0x5e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    3e10:	80 38       	cpi	r24, 0x80	; 128
    3e12:	31 f4       	brne	.+12     	; 0x3e20 <HandleIncomingMidiByte+0x42>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    3e14:	81 e0       	ldi	r24, 0x01	; 1
    3e16:	80 93 d7 05 	sts	0x05D7, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3e1a:	92 13       	cpse	r25, r18
    3e1c:	15 c0       	rjmp	.+42     	; 0x3e48 <HandleIncomingMidiByte+0x6a>
    3e1e:	10 c0       	rjmp	.+32     	; 0x3e40 <HandleIncomingMidiByte+0x62>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    3e20:	80 3c       	cpi	r24, 0xC0	; 192
    3e22:	11 f4       	brne	.+4      	; 0x3e28 <HandleIncomingMidiByte+0x4a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    3e24:	82 e0       	ldi	r24, 0x02	; 2
    3e26:	08 c0       	rjmp	.+16     	; 0x3e38 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    3e28:	80 3e       	cpi	r24, 0xE0	; 224
    3e2a:	11 f4       	brne	.+4      	; 0x3e30 <HandleIncomingMidiByte+0x52>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    3e2c:	87 e0       	ldi	r24, 0x07	; 7
    3e2e:	04 c0       	rjmp	.+8      	; 0x3e38 <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    3e30:	80 3b       	cpi	r24, 0xB0	; 176
    3e32:	09 f0       	breq	.+2      	; 0x3e36 <HandleIncomingMidiByte+0x58>
    3e34:	86 c0       	rjmp	.+268    	; 0x3f42 <HandleIncomingMidiByte+0x164>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    3e36:	83 e0       	ldi	r24, 0x03	; 3
    3e38:	80 93 d7 05 	sts	0x05D7, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3e3c:	92 13       	cpse	r25, r18
    3e3e:	03 c0       	rjmp	.+6      	; 0x3e46 <HandleIncomingMidiByte+0x68>
				{
					temporaryChannel=BANK_0;
    3e40:	10 92 db 05 	sts	0x05DB, r1
    3e44:	81 c0       	rjmp	.+258    	; 0x3f48 <HandleIncomingMidiByte+0x16a>
				}
				else
				{
					temporaryChannel=BANK_1;
    3e46:	81 e0       	ldi	r24, 0x01	; 1
    3e48:	80 93 db 05 	sts	0x05DB, r24
    3e4c:	7d c0       	rjmp	.+250    	; 0x3f48 <HandleIncomingMidiByte+0x16a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    3e4e:	10 91 d7 05 	lds	r17, 0x05D7
    3e52:	14 30       	cpi	r17, 0x04	; 4
    3e54:	09 f4       	brne	.+2      	; 0x3e58 <HandleIncomingMidiByte+0x7a>
    3e56:	53 c0       	rjmp	.+166    	; 0x3efe <HandleIncomingMidiByte+0x120>
    3e58:	50 f4       	brcc	.+20     	; 0x3e6e <HandleIncomingMidiByte+0x90>
    3e5a:	11 30       	cpi	r17, 0x01	; 1
    3e5c:	a1 f1       	breq	.+104    	; 0x3ec6 <HandleIncomingMidiByte+0xe8>
    3e5e:	c0 f0       	brcs	.+48     	; 0x3e90 <HandleIncomingMidiByte+0xb2>
    3e60:	12 30       	cpi	r17, 0x02	; 2
    3e62:	09 f4       	brne	.+2      	; 0x3e66 <HandleIncomingMidiByte+0x88>
    3e64:	43 c0       	rjmp	.+134    	; 0x3eec <HandleIncomingMidiByte+0x10e>
    3e66:	13 30       	cpi	r17, 0x03	; 3
    3e68:	09 f0       	breq	.+2      	; 0x3e6c <HandleIncomingMidiByte+0x8e>
    3e6a:	6b c0       	rjmp	.+214    	; 0x3f42 <HandleIncomingMidiByte+0x164>
    3e6c:	44 c0       	rjmp	.+136    	; 0x3ef6 <HandleIncomingMidiByte+0x118>
    3e6e:	17 30       	cpi	r17, 0x07	; 7
    3e70:	09 f4       	brne	.+2      	; 0x3e74 <HandleIncomingMidiByte+0x96>
    3e72:	53 c0       	rjmp	.+166    	; 0x3f1a <HandleIncomingMidiByte+0x13c>
    3e74:	30 f4       	brcc	.+12     	; 0x3e82 <HandleIncomingMidiByte+0xa4>
    3e76:	15 30       	cpi	r17, 0x05	; 5
    3e78:	79 f0       	breq	.+30     	; 0x3e98 <HandleIncomingMidiByte+0xba>
    3e7a:	16 30       	cpi	r17, 0x06	; 6
    3e7c:	09 f0       	breq	.+2      	; 0x3e80 <HandleIncomingMidiByte+0xa2>
    3e7e:	61 c0       	rjmp	.+194    	; 0x3f42 <HandleIncomingMidiByte+0x164>
    3e80:	26 c0       	rjmp	.+76     	; 0x3ece <HandleIncomingMidiByte+0xf0>
    3e82:	18 30       	cpi	r17, 0x08	; 8
    3e84:	09 f4       	brne	.+2      	; 0x3e88 <HandleIncomingMidiByte+0xaa>
    3e86:	4d c0       	rjmp	.+154    	; 0x3f22 <HandleIncomingMidiByte+0x144>
    3e88:	19 30       	cpi	r17, 0x09	; 9
    3e8a:	09 f0       	breq	.+2      	; 0x3e8e <HandleIncomingMidiByte+0xb0>
    3e8c:	5a c0       	rjmp	.+180    	; 0x3f42 <HandleIncomingMidiByte+0x164>
    3e8e:	5c c0       	rjmp	.+184    	; 0x3f48 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    3e90:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    3e94:	85 e0       	ldi	r24, 0x05	; 5
    3e96:	56 c0       	rjmp	.+172    	; 0x3f44 <HandleIncomingMidiByte+0x166>
    3e98:	90 91 dc 05 	lds	r25, 0x05DC
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    3e9c:	81 11       	cpse	r24, r1
    3e9e:	05 c0       	rjmp	.+10     	; 0x3eaa <HandleIncomingMidiByte+0xcc>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    3ea0:	82 e0       	ldi	r24, 0x02	; 2
    3ea2:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    3ea4:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    3ea6:	1c 82       	std	Y+4, r1	; 0x04
    3ea8:	04 c0       	rjmp	.+8      	; 0x3eb2 <HandleIncomingMidiByte+0xd4>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    3eaa:	21 e0       	ldi	r18, 0x01	; 1
    3eac:	2a 83       	std	Y+2, r18	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    3eae:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    3eb0:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    3eb2:	80 91 db 05 	lds	r24, 0x05DB
    3eb6:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    3eb8:	ce 01       	movw	r24, r28
    3eba:	01 96       	adiw	r24, 0x01	; 1
    3ebc:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    3ec0:	10 92 d7 05 	sts	0x05D7, r1
    3ec4:	41 c0       	rjmp	.+130    	; 0x3f48 <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    3ec6:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    3eca:	86 e0       	ldi	r24, 0x06	; 6
    3ecc:	3b c0       	rjmp	.+118    	; 0x3f44 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    3ece:	92 e0       	ldi	r25, 0x02	; 2
    3ed0:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    3ed2:	90 91 dc 05 	lds	r25, 0x05DC
    3ed6:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    3ed8:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    3eda:	80 91 db 05 	lds	r24, 0x05DB
    3ede:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    3ee0:	ce 01       	movw	r24, r28
    3ee2:	01 96       	adiw	r24, 0x01	; 1
    3ee4:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    3ee8:	81 e0       	ldi	r24, 0x01	; 1
    3eea:	2c c0       	rjmp	.+88     	; 0x3f44 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    3eec:	93 e0       	ldi	r25, 0x03	; 3
    3eee:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    3ef0:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    3ef2:	1c 82       	std	Y+4, r1	; 0x04
    3ef4:	1c c0       	rjmp	.+56     	; 0x3f2e <HandleIncomingMidiByte+0x150>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    3ef6:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    3efa:	84 e0       	ldi	r24, 0x04	; 4
    3efc:	23 c0       	rjmp	.+70     	; 0x3f44 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    3efe:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    3f00:	90 91 dc 05 	lds	r25, 0x05DC
    3f04:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    3f06:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    3f08:	80 91 db 05 	lds	r24, 0x05DB
    3f0c:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    3f0e:	ce 01       	movw	r24, r28
    3f10:	01 96       	adiw	r24, 0x01	; 1
    3f12:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    3f16:	83 e0       	ldi	r24, 0x03	; 3
    3f18:	15 c0       	rjmp	.+42     	; 0x3f44 <HandleIncomingMidiByte+0x166>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    3f1a:	80 93 dc 05 	sts	0x05DC, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    3f1e:	88 e0       	ldi	r24, 0x08	; 8
    3f20:	11 c0       	rjmp	.+34     	; 0x3f44 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    3f22:	17 e0       	ldi	r17, 0x07	; 7
    3f24:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    3f26:	90 91 dc 05 	lds	r25, 0x05DC
    3f2a:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    3f2c:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    3f2e:	80 91 db 05 	lds	r24, 0x05DB
    3f32:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    3f34:	ce 01       	movw	r24, r28
    3f36:	01 96       	adiw	r24, 0x01	; 1
    3f38:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    3f3c:	10 93 d7 05 	sts	0x05D7, r17
    3f40:	03 c0       	rjmp	.+6      	; 0x3f48 <HandleIncomingMidiByte+0x16a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    3f42:	89 e0       	ldi	r24, 0x09	; 9
    3f44:	80 93 d7 05 	sts	0x05D7, r24
			break;
		}	
	}
}
    3f48:	0f 90       	pop	r0
    3f4a:	0f 90       	pop	r0
    3f4c:	0f 90       	pop	r0
    3f4e:	0f 90       	pop	r0
    3f50:	df 91       	pop	r29
    3f52:	cf 91       	pop	r28
    3f54:	1f 91       	pop	r17
    3f56:	08 95       	ret

00003f58 <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    3f58:	80 91 61 06 	lds	r24, 0x0661
    3f5c:	81 11       	cpse	r24, r1
    3f5e:	07 c0       	rjmp	.+14     	; 0x3f6e <MidiTxBufferNotEmpty+0x16>
    3f60:	81 e0       	ldi	r24, 0x01	; 1
    3f62:	90 91 d8 05 	lds	r25, 0x05D8
    3f66:	91 11       	cpse	r25, r1
    3f68:	03 c0       	rjmp	.+6      	; 0x3f70 <MidiTxBufferNotEmpty+0x18>
    3f6a:	80 e0       	ldi	r24, 0x00	; 0
    3f6c:	08 95       	ret
	{
		return(true);
    3f6e:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    3f70:	08 95       	ret

00003f72 <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    3f72:	80 91 d8 05 	lds	r24, 0x05D8
    3f76:	83 30       	cpi	r24, 0x03	; 3
    3f78:	09 f4       	brne	.+2      	; 0x3f7c <PopOutgoingMidiByte+0xa>
    3f7a:	87 c0       	rjmp	.+270    	; 0x408a <PopOutgoingMidiByte+0x118>
    3f7c:	30 f4       	brcc	.+12     	; 0x3f8a <PopOutgoingMidiByte+0x18>
    3f7e:	81 30       	cpi	r24, 0x01	; 1
    3f80:	09 f4       	brne	.+2      	; 0x3f84 <PopOutgoingMidiByte+0x12>
    3f82:	7b c0       	rjmp	.+246    	; 0x407a <PopOutgoingMidiByte+0x108>
    3f84:	08 f0       	brcs	.+2      	; 0x3f88 <PopOutgoingMidiByte+0x16>
    3f86:	7b c0       	rjmp	.+246    	; 0x407e <PopOutgoingMidiByte+0x10c>
    3f88:	0c c0       	rjmp	.+24     	; 0x3fa2 <PopOutgoingMidiByte+0x30>
    3f8a:	85 30       	cpi	r24, 0x05	; 5
    3f8c:	09 f4       	brne	.+2      	; 0x3f90 <PopOutgoingMidiByte+0x1e>
    3f8e:	84 c0       	rjmp	.+264    	; 0x4098 <PopOutgoingMidiByte+0x126>
    3f90:	08 f4       	brcc	.+2      	; 0x3f94 <PopOutgoingMidiByte+0x22>
    3f92:	7f c0       	rjmp	.+254    	; 0x4092 <PopOutgoingMidiByte+0x120>
    3f94:	86 30       	cpi	r24, 0x06	; 6
    3f96:	09 f4       	brne	.+2      	; 0x3f9a <PopOutgoingMidiByte+0x28>
    3f98:	82 c0       	rjmp	.+260    	; 0x409e <PopOutgoingMidiByte+0x12c>
    3f9a:	87 30       	cpi	r24, 0x07	; 7
    3f9c:	09 f0       	breq	.+2      	; 0x3fa0 <PopOutgoingMidiByte+0x2e>
    3f9e:	86 c0       	rjmp	.+268    	; 0x40ac <PopOutgoingMidiByte+0x13a>
    3fa0:	80 c0       	rjmp	.+256    	; 0x40a2 <PopOutgoingMidiByte+0x130>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    3fa2:	80 91 61 06 	lds	r24, 0x0661
    3fa6:	88 23       	and	r24, r24
    3fa8:	f9 f0       	breq	.+62     	; 0x3fe8 <PopOutgoingMidiByte+0x76>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3faa:	90 91 da 05 	lds	r25, 0x05DA
    3fae:	24 e0       	ldi	r18, 0x04	; 4
    3fb0:	92 9f       	mul	r25, r18
    3fb2:	f0 01       	movw	r30, r0
    3fb4:	11 24       	eor	r1, r1
    3fb6:	e8 5b       	subi	r30, 0xB8	; 184
    3fb8:	f9 4f       	sbci	r31, 0xF9	; 249
    3fba:	21 81       	ldd	r18, Z+1	; 0x01
    3fbc:	20 93 de 05 	sts	0x05DE, r18
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    3fc0:	22 81       	ldd	r18, Z+2	; 0x02
    3fc2:	20 93 df 05 	sts	0x05DF, r18
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    3fc6:	23 81       	ldd	r18, Z+3	; 0x03
    3fc8:	20 93 e0 05 	sts	0x05E0, r18
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    3fcc:	20 81       	ld	r18, Z
    3fce:	20 93 dd 05 	sts	0x05DD, r18

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    3fd2:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3fd4:	96 30       	cpi	r25, 0x06	; 6
    3fd6:	18 f4       	brcc	.+6      	; 0x3fde <PopOutgoingMidiByte+0x6c>
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    3fd8:	90 93 da 05 	sts	0x05DA, r25
    3fdc:	02 c0       	rjmp	.+4      	; 0x3fe2 <PopOutgoingMidiByte+0x70>
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
    3fde:	10 92 da 05 	sts	0x05DA, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    3fe2:	81 50       	subi	r24, 0x01	; 1
    3fe4:	80 93 61 06 	sts	0x0661, r24
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    3fe8:	90 91 de 05 	lds	r25, 0x05DE
    3fec:	92 30       	cpi	r25, 0x02	; 2
    3fee:	b1 f0       	breq	.+44     	; 0x401c <PopOutgoingMidiByte+0xaa>
    3ff0:	20 f4       	brcc	.+8      	; 0x3ffa <PopOutgoingMidiByte+0x88>
    3ff2:	91 30       	cpi	r25, 0x01	; 1
    3ff4:	09 f0       	breq	.+2      	; 0x3ff8 <PopOutgoingMidiByte+0x86>
    3ff6:	5a c0       	rjmp	.+180    	; 0x40ac <PopOutgoingMidiByte+0x13a>
    3ff8:	06 c0       	rjmp	.+12     	; 0x4006 <PopOutgoingMidiByte+0x94>
    3ffa:	93 30       	cpi	r25, 0x03	; 3
    3ffc:	e9 f0       	breq	.+58     	; 0x4038 <PopOutgoingMidiByte+0xc6>
    3ffe:	94 30       	cpi	r25, 0x04	; 4
    4000:	09 f0       	breq	.+2      	; 0x4004 <PopOutgoingMidiByte+0x92>
    4002:	54 c0       	rjmp	.+168    	; 0x40ac <PopOutgoingMidiByte+0x13a>
    4004:	29 c0       	rjmp	.+82     	; 0x4058 <PopOutgoingMidiByte+0xe6>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4006:	80 91 dd 05 	lds	r24, 0x05DD
    400a:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    400c:	20 91 e1 05 	lds	r18, 0x05E1
    4010:	28 13       	cpse	r18, r24
    4012:	0f c0       	rjmp	.+30     	; 0x4032 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    4014:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4018:	93 e0       	ldi	r25, 0x03	; 3
    401a:	2c c0       	rjmp	.+88     	; 0x4074 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    401c:	80 91 dd 05 	lds	r24, 0x05DD
    4020:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    4022:	20 91 e1 05 	lds	r18, 0x05E1
    4026:	28 13       	cpse	r18, r24
    4028:	04 c0       	rjmp	.+8      	; 0x4032 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    402a:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    402e:	94 e0       	ldi	r25, 0x04	; 4
    4030:	21 c0       	rjmp	.+66     	; 0x4074 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4032:	80 93 e1 05 	sts	0x05E1, r24
    4036:	1e c0       	rjmp	.+60     	; 0x4074 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    4038:	80 91 dd 05 	lds	r24, 0x05DD
    403c:	80 6c       	ori	r24, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    403e:	90 91 e1 05 	lds	r25, 0x05E1
    4042:	98 13       	cpse	r25, r24
    4044:	05 c0       	rjmp	.+10     	; 0x4050 <PopOutgoingMidiByte+0xde>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    4046:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    404a:	10 92 d8 05 	sts	0x05D8, r1
    404e:	08 95       	ret
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4050:	80 93 e1 05 	sts	0x05E1, r24
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    4054:	95 e0       	ldi	r25, 0x05	; 5
    4056:	0e c0       	rjmp	.+28     	; 0x4074 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4058:	80 91 dd 05 	lds	r24, 0x05DD
    405c:	80 6b       	ori	r24, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    405e:	90 91 e1 05 	lds	r25, 0x05E1
    4062:	98 13       	cpse	r25, r24
    4064:	04 c0       	rjmp	.+8      	; 0x406e <PopOutgoingMidiByte+0xfc>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    4066:	80 91 df 05 	lds	r24, 0x05DF
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    406a:	97 e0       	ldi	r25, 0x07	; 7
    406c:	03 c0       	rjmp	.+6      	; 0x4074 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    406e:	80 93 e1 05 	sts	0x05E1, r24
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    4072:	96 e0       	ldi	r25, 0x06	; 6
    4074:	90 93 d8 05 	sts	0x05D8, r25
    4078:	08 95       	ret
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    407a:	83 e0       	ldi	r24, 0x03	; 3
    407c:	01 c0       	rjmp	.+2      	; 0x4080 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    407e:	84 e0       	ldi	r24, 0x04	; 4
    4080:	80 93 d8 05 	sts	0x05D8, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    4084:	80 91 df 05 	lds	r24, 0x05DF
    4088:	08 95       	ret
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    408a:	10 92 d8 05 	sts	0x05D8, r1
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
    408e:	80 e4       	ldi	r24, 0x40	; 64
    4090:	08 95       	ret
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4092:	10 92 d8 05 	sts	0x05D8, r1
    4096:	0a c0       	rjmp	.+20     	; 0x40ac <PopOutgoingMidiByte+0x13a>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4098:	10 92 d8 05 	sts	0x05D8, r1
    409c:	f3 cf       	rjmp	.-26     	; 0x4084 <PopOutgoingMidiByte+0x112>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    409e:	87 e0       	ldi	r24, 0x07	; 7
    40a0:	ef cf       	rjmp	.-34     	; 0x4080 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);								// Return the first data byte.
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    40a2:	10 92 d8 05 	sts	0x05D8, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    40a6:	80 91 e0 05 	lds	r24, 0x05E0
    40aa:	08 95       	ret

			}
			break;

			default:
			theByte=0;		// Make compiler happy.
    40ac:	80 e0       	ldi	r24, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    40ae:	08 95       	ret

000040b0 <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    40b0:	8a b1       	in	r24, 0x0a	; 10
    40b2:	8f 7c       	andi	r24, 0xCF	; 207
    40b4:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    40b6:	8b b1       	in	r24, 0x0b	; 11
    40b8:	80 63       	ori	r24, 0x30	; 48
    40ba:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    40bc:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    40c0:	e4 e6       	ldi	r30, 0x64	; 100
    40c2:	f0 e0       	ldi	r31, 0x00	; 0
    40c4:	80 81       	ld	r24, Z
    40c6:	80 61       	ori	r24, 0x10	; 16
    40c8:	80 83       	st	Z, r24
    40ca:	08 95       	ret

000040cc <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    40cc:	e4 e6       	ldi	r30, 0x64	; 100
    40ce:	f0 e0       	ldi	r31, 0x00	; 0
    40d0:	80 81       	ld	r24, Z
    40d2:	8f 7e       	andi	r24, 0xEF	; 239
    40d4:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    40d6:	ec ec       	ldi	r30, 0xCC	; 204
    40d8:	f0 e0       	ldi	r31, 0x00	; 0
    40da:	11 82       	std	Z+1, r1	; 0x01
    40dc:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    40de:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    40e0:	80 ec       	ldi	r24, 0xC0	; 192
    40e2:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    40e6:	88 e1       	ldi	r24, 0x18	; 24
    40e8:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    40ec:	81 e0       	ldi	r24, 0x01	; 1
    40ee:	90 e0       	ldi	r25, 0x00	; 0
    40f0:	91 83       	std	Z+1, r25	; 0x01
    40f2:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    40f4:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS high.
    40f6:	5d 9a       	sbi	0x0b, 5	; 11
    40f8:	08 95       	ret

000040fa <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    40fa:	5d 9a       	sbi	0x0b, 5	; 11
    40fc:	08 95       	ret

000040fe <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    40fe:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    4100:	5d 98       	cbi	0x0b, 5	; 11
    4102:	08 95       	ret

00004104 <TransferSdByte>:
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4104:	90 91 c8 00 	lds	r25, 0x00C8
    4108:	95 ff       	sbrs	r25, 5
    410a:	fc cf       	rjmp	.-8      	; 0x4104 <TransferSdByte>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    410c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4110:	80 91 c8 00 	lds	r24, 0x00C8
    4114:	87 ff       	sbrs	r24, 7
    4116:	fc cf       	rjmp	.-8      	; 0x4110 <TransferSdByte+0xc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4118:	80 91 ce 00 	lds	r24, 0x00CE
}
    411c:	08 95       	ret

0000411e <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    411e:	80 91 c8 00 	lds	r24, 0x00C8
    4122:	80 64       	ori	r24, 0x40	; 64
    4124:	80 93 c8 00 	sts	0x00C8, r24
	TransferSdByte(0xFF);	
    4128:	8f ef       	ldi	r24, 0xFF	; 255
    412a:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    412e:	80 91 c8 00 	lds	r24, 0x00C8
    4132:	86 ff       	sbrs	r24, 6
    4134:	fc cf       	rjmp	.-8      	; 0x412e <SendDummyByte+0x10>
		;
}
    4136:	08 95       	ret

00004138 <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    4138:	df 92       	push	r13
    413a:	ef 92       	push	r14
    413c:	ff 92       	push	r15
    413e:	0f 93       	push	r16
    4140:	1f 93       	push	r17
    4142:	cf 93       	push	r28
    4144:	df 93       	push	r29
    4146:	c8 2f       	mov	r28, r24
    4148:	04 2f       	mov	r16, r20
    414a:	f5 2e       	mov	r15, r21
    414c:	e6 2e       	mov	r14, r22
    414e:	d7 2e       	mov	r13, r23
	unsigned char
		i,
		response,
		tmpCrc;

	StartSdTransfer();		// Assert CS
    4150:	0e 94 7f 20 	call	0x40fe	; 0x40fe <StartSdTransfer>
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.
    4154:	8f ef       	ldi	r24, 0xFF	; 255
    4156:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    415a:	c7 ff       	sbrs	r28, 7
    415c:	31 c0       	rjmp	.+98     	; 0x41c0 <SendSdCommand+0x88>
	{
		TransferSdByte(0x40|CMD55);		// Put the start and transmission bits on the front of the command index
    415e:	87 e7       	ldi	r24, 0x77	; 119
    4160:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4164:	80 e0       	ldi	r24, 0x00	; 0
    4166:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    416a:	80 e0       	ldi	r24, 0x00	; 0
    416c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4170:	80 e0       	ldi	r24, 0x00	; 0
    4172:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		TransferSdByte(0);				// No argument					
    4176:	80 e0       	ldi	r24, 0x00	; 0
    4178:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		TransferSdByte(0x01);			// Send the CRC7 byte (and stop bit)
    417c:	81 e0       	ldi	r24, 0x01	; 1
    417e:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4182:	1a e0       	ldi	r17, 0x0A	; 10

		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    4184:	8f ef       	ldi	r24, 0xFF	; 255
    4186:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    418a:	d8 2f       	mov	r29, r24
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    418c:	8f 3f       	cpi	r24, 0xFF	; 255
    418e:	11 f4       	brne	.+4      	; 0x4194 <SendSdCommand+0x5c>
    4190:	11 50       	subi	r17, 0x01	; 1
    4192:	c1 f7       	brne	.-16     	; 0x4184 <SendSdCommand+0x4c>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4194:	90 91 c8 00 	lds	r25, 0x00C8
    4198:	90 64       	ori	r25, 0x40	; 64
    419a:	90 93 c8 00 	sts	0x00C8, r25
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
    419e:	8f ef       	ldi	r24, 0xFF	; 255
    41a0:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    41a4:	80 91 c8 00 	lds	r24, 0x00C8
    41a8:	86 ff       	sbrs	r24, 6
    41aa:	fc cf       	rjmp	.-8      	; 0x41a4 <SendSdCommand+0x6c>
			;

		if(response>1)				// Something wrong?
    41ac:	d2 30       	cpi	r29, 0x02	; 2
    41ae:	18 f0       	brcs	.+6      	; 0x41b6 <SendSdCommand+0x7e>
		{
			EndSdTransfer();	// Bring CS high
    41b0:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
			return(response);	// ACMD preambe returned something weird.  Bail.
    41b4:	34 c0       	rjmp	.+104    	; 0x421e <SendSdCommand+0xe6>
		}

		EndSdTransfer();	// Bring CS high
    41b6:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    41ba:	cf 77       	andi	r28, 0x7F	; 127
		StartSdTransfer();	// Assert CS
    41bc:	0e 94 7f 20 	call	0x40fe	; 0x40fe <StartSdTransfer>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    41c0:	8c 2f       	mov	r24, r28
    41c2:	80 64       	ori	r24, 0x40	; 64
    41c4:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    41c8:	8d 2d       	mov	r24, r13
    41ca:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    41ce:	8e 2d       	mov	r24, r14
    41d0:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    41d4:	8f 2d       	mov	r24, r15
    41d6:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	TransferSdByte((unsigned char)argument);			// LSB of argument
    41da:	80 2f       	mov	r24, r16
    41dc:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    41e0:	cc 23       	and	r28, r28
    41e2:	21 f0       	breq	.+8      	; 0x41ec <SendSdCommand+0xb4>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    41e4:	c8 30       	cpi	r28, 0x08	; 8
    41e6:	21 f0       	breq	.+8      	; 0x41f0 <SendSdCommand+0xb8>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)
    41e8:	81 e0       	ldi	r24, 0x01	; 1
    41ea:	03 c0       	rjmp	.+6      	; 0x41f2 <SendSdCommand+0xba>

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
	{
		tmpCrc=0x95;
    41ec:	85 e9       	ldi	r24, 0x95	; 149
    41ee:	01 c0       	rjmp	.+2      	; 0x41f2 <SendSdCommand+0xba>
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    41f0:	87 e8       	ldi	r24, 0x87	; 135
	}
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
    41f2:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    41f6:	cc 30       	cpi	r28, 0x0C	; 12
    41f8:	19 f4       	brne	.+6      	; 0x4200 <SendSdCommand+0xc8>
	{
		TransferSdByte(DUMMY_BYTE);		// Skip "stuff byte".
    41fa:	8f ef       	ldi	r24, 0xFF	; 255
    41fc:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    4200:	1a e0       	ldi	r17, 0x0A	; 10
	
	i=10;		// Give the SD card a 10 byte timeout in which to respond.
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    4202:	8f ef       	ldi	r24, 0xFF	; 255
    4204:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4208:	d8 2f       	mov	r29, r24
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    420a:	8f 3f       	cpi	r24, 0xFF	; 255
    420c:	11 f4       	brne	.+4      	; 0x4212 <SendSdCommand+0xda>
    420e:	11 50       	subi	r17, 0x01	; 1
    4210:	c1 f7       	brne	.-16     	; 0x4202 <SendSdCommand+0xca>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    4212:	c8 30       	cpi	r28, 0x08	; 8
    4214:	21 f0       	breq	.+8      	; 0x421e <SendSdCommand+0xe6>
    4216:	ca 33       	cpi	r28, 0x3A	; 58
    4218:	11 f0       	breq	.+4      	; 0x421e <SendSdCommand+0xe6>
	{
		SendDummyByte();	
    421a:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    421e:	8d 2f       	mov	r24, r29
    4220:	df 91       	pop	r29
    4222:	cf 91       	pop	r28
    4224:	1f 91       	pop	r17
    4226:	0f 91       	pop	r16
    4228:	ff 90       	pop	r15
    422a:	ef 90       	pop	r14
    422c:	df 90       	pop	r13
    422e:	08 95       	ret

00004230 <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    4230:	ef 92       	push	r14
    4232:	ff 92       	push	r15
    4234:	0f 93       	push	r16
    4236:	1f 93       	push	r17
    4238:	cf 93       	push	r28
    423a:	df 93       	push	r29
    423c:	00 d0       	rcall	.+0      	; 0x423e <SdHandshake+0xe>
    423e:	00 d0       	rcall	.+0      	; 0x4240 <SdHandshake+0x10>
    4240:	1f 92       	push	r1
    4242:	cd b7       	in	r28, 0x3d	; 61
    4244:	de b7       	in	r29, 0x3e	; 62
	bool
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
    4246:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
    424a:	14 e1       	ldi	r17, 0x14	; 20
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    424c:	80 91 c8 00 	lds	r24, 0x00C8
    4250:	80 64       	ori	r24, 0x40	; 64
    4252:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
    4256:	8f ef       	ldi	r24, 0xFF	; 255
    4258:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    425c:	11 50       	subi	r17, 0x01	; 1
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    425e:	b1 f7       	brne	.-20     	; 0x424c <SdHandshake+0x1c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4260:	80 91 c8 00 	lds	r24, 0x00C8
    4264:	86 ff       	sbrs	r24, 6
    4266:	fc cf       	rjmp	.-8      	; 0x4260 <SdHandshake+0x30>


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
    4268:	0e 94 7f 20 	call	0x40fe	; 0x40fe <StartSdTransfer>
    426c:	00 e0       	ldi	r16, 0x00	; 0
    426e:	12 e0       	ldi	r17, 0x02	; 2
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4270:	80 91 c8 00 	lds	r24, 0x00C8
    4274:	80 64       	ori	r24, 0x40	; 64
    4276:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(0xFF);	
    427a:	8f ef       	ldi	r24, 0xFF	; 255
    427c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4280:	01 50       	subi	r16, 0x01	; 1
    4282:	11 09       	sbc	r17, r1

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    4284:	a9 f7       	brne	.-22     	; 0x4270 <SdHandshake+0x40>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4286:	80 91 c8 00 	lds	r24, 0x00C8
    428a:	86 ff       	sbrs	r24, 6
    428c:	fc cf       	rjmp	.-8      	; 0x4286 <SdHandshake+0x56>
		;
	EndSdTransfer();
    428e:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    4292:	40 e0       	ldi	r20, 0x00	; 0
    4294:	50 e0       	ldi	r21, 0x00	; 0
    4296:	ba 01       	movw	r22, r20
    4298:	80 e0       	ldi	r24, 0x00	; 0
    429a:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    429e:	80 91 c8 00 	lds	r24, 0x00C8
    42a2:	86 ff       	sbrs	r24, 6
    42a4:	fc cf       	rjmp	.-8      	; 0x429e <SdHandshake+0x6e>
		;
	EndSdTransfer();
    42a6:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    42aa:	40 e0       	ldi	r20, 0x00	; 0
    42ac:	50 e0       	ldi	r21, 0x00	; 0
    42ae:	ba 01       	movw	r22, r20
    42b0:	80 e0       	ldi	r24, 0x00	; 0
    42b2:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    42b6:	81 30       	cpi	r24, 0x01	; 1
    42b8:	11 f0       	breq	.+4      	; 0x42be <SdHandshake+0x8e>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
    42ba:	80 e0       	ldi	r24, 0x00	; 0
    42bc:	b1 c0       	rjmp	.+354    	; 0x4420 <SdHandshake+0x1f0>
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high
    42be:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    42c2:	4a ea       	ldi	r20, 0xAA	; 170
    42c4:	51 e0       	ldi	r21, 0x01	; 1
    42c6:	60 e0       	ldi	r22, 0x00	; 0
    42c8:	70 e0       	ldi	r23, 0x00	; 0
    42ca:	88 e0       	ldi	r24, 0x08	; 8
    42cc:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    42d0:	81 30       	cpi	r24, 0x01	; 1
    42d2:	09 f0       	breq	.+2      	; 0x42d6 <SdHandshake+0xa6>
    42d4:	6e c0       	rjmp	.+220    	; 0x43b2 <SdHandshake+0x182>
    42d6:	8e 01       	movw	r16, r28
    42d8:	0f 5f       	subi	r16, 0xFF	; 255
    42da:	1f 4f       	sbci	r17, 0xFF	; 255
//-----------------------------------------------------------------------
// SD SPI Mode and Initialization Functions
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

bool SdHandshake(void)
    42dc:	7e 01       	movw	r14, r28
    42de:	85 e0       	ldi	r24, 0x05	; 5
    42e0:	e8 0e       	add	r14, r24
    42e2:	f1 1c       	adc	r15, r1

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    42e4:	8f ef       	ldi	r24, 0xFF	; 255
    42e6:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    42ea:	f8 01       	movw	r30, r16
    42ec:	81 93       	st	Z+, r24
    42ee:	8f 01       	movw	r16, r30
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    42f0:	ee 15       	cp	r30, r14
    42f2:	ff 05       	cpc	r31, r15
    42f4:	b9 f7       	brne	.-18     	; 0x42e4 <SdHandshake+0xb4>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    42f6:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
			EndSdTransfer();		// Bring CS high
    42fa:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    42fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4300:	81 30       	cpi	r24, 0x01	; 1
    4302:	d9 f6       	brne	.-74     	; 0x42ba <SdHandshake+0x8a>
    4304:	8c 81       	ldd	r24, Y+4	; 0x04
    4306:	8a 3a       	cpi	r24, 0xAA	; 170
    4308:	c1 f6       	brne	.-80     	; 0x42ba <SdHandshake+0x8a>
			{				
				SetTimer(TIMER_SD,SECOND);
    430a:	64 ec       	ldi	r22, 0xC4	; 196
    430c:	74 e0       	ldi	r23, 0x04	; 4
    430e:	83 e0       	ldi	r24, 0x03	; 3
    4310:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    4314:	04 c0       	rjmp	.+8      	; 0x431e <SdHandshake+0xee>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    4316:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
    431a:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    431e:	83 e0       	ldi	r24, 0x03	; 3
    4320:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4324:	88 23       	and	r24, r24
    4326:	31 f0       	breq	.+12     	; 0x4334 <SdHandshake+0x104>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    4328:	83 e0       	ldi	r24, 0x03	; 3
    432a:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    432e:	88 23       	and	r24, r24
    4330:	81 f0       	breq	.+32     	; 0x4352 <SdHandshake+0x122>
    4332:	c3 cf       	rjmp	.-122    	; 0x42ba <SdHandshake+0x8a>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    4334:	40 e0       	ldi	r20, 0x00	; 0
    4336:	50 e0       	ldi	r21, 0x00	; 0
    4338:	ba 01       	movw	r22, r20
    433a:	89 ea       	ldi	r24, 0xA9	; 169
    433c:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    4340:	81 11       	cpse	r24, r1
    4342:	e9 cf       	rjmp	.-46     	; 0x4316 <SdHandshake+0xe6>
    4344:	f1 cf       	rjmp	.-30     	; 0x4328 <SdHandshake+0xf8>
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    4346:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    434a:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <HandleSoftclock>
						EndSdTransfer();		// Bring CS high.
    434e:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4352:	83 e0       	ldi	r24, 0x03	; 3
    4354:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4358:	88 23       	and	r24, r24
    435a:	31 f0       	breq	.+12     	; 0x4368 <SdHandshake+0x138>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    435c:	83 e0       	ldi	r24, 0x03	; 3
    435e:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4362:	88 23       	and	r24, r24
    4364:	51 f0       	breq	.+20     	; 0x437a <SdHandshake+0x14a>
    4366:	a9 cf       	rjmp	.-174    	; 0x42ba <SdHandshake+0x8a>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    4368:	40 e0       	ldi	r20, 0x00	; 0
    436a:	50 e0       	ldi	r21, 0x00	; 0
    436c:	ba 01       	movw	r22, r20
    436e:	8a e3       	ldi	r24, 0x3A	; 58
    4370:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    4374:	81 11       	cpse	r24, r1
    4376:	e7 cf       	rjmp	.-50     	; 0x4346 <SdHandshake+0x116>
    4378:	f1 cf       	rjmp	.-30     	; 0x435c <SdHandshake+0x12c>
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    437a:	8f ef       	ldi	r24, 0xFF	; 255
    437c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4380:	8f ef       	ldi	r24, 0xFF	; 255
    4382:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4386:	8f ef       	ldi	r24, 0xFF	; 255
    4388:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    438c:	8f ef       	ldi	r24, 0xFF	; 255
    438e:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    4392:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
						EndSdTransfer();			// Bring CS high.
    4396:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    439a:	40 e0       	ldi	r20, 0x00	; 0
    439c:	52 e0       	ldi	r21, 0x02	; 2
    439e:	60 e0       	ldi	r22, 0x00	; 0
    43a0:	70 e0       	ldi	r23, 0x00	; 0
    43a2:	80 e1       	ldi	r24, 0x10	; 16
    43a4:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
						EndSdTransfer();						// Bring CS high.
    43a8:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
						SendDummyByte();						
    43ac:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
    43b0:	36 c0       	rjmp	.+108    	; 0x441e <SdHandshake+0x1ee>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    43b2:	0e 94 8f 20 	call	0x411e	; 0x411e <SendDummyByte>
			EndSdTransfer();					// Bring CS high
    43b6:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    43ba:	40 e0       	ldi	r20, 0x00	; 0
    43bc:	50 e0       	ldi	r21, 0x00	; 0
    43be:	ba 01       	movw	r22, r20
    43c0:	89 ea       	ldi	r24, 0xA9	; 169
    43c2:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    43c6:	82 30       	cpi	r24, 0x02	; 2
    43c8:	08 f0       	brcs	.+2      	; 0x43cc <SdHandshake+0x19c>
    43ca:	77 cf       	rjmp	.-274    	; 0x42ba <SdHandshake+0x8a>
			{
				EndSdTransfer();			// Bring CS high.
    43cc:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
				SetTimer(TIMER_SD,SECOND);
    43d0:	64 ec       	ldi	r22, 0xC4	; 196
    43d2:	74 e0       	ldi	r23, 0x04	; 4
    43d4:	83 e0       	ldi	r24, 0x03	; 3
    43d6:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    43da:	04 c0       	rjmp	.+8      	; 0x43e4 <SdHandshake+0x1b4>
				{
					HandleSoftclock();	// Keep the timer timing.
    43dc:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <HandleSoftclock>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    43e0:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    43e4:	83 e0       	ldi	r24, 0x03	; 3
    43e6:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    43ea:	88 23       	and	r24, r24
    43ec:	31 f0       	breq	.+12     	; 0x43fa <SdHandshake+0x1ca>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    43ee:	83 e0       	ldi	r24, 0x03	; 3
    43f0:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    43f4:	81 11       	cpse	r24, r1
    43f6:	61 cf       	rjmp	.-318    	; 0x42ba <SdHandshake+0x8a>
    43f8:	09 c0       	rjmp	.+18     	; 0x440c <SdHandshake+0x1dc>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    43fa:	40 e0       	ldi	r20, 0x00	; 0
    43fc:	50 e0       	ldi	r21, 0x00	; 0
    43fe:	ba 01       	movw	r22, r20
    4400:	89 ea       	ldi	r24, 0xA9	; 169
    4402:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    4406:	81 11       	cpse	r24, r1
    4408:	e9 cf       	rjmp	.-46     	; 0x43dc <SdHandshake+0x1ac>
    440a:	f1 cf       	rjmp	.-30     	; 0x43ee <SdHandshake+0x1be>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    440c:	40 e0       	ldi	r20, 0x00	; 0
    440e:	52 e0       	ldi	r21, 0x02	; 2
    4410:	60 e0       	ldi	r22, 0x00	; 0
    4412:	70 e0       	ldi	r23, 0x00	; 0
    4414:	80 e1       	ldi	r24, 0x10	; 16
    4416:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
					EndSdTransfer();						// Bring CS high.
    441a:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					cardValid=true;							// SDC v1 card, good to go
    441e:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}

	EndSdTransfer();	// Bring CS high
    4420:	8d 83       	std	Y+5, r24	; 0x05
    4422:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    4426:	8d 81       	ldd	r24, Y+5	; 0x05
    4428:	0f 90       	pop	r0
    442a:	0f 90       	pop	r0
    442c:	0f 90       	pop	r0
    442e:	0f 90       	pop	r0
    4430:	0f 90       	pop	r0
    4432:	df 91       	pop	r29
    4434:	cf 91       	pop	r28
    4436:	1f 91       	pop	r17
    4438:	0f 91       	pop	r16
    443a:	ff 90       	pop	r15
    443c:	ef 90       	pop	r14
    443e:	08 95       	ret

00004440 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    4440:	ab 01       	movw	r20, r22
    4442:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4444:	89 e0       	ldi	r24, 0x09	; 9
    4446:	44 0f       	add	r20, r20
    4448:	55 1f       	adc	r21, r21
    444a:	66 1f       	adc	r22, r22
    444c:	77 1f       	adc	r23, r23
    444e:	8a 95       	dec	r24
    4450:	d1 f7       	brne	.-12     	; 0x4446 <SdBeginSingleBlockRead+0x6>

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    4452:	81 e1       	ldi	r24, 0x11	; 17
    4454:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    4458:	91 e0       	ldi	r25, 0x01	; 1
    445a:	81 11       	cpse	r24, r1
    445c:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    445e:	89 2f       	mov	r24, r25
    4460:	08 95       	ret

00004462 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    4462:	ab 01       	movw	r20, r22
    4464:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4466:	99 e0       	ldi	r25, 0x09	; 9
    4468:	44 0f       	add	r20, r20
    446a:	55 1f       	adc	r21, r21
    446c:	66 1f       	adc	r22, r22
    446e:	77 1f       	adc	r23, r23
    4470:	9a 95       	dec	r25
    4472:	d1 f7       	brne	.-12     	; 0x4468 <SdBeginSingleBlockWrite+0x6>

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    4474:	88 e1       	ldi	r24, 0x18	; 24
    4476:	0e 94 9c 20 	call	0x4138	; 0x4138 <SendSdCommand>
    447a:	91 e0       	ldi	r25, 0x01	; 1
    447c:	81 11       	cpse	r24, r1
    447e:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    4480:	89 2f       	mov	r24, r25
    4482:	08 95       	ret

00004484 <main>:
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    4484:	cf ef       	ldi	r28, 0xFF	; 255
    4486:	c0 93 64 00 	sts	0x0064, r28
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    448a:	85 b7       	in	r24, 0x35	; 53
    448c:	8f 7e       	andi	r24, 0xEF	; 239
    448e:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    4490:	8f ee       	ldi	r24, 0xEF	; 239
    4492:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    4494:	88 e0       	ldi	r24, 0x08	; 8
    4496:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    4498:	80 e8       	ldi	r24, 0x80	; 128
    449a:	8a b9       	out	0x0a, r24	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    449c:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    449e:	96 e0       	ldi	r25, 0x06	; 6
    44a0:	92 b9       	out	0x02, r25	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    44a2:	9e e3       	ldi	r25, 0x3E	; 62
    44a4:	91 b9       	out	0x01, r25	; 1

	DDRB=0xFF;			// Latch port to OP.
    44a6:	c4 b9       	out	0x04, r28	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    44a8:	85 b9       	out	0x05, r24	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    44aa:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    44ac:	c4 b9       	out	0x04, r28	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    44ae:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    44b0:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    44b2:	0e 94 66 20 	call	0x40cc	; 0x40cc <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    44b6:	66 e2       	ldi	r22, 0x26	; 38
    44b8:	70 e0       	ldi	r23, 0x00	; 0
    44ba:	81 e0       	ldi	r24, 0x01	; 1
    44bc:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    44c0:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    44c2:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    44c4:	80 b1       	in	r24, 0x00	; 0
    44c6:	80 7c       	andi	r24, 0xC0	; 192
    44c8:	80 93 7c 05 	sts	0x057C, r24
	encoderValue=0;							// zero our relative position.
    44cc:	10 92 6b 05 	sts	0x056B, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    44d0:	10 92 5d 05 	sts	0x055D, r1
	ledBlinkMask=0;
    44d4:	10 92 7a 05 	sts	0x057A, r1
	WriteLedLatch(0);	// ...send the LED value to the latch.
    44d8:	80 e0       	ldi	r24, 0x00	; 0
    44da:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    44de:	0e 94 dd 1e 	call	0x3dba	; 0x3dba <InitMidi>
	InitUart0();
    44e2:	0e 94 27 1e 	call	0x3c4e	; 0x3c4e <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    44e6:	80 91 64 00 	lds	r24, 0x0064
    44ea:	8e 7f       	andi	r24, 0xFE	; 254
    44ec:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    44f0:	80 e6       	ldi	r24, 0x60	; 96
    44f2:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    44f6:	81 e0       	ldi	r24, 0x01	; 1
    44f8:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    44fc:	85 e9       	ldi	r24, 0x95	; 149
    44fe:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    4502:	80 91 7a 00 	lds	r24, 0x007A
    4506:	80 64       	ori	r24, 0x40	; 64
    4508:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    450c:	80 91 64 00 	lds	r24, 0x0064
    4510:	8f 7d       	andi	r24, 0xDF	; 223
    4512:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    4516:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    451a:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    451c:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    451e:	c5 bb       	out	0x15, r28	; 21
	systemTicks=0;
    4520:	10 92 2d 06 	sts	0x062D, r1
    4524:	10 92 2c 06 	sts	0x062C, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    4528:	83 e0       	ldi	r24, 0x03	; 3
    452a:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    452c:	80 91 64 00 	lds	r24, 0x0064
    4530:	87 7f       	andi	r24, 0xF7	; 247
    4532:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    4536:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    453a:	8f ef       	ldi	r24, 0xFF	; 255
    453c:	9f ef       	ldi	r25, 0xFF	; 255
    453e:	90 93 89 00 	sts	0x0089, r25
    4542:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    4546:	90 93 8b 00 	sts	0x008B, r25
    454a:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    454e:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    4552:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    4556:	10 92 85 00 	sts	0x0085, r1
    455a:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    455e:	c6 bb       	out	0x16, r28	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    4560:	10 92 57 05 	sts	0x0557, r1
	keyState=0;
    4564:	10 92 58 05 	sts	0x0558, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    4568:	10 92 59 05 	sts	0x0559, r1
	cardDetect=false;
    456c:	10 92 5a 05 	sts	0x055A, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    4570:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4572:	8b e7       	ldi	r24, 0x7B	; 123
    4574:	9e e0       	ldi	r25, 0x0E	; 14
    4576:	90 93 e5 05 	sts	0x05E5, r25
    457a:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    457e:	10 92 5b 05 	sts	0x055B, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    4582:	cc 24       	eor	r12, r12
    4584:	ca 94       	dec	r12
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    4586:	ee 24       	eor	r14, r14
    4588:	e3 94       	inc	r14
    458a:	f1 2c       	mov	r15, r1
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    458c:	c0 e0       	ldi	r28, 0x00	; 0
    458e:	d2 e0       	ldi	r29, 0x02	; 2
				TransferSdByte('W');				// Send flag that this is a WTPA card
				TransferSdByte('T');
				TransferSdByte('P');
				TransferSdByte('A');

				bytesLeftInBlock-=4;
    4590:	6c e0       	ldi	r22, 0x0C	; 12
    4592:	36 2e       	mov	r3, r22
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4594:	77 e0       	ldi	r23, 0x07	; 7
    4596:	97 2e       	mov	r9, r23
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
						;

					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    4598:	eb e0       	ldi	r30, 0x0B	; 11
    459a:	8e 2e       	mov	r8, r30

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    459c:	fe e0       	ldi	r31, 0x0E	; 14
    459e:	df 2e       	mov	r13, r31
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    45a0:	ad e0       	ldi	r26, 0x0D	; 13
    45a2:	ba 2e       	mov	r11, r26
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    45a4:	b4 e0       	ldi	r27, 0x04	; 4
    45a6:	2b 2e       	mov	r2, r27
				}
				if(theByte==0xFE)	// Got a start token!
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    45a8:	1a e0       	ldi	r17, 0x0A	; 10
    45aa:	a1 2e       	mov	r10, r17
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    45ac:	81 e0       	ldi	r24, 0x01	; 1
    45ae:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    45b2:	88 23       	and	r24, r24
    45b4:	d9 f0       	breq	.+54     	; 0x45ec <main+0x168>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    45b6:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    45b8:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    45ba:	c5 b8       	out	0x05, r12	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    45bc:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    45be:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    45c0:	00 00       	nop
		asm volatile("nop"::);
    45c2:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    45c4:	83 b1       	in	r24, 0x03	; 3
    45c6:	80 95       	com	r24
    45c8:	80 93 58 05 	sts	0x0558, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    45cc:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    45ce:	c4 b8       	out	0x04, r12	; 4
		SREG=sreg;					// Stop tying up interrupts
    45d0:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    45d2:	35 99       	sbic	0x06, 5	; 6
    45d4:	04 c0       	rjmp	.+8      	; 0x45de <main+0x15a>
		{
			cardDetect=true;
    45d6:	81 e0       	ldi	r24, 0x01	; 1
    45d8:	80 93 5a 05 	sts	0x055A, r24
    45dc:	02 c0       	rjmp	.+4      	; 0x45e2 <main+0x15e>
		}
		else
		{
			cardDetect=false;
    45de:	10 92 5a 05 	sts	0x055A, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
    45e2:	66 e2       	ldi	r22, 0x26	; 38
    45e4:	70 e0       	ldi	r23, 0x00	; 0
    45e6:	81 e0       	ldi	r24, 0x01	; 1
    45e8:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    45ec:	90 91 58 05 	lds	r25, 0x0558
    45f0:	80 91 7d 05 	lds	r24, 0x057D
    45f4:	80 95       	com	r24
    45f6:	89 23       	and	r24, r25
    45f8:	80 93 57 05 	sts	0x0557, r24
	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been held for more than one debounce loop.
    45fc:	80 95       	com	r24
    45fe:	89 23       	and	r24, r25
    4600:	80 93 6a 05 	sts	0x056A, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    4604:	90 93 7d 05 	sts	0x057D, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;

	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    4608:	20 91 2c 06 	lds	r18, 0x062C
    460c:	30 91 2d 06 	lds	r19, 0x062D
    4610:	80 91 7e 05 	lds	r24, 0x057E
    4614:	90 91 7f 05 	lds	r25, 0x057F
    4618:	28 17       	cp	r18, r24
    461a:	39 07       	cpc	r19, r25
    461c:	c9 f1       	breq	.+114    	; 0x4690 <main+0x20c>
	{
		lastEncTime=systemTicks;					// update last read time.
    461e:	80 91 2c 06 	lds	r24, 0x062C
    4622:	90 91 2d 06 	lds	r25, 0x062D
    4626:	90 93 7f 05 	sts	0x057F, r25
    462a:	80 93 7e 05 	sts	0x057E, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    462e:	80 b1       	in	r24, 0x00	; 0
    4630:	80 7c       	andi	r24, 0xC0	; 192
    4632:	80 93 7c 05 	sts	0x057C, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    4636:	90 91 80 05 	lds	r25, 0x0580
    463a:	89 17       	cp	r24, r25
    463c:	49 f1       	breq	.+82     	; 0x4690 <main+0x20c>
		{
			if(encoderState==ENC_POS_A)
    463e:	81 11       	cpse	r24, r1
    4640:	06 c0       	rjmp	.+12     	; 0x464e <main+0x1ca>
			{
				if(lastEncoderState==ENC_POS_D)
    4642:	90 38       	cpi	r25, 0x80	; 128
    4644:	09 f4       	brne	.+2      	; 0x4648 <main+0x1c4>
    4646:	17 c0       	rjmp	.+46     	; 0x4676 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_B)
    4648:	90 34       	cpi	r25, 0x40	; 64
    464a:	01 f5       	brne	.+64     	; 0x468c <main+0x208>
    464c:	1a c0       	rjmp	.+52     	; 0x4682 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_B)
    464e:	80 34       	cpi	r24, 0x40	; 64
    4650:	31 f4       	brne	.+12     	; 0x465e <main+0x1da>
			{
				if(lastEncoderState==ENC_POS_A)
    4652:	91 11       	cpse	r25, r1
    4654:	01 c0       	rjmp	.+2      	; 0x4658 <main+0x1d4>
    4656:	0f c0       	rjmp	.+30     	; 0x4676 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_C)
    4658:	90 3c       	cpi	r25, 0xC0	; 192
    465a:	c1 f4       	brne	.+48     	; 0x468c <main+0x208>
    465c:	12 c0       	rjmp	.+36     	; 0x4682 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_C)
    465e:	80 3c       	cpi	r24, 0xC0	; 192
    4660:	31 f4       	brne	.+12     	; 0x466e <main+0x1ea>
			{
				if(lastEncoderState==ENC_POS_B)
    4662:	90 34       	cpi	r25, 0x40	; 64
    4664:	09 f4       	brne	.+2      	; 0x4668 <main+0x1e4>
    4666:	07 c0       	rjmp	.+14     	; 0x4676 <main+0x1f2>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_D)
    4668:	90 38       	cpi	r25, 0x80	; 128
    466a:	81 f4       	brne	.+32     	; 0x468c <main+0x208>
    466c:	0a c0       	rjmp	.+20     	; 0x4682 <main+0x1fe>
				{
//					encoderValue--;
					encoderValue++;
				}
			}
			else if(encoderState==ENC_POS_D)
    466e:	80 38       	cpi	r24, 0x80	; 128
    4670:	69 f4       	brne	.+26     	; 0x468c <main+0x208>
			{
				if(lastEncoderState==ENC_POS_C)
    4672:	90 3c       	cpi	r25, 0xC0	; 192
    4674:	21 f4       	brne	.+8      	; 0x467e <main+0x1fa>
				{
//					encoderValue++;
					encoderValue--;
    4676:	90 91 6b 05 	lds	r25, 0x056B
    467a:	91 50       	subi	r25, 0x01	; 1
    467c:	05 c0       	rjmp	.+10     	; 0x4688 <main+0x204>
				}
				else if(lastEncoderState==ENC_POS_A)
    467e:	91 11       	cpse	r25, r1
    4680:	05 c0       	rjmp	.+10     	; 0x468c <main+0x208>
				{
//					encoderValue--;
					encoderValue++;
    4682:	90 91 6b 05 	lds	r25, 0x056B
    4686:	9f 5f       	subi	r25, 0xFF	; 255
    4688:	90 93 6b 05 	sts	0x056B, r25
				}
			}

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    468c:	80 93 80 05 	sts	0x0580, r24

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    4690:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    4694:	80 91 7a 05 	lds	r24, 0x057A
    4698:	88 23       	and	r24, r24
    469a:	e1 f1       	breq	.+120    	; 0x4714 <main+0x290>
    469c:	82 e0       	ldi	r24, 0x02	; 2
    469e:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    46a2:	88 23       	and	r24, r24
    46a4:	b9 f1       	breq	.+110    	; 0x4714 <main+0x290>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    46a6:	20 91 7a 05 	lds	r18, 0x057A
    46aa:	30 e0       	ldi	r19, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    46ac:	f0 91 81 05 	lds	r31, 0x0581
    46b0:	e0 91 5d 05 	lds	r30, 0x055D
    46b4:	80 e0       	ldi	r24, 0x00	; 0
    46b6:	90 e0       	ldi	r25, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    46b8:	b9 01       	movw	r22, r18
    46ba:	08 2e       	mov	r0, r24
    46bc:	02 c0       	rjmp	.+4      	; 0x46c2 <main+0x23e>
    46be:	75 95       	asr	r23
    46c0:	67 95       	ror	r22
    46c2:	0a 94       	dec	r0
    46c4:	e2 f7       	brpl	.-8      	; 0x46be <main+0x23a>
    46c6:	60 ff       	sbrs	r22, 0
    46c8:	0e c0       	rjmp	.+28     	; 0x46e6 <main+0x262>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    46ca:	b7 01       	movw	r22, r14
    46cc:	08 2e       	mov	r0, r24
    46ce:	02 c0       	rjmp	.+4      	; 0x46d4 <main+0x250>
    46d0:	66 0f       	add	r22, r22
    46d2:	77 1f       	adc	r23, r23
    46d4:	0a 94       	dec	r0
    46d6:	e2 f7       	brpl	.-8      	; 0x46d0 <main+0x24c>
    46d8:	ab 01       	movw	r20, r22
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    46da:	ff 23       	and	r31, r31
    46dc:	11 f0       	breq	.+4      	; 0x46e2 <main+0x25e>
				{
					ledOnOffMask|=(1<<i);
    46de:	e6 2b       	or	r30, r22
    46e0:	02 c0       	rjmp	.+4      	; 0x46e6 <main+0x262>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    46e2:	40 95       	com	r20
    46e4:	e4 23       	and	r30, r20
    46e6:	01 96       	adiw	r24, 0x01	; 1
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    46e8:	88 30       	cpi	r24, 0x08	; 8
    46ea:	91 05       	cpc	r25, r1
    46ec:	29 f7       	brne	.-54     	; 0x46b8 <main+0x234>
    46ee:	e0 93 5d 05 	sts	0x055D, r30
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    46f2:	81 e0       	ldi	r24, 0x01	; 1
    46f4:	90 91 81 05 	lds	r25, 0x0581
    46f8:	91 11       	cpse	r25, r1
    46fa:	80 e0       	ldi	r24, 0x00	; 0
    46fc:	80 93 81 05 	sts	0x0581, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    4700:	68 e9       	ldi	r22, 0x98	; 152
    4702:	70 e0       	ldi	r23, 0x00	; 0
    4704:	82 e0       	ldi	r24, 0x02	; 2
    4706:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    470a:	80 91 5d 05 	lds	r24, 0x055D
    470e:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
    4712:	0b c0       	rjmp	.+22     	; 0x472a <main+0x2a6>
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    4714:	10 91 5d 05 	lds	r17, 0x055D
    4718:	80 91 82 05 	lds	r24, 0x0582
    471c:	81 17       	cp	r24, r17
    471e:	29 f0       	breq	.+10     	; 0x472a <main+0x2a6>
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
    4720:	81 2f       	mov	r24, r17
    4722:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    4726:	10 93 82 05 	sts	0x0582, r17
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    472a:	90 91 5a 05 	lds	r25, 0x055A
    472e:	80 91 59 05 	lds	r24, 0x0559
    4732:	91 11       	cpse	r25, r1
    4734:	06 c0       	rjmp	.+12     	; 0x4742 <main+0x2be>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    4736:	88 23       	and	r24, r24
    4738:	09 f4       	brne	.+2      	; 0x473c <main+0x2b8>
    473a:	b5 c4       	rjmp	.+2410   	; 0x50a6 <main+0xc22>
		{
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
    473c:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <ResetSdCard>
    4740:	b2 c4       	rjmp	.+2404   	; 0x50a6 <main+0xc22>
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    4742:	86 30       	cpi	r24, 0x06	; 6
    4744:	09 f4       	brne	.+2      	; 0x4748 <main+0x2c4>
    4746:	4b c2       	rjmp	.+1174   	; 0x4bde <main+0x75a>
    4748:	80 f4       	brcc	.+32     	; 0x476a <main+0x2e6>
    474a:	82 30       	cpi	r24, 0x02	; 2
    474c:	09 f4       	brne	.+2      	; 0x4750 <main+0x2cc>
    474e:	d3 c0       	rjmp	.+422    	; 0x48f6 <main+0x472>
    4750:	30 f4       	brcc	.+12     	; 0x475e <main+0x2da>
    4752:	88 23       	and	r24, r24
    4754:	e9 f0       	breq	.+58     	; 0x4790 <main+0x30c>
    4756:	81 30       	cpi	r24, 0x01	; 1
    4758:	09 f0       	breq	.+2      	; 0x475c <main+0x2d8>
    475a:	a5 c4       	rjmp	.+2378   	; 0x50a6 <main+0xc22>
    475c:	22 c0       	rjmp	.+68     	; 0x47a2 <main+0x31e>
    475e:	84 30       	cpi	r24, 0x04	; 4
    4760:	09 f4       	brne	.+2      	; 0x4764 <main+0x2e0>
    4762:	b8 c1       	rjmp	.+880    	; 0x4ad4 <main+0x650>
    4764:	08 f0       	brcs	.+2      	; 0x4768 <main+0x2e4>
    4766:	f2 c1       	rjmp	.+996    	; 0x4b4c <main+0x6c8>
    4768:	32 c1       	rjmp	.+612    	; 0x49ce <main+0x54a>
    476a:	8a 30       	cpi	r24, 0x0A	; 10
    476c:	09 f4       	brne	.+2      	; 0x4770 <main+0x2ec>
    476e:	57 c3       	rjmp	.+1710   	; 0x4e1e <main+0x99a>
    4770:	30 f4       	brcc	.+12     	; 0x477e <main+0x2fa>
    4772:	88 30       	cpi	r24, 0x08	; 8
    4774:	09 f4       	brne	.+2      	; 0x4778 <main+0x2f4>
    4776:	bc c2       	rjmp	.+1400   	; 0x4cf0 <main+0x86c>
    4778:	08 f0       	brcs	.+2      	; 0x477c <main+0x2f8>
    477a:	ce c2       	rjmp	.+1436   	; 0x4d18 <main+0x894>
    477c:	81 c2       	rjmp	.+1282   	; 0x4c80 <main+0x7fc>
    477e:	8c 30       	cpi	r24, 0x0C	; 12
    4780:	09 f4       	brne	.+2      	; 0x4784 <main+0x300>
    4782:	2c c4       	rjmp	.+2136   	; 0x4fdc <main+0xb58>
    4784:	08 f4       	brcc	.+2      	; 0x4788 <main+0x304>
    4786:	e0 c3       	rjmp	.+1984   	; 0x4f48 <main+0xac4>
    4788:	8d 30       	cpi	r24, 0x0D	; 13
    478a:	09 f0       	breq	.+2      	; 0x478e <main+0x30a>
    478c:	8c c4       	rjmp	.+2328   	; 0x50a6 <main+0xc22>
    478e:	47 c4       	rjmp	.+2190   	; 0x501e <main+0xb9a>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    4790:	81 e0       	ldi	r24, 0x01	; 1
    4792:	80 93 59 05 	sts	0x0559, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    4796:	64 ec       	ldi	r22, 0xC4	; 196
    4798:	74 e0       	ldi	r23, 0x04	; 4
    479a:	83 e0       	ldi	r24, 0x03	; 3
    479c:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
    47a0:	82 c4       	rjmp	.+2308   	; 0x50a6 <main+0xc22>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    47a2:	83 e0       	ldi	r24, 0x03	; 3
    47a4:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    47a8:	88 23       	and	r24, r24
    47aa:	09 f4       	brne	.+2      	; 0x47ae <main+0x32a>
    47ac:	7c c4       	rjmp	.+2296   	; 0x50a6 <main+0xc22>
			{
				sdPlaybackQueued=false;
    47ae:	10 92 79 05 	sts	0x0579, r1
				sdAbortRead=false;
    47b2:	10 92 76 05 	sts	0x0576, r1

				if(SdHandshake()==true)	// Give it a shot...
    47b6:	0e 94 18 21 	call	0x4230	; 0x4230 <SdHandshake>
    47ba:	81 30       	cpi	r24, 0x01	; 1
    47bc:	09 f0       	breq	.+2      	; 0x47c0 <main+0x33c>
    47be:	99 c0       	rjmp	.+306    	; 0x48f2 <main+0x46e>
	// Are the first 4 chars WTPA?
	// Stop reading, return true or false based on answer.

	filesystemGood=true;					// Start assuming a good filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    47c0:	60 e0       	ldi	r22, 0x00	; 0
    47c2:	70 e0       	ldi	r23, 0x00	; 0
    47c4:	cb 01       	movw	r24, r22
    47c6:	0e 94 20 22 	call	0x4440	; 0x4440 <SdBeginSingleBlockRead>
    47ca:	81 30       	cpi	r24, 0x01	; 1
    47cc:	09 f0       	breq	.+2      	; 0x47d0 <main+0x34c>
    47ce:	58 c0       	rjmp	.+176    	; 0x4880 <main+0x3fc>
 		// Tue Jun 21 17:11:28 EDT 2011
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    47d0:	6a e7       	ldi	r22, 0x7A	; 122
    47d2:	70 e0       	ldi	r23, 0x00	; 0
    47d4:	83 e0       	ldi	r24, 0x03	; 3
    47d6:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
    47da:	02 c0       	rjmp	.+4      	; 0x47e0 <main+0x35c>

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    47dc:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <HandleSoftclock>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    47e0:	83 e0       	ldi	r24, 0x03	; 3
    47e2:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    47e6:	88 23       	and	r24, r24
    47e8:	51 f0       	breq	.+20     	; 0x47fe <main+0x37a>
		{
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
    47ea:	8f ef       	ldi	r24, 0xFF	; 255
    47ec:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    47f0:	18 2f       	mov	r17, r24
		if(theByte!='W')
		{
			filesystemGood=false;
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    47f2:	8f ef       	ldi	r24, 0xFF	; 255
    47f4:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		if(theByte!='T')
    47f8:	84 35       	cpi	r24, 0x54	; 84
    47fa:	59 f4       	brne	.+22     	; 0x4812 <main+0x38e>
    47fc:	06 c0       	rjmp	.+12     	; 0x480a <main+0x386>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    47fe:	8f ef       	ldi	r24, 0xFF	; 255
    4800:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4804:	8e 3f       	cpi	r24, 0xFE	; 254
    4806:	51 f7       	brne	.-44     	; 0x47dc <main+0x358>
    4808:	f0 cf       	rjmp	.-32     	; 0x47ea <main+0x366>
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
		if(theByte!='W')
    480a:	66 24       	eor	r6, r6
    480c:	63 94       	inc	r6
    480e:	17 35       	cpi	r17, 0x57	; 87
    4810:	09 f0       	breq	.+2      	; 0x4814 <main+0x390>
		}

		theByte=TransferSdByte(DUMMY_BYTE);
		if(theByte!='T')
		{
			filesystemGood=false;
    4812:	61 2c       	mov	r6, r1
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    4814:	8f ef       	ldi	r24, 0xFF	; 255
    4816:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		if(theByte!='P')
    481a:	80 35       	cpi	r24, 0x50	; 80
    481c:	09 f0       	breq	.+2      	; 0x4820 <main+0x39c>
		{
			filesystemGood=false;
    481e:	61 2c       	mov	r6, r1
		}

		theByte=TransferSdByte(DUMMY_BYTE);
    4820:	8f ef       	ldi	r24, 0xFF	; 255
    4822:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
		if(theByte!='A')
    4826:	81 34       	cpi	r24, 0x41	; 65
    4828:	09 f0       	breq	.+2      	; 0x482c <main+0x3a8>
		{
			filesystemGood=false;
    482a:	61 2c       	mov	r6, r1
    482c:	0c e0       	ldi	r16, 0x0C	; 12
    482e:	10 e0       	ldi	r17, 0x00	; 0
// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
    4830:	8f ef       	ldi	r24, 0xFF	; 255
    4832:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4836:	01 50       	subi	r16, 0x01	; 1
    4838:	11 09       	sbc	r17, r1
		}

// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
    483a:	d1 f7       	brne	.-12     	; 0x4830 <main+0x3ac>
		{
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
    483c:	71 e0       	ldi	r23, 0x01	; 1
    483e:	67 12       	cpse	r6, r23
    4840:	0f c0       	rjmp	.+30     	; 0x4860 <main+0x3dc>
    4842:	05 e8       	ldi	r16, 0x85	; 133
    4844:	15 e0       	ldi	r17, 0x05	; 5
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    4846:	8f ef       	ldi	r24, 0xFF	; 255
    4848:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    484c:	f8 01       	movw	r30, r16
    484e:	81 93       	st	Z+, r24
    4850:	8f 01       	movw	r16, r30
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    4852:	f5 e0       	ldi	r31, 0x05	; 5
    4854:	05 3c       	cpi	r16, 0xC5	; 197
    4856:	1f 07       	cpc	r17, r31
    4858:	b1 f7       	brne	.-20     	; 0x4846 <main+0x3c2>
		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
		}

		if(filesystemGood==true)			// Load TOC if this is a legit card
    485a:	02 eb       	ldi	r16, 0xB2	; 178
    485c:	11 e0       	ldi	r17, 0x01	; 1
    485e:	09 c0       	rjmp	.+18     	; 0x4872 <main+0x3ee>
    4860:	00 e4       	ldi	r16, 0x40	; 64
    4862:	10 e0       	ldi	r17, 0x00	; 0
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    4864:	8f ef       	ldi	r24, 0xFF	; 255
    4866:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    486a:	01 50       	subi	r16, 0x01	; 1
    486c:	11 09       	sbc	r17, r1
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    486e:	d1 f7       	brne	.-12     	; 0x4864 <main+0x3e0>
    4870:	f4 cf       	rjmp	.-24     	; 0x485a <main+0x3d6>
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    4872:	8f ef       	ldi	r24, 0xFF	; 255
    4874:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4878:	01 50       	subi	r16, 0x01	; 1
    487a:	11 09       	sbc	r17, r1
			{
				TransferSdByte(0xFF);
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    487c:	d1 f7       	brne	.-12     	; 0x4872 <main+0x3ee>
    487e:	01 c0       	rjmp	.+2      	; 0x4882 <main+0x3fe>
			TransferSdByte(0xFF);
		}
	}
	else
	{
		filesystemGood=false;	// Error issuing read command
    4880:	61 2c       	mov	r6, r1
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4882:	80 91 c8 00 	lds	r24, 0x00C8
    4886:	86 ff       	sbrs	r24, 6
    4888:	fc cf       	rjmp	.-8      	; 0x4882 <main+0x3fe>
		;

	EndSdTransfer();				// Bring CS high
    488a:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    488e:	8f ef       	ldi	r24, 0xFF	; 255
    4890:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				sdPlaybackQueued=false;
				sdAbortRead=false;

				if(SdHandshake()==true)	// Give it a shot...
				{
					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct filesystem, and if so, get the TOC as well.
    4894:	21 e0       	ldi	r18, 0x01	; 1
    4896:	62 12       	cpse	r6, r18
    4898:	19 c0       	rjmp	.+50     	; 0x48cc <main+0x448>
					{
						cardState=SD_IDLE;		// Card is legit and ready to go.
    489a:	d0 92 59 05 	sts	0x0559, r13
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    489e:	80 91 64 00 	lds	r24, 0x0064
    48a2:	8f 7b       	andi	r24, 0xBF	; 191
    48a4:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    48a8:	82 e0       	ldi	r24, 0x02	; 2
    48aa:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    48ae:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    48b2:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    48b6:	81 e7       	ldi	r24, 0x71	; 113
    48b8:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    48bc:	c7 ba       	out	0x17, r12	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    48be:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    48c2:	10 92 4f 05 	sts	0x054F, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    48c6:	10 92 55 05 	sts	0x0555, r1
    48ca:	ed c3       	rjmp	.+2010   	; 0x50a6 <main+0xc22>
						cardState=SD_IDLE;		// Card is legit and ready to go.
						InitSdIsr();			// Enable the timers necessary to give the SD card its own IRQ
					}
					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    48cc:	8f e0       	ldi	r24, 0x0F	; 15
    48ce:	80 93 59 05 	sts	0x0559, r24
    48d2:	e5 e8       	ldi	r30, 0x85	; 133
    48d4:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    48d6:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    48d8:	35 e0       	ldi	r19, 0x05	; 5
    48da:	e5 3c       	cpi	r30, 0xC5	; 197
    48dc:	f3 07       	cpc	r31, r19
    48de:	d9 f7       	brne	.-10     	; 0x48d6 <main+0x452>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    48e0:	89 e0       	ldi	r24, 0x09	; 9
    48e2:	91 e1       	ldi	r25, 0x11	; 17
    48e4:	90 93 e5 05 	sts	0x05E5, r25
    48e8:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    48ec:	10 92 5b 05 	sts	0x055B, r1
    48f0:	da c3       	rjmp	.+1972   	; 0x50a6 <main+0xc22>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    48f2:	8f e0       	ldi	r24, 0x0F	; 15
    48f4:	fe c3       	rjmp	.+2044   	; 0x50f2 <main+0xc6e>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    48f6:	2f b7       	in	r18, 0x3f	; 63
			cli();
    48f8:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    48fa:	80 91 26 01 	lds	r24, 0x0126
    48fe:	90 91 27 01 	lds	r25, 0x0127
    4902:	81 15       	cp	r24, r1
    4904:	92 40       	sbci	r25, 0x02	; 2
    4906:	a0 f4       	brcc	.+40     	; 0x4930 <main+0x4ac>
    4908:	80 91 26 01 	lds	r24, 0x0126
    490c:	90 91 27 01 	lds	r25, 0x0127
    4910:	40 91 1e 01 	lds	r20, 0x011E
    4914:	50 91 1f 01 	lds	r21, 0x011F
    4918:	60 91 20 01 	lds	r22, 0x0120
    491c:	70 91 21 01 	lds	r23, 0x0121
    4920:	a0 e0       	ldi	r26, 0x00	; 0
    4922:	b0 e0       	ldi	r27, 0x00	; 0
    4924:	84 17       	cp	r24, r20
    4926:	95 07       	cpc	r25, r21
    4928:	a6 07       	cpc	r26, r22
    492a:	b7 07       	cpc	r27, r23
    492c:	08 f4       	brcc	.+2      	; 0x4930 <main+0x4ac>
    492e:	55 c1       	rjmp	.+682    	; 0x4bda <main+0x756>
			{
				SREG=sreg;	// Done reading ISR variables.
    4930:	2f bf       	out	0x3f, r18	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    4932:	60 91 70 05 	lds	r22, 0x0570
    4936:	70 91 71 05 	lds	r23, 0x0571
    493a:	80 91 72 05 	lds	r24, 0x0572
    493e:	90 91 73 05 	lds	r25, 0x0573
    4942:	0e 94 31 22 	call	0x4462	; 0x4462 <SdBeginSingleBlockWrite>
    4946:	81 30       	cpi	r24, 0x01	; 1
    4948:	09 f0       	breq	.+2      	; 0x494c <main+0x4c8>
    494a:	f8 ce       	rjmp	.-528    	; 0x473c <main+0x2b8>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    494c:	d0 93 84 05 	sts	0x0584, r29
    4950:	c0 93 83 05 	sts	0x0583, r28

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    4954:	8f ef       	ldi	r24, 0xFF	; 255
    4956:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    495a:	8f ef       	ldi	r24, 0xFF	; 255
    495c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    4960:	8e ef       	ldi	r24, 0xFE	; 254
    4962:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    4966:	80 91 1e 01 	lds	r24, 0x011E
    496a:	90 91 1f 01 	lds	r25, 0x011F
    496e:	a0 91 20 01 	lds	r26, 0x0120
    4972:	b0 91 21 01 	lds	r27, 0x0121
    4976:	8b 2f       	mov	r24, r27
    4978:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    497c:	60 91 1e 01 	lds	r22, 0x011E
    4980:	70 91 1f 01 	lds	r23, 0x011F
    4984:	80 91 20 01 	lds	r24, 0x0120
    4988:	90 91 21 01 	lds	r25, 0x0121
    498c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    4990:	80 91 1e 01 	lds	r24, 0x011E
    4994:	90 91 1f 01 	lds	r25, 0x011F
    4998:	a0 91 20 01 	lds	r26, 0x0120
    499c:	b0 91 21 01 	lds	r27, 0x0121
    49a0:	89 2f       	mov	r24, r25
    49a2:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    49a6:	80 91 1e 01 	lds	r24, 0x011E
    49aa:	90 91 1f 01 	lds	r25, 0x011F
    49ae:	a0 91 20 01 	lds	r26, 0x0120
    49b2:	b0 91 21 01 	lds	r27, 0x0121
    49b6:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    49ba:	80 91 83 05 	lds	r24, 0x0583
    49be:	90 91 84 05 	lds	r25, 0x0584
    49c2:	04 97       	sbiw	r24, 0x04	; 4
    49c4:	90 93 84 05 	sts	0x0584, r25
    49c8:	80 93 83 05 	sts	0x0583, r24
    49cc:	04 c1       	rjmp	.+520    	; 0x4bd6 <main+0x752>
    49ce:	00 91 83 05 	lds	r16, 0x0583
    49d2:	10 91 84 05 	lds	r17, 0x0584
    49d6:	01 34       	cpi	r16, 0x41	; 65
    49d8:	11 05       	cpc	r17, r1
    49da:	10 f0       	brcs	.+4      	; 0x49e0 <main+0x55c>
    49dc:	00 e4       	ldi	r16, 0x40	; 64
    49de:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    49e0:	61 2c       	mov	r6, r1
    49e2:	56 c0       	rjmp	.+172    	; 0x4a90 <main+0x60c>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    49e4:	80 91 1e 01 	lds	r24, 0x011E
    49e8:	90 91 1f 01 	lds	r25, 0x011F
    49ec:	a0 91 20 01 	lds	r26, 0x0120
    49f0:	b0 91 21 01 	lds	r27, 0x0121
    49f4:	89 2b       	or	r24, r25
    49f6:	8a 2b       	or	r24, r26
    49f8:	8b 2b       	or	r24, r27
    49fa:	e9 f1       	breq	.+122    	; 0x4a76 <main+0x5f2>
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
    49fc:	e0 91 2a 01 	lds	r30, 0x012A
    4a00:	f0 91 2b 01 	lds	r31, 0x012B
    4a04:	e4 5d       	subi	r30, 0xD4	; 212
    4a06:	fe 4f       	sbci	r31, 0xFE	; 254
    4a08:	80 81       	ld	r24, Z
    4a0a:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    4a0e:	80 91 1e 01 	lds	r24, 0x011E
    4a12:	90 91 1f 01 	lds	r25, 0x011F
    4a16:	a0 91 20 01 	lds	r26, 0x0120
    4a1a:	b0 91 21 01 	lds	r27, 0x0121
    4a1e:	01 97       	sbiw	r24, 0x01	; 1
    4a20:	a1 09       	sbc	r26, r1
    4a22:	b1 09       	sbc	r27, r1
    4a24:	80 93 1e 01 	sts	0x011E, r24
    4a28:	90 93 1f 01 	sts	0x011F, r25
    4a2c:	a0 93 20 01 	sts	0x0120, r26
    4a30:	b0 93 21 01 	sts	0x0121, r27

					sdFifoReadPointer++;			// Move to next spot in fifo
    4a34:	80 91 2a 01 	lds	r24, 0x012A
    4a38:	90 91 2b 01 	lds	r25, 0x012B
    4a3c:	01 96       	adiw	r24, 0x01	; 1
    4a3e:	90 93 2b 01 	sts	0x012B, r25
    4a42:	80 93 2a 01 	sts	0x012A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    4a46:	80 91 2a 01 	lds	r24, 0x012A
    4a4a:	90 91 2b 01 	lds	r25, 0x012B
    4a4e:	81 15       	cp	r24, r1
    4a50:	93 40       	sbci	r25, 0x03	; 3
    4a52:	20 f0       	brcs	.+8      	; 0x4a5c <main+0x5d8>
					{
						sdFifoReadPointer=0;
    4a54:	10 92 2b 01 	sts	0x012B, r1
    4a58:	10 92 2a 01 	sts	0x012A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    4a5c:	2f b7       	in	r18, 0x3f	; 63
					cli();
    4a5e:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    4a60:	80 91 26 01 	lds	r24, 0x0126
    4a64:	90 91 27 01 	lds	r25, 0x0127
    4a68:	01 97       	sbiw	r24, 0x01	; 1
    4a6a:	90 93 27 01 	sts	0x0127, r25
    4a6e:	80 93 26 01 	sts	0x0126, r24
					SREG=sreg;
    4a72:	2f bf       	out	0x3f, r18	; 63
    4a74:	03 c0       	rjmp	.+6      	; 0x4a7c <main+0x5f8>
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    4a76:	8f ef       	ldi	r24, 0xFF	; 255
    4a78:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    4a7c:	80 91 83 05 	lds	r24, 0x0583
    4a80:	90 91 84 05 	lds	r25, 0x0584
    4a84:	01 97       	sbiw	r24, 0x01	; 1
    4a86:	90 93 84 05 	sts	0x0584, r25
    4a8a:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4a8e:	63 94       	inc	r6
    4a90:	86 2d       	mov	r24, r6
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	80 17       	cp	r24, r16
    4a96:	91 07       	cpc	r25, r17
    4a98:	08 f4       	brcc	.+2      	; 0x4a9c <main+0x618>
    4a9a:	a4 cf       	rjmp	.-184    	; 0x49e4 <main+0x560>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    4a9c:	80 91 83 05 	lds	r24, 0x0583
    4aa0:	90 91 84 05 	lds	r25, 0x0584
    4aa4:	89 2b       	or	r24, r25
    4aa6:	09 f0       	breq	.+2      	; 0x4aaa <main+0x626>
    4aa8:	fe c2       	rjmp	.+1532   	; 0x50a6 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4aaa:	8f ef       	ldi	r24, 0xFF	; 255
    4aac:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4ab0:	8f ef       	ldi	r24, 0xFF	; 255
    4ab2:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4ab6:	8f ef       	ldi	r24, 0xFF	; 255
    4ab8:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4abc:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4abe:	85 30       	cpi	r24, 0x05	; 5
    4ac0:	09 f0       	breq	.+2      	; 0x4ac4 <main+0x640>
    4ac2:	3c ce       	rjmp	.-904    	; 0x473c <main+0x2b8>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4ac4:	62 e6       	ldi	r22, 0x62	; 98
    4ac6:	72 e0       	ldi	r23, 0x02	; 2
    4ac8:	83 e0       	ldi	r24, 0x03	; 3
    4aca:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    4ace:	20 92 59 05 	sts	0x0559, r2
    4ad2:	e9 c2       	rjmp	.+1490   	; 0x50a6 <main+0xc22>
				}
			}
			break;

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    4ad4:	83 e0       	ldi	r24, 0x03	; 3
    4ad6:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4ada:	81 11       	cpse	r24, r1
    4adc:	2f ce       	rjmp	.-930    	; 0x473c <main+0x2b8>
    4ade:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4ae0:	8f ef       	ldi	r24, 0xFF	; 255
    4ae2:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4ae6:	8f 3f       	cpi	r24, 0xFF	; 255
    4ae8:	09 f4       	brne	.+2      	; 0x4aec <main+0x668>
    4aea:	09 c3       	rjmp	.+1554   	; 0x50fe <main+0xc7a>
    4aec:	11 50       	subi	r17, 0x01	; 1

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4aee:	c1 f7       	brne	.-16     	; 0x4ae0 <main+0x65c>
    4af0:	da c2       	rjmp	.+1460   	; 0x50a6 <main+0xc22>

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4af2:	80 91 c8 00 	lds	r24, 0x00C8
    4af6:	86 ff       	sbrs	r24, 6
    4af8:	fc cf       	rjmp	.-8      	; 0x4af2 <main+0x66e>
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    4afa:	80 91 1e 01 	lds	r24, 0x011E
    4afe:	90 91 1f 01 	lds	r25, 0x011F
    4b02:	a0 91 20 01 	lds	r26, 0x0120
    4b06:	b0 91 21 01 	lds	r27, 0x0121
    4b0a:	89 2b       	or	r24, r25
    4b0c:	8a 2b       	or	r24, r26
    4b0e:	8b 2b       	or	r24, r27
    4b10:	11 f0       	breq	.+4      	; 0x4b16 <main+0x692>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    4b12:	85 e0       	ldi	r24, 0x05	; 5
    4b14:	ee c2       	rjmp	.+1500   	; 0x50f2 <main+0xc6e>
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    4b16:	20 91 6e 05 	lds	r18, 0x056E
    4b1a:	30 91 6f 05 	lds	r19, 0x056F
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    4b1e:	f9 01       	movw	r30, r18
    4b20:	43 e0       	ldi	r20, 0x03	; 3
    4b22:	f6 95       	lsr	r31
    4b24:	e7 95       	ror	r30
    4b26:	4a 95       	dec	r20
    4b28:	e1 f7       	brne	.-8      	; 0x4b22 <main+0x69e>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    4b2a:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    4b2c:	eb 57       	subi	r30, 0x7B	; 123
    4b2e:	fa 4f       	sbci	r31, 0xFA	; 250
    4b30:	40 81       	ld	r20, Z
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    4b32:	27 70       	andi	r18, 0x07	; 7
    4b34:	33 27       	eor	r19, r19

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    4b36:	84 2f       	mov	r24, r20
    4b38:	90 e0       	ldi	r25, 0x00	; 0
    4b3a:	02 2e       	mov	r0, r18
    4b3c:	02 c0       	rjmp	.+4      	; 0x4b42 <main+0x6be>
    4b3e:	95 95       	asr	r25
    4b40:	87 95       	ror	r24
    4b42:	0a 94       	dec	r0
    4b44:	e2 f7       	brpl	.-8      	; 0x4b3e <main+0x6ba>
    4b46:	80 ff       	sbrs	r24, 0
    4b48:	ca c2       	rjmp	.+1428   	; 0x50de <main+0xc5a>
    4b4a:	d6 c2       	rjmp	.+1452   	; 0x50f8 <main+0xc74>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    4b4c:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4b4e:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    4b50:	80 91 26 01 	lds	r24, 0x0126
    4b54:	90 91 27 01 	lds	r25, 0x0127
    4b58:	81 15       	cp	r24, r1
    4b5a:	92 40       	sbci	r25, 0x02	; 2
    4b5c:	98 f4       	brcc	.+38     	; 0x4b84 <main+0x700>
    4b5e:	80 91 26 01 	lds	r24, 0x0126
    4b62:	90 91 27 01 	lds	r25, 0x0127
    4b66:	40 91 1e 01 	lds	r20, 0x011E
    4b6a:	50 91 1f 01 	lds	r21, 0x011F
    4b6e:	60 91 20 01 	lds	r22, 0x0120
    4b72:	70 91 21 01 	lds	r23, 0x0121
    4b76:	a0 e0       	ldi	r26, 0x00	; 0
    4b78:	b0 e0       	ldi	r27, 0x00	; 0
    4b7a:	84 17       	cp	r24, r20
    4b7c:	95 07       	cpc	r25, r21
    4b7e:	a6 07       	cpc	r26, r22
    4b80:	b7 07       	cpc	r27, r23
    4b82:	58 f1       	brcs	.+86     	; 0x4bda <main+0x756>
			{
				SREG=sreg;																	// Done reading ISR variables.
    4b84:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;		// On to the next
    4b86:	20 91 74 05 	lds	r18, 0x0574
    4b8a:	30 91 75 05 	lds	r19, 0x0575
    4b8e:	2f 5f       	subi	r18, 0xFF	; 255
    4b90:	3f 4f       	sbci	r19, 0xFF	; 255
    4b92:	30 93 75 05 	sts	0x0575, r19
    4b96:	20 93 74 05 	sts	0x0574, r18

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    4b9a:	60 91 70 05 	lds	r22, 0x0570
    4b9e:	70 91 71 05 	lds	r23, 0x0571
    4ba2:	80 91 72 05 	lds	r24, 0x0572
    4ba6:	90 91 73 05 	lds	r25, 0x0573
    4baa:	62 0f       	add	r22, r18
    4bac:	73 1f       	adc	r23, r19
    4bae:	81 1d       	adc	r24, r1
    4bb0:	91 1d       	adc	r25, r1
    4bb2:	0e 94 31 22 	call	0x4462	; 0x4462 <SdBeginSingleBlockWrite>
    4bb6:	81 30       	cpi	r24, 0x01	; 1
    4bb8:	09 f0       	breq	.+2      	; 0x4bbc <main+0x738>
    4bba:	c0 cd       	rjmp	.-1152   	; 0x473c <main+0x2b8>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4bbc:	d0 93 84 05 	sts	0x0584, r29
    4bc0:	c0 93 83 05 	sts	0x0583, r28

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    4bc4:	8f ef       	ldi	r24, 0xFF	; 255
    4bc6:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    4bca:	8f ef       	ldi	r24, 0xFF	; 255
    4bcc:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    4bd0:	8e ef       	ldi	r24, 0xFE	; 254
    4bd2:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    4bd6:	83 e0       	ldi	r24, 0x03	; 3
    4bd8:	8c c2       	rjmp	.+1304   	; 0x50f2 <main+0xc6e>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// Bytes remaining in sample, but not enough in the fifo yet
			{
				SREG=sreg;			// Done reading ISR variables.
    4bda:	2f bf       	out	0x3f, r18	; 63
    4bdc:	64 c2       	rjmp	.+1224   	; 0x50a6 <main+0xc22>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    4bde:	60 e0       	ldi	r22, 0x00	; 0
    4be0:	70 e0       	ldi	r23, 0x00	; 0
    4be2:	cb 01       	movw	r24, r22
    4be4:	0e 94 31 22 	call	0x4462	; 0x4462 <SdBeginSingleBlockWrite>
    4be8:	81 30       	cpi	r24, 0x01	; 1
    4bea:	09 f0       	breq	.+2      	; 0x4bee <main+0x76a>
    4bec:	a7 cd       	rjmp	.-1202   	; 0x473c <main+0x2b8>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    4bee:	d0 93 84 05 	sts	0x0584, r29
    4bf2:	c0 93 83 05 	sts	0x0583, r28

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4bf6:	8f ef       	ldi	r24, 0xFF	; 255
    4bf8:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    4bfc:	8f ef       	ldi	r24, 0xFF	; 255
    4bfe:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    4c02:	8e ef       	ldi	r24, 0xFE	; 254
    4c04:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte('W');				// Send flag that this is a WTPA card
    4c08:	87 e5       	ldi	r24, 0x57	; 87
    4c0a:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte('T');
    4c0e:	84 e5       	ldi	r24, 0x54	; 84
    4c10:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte('P');
    4c14:	80 e5       	ldi	r24, 0x50	; 80
    4c16:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte('A');
    4c1a:	81 e4       	ldi	r24, 0x41	; 65
    4c1c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>

				bytesLeftInBlock-=4;
    4c20:	80 91 83 05 	lds	r24, 0x0583
    4c24:	90 91 84 05 	lds	r25, 0x0584
    4c28:	04 97       	sbiw	r24, 0x04	; 4
    4c2a:	90 93 84 05 	sts	0x0584, r25
    4c2e:	80 93 83 05 	sts	0x0583, r24
    4c32:	1c e0       	ldi	r17, 0x0C	; 12

				for(i=0;i<12;i++)					// 12 don't care bytes
				{
					TransferSdByte('x');
    4c34:	88 e7       	ldi	r24, 0x78	; 120
    4c36:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4c3a:	11 50       	subi	r17, 0x01	; 1
				TransferSdByte('P');
				TransferSdByte('A');

				bytesLeftInBlock-=4;

				for(i=0;i<12;i++)					// 12 don't care bytes
    4c3c:	d9 f7       	brne	.-10     	; 0x4c34 <main+0x7b0>
				{
					TransferSdByte('x');
				}

				bytesLeftInBlock-=12;
    4c3e:	80 91 83 05 	lds	r24, 0x0583
    4c42:	90 91 84 05 	lds	r25, 0x0584
    4c46:	0c 97       	sbiw	r24, 0x0c	; 12
    4c48:	90 93 84 05 	sts	0x0584, r25
    4c4c:	80 93 83 05 	sts	0x0583, r24
    4c50:	05 e8       	ldi	r16, 0x85	; 133
    4c52:	15 e0       	ldi	r17, 0x05	; 5

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    4c54:	f8 01       	movw	r30, r16
    4c56:	81 91       	ld	r24, Z+
    4c58:	8f 01       	movw	r16, r30
    4c5a:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte('x');
				}

				bytesLeftInBlock-=12;

				for(i=0;i<64;i++)					// Write table of contents.
    4c5e:	f5 e0       	ldi	r31, 0x05	; 5
    4c60:	05 3c       	cpi	r16, 0xC5	; 197
    4c62:	1f 07       	cpc	r17, r31
    4c64:	b9 f7       	brne	.-18     	; 0x4c54 <main+0x7d0>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    4c66:	80 91 83 05 	lds	r24, 0x0583
    4c6a:	90 91 84 05 	lds	r25, 0x0584
    4c6e:	80 54       	subi	r24, 0x40	; 64
    4c70:	91 09       	sbc	r25, r1
    4c72:	90 93 84 05 	sts	0x0584, r25
    4c76:	80 93 83 05 	sts	0x0583, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4c7a:	90 92 59 05 	sts	0x0559, r9
    4c7e:	13 c2       	rjmp	.+1062   	; 0x50a6 <main+0xc22>
    4c80:	00 91 83 05 	lds	r16, 0x0583
    4c84:	10 91 84 05 	lds	r17, 0x0584
    4c88:	01 34       	cpi	r16, 0x41	; 65
    4c8a:	11 05       	cpc	r17, r1
    4c8c:	10 f0       	brcs	.+4      	; 0x4c92 <main+0x80e>
    4c8e:	00 e4       	ldi	r16, 0x40	; 64
    4c90:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4c92:	61 2c       	mov	r6, r1
    4c94:	0d c0       	rjmp	.+26     	; 0x4cb0 <main+0x82c>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4c96:	8f ef       	ldi	r24, 0xFF	; 255
    4c98:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    4c9c:	80 91 83 05 	lds	r24, 0x0583
    4ca0:	90 91 84 05 	lds	r25, 0x0584
    4ca4:	01 97       	sbiw	r24, 0x01	; 1
    4ca6:	90 93 84 05 	sts	0x0584, r25
    4caa:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4cae:	63 94       	inc	r6
    4cb0:	86 2d       	mov	r24, r6
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
    4cb4:	80 17       	cp	r24, r16
    4cb6:	91 07       	cpc	r25, r17
    4cb8:	70 f3       	brcs	.-36     	; 0x4c96 <main+0x812>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    4cba:	80 91 83 05 	lds	r24, 0x0583
    4cbe:	90 91 84 05 	lds	r25, 0x0584
    4cc2:	89 2b       	or	r24, r25
    4cc4:	09 f0       	breq	.+2      	; 0x4cc8 <main+0x844>
    4cc6:	ef c1       	rjmp	.+990    	; 0x50a6 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4cc8:	8f ef       	ldi	r24, 0xFF	; 255
    4cca:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4cce:	8f ef       	ldi	r24, 0xFF	; 255
    4cd0:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4cd4:	8f ef       	ldi	r24, 0xFF	; 255
    4cd6:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4cda:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4cdc:	85 30       	cpi	r24, 0x05	; 5
    4cde:	09 f0       	breq	.+2      	; 0x4ce2 <main+0x85e>
    4ce0:	2d cd       	rjmp	.-1446   	; 0x473c <main+0x2b8>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4ce2:	62 e6       	ldi	r22, 0x62	; 98
    4ce4:	72 e0       	ldi	r23, 0x02	; 2
    4ce6:	83 e0       	ldi	r24, 0x03	; 3
    4ce8:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    4cec:	88 e0       	ldi	r24, 0x08	; 8
    4cee:	01 c2       	rjmp	.+1026   	; 0x50f2 <main+0xc6e>
				}
			}
			break;

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4cf0:	83 e0       	ldi	r24, 0x03	; 3
    4cf2:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4cf6:	81 11       	cpse	r24, r1
    4cf8:	21 cd       	rjmp	.-1470   	; 0x473c <main+0x2b8>
    4cfa:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4cfc:	8f ef       	ldi	r24, 0xFF	; 255
    4cfe:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4d02:	8f 3f       	cpi	r24, 0xFF	; 255
    4d04:	09 f4       	brne	.+2      	; 0x4d08 <main+0x884>
    4d06:	01 c2       	rjmp	.+1026   	; 0x510a <main+0xc86>
    4d08:	11 50       	subi	r17, 0x01	; 1

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4d0a:	c1 f7       	brne	.-16     	; 0x4cfc <main+0x878>
    4d0c:	cc c1       	rjmp	.+920    	; 0x50a6 <main+0xc22>

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4d0e:	80 91 c8 00 	lds	r24, 0x00C8
    4d12:	86 ff       	sbrs	r24, 6
    4d14:	fc cf       	rjmp	.-8      	; 0x4d0e <main+0x88a>
    4d16:	f0 c1       	rjmp	.+992    	; 0x50f8 <main+0xc74>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4d18:	83 e0       	ldi	r24, 0x03	; 3
    4d1a:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4d1e:	81 11       	cpse	r24, r1
    4d20:	0d cd       	rjmp	.-1510   	; 0x473c <main+0x2b8>
    4d22:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4d24:	8f ef       	ldi	r24, 0xFF	; 255
    4d26:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    4d2a:	8f 3f       	cpi	r24, 0xFF	; 255
    4d2c:	19 f4       	brne	.+6      	; 0x4d34 <main+0x8b0>
    4d2e:	11 50       	subi	r17, 0x01	; 1

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    4d30:	c9 f7       	brne	.-14     	; 0x4d24 <main+0x8a0>
    4d32:	b9 c1       	rjmp	.+882    	; 0x50a6 <main+0xc22>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    4d34:	8e 3f       	cpi	r24, 0xFE	; 254
    4d36:	09 f0       	breq	.+2      	; 0x4d3a <main+0x8b6>
    4d38:	01 cd       	rjmp	.-1534   	; 0x473c <main+0x2b8>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
    4d3a:	d0 93 84 05 	sts	0x0584, r29
    4d3e:	c0 93 83 05 	sts	0x0583, r28

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    4d42:	8f ef       	ldi	r24, 0xFF	; 255
    4d44:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4d48:	90 e0       	ldi	r25, 0x00	; 0
    4d4a:	a0 e0       	ldi	r26, 0x00	; 0
    4d4c:	b0 e0       	ldi	r27, 0x00	; 0
    4d4e:	b8 2f       	mov	r27, r24
    4d50:	aa 27       	eor	r26, r26
    4d52:	99 27       	eor	r25, r25
    4d54:	88 27       	eor	r24, r24
    4d56:	80 93 1e 01 	sts	0x011E, r24
    4d5a:	90 93 1f 01 	sts	0x011F, r25
    4d5e:	a0 93 20 01 	sts	0x0120, r26
    4d62:	b0 93 21 01 	sts	0x0121, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    4d66:	40 90 1e 01 	lds	r4, 0x011E
    4d6a:	50 90 1f 01 	lds	r5, 0x011F
    4d6e:	60 90 20 01 	lds	r6, 0x0120
    4d72:	70 90 21 01 	lds	r7, 0x0121
    4d76:	8f ef       	ldi	r24, 0xFF	; 255
    4d78:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4d7c:	b3 01       	movw	r22, r6
    4d7e:	a2 01       	movw	r20, r4
    4d80:	68 2b       	or	r22, r24
    4d82:	40 93 1e 01 	sts	0x011E, r20
    4d86:	50 93 1f 01 	sts	0x011F, r21
    4d8a:	60 93 20 01 	sts	0x0120, r22
    4d8e:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    4d92:	40 90 1e 01 	lds	r4, 0x011E
    4d96:	50 90 1f 01 	lds	r5, 0x011F
    4d9a:	60 90 20 01 	lds	r6, 0x0120
    4d9e:	70 90 21 01 	lds	r7, 0x0121
    4da2:	8f ef       	ldi	r24, 0xFF	; 255
    4da4:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4da8:	b3 01       	movw	r22, r6
    4daa:	a2 01       	movw	r20, r4
    4dac:	58 2b       	or	r21, r24
    4dae:	40 93 1e 01 	sts	0x011E, r20
    4db2:	50 93 1f 01 	sts	0x011F, r21
    4db6:	60 93 20 01 	sts	0x0120, r22
    4dba:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    4dbe:	40 90 1e 01 	lds	r4, 0x011E
    4dc2:	50 90 1f 01 	lds	r5, 0x011F
    4dc6:	60 90 20 01 	lds	r6, 0x0120
    4dca:	70 90 21 01 	lds	r7, 0x0121
    4dce:	8f ef       	ldi	r24, 0xFF	; 255
    4dd0:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    4dd4:	b3 01       	movw	r22, r6
    4dd6:	a2 01       	movw	r20, r4
    4dd8:	48 2b       	or	r20, r24
    4dda:	40 93 1e 01 	sts	0x011E, r20
    4dde:	50 93 1f 01 	sts	0x011F, r21
    4de2:	60 93 20 01 	sts	0x0120, r22
    4de6:	70 93 21 01 	sts	0x0121, r23

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    4dea:	80 91 1e 01 	lds	r24, 0x011E
    4dee:	90 91 1f 01 	lds	r25, 0x011F
    4df2:	a0 91 20 01 	lds	r26, 0x0120
    4df6:	b0 91 21 01 	lds	r27, 0x0121
    4dfa:	80 93 22 01 	sts	0x0122, r24
    4dfe:	90 93 23 01 	sts	0x0123, r25
    4e02:	a0 93 24 01 	sts	0x0124, r26
    4e06:	b0 93 25 01 	sts	0x0125, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    4e0a:	80 91 83 05 	lds	r24, 0x0583
    4e0e:	90 91 84 05 	lds	r25, 0x0584
    4e12:	04 97       	sbiw	r24, 0x04	; 4
    4e14:	90 93 84 05 	sts	0x0584, r25
    4e18:	80 93 83 05 	sts	0x0583, r24
    4e1c:	f4 c0       	rjmp	.+488    	; 0x5006 <main+0xb82>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    4e1e:	80 91 76 05 	lds	r24, 0x0576
    4e22:	81 30       	cpi	r24, 0x01	; 1
    4e24:	09 f4       	brne	.+2      	; 0x4e28 <main+0x9a4>
    4e26:	f6 c0       	rjmp	.+492    	; 0x5014 <main+0xb90>
    4e28:	00 91 83 05 	lds	r16, 0x0583
    4e2c:	10 91 84 05 	lds	r17, 0x0584
    4e30:	01 34       	cpi	r16, 0x41	; 65
    4e32:	11 05       	cpc	r17, r1
    4e34:	10 f0       	brcs	.+4      	; 0x4e3a <main+0x9b6>
    4e36:	00 e4       	ldi	r16, 0x40	; 64
    4e38:	10 e0       	ldi	r17, 0x00	; 0
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    4e3a:	61 2c       	mov	r6, r1
    4e3c:	55 c0       	rjmp	.+170    	; 0x4ee8 <main+0xa64>
				{
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    4e3e:	8f ef       	ldi	r24, 0xFF	; 255
    4e40:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					bytesLeftInBlock--;						// One less byte in the block read.
    4e44:	20 91 83 05 	lds	r18, 0x0583
    4e48:	30 91 84 05 	lds	r19, 0x0584
    4e4c:	21 50       	subi	r18, 0x01	; 1
    4e4e:	31 09       	sbc	r19, r1
    4e50:	30 93 84 05 	sts	0x0584, r19
    4e54:	20 93 83 05 	sts	0x0583, r18

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    4e58:	40 91 1e 01 	lds	r20, 0x011E
    4e5c:	50 91 1f 01 	lds	r21, 0x011F
    4e60:	60 91 20 01 	lds	r22, 0x0120
    4e64:	70 91 21 01 	lds	r23, 0x0121
    4e68:	45 2b       	or	r20, r21
    4e6a:	46 2b       	or	r20, r22
    4e6c:	47 2b       	or	r20, r23
    4e6e:	d9 f1       	breq	.+118    	; 0x4ee6 <main+0xa62>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    4e70:	40 91 1e 01 	lds	r20, 0x011E
    4e74:	50 91 1f 01 	lds	r21, 0x011F
    4e78:	60 91 20 01 	lds	r22, 0x0120
    4e7c:	70 91 21 01 	lds	r23, 0x0121
    4e80:	41 50       	subi	r20, 0x01	; 1
    4e82:	51 09       	sbc	r21, r1
    4e84:	61 09       	sbc	r22, r1
    4e86:	71 09       	sbc	r23, r1
    4e88:	40 93 1e 01 	sts	0x011E, r20
    4e8c:	50 93 1f 01 	sts	0x011F, r21
    4e90:	60 93 20 01 	sts	0x0120, r22
    4e94:	70 93 21 01 	sts	0x0121, r23

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    4e98:	e0 91 28 01 	lds	r30, 0x0128
    4e9c:	f0 91 29 01 	lds	r31, 0x0129
    4ea0:	e4 5d       	subi	r30, 0xD4	; 212
    4ea2:	fe 4f       	sbci	r31, 0xFE	; 254
    4ea4:	80 83       	st	Z, r24
						sdFifoWritePointer++;				// Move to next spot in fifo
    4ea6:	80 91 28 01 	lds	r24, 0x0128
    4eaa:	90 91 29 01 	lds	r25, 0x0129
    4eae:	01 96       	adiw	r24, 0x01	; 1
    4eb0:	90 93 29 01 	sts	0x0129, r25
    4eb4:	80 93 28 01 	sts	0x0128, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    4eb8:	80 91 28 01 	lds	r24, 0x0128
    4ebc:	90 91 29 01 	lds	r25, 0x0129
    4ec0:	81 15       	cp	r24, r1
    4ec2:	93 40       	sbci	r25, 0x03	; 3
    4ec4:	20 f0       	brcs	.+8      	; 0x4ece <main+0xa4a>
						{
							sdFifoWritePointer=0;
    4ec6:	10 92 29 01 	sts	0x0129, r1
    4eca:	10 92 28 01 	sts	0x0128, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    4ece:	2f b7       	in	r18, 0x3f	; 63
						cli();
    4ed0:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    4ed2:	80 91 26 01 	lds	r24, 0x0126
    4ed6:	90 91 27 01 	lds	r25, 0x0127
    4eda:	01 96       	adiw	r24, 0x01	; 1
    4edc:	90 93 27 01 	sts	0x0127, r25
    4ee0:	80 93 26 01 	sts	0x0126, r24
						SREG=sreg;
    4ee4:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    4ee6:	63 94       	inc	r6
    4ee8:	86 2d       	mov	r24, r6
    4eea:	90 e0       	ldi	r25, 0x00	; 0
    4eec:	80 17       	cp	r24, r16
    4eee:	91 07       	cpc	r25, r17
    4ef0:	08 f4       	brcc	.+2      	; 0x4ef4 <main+0xa70>
    4ef2:	a5 cf       	rjmp	.-182    	; 0x4e3e <main+0x9ba>
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    4ef4:	80 91 83 05 	lds	r24, 0x0583
    4ef8:	90 91 84 05 	lds	r25, 0x0584
    4efc:	89 2b       	or	r24, r25
    4efe:	09 f0       	breq	.+2      	; 0x4f02 <main+0xa7e>
    4f00:	d2 c0       	rjmp	.+420    	; 0x50a6 <main+0xc22>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    4f02:	8f ef       	ldi	r24, 0xFF	; 255
    4f04:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    4f08:	8f ef       	ldi	r24, 0xFF	; 255
    4f0a:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4f0e:	80 91 c8 00 	lds	r24, 0x00C8
    4f12:	86 ff       	sbrs	r24, 6
    4f14:	fc cf       	rjmp	.-8      	; 0x4f0e <main+0xa8a>
						;

					EndSdTransfer();				// Bring CS high
    4f16:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    4f1a:	8f ef       	ldi	r24, 0xFF	; 255
    4f1c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    4f20:	80 92 59 05 	sts	0x0559, r8

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    4f24:	80 91 1e 01 	lds	r24, 0x011E
    4f28:	90 91 1f 01 	lds	r25, 0x011F
    4f2c:	a0 91 20 01 	lds	r26, 0x0120
    4f30:	b0 91 21 01 	lds	r27, 0x0121
    4f34:	89 2b       	or	r24, r25
    4f36:	8a 2b       	or	r24, r26
    4f38:	8b 2b       	or	r24, r27
    4f3a:	09 f0       	breq	.+2      	; 0x4f3e <main+0xaba>
    4f3c:	b4 c0       	rjmp	.+360    	; 0x50a6 <main+0xc22>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4f3e:	80 91 c8 00 	lds	r24, 0x00C8
    4f42:	86 ff       	sbrs	r24, 6
    4f44:	fc cf       	rjmp	.-8      	; 0x4f3e <main+0xaba>
    4f46:	d8 c0       	rjmp	.+432    	; 0x50f8 <main+0xc74>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    4f48:	ef b7       	in	r30, 0x3f	; 63
			cli();
    4f4a:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    4f4c:	20 91 26 01 	lds	r18, 0x0126
    4f50:	30 91 27 01 	lds	r19, 0x0127
    4f54:	80 e0       	ldi	r24, 0x00	; 0
    4f56:	93 e0       	ldi	r25, 0x03	; 3
    4f58:	ac 01       	movw	r20, r24
    4f5a:	42 1b       	sub	r20, r18
    4f5c:	53 0b       	sbc	r21, r19
    4f5e:	9a 01       	movw	r18, r20
    4f60:	21 15       	cp	r18, r1
    4f62:	32 40       	sbci	r19, 0x02	; 2
    4f64:	a8 f4       	brcc	.+42     	; 0x4f90 <main+0xb0c>
    4f66:	20 91 26 01 	lds	r18, 0x0126
    4f6a:	30 91 27 01 	lds	r19, 0x0127
    4f6e:	40 91 1e 01 	lds	r20, 0x011E
    4f72:	50 91 1f 01 	lds	r21, 0x011F
    4f76:	60 91 20 01 	lds	r22, 0x0120
    4f7a:	70 91 21 01 	lds	r23, 0x0121
    4f7e:	82 1b       	sub	r24, r18
    4f80:	93 0b       	sbc	r25, r19
    4f82:	a0 e0       	ldi	r26, 0x00	; 0
    4f84:	b0 e0       	ldi	r27, 0x00	; 0
    4f86:	84 17       	cp	r24, r20
    4f88:	95 07       	cpc	r25, r21
    4f8a:	a6 07       	cpc	r26, r22
    4f8c:	b7 07       	cpc	r27, r23
    4f8e:	20 f1       	brcs	.+72     	; 0x4fd8 <main+0xb54>
			{
				SREG=sreg;				// ISR back on.
    4f90:	ef bf       	out	0x3f, r30	; 63
				sdCurrentBlockOffset++;	// Point at next block
    4f92:	20 91 74 05 	lds	r18, 0x0574
    4f96:	30 91 75 05 	lds	r19, 0x0575
    4f9a:	2f 5f       	subi	r18, 0xFF	; 255
    4f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f9e:	30 93 75 05 	sts	0x0575, r19
    4fa2:	20 93 74 05 	sts	0x0574, r18

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    4fa6:	60 91 70 05 	lds	r22, 0x0570
    4faa:	70 91 71 05 	lds	r23, 0x0571
    4fae:	80 91 72 05 	lds	r24, 0x0572
    4fb2:	90 91 73 05 	lds	r25, 0x0573
    4fb6:	62 0f       	add	r22, r18
    4fb8:	73 1f       	adc	r23, r19
    4fba:	81 1d       	adc	r24, r1
    4fbc:	91 1d       	adc	r25, r1
    4fbe:	0e 94 20 22 	call	0x4440	; 0x4440 <SdBeginSingleBlockRead>
    4fc2:	81 30       	cpi	r24, 0x01	; 1
    4fc4:	09 f0       	breq	.+2      	; 0x4fc8 <main+0xb44>
    4fc6:	ba cb       	rjmp	.-2188   	; 0x473c <main+0x2b8>
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    4fc8:	6a e7       	ldi	r22, 0x7A	; 122
    4fca:	70 e0       	ldi	r23, 0x00	; 0
    4fcc:	83 e0       	ldi	r24, 0x03	; 3
    4fce:	0e 94 46 1e 	call	0x3c8c	; 0x3c8c <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    4fd2:	30 92 59 05 	sts	0x0559, r3
    4fd6:	67 c0       	rjmp	.+206    	; 0x50a6 <main+0xc22>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    4fd8:	ef bf       	out	0x3f, r30	; 63
    4fda:	65 c0       	rjmp	.+202    	; 0x50a6 <main+0xc22>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    4fdc:	83 e0       	ldi	r24, 0x03	; 3
    4fde:	0e 94 58 1e 	call	0x3cb0	; 0x3cb0 <CheckTimer>
    4fe2:	81 11       	cpse	r24, r1
    4fe4:	ab cb       	rjmp	.-2218   	; 0x473c <main+0x2b8>
    4fe6:	14 e0       	ldi	r17, 0x04	; 4
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4fe8:	8f ef       	ldi	r24, 0xFF	; 255
    4fea:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    4fee:	8f 3f       	cpi	r24, 0xFF	; 255
    4ff0:	19 f4       	brne	.+6      	; 0x4ff8 <main+0xb74>
    4ff2:	11 50       	subi	r17, 0x01	; 1

			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    4ff4:	c9 f7       	brne	.-14     	; 0x4fe8 <main+0xb64>
    4ff6:	57 c0       	rjmp	.+174    	; 0x50a6 <main+0xc22>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    4ff8:	8e 3f       	cpi	r24, 0xFE	; 254
    4ffa:	09 f0       	breq	.+2      	; 0x4ffe <main+0xb7a>
    4ffc:	9f cb       	rjmp	.-2242   	; 0x473c <main+0x2b8>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
    4ffe:	d0 93 84 05 	sts	0x0584, r29
    5002:	c0 93 83 05 	sts	0x0583, r28

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    5006:	a0 92 59 05 	sts	0x0559, r10
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    500a:	80 91 76 05 	lds	r24, 0x0576
    500e:	81 30       	cpi	r24, 0x01	; 1
    5010:	09 f0       	breq	.+2      	; 0x5014 <main+0xb90>
    5012:	49 c0       	rjmp	.+146    	; 0x50a6 <main+0xc22>
					{
						cardState=SD_READ_ABORT;
    5014:	b0 92 59 05 	sts	0x0559, r11
						sdAbortRead=false;
    5018:	10 92 76 05 	sts	0x0576, r1
    501c:	44 c0       	rjmp	.+136    	; 0x50a6 <main+0xc22>
    501e:	00 91 83 05 	lds	r16, 0x0583
    5022:	10 91 84 05 	lds	r17, 0x0584
    5026:	01 34       	cpi	r16, 0x41	; 65
    5028:	11 05       	cpc	r17, r1
    502a:	10 f0       	brcs	.+4      	; 0x5030 <main+0xbac>
    502c:	00 e4       	ldi	r16, 0x40	; 64
    502e:	10 e0       	ldi	r17, 0x00	; 0
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    5030:	61 2c       	mov	r6, r1
    5032:	0d c0       	rjmp	.+26     	; 0x504e <main+0xbca>
			{
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    5034:	8f ef       	ldi	r24, 0xFF	; 255
    5036:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    503a:	80 91 83 05 	lds	r24, 0x0583
    503e:	90 91 84 05 	lds	r25, 0x0584
    5042:	01 97       	sbiw	r24, 0x01	; 1
    5044:	90 93 84 05 	sts	0x0584, r25
    5048:	80 93 83 05 	sts	0x0583, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    504c:	63 94       	inc	r6
    504e:	86 2d       	mov	r24, r6
    5050:	90 e0       	ldi	r25, 0x00	; 0
    5052:	80 17       	cp	r24, r16
    5054:	91 07       	cpc	r25, r17
    5056:	70 f3       	brcs	.-36     	; 0x5034 <main+0xbb0>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    5058:	80 91 83 05 	lds	r24, 0x0583
    505c:	90 91 84 05 	lds	r25, 0x0584
    5060:	89 2b       	or	r24, r25
    5062:	09 f5       	brne	.+66     	; 0x50a6 <main+0xc22>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5064:	8f ef       	ldi	r24, 0xFF	; 255
    5066:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    506a:	8f ef       	ldi	r24, 0xFF	; 255
    506c:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5070:	80 91 c8 00 	lds	r24, 0x00C8
    5074:	86 ff       	sbrs	r24, 6
    5076:	fc cf       	rjmp	.-8      	; 0x5070 <main+0xbec>
					;

				EndSdTransfer();				// Bring CS high
    5078:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    507c:	8f ef       	ldi	r24, 0xFF	; 255
    507e:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5082:	80 91 c8 00 	lds	r24, 0x00C8
    5086:	86 ff       	sbrs	r24, 6
    5088:	fc cf       	rjmp	.-8      	; 0x5082 <main+0xbfe>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
    508a:	d0 92 59 05 	sts	0x0559, r13

				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    508e:	80 91 79 05 	lds	r24, 0x0579
    5092:	81 30       	cpi	r24, 0x01	; 1
    5094:	41 f4       	brne	.+16     	; 0x50a6 <main+0xc22>
				{
					sdPlaybackQueued=false;
    5096:	10 92 79 05 	sts	0x0579, r1
//					PlaySampleFromSd(sdQueuedBank,sdQueuedSlot);	// Trigger the next stream immediately
					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
    509a:	80 91 77 05 	lds	r24, 0x0577
    509e:	90 91 78 05 	lds	r25, 0x0578
    50a2:	0e 94 7c 11 	call	0x22f8	; 0x22f8 <PlaySampleFromSd>
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
		HandleLeds();			// Keep LEDs updated.
		UpdateCard();			// Keep the SD card state machine running.
		GetRandomLongInt();		// Keep random numbers rolling.
    50a6:	0e 94 04 09 	call	0x1208	; 0x1208 <GetRandomLongInt>

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    50aa:	0e 94 1e 1e 	call	0x3c3c	; 0x3c3c <Uart0GotByte>
    50ae:	88 23       	and	r24, r24
    50b0:	21 f0       	breq	.+8      	; 0x50ba <main+0xc36>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    50b2:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <Uart0GetByte>
    50b6:	0e 94 ef 1e 	call	0x3dde	; 0x3dde <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    50ba:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <MidiTxBufferNotEmpty>
    50be:	88 23       	and	r24, r24
    50c0:	41 f0       	breq	.+16     	; 0x50d2 <main+0xc4e>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    50c2:	80 91 c0 00 	lds	r24, 0x00C0
    50c6:	85 ff       	sbrs	r24, 5
    50c8:	04 c0       	rjmp	.+8      	; 0x50d2 <main+0xc4e>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    50ca:	0e 94 b9 1f 	call	0x3f72	; 0x3f72 <PopOutgoingMidiByte>
    50ce:	80 93 c6 00 	sts	0x00C6, r24
			}
		}

		State();				// Execute the current program state.
    50d2:	e0 91 e4 05 	lds	r30, 0x05E4
    50d6:	f0 91 e5 05 	lds	r31, 0x05E5
    50da:	09 95       	icall
	}
    50dc:	67 ca       	rjmp	.-2866   	; 0x45ac <main+0x128>
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    50de:	b7 01       	movw	r22, r14
    50e0:	02 c0       	rjmp	.+4      	; 0x50e6 <main+0xc62>
    50e2:	66 0f       	add	r22, r22
    50e4:	77 1f       	adc	r23, r23
    50e6:	2a 95       	dec	r18
    50e8:	e2 f7       	brpl	.-8      	; 0x50e2 <main+0xc5e>
    50ea:	9b 01       	movw	r18, r22
    50ec:	24 2b       	or	r18, r20
    50ee:	20 83       	st	Z, r18
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    50f0:	86 e0       	ldi	r24, 0x06	; 6
    50f2:	80 93 59 05 	sts	0x0559, r24
    50f6:	d7 cf       	rjmp	.-82     	; 0x50a6 <main+0xc22>
						}
						else
						{
							cardState=SD_IDLE;				// DONE!
    50f8:	d0 92 59 05 	sts	0x0559, r13
    50fc:	d4 cf       	rjmp	.-88     	; 0x50a6 <main+0xc22>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    50fe:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5102:	8f ef       	ldi	r24, 0xFF	; 255
    5104:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    5108:	f4 cc       	rjmp	.-1560   	; 0x4af2 <main+0x66e>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    510a:	0e 94 7d 20 	call	0x40fa	; 0x40fa <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    510e:	8f ef       	ldi	r24, 0xFF	; 255
    5110:	0e 94 82 20 	call	0x4104	; 0x4104 <TransferSdByte>
    5114:	fc cd       	rjmp	.-1032   	; 0x4d0e <main+0x88a>

00005116 <__udivmodqi4>:
    5116:	99 1b       	sub	r25, r25
    5118:	79 e0       	ldi	r23, 0x09	; 9
    511a:	04 c0       	rjmp	.+8      	; 0x5124 <__udivmodqi4_ep>

0000511c <__udivmodqi4_loop>:
    511c:	99 1f       	adc	r25, r25
    511e:	96 17       	cp	r25, r22
    5120:	08 f0       	brcs	.+2      	; 0x5124 <__udivmodqi4_ep>
    5122:	96 1b       	sub	r25, r22

00005124 <__udivmodqi4_ep>:
    5124:	88 1f       	adc	r24, r24
    5126:	7a 95       	dec	r23
    5128:	c9 f7       	brne	.-14     	; 0x511c <__udivmodqi4_loop>
    512a:	80 95       	com	r24
    512c:	08 95       	ret

0000512e <__udivmodsi4>:
    512e:	a1 e2       	ldi	r26, 0x21	; 33
    5130:	1a 2e       	mov	r1, r26
    5132:	aa 1b       	sub	r26, r26
    5134:	bb 1b       	sub	r27, r27
    5136:	fd 01       	movw	r30, r26
    5138:	0d c0       	rjmp	.+26     	; 0x5154 <__udivmodsi4_ep>

0000513a <__udivmodsi4_loop>:
    513a:	aa 1f       	adc	r26, r26
    513c:	bb 1f       	adc	r27, r27
    513e:	ee 1f       	adc	r30, r30
    5140:	ff 1f       	adc	r31, r31
    5142:	a2 17       	cp	r26, r18
    5144:	b3 07       	cpc	r27, r19
    5146:	e4 07       	cpc	r30, r20
    5148:	f5 07       	cpc	r31, r21
    514a:	20 f0       	brcs	.+8      	; 0x5154 <__udivmodsi4_ep>
    514c:	a2 1b       	sub	r26, r18
    514e:	b3 0b       	sbc	r27, r19
    5150:	e4 0b       	sbc	r30, r20
    5152:	f5 0b       	sbc	r31, r21

00005154 <__udivmodsi4_ep>:
    5154:	66 1f       	adc	r22, r22
    5156:	77 1f       	adc	r23, r23
    5158:	88 1f       	adc	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	1a 94       	dec	r1
    515e:	69 f7       	brne	.-38     	; 0x513a <__udivmodsi4_loop>
    5160:	60 95       	com	r22
    5162:	70 95       	com	r23
    5164:	80 95       	com	r24
    5166:	90 95       	com	r25
    5168:	9b 01       	movw	r18, r22
    516a:	ac 01       	movw	r20, r24
    516c:	bd 01       	movw	r22, r26
    516e:	cf 01       	movw	r24, r30
    5170:	08 95       	ret

00005172 <__tablejump2__>:
    5172:	ee 0f       	add	r30, r30
    5174:	ff 1f       	adc	r31, r31

00005176 <__tablejump__>:
    5176:	05 90       	lpm	r0, Z+
    5178:	f4 91       	lpm	r31, Z
    517a:	e0 2d       	mov	r30, r0
    517c:	09 94       	ijmp

0000517e <__umulhisi3>:
    517e:	a2 9f       	mul	r26, r18
    5180:	b0 01       	movw	r22, r0
    5182:	b3 9f       	mul	r27, r19
    5184:	c0 01       	movw	r24, r0
    5186:	a3 9f       	mul	r26, r19
    5188:	01 d0       	rcall	.+2      	; 0x518c <__umulhisi3+0xe>
    518a:	b2 9f       	mul	r27, r18
    518c:	70 0d       	add	r23, r0
    518e:	81 1d       	adc	r24, r1
    5190:	11 24       	eor	r1, r1
    5192:	91 1d       	adc	r25, r1
    5194:	08 95       	ret

00005196 <__muluhisi3>:
    5196:	0e 94 bf 28 	call	0x517e	; 0x517e <__umulhisi3>
    519a:	a5 9f       	mul	r26, r21
    519c:	90 0d       	add	r25, r0
    519e:	b4 9f       	mul	r27, r20
    51a0:	90 0d       	add	r25, r0
    51a2:	a4 9f       	mul	r26, r20
    51a4:	80 0d       	add	r24, r0
    51a6:	91 1d       	adc	r25, r1
    51a8:	11 24       	eor	r1, r1
    51aa:	08 95       	ret

000051ac <_exit>:
    51ac:	f8 94       	cli

000051ae <__stop_program>:
    51ae:	ff cf       	rjmp	.-2      	; 0x51ae <__stop_program>
