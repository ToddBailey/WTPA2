
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000057a0  00005834  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000057a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000544  0080011e  0080011e  00005852  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00005854  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000070  00000000  00000000  00005f20  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00005f90  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000003b0  00000000  00000000  00006050  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002bbd  00000000  00000000  00006400  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000008bd  00000000  00000000  00008fbd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00004064  00000000  00000000  0000987a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000410  00000000  00000000  0000d8e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001374  00000000  00000000  0000dcf0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001278  00000000  00000000  0000f064  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000002e8  00000000  00000000  000102dc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 56 09 	jmp	0x12ac	; 0x12ac <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 a5 0c 	jmp	0x194a	; 0x194a <__vector_9>
      28:	0c 94 d0 0a 	jmp	0x15a0	; 0x15a0 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 0f 09 	jmp	0x121e	; 0x121e <__vector_12>
      34:	0c 94 9e 09 	jmp	0x133c	; 0x133c <__vector_13>
      38:	0c 94 37 0a 	jmp	0x146e	; 0x146e <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	6d 22       	and	r6, r29
      7e:	f5 24       	eor	r15, r5
      80:	f5 24       	eor	r15, r5
      82:	f5 24       	eor	r15, r5
      84:	f5 24       	eor	r15, r5
      86:	f5 24       	eor	r15, r5
      88:	94 22       	and	r9, r20
      8a:	f5 24       	eor	r15, r5
      8c:	f5 24       	eor	r15, r5
      8e:	f5 24       	eor	r15, r5
      90:	f5 24       	eor	r15, r5
      92:	e0 22       	and	r14, r16
      94:	12 23       	and	r17, r18
      96:	37 23       	and	r19, r23
      98:	5c 23       	and	r21, r28
      9a:	83 23       	and	r24, r19
      9c:	9e 23       	and	r25, r30
      9e:	b3 23       	and	r27, r19
      a0:	ba 23       	and	r27, r26
      a2:	cc 23       	and	r28, r28
      a4:	e8 23       	and	r30, r24
      a6:	0f 24       	eor	r0, r15
      a8:	22 24       	eor	r2, r2
      aa:	35 24       	eor	r3, r5
      ac:	48 24       	eor	r4, r8
      ae:	6d 24       	eor	r6, r13
      b0:	83 24       	eor	r8, r3
      b2:	99 24       	eor	r9, r9

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e0 ea       	ldi	r30, 0xA0	; 160
      c8:	f7 e5       	ldi	r31, 0x57	; 87
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <.do_copy_data_start>

000000cc <.do_copy_data_loop>:
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0

000000d0 <.do_copy_data_start>:
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <.do_copy_data_loop>

000000d6 <__do_clear_bss>:
      d6:	16 e0       	ldi	r17, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a2 36       	cpi	r26, 0x62	; 98
      e2:	b1 07       	cpc	r27, r17
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 90 16 	call	0x2d20	; 0x2d20 <main>
      ea:	0c 94 ce 2b 	jmp	0x579c	; 0x579c <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 c0 0c 	jmp	0x1980	; 0x1980 <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 e6 05 	lds	r24, 0x05E6
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c9 f0       	breq	.+50     	; 0x12c <UpdateAudioChannel0+0x3a>
      fa:	84 30       	cpi	r24, 0x04	; 4
      fc:	30 f4       	brcc	.+12     	; 0x10a <UpdateAudioChannel0+0x18>
      fe:	81 30       	cpi	r24, 0x01	; 1
     100:	59 f0       	breq	.+22     	; 0x118 <UpdateAudioChannel0+0x26>
     102:	82 30       	cpi	r24, 0x02	; 2
     104:	09 f0       	breq	.+2      	; 0x108 <UpdateAudioChannel0+0x16>
     106:	8e c0       	rjmp	.+284    	; 0x224 <UpdateAudioChannel0+0x132>
     108:	0e c0       	rjmp	.+28     	; 0x126 <UpdateAudioChannel0+0x34>
     10a:	84 30       	cpi	r24, 0x04	; 4
     10c:	09 f4       	brne	.+2      	; 0x110 <UpdateAudioChannel0+0x1e>
     10e:	8c c0       	rjmp	.+280    	; 0x228 <UpdateAudioChannel0+0x136>
     110:	85 30       	cpi	r24, 0x05	; 5
     112:	09 f0       	breq	.+2      	; 0x116 <UpdateAudioChannel0+0x24>
     114:	87 c0       	rjmp	.+270    	; 0x224 <UpdateAudioChannel0+0x132>
     116:	0d c2       	rjmp	.+1050   	; 0x532 <UpdateAudioChannel0+0x440>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     118:	40 91 38 01 	lds	r20, 0x0138
     11c:	4f 5f       	subi	r20, 0xFF	; 255
     11e:	40 93 38 01 	sts	0x0138, r20
     122:	41 50       	subi	r20, 0x01	; 1
     124:	a3 c3       	rjmp	.+1862   	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     126:	40 91 58 02 	lds	r20, 0x0258
     12a:	f1 c1       	rjmp	.+994    	; 0x50e <UpdateAudioChannel0+0x41c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     130:	80 91 05 06 	lds	r24, 0x0605
     134:	90 91 06 06 	lds	r25, 0x0606
     138:	a0 91 07 06 	lds	r26, 0x0607
     13c:	b0 91 08 06 	lds	r27, 0x0608
     140:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     142:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     144:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     146:	80 91 05 06 	lds	r24, 0x0605
     14a:	90 91 06 06 	lds	r25, 0x0606
     14e:	a0 91 07 06 	lds	r26, 0x0607
     152:	b0 91 08 06 	lds	r27, 0x0608
     156:	89 2f       	mov	r24, r25
     158:	9a 2f       	mov	r25, r26
     15a:	ab 2f       	mov	r26, r27
     15c:	bb 27       	eor	r27, r27
     15e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     160:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     162:	14 98       	cbi	0x02, 4	; 2
		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     164:	80 91 05 06 	lds	r24, 0x0605
     168:	90 91 06 06 	lds	r25, 0x0606
     16c:	a0 91 07 06 	lds	r26, 0x0607
     170:	b0 91 08 06 	lds	r27, 0x0608
     174:	cd 01       	movw	r24, r26
     176:	aa 27       	eor	r26, r26
     178:	bb 27       	eor	r27, r27
     17a:	87 70       	andi	r24, 0x07	; 7
     17c:	88 68       	ori	r24, 0x88	; 136
     17e:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     180:	80 91 58 02 	lds	r24, 0x0258
     184:	85 b9       	out	0x05, r24	; 5
		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     186:	80 91 05 06 	lds	r24, 0x0605
     18a:	90 91 06 06 	lds	r25, 0x0606
     18e:	a0 91 07 06 	lds	r26, 0x0607
     192:	b0 91 08 06 	lds	r27, 0x0608
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	a1 1d       	adc	r26, r1
     19a:	b1 1d       	adc	r27, r1
     19c:	80 93 05 06 	sts	0x0605, r24
     1a0:	90 93 06 06 	sts	0x0606, r25
     1a4:	a0 93 07 06 	sts	0x0607, r26
     1a8:	b0 93 08 06 	sts	0x0608, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1ac:	80 91 05 06 	lds	r24, 0x0605
     1b0:	90 91 06 06 	lds	r25, 0x0606
     1b4:	a0 91 07 06 	lds	r26, 0x0607
     1b8:	b0 91 08 06 	lds	r27, 0x0608
     1bc:	80 93 f2 05 	sts	0x05F2, r24
     1c0:	90 93 f3 05 	sts	0x05F3, r25
     1c4:	a0 93 f4 05 	sts	0x05F4, r26
     1c8:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1cc:	80 91 05 06 	lds	r24, 0x0605
     1d0:	90 91 06 06 	lds	r25, 0x0606
     1d4:	a0 91 07 06 	lds	r26, 0x0607
     1d8:	b0 91 08 06 	lds	r27, 0x0608
     1dc:	80 93 fa 05 	sts	0x05FA, r24
     1e0:	90 93 fb 05 	sts	0x05FB, r25
     1e4:	a0 93 fc 05 	sts	0x05FC, r26
     1e8:	b0 93 fd 05 	sts	0x05FD, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1ec:	20 91 f2 05 	lds	r18, 0x05F2
     1f0:	30 91 f3 05 	lds	r19, 0x05F3
     1f4:	40 91 f4 05 	lds	r20, 0x05F4
     1f8:	50 91 f5 05 	lds	r21, 0x05F5
     1fc:	80 91 15 06 	lds	r24, 0x0615
     200:	90 91 16 06 	lds	r25, 0x0616
     204:	a0 91 17 06 	lds	r26, 0x0617
     208:	b0 91 18 06 	lds	r27, 0x0618
     20c:	28 17       	cp	r18, r24
     20e:	39 07       	cpc	r19, r25
     210:	4a 07       	cpc	r20, r26
     212:	5b 07       	cpc	r21, r27
     214:	28 f0       	brcs	.+10     	; 0x220 <UpdateAudioChannel0+0x12e>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     216:	10 92 e6 05 	sts	0x05E6, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	80 93 42 01 	sts	0x0142, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     220:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     222:	11 9a       	sbi	0x02, 1	; 2
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	22 c3       	rjmp	.+1604   	; 0x86c <UpdateAudioChannel0+0x77a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     228:	80 91 05 06 	lds	r24, 0x0605
     22c:	90 91 06 06 	lds	r25, 0x0606
     230:	a0 91 07 06 	lds	r26, 0x0607
     234:	b0 91 08 06 	lds	r27, 0x0608
     238:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23a:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23c:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     23e:	80 91 05 06 	lds	r24, 0x0605
     242:	90 91 06 06 	lds	r25, 0x0606
     246:	a0 91 07 06 	lds	r26, 0x0607
     24a:	b0 91 08 06 	lds	r27, 0x0608
     24e:	89 2f       	mov	r24, r25
     250:	9a 2f       	mov	r25, r26
     252:	ab 2f       	mov	r26, r27
     254:	bb 27       	eor	r27, r27
     256:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     258:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25a:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25c:	80 91 05 06 	lds	r24, 0x0605
     260:	90 91 06 06 	lds	r25, 0x0606
     264:	a0 91 07 06 	lds	r26, 0x0607
     268:	b0 91 08 06 	lds	r27, 0x0608
     26c:	cd 01       	movw	r24, r26
     26e:	aa 27       	eor	r26, r26
     270:	bb 27       	eor	r27, r27
     272:	87 70       	andi	r24, 0x07	; 7
     274:	88 68       	ori	r24, 0x88	; 136
     276:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     278:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     27a:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     27c:	80 91 ec 05 	lds	r24, 0x05EC
     280:	88 23       	and	r24, r24
     282:	09 f4       	brne	.+2      	; 0x286 <UpdateAudioChannel0+0x194>
     284:	6c c0       	rjmp	.+216    	; 0x35e <UpdateAudioChannel0+0x26c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     286:	80 91 50 01 	lds	r24, 0x0150
     28a:	90 91 51 01 	lds	r25, 0x0151
     28e:	a0 91 52 01 	lds	r26, 0x0152
     292:	b0 91 53 01 	lds	r27, 0x0153
     296:	00 97       	sbiw	r24, 0x00	; 0
     298:	a1 05       	cpc	r26, r1
     29a:	b1 05       	cpc	r27, r1
     29c:	39 f1       	breq	.+78     	; 0x2ec <UpdateAudioChannel0+0x1fa>
			{
				bankStates[BANK_0].currentAddress++;
     29e:	80 91 05 06 	lds	r24, 0x0605
     2a2:	90 91 06 06 	lds	r25, 0x0606
     2a6:	a0 91 07 06 	lds	r26, 0x0607
     2aa:	b0 91 08 06 	lds	r27, 0x0608
     2ae:	01 96       	adiw	r24, 0x01	; 1
     2b0:	a1 1d       	adc	r26, r1
     2b2:	b1 1d       	adc	r27, r1
     2b4:	80 93 05 06 	sts	0x0605, r24
     2b8:	90 93 06 06 	sts	0x0606, r25
     2bc:	a0 93 07 06 	sts	0x0607, r26
     2c0:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     2c4:	80 91 50 01 	lds	r24, 0x0150
     2c8:	90 91 51 01 	lds	r25, 0x0151
     2cc:	a0 91 52 01 	lds	r26, 0x0152
     2d0:	b0 91 53 01 	lds	r27, 0x0153
     2d4:	01 97       	sbiw	r24, 0x01	; 1
     2d6:	a1 09       	sbc	r26, r1
     2d8:	b1 09       	sbc	r27, r1
     2da:	80 93 50 01 	sts	0x0150, r24
     2de:	90 93 51 01 	sts	0x0151, r25
     2e2:	a0 93 52 01 	sts	0x0152, r26
     2e6:	b0 93 53 01 	sts	0x0153, r27
     2ea:	0d c1       	rjmp	.+538    	; 0x506 <UpdateAudioChannel0+0x414>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2ec:	80 91 48 01 	lds	r24, 0x0148
     2f0:	90 91 49 01 	lds	r25, 0x0149
     2f4:	a0 91 4a 01 	lds	r26, 0x014A
     2f8:	b0 91 4b 01 	lds	r27, 0x014B
     2fc:	80 93 50 01 	sts	0x0150, r24
     300:	90 93 51 01 	sts	0x0151, r25
     304:	a0 93 52 01 	sts	0x0152, r26
     308:	b0 93 53 01 	sts	0x0153, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     30c:	80 91 46 01 	lds	r24, 0x0146
     310:	8f 5f       	subi	r24, 0xFF	; 255
     312:	80 93 46 01 	sts	0x0146, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     316:	90 91 46 01 	lds	r25, 0x0146
     31a:	80 91 ec 05 	lds	r24, 0x05EC
     31e:	98 17       	cp	r25, r24
     320:	11 f4       	brne	.+4      	; 0x326 <UpdateAudioChannel0+0x234>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     322:	10 92 46 01 	sts	0x0146, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     326:	e0 91 46 01 	lds	r30, 0x0146
     32a:	20 91 48 01 	lds	r18, 0x0148
     32e:	30 91 49 01 	lds	r19, 0x0149
     332:	40 91 4a 01 	lds	r20, 0x014A
     336:	50 91 4b 01 	lds	r21, 0x014B
     33a:	f0 e0       	ldi	r31, 0x00	; 0
     33c:	e8 5a       	subi	r30, 0xA8	; 168
     33e:	fe 4f       	sbci	r31, 0xFE	; 254
     340:	60 81       	ld	r22, Z
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 e0       	ldi	r24, 0x00	; 0
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
     34c:	60 93 05 06 	sts	0x0605, r22
     350:	70 93 06 06 	sts	0x0606, r23
     354:	80 93 07 06 	sts	0x0607, r24
     358:	90 93 08 06 	sts	0x0608, r25
     35c:	d4 c0       	rjmp	.+424    	; 0x506 <UpdateAudioChannel0+0x414>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     35e:	80 91 ea 05 	lds	r24, 0x05EA
     362:	88 23       	and	r24, r24
     364:	09 f0       	breq	.+2      	; 0x368 <UpdateAudioChannel0+0x276>
     366:	62 c0       	rjmp	.+196    	; 0x42c <UpdateAudioChannel0+0x33a>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     368:	20 91 05 06 	lds	r18, 0x0605
     36c:	30 91 06 06 	lds	r19, 0x0606
     370:	40 91 07 06 	lds	r20, 0x0607
     374:	50 91 08 06 	lds	r21, 0x0608
     378:	80 91 fe 05 	lds	r24, 0x05FE
     37c:	90 91 ff 05 	lds	r25, 0x05FF
     380:	a0 91 00 06 	lds	r26, 0x0600
     384:	b0 91 01 06 	lds	r27, 0x0601
     388:	28 17       	cp	r18, r24
     38a:	39 07       	cpc	r19, r25
     38c:	4a 07       	cpc	r20, r26
     38e:	5b 07       	cpc	r21, r27
     390:	29 f4       	brne	.+10     	; 0x39c <UpdateAudioChannel0+0x2aa>
     392:	80 91 e7 05 	lds	r24, 0x05E7
     396:	81 30       	cpi	r24, 0x01	; 1
     398:	09 f4       	brne	.+2      	; 0x39c <UpdateAudioChannel0+0x2aa>
     39a:	61 c0       	rjmp	.+194    	; 0x45e <UpdateAudioChannel0+0x36c>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39c:	20 91 05 06 	lds	r18, 0x0605
     3a0:	30 91 06 06 	lds	r19, 0x0606
     3a4:	40 91 07 06 	lds	r20, 0x0607
     3a8:	50 91 08 06 	lds	r21, 0x0608
     3ac:	80 91 fe 05 	lds	r24, 0x05FE
     3b0:	90 91 ff 05 	lds	r25, 0x05FF
     3b4:	a0 91 00 06 	lds	r26, 0x0600
     3b8:	b0 91 01 06 	lds	r27, 0x0601
     3bc:	28 17       	cp	r18, r24
     3be:	39 07       	cpc	r19, r25
     3c0:	4a 07       	cpc	r20, r26
     3c2:	5b 07       	cpc	r21, r27
     3c4:	49 f4       	brne	.+18     	; 0x3d8 <UpdateAudioChannel0+0x2e6>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c6:	80 91 fa 05 	lds	r24, 0x05FA
     3ca:	90 91 fb 05 	lds	r25, 0x05FB
     3ce:	a0 91 fc 05 	lds	r26, 0x05FC
     3d2:	b0 91 fd 05 	lds	r27, 0x05FD
     3d6:	8f c0       	rjmp	.+286    	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3d8:	20 91 05 06 	lds	r18, 0x0605
     3dc:	30 91 06 06 	lds	r19, 0x0606
     3e0:	40 91 07 06 	lds	r20, 0x0607
     3e4:	50 91 08 06 	lds	r21, 0x0608
     3e8:	80 91 f6 05 	lds	r24, 0x05F6
     3ec:	90 91 f7 05 	lds	r25, 0x05F7
     3f0:	a0 91 f8 05 	lds	r26, 0x05F8
     3f4:	b0 91 f9 05 	lds	r27, 0x05F9
     3f8:	28 17       	cp	r18, r24
     3fa:	39 07       	cpc	r19, r25
     3fc:	4a 07       	cpc	r20, r26
     3fe:	5b 07       	cpc	r21, r27
     400:	49 f4       	brne	.+18     	; 0x414 <UpdateAudioChannel0+0x322>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     402:	80 91 f2 05 	lds	r24, 0x05F2
     406:	90 91 f3 05 	lds	r25, 0x05F3
     40a:	a0 91 f4 05 	lds	r26, 0x05F4
     40e:	b0 91 f5 05 	lds	r27, 0x05F5
     412:	71 c0       	rjmp	.+226    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     414:	80 91 05 06 	lds	r24, 0x0605
     418:	90 91 06 06 	lds	r25, 0x0606
     41c:	a0 91 07 06 	lds	r26, 0x0607
     420:	b0 91 08 06 	lds	r27, 0x0608
     424:	01 97       	sbiw	r24, 0x01	; 1
     426:	a1 09       	sbc	r26, r1
     428:	b1 09       	sbc	r27, r1
     42a:	65 c0       	rjmp	.+202    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42c:	20 91 05 06 	lds	r18, 0x0605
     430:	30 91 06 06 	lds	r19, 0x0606
     434:	40 91 07 06 	lds	r20, 0x0607
     438:	50 91 08 06 	lds	r21, 0x0608
     43c:	80 91 fa 05 	lds	r24, 0x05FA
     440:	90 91 fb 05 	lds	r25, 0x05FB
     444:	a0 91 fc 05 	lds	r26, 0x05FC
     448:	b0 91 fd 05 	lds	r27, 0x05FD
     44c:	28 17       	cp	r18, r24
     44e:	39 07       	cpc	r19, r25
     450:	4a 07       	cpc	r20, r26
     452:	5b 07       	cpc	r21, r27
     454:	49 f4       	brne	.+18     	; 0x468 <UpdateAudioChannel0+0x376>
     456:	80 91 e7 05 	lds	r24, 0x05E7
     45a:	81 30       	cpi	r24, 0x01	; 1
     45c:	29 f4       	brne	.+10     	; 0x468 <UpdateAudioChannel0+0x376>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     45e:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     462:	10 92 ef 05 	sts	0x05EF, r1
     466:	4f c0       	rjmp	.+158    	; 0x506 <UpdateAudioChannel0+0x414>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     468:	20 91 05 06 	lds	r18, 0x0605
     46c:	30 91 06 06 	lds	r19, 0x0606
     470:	40 91 07 06 	lds	r20, 0x0607
     474:	50 91 08 06 	lds	r21, 0x0608
     478:	80 91 fa 05 	lds	r24, 0x05FA
     47c:	90 91 fb 05 	lds	r25, 0x05FB
     480:	a0 91 fc 05 	lds	r26, 0x05FC
     484:	b0 91 fd 05 	lds	r27, 0x05FD
     488:	28 17       	cp	r18, r24
     48a:	39 07       	cpc	r19, r25
     48c:	4a 07       	cpc	r20, r26
     48e:	5b 07       	cpc	r21, r27
     490:	49 f4       	brne	.+18     	; 0x4a4 <UpdateAudioChannel0+0x3b2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     492:	80 91 fe 05 	lds	r24, 0x05FE
     496:	90 91 ff 05 	lds	r25, 0x05FF
     49a:	a0 91 00 06 	lds	r26, 0x0600
     49e:	b0 91 01 06 	lds	r27, 0x0601
     4a2:	29 c0       	rjmp	.+82     	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     4a4:	20 91 05 06 	lds	r18, 0x0605
     4a8:	30 91 06 06 	lds	r19, 0x0606
     4ac:	40 91 07 06 	lds	r20, 0x0607
     4b0:	50 91 08 06 	lds	r21, 0x0608
     4b4:	80 91 f2 05 	lds	r24, 0x05F2
     4b8:	90 91 f3 05 	lds	r25, 0x05F3
     4bc:	a0 91 f4 05 	lds	r26, 0x05F4
     4c0:	b0 91 f5 05 	lds	r27, 0x05F5
     4c4:	28 17       	cp	r18, r24
     4c6:	39 07       	cpc	r19, r25
     4c8:	4a 07       	cpc	r20, r26
     4ca:	5b 07       	cpc	r21, r27
     4cc:	49 f4       	brne	.+18     	; 0x4e0 <UpdateAudioChannel0+0x3ee>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4ce:	80 91 f6 05 	lds	r24, 0x05F6
     4d2:	90 91 f7 05 	lds	r25, 0x05F7
     4d6:	a0 91 f8 05 	lds	r26, 0x05F8
     4da:	b0 91 f9 05 	lds	r27, 0x05F9
     4de:	0b c0       	rjmp	.+22     	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4e0:	80 91 05 06 	lds	r24, 0x0605
     4e4:	90 91 06 06 	lds	r25, 0x0606
     4e8:	a0 91 07 06 	lds	r26, 0x0607
     4ec:	b0 91 08 06 	lds	r27, 0x0608
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	a1 1d       	adc	r26, r1
     4f4:	b1 1d       	adc	r27, r1
     4f6:	80 93 05 06 	sts	0x0605, r24
     4fa:	90 93 06 06 	sts	0x0606, r25
     4fe:	a0 93 07 06 	sts	0x0607, r26
     502:	b0 93 08 06 	sts	0x0608, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     506:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     508:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     50a:	8f ef       	ldi	r24, 0xFF	; 255
     50c:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     50e:	80 91 ee 05 	lds	r24, 0x05EE
     512:	88 23       	and	r24, r24
     514:	09 f4       	brne	.+2      	; 0x518 <UpdateAudioChannel0+0x426>
     516:	aa c1       	rjmp	.+852    	; 0x86c <UpdateAudioChannel0+0x77a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     518:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     51a:	20 91 ee 05 	lds	r18, 0x05EE
     51e:	8f ef       	ldi	r24, 0xFF	; 255
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	02 c0       	rjmp	.+4      	; 0x528 <UpdateAudioChannel0+0x436>
     524:	88 0f       	add	r24, r24
     526:	99 1f       	adc	r25, r25
     528:	2a 95       	dec	r18
     52a:	e2 f7       	brpl	.-8      	; 0x524 <UpdateAudioChannel0+0x432>
     52c:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     52e:	40 58       	subi	r20, 0x80	; 128
     530:	9d c1       	rjmp	.+826    	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     532:	80 91 05 06 	lds	r24, 0x0605
     536:	90 91 06 06 	lds	r25, 0x0606
     53a:	a0 91 07 06 	lds	r26, 0x0607
     53e:	b0 91 08 06 	lds	r27, 0x0608
     542:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     544:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     546:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     548:	80 91 05 06 	lds	r24, 0x0605
     54c:	90 91 06 06 	lds	r25, 0x0606
     550:	a0 91 07 06 	lds	r26, 0x0607
     554:	b0 91 08 06 	lds	r27, 0x0608
     558:	89 2f       	mov	r24, r25
     55a:	9a 2f       	mov	r25, r26
     55c:	ab 2f       	mov	r26, r27
     55e:	bb 27       	eor	r27, r27
     560:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     562:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     564:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     566:	80 91 05 06 	lds	r24, 0x0605
     56a:	90 91 06 06 	lds	r25, 0x0606
     56e:	a0 91 07 06 	lds	r26, 0x0607
     572:	b0 91 08 06 	lds	r27, 0x0608
     576:	cd 01       	movw	r24, r26
     578:	aa 27       	eor	r26, r26
     57a:	bb 27       	eor	r27, r27
     57c:	87 70       	andi	r24, 0x07	; 7
     57e:	88 68       	ori	r24, 0x88	; 136
     580:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     582:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     584:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     586:	80 91 ec 05 	lds	r24, 0x05EC
     58a:	88 23       	and	r24, r24
     58c:	09 f4       	brne	.+2      	; 0x590 <UpdateAudioChannel0+0x49e>
     58e:	6c c0       	rjmp	.+216    	; 0x668 <UpdateAudioChannel0+0x576>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     590:	80 91 50 01 	lds	r24, 0x0150
     594:	90 91 51 01 	lds	r25, 0x0151
     598:	a0 91 52 01 	lds	r26, 0x0152
     59c:	b0 91 53 01 	lds	r27, 0x0153
     5a0:	00 97       	sbiw	r24, 0x00	; 0
     5a2:	a1 05       	cpc	r26, r1
     5a4:	b1 05       	cpc	r27, r1
     5a6:	39 f1       	breq	.+78     	; 0x5f6 <UpdateAudioChannel0+0x504>
			{
				bankStates[BANK_0].currentAddress++;
     5a8:	80 91 05 06 	lds	r24, 0x0605
     5ac:	90 91 06 06 	lds	r25, 0x0606
     5b0:	a0 91 07 06 	lds	r26, 0x0607
     5b4:	b0 91 08 06 	lds	r27, 0x0608
     5b8:	01 96       	adiw	r24, 0x01	; 1
     5ba:	a1 1d       	adc	r26, r1
     5bc:	b1 1d       	adc	r27, r1
     5be:	80 93 05 06 	sts	0x0605, r24
     5c2:	90 93 06 06 	sts	0x0606, r25
     5c6:	a0 93 07 06 	sts	0x0607, r26
     5ca:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     5ce:	80 91 50 01 	lds	r24, 0x0150
     5d2:	90 91 51 01 	lds	r25, 0x0151
     5d6:	a0 91 52 01 	lds	r26, 0x0152
     5da:	b0 91 53 01 	lds	r27, 0x0153
     5de:	01 97       	sbiw	r24, 0x01	; 1
     5e0:	a1 09       	sbc	r26, r1
     5e2:	b1 09       	sbc	r27, r1
     5e4:	80 93 50 01 	sts	0x0150, r24
     5e8:	90 93 51 01 	sts	0x0151, r25
     5ec:	a0 93 52 01 	sts	0x0152, r26
     5f0:	b0 93 53 01 	sts	0x0153, r27
     5f4:	0d c1       	rjmp	.+538    	; 0x810 <UpdateAudioChannel0+0x71e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5f6:	80 91 48 01 	lds	r24, 0x0148
     5fa:	90 91 49 01 	lds	r25, 0x0149
     5fe:	a0 91 4a 01 	lds	r26, 0x014A
     602:	b0 91 4b 01 	lds	r27, 0x014B
     606:	80 93 50 01 	sts	0x0150, r24
     60a:	90 93 51 01 	sts	0x0151, r25
     60e:	a0 93 52 01 	sts	0x0152, r26
     612:	b0 93 53 01 	sts	0x0153, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     616:	80 91 46 01 	lds	r24, 0x0146
     61a:	8f 5f       	subi	r24, 0xFF	; 255
     61c:	80 93 46 01 	sts	0x0146, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     620:	90 91 46 01 	lds	r25, 0x0146
     624:	80 91 ec 05 	lds	r24, 0x05EC
     628:	98 17       	cp	r25, r24
     62a:	11 f4       	brne	.+4      	; 0x630 <UpdateAudioChannel0+0x53e>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     62c:	10 92 46 01 	sts	0x0146, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     630:	e0 91 46 01 	lds	r30, 0x0146
     634:	20 91 48 01 	lds	r18, 0x0148
     638:	30 91 49 01 	lds	r19, 0x0149
     63c:	40 91 4a 01 	lds	r20, 0x014A
     640:	50 91 4b 01 	lds	r21, 0x014B
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	e8 5a       	subi	r30, 0xA8	; 168
     648:	fe 4f       	sbci	r31, 0xFE	; 254
     64a:	60 81       	ld	r22, Z
     64c:	70 e0       	ldi	r23, 0x00	; 0
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
     656:	60 93 05 06 	sts	0x0605, r22
     65a:	70 93 06 06 	sts	0x0606, r23
     65e:	80 93 07 06 	sts	0x0607, r24
     662:	90 93 08 06 	sts	0x0608, r25
     666:	d4 c0       	rjmp	.+424    	; 0x810 <UpdateAudioChannel0+0x71e>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     668:	80 91 ea 05 	lds	r24, 0x05EA
     66c:	88 23       	and	r24, r24
     66e:	09 f0       	breq	.+2      	; 0x672 <UpdateAudioChannel0+0x580>
     670:	62 c0       	rjmp	.+196    	; 0x736 <UpdateAudioChannel0+0x644>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     672:	20 91 05 06 	lds	r18, 0x0605
     676:	30 91 06 06 	lds	r19, 0x0606
     67a:	40 91 07 06 	lds	r20, 0x0607
     67e:	50 91 08 06 	lds	r21, 0x0608
     682:	80 91 fe 05 	lds	r24, 0x05FE
     686:	90 91 ff 05 	lds	r25, 0x05FF
     68a:	a0 91 00 06 	lds	r26, 0x0600
     68e:	b0 91 01 06 	lds	r27, 0x0601
     692:	28 17       	cp	r18, r24
     694:	39 07       	cpc	r19, r25
     696:	4a 07       	cpc	r20, r26
     698:	5b 07       	cpc	r21, r27
     69a:	29 f4       	brne	.+10     	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     69c:	80 91 e7 05 	lds	r24, 0x05E7
     6a0:	81 30       	cpi	r24, 0x01	; 1
     6a2:	09 f4       	brne	.+2      	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     6a4:	61 c0       	rjmp	.+194    	; 0x768 <UpdateAudioChannel0+0x676>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     6a6:	20 91 05 06 	lds	r18, 0x0605
     6aa:	30 91 06 06 	lds	r19, 0x0606
     6ae:	40 91 07 06 	lds	r20, 0x0607
     6b2:	50 91 08 06 	lds	r21, 0x0608
     6b6:	80 91 fe 05 	lds	r24, 0x05FE
     6ba:	90 91 ff 05 	lds	r25, 0x05FF
     6be:	a0 91 00 06 	lds	r26, 0x0600
     6c2:	b0 91 01 06 	lds	r27, 0x0601
     6c6:	28 17       	cp	r18, r24
     6c8:	39 07       	cpc	r19, r25
     6ca:	4a 07       	cpc	r20, r26
     6cc:	5b 07       	cpc	r21, r27
     6ce:	49 f4       	brne	.+18     	; 0x6e2 <UpdateAudioChannel0+0x5f0>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6d0:	80 91 fa 05 	lds	r24, 0x05FA
     6d4:	90 91 fb 05 	lds	r25, 0x05FB
     6d8:	a0 91 fc 05 	lds	r26, 0x05FC
     6dc:	b0 91 fd 05 	lds	r27, 0x05FD
     6e0:	8f c0       	rjmp	.+286    	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6e2:	20 91 05 06 	lds	r18, 0x0605
     6e6:	30 91 06 06 	lds	r19, 0x0606
     6ea:	40 91 07 06 	lds	r20, 0x0607
     6ee:	50 91 08 06 	lds	r21, 0x0608
     6f2:	80 91 f6 05 	lds	r24, 0x05F6
     6f6:	90 91 f7 05 	lds	r25, 0x05F7
     6fa:	a0 91 f8 05 	lds	r26, 0x05F8
     6fe:	b0 91 f9 05 	lds	r27, 0x05F9
     702:	28 17       	cp	r18, r24
     704:	39 07       	cpc	r19, r25
     706:	4a 07       	cpc	r20, r26
     708:	5b 07       	cpc	r21, r27
     70a:	49 f4       	brne	.+18     	; 0x71e <UpdateAudioChannel0+0x62c>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     70c:	80 91 f2 05 	lds	r24, 0x05F2
     710:	90 91 f3 05 	lds	r25, 0x05F3
     714:	a0 91 f4 05 	lds	r26, 0x05F4
     718:	b0 91 f5 05 	lds	r27, 0x05F5
     71c:	71 c0       	rjmp	.+226    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     71e:	80 91 05 06 	lds	r24, 0x0605
     722:	90 91 06 06 	lds	r25, 0x0606
     726:	a0 91 07 06 	lds	r26, 0x0607
     72a:	b0 91 08 06 	lds	r27, 0x0608
     72e:	01 97       	sbiw	r24, 0x01	; 1
     730:	a1 09       	sbc	r26, r1
     732:	b1 09       	sbc	r27, r1
     734:	65 c0       	rjmp	.+202    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     736:	20 91 05 06 	lds	r18, 0x0605
     73a:	30 91 06 06 	lds	r19, 0x0606
     73e:	40 91 07 06 	lds	r20, 0x0607
     742:	50 91 08 06 	lds	r21, 0x0608
     746:	80 91 fa 05 	lds	r24, 0x05FA
     74a:	90 91 fb 05 	lds	r25, 0x05FB
     74e:	a0 91 fc 05 	lds	r26, 0x05FC
     752:	b0 91 fd 05 	lds	r27, 0x05FD
     756:	28 17       	cp	r18, r24
     758:	39 07       	cpc	r19, r25
     75a:	4a 07       	cpc	r20, r26
     75c:	5b 07       	cpc	r21, r27
     75e:	49 f4       	brne	.+18     	; 0x772 <UpdateAudioChannel0+0x680>
     760:	80 91 e7 05 	lds	r24, 0x05E7
     764:	81 30       	cpi	r24, 0x01	; 1
     766:	29 f4       	brne	.+10     	; 0x772 <UpdateAudioChannel0+0x680>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     768:	10 92 e6 05 	sts	0x05E6, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     76c:	10 92 ef 05 	sts	0x05EF, r1
     770:	4f c0       	rjmp	.+158    	; 0x810 <UpdateAudioChannel0+0x71e>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     772:	20 91 05 06 	lds	r18, 0x0605
     776:	30 91 06 06 	lds	r19, 0x0606
     77a:	40 91 07 06 	lds	r20, 0x0607
     77e:	50 91 08 06 	lds	r21, 0x0608
     782:	80 91 fa 05 	lds	r24, 0x05FA
     786:	90 91 fb 05 	lds	r25, 0x05FB
     78a:	a0 91 fc 05 	lds	r26, 0x05FC
     78e:	b0 91 fd 05 	lds	r27, 0x05FD
     792:	28 17       	cp	r18, r24
     794:	39 07       	cpc	r19, r25
     796:	4a 07       	cpc	r20, r26
     798:	5b 07       	cpc	r21, r27
     79a:	49 f4       	brne	.+18     	; 0x7ae <UpdateAudioChannel0+0x6bc>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     79c:	80 91 fe 05 	lds	r24, 0x05FE
     7a0:	90 91 ff 05 	lds	r25, 0x05FF
     7a4:	a0 91 00 06 	lds	r26, 0x0600
     7a8:	b0 91 01 06 	lds	r27, 0x0601
     7ac:	29 c0       	rjmp	.+82     	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     7ae:	20 91 05 06 	lds	r18, 0x0605
     7b2:	30 91 06 06 	lds	r19, 0x0606
     7b6:	40 91 07 06 	lds	r20, 0x0607
     7ba:	50 91 08 06 	lds	r21, 0x0608
     7be:	80 91 f2 05 	lds	r24, 0x05F2
     7c2:	90 91 f3 05 	lds	r25, 0x05F3
     7c6:	a0 91 f4 05 	lds	r26, 0x05F4
     7ca:	b0 91 f5 05 	lds	r27, 0x05F5
     7ce:	28 17       	cp	r18, r24
     7d0:	39 07       	cpc	r19, r25
     7d2:	4a 07       	cpc	r20, r26
     7d4:	5b 07       	cpc	r21, r27
     7d6:	49 f4       	brne	.+18     	; 0x7ea <UpdateAudioChannel0+0x6f8>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7d8:	80 91 f6 05 	lds	r24, 0x05F6
     7dc:	90 91 f7 05 	lds	r25, 0x05F7
     7e0:	a0 91 f8 05 	lds	r26, 0x05F8
     7e4:	b0 91 f9 05 	lds	r27, 0x05F9
     7e8:	0b c0       	rjmp	.+22     	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7ea:	80 91 05 06 	lds	r24, 0x0605
     7ee:	90 91 06 06 	lds	r25, 0x0606
     7f2:	a0 91 07 06 	lds	r26, 0x0607
     7f6:	b0 91 08 06 	lds	r27, 0x0608
     7fa:	01 96       	adiw	r24, 0x01	; 1
     7fc:	a1 1d       	adc	r26, r1
     7fe:	b1 1d       	adc	r27, r1
     800:	80 93 05 06 	sts	0x0605, r24
     804:	90 93 06 06 	sts	0x0606, r25
     808:	a0 93 07 06 	sts	0x0607, r26
     80c:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM		

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     810:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     812:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     818:	80 91 ee 05 	lds	r24, 0x05EE
     81c:	88 23       	and	r24, r24
     81e:	61 f0       	breq	.+24     	; 0x838 <UpdateAudioChannel0+0x746>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     820:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     822:	20 91 ee 05 	lds	r18, 0x05EE
     826:	8f ef       	ldi	r24, 0xFF	; 255
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	02 c0       	rjmp	.+4      	; 0x830 <UpdateAudioChannel0+0x73e>
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	2a 95       	dec	r18
     832:	e2 f7       	brpl	.-8      	; 0x82c <UpdateAudioChannel0+0x73a>
     834:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     836:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     838:	80 91 58 02 	lds	r24, 0x0258
     83c:	24 2f       	mov	r18, r20
     83e:	33 27       	eor	r19, r19
     840:	27 fd       	sbrc	r18, 7
     842:	30 95       	com	r19
     844:	99 27       	eor	r25, r25
     846:	87 fd       	sbrc	r24, 7
     848:	90 95       	com	r25
     84a:	28 0f       	add	r18, r24
     84c:	39 1f       	adc	r19, r25
     84e:	8f ef       	ldi	r24, 0xFF	; 255
     850:	20 38       	cpi	r18, 0x80	; 128
     852:	38 07       	cpc	r19, r24
     854:	14 f4       	brge	.+4      	; 0x85a <UpdateAudioChannel0+0x768>
     856:	20 e8       	ldi	r18, 0x80	; 128
     858:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     85a:	c9 01       	movw	r24, r18
     85c:	20 38       	cpi	r18, 0x80	; 128
     85e:	31 05       	cpc	r19, r1
     860:	14 f0       	brlt	.+4      	; 0x866 <UpdateAudioChannel0+0x774>
     862:	8f e7       	ldi	r24, 0x7F	; 127
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     868:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     86a:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
     86c:	84 2f       	mov	r24, r20
     86e:	08 95       	ret

00000870 <UpdateAudioChannel1>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     870:	80 91 09 06 	lds	r24, 0x0609
     874:	83 30       	cpi	r24, 0x03	; 3
     876:	c9 f0       	breq	.+50     	; 0x8aa <UpdateAudioChannel1+0x3a>
     878:	84 30       	cpi	r24, 0x04	; 4
     87a:	30 f4       	brcc	.+12     	; 0x888 <UpdateAudioChannel1+0x18>
     87c:	81 30       	cpi	r24, 0x01	; 1
     87e:	59 f0       	breq	.+22     	; 0x896 <UpdateAudioChannel1+0x26>
     880:	82 30       	cpi	r24, 0x02	; 2
     882:	09 f0       	breq	.+2      	; 0x886 <UpdateAudioChannel1+0x16>
     884:	8e c0       	rjmp	.+284    	; 0x9a2 <UpdateAudioChannel1+0x132>
     886:	0e c0       	rjmp	.+28     	; 0x8a4 <UpdateAudioChannel1+0x34>
     888:	84 30       	cpi	r24, 0x04	; 4
     88a:	09 f4       	brne	.+2      	; 0x88e <UpdateAudioChannel1+0x1e>
     88c:	8c c0       	rjmp	.+280    	; 0x9a6 <UpdateAudioChannel1+0x136>
     88e:	85 30       	cpi	r24, 0x05	; 5
     890:	09 f0       	breq	.+2      	; 0x894 <UpdateAudioChannel1+0x24>
     892:	87 c0       	rjmp	.+270    	; 0x9a2 <UpdateAudioChannel1+0x132>
     894:	15 c2       	rjmp	.+1066   	; 0xcc0 <UpdateAudioChannel1+0x450>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     896:	40 91 34 01 	lds	r20, 0x0134
     89a:	4f 5f       	subi	r20, 0xFF	; 255
     89c:	40 93 34 01 	sts	0x0134, r20
     8a0:	41 50       	subi	r20, 0x01	; 1
     8a2:	b3 c3       	rjmp	.+1894   	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     8a4:	40 91 58 02 	lds	r20, 0x0258
     8a8:	f9 c1       	rjmp	.+1010   	; 0xc9c <UpdateAudioChannel1+0x42c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     8aa:	8f ef       	ldi	r24, 0xFF	; 255
     8ac:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     8ae:	80 91 28 06 	lds	r24, 0x0628
     8b2:	90 91 29 06 	lds	r25, 0x0629
     8b6:	a0 91 2a 06 	lds	r26, 0x062A
     8ba:	b0 91 2b 06 	lds	r27, 0x062B
     8be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8c0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8c2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8c4:	80 91 28 06 	lds	r24, 0x0628
     8c8:	90 91 29 06 	lds	r25, 0x0629
     8cc:	a0 91 2a 06 	lds	r26, 0x062A
     8d0:	b0 91 2b 06 	lds	r27, 0x062B
     8d4:	89 2f       	mov	r24, r25
     8d6:	9a 2f       	mov	r25, r26
     8d8:	ab 2f       	mov	r26, r27
     8da:	bb 27       	eor	r27, r27
     8dc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8de:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8e0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8e2:	80 91 28 06 	lds	r24, 0x0628
     8e6:	90 91 29 06 	lds	r25, 0x0629
     8ea:	a0 91 2a 06 	lds	r26, 0x062A
     8ee:	b0 91 2b 06 	lds	r27, 0x062B
     8f2:	cd 01       	movw	r24, r26
     8f4:	aa 27       	eor	r26, r26
     8f6:	bb 27       	eor	r27, r27
     8f8:	87 70       	andi	r24, 0x07	; 7
     8fa:	88 68       	ori	r24, 0x88	; 136
     8fc:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8fe:	80 91 58 02 	lds	r24, 0x0258
     902:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     904:	80 91 28 06 	lds	r24, 0x0628
     908:	90 91 29 06 	lds	r25, 0x0629
     90c:	a0 91 2a 06 	lds	r26, 0x062A
     910:	b0 91 2b 06 	lds	r27, 0x062B
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	a1 09       	sbc	r26, r1
     918:	b1 09       	sbc	r27, r1
     91a:	80 93 28 06 	sts	0x0628, r24
     91e:	90 93 29 06 	sts	0x0629, r25
     922:	a0 93 2a 06 	sts	0x062A, r26
     926:	b0 93 2b 06 	sts	0x062B, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     92a:	80 91 28 06 	lds	r24, 0x0628
     92e:	90 91 29 06 	lds	r25, 0x0629
     932:	a0 91 2a 06 	lds	r26, 0x062A
     936:	b0 91 2b 06 	lds	r27, 0x062B
     93a:	80 93 15 06 	sts	0x0615, r24
     93e:	90 93 16 06 	sts	0x0616, r25
     942:	a0 93 17 06 	sts	0x0617, r26
     946:	b0 93 18 06 	sts	0x0618, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     94a:	80 91 28 06 	lds	r24, 0x0628
     94e:	90 91 29 06 	lds	r25, 0x0629
     952:	a0 91 2a 06 	lds	r26, 0x062A
     956:	b0 91 2b 06 	lds	r27, 0x062B
     95a:	80 93 1d 06 	sts	0x061D, r24
     95e:	90 93 1e 06 	sts	0x061E, r25
     962:	a0 93 1f 06 	sts	0x061F, r26
     966:	b0 93 20 06 	sts	0x0620, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     96a:	20 91 f2 05 	lds	r18, 0x05F2
     96e:	30 91 f3 05 	lds	r19, 0x05F3
     972:	40 91 f4 05 	lds	r20, 0x05F4
     976:	50 91 f5 05 	lds	r21, 0x05F5
     97a:	80 91 15 06 	lds	r24, 0x0615
     97e:	90 91 16 06 	lds	r25, 0x0616
     982:	a0 91 17 06 	lds	r26, 0x0617
     986:	b0 91 18 06 	lds	r27, 0x0618
     98a:	28 17       	cp	r18, r24
     98c:	39 07       	cpc	r19, r25
     98e:	4a 07       	cpc	r20, r26
     990:	5b 07       	cpc	r21, r27
     992:	28 f0       	brcs	.+10     	; 0x99e <UpdateAudioChannel1+0x12e>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     994:	10 92 09 06 	sts	0x0609, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	80 93 42 01 	sts	0x0142, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     99e:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     9a0:	11 9a       	sbi	0x02, 1	; 2
     9a2:	40 e0       	ldi	r20, 0x00	; 0
     9a4:	32 c3       	rjmp	.+1636   	; 0x100a <UpdateAudioChannel1+0x79a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     9a6:	80 91 28 06 	lds	r24, 0x0628
     9aa:	90 91 29 06 	lds	r25, 0x0629
     9ae:	a0 91 2a 06 	lds	r26, 0x062A
     9b2:	b0 91 2b 06 	lds	r27, 0x062B
     9b6:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     9b8:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     9ba:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9bc:	80 91 28 06 	lds	r24, 0x0628
     9c0:	90 91 29 06 	lds	r25, 0x0629
     9c4:	a0 91 2a 06 	lds	r26, 0x062A
     9c8:	b0 91 2b 06 	lds	r27, 0x062B
     9cc:	89 2f       	mov	r24, r25
     9ce:	9a 2f       	mov	r25, r26
     9d0:	ab 2f       	mov	r26, r27
     9d2:	bb 27       	eor	r27, r27
     9d4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9d6:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9d8:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9da:	80 91 28 06 	lds	r24, 0x0628
     9de:	90 91 29 06 	lds	r25, 0x0629
     9e2:	a0 91 2a 06 	lds	r26, 0x062A
     9e6:	b0 91 2b 06 	lds	r27, 0x062B
     9ea:	cd 01       	movw	r24, r26
     9ec:	aa 27       	eor	r26, r26
     9ee:	bb 27       	eor	r27, r27
     9f0:	87 70       	andi	r24, 0x07	; 7
     9f2:	88 68       	ori	r24, 0x88	; 136
     9f4:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9f6:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9f8:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9fa:	80 91 0f 06 	lds	r24, 0x060F
     9fe:	88 23       	and	r24, r24
     a00:	09 f4       	brne	.+2      	; 0xa04 <UpdateAudioChannel1+0x194>
     a02:	74 c0       	rjmp	.+232    	; 0xaec <UpdateAudioChannel1+0x27c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     a04:	80 91 54 01 	lds	r24, 0x0154
     a08:	90 91 55 01 	lds	r25, 0x0155
     a0c:	a0 91 56 01 	lds	r26, 0x0156
     a10:	b0 91 57 01 	lds	r27, 0x0157
     a14:	00 97       	sbiw	r24, 0x00	; 0
     a16:	a1 05       	cpc	r26, r1
     a18:	b1 05       	cpc	r27, r1
     a1a:	39 f1       	breq	.+78     	; 0xa6a <UpdateAudioChannel1+0x1fa>
			{
				bankStates[BANK_1].currentAddress--;
     a1c:	80 91 28 06 	lds	r24, 0x0628
     a20:	90 91 29 06 	lds	r25, 0x0629
     a24:	a0 91 2a 06 	lds	r26, 0x062A
     a28:	b0 91 2b 06 	lds	r27, 0x062B
     a2c:	01 97       	sbiw	r24, 0x01	; 1
     a2e:	a1 09       	sbc	r26, r1
     a30:	b1 09       	sbc	r27, r1
     a32:	80 93 28 06 	sts	0x0628, r24
     a36:	90 93 29 06 	sts	0x0629, r25
     a3a:	a0 93 2a 06 	sts	0x062A, r26
     a3e:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     a42:	80 91 54 01 	lds	r24, 0x0154
     a46:	90 91 55 01 	lds	r25, 0x0155
     a4a:	a0 91 56 01 	lds	r26, 0x0156
     a4e:	b0 91 57 01 	lds	r27, 0x0157
     a52:	01 97       	sbiw	r24, 0x01	; 1
     a54:	a1 09       	sbc	r26, r1
     a56:	b1 09       	sbc	r27, r1
     a58:	80 93 54 01 	sts	0x0154, r24
     a5c:	90 93 55 01 	sts	0x0155, r25
     a60:	a0 93 56 01 	sts	0x0156, r26
     a64:	b0 93 57 01 	sts	0x0157, r27
     a68:	15 c1       	rjmp	.+554    	; 0xc94 <UpdateAudioChannel1+0x424>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a6a:	80 91 4c 01 	lds	r24, 0x014C
     a6e:	90 91 4d 01 	lds	r25, 0x014D
     a72:	a0 91 4e 01 	lds	r26, 0x014E
     a76:	b0 91 4f 01 	lds	r27, 0x014F
     a7a:	80 93 54 01 	sts	0x0154, r24
     a7e:	90 93 55 01 	sts	0x0155, r25
     a82:	a0 93 56 01 	sts	0x0156, r26
     a86:	b0 93 57 01 	sts	0x0157, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a8a:	80 91 47 01 	lds	r24, 0x0147
     a8e:	8f 5f       	subi	r24, 0xFF	; 255
     a90:	80 93 47 01 	sts	0x0147, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a94:	90 91 47 01 	lds	r25, 0x0147
     a98:	80 91 0f 06 	lds	r24, 0x060F
     a9c:	98 17       	cp	r25, r24
     a9e:	11 f4       	brne	.+4      	; 0xaa4 <UpdateAudioChannel1+0x234>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     aa0:	10 92 47 01 	sts	0x0147, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     aa4:	e0 91 47 01 	lds	r30, 0x0147
     aa8:	20 91 4c 01 	lds	r18, 0x014C
     aac:	30 91 4d 01 	lds	r19, 0x014D
     ab0:	40 91 4e 01 	lds	r20, 0x014E
     ab4:	50 91 4f 01 	lds	r21, 0x014F
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	e8 52       	subi	r30, 0x28	; 40
     abc:	fe 4f       	sbci	r31, 0xFE	; 254
     abe:	60 81       	ld	r22, Z
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
     aca:	2f ef       	ldi	r18, 0xFF	; 255
     acc:	3f ef       	ldi	r19, 0xFF	; 255
     ace:	47 e0       	ldi	r20, 0x07	; 7
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	26 1b       	sub	r18, r22
     ad4:	37 0b       	sbc	r19, r23
     ad6:	48 0b       	sbc	r20, r24
     ad8:	59 0b       	sbc	r21, r25
     ada:	20 93 28 06 	sts	0x0628, r18
     ade:	30 93 29 06 	sts	0x0629, r19
     ae2:	40 93 2a 06 	sts	0x062A, r20
     ae6:	50 93 2b 06 	sts	0x062B, r21
     aea:	d4 c0       	rjmp	.+424    	; 0xc94 <UpdateAudioChannel1+0x424>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     aec:	80 91 0d 06 	lds	r24, 0x060D
     af0:	88 23       	and	r24, r24
     af2:	09 f0       	breq	.+2      	; 0xaf6 <UpdateAudioChannel1+0x286>
     af4:	62 c0       	rjmp	.+196    	; 0xbba <UpdateAudioChannel1+0x34a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     af6:	20 91 28 06 	lds	r18, 0x0628
     afa:	30 91 29 06 	lds	r19, 0x0629
     afe:	40 91 2a 06 	lds	r20, 0x062A
     b02:	50 91 2b 06 	lds	r21, 0x062B
     b06:	80 91 21 06 	lds	r24, 0x0621
     b0a:	90 91 22 06 	lds	r25, 0x0622
     b0e:	a0 91 23 06 	lds	r26, 0x0623
     b12:	b0 91 24 06 	lds	r27, 0x0624
     b16:	28 17       	cp	r18, r24
     b18:	39 07       	cpc	r19, r25
     b1a:	4a 07       	cpc	r20, r26
     b1c:	5b 07       	cpc	r21, r27
     b1e:	29 f4       	brne	.+10     	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b20:	80 91 0a 06 	lds	r24, 0x060A
     b24:	81 30       	cpi	r24, 0x01	; 1
     b26:	09 f4       	brne	.+2      	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b28:	61 c0       	rjmp	.+194    	; 0xbec <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b2a:	20 91 28 06 	lds	r18, 0x0628
     b2e:	30 91 29 06 	lds	r19, 0x0629
     b32:	40 91 2a 06 	lds	r20, 0x062A
     b36:	50 91 2b 06 	lds	r21, 0x062B
     b3a:	80 91 21 06 	lds	r24, 0x0621
     b3e:	90 91 22 06 	lds	r25, 0x0622
     b42:	a0 91 23 06 	lds	r26, 0x0623
     b46:	b0 91 24 06 	lds	r27, 0x0624
     b4a:	28 17       	cp	r18, r24
     b4c:	39 07       	cpc	r19, r25
     b4e:	4a 07       	cpc	r20, r26
     b50:	5b 07       	cpc	r21, r27
     b52:	49 f4       	brne	.+18     	; 0xb66 <UpdateAudioChannel1+0x2f6>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b54:	80 91 1d 06 	lds	r24, 0x061D
     b58:	90 91 1e 06 	lds	r25, 0x061E
     b5c:	a0 91 1f 06 	lds	r26, 0x061F
     b60:	b0 91 20 06 	lds	r27, 0x0620
     b64:	8f c0       	rjmp	.+286    	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b66:	20 91 28 06 	lds	r18, 0x0628
     b6a:	30 91 29 06 	lds	r19, 0x0629
     b6e:	40 91 2a 06 	lds	r20, 0x062A
     b72:	50 91 2b 06 	lds	r21, 0x062B
     b76:	80 91 19 06 	lds	r24, 0x0619
     b7a:	90 91 1a 06 	lds	r25, 0x061A
     b7e:	a0 91 1b 06 	lds	r26, 0x061B
     b82:	b0 91 1c 06 	lds	r27, 0x061C
     b86:	28 17       	cp	r18, r24
     b88:	39 07       	cpc	r19, r25
     b8a:	4a 07       	cpc	r20, r26
     b8c:	5b 07       	cpc	r21, r27
     b8e:	49 f4       	brne	.+18     	; 0xba2 <UpdateAudioChannel1+0x332>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b90:	80 91 15 06 	lds	r24, 0x0615
     b94:	90 91 16 06 	lds	r25, 0x0616
     b98:	a0 91 17 06 	lds	r26, 0x0617
     b9c:	b0 91 18 06 	lds	r27, 0x0618
     ba0:	71 c0       	rjmp	.+226    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ba2:	80 91 28 06 	lds	r24, 0x0628
     ba6:	90 91 29 06 	lds	r25, 0x0629
     baa:	a0 91 2a 06 	lds	r26, 0x062A
     bae:	b0 91 2b 06 	lds	r27, 0x062B
     bb2:	01 96       	adiw	r24, 0x01	; 1
     bb4:	a1 1d       	adc	r26, r1
     bb6:	b1 1d       	adc	r27, r1
     bb8:	65 c0       	rjmp	.+202    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     bba:	20 91 28 06 	lds	r18, 0x0628
     bbe:	30 91 29 06 	lds	r19, 0x0629
     bc2:	40 91 2a 06 	lds	r20, 0x062A
     bc6:	50 91 2b 06 	lds	r21, 0x062B
     bca:	80 91 1d 06 	lds	r24, 0x061D
     bce:	90 91 1e 06 	lds	r25, 0x061E
     bd2:	a0 91 1f 06 	lds	r26, 0x061F
     bd6:	b0 91 20 06 	lds	r27, 0x0620
     bda:	28 17       	cp	r18, r24
     bdc:	39 07       	cpc	r19, r25
     bde:	4a 07       	cpc	r20, r26
     be0:	5b 07       	cpc	r21, r27
     be2:	49 f4       	brne	.+18     	; 0xbf6 <UpdateAudioChannel1+0x386>
     be4:	80 91 0a 06 	lds	r24, 0x060A
     be8:	81 30       	cpi	r24, 0x01	; 1
     bea:	29 f4       	brne	.+10     	; 0xbf6 <UpdateAudioChannel1+0x386>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bec:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bf0:	10 92 12 06 	sts	0x0612, r1
     bf4:	4f c0       	rjmp	.+158    	; 0xc94 <UpdateAudioChannel1+0x424>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bf6:	20 91 28 06 	lds	r18, 0x0628
     bfa:	30 91 29 06 	lds	r19, 0x0629
     bfe:	40 91 2a 06 	lds	r20, 0x062A
     c02:	50 91 2b 06 	lds	r21, 0x062B
     c06:	80 91 1d 06 	lds	r24, 0x061D
     c0a:	90 91 1e 06 	lds	r25, 0x061E
     c0e:	a0 91 1f 06 	lds	r26, 0x061F
     c12:	b0 91 20 06 	lds	r27, 0x0620
     c16:	28 17       	cp	r18, r24
     c18:	39 07       	cpc	r19, r25
     c1a:	4a 07       	cpc	r20, r26
     c1c:	5b 07       	cpc	r21, r27
     c1e:	49 f4       	brne	.+18     	; 0xc32 <UpdateAudioChannel1+0x3c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     c20:	80 91 21 06 	lds	r24, 0x0621
     c24:	90 91 22 06 	lds	r25, 0x0622
     c28:	a0 91 23 06 	lds	r26, 0x0623
     c2c:	b0 91 24 06 	lds	r27, 0x0624
     c30:	29 c0       	rjmp	.+82     	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c32:	20 91 28 06 	lds	r18, 0x0628
     c36:	30 91 29 06 	lds	r19, 0x0629
     c3a:	40 91 2a 06 	lds	r20, 0x062A
     c3e:	50 91 2b 06 	lds	r21, 0x062B
     c42:	80 91 15 06 	lds	r24, 0x0615
     c46:	90 91 16 06 	lds	r25, 0x0616
     c4a:	a0 91 17 06 	lds	r26, 0x0617
     c4e:	b0 91 18 06 	lds	r27, 0x0618
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	4a 07       	cpc	r20, r26
     c58:	5b 07       	cpc	r21, r27
     c5a:	49 f4       	brne	.+18     	; 0xc6e <UpdateAudioChannel1+0x3fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c5c:	80 91 19 06 	lds	r24, 0x0619
     c60:	90 91 1a 06 	lds	r25, 0x061A
     c64:	a0 91 1b 06 	lds	r26, 0x061B
     c68:	b0 91 1c 06 	lds	r27, 0x061C
     c6c:	0b c0       	rjmp	.+22     	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c6e:	80 91 28 06 	lds	r24, 0x0628
     c72:	90 91 29 06 	lds	r25, 0x0629
     c76:	a0 91 2a 06 	lds	r26, 0x062A
     c7a:	b0 91 2b 06 	lds	r27, 0x062B
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	a1 09       	sbc	r26, r1
     c82:	b1 09       	sbc	r27, r1
     c84:	80 93 28 06 	sts	0x0628, r24
     c88:	90 93 29 06 	sts	0x0629, r25
     c8c:	a0 93 2a 06 	sts	0x062A, r26
     c90:	b0 93 2b 06 	sts	0x062B, r27
			}
		}
		
		// Done with addy, read RAM.
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c94:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c96:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c98:	8f ef       	ldi	r24, 0xFF	; 255
     c9a:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c9c:	80 91 11 06 	lds	r24, 0x0611
     ca0:	88 23       	and	r24, r24
     ca2:	09 f4       	brne	.+2      	; 0xca6 <UpdateAudioChannel1+0x436>
     ca4:	b2 c1       	rjmp	.+868    	; 0x100a <UpdateAudioChannel1+0x79a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     ca6:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     ca8:	20 91 11 06 	lds	r18, 0x0611
     cac:	8f ef       	ldi	r24, 0xFF	; 255
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <UpdateAudioChannel1+0x446>
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	2a 95       	dec	r18
     cb8:	e2 f7       	brpl	.-8      	; 0xcb2 <UpdateAudioChannel1+0x442>
     cba:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     cbc:	40 58       	subi	r20, 0x80	; 128
     cbe:	a5 c1       	rjmp	.+842    	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     cc0:	80 91 28 06 	lds	r24, 0x0628
     cc4:	90 91 29 06 	lds	r25, 0x0629
     cc8:	a0 91 2a 06 	lds	r26, 0x062A
     ccc:	b0 91 2b 06 	lds	r27, 0x062B
     cd0:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     cd2:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     cd4:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     cd6:	80 91 28 06 	lds	r24, 0x0628
     cda:	90 91 29 06 	lds	r25, 0x0629
     cde:	a0 91 2a 06 	lds	r26, 0x062A
     ce2:	b0 91 2b 06 	lds	r27, 0x062B
     ce6:	89 2f       	mov	r24, r25
     ce8:	9a 2f       	mov	r25, r26
     cea:	ab 2f       	mov	r26, r27
     cec:	bb 27       	eor	r27, r27
     cee:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cf0:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cf2:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cf4:	80 91 28 06 	lds	r24, 0x0628
     cf8:	90 91 29 06 	lds	r25, 0x0629
     cfc:	a0 91 2a 06 	lds	r26, 0x062A
     d00:	b0 91 2b 06 	lds	r27, 0x062B
     d04:	cd 01       	movw	r24, r26
     d06:	aa 27       	eor	r26, r26
     d08:	bb 27       	eor	r27, r27
     d0a:	87 70       	andi	r24, 0x07	; 7
     d0c:	88 68       	ori	r24, 0x88	; 136
     d0e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     d10:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     d12:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     d14:	80 91 0f 06 	lds	r24, 0x060F
     d18:	88 23       	and	r24, r24
     d1a:	09 f4       	brne	.+2      	; 0xd1e <UpdateAudioChannel1+0x4ae>
     d1c:	74 c0       	rjmp	.+232    	; 0xe06 <UpdateAudioChannel1+0x596>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     d1e:	80 91 54 01 	lds	r24, 0x0154
     d22:	90 91 55 01 	lds	r25, 0x0155
     d26:	a0 91 56 01 	lds	r26, 0x0156
     d2a:	b0 91 57 01 	lds	r27, 0x0157
     d2e:	00 97       	sbiw	r24, 0x00	; 0
     d30:	a1 05       	cpc	r26, r1
     d32:	b1 05       	cpc	r27, r1
     d34:	39 f1       	breq	.+78     	; 0xd84 <UpdateAudioChannel1+0x514>
			{
				bankStates[BANK_1].currentAddress--;
     d36:	80 91 28 06 	lds	r24, 0x0628
     d3a:	90 91 29 06 	lds	r25, 0x0629
     d3e:	a0 91 2a 06 	lds	r26, 0x062A
     d42:	b0 91 2b 06 	lds	r27, 0x062B
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 28 06 	sts	0x0628, r24
     d50:	90 93 29 06 	sts	0x0629, r25
     d54:	a0 93 2a 06 	sts	0x062A, r26
     d58:	b0 93 2b 06 	sts	0x062B, r27
				sliceRemaining[BANK_1]--;
     d5c:	80 91 54 01 	lds	r24, 0x0154
     d60:	90 91 55 01 	lds	r25, 0x0155
     d64:	a0 91 56 01 	lds	r26, 0x0156
     d68:	b0 91 57 01 	lds	r27, 0x0157
     d6c:	01 97       	sbiw	r24, 0x01	; 1
     d6e:	a1 09       	sbc	r26, r1
     d70:	b1 09       	sbc	r27, r1
     d72:	80 93 54 01 	sts	0x0154, r24
     d76:	90 93 55 01 	sts	0x0155, r25
     d7a:	a0 93 56 01 	sts	0x0156, r26
     d7e:	b0 93 57 01 	sts	0x0157, r27
     d82:	15 c1       	rjmp	.+554    	; 0xfae <UpdateAudioChannel1+0x73e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d84:	80 91 4c 01 	lds	r24, 0x014C
     d88:	90 91 4d 01 	lds	r25, 0x014D
     d8c:	a0 91 4e 01 	lds	r26, 0x014E
     d90:	b0 91 4f 01 	lds	r27, 0x014F
     d94:	80 93 54 01 	sts	0x0154, r24
     d98:	90 93 55 01 	sts	0x0155, r25
     d9c:	a0 93 56 01 	sts	0x0156, r26
     da0:	b0 93 57 01 	sts	0x0157, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     da4:	80 91 47 01 	lds	r24, 0x0147
     da8:	8f 5f       	subi	r24, 0xFF	; 255
     daa:	80 93 47 01 	sts	0x0147, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     dae:	90 91 47 01 	lds	r25, 0x0147
     db2:	80 91 0f 06 	lds	r24, 0x060F
     db6:	98 17       	cp	r25, r24
     db8:	11 f4       	brne	.+4      	; 0xdbe <UpdateAudioChannel1+0x54e>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     dba:	10 92 47 01 	sts	0x0147, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     dbe:	e0 91 47 01 	lds	r30, 0x0147
     dc2:	20 91 4c 01 	lds	r18, 0x014C
     dc6:	30 91 4d 01 	lds	r19, 0x014D
     dca:	40 91 4e 01 	lds	r20, 0x014E
     dce:	50 91 4f 01 	lds	r21, 0x014F
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	e8 52       	subi	r30, 0x28	; 40
     dd6:	fe 4f       	sbci	r31, 0xFE	; 254
     dd8:	60 81       	ld	r22, Z
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
     de4:	2f ef       	ldi	r18, 0xFF	; 255
     de6:	3f ef       	ldi	r19, 0xFF	; 255
     de8:	47 e0       	ldi	r20, 0x07	; 7
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	26 1b       	sub	r18, r22
     dee:	37 0b       	sbc	r19, r23
     df0:	48 0b       	sbc	r20, r24
     df2:	59 0b       	sbc	r21, r25
     df4:	20 93 28 06 	sts	0x0628, r18
     df8:	30 93 29 06 	sts	0x0629, r19
     dfc:	40 93 2a 06 	sts	0x062A, r20
     e00:	50 93 2b 06 	sts	0x062B, r21
     e04:	d4 c0       	rjmp	.+424    	; 0xfae <UpdateAudioChannel1+0x73e>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     e06:	80 91 0d 06 	lds	r24, 0x060D
     e0a:	88 23       	and	r24, r24
     e0c:	09 f0       	breq	.+2      	; 0xe10 <UpdateAudioChannel1+0x5a0>
     e0e:	62 c0       	rjmp	.+196    	; 0xed4 <UpdateAudioChannel1+0x664>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     e10:	20 91 28 06 	lds	r18, 0x0628
     e14:	30 91 29 06 	lds	r19, 0x0629
     e18:	40 91 2a 06 	lds	r20, 0x062A
     e1c:	50 91 2b 06 	lds	r21, 0x062B
     e20:	80 91 21 06 	lds	r24, 0x0621
     e24:	90 91 22 06 	lds	r25, 0x0622
     e28:	a0 91 23 06 	lds	r26, 0x0623
     e2c:	b0 91 24 06 	lds	r27, 0x0624
     e30:	28 17       	cp	r18, r24
     e32:	39 07       	cpc	r19, r25
     e34:	4a 07       	cpc	r20, r26
     e36:	5b 07       	cpc	r21, r27
     e38:	29 f4       	brne	.+10     	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e3a:	80 91 0a 06 	lds	r24, 0x060A
     e3e:	81 30       	cpi	r24, 0x01	; 1
     e40:	09 f4       	brne	.+2      	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e42:	61 c0       	rjmp	.+194    	; 0xf06 <UpdateAudioChannel1+0x696>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e44:	20 91 28 06 	lds	r18, 0x0628
     e48:	30 91 29 06 	lds	r19, 0x0629
     e4c:	40 91 2a 06 	lds	r20, 0x062A
     e50:	50 91 2b 06 	lds	r21, 0x062B
     e54:	80 91 21 06 	lds	r24, 0x0621
     e58:	90 91 22 06 	lds	r25, 0x0622
     e5c:	a0 91 23 06 	lds	r26, 0x0623
     e60:	b0 91 24 06 	lds	r27, 0x0624
     e64:	28 17       	cp	r18, r24
     e66:	39 07       	cpc	r19, r25
     e68:	4a 07       	cpc	r20, r26
     e6a:	5b 07       	cpc	r21, r27
     e6c:	49 f4       	brne	.+18     	; 0xe80 <UpdateAudioChannel1+0x610>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e6e:	80 91 1d 06 	lds	r24, 0x061D
     e72:	90 91 1e 06 	lds	r25, 0x061E
     e76:	a0 91 1f 06 	lds	r26, 0x061F
     e7a:	b0 91 20 06 	lds	r27, 0x0620
     e7e:	8f c0       	rjmp	.+286    	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e80:	20 91 28 06 	lds	r18, 0x0628
     e84:	30 91 29 06 	lds	r19, 0x0629
     e88:	40 91 2a 06 	lds	r20, 0x062A
     e8c:	50 91 2b 06 	lds	r21, 0x062B
     e90:	80 91 19 06 	lds	r24, 0x0619
     e94:	90 91 1a 06 	lds	r25, 0x061A
     e98:	a0 91 1b 06 	lds	r26, 0x061B
     e9c:	b0 91 1c 06 	lds	r27, 0x061C
     ea0:	28 17       	cp	r18, r24
     ea2:	39 07       	cpc	r19, r25
     ea4:	4a 07       	cpc	r20, r26
     ea6:	5b 07       	cpc	r21, r27
     ea8:	49 f4       	brne	.+18     	; 0xebc <UpdateAudioChannel1+0x64c>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     eaa:	80 91 15 06 	lds	r24, 0x0615
     eae:	90 91 16 06 	lds	r25, 0x0616
     eb2:	a0 91 17 06 	lds	r26, 0x0617
     eb6:	b0 91 18 06 	lds	r27, 0x0618
     eba:	71 c0       	rjmp	.+226    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ebc:	80 91 28 06 	lds	r24, 0x0628
     ec0:	90 91 29 06 	lds	r25, 0x0629
     ec4:	a0 91 2a 06 	lds	r26, 0x062A
     ec8:	b0 91 2b 06 	lds	r27, 0x062B
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	65 c0       	rjmp	.+202    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ed4:	20 91 28 06 	lds	r18, 0x0628
     ed8:	30 91 29 06 	lds	r19, 0x0629
     edc:	40 91 2a 06 	lds	r20, 0x062A
     ee0:	50 91 2b 06 	lds	r21, 0x062B
     ee4:	80 91 1d 06 	lds	r24, 0x061D
     ee8:	90 91 1e 06 	lds	r25, 0x061E
     eec:	a0 91 1f 06 	lds	r26, 0x061F
     ef0:	b0 91 20 06 	lds	r27, 0x0620
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	4a 07       	cpc	r20, r26
     efa:	5b 07       	cpc	r21, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6a0>
     efe:	80 91 0a 06 	lds	r24, 0x060A
     f02:	81 30       	cpi	r24, 0x01	; 1
     f04:	29 f4       	brne	.+10     	; 0xf10 <UpdateAudioChannel1+0x6a0>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     f06:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     f0a:	10 92 12 06 	sts	0x0612, r1
     f0e:	4f c0       	rjmp	.+158    	; 0xfae <UpdateAudioChannel1+0x73e>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     f10:	20 91 28 06 	lds	r18, 0x0628
     f14:	30 91 29 06 	lds	r19, 0x0629
     f18:	40 91 2a 06 	lds	r20, 0x062A
     f1c:	50 91 2b 06 	lds	r21, 0x062B
     f20:	80 91 1d 06 	lds	r24, 0x061D
     f24:	90 91 1e 06 	lds	r25, 0x061E
     f28:	a0 91 1f 06 	lds	r26, 0x061F
     f2c:	b0 91 20 06 	lds	r27, 0x0620
     f30:	28 17       	cp	r18, r24
     f32:	39 07       	cpc	r19, r25
     f34:	4a 07       	cpc	r20, r26
     f36:	5b 07       	cpc	r21, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6dc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     f3a:	80 91 21 06 	lds	r24, 0x0621
     f3e:	90 91 22 06 	lds	r25, 0x0622
     f42:	a0 91 23 06 	lds	r26, 0x0623
     f46:	b0 91 24 06 	lds	r27, 0x0624
     f4a:	29 c0       	rjmp	.+82     	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f4c:	20 91 28 06 	lds	r18, 0x0628
     f50:	30 91 29 06 	lds	r19, 0x0629
     f54:	40 91 2a 06 	lds	r20, 0x062A
     f58:	50 91 2b 06 	lds	r21, 0x062B
     f5c:	80 91 15 06 	lds	r24, 0x0615
     f60:	90 91 16 06 	lds	r25, 0x0616
     f64:	a0 91 17 06 	lds	r26, 0x0617
     f68:	b0 91 18 06 	lds	r27, 0x0618
     f6c:	28 17       	cp	r18, r24
     f6e:	39 07       	cpc	r19, r25
     f70:	4a 07       	cpc	r20, r26
     f72:	5b 07       	cpc	r21, r27
     f74:	49 f4       	brne	.+18     	; 0xf88 <UpdateAudioChannel1+0x718>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f76:	80 91 19 06 	lds	r24, 0x0619
     f7a:	90 91 1a 06 	lds	r25, 0x061A
     f7e:	a0 91 1b 06 	lds	r26, 0x061B
     f82:	b0 91 1c 06 	lds	r27, 0x061C
     f86:	0b c0       	rjmp	.+22     	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f88:	80 91 28 06 	lds	r24, 0x0628
     f8c:	90 91 29 06 	lds	r25, 0x0629
     f90:	a0 91 2a 06 	lds	r26, 0x062A
     f94:	b0 91 2b 06 	lds	r27, 0x062B
     f98:	01 97       	sbiw	r24, 0x01	; 1
     f9a:	a1 09       	sbc	r26, r1
     f9c:	b1 09       	sbc	r27, r1
     f9e:	80 93 28 06 	sts	0x0628, r24
     fa2:	90 93 29 06 	sts	0x0629, r25
     fa6:	a0 93 2a 06 	sts	0x062A, r26
     faa:	b0 93 2b 06 	sts	0x062B, r27
			}
		}
		
		// Finished with addy stuff, now finish data transfer
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     fae:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     fb0:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     fb2:	8f ef       	ldi	r24, 0xFF	; 255
     fb4:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     fb6:	80 91 11 06 	lds	r24, 0x0611
     fba:	88 23       	and	r24, r24
     fbc:	61 f0       	breq	.+24     	; 0xfd6 <UpdateAudioChannel1+0x766>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     fbe:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     fc0:	20 91 11 06 	lds	r18, 0x0611
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	02 c0       	rjmp	.+4      	; 0xfce <UpdateAudioChannel1+0x75e>
     fca:	88 0f       	add	r24, r24
     fcc:	99 1f       	adc	r25, r25
     fce:	2a 95       	dec	r18
     fd0:	e2 f7       	brpl	.-8      	; 0xfca <UpdateAudioChannel1+0x75a>
     fd2:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     fd4:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     fd6:	80 91 58 02 	lds	r24, 0x0258
     fda:	24 2f       	mov	r18, r20
     fdc:	33 27       	eor	r19, r19
     fde:	27 fd       	sbrc	r18, 7
     fe0:	30 95       	com	r19
     fe2:	99 27       	eor	r25, r25
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	90 95       	com	r25
     fe8:	28 0f       	add	r18, r24
     fea:	39 1f       	adc	r19, r25
     fec:	8f ef       	ldi	r24, 0xFF	; 255
     fee:	20 38       	cpi	r18, 0x80	; 128
     ff0:	38 07       	cpc	r19, r24
     ff2:	14 f4       	brge	.+4      	; 0xff8 <UpdateAudioChannel1+0x788>
     ff4:	20 e8       	ldi	r18, 0x80	; 128
     ff6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     ff8:	c9 01       	movw	r24, r18
     ffa:	20 38       	cpi	r18, 0x80	; 128
     ffc:	31 05       	cpc	r19, r1
     ffe:	14 f0       	brlt	.+4      	; 0x1004 <UpdateAudioChannel1+0x794>
    1000:	8f e7       	ldi	r24, 0x7F	; 127
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
    1006:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
    1008:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
    100a:	84 2f       	mov	r24, r20
    100c:	08 95       	ret

0000100e <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    100e:	80 91 bd 05 	lds	r24, 0x05BD
    1012:	68 2f       	mov	r22, r24
    1014:	77 27       	eor	r23, r23
    1016:	67 fd       	sbrc	r22, 7
    1018:	70 95       	com	r23
    101a:	80 91 bb 05 	lds	r24, 0x05BB
    101e:	99 27       	eor	r25, r25
    1020:	87 fd       	sbrc	r24, 7
    1022:	90 95       	com	r25
    1024:	68 0f       	add	r22, r24
    1026:	79 1f       	adc	r23, r25
    1028:	8f ef       	ldi	r24, 0xFF	; 255
    102a:	60 38       	cpi	r22, 0x80	; 128
    102c:	78 07       	cpc	r23, r24
    102e:	14 f4       	brge	.+4      	; 0x1034 <OutputMultiplyBanks+0x26>
    1030:	60 e8       	ldi	r22, 0x80	; 128
    1032:	7f ef       	ldi	r23, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1034:	80 91 be 05 	lds	r24, 0x05BE
    1038:	28 2f       	mov	r18, r24
    103a:	33 27       	eor	r19, r19
    103c:	27 fd       	sbrc	r18, 7
    103e:	30 95       	com	r19
    1040:	80 91 bc 05 	lds	r24, 0x05BC
    1044:	99 27       	eor	r25, r25
    1046:	87 fd       	sbrc	r24, 7
    1048:	90 95       	com	r25
    104a:	28 0f       	add	r18, r24
    104c:	39 1f       	adc	r19, r25
    104e:	8f ef       	ldi	r24, 0xFF	; 255
    1050:	21 38       	cpi	r18, 0x81	; 129
    1052:	38 07       	cpc	r19, r24
    1054:	14 f4       	brge	.+4      	; 0x105a <OutputMultiplyBanks+0x4c>
    1056:	21 e8       	ldi	r18, 0x81	; 129
    1058:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    105a:	a9 01       	movw	r20, r18
    105c:	20 38       	cpi	r18, 0x80	; 128
    105e:	31 05       	cpc	r19, r1
    1060:	14 f0       	brlt	.+4      	; 0x1066 <OutputMultiplyBanks+0x58>
    1062:	4f e7       	ldi	r20, 0x7F	; 127
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	9b 01       	movw	r18, r22
    1068:	60 38       	cpi	r22, 0x80	; 128
    106a:	71 05       	cpc	r23, r1
    106c:	14 f0       	brlt	.+4      	; 0x1072 <OutputMultiplyBanks+0x64>
    106e:	2f e7       	ldi	r18, 0x7F	; 127
    1070:	30 e0       	ldi	r19, 0x00	; 0

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    1072:	42 9f       	mul	r20, r18
    1074:	c0 01       	movw	r24, r0
    1076:	43 9f       	mul	r20, r19
    1078:	90 0d       	add	r25, r0
    107a:	52 9f       	mul	r21, r18
    107c:	90 0d       	add	r25, r0
    107e:	11 24       	eor	r1, r1
    1080:	60 e4       	ldi	r22, 0x40	; 64
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	0e 94 85 2b 	call	0x570a	; 0x570a <__divmodhi4>
    1088:	60 58       	subi	r22, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    108a:	80 91 c0 05 	lds	r24, 0x05C0
    108e:	68 17       	cp	r22, r24
    1090:	29 f0       	breq	.+10     	; 0x109c <OutputMultiplyBanks+0x8e>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1096:	65 b9       	out	0x05, r22	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1098:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    109a:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    109c:	60 93 c0 05 	sts	0x05C0, r22
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    10a0:	08 95       	ret

000010a2 <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC
	
//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
    10a2:	80 91 bc 05 	lds	r24, 0x05BC
    10a6:	28 2f       	mov	r18, r24
    10a8:	33 27       	eor	r19, r19
    10aa:	27 fd       	sbrc	r18, 7
    10ac:	30 95       	com	r19
    10ae:	80 91 bb 05 	lds	r24, 0x05BB
    10b2:	99 27       	eor	r25, r25
    10b4:	87 fd       	sbrc	r24, 7
    10b6:	90 95       	com	r25
    10b8:	28 0f       	add	r18, r24
    10ba:	39 1f       	adc	r19, r25
    10bc:	80 91 bd 05 	lds	r24, 0x05BD
    10c0:	99 27       	eor	r25, r25
    10c2:	87 fd       	sbrc	r24, 7
    10c4:	90 95       	com	r25
    10c6:	28 0f       	add	r18, r24
    10c8:	39 1f       	adc	r19, r25
    10ca:	80 91 be 05 	lds	r24, 0x05BE
    10ce:	99 27       	eor	r25, r25
    10d0:	87 fd       	sbrc	r24, 7
    10d2:	90 95       	com	r25
    10d4:	28 0f       	add	r18, r24
    10d6:	39 1f       	adc	r19, r25
    10d8:	80 91 bf 05 	lds	r24, 0x05BF
    10dc:	99 27       	eor	r25, r25
    10de:	87 fd       	sbrc	r24, 7
    10e0:	90 95       	com	r25
    10e2:	28 0f       	add	r18, r24
    10e4:	39 1f       	adc	r19, r25
    10e6:	8f ef       	ldi	r24, 0xFF	; 255
    10e8:	20 38       	cpi	r18, 0x80	; 128
    10ea:	38 07       	cpc	r19, r24
    10ec:	14 f4       	brge	.+4      	; 0x10f2 <OutputAddBanks+0x50>
    10ee:	20 e8       	ldi	r18, 0x80	; 128
    10f0:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
    10f2:	c9 01       	movw	r24, r18
    10f4:	20 38       	cpi	r18, 0x80	; 128
    10f6:	31 05       	cpc	r19, r1
    10f8:	14 f0       	brlt	.+4      	; 0x10fe <OutputAddBanks+0x5c>
    10fa:	8f e7       	ldi	r24, 0x7F	; 127
    10fc:	90 e0       	ldi	r25, 0x00	; 0
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10fe:	98 2f       	mov	r25, r24
    1100:	90 58       	subi	r25, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1102:	80 91 c0 05 	lds	r24, 0x05C0
    1106:	98 17       	cp	r25, r24
    1108:	29 f0       	breq	.+10     	; 0x1114 <__stack+0x15>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    110a:	8f ef       	ldi	r24, 0xFF	; 255
    110c:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    110e:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1110:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1112:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1114:	90 93 c0 05 	sts	0x05C0, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    1118:	08 95       	ret

0000111a <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    111a:	80 91 bd 05 	lds	r24, 0x05BD
    111e:	48 2f       	mov	r20, r24
    1120:	55 27       	eor	r21, r21
    1122:	47 fd       	sbrc	r20, 7
    1124:	50 95       	com	r21
    1126:	80 91 bb 05 	lds	r24, 0x05BB
    112a:	99 27       	eor	r25, r25
    112c:	87 fd       	sbrc	r24, 7
    112e:	90 95       	com	r25
    1130:	48 0f       	add	r20, r24
    1132:	59 1f       	adc	r21, r25
    1134:	8f ef       	ldi	r24, 0xFF	; 255
    1136:	40 38       	cpi	r20, 0x80	; 128
    1138:	58 07       	cpc	r21, r24
    113a:	14 f4       	brge	.+4      	; 0x1140 <OutputXorBanks+0x26>
    113c:	40 e8       	ldi	r20, 0x80	; 128
    113e:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1140:	80 91 be 05 	lds	r24, 0x05BE
    1144:	28 2f       	mov	r18, r24
    1146:	33 27       	eor	r19, r19
    1148:	27 fd       	sbrc	r18, 7
    114a:	30 95       	com	r19
    114c:	80 91 bc 05 	lds	r24, 0x05BC
    1150:	99 27       	eor	r25, r25
    1152:	87 fd       	sbrc	r24, 7
    1154:	90 95       	com	r25
    1156:	28 0f       	add	r18, r24
    1158:	39 1f       	adc	r19, r25
    115a:	8f ef       	ldi	r24, 0xFF	; 255
    115c:	20 38       	cpi	r18, 0x80	; 128
    115e:	38 07       	cpc	r19, r24
    1160:	14 f4       	brge	.+4      	; 0x1166 <OutputXorBanks+0x4c>
    1162:	20 e8       	ldi	r18, 0x80	; 128
    1164:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}		
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.		
    1166:	20 38       	cpi	r18, 0x80	; 128
    1168:	31 05       	cpc	r19, r1
    116a:	14 f0       	brlt	.+4      	; 0x1170 <OutputXorBanks+0x56>
    116c:	2f e7       	ldi	r18, 0x7F	; 127
    116e:	30 e0       	ldi	r19, 0x00	; 0
    1170:	ca 01       	movw	r24, r20
    1172:	40 38       	cpi	r20, 0x80	; 128
    1174:	51 05       	cpc	r21, r1
    1176:	14 f0       	brlt	.+4      	; 0x117c <OutputXorBanks+0x62>
    1178:	8f e7       	ldi	r24, 0x7F	; 127
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	92 2f       	mov	r25, r18
    117e:	98 27       	eor	r25, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1180:	80 91 c0 05 	lds	r24, 0x05C0
    1184:	98 17       	cp	r25, r24
    1186:	29 f0       	breq	.+10     	; 0x1192 <OutputXorBanks+0x78>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1188:	8f ef       	ldi	r24, 0xFF	; 255
    118a:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    118c:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    118e:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1190:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1192:	90 93 c0 05 	sts	0x05C0, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    1196:	08 95       	ret

00001198 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1198:	80 91 bd 05 	lds	r24, 0x05BD
    119c:	48 2f       	mov	r20, r24
    119e:	55 27       	eor	r21, r21
    11a0:	47 fd       	sbrc	r20, 7
    11a2:	50 95       	com	r21
    11a4:	80 91 bb 05 	lds	r24, 0x05BB
    11a8:	99 27       	eor	r25, r25
    11aa:	87 fd       	sbrc	r24, 7
    11ac:	90 95       	com	r25
    11ae:	48 0f       	add	r20, r24
    11b0:	59 1f       	adc	r21, r25
    11b2:	8f ef       	ldi	r24, 0xFF	; 255
    11b4:	40 38       	cpi	r20, 0x80	; 128
    11b6:	58 07       	cpc	r21, r24
    11b8:	14 f4       	brge	.+4      	; 0x11be <OutputAndBanks+0x26>
    11ba:	40 e8       	ldi	r20, 0x80	; 128
    11bc:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    11be:	80 91 be 05 	lds	r24, 0x05BE
    11c2:	28 2f       	mov	r18, r24
    11c4:	33 27       	eor	r19, r19
    11c6:	27 fd       	sbrc	r18, 7
    11c8:	30 95       	com	r19
    11ca:	80 91 bc 05 	lds	r24, 0x05BC
    11ce:	99 27       	eor	r25, r25
    11d0:	87 fd       	sbrc	r24, 7
    11d2:	90 95       	com	r25
    11d4:	28 0f       	add	r18, r24
    11d6:	39 1f       	adc	r19, r25
    11d8:	8f ef       	ldi	r24, 0xFF	; 255
    11da:	20 38       	cpi	r18, 0x80	; 128
    11dc:	38 07       	cpc	r19, r24
    11de:	14 f4       	brge	.+4      	; 0x11e4 <OutputAndBanks+0x4c>
    11e0:	20 e8       	ldi	r18, 0x80	; 128
    11e2:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.		
    11e4:	c9 01       	movw	r24, r18
    11e6:	20 38       	cpi	r18, 0x80	; 128
    11e8:	31 05       	cpc	r19, r1
    11ea:	14 f0       	brlt	.+4      	; 0x11f0 <OutputAndBanks+0x58>
    11ec:	8f e7       	ldi	r24, 0x7F	; 127
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	28 2f       	mov	r18, r24
    11f2:	20 58       	subi	r18, 0x80	; 128
    11f4:	ca 01       	movw	r24, r20
    11f6:	40 38       	cpi	r20, 0x80	; 128
    11f8:	51 05       	cpc	r21, r1
    11fa:	14 f0       	brlt	.+4      	; 0x1200 <OutputAndBanks+0x68>
    11fc:	8f e7       	ldi	r24, 0x7F	; 127
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	98 2f       	mov	r25, r24
    1202:	90 58       	subi	r25, 0x80	; 128
    1204:	92 23       	and	r25, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1206:	80 91 c0 05 	lds	r24, 0x05C0
    120a:	98 17       	cp	r25, r24
    120c:	29 f0       	breq	.+10     	; 0x1218 <OutputAndBanks+0x80>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    120e:	8f ef       	ldi	r24, 0xFF	; 255
    1210:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1212:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1214:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1216:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1218:	90 93 c0 05 	sts	0x05C0, r25
//	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
}
    121c:	08 95       	ret

0000121e <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    121e:	1f 92       	push	r1
    1220:	0f 92       	push	r0
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	0f 92       	push	r0
    1226:	11 24       	eor	r1, r1
    1228:	2f 93       	push	r18
    122a:	3f 93       	push	r19
    122c:	4f 93       	push	r20
    122e:	5f 93       	push	r21
    1230:	6f 93       	push	r22
    1232:	7f 93       	push	r23
    1234:	8f 93       	push	r24
    1236:	9f 93       	push	r25
    1238:	af 93       	push	r26
    123a:	bf 93       	push	r27
    123c:	ef 93       	push	r30
    123e:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1240:	80 91 e8 05 	lds	r24, 0x05E8
    1244:	88 23       	and	r24, r24
    1246:	41 f0       	breq	.+16     	; 0x1258 <__vector_12+0x3a>
    1248:	80 91 e8 05 	lds	r24, 0x05E8
    124c:	88 23       	and	r24, r24
    124e:	41 f0       	breq	.+16     	; 0x1260 <__vector_12+0x42>
    1250:	80 91 3a 01 	lds	r24, 0x013A
    1254:	88 23       	and	r24, r24
    1256:	21 f0       	breq	.+8      	; 0x1260 <__vector_12+0x42>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    1258:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    125c:	80 93 bb 05 	sts	0x05BB, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    1260:	10 92 3a 01 	sts	0x013A, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1264:	e0 91 e2 05 	lds	r30, 0x05E2
    1268:	f0 91 e3 05 	lds	r31, 0x05E3
    126c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    126e:	80 91 7a 00 	lds	r24, 0x007A
    1272:	86 fd       	sbrc	r24, 6
    1274:	0a c0       	rjmp	.+20     	; 0x128a <__vector_12+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1276:	80 91 79 00 	lds	r24, 0x0079
    127a:	80 58       	subi	r24, 0x80	; 128
    127c:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    1280:	80 91 7a 00 	lds	r24, 0x007A
    1284:	80 64       	ori	r24, 0x40	; 64
    1286:	80 93 7a 00 	sts	0x007A, r24
	}
}
    128a:	ff 91       	pop	r31
    128c:	ef 91       	pop	r30
    128e:	bf 91       	pop	r27
    1290:	af 91       	pop	r26
    1292:	9f 91       	pop	r25
    1294:	8f 91       	pop	r24
    1296:	7f 91       	pop	r23
    1298:	6f 91       	pop	r22
    129a:	5f 91       	pop	r21
    129c:	4f 91       	pop	r20
    129e:	3f 91       	pop	r19
    12a0:	2f 91       	pop	r18
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63
    12a6:	0f 90       	pop	r0
    12a8:	1f 90       	pop	r1
    12aa:	18 95       	reti

000012ac <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    12ac:	1f 92       	push	r1
    12ae:	0f 92       	push	r0
    12b0:	0f b6       	in	r0, 0x3f	; 63
    12b2:	0f 92       	push	r0
    12b4:	11 24       	eor	r1, r1
    12b6:	2f 93       	push	r18
    12b8:	3f 93       	push	r19
    12ba:	4f 93       	push	r20
    12bc:	5f 93       	push	r21
    12be:	6f 93       	push	r22
    12c0:	7f 93       	push	r23
    12c2:	8f 93       	push	r24
    12c4:	9f 93       	push	r25
    12c6:	af 93       	push	r26
    12c8:	bf 93       	push	r27
    12ca:	ef 93       	push	r30
    12cc:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    12ce:	80 91 0b 06 	lds	r24, 0x060B
    12d2:	88 23       	and	r24, r24
    12d4:	41 f0       	breq	.+16     	; 0x12e6 <__vector_6+0x3a>
    12d6:	80 91 0b 06 	lds	r24, 0x060B
    12da:	88 23       	and	r24, r24
    12dc:	41 f0       	breq	.+16     	; 0x12ee <__vector_6+0x42>
    12de:	80 91 39 01 	lds	r24, 0x0139
    12e2:	88 23       	and	r24, r24
    12e4:	21 f0       	breq	.+8      	; 0x12ee <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    12e6:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    12ea:	80 93 bc 05 	sts	0x05BC, r24
	}	
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    12ee:	10 92 39 01 	sts	0x0139, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    12f2:	e0 91 e2 05 	lds	r30, 0x05E2
    12f6:	f0 91 e3 05 	lds	r31, 0x05E3
    12fa:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    12fc:	80 91 7a 00 	lds	r24, 0x007A
    1300:	86 fd       	sbrc	r24, 6
    1302:	0a c0       	rjmp	.+20     	; 0x1318 <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1304:	80 91 79 00 	lds	r24, 0x0079
    1308:	80 58       	subi	r24, 0x80	; 128
    130a:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    130e:	80 91 7a 00 	lds	r24, 0x007A
    1312:	80 64       	ori	r24, 0x40	; 64
    1314:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    1318:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    131a:	ff 91       	pop	r31
    131c:	ef 91       	pop	r30
    131e:	bf 91       	pop	r27
    1320:	af 91       	pop	r26
    1322:	9f 91       	pop	r25
    1324:	8f 91       	pop	r24
    1326:	7f 91       	pop	r23
    1328:	6f 91       	pop	r22
    132a:	5f 91       	pop	r21
    132c:	4f 91       	pop	r20
    132e:	3f 91       	pop	r19
    1330:	2f 91       	pop	r18
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	0f 90       	pop	r0
    1338:	1f 90       	pop	r1
    133a:	18 95       	reti

0000133c <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    133c:	1f 92       	push	r1
    133e:	0f 92       	push	r0
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	0f 92       	push	r0
    1344:	11 24       	eor	r1, r1
    1346:	ef 92       	push	r14
    1348:	ff 92       	push	r15
    134a:	0f 93       	push	r16
    134c:	1f 93       	push	r17
    134e:	2f 93       	push	r18
    1350:	3f 93       	push	r19
    1352:	4f 93       	push	r20
    1354:	5f 93       	push	r21
    1356:	6f 93       	push	r22
    1358:	7f 93       	push	r23
    135a:	8f 93       	push	r24
    135c:	9f 93       	push	r25
    135e:	af 93       	push	r26
    1360:	bf 93       	push	r27
    1362:	ef 93       	push	r30
    1364:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1366:	80 91 e8 05 	lds	r24, 0x05E8
    136a:	88 23       	and	r24, r24
    136c:	41 f0       	breq	.+16     	; 0x137e <__vector_13+0x42>
    136e:	80 91 e8 05 	lds	r24, 0x05E8
    1372:	88 23       	and	r24, r24
    1374:	41 f0       	breq	.+16     	; 0x1386 <__vector_13+0x4a>
    1376:	80 91 35 01 	lds	r24, 0x0135
    137a:	88 23       	and	r24, r24
    137c:	21 f0       	breq	.+8      	; 0x1386 <__vector_13+0x4a>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    137e:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    1382:	80 93 bd 05 	sts	0x05BD, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    1386:	80 91 ed 05 	lds	r24, 0x05ED
    138a:	88 23       	and	r24, r24
    138c:	c1 f1       	breq	.+112    	; 0x13fe <__vector_13+0xc2>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    138e:	20 91 ed 05 	lds	r18, 0x05ED
    1392:	60 91 f0 05 	lds	r22, 0x05F0
    1396:	70 91 f1 05 	lds	r23, 0x05F1
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	90 e0       	ldi	r25, 0x00	; 0
    139e:	30 e0       	ldi	r19, 0x00	; 0
    13a0:	40 e0       	ldi	r20, 0x00	; 0
    13a2:	50 e0       	ldi	r21, 0x00	; 0
    13a4:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    13a8:	2f e7       	ldi	r18, 0x7F	; 127
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	40 e0       	ldi	r20, 0x00	; 0
    13ae:	50 e0       	ldi	r21, 0x00	; 0
    13b0:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    13b4:	e0 90 88 00 	lds	r14, 0x0088
    13b8:	f0 90 89 00 	lds	r15, 0x0089
    13bc:	00 91 f0 05 	lds	r16, 0x05F0
    13c0:	10 91 f1 05 	lds	r17, 0x05F1
    13c4:	60 91 00 01 	lds	r22, 0x0100
    13c8:	70 91 01 01 	lds	r23, 0x0101
    13cc:	80 91 02 01 	lds	r24, 0x0102
    13d0:	90 91 03 01 	lds	r25, 0x0103
    13d4:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
    13d8:	0e 0d       	add	r16, r14
    13da:	1f 1d       	adc	r17, r15
    13dc:	20 91 36 01 	lds	r18, 0x0136
    13e0:	30 91 37 01 	lds	r19, 0x0137
    13e4:	02 0f       	add	r16, r18
    13e6:	13 1f       	adc	r17, r19
    13e8:	06 1b       	sub	r16, r22
    13ea:	17 0b       	sbc	r17, r23
    13ec:	10 93 89 00 	sts	0x0089, r17
    13f0:	00 93 88 00 	sts	0x0088, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    13f4:	70 93 37 01 	sts	0x0137, r23
    13f8:	60 93 36 01 	sts	0x0136, r22
    13fc:	0e c0       	rjmp	.+28     	; 0x141a <__vector_13+0xde>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    13fe:	20 91 88 00 	lds	r18, 0x0088
    1402:	30 91 89 00 	lds	r19, 0x0089
    1406:	80 91 f0 05 	lds	r24, 0x05F0
    140a:	90 91 f1 05 	lds	r25, 0x05F1
    140e:	82 0f       	add	r24, r18
    1410:	93 1f       	adc	r25, r19
    1412:	90 93 89 00 	sts	0x0089, r25
    1416:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    141a:	10 92 35 01 	sts	0x0135, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    141e:	e0 91 e2 05 	lds	r30, 0x05E2
    1422:	f0 91 e3 05 	lds	r31, 0x05E3
    1426:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1428:	80 91 7a 00 	lds	r24, 0x007A
    142c:	86 fd       	sbrc	r24, 6
    142e:	0a c0       	rjmp	.+20     	; 0x1444 <__vector_13+0x108>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1430:	80 91 79 00 	lds	r24, 0x0079
    1434:	80 58       	subi	r24, 0x80	; 128
    1436:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    143a:	80 91 7a 00 	lds	r24, 0x007A
    143e:	80 64       	ori	r24, 0x40	; 64
    1440:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1444:	ff 91       	pop	r31
    1446:	ef 91       	pop	r30
    1448:	bf 91       	pop	r27
    144a:	af 91       	pop	r26
    144c:	9f 91       	pop	r25
    144e:	8f 91       	pop	r24
    1450:	7f 91       	pop	r23
    1452:	6f 91       	pop	r22
    1454:	5f 91       	pop	r21
    1456:	4f 91       	pop	r20
    1458:	3f 91       	pop	r19
    145a:	2f 91       	pop	r18
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	0f 90       	pop	r0
    1466:	0f be       	out	0x3f, r0	; 63
    1468:	0f 90       	pop	r0
    146a:	1f 90       	pop	r1
    146c:	18 95       	reti

0000146e <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    146e:	1f 92       	push	r1
    1470:	0f 92       	push	r0
    1472:	0f b6       	in	r0, 0x3f	; 63
    1474:	0f 92       	push	r0
    1476:	11 24       	eor	r1, r1
    1478:	ef 92       	push	r14
    147a:	ff 92       	push	r15
    147c:	0f 93       	push	r16
    147e:	1f 93       	push	r17
    1480:	2f 93       	push	r18
    1482:	3f 93       	push	r19
    1484:	4f 93       	push	r20
    1486:	5f 93       	push	r21
    1488:	6f 93       	push	r22
    148a:	7f 93       	push	r23
    148c:	8f 93       	push	r24
    148e:	9f 93       	push	r25
    1490:	af 93       	push	r26
    1492:	bf 93       	push	r27
    1494:	ef 93       	push	r30
    1496:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1498:	80 91 0b 06 	lds	r24, 0x060B
    149c:	88 23       	and	r24, r24
    149e:	41 f0       	breq	.+16     	; 0x14b0 <__vector_14+0x42>
    14a0:	80 91 0b 06 	lds	r24, 0x060B
    14a4:	88 23       	and	r24, r24
    14a6:	41 f0       	breq	.+16     	; 0x14b8 <__vector_14+0x4a>
    14a8:	80 91 31 01 	lds	r24, 0x0131
    14ac:	88 23       	and	r24, r24
    14ae:	21 f0       	breq	.+8      	; 0x14b8 <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    14b0:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    14b4:	80 93 be 05 	sts	0x05BE, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    14b8:	80 91 10 06 	lds	r24, 0x0610
    14bc:	88 23       	and	r24, r24
    14be:	c1 f1       	breq	.+112    	; 0x1530 <__vector_14+0xc2>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    14c0:	20 91 10 06 	lds	r18, 0x0610
    14c4:	60 91 13 06 	lds	r22, 0x0613
    14c8:	70 91 14 06 	lds	r23, 0x0614
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	30 e0       	ldi	r19, 0x00	; 0
    14d2:	40 e0       	ldi	r20, 0x00	; 0
    14d4:	50 e0       	ldi	r21, 0x00	; 0
    14d6:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    14da:	2f e7       	ldi	r18, 0x7F	; 127
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	40 e0       	ldi	r20, 0x00	; 0
    14e0:	50 e0       	ldi	r21, 0x00	; 0
    14e2:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    14e6:	e0 90 8a 00 	lds	r14, 0x008A
    14ea:	f0 90 8b 00 	lds	r15, 0x008B
    14ee:	00 91 13 06 	lds	r16, 0x0613
    14f2:	10 91 14 06 	lds	r17, 0x0614
    14f6:	60 91 00 01 	lds	r22, 0x0100
    14fa:	70 91 01 01 	lds	r23, 0x0101
    14fe:	80 91 02 01 	lds	r24, 0x0102
    1502:	90 91 03 01 	lds	r25, 0x0103
    1506:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
    150a:	0e 0d       	add	r16, r14
    150c:	1f 1d       	adc	r17, r15
    150e:	20 91 32 01 	lds	r18, 0x0132
    1512:	30 91 33 01 	lds	r19, 0x0133
    1516:	02 0f       	add	r16, r18
    1518:	13 1f       	adc	r17, r19
    151a:	06 1b       	sub	r16, r22
    151c:	17 0b       	sbc	r17, r23
    151e:	10 93 8b 00 	sts	0x008B, r17
    1522:	00 93 8a 00 	sts	0x008A, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    1526:	70 93 33 01 	sts	0x0133, r23
    152a:	60 93 32 01 	sts	0x0132, r22
    152e:	0e c0       	rjmp	.+28     	; 0x154c <__vector_14+0xde>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    1530:	20 91 8a 00 	lds	r18, 0x008A
    1534:	30 91 8b 00 	lds	r19, 0x008B
    1538:	80 91 13 06 	lds	r24, 0x0613
    153c:	90 91 14 06 	lds	r25, 0x0614
    1540:	82 0f       	add	r24, r18
    1542:	93 1f       	adc	r25, r19
    1544:	90 93 8b 00 	sts	0x008B, r25
    1548:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    154c:	10 92 31 01 	sts	0x0131, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1550:	e0 91 e2 05 	lds	r30, 0x05E2
    1554:	f0 91 e3 05 	lds	r31, 0x05E3
    1558:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    155a:	80 91 7a 00 	lds	r24, 0x007A
    155e:	86 fd       	sbrc	r24, 6
    1560:	0a c0       	rjmp	.+20     	; 0x1576 <__vector_14+0x108>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1562:	80 91 79 00 	lds	r24, 0x0079
    1566:	80 58       	subi	r24, 0x80	; 128
    1568:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    156c:	80 91 7a 00 	lds	r24, 0x007A
    1570:	80 64       	ori	r24, 0x40	; 64
    1572:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1576:	ff 91       	pop	r31
    1578:	ef 91       	pop	r30
    157a:	bf 91       	pop	r27
    157c:	af 91       	pop	r26
    157e:	9f 91       	pop	r25
    1580:	8f 91       	pop	r24
    1582:	7f 91       	pop	r23
    1584:	6f 91       	pop	r22
    1586:	5f 91       	pop	r21
    1588:	4f 91       	pop	r20
    158a:	3f 91       	pop	r19
    158c:	2f 91       	pop	r18
    158e:	1f 91       	pop	r17
    1590:	0f 91       	pop	r16
    1592:	ff 90       	pop	r15
    1594:	ef 90       	pop	r14
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63
    159a:	0f 90       	pop	r0
    159c:	1f 90       	pop	r1
    159e:	18 95       	reti

000015a0 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    15a0:	1f 92       	push	r1
    15a2:	0f 92       	push	r0
    15a4:	0f b6       	in	r0, 0x3f	; 63
    15a6:	0f 92       	push	r0
    15a8:	11 24       	eor	r1, r1
    15aa:	2f 93       	push	r18
    15ac:	3f 93       	push	r19
    15ae:	4f 93       	push	r20
    15b0:	5f 93       	push	r21
    15b2:	6f 93       	push	r22
    15b4:	7f 93       	push	r23
    15b6:	8f 93       	push	r24
    15b8:	9f 93       	push	r25
    15ba:	af 93       	push	r26
    15bc:	bf 93       	push	r27
    15be:	ef 93       	push	r30
    15c0:	ff 93       	push	r31
	unsigned char 
		theByte;

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    15c2:	80 91 b5 05 	lds	r24, 0x05B5
    15c6:	81 30       	cpi	r24, 0x01	; 1
    15c8:	09 f0       	breq	.+2      	; 0x15cc <__vector_10+0x2c>
    15ca:	b9 c0       	rjmp	.+370    	; 0x173e <__vector_10+0x19e>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    15cc:	80 91 a9 05 	lds	r24, 0x05A9
    15d0:	90 91 aa 05 	lds	r25, 0x05AA
    15d4:	a0 91 ab 05 	lds	r26, 0x05AB
    15d8:	b0 91 ac 05 	lds	r27, 0x05AC
    15dc:	00 97       	sbiw	r24, 0x00	; 0
    15de:	a1 05       	cpc	r26, r1
    15e0:	b1 05       	cpc	r27, r1
    15e2:	09 f4       	brne	.+2      	; 0x15e6 <__vector_10+0x46>
    15e4:	71 c0       	rjmp	.+226    	; 0x16c8 <__vector_10+0x128>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    15e6:	80 91 9e 05 	lds	r24, 0x059E
    15ea:	90 91 9f 05 	lds	r25, 0x059F
    15ee:	89 2b       	or	r24, r25
    15f0:	09 f4       	brne	.+2      	; 0x15f4 <__vector_10+0x54>
    15f2:	9a c1       	rjmp	.+820    	; 0x1928 <__vector_10+0x388>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    15f4:	e0 91 9a 05 	lds	r30, 0x059A
    15f8:	f0 91 9b 05 	lds	r31, 0x059B
    15fc:	e6 56       	subi	r30, 0x66	; 102
    15fe:	fd 4f       	sbci	r31, 0xFD	; 253
    1600:	e0 81       	ld	r30, Z

				sdFifoReadPointer++;					// Move to next spot in fifo									
    1602:	80 91 9a 05 	lds	r24, 0x059A
    1606:	90 91 9b 05 	lds	r25, 0x059B
    160a:	01 96       	adiw	r24, 0x01	; 1
    160c:	90 93 9b 05 	sts	0x059B, r25
    1610:	80 93 9a 05 	sts	0x059A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    1614:	80 91 9a 05 	lds	r24, 0x059A
    1618:	90 91 9b 05 	lds	r25, 0x059B
    161c:	80 50       	subi	r24, 0x00	; 0
    161e:	93 40       	sbci	r25, 0x03	; 3
    1620:	20 f0       	brcs	.+8      	; 0x162a <__vector_10+0x8a>
				{
					sdFifoReadPointer=0;
    1622:	10 92 9b 05 	sts	0x059B, r1
    1626:	10 92 9a 05 	sts	0x059A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    162a:	80 91 9e 05 	lds	r24, 0x059E
    162e:	90 91 9f 05 	lds	r25, 0x059F
    1632:	01 97       	sbiw	r24, 0x01	; 1
    1634:	90 93 9f 05 	sts	0x059F, r25
    1638:	80 93 9e 05 	sts	0x059E, r24
				sdRamSampleRemaining--;			// One less byte in the sample					
    163c:	80 91 a9 05 	lds	r24, 0x05A9
    1640:	90 91 aa 05 	lds	r25, 0x05AA
    1644:	a0 91 ab 05 	lds	r26, 0x05AB
    1648:	b0 91 ac 05 	lds	r27, 0x05AC
    164c:	01 97       	sbiw	r24, 0x01	; 1
    164e:	a1 09       	sbc	r26, r1
    1650:	b1 09       	sbc	r27, r1
    1652:	80 93 a9 05 	sts	0x05A9, r24
    1656:	90 93 aa 05 	sts	0x05AA, r25
    165a:	a0 93 ab 05 	sts	0x05AB, r26
    165e:	b0 93 ac 05 	sts	0x05AC, r27

				// Now put this byte into the RAM bank in the correct address.
			
				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    1662:	8f ef       	ldi	r24, 0xFF	; 255
    1664:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    1666:	20 91 b6 05 	lds	r18, 0x05B6
    166a:	30 91 b7 05 	lds	r19, 0x05B7
    166e:	40 91 b8 05 	lds	r20, 0x05B8
    1672:	50 91 b9 05 	lds	r21, 0x05B9
    1676:	25 b9       	out	0x05, r18	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    1678:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    167a:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    167c:	bb 27       	eor	r27, r27
    167e:	a5 2f       	mov	r26, r21
    1680:	94 2f       	mov	r25, r20
    1682:	83 2f       	mov	r24, r19
    1684:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    1686:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    1688:	14 98       	cbi	0x02, 4	; 2
				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    168a:	ca 01       	movw	r24, r20
    168c:	aa 27       	eor	r26, r26
    168e:	bb 27       	eor	r27, r27
    1690:	87 70       	andi	r24, 0x07	; 7
    1692:	88 68       	ori	r24, 0x88	; 136
    1694:	88 b9       	out	0x08, r24	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    1696:	e5 b9       	out	0x05, r30	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    1698:	80 91 ba 05 	lds	r24, 0x05BA
    169c:	81 30       	cpi	r24, 0x01	; 1
    169e:	29 f4       	brne	.+10     	; 0x16aa <__vector_10+0x10a>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    16a0:	2f 5f       	subi	r18, 0xFF	; 255
    16a2:	3f 4f       	sbci	r19, 0xFF	; 255
    16a4:	4f 4f       	sbci	r20, 0xFF	; 255
    16a6:	5f 4f       	sbci	r21, 0xFF	; 255
    16a8:	04 c0       	rjmp	.+8      	; 0x16b2 <__vector_10+0x112>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    16aa:	21 50       	subi	r18, 0x01	; 1
    16ac:	30 40       	sbci	r19, 0x00	; 0
    16ae:	40 40       	sbci	r20, 0x00	; 0
    16b0:	50 40       	sbci	r21, 0x00	; 0
    16b2:	20 93 b6 05 	sts	0x05B6, r18
    16b6:	30 93 b7 05 	sts	0x05B7, r19
    16ba:	40 93 b8 05 	sts	0x05B8, r20
    16be:	50 93 b9 05 	sts	0x05B9, r21
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    16c2:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    16c4:	11 9a       	sbi	0x02, 1	; 2
    16c6:	30 c1       	rjmp	.+608    	; 0x1928 <__vector_10+0x388>
										
			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    16c8:	10 92 b5 05 	sts	0x05B5, r1
			TCCR2B=0;					// Stop this timer
    16cc:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    16d0:	80 91 70 00 	lds	r24, 0x0070
    16d4:	8b 7f       	andi	r24, 0xFB	; 251
    16d6:	80 93 70 00 	sts	0x0070, r24
			
			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    16da:	80 91 ba 05 	lds	r24, 0x05BA
    16de:	20 91 b6 05 	lds	r18, 0x05B6
    16e2:	30 91 b7 05 	lds	r19, 0x05B7
    16e6:	40 91 b8 05 	lds	r20, 0x05B8
    16ea:	50 91 b9 05 	lds	r21, 0x05B9
    16ee:	81 30       	cpi	r24, 0x01	; 1
    16f0:	99 f4       	brne	.+38     	; 0x1718 <__vector_10+0x178>
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    16f2:	10 92 eb 05 	sts	0x05EB, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    16f6:	20 93 f2 05 	sts	0x05F2, r18
    16fa:	30 93 f3 05 	sts	0x05F3, r19
    16fe:	40 93 f4 05 	sts	0x05F4, r20
    1702:	50 93 f5 05 	sts	0x05F5, r21
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    1706:	20 93 fa 05 	sts	0x05FA, r18
    170a:	30 93 fb 05 	sts	0x05FB, r19
    170e:	40 93 fc 05 	sts	0x05FC, r20
    1712:	50 93 fd 05 	sts	0x05FD, r21
    1716:	08 c1       	rjmp	.+528    	; 0x1928 <__vector_10+0x388>
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    1718:	10 92 0e 06 	sts	0x060E, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    171c:	20 93 15 06 	sts	0x0615, r18
    1720:	30 93 16 06 	sts	0x0616, r19
    1724:	40 93 17 06 	sts	0x0617, r20
    1728:	50 93 18 06 	sts	0x0618, r21
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).			
    172c:	20 93 1d 06 	sts	0x061D, r18
    1730:	30 93 1e 06 	sts	0x061E, r19
    1734:	40 93 1f 06 	sts	0x061F, r20
    1738:	50 93 20 06 	sts	0x0620, r21
    173c:	f5 c0       	rjmp	.+490    	; 0x1928 <__vector_10+0x388>
			}
		}	
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    173e:	82 30       	cpi	r24, 0x02	; 2
    1740:	09 f0       	breq	.+2      	; 0x1744 <__vector_10+0x1a4>
    1742:	91 c0       	rjmp	.+290    	; 0x1866 <__vector_10+0x2c6>
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    1744:	80 91 9e 05 	lds	r24, 0x059E
    1748:	90 91 9f 05 	lds	r25, 0x059F
    174c:	80 50       	subi	r24, 0x00	; 0
    174e:	93 40       	sbci	r25, 0x03	; 3
    1750:	08 f0       	brcs	.+2      	; 0x1754 <__vector_10+0x1b4>
    1752:	ea c0       	rjmp	.+468    	; 0x1928 <__vector_10+0x388>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    1754:	80 91 a9 05 	lds	r24, 0x05A9
    1758:	90 91 aa 05 	lds	r25, 0x05AA
    175c:	a0 91 ab 05 	lds	r26, 0x05AB
    1760:	b0 91 ac 05 	lds	r27, 0x05AC
    1764:	60 91 ba 05 	lds	r22, 0x05BA
    1768:	00 97       	sbiw	r24, 0x00	; 0
    176a:	a1 05       	cpc	r26, r1
    176c:	b1 05       	cpc	r27, r1
    176e:	09 f4       	brne	.+2      	; 0x1772 <__vector_10+0x1d2>
    1770:	69 c0       	rjmp	.+210    	; 0x1844 <__vector_10+0x2a4>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    1772:	20 91 b6 05 	lds	r18, 0x05B6
    1776:	30 91 b7 05 	lds	r19, 0x05B7
    177a:	40 91 b8 05 	lds	r20, 0x05B8
    177e:	50 91 b9 05 	lds	r21, 0x05B9
    1782:	25 b9       	out	0x05, r18	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    1784:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    1786:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    1788:	bb 27       	eor	r27, r27
    178a:	a5 2f       	mov	r26, r21
    178c:	94 2f       	mov	r25, r20
    178e:	83 2f       	mov	r24, r19
    1790:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    1792:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    1794:	14 98       	cbi	0x02, 4	; 2

				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    1796:	ca 01       	movw	r24, r20
    1798:	aa 27       	eor	r26, r26
    179a:	bb 27       	eor	r27, r27
    179c:	87 70       	andi	r24, 0x07	; 7
    179e:	88 68       	ori	r24, 0x88	; 136
    17a0:	88 b9       	out	0x08, r24	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    17a2:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    17a4:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    17a6:	61 30       	cpi	r22, 0x01	; 1
    17a8:	29 f4       	brne	.+10     	; 0x17b4 <__vector_10+0x214>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    17aa:	2f 5f       	subi	r18, 0xFF	; 255
    17ac:	3f 4f       	sbci	r19, 0xFF	; 255
    17ae:	4f 4f       	sbci	r20, 0xFF	; 255
    17b0:	5f 4f       	sbci	r21, 0xFF	; 255
    17b2:	04 c0       	rjmp	.+8      	; 0x17bc <__vector_10+0x21c>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    17b4:	21 50       	subi	r18, 0x01	; 1
    17b6:	30 40       	sbci	r19, 0x00	; 0
    17b8:	40 40       	sbci	r20, 0x00	; 0
    17ba:	50 40       	sbci	r21, 0x00	; 0
    17bc:	20 93 b6 05 	sts	0x05B6, r18
    17c0:	30 93 b7 05 	sts	0x05B7, r19
    17c4:	40 93 b8 05 	sts	0x05B8, r20
    17c8:	50 93 b9 05 	sts	0x05B9, r21
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    17cc:	93 b1       	in	r25, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    17ce:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    17d0:	8f ef       	ldi	r24, 0xFF	; 255
    17d2:	84 b9       	out	0x04, r24	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    17d4:	e0 91 9c 05 	lds	r30, 0x059C
    17d8:	f0 91 9d 05 	lds	r31, 0x059D
    17dc:	e6 56       	subi	r30, 0x66	; 102
    17de:	fd 4f       	sbci	r31, 0xFD	; 253
    17e0:	90 83       	st	Z, r25
				sdFifoWritePointer++;				// Move to next spot in fifo									
    17e2:	80 91 9c 05 	lds	r24, 0x059C
    17e6:	90 91 9d 05 	lds	r25, 0x059D
    17ea:	01 96       	adiw	r24, 0x01	; 1
    17ec:	90 93 9d 05 	sts	0x059D, r25
    17f0:	80 93 9c 05 	sts	0x059C, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    17f4:	80 91 9c 05 	lds	r24, 0x059C
    17f8:	90 91 9d 05 	lds	r25, 0x059D
    17fc:	80 50       	subi	r24, 0x00	; 0
    17fe:	93 40       	sbci	r25, 0x03	; 3
    1800:	20 f0       	brcs	.+8      	; 0x180a <__vector_10+0x26a>
				{
					sdFifoWritePointer=0;
    1802:	10 92 9d 05 	sts	0x059D, r1
    1806:	10 92 9c 05 	sts	0x059C, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    180a:	80 91 9e 05 	lds	r24, 0x059E
    180e:	90 91 9f 05 	lds	r25, 0x059F
    1812:	01 96       	adiw	r24, 0x01	; 1
    1814:	90 93 9f 05 	sts	0x059F, r25
    1818:	80 93 9e 05 	sts	0x059E, r24
				sdRamSampleRemaining--;		// One less byte in the sample					
    181c:	80 91 a9 05 	lds	r24, 0x05A9
    1820:	90 91 aa 05 	lds	r25, 0x05AA
    1824:	a0 91 ab 05 	lds	r26, 0x05AB
    1828:	b0 91 ac 05 	lds	r27, 0x05AC
    182c:	01 97       	sbiw	r24, 0x01	; 1
    182e:	a1 09       	sbc	r26, r1
    1830:	b1 09       	sbc	r27, r1
    1832:	80 93 a9 05 	sts	0x05A9, r24
    1836:	90 93 aa 05 	sts	0x05AA, r25
    183a:	a0 93 ab 05 	sts	0x05AB, r26
    183e:	b0 93 ac 05 	sts	0x05AC, r27
    1842:	72 c0       	rjmp	.+228    	; 0x1928 <__vector_10+0x388>

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    1844:	10 92 b5 05 	sts	0x05B5, r1
				TCCR2B=0;					// Stop this timer
    1848:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    184c:	80 91 70 00 	lds	r24, 0x0070
    1850:	8b 7f       	andi	r24, 0xFB	; 251
    1852:	80 93 70 00 	sts	0x0070, r24
				
				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    1856:	61 30       	cpi	r22, 0x01	; 1
    1858:	19 f4       	brne	.+6      	; 0x1860 <__vector_10+0x2c0>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    185a:	10 92 eb 05 	sts	0x05EB, r1
    185e:	64 c0       	rjmp	.+200    	; 0x1928 <__vector_10+0x388>
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    1860:	10 92 0e 06 	sts	0x060E, r1
    1864:	61 c0       	rjmp	.+194    	; 0x1928 <__vector_10+0x388>
				}
			}			
		}				
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    1866:	83 30       	cpi	r24, 0x03	; 3
    1868:	09 f0       	breq	.+2      	; 0x186c <__vector_10+0x2cc>
    186a:	5e c0       	rjmp	.+188    	; 0x1928 <__vector_10+0x388>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    186c:	80 91 a9 05 	lds	r24, 0x05A9
    1870:	90 91 aa 05 	lds	r25, 0x05AA
    1874:	a0 91 ab 05 	lds	r26, 0x05AB
    1878:	b0 91 ac 05 	lds	r27, 0x05AC
    187c:	00 97       	sbiw	r24, 0x00	; 0
    187e:	a1 05       	cpc	r26, r1
    1880:	b1 05       	cpc	r27, r1
    1882:	09 f4       	brne	.+2      	; 0x1886 <__vector_10+0x2e6>
    1884:	46 c0       	rjmp	.+140    	; 0x1912 <__vector_10+0x372>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    1886:	80 91 9e 05 	lds	r24, 0x059E
    188a:	90 91 9f 05 	lds	r25, 0x059F
    188e:	89 2b       	or	r24, r25
    1890:	09 f4       	brne	.+2      	; 0x1894 <__vector_10+0x2f4>
    1892:	4a c0       	rjmp	.+148    	; 0x1928 <__vector_10+0x388>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    1894:	e0 91 9a 05 	lds	r30, 0x059A
    1898:	f0 91 9b 05 	lds	r31, 0x059B
    189c:	e6 56       	subi	r30, 0x66	; 102
    189e:	fd 4f       	sbci	r31, 0xFD	; 253
    18a0:	e0 81       	ld	r30, Z

				sdFifoReadPointer++;					// Move to next spot in fifo									
    18a2:	80 91 9a 05 	lds	r24, 0x059A
    18a6:	90 91 9b 05 	lds	r25, 0x059B
    18aa:	01 96       	adiw	r24, 0x01	; 1
    18ac:	90 93 9b 05 	sts	0x059B, r25
    18b0:	80 93 9a 05 	sts	0x059A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    18b4:	80 91 9a 05 	lds	r24, 0x059A
    18b8:	90 91 9b 05 	lds	r25, 0x059B
    18bc:	80 50       	subi	r24, 0x00	; 0
    18be:	93 40       	sbci	r25, 0x03	; 3
    18c0:	20 f0       	brcs	.+8      	; 0x18ca <__vector_10+0x32a>
				{
					sdFifoReadPointer=0;
    18c2:	10 92 9b 05 	sts	0x059B, r1
    18c6:	10 92 9a 05 	sts	0x059A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    18ca:	80 91 9e 05 	lds	r24, 0x059E
    18ce:	90 91 9f 05 	lds	r25, 0x059F
    18d2:	01 97       	sbiw	r24, 0x01	; 1
    18d4:	90 93 9f 05 	sts	0x059F, r25
    18d8:	80 93 9e 05 	sts	0x059E, r24
				sdRamSampleRemaining--;			// One less byte in the sample					
    18dc:	80 91 a9 05 	lds	r24, 0x05A9
    18e0:	90 91 aa 05 	lds	r25, 0x05AA
    18e4:	a0 91 ab 05 	lds	r26, 0x05AB
    18e8:	b0 91 ac 05 	lds	r27, 0x05AC
    18ec:	01 97       	sbiw	r24, 0x01	; 1
    18ee:	a1 09       	sbc	r26, r1
    18f0:	b1 09       	sbc	r27, r1
    18f2:	80 93 a9 05 	sts	0x05A9, r24
    18f6:	90 93 aa 05 	sts	0x05AA, r25
    18fa:	a0 93 ab 05 	sts	0x05AB, r26
    18fe:	b0 93 ac 05 	sts	0x05AC, r27

				// Now spit the byte out the DAC.
				
				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine			
    1902:	e0 93 bf 05 	sts	0x05BF, r30
				UpdateOutput();				// Update the DAC
    1906:	e0 91 e2 05 	lds	r30, 0x05E2
    190a:	f0 91 e3 05 	lds	r31, 0x05E3
    190e:	09 95       	icall
    1910:	0b c0       	rjmp	.+22     	; 0x1928 <__vector_10+0x388>
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    1912:	10 92 b5 05 	sts	0x05B5, r1
			TCCR2B=0;					// Stop this timer
    1916:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    191a:	80 91 70 00 	lds	r24, 0x0070
    191e:	8b 7f       	andi	r24, 0xFB	; 251
    1920:	80 93 70 00 	sts	0x0070, r24
			
			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    1924:	10 92 bf 05 	sts	0x05BF, r1
		}	
	}
}
    1928:	ff 91       	pop	r31
    192a:	ef 91       	pop	r30
    192c:	bf 91       	pop	r27
    192e:	af 91       	pop	r26
    1930:	9f 91       	pop	r25
    1932:	8f 91       	pop	r24
    1934:	7f 91       	pop	r23
    1936:	6f 91       	pop	r22
    1938:	5f 91       	pop	r21
    193a:	4f 91       	pop	r20
    193c:	3f 91       	pop	r19
    193e:	2f 91       	pop	r18
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	0f 90       	pop	r0
    1946:	1f 90       	pop	r1
    1948:	18 95       	reti

0000194a <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    194a:	1f 92       	push	r1
    194c:	0f 92       	push	r0
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	0f 92       	push	r0
    1952:	11 24       	eor	r1, r1
    1954:	8f 93       	push	r24
    1956:	9f 93       	push	r25
	static unsigned char
		pwmCount;
	
	if(ledPwm>pwmCount)
    1958:	80 91 3d 01 	lds	r24, 0x013D
    195c:	90 91 30 01 	lds	r25, 0x0130
    1960:	98 17       	cp	r25, r24
    1962:	18 f4       	brcc	.+6      	; 0x196a <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    1964:	8f ef       	ldi	r24, 0xFF	; 255
    1966:	85 b9       	out	0x05, r24	; 5
    1968:	01 c0       	rjmp	.+2      	; 0x196c <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    196a:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    196c:	9f 5f       	subi	r25, 0xFF	; 255
    196e:	90 93 30 01 	sts	0x0130, r25
}
    1972:	9f 91       	pop	r25
    1974:	8f 91       	pop	r24
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
    197a:	0f 90       	pop	r0
    197c:	1f 90       	pop	r1
    197e:	18 95       	reti

00001980 <__vector_default>:

ISR(__vector_default)
{
    1980:	1f 92       	push	r1
    1982:	0f 92       	push	r0
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	0f 92       	push	r0
    1988:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    198a:	0f 90       	pop	r0
    198c:	0f be       	out	0x3f, r0	; 63
    198e:	0f 90       	pop	r0
    1990:	1f 90       	pop	r1
    1992:	18 95       	reti

00001994 <HandleSoftclock>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    1994:	a8 9b       	sbis	0x15, 0	; 21
    1996:	0a c0       	rjmp	.+20     	; 0x19ac <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    1998:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    199a:	80 91 2c 06 	lds	r24, 0x062C
    199e:	90 91 2d 06 	lds	r25, 0x062D
    19a2:	01 96       	adiw	r24, 0x01	; 1
    19a4:	90 93 2d 06 	sts	0x062D, r25
    19a8:	80 93 2c 06 	sts	0x062C, r24
    19ac:	08 95       	ret

000019ae <SetSampleClock>:
// Updated to account for locking banks (removed above).  Necessary now because we can be screwing with RAM via SD stuff as well as play/rec.  Also the SD has its own ISR now which makes more sense.

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
    19ae:	78 2f       	mov	r23, r24
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    19b0:	28 2f       	mov	r18, r24
    19b2:	30 e0       	ldi	r19, 0x00	; 0
    19b4:	83 e2       	ldi	r24, 0x23	; 35
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	28 9f       	mul	r18, r24
    19ba:	f0 01       	movw	r30, r0
    19bc:	29 9f       	mul	r18, r25
    19be:	f0 0d       	add	r31, r0
    19c0:	38 9f       	mul	r19, r24
    19c2:	f0 0d       	add	r31, r0
    19c4:	11 24       	eor	r1, r1
    19c6:	ea 51       	subi	r30, 0x1A	; 26
    19c8:	fa 4f       	sbci	r31, 0xFA	; 250
    19ca:	61 87       	std	Z+9, r22	; 0x09

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    19cc:	62 30       	cpi	r22, 0x02	; 2
    19ce:	39 f5       	brne	.+78     	; 0x1a1e <SetSampleClock+0x70>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    19d0:	53 87       	std	Z+11, r21	; 0x0b
    19d2:	42 87       	std	Z+10, r20	; 0x0a

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    19d4:	77 23       	and	r23, r23
    19d6:	79 f4       	brne	.+30     	; 0x19f6 <SetSampleClock+0x48>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    19d8:	80 91 84 00 	lds	r24, 0x0084
    19dc:	90 91 85 00 	lds	r25, 0x0085
    19e0:	84 0f       	add	r24, r20
    19e2:	95 1f       	adc	r25, r21
    19e4:	90 93 89 00 	sts	0x0089, r25
    19e8:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    19ec:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    19ee:	80 91 6f 00 	lds	r24, 0x006F
    19f2:	82 60       	ori	r24, 0x02	; 2
    19f4:	0e c0       	rjmp	.+28     	; 0x1a12 <SetSampleClock+0x64>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    19f6:	80 91 84 00 	lds	r24, 0x0084
    19fa:	90 91 85 00 	lds	r25, 0x0085
    19fe:	84 0f       	add	r24, r20
    1a00:	95 1f       	adc	r25, r21
    1a02:	90 93 8b 00 	sts	0x008B, r25
    1a06:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    1a0a:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1a0c:	80 91 6f 00 	lds	r24, 0x006F
    1a10:	84 60       	ori	r24, 0x04	; 4
    1a12:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.			
    1a16:	81 e0       	ldi	r24, 0x01	; 1
    1a18:	80 93 81 00 	sts	0x0081, r24
    1a1c:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1a1e:	61 30       	cpi	r22, 0x01	; 1
    1a20:	a9 f4       	brne	.+42     	; 0x1a4c <SetSampleClock+0x9e>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1a22:	77 23       	and	r23, r23
    1a24:	61 f4       	brne	.+24     	; 0x1a3e <SetSampleClock+0x90>
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    1a26:	80 91 81 00 	lds	r24, 0x0081
    1a2a:	80 64       	ori	r24, 0x40	; 64
    1a2c:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1a30:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1a32:	80 91 6f 00 	lds	r24, 0x006F
    1a36:	80 62       	ori	r24, 0x20	; 32
    1a38:	80 93 6f 00 	sts	0x006F, r24
    1a3c:	08 95       	ret
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    1a3e:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    1a40:	84 e0       	ldi	r24, 0x04	; 4
    1a42:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    1a46:	80 e1       	ldi	r24, 0x10	; 16
    1a48:	80 93 6d 00 	sts	0x006D, r24
    1a4c:	08 95       	ret

00001a4e <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    1a4e:	ff 92       	push	r15
    1a50:	0f 93       	push	r16
    1a52:	1f 93       	push	r17
    1a54:	78 2f       	mov	r23, r24

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1a56:	28 2f       	mov	r18, r24
    1a58:	30 e0       	ldi	r19, 0x00	; 0
    1a5a:	83 e2       	ldi	r24, 0x23	; 35
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	28 9f       	mul	r18, r24
    1a60:	f0 01       	movw	r30, r0
    1a62:	29 9f       	mul	r18, r25
    1a64:	f0 0d       	add	r31, r0
    1a66:	38 9f       	mul	r19, r24
    1a68:	f0 0d       	add	r31, r0
    1a6a:	11 24       	eor	r1, r1
    1a6c:	ea 51       	subi	r30, 0x1A	; 26
    1a6e:	fa 4f       	sbci	r31, 0xFA	; 250
    1a70:	85 81       	ldd	r24, Z+5	; 0x05
    1a72:	88 23       	and	r24, r24
    1a74:	31 f0       	breq	.+12     	; 0x1a82 <StartRecording+0x34>
    1a76:	80 91 b5 05 	lds	r24, 0x05B5
    1a7a:	81 50       	subi	r24, 0x01	; 1
    1a7c:	82 30       	cpi	r24, 0x02	; 2
    1a7e:	08 f4       	brcc	.+2      	; 0x1a82 <StartRecording+0x34>
    1a80:	48 c0       	rjmp	.+144    	; 0x1b12 <StartRecording+0xc4>
	{

		sreg=SREG;	// Store global interrupt state.
    1a82:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1a84:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    1a86:	83 e2       	ldi	r24, 0x23	; 35
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	28 9f       	mul	r18, r24
    1a8c:	80 01       	movw	r16, r0
    1a8e:	29 9f       	mul	r18, r25
    1a90:	10 0d       	add	r17, r0
    1a92:	38 9f       	mul	r19, r24
    1a94:	10 0d       	add	r17, r0
    1a96:	11 24       	eor	r1, r1
    1a98:	0a 51       	subi	r16, 0x1A	; 26
    1a9a:	1a 4f       	sbci	r17, 0xFA	; 250
    1a9c:	83 e0       	ldi	r24, 0x03	; 3
    1a9e:	f8 01       	movw	r30, r16
    1aa0:	80 83       	st	Z, r24

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    1aa2:	80 89       	ldd	r24, Z+16	; 0x10
    1aa4:	91 89       	ldd	r25, Z+17	; 0x11
    1aa6:	a2 89       	ldd	r26, Z+18	; 0x12
    1aa8:	b3 89       	ldd	r27, Z+19	; 0x13
    1aaa:	87 8f       	std	Z+31, r24	; 0x1f
    1aac:	90 a3       	std	Z+32, r25	; 0x20
    1aae:	a1 a3       	std	Z+33, r26	; 0x21
    1ab0:	b2 a3       	std	Z+34, r27	; 0x22
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    1ab2:	80 89       	ldd	r24, Z+16	; 0x10
    1ab4:	91 89       	ldd	r25, Z+17	; 0x11
    1ab6:	a2 89       	ldd	r26, Z+18	; 0x12
    1ab8:	b3 89       	ldd	r27, Z+19	; 0x13
    1aba:	84 87       	std	Z+12, r24	; 0x0c
    1abc:	95 87       	std	Z+13, r25	; 0x0d
    1abe:	a6 87       	std	Z+14, r26	; 0x0e
    1ac0:	b7 87       	std	Z+15, r27	; 0x0f
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    1ac2:	80 89       	ldd	r24, Z+16	; 0x10
    1ac4:	91 89       	ldd	r25, Z+17	; 0x11
    1ac6:	a2 89       	ldd	r26, Z+18	; 0x12
    1ac8:	b3 89       	ldd	r27, Z+19	; 0x13
    1aca:	80 8f       	std	Z+24, r24	; 0x18
    1acc:	91 8f       	std	Z+25, r25	; 0x19
    1ace:	a2 8f       	std	Z+26, r26	; 0x1a
    1ad0:	b3 8f       	std	Z+27, r27	; 0x1b
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    1ad2:	80 89       	ldd	r24, Z+16	; 0x10
    1ad4:	91 89       	ldd	r25, Z+17	; 0x11
    1ad6:	a2 89       	ldd	r26, Z+18	; 0x12
    1ad8:	b3 89       	ldd	r27, Z+19	; 0x13
    1ada:	84 8b       	std	Z+20, r24	; 0x14
    1adc:	95 8b       	std	Z+21, r25	; 0x15
    1ade:	a6 8b       	std	Z+22, r26	; 0x16
    1ae0:	b7 8b       	std	Z+23, r27	; 0x17
		bankStates[theBank].sampleWindowOffset=0;									// "
    1ae2:	16 8e       	std	Z+30, r1	; 0x1e

		outOfRam=false;						// Plenty of ram left...
    1ae4:	10 92 42 01 	sts	0x0142, r1

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    1ae8:	87 2f       	mov	r24, r23
    1aea:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.		
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	f8 01       	movw	r30, r16
    1af2:	85 83       	std	Z+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    1af4:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1af6:	80 91 7a 00 	lds	r24, 0x007A
    1afa:	86 fd       	sbrc	r24, 6
    1afc:	0a c0       	rjmp	.+20     	; 0x1b12 <StartRecording+0xc4>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1afe:	80 91 79 00 	lds	r24, 0x0079
    1b02:	80 58       	subi	r24, 0x80	; 128
    1b04:	80 93 58 02 	sts	0x0258, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1b08:	80 91 7a 00 	lds	r24, 0x007A
    1b0c:	80 64       	ori	r24, 0x40	; 64
    1b0e:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    1b12:	1f 91       	pop	r17
    1b14:	0f 91       	pop	r16
    1b16:	ff 90       	pop	r15
    1b18:	08 95       	ret

00001b1a <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1b1a:	1f 93       	push	r17
    1b1c:	cf 93       	push	r28
    1b1e:	df 93       	push	r29
    1b20:	28 2f       	mov	r18, r24
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1b22:	c8 2f       	mov	r28, r24
    1b24:	d0 e0       	ldi	r29, 0x00	; 0
    1b26:	83 e2       	ldi	r24, 0x23	; 35
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	c8 9f       	mul	r28, r24
    1b2c:	f0 01       	movw	r30, r0
    1b2e:	c9 9f       	mul	r28, r25
    1b30:	f0 0d       	add	r31, r0
    1b32:	d8 9f       	mul	r29, r24
    1b34:	f0 0d       	add	r31, r0
    1b36:	11 24       	eor	r1, r1
    1b38:	ea 51       	subi	r30, 0x1A	; 26
    1b3a:	fa 4f       	sbci	r31, 0xFA	; 250
    1b3c:	85 81       	ldd	r24, Z+5	; 0x05
    1b3e:	88 23       	and	r24, r24
    1b40:	29 f0       	breq	.+10     	; 0x1b4c <StartPlayback+0x32>
    1b42:	80 91 b5 05 	lds	r24, 0x05B5
    1b46:	81 50       	subi	r24, 0x01	; 1
    1b48:	82 30       	cpi	r24, 0x02	; 2
    1b4a:	b8 f1       	brcs	.+110    	; 0x1bba <StartPlayback+0xa0>
	{
		sreg=SREG;	// Store global interrupt state.
    1b4c:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1b4e:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    1b50:	83 e2       	ldi	r24, 0x23	; 35
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	c8 9f       	mul	r28, r24
    1b56:	f0 01       	movw	r30, r0
    1b58:	c9 9f       	mul	r28, r25
    1b5a:	f0 0d       	add	r31, r0
    1b5c:	d8 9f       	mul	r29, r24
    1b5e:	f0 0d       	add	r31, r0
    1b60:	11 24       	eor	r1, r1
    1b62:	ea 51       	subi	r30, 0x1A	; 26
    1b64:	fa 4f       	sbci	r31, 0xFA	; 250
    1b66:	84 e0       	ldi	r24, 0x04	; 4
    1b68:	80 83       	st	Z, r24

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    1b6a:	83 81       	ldd	r24, Z+3	; 0x03
    1b6c:	88 23       	and	r24, r24
    1b6e:	51 f0       	breq	.+20     	; 0x1b84 <StartPlayback+0x6a>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    1b70:	84 89       	ldd	r24, Z+20	; 0x14
    1b72:	95 89       	ldd	r25, Z+21	; 0x15
    1b74:	a6 89       	ldd	r26, Z+22	; 0x16
    1b76:	b7 89       	ldd	r27, Z+23	; 0x17
    1b78:	87 8f       	std	Z+31, r24	; 0x1f
    1b7a:	90 a3       	std	Z+32, r25	; 0x20
    1b7c:	a1 a3       	std	Z+33, r26	; 0x21
    1b7e:	b2 a3       	std	Z+34, r27	; 0x22
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    1b80:	14 82       	std	Z+4, r1	; 0x04
    1b82:	0a c0       	rjmp	.+20     	; 0x1b98 <StartPlayback+0x7e>
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.	
    1b84:	80 8d       	ldd	r24, Z+24	; 0x18
    1b86:	91 8d       	ldd	r25, Z+25	; 0x19
    1b88:	a2 8d       	ldd	r26, Z+26	; 0x1a
    1b8a:	b3 8d       	ldd	r27, Z+27	; 0x1b
    1b8c:	87 8f       	std	Z+31, r24	; 0x1f
    1b8e:	90 a3       	std	Z+32, r25	; 0x20
    1b90:	a1 a3       	std	Z+33, r26	; 0x21
    1b92:	b2 a3       	std	Z+34, r27	; 0x22
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	84 83       	std	Z+4, r24	; 0x04
		}
		
		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    1b98:	82 2f       	mov	r24, r18
    1b9a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.		
    1b9e:	83 e2       	ldi	r24, 0x23	; 35
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	c8 9f       	mul	r28, r24
    1ba4:	f0 01       	movw	r30, r0
    1ba6:	c9 9f       	mul	r28, r25
    1ba8:	f0 0d       	add	r31, r0
    1baa:	d8 9f       	mul	r29, r24
    1bac:	f0 0d       	add	r31, r0
    1bae:	11 24       	eor	r1, r1
    1bb0:	ea 51       	subi	r30, 0x1A	; 26
    1bb2:	fa 4f       	sbci	r31, 0xFA	; 250
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1bb8:	1f bf       	out	0x3f, r17	; 63
	}
}
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	1f 91       	pop	r17
    1bc0:	08 95       	ret

00001bc2 <ContinuePlayback>:

static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
    1bc2:	ff 92       	push	r15
    1bc4:	0f 93       	push	r16
    1bc6:	1f 93       	push	r17
    1bc8:	78 2f       	mov	r23, r24
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1bca:	28 2f       	mov	r18, r24
    1bcc:	30 e0       	ldi	r19, 0x00	; 0
    1bce:	83 e2       	ldi	r24, 0x23	; 35
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	28 9f       	mul	r18, r24
    1bd4:	f0 01       	movw	r30, r0
    1bd6:	29 9f       	mul	r18, r25
    1bd8:	f0 0d       	add	r31, r0
    1bda:	38 9f       	mul	r19, r24
    1bdc:	f0 0d       	add	r31, r0
    1bde:	11 24       	eor	r1, r1
    1be0:	ea 51       	subi	r30, 0x1A	; 26
    1be2:	fa 4f       	sbci	r31, 0xFA	; 250
    1be4:	85 81       	ldd	r24, Z+5	; 0x05
    1be6:	88 23       	and	r24, r24
    1be8:	29 f0       	breq	.+10     	; 0x1bf4 <ContinuePlayback+0x32>
    1bea:	80 91 b5 05 	lds	r24, 0x05B5
    1bee:	81 50       	subi	r24, 0x01	; 1
    1bf0:	82 30       	cpi	r24, 0x02	; 2
    1bf2:	b8 f0       	brcs	.+46     	; 0x1c22 <ContinuePlayback+0x60>
	{
		sreg=SREG;	// Store global interrupt state.
    1bf4:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1bf6:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    1bf8:	83 e2       	ldi	r24, 0x23	; 35
    1bfa:	90 e0       	ldi	r25, 0x00	; 0
    1bfc:	28 9f       	mul	r18, r24
    1bfe:	80 01       	movw	r16, r0
    1c00:	29 9f       	mul	r18, r25
    1c02:	10 0d       	add	r17, r0
    1c04:	38 9f       	mul	r19, r24
    1c06:	10 0d       	add	r17, r0
    1c08:	11 24       	eor	r1, r1
    1c0a:	0a 51       	subi	r16, 0x1A	; 26
    1c0c:	1a 4f       	sbci	r17, 0xFA	; 250
    1c0e:	84 e0       	ldi	r24, 0x04	; 4
    1c10:	f8 01       	movw	r30, r16
    1c12:	80 83       	st	Z, r24
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1c14:	87 2f       	mov	r24, r23
    1c16:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.		
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	f8 01       	movw	r30, r16
    1c1e:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1c20:	ff be       	out	0x3f, r15	; 63
	}
}
    1c22:	1f 91       	pop	r17
    1c24:	0f 91       	pop	r16
    1c26:	ff 90       	pop	r15
    1c28:	08 95       	ret

00001c2a <StartOverdub>:

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    1c2a:	ff 92       	push	r15
    1c2c:	0f 93       	push	r16
    1c2e:	1f 93       	push	r17
    1c30:	78 2f       	mov	r23, r24
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    1c32:	28 2f       	mov	r18, r24
    1c34:	30 e0       	ldi	r19, 0x00	; 0
    1c36:	83 e2       	ldi	r24, 0x23	; 35
    1c38:	90 e0       	ldi	r25, 0x00	; 0
    1c3a:	28 9f       	mul	r18, r24
    1c3c:	f0 01       	movw	r30, r0
    1c3e:	29 9f       	mul	r18, r25
    1c40:	f0 0d       	add	r31, r0
    1c42:	38 9f       	mul	r19, r24
    1c44:	f0 0d       	add	r31, r0
    1c46:	11 24       	eor	r1, r1
    1c48:	ea 51       	subi	r30, 0x1A	; 26
    1c4a:	fa 4f       	sbci	r31, 0xFA	; 250
    1c4c:	85 81       	ldd	r24, Z+5	; 0x05
    1c4e:	88 23       	and	r24, r24
    1c50:	29 f0       	breq	.+10     	; 0x1c5c <StartOverdub+0x32>
    1c52:	80 91 b5 05 	lds	r24, 0x05B5
    1c56:	81 50       	subi	r24, 0x01	; 1
    1c58:	82 30       	cpi	r24, 0x02	; 2
    1c5a:	28 f1       	brcs	.+74     	; 0x1ca6 <StartOverdub+0x7c>
	{
		sreg=SREG;	// Store global interrupt state.
    1c5c:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    1c5e:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    1c60:	83 e2       	ldi	r24, 0x23	; 35
    1c62:	90 e0       	ldi	r25, 0x00	; 0
    1c64:	28 9f       	mul	r18, r24
    1c66:	80 01       	movw	r16, r0
    1c68:	29 9f       	mul	r18, r25
    1c6a:	10 0d       	add	r17, r0
    1c6c:	38 9f       	mul	r19, r24
    1c6e:	10 0d       	add	r17, r0
    1c70:	11 24       	eor	r1, r1
    1c72:	0a 51       	subi	r16, 0x1A	; 26
    1c74:	1a 4f       	sbci	r17, 0xFA	; 250
    1c76:	85 e0       	ldi	r24, 0x05	; 5
    1c78:	f8 01       	movw	r30, r16
    1c7a:	80 83       	st	Z, r24
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1c7c:	87 2f       	mov	r24, r23
    1c7e:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.		
    1c82:	81 e0       	ldi	r24, 0x01	; 1
    1c84:	f8 01       	movw	r30, r16
    1c86:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    1c88:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1c8a:	80 91 7a 00 	lds	r24, 0x007A
    1c8e:	86 fd       	sbrc	r24, 6
    1c90:	0a c0       	rjmp	.+20     	; 0x1ca6 <StartOverdub+0x7c>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1c92:	80 91 79 00 	lds	r24, 0x0079
    1c96:	80 58       	subi	r24, 0x80	; 128
    1c98:	80 93 58 02 	sts	0x0258, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1c9c:	80 91 7a 00 	lds	r24, 0x007A
    1ca0:	80 64       	ori	r24, 0x40	; 64
    1ca2:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    1ca6:	1f 91       	pop	r17
    1ca8:	0f 91       	pop	r16
    1caa:	ff 90       	pop	r15
    1cac:	08 95       	ret

00001cae <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
// Thu Nov 24 19:40:21 CST 2011
// OK to do realtime even when banks are locked since we don't use the RAM
{
    1cae:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    1cb0:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    1cb2:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    1cb4:	e8 2f       	mov	r30, r24
    1cb6:	f0 e0       	ldi	r31, 0x00	; 0
    1cb8:	23 e2       	ldi	r18, 0x23	; 35
    1cba:	30 e0       	ldi	r19, 0x00	; 0
    1cbc:	df 01       	movw	r26, r30
    1cbe:	a2 9f       	mul	r26, r18
    1cc0:	f0 01       	movw	r30, r0
    1cc2:	a3 9f       	mul	r26, r19
    1cc4:	f0 0d       	add	r31, r0
    1cc6:	b2 9f       	mul	r27, r18
    1cc8:	f0 0d       	add	r31, r0
    1cca:	11 24       	eor	r1, r1
    1ccc:	ea 51       	subi	r30, 0x1A	; 26
    1cce:	fa 4f       	sbci	r31, 0xFA	; 250
    1cd0:	92 e0       	ldi	r25, 0x02	; 2
    1cd2:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1cd4:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    1cd8:	1f bf       	out	0x3f, r17	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1cda:	80 91 7a 00 	lds	r24, 0x007A
    1cde:	86 fd       	sbrc	r24, 6
    1ce0:	0a c0       	rjmp	.+20     	; 0x1cf6 <StartRealtime+0x48>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1ce2:	80 91 79 00 	lds	r24, 0x0079
    1ce6:	80 58       	subi	r24, 0x80	; 128
    1ce8:	80 93 58 02 	sts	0x0258, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1cec:	80 91 7a 00 	lds	r24, 0x007A
    1cf0:	80 64       	ori	r24, 0x40	; 64
    1cf2:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1cf6:	1f 91       	pop	r17
    1cf8:	08 95       	ret

00001cfa <GetPlaybackRateFromNote>:
	B_NOTE,
};

static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
// Here we take a midi note number and turn it into the timer one compare match interrupt value.
{
    1cfa:	28 2f       	mov	r18, r24
    1cfc:	6c e0       	ldi	r22, 0x0C	; 12
    1cfe:	0e 94 79 2b 	call	0x56f2	; 0x56f2 <__udivmodqi4>
    1d02:	e9 2f       	mov	r30, r25
    1d04:	f0 e0       	ldi	r31, 0x00	; 0
    1d06:	ee 0f       	add	r30, r30
    1d08:	ff 1f       	adc	r31, r31
    1d0a:	ea 5f       	subi	r30, 0xFA	; 250
    1d0c:	fe 4f       	sbci	r31, 0xFE	; 254
    1d0e:	82 2f       	mov	r24, r18
    1d10:	0e 94 79 2b 	call	0x56f2	; 0x56f2 <__udivmodqi4>
    1d14:	20 81       	ld	r18, Z
    1d16:	31 81       	ldd	r19, Z+1	; 0x01
    1d18:	02 c0       	rjmp	.+4      	; 0x1d1e <GetPlaybackRateFromNote+0x24>
    1d1a:	36 95       	lsr	r19
    1d1c:	27 95       	ror	r18
    1d1e:	8a 95       	dec	r24
    1d20:	e2 f7       	brpl	.-8      	; 0x1d1a <GetPlaybackRateFromNote+0x20>
	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.

}
    1d22:	c9 01       	movw	r24, r18
    1d24:	08 95       	ret

00001d26 <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    1d26:	2f 92       	push	r2
    1d28:	3f 92       	push	r3
    1d2a:	4f 92       	push	r4
    1d2c:	5f 92       	push	r5
    1d2e:	6f 92       	push	r6
    1d30:	7f 92       	push	r7
    1d32:	8f 92       	push	r8
    1d34:	9f 92       	push	r9
    1d36:	af 92       	push	r10
    1d38:	bf 92       	push	r11
    1d3a:	cf 92       	push	r12
    1d3c:	df 92       	push	r13
    1d3e:	ef 92       	push	r14
    1d40:	ff 92       	push	r15
    1d42:	0f 93       	push	r16
    1d44:	1f 93       	push	r17
    1d46:	df 93       	push	r29
    1d48:	cf 93       	push	r28
    1d4a:	00 d0       	rcall	.+0      	; 0x1d4c <MakeNewGranularArray+0x26>
    1d4c:	0f 92       	push	r0
    1d4e:	cd b7       	in	r28, 0x3d	; 61
    1d50:	de b7       	in	r29, 0x3e	; 62
    1d52:	28 2e       	mov	r2, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    1d54:	62 30       	cpi	r22, 0x02	; 2
    1d56:	08 f4       	brcc	.+2      	; 0x1d5a <MakeNewGranularArray+0x34>
    1d58:	f2 c0       	rjmp	.+484    	; 0x1f3e <MakeNewGranularArray+0x218>
	{
		sreg=SREG;
    1d5a:	8f b7       	in	r24, 0x3f	; 63
    1d5c:	89 83       	std	Y+1, r24	; 0x01
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    1d5e:	f8 94       	cli
    1d60:	86 2e       	mov	r8, r22
    1d62:	90 e8       	ldi	r25, 0x80	; 128
    1d64:	96 17       	cp	r25, r22
    1d66:	10 f4       	brcc	.+4      	; 0x1d6c <MakeNewGranularArray+0x46>
    1d68:	30 e8       	ldi	r19, 0x80	; 128
    1d6a:	83 2e       	mov	r8, r19
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    1d6c:	62 2c       	mov	r6, r2
    1d6e:	77 24       	eor	r7, r7
    1d70:	d3 01       	movw	r26, r6
    1d72:	b6 95       	lsr	r27
    1d74:	ba 2f       	mov	r27, r26
    1d76:	aa 27       	eor	r26, r26
    1d78:	b7 95       	ror	r27
    1d7a:	a7 95       	ror	r26
    1d7c:	a8 5a       	subi	r26, 0xA8	; 168
    1d7e:	be 4f       	sbci	r27, 0xFE	; 254
    1d80:	bb 83       	std	Y+3, r27	; 0x03
    1d82:	aa 83       	std	Y+2, r26	; 0x02
    1d84:	fd 01       	movw	r30, r26
    1d86:	80 e0       	ldi	r24, 0x00	; 0
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    1d88:	81 93       	st	Z+, r24
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    1d8a:	8f 5f       	subi	r24, 0xFF	; 255
    1d8c:	88 15       	cp	r24, r8
    1d8e:	e0 f3       	brcs	.-8      	; 0x1d88 <MakeNewGranularArray+0x62>
    1d90:	e0 90 00 01 	lds	r14, 0x0100
    1d94:	f0 90 01 01 	lds	r15, 0x0101
    1d98:	00 91 02 01 	lds	r16, 0x0102
    1d9c:	10 91 03 01 	lds	r17, 0x0103
    1da0:	99 24       	eor	r9, r9
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1da2:	a8 2c       	mov	r10, r8
    1da4:	bb 24       	eor	r11, r11
    1da6:	cc 24       	eor	r12, r12
    1da8:	dd 24       	eor	r13, r13
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1daa:	23 01       	movw	r4, r6
    1dac:	56 94       	lsr	r5
    1dae:	54 2c       	mov	r5, r4
    1db0:	44 24       	eor	r4, r4
    1db2:	57 94       	ror	r5
    1db4:	47 94       	ror	r4
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    1db6:	ea 81       	ldd	r30, Y+2	; 0x02
    1db8:	fb 81       	ldd	r31, Y+3	; 0x03
    1dba:	30 80       	ld	r3, Z
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1dbc:	ee 0c       	add	r14, r14
    1dbe:	ff 1c       	adc	r15, r15
    1dc0:	00 1f       	adc	r16, r16
    1dc2:	11 1f       	adc	r17, r17
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1dc4:	17 ff       	sbrs	r17, 7
    1dc6:	08 c0       	rjmp	.+16     	; 0x1dd8 <MakeNewGranularArray+0xb2>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1dc8:	85 eb       	ldi	r24, 0xB5	; 181
    1dca:	95 e9       	ldi	r25, 0x95	; 149
    1dcc:	aa ea       	ldi	r26, 0xAA	; 170
    1dce:	b0 e2       	ldi	r27, 0x20	; 32
    1dd0:	e8 26       	eor	r14, r24
    1dd2:	f9 26       	eor	r15, r25
    1dd4:	0a 27       	eor	r16, r26
    1dd6:	1b 27       	eor	r17, r27

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    1dd8:	c8 01       	movw	r24, r16
    1dda:	b7 01       	movw	r22, r14
    1ddc:	a6 01       	movw	r20, r12
    1dde:	95 01       	movw	r18, r10
    1de0:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1de4:	f2 01       	movw	r30, r4
    1de6:	e6 0f       	add	r30, r22
    1de8:	f1 1d       	adc	r31, r1
    1dea:	e8 5a       	subi	r30, 0xA8	; 168
    1dec:	fe 4f       	sbci	r31, 0xFE	; 254
    1dee:	80 81       	ld	r24, Z
    1df0:	aa 81       	ldd	r26, Y+2	; 0x02
    1df2:	bb 81       	ldd	r27, Y+3	; 0x03
    1df4:	8d 93       	st	X+, r24
    1df6:	bb 83       	std	Y+3, r27	; 0x03
    1df8:	aa 83       	std	Y+2, r26	; 0x02
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1dfa:	30 82       	st	Z, r3
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    1dfc:	93 94       	inc	r9
    1dfe:	98 14       	cp	r9, r8
    1e00:	d0 f2       	brcs	.-76     	; 0x1db6 <MakeNewGranularArray+0x90>
    1e02:	e0 92 00 01 	sts	0x0100, r14
    1e06:	f0 92 01 01 	sts	0x0101, r15
    1e0a:	00 93 02 01 	sts	0x0102, r16
    1e0e:	10 93 03 01 	sts	0x0103, r17
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1e12:	22 20       	and	r2, r2
    1e14:	b9 f4       	brne	.+46     	; 0x1e44 <MakeNewGranularArray+0x11e>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1e16:	60 91 f2 05 	lds	r22, 0x05F2
    1e1a:	70 91 f3 05 	lds	r23, 0x05F3
    1e1e:	80 91 f4 05 	lds	r24, 0x05F4
    1e22:	90 91 f5 05 	lds	r25, 0x05F5
    1e26:	a6 01       	movw	r20, r12
    1e28:	95 01       	movw	r18, r10
    1e2a:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
    1e2e:	c9 01       	movw	r24, r18
    1e30:	da 01       	movw	r26, r20
    1e32:	80 93 48 01 	sts	0x0148, r24
    1e36:	90 93 49 01 	sts	0x0149, r25
    1e3a:	a0 93 4a 01 	sts	0x014A, r26
    1e3e:	b0 93 4b 01 	sts	0x014B, r27
    1e42:	1e c0       	rjmp	.+60     	; 0x1e80 <MakeNewGranularArray+0x15a>
		}	
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;		
    1e44:	20 91 15 06 	lds	r18, 0x0615
    1e48:	30 91 16 06 	lds	r19, 0x0616
    1e4c:	40 91 17 06 	lds	r20, 0x0617
    1e50:	50 91 18 06 	lds	r21, 0x0618
    1e54:	6f ef       	ldi	r22, 0xFF	; 255
    1e56:	7f ef       	ldi	r23, 0xFF	; 255
    1e58:	87 e0       	ldi	r24, 0x07	; 7
    1e5a:	90 e0       	ldi	r25, 0x00	; 0
    1e5c:	62 1b       	sub	r22, r18
    1e5e:	73 0b       	sbc	r23, r19
    1e60:	84 0b       	sbc	r24, r20
    1e62:	95 0b       	sbc	r25, r21
    1e64:	a6 01       	movw	r20, r12
    1e66:	95 01       	movw	r18, r10
    1e68:	0e 94 98 2b 	call	0x5730	; 0x5730 <__udivmodsi4>
    1e6c:	c9 01       	movw	r24, r18
    1e6e:	da 01       	movw	r26, r20
    1e70:	80 93 4c 01 	sts	0x014C, r24
    1e74:	90 93 4d 01 	sts	0x014D, r25
    1e78:	a0 93 4e 01 	sts	0x014E, r26
    1e7c:	b0 93 4f 01 	sts	0x014F, r27
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1e80:	83 e2       	ldi	r24, 0x23	; 35
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	68 9e       	mul	r6, r24
    1e86:	f0 01       	movw	r30, r0
    1e88:	69 9e       	mul	r6, r25
    1e8a:	f0 0d       	add	r31, r0
    1e8c:	78 9e       	mul	r7, r24
    1e8e:	f0 0d       	add	r31, r0
    1e90:	11 24       	eor	r1, r1
    1e92:	ea 51       	subi	r30, 0x1A	; 26
    1e94:	fa 4f       	sbci	r31, 0xFA	; 250
    1e96:	86 82       	std	Z+6, r8	; 0x06
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1e98:	f3 01       	movw	r30, r6
    1e9a:	ea 5b       	subi	r30, 0xBA	; 186
    1e9c:	fe 4f       	sbci	r31, 0xFE	; 254
    1e9e:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1ea0:	f3 01       	movw	r30, r6
    1ea2:	ee 0f       	add	r30, r30
    1ea4:	ff 1f       	adc	r31, r31
    1ea6:	ee 0f       	add	r30, r30
    1ea8:	ff 1f       	adc	r31, r31
    1eaa:	df 01       	movw	r26, r30
    1eac:	a8 5b       	subi	r26, 0xB8	; 184
    1eae:	be 4f       	sbci	r27, 0xFE	; 254
    1eb0:	8d 91       	ld	r24, X+
    1eb2:	9d 91       	ld	r25, X+
    1eb4:	0d 90       	ld	r0, X+
    1eb6:	bc 91       	ld	r27, X
    1eb8:	a0 2d       	mov	r26, r0
    1eba:	e0 5b       	subi	r30, 0xB0	; 176
    1ebc:	fe 4f       	sbci	r31, 0xFE	; 254
    1ebe:	80 83       	st	Z, r24
    1ec0:	91 83       	std	Z+1, r25	; 0x01
    1ec2:	a2 83       	std	Z+2, r26	; 0x02
    1ec4:	b3 83       	std	Z+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    1ec6:	22 20       	and	r2, r2
    1ec8:	c1 f4       	brne	.+48     	; 0x1efa <MakeNewGranularArray+0x1d4>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    1eca:	20 91 48 01 	lds	r18, 0x0148
    1ece:	30 91 49 01 	lds	r19, 0x0149
    1ed2:	40 91 4a 01 	lds	r20, 0x014A
    1ed6:	50 91 4b 01 	lds	r21, 0x014B
    1eda:	60 91 58 01 	lds	r22, 0x0158
    1ede:	70 e0       	ldi	r23, 0x00	; 0
    1ee0:	80 e0       	ldi	r24, 0x00	; 0
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    1ee8:	60 93 05 06 	sts	0x0605, r22
    1eec:	70 93 06 06 	sts	0x0606, r23
    1ef0:	80 93 07 06 	sts	0x0607, r24
    1ef4:	90 93 08 06 	sts	0x0608, r25
    1ef8:	1f c0       	rjmp	.+62     	; 0x1f38 <MakeNewGranularArray+0x212>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));								
    1efa:	20 91 4c 01 	lds	r18, 0x014C
    1efe:	30 91 4d 01 	lds	r19, 0x014D
    1f02:	40 91 4e 01 	lds	r20, 0x014E
    1f06:	50 91 4f 01 	lds	r21, 0x014F
    1f0a:	60 91 d8 01 	lds	r22, 0x01D8
    1f0e:	70 e0       	ldi	r23, 0x00	; 0
    1f10:	80 e0       	ldi	r24, 0x00	; 0
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    1f18:	2f ef       	ldi	r18, 0xFF	; 255
    1f1a:	3f ef       	ldi	r19, 0xFF	; 255
    1f1c:	47 e0       	ldi	r20, 0x07	; 7
    1f1e:	50 e0       	ldi	r21, 0x00	; 0
    1f20:	26 1b       	sub	r18, r22
    1f22:	37 0b       	sbc	r19, r23
    1f24:	48 0b       	sbc	r20, r24
    1f26:	59 0b       	sbc	r21, r25
    1f28:	20 93 28 06 	sts	0x0628, r18
    1f2c:	30 93 29 06 	sts	0x0629, r19
    1f30:	40 93 2a 06 	sts	0x062A, r20
    1f34:	50 93 2b 06 	sts	0x062B, r21
		}

		SREG=sreg;		// Restore interrupts.
    1f38:	b9 81       	ldd	r27, Y+1	; 0x01
    1f3a:	bf bf       	out	0x3f, r27	; 63
    1f3c:	0e c0       	rjmp	.+28     	; 0x1f5a <MakeNewGranularArray+0x234>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.	
    1f3e:	28 2f       	mov	r18, r24
    1f40:	30 e0       	ldi	r19, 0x00	; 0
    1f42:	83 e2       	ldi	r24, 0x23	; 35
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	28 9f       	mul	r18, r24
    1f48:	f0 01       	movw	r30, r0
    1f4a:	29 9f       	mul	r18, r25
    1f4c:	f0 0d       	add	r31, r0
    1f4e:	38 9f       	mul	r19, r24
    1f50:	f0 0d       	add	r31, r0
    1f52:	11 24       	eor	r1, r1
    1f54:	ea 51       	subi	r30, 0x1A	; 26
    1f56:	fa 4f       	sbci	r31, 0xFA	; 250
    1f58:	16 82       	std	Z+6, r1	; 0x06
	}
}
    1f5a:	0f 90       	pop	r0
    1f5c:	0f 90       	pop	r0
    1f5e:	0f 90       	pop	r0
    1f60:	cf 91       	pop	r28
    1f62:	df 91       	pop	r29
    1f64:	1f 91       	pop	r17
    1f66:	0f 91       	pop	r16
    1f68:	ff 90       	pop	r15
    1f6a:	ef 90       	pop	r14
    1f6c:	df 90       	pop	r13
    1f6e:	cf 90       	pop	r12
    1f70:	bf 90       	pop	r11
    1f72:	af 90       	pop	r10
    1f74:	9f 90       	pop	r9
    1f76:	8f 90       	pop	r8
    1f78:	7f 90       	pop	r7
    1f7a:	6f 90       	pop	r6
    1f7c:	5f 90       	pop	r5
    1f7e:	4f 90       	pop	r4
    1f80:	3f 90       	pop	r3
    1f82:	2f 90       	pop	r2
    1f84:	08 95       	ret

00001f86 <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    1f86:	2f 92       	push	r2
    1f88:	3f 92       	push	r3
    1f8a:	4f 92       	push	r4
    1f8c:	5f 92       	push	r5
    1f8e:	6f 92       	push	r6
    1f90:	7f 92       	push	r7
    1f92:	8f 92       	push	r8
    1f94:	9f 92       	push	r9
    1f96:	af 92       	push	r10
    1f98:	bf 92       	push	r11
    1f9a:	cf 92       	push	r12
    1f9c:	df 92       	push	r13
    1f9e:	ef 92       	push	r14
    1fa0:	ff 92       	push	r15
    1fa2:	0f 93       	push	r16
    1fa4:	1f 93       	push	r17
    1fa6:	df 93       	push	r29
    1fa8:	cf 93       	push	r28
    1faa:	0f 92       	push	r0
    1fac:	cd b7       	in	r28, 0x3d	; 61
    1fae:	de b7       	in	r29, 0x3e	; 62
	unsigned char 
		sreg;
	unsigned long
		chunkSize;
		
	sreg=SREG;
    1fb0:	9f b7       	in	r25, 0x3f	; 63
    1fb2:	99 83       	std	Y+1, r25	; 0x01
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1fb4:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1fb6:	88 23       	and	r24, r24
    1fb8:	09 f0       	breq	.+2      	; 0x1fbc <UpdateAdjustedSampleAddresses+0x36>
    1fba:	f4 c1       	rjmp	.+1000   	; 0x23a4 <UpdateAdjustedSampleAddresses+0x41e>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1fbc:	a0 90 f2 05 	lds	r10, 0x05F2
    1fc0:	b0 90 f3 05 	lds	r11, 0x05F3
    1fc4:	c0 90 f4 05 	lds	r12, 0x05F4
    1fc8:	d0 90 f5 05 	lds	r13, 0x05F5
    1fcc:	73 e0       	ldi	r23, 0x03	; 3
    1fce:	aa 0c       	add	r10, r10
    1fd0:	bb 1c       	adc	r11, r11
    1fd2:	cc 1c       	adc	r12, r12
    1fd4:	dd 1c       	adc	r13, r13
    1fd6:	7a 95       	dec	r23
    1fd8:	d1 f7       	brne	.-12     	; 0x1fce <UpdateAdjustedSampleAddresses+0x48>
    1fda:	ab 2c       	mov	r10, r11
    1fdc:	bc 2c       	mov	r11, r12
    1fde:	cd 2c       	mov	r12, r13
    1fe0:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1fe2:	60 91 02 06 	lds	r22, 0x0602
    1fe6:	20 91 04 06 	lds	r18, 0x0604
    1fea:	70 e0       	ldi	r23, 0x00	; 0
    1fec:	62 0f       	add	r22, r18
    1fee:	71 1d       	adc	r23, r1
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	a6 01       	movw	r20, r12
    1ff6:	95 01       	movw	r18, r10
    1ff8:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    1ffc:	53 e0       	ldi	r21, 0x03	; 3
    1ffe:	96 95       	lsr	r25
    2000:	87 95       	ror	r24
    2002:	77 95       	ror	r23
    2004:	67 95       	ror	r22
    2006:	5a 95       	dec	r21
    2008:	d1 f7       	brne	.-12     	; 0x1ffe <UpdateAdjustedSampleAddresses+0x78>
    200a:	60 93 fe 05 	sts	0x05FE, r22
    200e:	70 93 ff 05 	sts	0x05FF, r23
    2012:	80 93 00 06 	sts	0x0600, r24
    2016:	90 93 01 06 	sts	0x0601, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    201a:	20 90 f2 05 	lds	r2, 0x05F2
    201e:	30 90 f3 05 	lds	r3, 0x05F3
    2022:	40 90 f4 05 	lds	r4, 0x05F4
    2026:	50 90 f5 05 	lds	r5, 0x05F5
    202a:	60 90 03 06 	lds	r6, 0x0603
    202e:	20 91 04 06 	lds	r18, 0x0604
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	40 e0       	ldi	r20, 0x00	; 0
    2036:	50 e0       	ldi	r21, 0x00	; 0
    2038:	c6 01       	movw	r24, r12
    203a:	b5 01       	movw	r22, r10
    203c:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    2040:	7b 01       	movw	r14, r22
    2042:	8c 01       	movw	r16, r24
    2044:	43 e0       	ldi	r20, 0x03	; 3
    2046:	16 95       	lsr	r17
    2048:	07 95       	ror	r16
    204a:	f7 94       	ror	r15
    204c:	e7 94       	ror	r14
    204e:	4a 95       	dec	r20
    2050:	d1 f7       	brne	.-12     	; 0x2046 <UpdateAdjustedSampleAddresses+0xc0>
    2052:	e2 0c       	add	r14, r2
    2054:	f3 1c       	adc	r15, r3
    2056:	04 1d       	adc	r16, r4
    2058:	15 1d       	adc	r17, r5
    205a:	77 24       	eor	r7, r7
    205c:	88 24       	eor	r8, r8
    205e:	99 24       	eor	r9, r9
    2060:	c6 01       	movw	r24, r12
    2062:	b5 01       	movw	r22, r10
    2064:	a4 01       	movw	r20, r8
    2066:	93 01       	movw	r18, r6
    2068:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    206c:	33 e0       	ldi	r19, 0x03	; 3
    206e:	96 95       	lsr	r25
    2070:	87 95       	ror	r24
    2072:	77 95       	ror	r23
    2074:	67 95       	ror	r22
    2076:	3a 95       	dec	r19
    2078:	d1 f7       	brne	.-12     	; 0x206e <UpdateAdjustedSampleAddresses+0xe8>
    207a:	e6 1a       	sub	r14, r22
    207c:	f7 0a       	sbc	r15, r23
    207e:	08 0b       	sbc	r16, r24
    2080:	19 0b       	sbc	r17, r25
    2082:	e0 92 fa 05 	sts	0x05FA, r14
    2086:	f0 92 fb 05 	sts	0x05FB, r15
    208a:	00 93 fc 05 	sts	0x05FC, r16
    208e:	10 93 fd 05 	sts	0x05FD, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    2092:	20 91 fe 05 	lds	r18, 0x05FE
    2096:	30 91 ff 05 	lds	r19, 0x05FF
    209a:	40 91 00 06 	lds	r20, 0x0600
    209e:	50 91 01 06 	lds	r21, 0x0601
    20a2:	80 91 fa 05 	lds	r24, 0x05FA
    20a6:	90 91 fb 05 	lds	r25, 0x05FB
    20aa:	a0 91 fc 05 	lds	r26, 0x05FC
    20ae:	b0 91 fd 05 	lds	r27, 0x05FD
    20b2:	82 17       	cp	r24, r18
    20b4:	93 07       	cpc	r25, r19
    20b6:	a4 07       	cpc	r26, r20
    20b8:	b5 07       	cpc	r27, r21
    20ba:	50 f5       	brcc	.+84     	; 0x2110 <UpdateAdjustedSampleAddresses+0x18a>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    20bc:	80 91 e9 05 	lds	r24, 0x05E9
    20c0:	81 30       	cpi	r24, 0x01	; 1
    20c2:	19 f4       	brne	.+6      	; 0x20ca <UpdateAdjustedSampleAddresses+0x144>
			{
				bankStates[BANK_0].sampleDirection=true;
    20c4:	80 93 ea 05 	sts	0x05EA, r24
    20c8:	02 c0       	rjmp	.+4      	; 0x20ce <UpdateAdjustedSampleAddresses+0x148>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    20ca:	10 92 ea 05 	sts	0x05EA, r1
			}			

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    20ce:	20 91 fe 05 	lds	r18, 0x05FE
    20d2:	30 91 ff 05 	lds	r19, 0x05FF
    20d6:	40 91 00 06 	lds	r20, 0x0600
    20da:	50 91 01 06 	lds	r21, 0x0601
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    20de:	80 91 fa 05 	lds	r24, 0x05FA
    20e2:	90 91 fb 05 	lds	r25, 0x05FB
    20e6:	a0 91 fc 05 	lds	r26, 0x05FC
    20ea:	b0 91 fd 05 	lds	r27, 0x05FD
    20ee:	80 93 fe 05 	sts	0x05FE, r24
    20f2:	90 93 ff 05 	sts	0x05FF, r25
    20f6:	a0 93 00 06 	sts	0x0600, r26
    20fa:	b0 93 01 06 	sts	0x0601, r27
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    20fe:	20 93 fa 05 	sts	0x05FA, r18
    2102:	30 93 fb 05 	sts	0x05FB, r19
    2106:	40 93 fc 05 	sts	0x05FC, r20
    210a:	50 93 fd 05 	sts	0x05FD, r21
    210e:	0a c0       	rjmp	.+20     	; 0x2124 <UpdateAdjustedSampleAddresses+0x19e>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    2110:	80 91 e9 05 	lds	r24, 0x05E9
    2114:	81 30       	cpi	r24, 0x01	; 1
    2116:	19 f4       	brne	.+6      	; 0x211e <UpdateAdjustedSampleAddresses+0x198>
			{
				bankStates[BANK_0].sampleDirection=false;
    2118:	10 92 ea 05 	sts	0x05EA, r1
    211c:	03 c0       	rjmp	.+6      	; 0x2124 <UpdateAdjustedSampleAddresses+0x19e>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	80 93 ea 05 	sts	0x05EA, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    2124:	20 91 fe 05 	lds	r18, 0x05FE
    2128:	30 91 ff 05 	lds	r19, 0x05FF
    212c:	40 91 00 06 	lds	r20, 0x0600
    2130:	50 91 01 06 	lds	r21, 0x0601
    2134:	80 91 f2 05 	lds	r24, 0x05F2
    2138:	90 91 f3 05 	lds	r25, 0x05F3
    213c:	a0 91 f4 05 	lds	r26, 0x05F4
    2140:	b0 91 f5 05 	lds	r27, 0x05F5
    2144:	82 17       	cp	r24, r18
    2146:	93 07       	cpc	r25, r19
    2148:	a4 07       	cpc	r26, r20
    214a:	b5 07       	cpc	r27, r21
    214c:	e0 f4       	brcc	.+56     	; 0x2186 <UpdateAdjustedSampleAddresses+0x200>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    214e:	80 91 fe 05 	lds	r24, 0x05FE
    2152:	90 91 ff 05 	lds	r25, 0x05FF
    2156:	a0 91 00 06 	lds	r26, 0x0600
    215a:	b0 91 01 06 	lds	r27, 0x0601
    215e:	20 91 f2 05 	lds	r18, 0x05F2
    2162:	30 91 f3 05 	lds	r19, 0x05F3
    2166:	40 91 f4 05 	lds	r20, 0x05F4
    216a:	50 91 f5 05 	lds	r21, 0x05F5
    216e:	82 1b       	sub	r24, r18
    2170:	93 0b       	sbc	r25, r19
    2172:	a4 0b       	sbc	r26, r20
    2174:	b5 0b       	sbc	r27, r21
    2176:	80 93 fe 05 	sts	0x05FE, r24
    217a:	90 93 ff 05 	sts	0x05FF, r25
    217e:	a0 93 00 06 	sts	0x0600, r26
    2182:	b0 93 01 06 	sts	0x0601, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    2186:	20 91 fa 05 	lds	r18, 0x05FA
    218a:	30 91 fb 05 	lds	r19, 0x05FB
    218e:	40 91 fc 05 	lds	r20, 0x05FC
    2192:	50 91 fd 05 	lds	r21, 0x05FD
    2196:	80 91 f2 05 	lds	r24, 0x05F2
    219a:	90 91 f3 05 	lds	r25, 0x05F3
    219e:	a0 91 f4 05 	lds	r26, 0x05F4
    21a2:	b0 91 f5 05 	lds	r27, 0x05F5
    21a6:	82 17       	cp	r24, r18
    21a8:	93 07       	cpc	r25, r19
    21aa:	a4 07       	cpc	r26, r20
    21ac:	b5 07       	cpc	r27, r21
    21ae:	08 f0       	brcs	.+2      	; 0x21b2 <UpdateAdjustedSampleAddresses+0x22c>
    21b0:	44 c0       	rjmp	.+136    	; 0x223a <UpdateAdjustedSampleAddresses+0x2b4>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    21b2:	80 91 fa 05 	lds	r24, 0x05FA
    21b6:	90 91 fb 05 	lds	r25, 0x05FB
    21ba:	a0 91 fc 05 	lds	r26, 0x05FC
    21be:	b0 91 fd 05 	lds	r27, 0x05FD
    21c2:	20 91 f2 05 	lds	r18, 0x05F2
    21c6:	30 91 f3 05 	lds	r19, 0x05F3
    21ca:	40 91 f4 05 	lds	r20, 0x05F4
    21ce:	50 91 f5 05 	lds	r21, 0x05F5
    21d2:	82 1b       	sub	r24, r18
    21d4:	93 0b       	sbc	r25, r19
    21d6:	a4 0b       	sbc	r26, r20
    21d8:	b5 0b       	sbc	r27, r21
    21da:	80 93 fa 05 	sts	0x05FA, r24
    21de:	90 93 fb 05 	sts	0x05FB, r25
    21e2:	a0 93 fc 05 	sts	0x05FC, r26
    21e6:	b0 93 fd 05 	sts	0x05FD, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    21ea:	20 91 fa 05 	lds	r18, 0x05FA
    21ee:	30 91 fb 05 	lds	r19, 0x05FB
    21f2:	40 91 fc 05 	lds	r20, 0x05FC
    21f6:	50 91 fd 05 	lds	r21, 0x05FD
    21fa:	80 91 fe 05 	lds	r24, 0x05FE
    21fe:	90 91 ff 05 	lds	r25, 0x05FF
    2202:	a0 91 00 06 	lds	r26, 0x0600
    2206:	b0 91 01 06 	lds	r27, 0x0601
    220a:	28 17       	cp	r18, r24
    220c:	39 07       	cpc	r19, r25
    220e:	4a 07       	cpc	r20, r26
    2210:	5b 07       	cpc	r21, r27
    2212:	99 f4       	brne	.+38     	; 0x223a <UpdateAdjustedSampleAddresses+0x2b4>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    2214:	80 91 fa 05 	lds	r24, 0x05FA
    2218:	90 91 fb 05 	lds	r25, 0x05FB
    221c:	a0 91 fc 05 	lds	r26, 0x05FC
    2220:	b0 91 fd 05 	lds	r27, 0x05FD
    2224:	01 97       	sbiw	r24, 0x01	; 1
    2226:	a1 09       	sbc	r26, r1
    2228:	b1 09       	sbc	r27, r1
    222a:	80 93 fa 05 	sts	0x05FA, r24
    222e:	90 93 fb 05 	sts	0x05FB, r25
    2232:	a0 93 fc 05 	sts	0x05FC, r26
    2236:	b0 93 fd 05 	sts	0x05FD, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    223a:	20 91 fe 05 	lds	r18, 0x05FE
    223e:	30 91 ff 05 	lds	r19, 0x05FF
    2242:	40 91 00 06 	lds	r20, 0x0600
    2246:	50 91 01 06 	lds	r21, 0x0601
    224a:	80 91 fa 05 	lds	r24, 0x05FA
    224e:	90 91 fb 05 	lds	r25, 0x05FB
    2252:	a0 91 fc 05 	lds	r26, 0x05FC
    2256:	b0 91 fd 05 	lds	r27, 0x05FD
    225a:	82 17       	cp	r24, r18
    225c:	93 07       	cpc	r25, r19
    225e:	a4 07       	cpc	r26, r20
    2260:	b5 07       	cpc	r27, r21
    2262:	08 f0       	brcs	.+2      	; 0x2266 <UpdateAdjustedSampleAddresses+0x2e0>
    2264:	5a c0       	rjmp	.+180    	; 0x231a <UpdateAdjustedSampleAddresses+0x394>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    2266:	20 91 05 06 	lds	r18, 0x0605
    226a:	30 91 06 06 	lds	r19, 0x0606
    226e:	40 91 07 06 	lds	r20, 0x0607
    2272:	50 91 08 06 	lds	r21, 0x0608
    2276:	80 91 fe 05 	lds	r24, 0x05FE
    227a:	90 91 ff 05 	lds	r25, 0x05FF
    227e:	a0 91 00 06 	lds	r26, 0x0600
    2282:	b0 91 01 06 	lds	r27, 0x0601
    2286:	28 17       	cp	r18, r24
    2288:	39 07       	cpc	r19, r25
    228a:	4a 07       	cpc	r20, r26
    228c:	5b 07       	cpc	r21, r27
    228e:	08 f0       	brcs	.+2      	; 0x2292 <UpdateAdjustedSampleAddresses+0x30c>
    2290:	94 c2       	rjmp	.+1320   	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
    2292:	20 91 05 06 	lds	r18, 0x0605
    2296:	30 91 06 06 	lds	r19, 0x0606
    229a:	40 91 07 06 	lds	r20, 0x0607
    229e:	50 91 08 06 	lds	r21, 0x0608
    22a2:	80 91 fa 05 	lds	r24, 0x05FA
    22a6:	90 91 fb 05 	lds	r25, 0x05FB
    22aa:	a0 91 fc 05 	lds	r26, 0x05FC
    22ae:	b0 91 fd 05 	lds	r27, 0x05FD
    22b2:	82 17       	cp	r24, r18
    22b4:	93 07       	cpc	r25, r19
    22b6:	a4 07       	cpc	r26, r20
    22b8:	b5 07       	cpc	r27, r21
    22ba:	08 f0       	brcs	.+2      	; 0x22be <UpdateAdjustedSampleAddresses+0x338>
    22bc:	7e c2       	rjmp	.+1276   	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?	
    22be:	20 91 fe 05 	lds	r18, 0x05FE
    22c2:	30 91 ff 05 	lds	r19, 0x05FF
    22c6:	40 91 00 06 	lds	r20, 0x0600
    22ca:	50 91 01 06 	lds	r21, 0x0601
    22ce:	a0 90 05 06 	lds	r10, 0x0605
    22d2:	b0 90 06 06 	lds	r11, 0x0606
    22d6:	c0 90 07 06 	lds	r12, 0x0607
    22da:	d0 90 08 06 	lds	r13, 0x0608
    22de:	80 91 05 06 	lds	r24, 0x0605
    22e2:	90 91 06 06 	lds	r25, 0x0606
    22e6:	a0 91 07 06 	lds	r26, 0x0607
    22ea:	b0 91 08 06 	lds	r27, 0x0608
    22ee:	e0 90 fa 05 	lds	r14, 0x05FA
    22f2:	f0 90 fb 05 	lds	r15, 0x05FB
    22f6:	00 91 fc 05 	lds	r16, 0x05FC
    22fa:	10 91 fd 05 	lds	r17, 0x05FD
    22fe:	2a 19       	sub	r18, r10
    2300:	3b 09       	sbc	r19, r11
    2302:	4c 09       	sbc	r20, r12
    2304:	5d 09       	sbc	r21, r13
    2306:	8e 19       	sub	r24, r14
    2308:	9f 09       	sbc	r25, r15
    230a:	a0 0b       	sbc	r26, r16
    230c:	b1 0b       	sbc	r27, r17
    230e:	28 17       	cp	r18, r24
    2310:	39 07       	cpc	r19, r25
    2312:	4a 07       	cpc	r20, r26
    2314:	5b 07       	cpc	r21, r27
    2316:	a8 f1       	brcs	.+106    	; 0x2382 <UpdateAdjustedSampleAddresses+0x3fc>
    2318:	15 c0       	rjmp	.+42     	; 0x2344 <UpdateAdjustedSampleAddresses+0x3be>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    231a:	20 91 05 06 	lds	r18, 0x0605
    231e:	30 91 06 06 	lds	r19, 0x0606
    2322:	40 91 07 06 	lds	r20, 0x0607
    2326:	50 91 08 06 	lds	r21, 0x0608
    232a:	80 91 fe 05 	lds	r24, 0x05FE
    232e:	90 91 ff 05 	lds	r25, 0x05FF
    2332:	a0 91 00 06 	lds	r26, 0x0600
    2336:	b0 91 01 06 	lds	r27, 0x0601
    233a:	28 17       	cp	r18, r24
    233c:	39 07       	cpc	r19, r25
    233e:	4a 07       	cpc	r20, r26
    2340:	5b 07       	cpc	r21, r27
    2342:	48 f4       	brcc	.+18     	; 0x2356 <UpdateAdjustedSampleAddresses+0x3d0>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    2344:	80 91 fe 05 	lds	r24, 0x05FE
    2348:	90 91 ff 05 	lds	r25, 0x05FF
    234c:	a0 91 00 06 	lds	r26, 0x0600
    2350:	b0 91 01 06 	lds	r27, 0x0601
    2354:	1e c0       	rjmp	.+60     	; 0x2392 <UpdateAdjustedSampleAddresses+0x40c>
			}				
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    2356:	20 91 05 06 	lds	r18, 0x0605
    235a:	30 91 06 06 	lds	r19, 0x0606
    235e:	40 91 07 06 	lds	r20, 0x0607
    2362:	50 91 08 06 	lds	r21, 0x0608
    2366:	80 91 fa 05 	lds	r24, 0x05FA
    236a:	90 91 fb 05 	lds	r25, 0x05FB
    236e:	a0 91 fc 05 	lds	r26, 0x05FC
    2372:	b0 91 fd 05 	lds	r27, 0x05FD
    2376:	82 17       	cp	r24, r18
    2378:	93 07       	cpc	r25, r19
    237a:	a4 07       	cpc	r26, r20
    237c:	b5 07       	cpc	r27, r21
    237e:	08 f0       	brcs	.+2      	; 0x2382 <UpdateAdjustedSampleAddresses+0x3fc>
    2380:	1c c2       	rjmp	.+1080   	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    2382:	80 91 fa 05 	lds	r24, 0x05FA
    2386:	90 91 fb 05 	lds	r25, 0x05FB
    238a:	a0 91 fc 05 	lds	r26, 0x05FC
    238e:	b0 91 fd 05 	lds	r27, 0x05FD
    2392:	80 93 05 06 	sts	0x0605, r24
    2396:	90 93 06 06 	sts	0x0606, r25
    239a:	a0 93 07 06 	sts	0x0607, r26
    239e:	b0 93 08 06 	sts	0x0608, r27
    23a2:	0b c2       	rjmp	.+1046   	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
		}
	}	
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    23a4:	80 91 15 06 	lds	r24, 0x0615
    23a8:	90 91 16 06 	lds	r25, 0x0616
    23ac:	a0 91 17 06 	lds	r26, 0x0617
    23b0:	b0 91 18 06 	lds	r27, 0x0618
    23b4:	2f ef       	ldi	r18, 0xFF	; 255
    23b6:	e2 2e       	mov	r14, r18
    23b8:	2f ef       	ldi	r18, 0xFF	; 255
    23ba:	f2 2e       	mov	r15, r18
    23bc:	27 e0       	ldi	r18, 0x07	; 7
    23be:	02 2f       	mov	r16, r18
    23c0:	11 2d       	mov	r17, r1
    23c2:	57 01       	movw	r10, r14
    23c4:	68 01       	movw	r12, r16
    23c6:	a8 1a       	sub	r10, r24
    23c8:	b9 0a       	sbc	r11, r25
    23ca:	ca 0a       	sbc	r12, r26
    23cc:	db 0a       	sbc	r13, r27
    23ce:	a3 e0       	ldi	r26, 0x03	; 3
    23d0:	aa 0c       	add	r10, r10
    23d2:	bb 1c       	adc	r11, r11
    23d4:	cc 1c       	adc	r12, r12
    23d6:	dd 1c       	adc	r13, r13
    23d8:	aa 95       	dec	r26
    23da:	d1 f7       	brne	.-12     	; 0x23d0 <UpdateAdjustedSampleAddresses+0x44a>
    23dc:	ab 2c       	mov	r10, r11
    23de:	bc 2c       	mov	r11, r12
    23e0:	cd 2c       	mov	r12, r13
    23e2:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    23e4:	60 91 25 06 	lds	r22, 0x0625
    23e8:	20 91 27 06 	lds	r18, 0x0627
    23ec:	70 e0       	ldi	r23, 0x00	; 0
    23ee:	62 0f       	add	r22, r18
    23f0:	71 1d       	adc	r23, r1
    23f2:	80 e0       	ldi	r24, 0x00	; 0
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	a6 01       	movw	r20, r12
    23f8:	95 01       	movw	r18, r10
    23fa:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    23fe:	e3 e0       	ldi	r30, 0x03	; 3
    2400:	96 95       	lsr	r25
    2402:	87 95       	ror	r24
    2404:	77 95       	ror	r23
    2406:	67 95       	ror	r22
    2408:	ea 95       	dec	r30
    240a:	d1 f7       	brne	.-12     	; 0x2400 <UpdateAdjustedSampleAddresses+0x47a>
    240c:	e6 1a       	sub	r14, r22
    240e:	f7 0a       	sbc	r15, r23
    2410:	08 0b       	sbc	r16, r24
    2412:	19 0b       	sbc	r17, r25
    2414:	e0 92 21 06 	sts	0x0621, r14
    2418:	f0 92 22 06 	sts	0x0622, r15
    241c:	00 93 23 06 	sts	0x0623, r16
    2420:	10 93 24 06 	sts	0x0624, r17
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    2424:	20 90 15 06 	lds	r2, 0x0615
    2428:	30 90 16 06 	lds	r3, 0x0616
    242c:	40 90 17 06 	lds	r4, 0x0617
    2430:	50 90 18 06 	lds	r5, 0x0618
    2434:	20 91 26 06 	lds	r18, 0x0626
    2438:	60 90 27 06 	lds	r6, 0x0627
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	40 e0       	ldi	r20, 0x00	; 0
    2440:	50 e0       	ldi	r21, 0x00	; 0
    2442:	c6 01       	movw	r24, r12
    2444:	b5 01       	movw	r22, r10
    2446:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    244a:	7b 01       	movw	r14, r22
    244c:	8c 01       	movw	r16, r24
    244e:	53 e0       	ldi	r21, 0x03	; 3
    2450:	16 95       	lsr	r17
    2452:	07 95       	ror	r16
    2454:	f7 94       	ror	r15
    2456:	e7 94       	ror	r14
    2458:	5a 95       	dec	r21
    245a:	d1 f7       	brne	.-12     	; 0x2450 <UpdateAdjustedSampleAddresses+0x4ca>
    245c:	e2 0c       	add	r14, r2
    245e:	f3 1c       	adc	r15, r3
    2460:	04 1d       	adc	r16, r4
    2462:	15 1d       	adc	r17, r5
    2464:	77 24       	eor	r7, r7
    2466:	88 24       	eor	r8, r8
    2468:	99 24       	eor	r9, r9
    246a:	c6 01       	movw	r24, r12
    246c:	b5 01       	movw	r22, r10
    246e:	a4 01       	movw	r20, r8
    2470:	93 01       	movw	r18, r6
    2472:	0e 94 5a 2b 	call	0x56b4	; 0x56b4 <__mulsi3>
    2476:	43 e0       	ldi	r20, 0x03	; 3
    2478:	96 95       	lsr	r25
    247a:	87 95       	ror	r24
    247c:	77 95       	ror	r23
    247e:	67 95       	ror	r22
    2480:	4a 95       	dec	r20
    2482:	d1 f7       	brne	.-12     	; 0x2478 <UpdateAdjustedSampleAddresses+0x4f2>
    2484:	e6 1a       	sub	r14, r22
    2486:	f7 0a       	sbc	r15, r23
    2488:	08 0b       	sbc	r16, r24
    248a:	19 0b       	sbc	r17, r25
    248c:	e0 92 1d 06 	sts	0x061D, r14
    2490:	f0 92 1e 06 	sts	0x061E, r15
    2494:	00 93 1f 06 	sts	0x061F, r16
    2498:	10 93 20 06 	sts	0x0620, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    249c:	20 91 21 06 	lds	r18, 0x0621
    24a0:	30 91 22 06 	lds	r19, 0x0622
    24a4:	40 91 23 06 	lds	r20, 0x0623
    24a8:	50 91 24 06 	lds	r21, 0x0624
    24ac:	80 91 1d 06 	lds	r24, 0x061D
    24b0:	90 91 1e 06 	lds	r25, 0x061E
    24b4:	a0 91 1f 06 	lds	r26, 0x061F
    24b8:	b0 91 20 06 	lds	r27, 0x0620
    24bc:	28 17       	cp	r18, r24
    24be:	39 07       	cpc	r19, r25
    24c0:	4a 07       	cpc	r20, r26
    24c2:	5b 07       	cpc	r21, r27
    24c4:	50 f5       	brcc	.+84     	; 0x251a <UpdateAdjustedSampleAddresses+0x594>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    24c6:	80 91 0c 06 	lds	r24, 0x060C
    24ca:	81 30       	cpi	r24, 0x01	; 1
    24cc:	19 f4       	brne	.+6      	; 0x24d4 <UpdateAdjustedSampleAddresses+0x54e>
			{
				bankStates[BANK_1].sampleDirection=true;
    24ce:	80 93 0d 06 	sts	0x060D, r24
    24d2:	02 c0       	rjmp	.+4      	; 0x24d8 <UpdateAdjustedSampleAddresses+0x552>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    24d4:	10 92 0d 06 	sts	0x060D, r1
			}			

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    24d8:	20 91 21 06 	lds	r18, 0x0621
    24dc:	30 91 22 06 	lds	r19, 0x0622
    24e0:	40 91 23 06 	lds	r20, 0x0623
    24e4:	50 91 24 06 	lds	r21, 0x0624
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    24e8:	80 91 1d 06 	lds	r24, 0x061D
    24ec:	90 91 1e 06 	lds	r25, 0x061E
    24f0:	a0 91 1f 06 	lds	r26, 0x061F
    24f4:	b0 91 20 06 	lds	r27, 0x0620
    24f8:	80 93 21 06 	sts	0x0621, r24
    24fc:	90 93 22 06 	sts	0x0622, r25
    2500:	a0 93 23 06 	sts	0x0623, r26
    2504:	b0 93 24 06 	sts	0x0624, r27
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    2508:	20 93 1d 06 	sts	0x061D, r18
    250c:	30 93 1e 06 	sts	0x061E, r19
    2510:	40 93 1f 06 	sts	0x061F, r20
    2514:	50 93 20 06 	sts	0x0620, r21
    2518:	0a c0       	rjmp	.+20     	; 0x252e <UpdateAdjustedSampleAddresses+0x5a8>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    251a:	80 91 0c 06 	lds	r24, 0x060C
    251e:	81 30       	cpi	r24, 0x01	; 1
    2520:	19 f4       	brne	.+6      	; 0x2528 <UpdateAdjustedSampleAddresses+0x5a2>
			{
				bankStates[BANK_1].sampleDirection=false;
    2522:	10 92 0d 06 	sts	0x060D, r1
    2526:	03 c0       	rjmp	.+6      	; 0x252e <UpdateAdjustedSampleAddresses+0x5a8>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    2528:	81 e0       	ldi	r24, 0x01	; 1
    252a:	80 93 0d 06 	sts	0x060D, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    252e:	20 91 21 06 	lds	r18, 0x0621
    2532:	30 91 22 06 	lds	r19, 0x0622
    2536:	40 91 23 06 	lds	r20, 0x0623
    253a:	50 91 24 06 	lds	r21, 0x0624
    253e:	80 91 15 06 	lds	r24, 0x0615
    2542:	90 91 16 06 	lds	r25, 0x0616
    2546:	a0 91 17 06 	lds	r26, 0x0617
    254a:	b0 91 18 06 	lds	r27, 0x0618
    254e:	28 17       	cp	r18, r24
    2550:	39 07       	cpc	r19, r25
    2552:	4a 07       	cpc	r20, r26
    2554:	5b 07       	cpc	r21, r27
    2556:	00 f5       	brcc	.+64     	; 0x2598 <UpdateAdjustedSampleAddresses+0x612>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    2558:	80 91 21 06 	lds	r24, 0x0621
    255c:	90 91 22 06 	lds	r25, 0x0622
    2560:	a0 91 23 06 	lds	r26, 0x0623
    2564:	b0 91 24 06 	lds	r27, 0x0624
    2568:	20 91 15 06 	lds	r18, 0x0615
    256c:	30 91 16 06 	lds	r19, 0x0616
    2570:	40 91 17 06 	lds	r20, 0x0617
    2574:	50 91 18 06 	lds	r21, 0x0618
    2578:	81 50       	subi	r24, 0x01	; 1
    257a:	90 40       	sbci	r25, 0x00	; 0
    257c:	a8 4f       	sbci	r26, 0xF8	; 248
    257e:	bf 4f       	sbci	r27, 0xFF	; 255
    2580:	82 1b       	sub	r24, r18
    2582:	93 0b       	sbc	r25, r19
    2584:	a4 0b       	sbc	r26, r20
    2586:	b5 0b       	sbc	r27, r21
    2588:	80 93 21 06 	sts	0x0621, r24
    258c:	90 93 22 06 	sts	0x0622, r25
    2590:	a0 93 23 06 	sts	0x0623, r26
    2594:	b0 93 24 06 	sts	0x0624, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    2598:	20 91 1d 06 	lds	r18, 0x061D
    259c:	30 91 1e 06 	lds	r19, 0x061E
    25a0:	40 91 1f 06 	lds	r20, 0x061F
    25a4:	50 91 20 06 	lds	r21, 0x0620
    25a8:	80 91 15 06 	lds	r24, 0x0615
    25ac:	90 91 16 06 	lds	r25, 0x0616
    25b0:	a0 91 17 06 	lds	r26, 0x0617
    25b4:	b0 91 18 06 	lds	r27, 0x0618
    25b8:	28 17       	cp	r18, r24
    25ba:	39 07       	cpc	r19, r25
    25bc:	4a 07       	cpc	r20, r26
    25be:	5b 07       	cpc	r21, r27
    25c0:	08 f0       	brcs	.+2      	; 0x25c4 <UpdateAdjustedSampleAddresses+0x63e>
    25c2:	48 c0       	rjmp	.+144    	; 0x2654 <UpdateAdjustedSampleAddresses+0x6ce>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    25c4:	80 91 1d 06 	lds	r24, 0x061D
    25c8:	90 91 1e 06 	lds	r25, 0x061E
    25cc:	a0 91 1f 06 	lds	r26, 0x061F
    25d0:	b0 91 20 06 	lds	r27, 0x0620
    25d4:	20 91 15 06 	lds	r18, 0x0615
    25d8:	30 91 16 06 	lds	r19, 0x0616
    25dc:	40 91 17 06 	lds	r20, 0x0617
    25e0:	50 91 18 06 	lds	r21, 0x0618
    25e4:	81 50       	subi	r24, 0x01	; 1
    25e6:	90 40       	sbci	r25, 0x00	; 0
    25e8:	a8 4f       	sbci	r26, 0xF8	; 248
    25ea:	bf 4f       	sbci	r27, 0xFF	; 255
    25ec:	82 1b       	sub	r24, r18
    25ee:	93 0b       	sbc	r25, r19
    25f0:	a4 0b       	sbc	r26, r20
    25f2:	b5 0b       	sbc	r27, r21
    25f4:	80 93 1d 06 	sts	0x061D, r24
    25f8:	90 93 1e 06 	sts	0x061E, r25
    25fc:	a0 93 1f 06 	sts	0x061F, r26
    2600:	b0 93 20 06 	sts	0x0620, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    2604:	20 91 1d 06 	lds	r18, 0x061D
    2608:	30 91 1e 06 	lds	r19, 0x061E
    260c:	40 91 1f 06 	lds	r20, 0x061F
    2610:	50 91 20 06 	lds	r21, 0x0620
    2614:	80 91 21 06 	lds	r24, 0x0621
    2618:	90 91 22 06 	lds	r25, 0x0622
    261c:	a0 91 23 06 	lds	r26, 0x0623
    2620:	b0 91 24 06 	lds	r27, 0x0624
    2624:	28 17       	cp	r18, r24
    2626:	39 07       	cpc	r19, r25
    2628:	4a 07       	cpc	r20, r26
    262a:	5b 07       	cpc	r21, r27
    262c:	99 f4       	brne	.+38     	; 0x2654 <UpdateAdjustedSampleAddresses+0x6ce>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    262e:	80 91 1d 06 	lds	r24, 0x061D
    2632:	90 91 1e 06 	lds	r25, 0x061E
    2636:	a0 91 1f 06 	lds	r26, 0x061F
    263a:	b0 91 20 06 	lds	r27, 0x0620
    263e:	01 96       	adiw	r24, 0x01	; 1
    2640:	a1 1d       	adc	r26, r1
    2642:	b1 1d       	adc	r27, r1
    2644:	80 93 1d 06 	sts	0x061D, r24
    2648:	90 93 1e 06 	sts	0x061E, r25
    264c:	a0 93 1f 06 	sts	0x061F, r26
    2650:	b0 93 20 06 	sts	0x0620, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    2654:	20 91 21 06 	lds	r18, 0x0621
    2658:	30 91 22 06 	lds	r19, 0x0622
    265c:	40 91 23 06 	lds	r20, 0x0623
    2660:	50 91 24 06 	lds	r21, 0x0624
    2664:	80 91 1d 06 	lds	r24, 0x061D
    2668:	90 91 1e 06 	lds	r25, 0x061E
    266c:	a0 91 1f 06 	lds	r26, 0x061F
    2670:	b0 91 20 06 	lds	r27, 0x0620
    2674:	28 17       	cp	r18, r24
    2676:	39 07       	cpc	r19, r25
    2678:	4a 07       	cpc	r20, r26
    267a:	5b 07       	cpc	r21, r27
    267c:	08 f0       	brcs	.+2      	; 0x2680 <UpdateAdjustedSampleAddresses+0x6fa>
    267e:	5a c0       	rjmp	.+180    	; 0x2734 <UpdateAdjustedSampleAddresses+0x7ae>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    2680:	20 91 28 06 	lds	r18, 0x0628
    2684:	30 91 29 06 	lds	r19, 0x0629
    2688:	40 91 2a 06 	lds	r20, 0x062A
    268c:	50 91 2b 06 	lds	r21, 0x062B
    2690:	80 91 21 06 	lds	r24, 0x0621
    2694:	90 91 22 06 	lds	r25, 0x0622
    2698:	a0 91 23 06 	lds	r26, 0x0623
    269c:	b0 91 24 06 	lds	r27, 0x0624
    26a0:	82 17       	cp	r24, r18
    26a2:	93 07       	cpc	r25, r19
    26a4:	a4 07       	cpc	r26, r20
    26a6:	b5 07       	cpc	r27, r21
    26a8:	08 f0       	brcs	.+2      	; 0x26ac <UpdateAdjustedSampleAddresses+0x726>
    26aa:	87 c0       	rjmp	.+270    	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
    26ac:	20 91 28 06 	lds	r18, 0x0628
    26b0:	30 91 29 06 	lds	r19, 0x0629
    26b4:	40 91 2a 06 	lds	r20, 0x062A
    26b8:	50 91 2b 06 	lds	r21, 0x062B
    26bc:	80 91 1d 06 	lds	r24, 0x061D
    26c0:	90 91 1e 06 	lds	r25, 0x061E
    26c4:	a0 91 1f 06 	lds	r26, 0x061F
    26c8:	b0 91 20 06 	lds	r27, 0x0620
    26cc:	28 17       	cp	r18, r24
    26ce:	39 07       	cpc	r19, r25
    26d0:	4a 07       	cpc	r20, r26
    26d2:	5b 07       	cpc	r21, r27
    26d4:	08 f0       	brcs	.+2      	; 0x26d8 <UpdateAdjustedSampleAddresses+0x752>
    26d6:	71 c0       	rjmp	.+226    	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?	
    26d8:	20 91 28 06 	lds	r18, 0x0628
    26dc:	30 91 29 06 	lds	r19, 0x0629
    26e0:	40 91 2a 06 	lds	r20, 0x062A
    26e4:	50 91 2b 06 	lds	r21, 0x062B
    26e8:	a0 90 21 06 	lds	r10, 0x0621
    26ec:	b0 90 22 06 	lds	r11, 0x0622
    26f0:	c0 90 23 06 	lds	r12, 0x0623
    26f4:	d0 90 24 06 	lds	r13, 0x0624
    26f8:	80 91 1d 06 	lds	r24, 0x061D
    26fc:	90 91 1e 06 	lds	r25, 0x061E
    2700:	a0 91 1f 06 	lds	r26, 0x061F
    2704:	b0 91 20 06 	lds	r27, 0x0620
    2708:	e0 90 28 06 	lds	r14, 0x0628
    270c:	f0 90 29 06 	lds	r15, 0x0629
    2710:	00 91 2a 06 	lds	r16, 0x062A
    2714:	10 91 2b 06 	lds	r17, 0x062B
    2718:	2a 19       	sub	r18, r10
    271a:	3b 09       	sbc	r19, r11
    271c:	4c 09       	sbc	r20, r12
    271e:	5d 09       	sbc	r21, r13
    2720:	8e 19       	sub	r24, r14
    2722:	9f 09       	sbc	r25, r15
    2724:	a0 0b       	sbc	r26, r16
    2726:	b1 0b       	sbc	r27, r17
    2728:	82 17       	cp	r24, r18
    272a:	93 07       	cpc	r25, r19
    272c:	a4 07       	cpc	r26, r20
    272e:	b5 07       	cpc	r27, r21
    2730:	a0 f1       	brcs	.+104    	; 0x279a <UpdateAdjustedSampleAddresses+0x814>
    2732:	15 c0       	rjmp	.+42     	; 0x275e <UpdateAdjustedSampleAddresses+0x7d8>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    2734:	20 91 28 06 	lds	r18, 0x0628
    2738:	30 91 29 06 	lds	r19, 0x0629
    273c:	40 91 2a 06 	lds	r20, 0x062A
    2740:	50 91 2b 06 	lds	r21, 0x062B
    2744:	80 91 21 06 	lds	r24, 0x0621
    2748:	90 91 22 06 	lds	r25, 0x0622
    274c:	a0 91 23 06 	lds	r26, 0x0623
    2750:	b0 91 24 06 	lds	r27, 0x0624
    2754:	82 17       	cp	r24, r18
    2756:	93 07       	cpc	r25, r19
    2758:	a4 07       	cpc	r26, r20
    275a:	b5 07       	cpc	r27, r21
    275c:	48 f4       	brcc	.+18     	; 0x2770 <UpdateAdjustedSampleAddresses+0x7ea>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    275e:	80 91 21 06 	lds	r24, 0x0621
    2762:	90 91 22 06 	lds	r25, 0x0622
    2766:	a0 91 23 06 	lds	r26, 0x0623
    276a:	b0 91 24 06 	lds	r27, 0x0624
    276e:	1d c0       	rjmp	.+58     	; 0x27aa <UpdateAdjustedSampleAddresses+0x824>
			}				
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    2770:	20 91 28 06 	lds	r18, 0x0628
    2774:	30 91 29 06 	lds	r19, 0x0629
    2778:	40 91 2a 06 	lds	r20, 0x062A
    277c:	50 91 2b 06 	lds	r21, 0x062B
    2780:	80 91 1d 06 	lds	r24, 0x061D
    2784:	90 91 1e 06 	lds	r25, 0x061E
    2788:	a0 91 1f 06 	lds	r26, 0x061F
    278c:	b0 91 20 06 	lds	r27, 0x0620
    2790:	28 17       	cp	r18, r24
    2792:	39 07       	cpc	r19, r25
    2794:	4a 07       	cpc	r20, r26
    2796:	5b 07       	cpc	r21, r27
    2798:	80 f4       	brcc	.+32     	; 0x27ba <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    279a:	80 91 1d 06 	lds	r24, 0x061D
    279e:	90 91 1e 06 	lds	r25, 0x061E
    27a2:	a0 91 1f 06 	lds	r26, 0x061F
    27a6:	b0 91 20 06 	lds	r27, 0x0620
    27aa:	80 93 28 06 	sts	0x0628, r24
    27ae:	90 93 29 06 	sts	0x0629, r25
    27b2:	a0 93 2a 06 	sts	0x062A, r26
    27b6:	b0 93 2b 06 	sts	0x062B, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    27ba:	e9 81       	ldd	r30, Y+1	; 0x01
    27bc:	ef bf       	out	0x3f, r30	; 63
}
    27be:	0f 90       	pop	r0
    27c0:	cf 91       	pop	r28
    27c2:	df 91       	pop	r29
    27c4:	1f 91       	pop	r17
    27c6:	0f 91       	pop	r16
    27c8:	ff 90       	pop	r15
    27ca:	ef 90       	pop	r14
    27cc:	df 90       	pop	r13
    27ce:	cf 90       	pop	r12
    27d0:	bf 90       	pop	r11
    27d2:	af 90       	pop	r10
    27d4:	9f 90       	pop	r9
    27d6:	8f 90       	pop	r8
    27d8:	7f 90       	pop	r7
    27da:	6f 90       	pop	r6
    27dc:	5f 90       	pop	r5
    27de:	4f 90       	pop	r4
    27e0:	3f 90       	pop	r3
    27e2:	2f 90       	pop	r2
    27e4:	08 95       	ret

000027e6 <BlinkLeds>:

static void BlinkLeds(unsigned int theMask)
// Sets up the mask of leds to blink and their blink rate.
// NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from having 8 separate software clocks.
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
    27e6:	a8 2f       	mov	r26, r24
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27e8:	80 91 3c 01 	lds	r24, 0x013C
    27ec:	68 2f       	mov	r22, r24
    27ee:	70 e0       	ldi	r23, 0x00	; 0
    27f0:	50 91 3b 01 	lds	r21, 0x013B
    27f4:	20 e0       	ldi	r18, 0x00	; 0
    27f6:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    27f8:	e1 e0       	ldi	r30, 0x01	; 1
    27fa:	f0 e0       	ldi	r31, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    27fc:	cb 01       	movw	r24, r22
    27fe:	02 2e       	mov	r0, r18
    2800:	02 c0       	rjmp	.+4      	; 0x2806 <BlinkLeds+0x20>
    2802:	95 95       	asr	r25
    2804:	87 95       	ror	r24
    2806:	0a 94       	dec	r0
    2808:	e2 f7       	brpl	.-8      	; 0x2802 <BlinkLeds+0x1c>
    280a:	80 ff       	sbrs	r24, 0
    280c:	09 c0       	rjmp	.+18     	; 0x2820 <BlinkLeds+0x3a>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    280e:	cf 01       	movw	r24, r30
    2810:	02 2e       	mov	r0, r18
    2812:	02 c0       	rjmp	.+4      	; 0x2818 <BlinkLeds+0x32>
    2814:	88 0f       	add	r24, r24
    2816:	99 1f       	adc	r25, r25
    2818:	0a 94       	dec	r0
    281a:	e2 f7       	brpl	.-8      	; 0x2814 <BlinkLeds+0x2e>
    281c:	80 95       	com	r24
    281e:	58 23       	and	r21, r24
    2820:	2f 5f       	subi	r18, 0xFF	; 255
    2822:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    2824:	28 30       	cpi	r18, 0x08	; 8
    2826:	31 05       	cpc	r19, r1
    2828:	49 f7       	brne	.-46     	; 0x27fc <BlinkLeds+0x16>
    282a:	50 93 3b 01 	sts	0x013B, r21
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    282e:	a0 93 3c 01 	sts	0x013C, r26
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    2832:	82 e0       	ldi	r24, 0x02	; 2
    2834:	68 e9       	ldi	r22, 0x98	; 152
    2836:	70 e0       	ldi	r23, 0x00	; 0
    2838:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
}
    283c:	08 95       	ret

0000283e <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    283e:	10 92 3b 01 	sts	0x013B, r1
	BlinkLeds(0);		// Durrrr.....
    2842:	80 e0       	ldi	r24, 0x00	; 0
    2844:	90 e0       	ldi	r25, 0x00	; 0
    2846:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
}
    284a:	08 95       	ret

0000284c <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    284c:	80 91 41 01 	lds	r24, 0x0141
    2850:	88 23       	and	r24, r24
    2852:	81 f4       	brne	.+32     	; 0x2874 <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs 
    2854:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
												
		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    2858:	10 92 e6 05 	sts	0x05E6, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    285c:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    2860:	10 92 09 06 	sts	0x0609, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    2864:	10 92 12 06 	sts	0x0612, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    2868:	81 e8       	ldi	r24, 0x81	; 129
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
		subState=SS_1;		
    2870:	81 e0       	ldi	r24, 0x01	; 1
    2872:	13 c0       	rjmp	.+38     	; 0x289a <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    2874:	81 30       	cpi	r24, 0x01	; 1
    2876:	09 f5       	brne	.+66     	; 0x28ba <DoFormatCard+0x6e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    2878:	80 91 3e 01 	lds	r24, 0x013E
    287c:	80 ff       	sbrs	r24, 0
    287e:	10 c0       	rjmp	.+32     	; 0x28a0 <DoFormatCard+0x54>
    2880:	87 ff       	sbrs	r24, 7
    2882:	0e c0       	rjmp	.+28     	; 0x28a0 <DoFormatCard+0x54>
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    2884:	86 e0       	ldi	r24, 0x06	; 6
    2886:	80 93 59 02 	sts	0x0259, r24
			KillLeds();
    288a:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs		
    288e:	80 91 3b 01 	lds	r24, 0x013B
    2892:	81 68       	ori	r24, 0x81	; 129
    2894:	80 93 3b 01 	sts	0x013B, r24
			subState=SS_2;		
    2898:	82 e0       	ldi	r24, 0x02	; 2
    289a:	80 93 41 01 	sts	0x0141, r24
    289e:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    28a0:	80 91 59 02 	lds	r24, 0x0259
    28a4:	88 23       	and	r24, r24
    28a6:	31 f5       	brne	.+76     	; 0x28f4 <DoFormatCard+0xa8>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    28a8:	83 e0       	ldi	r24, 0x03	; 3
    28aa:	95 e1       	ldi	r25, 0x15	; 21
    28ac:	90 93 e5 05 	sts	0x05E5, r25
    28b0:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    28b4:	10 92 41 01 	sts	0x0141, r1
    28b8:	08 95       	ret
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    28ba:	82 30       	cpi	r24, 0x02	; 2
    28bc:	d9 f4       	brne	.+54     	; 0x28f4 <DoFormatCard+0xa8>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    28be:	80 91 59 02 	lds	r24, 0x0259
    28c2:	8e 30       	cpi	r24, 0x0E	; 14
    28c4:	b9 f4       	brne	.+46     	; 0x28f4 <DoFormatCard+0xa8>
		{
			KillLeds();
    28c6:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    28ca:	80 91 3b 01 	lds	r24, 0x013B
    28ce:	82 60       	ori	r24, 0x02	; 2
    28d0:	80 93 3b 01 	sts	0x013B, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    28d4:	80 91 59 02 	lds	r24, 0x0259
    28d8:	88 23       	and	r24, r24
    28da:	21 f0       	breq	.+8      	; 0x28e4 <DoFormatCard+0x98>
    28dc:	80 91 3f 01 	lds	r24, 0x013F
    28e0:	88 23       	and	r24, r24
    28e2:	41 f0       	breq	.+16     	; 0x28f4 <DoFormatCard+0xa8>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    28e4:	83 e0       	ldi	r24, 0x03	; 3
    28e6:	95 e1       	ldi	r25, 0x15	; 21
    28e8:	90 93 e5 05 	sts	0x05E5, r25
    28ec:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    28f0:	10 92 41 01 	sts	0x0141, r1
    28f4:	08 95       	ret

000028f6 <DoSawtooth>:
// Also test to see if our flash is present and working.
{
	static unsigned char
		lastShuttleRead;

	if(subState==SS_0)
    28f6:	80 91 41 01 	lds	r24, 0x0141
    28fa:	88 23       	and	r24, r24
    28fc:	41 f4       	brne	.+16     	; 0x290e <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    28fe:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    2902:	80 ec       	ldi	r24, 0xC0	; 192
    2904:	90 e0       	ldi	r25, 0x00	; 0
    2906:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
		subState=SS_1;
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	19 c0       	rjmp	.+50     	; 0x2940 <DoSawtooth+0x4a>
	}
	else if(subState==SS_1)
    290e:	81 30       	cpi	r24, 0x01	; 1
    2910:	d1 f4       	brne	.+52     	; 0x2946 <DoSawtooth+0x50>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2912:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    2914:	80 93 e6 05 	sts	0x05E6, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    2918:	80 93 ef 05 	sts	0x05EF, r24
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
    291c:	80 e0       	ldi	r24, 0x00	; 0
    291e:	61 e0       	ldi	r22, 0x01	; 1
    2920:	40 e0       	ldi	r20, 0x00	; 0
    2922:	50 e0       	ldi	r21, 0x00	; 0
    2924:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <SetSampleClock>
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2928:	81 e5       	ldi	r24, 0x51	; 81
    292a:	98 e0       	ldi	r25, 0x08	; 8
    292c:	90 93 e3 05 	sts	0x05E3, r25
    2930:	80 93 e2 05 	sts	0x05E2, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.		
    2934:	78 94       	sei

		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the leds when it changes.
    2936:	80 91 44 01 	lds	r24, 0x0144
    293a:	80 93 2f 01 	sts	0x012F, r24

		subState=SS_2;					// And wait forever.
    293e:	82 e0       	ldi	r24, 0x02	; 2
    2940:	80 93 41 01 	sts	0x0141, r24
    2944:	08 95       	ret
	}
	else if(subState==SS_2)
    2946:	82 30       	cpi	r24, 0x02	; 2
    2948:	09 f0       	breq	.+2      	; 0x294c <DoSawtooth+0x56>
    294a:	5c c0       	rjmp	.+184    	; 0x2a04 <DoSawtooth+0x10e>
	{

		if(newKeys&Im_SWITCH_0)
    294c:	80 91 3f 01 	lds	r24, 0x013F
    2950:	28 2f       	mov	r18, r24
    2952:	80 ff       	sbrs	r24, 0
    2954:	06 c0       	rjmp	.+12     	; 0x2962 <DoSawtooth+0x6c>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    2956:	80 91 3b 01 	lds	r24, 0x013B
    295a:	91 e0       	ldi	r25, 0x01	; 1
    295c:	89 27       	eor	r24, r25
    295e:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_1)
    2962:	21 ff       	sbrs	r18, 1
    2964:	06 c0       	rjmp	.+12     	; 0x2972 <DoSawtooth+0x7c>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    2966:	80 91 3b 01 	lds	r24, 0x013B
    296a:	92 e0       	ldi	r25, 0x02	; 2
    296c:	89 27       	eor	r24, r25
    296e:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_2)
    2972:	22 ff       	sbrs	r18, 2
    2974:	06 c0       	rjmp	.+12     	; 0x2982 <DoSawtooth+0x8c>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    2976:	80 91 3b 01 	lds	r24, 0x013B
    297a:	94 e0       	ldi	r25, 0x04	; 4
    297c:	89 27       	eor	r24, r25
    297e:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_3)
    2982:	23 ff       	sbrs	r18, 3
    2984:	06 c0       	rjmp	.+12     	; 0x2992 <DoSawtooth+0x9c>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    2986:	80 91 3b 01 	lds	r24, 0x013B
    298a:	98 e0       	ldi	r25, 0x08	; 8
    298c:	89 27       	eor	r24, r25
    298e:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_4)
    2992:	24 ff       	sbrs	r18, 4
    2994:	06 c0       	rjmp	.+12     	; 0x29a2 <DoSawtooth+0xac>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    2996:	80 91 3b 01 	lds	r24, 0x013B
    299a:	90 e1       	ldi	r25, 0x10	; 16
    299c:	89 27       	eor	r24, r25
    299e:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_5)
    29a2:	25 ff       	sbrs	r18, 5
    29a4:	06 c0       	rjmp	.+12     	; 0x29b2 <DoSawtooth+0xbc>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    29a6:	80 91 3b 01 	lds	r24, 0x013B
    29aa:	90 e2       	ldi	r25, 0x20	; 32
    29ac:	89 27       	eor	r24, r25
    29ae:	80 93 3b 01 	sts	0x013B, r24
		}

		if(newKeys&Im_SWITCH_6)
    29b2:	26 ff       	sbrs	r18, 6
    29b4:	0a c0       	rjmp	.+20     	; 0x29ca <DoSawtooth+0xd4>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    29b6:	80 e0       	ldi	r24, 0x00	; 0
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
		}

		if(newKeys&Im_SWITCH_6)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    29be:	80 91 3b 01 	lds	r24, 0x013B
    29c2:	90 e4       	ldi	r25, 0x40	; 64
    29c4:	89 27       	eor	r24, r25
    29c6:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_7)
    29ca:	80 91 3f 01 	lds	r24, 0x013F
    29ce:	87 ff       	sbrs	r24, 7
    29d0:	09 c0       	rjmp	.+18     	; 0x29e4 <DoSawtooth+0xee>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    29d2:	80 e0       	ldi	r24, 0x00	; 0
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
		}
		if(newKeys&Im_SWITCH_7)
		{
			StopBlinking();
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    29da:	80 91 3b 01 	lds	r24, 0x013B
    29de:	80 58       	subi	r24, 0x80	; 128
    29e0:	80 93 3b 01 	sts	0x013B, r24
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
    29e4:	90 91 2f 01 	lds	r25, 0x012F
    29e8:	80 91 44 01 	lds	r24, 0x0144
    29ec:	98 17       	cp	r25, r24
    29ee:	51 f0       	breq	.+20     	; 0x2a04 <DoSawtooth+0x10e>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    29f0:	80 e0       	ldi	r24, 0x00	; 0
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
		}
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    29f8:	80 91 44 01 	lds	r24, 0x0144
    29fc:	80 93 3b 01 	sts	0x013B, r24
			lastShuttleRead=encoderValue;
    2a00:	80 93 2f 01 	sts	0x012F, r24
    2a04:	08 95       	ret

00002a06 <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    2a06:	1f 93       	push	r17
	static unsigned char
		i;
		
	if(subState==SS_0)
    2a08:	10 91 41 01 	lds	r17, 0x0141
    2a0c:	11 23       	and	r17, r17
    2a0e:	69 f4       	brne	.+26     	; 0x2a2a <DoFruitcakeIntro+0x24>
	{
		KillLeds();
    2a10:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
		i=0;
    2a14:	10 92 26 01 	sts	0x0126, r1
		ledOnOffMask=0;
    2a18:	10 92 3b 01 	sts	0x013B, r1
		subState=SS_1;
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	80 93 41 01 	sts	0x0141, r24
		SetTimer(TIMER_1,(SECOND/4));
    2a22:	80 e0       	ldi	r24, 0x00	; 0
    2a24:	61 e3       	ldi	r22, 0x31	; 49
    2a26:	71 e0       	ldi	r23, 0x01	; 1
    2a28:	6a c0       	rjmp	.+212    	; 0x2afe <DoFruitcakeIntro+0xf8>
	}
	else if(subState==SS_1)
    2a2a:	11 30       	cpi	r17, 0x01	; 1
    2a2c:	41 f4       	brne	.+16     	; 0x2a3e <DoFruitcakeIntro+0x38>
	{
		if(CheckTimer(TIMER_1))
    2a2e:	80 e0       	ldi	r24, 0x00	; 0
    2a30:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2a34:	88 23       	and	r24, r24
    2a36:	09 f4       	brne	.+2      	; 0x2a3a <DoFruitcakeIntro+0x34>
    2a38:	91 c0       	rjmp	.+290    	; 0x2b5c <DoFruitcakeIntro+0x156>
		{
			subState=SS_2;
    2a3a:	82 e0       	ldi	r24, 0x02	; 2
    2a3c:	7b c0       	rjmp	.+246    	; 0x2b34 <DoFruitcakeIntro+0x12e>
		}
	}

	else if(subState==SS_2)
    2a3e:	12 30       	cpi	r17, 0x02	; 2
    2a40:	09 f0       	breq	.+2      	; 0x2a44 <DoFruitcakeIntro+0x3e>
    2a42:	4a c0       	rjmp	.+148    	; 0x2ad8 <DoFruitcakeIntro+0xd2>
	{
		if(i<NUM_LEDS)
    2a44:	80 91 26 01 	lds	r24, 0x0126
    2a48:	88 30       	cpi	r24, 0x08	; 8
    2a4a:	f8 f4       	brcc	.+62     	; 0x2a8a <DoFruitcakeIntro+0x84>
		{
			if(CheckTimer(TIMER_1))
    2a4c:	80 e0       	ldi	r24, 0x00	; 0
    2a4e:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2a52:	88 23       	and	r24, r24
    2a54:	09 f4       	brne	.+2      	; 0x2a58 <DoFruitcakeIntro+0x52>
    2a56:	82 c0       	rjmp	.+260    	; 0x2b5c <DoFruitcakeIntro+0x156>
			{
				ledOnOffMask|=(1<<i);
    2a58:	81 e0       	ldi	r24, 0x01	; 1
    2a5a:	90 e0       	ldi	r25, 0x00	; 0
    2a5c:	00 90 26 01 	lds	r0, 0x0126
    2a60:	02 c0       	rjmp	.+4      	; 0x2a66 <DoFruitcakeIntro+0x60>
    2a62:	88 0f       	add	r24, r24
    2a64:	99 1f       	adc	r25, r25
    2a66:	0a 94       	dec	r0
    2a68:	e2 f7       	brpl	.-8      	; 0x2a62 <DoFruitcakeIntro+0x5c>
    2a6a:	20 91 3b 01 	lds	r18, 0x013B
    2a6e:	28 2b       	or	r18, r24
    2a70:	20 93 3b 01 	sts	0x013B, r18
				SetTimer(TIMER_1,(SECOND/20));		
    2a74:	80 e0       	ldi	r24, 0x00	; 0
    2a76:	6d e3       	ldi	r22, 0x3D	; 61
    2a78:	70 e0       	ldi	r23, 0x00	; 0
    2a7a:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
				i++;
    2a7e:	80 91 26 01 	lds	r24, 0x0126
    2a82:	8f 5f       	subi	r24, 0xFF	; 255
    2a84:	80 93 26 01 	sts	0x0126, r24
    2a88:	69 c0       	rjmp	.+210    	; 0x2b5c <DoFruitcakeIntro+0x156>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    2a8a:	80 e0       	ldi	r24, 0x00	; 0
    2a8c:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2a90:	88 23       	and	r24, r24
    2a92:	09 f4       	brne	.+2      	; 0x2a96 <DoFruitcakeIntro+0x90>
    2a94:	63 c0       	rjmp	.+198    	; 0x2b5c <DoFruitcakeIntro+0x156>
			{
				SetTimer(TIMER_1,(SECOND/8));
    2a96:	80 e0       	ldi	r24, 0x00	; 0
    2a98:	68 e9       	ldi	r22, 0x98	; 152
    2a9a:	70 e0       	ldi	r23, 0x00	; 0
    2a9c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
				ledPwm=255;
    2aa0:	9f ef       	ldi	r25, 0xFF	; 255
    2aa2:	90 93 3d 01 	sts	0x013D, r25
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.	
    2aa6:	80 91 64 00 	lds	r24, 0x0064
    2aaa:	8f 7b       	andi	r24, 0xBF	; 191
    2aac:	80 93 64 00 	sts	0x0064, r24

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.	
    2ab0:	10 93 b0 00 	sts	0x00B0, r17
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    2ab4:	81 e0       	ldi	r24, 0x01	; 1
    2ab6:	80 93 b1 00 	sts	0x00B1, r24
				TCNT2=0;			// Init counter reg
    2aba:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    2abe:	80 e8       	ldi	r24, 0x80	; 128
    2ac0:	80 93 b3 00 	sts	0x00B3, r24
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    2ac4:	97 bb       	out	0x17, r25	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    2ac6:	10 93 70 00 	sts	0x0070, r17

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    2aca:	82 b1       	in	r24, 0x02	; 2
    2acc:	86 60       	ori	r24, 0x06	; 6
    2ace:	82 b9       	out	0x02, r24	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2ad0:	94 b9       	out	0x04, r25	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    2ad2:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;		
    2ad4:	83 e0       	ldi	r24, 0x03	; 3
    2ad6:	2e c0       	rjmp	.+92     	; 0x2b34 <DoFruitcakeIntro+0x12e>
			}
		}
	}
	else if(subState==SS_3)
    2ad8:	13 30       	cpi	r17, 0x03	; 3
    2ada:	79 f5       	brne	.+94     	; 0x2b3a <DoFruitcakeIntro+0x134>
	{		
		if(CheckTimer(TIMER_1))
    2adc:	80 e0       	ldi	r24, 0x00	; 0
    2ade:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2ae2:	88 23       	and	r24, r24
    2ae4:	d9 f1       	breq	.+118    	; 0x2b5c <DoFruitcakeIntro+0x156>
		{
			if(ledPwm>1)
    2ae6:	80 91 3d 01 	lds	r24, 0x013D
    2aea:	82 30       	cpi	r24, 0x02	; 2
    2aec:	58 f0       	brcs	.+22     	; 0x2b04 <DoFruitcakeIntro+0xfe>
			{
				ledPwm-=2;
    2aee:	80 91 3d 01 	lds	r24, 0x013D
    2af2:	82 50       	subi	r24, 0x02	; 2
    2af4:	80 93 3d 01 	sts	0x013D, r24
				SetTimer(TIMER_1,(SECOND/256));
    2af8:	80 e0       	ldi	r24, 0x00	; 0
    2afa:	64 e0       	ldi	r22, 0x04	; 4
    2afc:	70 e0       	ldi	r23, 0x00	; 0
    2afe:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
    2b02:	2c c0       	rjmp	.+88     	; 0x2b5c <DoFruitcakeIntro+0x156>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    2b04:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    2b08:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    2b0c:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.	
    2b10:	80 91 64 00 	lds	r24, 0x0064
    2b14:	80 64       	ori	r24, 0x40	; 64
    2b16:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    2b1a:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    2b1c:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    2b1e:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    2b22:	81 e1       	ldi	r24, 0x11	; 17
    2b24:	80 93 3b 01 	sts	0x013B, r24
				SetTimer(TIMER_1,(SECOND/2));
    2b28:	80 e0       	ldi	r24, 0x00	; 0
    2b2a:	62 e6       	ldi	r22, 0x62	; 98
    2b2c:	72 e0       	ldi	r23, 0x02	; 2
    2b2e:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
				subState=SS_4;
    2b32:	84 e0       	ldi	r24, 0x04	; 4
    2b34:	80 93 41 01 	sts	0x0141, r24
    2b38:	11 c0       	rjmp	.+34     	; 0x2b5c <DoFruitcakeIntro+0x156>
			}
		}
	}
	else if(subState==SS_4)
    2b3a:	14 30       	cpi	r17, 0x04	; 4
    2b3c:	79 f4       	brne	.+30     	; 0x2b5c <DoFruitcakeIntro+0x156>
	{
		if(CheckTimer(TIMER_1))
    2b3e:	80 e0       	ldi	r24, 0x00	; 0
    2b40:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2b44:	88 23       	and	r24, r24
    2b46:	51 f0       	breq	.+20     	; 0x2b5c <DoFruitcakeIntro+0x156>
		{
			KillLeds();
    2b48:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2b4c:	80 eb       	ldi	r24, 0xB0	; 176
    2b4e:	95 e1       	ldi	r25, 0x15	; 21
    2b50:	90 93 e5 05 	sts	0x05E5, r25
    2b54:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2b58:	10 92 41 01 	sts	0x0141, r1
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
	}
}
    2b5c:	1f 91       	pop	r17
    2b5e:	08 95       	ret

00002b60 <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    2b60:	80 91 41 01 	lds	r24, 0x0141
    2b64:	88 23       	and	r24, r24
    2b66:	41 f4       	brne	.+16     	; 0x2b78 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    2b68:	68 e9       	ldi	r22, 0x98	; 152
    2b6a:	70 e0       	ldi	r23, 0x00	; 0
    2b6c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
		subState=SS_1;
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	80 93 41 01 	sts	0x0141, r24
    2b76:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    2b78:	80 e0       	ldi	r24, 0x00	; 0
    2b7a:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2b7e:	88 23       	and	r24, r24
    2b80:	d1 f0       	breq	.+52     	; 0x2bb6 <DoStartupSelect+0x56>
		{
			if(keyState&Im_SWITCH_0)
    2b82:	80 91 3e 01 	lds	r24, 0x013E
    2b86:	80 ff       	sbrs	r24, 0
    2b88:	03 c0       	rjmp	.+6      	; 0x2b90 <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2b8a:	8b e7       	ldi	r24, 0x7B	; 123
    2b8c:	94 e1       	ldi	r25, 0x14	; 20
    2b8e:	04 c0       	rjmp	.+8      	; 0x2b98 <DoStartupSelect+0x38>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    2b90:	85 ff       	sbrs	r24, 5
    2b92:	09 c0       	rjmp	.+18     	; 0x2ba6 <DoStartupSelect+0x46>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2b94:	83 ed       	ldi	r24, 0xD3	; 211
    2b96:	95 e2       	ldi	r25, 0x25	; 37
    2b98:	90 93 e5 05 	sts	0x05E5, r25
    2b9c:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2ba0:	10 92 41 01 	sts	0x0141, r1
    2ba4:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2ba6:	83 e9       	ldi	r24, 0x93	; 147
    2ba8:	9d e1       	ldi	r25, 0x1D	; 29
    2baa:	90 93 e5 05 	sts	0x05E5, r25
    2bae:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2bb2:	10 92 41 01 	sts	0x0141, r1
    2bb6:	08 95       	ret

00002bb8 <SdStartSampleRead>:

static bool SdStartSampleRead(unsigned int sampleSlot)
// Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
// Begins a sample read in the correct spot.
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
    2bb8:	df 92       	push	r13
    2bba:	ef 92       	push	r14
    2bbc:	ff 92       	push	r15
    2bbe:	0f 93       	push	r16
    2bc0:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;
    2bc2:	df b6       	in	r13, 0x3f	; 63
	cli();		// Pause ISR
    2bc4:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    2bc6:	38 2f       	mov	r19, r24
    2bc8:	33 0f       	add	r19, r19
    2bca:	33 0f       	add	r19, r19
    2bcc:	20 e0       	ldi	r18, 0x00	; 0
    2bce:	2f 5f       	subi	r18, 0xFF	; 255
    2bd0:	3f 4f       	sbci	r19, 0xFF	; 255
    2bd2:	79 01       	movw	r14, r18
    2bd4:	00 e0       	ldi	r16, 0x00	; 0
    2bd6:	10 e0       	ldi	r17, 0x00	; 0
    2bd8:	c8 01       	movw	r24, r16
    2bda:	b7 01       	movw	r22, r14
    2bdc:	0e 94 21 2a 	call	0x5442	; 0x5442 <SdBeginSingleBlockRead>
    2be0:	81 30       	cpi	r24, 0x01	; 1
    2be2:	19 f5       	brne	.+70     	; 0x2c2a <SdStartSampleRead+0x72>
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    2be4:	e0 92 a5 05 	sts	0x05A5, r14
    2be8:	f0 92 a6 05 	sts	0x05A6, r15
    2bec:	00 93 a7 05 	sts	0x05A7, r16
    2bf0:	10 93 a8 05 	sts	0x05A8, r17
		sdCurrentBlockOffset=0;						// Read first block first
    2bf4:	10 92 b4 05 	sts	0x05B4, r1
    2bf8:	10 92 b3 05 	sts	0x05B3, r1
	
		sdFifoReadPointer=0;		// Reset FIFO variables
    2bfc:	10 92 9b 05 	sts	0x059B, r1
    2c00:	10 92 9a 05 	sts	0x059A, r1
		sdFifoWritePointer=0;
    2c04:	10 92 9d 05 	sts	0x059D, r1
    2c08:	10 92 9c 05 	sts	0x059C, r1
		sdBytesInFifo=0;
    2c0c:	10 92 9f 05 	sts	0x059F, r1
    2c10:	10 92 9e 05 	sts	0x059E, r1
		
		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    2c14:	83 e0       	ldi	r24, 0x03	; 3
    2c16:	6a e7       	ldi	r22, 0x7A	; 122
    2c18:	70 e0       	ldi	r23, 0x00	; 0
    2c1a:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    2c1e:	89 e0       	ldi	r24, 0x09	; 9
    2c20:	80 93 59 02 	sts	0x0259, r24

		SREG=sreg;	// Resume ISR
    2c24:	df be       	out	0x3f, r13	; 63
    2c26:	81 e0       	ldi	r24, 0x01	; 1
    2c28:	02 c0       	rjmp	.+4      	; 0x2c2e <SdStartSampleRead+0x76>

		return(true);			
	}
	SREG=sreg;	// Resume ISR
    2c2a:	df be       	out	0x3f, r13	; 63
    2c2c:	80 e0       	ldi	r24, 0x00	; 0
	return(false);
}
    2c2e:	1f 91       	pop	r17
    2c30:	0f 91       	pop	r16
    2c32:	ff 90       	pop	r15
    2c34:	ef 90       	pop	r14
    2c36:	df 90       	pop	r13
    2c38:	08 95       	ret

00002c3a <PlaySampleFromSd>:
	}
}

static void PlaySampleFromSd(unsigned char theBank, unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    2c3a:	0f 93       	push	r16
    2c3c:	1f 93       	push	r17
    2c3e:	98 2f       	mov	r25, r24
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    2c40:	80 91 59 02 	lds	r24, 0x0259
    2c44:	8e 30       	cpi	r24, 0x0E	; 14
    2c46:	b9 f4       	brne	.+46     	; 0x2c76 <PlaySampleFromSd+0x3c>
	{		
		sreg=SREG;	 // Pause ISRs 		
    2c48:	1f b7       	in	r17, 0x3f	; 63
		cli();
    2c4a:	f8 94       	cli

		SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    2c4c:	cb 01       	movw	r24, r22
    2c4e:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <SdStartSampleRead>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	a0 e0       	ldi	r26, 0x00	; 0
    2c58:	b0 e0       	ldi	r27, 0x00	; 0
    2c5a:	80 93 a9 05 	sts	0x05A9, r24
    2c5e:	90 93 aa 05 	sts	0x05AA, r25
    2c62:	a0 93 ab 05 	sts	0x05AB, r26
    2c66:	b0 93 ac 05 	sts	0x05AC, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;
	
	sreg=SREG;
    2c6a:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    2c6c:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    2c6e:	83 e0       	ldi	r24, 0x03	; 3
    2c70:	80 93 b5 05 	sts	0x05B5, r24
    2c74:	1c c0       	rjmp	.+56     	; 0x2cae <PlaySampleFromSd+0x74>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    2c76:	00 91 b5 05 	lds	r16, 0x05B5
    2c7a:	03 30       	cpi	r16, 0x03	; 3
    2c7c:	09 f0       	breq	.+2      	; 0x2c80 <PlaySampleFromSd+0x46>
    2c7e:	4d c0       	rjmp	.+154    	; 0x2d1a <PlaySampleFromSd+0xe0>
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    2c80:	8b 30       	cpi	r24, 0x0B	; 11
    2c82:	39 f5       	brne	.+78     	; 0x2cd2 <PlaySampleFromSd+0x98>
		{
			sreg=SREG;	 // Pause ISRs 		
    2c84:	1f b7       	in	r17, 0x3f	; 63
			cli();
    2c86:	f8 94       	cli

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    2c88:	cb 01       	movw	r24, r22
    2c8a:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    2c8e:	81 e0       	ldi	r24, 0x01	; 1
    2c90:	90 e0       	ldi	r25, 0x00	; 0
    2c92:	a0 e0       	ldi	r26, 0x00	; 0
    2c94:	b0 e0       	ldi	r27, 0x00	; 0
    2c96:	80 93 a9 05 	sts	0x05A9, r24
    2c9a:	90 93 aa 05 	sts	0x05AA, r25
    2c9e:	a0 93 ab 05 	sts	0x05AB, r26
    2ca2:	b0 93 ac 05 	sts	0x05AC, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;
	
	sreg=SREG;
    2ca6:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    2ca8:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    2caa:	00 93 b5 05 	sts	0x05B5, r16

	TCNT2=0;			// Init counter reg
    2cae:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
    2cb2:	81 e7       	ldi	r24, 0x71	; 113
    2cb4:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2cb8:	8f ef       	ldi	r24, 0xFF	; 255
    2cba:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2cbc:	80 91 70 00 	lds	r24, 0x0070
    2cc0:	84 60       	ori	r24, 0x04	; 4
    2cc2:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2cc6:	82 e0       	ldi	r24, 0x02	; 2
    2cc8:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs		
    2ccc:	9f bf       	out	0x3f, r25	; 63

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

			SREG=sreg;	// resume isr		
    2cce:	1f bf       	out	0x3f, r17	; 63
    2cd0:	24 c0       	rjmp	.+72     	; 0x2d1a <PlaySampleFromSd+0xe0>
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    2cd2:	8d 30       	cpi	r24, 0x0D	; 13
    2cd4:	21 f0       	breq	.+8      	; 0x2cde <PlaySampleFromSd+0xa4>
    2cd6:	80 91 a4 05 	lds	r24, 0x05A4
    2cda:	81 30       	cpi	r24, 0x01	; 1
    2cdc:	39 f4       	brne	.+14     	; 0x2cec <PlaySampleFromSd+0xb2>
		{
			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
    2cde:	90 93 a0 05 	sts	0x05A0, r25
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block 
    2ce2:	70 93 a2 05 	sts	0x05A2, r23
    2ce6:	60 93 a1 05 	sts	0x05A1, r22
    2cea:	17 c0       	rjmp	.+46     	; 0x2d1a <PlaySampleFromSd+0xe0>
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
    2cec:	90 93 a0 05 	sts	0x05A0, r25
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block 	
    2cf0:	70 93 a2 05 	sts	0x05A2, r23
    2cf4:	60 93 a1 05 	sts	0x05A1, r22
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    2cf8:	81 e0       	ldi	r24, 0x01	; 1
    2cfa:	80 93 a3 05 	sts	0x05A3, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    2cfe:	80 93 a4 05 	sts	0x05A4, r24
					
			sreg=SREG;	 		// Pause ISRs 		
    2d02:	9f b7       	in	r25, 0x3f	; 63
			cli();
    2d04:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    2d06:	10 92 9f 05 	sts	0x059F, r1
    2d0a:	10 92 9e 05 	sts	0x059E, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    2d0e:	80 91 70 00 	lds	r24, 0x0070
    2d12:	8b 7f       	andi	r24, 0xFB	; 251
    2d14:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;						
    2d18:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    2d1a:	1f 91       	pop	r17
    2d1c:	0f 91       	pop	r16
    2d1e:	08 95       	ret

00002d20 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    2d20:	2f 92       	push	r2
    2d22:	3f 92       	push	r3
    2d24:	4f 92       	push	r4
    2d26:	5f 92       	push	r5
    2d28:	6f 92       	push	r6
    2d2a:	7f 92       	push	r7
    2d2c:	8f 92       	push	r8
    2d2e:	9f 92       	push	r9
    2d30:	af 92       	push	r10
    2d32:	bf 92       	push	r11
    2d34:	cf 92       	push	r12
    2d36:	df 92       	push	r13
    2d38:	ef 92       	push	r14
    2d3a:	ff 92       	push	r15
    2d3c:	0f 93       	push	r16
    2d3e:	1f 93       	push	r17
    2d40:	cf 93       	push	r28
    2d42:	df 93       	push	r29
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    2d44:	1f ef       	ldi	r17, 0xFF	; 255
    2d46:	10 93 64 00 	sts	0x0064, r17
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    2d4a:	85 b7       	in	r24, 0x35	; 53
    2d4c:	8f 7e       	andi	r24, 0xEF	; 239
    2d4e:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    2d50:	8f ee       	ldi	r24, 0xEF	; 239
    2d52:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    2d54:	88 e0       	ldi	r24, 0x08	; 8
    2d56:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    2d58:	90 e8       	ldi	r25, 0x80	; 128
    2d5a:	9a b9       	out	0x0a, r25	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    2d5c:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    2d5e:	86 e0       	ldi	r24, 0x06	; 6
    2d60:	82 b9       	out	0x02, r24	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    2d62:	8e e3       	ldi	r24, 0x3E	; 62
    2d64:	81 b9       	out	0x01, r24	; 1

	DDRB=0xFF;			// Latch port to OP.
    2d66:	14 b9       	out	0x04, r17	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    2d68:	95 b9       	out	0x05, r25	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    2d6a:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    2d6c:	14 b9       	out	0x04, r17	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    2d6e:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    2d70:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    2d72:	0e 94 cb 28 	call	0x5196	; 0x5196 <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    2d76:	81 e0       	ldi	r24, 0x01	; 1
    2d78:	66 e2       	ldi	r22, 0x26	; 38
    2d7a:	70 e0       	ldi	r23, 0x00	; 0
    2d7c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    2d80:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    2d82:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    2d84:	80 b1       	in	r24, 0x00	; 0
    2d86:	80 7c       	andi	r24, 0xC0	; 192
    2d88:	80 93 43 01 	sts	0x0143, r24
	encoderValue=0;							// zero our relative position.
    2d8c:	10 92 44 01 	sts	0x0144, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    2d90:	10 92 3b 01 	sts	0x013B, r1
	ledBlinkMask=0;
    2d94:	10 92 3c 01 	sts	0x013C, r1
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2d98:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2d9a:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    2d9c:	15 b8       	out	0x05, r1	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2d9e:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    2da0:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    2da2:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2da4:	8f bf       	out	0x3f, r24	; 63

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    2da6:	0e 94 1d 27 	call	0x4e3a	; 0x4e3a <InitMidi>
	InitUart0();
    2daa:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    2dae:	80 91 64 00 	lds	r24, 0x0064
    2db2:	8e 7f       	andi	r24, 0xFE	; 254
    2db4:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    2db8:	80 e6       	ldi	r24, 0x60	; 96
    2dba:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    2dbe:	81 e0       	ldi	r24, 0x01	; 1
    2dc0:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    2dc4:	85 e9       	ldi	r24, 0x95	; 149
    2dc6:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    2dca:	80 91 7a 00 	lds	r24, 0x007A
    2dce:	80 64       	ori	r24, 0x40	; 64
    2dd0:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    2dd4:	80 91 64 00 	lds	r24, 0x0064
    2dd8:	8f 7d       	andi	r24, 0xDF	; 223
    2dda:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    2dde:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    2de2:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    2de4:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    2de6:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    2de8:	10 92 2d 06 	sts	0x062D, r1
    2dec:	10 92 2c 06 	sts	0x062C, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    2df0:	83 e0       	ldi	r24, 0x03	; 3
    2df2:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    2df4:	80 91 64 00 	lds	r24, 0x0064
    2df8:	87 7f       	andi	r24, 0xF7	; 247
    2dfa:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    2dfe:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    2e02:	8f ef       	ldi	r24, 0xFF	; 255
    2e04:	9f ef       	ldi	r25, 0xFF	; 255
    2e06:	90 93 89 00 	sts	0x0089, r25
    2e0a:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    2e0e:	90 93 8b 00 	sts	0x008B, r25
    2e12:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    2e16:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    2e1a:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    2e1e:	10 92 85 00 	sts	0x0085, r1
    2e22:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    2e26:	16 bb       	out	0x16, r17	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    2e28:	10 92 3f 01 	sts	0x013F, r1
	keyState=0;
    2e2c:	10 92 3e 01 	sts	0x013E, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    2e30:	10 92 59 02 	sts	0x0259, r1
	cardDetect=false;
    2e34:	10 92 40 01 	sts	0x0140, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    2e38:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2e3a:	83 e0       	ldi	r24, 0x03	; 3
    2e3c:	95 e1       	ldi	r25, 0x15	; 21
    2e3e:	90 93 e5 05 	sts	0x05E5, r25
    2e42:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    2e46:	10 92 41 01 	sts	0x0141, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    2e4a:	99 24       	eor	r9, r9
    2e4c:	9a 94       	dec	r9
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    2e4e:	01 e0       	ldi	r16, 0x01	; 1
    2e50:	a0 2e       	mov	r10, r16
    2e52:	b1 2c       	mov	r11, r1
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    2e54:	c1 2c       	mov	r12, r1
    2e56:	12 e0       	ldi	r17, 0x02	; 2
    2e58:	d1 2e       	mov	r13, r17

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    2e5a:	be e0       	ldi	r27, 0x0E	; 14
    2e5c:	8b 2e       	mov	r8, r27
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    2e5e:	ad e0       	ldi	r26, 0x0D	; 13
    2e60:	3a 2e       	mov	r3, r26
				}
				if(theByte==0xFE)	// Got a start token!
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left				

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    2e62:	fa e0       	ldi	r31, 0x0A	; 10
    2e64:	2f 2e       	mov	r2, r31
static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    2e66:	e5 eb       	ldi	r30, 0xB5	; 181
    2e68:	4e 2e       	mov	r4, r30
    2e6a:	e5 e9       	ldi	r30, 0x95	; 149
    2e6c:	5e 2e       	mov	r5, r30
    2e6e:	ea ea       	ldi	r30, 0xAA	; 170
    2e70:	6e 2e       	mov	r6, r30
    2e72:	e0 e2       	ldi	r30, 0x20	; 32
    2e74:	7e 2e       	mov	r7, r30
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2e7c:	88 23       	and	r24, r24
    2e7e:	d9 f0       	breq	.+54     	; 0x2eb6 <main+0x196>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    2e80:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    2e82:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    2e84:	95 b8       	out	0x05, r9	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    2e86:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    2e88:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    2e8a:	00 00       	nop
		asm volatile("nop"::);
    2e8c:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    2e8e:	83 b1       	in	r24, 0x03	; 3
    2e90:	80 95       	com	r24
    2e92:	80 93 3e 01 	sts	0x013E, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    2e96:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    2e98:	94 b8       	out	0x04, r9	; 4
		SREG=sreg;					// Stop tying up interrupts		
    2e9a:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    2e9c:	35 99       	sbic	0x06, 5	; 6
    2e9e:	04 c0       	rjmp	.+8      	; 0x2ea8 <main+0x188>
		{
			cardDetect=true;
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	80 93 40 01 	sts	0x0140, r24
    2ea6:	02 c0       	rjmp	.+4      	; 0x2eac <main+0x18c>
		}
		else
		{
			cardDetect=false;
    2ea8:	10 92 40 01 	sts	0x0140, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)		
    2eac:	81 e0       	ldi	r24, 0x01	; 1
    2eae:	66 e2       	ldi	r22, 0x26	; 38
    2eb0:	70 e0       	ldi	r23, 0x00	; 0
    2eb2:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    2eb6:	80 91 1e 01 	lds	r24, 0x011E
    2eba:	80 95       	com	r24
    2ebc:	90 91 3e 01 	lds	r25, 0x013E
    2ec0:	89 23       	and	r24, r25
    2ec2:	80 93 3f 01 	sts	0x013F, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    2ec6:	90 93 1e 01 	sts	0x011E, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;
		
	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    2eca:	20 91 2c 06 	lds	r18, 0x062C
    2ece:	30 91 2d 06 	lds	r19, 0x062D
    2ed2:	80 91 1f 01 	lds	r24, 0x011F
    2ed6:	90 91 20 01 	lds	r25, 0x0120
    2eda:	28 17       	cp	r18, r24
    2edc:	39 07       	cpc	r19, r25
    2ede:	c1 f1       	breq	.+112    	; 0x2f50 <main+0x230>
	{
		lastEncTime=systemTicks;					// update last read time.
    2ee0:	80 91 2c 06 	lds	r24, 0x062C
    2ee4:	90 91 2d 06 	lds	r25, 0x062D
    2ee8:	90 93 20 01 	sts	0x0120, r25
    2eec:	80 93 1f 01 	sts	0x011F, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    2ef0:	80 b1       	in	r24, 0x00	; 0
    2ef2:	80 7c       	andi	r24, 0xC0	; 192
    2ef4:	80 93 43 01 	sts	0x0143, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    2ef8:	90 91 21 01 	lds	r25, 0x0121
    2efc:	89 17       	cp	r24, r25
    2efe:	41 f1       	breq	.+80     	; 0x2f50 <main+0x230>
		{
			if(encoderState==ENC_POS_A)
    2f00:	88 23       	and	r24, r24
    2f02:	29 f4       	brne	.+10     	; 0x2f0e <main+0x1ee>
			{
				if(lastEncoderState==ENC_POS_D)
    2f04:	90 38       	cpi	r25, 0x80	; 128
    2f06:	a9 f0       	breq	.+42     	; 0x2f32 <main+0x212>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_B)
    2f08:	90 34       	cpi	r25, 0x40	; 64
    2f0a:	f1 f4       	brne	.+60     	; 0x2f48 <main+0x228>
    2f0c:	18 c0       	rjmp	.+48     	; 0x2f3e <main+0x21e>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_B)
    2f0e:	80 34       	cpi	r24, 0x40	; 64
    2f10:	29 f4       	brne	.+10     	; 0x2f1c <main+0x1fc>
			{
				if(lastEncoderState==ENC_POS_A)
    2f12:	99 23       	and	r25, r25
    2f14:	71 f0       	breq	.+28     	; 0x2f32 <main+0x212>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_C)
    2f16:	90 3c       	cpi	r25, 0xC0	; 192
    2f18:	b9 f4       	brne	.+46     	; 0x2f48 <main+0x228>
    2f1a:	11 c0       	rjmp	.+34     	; 0x2f3e <main+0x21e>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_C)
    2f1c:	80 3c       	cpi	r24, 0xC0	; 192
    2f1e:	29 f4       	brne	.+10     	; 0x2f2a <main+0x20a>
			{
				if(lastEncoderState==ENC_POS_B)
    2f20:	90 34       	cpi	r25, 0x40	; 64
    2f22:	39 f0       	breq	.+14     	; 0x2f32 <main+0x212>
				{
//					encoderValue++;
					encoderValue--;
				}
				else if(lastEncoderState==ENC_POS_D)
    2f24:	90 38       	cpi	r25, 0x80	; 128
    2f26:	81 f4       	brne	.+32     	; 0x2f48 <main+0x228>
    2f28:	0a c0       	rjmp	.+20     	; 0x2f3e <main+0x21e>
				{
//					encoderValue--;
					encoderValue++;
				}
			}		
			else if(encoderState==ENC_POS_D)
    2f2a:	80 38       	cpi	r24, 0x80	; 128
    2f2c:	69 f4       	brne	.+26     	; 0x2f48 <main+0x228>
			{
				if(lastEncoderState==ENC_POS_C)
    2f2e:	90 3c       	cpi	r25, 0xC0	; 192
    2f30:	21 f4       	brne	.+8      	; 0x2f3a <main+0x21a>
				{
//					encoderValue++;
					encoderValue--;
    2f32:	80 91 44 01 	lds	r24, 0x0144
    2f36:	81 50       	subi	r24, 0x01	; 1
    2f38:	05 c0       	rjmp	.+10     	; 0x2f44 <main+0x224>
				}
				else if(lastEncoderState==ENC_POS_A)
    2f3a:	99 23       	and	r25, r25
    2f3c:	29 f4       	brne	.+10     	; 0x2f48 <main+0x228>
				{
//					encoderValue--;
					encoderValue++;
    2f3e:	80 91 44 01 	lds	r24, 0x0144
    2f42:	8f 5f       	subi	r24, 0xFF	; 255
    2f44:	80 93 44 01 	sts	0x0144, r24
				}
			}		

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    2f48:	80 91 43 01 	lds	r24, 0x0143
    2f4c:	80 93 21 01 	sts	0x0121, r24

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    2f50:	0e 94 ca 0c 	call	0x1994	; 0x1994 <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    2f54:	80 91 3c 01 	lds	r24, 0x013C
    2f58:	88 23       	and	r24, r24
    2f5a:	09 f4       	brne	.+2      	; 0x2f5e <main+0x23e>
    2f5c:	49 c0       	rjmp	.+146    	; 0x2ff0 <main+0x2d0>
    2f5e:	82 e0       	ldi	r24, 0x02	; 2
    2f60:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    2f64:	88 23       	and	r24, r24
    2f66:	09 f4       	brne	.+2      	; 0x2f6a <main+0x24a>
    2f68:	43 c0       	rjmp	.+134    	; 0x2ff0 <main+0x2d0>
    2f6a:	40 e0       	ldi	r20, 0x00	; 0
    2f6c:	50 e0       	ldi	r21, 0x00	; 0
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    2f6e:	80 91 3c 01 	lds	r24, 0x013C
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	04 2e       	mov	r0, r20
    2f76:	02 c0       	rjmp	.+4      	; 0x2f7c <main+0x25c>
    2f78:	95 95       	asr	r25
    2f7a:	87 95       	ror	r24
    2f7c:	0a 94       	dec	r0
    2f7e:	e2 f7       	brpl	.-8      	; 0x2f78 <main+0x258>
    2f80:	80 ff       	sbrs	r24, 0
    2f82:	1a c0       	rjmp	.+52     	; 0x2fb8 <main+0x298>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    2f84:	80 91 23 01 	lds	r24, 0x0123
    2f88:	20 91 3b 01 	lds	r18, 0x013B
    2f8c:	88 23       	and	r24, r24
    2f8e:	49 f0       	breq	.+18     	; 0x2fa2 <main+0x282>
				{
					ledOnOffMask|=(1<<i);
    2f90:	c5 01       	movw	r24, r10
    2f92:	04 2e       	mov	r0, r20
    2f94:	02 c0       	rjmp	.+4      	; 0x2f9a <main+0x27a>
    2f96:	88 0f       	add	r24, r24
    2f98:	99 1f       	adc	r25, r25
    2f9a:	0a 94       	dec	r0
    2f9c:	e2 f7       	brpl	.-8      	; 0x2f96 <main+0x276>
    2f9e:	28 2b       	or	r18, r24
    2fa0:	09 c0       	rjmp	.+18     	; 0x2fb4 <main+0x294>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    2fa2:	c5 01       	movw	r24, r10
    2fa4:	04 2e       	mov	r0, r20
    2fa6:	02 c0       	rjmp	.+4      	; 0x2fac <main+0x28c>
    2fa8:	88 0f       	add	r24, r24
    2faa:	99 1f       	adc	r25, r25
    2fac:	0a 94       	dec	r0
    2fae:	e2 f7       	brpl	.-8      	; 0x2fa8 <main+0x288>
    2fb0:	80 95       	com	r24
    2fb2:	28 23       	and	r18, r24
    2fb4:	20 93 3b 01 	sts	0x013B, r18
    2fb8:	4f 5f       	subi	r20, 0xFF	; 255
    2fba:	5f 4f       	sbci	r21, 0xFF	; 255
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    2fbc:	48 30       	cpi	r20, 0x08	; 8
    2fbe:	51 05       	cpc	r21, r1
    2fc0:	b1 f6       	brne	.-84     	; 0x2f6e <main+0x24e>
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	80 91 23 01 	lds	r24, 0x0123
    2fc8:	88 23       	and	r24, r24
    2fca:	09 f4       	brne	.+2      	; 0x2fce <main+0x2ae>
    2fcc:	91 e0       	ldi	r25, 0x01	; 1
    2fce:	90 93 23 01 	sts	0x0123, r25
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    2fd2:	82 e0       	ldi	r24, 0x02	; 2
    2fd4:	68 e9       	ldi	r22, 0x98	; 152
    2fd6:	70 e0       	ldi	r23, 0x00	; 0
    2fd8:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    2fdc:	80 91 3b 01 	lds	r24, 0x013B
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2fe0:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2fe2:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    2fe4:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2fe6:	94 b8       	out	0x04, r9	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    2fe8:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    2fea:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2fec:	9f bf       	out	0x3f, r25	; 63
    2fee:	11 c0       	rjmp	.+34     	; 0x3012 <main+0x2f2>

		toggle=(!toggle);						// flip the sign of the led for next time.
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    2ff0:	90 91 3b 01 	lds	r25, 0x013B
    2ff4:	80 91 22 01 	lds	r24, 0x0122
    2ff8:	89 17       	cp	r24, r25
    2ffa:	59 f0       	breq	.+22     	; 0x3012 <main+0x2f2>
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2ffc:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2ffe:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    3000:	95 b9       	out	0x05, r25	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    3002:	94 b8       	out	0x04, r9	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    3004:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    3006:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    3008:	8f bf       	out	0x3f, r24	; 63
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    300a:	80 91 3b 01 	lds	r24, 0x013B
    300e:	80 93 22 01 	sts	0x0122, r24
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    3012:	80 91 40 01 	lds	r24, 0x0140
    3016:	90 91 59 02 	lds	r25, 0x0259
    301a:	88 23       	and	r24, r24
    301c:	21 f4       	brne	.+8      	; 0x3026 <main+0x306>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    301e:	99 23       	and	r25, r25
    3020:	09 f4       	brne	.+2      	; 0x3024 <main+0x304>
    3022:	19 c5       	rjmp	.+2610   	; 0x3a56 <main+0xd36>
    3024:	cf c4       	rjmp	.+2462   	; 0x39c4 <main+0xca4>
			cardState=SD_NOT_PRESENT;		// Mark the card as st elsewhere
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    3026:	96 30       	cpi	r25, 0x06	; 6
    3028:	09 f4       	brne	.+2      	; 0x302c <main+0x30c>
    302a:	6d c2       	rjmp	.+1242   	; 0x3506 <main+0x7e6>
    302c:	97 30       	cpi	r25, 0x07	; 7
    302e:	90 f4       	brcc	.+36     	; 0x3054 <main+0x334>
    3030:	92 30       	cpi	r25, 0x02	; 2
    3032:	09 f4       	brne	.+2      	; 0x3036 <main+0x316>
    3034:	d8 c0       	rjmp	.+432    	; 0x31e6 <main+0x4c6>
    3036:	93 30       	cpi	r25, 0x03	; 3
    3038:	30 f4       	brcc	.+12     	; 0x3046 <main+0x326>
    303a:	99 23       	and	r25, r25
    303c:	09 f1       	breq	.+66     	; 0x3080 <main+0x360>
    303e:	91 30       	cpi	r25, 0x01	; 1
    3040:	09 f0       	breq	.+2      	; 0x3044 <main+0x324>
    3042:	09 c5       	rjmp	.+2578   	; 0x3a56 <main+0xd36>
    3044:	26 c0       	rjmp	.+76     	; 0x3092 <main+0x372>
    3046:	94 30       	cpi	r25, 0x04	; 4
    3048:	09 f4       	brne	.+2      	; 0x304c <main+0x32c>
    304a:	c5 c1       	rjmp	.+906    	; 0x33d6 <main+0x6b6>
    304c:	95 30       	cpi	r25, 0x05	; 5
    304e:	08 f0       	brcs	.+2      	; 0x3052 <main+0x332>
    3050:	0e c2       	rjmp	.+1052   	; 0x346e <main+0x74e>
    3052:	3e c1       	rjmp	.+636    	; 0x32d0 <main+0x5b0>
    3054:	9a 30       	cpi	r25, 0x0A	; 10
    3056:	09 f4       	brne	.+2      	; 0x305a <main+0x33a>
    3058:	a4 c3       	rjmp	.+1864   	; 0x37a2 <main+0xa82>
    305a:	9b 30       	cpi	r25, 0x0B	; 11
    305c:	38 f4       	brcc	.+14     	; 0x306c <main+0x34c>
    305e:	98 30       	cpi	r25, 0x08	; 8
    3060:	09 f4       	brne	.+2      	; 0x3064 <main+0x344>
    3062:	db c2       	rjmp	.+1462   	; 0x361a <main+0x8fa>
    3064:	99 30       	cpi	r25, 0x09	; 9
    3066:	08 f0       	brcs	.+2      	; 0x306a <main+0x34a>
    3068:	fc c2       	rjmp	.+1528   	; 0x3662 <main+0x942>
    306a:	9d c2       	rjmp	.+1338   	; 0x35a6 <main+0x886>
    306c:	9c 30       	cpi	r25, 0x0C	; 12
    306e:	09 f4       	brne	.+2      	; 0x3072 <main+0x352>
    3070:	7d c4       	rjmp	.+2298   	; 0x396c <main+0xc4c>
    3072:	9c 30       	cpi	r25, 0x0C	; 12
    3074:	08 f4       	brcc	.+2      	; 0x3078 <main+0x358>
    3076:	2c c4       	rjmp	.+2136   	; 0x38d0 <main+0xbb0>
    3078:	9d 30       	cpi	r25, 0x0D	; 13
    307a:	09 f0       	breq	.+2      	; 0x307e <main+0x35e>
    307c:	ec c4       	rjmp	.+2520   	; 0x3a56 <main+0xd36>
    307e:	a5 c4       	rjmp	.+2378   	; 0x39ca <main+0xcaa>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	80 93 59 02 	sts	0x0259, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    3086:	83 e0       	ldi	r24, 0x03	; 3
    3088:	64 ec       	ldi	r22, 0xC4	; 196
    308a:	74 e0       	ldi	r23, 0x04	; 4
    308c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
    3090:	e2 c4       	rjmp	.+2500   	; 0x3a56 <main+0xd36>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    3092:	83 e0       	ldi	r24, 0x03	; 3
    3094:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    3098:	88 23       	and	r24, r24
    309a:	09 f4       	brne	.+2      	; 0x309e <main+0x37e>
    309c:	dc c4       	rjmp	.+2488   	; 0x3a56 <main+0xd36>
			{
				sdPlaybackQueued=false;	
    309e:	10 92 a3 05 	sts	0x05A3, r1
				sdAbortRead=false;			
    30a2:	10 92 a4 05 	sts	0x05A4, r1

				if(SdHandshake()==true)	// Give it a shot...
    30a6:	0e 94 45 2a 	call	0x548a	; 0x548a <SdHandshake>
    30aa:	81 30       	cpi	r24, 0x01	; 1
    30ac:	09 f0       	breq	.+2      	; 0x30b0 <main+0x390>
    30ae:	97 c0       	rjmp	.+302    	; 0x31de <main+0x4be>
	// Are the first 4 chars WTPA?
	// Stop reading, return true or false based on answer.
	
	filesystemGood=true;					// Start assuming a good filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    30b0:	60 e0       	ldi	r22, 0x00	; 0
    30b2:	70 e0       	ldi	r23, 0x00	; 0
    30b4:	80 e0       	ldi	r24, 0x00	; 0
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	0e 94 21 2a 	call	0x5442	; 0x5442 <SdBeginSingleBlockRead>
    30bc:	81 30       	cpi	r24, 0x01	; 1
    30be:	11 f0       	breq	.+4      	; 0x30c4 <main+0x3a4>
    30c0:	10 e0       	ldi	r17, 0x00	; 0
    30c2:	56 c0       	rjmp	.+172    	; 0x3170 <main+0x450>
 		// Tue Jun 21 17:11:28 EDT 2011 
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --  
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    30c4:	83 e0       	ldi	r24, 0x03	; 3
    30c6:	6a e7       	ldi	r22, 0x7A	; 122
    30c8:	70 e0       	ldi	r23, 0x00	; 0
    30ca:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
    30ce:	02 c0       	rjmp	.+4      	; 0x30d4 <main+0x3b4>
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    30d0:	0e 94 ca 0c 	call	0x1994	; 0x1994 <HandleSoftclock>
		// So --  
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
		
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    30d4:	83 e0       	ldi	r24, 0x03	; 3
    30d6:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    30da:	88 23       	and	r24, r24
    30dc:	29 f4       	brne	.+10     	; 0x30e8 <main+0x3c8>
    30de:	8f ef       	ldi	r24, 0xFF	; 255
    30e0:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    30e4:	8e 3f       	cpi	r24, 0xFE	; 254
    30e6:	a1 f7       	brne	.-24     	; 0x30d0 <main+0x3b0>
		{
			HandleSoftclock();	// Kludgy
		}

		// Check the first 4 characters
		theByte=TransferSdByte(DUMMY_BYTE);
    30e8:	8f ef       	ldi	r24, 0xFF	; 255
    30ea:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    30ee:	08 2f       	mov	r16, r24
		if(theByte!='W')
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    30f0:	8f ef       	ldi	r24, 0xFF	; 255
    30f2:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
		if(theByte!='T')
    30f6:	84 35       	cpi	r24, 0x54	; 84
    30f8:	11 f0       	breq	.+4      	; 0x30fe <main+0x3de>
    30fa:	10 e0       	ldi	r17, 0x00	; 0
    30fc:	04 c0       	rjmp	.+8      	; 0x3106 <main+0x3e6>
    30fe:	10 e0       	ldi	r17, 0x00	; 0
    3100:	07 35       	cpi	r16, 0x57	; 87
    3102:	09 f4       	brne	.+2      	; 0x3106 <main+0x3e6>
    3104:	11 e0       	ldi	r17, 0x01	; 1
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    3106:	8f ef       	ldi	r24, 0xFF	; 255
    3108:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
		if(theByte!='P')
    310c:	80 35       	cpi	r24, 0x50	; 80
    310e:	09 f0       	breq	.+2      	; 0x3112 <main+0x3f2>
    3110:	10 e0       	ldi	r17, 0x00	; 0
		{
			filesystemGood=false;
		}
		
		theByte=TransferSdByte(DUMMY_BYTE);
    3112:	8f ef       	ldi	r24, 0xFF	; 255
    3114:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
		if(theByte!='A')
    3118:	81 34       	cpi	r24, 0x41	; 65
    311a:	09 f0       	breq	.+2      	; 0x311e <main+0x3fe>
    311c:	10 e0       	ldi	r17, 0x00	; 0
    311e:	c0 e0       	ldi	r28, 0x00	; 0
    3120:	d0 e0       	ldi	r29, 0x00	; 0
// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
		{
			TransferSdByte(0xFF);
    3122:	8f ef       	ldi	r24, 0xFF	; 255
    3124:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
		}

// Sat Nov 12 16:38:20 EST 2011
// Update the following don't cares for nintendo formatted cards for AMR's DPCM reading functions, and update the return value to be a char which indicates the TYPE of card.

		for(i=0;i<12;i++)					// 12 don't care bytes
    3128:	21 96       	adiw	r28, 0x01	; 1
    312a:	cc 30       	cpi	r28, 0x0C	; 12
    312c:	d1 05       	cpc	r29, r1
    312e:	c9 f7       	brne	.-14     	; 0x3122 <main+0x402>
		{
			TransferSdByte(0xFF);
		}
		
		if(filesystemGood==true)			// Load TOC if this is a legit card
    3130:	11 30       	cpi	r17, 0x01	; 1
    3132:	59 f4       	brne	.+22     	; 0x314a <main+0x42a>
    3134:	ca e5       	ldi	r28, 0x5A	; 90
    3136:	d2 e0       	ldi	r29, 0x02	; 2
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    3138:	8f ef       	ldi	r24, 0xFF	; 255
    313a:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    313e:	89 93       	st	Y+, r24
			TransferSdByte(0xFF);
		}
		
		if(filesystemGood==true)			// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    3140:	22 e0       	ldi	r18, 0x02	; 2
    3142:	ca 39       	cpi	r28, 0x9A	; 154
    3144:	d2 07       	cpc	r29, r18
    3146:	c1 f7       	brne	.-16     	; 0x3138 <main+0x418>
    3148:	09 c0       	rjmp	.+18     	; 0x315c <main+0x43c>
    314a:	c0 e0       	ldi	r28, 0x00	; 0
    314c:	d0 e0       	ldi	r29, 0x00	; 0
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    314e:	8f ef       	ldi	r24, 0xFF	; 255
    3150:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}		
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    3154:	21 96       	adiw	r28, 0x01	; 1
    3156:	c0 34       	cpi	r28, 0x40	; 64
    3158:	d1 05       	cpc	r29, r1
    315a:	c9 f7       	brne	.-14     	; 0x314e <main+0x42e>
    315c:	c0 e0       	ldi	r28, 0x00	; 0
    315e:	d0 e0       	ldi	r29, 0x00	; 0
			}		
		
		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    3160:	8f ef       	ldi	r24, 0xFF	; 255
    3162:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
			{
				TransferSdByte(0xFF);
			}		
		
		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    3166:	21 96       	adiw	r28, 0x01	; 1
    3168:	31 e0       	ldi	r19, 0x01	; 1
    316a:	c2 3b       	cpi	r28, 0xB2	; 178
    316c:	d3 07       	cpc	r29, r19
    316e:	c1 f7       	brne	.-16     	; 0x3160 <main+0x440>
	}	
	else
	{
		filesystemGood=false;	// Error issuing read command
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    3170:	80 91 c8 00 	lds	r24, 0x00C8
    3174:	86 ff       	sbrs	r24, 6
    3176:	fc cf       	rjmp	.-8      	; 0x3170 <main+0x450>
		;

	EndSdTransfer();				// Bring CS high
    3178:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    317c:	8f ef       	ldi	r24, 0xFF	; 255
    317e:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				sdPlaybackQueued=false;	
				sdAbortRead=false;			

				if(SdHandshake()==true)	// Give it a shot...
				{
					if(GetCardFilesystem()==true)	// Yep, it's an SD card.  See if it already has the correct filesystem, and if so, get the TOC as well.
    3182:	11 30       	cpi	r17, 0x01	; 1
    3184:	c9 f4       	brne	.+50     	; 0x31b8 <main+0x498>
					{
						cardState=SD_IDLE;		// Card is legit and ready to go.
    3186:	80 92 59 02 	sts	0x0259, r8
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.	
    318a:	80 91 64 00 	lds	r24, 0x0064
    318e:	8f 7b       	andi	r24, 0xBF	; 191
    3190:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.	
    3194:	82 e0       	ldi	r24, 0x02	; 2
    3196:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    319a:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    319e:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    31a2:	81 e7       	ldi	r24, 0x71	; 113
    31a4:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    31a8:	97 ba       	out	0x17, r9	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    31aa:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    31ae:	10 92 b5 05 	sts	0x05B5, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    31b2:	10 92 bf 05 	sts	0x05BF, r1
    31b6:	4f c4       	rjmp	.+2206   	; 0x3a56 <main+0xd36>
						cardState=SD_IDLE;		// Card is legit and ready to go.
						InitSdIsr();			// Enable the timers necessary to give the SD card its own IRQ	
					}
					else	// Valid card, but invalid filesystem.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    31b8:	9f e0       	ldi	r25, 0x0F	; 15
    31ba:	90 93 59 02 	sts	0x0259, r25
    31be:	ea e5       	ldi	r30, 0x5A	; 90
    31c0:	f2 e0       	ldi	r31, 0x02	; 2
	unsigned char
		i;
	
	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"	
    31c2:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;
	
	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    31c4:	22 e0       	ldi	r18, 0x02	; 2
    31c6:	ea 39       	cpi	r30, 0x9A	; 154
    31c8:	f2 07       	cpc	r31, r18
    31ca:	d9 f7       	brne	.-10     	; 0x31c2 <main+0x4a2>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    31cc:	86 e2       	ldi	r24, 0x26	; 38
    31ce:	94 e1       	ldi	r25, 0x14	; 20
    31d0:	90 93 e5 05 	sts	0x05E5, r25
    31d4:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    31d8:	10 92 41 01 	sts	0x0141, r1
    31dc:	3c c4       	rjmp	.+2168   	; 0x3a56 <main+0xd36>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    31de:	9f e0       	ldi	r25, 0x0F	; 15
    31e0:	90 93 59 02 	sts	0x0259, r25
    31e4:	38 c4       	rjmp	.+2160   	; 0x3a56 <main+0xd36>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    31e6:	6f b7       	in	r22, 0x3f	; 63
			cli();
    31e8:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    31ea:	80 91 9e 05 	lds	r24, 0x059E
    31ee:	90 91 9f 05 	lds	r25, 0x059F
    31f2:	80 50       	subi	r24, 0x00	; 0
    31f4:	92 40       	sbci	r25, 0x02	; 2
    31f6:	a0 f4       	brcc	.+40     	; 0x3220 <main+0x500>
    31f8:	80 91 9e 05 	lds	r24, 0x059E
    31fc:	90 91 9f 05 	lds	r25, 0x059F
    3200:	20 91 ad 05 	lds	r18, 0x05AD
    3204:	30 91 ae 05 	lds	r19, 0x05AE
    3208:	40 91 af 05 	lds	r20, 0x05AF
    320c:	50 91 b0 05 	lds	r21, 0x05B0
    3210:	a0 e0       	ldi	r26, 0x00	; 0
    3212:	b0 e0       	ldi	r27, 0x00	; 0
    3214:	82 17       	cp	r24, r18
    3216:	93 07       	cpc	r25, r19
    3218:	a4 07       	cpc	r26, r20
    321a:	b5 07       	cpc	r27, r21
    321c:	08 f4       	brcc	.+2      	; 0x3220 <main+0x500>
    321e:	a4 c3       	rjmp	.+1864   	; 0x3968 <main+0xc48>
			{
				SREG=sreg;	// Done reading ISR variables.
    3220:	6f bf       	out	0x3f, r22	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    3222:	60 91 a5 05 	lds	r22, 0x05A5
    3226:	70 91 a6 05 	lds	r23, 0x05A6
    322a:	80 91 a7 05 	lds	r24, 0x05A7
    322e:	90 91 a8 05 	lds	r25, 0x05A8
    3232:	0e 94 33 2a 	call	0x5466	; 0x5466 <SdBeginSingleBlockWrite>
    3236:	81 30       	cpi	r24, 0x01	; 1
    3238:	09 f0       	breq	.+2      	; 0x323c <main+0x51c>
    323a:	c4 c3       	rjmp	.+1928   	; 0x39c4 <main+0xca4>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    323c:	d0 92 25 01 	sts	0x0125, r13
    3240:	c0 92 24 01 	sts	0x0124, r12

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    3244:	8f ef       	ldi	r24, 0xFF	; 255
    3246:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    324a:	8f ef       	ldi	r24, 0xFF	; 255
    324c:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    3250:	8e ef       	ldi	r24, 0xFE	; 254
    3252:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    3256:	80 91 ad 05 	lds	r24, 0x05AD
    325a:	90 91 ae 05 	lds	r25, 0x05AE
    325e:	a0 91 af 05 	lds	r26, 0x05AF
    3262:	b0 91 b0 05 	lds	r27, 0x05B0
    3266:	8b 2f       	mov	r24, r27
    3268:	99 27       	eor	r25, r25
    326a:	aa 27       	eor	r26, r26
    326c:	bb 27       	eor	r27, r27
    326e:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    3272:	80 91 ad 05 	lds	r24, 0x05AD
    3276:	90 91 ae 05 	lds	r25, 0x05AE
    327a:	a0 91 af 05 	lds	r26, 0x05AF
    327e:	b0 91 b0 05 	lds	r27, 0x05B0
    3282:	cd 01       	movw	r24, r26
    3284:	aa 27       	eor	r26, r26
    3286:	bb 27       	eor	r27, r27
    3288:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    328c:	80 91 ad 05 	lds	r24, 0x05AD
    3290:	90 91 ae 05 	lds	r25, 0x05AE
    3294:	a0 91 af 05 	lds	r26, 0x05AF
    3298:	b0 91 b0 05 	lds	r27, 0x05B0
    329c:	89 2f       	mov	r24, r25
    329e:	9a 2f       	mov	r25, r26
    32a0:	ab 2f       	mov	r26, r27
    32a2:	bb 27       	eor	r27, r27
    32a4:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    32a8:	80 91 ad 05 	lds	r24, 0x05AD
    32ac:	90 91 ae 05 	lds	r25, 0x05AE
    32b0:	a0 91 af 05 	lds	r26, 0x05AF
    32b4:	b0 91 b0 05 	lds	r27, 0x05B0
    32b8:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    32bc:	80 91 24 01 	lds	r24, 0x0124
    32c0:	90 91 25 01 	lds	r25, 0x0125
    32c4:	04 97       	sbiw	r24, 0x04	; 4
    32c6:	90 93 25 01 	sts	0x0125, r25
    32ca:	80 93 24 01 	sts	0x0124, r24
    32ce:	17 c1       	rjmp	.+558    	; 0x34fe <main+0x7de>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
				}
			}
			else	// Fifo not ready yet
			{
				SREG=sreg;	// Turn ISR back on
    32d0:	c0 91 24 01 	lds	r28, 0x0124
    32d4:	d0 91 25 01 	lds	r29, 0x0125
    32d8:	c1 34       	cpi	r28, 0x41	; 65
    32da:	d1 05       	cpc	r29, r1
    32dc:	10 f0       	brcs	.+4      	; 0x32e2 <main+0x5c2>
    32de:	c0 e4       	ldi	r28, 0x40	; 64
    32e0:	d0 e0       	ldi	r29, 0x00	; 0
    32e2:	10 e0       	ldi	r17, 0x00	; 0
    32e4:	57 c0       	rjmp	.+174    	; 0x3394 <main+0x674>
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
			{														
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    32e6:	80 91 ad 05 	lds	r24, 0x05AD
    32ea:	90 91 ae 05 	lds	r25, 0x05AE
    32ee:	a0 91 af 05 	lds	r26, 0x05AF
    32f2:	b0 91 b0 05 	lds	r27, 0x05B0
    32f6:	00 97       	sbiw	r24, 0x00	; 0
    32f8:	a1 05       	cpc	r26, r1
    32fa:	b1 05       	cpc	r27, r1
    32fc:	09 f4       	brne	.+2      	; 0x3300 <main+0x5e0>
    32fe:	3d c0       	rjmp	.+122    	; 0x337a <main+0x65a>
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD 
    3300:	e0 91 9a 05 	lds	r30, 0x059A
    3304:	f0 91 9b 05 	lds	r31, 0x059B
    3308:	e6 56       	subi	r30, 0x66	; 102
    330a:	fd 4f       	sbci	r31, 0xFD	; 253
    330c:	80 81       	ld	r24, Z
    330e:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    3312:	80 91 ad 05 	lds	r24, 0x05AD
    3316:	90 91 ae 05 	lds	r25, 0x05AE
    331a:	a0 91 af 05 	lds	r26, 0x05AF
    331e:	b0 91 b0 05 	lds	r27, 0x05B0
    3322:	01 97       	sbiw	r24, 0x01	; 1
    3324:	a1 09       	sbc	r26, r1
    3326:	b1 09       	sbc	r27, r1
    3328:	80 93 ad 05 	sts	0x05AD, r24
    332c:	90 93 ae 05 	sts	0x05AE, r25
    3330:	a0 93 af 05 	sts	0x05AF, r26
    3334:	b0 93 b0 05 	sts	0x05B0, r27

					sdFifoReadPointer++;			// Move to next spot in fifo									
    3338:	80 91 9a 05 	lds	r24, 0x059A
    333c:	90 91 9b 05 	lds	r25, 0x059B
    3340:	01 96       	adiw	r24, 0x01	; 1
    3342:	90 93 9b 05 	sts	0x059B, r25
    3346:	80 93 9a 05 	sts	0x059A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    334a:	80 91 9a 05 	lds	r24, 0x059A
    334e:	90 91 9b 05 	lds	r25, 0x059B
    3352:	80 50       	subi	r24, 0x00	; 0
    3354:	93 40       	sbci	r25, 0x03	; 3
    3356:	20 f0       	brcs	.+8      	; 0x3360 <main+0x640>
					{
						sdFifoReadPointer=0;
    3358:	10 92 9b 05 	sts	0x059B, r1
    335c:	10 92 9a 05 	sts	0x059A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    3360:	2f b7       	in	r18, 0x3f	; 63
					cli();
    3362:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    3364:	80 91 9e 05 	lds	r24, 0x059E
    3368:	90 91 9f 05 	lds	r25, 0x059F
    336c:	01 97       	sbiw	r24, 0x01	; 1
    336e:	90 93 9f 05 	sts	0x059F, r25
    3372:	80 93 9e 05 	sts	0x059E, r24
					SREG=sreg;
    3376:	2f bf       	out	0x3f, r18	; 63
    3378:	03 c0       	rjmp	.+6      	; 0x3380 <main+0x660>
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    337a:	8f ef       	ldi	r24, 0xFF	; 255
    337c:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    3380:	80 91 24 01 	lds	r24, 0x0124
    3384:	90 91 25 01 	lds	r25, 0x0125
    3388:	01 97       	sbiw	r24, 0x01	; 1
    338a:	90 93 25 01 	sts	0x0125, r25
    338e:	80 93 24 01 	sts	0x0124, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    3392:	1f 5f       	subi	r17, 0xFF	; 255
    3394:	81 2f       	mov	r24, r17
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	8c 17       	cp	r24, r28
    339a:	9d 07       	cpc	r25, r29
    339c:	08 f4       	brcc	.+2      	; 0x33a0 <main+0x680>
    339e:	a3 cf       	rjmp	.-186    	; 0x32e6 <main+0x5c6>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    33a0:	80 91 24 01 	lds	r24, 0x0124
    33a4:	90 91 25 01 	lds	r25, 0x0125
    33a8:	89 2b       	or	r24, r25
    33aa:	09 f0       	breq	.+2      	; 0x33ae <main+0x68e>
    33ac:	54 c3       	rjmp	.+1704   	; 0x3a56 <main+0xd36>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    33ae:	8f ef       	ldi	r24, 0xFF	; 255
    33b0:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    33b4:	8f ef       	ldi	r24, 0xFF	; 255
    33b6:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code	
    33ba:	8f ef       	ldi	r24, 0xFF	; 255
    33bc:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    33c0:	8f 71       	andi	r24, 0x1F	; 31
    33c2:	85 30       	cpi	r24, 0x05	; 5
    33c4:	09 f0       	breq	.+2      	; 0x33c8 <main+0x6a8>
    33c6:	fe c2       	rjmp	.+1532   	; 0x39c4 <main+0xca4>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    33c8:	83 e0       	ldi	r24, 0x03	; 3
    33ca:	62 e6       	ldi	r22, 0x62	; 98
    33cc:	72 e0       	ldi	r23, 0x02	; 2
    33ce:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    33d2:	24 e0       	ldi	r18, 0x04	; 4
    33d4:	85 c3       	rjmp	.+1802   	; 0x3ae0 <main+0xdc0>
				}	
			}
			break;
			
			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    33d6:	83 e0       	ldi	r24, 0x03	; 3
    33d8:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    33dc:	88 23       	and	r24, r24
    33de:	09 f0       	breq	.+2      	; 0x33e2 <main+0x6c2>
    33e0:	f1 c2       	rjmp	.+1506   	; 0x39c4 <main+0xca4>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    33e2:	8f ef       	ldi	r24, 0xFF	; 255
    33e4:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    33e8:	8f 3f       	cpi	r24, 0xFF	; 255
    33ea:	09 f4       	brne	.+2      	; 0x33ee <main+0x6ce>
    33ec:	7c c3       	rjmp	.+1784   	; 0x3ae6 <main+0xdc6>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    33ee:	8f ef       	ldi	r24, 0xFF	; 255
    33f0:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    33f4:	8f 3f       	cpi	r24, 0xFF	; 255
    33f6:	09 f4       	brne	.+2      	; 0x33fa <main+0x6da>
    33f8:	76 c3       	rjmp	.+1772   	; 0x3ae6 <main+0xdc6>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    33fa:	8f ef       	ldi	r24, 0xFF	; 255
    33fc:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    3400:	8f 3f       	cpi	r24, 0xFF	; 255
    3402:	09 f4       	brne	.+2      	; 0x3406 <main+0x6e6>
    3404:	70 c3       	rjmp	.+1760   	; 0x3ae6 <main+0xdc6>
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3406:	8f ef       	ldi	r24, 0xFF	; 255
    3408:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    340c:	8f 3f       	cpi	r24, 0xFF	; 255
    340e:	09 f0       	breq	.+2      	; 0x3412 <main+0x6f2>
    3410:	22 c3       	rjmp	.+1604   	; 0x3a56 <main+0xd36>
    3412:	69 c3       	rjmp	.+1746   	; 0x3ae6 <main+0xdc6>
				
				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    3414:	80 91 c8 00 	lds	r24, 0x00C8
    3418:	86 ff       	sbrs	r24, 6
    341a:	fc cf       	rjmp	.-8      	; 0x3414 <main+0x6f4>
						;				
					
					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    341c:	80 91 ad 05 	lds	r24, 0x05AD
    3420:	90 91 ae 05 	lds	r25, 0x05AE
    3424:	a0 91 af 05 	lds	r26, 0x05AF
    3428:	b0 91 b0 05 	lds	r27, 0x05B0
    342c:	00 97       	sbiw	r24, 0x00	; 0
    342e:	a1 05       	cpc	r26, r1
    3430:	b1 05       	cpc	r27, r1
    3432:	11 f0       	breq	.+4      	; 0x3438 <main+0x718>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    3434:	35 e0       	ldi	r19, 0x05	; 5
    3436:	ee c0       	rjmp	.+476    	; 0x3614 <main+0x8f4>
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    3438:	20 91 b1 05 	lds	r18, 0x05B1
    343c:	30 91 b2 05 	lds	r19, 0x05B2
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    3440:	c9 01       	movw	r24, r18
    3442:	43 e0       	ldi	r20, 0x03	; 3
    3444:	96 95       	lsr	r25
    3446:	87 95       	ror	r24
    3448:	4a 95       	dec	r20
    344a:	e1 f7       	brne	.-8      	; 0x3444 <main+0x724>
    344c:	e8 2f       	mov	r30, r24
    344e:	f0 e0       	ldi	r31, 0x00	; 0
    3450:	e6 5a       	subi	r30, 0xA6	; 166
    3452:	fd 4f       	sbci	r31, 0xFD	; 253
    3454:	30 81       	ld	r19, Z
    3456:	27 70       	andi	r18, 0x07	; 7
    3458:	83 2f       	mov	r24, r19
    345a:	90 e0       	ldi	r25, 0x00	; 0
    345c:	02 2e       	mov	r0, r18
    345e:	02 c0       	rjmp	.+4      	; 0x3464 <main+0x744>
    3460:	95 95       	asr	r25
    3462:	87 95       	ror	r24
    3464:	0a 94       	dec	r0
    3466:	e2 f7       	brpl	.-8      	; 0x3460 <main+0x740>
    3468:	80 ff       	sbrs	r24, 0
    346a:	31 c3       	rjmp	.+1634   	; 0x3ace <main+0xdae>
    346c:	2e c2       	rjmp	.+1116   	; 0x38ca <main+0xbaa>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    346e:	6f b7       	in	r22, 0x3f	; 63
			cli();
    3470:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    3472:	80 91 9e 05 	lds	r24, 0x059E
    3476:	90 91 9f 05 	lds	r25, 0x059F
    347a:	80 50       	subi	r24, 0x00	; 0
    347c:	92 40       	sbci	r25, 0x02	; 2
    347e:	a0 f4       	brcc	.+40     	; 0x34a8 <main+0x788>
    3480:	80 91 9e 05 	lds	r24, 0x059E
    3484:	90 91 9f 05 	lds	r25, 0x059F
    3488:	20 91 ad 05 	lds	r18, 0x05AD
    348c:	30 91 ae 05 	lds	r19, 0x05AE
    3490:	40 91 af 05 	lds	r20, 0x05AF
    3494:	50 91 b0 05 	lds	r21, 0x05B0
    3498:	a0 e0       	ldi	r26, 0x00	; 0
    349a:	b0 e0       	ldi	r27, 0x00	; 0
    349c:	82 17       	cp	r24, r18
    349e:	93 07       	cpc	r25, r19
    34a0:	a4 07       	cpc	r26, r20
    34a2:	b5 07       	cpc	r27, r21
    34a4:	08 f4       	brcc	.+2      	; 0x34a8 <main+0x788>
    34a6:	60 c2       	rjmp	.+1216   	; 0x3968 <main+0xc48>
			{
				SREG=sreg;																	// Done reading ISR variables.
    34a8:	6f bf       	out	0x3f, r22	; 63
				sdCurrentBlockOffset++;		// On to the next
    34aa:	60 91 b3 05 	lds	r22, 0x05B3
    34ae:	70 91 b4 05 	lds	r23, 0x05B4
    34b2:	6f 5f       	subi	r22, 0xFF	; 255
    34b4:	7f 4f       	sbci	r23, 0xFF	; 255
    34b6:	70 93 b4 05 	sts	0x05B4, r23
    34ba:	60 93 b3 05 	sts	0x05B3, r22

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    34be:	80 e0       	ldi	r24, 0x00	; 0
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	20 91 a5 05 	lds	r18, 0x05A5
    34c6:	30 91 a6 05 	lds	r19, 0x05A6
    34ca:	40 91 a7 05 	lds	r20, 0x05A7
    34ce:	50 91 a8 05 	lds	r21, 0x05A8
    34d2:	62 0f       	add	r22, r18
    34d4:	73 1f       	adc	r23, r19
    34d6:	84 1f       	adc	r24, r20
    34d8:	95 1f       	adc	r25, r21
    34da:	0e 94 33 2a 	call	0x5466	; 0x5466 <SdBeginSingleBlockWrite>
    34de:	81 30       	cpi	r24, 0x01	; 1
    34e0:	09 f0       	breq	.+2      	; 0x34e4 <main+0x7c4>
    34e2:	70 c2       	rjmp	.+1248   	; 0x39c4 <main+0xca4>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    34e4:	d0 92 25 01 	sts	0x0125, r13
    34e8:	c0 92 24 01 	sts	0x0124, r12

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    34ec:	8f ef       	ldi	r24, 0xFF	; 255
    34ee:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    34f2:	8f ef       	ldi	r24, 0xFF	; 255
    34f4:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    34f8:	8e ef       	ldi	r24, 0xFE	; 254
    34fa:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    34fe:	83 e0       	ldi	r24, 0x03	; 3
    3500:	80 93 59 02 	sts	0x0259, r24
    3504:	a8 c2       	rjmp	.+1360   	; 0x3a56 <main+0xd36>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    3506:	60 e0       	ldi	r22, 0x00	; 0
    3508:	70 e0       	ldi	r23, 0x00	; 0
    350a:	80 e0       	ldi	r24, 0x00	; 0
    350c:	90 e0       	ldi	r25, 0x00	; 0
    350e:	0e 94 33 2a 	call	0x5466	; 0x5466 <SdBeginSingleBlockWrite>
    3512:	81 30       	cpi	r24, 0x01	; 1
    3514:	09 f0       	breq	.+2      	; 0x3518 <main+0x7f8>
    3516:	56 c2       	rjmp	.+1196   	; 0x39c4 <main+0xca4>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    3518:	d0 92 25 01 	sts	0x0125, r13
    351c:	c0 92 24 01 	sts	0x0124, r12

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    3520:	8f ef       	ldi	r24, 0xFF	; 255
    3522:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    3526:	8f ef       	ldi	r24, 0xFF	; 255
    3528:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    352c:	8e ef       	ldi	r24, 0xFE	; 254
    352e:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte('W');				// Send flag that this is a WTPA card
    3532:	87 e5       	ldi	r24, 0x57	; 87
    3534:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte('T');
    3538:	84 e5       	ldi	r24, 0x54	; 84
    353a:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte('P');
    353e:	80 e5       	ldi	r24, 0x50	; 80
    3540:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte('A');
    3544:	81 e4       	ldi	r24, 0x41	; 65
    3546:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				
				bytesLeftInBlock-=4;
    354a:	80 91 24 01 	lds	r24, 0x0124
    354e:	90 91 25 01 	lds	r25, 0x0125
    3552:	04 97       	sbiw	r24, 0x04	; 4
    3554:	90 93 25 01 	sts	0x0125, r25
    3558:	80 93 24 01 	sts	0x0124, r24
    355c:	10 e0       	ldi	r17, 0x00	; 0

				for(i=0;i<12;i++)					// 12 don't care bytes
				{
					TransferSdByte('x');
    355e:	88 e7       	ldi	r24, 0x78	; 120
    3560:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte('P');
				TransferSdByte('A');
				
				bytesLeftInBlock-=4;

				for(i=0;i<12;i++)					// 12 don't care bytes
    3564:	1f 5f       	subi	r17, 0xFF	; 255
    3566:	1c 30       	cpi	r17, 0x0C	; 12
    3568:	d1 f7       	brne	.-12     	; 0x355e <main+0x83e>
				{
					TransferSdByte('x');
				}
				
				bytesLeftInBlock-=12;
    356a:	80 91 24 01 	lds	r24, 0x0124
    356e:	90 91 25 01 	lds	r25, 0x0125
    3572:	0c 97       	sbiw	r24, 0x0c	; 12
    3574:	90 93 25 01 	sts	0x0125, r25
    3578:	80 93 24 01 	sts	0x0124, r24
    357c:	ca e5       	ldi	r28, 0x5A	; 90
    357e:	d2 e0       	ldi	r29, 0x02	; 2

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    3580:	89 91       	ld	r24, Y+
    3582:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte('x');
				}
				
				bytesLeftInBlock-=12;

				for(i=0;i<64;i++)					// Write table of contents.
    3586:	f2 e0       	ldi	r31, 0x02	; 2
    3588:	ca 39       	cpi	r28, 0x9A	; 154
    358a:	df 07       	cpc	r29, r31
    358c:	c9 f7       	brne	.-14     	; 0x3580 <main+0x860>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    358e:	80 91 24 01 	lds	r24, 0x0124
    3592:	90 91 25 01 	lds	r25, 0x0125
    3596:	80 54       	subi	r24, 0x40	; 64
    3598:	90 40       	sbci	r25, 0x00	; 0
    359a:	90 93 25 01 	sts	0x0125, r25
    359e:	80 93 24 01 	sts	0x0124, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    35a2:	27 e0       	ldi	r18, 0x07	; 7
    35a4:	9d c2       	rjmp	.+1338   	; 0x3ae0 <main+0xdc0>
			}
			else	// Block write failed
			{
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
    35a6:	c0 91 24 01 	lds	r28, 0x0124
    35aa:	d0 91 25 01 	lds	r29, 0x0125
    35ae:	c1 34       	cpi	r28, 0x41	; 65
    35b0:	d1 05       	cpc	r29, r1
    35b2:	10 f0       	brcs	.+4      	; 0x35b8 <main+0x898>
    35b4:	c0 e4       	ldi	r28, 0x40	; 64
    35b6:	d0 e0       	ldi	r29, 0x00	; 0
    35b8:	10 e0       	ldi	r17, 0x00	; 0
    35ba:	0d c0       	rjmp	.+26     	; 0x35d6 <main+0x8b6>
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
			{														
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    35bc:	8f ef       	ldi	r24, 0xFF	; 255
    35be:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    35c2:	80 91 24 01 	lds	r24, 0x0124
    35c6:	90 91 25 01 	lds	r25, 0x0125
    35ca:	01 97       	sbiw	r24, 0x01	; 1
    35cc:	90 93 25 01 	sts	0x0125, r25
    35d0:	80 93 24 01 	sts	0x0124, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    35d4:	1f 5f       	subi	r17, 0xFF	; 255
    35d6:	81 2f       	mov	r24, r17
    35d8:	90 e0       	ldi	r25, 0x00	; 0
    35da:	8c 17       	cp	r24, r28
    35dc:	9d 07       	cpc	r25, r29
    35de:	70 f3       	brcs	.-36     	; 0x35bc <main+0x89c>
			{														
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    35e0:	80 91 24 01 	lds	r24, 0x0124
    35e4:	90 91 25 01 	lds	r25, 0x0125
    35e8:	89 2b       	or	r24, r25
    35ea:	09 f0       	breq	.+2      	; 0x35ee <main+0x8ce>
    35ec:	34 c2       	rjmp	.+1128   	; 0x3a56 <main+0xd36>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    35ee:	8f ef       	ldi	r24, 0xFF	; 255
    35f0:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    35f4:	8f ef       	ldi	r24, 0xFF	; 255
    35f6:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code	
    35fa:	8f ef       	ldi	r24, 0xFF	; 255
    35fc:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    3600:	8f 71       	andi	r24, 0x1F	; 31
    3602:	85 30       	cpi	r24, 0x05	; 5
    3604:	09 f0       	breq	.+2      	; 0x3608 <main+0x8e8>
    3606:	de c1       	rjmp	.+956    	; 0x39c4 <main+0xca4>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    3608:	83 e0       	ldi	r24, 0x03	; 3
    360a:	62 e6       	ldi	r22, 0x62	; 98
    360c:	72 e0       	ldi	r23, 0x02	; 2
    360e:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    3612:	38 e0       	ldi	r19, 0x08	; 8
    3614:	30 93 59 02 	sts	0x0259, r19
    3618:	1e c2       	rjmp	.+1084   	; 0x3a56 <main+0xd36>
				}	
			}
			break;
			
			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    361a:	83 e0       	ldi	r24, 0x03	; 3
    361c:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    3620:	88 23       	and	r24, r24
    3622:	09 f0       	breq	.+2      	; 0x3626 <main+0x906>
    3624:	cf c1       	rjmp	.+926    	; 0x39c4 <main+0xca4>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3626:	8f ef       	ldi	r24, 0xFF	; 255
    3628:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    362c:	8f 3f       	cpi	r24, 0xFF	; 255
    362e:	09 f4       	brne	.+2      	; 0x3632 <main+0x912>
    3630:	60 c2       	rjmp	.+1216   	; 0x3af2 <main+0xdd2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3632:	8f ef       	ldi	r24, 0xFF	; 255
    3634:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    3638:	8f 3f       	cpi	r24, 0xFF	; 255
    363a:	09 f4       	brne	.+2      	; 0x363e <main+0x91e>
    363c:	5a c2       	rjmp	.+1204   	; 0x3af2 <main+0xdd2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    363e:	8f ef       	ldi	r24, 0xFF	; 255
    3640:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    3644:	8f 3f       	cpi	r24, 0xFF	; 255
    3646:	09 f4       	brne	.+2      	; 0x364a <main+0x92a>
    3648:	54 c2       	rjmp	.+1192   	; 0x3af2 <main+0xdd2>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    364a:	8f ef       	ldi	r24, 0xFF	; 255
    364c:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    3650:	8f 3f       	cpi	r24, 0xFF	; 255
    3652:	09 f0       	breq	.+2      	; 0x3656 <main+0x936>
    3654:	00 c2       	rjmp	.+1024   	; 0x3a56 <main+0xd36>
    3656:	4d c2       	rjmp	.+1178   	; 0x3af2 <main+0xdd2>
				
				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    3658:	80 91 c8 00 	lds	r24, 0x00C8
    365c:	86 ff       	sbrs	r24, 6
    365e:	fc cf       	rjmp	.-8      	; 0x3658 <main+0x938>
    3660:	34 c1       	rjmp	.+616    	; 0x38ca <main+0xbaa>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------
						
			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    3662:	83 e0       	ldi	r24, 0x03	; 3
    3664:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    3668:	88 23       	and	r24, r24
    366a:	09 f0       	breq	.+2      	; 0x366e <main+0x94e>
    366c:	ab c1       	rjmp	.+854    	; 0x39c4 <main+0xca4>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    366e:	8f ef       	ldi	r24, 0xFF	; 255
    3670:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    3674:	8f 3f       	cpi	r24, 0xFF	; 255
    3676:	69 f4       	brne	.+26     	; 0x3692 <main+0x972>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3678:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    367c:	8f 3f       	cpi	r24, 0xFF	; 255
    367e:	49 f4       	brne	.+18     	; 0x3692 <main+0x972>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3680:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    3684:	8f 3f       	cpi	r24, 0xFF	; 255
    3686:	29 f4       	brne	.+10     	; 0x3692 <main+0x972>
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3688:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    368c:	8f 3f       	cpi	r24, 0xFF	; 255
    368e:	09 f4       	brne	.+2      	; 0x3692 <main+0x972>
    3690:	e2 c1       	rjmp	.+964    	; 0x3a56 <main+0xd36>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    3692:	8e 3f       	cpi	r24, 0xFE	; 254
    3694:	09 f0       	breq	.+2      	; 0x3698 <main+0x978>
    3696:	93 c1       	rjmp	.+806    	; 0x39be <main+0xc9e>
				{				
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left				
    3698:	d0 92 25 01 	sts	0x0125, r13
    369c:	c0 92 24 01 	sts	0x0124, r12

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    36a0:	8f ef       	ldi	r24, 0xFF	; 255
    36a2:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	a0 e0       	ldi	r26, 0x00	; 0
    36aa:	b0 e0       	ldi	r27, 0x00	; 0
    36ac:	b8 2f       	mov	r27, r24
    36ae:	aa 27       	eor	r26, r26
    36b0:	99 27       	eor	r25, r25
    36b2:	88 27       	eor	r24, r24
    36b4:	80 93 ad 05 	sts	0x05AD, r24
    36b8:	90 93 ae 05 	sts	0x05AE, r25
    36bc:	a0 93 af 05 	sts	0x05AF, r26
    36c0:	b0 93 b0 05 	sts	0x05B0, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    36c4:	e0 90 ad 05 	lds	r14, 0x05AD
    36c8:	f0 90 ae 05 	lds	r15, 0x05AE
    36cc:	00 91 af 05 	lds	r16, 0x05AF
    36d0:	10 91 b0 05 	lds	r17, 0x05B0
    36d4:	8f ef       	ldi	r24, 0xFF	; 255
    36d6:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	a0 e0       	ldi	r26, 0x00	; 0
    36de:	b0 e0       	ldi	r27, 0x00	; 0
    36e0:	dc 01       	movw	r26, r24
    36e2:	99 27       	eor	r25, r25
    36e4:	88 27       	eor	r24, r24
    36e6:	8e 29       	or	r24, r14
    36e8:	9f 29       	or	r25, r15
    36ea:	a0 2b       	or	r26, r16
    36ec:	b1 2b       	or	r27, r17
    36ee:	80 93 ad 05 	sts	0x05AD, r24
    36f2:	90 93 ae 05 	sts	0x05AE, r25
    36f6:	a0 93 af 05 	sts	0x05AF, r26
    36fa:	b0 93 b0 05 	sts	0x05B0, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    36fe:	e0 90 ad 05 	lds	r14, 0x05AD
    3702:	f0 90 ae 05 	lds	r15, 0x05AE
    3706:	00 91 af 05 	lds	r16, 0x05AF
    370a:	10 91 b0 05 	lds	r17, 0x05B0
    370e:	8f ef       	ldi	r24, 0xFF	; 255
    3710:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    3714:	90 e0       	ldi	r25, 0x00	; 0
    3716:	a0 e0       	ldi	r26, 0x00	; 0
    3718:	b0 e0       	ldi	r27, 0x00	; 0
    371a:	ba 2f       	mov	r27, r26
    371c:	a9 2f       	mov	r26, r25
    371e:	98 2f       	mov	r25, r24
    3720:	88 27       	eor	r24, r24
    3722:	8e 29       	or	r24, r14
    3724:	9f 29       	or	r25, r15
    3726:	a0 2b       	or	r26, r16
    3728:	b1 2b       	or	r27, r17
    372a:	80 93 ad 05 	sts	0x05AD, r24
    372e:	90 93 ae 05 	sts	0x05AE, r25
    3732:	a0 93 af 05 	sts	0x05AF, r26
    3736:	b0 93 b0 05 	sts	0x05B0, r27
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    373a:	e0 90 ad 05 	lds	r14, 0x05AD
    373e:	f0 90 ae 05 	lds	r15, 0x05AE
    3742:	00 91 af 05 	lds	r16, 0x05AF
    3746:	10 91 b0 05 	lds	r17, 0x05B0
    374a:	8f ef       	ldi	r24, 0xFF	; 255
    374c:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	a0 e0       	ldi	r26, 0x00	; 0
    3754:	b0 e0       	ldi	r27, 0x00	; 0
    3756:	8e 29       	or	r24, r14
    3758:	9f 29       	or	r25, r15
    375a:	a0 2b       	or	r26, r16
    375c:	b1 2b       	or	r27, r17
    375e:	80 93 ad 05 	sts	0x05AD, r24
    3762:	90 93 ae 05 	sts	0x05AE, r25
    3766:	a0 93 af 05 	sts	0x05AF, r26
    376a:	b0 93 b0 05 	sts	0x05B0, r27

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    376e:	80 91 ad 05 	lds	r24, 0x05AD
    3772:	90 91 ae 05 	lds	r25, 0x05AE
    3776:	a0 91 af 05 	lds	r26, 0x05AF
    377a:	b0 91 b0 05 	lds	r27, 0x05B0
    377e:	80 93 a9 05 	sts	0x05A9, r24
    3782:	90 93 aa 05 	sts	0x05AA, r25
    3786:	a0 93 ab 05 	sts	0x05AB, r26
    378a:	b0 93 ac 05 	sts	0x05AC, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    378e:	80 91 24 01 	lds	r24, 0x0124
    3792:	90 91 25 01 	lds	r25, 0x0125
    3796:	04 97       	sbiw	r24, 0x04	; 4
    3798:	90 93 25 01 	sts	0x0125, r25
    379c:	80 93 24 01 	sts	0x0124, r24
    37a0:	02 c1       	rjmp	.+516    	; 0x39a6 <main+0xc86>
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    37a2:	80 91 a4 05 	lds	r24, 0x05A4
    37a6:	81 30       	cpi	r24, 0x01	; 1
    37a8:	09 f4       	brne	.+2      	; 0x37ac <main+0xa8c>
    37aa:	04 c1       	rjmp	.+520    	; 0x39b4 <main+0xc94>
			{
				cardState=SD_READ_ABORT;
				sdAbortRead=false;			
    37ac:	c0 91 24 01 	lds	r28, 0x0124
    37b0:	d0 91 25 01 	lds	r29, 0x0125
    37b4:	c1 34       	cpi	r28, 0x41	; 65
    37b6:	d1 05       	cpc	r29, r1
    37b8:	10 f0       	brcs	.+4      	; 0x37be <main+0xa9e>
    37ba:	c0 e4       	ldi	r28, 0x40	; 64
    37bc:	d0 e0       	ldi	r29, 0x00	; 0
    37be:	10 e0       	ldi	r17, 0x00	; 0
    37c0:	54 c0       	rjmp	.+168    	; 0x386a <main+0xb4a>
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
				{									
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    37c2:	8f ef       	ldi	r24, 0xFF	; 255
    37c4:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    37c8:	28 2f       	mov	r18, r24
					bytesLeftInBlock--;						// One less byte in the block read.
    37ca:	80 91 24 01 	lds	r24, 0x0124
    37ce:	90 91 25 01 	lds	r25, 0x0125
    37d2:	01 97       	sbiw	r24, 0x01	; 1
    37d4:	90 93 25 01 	sts	0x0125, r25
    37d8:	80 93 24 01 	sts	0x0124, r24

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    37dc:	80 91 ad 05 	lds	r24, 0x05AD
    37e0:	90 91 ae 05 	lds	r25, 0x05AE
    37e4:	a0 91 af 05 	lds	r26, 0x05AF
    37e8:	b0 91 b0 05 	lds	r27, 0x05B0
    37ec:	00 97       	sbiw	r24, 0x00	; 0
    37ee:	a1 05       	cpc	r26, r1
    37f0:	b1 05       	cpc	r27, r1
    37f2:	d1 f1       	breq	.+116    	; 0x3868 <main+0xb48>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    37f4:	80 91 ad 05 	lds	r24, 0x05AD
    37f8:	90 91 ae 05 	lds	r25, 0x05AE
    37fc:	a0 91 af 05 	lds	r26, 0x05AF
    3800:	b0 91 b0 05 	lds	r27, 0x05B0
    3804:	01 97       	sbiw	r24, 0x01	; 1
    3806:	a1 09       	sbc	r26, r1
    3808:	b1 09       	sbc	r27, r1
    380a:	80 93 ad 05 	sts	0x05AD, r24
    380e:	90 93 ae 05 	sts	0x05AE, r25
    3812:	a0 93 af 05 	sts	0x05AF, r26
    3816:	b0 93 b0 05 	sts	0x05B0, r27

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    381a:	e0 91 9c 05 	lds	r30, 0x059C
    381e:	f0 91 9d 05 	lds	r31, 0x059D
    3822:	e6 56       	subi	r30, 0x66	; 102
    3824:	fd 4f       	sbci	r31, 0xFD	; 253
    3826:	20 83       	st	Z, r18
						sdFifoWritePointer++;				// Move to next spot in fifo									
    3828:	80 91 9c 05 	lds	r24, 0x059C
    382c:	90 91 9d 05 	lds	r25, 0x059D
    3830:	01 96       	adiw	r24, 0x01	; 1
    3832:	90 93 9d 05 	sts	0x059D, r25
    3836:	80 93 9c 05 	sts	0x059C, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    383a:	80 91 9c 05 	lds	r24, 0x059C
    383e:	90 91 9d 05 	lds	r25, 0x059D
    3842:	80 50       	subi	r24, 0x00	; 0
    3844:	93 40       	sbci	r25, 0x03	; 3
    3846:	20 f0       	brcs	.+8      	; 0x3850 <main+0xb30>
						{
							sdFifoWritePointer=0;
    3848:	10 92 9d 05 	sts	0x059D, r1
    384c:	10 92 9c 05 	sts	0x059C, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    3850:	2f b7       	in	r18, 0x3f	; 63
						cli();
    3852:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    3854:	80 91 9e 05 	lds	r24, 0x059E
    3858:	90 91 9f 05 	lds	r25, 0x059F
    385c:	01 96       	adiw	r24, 0x01	; 1
    385e:	90 93 9f 05 	sts	0x059F, r25
    3862:	80 93 9e 05 	sts	0x059E, r24
						SREG=sreg;
    3866:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    3868:	1f 5f       	subi	r17, 0xFF	; 255
    386a:	81 2f       	mov	r24, r17
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	8c 17       	cp	r24, r28
    3870:	9d 07       	cpc	r25, r29
    3872:	08 f4       	brcc	.+2      	; 0x3876 <main+0xb56>
    3874:	a6 cf       	rjmp	.-180    	; 0x37c2 <main+0xaa2>
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    3876:	80 91 24 01 	lds	r24, 0x0124
    387a:	90 91 25 01 	lds	r25, 0x0125
    387e:	89 2b       	or	r24, r25
    3880:	09 f0       	breq	.+2      	; 0x3884 <main+0xb64>
    3882:	e9 c0       	rjmp	.+466    	; 0x3a56 <main+0xd36>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    3884:	8f ef       	ldi	r24, 0xFF	; 255
    3886:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    388a:	8f ef       	ldi	r24, 0xFF	; 255
    388c:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    3890:	80 91 c8 00 	lds	r24, 0x00C8
    3894:	86 ff       	sbrs	r24, 6
    3896:	fc cf       	rjmp	.-8      	; 0x3890 <main+0xb70>
						;

					EndSdTransfer();				// Bring CS high
    3898:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    389c:	8f ef       	ldi	r24, 0xFF	; 255
    389e:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    38a2:	fb e0       	ldi	r31, 0x0B	; 11
    38a4:	f0 93 59 02 	sts	0x0259, r31

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    38a8:	80 91 ad 05 	lds	r24, 0x05AD
    38ac:	90 91 ae 05 	lds	r25, 0x05AE
    38b0:	a0 91 af 05 	lds	r26, 0x05AF
    38b4:	b0 91 b0 05 	lds	r27, 0x05B0
    38b8:	00 97       	sbiw	r24, 0x00	; 0
    38ba:	a1 05       	cpc	r26, r1
    38bc:	b1 05       	cpc	r27, r1
    38be:	09 f0       	breq	.+2      	; 0x38c2 <main+0xba2>
    38c0:	ca c0       	rjmp	.+404    	; 0x3a56 <main+0xd36>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    38c2:	80 91 c8 00 	lds	r24, 0x00C8
    38c6:	86 ff       	sbrs	r24, 6
    38c8:	fc cf       	rjmp	.-8      	; 0x38c2 <main+0xba2>
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    38ca:	80 92 59 02 	sts	0x0259, r8
    38ce:	c3 c0       	rjmp	.+390    	; 0x3a56 <main+0xd36>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    38d0:	6f b7       	in	r22, 0x3f	; 63
			cli();
    38d2:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    38d4:	80 91 9e 05 	lds	r24, 0x059E
    38d8:	90 91 9f 05 	lds	r25, 0x059F
    38dc:	20 e0       	ldi	r18, 0x00	; 0
    38de:	33 e0       	ldi	r19, 0x03	; 3
    38e0:	28 1b       	sub	r18, r24
    38e2:	39 0b       	sbc	r19, r25
    38e4:	c9 01       	movw	r24, r18
    38e6:	80 50       	subi	r24, 0x00	; 0
    38e8:	92 40       	sbci	r25, 0x02	; 2
    38ea:	c0 f4       	brcc	.+48     	; 0x391c <main+0xbfc>
    38ec:	80 91 9e 05 	lds	r24, 0x059E
    38f0:	90 91 9f 05 	lds	r25, 0x059F
    38f4:	20 91 ad 05 	lds	r18, 0x05AD
    38f8:	30 91 ae 05 	lds	r19, 0x05AE
    38fc:	40 91 af 05 	lds	r20, 0x05AF
    3900:	50 91 b0 05 	lds	r21, 0x05B0
    3904:	e0 e0       	ldi	r30, 0x00	; 0
    3906:	f3 e0       	ldi	r31, 0x03	; 3
    3908:	e8 1b       	sub	r30, r24
    390a:	f9 0b       	sbc	r31, r25
    390c:	cf 01       	movw	r24, r30
    390e:	a0 e0       	ldi	r26, 0x00	; 0
    3910:	b0 e0       	ldi	r27, 0x00	; 0
    3912:	82 17       	cp	r24, r18
    3914:	93 07       	cpc	r25, r19
    3916:	a4 07       	cpc	r26, r20
    3918:	b5 07       	cpc	r27, r21
    391a:	30 f1       	brcs	.+76     	; 0x3968 <main+0xc48>
			{
				SREG=sreg;				// ISR back on.
    391c:	6f bf       	out	0x3f, r22	; 63
				sdCurrentBlockOffset++;	// Point at next block
    391e:	60 91 b3 05 	lds	r22, 0x05B3
    3922:	70 91 b4 05 	lds	r23, 0x05B4
    3926:	6f 5f       	subi	r22, 0xFF	; 255
    3928:	7f 4f       	sbci	r23, 0xFF	; 255
    392a:	70 93 b4 05 	sts	0x05B4, r23
    392e:	60 93 b3 05 	sts	0x05B3, r22

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    3932:	80 e0       	ldi	r24, 0x00	; 0
    3934:	90 e0       	ldi	r25, 0x00	; 0
    3936:	20 91 a5 05 	lds	r18, 0x05A5
    393a:	30 91 a6 05 	lds	r19, 0x05A6
    393e:	40 91 a7 05 	lds	r20, 0x05A7
    3942:	50 91 a8 05 	lds	r21, 0x05A8
    3946:	62 0f       	add	r22, r18
    3948:	73 1f       	adc	r23, r19
    394a:	84 1f       	adc	r24, r20
    394c:	95 1f       	adc	r25, r21
    394e:	0e 94 21 2a 	call	0x5442	; 0x5442 <SdBeginSingleBlockRead>
    3952:	81 30       	cpi	r24, 0x01	; 1
    3954:	b9 f5       	brne	.+110    	; 0x39c4 <main+0xca4>
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    3956:	83 e0       	ldi	r24, 0x03	; 3
    3958:	6a e7       	ldi	r22, 0x7A	; 122
    395a:	70 e0       	ldi	r23, 0x00	; 0
    395c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    3960:	fc e0       	ldi	r31, 0x0C	; 12
    3962:	f0 93 59 02 	sts	0x0259, r31
    3966:	77 c0       	rjmp	.+238    	; 0x3a56 <main+0xd36>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
				}							
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    3968:	6f bf       	out	0x3f, r22	; 63
    396a:	75 c0       	rjmp	.+234    	; 0x3a56 <main+0xd36>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    396c:	83 e0       	ldi	r24, 0x03	; 3
    396e:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    3972:	88 23       	and	r24, r24
    3974:	39 f5       	brne	.+78     	; 0x39c4 <main+0xca4>
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3976:	8f ef       	ldi	r24, 0xFF	; 255
    3978:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    397c:	8f 3f       	cpi	r24, 0xFF	; 255
    397e:	69 f4       	brne	.+26     	; 0x399a <main+0xc7a>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3980:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    3984:	8f 3f       	cpi	r24, 0xFF	; 255
    3986:	49 f4       	brne	.+18     	; 0x399a <main+0xc7a>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3988:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    398c:	8f 3f       	cpi	r24, 0xFF	; 255
    398e:	29 f4       	brne	.+10     	; 0x399a <main+0xc7a>
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card	
    3990:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    3994:	8f 3f       	cpi	r24, 0xFF	; 255
    3996:	09 f4       	brne	.+2      	; 0x399a <main+0xc7a>
    3998:	5e c0       	rjmp	.+188    	; 0x3a56 <main+0xd36>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    399a:	8e 3f       	cpi	r24, 0xFE	; 254
    399c:	81 f4       	brne	.+32     	; 0x39be <main+0xc9e>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left				
    399e:	d0 92 25 01 	sts	0x0125, r13
    39a2:	c0 92 24 01 	sts	0x0124, r12

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    39a6:	20 92 59 02 	sts	0x0259, r2
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    39aa:	80 91 a4 05 	lds	r24, 0x05A4
    39ae:	81 30       	cpi	r24, 0x01	; 1
    39b0:	09 f0       	breq	.+2      	; 0x39b4 <main+0xc94>
    39b2:	51 c0       	rjmp	.+162    	; 0x3a56 <main+0xd36>
					{
						cardState=SD_READ_ABORT;
    39b4:	30 92 59 02 	sts	0x0259, r3
						sdAbortRead=false;
    39b8:	10 92 a4 05 	sts	0x05A4, r1
    39bc:	4c c0       	rjmp	.+152    	; 0x3a56 <main+0xd36>
					}
				}
				else if(theByte!=0xFF)		// Got something other than a start token OR idle byte (like an error)
    39be:	8f 3f       	cpi	r24, 0xFF	; 255
    39c0:	09 f4       	brne	.+2      	; 0x39c4 <main+0xca4>
    39c2:	49 c0       	rjmp	.+146    	; 0x3a56 <main+0xd36>
					cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
				}
			}
			else	// Timed out starting read.
			{
				cardState=SD_NOT_PRESENT;   // @@@ kludgy way to reset card
    39c4:	10 92 59 02 	sts	0x0259, r1
    39c8:	46 c0       	rjmp	.+140    	; 0x3a56 <main+0xd36>
    39ca:	c0 91 24 01 	lds	r28, 0x0124
    39ce:	d0 91 25 01 	lds	r29, 0x0125
    39d2:	c1 34       	cpi	r28, 0x41	; 65
    39d4:	d1 05       	cpc	r29, r1
    39d6:	10 f0       	brcs	.+4      	; 0x39dc <main+0xcbc>
    39d8:	c0 e4       	ldi	r28, 0x40	; 64
    39da:	d0 e0       	ldi	r29, 0x00	; 0
    39dc:	10 e0       	ldi	r17, 0x00	; 0
    39de:	0d c0       	rjmp	.+26     	; 0x39fa <main+0xcda>
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
			{									
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    39e0:	8f ef       	ldi	r24, 0xFF	; 255
    39e2:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    39e6:	80 91 24 01 	lds	r24, 0x0124
    39ea:	90 91 25 01 	lds	r25, 0x0125
    39ee:	01 97       	sbiw	r24, 0x01	; 1
    39f0:	90 93 25 01 	sts	0x0125, r25
    39f4:	80 93 24 01 	sts	0x0124, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    39f8:	1f 5f       	subi	r17, 0xFF	; 255
    39fa:	81 2f       	mov	r24, r17
    39fc:	90 e0       	ldi	r25, 0x00	; 0
    39fe:	8c 17       	cp	r24, r28
    3a00:	9d 07       	cpc	r25, r29
    3a02:	70 f3       	brcs	.-36     	; 0x39e0 <main+0xcc0>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    3a04:	80 91 24 01 	lds	r24, 0x0124
    3a08:	90 91 25 01 	lds	r25, 0x0125
    3a0c:	89 2b       	or	r24, r25
    3a0e:	19 f5       	brne	.+70     	; 0x3a56 <main+0xd36>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    3a10:	8f ef       	ldi	r24, 0xFF	; 255
    3a12:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    3a16:	8f ef       	ldi	r24, 0xFF	; 255
    3a18:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    3a1c:	80 91 c8 00 	lds	r24, 0x00C8
    3a20:	86 ff       	sbrs	r24, 6
    3a22:	fc cf       	rjmp	.-8      	; 0x3a1c <main+0xcfc>
					;

				EndSdTransfer();				// Bring CS high
    3a24:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    3a28:	8f ef       	ldi	r24, 0xFF	; 255
    3a2a:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    3a2e:	80 91 c8 00 	lds	r24, 0x00C8
    3a32:	86 ff       	sbrs	r24, 6
    3a34:	fc cf       	rjmp	.-8      	; 0x3a2e <main+0xd0e>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....				
    3a36:	80 92 59 02 	sts	0x0259, r8
		
				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    3a3a:	80 91 a3 05 	lds	r24, 0x05A3
    3a3e:	81 30       	cpi	r24, 0x01	; 1
    3a40:	51 f4       	brne	.+20     	; 0x3a56 <main+0xd36>
				{
					sdPlaybackQueued=false;
    3a42:	10 92 a3 05 	sts	0x05A3, r1
					PlaySampleFromSd(sdQueuedBank,sdQueuedSlot);	// Trigger the next stream immediately
    3a46:	60 91 a1 05 	lds	r22, 0x05A1
    3a4a:	70 91 a2 05 	lds	r23, 0x05A2
    3a4e:	80 91 a0 05 	lds	r24, 0x05A0
    3a52:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <PlaySampleFromSd>
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    3a56:	80 91 00 01 	lds	r24, 0x0100
    3a5a:	90 91 01 01 	lds	r25, 0x0101
    3a5e:	a0 91 02 01 	lds	r26, 0x0102
    3a62:	b0 91 03 01 	lds	r27, 0x0103
    3a66:	88 0f       	add	r24, r24
    3a68:	99 1f       	adc	r25, r25
    3a6a:	aa 1f       	adc	r26, r26
    3a6c:	bb 1f       	adc	r27, r27
    3a6e:	80 93 00 01 	sts	0x0100, r24
    3a72:	90 93 01 01 	sts	0x0101, r25
    3a76:	a0 93 02 01 	sts	0x0102, r26
    3a7a:	b0 93 03 01 	sts	0x0103, r27
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    3a7e:	b7 ff       	sbrs	r27, 7
    3a80:	0c c0       	rjmp	.+24     	; 0x3a9a <main+0xd7a>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    3a82:	84 25       	eor	r24, r4
    3a84:	95 25       	eor	r25, r5
    3a86:	a6 25       	eor	r26, r6
    3a88:	b7 25       	eor	r27, r7
    3a8a:	80 93 00 01 	sts	0x0100, r24
    3a8e:	90 93 01 01 	sts	0x0101, r25
    3a92:	a0 93 02 01 	sts	0x0102, r26
    3a96:	b0 93 03 01 	sts	0x0103, r27
		GetRandomLongInt();		// Keep random numbers rolling.

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    3a9a:	0e 94 49 26 	call	0x4c92	; 0x4c92 <Uart0GotByte>
    3a9e:	88 23       	and	r24, r24
    3aa0:	21 f0       	breq	.+8      	; 0x3aaa <main+0xd8a>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    3aa2:	0e 94 4f 26 	call	0x4c9e	; 0x4c9e <Uart0GetByte>
    3aa6:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    3aaa:	0e 94 04 28 	call	0x5008	; 0x5008 <MidiTxBufferNotEmpty>
    3aae:	88 23       	and	r24, r24
    3ab0:	41 f0       	breq	.+16     	; 0x3ac2 <main+0xda2>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    3ab2:	80 91 c0 00 	lds	r24, 0x00C0
    3ab6:	85 ff       	sbrs	r24, 5
    3ab8:	04 c0       	rjmp	.+8      	; 0x3ac2 <main+0xda2>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    3aba:	0e 94 0f 28 	call	0x501e	; 0x501e <PopOutgoingMidiByte>
    3abe:	80 93 c6 00 	sts	0x00C6, r24
			}				
		}

		State();				// Execute the current program state.
    3ac2:	e0 91 e4 05 	lds	r30, 0x05E4
    3ac6:	f0 91 e5 05 	lds	r31, 0x05E5
    3aca:	09 95       	icall
    3acc:	d4 c9       	rjmp	.-3160   	; 0x2e76 <main+0x156>
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    3ace:	c5 01       	movw	r24, r10
    3ad0:	02 c0       	rjmp	.+4      	; 0x3ad6 <main+0xdb6>
    3ad2:	88 0f       	add	r24, r24
    3ad4:	99 1f       	adc	r25, r25
    3ad6:	2a 95       	dec	r18
    3ad8:	e2 f7       	brpl	.-8      	; 0x3ad2 <main+0xdb2>
    3ada:	38 2b       	or	r19, r24
    3adc:	30 83       	st	Z, r19
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents							
    3ade:	26 e0       	ldi	r18, 0x06	; 6
    3ae0:	20 93 59 02 	sts	0x0259, r18
    3ae4:	b8 cf       	rjmp	.-144    	; 0x3a56 <main+0xd36>
					}
				}
				
				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    3ae6:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    3aea:	8f ef       	ldi	r24, 0xFF	; 255
    3aec:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    3af0:	91 cc       	rjmp	.-1758   	; 0x3414 <main+0x6f4>
					}
				}
				
				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    3af2:	0e 94 e2 28 	call	0x51c4	; 0x51c4 <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.	
    3af6:	8f ef       	ldi	r24, 0xFF	; 255
    3af8:	0e 94 e7 28 	call	0x51ce	; 0x51ce <TransferSdByte>
    3afc:	ad cd       	rjmp	.-1190   	; 0x3658 <main+0x938>

00003afe <GetMidiChannel>:
}


static unsigned char GetMidiChannel(unsigned char theBank)
// Get the midi channel we stored in EEPROM.
{
    3afe:	1f 93       	push	r17
    3b00:	18 2f       	mov	r17, r24
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    3b02:	88 23       	and	r24, r24
    3b04:	11 f4       	brne	.+4      	; 0x3b0a <GetMidiChannel+0xc>
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    3b06:	84 e0       	ldi	r24, 0x04	; 4
    3b08:	05 c0       	rjmp	.+10     	; 0x3b14 <GetMidiChannel+0x16>
	}
	else if(theBank==BANK_1)
    3b0a:	81 30       	cpi	r24, 0x01	; 1
    3b0c:	11 f0       	breq	.+4      	; 0x3b12 <GetMidiChannel+0x14>
    3b0e:	80 e0       	ldi	r24, 0x00	; 0
    3b10:	08 c0       	rjmp	.+16     	; 0x3b22 <GetMidiChannel+0x24>
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    3b12:	88 e0       	ldi	r24, 0x08	; 8
    3b14:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <EepromRead>
	}

	if(x<16)					// Legit number?
    3b18:	80 31       	cpi	r24, 0x10	; 16
    3b1a:	18 f0       	brcs	.+6      	; 0x3b22 <GetMidiChannel+0x24>
    3b1c:	81 2f       	mov	r24, r17
    3b1e:	11 11       	cpse	r17, r1
    3b20:	81 e0       	ldi	r24, 0x01	; 1
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
	}	
}
    3b22:	1f 91       	pop	r17
    3b24:	08 95       	ret

00003b26 <DoSampler>:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.

// Wed Apr  8 11:42:07 CDT 2009
// This state is based on the idea that playing, recording, and overdubbing are all discrete things and that if you're doing one you can't be doing another.
{
    3b26:	cf 92       	push	r12
    3b28:	df 92       	push	r13
    3b2a:	ef 92       	push	r14
    3b2c:	ff 92       	push	r15
    3b2e:	0f 93       	push	r16
    3b30:	1f 93       	push	r17
    3b32:	cf 93       	push	r28
    3b34:	df 93       	push	r29
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	static bool
		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
    3b36:	80 91 41 01 	lds	r24, 0x0141
    3b3a:	88 23       	and	r24, r24
    3b3c:	09 f0       	breq	.+2      	; 0x3b40 <DoSampler+0x1a>
    3b3e:	8b c0       	rjmp	.+278    	; 0x3c56 <DoSampler+0x130>
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    3b40:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <GetMidiChannel>
    3b44:	80 93 2e 06 	sts	0x062E, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    3b48:	81 e0       	ldi	r24, 0x01	; 1
    3b4a:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <GetMidiChannel>
    3b4e:	80 93 47 06 	sts	0x0647, r24
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    3b52:	10 92 f6 05 	sts	0x05F6, r1
    3b56:	10 92 f7 05 	sts	0x05F7, r1
    3b5a:	10 92 f8 05 	sts	0x05F8, r1
    3b5e:	10 92 f9 05 	sts	0x05F9, r1
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    3b62:	8f ef       	ldi	r24, 0xFF	; 255
    3b64:	9f ef       	ldi	r25, 0xFF	; 255
    3b66:	a7 e0       	ldi	r26, 0x07	; 7
    3b68:	b0 e0       	ldi	r27, 0x00	; 0
    3b6a:	80 93 19 06 	sts	0x0619, r24
    3b6e:	90 93 1a 06 	sts	0x061A, r25
    3b72:	a0 93 1b 06 	sts	0x061B, r26
    3b76:	b0 93 1c 06 	sts	0x061C, r27
    3b7a:	01 ec       	ldi	r16, 0xC1	; 193
    3b7c:	15 e0       	ldi	r17, 0x05	; 5
    3b7e:	c0 e0       	ldi	r28, 0x00	; 0
    3b80:	d0 e0       	ldi	r29, 0x00	; 0

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    3b82:	e3 e2       	ldi	r30, 0x23	; 35
    3b84:	ce 2e       	mov	r12, r30
    3b86:	d1 2c       	mov	r13, r1
			bankStates[i].loopOnce=false;
			bankStates[i].bitReduction=0;				// No crusties yet.
			bankStates[i].jitterValue=0;				// No hissies yet.
			bankStates[i].granularSlices=0;				// No remix yet.
			bankStates[i].halfSpeed=false;
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    3b88:	ee 24       	eor	r14, r14
    3b8a:	e3 94       	inc	r14
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    3b8c:	cc 9d       	mul	r28, r12
    3b8e:	f0 01       	movw	r30, r0
    3b90:	cd 9d       	mul	r28, r13
    3b92:	f0 0d       	add	r31, r0
    3b94:	dc 9d       	mul	r29, r12
    3b96:	f0 0d       	add	r31, r0
    3b98:	11 24       	eor	r1, r1
    3b9a:	ea 51       	subi	r30, 0x1A	; 26
    3b9c:	fa 4f       	sbci	r31, 0xFA	; 250
    3b9e:	10 82       	st	Z, r1
			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    3ba0:	11 86       	std	Z+9, r1	; 0x09
			bankStates[i].loopOnce=false;
    3ba2:	11 82       	std	Z+1, r1	; 0x01
			bankStates[i].bitReduction=0;				// No crusties yet.
    3ba4:	10 86       	std	Z+8, r1	; 0x08
			bankStates[i].jitterValue=0;				// No hissies yet.
    3ba6:	17 82       	std	Z+7, r1	; 0x07
			bankStates[i].granularSlices=0;				// No remix yet.
    3ba8:	16 82       	std	Z+6, r1	; 0x06
			bankStates[i].halfSpeed=false;
    3baa:	12 82       	std	Z+2, r1	; 0x02
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    3bac:	e4 82       	std	Z+4, r14	; 0x04
			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    3bae:	13 82       	std	Z+3, r1	; 0x03
			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    3bb0:	80 89       	ldd	r24, Z+16	; 0x10
    3bb2:	91 89       	ldd	r25, Z+17	; 0x11
    3bb4:	a2 89       	ldd	r26, Z+18	; 0x12
    3bb6:	b3 89       	ldd	r27, Z+19	; 0x13
    3bb8:	87 8f       	std	Z+31, r24	; 0x1f
    3bba:	90 a3       	std	Z+32, r25	; 0x20
    3bbc:	a1 a3       	std	Z+33, r26	; 0x21
    3bbe:	b2 a3       	std	Z+34, r27	; 0x22
			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    3bc0:	80 89       	ldd	r24, Z+16	; 0x10
    3bc2:	91 89       	ldd	r25, Z+17	; 0x11
    3bc4:	a2 89       	ldd	r26, Z+18	; 0x12
    3bc6:	b3 89       	ldd	r27, Z+19	; 0x13
    3bc8:	84 87       	std	Z+12, r24	; 0x0c
    3bca:	95 87       	std	Z+13, r25	; 0x0d
    3bcc:	a6 87       	std	Z+14, r26	; 0x0e
    3bce:	b7 87       	std	Z+15, r27	; 0x0f
			realtimeOn[i]=false;								// We'll default to playback.	
    3bd0:	de 01       	movw	r26, r28
    3bd2:	a8 5d       	subi	r26, 0xD8	; 216
    3bd4:	be 4f       	sbci	r27, 0xFE	; 254
    3bd6:	1c 92       	st	X, r1
			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    3bd8:	15 82       	std	Z+5, r1	; 0x05
			editModeEntered=false;			
    3bda:	10 92 27 01 	sts	0x0127, r1
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    3bde:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    3be0:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    3be2:	80 89       	ldd	r24, Z+16	; 0x10
    3be4:	91 89       	ldd	r25, Z+17	; 0x11
    3be6:	a2 89       	ldd	r26, Z+18	; 0x12
    3be8:	b3 89       	ldd	r27, Z+19	; 0x13
    3bea:	80 8f       	std	Z+24, r24	; 0x18
    3bec:	91 8f       	std	Z+25, r25	; 0x19
    3bee:	a2 8f       	std	Z+26, r26	; 0x1a
    3bf0:	b3 8f       	std	Z+27, r27	; 0x1b
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3bf2:	84 85       	ldd	r24, Z+12	; 0x0c
    3bf4:	95 85       	ldd	r25, Z+13	; 0x0d
    3bf6:	a6 85       	ldd	r26, Z+14	; 0x0e
    3bf8:	b7 85       	ldd	r27, Z+15	; 0x0f
    3bfa:	84 8b       	std	Z+20, r24	; 0x14
    3bfc:	95 8b       	std	Z+21, r25	; 0x15
    3bfe:	a6 8b       	std	Z+22, r26	; 0x16
    3c00:	b7 8b       	std	Z+23, r27	; 0x17
	bankStates[theBank].sampleStartOffset=0;
    3c02:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleEndOffset=0;
    3c04:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleWindowOffset=0;
    3c06:	16 8e       	std	Z+30, r1	; 0x1e
	SREG=sreg;		// Restore interrupts.
    3c08:	2f bf       	out	0x3f, r18	; 63
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    3c0a:	cc 23       	and	r28, r28
    3c0c:	11 f4       	brne	.+4      	; 0x3c12 <DoSampler+0xec>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    3c0e:	87 e0       	ldi	r24, 0x07	; 7
    3c10:	01 c0       	rjmp	.+2      	; 0x3c14 <DoSampler+0xee>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    3c12:	8b e0       	ldi	r24, 0x0B	; 11
    3c14:	0e 94 3b 26 	call	0x4c76	; 0x4c76 <EepromRead>
	}

	if(x<90)					// Legit number?
    3c18:	8a 35       	cpi	r24, 0x5A	; 90
    3c1a:	08 f0       	brcs	.+2      	; 0x3c1e <DoSampler+0xf8>
    3c1c:	80 e3       	ldi	r24, 0x30	; 48
			bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
			editModeEntered=false;			
			
			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
    3c1e:	f8 01       	movw	r30, r16
    3c20:	80 83       	st	Z, r24
    3c22:	11 82       	std	Z+1, r1	; 0x01
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    3c24:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    3c28:	f8 01       	movw	r30, r16
    3c2a:	81 93       	st	Z+, r24
    3c2c:	91 93       	st	Z+, r25
    3c2e:	8f 01       	movw	r16, r30
    3c30:	21 96       	adiw	r28, 0x01	; 1
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    3c32:	c2 30       	cpi	r28, 0x02	; 2
    3c34:	d1 05       	cpc	r29, r1
    3c36:	09 f0       	breq	.+2      	; 0x3c3a <DoSampler+0x114>
    3c38:	a9 cf       	rjmp	.-174    	; 0x3b8c <DoSampler+0x66>

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
		}

		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3c3a:	81 e5       	ldi	r24, 0x51	; 81
    3c3c:	98 e0       	ldi	r25, 0x08	; 8
    3c3e:	90 93 e3 05 	sts	0x05E3, r25
    3c42:	80 93 e2 05 	sts	0x05E2, r24

		currentBank=BANK_0;			// Point at the first bank until we change banks.
    3c46:	10 92 2e 01 	sts	0x012E, r1

		KillLeds();					// All leds off, and no blinking.
    3c4a:	0e 94 1f 14 	call	0x283e	; 0x283e <KillLeds>
		subState=SS_1;
    3c4e:	81 e0       	ldi	r24, 0x01	; 1
    3c50:	80 93 41 01 	sts	0x0141, r24
    3c54:	ca c6       	rjmp	.+3476   	; 0x49ea <DoSampler+0xec4>
	}

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    3c56:	81 30       	cpi	r24, 0x01	; 1
    3c58:	09 f0       	breq	.+2      	; 0x3c5c <DoSampler+0x136>
    3c5a:	c7 c6       	rjmp	.+3470   	; 0x49ea <DoSampler+0xec4>
	{
		if(editModeEntered==false)	// Normal functions for buttons?
    3c5c:	80 91 27 01 	lds	r24, 0x0127
    3c60:	90 91 3e 01 	lds	r25, 0x013E
    3c64:	88 23       	and	r24, r24
    3c66:	09 f0       	breq	.+2      	; 0x3c6a <DoSampler+0x144>
    3c68:	2e c3       	rjmp	.+1628   	; 0x42c6 <DoSampler+0x7a0>
		{
			if(keyState&Im_EFFECT)			// If we're holding the effect switch, our other switches call up patches instead of their normal functions.  It's like a shift key.
    3c6a:	29 2f       	mov	r18, r25
    3c6c:	30 e0       	ldi	r19, 0x00	; 0
    3c6e:	95 ff       	sbrs	r25, 5
    3c70:	2c c1       	rjmp	.+600    	; 0x3eca <DoSampler+0x3a4>
			{
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
    3c72:	b9 01       	movw	r22, r18
    3c74:	68 70       	andi	r22, 0x08	; 8
    3c76:	70 70       	andi	r23, 0x00	; 0
    3c78:	93 ff       	sbrs	r25, 3
    3c7a:	04 c0       	rjmp	.+8      	; 0x3c84 <DoSampler+0x15e>
    3c7c:	80 91 3f 01 	lds	r24, 0x013F
    3c80:	84 fd       	sbrc	r24, 4
    3c82:	0a c0       	rjmp	.+20     	; 0x3c98 <DoSampler+0x172>
    3c84:	80 91 3f 01 	lds	r24, 0x013F
    3c88:	90 e0       	ldi	r25, 0x00	; 0
    3c8a:	ac 01       	movw	r20, r24
    3c8c:	48 70       	andi	r20, 0x08	; 8
    3c8e:	50 70       	andi	r21, 0x00	; 0
    3c90:	83 ff       	sbrs	r24, 3
    3c92:	4d c0       	rjmp	.+154    	; 0x3d2e <DoSampler+0x208>
    3c94:	24 ff       	sbrs	r18, 4
    3c96:	4b c0       	rjmp	.+150    	; 0x3d2e <DoSampler+0x208>
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3c98:	81 e5       	ldi	r24, 0x51	; 81
    3c9a:	98 e0       	ldi	r25, 0x08	; 8
    3c9c:	90 93 e3 05 	sts	0x05E3, r25
    3ca0:	80 93 e2 05 	sts	0x05E2, r24
					RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    3ca4:	80 91 2e 01 	lds	r24, 0x012E
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    3ca8:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    3caa:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    3cac:	90 e0       	ldi	r25, 0x00	; 0
    3cae:	43 e2       	ldi	r20, 0x23	; 35
    3cb0:	50 e0       	ldi	r21, 0x00	; 0
    3cb2:	84 9f       	mul	r24, r20
    3cb4:	f0 01       	movw	r30, r0
    3cb6:	85 9f       	mul	r24, r21
    3cb8:	f0 0d       	add	r31, r0
    3cba:	94 9f       	mul	r25, r20
    3cbc:	f0 0d       	add	r31, r0
    3cbe:	11 24       	eor	r1, r1
    3cc0:	ea 51       	subi	r30, 0x1A	; 26
    3cc2:	fa 4f       	sbci	r31, 0xFA	; 250
    3cc4:	80 89       	ldd	r24, Z+16	; 0x10
    3cc6:	91 89       	ldd	r25, Z+17	; 0x11
    3cc8:	a2 89       	ldd	r26, Z+18	; 0x12
    3cca:	b3 89       	ldd	r27, Z+19	; 0x13
    3ccc:	80 8f       	std	Z+24, r24	; 0x18
    3cce:	91 8f       	std	Z+25, r25	; 0x19
    3cd0:	a2 8f       	std	Z+26, r26	; 0x1a
    3cd2:	b3 8f       	std	Z+27, r27	; 0x1b
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3cd4:	84 85       	ldd	r24, Z+12	; 0x0c
    3cd6:	95 85       	ldd	r25, Z+13	; 0x0d
    3cd8:	a6 85       	ldd	r26, Z+14	; 0x0e
    3cda:	b7 85       	ldd	r27, Z+15	; 0x0f
    3cdc:	84 8b       	std	Z+20, r24	; 0x14
    3cde:	95 8b       	std	Z+21, r25	; 0x15
    3ce0:	a6 8b       	std	Z+22, r26	; 0x16
    3ce2:	b7 8b       	std	Z+23, r27	; 0x17
	bankStates[theBank].sampleStartOffset=0;
    3ce4:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleEndOffset=0;
    3ce6:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleWindowOffset=0;
    3ce8:	16 8e       	std	Z+30, r1	; 0x1e
	SREG=sreg;		// Restore interrupts.
    3cea:	2f bf       	out	0x3f, r18	; 63
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
					bankStates[currentBank].bitReduction=0;			// No crusties yet.
    3cec:	80 91 2e 01 	lds	r24, 0x012E
    3cf0:	28 2f       	mov	r18, r24
    3cf2:	30 e0       	ldi	r19, 0x00	; 0
    3cf4:	24 9f       	mul	r18, r20
    3cf6:	f0 01       	movw	r30, r0
    3cf8:	25 9f       	mul	r18, r21
    3cfa:	f0 0d       	add	r31, r0
    3cfc:	34 9f       	mul	r19, r20
    3cfe:	f0 0d       	add	r31, r0
    3d00:	11 24       	eor	r1, r1
    3d02:	ea 51       	subi	r30, 0x1A	; 26
    3d04:	fa 4f       	sbci	r31, 0xFA	; 250
    3d06:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentBank].jitterValue=0;			// No hissies yet.
    3d08:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentBank].granularSlices=0;		// No remix yet.
    3d0a:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentBank].halfSpeed=false;
    3d0c:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentBank].backwardsPlayback=false;					
    3d0e:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentBank].sampleDirection=true;					
    3d10:	91 e0       	ldi	r25, 0x01	; 1
    3d12:	94 83       	std	Z+4, r25	; 0x04
					bankStates[currentBank].loopOnce=false;				
    3d14:	11 82       	std	Z+1, r1	; 0x01
					editModeEntered=false;
    3d16:	10 92 27 01 	sts	0x0127, r1
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);		// Send it out to the techno nerds.			
    3d1a:	64 e0       	ldi	r22, 0x04	; 4
    3d1c:	42 e1       	ldi	r20, 0x12	; 18
    3d1e:	20 e0       	ldi	r18, 0x00	; 0
    3d20:	0e 94 f7 26 	call	0x4dee	; 0x4dee <PutMidiMessageInOutgoingFifo>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.			
    3d24:	80 91 2e 01 	lds	r24, 0x012E
    3d28:	64 e0       	ldi	r22, 0x04	; 4
    3d2a:	4b e1       	ldi	r20, 0x1B	; 27
    3d2c:	20 c1       	rjmp	.+576    	; 0x3f6e <DoSampler+0x448>
				}
				else if(keyState&Im_SWITCH_3)	// Sample trimming
    3d2e:	67 2b       	or	r22, r23
    3d30:	51 f1       	breq	.+84     	; 0x3d86 <DoSampler+0x260>
				{
					if(keyState&Im_SWITCH_0||keyState&Im_SWITCH_1||keyState&Im_SWITCH_2)	// These are all edit commands, if we hit them then enter edit mode.
    3d32:	20 fd       	sbrc	r18, 0
    3d34:	04 c0       	rjmp	.+8      	; 0x3d3e <DoSampler+0x218>
    3d36:	26 70       	andi	r18, 0x06	; 6
    3d38:	30 70       	andi	r19, 0x00	; 0
    3d3a:	23 2b       	or	r18, r19
    3d3c:	21 f0       	breq	.+8      	; 0x3d46 <DoSampler+0x220>
					{
						editModeEntered=true;
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	80 93 27 01 	sts	0x0127, r24
    3d44:	34 c3       	rjmp	.+1640   	; 0x43ae <DoSampler+0x888>
					}
					else if(newKeys&Im_SWITCH_3)		// Screw and chop (toggle) (default two key combo)
    3d46:	45 2b       	or	r20, r21
    3d48:	09 f4       	brne	.+2      	; 0x3d4c <DoSampler+0x226>
    3d4a:	31 c3       	rjmp	.+1634   	; 0x43ae <DoSampler+0x888>
					{
						if(bankStates[currentBank].halfSpeed==false)
    3d4c:	40 91 2e 01 	lds	r20, 0x012E
    3d50:	84 2f       	mov	r24, r20
    3d52:	90 e0       	ldi	r25, 0x00	; 0
    3d54:	23 e2       	ldi	r18, 0x23	; 35
    3d56:	30 e0       	ldi	r19, 0x00	; 0
    3d58:	82 9f       	mul	r24, r18
    3d5a:	f0 01       	movw	r30, r0
    3d5c:	83 9f       	mul	r24, r19
    3d5e:	f0 0d       	add	r31, r0
    3d60:	92 9f       	mul	r25, r18
    3d62:	f0 0d       	add	r31, r0
    3d64:	11 24       	eor	r1, r1
    3d66:	ea 51       	subi	r30, 0x1A	; 26
    3d68:	fa 4f       	sbci	r31, 0xFA	; 250
    3d6a:	82 81       	ldd	r24, Z+2	; 0x02
    3d6c:	88 23       	and	r24, r24
    3d6e:	31 f4       	brne	.+12     	; 0x3d7c <DoSampler+0x256>
						{
							bankStates[currentBank].halfSpeed=true;
    3d70:	81 e0       	ldi	r24, 0x01	; 1
    3d72:	82 83       	std	Z+2, r24	; 0x02
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    3d74:	84 2f       	mov	r24, r20
    3d76:	64 e0       	ldi	r22, 0x04	; 4
    3d78:	40 e1       	ldi	r20, 0x10	; 16
    3d7a:	4d c1       	rjmp	.+666    	; 0x4016 <DoSampler+0x4f0>
						}
						else
						{
							bankStates[currentBank].halfSpeed=false;				
    3d7c:	12 82       	std	Z+2, r1	; 0x02
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    3d7e:	84 2f       	mov	r24, r20
    3d80:	64 e0       	ldi	r22, 0x04	; 4
    3d82:	40 e1       	ldi	r20, 0x10	; 16
    3d84:	f4 c0       	rjmp	.+488    	; 0x3f6e <DoSampler+0x448>
						}
					}
				}
				else if(keyState&Im_SWITCH_4)		// Realtime.
    3d86:	24 ff       	sbrs	r18, 4
    3d88:	35 c0       	rjmp	.+106    	; 0x3df4 <DoSampler+0x2ce>
				{
					if(newKeys&Im_SWITCH_2)		// Do realtime (three button combo)
    3d8a:	82 ff       	sbrs	r24, 2
    3d8c:	0c c0       	rjmp	.+24     	; 0x3da6 <DoSampler+0x280>
					{
						StartRealtime(currentBank,CLK_EXTERNAL,0);
    3d8e:	80 91 2e 01 	lds	r24, 0x012E
    3d92:	61 e0       	ldi	r22, 0x01	; 1
    3d94:	40 e0       	ldi	r20, 0x00	; 0
    3d96:	50 e0       	ldi	r21, 0x00	; 0
    3d98:	0e 94 57 0e 	call	0x1cae	; 0x1cae <StartRealtime>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    3d9c:	80 91 2e 01 	lds	r24, 0x012E
    3da0:	64 e0       	ldi	r22, 0x04	; 4
    3da2:	4e e0       	ldi	r20, 0x0E	; 14
    3da4:	fe c0       	rjmp	.+508    	; 0x3fa2 <DoSampler+0x47c>
					}
					else if(newKeys&Im_SWITCH_4)		// "Paul is Dead" mask (only pressing two keys)
    3da6:	84 ff       	sbrs	r24, 4
    3da8:	02 c3       	rjmp	.+1540   	; 0x43ae <DoSampler+0x888>
					{
						if(bankStates[currentBank].backwardsPlayback==false)
    3daa:	40 91 2e 01 	lds	r20, 0x012E
    3dae:	84 2f       	mov	r24, r20
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	23 e2       	ldi	r18, 0x23	; 35
    3db4:	30 e0       	ldi	r19, 0x00	; 0
    3db6:	82 9f       	mul	r24, r18
    3db8:	f0 01       	movw	r30, r0
    3dba:	83 9f       	mul	r24, r19
    3dbc:	f0 0d       	add	r31, r0
    3dbe:	92 9f       	mul	r25, r18
    3dc0:	f0 0d       	add	r31, r0
    3dc2:	11 24       	eor	r1, r1
    3dc4:	ea 51       	subi	r30, 0x1A	; 26
    3dc6:	fa 4f       	sbci	r31, 0xFA	; 250
    3dc8:	83 81       	ldd	r24, Z+3	; 0x03
    3dca:	88 23       	and	r24, r24
    3dcc:	39 f4       	brne	.+14     	; 0x3ddc <DoSampler+0x2b6>
						{
							bankStates[currentBank].backwardsPlayback=true;
    3dce:	81 e0       	ldi	r24, 0x01	; 1
    3dd0:	83 83       	std	Z+3, r24	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    3dd2:	84 2f       	mov	r24, r20
    3dd4:	64 e0       	ldi	r22, 0x04	; 4
    3dd6:	41 e1       	ldi	r20, 0x11	; 17
    3dd8:	20 e4       	ldi	r18, 0x40	; 64
    3dda:	05 c0       	rjmp	.+10     	; 0x3de6 <DoSampler+0x2c0>
						}
						else
						{
							bankStates[currentBank].backwardsPlayback=false;				
    3ddc:	13 82       	std	Z+3, r1	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    3dde:	84 2f       	mov	r24, r20
    3de0:	64 e0       	ldi	r22, 0x04	; 4
    3de2:	41 e1       	ldi	r20, 0x11	; 17
    3de4:	20 e0       	ldi	r18, 0x00	; 0
    3de6:	0e 94 f7 26 	call	0x4dee	; 0x4dee <PutMidiMessageInOutgoingFifo>
						}										
						
						UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    3dea:	80 91 2e 01 	lds	r24, 0x012E
    3dee:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <UpdateAdjustedSampleAddresses>
    3df2:	dd c2       	rjmp	.+1466   	; 0x43ae <DoSampler+0x888>
					}
				}			
				else
				{
					if(newKeys&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    3df4:	80 ff       	sbrs	r24, 0
    3df6:	16 c0       	rjmp	.+44     	; 0x3e24 <DoSampler+0x2fe>
					{
						bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    3df8:	80 91 2e 01 	lds	r24, 0x012E
    3dfc:	68 2f       	mov	r22, r24
    3dfe:	70 e0       	ldi	r23, 0x00	; 0
    3e00:	20 91 45 01 	lds	r18, 0x0145
    3e04:	43 e2       	ldi	r20, 0x23	; 35
    3e06:	50 e0       	ldi	r21, 0x00	; 0
    3e08:	64 9f       	mul	r22, r20
    3e0a:	f0 01       	movw	r30, r0
    3e0c:	65 9f       	mul	r22, r21
    3e0e:	f0 0d       	add	r31, r0
    3e10:	74 9f       	mul	r23, r20
    3e12:	f0 0d       	add	r31, r0
    3e14:	11 24       	eor	r1, r1
    3e16:	ea 51       	subi	r30, 0x1A	; 26
    3e18:	fa 4f       	sbci	r31, 0xFA	; 250
    3e1a:	20 87       	std	Z+8, r18	; 0x08
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    3e1c:	64 e0       	ldi	r22, 0x04	; 4
    3e1e:	43 e1       	ldi	r20, 0x13	; 19
    3e20:	0e 94 f7 26 	call	0x4dee	; 0x4dee <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_1)		// Switch 1 sends granular data.
    3e24:	80 91 3f 01 	lds	r24, 0x013F
    3e28:	81 ff       	sbrs	r24, 1
    3e2a:	10 c0       	rjmp	.+32     	; 0x3e4c <DoSampler+0x326>
					{
						MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.	
    3e2c:	60 91 44 01 	lds	r22, 0x0144
    3e30:	66 95       	lsr	r22
    3e32:	80 91 2e 01 	lds	r24, 0x012E
    3e36:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <MakeNewGranularArray>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    3e3a:	20 91 44 01 	lds	r18, 0x0144
    3e3e:	26 95       	lsr	r18
    3e40:	80 91 2e 01 	lds	r24, 0x012E
    3e44:	64 e0       	ldi	r22, 0x04	; 4
    3e46:	44 e1       	ldi	r20, 0x14	; 20
    3e48:	0e 94 f7 26 	call	0x4dee	; 0x4dee <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_2)		// Switch 2 assigns our different ways of combining audio channels on the output.
    3e4c:	80 91 3f 01 	lds	r24, 0x013F
    3e50:	82 ff       	sbrs	r24, 2
    3e52:	ad c2       	rjmp	.+1370   	; 0x43ae <DoSampler+0x888>
					{
						switch(scaledEncoderValue)
    3e54:	20 91 45 01 	lds	r18, 0x0145
    3e58:	21 30       	cpi	r18, 0x01	; 1
    3e5a:	99 f0       	breq	.+38     	; 0x3e82 <DoSampler+0x35c>
    3e5c:	21 30       	cpi	r18, 0x01	; 1
    3e5e:	30 f0       	brcs	.+12     	; 0x3e6c <DoSampler+0x346>
    3e60:	22 30       	cpi	r18, 0x02	; 2
    3e62:	d9 f0       	breq	.+54     	; 0x3e9a <DoSampler+0x374>
    3e64:	23 30       	cpi	r18, 0x03	; 3
    3e66:	09 f0       	breq	.+2      	; 0x3e6a <DoSampler+0x344>
    3e68:	a2 c2       	rjmp	.+1348   	; 0x43ae <DoSampler+0x888>
    3e6a:	23 c0       	rjmp	.+70     	; 0x3eb2 <DoSampler+0x38c>
						{
							case 0:
							UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3e6c:	81 e5       	ldi	r24, 0x51	; 81
    3e6e:	98 e0       	ldi	r25, 0x08	; 8
    3e70:	90 93 e3 05 	sts	0x05E3, r25
    3e74:	80 93 e2 05 	sts	0x05E2, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3e78:	80 91 2e 01 	lds	r24, 0x012E
    3e7c:	64 e0       	ldi	r22, 0x04	; 4
    3e7e:	46 e1       	ldi	r20, 0x16	; 22
    3e80:	44 c2       	rjmp	.+1160   	; 0x430a <DoSampler+0x7e4>
							break;

							case 1:
							UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3e82:	87 e0       	ldi	r24, 0x07	; 7
    3e84:	98 e0       	ldi	r25, 0x08	; 8
    3e86:	90 93 e3 05 	sts	0x05E3, r25
    3e8a:	80 93 e2 05 	sts	0x05E2, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3e8e:	80 91 2e 01 	lds	r24, 0x012E
    3e92:	64 e0       	ldi	r22, 0x04	; 4
    3e94:	46 e1       	ldi	r20, 0x16	; 22
    3e96:	21 e0       	ldi	r18, 0x01	; 1
    3e98:	38 c2       	rjmp	.+1136   	; 0x430a <DoSampler+0x7e4>
							break;
							
							case 2:
							UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3e9a:	8c ec       	ldi	r24, 0xCC	; 204
    3e9c:	98 e0       	ldi	r25, 0x08	; 8
    3e9e:	90 93 e3 05 	sts	0x05E3, r25
    3ea2:	80 93 e2 05 	sts	0x05E2, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3ea6:	80 91 2e 01 	lds	r24, 0x012E
    3eaa:	64 e0       	ldi	r22, 0x04	; 4
    3eac:	46 e1       	ldi	r20, 0x16	; 22
    3eae:	22 e0       	ldi	r18, 0x02	; 2
    3eb0:	2c c2       	rjmp	.+1112   	; 0x430a <DoSampler+0x7e4>
							break;
							
							case 3:
							UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    3eb2:	8d e8       	ldi	r24, 0x8D	; 141
    3eb4:	98 e0       	ldi	r25, 0x08	; 8
    3eb6:	90 93 e3 05 	sts	0x05E3, r25
    3eba:	80 93 e2 05 	sts	0x05E2, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    3ebe:	80 91 2e 01 	lds	r24, 0x012E
    3ec2:	64 e0       	ldi	r22, 0x04	; 4
    3ec4:	46 e1       	ldi	r20, 0x16	; 22
    3ec6:	23 e0       	ldi	r18, 0x03	; 3
    3ec8:	20 c2       	rjmp	.+1088   	; 0x430a <DoSampler+0x7e4>
					}
				}
			}
			else
			{
				if(newKeys&Im_REC)										// Record switch pressed.
    3eca:	90 91 3f 01 	lds	r25, 0x013F
    3ece:	90 ff       	sbrs	r25, 0
    3ed0:	24 c0       	rjmp	.+72     	; 0x3f1a <DoSampler+0x3f4>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    3ed2:	20 91 2e 01 	lds	r18, 0x012E
    3ed6:	82 2f       	mov	r24, r18
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	c3 e2       	ldi	r28, 0x23	; 35
    3edc:	d0 e0       	ldi	r29, 0x00	; 0
    3ede:	8c 9f       	mul	r24, r28
    3ee0:	f0 01       	movw	r30, r0
    3ee2:	8d 9f       	mul	r24, r29
    3ee4:	f0 0d       	add	r31, r0
    3ee6:	9c 9f       	mul	r25, r28
    3ee8:	f0 0d       	add	r31, r0
    3eea:	11 24       	eor	r1, r1
    3eec:	ea 51       	subi	r30, 0x1A	; 26
    3eee:	fa 4f       	sbci	r31, 0xFA	; 250
    3ef0:	80 81       	ld	r24, Z
    3ef2:	83 30       	cpi	r24, 0x03	; 3
    3ef4:	39 f4       	brne	.+14     	; 0x3f04 <DoSampler+0x3de>
					{
						StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    3ef6:	82 2f       	mov	r24, r18
    3ef8:	61 e0       	ldi	r22, 0x01	; 1
    3efa:	40 e0       	ldi	r20, 0x00	; 0
    3efc:	50 e0       	ldi	r21, 0x00	; 0
    3efe:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <StartPlayback>
    3f02:	79 c0       	rjmp	.+242    	; 0x3ff6 <DoSampler+0x4d0>
						bankStates[currentBank].loopOnce=false;
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
					}
					else											// We're not recording right now, so start doing it.
					{
						StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    3f04:	82 2f       	mov	r24, r18
    3f06:	61 e0       	ldi	r22, 0x01	; 1
    3f08:	40 e0       	ldi	r20, 0x00	; 0
    3f0a:	50 e0       	ldi	r21, 0x00	; 0
    3f0c:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <StartRecording>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    3f10:	80 91 2e 01 	lds	r24, 0x012E
    3f14:	64 e0       	ldi	r22, 0x04	; 4
    3f16:	43 e0       	ldi	r20, 0x03	; 3
    3f18:	44 c0       	rjmp	.+136    	; 0x3fa2 <DoSampler+0x47c>
					}
				}

				else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    3f1a:	91 ff       	sbrs	r25, 1
    3f1c:	44 c0       	rjmp	.+136    	; 0x3fa6 <DoSampler+0x480>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    3f1e:	60 91 2e 01 	lds	r22, 0x012E
    3f22:	86 2f       	mov	r24, r22
    3f24:	90 e0       	ldi	r25, 0x00	; 0
    3f26:	c3 e2       	ldi	r28, 0x23	; 35
    3f28:	d0 e0       	ldi	r29, 0x00	; 0
    3f2a:	8c 9f       	mul	r24, r28
    3f2c:	f0 01       	movw	r30, r0
    3f2e:	8d 9f       	mul	r24, r29
    3f30:	f0 0d       	add	r31, r0
    3f32:	9c 9f       	mul	r25, r28
    3f34:	f0 0d       	add	r31, r0
    3f36:	11 24       	eor	r1, r1
    3f38:	ea 51       	subi	r30, 0x1A	; 26
    3f3a:	fa 4f       	sbci	r31, 0xFA	; 250
    3f3c:	80 81       	ld	r24, Z
    3f3e:	85 30       	cpi	r24, 0x05	; 5
    3f40:	c1 f4       	brne	.+48     	; 0x3f72 <DoSampler+0x44c>
					{
						ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
    3f42:	86 2f       	mov	r24, r22
    3f44:	61 e0       	ldi	r22, 0x01	; 1
    3f46:	40 e0       	ldi	r20, 0x00	; 0
    3f48:	50 e0       	ldi	r21, 0x00	; 0
    3f4a:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <ContinuePlayback>
						bankStates[currentBank].loopOnce=false;
    3f4e:	80 91 2e 01 	lds	r24, 0x012E
    3f52:	28 2f       	mov	r18, r24
    3f54:	30 e0       	ldi	r19, 0x00	; 0
    3f56:	2c 9f       	mul	r18, r28
    3f58:	f0 01       	movw	r30, r0
    3f5a:	2d 9f       	mul	r18, r29
    3f5c:	f0 0d       	add	r31, r0
    3f5e:	3c 9f       	mul	r19, r28
    3f60:	f0 0d       	add	r31, r0
    3f62:	11 24       	eor	r1, r1
    3f64:	ea 51       	subi	r30, 0x1A	; 26
    3f66:	fa 4f       	sbci	r31, 0xFA	; 250
    3f68:	11 82       	std	Z+1, r1	; 0x01
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    3f6a:	64 e0       	ldi	r22, 0x04	; 4
    3f6c:	49 e0       	ldi	r20, 0x09	; 9
    3f6e:	20 e0       	ldi	r18, 0x00	; 0
    3f70:	cc c1       	rjmp	.+920    	; 0x430a <DoSampler+0x7e4>
					}
					else							// We're not recording right now, so start doing it.
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    3f72:	20 89       	ldd	r18, Z+16	; 0x10
    3f74:	31 89       	ldd	r19, Z+17	; 0x11
    3f76:	42 89       	ldd	r20, Z+18	; 0x12
    3f78:	53 89       	ldd	r21, Z+19	; 0x13
    3f7a:	84 85       	ldd	r24, Z+12	; 0x0c
    3f7c:	95 85       	ldd	r25, Z+13	; 0x0d
    3f7e:	a6 85       	ldd	r26, Z+14	; 0x0e
    3f80:	b7 85       	ldd	r27, Z+15	; 0x0f
    3f82:	28 17       	cp	r18, r24
    3f84:	39 07       	cpc	r19, r25
    3f86:	4a 07       	cpc	r20, r26
    3f88:	5b 07       	cpc	r21, r27
    3f8a:	09 f4       	brne	.+2      	; 0x3f8e <DoSampler+0x468>
    3f8c:	10 c2       	rjmp	.+1056   	; 0x43ae <DoSampler+0x888>
						{
							StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    3f8e:	86 2f       	mov	r24, r22
    3f90:	61 e0       	ldi	r22, 0x01	; 1
    3f92:	40 e0       	ldi	r20, 0x00	; 0
    3f94:	50 e0       	ldi	r21, 0x00	; 0
    3f96:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <StartOverdub>
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    3f9a:	80 91 2e 01 	lds	r24, 0x012E
    3f9e:	64 e0       	ldi	r22, 0x04	; 4
    3fa0:	49 e0       	ldi	r20, 0x09	; 9
    3fa2:	20 e3       	ldi	r18, 0x30	; 48
    3fa4:	b2 c1       	rjmp	.+868    	; 0x430a <DoSampler+0x7e4>
						}
					}
				}
				else if(newKeys&Im_PLAY_PAUSE)		// Play / Pause switch pressed.  If anything is happening this will stop it.  Otherwise, this will start playing back AS A LOOP.  This will not restart a playing sample from the beginning.
    3fa6:	92 ff       	sbrs	r25, 2
    3fa8:	3e c0       	rjmp	.+124    	; 0x4026 <DoSampler+0x500>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    3faa:	60 91 2e 01 	lds	r22, 0x012E
    3fae:	86 2f       	mov	r24, r22
    3fb0:	90 e0       	ldi	r25, 0x00	; 0
    3fb2:	c3 e2       	ldi	r28, 0x23	; 35
    3fb4:	d0 e0       	ldi	r29, 0x00	; 0
    3fb6:	8c 9f       	mul	r24, r28
    3fb8:	f0 01       	movw	r30, r0
    3fba:	8d 9f       	mul	r24, r29
    3fbc:	f0 0d       	add	r31, r0
    3fbe:	9c 9f       	mul	r25, r28
    3fc0:	f0 0d       	add	r31, r0
    3fc2:	11 24       	eor	r1, r1
    3fc4:	ea 51       	subi	r30, 0x1A	; 26
    3fc6:	fa 4f       	sbci	r31, 0xFA	; 250
    3fc8:	80 81       	ld	r24, Z
    3fca:	88 23       	and	r24, r24
    3fcc:	31 f5       	brne	.+76     	; 0x401a <DoSampler+0x4f4>
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    3fce:	20 89       	ldd	r18, Z+16	; 0x10
    3fd0:	31 89       	ldd	r19, Z+17	; 0x11
    3fd2:	42 89       	ldd	r20, Z+18	; 0x12
    3fd4:	53 89       	ldd	r21, Z+19	; 0x13
    3fd6:	84 85       	ldd	r24, Z+12	; 0x0c
    3fd8:	95 85       	ldd	r25, Z+13	; 0x0d
    3fda:	a6 85       	ldd	r26, Z+14	; 0x0e
    3fdc:	b7 85       	ldd	r27, Z+15	; 0x0f
    3fde:	28 17       	cp	r18, r24
    3fe0:	39 07       	cpc	r19, r25
    3fe2:	4a 07       	cpc	r20, r26
    3fe4:	5b 07       	cpc	r21, r27
    3fe6:	09 f4       	brne	.+2      	; 0x3fea <DoSampler+0x4c4>
    3fe8:	e2 c1       	rjmp	.+964    	; 0x43ae <DoSampler+0x888>
						{
							ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
    3fea:	86 2f       	mov	r24, r22
    3fec:	61 e0       	ldi	r22, 0x01	; 1
    3fee:	40 e0       	ldi	r20, 0x00	; 0
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <ContinuePlayback>
							bankStates[currentBank].loopOnce=false;
    3ff6:	80 91 2e 01 	lds	r24, 0x012E
    3ffa:	28 2f       	mov	r18, r24
    3ffc:	30 e0       	ldi	r19, 0x00	; 0
    3ffe:	2c 9f       	mul	r18, r28
    4000:	f0 01       	movw	r30, r0
    4002:	2d 9f       	mul	r18, r29
    4004:	f0 0d       	add	r31, r0
    4006:	3c 9f       	mul	r19, r28
    4008:	f0 0d       	add	r31, r0
    400a:	11 24       	eor	r1, r1
    400c:	ea 51       	subi	r30, 0x1A	; 26
    400e:	fa 4f       	sbci	r31, 0xFA	; 250
    4010:	11 82       	std	Z+1, r1	; 0x01
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    4012:	61 e0       	ldi	r22, 0x01	; 1
    4014:	40 e3       	ldi	r20, 0x30	; 48
    4016:	20 e4       	ldi	r18, 0x40	; 64
    4018:	78 c1       	rjmp	.+752    	; 0x430a <DoSampler+0x7e4>
						}
					}
					else		// Pause whatever we were doing.
					{
						bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    401a:	10 82       	st	Z, r1
						bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    401c:	11 86       	std	Z+9, r1	; 0x09
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    401e:	86 2f       	mov	r24, r22
    4020:	62 e0       	ldi	r22, 0x02	; 2
    4022:	40 e3       	ldi	r20, 0x30	; 48
    4024:	a4 cf       	rjmp	.-184    	; 0x3f6e <DoSampler+0x448>
//							StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
//							bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
//							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
//						}				
//					}
				else if(newKeys&Im_BANK)		// Increment through banks when this button is pressed.
    4026:	94 ff       	sbrs	r25, 4
    4028:	0b c0       	rjmp	.+22     	; 0x4040 <DoSampler+0x51a>
				{
					currentBank++;
    402a:	80 91 2e 01 	lds	r24, 0x012E
    402e:	8f 5f       	subi	r24, 0xFF	; 255
    4030:	80 93 2e 01 	sts	0x012E, r24
					if(currentBank>=NUM_BANKS)
    4034:	82 30       	cpi	r24, 0x02	; 2
    4036:	08 f4       	brcc	.+2      	; 0x403a <DoSampler+0x514>
    4038:	ba c1       	rjmp	.+884    	; 0x43ae <DoSampler+0x888>
					{
						currentBank=BANK_0;		// Loop around.
    403a:	10 92 2e 01 	sts	0x012E, r1
    403e:	b7 c1       	rjmp	.+878    	; 0x43ae <DoSampler+0x888>
					}
				}
// ------------------------------------
// FLASH TEST
				else if(newKeys&Im_SWITCH_6)	// Write sample to slot 0 from bank 0
    4040:	96 ff       	sbrs	r25, 6
    4042:	da c0       	rjmp	.+436    	; 0x41f8 <DoSampler+0x6d2>
				{
					WriteSampleToSd(currentBank,0);				
    4044:	60 91 2e 01 	lds	r22, 0x012E
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    4048:	80 91 59 02 	lds	r24, 0x0259
    404c:	8e 30       	cpi	r24, 0x0E	; 14
    404e:	09 f0       	breq	.+2      	; 0x4052 <DoSampler+0x52c>
    4050:	ae c1       	rjmp	.+860    	; 0x43ae <DoSampler+0x888>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    4052:	c6 2f       	mov	r28, r22
    4054:	d0 e0       	ldi	r29, 0x00	; 0
    4056:	83 e2       	ldi	r24, 0x23	; 35
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	c8 9f       	mul	r28, r24
    405c:	f0 01       	movw	r30, r0
    405e:	c9 9f       	mul	r28, r25
    4060:	f0 0d       	add	r31, r0
    4062:	d8 9f       	mul	r29, r24
    4064:	f0 0d       	add	r31, r0
    4066:	11 24       	eor	r1, r1
    4068:	ea 51       	subi	r30, 0x1A	; 26
    406a:	fa 4f       	sbci	r31, 0xFA	; 250
    406c:	85 81       	ldd	r24, Z+5	; 0x05
    406e:	88 23       	and	r24, r24
    4070:	09 f0       	breq	.+2      	; 0x4074 <DoSampler+0x54e>
    4072:	9d c1       	rjmp	.+826    	; 0x43ae <DoSampler+0x888>
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    4074:	66 23       	and	r22, r22
    4076:	89 f4       	brne	.+34     	; 0x409a <DoSampler+0x574>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    4078:	86 81       	ldd	r24, Z+6	; 0x06
    407a:	88 23       	and	r24, r24
    407c:	49 f4       	brne	.+18     	; 0x4090 <DoSampler+0x56a>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    407e:	24 89       	ldd	r18, Z+20	; 0x14
    4080:	35 89       	ldd	r19, Z+21	; 0x15
    4082:	46 89       	ldd	r20, Z+22	; 0x16
    4084:	57 89       	ldd	r21, Z+23	; 0x17
    4086:	80 8d       	ldd	r24, Z+24	; 0x18
    4088:	91 8d       	ldd	r25, Z+25	; 0x19
    408a:	a2 8d       	ldd	r26, Z+26	; 0x1a
    408c:	b3 8d       	ldd	r27, Z+27	; 0x1b
    408e:	10 c0       	rjmp	.+32     	; 0x40b0 <DoSampler+0x58a>
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    4090:	24 85       	ldd	r18, Z+12	; 0x0c
    4092:	35 85       	ldd	r19, Z+13	; 0x0d
    4094:	46 85       	ldd	r20, Z+14	; 0x0e
    4096:	57 85       	ldd	r21, Z+15	; 0x0f
    4098:	1c c0       	rjmp	.+56     	; 0x40d2 <DoSampler+0x5ac>
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    409a:	86 81       	ldd	r24, Z+6	; 0x06
    409c:	88 23       	and	r24, r24
    409e:	69 f4       	brne	.+26     	; 0x40ba <DoSampler+0x594>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    40a0:	20 8d       	ldd	r18, Z+24	; 0x18
    40a2:	31 8d       	ldd	r19, Z+25	; 0x19
    40a4:	42 8d       	ldd	r20, Z+26	; 0x1a
    40a6:	53 8d       	ldd	r21, Z+27	; 0x1b
    40a8:	84 89       	ldd	r24, Z+20	; 0x14
    40aa:	95 89       	ldd	r25, Z+21	; 0x15
    40ac:	a6 89       	ldd	r26, Z+22	; 0x16
    40ae:	b7 89       	ldd	r27, Z+23	; 0x17
    40b0:	2f 5f       	subi	r18, 0xFF	; 255
    40b2:	3f 4f       	sbci	r19, 0xFF	; 255
    40b4:	4f 4f       	sbci	r20, 0xFF	; 255
    40b6:	5f 4f       	sbci	r21, 0xFF	; 255
    40b8:	08 c0       	rjmp	.+16     	; 0x40ca <DoSampler+0x5a4>
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    40ba:	20 89       	ldd	r18, Z+16	; 0x10
    40bc:	31 89       	ldd	r19, Z+17	; 0x11
    40be:	42 89       	ldd	r20, Z+18	; 0x12
    40c0:	53 89       	ldd	r21, Z+19	; 0x13
    40c2:	84 85       	ldd	r24, Z+12	; 0x0c
    40c4:	95 85       	ldd	r25, Z+13	; 0x0d
    40c6:	a6 85       	ldd	r26, Z+14	; 0x0e
    40c8:	b7 85       	ldd	r27, Z+15	; 0x0f
    40ca:	28 1b       	sub	r18, r24
    40cc:	39 0b       	sbc	r19, r25
    40ce:	4a 0b       	sbc	r20, r26
    40d0:	5b 0b       	sbc	r21, r27
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    40d2:	1f b7       	in	r17, 0x3f	; 63
			cli();		// Pause ISR
    40d4:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    40d6:	7f b7       	in	r23, 0x3f	; 63
	cli();		// Pause ISR
    40d8:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    40da:	10 92 b2 05 	sts	0x05B2, r1
    40de:	10 92 b1 05 	sts	0x05B1, r1
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    40e2:	81 e0       	ldi	r24, 0x01	; 1
    40e4:	90 e0       	ldi	r25, 0x00	; 0
    40e6:	a0 e0       	ldi	r26, 0x00	; 0
    40e8:	b0 e0       	ldi	r27, 0x00	; 0
    40ea:	80 93 a5 05 	sts	0x05A5, r24
    40ee:	90 93 a6 05 	sts	0x05A6, r25
    40f2:	a0 93 a7 05 	sts	0x05A7, r26
    40f6:	b0 93 a8 05 	sts	0x05A8, r27
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    40fa:	10 92 b4 05 	sts	0x05B4, r1
    40fe:	10 92 b3 05 	sts	0x05B3, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    4102:	10 92 9b 05 	sts	0x059B, r1
    4106:	10 92 9a 05 	sts	0x059A, r1
	sdFifoWritePointer=0;
    410a:	10 92 9d 05 	sts	0x059D, r1
    410e:	10 92 9c 05 	sts	0x059C, r1
	sdBytesInFifo=0;
    4112:	10 92 9f 05 	sts	0x059F, r1
    4116:	10 92 9e 05 	sts	0x059E, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    411a:	2d 3f       	cpi	r18, 0xFD	; 253
    411c:	ff ef       	ldi	r31, 0xFF	; 255
    411e:	3f 07       	cpc	r19, r31
    4120:	f7 e0       	ldi	r31, 0x07	; 7
    4122:	4f 07       	cpc	r20, r31
    4124:	f0 e0       	ldi	r31, 0x00	; 0
    4126:	5f 07       	cpc	r21, r31
    4128:	48 f4       	brcc	.+18     	; 0x413c <DoSampler+0x616>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
    412a:	20 93 a9 05 	sts	0x05A9, r18
    412e:	30 93 aa 05 	sts	0x05AA, r19
    4132:	40 93 ab 05 	sts	0x05AB, r20
    4136:	50 93 ac 05 	sts	0x05AC, r21
    413a:	0c c0       	rjmp	.+24     	; 0x4154 <DoSampler+0x62e>
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    413c:	8c ef       	ldi	r24, 0xFC	; 252
    413e:	9f ef       	ldi	r25, 0xFF	; 255
    4140:	a7 e0       	ldi	r26, 0x07	; 7
    4142:	b0 e0       	ldi	r27, 0x00	; 0
    4144:	80 93 a9 05 	sts	0x05A9, r24
    4148:	90 93 aa 05 	sts	0x05AA, r25
    414c:	a0 93 ab 05 	sts	0x05AB, r26
    4150:	b0 93 ac 05 	sts	0x05AC, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    4154:	80 91 a9 05 	lds	r24, 0x05A9
    4158:	90 91 aa 05 	lds	r25, 0x05AA
    415c:	a0 91 ab 05 	lds	r26, 0x05AB
    4160:	b0 91 ac 05 	lds	r27, 0x05AC
    4164:	80 93 ad 05 	sts	0x05AD, r24
    4168:	90 93 ae 05 	sts	0x05AE, r25
    416c:	a0 93 af 05 	sts	0x05AF, r26
    4170:	b0 93 b0 05 	sts	0x05B0, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start 
    4174:	82 e0       	ldi	r24, 0x02	; 2
    4176:	80 93 59 02 	sts	0x0259, r24
	SREG=sreg;	// Resume ISR
    417a:	7f bf       	out	0x3f, r23	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;
	
	sreg=SREG;
    417c:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    417e:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    4180:	80 93 b5 05 	sts	0x05B5, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    4184:	83 e2       	ldi	r24, 0x23	; 35
    4186:	90 e0       	ldi	r25, 0x00	; 0
    4188:	c8 9f       	mul	r28, r24
    418a:	f0 01       	movw	r30, r0
    418c:	c9 9f       	mul	r28, r25
    418e:	f0 0d       	add	r31, r0
    4190:	d8 9f       	mul	r29, r24
    4192:	f0 0d       	add	r31, r0
    4194:	11 24       	eor	r1, r1
    4196:	ea 51       	subi	r30, 0x1A	; 26
    4198:	fa 4f       	sbci	r31, 0xFA	; 250
    419a:	81 e0       	ldi	r24, 0x01	; 1
    419c:	85 83       	std	Z+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    419e:	66 23       	and	r22, r22
    41a0:	59 f4       	brne	.+22     	; 0x41b8 <DoSampler+0x692>
	{
		sdBank0=true;
    41a2:	80 93 ba 05 	sts	0x05BA, r24
		sdRamAddress=BANK_0_START_ADDRESS;		
    41a6:	10 92 b6 05 	sts	0x05B6, r1
    41aa:	10 92 b7 05 	sts	0x05B7, r1
    41ae:	10 92 b8 05 	sts	0x05B8, r1
    41b2:	10 92 b9 05 	sts	0x05B9, r1
    41b6:	0e c0       	rjmp	.+28     	; 0x41d4 <DoSampler+0x6ae>
	}
	else
	{
		sdBank0=false;
    41b8:	10 92 ba 05 	sts	0x05BA, r1
		sdRamAddress=BANK_1_START_ADDRESS;		
    41bc:	8f ef       	ldi	r24, 0xFF	; 255
    41be:	9f ef       	ldi	r25, 0xFF	; 255
    41c0:	a7 e0       	ldi	r26, 0x07	; 7
    41c2:	b0 e0       	ldi	r27, 0x00	; 0
    41c4:	80 93 b6 05 	sts	0x05B6, r24
    41c8:	90 93 b7 05 	sts	0x05B7, r25
    41cc:	a0 93 b8 05 	sts	0x05B8, r26
    41d0:	b0 93 b9 05 	sts	0x05B9, r27
	}	

	TCNT2=0;			// Init counter reg
    41d4:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    41d8:	81 e6       	ldi	r24, 0x61	; 97
    41da:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    41de:	8f ef       	ldi	r24, 0xFF	; 255
    41e0:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    41e2:	80 91 70 00 	lds	r24, 0x0070
    41e6:	84 60       	ori	r24, 0x04	; 4
    41e8:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    41ec:	82 e0       	ldi	r24, 0x02	; 2
    41ee:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs		
    41f2:	2f bf       	out	0x3f, r18	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    41f4:	1f bf       	out	0x3f, r17	; 63
    41f6:	db c0       	rjmp	.+438    	; 0x43ae <DoSampler+0x888>
// FLASH TEST
				else if(newKeys&Im_SWITCH_6)	// Write sample to slot 0 from bank 0
				{
					WriteSampleToSd(currentBank,0);				
				}
				else if(newKeys&Im_SWITCH_7)	// Read sample from slot 0 to bank 0
    41f8:	97 ff       	sbrs	r25, 7
    41fa:	5d c0       	rjmp	.+186    	; 0x42b6 <DoSampler+0x790>
				{
					ReadSampleFromSd(currentBank,0);								
    41fc:	10 91 2e 01 	lds	r17, 0x012E
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    4200:	80 91 59 02 	lds	r24, 0x0259
    4204:	8e 30       	cpi	r24, 0x0E	; 14
    4206:	09 f0       	breq	.+2      	; 0x420a <DoSampler+0x6e4>
    4208:	d2 c0       	rjmp	.+420    	; 0x43ae <DoSampler+0x888>
	{		
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    420a:	81 2f       	mov	r24, r17
    420c:	90 e0       	ldi	r25, 0x00	; 0
    420e:	23 e2       	ldi	r18, 0x23	; 35
    4210:	30 e0       	ldi	r19, 0x00	; 0
    4212:	82 9f       	mul	r24, r18
    4214:	e0 01       	movw	r28, r0
    4216:	83 9f       	mul	r24, r19
    4218:	d0 0d       	add	r29, r0
    421a:	92 9f       	mul	r25, r18
    421c:	d0 0d       	add	r29, r0
    421e:	11 24       	eor	r1, r1
    4220:	ca 51       	subi	r28, 0x1A	; 26
    4222:	da 4f       	sbci	r29, 0xFA	; 250
    4224:	8d 81       	ldd	r24, Y+5	; 0x05
    4226:	88 23       	and	r24, r24
    4228:	09 f0       	breq	.+2      	; 0x422c <DoSampler+0x706>
    422a:	c1 c0       	rjmp	.+386    	; 0x43ae <DoSampler+0x888>
		{
			sreg=SREG;
    422c:	0f b7       	in	r16, 0x3f	; 63
			cli();		// Pause ISR
    422e:	f8 94       	cli

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
    4230:	80 e0       	ldi	r24, 0x00	; 0
    4232:	90 e0       	ldi	r25, 0x00	; 0
    4234:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    4238:	81 e0       	ldi	r24, 0x01	; 1
    423a:	90 e0       	ldi	r25, 0x00	; 0
    423c:	a0 e0       	ldi	r26, 0x00	; 0
    423e:	b0 e0       	ldi	r27, 0x00	; 0
    4240:	80 93 a9 05 	sts	0x05A9, r24
    4244:	90 93 aa 05 	sts	0x05AA, r25
    4248:	a0 93 ab 05 	sts	0x05AB, r26
    424c:	b0 93 ac 05 	sts	0x05AC, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;
	
	sreg=SREG;
    4250:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    4252:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    4254:	81 e0       	ldi	r24, 0x01	; 1
    4256:	80 93 b5 05 	sts	0x05B5, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    425a:	8d 83       	std	Y+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    425c:	11 23       	and	r17, r17
    425e:	59 f4       	brne	.+22     	; 0x4276 <DoSampler+0x750>
	{
		sdBank0=true;
    4260:	80 93 ba 05 	sts	0x05BA, r24
		sdRamAddress=BANK_0_START_ADDRESS;		
    4264:	10 92 b6 05 	sts	0x05B6, r1
    4268:	10 92 b7 05 	sts	0x05B7, r1
    426c:	10 92 b8 05 	sts	0x05B8, r1
    4270:	10 92 b9 05 	sts	0x05B9, r1
    4274:	0e c0       	rjmp	.+28     	; 0x4292 <DoSampler+0x76c>
	}
	else
	{
		sdBank0=false;
    4276:	10 92 ba 05 	sts	0x05BA, r1
		sdRamAddress=BANK_1_START_ADDRESS;		
    427a:	8f ef       	ldi	r24, 0xFF	; 255
    427c:	9f ef       	ldi	r25, 0xFF	; 255
    427e:	a7 e0       	ldi	r26, 0x07	; 7
    4280:	b0 e0       	ldi	r27, 0x00	; 0
    4282:	80 93 b6 05 	sts	0x05B6, r24
    4286:	90 93 b7 05 	sts	0x05B7, r25
    428a:	a0 93 b8 05 	sts	0x05B8, r26
    428e:	b0 93 b9 05 	sts	0x05B9, r27
	}	

	TCNT2=0;			// Init counter reg
    4292:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    4296:	81 e6       	ldi	r24, 0x61	; 97
    4298:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    429c:	8f ef       	ldi	r24, 0xFF	; 255
    429e:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    42a0:	80 91 70 00 	lds	r24, 0x0070
    42a4:	84 60       	ori	r24, 0x04	; 4
    42a6:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    42aa:	82 e0       	ldi	r24, 0x02	; 2
    42ac:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs		
    42b0:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    42b2:	0f bf       	out	0x3f, r16	; 63
    42b4:	7c c0       	rjmp	.+248    	; 0x43ae <DoSampler+0x888>
				}
				else if(newKeys&Im_SWITCH_7)	// Read sample from slot 0 to bank 0
				{
					ReadSampleFromSd(currentBank,0);								
				}
				else if(newKeys&Im_SINGLE_PLAY)		// @@@TEST Play direct from the SD
    42b6:	93 ff       	sbrs	r25, 3
    42b8:	7a c0       	rjmp	.+244    	; 0x43ae <DoSampler+0x888>
				{
					PlaySampleFromSd(BANK_0,0);								
    42ba:	80 e0       	ldi	r24, 0x00	; 0
    42bc:	60 e0       	ldi	r22, 0x00	; 0
    42be:	70 e0       	ldi	r23, 0x00	; 0
    42c0:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <PlaySampleFromSd>
    42c4:	74 c0       	rjmp	.+232    	; 0x43ae <DoSampler+0x888>
// ------------------------------------
			}
		}
		else	// In edit mode.
		{
			if(keyState&Im_SWITCH_0)		// Adjust start (three button combo)
    42c6:	90 ff       	sbrs	r25, 0
    42c8:	23 c0       	rjmp	.+70     	; 0x4310 <DoSampler+0x7ea>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    42ca:	40 91 2e 01 	lds	r20, 0x012E
    42ce:	84 2f       	mov	r24, r20
    42d0:	90 e0       	ldi	r25, 0x00	; 0
    42d2:	23 e2       	ldi	r18, 0x23	; 35
    42d4:	30 e0       	ldi	r19, 0x00	; 0
    42d6:	82 9f       	mul	r24, r18
    42d8:	f0 01       	movw	r30, r0
    42da:	83 9f       	mul	r24, r19
    42dc:	f0 0d       	add	r31, r0
    42de:	92 9f       	mul	r25, r18
    42e0:	f0 0d       	add	r31, r0
    42e2:	11 24       	eor	r1, r1
    42e4:	ea 51       	subi	r30, 0x1A	; 26
    42e6:	fa 4f       	sbci	r31, 0xFA	; 250
    42e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    42ea:	90 91 44 01 	lds	r25, 0x0144
    42ee:	89 17       	cp	r24, r25
    42f0:	09 f4       	brne	.+2      	; 0x42f4 <DoSampler+0x7ce>
    42f2:	5d c0       	rjmp	.+186    	; 0x43ae <DoSampler+0x888>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    42f4:	94 8f       	std	Z+28, r25	; 0x1c
	UpdateAdjustedSampleAddresses(theBank);
    42f6:	84 2f       	mov	r24, r20
    42f8:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleStart(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,i);		// Send it out to the techno nerds.			
    42fc:	20 91 44 01 	lds	r18, 0x0144
    4300:	26 95       	lsr	r18
    4302:	80 91 2e 01 	lds	r24, 0x012E
    4306:	64 e0       	ldi	r22, 0x04	; 4
    4308:	4c e1       	ldi	r20, 0x1C	; 28
    430a:	0e 94 f7 26 	call	0x4dee	; 0x4dee <PutMidiMessageInOutgoingFifo>
    430e:	4f c0       	rjmp	.+158    	; 0x43ae <DoSampler+0x888>
				}
			}
			else if(keyState&Im_SWITCH_1)		// Adjust end (three button combo)
    4310:	91 ff       	sbrs	r25, 1
    4312:	20 c0       	rjmp	.+64     	; 0x4354 <DoSampler+0x82e>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    4314:	40 91 2e 01 	lds	r20, 0x012E
    4318:	84 2f       	mov	r24, r20
    431a:	90 e0       	ldi	r25, 0x00	; 0
    431c:	23 e2       	ldi	r18, 0x23	; 35
    431e:	30 e0       	ldi	r19, 0x00	; 0
    4320:	82 9f       	mul	r24, r18
    4322:	f0 01       	movw	r30, r0
    4324:	83 9f       	mul	r24, r19
    4326:	f0 0d       	add	r31, r0
    4328:	92 9f       	mul	r25, r18
    432a:	f0 0d       	add	r31, r0
    432c:	11 24       	eor	r1, r1
    432e:	ea 51       	subi	r30, 0x1A	; 26
    4330:	fa 4f       	sbci	r31, 0xFA	; 250
    4332:	85 8d       	ldd	r24, Z+29	; 0x1d
    4334:	90 91 44 01 	lds	r25, 0x0144
    4338:	89 17       	cp	r24, r25
    433a:	c9 f1       	breq	.+114    	; 0x43ae <DoSampler+0x888>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    433c:	95 8f       	std	Z+29, r25	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    433e:	84 2f       	mov	r24, r20
    4340:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleEnd(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,i);		// Send it out to the techno nerds.			
    4344:	20 91 44 01 	lds	r18, 0x0144
    4348:	26 95       	lsr	r18
    434a:	80 91 2e 01 	lds	r24, 0x012E
    434e:	64 e0       	ldi	r22, 0x04	; 4
    4350:	4d e1       	ldi	r20, 0x1D	; 29
    4352:	db cf       	rjmp	.-74     	; 0x430a <DoSampler+0x7e4>
				}
			}
			else if(keyState&Im_SWITCH_2)		// Adjust window (three button combo)
    4354:	92 ff       	sbrs	r25, 2
    4356:	20 c0       	rjmp	.+64     	; 0x4398 <DoSampler+0x872>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    4358:	40 91 2e 01 	lds	r20, 0x012E
    435c:	84 2f       	mov	r24, r20
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	23 e2       	ldi	r18, 0x23	; 35
    4362:	30 e0       	ldi	r19, 0x00	; 0
    4364:	82 9f       	mul	r24, r18
    4366:	f0 01       	movw	r30, r0
    4368:	83 9f       	mul	r24, r19
    436a:	f0 0d       	add	r31, r0
    436c:	92 9f       	mul	r25, r18
    436e:	f0 0d       	add	r31, r0
    4370:	11 24       	eor	r1, r1
    4372:	ea 51       	subi	r30, 0x1A	; 26
    4374:	fa 4f       	sbci	r31, 0xFA	; 250
    4376:	86 8d       	ldd	r24, Z+30	; 0x1e
    4378:	90 91 44 01 	lds	r25, 0x0144
    437c:	89 17       	cp	r24, r25
    437e:	b9 f0       	breq	.+46     	; 0x43ae <DoSampler+0x888>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    4380:	96 8f       	std	Z+30, r25	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    4382:	84 2f       	mov	r24, r20
    4384:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleWindow(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,i);		// Send it out to the techno nerds.			
    4388:	20 91 44 01 	lds	r18, 0x0144
    438c:	26 95       	lsr	r18
    438e:	80 91 2e 01 	lds	r24, 0x012E
    4392:	64 e0       	ldi	r22, 0x04	; 4
    4394:	4e e1       	ldi	r20, 0x1E	; 30
    4396:	b9 cf       	rjmp	.-142    	; 0x430a <DoSampler+0x7e4>
				}
			}
			else if(newKeys&Im_SWITCH_3||newKeys&Im_SWITCH_4||newKeys&Im_SWITCH_5)	// Non edit-mode key hit, bail from edit mode.
    4398:	80 91 3f 01 	lds	r24, 0x013F
    439c:	90 e0       	ldi	r25, 0x00	; 0
    439e:	83 fd       	sbrc	r24, 3
    43a0:	04 c0       	rjmp	.+8      	; 0x43aa <DoSampler+0x884>
    43a2:	80 73       	andi	r24, 0x30	; 48
    43a4:	90 70       	andi	r25, 0x00	; 0
    43a6:	89 2b       	or	r24, r25
    43a8:	11 f0       	breq	.+4      	; 0x43ae <DoSampler+0x888>
			{
				editModeEntered=false;				
    43aa:	10 92 27 01 	sts	0x0127, r1
			}		
		}
		
// Dealt with Caveman inputs, now deal with MIDI.

		if(midiMessagesInIncomingFifo)
    43ae:	80 91 60 06 	lds	r24, 0x0660
    43b2:	88 23       	and	r24, r24
    43b4:	09 f4       	brne	.+2      	; 0x43b8 <DoSampler+0x892>
    43b6:	19 c3       	rjmp	.+1586   	; 0x49ea <DoSampler+0xec4>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    43b8:	8a e2       	ldi	r24, 0x2A	; 42
    43ba:	91 e0       	ldi	r25, 0x01	; 1
    43bc:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <GetMidiMessageFromIncomingFifo>
			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
			{
				// Do this here.
			}
*/
			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    43c0:	80 91 2b 01 	lds	r24, 0x012B
    43c4:	82 30       	cpi	r24, 0x02	; 2
    43c6:	c1 f5       	brne	.+112    	; 0x4438 <DoSampler+0x912>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    43c8:	80 91 2a 01 	lds	r24, 0x012A
    43cc:	48 2f       	mov	r20, r24
    43ce:	50 e0       	ldi	r21, 0x00	; 0
    43d0:	83 e2       	ldi	r24, 0x23	; 35
    43d2:	90 e0       	ldi	r25, 0x00	; 0
    43d4:	48 9f       	mul	r20, r24
    43d6:	f0 01       	movw	r30, r0
    43d8:	49 9f       	mul	r20, r25
    43da:	f0 0d       	add	r31, r0
    43dc:	58 9f       	mul	r21, r24
    43de:	f0 0d       	add	r31, r0
    43e0:	11 24       	eor	r1, r1
    43e2:	ea 51       	subi	r30, 0x1A	; 26
    43e4:	fa 4f       	sbci	r31, 0xFA	; 250
    43e6:	80 81       	ld	r24, Z
    43e8:	84 30       	cpi	r24, 0x04	; 4
    43ea:	21 f0       	breq	.+8      	; 0x43f4 <DoSampler+0x8ce>
    43ec:	80 81       	ld	r24, Z
    43ee:	82 30       	cpi	r24, 0x02	; 2
    43f0:	09 f0       	breq	.+2      	; 0x43f4 <DoSampler+0x8ce>
    43f2:	fb c2       	rjmp	.+1526   	; 0x49ea <DoSampler+0xec4>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    43f4:	fa 01       	movw	r30, r20
    43f6:	ec 5f       	subi	r30, 0xFC	; 252
    43f8:	fe 4f       	sbci	r31, 0xFE	; 254
    43fa:	90 91 2c 01 	lds	r25, 0x012C
    43fe:	80 81       	ld	r24, Z
    4400:	98 17       	cp	r25, r24
    4402:	09 f0       	breq	.+2      	; 0x4406 <DoSampler+0x8e0>
    4404:	f2 c2       	rjmp	.+1508   	; 0x49ea <DoSampler+0xec4>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    4406:	23 e2       	ldi	r18, 0x23	; 35
    4408:	30 e0       	ldi	r19, 0x00	; 0
    440a:	42 9f       	mul	r20, r18
    440c:	f0 01       	movw	r30, r0
    440e:	43 9f       	mul	r20, r19
    4410:	f0 0d       	add	r31, r0
    4412:	52 9f       	mul	r21, r18
    4414:	f0 0d       	add	r31, r0
    4416:	11 24       	eor	r1, r1
    4418:	ea 51       	subi	r30, 0x1A	; 26
    441a:	fa 4f       	sbci	r31, 0xFA	; 250
    441c:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
    441e:	80 91 2a 01 	lds	r24, 0x012A
    4422:	90 e0       	ldi	r25, 0x00	; 0
    4424:	82 9f       	mul	r24, r18
    4426:	f0 01       	movw	r30, r0
    4428:	83 9f       	mul	r24, r19
    442a:	f0 0d       	add	r31, r0
    442c:	92 9f       	mul	r25, r18
    442e:	f0 0d       	add	r31, r0
    4430:	11 24       	eor	r1, r1
    4432:	ea 51       	subi	r30, 0x1A	; 26
    4434:	fa 4f       	sbci	r31, 0xFA	; 250
    4436:	76 c0       	rjmp	.+236    	; 0x4524 <DoSampler+0x9fe>
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    4438:	81 30       	cpi	r24, 0x01	; 1
    443a:	d9 f5       	brne	.+118    	; 0x44b2 <DoSampler+0x98c>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    443c:	10 91 2a 01 	lds	r17, 0x012A
    4440:	21 2f       	mov	r18, r17
    4442:	30 e0       	ldi	r19, 0x00	; 0
    4444:	f9 01       	movw	r30, r18
    4446:	ec 5f       	subi	r30, 0xFC	; 252
    4448:	fe 4f       	sbci	r31, 0xFE	; 254
    444a:	60 91 2c 01 	lds	r22, 0x012C
    444e:	60 83       	st	Z, r22

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
    4450:	f9 01       	movw	r30, r18
    4452:	e8 5d       	subi	r30, 0xD8	; 216
    4454:	fe 4f       	sbci	r31, 0xFE	; 254
    4456:	80 81       	ld	r24, Z
    4458:	88 23       	and	r24, r24
    445a:	49 f0       	breq	.+18     	; 0x446e <DoSampler+0x948>
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.		
    445c:	86 2f       	mov	r24, r22
    445e:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    4462:	ac 01       	movw	r20, r24
    4464:	81 2f       	mov	r24, r17
    4466:	62 e0       	ldi	r22, 0x02	; 2
    4468:	0e 94 57 0e 	call	0x1cae	; 0x1cae <StartRealtime>
    446c:	be c2       	rjmp	.+1404   	; 0x49ea <DoSampler+0xec4>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    446e:	83 e2       	ldi	r24, 0x23	; 35
    4470:	90 e0       	ldi	r25, 0x00	; 0
    4472:	28 9f       	mul	r18, r24
    4474:	f0 01       	movw	r30, r0
    4476:	29 9f       	mul	r18, r25
    4478:	f0 0d       	add	r31, r0
    447a:	38 9f       	mul	r19, r24
    447c:	f0 0d       	add	r31, r0
    447e:	11 24       	eor	r1, r1
    4480:	ea 51       	subi	r30, 0x1A	; 26
    4482:	fa 4f       	sbci	r31, 0xFA	; 250
    4484:	20 89       	ldd	r18, Z+16	; 0x10
    4486:	31 89       	ldd	r19, Z+17	; 0x11
    4488:	42 89       	ldd	r20, Z+18	; 0x12
    448a:	53 89       	ldd	r21, Z+19	; 0x13
    448c:	84 85       	ldd	r24, Z+12	; 0x0c
    448e:	95 85       	ldd	r25, Z+13	; 0x0d
    4490:	a6 85       	ldd	r26, Z+14	; 0x0e
    4492:	b7 85       	ldd	r27, Z+15	; 0x0f
    4494:	28 17       	cp	r18, r24
    4496:	39 07       	cpc	r19, r25
    4498:	4a 07       	cpc	r20, r26
    449a:	5b 07       	cpc	r21, r27
    449c:	09 f4       	brne	.+2      	; 0x44a0 <DoSampler+0x97a>
    449e:	a5 c2       	rjmp	.+1354   	; 0x49ea <DoSampler+0xec4>
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    44a0:	86 2f       	mov	r24, r22
    44a2:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    44a6:	ac 01       	movw	r20, r24
    44a8:	81 2f       	mov	r24, r17
    44aa:	62 e0       	ldi	r22, 0x02	; 2
    44ac:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <StartPlayback>
    44b0:	9c c2       	rjmp	.+1336   	; 0x49ea <DoSampler+0xec4>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    44b2:	84 30       	cpi	r24, 0x04	; 4
    44b4:	09 f0       	breq	.+2      	; 0x44b8 <DoSampler+0x992>
    44b6:	55 c2       	rjmp	.+1194   	; 0x4962 <DoSampler+0xe3c>
			{
				switch(currentMidiMessage.dataByteOne)
    44b8:	80 91 2c 01 	lds	r24, 0x012C
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	fc 01       	movw	r30, r24
    44c0:	33 97       	sbiw	r30, 0x03	; 3
    44c2:	ec 31       	cpi	r30, 0x1C	; 28
    44c4:	f1 05       	cpc	r31, r1
    44c6:	08 f0       	brcs	.+2      	; 0x44ca <DoSampler+0x9a4>
    44c8:	90 c2       	rjmp	.+1312   	; 0x49ea <DoSampler+0xec4>
    44ca:	e2 5c       	subi	r30, 0xC2	; 194
    44cc:	ff 4f       	sbci	r31, 0xFF	; 255
    44ce:	ee 0f       	add	r30, r30
    44d0:	ff 1f       	adc	r31, r31
    44d2:	05 90       	lpm	r0, Z+
    44d4:	f4 91       	lpm	r31, Z+
    44d6:	e0 2d       	mov	r30, r0
    44d8:	09 94       	ijmp
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    44da:	80 91 2d 01 	lds	r24, 0x012D
    44de:	88 23       	and	r24, r24
    44e0:	71 f0       	breq	.+28     	; 0x44fe <DoSampler+0x9d8>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    44e2:	80 91 2a 01 	lds	r24, 0x012A
    44e6:	e8 2f       	mov	r30, r24
    44e8:	f0 e0       	ldi	r31, 0x00	; 0
    44ea:	ee 0f       	add	r30, r30
    44ec:	ff 1f       	adc	r31, r31
    44ee:	ef 53       	subi	r30, 0x3F	; 63
    44f0:	fa 4f       	sbci	r31, 0xFA	; 250
    44f2:	40 81       	ld	r20, Z
    44f4:	51 81       	ldd	r21, Z+1	; 0x01
    44f6:	62 e0       	ldi	r22, 0x02	; 2
    44f8:	0e 94 27 0d 	call	0x1a4e	; 0x1a4e <StartRecording>
    44fc:	3e c0       	rjmp	.+124    	; 0x457a <DoSampler+0xa54>
						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback after a recording.	
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    44fe:	80 91 2a 01 	lds	r24, 0x012A
    4502:	90 e0       	ldi	r25, 0x00	; 0
    4504:	23 e2       	ldi	r18, 0x23	; 35
    4506:	30 e0       	ldi	r19, 0x00	; 0
    4508:	82 9f       	mul	r24, r18
    450a:	f0 01       	movw	r30, r0
    450c:	83 9f       	mul	r24, r19
    450e:	f0 0d       	add	r31, r0
    4510:	92 9f       	mul	r25, r18
    4512:	f0 0d       	add	r31, r0
    4514:	11 24       	eor	r1, r1
    4516:	ea 51       	subi	r30, 0x1A	; 26
    4518:	fa 4f       	sbci	r31, 0xFA	; 250
    451a:	80 81       	ld	r24, Z
    451c:	83 30       	cpi	r24, 0x03	; 3
    451e:	09 f0       	breq	.+2      	; 0x4522 <DoSampler+0x9fc>
    4520:	64 c2       	rjmp	.+1224   	; 0x49ea <DoSampler+0xec4>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    4522:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    4524:	11 86       	std	Z+9, r1	; 0x09
    4526:	61 c2       	rjmp	.+1218   	; 0x49ea <DoSampler+0xec4>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    4528:	80 91 2d 01 	lds	r24, 0x012D
    452c:	88 23       	and	r24, r24
    452e:	61 f1       	breq	.+88     	; 0x4588 <DoSampler+0xa62>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    4530:	60 91 2a 01 	lds	r22, 0x012A
    4534:	c6 2f       	mov	r28, r22
    4536:	d0 e0       	ldi	r29, 0x00	; 0
    4538:	83 e2       	ldi	r24, 0x23	; 35
    453a:	90 e0       	ldi	r25, 0x00	; 0
    453c:	c8 9f       	mul	r28, r24
    453e:	f0 01       	movw	r30, r0
    4540:	c9 9f       	mul	r28, r25
    4542:	f0 0d       	add	r31, r0
    4544:	d8 9f       	mul	r29, r24
    4546:	f0 0d       	add	r31, r0
    4548:	11 24       	eor	r1, r1
    454a:	ea 51       	subi	r30, 0x1A	; 26
    454c:	fa 4f       	sbci	r31, 0xFA	; 250
    454e:	20 89       	ldd	r18, Z+16	; 0x10
    4550:	31 89       	ldd	r19, Z+17	; 0x11
    4552:	42 89       	ldd	r20, Z+18	; 0x12
    4554:	53 89       	ldd	r21, Z+19	; 0x13
    4556:	84 85       	ldd	r24, Z+12	; 0x0c
    4558:	95 85       	ldd	r25, Z+13	; 0x0d
    455a:	a6 85       	ldd	r26, Z+14	; 0x0e
    455c:	b7 85       	ldd	r27, Z+15	; 0x0f
    455e:	28 17       	cp	r18, r24
    4560:	39 07       	cpc	r19, r25
    4562:	4a 07       	cpc	r20, r26
    4564:	5b 07       	cpc	r21, r27
    4566:	09 f4       	brne	.+2      	; 0x456a <DoSampler+0xa44>
    4568:	40 c2       	rjmp	.+1152   	; 0x49ea <DoSampler+0xec4>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    456a:	cc 5f       	subi	r28, 0xFC	; 252
    456c:	de 4f       	sbci	r29, 0xFE	; 254
    456e:	48 81       	ld	r20, Y
    4570:	86 2f       	mov	r24, r22
    4572:	62 e0       	ldi	r22, 0x02	; 2
    4574:	50 e0       	ldi	r21, 0x00	; 0
    4576:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <StartOverdub>
							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to playback after a recording.	
    457a:	e0 91 2a 01 	lds	r30, 0x012A
    457e:	f0 e0       	ldi	r31, 0x00	; 0
    4580:	e8 5d       	subi	r30, 0xD8	; 216
    4582:	fe 4f       	sbci	r31, 0xFE	; 254
    4584:	10 82       	st	Z, r1
    4586:	31 c2       	rjmp	.+1122   	; 0x49ea <DoSampler+0xec4>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    4588:	20 91 2a 01 	lds	r18, 0x012A
    458c:	a2 2f       	mov	r26, r18
    458e:	b0 e0       	ldi	r27, 0x00	; 0
    4590:	83 e2       	ldi	r24, 0x23	; 35
    4592:	90 e0       	ldi	r25, 0x00	; 0
    4594:	a8 9f       	mul	r26, r24
    4596:	f0 01       	movw	r30, r0
    4598:	a9 9f       	mul	r26, r25
    459a:	f0 0d       	add	r31, r0
    459c:	b8 9f       	mul	r27, r24
    459e:	f0 0d       	add	r31, r0
    45a0:	11 24       	eor	r1, r1
    45a2:	ea 51       	subi	r30, 0x1A	; 26
    45a4:	fa 4f       	sbci	r31, 0xFA	; 250
    45a6:	80 81       	ld	r24, Z
    45a8:	85 30       	cpi	r24, 0x05	; 5
    45aa:	09 f0       	breq	.+2      	; 0x45ae <DoSampler+0xa88>
    45ac:	1e c2       	rjmp	.+1084   	; 0x49ea <DoSampler+0xec4>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    45ae:	ac 5f       	subi	r26, 0xFC	; 252
    45b0:	be 4f       	sbci	r27, 0xFE	; 254
    45b2:	4c 91       	ld	r20, X
    45b4:	82 2f       	mov	r24, r18
    45b6:	62 e0       	ldi	r22, 0x02	; 2
    45b8:	50 e0       	ldi	r21, 0x00	; 0
    45ba:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <ContinuePlayback>
    45be:	15 c2       	rjmp	.+1066   	; 0x49ea <DoSampler+0xec4>
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    45c0:	80 91 2d 01 	lds	r24, 0x012D
    45c4:	88 23       	and	r24, r24
    45c6:	a9 f0       	breq	.+42     	; 0x45f2 <DoSampler+0xacc>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    45c8:	80 91 2a 01 	lds	r24, 0x012A
    45cc:	e8 2f       	mov	r30, r24
    45ce:	f0 e0       	ldi	r31, 0x00	; 0
    45d0:	ee 0f       	add	r30, r30
    45d2:	ff 1f       	adc	r31, r31
    45d4:	ef 53       	subi	r30, 0x3F	; 63
    45d6:	fa 4f       	sbci	r31, 0xFA	; 250
    45d8:	40 81       	ld	r20, Z
    45da:	51 81       	ldd	r21, Z+1	; 0x01
    45dc:	62 e0       	ldi	r22, 0x02	; 2
    45de:	0e 94 57 0e 	call	0x1cae	; 0x1cae <StartRealtime>
						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop realtime processing if we get a note off.
    45e2:	e0 91 2a 01 	lds	r30, 0x012A
    45e6:	f0 e0       	ldi	r31, 0x00	; 0
    45e8:	e8 5d       	subi	r30, 0xD8	; 216
    45ea:	fe 4f       	sbci	r31, 0xFE	; 254
    45ec:	81 e0       	ldi	r24, 0x01	; 1
    45ee:	80 83       	st	Z, r24
    45f0:	fc c1       	rjmp	.+1016   	; 0x49ea <DoSampler+0xec4>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    45f2:	80 91 2a 01 	lds	r24, 0x012A
    45f6:	a8 2f       	mov	r26, r24
    45f8:	b0 e0       	ldi	r27, 0x00	; 0
    45fa:	83 e2       	ldi	r24, 0x23	; 35
    45fc:	90 e0       	ldi	r25, 0x00	; 0
    45fe:	a8 9f       	mul	r26, r24
    4600:	f0 01       	movw	r30, r0
    4602:	a9 9f       	mul	r26, r25
    4604:	f0 0d       	add	r31, r0
    4606:	b8 9f       	mul	r27, r24
    4608:	f0 0d       	add	r31, r0
    460a:	11 24       	eor	r1, r1
    460c:	ea 51       	subi	r30, 0x1A	; 26
    460e:	fa 4f       	sbci	r31, 0xFA	; 250
    4610:	80 81       	ld	r24, Z
    4612:	82 30       	cpi	r24, 0x02	; 2
    4614:	09 f0       	breq	.+2      	; 0x4618 <DoSampler+0xaf2>
    4616:	e9 c1       	rjmp	.+978    	; 0x49ea <DoSampler+0xec4>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    4618:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    461a:	11 86       	std	Z+9, r1	; 0x09
						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    461c:	a8 5d       	subi	r26, 0xD8	; 216
    461e:	be 4f       	sbci	r27, 0xFE	; 254
    4620:	1c 92       	st	X, r1
    4622:	e3 c1       	rjmp	.+966    	; 0x49ea <DoSampler+0xec4>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    4624:	80 91 2d 01 	lds	r24, 0x012D
    4628:	88 23       	and	r24, r24
    462a:	81 f0       	breq	.+32     	; 0x464c <DoSampler+0xb26>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    462c:	80 91 2a 01 	lds	r24, 0x012A
    4630:	90 e0       	ldi	r25, 0x00	; 0
    4632:	23 e2       	ldi	r18, 0x23	; 35
    4634:	30 e0       	ldi	r19, 0x00	; 0
    4636:	82 9f       	mul	r24, r18
    4638:	f0 01       	movw	r30, r0
    463a:	83 9f       	mul	r24, r19
    463c:	f0 0d       	add	r31, r0
    463e:	92 9f       	mul	r25, r18
    4640:	f0 0d       	add	r31, r0
    4642:	11 24       	eor	r1, r1
    4644:	ea 51       	subi	r30, 0x1A	; 26
    4646:	fa 4f       	sbci	r31, 0xFA	; 250
    4648:	11 82       	std	Z+1, r1	; 0x01
    464a:	cf c1       	rjmp	.+926    	; 0x49ea <DoSampler+0xec4>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    464c:	80 91 2a 01 	lds	r24, 0x012A
    4650:	90 e0       	ldi	r25, 0x00	; 0
    4652:	23 e2       	ldi	r18, 0x23	; 35
    4654:	30 e0       	ldi	r19, 0x00	; 0
    4656:	82 9f       	mul	r24, r18
    4658:	f0 01       	movw	r30, r0
    465a:	83 9f       	mul	r24, r19
    465c:	f0 0d       	add	r31, r0
    465e:	92 9f       	mul	r25, r18
    4660:	f0 0d       	add	r31, r0
    4662:	11 24       	eor	r1, r1
    4664:	ea 51       	subi	r30, 0x1A	; 26
    4666:	fa 4f       	sbci	r31, 0xFA	; 250
    4668:	81 e0       	ldi	r24, 0x01	; 1
    466a:	81 83       	std	Z+1, r24	; 0x01
    466c:	be c1       	rjmp	.+892    	; 0x49ea <DoSampler+0xec4>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    466e:	80 91 2d 01 	lds	r24, 0x012D
    4672:	88 23       	and	r24, r24
    4674:	89 f0       	breq	.+34     	; 0x4698 <DoSampler+0xb72>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    4676:	80 91 2a 01 	lds	r24, 0x012A
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	23 e2       	ldi	r18, 0x23	; 35
    467e:	30 e0       	ldi	r19, 0x00	; 0
    4680:	82 9f       	mul	r24, r18
    4682:	f0 01       	movw	r30, r0
    4684:	83 9f       	mul	r24, r19
    4686:	f0 0d       	add	r31, r0
    4688:	92 9f       	mul	r25, r18
    468a:	f0 0d       	add	r31, r0
    468c:	11 24       	eor	r1, r1
    468e:	ea 51       	subi	r30, 0x1A	; 26
    4690:	fa 4f       	sbci	r31, 0xFA	; 250
    4692:	81 e0       	ldi	r24, 0x01	; 1
    4694:	82 83       	std	Z+2, r24	; 0x02
    4696:	a9 c1       	rjmp	.+850    	; 0x49ea <DoSampler+0xec4>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    4698:	80 91 2a 01 	lds	r24, 0x012A
    469c:	90 e0       	ldi	r25, 0x00	; 0
    469e:	23 e2       	ldi	r18, 0x23	; 35
    46a0:	30 e0       	ldi	r19, 0x00	; 0
    46a2:	82 9f       	mul	r24, r18
    46a4:	f0 01       	movw	r30, r0
    46a6:	83 9f       	mul	r24, r19
    46a8:	f0 0d       	add	r31, r0
    46aa:	92 9f       	mul	r25, r18
    46ac:	f0 0d       	add	r31, r0
    46ae:	11 24       	eor	r1, r1
    46b0:	ea 51       	subi	r30, 0x1A	; 26
    46b2:	fa 4f       	sbci	r31, 0xFA	; 250
    46b4:	12 82       	std	Z+2, r1	; 0x02
    46b6:	99 c1       	rjmp	.+818    	; 0x49ea <DoSampler+0xec4>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    46b8:	80 91 2d 01 	lds	r24, 0x012D
    46bc:	88 23       	and	r24, r24
    46be:	89 f0       	breq	.+34     	; 0x46e2 <DoSampler+0xbbc>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    46c0:	80 91 2a 01 	lds	r24, 0x012A
    46c4:	90 e0       	ldi	r25, 0x00	; 0
    46c6:	23 e2       	ldi	r18, 0x23	; 35
    46c8:	30 e0       	ldi	r19, 0x00	; 0
    46ca:	82 9f       	mul	r24, r18
    46cc:	f0 01       	movw	r30, r0
    46ce:	83 9f       	mul	r24, r19
    46d0:	f0 0d       	add	r31, r0
    46d2:	92 9f       	mul	r25, r18
    46d4:	f0 0d       	add	r31, r0
    46d6:	11 24       	eor	r1, r1
    46d8:	ea 51       	subi	r30, 0x1A	; 26
    46da:	fa 4f       	sbci	r31, 0xFA	; 250
    46dc:	81 e0       	ldi	r24, 0x01	; 1
    46de:	83 83       	std	Z+3, r24	; 0x03
    46e0:	0f c0       	rjmp	.+30     	; 0x4700 <DoSampler+0xbda>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    46e2:	80 91 2a 01 	lds	r24, 0x012A
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	23 e2       	ldi	r18, 0x23	; 35
    46ea:	30 e0       	ldi	r19, 0x00	; 0
    46ec:	82 9f       	mul	r24, r18
    46ee:	f0 01       	movw	r30, r0
    46f0:	83 9f       	mul	r24, r19
    46f2:	f0 0d       	add	r31, r0
    46f4:	92 9f       	mul	r25, r18
    46f6:	f0 0d       	add	r31, r0
    46f8:	11 24       	eor	r1, r1
    46fa:	ea 51       	subi	r30, 0x1A	; 26
    46fc:	fa 4f       	sbci	r31, 0xFA	; 250
    46fe:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    4700:	80 91 2a 01 	lds	r24, 0x012A
    4704:	2b c1       	rjmp	.+598    	; 0x495c <DoSampler+0xe36>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    4706:	a0 91 2a 01 	lds	r26, 0x012A
    470a:	b0 e0       	ldi	r27, 0x00	; 0
    470c:	83 e2       	ldi	r24, 0x23	; 35
    470e:	90 e0       	ldi	r25, 0x00	; 0
    4710:	a8 9f       	mul	r26, r24
    4712:	f0 01       	movw	r30, r0
    4714:	a9 9f       	mul	r26, r25
    4716:	f0 0d       	add	r31, r0
    4718:	b8 9f       	mul	r27, r24
    471a:	f0 0d       	add	r31, r0
    471c:	11 24       	eor	r1, r1
    471e:	ea 51       	subi	r30, 0x1A	; 26
    4720:	fa 4f       	sbci	r31, 0xFA	; 250
    4722:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    4724:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    4726:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    4728:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    472a:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    472c:	81 e0       	ldi	r24, 0x01	; 1
    472e:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;					
    4730:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    4732:	84 83       	std	Z+4, r24	; 0x04
					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    4734:	a8 5d       	subi	r26, 0xD8	; 216
    4736:	be 4f       	sbci	r27, 0xFE	; 254
    4738:	1c 92       	st	X, r1
    473a:	3a c0       	rjmp	.+116    	; 0x47b0 <DoSampler+0xc8a>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    473c:	40 91 2d 01 	lds	r20, 0x012D
    4740:	48 30       	cpi	r20, 0x08	; 8
    4742:	08 f0       	brcs	.+2      	; 0x4746 <DoSampler+0xc20>
    4744:	52 c1       	rjmp	.+676    	; 0x49ea <DoSampler+0xec4>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;				
    4746:	80 91 2a 01 	lds	r24, 0x012A
    474a:	90 e0       	ldi	r25, 0x00	; 0
    474c:	23 e2       	ldi	r18, 0x23	; 35
    474e:	30 e0       	ldi	r19, 0x00	; 0
    4750:	82 9f       	mul	r24, r18
    4752:	f0 01       	movw	r30, r0
    4754:	83 9f       	mul	r24, r19
    4756:	f0 0d       	add	r31, r0
    4758:	92 9f       	mul	r25, r18
    475a:	f0 0d       	add	r31, r0
    475c:	11 24       	eor	r1, r1
    475e:	ea 51       	subi	r30, 0x1A	; 26
    4760:	fa 4f       	sbci	r31, 0xFA	; 250
    4762:	40 87       	std	Z+8, r20	; 0x08
    4764:	42 c1       	rjmp	.+644    	; 0x49ea <DoSampler+0xec4>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    4766:	80 91 2a 01 	lds	r24, 0x012A
    476a:	60 91 2d 01 	lds	r22, 0x012D
    476e:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <MakeNewGranularArray>
    4772:	3b c1       	rjmp	.+630    	; 0x49ea <DoSampler+0xec4>
					break;

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;				
    4774:	80 91 2a 01 	lds	r24, 0x012A
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	40 91 2d 01 	lds	r20, 0x012D
    477e:	23 e2       	ldi	r18, 0x23	; 35
    4780:	30 e0       	ldi	r19, 0x00	; 0
    4782:	82 9f       	mul	r24, r18
    4784:	f0 01       	movw	r30, r0
    4786:	83 9f       	mul	r24, r19
    4788:	f0 0d       	add	r31, r0
    478a:	92 9f       	mul	r25, r18
    478c:	f0 0d       	add	r31, r0
    478e:	11 24       	eor	r1, r1
    4790:	ea 51       	subi	r30, 0x1A	; 26
    4792:	fa 4f       	sbci	r31, 0xFA	; 250
    4794:	47 83       	std	Z+7, r20	; 0x07
    4796:	29 c1       	rjmp	.+594    	; 0x49ea <DoSampler+0xec4>
					break;

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    4798:	80 91 2d 01 	lds	r24, 0x012D
    479c:	81 30       	cpi	r24, 0x01	; 1
    479e:	59 f0       	breq	.+22     	; 0x47b6 <DoSampler+0xc90>
    47a0:	81 30       	cpi	r24, 0x01	; 1
    47a2:	30 f0       	brcs	.+12     	; 0x47b0 <DoSampler+0xc8a>
    47a4:	82 30       	cpi	r24, 0x02	; 2
    47a6:	51 f0       	breq	.+20     	; 0x47bc <DoSampler+0xc96>
    47a8:	83 30       	cpi	r24, 0x03	; 3
    47aa:	09 f0       	breq	.+2      	; 0x47ae <DoSampler+0xc88>
    47ac:	1e c1       	rjmp	.+572    	; 0x49ea <DoSampler+0xec4>
    47ae:	09 c0       	rjmp	.+18     	; 0x47c2 <DoSampler+0xc9c>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    47b0:	81 e5       	ldi	r24, 0x51	; 81
    47b2:	98 e0       	ldi	r25, 0x08	; 8
    47b4:	08 c0       	rjmp	.+16     	; 0x47c6 <DoSampler+0xca0>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    47b6:	87 e0       	ldi	r24, 0x07	; 7
    47b8:	98 e0       	ldi	r25, 0x08	; 8
    47ba:	05 c0       	rjmp	.+10     	; 0x47c6 <DoSampler+0xca0>
						break;
						
						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    47bc:	8c ec       	ldi	r24, 0xCC	; 204
    47be:	98 e0       	ldi	r25, 0x08	; 8
    47c0:	02 c0       	rjmp	.+4      	; 0x47c6 <DoSampler+0xca0>
						break;
						
						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    47c2:	8d e8       	ldi	r24, 0x8D	; 141
    47c4:	98 e0       	ldi	r25, 0x08	; 8
    47c6:	90 93 e3 05 	sts	0x05E3, r25
    47ca:	80 93 e2 05 	sts	0x05E2, r24
    47ce:	0d c1       	rjmp	.+538    	; 0x49ea <DoSampler+0xec4>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
    47d0:	cf b6       	in	r12, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    47d2:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    47d4:	d0 90 2a 01 	lds	r13, 0x012A
    47d8:	0d 2d       	mov	r16, r13
    47da:	10 e0       	ldi	r17, 0x00	; 0
    47dc:	54 e0       	ldi	r21, 0x04	; 4
    47de:	e5 2e       	mov	r14, r21
    47e0:	51 e0       	ldi	r21, 0x01	; 1
    47e2:	f5 2e       	mov	r15, r21
    47e4:	e0 0e       	add	r14, r16
    47e6:	f1 1e       	adc	r15, r17
    47e8:	f7 01       	movw	r30, r14
    47ea:	80 81       	ld	r24, Z
    47ec:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    47f0:	00 0f       	add	r16, r16
    47f2:	11 1f       	adc	r17, r17
    47f4:	0f 53       	subi	r16, 0x3F	; 63
    47f6:	1a 4f       	sbci	r17, 0xFA	; 250
    47f8:	f8 01       	movw	r30, r16
    47fa:	91 83       	std	Z+1, r25	; 0x01
    47fc:	80 83       	st	Z, r24
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
    47fe:	f7 01       	movw	r30, r14
    4800:	60 81       	ld	r22, Z
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    4802:	dd 20       	and	r13, r13
    4804:	19 f4       	brne	.+6      	; 0x480c <DoSampler+0xce6>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    4806:	87 e0       	ldi	r24, 0x07	; 7
    4808:	90 e0       	ldi	r25, 0x00	; 0
    480a:	05 c0       	rjmp	.+10     	; 0x4816 <DoSampler+0xcf0>
	}
	else if(theBank==BANK_1)
    480c:	f1 e0       	ldi	r31, 0x01	; 1
    480e:	df 16       	cp	r13, r31
    4810:	21 f4       	brne	.+8      	; 0x481a <DoSampler+0xcf4>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    4812:	8b e0       	ldi	r24, 0x0B	; 11
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=i;		// Re-enable interrupts.
    481a:	cf be       	out	0x3f, r12	; 63
    481c:	e6 c0       	rjmp	.+460    	; 0x49ea <DoSampler+0xec4>
					break;

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    481e:	80 91 2a 01 	lds	r24, 0x012A
    4822:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    4826:	48 2f       	mov	r20, r24
    4828:	50 e0       	ldi	r21, 0x00	; 0
    482a:	23 e2       	ldi	r18, 0x23	; 35
    482c:	30 e0       	ldi	r19, 0x00	; 0
    482e:	42 9f       	mul	r20, r18
    4830:	f0 01       	movw	r30, r0
    4832:	43 9f       	mul	r20, r19
    4834:	f0 0d       	add	r31, r0
    4836:	52 9f       	mul	r21, r18
    4838:	f0 0d       	add	r31, r0
    483a:	11 24       	eor	r1, r1
    483c:	ea 51       	subi	r30, 0x1A	; 26
    483e:	fa 4f       	sbci	r31, 0xFA	; 250
    4840:	94 8f       	std	Z+28, r25	; 0x1c
    4842:	8c c0       	rjmp	.+280    	; 0x495c <DoSampler+0xe36>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    4844:	80 91 2a 01 	lds	r24, 0x012A
    4848:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    484c:	48 2f       	mov	r20, r24
    484e:	50 e0       	ldi	r21, 0x00	; 0
    4850:	23 e2       	ldi	r18, 0x23	; 35
    4852:	30 e0       	ldi	r19, 0x00	; 0
    4854:	42 9f       	mul	r20, r18
    4856:	f0 01       	movw	r30, r0
    4858:	43 9f       	mul	r20, r19
    485a:	f0 0d       	add	r31, r0
    485c:	52 9f       	mul	r21, r18
    485e:	f0 0d       	add	r31, r0
    4860:	11 24       	eor	r1, r1
    4862:	ea 51       	subi	r30, 0x1A	; 26
    4864:	fa 4f       	sbci	r31, 0xFA	; 250
    4866:	95 8f       	std	Z+29, r25	; 0x1d
    4868:	79 c0       	rjmp	.+242    	; 0x495c <DoSampler+0xe36>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    486a:	80 91 2a 01 	lds	r24, 0x012A
    486e:	90 91 2d 01 	lds	r25, 0x012D
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    4872:	48 2f       	mov	r20, r24
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	23 e2       	ldi	r18, 0x23	; 35
    4878:	30 e0       	ldi	r19, 0x00	; 0
    487a:	42 9f       	mul	r20, r18
    487c:	f0 01       	movw	r30, r0
    487e:	43 9f       	mul	r20, r19
    4880:	f0 0d       	add	r31, r0
    4882:	52 9f       	mul	r21, r18
    4884:	f0 0d       	add	r31, r0
    4886:	11 24       	eor	r1, r1
    4888:	ea 51       	subi	r30, 0x1A	; 26
    488a:	fa 4f       	sbci	r31, 0xFA	; 250
    488c:	96 8f       	std	Z+30, r25	; 0x1e
    488e:	66 c0       	rjmp	.+204    	; 0x495c <DoSampler+0xe36>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:						
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    4890:	20 91 2a 01 	lds	r18, 0x012A
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    4894:	4f b7       	in	r20, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    4896:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    4898:	30 e0       	ldi	r19, 0x00	; 0
    489a:	83 e2       	ldi	r24, 0x23	; 35
    489c:	90 e0       	ldi	r25, 0x00	; 0
    489e:	28 9f       	mul	r18, r24
    48a0:	f0 01       	movw	r30, r0
    48a2:	29 9f       	mul	r18, r25
    48a4:	f0 0d       	add	r31, r0
    48a6:	38 9f       	mul	r19, r24
    48a8:	f0 0d       	add	r31, r0
    48aa:	11 24       	eor	r1, r1
    48ac:	ea 51       	subi	r30, 0x1A	; 26
    48ae:	fa 4f       	sbci	r31, 0xFA	; 250
    48b0:	80 89       	ldd	r24, Z+16	; 0x10
    48b2:	91 89       	ldd	r25, Z+17	; 0x11
    48b4:	a2 89       	ldd	r26, Z+18	; 0x12
    48b6:	b3 89       	ldd	r27, Z+19	; 0x13
    48b8:	80 8f       	std	Z+24, r24	; 0x18
    48ba:	91 8f       	std	Z+25, r25	; 0x19
    48bc:	a2 8f       	std	Z+26, r26	; 0x1a
    48be:	b3 8f       	std	Z+27, r27	; 0x1b
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    48c0:	84 85       	ldd	r24, Z+12	; 0x0c
    48c2:	95 85       	ldd	r25, Z+13	; 0x0d
    48c4:	a6 85       	ldd	r26, Z+14	; 0x0e
    48c6:	b7 85       	ldd	r27, Z+15	; 0x0f
    48c8:	84 8b       	std	Z+20, r24	; 0x14
    48ca:	95 8b       	std	Z+21, r25	; 0x15
    48cc:	a6 8b       	std	Z+22, r26	; 0x16
    48ce:	b7 8b       	std	Z+23, r27	; 0x17
	bankStates[theBank].sampleStartOffset=0;
    48d0:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleEndOffset=0;
    48d2:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleWindowOffset=0;
    48d4:	16 8e       	std	Z+30, r1	; 0x1e
	SREG=sreg;		// Restore interrupts.
    48d6:	4f bf       	out	0x3f, r20	; 63
    48d8:	88 c0       	rjmp	.+272    	; 0x49ea <DoSampler+0xec4>
					case MIDI_REVERT_SAMPLE_TO_FULL:						
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
					break;

					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    48da:	80 91 2a 01 	lds	r24, 0x012A
    48de:	40 91 2d 01 	lds	r20, 0x012D
    48e2:	50 e0       	ldi	r21, 0x00	; 0
    48e4:	44 0f       	add	r20, r20
    48e6:	55 1f       	adc	r21, r21
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    48e8:	68 2f       	mov	r22, r24
    48ea:	70 e0       	ldi	r23, 0x00	; 0
    48ec:	23 e2       	ldi	r18, 0x23	; 35
    48ee:	30 e0       	ldi	r19, 0x00	; 0
    48f0:	62 9f       	mul	r22, r18
    48f2:	f0 01       	movw	r30, r0
    48f4:	63 9f       	mul	r22, r19
    48f6:	f0 0d       	add	r31, r0
    48f8:	72 9f       	mul	r23, r18
    48fa:	f0 0d       	add	r31, r0
    48fc:	11 24       	eor	r1, r1
    48fe:	ea 51       	subi	r30, 0x1A	; 26
    4900:	fa 4f       	sbci	r31, 0xFA	; 250
    4902:	44 8f       	std	Z+28, r20	; 0x1c
    4904:	2b c0       	rjmp	.+86     	; 0x495c <DoSampler+0xe36>
					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    4906:	80 91 2a 01 	lds	r24, 0x012A
    490a:	40 91 2d 01 	lds	r20, 0x012D
    490e:	50 e0       	ldi	r21, 0x00	; 0
    4910:	44 0f       	add	r20, r20
    4912:	55 1f       	adc	r21, r21
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    4914:	68 2f       	mov	r22, r24
    4916:	70 e0       	ldi	r23, 0x00	; 0
    4918:	23 e2       	ldi	r18, 0x23	; 35
    491a:	30 e0       	ldi	r19, 0x00	; 0
    491c:	62 9f       	mul	r22, r18
    491e:	f0 01       	movw	r30, r0
    4920:	63 9f       	mul	r22, r19
    4922:	f0 0d       	add	r31, r0
    4924:	72 9f       	mul	r23, r18
    4926:	f0 0d       	add	r31, r0
    4928:	11 24       	eor	r1, r1
    492a:	ea 51       	subi	r30, 0x1A	; 26
    492c:	fa 4f       	sbci	r31, 0xFA	; 250
    492e:	45 8f       	std	Z+29, r20	; 0x1d
    4930:	15 c0       	rjmp	.+42     	; 0x495c <DoSampler+0xe36>
					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    4932:	80 91 2a 01 	lds	r24, 0x012A
    4936:	40 91 2d 01 	lds	r20, 0x012D
    493a:	50 e0       	ldi	r21, 0x00	; 0
    493c:	44 0f       	add	r20, r20
    493e:	55 1f       	adc	r21, r21
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    4940:	68 2f       	mov	r22, r24
    4942:	70 e0       	ldi	r23, 0x00	; 0
    4944:	23 e2       	ldi	r18, 0x23	; 35
    4946:	30 e0       	ldi	r19, 0x00	; 0
    4948:	62 9f       	mul	r22, r18
    494a:	f0 01       	movw	r30, r0
    494c:	63 9f       	mul	r22, r19
    494e:	f0 0d       	add	r31, r0
    4950:	72 9f       	mul	r23, r18
    4952:	f0 0d       	add	r31, r0
    4954:	11 24       	eor	r1, r1
    4956:	ea 51       	subi	r30, 0x1A	; 26
    4958:	fa 4f       	sbci	r31, 0xFA	; 250
    495a:	46 8f       	std	Z+30, r20	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    495c:	0e 94 c3 0f 	call	0x1f86	; 0x1f86 <UpdateAdjustedSampleAddresses>
    4960:	44 c0       	rjmp	.+136    	; 0x49ea <DoSampler+0xec4>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    4962:	87 30       	cpi	r24, 0x07	; 7
    4964:	09 f0       	breq	.+2      	; 0x4968 <DoSampler+0xe42>
    4966:	41 c0       	rjmp	.+130    	; 0x49ea <DoSampler+0xec4>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    4968:	80 91 2d 01 	lds	r24, 0x012D
    496c:	c8 2f       	mov	r28, r24
    496e:	d0 e0       	ldi	r29, 0x00	; 0
    4970:	d6 95       	lsr	r29
    4972:	dc 2f       	mov	r29, r28
    4974:	cc 27       	eor	r28, r28
    4976:	d7 95       	ror	r29
    4978:	c7 95       	ror	r28
    497a:	80 91 2c 01 	lds	r24, 0x012C
    497e:	c8 0f       	add	r28, r24
    4980:	d1 1d       	adc	r29, r1

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    4982:	80 e2       	ldi	r24, 0x20	; 32
    4984:	c0 30       	cpi	r28, 0x00	; 0
    4986:	d8 07       	cpc	r29, r24
    4988:	d1 f0       	breq	.+52     	; 0x49be <DoSampler+0xe98>
    498a:	00 91 2a 01 	lds	r16, 0x012A
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
    498e:	e0 e2       	ldi	r30, 0x20	; 32
    4990:	c0 30       	cpi	r28, 0x00	; 0
    4992:	de 07       	cpc	r29, r30
    4994:	40 f4       	brcc	.+16     	; 0x49a6 <DoSampler+0xe80>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    4996:	10 e0       	ldi	r17, 0x00	; 0
    4998:	f8 01       	movw	r30, r16
    499a:	ec 5f       	subi	r30, 0xFC	; 252
    499c:	fe 4f       	sbci	r31, 0xFE	; 254
    499e:	80 81       	ld	r24, Z
    49a0:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    49a4:	07 c0       	rjmp	.+14     	; 0x49b4 <DoSampler+0xe8e>
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    49a6:	10 e0       	ldi	r17, 0x00	; 0
    49a8:	f8 01       	movw	r30, r16
    49aa:	ec 5f       	subi	r30, 0xFC	; 252
    49ac:	fe 4f       	sbci	r31, 0xFE	; 254
    49ae:	80 81       	ld	r24, Z
    49b0:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    49b4:	80 50       	subi	r24, 0x00	; 0
    49b6:	90 4e       	sbci	r25, 0xE0	; 224
    49b8:	8c 1b       	sub	r24, r28
    49ba:	9d 0b       	sbc	r25, r29
    49bc:	09 c0       	rjmp	.+18     	; 0x49d0 <DoSampler+0xeaa>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    49be:	00 91 2a 01 	lds	r16, 0x012A
    49c2:	10 e0       	ldi	r17, 0x00	; 0
    49c4:	f8 01       	movw	r30, r16
    49c6:	ec 5f       	subi	r30, 0xFC	; 252
    49c8:	fe 4f       	sbci	r31, 0xFE	; 254
    49ca:	80 81       	ld	r24, Z
    49cc:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <GetPlaybackRateFromNote>
    49d0:	23 e2       	ldi	r18, 0x23	; 35
    49d2:	30 e0       	ldi	r19, 0x00	; 0
    49d4:	02 9f       	mul	r16, r18
    49d6:	f0 01       	movw	r30, r0
    49d8:	03 9f       	mul	r16, r19
    49da:	f0 0d       	add	r31, r0
    49dc:	12 9f       	mul	r17, r18
    49de:	f0 0d       	add	r31, r0
    49e0:	11 24       	eor	r1, r1
    49e2:	ea 51       	subi	r30, 0x1A	; 26
    49e4:	fa 4f       	sbci	r31, 0xFA	; 250
    49e6:	93 87       	std	Z+11, r25	; 0x0b
    49e8:	82 87       	std	Z+10, r24	; 0x0a
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    49ea:	80 91 b5 05 	lds	r24, 0x05B5
    49ee:	83 30       	cpi	r24, 0x03	; 3
    49f0:	11 f0       	breq	.+4      	; 0x49f6 <DoSampler+0xed0>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    49f2:	10 92 bf 05 	sts	0x05BF, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    49f6:	80 91 ef 05 	lds	r24, 0x05EF
    49fa:	81 30       	cpi	r24, 0x01	; 1
    49fc:	41 f0       	breq	.+16     	; 0x4a0e <DoSampler+0xee8>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    49fe:	10 92 bb 05 	sts	0x05BB, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    4a02:	80 91 6f 00 	lds	r24, 0x006F
    4a06:	8f 7d       	andi	r24, 0xDF	; 223
    4a08:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.	
    4a0c:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    4a0e:	80 91 12 06 	lds	r24, 0x0612
    4a12:	81 30       	cpi	r24, 0x01	; 1
    4a14:	31 f0       	breq	.+12     	; 0x4a22 <DoSampler+0xefc>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    4a16:	10 92 bc 05 	sts	0x05BC, r1
		PCICR=0;			// No global PCINTS.
    4a1a:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    4a1e:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    4a22:	80 91 ef 05 	lds	r24, 0x05EF
    4a26:	82 30       	cpi	r24, 0x02	; 2
    4a28:	41 f0       	breq	.+16     	; 0x4a3a <DoSampler+0xf14>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    4a2a:	10 92 bd 05 	sts	0x05BD, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    4a2e:	80 91 6f 00 	lds	r24, 0x006F
    4a32:	8d 7f       	andi	r24, 0xFD	; 253
    4a34:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.	
    4a38:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    4a3a:	80 91 12 06 	lds	r24, 0x0612
    4a3e:	82 30       	cpi	r24, 0x02	; 2
    4a40:	41 f0       	breq	.+16     	; 0x4a52 <DoSampler+0xf2c>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    4a42:	10 92 be 05 	sts	0x05BE, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    4a46:	80 91 6f 00 	lds	r24, 0x006F
    4a4a:	8b 7f       	andi	r24, 0xFB	; 251
    4a4c:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.	
    4a50:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    4a52:	80 91 ef 05 	lds	r24, 0x05EF
    4a56:	88 23       	and	r24, r24
    4a58:	61 f4       	brne	.+24     	; 0x4a72 <DoSampler+0xf4c>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    4a5a:	80 91 b5 05 	lds	r24, 0x05B5
    4a5e:	88 23       	and	r24, r24
    4a60:	31 f0       	breq	.+12     	; 0x4a6e <DoSampler+0xf48>
    4a62:	83 30       	cpi	r24, 0x03	; 3
    4a64:	21 f0       	breq	.+8      	; 0x4a6e <DoSampler+0xf48>
    4a66:	80 91 ba 05 	lds	r24, 0x05BA
    4a6a:	88 23       	and	r24, r24
    4a6c:	11 f4       	brne	.+4      	; 0x4a72 <DoSampler+0xf4c>
		{
			bankStates[BANK_0].isLocked=false;		
    4a6e:	10 92 eb 05 	sts	0x05EB, r1
		}	
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    4a72:	80 91 12 06 	lds	r24, 0x0612
    4a76:	88 23       	and	r24, r24
    4a78:	61 f4       	brne	.+24     	; 0x4a92 <DoSampler+0xf6c>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    4a7a:	80 91 b5 05 	lds	r24, 0x05B5
    4a7e:	88 23       	and	r24, r24
    4a80:	31 f0       	breq	.+12     	; 0x4a8e <DoSampler+0xf68>
    4a82:	83 30       	cpi	r24, 0x03	; 3
    4a84:	21 f0       	breq	.+8      	; 0x4a8e <DoSampler+0xf68>
    4a86:	80 91 ba 05 	lds	r24, 0x05BA
    4a8a:	81 30       	cpi	r24, 0x01	; 1
    4a8c:	11 f4       	brne	.+4      	; 0x4a92 <DoSampler+0xf6c>
		{
			bankStates[BANK_1].isLocked=false;		
    4a8e:	10 92 0e 06 	sts	0x060E, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    4a92:	80 91 44 01 	lds	r24, 0x0144
    4a96:	82 95       	swap	r24
    4a98:	86 95       	lsr	r24
    4a9a:	87 70       	andi	r24, 0x07	; 7
    4a9c:	80 93 45 01 	sts	0x0145, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    4aa0:	90 91 3b 01 	lds	r25, 0x013B
    4aa4:	9f 71       	andi	r25, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    4aa6:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    4aa8:	90 68       	ori	r25, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    4aaa:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    4aac:	90 64       	ori	r25, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    4aae:	82 fd       	sbrc	r24, 2
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    4ab0:	90 62       	ori	r25, 0x20	; 32
	}

	ledOnOffMask=temp;		// Update the leds.
    4ab2:	90 93 3b 01 	sts	0x013B, r25
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    4ab6:	30 91 2e 01 	lds	r19, 0x012E
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    4aba:	29 2f       	mov	r18, r25
    4abc:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    4abe:	43 2f       	mov	r20, r19
    4ac0:	50 e0       	ldi	r21, 0x00	; 0
    4ac2:	83 e2       	ldi	r24, 0x23	; 35
    4ac4:	90 e0       	ldi	r25, 0x00	; 0
    4ac6:	48 9f       	mul	r20, r24
    4ac8:	f0 01       	movw	r30, r0
    4aca:	49 9f       	mul	r20, r25
    4acc:	f0 0d       	add	r31, r0
    4ace:	58 9f       	mul	r21, r24
    4ad0:	f0 0d       	add	r31, r0
    4ad2:	11 24       	eor	r1, r1
    4ad4:	ea 51       	subi	r30, 0x1A	; 26
    4ad6:	fa 4f       	sbci	r31, 0xFA	; 250
    4ad8:	80 81       	ld	r24, Z
    4ada:	83 30       	cpi	r24, 0x03	; 3
    4adc:	09 f4       	brne	.+2      	; 0x4ae0 <DoSampler+0xfba>
	{
		temp|=Om_LED_REC;
    4ade:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    4ae0:	83 e2       	ldi	r24, 0x23	; 35
    4ae2:	90 e0       	ldi	r25, 0x00	; 0
    4ae4:	48 9f       	mul	r20, r24
    4ae6:	f0 01       	movw	r30, r0
    4ae8:	49 9f       	mul	r20, r25
    4aea:	f0 0d       	add	r31, r0
    4aec:	58 9f       	mul	r21, r24
    4aee:	f0 0d       	add	r31, r0
    4af0:	11 24       	eor	r1, r1
    4af2:	ea 51       	subi	r30, 0x1A	; 26
    4af4:	fa 4f       	sbci	r31, 0xFA	; 250
    4af6:	80 81       	ld	r24, Z
    4af8:	84 30       	cpi	r24, 0x04	; 4
    4afa:	09 f4       	brne	.+2      	; 0x4afe <DoSampler+0xfd8>
	{
		temp|=Om_LED_PLAY;
    4afc:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    4afe:	83 e2       	ldi	r24, 0x23	; 35
    4b00:	90 e0       	ldi	r25, 0x00	; 0
    4b02:	48 9f       	mul	r20, r24
    4b04:	f0 01       	movw	r30, r0
    4b06:	49 9f       	mul	r20, r25
    4b08:	f0 0d       	add	r31, r0
    4b0a:	58 9f       	mul	r21, r24
    4b0c:	f0 0d       	add	r31, r0
    4b0e:	11 24       	eor	r1, r1
    4b10:	ea 51       	subi	r30, 0x1A	; 26
    4b12:	fa 4f       	sbci	r31, 0xFA	; 250
    4b14:	80 81       	ld	r24, Z
    4b16:	85 30       	cpi	r24, 0x05	; 5
    4b18:	09 f4       	brne	.+2      	; 0x4b1c <DoSampler+0xff6>
	{
		temp|=Om_LED_ODUB;
    4b1a:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    4b1c:	83 e2       	ldi	r24, 0x23	; 35
    4b1e:	90 e0       	ldi	r25, 0x00	; 0
    4b20:	48 9f       	mul	r20, r24
    4b22:	f0 01       	movw	r30, r0
    4b24:	49 9f       	mul	r20, r25
    4b26:	f0 0d       	add	r31, r0
    4b28:	58 9f       	mul	r21, r24
    4b2a:	f0 0d       	add	r31, r0
    4b2c:	11 24       	eor	r1, r1
    4b2e:	ea 51       	subi	r30, 0x1A	; 26
    4b30:	fa 4f       	sbci	r31, 0xFA	; 250
    4b32:	80 81       	ld	r24, Z
    4b34:	82 30       	cpi	r24, 0x02	; 2
    4b36:	09 f4       	brne	.+2      	; 0x4b3a <DoSampler+0x1014>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    4b38:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    4b3a:	80 91 42 01 	lds	r24, 0x0142
    4b3e:	81 30       	cpi	r24, 0x01	; 1
    4b40:	09 f4       	brne	.+2      	; 0x4b44 <DoSampler+0x101e>
	{
		temp|=Om_LED_OUT_OF_MEM;
    4b42:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    4b44:	31 30       	cpi	r19, 0x01	; 1
    4b46:	09 f4       	brne	.+2      	; 0x4b4a <DoSampler+0x1024>
	{
		temp|=Om_LED_BANK;
    4b48:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    4b4a:	20 93 3b 01 	sts	0x013B, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    4b4e:	83 e2       	ldi	r24, 0x23	; 35
    4b50:	90 e0       	ldi	r25, 0x00	; 0
    4b52:	48 9f       	mul	r20, r24
    4b54:	f0 01       	movw	r30, r0
    4b56:	49 9f       	mul	r20, r25
    4b58:	f0 0d       	add	r31, r0
    4b5a:	58 9f       	mul	r21, r24
    4b5c:	f0 0d       	add	r31, r0
    4b5e:	11 24       	eor	r1, r1
    4b60:	ea 51       	subi	r30, 0x1A	; 26
    4b62:	fa 4f       	sbci	r31, 0xFA	; 250
    4b64:	20 89       	ldd	r18, Z+16	; 0x10
    4b66:	31 89       	ldd	r19, Z+17	; 0x11
    4b68:	42 89       	ldd	r20, Z+18	; 0x12
    4b6a:	53 89       	ldd	r21, Z+19	; 0x13
    4b6c:	84 85       	ldd	r24, Z+12	; 0x0c
    4b6e:	95 85       	ldd	r25, Z+13	; 0x0d
    4b70:	a6 85       	ldd	r26, Z+14	; 0x0e
    4b72:	b7 85       	ldd	r27, Z+15	; 0x0f
    4b74:	28 17       	cp	r18, r24
    4b76:	39 07       	cpc	r19, r25
    4b78:	4a 07       	cpc	r20, r26
    4b7a:	5b 07       	cpc	r21, r27
    4b7c:	39 f4       	brne	.+14     	; 0x4b8c <DoSampler+0x1066>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    4b7e:	80 91 3c 01 	lds	r24, 0x013C
    4b82:	82 fd       	sbrc	r24, 2
    4b84:	07 c0       	rjmp	.+14     	; 0x4b94 <DoSampler+0x106e>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    4b86:	84 e0       	ldi	r24, 0x04	; 4
    4b88:	90 e0       	ldi	r25, 0x00	; 0
    4b8a:	02 c0       	rjmp	.+4      	; 0x4b90 <DoSampler+0x106a>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    4b8c:	80 e0       	ldi	r24, 0x00	; 0
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	0e 94 f3 13 	call	0x27e6	; 0x27e6 <BlinkLeds>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    4b94:	df 91       	pop	r29
    4b96:	cf 91       	pop	r28
    4b98:	1f 91       	pop	r17
    4b9a:	0f 91       	pop	r16
    4b9c:	ff 90       	pop	r15
    4b9e:	ef 90       	pop	r14
    4ba0:	df 90       	pop	r13
    4ba2:	cf 90       	pop	r12
    4ba4:	08 95       	ret

00004ba6 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{	
	if(subState==SS_0)
    4ba6:	80 91 41 01 	lds	r24, 0x0141
    4baa:	88 23       	and	r24, r24
    4bac:	a1 f4       	brne	.+40     	; 0x4bd6 <SetMidiChannels+0x30>
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    4bae:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <GetMidiChannel>
    4bb2:	80 93 2e 06 	sts	0x062E, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);
    4bb6:	81 e0       	ldi	r24, 0x01	; 1
    4bb8:	0e 94 7f 1d 	call	0x3afe	; 0x3afe <GetMidiChannel>
    4bbc:	80 93 47 06 	sts	0x0647, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    4bc0:	82 95       	swap	r24
    4bc2:	80 7f       	andi	r24, 0xF0	; 240
    4bc4:	90 91 2e 06 	lds	r25, 0x062E
    4bc8:	98 2b       	or	r25, r24
    4bca:	90 93 3b 01 	sts	0x013B, r25
		subState=SS_1;
    4bce:	81 e0       	ldi	r24, 0x01	; 1
    4bd0:	80 93 41 01 	sts	0x0141, r24
    4bd4:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    4bd6:	80 91 3f 01 	lds	r24, 0x013F
    4bda:	28 2f       	mov	r18, r24
    4bdc:	80 ff       	sbrs	r24, 0
    4bde:	11 c0       	rjmp	.+34     	; 0x4c02 <SetMidiChannels+0x5c>
		{
			midiChannelNumberA++;
    4be0:	80 91 2e 06 	lds	r24, 0x062E
    4be4:	8f 5f       	subi	r24, 0xFF	; 255
    4be6:	80 93 2e 06 	sts	0x062E, r24
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    4bea:	80 31       	cpi	r24, 0x10	; 16
    4bec:	10 f0       	brcs	.+4      	; 0x4bf2 <SetMidiChannels+0x4c>
			{
				midiChannelNumberA=0;
    4bee:	10 92 2e 06 	sts	0x062E, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    4bf2:	80 91 3b 01 	lds	r24, 0x013B
    4bf6:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    4bf8:	90 91 2e 06 	lds	r25, 0x062E
    4bfc:	89 2b       	or	r24, r25
    4bfe:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_1)
    4c02:	21 ff       	sbrs	r18, 1
    4c04:	13 c0       	rjmp	.+38     	; 0x4c2c <SetMidiChannels+0x86>
		{
			midiChannelNumberB++;
    4c06:	80 91 47 06 	lds	r24, 0x0647
    4c0a:	8f 5f       	subi	r24, 0xFF	; 255
    4c0c:	80 93 47 06 	sts	0x0647, r24
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    4c10:	80 31       	cpi	r24, 0x10	; 16
    4c12:	10 f0       	brcs	.+4      	; 0x4c18 <SetMidiChannels+0x72>
			{
				midiChannelNumberB=0;
    4c14:	10 92 47 06 	sts	0x0647, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    4c18:	90 91 3b 01 	lds	r25, 0x013B
    4c1c:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.		
    4c1e:	80 91 47 06 	lds	r24, 0x0647
    4c22:	82 95       	swap	r24
    4c24:	80 7f       	andi	r24, 0xF0	; 240
    4c26:	89 2b       	or	r24, r25
    4c28:	80 93 3b 01 	sts	0x013B, r24
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    4c2c:	22 ff       	sbrs	r18, 2
    4c2e:	14 c0       	rjmp	.+40     	; 0x4c58 <SetMidiChannels+0xb2>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    4c30:	84 e0       	ldi	r24, 0x04	; 4
    4c32:	90 e0       	ldi	r25, 0x00	; 0
    4c34:	60 91 2e 06 	lds	r22, 0x062E
    4c38:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    4c3c:	88 e0       	ldi	r24, 0x08	; 8
    4c3e:	90 e0       	ldi	r25, 0x00	; 0
    4c40:	60 91 47 06 	lds	r22, 0x0647
    4c44:	0e 94 2d 26 	call	0x4c5a	; 0x4c5a <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4c48:	83 e9       	ldi	r24, 0x93	; 147
    4c4a:	9d e1       	ldi	r25, 0x1D	; 29
    4c4c:	90 93 e5 05 	sts	0x05E5, r25
    4c50:	80 93 e4 05 	sts	0x05E4, r24
	subState=SS_0;
    4c54:	10 92 41 01 	sts	0x0141, r1
    4c58:	08 95       	ret

00004c5a <EepromWrite>:
// NOTE:  Accepted lore is not to use eeprom address 0 since it's the most likely one to get buggered in a crash.

#include "includes.h"

void EepromWrite(unsigned int theAddress, unsigned char theData)
{
    4c5a:	9c 01       	movw	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    4c5c:	f9 99       	sbic	0x1f, 1	; 31
    4c5e:	fe cf       	rjmp	.-4      	; 0x4c5c <EepromWrite+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    4c60:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    4c62:	f8 94       	cli

	EEAR=theAddress;
    4c64:	32 bd       	out	0x22, r19	; 34
    4c66:	21 bd       	out	0x21, r18	; 33
	EEDR=theData;
    4c68:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    4c6a:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    4c6c:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    4c6e:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    4c70:	12 bc       	out	0x22, r1	; 34
    4c72:	11 bc       	out	0x21, r1	; 33
}
    4c74:	08 95       	ret

00004c76 <EepromRead>:

unsigned char EepromRead(unsigned char theAddress)
{
    4c76:	28 2f       	mov	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    4c78:	f9 99       	sbic	0x1f, 1	; 31
    4c7a:	fe cf       	rjmp	.-4      	; 0x4c78 <EepromRead+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    4c7c:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    4c7e:	f8 94       	cli

	EEAR=theAddress;
    4c80:	30 e0       	ldi	r19, 0x00	; 0
    4c82:	32 bd       	out	0x22, r19	; 34
    4c84:	21 bd       	out	0x21, r18	; 33
	EECR|=(1<<EERE);	// Start reading.
    4c86:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    4c88:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    4c8a:	12 bc       	out	0x22, r1	; 34
    4c8c:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    4c8e:	80 b5       	in	r24, 0x20	; 32
}
    4c90:	08 95       	ret

00004c92 <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4c92:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    4c96:	88 1f       	adc	r24, r24
    4c98:	88 27       	eor	r24, r24
    4c9a:	88 1f       	adc	r24, r24
    4c9c:	08 95       	ret

00004c9e <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    4c9e:	80 91 c6 00 	lds	r24, 0x00C6
}
    4ca2:	08 95       	ret

00004ca4 <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    4ca4:	80 91 64 00 	lds	r24, 0x0064
    4ca8:	8d 7f       	andi	r24, 0xFD	; 253
    4caa:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    4cae:	80 91 c0 00 	lds	r24, 0x00C0
    4cb2:	8d 7f       	andi	r24, 0xFD	; 253
    4cb4:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    4cb8:	88 e1       	ldi	r24, 0x18	; 24
    4cba:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    4cbe:	87 e2       	ldi	r24, 0x27	; 39
    4cc0:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    4cc4:	86 e0       	ldi	r24, 0x06	; 6
    4cc6:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    4cca:	80 91 c0 00 	lds	r24, 0x00C0
    4cce:	85 ff       	sbrs	r24, 5
    4cd0:	fc cf       	rjmp	.-8      	; 0x4cca <InitUart0+0x26>
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4cd2:	80 91 c0 00 	lds	r24, 0x00C0
    4cd6:	87 ff       	sbrs	r24, 7
    4cd8:	03 c0       	rjmp	.+6      	; 0x4ce0 <InitUart0+0x3c>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    4cda:	80 91 c6 00 	lds	r24, 0x00C6
    4cde:	f9 cf       	rjmp	.-14     	; 0x4cd2 <InitUart0+0x2e>
    4ce0:	08 95       	ret

00004ce2 <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    4ce2:	e8 2f       	mov	r30, r24
    4ce4:	f0 e0       	ldi	r31, 0x00	; 0
    4ce6:	80 91 2c 06 	lds	r24, 0x062C
    4cea:	90 91 2d 06 	lds	r25, 0x062D
    4cee:	ee 0f       	add	r30, r30
    4cf0:	ff 1f       	adc	r31, r31
    4cf2:	df 01       	movw	r26, r30
    4cf4:	ab 53       	subi	r26, 0x3B	; 59
    4cf6:	ba 4f       	sbci	r27, 0xFA	; 250
    4cf8:	8d 93       	st	X+, r24
    4cfa:	9c 93       	st	X, r25
	delayTime[timerNum]=ticks_to_wait;
    4cfc:	e3 53       	subi	r30, 0x33	; 51
    4cfe:	fa 4f       	sbci	r31, 0xFA	; 250
    4d00:	71 83       	std	Z+1, r23	; 0x01
    4d02:	60 83       	st	Z, r22
}
    4d04:	08 95       	ret

00004d06 <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    4d06:	20 91 2c 06 	lds	r18, 0x062C
    4d0a:	30 91 2d 06 	lds	r19, 0x062D
    4d0e:	e8 2f       	mov	r30, r24
    4d10:	f0 e0       	ldi	r31, 0x00	; 0
    4d12:	40 e0       	ldi	r20, 0x00	; 0
    4d14:	ee 0f       	add	r30, r30
    4d16:	ff 1f       	adc	r31, r31
    4d18:	df 01       	movw	r26, r30
    4d1a:	ab 53       	subi	r26, 0x3B	; 59
    4d1c:	ba 4f       	sbci	r27, 0xFA	; 250
    4d1e:	8d 91       	ld	r24, X+
    4d20:	9c 91       	ld	r25, X
    4d22:	28 1b       	sub	r18, r24
    4d24:	39 0b       	sbc	r19, r25
    4d26:	e3 53       	subi	r30, 0x33	; 51
    4d28:	fa 4f       	sbci	r31, 0xFA	; 250
    4d2a:	80 81       	ld	r24, Z
    4d2c:	91 81       	ldd	r25, Z+1	; 0x01
    4d2e:	28 17       	cp	r18, r24
    4d30:	39 07       	cpc	r19, r25
    4d32:	08 f0       	brcs	.+2      	; 0x4d36 <CheckTimer+0x30>
    4d34:	41 e0       	ldi	r20, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    4d36:	84 2f       	mov	r24, r20
    4d38:	08 95       	ret

00004d3a <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    4d3a:	cf 93       	push	r28
    4d3c:	df 93       	push	r29
    4d3e:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    4d40:	20 91 60 06 	lds	r18, 0x0660
    4d44:	22 23       	and	r18, r18
    4d46:	19 f1       	breq	.+70     	; 0x4d8e <GetMidiMessageFromIncomingFifo+0x54>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    4d48:	90 91 dd 05 	lds	r25, 0x05DD
    4d4c:	e9 2f       	mov	r30, r25
    4d4e:	f0 e0       	ldi	r31, 0x00	; 0
    4d50:	ee 0f       	add	r30, r30
    4d52:	ff 1f       	adc	r31, r31
    4d54:	ee 0f       	add	r30, r30
    4d56:	ff 1f       	adc	r31, r31
    4d58:	df 01       	movw	r26, r30
    4d5a:	a1 5d       	subi	r26, 0xD1	; 209
    4d5c:	b9 4f       	sbci	r27, 0xF9	; 249
    4d5e:	11 96       	adiw	r26, 0x01	; 1
    4d60:	8c 91       	ld	r24, X
    4d62:	11 97       	sbiw	r26, 0x01	; 1
    4d64:	89 83       	std	Y+1, r24	; 0x01
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    4d66:	ef 5c       	subi	r30, 0xCF	; 207
    4d68:	f9 4f       	sbci	r31, 0xF9	; 249
    4d6a:	80 81       	ld	r24, Z
    4d6c:	8a 83       	std	Y+2, r24	; 0x02
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    4d6e:	13 96       	adiw	r26, 0x03	; 3
    4d70:	8c 91       	ld	r24, X
    4d72:	13 97       	sbiw	r26, 0x03	; 3
    4d74:	8b 83       	std	Y+3, r24	; 0x03
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    4d76:	8c 91       	ld	r24, X
    4d78:	88 83       	st	Y, r24

		midiIncomingFifoReadPointer++;			// read from the next element next time
    4d7a:	9f 5f       	subi	r25, 0xFF	; 255
    4d7c:	90 93 dd 05 	sts	0x05DD, r25
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    4d80:	96 30       	cpi	r25, 0x06	; 6
    4d82:	10 f0       	brcs	.+4      	; 0x4d88 <GetMidiMessageFromIncomingFifo+0x4e>
		{
			midiIncomingFifoReadPointer=0;
    4d84:	10 92 dd 05 	sts	0x05DD, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    4d88:	21 50       	subi	r18, 0x01	; 1
    4d8a:	20 93 60 06 	sts	0x0660, r18
	}
}
    4d8e:	df 91       	pop	r29
    4d90:	cf 91       	pop	r28
    4d92:	08 95       	ret

00004d94 <PutMidiMessageInIncomingFifo>:

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    4d94:	cf 93       	push	r28
    4d96:	df 93       	push	r29
    4d98:	ec 01       	movw	r28, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    4d9a:	20 91 60 06 	lds	r18, 0x0660
    4d9e:	26 30       	cpi	r18, 0x06	; 6
    4da0:	18 f5       	brcc	.+70     	; 0x4de8 <PutMidiMessageInIncomingFifo+0x54>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    4da2:	90 91 dc 05 	lds	r25, 0x05DC
    4da6:	e9 2f       	mov	r30, r25
    4da8:	f0 e0       	ldi	r31, 0x00	; 0
    4daa:	ee 0f       	add	r30, r30
    4dac:	ff 1f       	adc	r31, r31
    4dae:	ee 0f       	add	r30, r30
    4db0:	ff 1f       	adc	r31, r31
    4db2:	df 01       	movw	r26, r30
    4db4:	a1 5d       	subi	r26, 0xD1	; 209
    4db6:	b9 4f       	sbci	r27, 0xF9	; 249
    4db8:	89 81       	ldd	r24, Y+1	; 0x01
    4dba:	11 96       	adiw	r26, 0x01	; 1
    4dbc:	8c 93       	st	X, r24
    4dbe:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4dc0:	ef 5c       	subi	r30, 0xCF	; 207
    4dc2:	f9 4f       	sbci	r31, 0xF9	; 249
    4dc4:	8a 81       	ldd	r24, Y+2	; 0x02
    4dc6:	80 83       	st	Z, r24
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    4dc8:	8b 81       	ldd	r24, Y+3	; 0x03
    4dca:	13 96       	adiw	r26, 0x03	; 3
    4dcc:	8c 93       	st	X, r24
    4dce:	13 97       	sbiw	r26, 0x03	; 3
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    4dd0:	88 81       	ld	r24, Y
    4dd2:	8c 93       	st	X, r24
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    4dd4:	9f 5f       	subi	r25, 0xFF	; 255
    4dd6:	90 93 dc 05 	sts	0x05DC, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    4dda:	96 30       	cpi	r25, 0x06	; 6
    4ddc:	10 f0       	brcs	.+4      	; 0x4de2 <PutMidiMessageInIncomingFifo+0x4e>
		{
			midiIncomingFifoWritePointer=0;
    4dde:	10 92 dc 05 	sts	0x05DC, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    4de2:	2f 5f       	subi	r18, 0xFF	; 255
    4de4:	20 93 60 06 	sts	0x0660, r18
	}
}
    4de8:	df 91       	pop	r29
    4dea:	cf 91       	pop	r28
    4dec:	08 95       	ret

00004dee <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    4dee:	30 91 61 06 	lds	r19, 0x0661
    4df2:	36 30       	cpi	r19, 0x06	; 6
    4df4:	08 f5       	brcc	.+66     	; 0x4e38 <PutMidiMessageInOutgoingFifo+0x4a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    4df6:	90 91 df 05 	lds	r25, 0x05DF
    4dfa:	e9 2f       	mov	r30, r25
    4dfc:	f0 e0       	ldi	r31, 0x00	; 0
    4dfe:	ee 0f       	add	r30, r30
    4e00:	ff 1f       	adc	r31, r31
    4e02:	ee 0f       	add	r30, r30
    4e04:	ff 1f       	adc	r31, r31
    4e06:	df 01       	movw	r26, r30
    4e08:	a8 5b       	subi	r26, 0xB8	; 184
    4e0a:	b9 4f       	sbci	r27, 0xF9	; 249
    4e0c:	11 96       	adiw	r26, 0x01	; 1
    4e0e:	6c 93       	st	X, r22
    4e10:	11 97       	sbiw	r26, 0x01	; 1
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    4e12:	e6 5b       	subi	r30, 0xB6	; 182
    4e14:	f9 4f       	sbci	r31, 0xF9	; 249
    4e16:	40 83       	st	Z, r20
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    4e18:	13 96       	adiw	r26, 0x03	; 3
    4e1a:	2c 93       	st	X, r18
    4e1c:	13 97       	sbiw	r26, 0x03	; 3
    4e1e:	80 91 2e 06 	lds	r24, 0x062E
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    4e22:	8c 93       	st	X, r24
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    4e24:	9f 5f       	subi	r25, 0xFF	; 255
    4e26:	90 93 df 05 	sts	0x05DF, r25
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    4e2a:	96 30       	cpi	r25, 0x06	; 6
    4e2c:	10 f0       	brcs	.+4      	; 0x4e32 <PutMidiMessageInOutgoingFifo+0x44>
		{
			midiOutgoingFifoWritePointer=0;
    4e2e:	10 92 df 05 	sts	0x05DF, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    4e32:	3f 5f       	subi	r19, 0xFF	; 255
    4e34:	30 93 61 06 	sts	0x0661, r19
    4e38:	08 95       	ret

00004e3a <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    4e3a:	89 e0       	ldi	r24, 0x09	; 9
    4e3c:	80 93 de 05 	sts	0x05DE, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    4e40:	10 92 e1 05 	sts	0x05E1, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    4e44:	10 92 60 06 	sts	0x0660, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    4e48:	10 92 dc 05 	sts	0x05DC, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    4e4c:	10 92 dd 05 	sts	0x05DD, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    4e50:	10 92 61 06 	sts	0x0661, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    4e54:	10 92 df 05 	sts	0x05DF, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    4e58:	10 92 e0 05 	sts	0x05E0, r1
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
	InitMidiIncomingFifo();								// Set up the receiving buffer.
	InitMidiOutgoingFifo();								// Set up xmit buffer.
}
    4e5c:	08 95       	ret

00004e5e <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    4e5e:	1f 93       	push	r17
    4e60:	df 93       	push	r29
    4e62:	cf 93       	push	r28
    4e64:	00 d0       	rcall	.+0      	; 0x4e66 <HandleIncomingMidiByte+0x8>
    4e66:	00 d0       	rcall	.+0      	; 0x4e68 <HandleIncomingMidiByte+0xa>
    4e68:	cd b7       	in	r28, 0x3d	; 61
    4e6a:	de b7       	in	r29, 0x3e	; 62
    4e6c:	28 2f       	mov	r18, r24
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    4e6e:	87 ff       	sbrs	r24, 7
    4e70:	41 c0       	rjmp	.+130    	; 0x4ef4 <HandleIncomingMidiByte+0x96>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    4e72:	68 2f       	mov	r22, r24
    4e74:	70 e0       	ldi	r23, 0x00	; 0
    4e76:	9b 01       	movw	r18, r22
    4e78:	2f 70       	andi	r18, 0x0F	; 15
    4e7a:	30 70       	andi	r19, 0x00	; 0
    4e7c:	80 91 2e 06 	lds	r24, 0x062E
    4e80:	48 2f       	mov	r20, r24
    4e82:	50 e0       	ldi	r21, 0x00	; 0
    4e84:	24 17       	cp	r18, r20
    4e86:	35 07       	cpc	r19, r21
    4e88:	39 f0       	breq	.+14     	; 0x4e98 <HandleIncomingMidiByte+0x3a>
    4e8a:	80 91 47 06 	lds	r24, 0x0647
    4e8e:	90 e0       	ldi	r25, 0x00	; 0
    4e90:	28 17       	cp	r18, r24
    4e92:	39 07       	cpc	r19, r25
    4e94:	09 f0       	breq	.+2      	; 0x4e98 <HandleIncomingMidiByte+0x3a>
    4e96:	ad c0       	rjmp	.+346    	; 0x4ff2 <HandleIncomingMidiByte+0x194>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    4e98:	cb 01       	movw	r24, r22
    4e9a:	80 7f       	andi	r24, 0xF0	; 240
    4e9c:	90 70       	andi	r25, 0x00	; 0
    4e9e:	80 39       	cpi	r24, 0x90	; 144
    4ea0:	91 05       	cpc	r25, r1
    4ea2:	19 f4       	brne	.+6      	; 0x4eaa <HandleIncomingMidiByte+0x4c>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    4ea4:	10 92 de 05 	sts	0x05DE, r1
    4ea8:	1b c0       	rjmp	.+54     	; 0x4ee0 <HandleIncomingMidiByte+0x82>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    4eaa:	80 38       	cpi	r24, 0x80	; 128
    4eac:	91 05       	cpc	r25, r1
    4eae:	39 f4       	brne	.+14     	; 0x4ebe <HandleIncomingMidiByte+0x60>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    4eb0:	81 e0       	ldi	r24, 0x01	; 1
    4eb2:	80 93 de 05 	sts	0x05DE, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    4eb6:	24 17       	cp	r18, r20
    4eb8:	35 07       	cpc	r19, r21
    4eba:	c9 f4       	brne	.+50     	; 0x4eee <HandleIncomingMidiByte+0x90>
    4ebc:	14 c0       	rjmp	.+40     	; 0x4ee6 <HandleIncomingMidiByte+0x88>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    4ebe:	80 3c       	cpi	r24, 0xC0	; 192
    4ec0:	91 05       	cpc	r25, r1
    4ec2:	11 f4       	brne	.+4      	; 0x4ec8 <HandleIncomingMidiByte+0x6a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    4ec4:	82 e0       	ldi	r24, 0x02	; 2
    4ec6:	0a c0       	rjmp	.+20     	; 0x4edc <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    4ec8:	80 3e       	cpi	r24, 0xE0	; 224
    4eca:	91 05       	cpc	r25, r1
    4ecc:	11 f4       	brne	.+4      	; 0x4ed2 <HandleIncomingMidiByte+0x74>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    4ece:	87 e0       	ldi	r24, 0x07	; 7
    4ed0:	05 c0       	rjmp	.+10     	; 0x4edc <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    4ed2:	80 3b       	cpi	r24, 0xB0	; 176
    4ed4:	91 05       	cpc	r25, r1
    4ed6:	09 f0       	breq	.+2      	; 0x4eda <HandleIncomingMidiByte+0x7c>
    4ed8:	8c c0       	rjmp	.+280    	; 0x4ff2 <HandleIncomingMidiByte+0x194>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    4eda:	83 e0       	ldi	r24, 0x03	; 3
    4edc:	80 93 de 05 	sts	0x05DE, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    4ee0:	24 17       	cp	r18, r20
    4ee2:	35 07       	cpc	r19, r21
    4ee4:	19 f4       	brne	.+6      	; 0x4eec <HandleIncomingMidiByte+0x8e>
				{
					temporaryChannel=BANK_0;
    4ee6:	10 92 da 05 	sts	0x05DA, r1
    4eea:	86 c0       	rjmp	.+268    	; 0x4ff8 <HandleIncomingMidiByte+0x19a>
				}
				else
				{
					temporaryChannel=BANK_1;
    4eec:	81 e0       	ldi	r24, 0x01	; 1
    4eee:	80 93 da 05 	sts	0x05DA, r24
    4ef2:	82 c0       	rjmp	.+260    	; 0x4ff8 <HandleIncomingMidiByte+0x19a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    4ef4:	10 91 de 05 	lds	r17, 0x05DE
    4ef8:	14 30       	cpi	r17, 0x04	; 4
    4efa:	09 f4       	brne	.+2      	; 0x4efe <HandleIncomingMidiByte+0xa0>
    4efc:	58 c0       	rjmp	.+176    	; 0x4fae <HandleIncomingMidiByte+0x150>
    4efe:	15 30       	cpi	r17, 0x05	; 5
    4f00:	58 f4       	brcc	.+22     	; 0x4f18 <HandleIncomingMidiByte+0xba>
    4f02:	11 30       	cpi	r17, 0x01	; 1
    4f04:	c1 f1       	breq	.+112    	; 0x4f76 <HandleIncomingMidiByte+0x118>
    4f06:	11 30       	cpi	r17, 0x01	; 1
    4f08:	c8 f0       	brcs	.+50     	; 0x4f3c <HandleIncomingMidiByte+0xde>
    4f0a:	12 30       	cpi	r17, 0x02	; 2
    4f0c:	09 f4       	brne	.+2      	; 0x4f10 <HandleIncomingMidiByte+0xb2>
    4f0e:	46 c0       	rjmp	.+140    	; 0x4f9c <HandleIncomingMidiByte+0x13e>
    4f10:	13 30       	cpi	r17, 0x03	; 3
    4f12:	09 f0       	breq	.+2      	; 0x4f16 <HandleIncomingMidiByte+0xb8>
    4f14:	6e c0       	rjmp	.+220    	; 0x4ff2 <HandleIncomingMidiByte+0x194>
    4f16:	47 c0       	rjmp	.+142    	; 0x4fa6 <HandleIncomingMidiByte+0x148>
    4f18:	17 30       	cpi	r17, 0x07	; 7
    4f1a:	09 f4       	brne	.+2      	; 0x4f1e <HandleIncomingMidiByte+0xc0>
    4f1c:	56 c0       	rjmp	.+172    	; 0x4fca <HandleIncomingMidiByte+0x16c>
    4f1e:	18 30       	cpi	r17, 0x08	; 8
    4f20:	30 f4       	brcc	.+12     	; 0x4f2e <HandleIncomingMidiByte+0xd0>
    4f22:	15 30       	cpi	r17, 0x05	; 5
    4f24:	79 f0       	breq	.+30     	; 0x4f44 <HandleIncomingMidiByte+0xe6>
    4f26:	16 30       	cpi	r17, 0x06	; 6
    4f28:	09 f0       	breq	.+2      	; 0x4f2c <HandleIncomingMidiByte+0xce>
    4f2a:	63 c0       	rjmp	.+198    	; 0x4ff2 <HandleIncomingMidiByte+0x194>
    4f2c:	28 c0       	rjmp	.+80     	; 0x4f7e <HandleIncomingMidiByte+0x120>
    4f2e:	18 30       	cpi	r17, 0x08	; 8
    4f30:	09 f4       	brne	.+2      	; 0x4f34 <HandleIncomingMidiByte+0xd6>
    4f32:	4f c0       	rjmp	.+158    	; 0x4fd2 <HandleIncomingMidiByte+0x174>
    4f34:	19 30       	cpi	r17, 0x09	; 9
    4f36:	09 f0       	breq	.+2      	; 0x4f3a <HandleIncomingMidiByte+0xdc>
    4f38:	5c c0       	rjmp	.+184    	; 0x4ff2 <HandleIncomingMidiByte+0x194>
    4f3a:	5e c0       	rjmp	.+188    	; 0x4ff8 <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    4f3c:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    4f40:	85 e0       	ldi	r24, 0x05	; 5
    4f42:	58 c0       	rjmp	.+176    	; 0x4ff4 <HandleIncomingMidiByte+0x196>
    4f44:	30 91 db 05 	lds	r19, 0x05DB
    4f48:	40 91 da 05 	lds	r20, 0x05DA
    4f4c:	be 01       	movw	r22, r28
    4f4e:	6f 5f       	subi	r22, 0xFF	; 255
    4f50:	7f 4f       	sbci	r23, 0xFF	; 255
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    4f52:	88 23       	and	r24, r24
    4f54:	29 f4       	brne	.+10     	; 0x4f60 <HandleIncomingMidiByte+0x102>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    4f56:	82 e0       	ldi	r24, 0x02	; 2
    4f58:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4f5a:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    4f5c:	1c 82       	std	Y+4, r1	; 0x04
    4f5e:	04 c0       	rjmp	.+8      	; 0x4f68 <HandleIncomingMidiByte+0x10a>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    4f60:	81 e0       	ldi	r24, 0x01	; 1
    4f62:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    4f64:	3b 83       	std	Y+3, r19	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    4f66:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    4f68:	49 83       	std	Y+1, r20	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    4f6a:	cb 01       	movw	r24, r22
    4f6c:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    4f70:	10 92 de 05 	sts	0x05DE, r1
    4f74:	41 c0       	rjmp	.+130    	; 0x4ff8 <HandleIncomingMidiByte+0x19a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    4f76:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    4f7a:	86 e0       	ldi	r24, 0x06	; 6
    4f7c:	3b c0       	rjmp	.+118    	; 0x4ff4 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    4f7e:	82 e0       	ldi	r24, 0x02	; 2
    4f80:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4f82:	80 91 db 05 	lds	r24, 0x05DB
    4f86:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    4f88:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    4f8a:	80 91 da 05 	lds	r24, 0x05DA
    4f8e:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    4f90:	ce 01       	movw	r24, r28
    4f92:	01 96       	adiw	r24, 0x01	; 1
    4f94:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	2c c0       	rjmp	.+88     	; 0x4ff4 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    4f9c:	83 e0       	ldi	r24, 0x03	; 3
    4f9e:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    4fa0:	2b 83       	std	Y+3, r18	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    4fa2:	1c 82       	std	Y+4, r1	; 0x04
    4fa4:	1c c0       	rjmp	.+56     	; 0x4fde <HandleIncomingMidiByte+0x180>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    4fa6:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    4faa:	84 e0       	ldi	r24, 0x04	; 4
    4fac:	23 c0       	rjmp	.+70     	; 0x4ff4 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    4fae:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    4fb0:	80 91 db 05 	lds	r24, 0x05DB
    4fb4:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    4fb6:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    4fb8:	80 91 da 05 	lds	r24, 0x05DA
    4fbc:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    4fbe:	ce 01       	movw	r24, r28
    4fc0:	01 96       	adiw	r24, 0x01	; 1
    4fc2:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    4fc6:	83 e0       	ldi	r24, 0x03	; 3
    4fc8:	15 c0       	rjmp	.+42     	; 0x4ff4 <HandleIncomingMidiByte+0x196>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    4fca:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    4fce:	88 e0       	ldi	r24, 0x08	; 8
    4fd0:	11 c0       	rjmp	.+34     	; 0x4ff4 <HandleIncomingMidiByte+0x196>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    4fd2:	17 e0       	ldi	r17, 0x07	; 7
    4fd4:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    4fd6:	80 91 db 05 	lds	r24, 0x05DB
    4fda:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    4fdc:	2c 83       	std	Y+4, r18	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    4fde:	80 91 da 05 	lds	r24, 0x05DA
    4fe2:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    4fe4:	ce 01       	movw	r24, r28
    4fe6:	01 96       	adiw	r24, 0x01	; 1
    4fe8:	0e 94 ca 26 	call	0x4d94	; 0x4d94 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    4fec:	10 93 de 05 	sts	0x05DE, r17
    4ff0:	03 c0       	rjmp	.+6      	; 0x4ff8 <HandleIncomingMidiByte+0x19a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    4ff2:	89 e0       	ldi	r24, 0x09	; 9
    4ff4:	80 93 de 05 	sts	0x05DE, r24
			break;
		}	
	}
}
    4ff8:	0f 90       	pop	r0
    4ffa:	0f 90       	pop	r0
    4ffc:	0f 90       	pop	r0
    4ffe:	0f 90       	pop	r0
    5000:	cf 91       	pop	r28
    5002:	df 91       	pop	r29
    5004:	1f 91       	pop	r17
    5006:	08 95       	ret

00005008 <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    5008:	80 91 61 06 	lds	r24, 0x0661
    500c:	88 23       	and	r24, r24
    500e:	11 f0       	breq	.+4      	; 0x5014 <MidiTxBufferNotEmpty+0xc>
    5010:	81 e0       	ldi	r24, 0x01	; 1
    5012:	08 95       	ret
    5014:	80 91 e1 05 	lds	r24, 0x05E1
    5018:	81 11       	cpse	r24, r1
    501a:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    501c:	08 95       	ret

0000501e <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    501e:	80 91 e1 05 	lds	r24, 0x05E1
    5022:	83 30       	cpi	r24, 0x03	; 3
    5024:	09 f4       	brne	.+2      	; 0x5028 <PopOutgoingMidiByte+0xa>
    5026:	91 c0       	rjmp	.+290    	; 0x514a <PopOutgoingMidiByte+0x12c>
    5028:	84 30       	cpi	r24, 0x04	; 4
    502a:	38 f4       	brcc	.+14     	; 0x503a <PopOutgoingMidiByte+0x1c>
    502c:	81 30       	cpi	r24, 0x01	; 1
    502e:	09 f4       	brne	.+2      	; 0x5032 <PopOutgoingMidiByte+0x14>
    5030:	88 c0       	rjmp	.+272    	; 0x5142 <PopOutgoingMidiByte+0x124>
    5032:	82 30       	cpi	r24, 0x02	; 2
    5034:	08 f0       	brcs	.+2      	; 0x5038 <PopOutgoingMidiByte+0x1a>
    5036:	87 c0       	rjmp	.+270    	; 0x5146 <PopOutgoingMidiByte+0x128>
    5038:	0d c0       	rjmp	.+26     	; 0x5054 <PopOutgoingMidiByte+0x36>
    503a:	85 30       	cpi	r24, 0x05	; 5
    503c:	09 f4       	brne	.+2      	; 0x5040 <PopOutgoingMidiByte+0x22>
    503e:	8c c0       	rjmp	.+280    	; 0x5158 <PopOutgoingMidiByte+0x13a>
    5040:	85 30       	cpi	r24, 0x05	; 5
    5042:	08 f4       	brcc	.+2      	; 0x5046 <PopOutgoingMidiByte+0x28>
    5044:	86 c0       	rjmp	.+268    	; 0x5152 <PopOutgoingMidiByte+0x134>
    5046:	86 30       	cpi	r24, 0x06	; 6
    5048:	09 f4       	brne	.+2      	; 0x504c <PopOutgoingMidiByte+0x2e>
    504a:	89 c0       	rjmp	.+274    	; 0x515e <PopOutgoingMidiByte+0x140>
    504c:	87 30       	cpi	r24, 0x07	; 7
    504e:	09 f0       	breq	.+2      	; 0x5052 <PopOutgoingMidiByte+0x34>
    5050:	91 c0       	rjmp	.+290    	; 0x5174 <PopOutgoingMidiByte+0x156>
    5052:	8b c0       	rjmp	.+278    	; 0x516a <PopOutgoingMidiByte+0x14c>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    5054:	20 91 61 06 	lds	r18, 0x0661
    5058:	22 23       	and	r18, r18
    505a:	39 f1       	breq	.+78     	; 0x50aa <PopOutgoingMidiByte+0x8c>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    505c:	90 91 e0 05 	lds	r25, 0x05E0
    5060:	e9 2f       	mov	r30, r25
    5062:	f0 e0       	ldi	r31, 0x00	; 0
    5064:	ee 0f       	add	r30, r30
    5066:	ff 1f       	adc	r31, r31
    5068:	ee 0f       	add	r30, r30
    506a:	ff 1f       	adc	r31, r31
    506c:	df 01       	movw	r26, r30
    506e:	a8 5b       	subi	r26, 0xB8	; 184
    5070:	b9 4f       	sbci	r27, 0xF9	; 249
    5072:	11 96       	adiw	r26, 0x01	; 1
    5074:	8c 91       	ld	r24, X
    5076:	11 97       	sbiw	r26, 0x01	; 1
    5078:	80 93 d7 05 	sts	0x05D7, r24
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    507c:	e6 5b       	subi	r30, 0xB6	; 182
    507e:	f9 4f       	sbci	r31, 0xF9	; 249
    5080:	80 81       	ld	r24, Z
    5082:	80 93 d8 05 	sts	0x05D8, r24
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    5086:	13 96       	adiw	r26, 0x03	; 3
    5088:	8c 91       	ld	r24, X
    508a:	13 97       	sbiw	r26, 0x03	; 3
    508c:	80 93 d9 05 	sts	0x05D9, r24
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    5090:	8c 91       	ld	r24, X
    5092:	80 93 d6 05 	sts	0x05D6, r24

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    5096:	9f 5f       	subi	r25, 0xFF	; 255
    5098:	90 93 e0 05 	sts	0x05E0, r25
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    509c:	96 30       	cpi	r25, 0x06	; 6
    509e:	10 f0       	brcs	.+4      	; 0x50a4 <PopOutgoingMidiByte+0x86>
		{
			midiOutgoingFifoReadPointer=0;
    50a0:	10 92 e0 05 	sts	0x05E0, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    50a4:	21 50       	subi	r18, 0x01	; 1
    50a6:	20 93 61 06 	sts	0x0661, r18
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    50aa:	20 91 d7 05 	lds	r18, 0x05D7
    50ae:	22 30       	cpi	r18, 0x02	; 2
    50b0:	b9 f0       	breq	.+46     	; 0x50e0 <PopOutgoingMidiByte+0xc2>
    50b2:	23 30       	cpi	r18, 0x03	; 3
    50b4:	20 f4       	brcc	.+8      	; 0x50be <PopOutgoingMidiByte+0xa0>
    50b6:	21 30       	cpi	r18, 0x01	; 1
    50b8:	09 f0       	breq	.+2      	; 0x50bc <PopOutgoingMidiByte+0x9e>
    50ba:	5c c0       	rjmp	.+184    	; 0x5174 <PopOutgoingMidiByte+0x156>
    50bc:	06 c0       	rjmp	.+12     	; 0x50ca <PopOutgoingMidiByte+0xac>
    50be:	23 30       	cpi	r18, 0x03	; 3
    50c0:	f9 f0       	breq	.+62     	; 0x5100 <PopOutgoingMidiByte+0xe2>
    50c2:	24 30       	cpi	r18, 0x04	; 4
    50c4:	09 f0       	breq	.+2      	; 0x50c8 <PopOutgoingMidiByte+0xaa>
    50c6:	56 c0       	rjmp	.+172    	; 0x5174 <PopOutgoingMidiByte+0x156>
    50c8:	2b c0       	rjmp	.+86     	; 0x5120 <PopOutgoingMidiByte+0x102>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    50ca:	90 91 d6 05 	lds	r25, 0x05D6
    50ce:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    50d0:	80 91 d5 05 	lds	r24, 0x05D5
    50d4:	89 17       	cp	r24, r25
    50d6:	79 f4       	brne	.+30     	; 0x50f6 <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    50d8:	90 91 d8 05 	lds	r25, 0x05D8
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    50dc:	83 e0       	ldi	r24, 0x03	; 3
    50de:	2a c0       	rjmp	.+84     	; 0x5134 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    50e0:	90 91 d6 05 	lds	r25, 0x05D6
    50e4:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    50e6:	80 91 d5 05 	lds	r24, 0x05D5
    50ea:	89 17       	cp	r24, r25
    50ec:	21 f4       	brne	.+8      	; 0x50f6 <PopOutgoingMidiByte+0xd8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    50ee:	90 91 d8 05 	lds	r25, 0x05D8
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    50f2:	84 e0       	ldi	r24, 0x04	; 4
    50f4:	1f c0       	rjmp	.+62     	; 0x5134 <PopOutgoingMidiByte+0x116>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    50f6:	90 93 d5 05 	sts	0x05D5, r25
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
    50fa:	20 93 e1 05 	sts	0x05E1, r18
    50fe:	3b c0       	rjmp	.+118    	; 0x5176 <PopOutgoingMidiByte+0x158>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    5100:	90 91 d6 05 	lds	r25, 0x05D6
    5104:	90 6c       	ori	r25, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    5106:	80 91 d5 05 	lds	r24, 0x05D5
    510a:	89 17       	cp	r24, r25
    510c:	29 f4       	brne	.+10     	; 0x5118 <PopOutgoingMidiByte+0xfa>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    510e:	90 91 d8 05 	lds	r25, 0x05D8
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    5112:	10 92 e1 05 	sts	0x05E1, r1
    5116:	2f c0       	rjmp	.+94     	; 0x5176 <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    5118:	90 93 d5 05 	sts	0x05D5, r25
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    511c:	85 e0       	ldi	r24, 0x05	; 5
    511e:	0a c0       	rjmp	.+20     	; 0x5134 <PopOutgoingMidiByte+0x116>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    5120:	90 91 d6 05 	lds	r25, 0x05D6
    5124:	90 6b       	ori	r25, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    5126:	80 91 d5 05 	lds	r24, 0x05D5
    512a:	89 17       	cp	r24, r25
    512c:	31 f4       	brne	.+12     	; 0x513a <PopOutgoingMidiByte+0x11c>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    512e:	90 91 d8 05 	lds	r25, 0x05D8
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    5132:	87 e0       	ldi	r24, 0x07	; 7
    5134:	80 93 e1 05 	sts	0x05E1, r24
    5138:	1e c0       	rjmp	.+60     	; 0x5176 <PopOutgoingMidiByte+0x158>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    513a:	90 93 d5 05 	sts	0x05D5, r25
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    513e:	86 e0       	ldi	r24, 0x06	; 6
    5140:	f9 cf       	rjmp	.-14     	; 0x5134 <PopOutgoingMidiByte+0x116>
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    5142:	83 e0       	ldi	r24, 0x03	; 3
    5144:	0d c0       	rjmp	.+26     	; 0x5160 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    5146:	84 e0       	ldi	r24, 0x04	; 4
    5148:	0b c0       	rjmp	.+22     	; 0x5160 <PopOutgoingMidiByte+0x142>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    514a:	10 92 e1 05 	sts	0x05E1, r1
    514e:	90 e4       	ldi	r25, 0x40	; 64
    5150:	12 c0       	rjmp	.+36     	; 0x5176 <PopOutgoingMidiByte+0x158>
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5152:	10 92 e1 05 	sts	0x05E1, r1
    5156:	0e c0       	rjmp	.+28     	; 0x5174 <PopOutgoingMidiByte+0x156>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    5158:	10 92 e1 05 	sts	0x05E1, r1
    515c:	03 c0       	rjmp	.+6      	; 0x5164 <PopOutgoingMidiByte+0x146>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    515e:	87 e0       	ldi	r24, 0x07	; 7
    5160:	80 93 e1 05 	sts	0x05E1, r24
		return(theMessage.dataByteOne);								// Return the first data byte.
    5164:	90 91 d8 05 	lds	r25, 0x05D8
    5168:	06 c0       	rjmp	.+12     	; 0x5176 <PopOutgoingMidiByte+0x158>
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    516a:	10 92 e1 05 	sts	0x05E1, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    516e:	90 91 d9 05 	lds	r25, 0x05D9
    5172:	01 c0       	rjmp	.+2      	; 0x5176 <PopOutgoingMidiByte+0x158>
    5174:	90 e0       	ldi	r25, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    5176:	89 2f       	mov	r24, r25
    5178:	08 95       	ret

0000517a <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    517a:	8a b1       	in	r24, 0x0a	; 10
    517c:	8f 7c       	andi	r24, 0xCF	; 207
    517e:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    5180:	8b b1       	in	r24, 0x0b	; 11
    5182:	80 63       	ori	r24, 0x30	; 48
    5184:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    5186:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    518a:	e4 e6       	ldi	r30, 0x64	; 100
    518c:	f0 e0       	ldi	r31, 0x00	; 0
    518e:	80 81       	ld	r24, Z
    5190:	80 61       	ori	r24, 0x10	; 16
    5192:	80 83       	st	Z, r24
}
    5194:	08 95       	ret

00005196 <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    5196:	e4 e6       	ldi	r30, 0x64	; 100
    5198:	f0 e0       	ldi	r31, 0x00	; 0
    519a:	80 81       	ld	r24, Z
    519c:	8f 7e       	andi	r24, 0xEF	; 239
    519e:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    51a0:	ec ec       	ldi	r30, 0xCC	; 204
    51a2:	f0 e0       	ldi	r31, 0x00	; 0
    51a4:	11 82       	std	Z+1, r1	; 0x01
    51a6:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    51a8:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    51aa:	80 ec       	ldi	r24, 0xC0	; 192
    51ac:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    51b0:	88 e1       	ldi	r24, 0x18	; 24
    51b2:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    51b6:	81 e0       	ldi	r24, 0x01	; 1
    51b8:	90 e0       	ldi	r25, 0x00	; 0
    51ba:	91 83       	std	Z+1, r25	; 0x01
    51bc:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    51be:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS low.
    51c0:	5d 9a       	sbi	0x0b, 5	; 11
}
    51c2:	08 95       	ret

000051c4 <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    51c4:	5d 9a       	sbi	0x0b, 5	; 11
}
    51c6:	08 95       	ret

000051c8 <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    51c8:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    51ca:	5d 98       	cbi	0x0b, 5	; 11
}
    51cc:	08 95       	ret

000051ce <TransferSdByte>:
// Slow and careful transfers; checks both send and receive buffers and waits until they're ready to move on.
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
    51ce:	98 2f       	mov	r25, r24
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    51d0:	80 91 c8 00 	lds	r24, 0x00C8
    51d4:	85 ff       	sbrs	r24, 5
    51d6:	fc cf       	rjmp	.-8      	; 0x51d0 <TransferSdByte+0x2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    51d8:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    51dc:	80 91 c8 00 	lds	r24, 0x00C8
    51e0:	87 ff       	sbrs	r24, 7
    51e2:	fc cf       	rjmp	.-8      	; 0x51dc <TransferSdByte+0xe>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    51e4:	80 91 ce 00 	lds	r24, 0x00CE
}
    51e8:	08 95       	ret

000051ea <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    51ea:	80 91 c8 00 	lds	r24, 0x00C8
    51ee:	80 64       	ori	r24, 0x40	; 64
    51f0:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    51f4:	80 91 c8 00 	lds	r24, 0x00C8
    51f8:	85 ff       	sbrs	r24, 5
    51fa:	fc cf       	rjmp	.-8      	; 0x51f4 <SendDummyByte+0xa>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    51fc:	8f ef       	ldi	r24, 0xFF	; 255
    51fe:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5202:	80 91 c8 00 	lds	r24, 0x00C8
    5206:	87 ff       	sbrs	r24, 7
    5208:	fc cf       	rjmp	.-8      	; 0x5202 <SendDummyByte+0x18>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    520a:	80 91 ce 00 	lds	r24, 0x00CE
static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
	TransferSdByte(0xFF);	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    520e:	80 91 c8 00 	lds	r24, 0x00C8
    5212:	86 ff       	sbrs	r24, 6
    5214:	fc cf       	rjmp	.-8      	; 0x520e <SendDummyByte+0x24>
		;
}
    5216:	08 95       	ret

00005218 <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    5218:	1f 93       	push	r17
    521a:	28 2f       	mov	r18, r24

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    521c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    521e:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5220:	80 91 c8 00 	lds	r24, 0x00C8
    5224:	85 ff       	sbrs	r24, 5
    5226:	fc cf       	rjmp	.-8      	; 0x5220 <SendSdCommand+0x8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5228:	8f ef       	ldi	r24, 0xFF	; 255
    522a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    522e:	80 91 c8 00 	lds	r24, 0x00C8
    5232:	87 ff       	sbrs	r24, 7
    5234:	fc cf       	rjmp	.-8      	; 0x522e <SendSdCommand+0x16>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5236:	80 91 ce 00 	lds	r24, 0x00CE
		tmpCrc;

	StartSdTransfer();		// Assert CS
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    523a:	27 ff       	sbrs	r18, 7
    523c:	7a c0       	rjmp	.+244    	; 0x5332 <SendSdCommand+0x11a>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    523e:	80 91 c8 00 	lds	r24, 0x00C8
    5242:	85 ff       	sbrs	r24, 5
    5244:	fc cf       	rjmp	.-8      	; 0x523e <SendSdCommand+0x26>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5246:	87 e7       	ldi	r24, 0x77	; 119
    5248:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    524c:	80 91 c8 00 	lds	r24, 0x00C8
    5250:	87 ff       	sbrs	r24, 7
    5252:	fc cf       	rjmp	.-8      	; 0x524c <SendSdCommand+0x34>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5254:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5258:	80 91 c8 00 	lds	r24, 0x00C8
    525c:	85 ff       	sbrs	r24, 5
    525e:	fc cf       	rjmp	.-8      	; 0x5258 <SendSdCommand+0x40>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5260:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5264:	80 91 c8 00 	lds	r24, 0x00C8
    5268:	87 ff       	sbrs	r24, 7
    526a:	fc cf       	rjmp	.-8      	; 0x5264 <SendSdCommand+0x4c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    526c:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5270:	80 91 c8 00 	lds	r24, 0x00C8
    5274:	85 ff       	sbrs	r24, 5
    5276:	fc cf       	rjmp	.-8      	; 0x5270 <SendSdCommand+0x58>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5278:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    527c:	80 91 c8 00 	lds	r24, 0x00C8
    5280:	87 ff       	sbrs	r24, 7
    5282:	fc cf       	rjmp	.-8      	; 0x527c <SendSdCommand+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5284:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5288:	80 91 c8 00 	lds	r24, 0x00C8
    528c:	85 ff       	sbrs	r24, 5
    528e:	fc cf       	rjmp	.-8      	; 0x5288 <SendSdCommand+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5290:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5294:	80 91 c8 00 	lds	r24, 0x00C8
    5298:	87 ff       	sbrs	r24, 7
    529a:	fc cf       	rjmp	.-8      	; 0x5294 <SendSdCommand+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    529c:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    52a0:	80 91 c8 00 	lds	r24, 0x00C8
    52a4:	85 ff       	sbrs	r24, 5
    52a6:	fc cf       	rjmp	.-8      	; 0x52a0 <SendSdCommand+0x88>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    52a8:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    52ac:	80 91 c8 00 	lds	r24, 0x00C8
    52b0:	87 ff       	sbrs	r24, 7
    52b2:	fc cf       	rjmp	.-8      	; 0x52ac <SendSdCommand+0x94>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    52b4:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    52b8:	80 91 c8 00 	lds	r24, 0x00C8
    52bc:	85 ff       	sbrs	r24, 5
    52be:	fc cf       	rjmp	.-8      	; 0x52b8 <SendSdCommand+0xa0>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    52c0:	81 e0       	ldi	r24, 0x01	; 1
    52c2:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    52c6:	80 91 c8 00 	lds	r24, 0x00C8
    52ca:	87 ff       	sbrs	r24, 7
    52cc:	fc cf       	rjmp	.-8      	; 0x52c6 <SendSdCommand+0xae>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    52ce:	80 91 ce 00 	lds	r24, 0x00CE
    52d2:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    52d4:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    52d6:	80 91 c8 00 	lds	r24, 0x00C8
    52da:	85 ff       	sbrs	r24, 5
    52dc:	fc cf       	rjmp	.-8      	; 0x52d6 <SendSdCommand+0xbe>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    52de:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    52e2:	80 91 c8 00 	lds	r24, 0x00C8
    52e6:	87 ff       	sbrs	r24, 7
    52e8:	fc cf       	rjmp	.-8      	; 0x52e2 <SendSdCommand+0xca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    52ea:	10 91 ce 00 	lds	r17, 0x00CE
		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    52ee:	1f 3f       	cpi	r17, 0xFF	; 255
    52f0:	11 f4       	brne	.+4      	; 0x52f6 <SendSdCommand+0xde>
    52f2:	91 50       	subi	r25, 0x01	; 1
    52f4:	81 f7       	brne	.-32     	; 0x52d6 <SendSdCommand+0xbe>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    52f6:	80 91 c8 00 	lds	r24, 0x00C8
    52fa:	80 64       	ori	r24, 0x40	; 64
    52fc:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5300:	80 91 c8 00 	lds	r24, 0x00C8
    5304:	85 ff       	sbrs	r24, 5
    5306:	fc cf       	rjmp	.-8      	; 0x5300 <SendSdCommand+0xe8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5308:	8f ef       	ldi	r24, 0xFF	; 255
    530a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    530e:	80 91 c8 00 	lds	r24, 0x00C8
    5312:	87 ff       	sbrs	r24, 7
    5314:	fc cf       	rjmp	.-8      	; 0x530e <SendSdCommand+0xf6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5316:	80 91 ce 00 	lds	r24, 0x00CE
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    531a:	80 91 c8 00 	lds	r24, 0x00C8
    531e:	86 ff       	sbrs	r24, 6
    5320:	fc cf       	rjmp	.-8      	; 0x531a <SendSdCommand+0x102>
			;

		if(response>1)				// Something wrong?
    5322:	12 30       	cpi	r17, 0x02	; 2
    5324:	10 f0       	brcs	.+4      	; 0x532a <SendSdCommand+0x112>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5326:	5d 9a       	sbi	0x0b, 5	; 11
    5328:	89 c0       	rjmp	.+274    	; 0x543c <SendSdCommand+0x224>
    532a:	5d 9a       	sbi	0x0b, 5	; 11
			EndSdTransfer();	// Bring CS high
			return(response);	// ACMD preambe returned something weird.  Bail.
		}

		EndSdTransfer();	// Bring CS high
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    532c:	2f 77       	andi	r18, 0x7F	; 127

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    532e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    5330:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5332:	80 91 c8 00 	lds	r24, 0x00C8
    5336:	85 ff       	sbrs	r24, 5
    5338:	fc cf       	rjmp	.-8      	; 0x5332 <SendSdCommand+0x11a>
		StartSdTransfer();	// Assert CS
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    533a:	82 2f       	mov	r24, r18
    533c:	80 64       	ori	r24, 0x40	; 64
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    533e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5342:	80 91 c8 00 	lds	r24, 0x00C8
    5346:	87 ff       	sbrs	r24, 7
    5348:	fc cf       	rjmp	.-8      	; 0x5342 <SendSdCommand+0x12a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    534a:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    534e:	80 91 c8 00 	lds	r24, 0x00C8
    5352:	85 ff       	sbrs	r24, 5
    5354:	fc cf       	rjmp	.-8      	; 0x534e <SendSdCommand+0x136>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    5356:	87 2f       	mov	r24, r23
    5358:	99 27       	eor	r25, r25
    535a:	aa 27       	eor	r26, r26
    535c:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    535e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5362:	80 91 c8 00 	lds	r24, 0x00C8
    5366:	87 ff       	sbrs	r24, 7
    5368:	fc cf       	rjmp	.-8      	; 0x5362 <SendSdCommand+0x14a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    536a:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    536e:	80 91 c8 00 	lds	r24, 0x00C8
    5372:	85 ff       	sbrs	r24, 5
    5374:	fc cf       	rjmp	.-8      	; 0x536e <SendSdCommand+0x156>

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    5376:	cb 01       	movw	r24, r22
    5378:	aa 27       	eor	r26, r26
    537a:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    537c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5380:	80 91 c8 00 	lds	r24, 0x00C8
    5384:	87 ff       	sbrs	r24, 7
    5386:	fc cf       	rjmp	.-8      	; 0x5380 <SendSdCommand+0x168>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5388:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    538c:	80 91 c8 00 	lds	r24, 0x00C8
    5390:	85 ff       	sbrs	r24, 5
    5392:	fc cf       	rjmp	.-8      	; 0x538c <SendSdCommand+0x174>
	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    5394:	bb 27       	eor	r27, r27
    5396:	a7 2f       	mov	r26, r23
    5398:	96 2f       	mov	r25, r22
    539a:	85 2f       	mov	r24, r21
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    539c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    53a0:	80 91 c8 00 	lds	r24, 0x00C8
    53a4:	87 ff       	sbrs	r24, 7
    53a6:	fc cf       	rjmp	.-8      	; 0x53a0 <SendSdCommand+0x188>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    53a8:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    53ac:	80 91 c8 00 	lds	r24, 0x00C8
    53b0:	85 ff       	sbrs	r24, 5
    53b2:	fc cf       	rjmp	.-8      	; 0x53ac <SendSdCommand+0x194>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    53b4:	40 93 ce 00 	sts	0x00CE, r20

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    53b8:	80 91 c8 00 	lds	r24, 0x00C8
    53bc:	87 ff       	sbrs	r24, 7
    53be:	fc cf       	rjmp	.-8      	; 0x53b8 <SendSdCommand+0x1a0>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    53c0:	80 91 ce 00 	lds	r24, 0x00CE
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    53c4:	22 23       	and	r18, r18
    53c6:	11 f4       	brne	.+4      	; 0x53cc <SendSdCommand+0x1b4>
    53c8:	95 e9       	ldi	r25, 0x95	; 149
    53ca:	05 c0       	rjmp	.+10     	; 0x53d6 <SendSdCommand+0x1be>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    53cc:	28 30       	cpi	r18, 0x08	; 8
    53ce:	11 f4       	brne	.+4      	; 0x53d4 <SendSdCommand+0x1bc>
    53d0:	97 e8       	ldi	r25, 0x87	; 135
    53d2:	01 c0       	rjmp	.+2      	; 0x53d6 <SendSdCommand+0x1be>
    53d4:	91 e0       	ldi	r25, 0x01	; 1
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    53d6:	80 91 c8 00 	lds	r24, 0x00C8
    53da:	85 ff       	sbrs	r24, 5
    53dc:	fc cf       	rjmp	.-8      	; 0x53d6 <SendSdCommand+0x1be>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    53de:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    53e2:	80 91 c8 00 	lds	r24, 0x00C8
    53e6:	87 ff       	sbrs	r24, 7
    53e8:	fc cf       	rjmp	.-8      	; 0x53e2 <SendSdCommand+0x1ca>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    53ea:	80 91 ce 00 	lds	r24, 0x00CE
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    53ee:	2c 30       	cpi	r18, 0x0C	; 12
    53f0:	69 f4       	brne	.+26     	; 0x540c <SendSdCommand+0x1f4>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    53f2:	80 91 c8 00 	lds	r24, 0x00C8
    53f6:	85 ff       	sbrs	r24, 5
    53f8:	fc cf       	rjmp	.-8      	; 0x53f2 <SendSdCommand+0x1da>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    53fa:	8f ef       	ldi	r24, 0xFF	; 255
    53fc:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5400:	80 91 c8 00 	lds	r24, 0x00C8
    5404:	87 ff       	sbrs	r24, 7
    5406:	fc cf       	rjmp	.-8      	; 0x5400 <SendSdCommand+0x1e8>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5408:	80 91 ce 00 	lds	r24, 0x00CE
    540c:	9a e0       	ldi	r25, 0x0A	; 10
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    540e:	3f ef       	ldi	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5410:	80 91 c8 00 	lds	r24, 0x00C8
    5414:	85 ff       	sbrs	r24, 5
    5416:	fc cf       	rjmp	.-8      	; 0x5410 <SendSdCommand+0x1f8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5418:	30 93 ce 00 	sts	0x00CE, r19

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    541c:	80 91 c8 00 	lds	r24, 0x00C8
    5420:	87 ff       	sbrs	r24, 7
    5422:	fc cf       	rjmp	.-8      	; 0x541c <SendSdCommand+0x204>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5424:	10 91 ce 00 	lds	r17, 0x00CE
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    5428:	1f 3f       	cpi	r17, 0xFF	; 255
    542a:	11 f4       	brne	.+4      	; 0x5430 <SendSdCommand+0x218>
    542c:	91 50       	subi	r25, 0x01	; 1
    542e:	81 f7       	brne	.-32     	; 0x5410 <SendSdCommand+0x1f8>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    5430:	28 30       	cpi	r18, 0x08	; 8
    5432:	21 f0       	breq	.+8      	; 0x543c <SendSdCommand+0x224>
    5434:	2a 33       	cpi	r18, 0x3A	; 58
    5436:	11 f0       	breq	.+4      	; 0x543c <SendSdCommand+0x224>
	{
		SendDummyByte();	
    5438:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    543c:	81 2f       	mov	r24, r17
    543e:	1f 91       	pop	r17
    5440:	08 95       	ret

00005442 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    5442:	ab 01       	movw	r20, r22
    5444:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    5446:	e9 e0       	ldi	r30, 0x09	; 9
    5448:	44 0f       	add	r20, r20
    544a:	55 1f       	adc	r21, r21
    544c:	66 1f       	adc	r22, r22
    544e:	77 1f       	adc	r23, r23
    5450:	ea 95       	dec	r30
    5452:	d1 f7       	brne	.-12     	; 0x5448 <SdBeginSingleBlockRead+0x6>
    5454:	81 e1       	ldi	r24, 0x11	; 17
    5456:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    545a:	90 e0       	ldi	r25, 0x00	; 0
    545c:	88 23       	and	r24, r24
    545e:	09 f4       	brne	.+2      	; 0x5462 <SdBeginSingleBlockRead+0x20>
    5460:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    5462:	89 2f       	mov	r24, r25
    5464:	08 95       	ret

00005466 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    5466:	ab 01       	movw	r20, r22
    5468:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    546a:	f9 e0       	ldi	r31, 0x09	; 9
    546c:	44 0f       	add	r20, r20
    546e:	55 1f       	adc	r21, r21
    5470:	66 1f       	adc	r22, r22
    5472:	77 1f       	adc	r23, r23
    5474:	fa 95       	dec	r31
    5476:	d1 f7       	brne	.-12     	; 0x546c <SdBeginSingleBlockWrite+0x6>
    5478:	88 e1       	ldi	r24, 0x18	; 24
    547a:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    547e:	90 e0       	ldi	r25, 0x00	; 0
    5480:	88 23       	and	r24, r24
    5482:	09 f4       	brne	.+2      	; 0x5486 <SdBeginSingleBlockWrite+0x20>
    5484:	91 e0       	ldi	r25, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    5486:	89 2f       	mov	r24, r25
    5488:	08 95       	ret

0000548a <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    548a:	df 93       	push	r29
    548c:	cf 93       	push	r28
    548e:	00 d0       	rcall	.+0      	; 0x5490 <SdHandshake+0x6>
    5490:	00 d0       	rcall	.+0      	; 0x5492 <SdHandshake+0x8>
    5492:	cd b7       	in	r28, 0x3d	; 61
    5494:	de b7       	in	r29, 0x3e	; 62
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5496:	5d 9a       	sbi	0x0b, 5	; 11
    5498:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    549a:	2f ef       	ldi	r18, 0xFF	; 255
	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    549c:	80 91 c8 00 	lds	r24, 0x00C8
    54a0:	80 64       	ori	r24, 0x40	; 64
    54a2:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54a6:	80 91 c8 00 	lds	r24, 0x00C8
    54aa:	85 ff       	sbrs	r24, 5
    54ac:	fc cf       	rjmp	.-8      	; 0x54a6 <SdHandshake+0x1c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54ae:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54b2:	80 91 c8 00 	lds	r24, 0x00C8
    54b6:	87 ff       	sbrs	r24, 7
    54b8:	fc cf       	rjmp	.-8      	; 0x54b2 <SdHandshake+0x28>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54ba:	80 91 ce 00 	lds	r24, 0x00CE
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    54be:	9f 5f       	subi	r25, 0xFF	; 255
    54c0:	94 31       	cpi	r25, 0x14	; 20
    54c2:	61 f7       	brne	.-40     	; 0x549c <SdHandshake+0x12>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    54c4:	80 91 c8 00 	lds	r24, 0x00C8
    54c8:	86 ff       	sbrs	r24, 6
    54ca:	fc cf       	rjmp	.-8      	; 0x54c4 <SdHandshake+0x3a>

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    54cc:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    54ce:	5d 98       	cbi	0x0b, 5	; 11
    54d0:	20 e0       	ldi	r18, 0x00	; 0
    54d2:	30 e0       	ldi	r19, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54d4:	9f ef       	ldi	r25, 0xFF	; 255
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    54d6:	80 91 c8 00 	lds	r24, 0x00C8
    54da:	80 64       	ori	r24, 0x40	; 64
    54dc:	80 93 c8 00 	sts	0x00C8, r24
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    54e0:	80 91 c8 00 	lds	r24, 0x00C8
    54e4:	85 ff       	sbrs	r24, 5
    54e6:	fc cf       	rjmp	.-8      	; 0x54e0 <SdHandshake+0x56>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    54e8:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    54ec:	80 91 c8 00 	lds	r24, 0x00C8
    54f0:	87 ff       	sbrs	r24, 7
    54f2:	fc cf       	rjmp	.-8      	; 0x54ec <SdHandshake+0x62>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    54f4:	80 91 ce 00 	lds	r24, 0x00CE

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    54f8:	2f 5f       	subi	r18, 0xFF	; 255
    54fa:	3f 4f       	sbci	r19, 0xFF	; 255
    54fc:	82 e0       	ldi	r24, 0x02	; 2
    54fe:	20 30       	cpi	r18, 0x00	; 0
    5500:	38 07       	cpc	r19, r24
    5502:	49 f7       	brne	.-46     	; 0x54d6 <SdHandshake+0x4c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    5504:	80 91 c8 00 	lds	r24, 0x00C8
    5508:	86 ff       	sbrs	r24, 6
    550a:	fc cf       	rjmp	.-8      	; 0x5504 <SdHandshake+0x7a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    550c:	5d 9a       	sbi	0x0b, 5	; 11
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    550e:	80 e0       	ldi	r24, 0x00	; 0
    5510:	40 e0       	ldi	r20, 0x00	; 0
    5512:	50 e0       	ldi	r21, 0x00	; 0
    5514:	60 e0       	ldi	r22, 0x00	; 0
    5516:	70 e0       	ldi	r23, 0x00	; 0
    5518:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    551c:	80 91 c8 00 	lds	r24, 0x00C8
    5520:	86 ff       	sbrs	r24, 6
    5522:	fc cf       	rjmp	.-8      	; 0x551c <SdHandshake+0x92>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5524:	5d 9a       	sbi	0x0b, 5	; 11
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    5526:	80 e0       	ldi	r24, 0x00	; 0
    5528:	40 e0       	ldi	r20, 0x00	; 0
    552a:	50 e0       	ldi	r21, 0x00	; 0
    552c:	60 e0       	ldi	r22, 0x00	; 0
    552e:	70 e0       	ldi	r23, 0x00	; 0
    5530:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    5534:	81 30       	cpi	r24, 0x01	; 1
    5536:	09 f0       	breq	.+2      	; 0x553a <SdHandshake+0xb0>
    5538:	b4 c0       	rjmp	.+360    	; 0x56a2 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    553a:	5d 9a       	sbi	0x0b, 5	; 11
	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    553c:	88 e0       	ldi	r24, 0x08	; 8
    553e:	4a ea       	ldi	r20, 0xAA	; 170
    5540:	51 e0       	ldi	r21, 0x01	; 1
    5542:	60 e0       	ldi	r22, 0x00	; 0
    5544:	70 e0       	ldi	r23, 0x00	; 0
    5546:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    554a:	81 30       	cpi	r24, 0x01	; 1
    554c:	09 f0       	breq	.+2      	; 0x5550 <SdHandshake+0xc6>
    554e:	76 c0       	rjmp	.+236    	; 0x563c <SdHandshake+0x1b2>
    5550:	fe 01       	movw	r30, r28
    5552:	31 96       	adiw	r30, 0x01	; 1
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5554:	9f ef       	ldi	r25, 0xFF	; 255
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    5556:	9e 01       	movw	r18, r28
    5558:	2b 5f       	subi	r18, 0xFB	; 251
    555a:	3f 4f       	sbci	r19, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    555c:	80 91 c8 00 	lds	r24, 0x00C8
    5560:	85 ff       	sbrs	r24, 5
    5562:	fc cf       	rjmp	.-8      	; 0x555c <SdHandshake+0xd2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5564:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5568:	80 91 c8 00 	lds	r24, 0x00C8
    556c:	87 ff       	sbrs	r24, 7
    556e:	fc cf       	rjmp	.-8      	; 0x5568 <SdHandshake+0xde>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5570:	80 91 ce 00 	lds	r24, 0x00CE

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    5574:	81 93       	st	Z+, r24
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    5576:	e2 17       	cp	r30, r18
    5578:	f3 07       	cpc	r31, r19
    557a:	81 f7       	brne	.-32     	; 0x555c <SdHandshake+0xd2>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    557c:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5580:	5d 9a       	sbi	0x0b, 5	; 11
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
			EndSdTransfer();		// Bring CS high

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    5582:	8b 81       	ldd	r24, Y+3	; 0x03
    5584:	81 30       	cpi	r24, 0x01	; 1
    5586:	09 f0       	breq	.+2      	; 0x558a <SdHandshake+0x100>
    5588:	8c c0       	rjmp	.+280    	; 0x56a2 <SdHandshake+0x218>
    558a:	8c 81       	ldd	r24, Y+4	; 0x04
    558c:	8a 3a       	cpi	r24, 0xAA	; 170
    558e:	09 f0       	breq	.+2      	; 0x5592 <SdHandshake+0x108>
    5590:	88 c0       	rjmp	.+272    	; 0x56a2 <SdHandshake+0x218>
			{				
				SetTimer(TIMER_SD,SECOND);
    5592:	83 e0       	ldi	r24, 0x03	; 3
    5594:	64 ec       	ldi	r22, 0xC4	; 196
    5596:	74 e0       	ldi	r23, 0x04	; 4
    5598:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
    559c:	03 c0       	rjmp	.+6      	; 0x55a4 <SdHandshake+0x11a>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    559e:	5d 9a       	sbi	0x0b, 5	; 11
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
    55a0:	0e 94 ca 0c 	call	0x1994	; 0x1994 <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    55a4:	83 e0       	ldi	r24, 0x03	; 3
    55a6:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    55aa:	88 23       	and	r24, r24
    55ac:	49 f4       	brne	.+18     	; 0x55c0 <SdHandshake+0x136>
    55ae:	89 ea       	ldi	r24, 0xA9	; 169
    55b0:	40 e0       	ldi	r20, 0x00	; 0
    55b2:	50 e0       	ldi	r21, 0x00	; 0
    55b4:	60 e0       	ldi	r22, 0x00	; 0
    55b6:	70 e0       	ldi	r23, 0x00	; 0
    55b8:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    55bc:	88 23       	and	r24, r24
    55be:	79 f7       	brne	.-34     	; 0x559e <SdHandshake+0x114>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    55c0:	83 e0       	ldi	r24, 0x03	; 3
    55c2:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    55c6:	88 23       	and	r24, r24
    55c8:	31 f0       	breq	.+12     	; 0x55d6 <SdHandshake+0x14c>
    55ca:	6b c0       	rjmp	.+214    	; 0x56a2 <SdHandshake+0x218>
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    55cc:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    55d0:	0e 94 ca 0c 	call	0x1994	; 0x1994 <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    55d4:	5d 9a       	sbi	0x0b, 5	; 11
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    55d6:	83 e0       	ldi	r24, 0x03	; 3
    55d8:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    55dc:	88 23       	and	r24, r24
    55de:	49 f4       	brne	.+18     	; 0x55f2 <SdHandshake+0x168>
    55e0:	8a e3       	ldi	r24, 0x3A	; 58
    55e2:	40 e0       	ldi	r20, 0x00	; 0
    55e4:	50 e0       	ldi	r21, 0x00	; 0
    55e6:	60 e0       	ldi	r22, 0x00	; 0
    55e8:	70 e0       	ldi	r23, 0x00	; 0
    55ea:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    55ee:	88 23       	and	r24, r24
    55f0:	69 f7       	brne	.-38     	; 0x55cc <SdHandshake+0x142>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    55f2:	83 e0       	ldi	r24, 0x03	; 3
    55f4:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    55f8:	88 23       	and	r24, r24
    55fa:	09 f0       	breq	.+2      	; 0x55fe <SdHandshake+0x174>
    55fc:	52 c0       	rjmp	.+164    	; 0x56a2 <SdHandshake+0x218>
    55fe:	90 e0       	ldi	r25, 0x00	; 0
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5600:	2f ef       	ldi	r18, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5602:	80 91 c8 00 	lds	r24, 0x00C8
    5606:	85 ff       	sbrs	r24, 5
    5608:	fc cf       	rjmp	.-8      	; 0x5602 <SdHandshake+0x178>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    560a:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    560e:	80 91 c8 00 	lds	r24, 0x00C8
    5612:	87 ff       	sbrs	r24, 7
    5614:	fc cf       	rjmp	.-8      	; 0x560e <SdHandshake+0x184>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5616:	80 91 ce 00 	lds	r24, 0x00CE
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
    561a:	9f 5f       	subi	r25, 0xFF	; 255
    561c:	94 30       	cpi	r25, 0x04	; 4
    561e:	89 f7       	brne	.-30     	; 0x5602 <SdHandshake+0x178>
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    5620:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5624:	5d 9a       	sbi	0x0b, 5	; 11
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    5626:	80 e1       	ldi	r24, 0x10	; 16
    5628:	40 e0       	ldi	r20, 0x00	; 0
    562a:	52 e0       	ldi	r21, 0x02	; 2
    562c:	60 e0       	ldi	r22, 0x00	; 0
    562e:	70 e0       	ldi	r23, 0x00	; 0
    5630:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5634:	5d 9a       	sbi	0x0b, 5	; 11
						SendDummyByte();			// Send extra FF after multibyte response. 
						EndSdTransfer();			// Bring CS high.

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
						EndSdTransfer();						// Bring CS high.
						SendDummyByte();						
    5636:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
    563a:	31 c0       	rjmp	.+98     	; 0x569e <SdHandshake+0x214>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    563c:	0e 94 f5 28 	call	0x51ea	; 0x51ea <SendDummyByte>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5640:	5d 9a       	sbi	0x0b, 5	; 11
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    5642:	89 ea       	ldi	r24, 0xA9	; 169
    5644:	40 e0       	ldi	r20, 0x00	; 0
    5646:	50 e0       	ldi	r21, 0x00	; 0
    5648:	60 e0       	ldi	r22, 0x00	; 0
    564a:	70 e0       	ldi	r23, 0x00	; 0
    564c:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    5650:	82 30       	cpi	r24, 0x02	; 2
    5652:	38 f5       	brcc	.+78     	; 0x56a2 <SdHandshake+0x218>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5654:	5d 9a       	sbi	0x0b, 5	; 11
			SendDummyByte();					// Send extra FF after multibyte response. 
			EndSdTransfer();					// Bring CS high
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);
    5656:	83 e0       	ldi	r24, 0x03	; 3
    5658:	64 ec       	ldi	r22, 0xC4	; 196
    565a:	74 e0       	ldi	r23, 0x04	; 4
    565c:	0e 94 71 26 	call	0x4ce2	; 0x4ce2 <SetTimer>
    5660:	03 c0       	rjmp	.+6      	; 0x5668 <SdHandshake+0x1de>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
				{
					HandleSoftclock();	// Keep the timer timing.
    5662:	0e 94 ca 0c 	call	0x1994	; 0x1994 <HandleSoftclock>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    5666:	5d 9a       	sbi	0x0b, 5	; 11
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    5668:	83 e0       	ldi	r24, 0x03	; 3
    566a:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    566e:	88 23       	and	r24, r24
    5670:	49 f4       	brne	.+18     	; 0x5684 <SdHandshake+0x1fa>
    5672:	89 ea       	ldi	r24, 0xA9	; 169
    5674:	40 e0       	ldi	r20, 0x00	; 0
    5676:	50 e0       	ldi	r21, 0x00	; 0
    5678:	60 e0       	ldi	r22, 0x00	; 0
    567a:	70 e0       	ldi	r23, 0x00	; 0
    567c:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
    5680:	88 23       	and	r24, r24
    5682:	79 f7       	brne	.-34     	; 0x5662 <SdHandshake+0x1d8>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    5684:	83 e0       	ldi	r24, 0x03	; 3
    5686:	0e 94 83 26 	call	0x4d06	; 0x4d06 <CheckTimer>
    568a:	88 23       	and	r24, r24
    568c:	51 f4       	brne	.+20     	; 0x56a2 <SdHandshake+0x218>
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    568e:	80 e1       	ldi	r24, 0x10	; 16
    5690:	40 e0       	ldi	r20, 0x00	; 0
    5692:	52 e0       	ldi	r21, 0x02	; 2
    5694:	60 e0       	ldi	r22, 0x00	; 0
    5696:	70 e0       	ldi	r23, 0x00	; 0
    5698:	0e 94 0c 29 	call	0x5218	; 0x5218 <SendSdCommand>
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    569c:	5d 9a       	sbi	0x0b, 5	; 11
    569e:	81 e0       	ldi	r24, 0x01	; 1
    56a0:	01 c0       	rjmp	.+2      	; 0x56a4 <SdHandshake+0x21a>
    56a2:	80 e0       	ldi	r24, 0x00	; 0
    56a4:	5d 9a       	sbi	0x0b, 5	; 11
		}
	}

	EndSdTransfer();	// Bring CS high
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    56a6:	0f 90       	pop	r0
    56a8:	0f 90       	pop	r0
    56aa:	0f 90       	pop	r0
    56ac:	0f 90       	pop	r0
    56ae:	cf 91       	pop	r28
    56b0:	df 91       	pop	r29
    56b2:	08 95       	ret

000056b4 <__mulsi3>:
    56b4:	62 9f       	mul	r22, r18
    56b6:	d0 01       	movw	r26, r0
    56b8:	73 9f       	mul	r23, r19
    56ba:	f0 01       	movw	r30, r0
    56bc:	82 9f       	mul	r24, r18
    56be:	e0 0d       	add	r30, r0
    56c0:	f1 1d       	adc	r31, r1
    56c2:	64 9f       	mul	r22, r20
    56c4:	e0 0d       	add	r30, r0
    56c6:	f1 1d       	adc	r31, r1
    56c8:	92 9f       	mul	r25, r18
    56ca:	f0 0d       	add	r31, r0
    56cc:	83 9f       	mul	r24, r19
    56ce:	f0 0d       	add	r31, r0
    56d0:	74 9f       	mul	r23, r20
    56d2:	f0 0d       	add	r31, r0
    56d4:	65 9f       	mul	r22, r21
    56d6:	f0 0d       	add	r31, r0
    56d8:	99 27       	eor	r25, r25
    56da:	72 9f       	mul	r23, r18
    56dc:	b0 0d       	add	r27, r0
    56de:	e1 1d       	adc	r30, r1
    56e0:	f9 1f       	adc	r31, r25
    56e2:	63 9f       	mul	r22, r19
    56e4:	b0 0d       	add	r27, r0
    56e6:	e1 1d       	adc	r30, r1
    56e8:	f9 1f       	adc	r31, r25
    56ea:	bd 01       	movw	r22, r26
    56ec:	cf 01       	movw	r24, r30
    56ee:	11 24       	eor	r1, r1
    56f0:	08 95       	ret

000056f2 <__udivmodqi4>:
    56f2:	99 1b       	sub	r25, r25
    56f4:	79 e0       	ldi	r23, 0x09	; 9
    56f6:	04 c0       	rjmp	.+8      	; 0x5700 <__udivmodqi4_ep>

000056f8 <__udivmodqi4_loop>:
    56f8:	99 1f       	adc	r25, r25
    56fa:	96 17       	cp	r25, r22
    56fc:	08 f0       	brcs	.+2      	; 0x5700 <__udivmodqi4_ep>
    56fe:	96 1b       	sub	r25, r22

00005700 <__udivmodqi4_ep>:
    5700:	88 1f       	adc	r24, r24
    5702:	7a 95       	dec	r23
    5704:	c9 f7       	brne	.-14     	; 0x56f8 <__udivmodqi4_loop>
    5706:	80 95       	com	r24
    5708:	08 95       	ret

0000570a <__divmodhi4>:
    570a:	97 fb       	bst	r25, 7
    570c:	09 2e       	mov	r0, r25
    570e:	07 26       	eor	r0, r23
    5710:	0a d0       	rcall	.+20     	; 0x5726 <__divmodhi4_neg1>
    5712:	77 fd       	sbrc	r23, 7
    5714:	04 d0       	rcall	.+8      	; 0x571e <__divmodhi4_neg2>
    5716:	2e d0       	rcall	.+92     	; 0x5774 <__udivmodhi4>
    5718:	06 d0       	rcall	.+12     	; 0x5726 <__divmodhi4_neg1>
    571a:	00 20       	and	r0, r0
    571c:	1a f4       	brpl	.+6      	; 0x5724 <__divmodhi4_exit>

0000571e <__divmodhi4_neg2>:
    571e:	70 95       	com	r23
    5720:	61 95       	neg	r22
    5722:	7f 4f       	sbci	r23, 0xFF	; 255

00005724 <__divmodhi4_exit>:
    5724:	08 95       	ret

00005726 <__divmodhi4_neg1>:
    5726:	f6 f7       	brtc	.-4      	; 0x5724 <__divmodhi4_exit>
    5728:	90 95       	com	r25
    572a:	81 95       	neg	r24
    572c:	9f 4f       	sbci	r25, 0xFF	; 255
    572e:	08 95       	ret

00005730 <__udivmodsi4>:
    5730:	a1 e2       	ldi	r26, 0x21	; 33
    5732:	1a 2e       	mov	r1, r26
    5734:	aa 1b       	sub	r26, r26
    5736:	bb 1b       	sub	r27, r27
    5738:	fd 01       	movw	r30, r26
    573a:	0d c0       	rjmp	.+26     	; 0x5756 <__udivmodsi4_ep>

0000573c <__udivmodsi4_loop>:
    573c:	aa 1f       	adc	r26, r26
    573e:	bb 1f       	adc	r27, r27
    5740:	ee 1f       	adc	r30, r30
    5742:	ff 1f       	adc	r31, r31
    5744:	a2 17       	cp	r26, r18
    5746:	b3 07       	cpc	r27, r19
    5748:	e4 07       	cpc	r30, r20
    574a:	f5 07       	cpc	r31, r21
    574c:	20 f0       	brcs	.+8      	; 0x5756 <__udivmodsi4_ep>
    574e:	a2 1b       	sub	r26, r18
    5750:	b3 0b       	sbc	r27, r19
    5752:	e4 0b       	sbc	r30, r20
    5754:	f5 0b       	sbc	r31, r21

00005756 <__udivmodsi4_ep>:
    5756:	66 1f       	adc	r22, r22
    5758:	77 1f       	adc	r23, r23
    575a:	88 1f       	adc	r24, r24
    575c:	99 1f       	adc	r25, r25
    575e:	1a 94       	dec	r1
    5760:	69 f7       	brne	.-38     	; 0x573c <__udivmodsi4_loop>
    5762:	60 95       	com	r22
    5764:	70 95       	com	r23
    5766:	80 95       	com	r24
    5768:	90 95       	com	r25
    576a:	9b 01       	movw	r18, r22
    576c:	ac 01       	movw	r20, r24
    576e:	bd 01       	movw	r22, r26
    5770:	cf 01       	movw	r24, r30
    5772:	08 95       	ret

00005774 <__udivmodhi4>:
    5774:	aa 1b       	sub	r26, r26
    5776:	bb 1b       	sub	r27, r27
    5778:	51 e1       	ldi	r21, 0x11	; 17
    577a:	07 c0       	rjmp	.+14     	; 0x578a <__udivmodhi4_ep>

0000577c <__udivmodhi4_loop>:
    577c:	aa 1f       	adc	r26, r26
    577e:	bb 1f       	adc	r27, r27
    5780:	a6 17       	cp	r26, r22
    5782:	b7 07       	cpc	r27, r23
    5784:	10 f0       	brcs	.+4      	; 0x578a <__udivmodhi4_ep>
    5786:	a6 1b       	sub	r26, r22
    5788:	b7 0b       	sbc	r27, r23

0000578a <__udivmodhi4_ep>:
    578a:	88 1f       	adc	r24, r24
    578c:	99 1f       	adc	r25, r25
    578e:	5a 95       	dec	r21
    5790:	a9 f7       	brne	.-22     	; 0x577c <__udivmodhi4_loop>
    5792:	80 95       	com	r24
    5794:	90 95       	com	r25
    5796:	bc 01       	movw	r22, r24
    5798:	cd 01       	movw	r24, r26
    579a:	08 95       	ret

0000579c <_exit>:
    579c:	f8 94       	cli

0000579e <__stop_program>:
    579e:	ff cf       	rjmp	.-2      	; 0x579e <__stop_program>
