
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00005438  000054cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005438  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000545  0080011e  0080011e  000054ea  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000054ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00005bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00005c4f  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000000e0  00000000  00000000  00005c7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00004438  00000000  00000000  00005d5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000a56  00000000  00000000  0000a196  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001005  00000000  00000000  0000abec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000910  00000000  00000000  0000bbf4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001417  00000000  00000000  0000c504  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002530  00000000  00000000  0000d91b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000001c0  00000000  00000000  0000fe4b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 50 1b 	jmp	0x36a0	; 0x36a0 <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 a3 1e 	jmp	0x3d46	; 0x3d46 <__vector_9>
      28:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <__vector_10>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 09 1b 	jmp	0x3612	; 0x3612 <__vector_12>
      34:	0c 94 98 1b 	jmp	0x3730	; 0x3730 <__vector_13>
      38:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	34 18       	sub	r3, r4
      7e:	2f 1a       	sub	r2, r31
      80:	2f 1a       	sub	r2, r31
      82:	2f 1a       	sub	r2, r31
      84:	2f 1a       	sub	r2, r31
      86:	2f 1a       	sub	r2, r31
      88:	59 18       	sub	r5, r9
      8a:	2f 1a       	sub	r2, r31
      8c:	2f 1a       	sub	r2, r31
      8e:	2f 1a       	sub	r2, r31
      90:	2f 1a       	sub	r2, r31
      92:	9c 18       	sub	r9, r12
      94:	c6 18       	sub	r12, r6
      96:	dd 18       	sub	r13, r13
      98:	f4 18       	sub	r15, r4
      9a:	0d 19       	sub	r16, r13
      9c:	20 19       	sub	r18, r0
      9e:	2f 19       	sub	r18, r15
      a0:	36 19       	sub	r19, r6
      a2:	42 19       	sub	r20, r2
      a4:	5d 19       	sub	r21, r13
      a6:	8d 19       	sub	r24, r13
      a8:	96 19       	sub	r25, r6
      aa:	9f 19       	sub	r25, r15
      ac:	a8 19       	sub	r26, r8
      ae:	ad 19       	sub	r26, r13
      b0:	ba 19       	sub	r27, r10
      b2:	c7 19       	sub	r28, r7

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e8 e3       	ldi	r30, 0x38	; 56
      c8:	f4 e5       	ldi	r31, 0x54	; 84
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <__do_copy_data+0x10>
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <__do_copy_data+0xc>

000000d6 <__do_clear_bss>:
      d6:	26 e0       	ldi	r18, 0x06	; 6
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a3 36       	cpi	r26, 0x63	; 99
      e2:	b2 07       	cpc	r27, r18
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 13 23 	call	0x4626	; 0x4626 <main>
      ea:	0c 94 1a 2a 	jmp	0x5434	; 0x5434 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 be 1e 	jmp	0x3d7c	; 0x3d7c <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 e5 05 	lds	r24, 0x05E5
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c1 f0       	breq	.+48     	; 0x12a <UpdateAudioChannel0+0x38>
      fa:	30 f4       	brcc	.+12     	; 0x108 <UpdateAudioChannel0+0x16>
      fc:	81 30       	cpi	r24, 0x01	; 1
      fe:	59 f0       	breq	.+22     	; 0x116 <UpdateAudioChannel0+0x24>
     100:	82 30       	cpi	r24, 0x02	; 2
     102:	09 f0       	breq	.+2      	; 0x106 <UpdateAudioChannel0+0x14>
     104:	a2 c3       	rjmp	.+1860   	; 0x84a <UpdateAudioChannel0+0x758>
     106:	0e c0       	rjmp	.+28     	; 0x124 <UpdateAudioChannel0+0x32>
     108:	84 30       	cpi	r24, 0x04	; 4
     10a:	09 f4       	brne	.+2      	; 0x10e <UpdateAudioChannel0+0x1c>
     10c:	8e c0       	rjmp	.+284    	; 0x22a <UpdateAudioChannel0+0x138>
     10e:	85 30       	cpi	r24, 0x05	; 5
     110:	09 f0       	breq	.+2      	; 0x114 <UpdateAudioChannel0+0x22>
     112:	9b c3       	rjmp	.+1846   	; 0x84a <UpdateAudioChannel0+0x758>
     114:	07 c2       	rjmp	.+1038   	; 0x524 <UpdateAudioChannel0+0x432>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     116:	80 91 43 04 	lds	r24, 0x0443
     11a:	98 2f       	mov	r25, r24
     11c:	9f 5f       	subi	r25, 0xFF	; 255
     11e:	90 93 43 04 	sts	0x0443, r25
		break;
     122:	08 95       	ret

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     124:	80 91 2c 04 	lds	r24, 0x042C
     128:	eb c1       	rjmp	.+982    	; 0x500 <UpdateAudioChannel0+0x40e>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12a:	8f ef       	ldi	r24, 0xFF	; 255
     12c:	84 b9       	out	0x04, r24	; 4
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     12e:	80 91 05 06 	lds	r24, 0x0605
     132:	90 91 06 06 	lds	r25, 0x0606
     136:	a0 91 07 06 	lds	r26, 0x0607
     13a:	b0 91 08 06 	lds	r27, 0x0608
     13e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     140:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     142:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     144:	80 91 05 06 	lds	r24, 0x0605
     148:	90 91 06 06 	lds	r25, 0x0606
     14c:	a0 91 07 06 	lds	r26, 0x0607
     150:	b0 91 08 06 	lds	r27, 0x0608
     154:	89 2f       	mov	r24, r25
     156:	9a 2f       	mov	r25, r26
     158:	ab 2f       	mov	r26, r27
     15a:	bb 27       	eor	r27, r27
     15c:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     15e:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     160:	14 98       	cbi	0x02, 4	; 2
		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     162:	80 91 05 06 	lds	r24, 0x0605
     166:	90 91 06 06 	lds	r25, 0x0606
     16a:	a0 91 07 06 	lds	r26, 0x0607
     16e:	b0 91 08 06 	lds	r27, 0x0608
     172:	cd 01       	movw	r24, r26
     174:	aa 27       	eor	r26, r26
     176:	bb 27       	eor	r27, r27
     178:	87 70       	andi	r24, 0x07	; 7
     17a:	99 27       	eor	r25, r25
     17c:	aa 27       	eor	r26, r26
     17e:	bb 27       	eor	r27, r27
     180:	88 68       	ori	r24, 0x88	; 136
     182:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     184:	80 91 2c 04 	lds	r24, 0x042C
     188:	85 b9       	out	0x05, r24	; 5
		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     18a:	80 91 05 06 	lds	r24, 0x0605
     18e:	90 91 06 06 	lds	r25, 0x0606
     192:	a0 91 07 06 	lds	r26, 0x0607
     196:	b0 91 08 06 	lds	r27, 0x0608
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	a1 1d       	adc	r26, r1
     19e:	b1 1d       	adc	r27, r1
     1a0:	80 93 05 06 	sts	0x0605, r24
     1a4:	90 93 06 06 	sts	0x0606, r25
     1a8:	a0 93 07 06 	sts	0x0607, r26
     1ac:	b0 93 08 06 	sts	0x0608, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1b0:	80 91 05 06 	lds	r24, 0x0605
     1b4:	90 91 06 06 	lds	r25, 0x0606
     1b8:	a0 91 07 06 	lds	r26, 0x0607
     1bc:	b0 91 08 06 	lds	r27, 0x0608
     1c0:	80 93 f2 05 	sts	0x05F2, r24
     1c4:	90 93 f3 05 	sts	0x05F3, r25
     1c8:	a0 93 f4 05 	sts	0x05F4, r26
     1cc:	b0 93 f5 05 	sts	0x05F5, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1d0:	80 91 05 06 	lds	r24, 0x0605
     1d4:	90 91 06 06 	lds	r25, 0x0606
     1d8:	a0 91 07 06 	lds	r26, 0x0607
     1dc:	b0 91 08 06 	lds	r27, 0x0608
     1e0:	80 93 fa 05 	sts	0x05FA, r24
     1e4:	90 93 fb 05 	sts	0x05FB, r25
     1e8:	a0 93 fc 05 	sts	0x05FC, r26
     1ec:	b0 93 fd 05 	sts	0x05FD, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1f0:	40 91 f2 05 	lds	r20, 0x05F2
     1f4:	50 91 f3 05 	lds	r21, 0x05F3
     1f8:	60 91 f4 05 	lds	r22, 0x05F4
     1fc:	70 91 f5 05 	lds	r23, 0x05F5
     200:	80 91 16 06 	lds	r24, 0x0616
     204:	90 91 17 06 	lds	r25, 0x0617
     208:	a0 91 18 06 	lds	r26, 0x0618
     20c:	b0 91 19 06 	lds	r27, 0x0619
     210:	48 17       	cp	r20, r24
     212:	59 07       	cpc	r21, r25
     214:	6a 07       	cpc	r22, r26
     216:	7b 07       	cpc	r23, r27
     218:	28 f0       	brcs	.+10     	; 0x224 <UpdateAudioChannel0+0x132>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     21a:	10 92 e5 05 	sts	0x05E5, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	80 93 3f 04 	sts	0x043F, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     224:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     226:	11 9a       	sbi	0x02, 1	; 2
     228:	10 c3       	rjmp	.+1568   	; 0x84a <UpdateAudioChannel0+0x758>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     22a:	80 91 05 06 	lds	r24, 0x0605
     22e:	90 91 06 06 	lds	r25, 0x0606
     232:	a0 91 07 06 	lds	r26, 0x0607
     236:	b0 91 08 06 	lds	r27, 0x0608
     23a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     240:	80 91 05 06 	lds	r24, 0x0605
     244:	90 91 06 06 	lds	r25, 0x0606
     248:	a0 91 07 06 	lds	r26, 0x0607
     24c:	b0 91 08 06 	lds	r27, 0x0608
     250:	89 2f       	mov	r24, r25
     252:	9a 2f       	mov	r25, r26
     254:	ab 2f       	mov	r26, r27
     256:	bb 27       	eor	r27, r27
     258:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     25a:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25c:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25e:	80 91 05 06 	lds	r24, 0x0605
     262:	90 91 06 06 	lds	r25, 0x0606
     266:	a0 91 07 06 	lds	r26, 0x0607
     26a:	b0 91 08 06 	lds	r27, 0x0608
     26e:	cd 01       	movw	r24, r26
     270:	aa 27       	eor	r26, r26
     272:	bb 27       	eor	r27, r27
     274:	87 70       	andi	r24, 0x07	; 7
     276:	99 27       	eor	r25, r25
     278:	aa 27       	eor	r26, r26
     27a:	bb 27       	eor	r27, r27
     27c:	88 68       	ori	r24, 0x88	; 136
     27e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     280:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     282:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     284:	80 91 ec 05 	lds	r24, 0x05EC
     288:	88 23       	and	r24, r24
     28a:	09 f4       	brne	.+2      	; 0x28e <UpdateAudioChannel0+0x19c>
     28c:	6a c0       	rjmp	.+212    	; 0x362 <UpdateAudioChannel0+0x270>
		{
			// Slice first, only worry about forward ### @@@

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     28e:	80 91 2d 04 	lds	r24, 0x042D
     292:	90 91 2e 04 	lds	r25, 0x042E
     296:	a0 91 2f 04 	lds	r26, 0x042F
     29a:	b0 91 30 04 	lds	r27, 0x0430
     29e:	89 2b       	or	r24, r25
     2a0:	8a 2b       	or	r24, r26
     2a2:	8b 2b       	or	r24, r27
     2a4:	39 f1       	breq	.+78     	; 0x2f4 <UpdateAudioChannel0+0x202>
			{
				bankStates[BANK_0].currentAddress++;
     2a6:	80 91 05 06 	lds	r24, 0x0605
     2aa:	90 91 06 06 	lds	r25, 0x0606
     2ae:	a0 91 07 06 	lds	r26, 0x0607
     2b2:	b0 91 08 06 	lds	r27, 0x0608
     2b6:	01 96       	adiw	r24, 0x01	; 1
     2b8:	a1 1d       	adc	r26, r1
     2ba:	b1 1d       	adc	r27, r1
     2bc:	80 93 05 06 	sts	0x0605, r24
     2c0:	90 93 06 06 	sts	0x0606, r25
     2c4:	a0 93 07 06 	sts	0x0607, r26
     2c8:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     2cc:	80 91 2d 04 	lds	r24, 0x042D
     2d0:	90 91 2e 04 	lds	r25, 0x042E
     2d4:	a0 91 2f 04 	lds	r26, 0x042F
     2d8:	b0 91 30 04 	lds	r27, 0x0430
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	a1 09       	sbc	r26, r1
     2e0:	b1 09       	sbc	r27, r1
     2e2:	80 93 2d 04 	sts	0x042D, r24
     2e6:	90 93 2e 04 	sts	0x042E, r25
     2ea:	a0 93 2f 04 	sts	0x042F, r26
     2ee:	b0 93 30 04 	sts	0x0430, r27
     2f2:	02 c1       	rjmp	.+516    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2f4:	80 91 35 04 	lds	r24, 0x0435
     2f8:	90 91 36 04 	lds	r25, 0x0436
     2fc:	a0 91 37 04 	lds	r26, 0x0437
     300:	b0 91 38 04 	lds	r27, 0x0438
     304:	80 93 2d 04 	sts	0x042D, r24
     308:	90 93 2e 04 	sts	0x042E, r25
     30c:	a0 93 2f 04 	sts	0x042F, r26
     310:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     314:	80 91 3d 04 	lds	r24, 0x043D
     318:	8f 5f       	subi	r24, 0xFF	; 255
     31a:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     31e:	90 91 3d 04 	lds	r25, 0x043D
     322:	80 91 ec 05 	lds	r24, 0x05EC
     326:	98 13       	cpse	r25, r24
     328:	02 c0       	rjmp	.+4      	; 0x32e <UpdateAudioChannel0+0x23c>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     32a:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     32e:	e0 91 3d 04 	lds	r30, 0x043D
     332:	20 91 35 04 	lds	r18, 0x0435
     336:	30 91 36 04 	lds	r19, 0x0436
     33a:	40 91 37 04 	lds	r20, 0x0437
     33e:	50 91 38 04 	lds	r21, 0x0438
     342:	f0 e0       	ldi	r31, 0x00	; 0
     344:	ec 5b       	subi	r30, 0xBC	; 188
     346:	fb 4f       	sbci	r31, 0xFB	; 251
     348:	a0 81       	ld	r26, Z
     34a:	b0 e0       	ldi	r27, 0x00	; 0
     34c:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
     350:	60 93 05 06 	sts	0x0605, r22
     354:	70 93 06 06 	sts	0x0606, r23
     358:	80 93 07 06 	sts	0x0607, r24
     35c:	90 93 08 06 	sts	0x0608, r25
     360:	cb c0       	rjmp	.+406    	; 0x4f8 <UpdateAudioChannel0+0x406>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     362:	80 91 e9 05 	lds	r24, 0x05E9
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     366:	40 91 05 06 	lds	r20, 0x0605
     36a:	50 91 06 06 	lds	r21, 0x0606
     36e:	60 91 07 06 	lds	r22, 0x0607
     372:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     376:	81 11       	cpse	r24, r1
     378:	5a c0       	rjmp	.+180    	; 0x42e <UpdateAudioChannel0+0x33c>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     37a:	80 91 fe 05 	lds	r24, 0x05FE
     37e:	90 91 ff 05 	lds	r25, 0x05FF
     382:	a0 91 00 06 	lds	r26, 0x0600
     386:	b0 91 01 06 	lds	r27, 0x0601
     38a:	48 17       	cp	r20, r24
     38c:	59 07       	cpc	r21, r25
     38e:	6a 07       	cpc	r22, r26
     390:	7b 07       	cpc	r23, r27
     392:	29 f4       	brne	.+10     	; 0x39e <UpdateAudioChannel0+0x2ac>
     394:	80 91 e6 05 	lds	r24, 0x05E6
     398:	81 30       	cpi	r24, 0x01	; 1
     39a:	09 f4       	brne	.+2      	; 0x39e <UpdateAudioChannel0+0x2ac>
     39c:	59 c0       	rjmp	.+178    	; 0x450 <UpdateAudioChannel0+0x35e>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39e:	40 91 05 06 	lds	r20, 0x0605
     3a2:	50 91 06 06 	lds	r21, 0x0606
     3a6:	60 91 07 06 	lds	r22, 0x0607
     3aa:	70 91 08 06 	lds	r23, 0x0608
     3ae:	80 91 fe 05 	lds	r24, 0x05FE
     3b2:	90 91 ff 05 	lds	r25, 0x05FF
     3b6:	a0 91 00 06 	lds	r26, 0x0600
     3ba:	b0 91 01 06 	lds	r27, 0x0601
     3be:	48 17       	cp	r20, r24
     3c0:	59 07       	cpc	r21, r25
     3c2:	6a 07       	cpc	r22, r26
     3c4:	7b 07       	cpc	r23, r27
     3c6:	49 f4       	brne	.+18     	; 0x3da <UpdateAudioChannel0+0x2e8>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c8:	80 91 fa 05 	lds	r24, 0x05FA
     3cc:	90 91 fb 05 	lds	r25, 0x05FB
     3d0:	a0 91 fc 05 	lds	r26, 0x05FC
     3d4:	b0 91 fd 05 	lds	r27, 0x05FD
     3d8:	87 c0       	rjmp	.+270    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3da:	40 91 05 06 	lds	r20, 0x0605
     3de:	50 91 06 06 	lds	r21, 0x0606
     3e2:	60 91 07 06 	lds	r22, 0x0607
     3e6:	70 91 08 06 	lds	r23, 0x0608
     3ea:	80 91 f6 05 	lds	r24, 0x05F6
     3ee:	90 91 f7 05 	lds	r25, 0x05F7
     3f2:	a0 91 f8 05 	lds	r26, 0x05F8
     3f6:	b0 91 f9 05 	lds	r27, 0x05F9
     3fa:	48 17       	cp	r20, r24
     3fc:	59 07       	cpc	r21, r25
     3fe:	6a 07       	cpc	r22, r26
     400:	7b 07       	cpc	r23, r27
     402:	49 f4       	brne	.+18     	; 0x416 <UpdateAudioChannel0+0x324>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     404:	80 91 f2 05 	lds	r24, 0x05F2
     408:	90 91 f3 05 	lds	r25, 0x05F3
     40c:	a0 91 f4 05 	lds	r26, 0x05F4
     410:	b0 91 f5 05 	lds	r27, 0x05F5
     414:	69 c0       	rjmp	.+210    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     416:	80 91 05 06 	lds	r24, 0x0605
     41a:	90 91 06 06 	lds	r25, 0x0606
     41e:	a0 91 07 06 	lds	r26, 0x0607
     422:	b0 91 08 06 	lds	r27, 0x0608
     426:	01 97       	sbiw	r24, 0x01	; 1
     428:	a1 09       	sbc	r26, r1
     42a:	b1 09       	sbc	r27, r1
     42c:	5d c0       	rjmp	.+186    	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42e:	80 91 fa 05 	lds	r24, 0x05FA
     432:	90 91 fb 05 	lds	r25, 0x05FB
     436:	a0 91 fc 05 	lds	r26, 0x05FC
     43a:	b0 91 fd 05 	lds	r27, 0x05FD
     43e:	48 17       	cp	r20, r24
     440:	59 07       	cpc	r21, r25
     442:	6a 07       	cpc	r22, r26
     444:	7b 07       	cpc	r23, r27
     446:	49 f4       	brne	.+18     	; 0x45a <UpdateAudioChannel0+0x368>
     448:	80 91 e6 05 	lds	r24, 0x05E6
     44c:	81 30       	cpi	r24, 0x01	; 1
     44e:	29 f4       	brne	.+10     	; 0x45a <UpdateAudioChannel0+0x368>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     450:	10 92 e5 05 	sts	0x05E5, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     454:	10 92 ef 05 	sts	0x05EF, r1
     458:	4f c0       	rjmp	.+158    	; 0x4f8 <UpdateAudioChannel0+0x406>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     45a:	40 91 05 06 	lds	r20, 0x0605
     45e:	50 91 06 06 	lds	r21, 0x0606
     462:	60 91 07 06 	lds	r22, 0x0607
     466:	70 91 08 06 	lds	r23, 0x0608
     46a:	80 91 fa 05 	lds	r24, 0x05FA
     46e:	90 91 fb 05 	lds	r25, 0x05FB
     472:	a0 91 fc 05 	lds	r26, 0x05FC
     476:	b0 91 fd 05 	lds	r27, 0x05FD
     47a:	48 17       	cp	r20, r24
     47c:	59 07       	cpc	r21, r25
     47e:	6a 07       	cpc	r22, r26
     480:	7b 07       	cpc	r23, r27
     482:	49 f4       	brne	.+18     	; 0x496 <UpdateAudioChannel0+0x3a4>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     484:	80 91 fe 05 	lds	r24, 0x05FE
     488:	90 91 ff 05 	lds	r25, 0x05FF
     48c:	a0 91 00 06 	lds	r26, 0x0600
     490:	b0 91 01 06 	lds	r27, 0x0601
     494:	29 c0       	rjmp	.+82     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     496:	40 91 05 06 	lds	r20, 0x0605
     49a:	50 91 06 06 	lds	r21, 0x0606
     49e:	60 91 07 06 	lds	r22, 0x0607
     4a2:	70 91 08 06 	lds	r23, 0x0608
     4a6:	80 91 f2 05 	lds	r24, 0x05F2
     4aa:	90 91 f3 05 	lds	r25, 0x05F3
     4ae:	a0 91 f4 05 	lds	r26, 0x05F4
     4b2:	b0 91 f5 05 	lds	r27, 0x05F5
     4b6:	48 17       	cp	r20, r24
     4b8:	59 07       	cpc	r21, r25
     4ba:	6a 07       	cpc	r22, r26
     4bc:	7b 07       	cpc	r23, r27
     4be:	49 f4       	brne	.+18     	; 0x4d2 <UpdateAudioChannel0+0x3e0>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4c0:	80 91 f6 05 	lds	r24, 0x05F6
     4c4:	90 91 f7 05 	lds	r25, 0x05F7
     4c8:	a0 91 f8 05 	lds	r26, 0x05F8
     4cc:	b0 91 f9 05 	lds	r27, 0x05F9
     4d0:	0b c0       	rjmp	.+22     	; 0x4e8 <UpdateAudioChannel0+0x3f6>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4d2:	80 91 05 06 	lds	r24, 0x0605
     4d6:	90 91 06 06 	lds	r25, 0x0606
     4da:	a0 91 07 06 	lds	r26, 0x0607
     4de:	b0 91 08 06 	lds	r27, 0x0608
     4e2:	01 96       	adiw	r24, 0x01	; 1
     4e4:	a1 1d       	adc	r26, r1
     4e6:	b1 1d       	adc	r27, r1
     4e8:	80 93 05 06 	sts	0x0605, r24
     4ec:	90 93 06 06 	sts	0x0606, r25
     4f0:	a0 93 07 06 	sts	0x0607, r26
     4f4:	b0 93 08 06 	sts	0x0608, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     4f8:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     4fa:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     4fc:	9f ef       	ldi	r25, 0xFF	; 255
     4fe:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     500:	90 91 ee 05 	lds	r25, 0x05EE
     504:	99 23       	and	r25, r25
     506:	09 f4       	brne	.+2      	; 0x50a <UpdateAudioChannel0+0x418>
     508:	a1 c1       	rjmp	.+834    	; 0x84c <UpdateAudioChannel0+0x75a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     50a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     50c:	90 91 ee 05 	lds	r25, 0x05EE
     510:	2f ef       	ldi	r18, 0xFF	; 255
     512:	30 e0       	ldi	r19, 0x00	; 0
     514:	09 2e       	mov	r0, r25
     516:	01 c0       	rjmp	.+2      	; 0x51a <UpdateAudioChannel0+0x428>
     518:	22 0f       	add	r18, r18
     51a:	0a 94       	dec	r0
     51c:	ea f7       	brpl	.-6      	; 0x518 <UpdateAudioChannel0+0x426>
     51e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     520:	80 58       	subi	r24, 0x80	; 128
     522:	08 95       	ret
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     524:	80 91 05 06 	lds	r24, 0x0605
     528:	90 91 06 06 	lds	r25, 0x0606
     52c:	a0 91 07 06 	lds	r26, 0x0607
     530:	b0 91 08 06 	lds	r27, 0x0608
     534:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     536:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     538:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     53a:	80 91 05 06 	lds	r24, 0x0605
     53e:	90 91 06 06 	lds	r25, 0x0606
     542:	a0 91 07 06 	lds	r26, 0x0607
     546:	b0 91 08 06 	lds	r27, 0x0608
     54a:	89 2f       	mov	r24, r25
     54c:	9a 2f       	mov	r25, r26
     54e:	ab 2f       	mov	r26, r27
     550:	bb 27       	eor	r27, r27
     552:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     554:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     556:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     558:	80 91 05 06 	lds	r24, 0x0605
     55c:	90 91 06 06 	lds	r25, 0x0606
     560:	a0 91 07 06 	lds	r26, 0x0607
     564:	b0 91 08 06 	lds	r27, 0x0608
     568:	cd 01       	movw	r24, r26
     56a:	aa 27       	eor	r26, r26
     56c:	bb 27       	eor	r27, r27
     56e:	87 70       	andi	r24, 0x07	; 7
     570:	99 27       	eor	r25, r25
     572:	aa 27       	eor	r26, r26
     574:	bb 27       	eor	r27, r27
     576:	88 68       	ori	r24, 0x88	; 136
     578:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     57a:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     57c:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     57e:	80 91 ec 05 	lds	r24, 0x05EC
     582:	88 23       	and	r24, r24
     584:	09 f4       	brne	.+2      	; 0x588 <UpdateAudioChannel0+0x496>
     586:	6a c0       	rjmp	.+212    	; 0x65c <UpdateAudioChannel0+0x56a>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     588:	80 91 2d 04 	lds	r24, 0x042D
     58c:	90 91 2e 04 	lds	r25, 0x042E
     590:	a0 91 2f 04 	lds	r26, 0x042F
     594:	b0 91 30 04 	lds	r27, 0x0430
     598:	89 2b       	or	r24, r25
     59a:	8a 2b       	or	r24, r26
     59c:	8b 2b       	or	r24, r27
     59e:	39 f1       	breq	.+78     	; 0x5ee <UpdateAudioChannel0+0x4fc>
			{
				bankStates[BANK_0].currentAddress++;
     5a0:	80 91 05 06 	lds	r24, 0x0605
     5a4:	90 91 06 06 	lds	r25, 0x0606
     5a8:	a0 91 07 06 	lds	r26, 0x0607
     5ac:	b0 91 08 06 	lds	r27, 0x0608
     5b0:	01 96       	adiw	r24, 0x01	; 1
     5b2:	a1 1d       	adc	r26, r1
     5b4:	b1 1d       	adc	r27, r1
     5b6:	80 93 05 06 	sts	0x0605, r24
     5ba:	90 93 06 06 	sts	0x0606, r25
     5be:	a0 93 07 06 	sts	0x0607, r26
     5c2:	b0 93 08 06 	sts	0x0608, r27
				sliceRemaining[BANK_0]--;
     5c6:	80 91 2d 04 	lds	r24, 0x042D
     5ca:	90 91 2e 04 	lds	r25, 0x042E
     5ce:	a0 91 2f 04 	lds	r26, 0x042F
     5d2:	b0 91 30 04 	lds	r27, 0x0430
     5d6:	01 97       	sbiw	r24, 0x01	; 1
     5d8:	a1 09       	sbc	r26, r1
     5da:	b1 09       	sbc	r27, r1
     5dc:	80 93 2d 04 	sts	0x042D, r24
     5e0:	90 93 2e 04 	sts	0x042E, r25
     5e4:	a0 93 2f 04 	sts	0x042F, r26
     5e8:	b0 93 30 04 	sts	0x0430, r27
     5ec:	02 c1       	rjmp	.+516    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5ee:	80 91 35 04 	lds	r24, 0x0435
     5f2:	90 91 36 04 	lds	r25, 0x0436
     5f6:	a0 91 37 04 	lds	r26, 0x0437
     5fa:	b0 91 38 04 	lds	r27, 0x0438
     5fe:	80 93 2d 04 	sts	0x042D, r24
     602:	90 93 2e 04 	sts	0x042E, r25
     606:	a0 93 2f 04 	sts	0x042F, r26
     60a:	b0 93 30 04 	sts	0x0430, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     60e:	80 91 3d 04 	lds	r24, 0x043D
     612:	8f 5f       	subi	r24, 0xFF	; 255
     614:	80 93 3d 04 	sts	0x043D, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     618:	90 91 3d 04 	lds	r25, 0x043D
     61c:	80 91 ec 05 	lds	r24, 0x05EC
     620:	98 13       	cpse	r25, r24
     622:	02 c0       	rjmp	.+4      	; 0x628 <UpdateAudioChannel0+0x536>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     624:	10 92 3d 04 	sts	0x043D, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
     628:	e0 91 3d 04 	lds	r30, 0x043D
     62c:	20 91 35 04 	lds	r18, 0x0435
     630:	30 91 36 04 	lds	r19, 0x0436
     634:	40 91 37 04 	lds	r20, 0x0437
     638:	50 91 38 04 	lds	r21, 0x0438
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 5b       	subi	r30, 0xBC	; 188
     640:	fb 4f       	sbci	r31, 0xFB	; 251
     642:	a0 81       	ld	r26, Z
     644:	b0 e0       	ldi	r27, 0x00	; 0
     646:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
     64a:	60 93 05 06 	sts	0x0605, r22
     64e:	70 93 06 06 	sts	0x0606, r23
     652:	80 93 07 06 	sts	0x0607, r24
     656:	90 93 08 06 	sts	0x0608, r25
     65a:	cb c0       	rjmp	.+406    	; 0x7f2 <UpdateAudioChannel0+0x700>
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     65c:	80 91 e9 05 	lds	r24, 0x05E9
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     660:	40 91 05 06 	lds	r20, 0x0605
     664:	50 91 06 06 	lds	r21, 0x0606
     668:	60 91 07 06 	lds	r22, 0x0607
     66c:	70 91 08 06 	lds	r23, 0x0608
				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
			}
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     670:	81 11       	cpse	r24, r1
     672:	5a c0       	rjmp	.+180    	; 0x728 <UpdateAudioChannel0+0x636>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     674:	80 91 fe 05 	lds	r24, 0x05FE
     678:	90 91 ff 05 	lds	r25, 0x05FF
     67c:	a0 91 00 06 	lds	r26, 0x0600
     680:	b0 91 01 06 	lds	r27, 0x0601
     684:	48 17       	cp	r20, r24
     686:	59 07       	cpc	r21, r25
     688:	6a 07       	cpc	r22, r26
     68a:	7b 07       	cpc	r23, r27
     68c:	29 f4       	brne	.+10     	; 0x698 <UpdateAudioChannel0+0x5a6>
     68e:	80 91 e6 05 	lds	r24, 0x05E6
     692:	81 30       	cpi	r24, 0x01	; 1
     694:	09 f4       	brne	.+2      	; 0x698 <UpdateAudioChannel0+0x5a6>
     696:	59 c0       	rjmp	.+178    	; 0x74a <UpdateAudioChannel0+0x658>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     698:	40 91 05 06 	lds	r20, 0x0605
     69c:	50 91 06 06 	lds	r21, 0x0606
     6a0:	60 91 07 06 	lds	r22, 0x0607
     6a4:	70 91 08 06 	lds	r23, 0x0608
     6a8:	80 91 fe 05 	lds	r24, 0x05FE
     6ac:	90 91 ff 05 	lds	r25, 0x05FF
     6b0:	a0 91 00 06 	lds	r26, 0x0600
     6b4:	b0 91 01 06 	lds	r27, 0x0601
     6b8:	48 17       	cp	r20, r24
     6ba:	59 07       	cpc	r21, r25
     6bc:	6a 07       	cpc	r22, r26
     6be:	7b 07       	cpc	r23, r27
     6c0:	49 f4       	brne	.+18     	; 0x6d4 <UpdateAudioChannel0+0x5e2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6c2:	80 91 fa 05 	lds	r24, 0x05FA
     6c6:	90 91 fb 05 	lds	r25, 0x05FB
     6ca:	a0 91 fc 05 	lds	r26, 0x05FC
     6ce:	b0 91 fd 05 	lds	r27, 0x05FD
     6d2:	87 c0       	rjmp	.+270    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6d4:	40 91 05 06 	lds	r20, 0x0605
     6d8:	50 91 06 06 	lds	r21, 0x0606
     6dc:	60 91 07 06 	lds	r22, 0x0607
     6e0:	70 91 08 06 	lds	r23, 0x0608
     6e4:	80 91 f6 05 	lds	r24, 0x05F6
     6e8:	90 91 f7 05 	lds	r25, 0x05F7
     6ec:	a0 91 f8 05 	lds	r26, 0x05F8
     6f0:	b0 91 f9 05 	lds	r27, 0x05F9
     6f4:	48 17       	cp	r20, r24
     6f6:	59 07       	cpc	r21, r25
     6f8:	6a 07       	cpc	r22, r26
     6fa:	7b 07       	cpc	r23, r27
     6fc:	49 f4       	brne	.+18     	; 0x710 <UpdateAudioChannel0+0x61e>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     6fe:	80 91 f2 05 	lds	r24, 0x05F2
     702:	90 91 f3 05 	lds	r25, 0x05F3
     706:	a0 91 f4 05 	lds	r26, 0x05F4
     70a:	b0 91 f5 05 	lds	r27, 0x05F5
     70e:	69 c0       	rjmp	.+210    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     710:	80 91 05 06 	lds	r24, 0x0605
     714:	90 91 06 06 	lds	r25, 0x0606
     718:	a0 91 07 06 	lds	r26, 0x0607
     71c:	b0 91 08 06 	lds	r27, 0x0608
     720:	01 97       	sbiw	r24, 0x01	; 1
     722:	a1 09       	sbc	r26, r1
     724:	b1 09       	sbc	r27, r1
     726:	5d c0       	rjmp	.+186    	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     728:	80 91 fa 05 	lds	r24, 0x05FA
     72c:	90 91 fb 05 	lds	r25, 0x05FB
     730:	a0 91 fc 05 	lds	r26, 0x05FC
     734:	b0 91 fd 05 	lds	r27, 0x05FD
     738:	48 17       	cp	r20, r24
     73a:	59 07       	cpc	r21, r25
     73c:	6a 07       	cpc	r22, r26
     73e:	7b 07       	cpc	r23, r27
     740:	49 f4       	brne	.+18     	; 0x754 <UpdateAudioChannel0+0x662>
     742:	80 91 e6 05 	lds	r24, 0x05E6
     746:	81 30       	cpi	r24, 0x01	; 1
     748:	29 f4       	brne	.+10     	; 0x754 <UpdateAudioChannel0+0x662>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     74a:	10 92 e5 05 	sts	0x05E5, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     74e:	10 92 ef 05 	sts	0x05EF, r1
     752:	4f c0       	rjmp	.+158    	; 0x7f2 <UpdateAudioChannel0+0x700>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     754:	40 91 05 06 	lds	r20, 0x0605
     758:	50 91 06 06 	lds	r21, 0x0606
     75c:	60 91 07 06 	lds	r22, 0x0607
     760:	70 91 08 06 	lds	r23, 0x0608
     764:	80 91 fa 05 	lds	r24, 0x05FA
     768:	90 91 fb 05 	lds	r25, 0x05FB
     76c:	a0 91 fc 05 	lds	r26, 0x05FC
     770:	b0 91 fd 05 	lds	r27, 0x05FD
     774:	48 17       	cp	r20, r24
     776:	59 07       	cpc	r21, r25
     778:	6a 07       	cpc	r22, r26
     77a:	7b 07       	cpc	r23, r27
     77c:	49 f4       	brne	.+18     	; 0x790 <UpdateAudioChannel0+0x69e>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     77e:	80 91 fe 05 	lds	r24, 0x05FE
     782:	90 91 ff 05 	lds	r25, 0x05FF
     786:	a0 91 00 06 	lds	r26, 0x0600
     78a:	b0 91 01 06 	lds	r27, 0x0601
     78e:	29 c0       	rjmp	.+82     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     790:	40 91 05 06 	lds	r20, 0x0605
     794:	50 91 06 06 	lds	r21, 0x0606
     798:	60 91 07 06 	lds	r22, 0x0607
     79c:	70 91 08 06 	lds	r23, 0x0608
     7a0:	80 91 f2 05 	lds	r24, 0x05F2
     7a4:	90 91 f3 05 	lds	r25, 0x05F3
     7a8:	a0 91 f4 05 	lds	r26, 0x05F4
     7ac:	b0 91 f5 05 	lds	r27, 0x05F5
     7b0:	48 17       	cp	r20, r24
     7b2:	59 07       	cpc	r21, r25
     7b4:	6a 07       	cpc	r22, r26
     7b6:	7b 07       	cpc	r23, r27
     7b8:	49 f4       	brne	.+18     	; 0x7cc <UpdateAudioChannel0+0x6da>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7ba:	80 91 f6 05 	lds	r24, 0x05F6
     7be:	90 91 f7 05 	lds	r25, 0x05F7
     7c2:	a0 91 f8 05 	lds	r26, 0x05F8
     7c6:	b0 91 f9 05 	lds	r27, 0x05F9
     7ca:	0b c0       	rjmp	.+22     	; 0x7e2 <UpdateAudioChannel0+0x6f0>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7cc:	80 91 05 06 	lds	r24, 0x0605
     7d0:	90 91 06 06 	lds	r25, 0x0606
     7d4:	a0 91 07 06 	lds	r26, 0x0607
     7d8:	b0 91 08 06 	lds	r27, 0x0608
     7dc:	01 96       	adiw	r24, 0x01	; 1
     7de:	a1 1d       	adc	r26, r1
     7e0:	b1 1d       	adc	r27, r1
     7e2:	80 93 05 06 	sts	0x0605, r24
     7e6:	90 93 06 06 	sts	0x0606, r25
     7ea:	a0 93 07 06 	sts	0x0607, r26
     7ee:	b0 93 08 06 	sts	0x0608, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     7f2:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     7f4:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     7f6:	9f ef       	ldi	r25, 0xFF	; 255
     7f8:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     7fa:	90 91 ee 05 	lds	r25, 0x05EE
     7fe:	99 23       	and	r25, r25
     800:	61 f0       	breq	.+24     	; 0x81a <UpdateAudioChannel0+0x728>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     802:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     804:	90 91 ee 05 	lds	r25, 0x05EE
     808:	2f ef       	ldi	r18, 0xFF	; 255
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	09 2e       	mov	r0, r25
     80e:	01 c0       	rjmp	.+2      	; 0x812 <UpdateAudioChannel0+0x720>
     810:	22 0f       	add	r18, r18
     812:	0a 94       	dec	r0
     814:	ea f7       	brpl	.-6      	; 0x810 <UpdateAudioChannel0+0x71e>
     816:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     818:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     81a:	20 91 2c 04 	lds	r18, 0x042C
     81e:	33 27       	eor	r19, r19
     820:	27 fd       	sbrc	r18, 7
     822:	30 95       	com	r19
     824:	28 0f       	add	r18, r24
     826:	31 1d       	adc	r19, r1
     828:	87 fd       	sbrc	r24, 7
     82a:	3a 95       	dec	r19
     82c:	20 38       	cpi	r18, 0x80	; 128
     82e:	9f ef       	ldi	r25, 0xFF	; 255
     830:	39 07       	cpc	r19, r25
     832:	14 f4       	brge	.+4      	; 0x838 <UpdateAudioChannel0+0x746>
     834:	20 e8       	ldi	r18, 0x80	; 128
     836:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     838:	20 38       	cpi	r18, 0x80	; 128
     83a:	31 05       	cpc	r19, r1
     83c:	14 f0       	brlt	.+4      	; 0x842 <UpdateAudioChannel0+0x750>
     83e:	2f e7       	ldi	r18, 0x7F	; 127
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     844:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     846:	11 9a       	sbi	0x02, 1	; 2
		break;
     848:	08 95       	ret
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     84a:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     84c:	08 95       	ret

0000084e <UpdateAudioChannel1>:

static unsigned char UpdateAudioChannel1(void)
// New banked idea of the audio handler -- ONE FOR EACH BANK!
{
     84e:	0f 93       	push	r16
     850:	1f 93       	push	r17
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     852:	80 91 09 06 	lds	r24, 0x0609
     856:	83 30       	cpi	r24, 0x03	; 3
     858:	c1 f0       	breq	.+48     	; 0x88a <UpdateAudioChannel1+0x3c>
     85a:	30 f4       	brcc	.+12     	; 0x868 <UpdateAudioChannel1+0x1a>
     85c:	81 30       	cpi	r24, 0x01	; 1
     85e:	59 f0       	breq	.+22     	; 0x876 <UpdateAudioChannel1+0x28>
     860:	82 30       	cpi	r24, 0x02	; 2
     862:	09 f0       	breq	.+2      	; 0x866 <UpdateAudioChannel1+0x18>
     864:	b2 c3       	rjmp	.+1892   	; 0xfca <UpdateAudioChannel1+0x77c>
     866:	0e c0       	rjmp	.+28     	; 0x884 <UpdateAudioChannel1+0x36>
     868:	84 30       	cpi	r24, 0x04	; 4
     86a:	09 f4       	brne	.+2      	; 0x86e <UpdateAudioChannel1+0x20>
     86c:	8e c0       	rjmp	.+284    	; 0x98a <UpdateAudioChannel1+0x13c>
     86e:	85 30       	cpi	r24, 0x05	; 5
     870:	09 f0       	breq	.+2      	; 0x874 <UpdateAudioChannel1+0x26>
     872:	ab c3       	rjmp	.+1878   	; 0xfca <UpdateAudioChannel1+0x77c>
     874:	0f c2       	rjmp	.+1054   	; 0xc94 <UpdateAudioChannel1+0x446>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     876:	80 91 46 05 	lds	r24, 0x0546
     87a:	98 2f       	mov	r25, r24
     87c:	9f 5f       	subi	r25, 0xFF	; 255
     87e:	90 93 46 05 	sts	0x0546, r25
		break;
     882:	a4 c3       	rjmp	.+1864   	; 0xfcc <UpdateAudioChannel1+0x77e>

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     884:	80 91 2c 04 	lds	r24, 0x042C
     888:	f3 c1       	rjmp	.+998    	; 0xc70 <UpdateAudioChannel1+0x422>
		}
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     88a:	8f ef       	ldi	r24, 0xFF	; 255
     88c:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     88e:	80 91 29 06 	lds	r24, 0x0629
     892:	90 91 2a 06 	lds	r25, 0x062A
     896:	a0 91 2b 06 	lds	r26, 0x062B
     89a:	b0 91 2c 06 	lds	r27, 0x062C
     89e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8a0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8a2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8a4:	80 91 29 06 	lds	r24, 0x0629
     8a8:	90 91 2a 06 	lds	r25, 0x062A
     8ac:	a0 91 2b 06 	lds	r26, 0x062B
     8b0:	b0 91 2c 06 	lds	r27, 0x062C
     8b4:	89 2f       	mov	r24, r25
     8b6:	9a 2f       	mov	r25, r26
     8b8:	ab 2f       	mov	r26, r27
     8ba:	bb 27       	eor	r27, r27
     8bc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8be:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8c0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8c2:	80 91 29 06 	lds	r24, 0x0629
     8c6:	90 91 2a 06 	lds	r25, 0x062A
     8ca:	a0 91 2b 06 	lds	r26, 0x062B
     8ce:	b0 91 2c 06 	lds	r27, 0x062C
     8d2:	cd 01       	movw	r24, r26
     8d4:	aa 27       	eor	r26, r26
     8d6:	bb 27       	eor	r27, r27
     8d8:	87 70       	andi	r24, 0x07	; 7
     8da:	99 27       	eor	r25, r25
     8dc:	aa 27       	eor	r26, r26
     8de:	bb 27       	eor	r27, r27
     8e0:	88 68       	ori	r24, 0x88	; 136
     8e2:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8e4:	80 91 2c 04 	lds	r24, 0x042C
     8e8:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     8ea:	80 91 29 06 	lds	r24, 0x0629
     8ee:	90 91 2a 06 	lds	r25, 0x062A
     8f2:	a0 91 2b 06 	lds	r26, 0x062B
     8f6:	b0 91 2c 06 	lds	r27, 0x062C
     8fa:	01 97       	sbiw	r24, 0x01	; 1
     8fc:	a1 09       	sbc	r26, r1
     8fe:	b1 09       	sbc	r27, r1
     900:	80 93 29 06 	sts	0x0629, r24
     904:	90 93 2a 06 	sts	0x062A, r25
     908:	a0 93 2b 06 	sts	0x062B, r26
     90c:	b0 93 2c 06 	sts	0x062C, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     910:	80 91 29 06 	lds	r24, 0x0629
     914:	90 91 2a 06 	lds	r25, 0x062A
     918:	a0 91 2b 06 	lds	r26, 0x062B
     91c:	b0 91 2c 06 	lds	r27, 0x062C
     920:	80 93 16 06 	sts	0x0616, r24
     924:	90 93 17 06 	sts	0x0617, r25
     928:	a0 93 18 06 	sts	0x0618, r26
     92c:	b0 93 19 06 	sts	0x0619, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     930:	80 91 29 06 	lds	r24, 0x0629
     934:	90 91 2a 06 	lds	r25, 0x062A
     938:	a0 91 2b 06 	lds	r26, 0x062B
     93c:	b0 91 2c 06 	lds	r27, 0x062C
     940:	80 93 1e 06 	sts	0x061E, r24
     944:	90 93 1f 06 	sts	0x061F, r25
     948:	a0 93 20 06 	sts	0x0620, r26
     94c:	b0 93 21 06 	sts	0x0621, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     950:	40 91 f2 05 	lds	r20, 0x05F2
     954:	50 91 f3 05 	lds	r21, 0x05F3
     958:	60 91 f4 05 	lds	r22, 0x05F4
     95c:	70 91 f5 05 	lds	r23, 0x05F5
     960:	80 91 16 06 	lds	r24, 0x0616
     964:	90 91 17 06 	lds	r25, 0x0617
     968:	a0 91 18 06 	lds	r26, 0x0618
     96c:	b0 91 19 06 	lds	r27, 0x0619
     970:	48 17       	cp	r20, r24
     972:	59 07       	cpc	r21, r25
     974:	6a 07       	cpc	r22, r26
     976:	7b 07       	cpc	r23, r27
     978:	28 f0       	brcs	.+10     	; 0x984 <UpdateAudioChannel1+0x136>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     97a:	10 92 09 06 	sts	0x0609, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     97e:	81 e0       	ldi	r24, 0x01	; 1
     980:	80 93 3f 04 	sts	0x043F, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     984:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     986:	11 9a       	sbi	0x02, 1	; 2
     988:	20 c3       	rjmp	.+1600   	; 0xfca <UpdateAudioChannel1+0x77c>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     98a:	80 91 29 06 	lds	r24, 0x0629
     98e:	90 91 2a 06 	lds	r25, 0x062A
     992:	a0 91 2b 06 	lds	r26, 0x062B
     996:	b0 91 2c 06 	lds	r27, 0x062C
     99a:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     99c:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     99e:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9a0:	80 91 29 06 	lds	r24, 0x0629
     9a4:	90 91 2a 06 	lds	r25, 0x062A
     9a8:	a0 91 2b 06 	lds	r26, 0x062B
     9ac:	b0 91 2c 06 	lds	r27, 0x062C
     9b0:	89 2f       	mov	r24, r25
     9b2:	9a 2f       	mov	r25, r26
     9b4:	ab 2f       	mov	r26, r27
     9b6:	bb 27       	eor	r27, r27
     9b8:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9ba:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9bc:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9be:	80 91 29 06 	lds	r24, 0x0629
     9c2:	90 91 2a 06 	lds	r25, 0x062A
     9c6:	a0 91 2b 06 	lds	r26, 0x062B
     9ca:	b0 91 2c 06 	lds	r27, 0x062C
     9ce:	cd 01       	movw	r24, r26
     9d0:	aa 27       	eor	r26, r26
     9d2:	bb 27       	eor	r27, r27
     9d4:	87 70       	andi	r24, 0x07	; 7
     9d6:	99 27       	eor	r25, r25
     9d8:	aa 27       	eor	r26, r26
     9da:	bb 27       	eor	r27, r27
     9dc:	88 68       	ori	r24, 0x88	; 136
     9de:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9e0:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9e2:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9e4:	80 91 10 06 	lds	r24, 0x0610
     9e8:	88 23       	and	r24, r24
     9ea:	09 f4       	brne	.+2      	; 0x9ee <UpdateAudioChannel1+0x1a0>
     9ec:	72 c0       	rjmp	.+228    	; 0xad2 <UpdateAudioChannel1+0x284>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     9ee:	80 91 31 04 	lds	r24, 0x0431
     9f2:	90 91 32 04 	lds	r25, 0x0432
     9f6:	a0 91 33 04 	lds	r26, 0x0433
     9fa:	b0 91 34 04 	lds	r27, 0x0434
     9fe:	89 2b       	or	r24, r25
     a00:	8a 2b       	or	r24, r26
     a02:	8b 2b       	or	r24, r27
     a04:	39 f1       	breq	.+78     	; 0xa54 <UpdateAudioChannel1+0x206>
			{
				bankStates[BANK_1].currentAddress--;
     a06:	80 91 29 06 	lds	r24, 0x0629
     a0a:	90 91 2a 06 	lds	r25, 0x062A
     a0e:	a0 91 2b 06 	lds	r26, 0x062B
     a12:	b0 91 2c 06 	lds	r27, 0x062C
     a16:	01 97       	sbiw	r24, 0x01	; 1
     a18:	a1 09       	sbc	r26, r1
     a1a:	b1 09       	sbc	r27, r1
     a1c:	80 93 29 06 	sts	0x0629, r24
     a20:	90 93 2a 06 	sts	0x062A, r25
     a24:	a0 93 2b 06 	sts	0x062B, r26
     a28:	b0 93 2c 06 	sts	0x062C, r27
				sliceRemaining[BANK_1]--;
     a2c:	80 91 31 04 	lds	r24, 0x0431
     a30:	90 91 32 04 	lds	r25, 0x0432
     a34:	a0 91 33 04 	lds	r26, 0x0433
     a38:	b0 91 34 04 	lds	r27, 0x0434
     a3c:	01 97       	sbiw	r24, 0x01	; 1
     a3e:	a1 09       	sbc	r26, r1
     a40:	b1 09       	sbc	r27, r1
     a42:	80 93 31 04 	sts	0x0431, r24
     a46:	90 93 32 04 	sts	0x0432, r25
     a4a:	a0 93 33 04 	sts	0x0433, r26
     a4e:	b0 93 34 04 	sts	0x0434, r27
     a52:	0a c1       	rjmp	.+532    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a54:	80 91 39 04 	lds	r24, 0x0439
     a58:	90 91 3a 04 	lds	r25, 0x043A
     a5c:	a0 91 3b 04 	lds	r26, 0x043B
     a60:	b0 91 3c 04 	lds	r27, 0x043C
     a64:	80 93 31 04 	sts	0x0431, r24
     a68:	90 93 32 04 	sts	0x0432, r25
     a6c:	a0 93 33 04 	sts	0x0433, r26
     a70:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a74:	80 91 3e 04 	lds	r24, 0x043E
     a78:	8f 5f       	subi	r24, 0xFF	; 255
     a7a:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a7e:	90 91 3e 04 	lds	r25, 0x043E
     a82:	80 91 10 06 	lds	r24, 0x0610
     a86:	98 13       	cpse	r25, r24
     a88:	02 c0       	rjmp	.+4      	; 0xa8e <UpdateAudioChannel1+0x240>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     a8a:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     a8e:	e0 91 3e 04 	lds	r30, 0x043E
     a92:	20 91 39 04 	lds	r18, 0x0439
     a96:	30 91 3a 04 	lds	r19, 0x043A
     a9a:	40 91 3b 04 	lds	r20, 0x043B
     a9e:	50 91 3c 04 	lds	r21, 0x043C
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	ec 53       	subi	r30, 0x3C	; 60
     aa6:	fb 4f       	sbci	r31, 0xFB	; 251
     aa8:	a0 81       	ld	r26, Z
     aaa:	b0 e0       	ldi	r27, 0x00	; 0
     aac:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
     ab0:	0f ef       	ldi	r16, 0xFF	; 255
     ab2:	1f ef       	ldi	r17, 0xFF	; 255
     ab4:	27 e0       	ldi	r18, 0x07	; 7
     ab6:	30 e0       	ldi	r19, 0x00	; 0
     ab8:	06 1b       	sub	r16, r22
     aba:	17 0b       	sbc	r17, r23
     abc:	28 0b       	sbc	r18, r24
     abe:	39 0b       	sbc	r19, r25
     ac0:	00 93 29 06 	sts	0x0629, r16
     ac4:	10 93 2a 06 	sts	0x062A, r17
     ac8:	20 93 2b 06 	sts	0x062B, r18
     acc:	30 93 2c 06 	sts	0x062C, r19
     ad0:	cb c0       	rjmp	.+406    	; 0xc68 <UpdateAudioChannel1+0x41a>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ad2:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     ad6:	40 91 29 06 	lds	r20, 0x0629
     ada:	50 91 2a 06 	lds	r21, 0x062A
     ade:	60 91 2b 06 	lds	r22, 0x062B
     ae2:	70 91 2c 06 	lds	r23, 0x062C
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ae6:	81 11       	cpse	r24, r1
     ae8:	5a c0       	rjmp	.+180    	; 0xb9e <UpdateAudioChannel1+0x350>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     aea:	80 91 22 06 	lds	r24, 0x0622
     aee:	90 91 23 06 	lds	r25, 0x0623
     af2:	a0 91 24 06 	lds	r26, 0x0624
     af6:	b0 91 25 06 	lds	r27, 0x0625
     afa:	48 17       	cp	r20, r24
     afc:	59 07       	cpc	r21, r25
     afe:	6a 07       	cpc	r22, r26
     b00:	7b 07       	cpc	r23, r27
     b02:	29 f4       	brne	.+10     	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b04:	80 91 0a 06 	lds	r24, 0x060A
     b08:	81 30       	cpi	r24, 0x01	; 1
     b0a:	09 f4       	brne	.+2      	; 0xb0e <UpdateAudioChannel1+0x2c0>
     b0c:	59 c0       	rjmp	.+178    	; 0xbc0 <UpdateAudioChannel1+0x372>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b0e:	40 91 29 06 	lds	r20, 0x0629
     b12:	50 91 2a 06 	lds	r21, 0x062A
     b16:	60 91 2b 06 	lds	r22, 0x062B
     b1a:	70 91 2c 06 	lds	r23, 0x062C
     b1e:	80 91 22 06 	lds	r24, 0x0622
     b22:	90 91 23 06 	lds	r25, 0x0623
     b26:	a0 91 24 06 	lds	r26, 0x0624
     b2a:	b0 91 25 06 	lds	r27, 0x0625
     b2e:	48 17       	cp	r20, r24
     b30:	59 07       	cpc	r21, r25
     b32:	6a 07       	cpc	r22, r26
     b34:	7b 07       	cpc	r23, r27
     b36:	49 f4       	brne	.+18     	; 0xb4a <UpdateAudioChannel1+0x2fc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b38:	80 91 1e 06 	lds	r24, 0x061E
     b3c:	90 91 1f 06 	lds	r25, 0x061F
     b40:	a0 91 20 06 	lds	r26, 0x0620
     b44:	b0 91 21 06 	lds	r27, 0x0621
     b48:	87 c0       	rjmp	.+270    	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b4a:	40 91 29 06 	lds	r20, 0x0629
     b4e:	50 91 2a 06 	lds	r21, 0x062A
     b52:	60 91 2b 06 	lds	r22, 0x062B
     b56:	70 91 2c 06 	lds	r23, 0x062C
     b5a:	80 91 1a 06 	lds	r24, 0x061A
     b5e:	90 91 1b 06 	lds	r25, 0x061B
     b62:	a0 91 1c 06 	lds	r26, 0x061C
     b66:	b0 91 1d 06 	lds	r27, 0x061D
     b6a:	48 17       	cp	r20, r24
     b6c:	59 07       	cpc	r21, r25
     b6e:	6a 07       	cpc	r22, r26
     b70:	7b 07       	cpc	r23, r27
     b72:	49 f4       	brne	.+18     	; 0xb86 <UpdateAudioChannel1+0x338>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b74:	80 91 16 06 	lds	r24, 0x0616
     b78:	90 91 17 06 	lds	r25, 0x0617
     b7c:	a0 91 18 06 	lds	r26, 0x0618
     b80:	b0 91 19 06 	lds	r27, 0x0619
     b84:	69 c0       	rjmp	.+210    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     b86:	80 91 29 06 	lds	r24, 0x0629
     b8a:	90 91 2a 06 	lds	r25, 0x062A
     b8e:	a0 91 2b 06 	lds	r26, 0x062B
     b92:	b0 91 2c 06 	lds	r27, 0x062C
     b96:	01 96       	adiw	r24, 0x01	; 1
     b98:	a1 1d       	adc	r26, r1
     b9a:	b1 1d       	adc	r27, r1
     b9c:	5d c0       	rjmp	.+186    	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     b9e:	80 91 1e 06 	lds	r24, 0x061E
     ba2:	90 91 1f 06 	lds	r25, 0x061F
     ba6:	a0 91 20 06 	lds	r26, 0x0620
     baa:	b0 91 21 06 	lds	r27, 0x0621
     bae:	48 17       	cp	r20, r24
     bb0:	59 07       	cpc	r21, r25
     bb2:	6a 07       	cpc	r22, r26
     bb4:	7b 07       	cpc	r23, r27
     bb6:	49 f4       	brne	.+18     	; 0xbca <UpdateAudioChannel1+0x37c>
     bb8:	80 91 0a 06 	lds	r24, 0x060A
     bbc:	81 30       	cpi	r24, 0x01	; 1
     bbe:	29 f4       	brne	.+10     	; 0xbca <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bc0:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bc4:	10 92 13 06 	sts	0x0613, r1
     bc8:	4f c0       	rjmp	.+158    	; 0xc68 <UpdateAudioChannel1+0x41a>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bca:	40 91 29 06 	lds	r20, 0x0629
     bce:	50 91 2a 06 	lds	r21, 0x062A
     bd2:	60 91 2b 06 	lds	r22, 0x062B
     bd6:	70 91 2c 06 	lds	r23, 0x062C
     bda:	80 91 1e 06 	lds	r24, 0x061E
     bde:	90 91 1f 06 	lds	r25, 0x061F
     be2:	a0 91 20 06 	lds	r26, 0x0620
     be6:	b0 91 21 06 	lds	r27, 0x0621
     bea:	48 17       	cp	r20, r24
     bec:	59 07       	cpc	r21, r25
     bee:	6a 07       	cpc	r22, r26
     bf0:	7b 07       	cpc	r23, r27
     bf2:	49 f4       	brne	.+18     	; 0xc06 <UpdateAudioChannel1+0x3b8>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     bf4:	80 91 22 06 	lds	r24, 0x0622
     bf8:	90 91 23 06 	lds	r25, 0x0623
     bfc:	a0 91 24 06 	lds	r26, 0x0624
     c00:	b0 91 25 06 	lds	r27, 0x0625
     c04:	29 c0       	rjmp	.+82     	; 0xc58 <UpdateAudioChannel1+0x40a>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c06:	40 91 29 06 	lds	r20, 0x0629
     c0a:	50 91 2a 06 	lds	r21, 0x062A
     c0e:	60 91 2b 06 	lds	r22, 0x062B
     c12:	70 91 2c 06 	lds	r23, 0x062C
     c16:	80 91 16 06 	lds	r24, 0x0616
     c1a:	90 91 17 06 	lds	r25, 0x0617
     c1e:	a0 91 18 06 	lds	r26, 0x0618
     c22:	b0 91 19 06 	lds	r27, 0x0619
     c26:	48 17       	cp	r20, r24
     c28:	59 07       	cpc	r21, r25
     c2a:	6a 07       	cpc	r22, r26
     c2c:	7b 07       	cpc	r23, r27
     c2e:	49 f4       	brne	.+18     	; 0xc42 <UpdateAudioChannel1+0x3f4>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c30:	80 91 1a 06 	lds	r24, 0x061A
     c34:	90 91 1b 06 	lds	r25, 0x061B
     c38:	a0 91 1c 06 	lds	r26, 0x061C
     c3c:	b0 91 1d 06 	lds	r27, 0x061D
     c40:	0b c0       	rjmp	.+22     	; 0xc58 <UpdateAudioChannel1+0x40a>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c42:	80 91 29 06 	lds	r24, 0x0629
     c46:	90 91 2a 06 	lds	r25, 0x062A
     c4a:	a0 91 2b 06 	lds	r26, 0x062B
     c4e:	b0 91 2c 06 	lds	r27, 0x062C
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	a1 09       	sbc	r26, r1
     c56:	b1 09       	sbc	r27, r1
     c58:	80 93 29 06 	sts	0x0629, r24
     c5c:	90 93 2a 06 	sts	0x062A, r25
     c60:	a0 93 2b 06 	sts	0x062B, r26
     c64:	b0 93 2c 06 	sts	0x062C, r27
			}
		}

		// Done with addy, read RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c68:	83 b1       	in	r24, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c6a:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c6c:	9f ef       	ldi	r25, 0xFF	; 255
     c6e:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c70:	90 91 12 06 	lds	r25, 0x0612
     c74:	99 23       	and	r25, r25
     c76:	09 f4       	brne	.+2      	; 0xc7a <UpdateAudioChannel1+0x42c>
     c78:	a9 c1       	rjmp	.+850    	; 0xfcc <UpdateAudioChannel1+0x77e>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     c7a:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     c7c:	90 91 12 06 	lds	r25, 0x0612
     c80:	2f ef       	ldi	r18, 0xFF	; 255
     c82:	30 e0       	ldi	r19, 0x00	; 0
     c84:	09 2e       	mov	r0, r25
     c86:	01 c0       	rjmp	.+2      	; 0xc8a <UpdateAudioChannel1+0x43c>
     c88:	22 0f       	add	r18, r18
     c8a:	0a 94       	dec	r0
     c8c:	ea f7       	brpl	.-6      	; 0xc88 <UpdateAudioChannel1+0x43a>
     c8e:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     c90:	80 58       	subi	r24, 0x80	; 128
     c92:	9c c1       	rjmp	.+824    	; 0xfcc <UpdateAudioChannel1+0x77e>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     c94:	80 91 29 06 	lds	r24, 0x0629
     c98:	90 91 2a 06 	lds	r25, 0x062A
     c9c:	a0 91 2b 06 	lds	r26, 0x062B
     ca0:	b0 91 2c 06 	lds	r27, 0x062C
     ca4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     ca6:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     ca8:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     caa:	80 91 29 06 	lds	r24, 0x0629
     cae:	90 91 2a 06 	lds	r25, 0x062A
     cb2:	a0 91 2b 06 	lds	r26, 0x062B
     cb6:	b0 91 2c 06 	lds	r27, 0x062C
     cba:	89 2f       	mov	r24, r25
     cbc:	9a 2f       	mov	r25, r26
     cbe:	ab 2f       	mov	r26, r27
     cc0:	bb 27       	eor	r27, r27
     cc2:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cc4:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cc6:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cc8:	80 91 29 06 	lds	r24, 0x0629
     ccc:	90 91 2a 06 	lds	r25, 0x062A
     cd0:	a0 91 2b 06 	lds	r26, 0x062B
     cd4:	b0 91 2c 06 	lds	r27, 0x062C
     cd8:	cd 01       	movw	r24, r26
     cda:	aa 27       	eor	r26, r26
     cdc:	bb 27       	eor	r27, r27
     cde:	87 70       	andi	r24, 0x07	; 7
     ce0:	99 27       	eor	r25, r25
     ce2:	aa 27       	eor	r26, r26
     ce4:	bb 27       	eor	r27, r27
     ce6:	88 68       	ori	r24, 0x88	; 136
     ce8:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     cea:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     cec:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     cee:	80 91 10 06 	lds	r24, 0x0610
     cf2:	88 23       	and	r24, r24
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <UpdateAudioChannel1+0x4aa>
     cf6:	72 c0       	rjmp	.+228    	; 0xddc <UpdateAudioChannel1+0x58e>
		{
			// Slice first, only worry about forward ###

			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     cf8:	80 91 31 04 	lds	r24, 0x0431
     cfc:	90 91 32 04 	lds	r25, 0x0432
     d00:	a0 91 33 04 	lds	r26, 0x0433
     d04:	b0 91 34 04 	lds	r27, 0x0434
     d08:	89 2b       	or	r24, r25
     d0a:	8a 2b       	or	r24, r26
     d0c:	8b 2b       	or	r24, r27
     d0e:	39 f1       	breq	.+78     	; 0xd5e <UpdateAudioChannel1+0x510>
			{
				bankStates[BANK_1].currentAddress--;
     d10:	80 91 29 06 	lds	r24, 0x0629
     d14:	90 91 2a 06 	lds	r25, 0x062A
     d18:	a0 91 2b 06 	lds	r26, 0x062B
     d1c:	b0 91 2c 06 	lds	r27, 0x062C
     d20:	01 97       	sbiw	r24, 0x01	; 1
     d22:	a1 09       	sbc	r26, r1
     d24:	b1 09       	sbc	r27, r1
     d26:	80 93 29 06 	sts	0x0629, r24
     d2a:	90 93 2a 06 	sts	0x062A, r25
     d2e:	a0 93 2b 06 	sts	0x062B, r26
     d32:	b0 93 2c 06 	sts	0x062C, r27
				sliceRemaining[BANK_1]--;
     d36:	80 91 31 04 	lds	r24, 0x0431
     d3a:	90 91 32 04 	lds	r25, 0x0432
     d3e:	a0 91 33 04 	lds	r26, 0x0433
     d42:	b0 91 34 04 	lds	r27, 0x0434
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 31 04 	sts	0x0431, r24
     d50:	90 93 32 04 	sts	0x0432, r25
     d54:	a0 93 33 04 	sts	0x0433, r26
     d58:	b0 93 34 04 	sts	0x0434, r27
     d5c:	0a c1       	rjmp	.+532    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d5e:	80 91 39 04 	lds	r24, 0x0439
     d62:	90 91 3a 04 	lds	r25, 0x043A
     d66:	a0 91 3b 04 	lds	r26, 0x043B
     d6a:	b0 91 3c 04 	lds	r27, 0x043C
     d6e:	80 93 31 04 	sts	0x0431, r24
     d72:	90 93 32 04 	sts	0x0432, r25
     d76:	a0 93 33 04 	sts	0x0433, r26
     d7a:	b0 93 34 04 	sts	0x0434, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     d7e:	80 91 3e 04 	lds	r24, 0x043E
     d82:	8f 5f       	subi	r24, 0xFF	; 255
     d84:	80 93 3e 04 	sts	0x043E, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     d88:	90 91 3e 04 	lds	r25, 0x043E
     d8c:	80 91 10 06 	lds	r24, 0x0610
     d90:	98 13       	cpse	r25, r24
     d92:	02 c0       	rjmp	.+4      	; 0xd98 <UpdateAudioChannel1+0x54a>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     d94:	10 92 3e 04 	sts	0x043E, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
     d98:	e0 91 3e 04 	lds	r30, 0x043E
     d9c:	20 91 39 04 	lds	r18, 0x0439
     da0:	30 91 3a 04 	lds	r19, 0x043A
     da4:	40 91 3b 04 	lds	r20, 0x043B
     da8:	50 91 3c 04 	lds	r21, 0x043C
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	ec 53       	subi	r30, 0x3C	; 60
     db0:	fb 4f       	sbci	r31, 0xFB	; 251
     db2:	a0 81       	ld	r26, Z
     db4:	b0 e0       	ldi	r27, 0x00	; 0
     db6:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
     dba:	0f ef       	ldi	r16, 0xFF	; 255
     dbc:	1f ef       	ldi	r17, 0xFF	; 255
     dbe:	27 e0       	ldi	r18, 0x07	; 7
     dc0:	30 e0       	ldi	r19, 0x00	; 0
     dc2:	06 1b       	sub	r16, r22
     dc4:	17 0b       	sbc	r17, r23
     dc6:	28 0b       	sbc	r18, r24
     dc8:	39 0b       	sbc	r19, r25
     dca:	00 93 29 06 	sts	0x0629, r16
     dce:	10 93 2a 06 	sts	0x062A, r17
     dd2:	20 93 2b 06 	sts	0x062B, r18
     dd6:	30 93 2c 06 	sts	0x062C, r19
     dda:	cb c0       	rjmp	.+406    	; 0xf72 <UpdateAudioChannel1+0x724>
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     ddc:	80 91 0d 06 	lds	r24, 0x060D
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     de0:	40 91 29 06 	lds	r20, 0x0629
     de4:	50 91 2a 06 	lds	r21, 0x062A
     de8:	60 91 2b 06 	lds	r22, 0x062B
     dec:	70 91 2c 06 	lds	r23, 0x062C
				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));
			}
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     df0:	81 11       	cpse	r24, r1
     df2:	5a c0       	rjmp	.+180    	; 0xea8 <UpdateAudioChannel1+0x65a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     df4:	80 91 22 06 	lds	r24, 0x0622
     df8:	90 91 23 06 	lds	r25, 0x0623
     dfc:	a0 91 24 06 	lds	r26, 0x0624
     e00:	b0 91 25 06 	lds	r27, 0x0625
     e04:	48 17       	cp	r20, r24
     e06:	59 07       	cpc	r21, r25
     e08:	6a 07       	cpc	r22, r26
     e0a:	7b 07       	cpc	r23, r27
     e0c:	29 f4       	brne	.+10     	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e0e:	80 91 0a 06 	lds	r24, 0x060A
     e12:	81 30       	cpi	r24, 0x01	; 1
     e14:	09 f4       	brne	.+2      	; 0xe18 <UpdateAudioChannel1+0x5ca>
     e16:	59 c0       	rjmp	.+178    	; 0xeca <UpdateAudioChannel1+0x67c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e18:	40 91 29 06 	lds	r20, 0x0629
     e1c:	50 91 2a 06 	lds	r21, 0x062A
     e20:	60 91 2b 06 	lds	r22, 0x062B
     e24:	70 91 2c 06 	lds	r23, 0x062C
     e28:	80 91 22 06 	lds	r24, 0x0622
     e2c:	90 91 23 06 	lds	r25, 0x0623
     e30:	a0 91 24 06 	lds	r26, 0x0624
     e34:	b0 91 25 06 	lds	r27, 0x0625
     e38:	48 17       	cp	r20, r24
     e3a:	59 07       	cpc	r21, r25
     e3c:	6a 07       	cpc	r22, r26
     e3e:	7b 07       	cpc	r23, r27
     e40:	49 f4       	brne	.+18     	; 0xe54 <UpdateAudioChannel1+0x606>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e42:	80 91 1e 06 	lds	r24, 0x061E
     e46:	90 91 1f 06 	lds	r25, 0x061F
     e4a:	a0 91 20 06 	lds	r26, 0x0620
     e4e:	b0 91 21 06 	lds	r27, 0x0621
     e52:	87 c0       	rjmp	.+270    	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e54:	40 91 29 06 	lds	r20, 0x0629
     e58:	50 91 2a 06 	lds	r21, 0x062A
     e5c:	60 91 2b 06 	lds	r22, 0x062B
     e60:	70 91 2c 06 	lds	r23, 0x062C
     e64:	80 91 1a 06 	lds	r24, 0x061A
     e68:	90 91 1b 06 	lds	r25, 0x061B
     e6c:	a0 91 1c 06 	lds	r26, 0x061C
     e70:	b0 91 1d 06 	lds	r27, 0x061D
     e74:	48 17       	cp	r20, r24
     e76:	59 07       	cpc	r21, r25
     e78:	6a 07       	cpc	r22, r26
     e7a:	7b 07       	cpc	r23, r27
     e7c:	49 f4       	brne	.+18     	; 0xe90 <UpdateAudioChannel1+0x642>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     e7e:	80 91 16 06 	lds	r24, 0x0616
     e82:	90 91 17 06 	lds	r25, 0x0617
     e86:	a0 91 18 06 	lds	r26, 0x0618
     e8a:	b0 91 19 06 	lds	r27, 0x0619
     e8e:	69 c0       	rjmp	.+210    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     e90:	80 91 29 06 	lds	r24, 0x0629
     e94:	90 91 2a 06 	lds	r25, 0x062A
     e98:	a0 91 2b 06 	lds	r26, 0x062B
     e9c:	b0 91 2c 06 	lds	r27, 0x062C
     ea0:	01 96       	adiw	r24, 0x01	; 1
     ea2:	a1 1d       	adc	r26, r1
     ea4:	b1 1d       	adc	r27, r1
     ea6:	5d c0       	rjmp	.+186    	; 0xf62 <UpdateAudioChannel1+0x714>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ea8:	80 91 1e 06 	lds	r24, 0x061E
     eac:	90 91 1f 06 	lds	r25, 0x061F
     eb0:	a0 91 20 06 	lds	r26, 0x0620
     eb4:	b0 91 21 06 	lds	r27, 0x0621
     eb8:	48 17       	cp	r20, r24
     eba:	59 07       	cpc	r21, r25
     ebc:	6a 07       	cpc	r22, r26
     ebe:	7b 07       	cpc	r23, r27
     ec0:	49 f4       	brne	.+18     	; 0xed4 <UpdateAudioChannel1+0x686>
     ec2:	80 91 0a 06 	lds	r24, 0x060A
     ec6:	81 30       	cpi	r24, 0x01	; 1
     ec8:	29 f4       	brne	.+10     	; 0xed4 <UpdateAudioChannel1+0x686>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     eca:	10 92 09 06 	sts	0x0609, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     ece:	10 92 13 06 	sts	0x0613, r1
     ed2:	4f c0       	rjmp	.+158    	; 0xf72 <UpdateAudioChannel1+0x724>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     ed4:	40 91 29 06 	lds	r20, 0x0629
     ed8:	50 91 2a 06 	lds	r21, 0x062A
     edc:	60 91 2b 06 	lds	r22, 0x062B
     ee0:	70 91 2c 06 	lds	r23, 0x062C
     ee4:	80 91 1e 06 	lds	r24, 0x061E
     ee8:	90 91 1f 06 	lds	r25, 0x061F
     eec:	a0 91 20 06 	lds	r26, 0x0620
     ef0:	b0 91 21 06 	lds	r27, 0x0621
     ef4:	48 17       	cp	r20, r24
     ef6:	59 07       	cpc	r21, r25
     ef8:	6a 07       	cpc	r22, r26
     efa:	7b 07       	cpc	r23, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     efe:	80 91 22 06 	lds	r24, 0x0622
     f02:	90 91 23 06 	lds	r25, 0x0623
     f06:	a0 91 24 06 	lds	r26, 0x0624
     f0a:	b0 91 25 06 	lds	r27, 0x0625
     f0e:	29 c0       	rjmp	.+82     	; 0xf62 <UpdateAudioChannel1+0x714>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f10:	40 91 29 06 	lds	r20, 0x0629
     f14:	50 91 2a 06 	lds	r21, 0x062A
     f18:	60 91 2b 06 	lds	r22, 0x062B
     f1c:	70 91 2c 06 	lds	r23, 0x062C
     f20:	80 91 16 06 	lds	r24, 0x0616
     f24:	90 91 17 06 	lds	r25, 0x0617
     f28:	a0 91 18 06 	lds	r26, 0x0618
     f2c:	b0 91 19 06 	lds	r27, 0x0619
     f30:	48 17       	cp	r20, r24
     f32:	59 07       	cpc	r21, r25
     f34:	6a 07       	cpc	r22, r26
     f36:	7b 07       	cpc	r23, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f3a:	80 91 1a 06 	lds	r24, 0x061A
     f3e:	90 91 1b 06 	lds	r25, 0x061B
     f42:	a0 91 1c 06 	lds	r26, 0x061C
     f46:	b0 91 1d 06 	lds	r27, 0x061D
     f4a:	0b c0       	rjmp	.+22     	; 0xf62 <UpdateAudioChannel1+0x714>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f4c:	80 91 29 06 	lds	r24, 0x0629
     f50:	90 91 2a 06 	lds	r25, 0x062A
     f54:	a0 91 2b 06 	lds	r26, 0x062B
     f58:	b0 91 2c 06 	lds	r27, 0x062C
     f5c:	01 97       	sbiw	r24, 0x01	; 1
     f5e:	a1 09       	sbc	r26, r1
     f60:	b1 09       	sbc	r27, r1
     f62:	80 93 29 06 	sts	0x0629, r24
     f66:	90 93 2a 06 	sts	0x062A, r25
     f6a:	a0 93 2b 06 	sts	0x062B, r26
     f6e:	b0 93 2c 06 	sts	0x062C, r27
			}
		}

		// Finished with addy stuff, now finish data transfer

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     f72:	83 b1       	in	r24, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     f74:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     f76:	9f ef       	ldi	r25, 0xFF	; 255
     f78:	94 b9       	out	0x04, r25	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     f7a:	90 91 12 06 	lds	r25, 0x0612
     f7e:	99 23       	and	r25, r25
     f80:	61 f0       	breq	.+24     	; 0xf9a <UpdateAudioChannel1+0x74c>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.
     f82:	80 58       	subi	r24, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     f84:	90 91 12 06 	lds	r25, 0x0612
     f88:	2f ef       	ldi	r18, 0xFF	; 255
     f8a:	30 e0       	ldi	r19, 0x00	; 0
     f8c:	09 2e       	mov	r0, r25
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <UpdateAudioChannel1+0x744>
     f90:	22 0f       	add	r18, r18
     f92:	0a 94       	dec	r0
     f94:	ea f7       	brpl	.-6      	; 0xf90 <UpdateAudioChannel1+0x742>
     f96:	82 23       	and	r24, r18
			outputByte^=0x80;											// Bring it back to signed.
     f98:	80 58       	subi	r24, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     f9a:	20 91 2c 04 	lds	r18, 0x042C
     f9e:	33 27       	eor	r19, r19
     fa0:	27 fd       	sbrc	r18, 7
     fa2:	30 95       	com	r19
     fa4:	28 0f       	add	r18, r24
     fa6:	31 1d       	adc	r19, r1
     fa8:	87 fd       	sbrc	r24, 7
     faa:	3a 95       	dec	r19
     fac:	20 38       	cpi	r18, 0x80	; 128
     fae:	9f ef       	ldi	r25, 0xFF	; 255
     fb0:	39 07       	cpc	r19, r25
     fb2:	14 f4       	brge	.+4      	; 0xfb8 <UpdateAudioChannel1+0x76a>
     fb4:	20 e8       	ldi	r18, 0x80	; 128
     fb6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     fb8:	20 38       	cpi	r18, 0x80	; 128
     fba:	31 05       	cpc	r19, r1
     fbc:	14 f0       	brlt	.+4      	; 0xfc2 <UpdateAudioChannel1+0x774>
     fbe:	2f e7       	ldi	r18, 0x7F	; 127
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	25 b9       	out	0x05, r18	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     fc4:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     fc6:	11 9a       	sbi	0x02, 1	; 2
		break;
     fc8:	01 c0       	rjmp	.+2      	; 0xfcc <UpdateAudioChannel1+0x77e>
	signed char
		outputByte;		// What will we pass out at the end?
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.
     fca:	80 e0       	ldi	r24, 0x00	; 0
		PORTA|=(Om_RAM_WE);			// Disbale writes.
		break;
	}

	return(outputByte);
}
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	08 95       	ret

00000fd2 <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
     fd2:	80 91 42 04 	lds	r24, 0x0442
     fd6:	20 91 48 05 	lds	r18, 0x0548
     fda:	33 27       	eor	r19, r19
     fdc:	27 fd       	sbrc	r18, 7
     fde:	30 95       	com	r19
     fe0:	28 0f       	add	r18, r24
     fe2:	31 1d       	adc	r19, r1
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	3a 95       	dec	r19
     fe8:	20 38       	cpi	r18, 0x80	; 128
     fea:	4f ef       	ldi	r20, 0xFF	; 255
     fec:	34 07       	cpc	r19, r20
     fee:	14 f4       	brge	.+4      	; 0xff4 <OutputMultiplyBanks+0x22>
     ff0:	20 e8       	ldi	r18, 0x80	; 128
     ff2:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
     ff4:	40 91 45 05 	lds	r20, 0x0545
     ff8:	80 91 4c 05 	lds	r24, 0x054C
     ffc:	99 27       	eor	r25, r25
     ffe:	87 fd       	sbrc	r24, 7
    1000:	90 95       	com	r25
    1002:	84 0f       	add	r24, r20
    1004:	91 1d       	adc	r25, r1
    1006:	47 fd       	sbrc	r20, 7
    1008:	9a 95       	dec	r25
    100a:	81 38       	cpi	r24, 0x81	; 129
    100c:	4f ef       	ldi	r20, 0xFF	; 255
    100e:	94 07       	cpc	r25, r20
    1010:	14 f4       	brge	.+4      	; 0x1016 <OutputMultiplyBanks+0x44>
    1012:	81 e8       	ldi	r24, 0x81	; 129
    1014:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    1016:	20 38       	cpi	r18, 0x80	; 128
    1018:	31 05       	cpc	r19, r1
    101a:	14 f0       	brlt	.+4      	; 0x1020 <OutputMultiplyBanks+0x4e>
    101c:	2f e7       	ldi	r18, 0x7F	; 127
    101e:	30 e0       	ldi	r19, 0x00	; 0
    1020:	80 38       	cpi	r24, 0x80	; 128
    1022:	91 05       	cpc	r25, r1
    1024:	14 f0       	brlt	.+4      	; 0x102a <OutputMultiplyBanks+0x58>
    1026:	8f e7       	ldi	r24, 0x7F	; 127
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	28 9f       	mul	r18, r24
    102c:	a0 01       	movw	r20, r0
    102e:	29 9f       	mul	r18, r25
    1030:	50 0d       	add	r21, r0
    1032:	38 9f       	mul	r19, r24
    1034:	50 0d       	add	r21, r0
    1036:	11 24       	eor	r1, r1
    1038:	57 ff       	sbrs	r21, 7
    103a:	02 c0       	rjmp	.+4      	; 0x1040 <OutputMultiplyBanks+0x6e>
    103c:	41 5c       	subi	r20, 0xC1	; 193
    103e:	5f 4f       	sbci	r21, 0xFF	; 255
    1040:	ca 01       	movw	r24, r20
    1042:	46 e0       	ldi	r20, 0x06	; 6
    1044:	95 95       	asr	r25
    1046:	87 95       	ror	r24
    1048:	4a 95       	dec	r20
    104a:	e1 f7       	brne	.-8      	; 0x1044 <OutputMultiplyBanks+0x72>

//@@@  NOTE -- as is, the result in sum0 may overflow a signed char -- when cast back below, the results may be hosed.
//@@@  NOTE -- you are multiplying signed numbers.  This is in the asm instruction set, but divide is not.  We could cast back to unsigned then shift (otherwise a shift will not work).

	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    104c:	80 58       	subi	r24, 0x80	; 128
    104e:	90 95       	com	r25
    1050:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1052:	30 91 69 05 	lds	r19, 0x0569
    1056:	83 17       	cp	r24, r19
    1058:	29 f0       	breq	.+10     	; 0x1064 <OutputMultiplyBanks+0x92>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    105a:	9f ef       	ldi	r25, 0xFF	; 255
    105c:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    105e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1060:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1062:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1064:	20 93 69 05 	sts	0x0569, r18
    1068:	08 95       	ret

0000106a <OutputAddBanks>:

	unsigned char
		output;			// What to put on the DAC

//	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);						// Sum everything that might be involved in our output waveform:
	sum0=extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1+sdStreamOutput;		// Sum everything that might be involved in our output waveform:
    106a:	20 91 42 04 	lds	r18, 0x0442
    106e:	80 91 45 05 	lds	r24, 0x0545
    1072:	99 27       	eor	r25, r25
    1074:	87 fd       	sbrc	r24, 7
    1076:	90 95       	com	r25
    1078:	82 0f       	add	r24, r18
    107a:	91 1d       	adc	r25, r1
    107c:	27 fd       	sbrc	r18, 7
    107e:	9a 95       	dec	r25
    1080:	20 91 48 05 	lds	r18, 0x0548
    1084:	82 0f       	add	r24, r18
    1086:	91 1d       	adc	r25, r1
    1088:	27 fd       	sbrc	r18, 7
    108a:	9a 95       	dec	r25
    108c:	20 91 4c 05 	lds	r18, 0x054C
    1090:	82 0f       	add	r24, r18
    1092:	91 1d       	adc	r25, r1
    1094:	27 fd       	sbrc	r18, 7
    1096:	9a 95       	dec	r25
    1098:	20 91 55 05 	lds	r18, 0x0555
    109c:	82 0f       	add	r24, r18
    109e:	91 1d       	adc	r25, r1
    10a0:	27 fd       	sbrc	r18, 7
    10a2:	9a 95       	dec	r25
    10a4:	80 38       	cpi	r24, 0x80	; 128
    10a6:	2f ef       	ldi	r18, 0xFF	; 255
    10a8:	92 07       	cpc	r25, r18
    10aa:	14 f4       	brge	.+4      	; 0x10b0 <OutputAddBanks+0x46>
    10ac:	80 e8       	ldi	r24, 0x80	; 128
    10ae:	9f ef       	ldi	r25, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10b0:	80 38       	cpi	r24, 0x80	; 128
    10b2:	91 05       	cpc	r25, r1
    10b4:	14 f0       	brlt	.+4      	; 0x10ba <OutputAddBanks+0x50>
    10b6:	8f e7       	ldi	r24, 0x7F	; 127
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	80 58       	subi	r24, 0x80	; 128
    10bc:	28 2f       	mov	r18, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    10be:	30 91 69 05 	lds	r19, 0x0569
    10c2:	83 17       	cp	r24, r19
    10c4:	29 f0       	breq	.+10     	; 0x10d0 <OutputAddBanks+0x66>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    10c6:	9f ef       	ldi	r25, 0xFF	; 255
    10c8:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    10ca:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    10cc:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    10ce:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    10d0:	20 93 69 05 	sts	0x0569, r18
    10d4:	08 95       	ret

000010d6 <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    10d6:	20 91 42 04 	lds	r18, 0x0442
    10da:	80 91 48 05 	lds	r24, 0x0548
    10de:	99 27       	eor	r25, r25
    10e0:	87 fd       	sbrc	r24, 7
    10e2:	90 95       	com	r25
    10e4:	82 0f       	add	r24, r18
    10e6:	91 1d       	adc	r25, r1
    10e8:	27 fd       	sbrc	r18, 7
    10ea:	9a 95       	dec	r25
    10ec:	80 38       	cpi	r24, 0x80	; 128
    10ee:	2f ef       	ldi	r18, 0xFF	; 255
    10f0:	92 07       	cpc	r25, r18
    10f2:	14 f4       	brge	.+4      	; 0x10f8 <OutputXorBanks+0x22>
    10f4:	80 e8       	ldi	r24, 0x80	; 128
    10f6:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    10f8:	40 91 45 05 	lds	r20, 0x0545
    10fc:	20 91 4c 05 	lds	r18, 0x054C
    1100:	33 27       	eor	r19, r19
    1102:	27 fd       	sbrc	r18, 7
    1104:	30 95       	com	r19
    1106:	24 0f       	add	r18, r20
    1108:	31 1d       	adc	r19, r1
    110a:	47 fd       	sbrc	r20, 7
    110c:	3a 95       	dec	r19
    110e:	20 38       	cpi	r18, 0x80	; 128
    1110:	4f ef       	ldi	r20, 0xFF	; 255
    1112:	34 07       	cpc	r19, r20
    1114:	14 f4       	brge	.+4      	; 0x111a <__stack+0x1b>
    1116:	20 e8       	ldi	r18, 0x80	; 128
    1118:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.
    111a:	20 38       	cpi	r18, 0x80	; 128
    111c:	31 05       	cpc	r19, r1
    111e:	14 f0       	brlt	.+4      	; 0x1124 <__stack+0x25>
    1120:	2f e7       	ldi	r18, 0x7F	; 127
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	20 58       	subi	r18, 0x80	; 128
    1126:	30 95       	com	r19
    1128:	80 38       	cpi	r24, 0x80	; 128
    112a:	91 05       	cpc	r25, r1
    112c:	14 f0       	brlt	.+4      	; 0x1132 <__stack+0x33>
    112e:	8f e7       	ldi	r24, 0x7F	; 127
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	80 58       	subi	r24, 0x80	; 128
    1134:	90 95       	com	r25
    1136:	82 27       	eor	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1138:	90 91 69 05 	lds	r25, 0x0569
    113c:	89 17       	cp	r24, r25
    113e:	29 f0       	breq	.+10     	; 0x114a <__stack+0x4b>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1140:	9f ef       	ldi	r25, 0xFF	; 255
    1142:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1144:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1146:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1148:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    114a:	80 93 69 05 	sts	0x0569, r24
    114e:	08 95       	ret

00001150 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC

	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1150:	20 91 42 04 	lds	r18, 0x0442
    1154:	80 91 48 05 	lds	r24, 0x0548
    1158:	99 27       	eor	r25, r25
    115a:	87 fd       	sbrc	r24, 7
    115c:	90 95       	com	r25
    115e:	82 0f       	add	r24, r18
    1160:	91 1d       	adc	r25, r1
    1162:	27 fd       	sbrc	r18, 7
    1164:	9a 95       	dec	r25
    1166:	80 38       	cpi	r24, 0x80	; 128
    1168:	2f ef       	ldi	r18, 0xFF	; 255
    116a:	92 07       	cpc	r25, r18
    116c:	14 f4       	brge	.+4      	; 0x1172 <OutputAndBanks+0x22>
    116e:	80 e8       	ldi	r24, 0x80	; 128
    1170:	9f ef       	ldi	r25, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1172:	40 91 45 05 	lds	r20, 0x0545
    1176:	20 91 4c 05 	lds	r18, 0x054C
    117a:	33 27       	eor	r19, r19
    117c:	27 fd       	sbrc	r18, 7
    117e:	30 95       	com	r19
    1180:	24 0f       	add	r18, r20
    1182:	31 1d       	adc	r19, r1
    1184:	47 fd       	sbrc	r20, 7
    1186:	3a 95       	dec	r19
    1188:	20 38       	cpi	r18, 0x80	; 128
    118a:	4f ef       	ldi	r20, 0xFF	; 255
    118c:	34 07       	cpc	r19, r20
    118e:	14 f4       	brge	.+4      	; 0x1194 <OutputAndBanks+0x44>
    1190:	20 e8       	ldi	r18, 0x80	; 128
    1192:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.
    1194:	20 38       	cpi	r18, 0x80	; 128
    1196:	31 05       	cpc	r19, r1
    1198:	14 f0       	brlt	.+4      	; 0x119e <OutputAndBanks+0x4e>
    119a:	2f e7       	ldi	r18, 0x7F	; 127
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	20 58       	subi	r18, 0x80	; 128
    11a0:	30 95       	com	r19
    11a2:	80 38       	cpi	r24, 0x80	; 128
    11a4:	91 05       	cpc	r25, r1
    11a6:	14 f0       	brlt	.+4      	; 0x11ac <OutputAndBanks+0x5c>
    11a8:	8f e7       	ldi	r24, 0x7F	; 127
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	80 58       	subi	r24, 0x80	; 128
    11ae:	90 95       	com	r25
    11b0:	82 23       	and	r24, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11b2:	90 91 69 05 	lds	r25, 0x0569
    11b6:	89 17       	cp	r24, r25
    11b8:	29 f0       	breq	.+10     	; 0x11c4 <OutputAndBanks+0x74>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    11ba:	9f ef       	ldi	r25, 0xFF	; 255
    11bc:	94 b9       	out	0x04, r25	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    11be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    11c0:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    11c2:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    11c4:	80 93 69 05 	sts	0x0569, r24
    11c8:	08 95       	ret

000011ca <WriteLedLatch>:
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    11ca:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    11cc:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    11ce:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	84 b9       	out	0x04, r24	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    11d4:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    11d6:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    11d8:	9f bf       	out	0x3f, r25	; 63
    11da:	08 95       	ret

000011dc <CheckSdSlotFull>:
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    11dc:	fc 01       	movw	r30, r24
    11de:	53 e0       	ldi	r21, 0x03	; 3
    11e0:	f6 95       	lsr	r31
    11e2:	e7 95       	ror	r30
    11e4:	5a 95       	dec	r21
    11e6:	e1 f7       	brne	.-8      	; 0x11e0 <CheckSdSlotFull+0x4>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    11e8:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    11ea:	e2 59       	subi	r30, 0x92	; 146
    11ec:	fa 4f       	sbci	r31, 0xFA	; 250
    11ee:	20 81       	ld	r18, Z
    11f0:	30 e0       	ldi	r19, 0x00	; 0
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    11f2:	87 70       	andi	r24, 0x07	; 7
    11f4:	99 27       	eor	r25, r25

	if(sampleToc[theByte]&(1<<theBit))	// Bit is set?
    11f6:	02 c0       	rjmp	.+4      	; 0x11fc <CheckSdSlotFull+0x20>
    11f8:	35 95       	asr	r19
    11fa:	27 95       	ror	r18
    11fc:	8a 95       	dec	r24
    11fe:	e2 f7       	brpl	.-8      	; 0x11f8 <CheckSdSlotFull+0x1c>
	}
	else
	{
		return(false);
	}
}
    1200:	82 2f       	mov	r24, r18
    1202:	81 70       	andi	r24, 0x01	; 1
    1204:	08 95       	ret

00001206 <SdIsrStartStreamingAudio>:
// Tell it to take the bytes in the SD buffer and put them into SRAM.
{
	unsigned char
		sreg;

	sreg=SREG;
    1206:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Pause ISRs
    1208:	f8 94       	cli

	sdIsrState=SD_ISR_STREAMING_PLAYBACK;		// Take bytes from the SD buffer as they come in and spit them out the DAC
    120a:	83 e0       	ldi	r24, 0x03	; 3
    120c:	80 93 4f 05 	sts	0x054F, r24

	TCNT2=0;			// Init counter reg
    1210:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis -- close to 22050)
    1214:	81 e7       	ldi	r24, 0x71	; 113
    1216:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    121a:	8f ef       	ldi	r24, 0xFF	; 255
    121c:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    121e:	e0 e7       	ldi	r30, 0x70	; 112
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	80 81       	ld	r24, Z
    1224:	84 60       	ori	r24, 0x04	; 4
    1226:	80 83       	st	Z, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    1228:	82 e0       	ldi	r24, 0x02	; 2
    122a:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    122e:	9f bf       	out	0x3f, r25	; 63
    1230:	08 95       	ret

00001232 <GetRandomLongInt>:
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1232:	40 91 00 01 	lds	r20, 0x0100
    1236:	50 91 01 01 	lds	r21, 0x0101
    123a:	60 91 02 01 	lds	r22, 0x0102
    123e:	70 91 03 01 	lds	r23, 0x0103
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1242:	db 01       	movw	r26, r22
    1244:	ca 01       	movw	r24, r20
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	aa 1f       	adc	r26, r26
    124c:	bb 1f       	adc	r27, r27
    124e:	76 ff       	sbrs	r23, 6
    1250:	08 c0       	rjmp	.+16     	; 0x1262 <GetRandomLongInt+0x30>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1252:	25 eb       	ldi	r18, 0xB5	; 181
    1254:	82 27       	eor	r24, r18
    1256:	25 e9       	ldi	r18, 0x95	; 149
    1258:	92 27       	eor	r25, r18
    125a:	2a ea       	ldi	r18, 0xAA	; 170
    125c:	a2 27       	eor	r26, r18
    125e:	20 e2       	ldi	r18, 0x20	; 32
    1260:	b2 27       	eor	r27, r18
    1262:	80 93 00 01 	sts	0x0100, r24
    1266:	90 93 01 01 	sts	0x0101, r25
    126a:	a0 93 02 01 	sts	0x0102, r26
    126e:	b0 93 03 01 	sts	0x0103, r27
	}
	return(random31);
    1272:	60 91 00 01 	lds	r22, 0x0100
    1276:	70 91 01 01 	lds	r23, 0x0101
}
    127a:	80 91 02 01 	lds	r24, 0x0102
    127e:	90 91 03 01 	lds	r25, 0x0103
    1282:	08 95       	ret

00001284 <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM.
{
    1284:	2f 92       	push	r2
    1286:	3f 92       	push	r3
    1288:	4f 92       	push	r4
    128a:	5f 92       	push	r5
    128c:	6f 92       	push	r6
    128e:	7f 92       	push	r7
    1290:	8f 92       	push	r8
    1292:	9f 92       	push	r9
    1294:	af 92       	push	r10
    1296:	bf 92       	push	r11
    1298:	cf 92       	push	r12
    129a:	df 92       	push	r13
    129c:	ef 92       	push	r14
    129e:	ff 92       	push	r15
    12a0:	0f 93       	push	r16
    12a2:	1f 93       	push	r17
    12a4:	cf 93       	push	r28
    12a6:	df 93       	push	r29
    12a8:	38 2e       	mov	r3, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    12aa:	62 30       	cpi	r22, 0x02	; 2
    12ac:	08 f4       	brcc	.+2      	; 0x12b0 <MakeNewGranularArray+0x2c>
    12ae:	cd c0       	rjmp	.+410    	; 0x144a <MakeNewGranularArray+0x1c6>
	{
		sreg=SREG;
    12b0:	9f b6       	in	r9, 0x3f	; 63
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    12b2:	f8 94       	cli
    12b4:	86 2e       	mov	r8, r22
    12b6:	80 e8       	ldi	r24, 0x80	; 128
    12b8:	86 17       	cp	r24, r22
    12ba:	10 f4       	brcc	.+4      	; 0x12c0 <MakeNewGranularArray+0x3c>
    12bc:	00 e8       	ldi	r16, 0x80	; 128
    12be:	80 2e       	mov	r8, r16
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12c0:	c3 2d       	mov	r28, r3
    12c2:	d0 e0       	ldi	r29, 0x00	; 0
    12c4:	9e 01       	movw	r18, r28
    12c6:	36 95       	lsr	r19
    12c8:	32 2f       	mov	r19, r18
    12ca:	22 27       	eor	r18, r18
    12cc:	37 95       	ror	r19
    12ce:	27 95       	ror	r18
    12d0:	2c 5b       	subi	r18, 0xBC	; 188
    12d2:	3b 4f       	sbci	r19, 0xFB	; 251
    12d4:	80 e0       	ldi	r24, 0x00	; 0
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	f9 01       	movw	r30, r18
    12da:	e8 0f       	add	r30, r24
    12dc:	f9 1f       	adc	r31, r25
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    12de:	80 83       	st	Z, r24
    12e0:	01 96       	adiw	r24, 0x01	; 1
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    12e2:	88 15       	cp	r24, r8
    12e4:	c8 f3       	brcs	.-14     	; 0x12d8 <MakeNewGranularArray+0x54>
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    12e6:	6e 01       	movw	r12, r28
    12e8:	d6 94       	lsr	r13
    12ea:	dc 2c       	mov	r13, r12
    12ec:	cc 24       	eor	r12, r12
    12ee:	d7 94       	ror	r13
    12f0:	c7 94       	ror	r12
    12f2:	b4 e4       	ldi	r27, 0x44	; 68
    12f4:	ab 2e       	mov	r10, r27
    12f6:	b4 e0       	ldi	r27, 0x04	; 4
    12f8:	bb 2e       	mov	r11, r27
    12fa:	ac 0c       	add	r10, r12
    12fc:	bd 1c       	adc	r11, r13
    12fe:	00 e0       	ldi	r16, 0x00	; 0
    1300:	10 e0       	ldi	r17, 0x00	; 0
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1302:	48 2c       	mov	r4, r8
    1304:	51 2c       	mov	r5, r1
    1306:	61 2c       	mov	r6, r1
    1308:	71 2c       	mov	r7, r1
		random31^=0x20AA95B5;	//xor magic number (taps)
	}
}
*/

static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
    130a:	75 01       	movw	r14, r10
    130c:	e0 0e       	add	r14, r16
    130e:	f1 1e       	adc	r15, r17
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    1310:	d7 01       	movw	r26, r14
    1312:	2c 90       	ld	r2, X
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1314:	0e 94 19 09 	call	0x1232	; 0x1232 <GetRandomLongInt>
    1318:	a3 01       	movw	r20, r6
    131a:	92 01       	movw	r18, r4
    131c:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    1320:	fb 01       	movw	r30, r22
    1322:	ec 0d       	add	r30, r12
    1324:	fd 1d       	adc	r31, r13
    1326:	ec 5b       	subi	r30, 0xBC	; 188
    1328:	fb 4f       	sbci	r31, 0xFB	; 251
    132a:	80 81       	ld	r24, Z
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    132c:	d7 01       	movw	r26, r14
    132e:	8c 93       	st	X, r24
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1330:	20 82       	st	Z, r2
    1332:	0f 5f       	subi	r16, 0xFF	; 255
    1334:	1f 4f       	sbci	r17, 0xFF	; 255
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    1336:	08 15       	cp	r16, r8
    1338:	40 f3       	brcs	.-48     	; 0x130a <MakeNewGranularArray+0x86>
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    133a:	31 10       	cpse	r3, r1
    133c:	15 c0       	rjmp	.+42     	; 0x1368 <MakeNewGranularArray+0xe4>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    133e:	60 91 f2 05 	lds	r22, 0x05F2
    1342:	70 91 f3 05 	lds	r23, 0x05F3
    1346:	80 91 f4 05 	lds	r24, 0x05F4
    134a:	90 91 f5 05 	lds	r25, 0x05F5
    134e:	a3 01       	movw	r20, r6
    1350:	92 01       	movw	r18, r4
    1352:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
    1356:	20 93 35 04 	sts	0x0435, r18
    135a:	30 93 36 04 	sts	0x0436, r19
    135e:	40 93 37 04 	sts	0x0437, r20
    1362:	50 93 38 04 	sts	0x0438, r21
    1366:	1c c0       	rjmp	.+56     	; 0x13a0 <MakeNewGranularArray+0x11c>
		}
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;
    1368:	00 91 16 06 	lds	r16, 0x0616
    136c:	10 91 17 06 	lds	r17, 0x0617
    1370:	20 91 18 06 	lds	r18, 0x0618
    1374:	30 91 19 06 	lds	r19, 0x0619
    1378:	6f ef       	ldi	r22, 0xFF	; 255
    137a:	7f ef       	ldi	r23, 0xFF	; 255
    137c:	87 e0       	ldi	r24, 0x07	; 7
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	60 1b       	sub	r22, r16
    1382:	71 0b       	sbc	r23, r17
    1384:	82 0b       	sbc	r24, r18
    1386:	93 0b       	sbc	r25, r19
    1388:	a3 01       	movw	r20, r6
    138a:	92 01       	movw	r18, r4
    138c:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
    1390:	20 93 39 04 	sts	0x0439, r18
    1394:	30 93 3a 04 	sts	0x043A, r19
    1398:	40 93 3b 04 	sts	0x043B, r20
    139c:	50 93 3c 04 	sts	0x043C, r21
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    13a0:	84 e2       	ldi	r24, 0x24	; 36
    13a2:	8c 9f       	mul	r24, r28
    13a4:	f0 01       	movw	r30, r0
    13a6:	8d 9f       	mul	r24, r29
    13a8:	f0 0d       	add	r31, r0
    13aa:	11 24       	eor	r1, r1
    13ac:	eb 51       	subi	r30, 0x1B	; 27
    13ae:	fa 4f       	sbci	r31, 0xFA	; 250
    13b0:	87 82       	std	Z+7, r8	; 0x07
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    13b2:	fe 01       	movw	r30, r28
    13b4:	e3 5c       	subi	r30, 0xC3	; 195
    13b6:	fb 4f       	sbci	r31, 0xFB	; 251
    13b8:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    13ba:	cc 0f       	add	r28, r28
    13bc:	dd 1f       	adc	r29, r29
    13be:	cc 0f       	add	r28, r28
    13c0:	dd 1f       	adc	r29, r29
    13c2:	fe 01       	movw	r30, r28
    13c4:	eb 5c       	subi	r30, 0xCB	; 203
    13c6:	fb 4f       	sbci	r31, 0xFB	; 251
    13c8:	80 81       	ld	r24, Z
    13ca:	91 81       	ldd	r25, Z+1	; 0x01
    13cc:	a2 81       	ldd	r26, Z+2	; 0x02
    13ce:	b3 81       	ldd	r27, Z+3	; 0x03
    13d0:	c3 5d       	subi	r28, 0xD3	; 211
    13d2:	db 4f       	sbci	r29, 0xFB	; 251
    13d4:	88 83       	st	Y, r24
    13d6:	99 83       	std	Y+1, r25	; 0x01
    13d8:	aa 83       	std	Y+2, r26	; 0x02
    13da:	bb 83       	std	Y+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    13dc:	31 10       	cpse	r3, r1
    13de:	16 c0       	rjmp	.+44     	; 0x140c <MakeNewGranularArray+0x188>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    13e0:	20 91 35 04 	lds	r18, 0x0435
    13e4:	30 91 36 04 	lds	r19, 0x0436
    13e8:	40 91 37 04 	lds	r20, 0x0437
    13ec:	50 91 38 04 	lds	r21, 0x0438
    13f0:	a0 91 44 04 	lds	r26, 0x0444
    13f4:	b0 e0       	ldi	r27, 0x00	; 0
    13f6:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    13fa:	60 93 05 06 	sts	0x0605, r22
    13fe:	70 93 06 06 	sts	0x0606, r23
    1402:	80 93 07 06 	sts	0x0607, r24
    1406:	90 93 08 06 	sts	0x0608, r25
    140a:	1d c0       	rjmp	.+58     	; 0x1446 <MakeNewGranularArray+0x1c2>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));
    140c:	20 91 39 04 	lds	r18, 0x0439
    1410:	30 91 3a 04 	lds	r19, 0x043A
    1414:	40 91 3b 04 	lds	r20, 0x043B
    1418:	50 91 3c 04 	lds	r21, 0x043C
    141c:	a0 91 c4 04 	lds	r26, 0x04C4
    1420:	b0 e0       	ldi	r27, 0x00	; 0
    1422:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    1426:	0f ef       	ldi	r16, 0xFF	; 255
    1428:	1f ef       	ldi	r17, 0xFF	; 255
    142a:	27 e0       	ldi	r18, 0x07	; 7
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	06 1b       	sub	r16, r22
    1430:	17 0b       	sbc	r17, r23
    1432:	28 0b       	sbc	r18, r24
    1434:	39 0b       	sbc	r19, r25
    1436:	00 93 29 06 	sts	0x0629, r16
    143a:	10 93 2a 06 	sts	0x062A, r17
    143e:	20 93 2b 06 	sts	0x062B, r18
    1442:	30 93 2c 06 	sts	0x062C, r19
		}

		SREG=sreg;		// Restore interrupts.
    1446:	9f be       	out	0x3f, r9	; 63
    1448:	07 c0       	rjmp	.+14     	; 0x1458 <MakeNewGranularArray+0x1d4>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.
    144a:	b4 e2       	ldi	r27, 0x24	; 36
    144c:	8b 9f       	mul	r24, r27
    144e:	f0 01       	movw	r30, r0
    1450:	11 24       	eor	r1, r1
    1452:	eb 51       	subi	r30, 0x1B	; 27
    1454:	fa 4f       	sbci	r31, 0xFA	; 250
    1456:	17 82       	std	Z+7, r1	; 0x07
	}
}
    1458:	df 91       	pop	r29
    145a:	cf 91       	pop	r28
    145c:	1f 91       	pop	r17
    145e:	0f 91       	pop	r16
    1460:	ff 90       	pop	r15
    1462:	ef 90       	pop	r14
    1464:	df 90       	pop	r13
    1466:	cf 90       	pop	r12
    1468:	bf 90       	pop	r11
    146a:	af 90       	pop	r10
    146c:	9f 90       	pop	r9
    146e:	8f 90       	pop	r8
    1470:	7f 90       	pop	r7
    1472:	6f 90       	pop	r6
    1474:	5f 90       	pop	r5
    1476:	4f 90       	pop	r4
    1478:	3f 90       	pop	r3
    147a:	2f 90       	pop	r2
    147c:	08 95       	ret

0000147e <UpdateAdjustedSampleAddresses>:
static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttlewheel)
// Wed Jun 22 13:50:04 EDT 2011
// Now that we use an encoder we could adjust this more finely if we wanted to.
{
    147e:	4f 92       	push	r4
    1480:	5f 92       	push	r5
    1482:	6f 92       	push	r6
    1484:	7f 92       	push	r7
    1486:	8f 92       	push	r8
    1488:	9f 92       	push	r9
    148a:	af 92       	push	r10
    148c:	bf 92       	push	r11
    148e:	cf 92       	push	r12
    1490:	df 92       	push	r13
    1492:	ef 92       	push	r14
    1494:	ff 92       	push	r15
	unsigned char
		sreg;
	unsigned long
		chunkSize;

	sreg=SREG;
    1496:	ef b7       	in	r30, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1498:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    149a:	81 11       	cpse	r24, r1
    149c:	e9 c1       	rjmp	.+978    	; 0x1870 <UpdateAdjustedSampleAddresses+0x3f2>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    149e:	80 90 f2 05 	lds	r8, 0x05F2
    14a2:	90 90 f3 05 	lds	r9, 0x05F3
    14a6:	a0 90 f4 05 	lds	r10, 0x05F4
    14aa:	b0 90 f5 05 	lds	r11, 0x05F5
    14ae:	83 e0       	ldi	r24, 0x03	; 3
    14b0:	88 0c       	add	r8, r8
    14b2:	99 1c       	adc	r9, r9
    14b4:	aa 1c       	adc	r10, r10
    14b6:	bb 1c       	adc	r11, r11
    14b8:	8a 95       	dec	r24
    14ba:	d1 f7       	brne	.-12     	; 0x14b0 <UpdateAdjustedSampleAddresses+0x32>
    14bc:	89 2c       	mov	r8, r9
    14be:	9a 2c       	mov	r9, r10
    14c0:	ab 2c       	mov	r10, r11
    14c2:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    14c4:	a0 91 02 06 	lds	r26, 0x0602
    14c8:	80 91 04 06 	lds	r24, 0x0604
    14cc:	b0 e0       	ldi	r27, 0x00	; 0
    14ce:	a8 0f       	add	r26, r24
    14d0:	b1 1d       	adc	r27, r1
    14d2:	a5 01       	movw	r20, r10
    14d4:	94 01       	movw	r18, r8
    14d6:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    14da:	f3 e0       	ldi	r31, 0x03	; 3
    14dc:	96 95       	lsr	r25
    14de:	87 95       	ror	r24
    14e0:	77 95       	ror	r23
    14e2:	67 95       	ror	r22
    14e4:	fa 95       	dec	r31
    14e6:	d1 f7       	brne	.-12     	; 0x14dc <UpdateAdjustedSampleAddresses+0x5e>
    14e8:	60 93 fe 05 	sts	0x05FE, r22
    14ec:	70 93 ff 05 	sts	0x05FF, r23
    14f0:	80 93 00 06 	sts	0x0600, r24
    14f4:	90 93 01 06 	sts	0x0601, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    14f8:	40 90 f2 05 	lds	r4, 0x05F2
    14fc:	50 90 f3 05 	lds	r5, 0x05F3
    1500:	60 90 f4 05 	lds	r6, 0x05F4
    1504:	70 90 f5 05 	lds	r7, 0x05F5
    1508:	f0 91 03 06 	lds	r31, 0x0603
    150c:	a0 91 04 06 	lds	r26, 0x0604
    1510:	b0 e0       	ldi	r27, 0x00	; 0
    1512:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    1516:	6b 01       	movw	r12, r22
    1518:	7c 01       	movw	r14, r24
    151a:	a3 e0       	ldi	r26, 0x03	; 3
    151c:	f6 94       	lsr	r15
    151e:	e7 94       	ror	r14
    1520:	d7 94       	ror	r13
    1522:	c7 94       	ror	r12
    1524:	aa 95       	dec	r26
    1526:	d1 f7       	brne	.-12     	; 0x151c <UpdateAdjustedSampleAddresses+0x9e>
    1528:	c4 0c       	add	r12, r4
    152a:	d5 1c       	adc	r13, r5
    152c:	e6 1c       	adc	r14, r6
    152e:	f7 1c       	adc	r15, r7
    1530:	af 2f       	mov	r26, r31
    1532:	b0 e0       	ldi	r27, 0x00	; 0
    1534:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    1538:	b3 e0       	ldi	r27, 0x03	; 3
    153a:	96 95       	lsr	r25
    153c:	87 95       	ror	r24
    153e:	77 95       	ror	r23
    1540:	67 95       	ror	r22
    1542:	ba 95       	dec	r27
    1544:	d1 f7       	brne	.-12     	; 0x153a <UpdateAdjustedSampleAddresses+0xbc>
    1546:	c6 1a       	sub	r12, r22
    1548:	d7 0a       	sbc	r13, r23
    154a:	e8 0a       	sbc	r14, r24
    154c:	f9 0a       	sbc	r15, r25
    154e:	c0 92 fa 05 	sts	0x05FA, r12
    1552:	d0 92 fb 05 	sts	0x05FB, r13
    1556:	e0 92 fc 05 	sts	0x05FC, r14
    155a:	f0 92 fd 05 	sts	0x05FD, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    155e:	40 91 fe 05 	lds	r20, 0x05FE
    1562:	50 91 ff 05 	lds	r21, 0x05FF
    1566:	60 91 00 06 	lds	r22, 0x0600
    156a:	70 91 01 06 	lds	r23, 0x0601
    156e:	80 91 fa 05 	lds	r24, 0x05FA
    1572:	90 91 fb 05 	lds	r25, 0x05FB
    1576:	a0 91 fc 05 	lds	r26, 0x05FC
    157a:	b0 91 fd 05 	lds	r27, 0x05FD
    157e:	84 17       	cp	r24, r20
    1580:	95 07       	cpc	r25, r21
    1582:	a6 07       	cpc	r26, r22
    1584:	b7 07       	cpc	r27, r23
    1586:	50 f5       	brcc	.+84     	; 0x15dc <UpdateAdjustedSampleAddresses+0x15e>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1588:	80 91 e8 05 	lds	r24, 0x05E8
    158c:	81 30       	cpi	r24, 0x01	; 1
    158e:	19 f4       	brne	.+6      	; 0x1596 <UpdateAdjustedSampleAddresses+0x118>
			{
				bankStates[BANK_0].sampleDirection=true;
    1590:	80 93 e9 05 	sts	0x05E9, r24
    1594:	02 c0       	rjmp	.+4      	; 0x159a <UpdateAdjustedSampleAddresses+0x11c>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    1596:	10 92 e9 05 	sts	0x05E9, r1
			}

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    159a:	80 91 fe 05 	lds	r24, 0x05FE
    159e:	90 91 ff 05 	lds	r25, 0x05FF
    15a2:	a0 91 00 06 	lds	r26, 0x0600
    15a6:	b0 91 01 06 	lds	r27, 0x0601
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    15aa:	40 91 fa 05 	lds	r20, 0x05FA
    15ae:	50 91 fb 05 	lds	r21, 0x05FB
    15b2:	60 91 fc 05 	lds	r22, 0x05FC
    15b6:	70 91 fd 05 	lds	r23, 0x05FD
    15ba:	40 93 fe 05 	sts	0x05FE, r20
    15be:	50 93 ff 05 	sts	0x05FF, r21
    15c2:	60 93 00 06 	sts	0x0600, r22
    15c6:	70 93 01 06 	sts	0x0601, r23
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    15ca:	80 93 fa 05 	sts	0x05FA, r24
    15ce:	90 93 fb 05 	sts	0x05FB, r25
    15d2:	a0 93 fc 05 	sts	0x05FC, r26
    15d6:	b0 93 fd 05 	sts	0x05FD, r27
    15da:	0a c0       	rjmp	.+20     	; 0x15f0 <UpdateAdjustedSampleAddresses+0x172>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    15dc:	80 91 e8 05 	lds	r24, 0x05E8
    15e0:	81 30       	cpi	r24, 0x01	; 1
    15e2:	19 f4       	brne	.+6      	; 0x15ea <UpdateAdjustedSampleAddresses+0x16c>
			{
				bankStates[BANK_0].sampleDirection=false;
    15e4:	10 92 e9 05 	sts	0x05E9, r1
    15e8:	03 c0       	rjmp	.+6      	; 0x15f0 <UpdateAdjustedSampleAddresses+0x172>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	80 93 e9 05 	sts	0x05E9, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    15f0:	40 91 fe 05 	lds	r20, 0x05FE
    15f4:	50 91 ff 05 	lds	r21, 0x05FF
    15f8:	60 91 00 06 	lds	r22, 0x0600
    15fc:	70 91 01 06 	lds	r23, 0x0601
    1600:	80 91 f2 05 	lds	r24, 0x05F2
    1604:	90 91 f3 05 	lds	r25, 0x05F3
    1608:	a0 91 f4 05 	lds	r26, 0x05F4
    160c:	b0 91 f5 05 	lds	r27, 0x05F5
    1610:	84 17       	cp	r24, r20
    1612:	95 07       	cpc	r25, r21
    1614:	a6 07       	cpc	r26, r22
    1616:	b7 07       	cpc	r27, r23
    1618:	e0 f4       	brcc	.+56     	; 0x1652 <UpdateAdjustedSampleAddresses+0x1d4>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    161a:	80 91 fe 05 	lds	r24, 0x05FE
    161e:	90 91 ff 05 	lds	r25, 0x05FF
    1622:	a0 91 00 06 	lds	r26, 0x0600
    1626:	b0 91 01 06 	lds	r27, 0x0601
    162a:	40 91 f2 05 	lds	r20, 0x05F2
    162e:	50 91 f3 05 	lds	r21, 0x05F3
    1632:	60 91 f4 05 	lds	r22, 0x05F4
    1636:	70 91 f5 05 	lds	r23, 0x05F5
    163a:	84 1b       	sub	r24, r20
    163c:	95 0b       	sbc	r25, r21
    163e:	a6 0b       	sbc	r26, r22
    1640:	b7 0b       	sbc	r27, r23
    1642:	80 93 fe 05 	sts	0x05FE, r24
    1646:	90 93 ff 05 	sts	0x05FF, r25
    164a:	a0 93 00 06 	sts	0x0600, r26
    164e:	b0 93 01 06 	sts	0x0601, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    1652:	40 91 fa 05 	lds	r20, 0x05FA
    1656:	50 91 fb 05 	lds	r21, 0x05FB
    165a:	60 91 fc 05 	lds	r22, 0x05FC
    165e:	70 91 fd 05 	lds	r23, 0x05FD
    1662:	80 91 f2 05 	lds	r24, 0x05F2
    1666:	90 91 f3 05 	lds	r25, 0x05F3
    166a:	a0 91 f4 05 	lds	r26, 0x05F4
    166e:	b0 91 f5 05 	lds	r27, 0x05F5
    1672:	84 17       	cp	r24, r20
    1674:	95 07       	cpc	r25, r21
    1676:	a6 07       	cpc	r26, r22
    1678:	b7 07       	cpc	r27, r23
    167a:	08 f0       	brcs	.+2      	; 0x167e <UpdateAdjustedSampleAddresses+0x200>
    167c:	44 c0       	rjmp	.+136    	; 0x1706 <UpdateAdjustedSampleAddresses+0x288>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    167e:	80 91 fa 05 	lds	r24, 0x05FA
    1682:	90 91 fb 05 	lds	r25, 0x05FB
    1686:	a0 91 fc 05 	lds	r26, 0x05FC
    168a:	b0 91 fd 05 	lds	r27, 0x05FD
    168e:	40 91 f2 05 	lds	r20, 0x05F2
    1692:	50 91 f3 05 	lds	r21, 0x05F3
    1696:	60 91 f4 05 	lds	r22, 0x05F4
    169a:	70 91 f5 05 	lds	r23, 0x05F5
    169e:	84 1b       	sub	r24, r20
    16a0:	95 0b       	sbc	r25, r21
    16a2:	a6 0b       	sbc	r26, r22
    16a4:	b7 0b       	sbc	r27, r23
    16a6:	80 93 fa 05 	sts	0x05FA, r24
    16aa:	90 93 fb 05 	sts	0x05FB, r25
    16ae:	a0 93 fc 05 	sts	0x05FC, r26
    16b2:	b0 93 fd 05 	sts	0x05FD, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    16b6:	40 91 fa 05 	lds	r20, 0x05FA
    16ba:	50 91 fb 05 	lds	r21, 0x05FB
    16be:	60 91 fc 05 	lds	r22, 0x05FC
    16c2:	70 91 fd 05 	lds	r23, 0x05FD
    16c6:	80 91 fe 05 	lds	r24, 0x05FE
    16ca:	90 91 ff 05 	lds	r25, 0x05FF
    16ce:	a0 91 00 06 	lds	r26, 0x0600
    16d2:	b0 91 01 06 	lds	r27, 0x0601
    16d6:	48 17       	cp	r20, r24
    16d8:	59 07       	cpc	r21, r25
    16da:	6a 07       	cpc	r22, r26
    16dc:	7b 07       	cpc	r23, r27
    16de:	99 f4       	brne	.+38     	; 0x1706 <UpdateAdjustedSampleAddresses+0x288>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    16e0:	80 91 fa 05 	lds	r24, 0x05FA
    16e4:	90 91 fb 05 	lds	r25, 0x05FB
    16e8:	a0 91 fc 05 	lds	r26, 0x05FC
    16ec:	b0 91 fd 05 	lds	r27, 0x05FD
    16f0:	01 97       	sbiw	r24, 0x01	; 1
    16f2:	a1 09       	sbc	r26, r1
    16f4:	b1 09       	sbc	r27, r1
    16f6:	80 93 fa 05 	sts	0x05FA, r24
    16fa:	90 93 fb 05 	sts	0x05FB, r25
    16fe:	a0 93 fc 05 	sts	0x05FC, r26
    1702:	b0 93 fd 05 	sts	0x05FD, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    1706:	40 91 fe 05 	lds	r20, 0x05FE
    170a:	50 91 ff 05 	lds	r21, 0x05FF
    170e:	60 91 00 06 	lds	r22, 0x0600
    1712:	70 91 01 06 	lds	r23, 0x0601
    1716:	80 91 fa 05 	lds	r24, 0x05FA
    171a:	90 91 fb 05 	lds	r25, 0x05FB
    171e:	a0 91 fc 05 	lds	r26, 0x05FC
    1722:	b0 91 fd 05 	lds	r27, 0x05FD
    1726:	84 17       	cp	r24, r20
    1728:	95 07       	cpc	r25, r21
    172a:	a6 07       	cpc	r26, r22
    172c:	b7 07       	cpc	r27, r23
    172e:	08 f0       	brcs	.+2      	; 0x1732 <UpdateAdjustedSampleAddresses+0x2b4>
    1730:	5a c0       	rjmp	.+180    	; 0x17e6 <UpdateAdjustedSampleAddresses+0x368>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1732:	40 91 05 06 	lds	r20, 0x0605
    1736:	50 91 06 06 	lds	r21, 0x0606
    173a:	60 91 07 06 	lds	r22, 0x0607
    173e:	70 91 08 06 	lds	r23, 0x0608
    1742:	80 91 fe 05 	lds	r24, 0x05FE
    1746:	90 91 ff 05 	lds	r25, 0x05FF
    174a:	a0 91 00 06 	lds	r26, 0x0600
    174e:	b0 91 01 06 	lds	r27, 0x0601
    1752:	48 17       	cp	r20, r24
    1754:	59 07       	cpc	r21, r25
    1756:	6a 07       	cpc	r22, r26
    1758:	7b 07       	cpc	r23, r27
    175a:	08 f0       	brcs	.+2      	; 0x175e <UpdateAdjustedSampleAddresses+0x2e0>
    175c:	86 c2       	rjmp	.+1292   	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
    175e:	40 91 05 06 	lds	r20, 0x0605
    1762:	50 91 06 06 	lds	r21, 0x0606
    1766:	60 91 07 06 	lds	r22, 0x0607
    176a:	70 91 08 06 	lds	r23, 0x0608
    176e:	80 91 fa 05 	lds	r24, 0x05FA
    1772:	90 91 fb 05 	lds	r25, 0x05FB
    1776:	a0 91 fc 05 	lds	r26, 0x05FC
    177a:	b0 91 fd 05 	lds	r27, 0x05FD
    177e:	84 17       	cp	r24, r20
    1780:	95 07       	cpc	r25, r21
    1782:	a6 07       	cpc	r26, r22
    1784:	b7 07       	cpc	r27, r23
    1786:	08 f0       	brcs	.+2      	; 0x178a <UpdateAdjustedSampleAddresses+0x30c>
    1788:	70 c2       	rjmp	.+1248   	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?
    178a:	40 91 fe 05 	lds	r20, 0x05FE
    178e:	50 91 ff 05 	lds	r21, 0x05FF
    1792:	60 91 00 06 	lds	r22, 0x0600
    1796:	70 91 01 06 	lds	r23, 0x0601
    179a:	80 90 05 06 	lds	r8, 0x0605
    179e:	90 90 06 06 	lds	r9, 0x0606
    17a2:	a0 90 07 06 	lds	r10, 0x0607
    17a6:	b0 90 08 06 	lds	r11, 0x0608
    17aa:	80 91 05 06 	lds	r24, 0x0605
    17ae:	90 91 06 06 	lds	r25, 0x0606
    17b2:	a0 91 07 06 	lds	r26, 0x0607
    17b6:	b0 91 08 06 	lds	r27, 0x0608
    17ba:	c0 90 fa 05 	lds	r12, 0x05FA
    17be:	d0 90 fb 05 	lds	r13, 0x05FB
    17c2:	e0 90 fc 05 	lds	r14, 0x05FC
    17c6:	f0 90 fd 05 	lds	r15, 0x05FD
    17ca:	48 19       	sub	r20, r8
    17cc:	59 09       	sbc	r21, r9
    17ce:	6a 09       	sbc	r22, r10
    17d0:	7b 09       	sbc	r23, r11
    17d2:	8c 19       	sub	r24, r12
    17d4:	9d 09       	sbc	r25, r13
    17d6:	ae 09       	sbc	r26, r14
    17d8:	bf 09       	sbc	r27, r15
    17da:	48 17       	cp	r20, r24
    17dc:	59 07       	cpc	r21, r25
    17de:	6a 07       	cpc	r22, r26
    17e0:	7b 07       	cpc	r23, r27
    17e2:	e8 f1       	brcs	.+122    	; 0x185e <UpdateAdjustedSampleAddresses+0x3e0>
    17e4:	15 c0       	rjmp	.+42     	; 0x1810 <UpdateAdjustedSampleAddresses+0x392>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    17e6:	40 91 05 06 	lds	r20, 0x0605
    17ea:	50 91 06 06 	lds	r21, 0x0606
    17ee:	60 91 07 06 	lds	r22, 0x0607
    17f2:	70 91 08 06 	lds	r23, 0x0608
    17f6:	80 91 fe 05 	lds	r24, 0x05FE
    17fa:	90 91 ff 05 	lds	r25, 0x05FF
    17fe:	a0 91 00 06 	lds	r26, 0x0600
    1802:	b0 91 01 06 	lds	r27, 0x0601
    1806:	48 17       	cp	r20, r24
    1808:	59 07       	cpc	r21, r25
    180a:	6a 07       	cpc	r22, r26
    180c:	7b 07       	cpc	r23, r27
    180e:	88 f4       	brcc	.+34     	; 0x1832 <UpdateAdjustedSampleAddresses+0x3b4>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    1810:	80 91 fe 05 	lds	r24, 0x05FE
    1814:	90 91 ff 05 	lds	r25, 0x05FF
    1818:	a0 91 00 06 	lds	r26, 0x0600
    181c:	b0 91 01 06 	lds	r27, 0x0601
    1820:	80 93 05 06 	sts	0x0605, r24
    1824:	90 93 06 06 	sts	0x0606, r25
    1828:	a0 93 07 06 	sts	0x0607, r26
    182c:	b0 93 08 06 	sts	0x0608, r27
    1830:	1c c2       	rjmp	.+1080   	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
			}
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    1832:	40 91 05 06 	lds	r20, 0x0605
    1836:	50 91 06 06 	lds	r21, 0x0606
    183a:	60 91 07 06 	lds	r22, 0x0607
    183e:	70 91 08 06 	lds	r23, 0x0608
    1842:	80 91 fa 05 	lds	r24, 0x05FA
    1846:	90 91 fb 05 	lds	r25, 0x05FB
    184a:	a0 91 fc 05 	lds	r26, 0x05FC
    184e:	b0 91 fd 05 	lds	r27, 0x05FD
    1852:	84 17       	cp	r24, r20
    1854:	95 07       	cpc	r25, r21
    1856:	a6 07       	cpc	r26, r22
    1858:	b7 07       	cpc	r27, r23
    185a:	08 f0       	brcs	.+2      	; 0x185e <UpdateAdjustedSampleAddresses+0x3e0>
    185c:	06 c2       	rjmp	.+1036   	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    185e:	80 91 fa 05 	lds	r24, 0x05FA
    1862:	90 91 fb 05 	lds	r25, 0x05FB
    1866:	a0 91 fc 05 	lds	r26, 0x05FC
    186a:	b0 91 fd 05 	lds	r27, 0x05FD
    186e:	d8 cf       	rjmp	.-80     	; 0x1820 <UpdateAdjustedSampleAddresses+0x3a2>
		}
	}
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    1870:	80 91 16 06 	lds	r24, 0x0616
    1874:	90 91 17 06 	lds	r25, 0x0617
    1878:	a0 91 18 06 	lds	r26, 0x0618
    187c:	b0 91 19 06 	lds	r27, 0x0619
    1880:	cc 24       	eor	r12, r12
    1882:	ca 94       	dec	r12
    1884:	dc 2c       	mov	r13, r12
    1886:	27 e0       	ldi	r18, 0x07	; 7
    1888:	e2 2e       	mov	r14, r18
    188a:	f1 2c       	mov	r15, r1
    188c:	46 01       	movw	r8, r12
    188e:	57 01       	movw	r10, r14
    1890:	88 1a       	sub	r8, r24
    1892:	99 0a       	sbc	r9, r25
    1894:	aa 0a       	sbc	r10, r26
    1896:	bb 0a       	sbc	r11, r27
    1898:	33 e0       	ldi	r19, 0x03	; 3
    189a:	88 0c       	add	r8, r8
    189c:	99 1c       	adc	r9, r9
    189e:	aa 1c       	adc	r10, r10
    18a0:	bb 1c       	adc	r11, r11
    18a2:	3a 95       	dec	r19
    18a4:	d1 f7       	brne	.-12     	; 0x189a <UpdateAdjustedSampleAddresses+0x41c>
    18a6:	89 2c       	mov	r8, r9
    18a8:	9a 2c       	mov	r9, r10
    18aa:	ab 2c       	mov	r10, r11
    18ac:	bb 24       	eor	r11, r11

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    18ae:	a0 91 26 06 	lds	r26, 0x0626
    18b2:	80 91 28 06 	lds	r24, 0x0628
    18b6:	b0 e0       	ldi	r27, 0x00	; 0
    18b8:	a8 0f       	add	r26, r24
    18ba:	b1 1d       	adc	r27, r1
    18bc:	a5 01       	movw	r20, r10
    18be:	94 01       	movw	r18, r8
    18c0:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    18c4:	f3 e0       	ldi	r31, 0x03	; 3
    18c6:	96 95       	lsr	r25
    18c8:	87 95       	ror	r24
    18ca:	77 95       	ror	r23
    18cc:	67 95       	ror	r22
    18ce:	fa 95       	dec	r31
    18d0:	d1 f7       	brne	.-12     	; 0x18c6 <UpdateAdjustedSampleAddresses+0x448>
    18d2:	c6 1a       	sub	r12, r22
    18d4:	d7 0a       	sbc	r13, r23
    18d6:	e8 0a       	sbc	r14, r24
    18d8:	f9 0a       	sbc	r15, r25
    18da:	c0 92 22 06 	sts	0x0622, r12
    18de:	d0 92 23 06 	sts	0x0623, r13
    18e2:	e0 92 24 06 	sts	0x0624, r14
    18e6:	f0 92 25 06 	sts	0x0625, r15
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    18ea:	40 90 16 06 	lds	r4, 0x0616
    18ee:	50 90 17 06 	lds	r5, 0x0617
    18f2:	60 90 18 06 	lds	r6, 0x0618
    18f6:	70 90 19 06 	lds	r7, 0x0619
    18fa:	a0 91 27 06 	lds	r26, 0x0627
    18fe:	f0 91 28 06 	lds	r31, 0x0628
    1902:	b0 e0       	ldi	r27, 0x00	; 0
    1904:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    1908:	6b 01       	movw	r12, r22
    190a:	7c 01       	movw	r14, r24
    190c:	a3 e0       	ldi	r26, 0x03	; 3
    190e:	f6 94       	lsr	r15
    1910:	e7 94       	ror	r14
    1912:	d7 94       	ror	r13
    1914:	c7 94       	ror	r12
    1916:	aa 95       	dec	r26
    1918:	d1 f7       	brne	.-12     	; 0x190e <UpdateAdjustedSampleAddresses+0x490>
    191a:	c4 0c       	add	r12, r4
    191c:	d5 1c       	adc	r13, r5
    191e:	e6 1c       	adc	r14, r6
    1920:	f7 1c       	adc	r15, r7
    1922:	af 2f       	mov	r26, r31
    1924:	b0 e0       	ldi	r27, 0x00	; 0
    1926:	0e 94 0f 2a 	call	0x541e	; 0x541e <__muluhisi3>
    192a:	b3 e0       	ldi	r27, 0x03	; 3
    192c:	96 95       	lsr	r25
    192e:	87 95       	ror	r24
    1930:	77 95       	ror	r23
    1932:	67 95       	ror	r22
    1934:	ba 95       	dec	r27
    1936:	d1 f7       	brne	.-12     	; 0x192c <UpdateAdjustedSampleAddresses+0x4ae>
    1938:	c6 1a       	sub	r12, r22
    193a:	d7 0a       	sbc	r13, r23
    193c:	e8 0a       	sbc	r14, r24
    193e:	f9 0a       	sbc	r15, r25
    1940:	c0 92 1e 06 	sts	0x061E, r12
    1944:	d0 92 1f 06 	sts	0x061F, r13
    1948:	e0 92 20 06 	sts	0x0620, r14
    194c:	f0 92 21 06 	sts	0x0621, r15

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1950:	40 91 22 06 	lds	r20, 0x0622
    1954:	50 91 23 06 	lds	r21, 0x0623
    1958:	60 91 24 06 	lds	r22, 0x0624
    195c:	70 91 25 06 	lds	r23, 0x0625
    1960:	80 91 1e 06 	lds	r24, 0x061E
    1964:	90 91 1f 06 	lds	r25, 0x061F
    1968:	a0 91 20 06 	lds	r26, 0x0620
    196c:	b0 91 21 06 	lds	r27, 0x0621
    1970:	48 17       	cp	r20, r24
    1972:	59 07       	cpc	r21, r25
    1974:	6a 07       	cpc	r22, r26
    1976:	7b 07       	cpc	r23, r27
    1978:	50 f5       	brcc	.+84     	; 0x19ce <UpdateAdjustedSampleAddresses+0x550>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    197a:	80 91 0c 06 	lds	r24, 0x060C
    197e:	81 30       	cpi	r24, 0x01	; 1
    1980:	19 f4       	brne	.+6      	; 0x1988 <UpdateAdjustedSampleAddresses+0x50a>
			{
				bankStates[BANK_1].sampleDirection=true;
    1982:	80 93 0d 06 	sts	0x060D, r24
    1986:	02 c0       	rjmp	.+4      	; 0x198c <UpdateAdjustedSampleAddresses+0x50e>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    1988:	10 92 0d 06 	sts	0x060D, r1
			}

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    198c:	80 91 22 06 	lds	r24, 0x0622
    1990:	90 91 23 06 	lds	r25, 0x0623
    1994:	a0 91 24 06 	lds	r26, 0x0624
    1998:	b0 91 25 06 	lds	r27, 0x0625
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    199c:	40 91 1e 06 	lds	r20, 0x061E
    19a0:	50 91 1f 06 	lds	r21, 0x061F
    19a4:	60 91 20 06 	lds	r22, 0x0620
    19a8:	70 91 21 06 	lds	r23, 0x0621
    19ac:	40 93 22 06 	sts	0x0622, r20
    19b0:	50 93 23 06 	sts	0x0623, r21
    19b4:	60 93 24 06 	sts	0x0624, r22
    19b8:	70 93 25 06 	sts	0x0625, r23
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    19bc:	80 93 1e 06 	sts	0x061E, r24
    19c0:	90 93 1f 06 	sts	0x061F, r25
    19c4:	a0 93 20 06 	sts	0x0620, r26
    19c8:	b0 93 21 06 	sts	0x0621, r27
    19cc:	0a c0       	rjmp	.+20     	; 0x19e2 <UpdateAdjustedSampleAddresses+0x564>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    19ce:	80 91 0c 06 	lds	r24, 0x060C
    19d2:	81 30       	cpi	r24, 0x01	; 1
    19d4:	19 f4       	brne	.+6      	; 0x19dc <UpdateAdjustedSampleAddresses+0x55e>
			{
				bankStates[BANK_1].sampleDirection=false;
    19d6:	10 92 0d 06 	sts	0x060D, r1
    19da:	03 c0       	rjmp	.+6      	; 0x19e2 <UpdateAdjustedSampleAddresses+0x564>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	80 93 0d 06 	sts	0x060D, r24
			}
		}

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    19e2:	40 91 22 06 	lds	r20, 0x0622
    19e6:	50 91 23 06 	lds	r21, 0x0623
    19ea:	60 91 24 06 	lds	r22, 0x0624
    19ee:	70 91 25 06 	lds	r23, 0x0625
    19f2:	80 91 16 06 	lds	r24, 0x0616
    19f6:	90 91 17 06 	lds	r25, 0x0617
    19fa:	a0 91 18 06 	lds	r26, 0x0618
    19fe:	b0 91 19 06 	lds	r27, 0x0619
    1a02:	48 17       	cp	r20, r24
    1a04:	59 07       	cpc	r21, r25
    1a06:	6a 07       	cpc	r22, r26
    1a08:	7b 07       	cpc	r23, r27
    1a0a:	f8 f4       	brcc	.+62     	; 0x1a4a <UpdateAdjustedSampleAddresses+0x5cc>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    1a0c:	80 91 22 06 	lds	r24, 0x0622
    1a10:	90 91 23 06 	lds	r25, 0x0623
    1a14:	a0 91 24 06 	lds	r26, 0x0624
    1a18:	b0 91 25 06 	lds	r27, 0x0625
    1a1c:	40 91 16 06 	lds	r20, 0x0616
    1a20:	50 91 17 06 	lds	r21, 0x0617
    1a24:	60 91 18 06 	lds	r22, 0x0618
    1a28:	70 91 19 06 	lds	r23, 0x0619
    1a2c:	01 97       	sbiw	r24, 0x01	; 1
    1a2e:	a8 4f       	sbci	r26, 0xF8	; 248
    1a30:	bf 4f       	sbci	r27, 0xFF	; 255
    1a32:	84 1b       	sub	r24, r20
    1a34:	95 0b       	sbc	r25, r21
    1a36:	a6 0b       	sbc	r26, r22
    1a38:	b7 0b       	sbc	r27, r23
    1a3a:	80 93 22 06 	sts	0x0622, r24
    1a3e:	90 93 23 06 	sts	0x0623, r25
    1a42:	a0 93 24 06 	sts	0x0624, r26
    1a46:	b0 93 25 06 	sts	0x0625, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    1a4a:	40 91 1e 06 	lds	r20, 0x061E
    1a4e:	50 91 1f 06 	lds	r21, 0x061F
    1a52:	60 91 20 06 	lds	r22, 0x0620
    1a56:	70 91 21 06 	lds	r23, 0x0621
    1a5a:	80 91 16 06 	lds	r24, 0x0616
    1a5e:	90 91 17 06 	lds	r25, 0x0617
    1a62:	a0 91 18 06 	lds	r26, 0x0618
    1a66:	b0 91 19 06 	lds	r27, 0x0619
    1a6a:	48 17       	cp	r20, r24
    1a6c:	59 07       	cpc	r21, r25
    1a6e:	6a 07       	cpc	r22, r26
    1a70:	7b 07       	cpc	r23, r27
    1a72:	08 f0       	brcs	.+2      	; 0x1a76 <UpdateAdjustedSampleAddresses+0x5f8>
    1a74:	47 c0       	rjmp	.+142    	; 0x1b04 <UpdateAdjustedSampleAddresses+0x686>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    1a76:	80 91 1e 06 	lds	r24, 0x061E
    1a7a:	90 91 1f 06 	lds	r25, 0x061F
    1a7e:	a0 91 20 06 	lds	r26, 0x0620
    1a82:	b0 91 21 06 	lds	r27, 0x0621
    1a86:	40 91 16 06 	lds	r20, 0x0616
    1a8a:	50 91 17 06 	lds	r21, 0x0617
    1a8e:	60 91 18 06 	lds	r22, 0x0618
    1a92:	70 91 19 06 	lds	r23, 0x0619
    1a96:	01 97       	sbiw	r24, 0x01	; 1
    1a98:	a8 4f       	sbci	r26, 0xF8	; 248
    1a9a:	bf 4f       	sbci	r27, 0xFF	; 255
    1a9c:	84 1b       	sub	r24, r20
    1a9e:	95 0b       	sbc	r25, r21
    1aa0:	a6 0b       	sbc	r26, r22
    1aa2:	b7 0b       	sbc	r27, r23
    1aa4:	80 93 1e 06 	sts	0x061E, r24
    1aa8:	90 93 1f 06 	sts	0x061F, r25
    1aac:	a0 93 20 06 	sts	0x0620, r26
    1ab0:	b0 93 21 06 	sts	0x0621, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    1ab4:	40 91 1e 06 	lds	r20, 0x061E
    1ab8:	50 91 1f 06 	lds	r21, 0x061F
    1abc:	60 91 20 06 	lds	r22, 0x0620
    1ac0:	70 91 21 06 	lds	r23, 0x0621
    1ac4:	80 91 22 06 	lds	r24, 0x0622
    1ac8:	90 91 23 06 	lds	r25, 0x0623
    1acc:	a0 91 24 06 	lds	r26, 0x0624
    1ad0:	b0 91 25 06 	lds	r27, 0x0625
    1ad4:	48 17       	cp	r20, r24
    1ad6:	59 07       	cpc	r21, r25
    1ad8:	6a 07       	cpc	r22, r26
    1ada:	7b 07       	cpc	r23, r27
    1adc:	99 f4       	brne	.+38     	; 0x1b04 <UpdateAdjustedSampleAddresses+0x686>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    1ade:	80 91 1e 06 	lds	r24, 0x061E
    1ae2:	90 91 1f 06 	lds	r25, 0x061F
    1ae6:	a0 91 20 06 	lds	r26, 0x0620
    1aea:	b0 91 21 06 	lds	r27, 0x0621
    1aee:	01 96       	adiw	r24, 0x01	; 1
    1af0:	a1 1d       	adc	r26, r1
    1af2:	b1 1d       	adc	r27, r1
    1af4:	80 93 1e 06 	sts	0x061E, r24
    1af8:	90 93 1f 06 	sts	0x061F, r25
    1afc:	a0 93 20 06 	sts	0x0620, r26
    1b00:	b0 93 21 06 	sts	0x0621, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    1b04:	40 91 22 06 	lds	r20, 0x0622
    1b08:	50 91 23 06 	lds	r21, 0x0623
    1b0c:	60 91 24 06 	lds	r22, 0x0624
    1b10:	70 91 25 06 	lds	r23, 0x0625
    1b14:	80 91 1e 06 	lds	r24, 0x061E
    1b18:	90 91 1f 06 	lds	r25, 0x061F
    1b1c:	a0 91 20 06 	lds	r26, 0x0620
    1b20:	b0 91 21 06 	lds	r27, 0x0621
    1b24:	48 17       	cp	r20, r24
    1b26:	59 07       	cpc	r21, r25
    1b28:	6a 07       	cpc	r22, r26
    1b2a:	7b 07       	cpc	r23, r27
    1b2c:	08 f0       	brcs	.+2      	; 0x1b30 <UpdateAdjustedSampleAddresses+0x6b2>
    1b2e:	5a c0       	rjmp	.+180    	; 0x1be4 <UpdateAdjustedSampleAddresses+0x766>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1b30:	40 91 29 06 	lds	r20, 0x0629
    1b34:	50 91 2a 06 	lds	r21, 0x062A
    1b38:	60 91 2b 06 	lds	r22, 0x062B
    1b3c:	70 91 2c 06 	lds	r23, 0x062C
    1b40:	80 91 22 06 	lds	r24, 0x0622
    1b44:	90 91 23 06 	lds	r25, 0x0623
    1b48:	a0 91 24 06 	lds	r26, 0x0624
    1b4c:	b0 91 25 06 	lds	r27, 0x0625
    1b50:	84 17       	cp	r24, r20
    1b52:	95 07       	cpc	r25, r21
    1b54:	a6 07       	cpc	r26, r22
    1b56:	b7 07       	cpc	r27, r23
    1b58:	08 f0       	brcs	.+2      	; 0x1b5c <UpdateAdjustedSampleAddresses+0x6de>
    1b5a:	87 c0       	rjmp	.+270    	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
    1b5c:	40 91 29 06 	lds	r20, 0x0629
    1b60:	50 91 2a 06 	lds	r21, 0x062A
    1b64:	60 91 2b 06 	lds	r22, 0x062B
    1b68:	70 91 2c 06 	lds	r23, 0x062C
    1b6c:	80 91 1e 06 	lds	r24, 0x061E
    1b70:	90 91 1f 06 	lds	r25, 0x061F
    1b74:	a0 91 20 06 	lds	r26, 0x0620
    1b78:	b0 91 21 06 	lds	r27, 0x0621
    1b7c:	48 17       	cp	r20, r24
    1b7e:	59 07       	cpc	r21, r25
    1b80:	6a 07       	cpc	r22, r26
    1b82:	7b 07       	cpc	r23, r27
    1b84:	08 f0       	brcs	.+2      	; 0x1b88 <UpdateAdjustedSampleAddresses+0x70a>
    1b86:	71 c0       	rjmp	.+226    	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?
    1b88:	40 91 29 06 	lds	r20, 0x0629
    1b8c:	50 91 2a 06 	lds	r21, 0x062A
    1b90:	60 91 2b 06 	lds	r22, 0x062B
    1b94:	70 91 2c 06 	lds	r23, 0x062C
    1b98:	80 90 22 06 	lds	r8, 0x0622
    1b9c:	90 90 23 06 	lds	r9, 0x0623
    1ba0:	a0 90 24 06 	lds	r10, 0x0624
    1ba4:	b0 90 25 06 	lds	r11, 0x0625
    1ba8:	80 91 1e 06 	lds	r24, 0x061E
    1bac:	90 91 1f 06 	lds	r25, 0x061F
    1bb0:	a0 91 20 06 	lds	r26, 0x0620
    1bb4:	b0 91 21 06 	lds	r27, 0x0621
    1bb8:	c0 90 29 06 	lds	r12, 0x0629
    1bbc:	d0 90 2a 06 	lds	r13, 0x062A
    1bc0:	e0 90 2b 06 	lds	r14, 0x062B
    1bc4:	f0 90 2c 06 	lds	r15, 0x062C
    1bc8:	48 19       	sub	r20, r8
    1bca:	59 09       	sbc	r21, r9
    1bcc:	6a 09       	sbc	r22, r10
    1bce:	7b 09       	sbc	r23, r11
    1bd0:	8c 19       	sub	r24, r12
    1bd2:	9d 09       	sbc	r25, r13
    1bd4:	ae 09       	sbc	r26, r14
    1bd6:	bf 09       	sbc	r27, r15
    1bd8:	84 17       	cp	r24, r20
    1bda:	95 07       	cpc	r25, r21
    1bdc:	a6 07       	cpc	r26, r22
    1bde:	b7 07       	cpc	r27, r23
    1be0:	a0 f1       	brcs	.+104    	; 0x1c4a <UpdateAdjustedSampleAddresses+0x7cc>
    1be2:	15 c0       	rjmp	.+42     	; 0x1c0e <UpdateAdjustedSampleAddresses+0x790>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    1be4:	40 91 29 06 	lds	r20, 0x0629
    1be8:	50 91 2a 06 	lds	r21, 0x062A
    1bec:	60 91 2b 06 	lds	r22, 0x062B
    1bf0:	70 91 2c 06 	lds	r23, 0x062C
    1bf4:	80 91 22 06 	lds	r24, 0x0622
    1bf8:	90 91 23 06 	lds	r25, 0x0623
    1bfc:	a0 91 24 06 	lds	r26, 0x0624
    1c00:	b0 91 25 06 	lds	r27, 0x0625
    1c04:	84 17       	cp	r24, r20
    1c06:	95 07       	cpc	r25, r21
    1c08:	a6 07       	cpc	r26, r22
    1c0a:	b7 07       	cpc	r27, r23
    1c0c:	48 f4       	brcc	.+18     	; 0x1c20 <UpdateAdjustedSampleAddresses+0x7a2>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    1c0e:	80 91 22 06 	lds	r24, 0x0622
    1c12:	90 91 23 06 	lds	r25, 0x0623
    1c16:	a0 91 24 06 	lds	r26, 0x0624
    1c1a:	b0 91 25 06 	lds	r27, 0x0625
    1c1e:	1d c0       	rjmp	.+58     	; 0x1c5a <UpdateAdjustedSampleAddresses+0x7dc>
			}
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    1c20:	40 91 29 06 	lds	r20, 0x0629
    1c24:	50 91 2a 06 	lds	r21, 0x062A
    1c28:	60 91 2b 06 	lds	r22, 0x062B
    1c2c:	70 91 2c 06 	lds	r23, 0x062C
    1c30:	80 91 1e 06 	lds	r24, 0x061E
    1c34:	90 91 1f 06 	lds	r25, 0x061F
    1c38:	a0 91 20 06 	lds	r26, 0x0620
    1c3c:	b0 91 21 06 	lds	r27, 0x0621
    1c40:	48 17       	cp	r20, r24
    1c42:	59 07       	cpc	r21, r25
    1c44:	6a 07       	cpc	r22, r26
    1c46:	7b 07       	cpc	r23, r27
    1c48:	80 f4       	brcc	.+32     	; 0x1c6a <UpdateAdjustedSampleAddresses+0x7ec>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    1c4a:	80 91 1e 06 	lds	r24, 0x061E
    1c4e:	90 91 1f 06 	lds	r25, 0x061F
    1c52:	a0 91 20 06 	lds	r26, 0x0620
    1c56:	b0 91 21 06 	lds	r27, 0x0621
    1c5a:	80 93 29 06 	sts	0x0629, r24
    1c5e:	90 93 2a 06 	sts	0x062A, r25
    1c62:	a0 93 2b 06 	sts	0x062B, r26
    1c66:	b0 93 2c 06 	sts	0x062C, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    1c6a:	ef bf       	out	0x3f, r30	; 63
}
    1c6c:	ff 90       	pop	r15
    1c6e:	ef 90       	pop	r14
    1c70:	df 90       	pop	r13
    1c72:	cf 90       	pop	r12
    1c74:	bf 90       	pop	r11
    1c76:	af 90       	pop	r10
    1c78:	9f 90       	pop	r9
    1c7a:	8f 90       	pop	r8
    1c7c:	7f 90       	pop	r7
    1c7e:	6f 90       	pop	r6
    1c80:	5f 90       	pop	r5
    1c82:	4f 90       	pop	r4
    1c84:	08 95       	ret

00001c86 <RevertSampleToUnadjusted>:
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char
		sreg;

	sreg=SREG;
    1c86:	9f b7       	in	r25, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1c88:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    1c8a:	24 e2       	ldi	r18, 0x24	; 36
    1c8c:	82 9f       	mul	r24, r18
    1c8e:	f0 01       	movw	r30, r0
    1c90:	11 24       	eor	r1, r1
    1c92:	eb 51       	subi	r30, 0x1B	; 27
    1c94:	fa 4f       	sbci	r31, 0xFA	; 250
    1c96:	41 89       	ldd	r20, Z+17	; 0x11
    1c98:	52 89       	ldd	r21, Z+18	; 0x12
    1c9a:	63 89       	ldd	r22, Z+19	; 0x13
    1c9c:	74 89       	ldd	r23, Z+20	; 0x14
    1c9e:	41 8f       	std	Z+25, r20	; 0x19
    1ca0:	52 8f       	std	Z+26, r21	; 0x1a
    1ca2:	63 8f       	std	Z+27, r22	; 0x1b
    1ca4:	74 8f       	std	Z+28, r23	; 0x1c
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    1ca6:	45 85       	ldd	r20, Z+13	; 0x0d
    1ca8:	56 85       	ldd	r21, Z+14	; 0x0e
    1caa:	67 85       	ldd	r22, Z+15	; 0x0f
    1cac:	70 89       	ldd	r23, Z+16	; 0x10
    1cae:	45 8b       	std	Z+21, r20	; 0x15
    1cb0:	56 8b       	std	Z+22, r21	; 0x16
    1cb2:	67 8b       	std	Z+23, r22	; 0x17
    1cb4:	70 8f       	std	Z+24, r23	; 0x18
	bankStates[theBank].sampleStartOffset=0;
    1cb6:	15 8e       	std	Z+29, r1	; 0x1d
	bankStates[theBank].sampleEndOffset=0;
    1cb8:	16 8e       	std	Z+30, r1	; 0x1e
	bankStates[theBank].sampleWindowOffset=0;
    1cba:	17 8e       	std	Z+31, r1	; 0x1f
	SREG=sreg;		// Restore interrupts.
    1cbc:	9f bf       	out	0x3f, r25	; 63
    1cbe:	08 95       	ret

00001cc0 <BlinkLeds>:
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1cc0:	40 91 ae 05 	lds	r20, 0x05AE
    1cc4:	50 e0       	ldi	r21, 0x00	; 0
    1cc6:	90 91 5d 05 	lds	r25, 0x055D
    1cca:	20 e0       	ldi	r18, 0x00	; 0
    1ccc:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1cce:	61 e0       	ldi	r22, 0x01	; 1
    1cd0:	70 e0       	ldi	r23, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    1cd2:	da 01       	movw	r26, r20
    1cd4:	02 2e       	mov	r0, r18
    1cd6:	02 c0       	rjmp	.+4      	; 0x1cdc <BlinkLeds+0x1c>
    1cd8:	b5 95       	asr	r27
    1cda:	a7 95       	ror	r26
    1cdc:	0a 94       	dec	r0
    1cde:	e2 f7       	brpl	.-8      	; 0x1cd8 <BlinkLeds+0x18>
    1ce0:	a0 ff       	sbrs	r26, 0
    1ce2:	0a c0       	rjmp	.+20     	; 0x1cf8 <BlinkLeds+0x38>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    1ce4:	db 01       	movw	r26, r22
    1ce6:	02 2e       	mov	r0, r18
    1ce8:	02 c0       	rjmp	.+4      	; 0x1cee <BlinkLeds+0x2e>
    1cea:	aa 0f       	add	r26, r26
    1cec:	bb 1f       	adc	r27, r27
    1cee:	0a 94       	dec	r0
    1cf0:	e2 f7       	brpl	.-8      	; 0x1cea <BlinkLeds+0x2a>
    1cf2:	fd 01       	movw	r30, r26
    1cf4:	e0 95       	com	r30
    1cf6:	9e 23       	and	r25, r30
    1cf8:	2f 5f       	subi	r18, 0xFF	; 255
    1cfa:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    1cfc:	28 30       	cpi	r18, 0x08	; 8
    1cfe:	31 05       	cpc	r19, r1
    1d00:	41 f7       	brne	.-48     	; 0x1cd2 <BlinkLeds+0x12>
    1d02:	90 93 5d 05 	sts	0x055D, r25
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    1d06:	80 93 ae 05 	sts	0x05AE, r24
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    1d0a:	68 e9       	ldi	r22, 0x98	; 152
    1d0c:	70 e0       	ldi	r23, 0x00	; 0
    1d0e:	82 e0       	ldi	r24, 0x02	; 2
    1d10:	0c 94 17 1f 	jmp	0x3e2e	; 0x3e2e <SetTimer>

00001d14 <KillLeds>:
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    1d14:	10 92 5d 05 	sts	0x055D, r1
	BlinkLeds(0);		// Durrrr.....
    1d18:	80 e0       	ldi	r24, 0x00	; 0
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <BlinkLeds>

00001d20 <StopBlinking>:
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    1d20:	80 e0       	ldi	r24, 0x00	; 0
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <BlinkLeds>

00001d28 <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    1d28:	cf 93       	push	r28
	static unsigned char
		i;

	if(subState==SS_0)
    1d2a:	c0 91 5b 05 	lds	r28, 0x055B
    1d2e:	c1 11       	cpse	r28, r1
    1d30:	11 c0       	rjmp	.+34     	; 0x1d54 <DoFruitcakeIntro+0x2c>
	{
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    1d32:	10 92 59 05 	sts	0x0559, r1

		KillLeds();
    1d36:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
		i=0;
    1d3a:	10 92 5c 05 	sts	0x055C, r1
		ledOnOffMask=0;
    1d3e:	10 92 5d 05 	sts	0x055D, r1
		subState=SS_1;
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	80 93 5b 05 	sts	0x055B, r24
		SetTimer(TIMER_1,(SECOND/4));
    1d48:	61 e3       	ldi	r22, 0x31	; 49
    1d4a:	71 e0       	ldi	r23, 0x01	; 1
    1d4c:	80 e0       	ldi	r24, 0x00	; 0
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
}
    1d4e:	cf 91       	pop	r28

		KillLeds();
		i=0;
		ledOnOffMask=0;
		subState=SS_1;
		SetTimer(TIMER_1,(SECOND/4));
    1d50:	0c 94 17 1f 	jmp	0x3e2e	; 0x3e2e <SetTimer>
	}
	else if(subState==SS_1)
    1d54:	c1 30       	cpi	r28, 0x01	; 1
    1d56:	41 f4       	brne	.+16     	; 0x1d68 <DoFruitcakeIntro+0x40>
	{
		if(CheckTimer(TIMER_1))
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    1d5e:	88 23       	and	r24, r24
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <DoFruitcakeIntro+0x3c>
    1d62:	91 c0       	rjmp	.+290    	; 0x1e86 <DoFruitcakeIntro+0x15e>
		{
			subState=SS_2;
    1d64:	82 e0       	ldi	r24, 0x02	; 2
    1d66:	7b c0       	rjmp	.+246    	; 0x1e5e <DoFruitcakeIntro+0x136>
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}

	else if(subState==SS_2)
    1d68:	c2 30       	cpi	r28, 0x02	; 2
    1d6a:	09 f0       	breq	.+2      	; 0x1d6e <DoFruitcakeIntro+0x46>
    1d6c:	4a c0       	rjmp	.+148    	; 0x1e02 <DoFruitcakeIntro+0xda>
	{
		if(i<NUM_LEDS)
    1d6e:	80 91 5c 05 	lds	r24, 0x055C
    1d72:	88 30       	cpi	r24, 0x08	; 8
    1d74:	f8 f4       	brcc	.+62     	; 0x1db4 <DoFruitcakeIntro+0x8c>
		{
			if(CheckTimer(TIMER_1))
    1d76:	80 e0       	ldi	r24, 0x00	; 0
    1d78:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    1d7c:	88 23       	and	r24, r24
    1d7e:	09 f4       	brne	.+2      	; 0x1d82 <DoFruitcakeIntro+0x5a>
    1d80:	82 c0       	rjmp	.+260    	; 0x1e86 <DoFruitcakeIntro+0x15e>
			{
				ledOnOffMask|=(1<<i);
    1d82:	81 e0       	ldi	r24, 0x01	; 1
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	00 90 5c 05 	lds	r0, 0x055C
    1d8a:	02 c0       	rjmp	.+4      	; 0x1d90 <DoFruitcakeIntro+0x68>
    1d8c:	88 0f       	add	r24, r24
    1d8e:	99 1f       	adc	r25, r25
    1d90:	0a 94       	dec	r0
    1d92:	e2 f7       	brpl	.-8      	; 0x1d8c <DoFruitcakeIntro+0x64>
    1d94:	90 91 5d 05 	lds	r25, 0x055D
    1d98:	98 2b       	or	r25, r24
    1d9a:	90 93 5d 05 	sts	0x055D, r25
				SetTimer(TIMER_1,(SECOND/20));
    1d9e:	6d e3       	ldi	r22, 0x3D	; 61
    1da0:	70 e0       	ldi	r23, 0x00	; 0
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
				i++;
    1da8:	80 91 5c 05 	lds	r24, 0x055C
    1dac:	8f 5f       	subi	r24, 0xFF	; 255
    1dae:	80 93 5c 05 	sts	0x055C, r24
    1db2:	69 c0       	rjmp	.+210    	; 0x1e86 <DoFruitcakeIntro+0x15e>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    1db4:	80 e0       	ldi	r24, 0x00	; 0
    1db6:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    1dba:	88 23       	and	r24, r24
    1dbc:	09 f4       	brne	.+2      	; 0x1dc0 <DoFruitcakeIntro+0x98>
    1dbe:	63 c0       	rjmp	.+198    	; 0x1e86 <DoFruitcakeIntro+0x15e>
			{
				SetTimer(TIMER_1,(SECOND/8));
    1dc0:	68 e9       	ldi	r22, 0x98	; 152
    1dc2:	70 e0       	ldi	r23, 0x00	; 0
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
    1dc6:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
				ledPwm=255;
    1dca:	8f ef       	ldi	r24, 0xFF	; 255
    1dcc:	80 93 40 04 	sts	0x0440, r24
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    1dd0:	90 91 64 00 	lds	r25, 0x0064
    1dd4:	9f 7b       	andi	r25, 0xBF	; 191
    1dd6:	90 93 64 00 	sts	0x0064, r25

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    1dda:	c0 93 b0 00 	sts	0x00B0, r28
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    1dde:	91 e0       	ldi	r25, 0x01	; 1
    1de0:	90 93 b1 00 	sts	0x00B1, r25
				TCNT2=0;			// Init counter reg
    1de4:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    1de8:	90 e8       	ldi	r25, 0x80	; 128
    1dea:	90 93 b3 00 	sts	0x00B3, r25
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    1dee:	87 bb       	out	0x17, r24	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    1df0:	c0 93 70 00 	sts	0x0070, r28

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    1df4:	92 b1       	in	r25, 0x02	; 2
    1df6:	96 60       	ori	r25, 0x06	; 6
    1df8:	92 b9       	out	0x02, r25	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    1dfa:	84 b9       	out	0x04, r24	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    1dfc:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;
    1dfe:	83 e0       	ldi	r24, 0x03	; 3
    1e00:	2e c0       	rjmp	.+92     	; 0x1e5e <DoFruitcakeIntro+0x136>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_3)
    1e02:	c3 30       	cpi	r28, 0x03	; 3
    1e04:	79 f5       	brne	.+94     	; 0x1e64 <DoFruitcakeIntro+0x13c>
	{
		if(CheckTimer(TIMER_1))
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    1e0c:	88 23       	and	r24, r24
    1e0e:	d9 f1       	breq	.+118    	; 0x1e86 <DoFruitcakeIntro+0x15e>
		{
			if(ledPwm>1)
    1e10:	80 91 40 04 	lds	r24, 0x0440
    1e14:	82 30       	cpi	r24, 0x02	; 2
    1e16:	58 f0       	brcs	.+22     	; 0x1e2e <DoFruitcakeIntro+0x106>
			{
				ledPwm-=2;
    1e18:	80 91 40 04 	lds	r24, 0x0440
    1e1c:	82 50       	subi	r24, 0x02	; 2
    1e1e:	80 93 40 04 	sts	0x0440, r24
				SetTimer(TIMER_1,(SECOND/256));
    1e22:	64 e0       	ldi	r22, 0x04	; 4
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	80 e0       	ldi	r24, 0x00	; 0
    1e28:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
    1e2c:	2c c0       	rjmp	.+88     	; 0x1e86 <DoFruitcakeIntro+0x15e>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    1e2e:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports
    1e32:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    1e36:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.
    1e3a:	80 91 64 00 	lds	r24, 0x0064
    1e3e:	80 64       	ori	r24, 0x40	; 64
    1e40:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    1e44:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    1e46:	5f 98       	cbi	0x0b, 7	; 11

				KillLeds();				// App knows leds are off.
    1e48:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    1e4c:	82 e1       	ldi	r24, 0x12	; 18
    1e4e:	80 93 5d 05 	sts	0x055D, r24
				SetTimer(TIMER_1,(SECOND/2));
    1e52:	62 e6       	ldi	r22, 0x62	; 98
    1e54:	72 e0       	ldi	r23, 0x02	; 2
    1e56:	80 e0       	ldi	r24, 0x00	; 0
    1e58:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
				subState=SS_4;
    1e5c:	84 e0       	ldi	r24, 0x04	; 4
    1e5e:	80 93 5b 05 	sts	0x055B, r24
    1e62:	11 c0       	rjmp	.+34     	; 0x1e86 <DoFruitcakeIntro+0x15e>
			}
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
	}
	else if(subState==SS_4)
    1e64:	c4 30       	cpi	r28, 0x04	; 4
    1e66:	89 f4       	brne	.+34     	; 0x1e8a <DoFruitcakeIntro+0x162>
	{
		if(CheckTimer(TIMER_1))
    1e68:	80 e0       	ldi	r24, 0x00	; 0
    1e6a:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    1e6e:	88 23       	and	r24, r24
    1e70:	51 f0       	breq	.+20     	; 0x1e86 <DoFruitcakeIntro+0x15e>
		{
			KillLeds();
    1e72:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    1e76:	8f e6       	ldi	r24, 0x6F	; 111
    1e78:	91 e1       	ldi	r25, 0x11	; 17
    1e7a:	90 93 e4 05 	sts	0x05E4, r25
    1e7e:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    1e82:	10 92 5b 05 	sts	0x055B, r1
		if(CheckTimer(TIMER_1))
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
		cardState=SD_NOT_PRESENT;	// Don't allow card to come up while we're monkeying with the bus
    1e86:	10 92 59 05 	sts	0x0559, r1
	}
}
    1e8a:	cf 91       	pop	r28
    1e8c:	08 95       	ret

00001e8e <ResetSdCard>:
	SREG=sreg;	// Resume ISR
}

static void ResetSdCard(void)
// If we unceremoniously pull a card, do this.
{
    1e8e:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1e90:	cf b7       	in	r28, 0x3f	; 63
	cli();
    1e92:	f8 94       	cli
	
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
    1e94:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
    1e98:	ee e6       	ldi	r30, 0x6E	; 110
    1e9a:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    1e9c:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    1e9e:	85 e0       	ldi	r24, 0x05	; 5
    1ea0:	ee 3a       	cpi	r30, 0xAE	; 174
    1ea2:	f8 07       	cpc	r31, r24
    1ea4:	d9 f7       	brne	.-10     	; 0x1e9c <ResetSdCard+0xe>
	EndSdTransfer();		// Bring CS high.  This will fuck things up if the card is mid transfer.
	ClearSampleToc();
	
	// Stop SD card ISR

	sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    1ea6:	10 92 4f 05 	sts	0x054F, r1
	TCCR2B=0;					// Stop this timer
    1eaa:	10 92 b1 00 	sts	0x00B1, r1
	TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    1eae:	80 91 70 00 	lds	r24, 0x0070
    1eb2:	8b 7f       	andi	r24, 0xFB	; 251
    1eb4:	80 93 70 00 	sts	0x0070, r24

	// Set this contribution to the DAC to midscale (this output source is now quiet)
	sdStreamOutput=0;
    1eb8:	10 92 55 05 	sts	0x0555, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    1ebc:	10 92 2b 01 	sts	0x012B, r1
    1ec0:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    1ec4:	10 92 29 01 	sts	0x0129, r1
    1ec8:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    1ecc:	10 92 27 01 	sts	0x0127, r1
    1ed0:	10 92 26 01 	sts	0x0126, r1

	InitSdInterface();
    1ed4:	0e 94 37 21 	call	0x426e	; 0x426e <InitSdInterface>
	cardState=SD_NOT_PRESENT;	// Mark the card as st elsewhere
    1ed8:	10 92 59 05 	sts	0x0559, r1

	SREG=sreg;
    1edc:	cf bf       	out	0x3f, r28	; 63
}
    1ede:	cf 91       	pop	r28
    1ee0:	08 95       	ret

00001ee2 <SdStartSampleRead>:

static bool SdStartSampleRead(unsigned int sampleSlot)
// Initializes the state machine and FIFOs for reading in a sample from the SD into RAM.
// Begins a sample read in the correct spot.
// NOTE -- card must be present and not busy to do this.  Caller's reponsibility to check this.
{
    1ee2:	cf 92       	push	r12
    1ee4:	df 92       	push	r13
    1ee6:	ef 92       	push	r14
    1ee8:	ff 92       	push	r15
    1eea:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;
    1eec:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    1eee:	f8 94       	cli

	if(SdBeginSingleBlockRead(1+(sampleSlot*1024))==true)	// Try to open the card for a single block read (*1024 to give 512k sample slots)
    1ef0:	38 2f       	mov	r19, r24
    1ef2:	33 0f       	add	r19, r19
    1ef4:	33 0f       	add	r19, r19
    1ef6:	20 e0       	ldi	r18, 0x00	; 0
    1ef8:	69 01       	movw	r12, r18
    1efa:	8f ef       	ldi	r24, 0xFF	; 255
    1efc:	c8 1a       	sub	r12, r24
    1efe:	d8 0a       	sbc	r13, r24
    1f00:	e1 2c       	mov	r14, r1
    1f02:	f1 2c       	mov	r15, r1
    1f04:	c7 01       	movw	r24, r14
    1f06:	b6 01       	movw	r22, r12
    1f08:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <SdBeginSingleBlockRead>
    1f0c:	81 30       	cpi	r24, 0x01	; 1
    1f0e:	19 f5       	brne	.+70     	; 0x1f56 <SdStartSampleRead+0x74>
	{
		sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    1f10:	c0 92 b1 05 	sts	0x05B1, r12
    1f14:	d0 92 b2 05 	sts	0x05B2, r13
    1f18:	e0 92 b3 05 	sts	0x05B3, r14
    1f1c:	f0 92 b4 05 	sts	0x05B4, r15
		sdCurrentBlockOffset=0;						// Read first block first
    1f20:	10 92 b6 05 	sts	0x05B6, r1
    1f24:	10 92 b5 05 	sts	0x05B5, r1

		sdFifoReadPointer=0;		// Reset FIFO variables
    1f28:	10 92 2b 01 	sts	0x012B, r1
    1f2c:	10 92 2a 01 	sts	0x012A, r1
		sdFifoWritePointer=0;
    1f30:	10 92 29 01 	sts	0x0129, r1
    1f34:	10 92 28 01 	sts	0x0128, r1
		sdBytesInFifo=0;
    1f38:	10 92 27 01 	sts	0x0127, r1
    1f3c:	10 92 26 01 	sts	0x0126, r1

		SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    1f40:	6a e7       	ldi	r22, 0x7A	; 122
    1f42:	70 e0       	ldi	r23, 0x00	; 0
    1f44:	83 e0       	ldi	r24, 0x03	; 3
    1f46:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
		cardState=SD_READ_START;				// Read in the first sample block with the state machine
    1f4a:	89 e0       	ldi	r24, 0x09	; 9
    1f4c:	80 93 59 05 	sts	0x0559, r24

		SREG=sreg;	// Resume ISR
    1f50:	cf bf       	out	0x3f, r28	; 63

		return(true);
    1f52:	81 e0       	ldi	r24, 0x01	; 1
    1f54:	02 c0       	rjmp	.+4      	; 0x1f5a <SdStartSampleRead+0x78>
	}
	SREG=sreg;	// Resume ISR
    1f56:	cf bf       	out	0x3f, r28	; 63
	return(false);
    1f58:	80 e0       	ldi	r24, 0x00	; 0
}
    1f5a:	cf 91       	pop	r28
    1f5c:	ff 90       	pop	r15
    1f5e:	ef 90       	pop	r14
    1f60:	df 90       	pop	r13
    1f62:	cf 90       	pop	r12
    1f64:	08 95       	ret

00001f66 <SetSampleClock.part.0>:
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    1f66:	e1 e8       	ldi	r30, 0x81	; 129
    1f68:	f0 e0       	ldi	r31, 0x00	; 0
    1f6a:	80 81       	ld	r24, Z
    1f6c:	80 64       	ori	r24, 0x40	; 64
    1f6e:	80 83       	st	Z, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    1f70:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    1f72:	ef e6       	ldi	r30, 0x6F	; 111
    1f74:	f0 e0       	ldi	r31, 0x00	; 0
    1f76:	80 81       	ld	r24, Z
    1f78:	80 62       	ori	r24, 0x20	; 32
    1f7a:	80 83       	st	Z, r24
    1f7c:	08 95       	ret

00001f7e <SetSampleClock>:

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    1f7e:	94 e2       	ldi	r25, 0x24	; 36
    1f80:	89 9f       	mul	r24, r25
    1f82:	f0 01       	movw	r30, r0
    1f84:	11 24       	eor	r1, r1
    1f86:	eb 51       	subi	r30, 0x1B	; 27
    1f88:	fa 4f       	sbci	r31, 0xFA	; 250
    1f8a:	62 87       	std	Z+10, r22	; 0x0a

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    1f8c:	62 30       	cpi	r22, 0x02	; 2
    1f8e:	39 f5       	brne	.+78     	; 0x1fde <SetSampleClock+0x60>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1f90:	54 87       	std	Z+12, r21	; 0x0c
    1f92:	43 87       	std	Z+11, r20	; 0x0b

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1f94:	81 11       	cpse	r24, r1
    1f96:	0f c0       	rjmp	.+30     	; 0x1fb6 <SetSampleClock+0x38>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1f98:	80 91 84 00 	lds	r24, 0x0084
    1f9c:	90 91 85 00 	lds	r25, 0x0085
    1fa0:	84 0f       	add	r24, r20
    1fa2:	95 1f       	adc	r25, r21
    1fa4:	90 93 89 00 	sts	0x0089, r25
    1fa8:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1fac:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    1fae:	80 91 6f 00 	lds	r24, 0x006F
    1fb2:	82 60       	ori	r24, 0x02	; 2
    1fb4:	0e c0       	rjmp	.+28     	; 0x1fd2 <SetSampleClock+0x54>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.
    1fb6:	80 91 84 00 	lds	r24, 0x0084
    1fba:	90 91 85 00 	lds	r25, 0x0085
    1fbe:	84 0f       	add	r24, r20
    1fc0:	95 1f       	adc	r25, r21
    1fc2:	90 93 8b 00 	sts	0x008B, r25
    1fc6:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    1fca:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1fcc:	80 91 6f 00 	lds	r24, 0x006F
    1fd0:	84 60       	ori	r24, 0x04	; 4
    1fd2:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	80 93 81 00 	sts	0x0081, r24
    1fdc:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    1fde:	61 30       	cpi	r22, 0x01	; 1
    1fe0:	59 f4       	brne	.+22     	; 0x1ff8 <SetSampleClock+0x7a>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    1fe2:	81 11       	cpse	r24, r1
    1fe4:	02 c0       	rjmp	.+4      	; 0x1fea <SetSampleClock+0x6c>
    1fe6:	0c 94 b3 0f 	jmp	0x1f66	; 0x1f66 <SetSampleClock.part.0>
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    1fea:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    1fec:	84 e0       	ldi	r24, 0x04	; 4
    1fee:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    1ff2:	80 e1       	ldi	r24, 0x10	; 16
    1ff4:	80 93 6d 00 	sts	0x006D, r24
    1ff8:	08 95       	ret

00001ffa <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1ffa:	ff 92       	push	r15
    1ffc:	0f 93       	push	r16
    1ffe:	1f 93       	push	r17
    2000:	cf 93       	push	r28
    2002:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2004:	c8 2f       	mov	r28, r24
    2006:	d0 e0       	ldi	r29, 0x00	; 0
    2008:	94 e2       	ldi	r25, 0x24	; 36
    200a:	89 9f       	mul	r24, r25
    200c:	f0 01       	movw	r30, r0
    200e:	11 24       	eor	r1, r1
    2010:	eb 51       	subi	r30, 0x1B	; 27
    2012:	fa 4f       	sbci	r31, 0xFA	; 250
    2014:	95 81       	ldd	r25, Z+5	; 0x05
    2016:	99 23       	and	r25, r25
    2018:	29 f0       	breq	.+10     	; 0x2024 <StartPlayback+0x2a>
    201a:	90 91 4f 05 	lds	r25, 0x054F
    201e:	91 50       	subi	r25, 0x01	; 1
    2020:	92 30       	cpi	r25, 0x02	; 2
    2022:	80 f1       	brcs	.+96     	; 0x2084 <StartPlayback+0x8a>
	{
		sreg=SREG;	// Store global interrupt state.
    2024:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    2026:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    2028:	94 e2       	ldi	r25, 0x24	; 36
    202a:	9c 9f       	mul	r25, r28
    202c:	f0 01       	movw	r30, r0
    202e:	9d 9f       	mul	r25, r29
    2030:	f0 0d       	add	r31, r0
    2032:	11 24       	eor	r1, r1
    2034:	eb 51       	subi	r30, 0x1B	; 27
    2036:	fa 4f       	sbci	r31, 0xFA	; 250
    2038:	94 e0       	ldi	r25, 0x04	; 4
    203a:	90 83       	st	Z, r25

		if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    203c:	93 81       	ldd	r25, Z+3	; 0x03
    203e:	99 23       	and	r25, r25
    2040:	51 f0       	breq	.+20     	; 0x2056 <StartPlayback+0x5c>
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    2042:	05 89       	ldd	r16, Z+21	; 0x15
    2044:	16 89       	ldd	r17, Z+22	; 0x16
    2046:	27 89       	ldd	r18, Z+23	; 0x17
    2048:	30 8d       	ldd	r19, Z+24	; 0x18
    204a:	00 a3       	std	Z+32, r16	; 0x20
    204c:	11 a3       	std	Z+33, r17	; 0x21
    204e:	22 a3       	std	Z+34, r18	; 0x22
    2050:	33 a3       	std	Z+35, r19	; 0x23
			bankStates[theBank].sampleDirection=false;	// make us run backwards.
    2052:	14 82       	std	Z+4, r1	; 0x04
    2054:	0a c0       	rjmp	.+20     	; 0x206a <StartPlayback+0x70>
		}
		else
		{
			bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.
    2056:	01 8d       	ldd	r16, Z+25	; 0x19
    2058:	12 8d       	ldd	r17, Z+26	; 0x1a
    205a:	23 8d       	ldd	r18, Z+27	; 0x1b
    205c:	34 8d       	ldd	r19, Z+28	; 0x1c
    205e:	00 a3       	std	Z+32, r16	; 0x20
    2060:	11 a3       	std	Z+33, r17	; 0x21
    2062:	22 a3       	std	Z+34, r18	; 0x22
    2064:	33 a3       	std	Z+35, r19	; 0x23
			bankStates[theBank].sampleDirection=true;	// make us run forwards.
    2066:	91 e0       	ldi	r25, 0x01	; 1
    2068:	94 83       	std	Z+4, r25	; 0x04
		}

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    206a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    206e:	84 e2       	ldi	r24, 0x24	; 36
    2070:	8c 9f       	mul	r24, r28
    2072:	f0 01       	movw	r30, r0
    2074:	8d 9f       	mul	r24, r29
    2076:	f0 0d       	add	r31, r0
    2078:	11 24       	eor	r1, r1
    207a:	eb 51       	subi	r30, 0x1B	; 27
    207c:	fa 4f       	sbci	r31, 0xFA	; 250
    207e:	81 e0       	ldi	r24, 0x01	; 1
    2080:	85 83       	std	Z+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    2082:	ff be       	out	0x3f, r15	; 63
	}
}
    2084:	df 91       	pop	r29
    2086:	cf 91       	pop	r28
    2088:	1f 91       	pop	r17
    208a:	0f 91       	pop	r16
    208c:	ff 90       	pop	r15
    208e:	08 95       	ret

00002090 <ContinuePlayback>:

static void ContinuePlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Sets the clock source and ISR appropriately to do playback, but does not move the RAM pointer.
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
    2090:	1f 93       	push	r17
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    2096:	28 2f       	mov	r18, r24
    2098:	30 e0       	ldi	r19, 0x00	; 0
    209a:	94 e2       	ldi	r25, 0x24	; 36
    209c:	89 9f       	mul	r24, r25
    209e:	f0 01       	movw	r30, r0
    20a0:	11 24       	eor	r1, r1
    20a2:	eb 51       	subi	r30, 0x1B	; 27
    20a4:	fa 4f       	sbci	r31, 0xFA	; 250
    20a6:	95 81       	ldd	r25, Z+5	; 0x05
    20a8:	99 23       	and	r25, r25
    20aa:	29 f0       	breq	.+10     	; 0x20b6 <ContinuePlayback+0x26>
    20ac:	90 91 4f 05 	lds	r25, 0x054F
    20b0:	91 50       	subi	r25, 0x01	; 1
    20b2:	92 30       	cpi	r25, 0x02	; 2
    20b4:	88 f0       	brcs	.+34     	; 0x20d8 <ContinuePlayback+0x48>
	{
		sreg=SREG;	// Store global interrupt state.
    20b6:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    20b8:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    20ba:	94 e2       	ldi	r25, 0x24	; 36
    20bc:	92 9f       	mul	r25, r18
    20be:	e0 01       	movw	r28, r0
    20c0:	93 9f       	mul	r25, r19
    20c2:	d0 0d       	add	r29, r0
    20c4:	11 24       	eor	r1, r1
    20c6:	cb 51       	subi	r28, 0x1B	; 27
    20c8:	da 4f       	sbci	r29, 0xFA	; 250
    20ca:	94 e0       	ldi	r25, 0x04	; 4
    20cc:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    20ce:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    20d6:	1f bf       	out	0x3f, r17	; 63
	}
}
    20d8:	df 91       	pop	r29
    20da:	cf 91       	pop	r28
    20dc:	1f 91       	pop	r17
    20de:	08 95       	ret

000020e0 <StartRecording>:
static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009  --  ?
// Thu Nov 24 19:22:05 CST 2011  --  Still allow play/rec to step on each other, but don't allow them to abort SD RAM access since that could mess up files saved on the SD.
{
    20e0:	ff 92       	push	r15
    20e2:	0f 93       	push	r16
    20e4:	1f 93       	push	r17
    20e6:	cf 93       	push	r28
    20e8:	df 93       	push	r29

	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    20ea:	28 2f       	mov	r18, r24
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	94 e2       	ldi	r25, 0x24	; 36
    20f0:	89 9f       	mul	r24, r25
    20f2:	f0 01       	movw	r30, r0
    20f4:	11 24       	eor	r1, r1
    20f6:	eb 51       	subi	r30, 0x1B	; 27
    20f8:	fa 4f       	sbci	r31, 0xFA	; 250
    20fa:	95 81       	ldd	r25, Z+5	; 0x05
    20fc:	99 23       	and	r25, r25
    20fe:	31 f0       	breq	.+12     	; 0x210c <StartRecording+0x2c>
    2100:	90 91 4f 05 	lds	r25, 0x054F
    2104:	91 50       	subi	r25, 0x01	; 1
    2106:	92 30       	cpi	r25, 0x02	; 2
    2108:	08 f4       	brcc	.+2      	; 0x210c <StartRecording+0x2c>
    210a:	42 c0       	rjmp	.+132    	; 0x2190 <StartRecording+0xb0>
	{

		sreg=SREG;	// Store global interrupt state.
    210c:	ff b6       	in	r15, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    210e:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    2110:	94 e2       	ldi	r25, 0x24	; 36
    2112:	92 9f       	mul	r25, r18
    2114:	e0 01       	movw	r28, r0
    2116:	93 9f       	mul	r25, r19
    2118:	d0 0d       	add	r29, r0
    211a:	11 24       	eor	r1, r1
    211c:	cb 51       	subi	r28, 0x1B	; 27
    211e:	da 4f       	sbci	r29, 0xFA	; 250
    2120:	93 e0       	ldi	r25, 0x03	; 3
    2122:	98 83       	st	Y, r25

		bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    2124:	09 89       	ldd	r16, Y+17	; 0x11
    2126:	1a 89       	ldd	r17, Y+18	; 0x12
    2128:	2b 89       	ldd	r18, Y+19	; 0x13
    212a:	3c 89       	ldd	r19, Y+20	; 0x14
    212c:	08 a3       	std	Y+32, r16	; 0x20
    212e:	19 a3       	std	Y+33, r17	; 0x21
    2130:	2a a3       	std	Y+34, r18	; 0x22
    2132:	3b a3       	std	Y+35, r19	; 0x23
		bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    2134:	09 89       	ldd	r16, Y+17	; 0x11
    2136:	1a 89       	ldd	r17, Y+18	; 0x12
    2138:	2b 89       	ldd	r18, Y+19	; 0x13
    213a:	3c 89       	ldd	r19, Y+20	; 0x14
    213c:	0d 87       	std	Y+13, r16	; 0x0d
    213e:	1e 87       	std	Y+14, r17	; 0x0e
    2140:	2f 87       	std	Y+15, r18	; 0x0f
    2142:	38 8b       	std	Y+16, r19	; 0x10
		bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    2144:	09 89       	ldd	r16, Y+17	; 0x11
    2146:	1a 89       	ldd	r17, Y+18	; 0x12
    2148:	2b 89       	ldd	r18, Y+19	; 0x13
    214a:	3c 89       	ldd	r19, Y+20	; 0x14
    214c:	09 8f       	std	Y+25, r16	; 0x19
    214e:	1a 8f       	std	Y+26, r17	; 0x1a
    2150:	2b 8f       	std	Y+27, r18	; 0x1b
    2152:	3c 8f       	std	Y+28, r19	; 0x1c
		bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    2154:	09 89       	ldd	r16, Y+17	; 0x11
    2156:	1a 89       	ldd	r17, Y+18	; 0x12
    2158:	2b 89       	ldd	r18, Y+19	; 0x13
    215a:	3c 89       	ldd	r19, Y+20	; 0x14
    215c:	0d 8b       	std	Y+21, r16	; 0x15
    215e:	1e 8b       	std	Y+22, r17	; 0x16
    2160:	2f 8b       	std	Y+23, r18	; 0x17
    2162:	38 8f       	std	Y+24, r19	; 0x18
		bankStates[theBank].sampleWindowOffset=0;									// "
    2164:	1f 8e       	std	Y+31, r1	; 0x1f

		outOfRam=false;						// Plenty of ram left...
    2166:	10 92 3f 04 	sts	0x043F, r1

		SetSampleClock(theBank,theClock,theRate);	// Set the appropriate clock source for this audio function.
    216a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <SetSampleClock>
		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	8d 83       	std	Y+5, r24	; 0x05

		SREG=sreg;		// Restore interrupts.
    2172:	ff be       	out	0x3f, r15	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2174:	80 91 7a 00 	lds	r24, 0x007A
    2178:	86 fd       	sbrc	r24, 6
    217a:	0a c0       	rjmp	.+20     	; 0x2190 <StartRecording+0xb0>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    217c:	80 91 79 00 	lds	r24, 0x0079
    2180:	80 58       	subi	r24, 0x80	; 128
    2182:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2186:	80 91 7a 00 	lds	r24, 0x007A
    218a:	80 64       	ori	r24, 0x40	; 64
    218c:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    2190:	df 91       	pop	r29
    2192:	cf 91       	pop	r28
    2194:	1f 91       	pop	r17
    2196:	0f 91       	pop	r16
    2198:	ff 90       	pop	r15
    219a:	08 95       	ret

0000219c <StartOverdub>:
}

static void StartOverdub(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begin recording to ram at the current RAM address.
// Continue playing back from that address, too.
{
    219c:	1f 93       	push	r17
    219e:	cf 93       	push	r28
    21a0:	df 93       	push	r29
	unsigned char
		sreg;

	if((bankStates[theBank].isLocked==false)||((sdIsrState!=SD_ISR_LOADING_RAM)&&(sdIsrState!=SD_ISR_READING_RAM)))		// Check whether the bank is locked but ONLY BY SD FUNCTIONS.  Normal RAM play/rec functions can step on each other.
    21a2:	28 2f       	mov	r18, r24
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	94 e2       	ldi	r25, 0x24	; 36
    21a8:	89 9f       	mul	r24, r25
    21aa:	f0 01       	movw	r30, r0
    21ac:	11 24       	eor	r1, r1
    21ae:	eb 51       	subi	r30, 0x1B	; 27
    21b0:	fa 4f       	sbci	r31, 0xFA	; 250
    21b2:	95 81       	ldd	r25, Z+5	; 0x05
    21b4:	99 23       	and	r25, r25
    21b6:	29 f0       	breq	.+10     	; 0x21c2 <StartOverdub+0x26>
    21b8:	90 91 4f 05 	lds	r25, 0x054F
    21bc:	91 50       	subi	r25, 0x01	; 1
    21be:	92 30       	cpi	r25, 0x02	; 2
    21c0:	f8 f0       	brcs	.+62     	; 0x2200 <StartOverdub+0x64>
	{
		sreg=SREG;	// Store global interrupt state.
    21c2:	1f b7       	in	r17, 0x3f	; 63
		cli();		// Disable interrupts while we muck with the settings.
    21c4:	f8 94       	cli

		bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    21c6:	94 e2       	ldi	r25, 0x24	; 36
    21c8:	92 9f       	mul	r25, r18
    21ca:	e0 01       	movw	r28, r0
    21cc:	93 9f       	mul	r25, r19
    21ce:	d0 0d       	add	r29, r0
    21d0:	11 24       	eor	r1, r1
    21d2:	cb 51       	subi	r28, 0x1B	; 27
    21d4:	da 4f       	sbci	r29, 0xFA	; 250
    21d6:	95 e0       	ldi	r25, 0x05	; 5
    21d8:	98 83       	st	Y, r25
		SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    21da:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <SetSampleClock>

		bankStates[theBank].isLocked=true;			// Let program know we're using this RAM bank right now.
    21de:	81 e0       	ldi	r24, 0x01	; 1
    21e0:	8d 83       	std	Y+5, r24	; 0x05
		SREG=sreg;		// Restore interrupts.
    21e2:	1f bf       	out	0x3f, r17	; 63

		// Throw out the results of an old conversion since it could be very old (unless it's already going)
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    21e4:	80 91 7a 00 	lds	r24, 0x007A
    21e8:	86 fd       	sbrc	r24, 6
    21ea:	0a c0       	rjmp	.+20     	; 0x2200 <StartOverdub+0x64>
		{
			adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    21ec:	80 91 79 00 	lds	r24, 0x0079
    21f0:	80 58       	subi	r24, 0x80	; 128
    21f2:	80 93 2c 04 	sts	0x042C, r24
			ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    21f6:	80 91 7a 00 	lds	r24, 0x007A
    21fa:	80 64       	ori	r24, 0x40	; 64
    21fc:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    2200:	df 91       	pop	r29
    2202:	cf 91       	pop	r28
    2204:	1f 91       	pop	r17
    2206:	08 95       	ret

00002208 <StartRealtime>:

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
// Thu Nov 24 19:40:21 CST 2011
// OK to do realtime even when banks are locked since we don't use the RAM
{
    2208:	cf 93       	push	r28
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    220a:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    220c:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    220e:	94 e2       	ldi	r25, 0x24	; 36
    2210:	89 9f       	mul	r24, r25
    2212:	f0 01       	movw	r30, r0
    2214:	11 24       	eor	r1, r1
    2216:	eb 51       	subi	r30, 0x1B	; 27
    2218:	fa 4f       	sbci	r31, 0xFA	; 250
    221a:	92 e0       	ldi	r25, 0x02	; 2
    221c:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    221e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    2222:	cf bf       	out	0x3f, r28	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    2224:	80 91 7a 00 	lds	r24, 0x007A
    2228:	86 fd       	sbrc	r24, 6
    222a:	0a c0       	rjmp	.+20     	; 0x2240 <StartRealtime+0x38>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    222c:	80 91 79 00 	lds	r24, 0x0079
    2230:	80 58       	subi	r24, 0x80	; 128
    2232:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    2236:	80 91 7a 00 	lds	r24, 0x007A
    223a:	80 64       	ori	r24, 0x40	; 64
    223c:	80 93 7a 00 	sts	0x007A, r24
	}
}
    2240:	cf 91       	pop	r28
    2242:	08 95       	ret

00002244 <DoFormatCard>:

static void DoFormatCard(void)
// We get here if the card has something other than the WTPA filesystem on it (like, say, FAT16)
// Give the user the option to purge the card of its evil ways, and do so and reboot.
{
	if(subState==SS_0)
    2244:	80 91 5b 05 	lds	r24, 0x055B
    2248:	81 11       	cpse	r24, r1
    224a:	10 c0       	rjmp	.+32     	; 0x226c <DoFormatCard+0x28>
	{
		KillLeds();		// Turn off LEDs
    224c:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>

		bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop audio ISRs
    2250:	10 92 e5 05 	sts	0x05E5, r1
		bankStates[BANK_0].clockMode=CLK_NONE;
    2254:	10 92 ef 05 	sts	0x05EF, r1
		bankStates[BANK_1].audioFunction=AUDIO_IDLE;
    2258:	10 92 09 06 	sts	0x0609, r1
		bankStates[BANK_1].clockMode=CLK_NONE;
    225c:	10 92 13 06 	sts	0x0613, r1

		BlinkLeds((1<<LED_0)|(1<<LED_7));	// Blink Leds 0, 7 to show the user something serious is going down
    2260:	81 e8       	ldi	r24, 0x81	; 129
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <BlinkLeds>
		subState=SS_1;
    2268:	81 e0       	ldi	r24, 0x01	; 1
    226a:	13 c0       	rjmp	.+38     	; 0x2292 <DoFormatCard+0x4e>
	}
	else if(subState==SS_1)
    226c:	81 30       	cpi	r24, 0x01	; 1
    226e:	c9 f4       	brne	.+50     	; 0x22a2 <DoFormatCard+0x5e>
	{
		if((keyState&Im_SWITCH_0)&&(keyState&Im_SWITCH_7))	// Both buttons pressed?
    2270:	80 91 58 05 	lds	r24, 0x0558
    2274:	80 ff       	sbrs	r24, 0
    2276:	10 c0       	rjmp	.+32     	; 0x2298 <DoFormatCard+0x54>
    2278:	87 ff       	sbrs	r24, 7
    227a:	0e c0       	rjmp	.+28     	; 0x2298 <DoFormatCard+0x54>
		{
			cardState=SD_TOC_WRITE_START;	// Start TOC write
    227c:	86 e0       	ldi	r24, 0x06	; 6
    227e:	80 93 59 05 	sts	0x0559, r24
			KillLeds();
    2282:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
			ledOnOffMask|=(1<<LED_0)|(1<<LED_7);	// Turn both LEDs on while write occurs
    2286:	80 91 5d 05 	lds	r24, 0x055D
    228a:	81 68       	ori	r24, 0x81	; 129
    228c:	80 93 5d 05 	sts	0x055D, r24
			subState=SS_2;
    2290:	82 e0       	ldi	r24, 0x02	; 2
    2292:	80 93 5b 05 	sts	0x055B, r24
    2296:	08 95       	ret
		}
		else if(cardState==SD_NOT_PRESENT)	// We pulled the SD card.  Reset sampler
    2298:	80 91 59 05 	lds	r24, 0x0559
    229c:	81 11       	cpse	r24, r1
    229e:	1e c0       	rjmp	.+60     	; 0x22dc <DoFormatCard+0x98>
    22a0:	15 c0       	rjmp	.+42     	; 0x22cc <DoFormatCard+0x88>
		{
			SetState(DoFruitcakeIntro);	// Yep, start sampler over again.
		}
	}
	else if(subState==SS_2)
    22a2:	82 30       	cpi	r24, 0x02	; 2
    22a4:	d9 f4       	brne	.+54     	; 0x22dc <DoFormatCard+0x98>
	{
		if(cardState==SD_IDLE)	// Got what we wanted?
    22a6:	80 91 59 05 	lds	r24, 0x0559
    22aa:	8e 30       	cpi	r24, 0x0E	; 14
    22ac:	b9 f4       	brne	.+46     	; 0x22dc <DoFormatCard+0x98>
		{
			KillLeds();
    22ae:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
			ledOnOffMask|=(1<<LED_1);
    22b2:	80 91 5d 05 	lds	r24, 0x055D
    22b6:	82 60       	ori	r24, 0x02	; 2
    22b8:	80 93 5d 05 	sts	0x055D, r24
			if(cardState==SD_NOT_PRESENT||newKeys)		// We pulled the SD card or hit a key.
    22bc:	80 91 59 05 	lds	r24, 0x0559
    22c0:	88 23       	and	r24, r24
    22c2:	21 f0       	breq	.+8      	; 0x22cc <DoFormatCard+0x88>
    22c4:	80 91 57 05 	lds	r24, 0x0557
    22c8:	88 23       	and	r24, r24
    22ca:	41 f0       	breq	.+16     	; 0x22dc <DoFormatCard+0x98>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    22cc:	84 e9       	ldi	r24, 0x94	; 148
    22ce:	9e e0       	ldi	r25, 0x0E	; 14
    22d0:	90 93 e4 05 	sts	0x05E4, r25
    22d4:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    22d8:	10 92 5b 05 	sts	0x055B, r1
    22dc:	08 95       	ret

000022de <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    22de:	80 91 5b 05 	lds	r24, 0x055B
    22e2:	81 11       	cpse	r24, r1
    22e4:	08 c0       	rjmp	.+16     	; 0x22f6 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    22e6:	68 e9       	ldi	r22, 0x98	; 152
    22e8:	70 e0       	ldi	r23, 0x00	; 0
    22ea:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
		subState=SS_1;
    22ee:	81 e0       	ldi	r24, 0x01	; 1
    22f0:	80 93 5b 05 	sts	0x055B, r24
    22f4:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    22fc:	88 23       	and	r24, r24
    22fe:	a1 f0       	breq	.+40     	; 0x2328 <DoStartupSelect+0x4a>
		{
			if(keyState&Im_SWITCH_0)
    2300:	80 91 58 05 	lds	r24, 0x0558
    2304:	80 ff       	sbrs	r24, 0
    2306:	03 c0       	rjmp	.+6      	; 0x230e <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2308:	85 ef       	ldi	r24, 0xF5	; 245
    230a:	93 e1       	ldi	r25, 0x13	; 19
    230c:	07 c0       	rjmp	.+14     	; 0x231c <DoStartupSelect+0x3e>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    230e:	85 ff       	sbrs	r24, 5
    2310:	03 c0       	rjmp	.+6      	; 0x2318 <DoStartupSelect+0x3a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2312:	89 e0       	ldi	r24, 0x09	; 9
    2314:	95 e1       	ldi	r25, 0x15	; 21
    2316:	02 c0       	rjmp	.+4      	; 0x231c <DoStartupSelect+0x3e>
    2318:	8c e6       	ldi	r24, 0x6C	; 108
    231a:	94 e1       	ldi	r25, 0x14	; 20
    231c:	90 93 e4 05 	sts	0x05E4, r25
    2320:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    2324:	10 92 5b 05 	sts	0x055B, r1
    2328:	08 95       	ret

0000232a <PlaySampleFromSd>:
	}
}

static void PlaySampleFromSd(unsigned int theSlot)
// Reads a sample from the SD directly, and plays it without putting it in RAM first.  The sample is passed out through its own ISR.
{
    232a:	cf 93       	push	r28
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    232c:	20 91 59 05 	lds	r18, 0x0559
    2330:	2e 30       	cpi	r18, 0x0E	; 14
    2332:	09 f4       	brne	.+2      	; 0x2336 <PlaySampleFromSd+0xc>
    2334:	06 c0       	rjmp	.+12     	; 0x2342 <PlaySampleFromSd+0x18>
		sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
		SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM

		SREG=sreg;	// resume isr
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// If we are already playing a sample from the SD, abort current SD stream, start new one
    2336:	30 91 4f 05 	lds	r19, 0x054F
    233a:	33 30       	cpi	r19, 0x03	; 3
    233c:	b1 f5       	brne	.+108    	; 0x23aa <PlaySampleFromSd+0x80>
	// This requires finishing the current block read.  To not stop the audio ISRs and also not fuck up MIDI or encoders this requires some creativity in the SD state machine
	{
		if(cardState==SD_READ_FIFO_WAIT)	// Are we mid block read?  If not, and we're waiting for the FIFO, we can just abort and restart -- NOTE: we spend a lot of time waiting for the FIFO (the majority in some cases) so this happens often
    233e:	2b 30       	cpi	r18, 0x0B	; 11
    2340:	a1 f4       	brne	.+40     	; 0x236a <PlaySampleFromSd+0x40>
		{
			sreg=SREG;	 // Pause ISRs
    2342:	cf b7       	in	r28, 0x3f	; 63
			cli();
    2344:	f8 94       	cli

			SdStartSampleRead(theSlot);	// Open the SD for writing and init the fifo
    2346:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;  // Must be not-zero when the ISR is triggered, since having zero bytes left to transfer to RAM is how we test to see if we're done in the ISR.  We will put a real number here before we fill the FIFO
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	a0 e0       	ldi	r26, 0x00	; 0
    2350:	b0 e0       	ldi	r27, 0x00	; 0
    2352:	80 93 22 01 	sts	0x0122, r24
    2356:	90 93 23 01 	sts	0x0123, r25
    235a:	a0 93 24 01 	sts	0x0124, r26
    235e:	b0 93 25 01 	sts	0x0125, r27
			SdIsrStartStreamingAudio();	// Begin kicking out audio, do not lock RAM
    2362:	0e 94 03 09 	call	0x1206	; 0x1206 <SdIsrStartStreamingAudio>

			SREG=sreg;	// resume isr
    2366:	cf bf       	out	0x3f, r28	; 63
    2368:	20 c0       	rjmp	.+64     	; 0x23aa <PlaySampleFromSd+0x80>
		}
		else if(cardState==SD_READ_ABORT||sdAbortRead==true)	// We got a new play command while cleaning up a read in progress.  Keep cleaning the old read, but update the next sound in the queue with the most recent one.
    236a:	2d 30       	cpi	r18, 0x0D	; 13
    236c:	21 f0       	breq	.+8      	; 0x2376 <PlaySampleFromSd+0x4c>
    236e:	20 91 b7 05 	lds	r18, 0x05B7
    2372:	21 30       	cpi	r18, 0x01	; 1
    2374:	29 f4       	brne	.+10     	; 0x2380 <PlaySampleFromSd+0x56>
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    2376:	90 93 b9 05 	sts	0x05B9, r25
    237a:	80 93 b8 05 	sts	0x05B8, r24
    237e:	15 c0       	rjmp	.+42     	; 0x23aa <PlaySampleFromSd+0x80>
		}
		else	// Block is open for reading, so set up the SD state machine to end the read gracefully (and quickly) and then start the next one.
		{
//			sdQueuedBank=theBank;		// Store next bank to operate on once we finish the current block
			sdQueuedSlot=theSlot;		// Store the slot to read from once we finish the current block
    2380:	90 93 b9 05 	sts	0x05B9, r25
    2384:	80 93 b8 05 	sts	0x05B8, r24
			sdPlaybackQueued=true;		// Let abort routine know to re-trigger playback once abort is done.
    2388:	81 e0       	ldi	r24, 0x01	; 1
    238a:	80 93 ba 05 	sts	0x05BA, r24
			sdAbortRead=true;			// Let the state machine know to abort the read when it is safe to do so (ie, not waiting for a token) -- Mark the state machine to finish this block as fast as possible and throw out the data
    238e:	80 93 b7 05 	sts	0x05B7, r24

			sreg=SREG;	 		// Pause ISRs
    2392:	9f b7       	in	r25, 0x3f	; 63
			cli();
    2394:	f8 94       	cli
			sdBytesInFifo=0;		// Clear the FIFO so we don't mess with samples anymore
    2396:	10 92 27 01 	sts	0x0127, r1
    239a:	10 92 26 01 	sts	0x0126, r1
			TIMSK2&=~(1<<OCIE2B);	// Stop isr until we need it again
    239e:	80 91 70 00 	lds	r24, 0x0070
    23a2:	8b 7f       	andi	r24, 0xFB	; 251
    23a4:	80 93 70 00 	sts	0x0070, r24
			SREG=sreg;
    23a8:	9f bf       	out	0x3f, r25	; 63
		}
	}
}
    23aa:	cf 91       	pop	r28
    23ac:	08 95       	ret

000023ae <SdCardMenu>:
// NOTE:  Load and Save functions apply to the bank currently selected.

// Button		0			1			2			3			4			5			6			7
// -------------------------------------------------------------------------------------------------------------------
// No Shift:	Play		Load		Save		Delete		Exit		Exit		Exit		Exit
{
    23ae:	ef 92       	push	r14
    23b0:	ff 92       	push	r15
    23b2:	0f 93       	push	r16
    23b4:	1f 93       	push	r17
    23b6:	cf 93       	push	r28
    23b8:	df 93       	push	r29
	if(subState==SS_0)		// Initialize LEDs and slots
    23ba:	80 91 5b 05 	lds	r24, 0x055B
    23be:	81 11       	cpse	r24, r1
    23c0:	23 c0       	rjmp	.+70     	; 0x2408 <SdCardMenu+0x5a>
	{		
		if(sdCurrentSlot>127)		// Max slot we can handle with the user interface
    23c2:	80 91 63 05 	lds	r24, 0x0563
    23c6:	90 91 64 05 	lds	r25, 0x0564
    23ca:	80 38       	cpi	r24, 0x80	; 128
    23cc:	91 05       	cpc	r25, r1
    23ce:	30 f0       	brcs	.+12     	; 0x23dc <SdCardMenu+0x2e>
		{
			sdCurrentSlot=127;
    23d0:	8f e7       	ldi	r24, 0x7F	; 127
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	90 93 64 05 	sts	0x0564, r25
    23d8:	80 93 63 05 	sts	0x0563, r24
		}		

		ledOnOffMask=sdCurrentSlot;		// Turn on the LEDs corresponding to the slot we're currently looking at
    23dc:	80 91 63 05 	lds	r24, 0x0563
    23e0:	80 93 5d 05 	sts	0x055D, r24
		StopBlinking();					// Make sure nothing is errantly blinking
    23e4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>

		if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
    23e8:	80 91 63 05 	lds	r24, 0x0563
    23ec:	90 91 64 05 	lds	r25, 0x0564
    23f0:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    23f4:	88 23       	and	r24, r24
    23f6:	21 f0       	breq	.+8      	; 0x2400 <SdCardMenu+0x52>
		{
			BlinkLeds(1<<LED_7);
    23f8:	80 e8       	ldi	r24, 0x80	; 128
    23fa:	90 e0       	ldi	r25, 0x00	; 0
    23fc:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <BlinkLeds>
		}	

		subState=SS_1;
    2400:	81 e0       	ldi	r24, 0x01	; 1
    2402:	80 93 5b 05 	sts	0x055B, r24
    2406:	ea c1       	rjmp	.+980    	; 0x27dc <SdCardMenu+0x42e>
	}
	else
	{
		if(cardDetect==false||cardState==SD_INVALID)	//Bail if SD card removed or becomes invalid
    2408:	90 91 5a 05 	lds	r25, 0x055A
    240c:	80 91 59 05 	lds	r24, 0x0559
    2410:	99 23       	and	r25, r25
    2412:	19 f0       	breq	.+6      	; 0x241a <SdCardMenu+0x6c>
    2414:	8f 30       	cpi	r24, 0x0F	; 15
    2416:	39 f4       	brne	.+14     	; 0x2426 <SdCardMenu+0x78>
    2418:	03 c0       	rjmp	.+6      	; 0x2420 <SdCardMenu+0x72>
		{
			if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    241a:	88 23       	and	r24, r24
    241c:	09 f4       	brne	.+2      	; 0x2420 <SdCardMenu+0x72>
    241e:	d4 c1       	rjmp	.+936    	; 0x27c8 <SdCardMenu+0x41a>
			{
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
    2420:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <ResetSdCard>
    2424:	d1 c1       	rjmp	.+930    	; 0x27c8 <SdCardMenu+0x41a>
			KillLeds();				// Exit menu
			SetState(DoSampler);
		}
		else
		{
			if(newEncoder)		// Increment or decrement card slot if encoder moves
    2426:	80 91 6b 05 	lds	r24, 0x056B
    242a:	88 23       	and	r24, r24
    242c:	e9 f1       	breq	.+122    	; 0x24a8 <SdCardMenu+0xfa>
			{
				if(encoderCw)
    242e:	80 91 af 05 	lds	r24, 0x05AF
    2432:	88 23       	and	r24, r24
    2434:	89 f0       	breq	.+34     	; 0x2458 <SdCardMenu+0xaa>
				{
					sdCurrentSlot++;
    2436:	80 91 63 05 	lds	r24, 0x0563
    243a:	90 91 64 05 	lds	r25, 0x0564
    243e:	01 96       	adiw	r24, 0x01	; 1
    2440:	90 93 64 05 	sts	0x0564, r25
    2444:	80 93 63 05 	sts	0x0563, r24
					if(sdCurrentSlot>127)
    2448:	80 38       	cpi	r24, 0x80	; 128
    244a:	91 05       	cpc	r25, r1
    244c:	b8 f0       	brcs	.+46     	; 0x247c <SdCardMenu+0xce>
					{
						sdCurrentSlot=0;
    244e:	10 92 64 05 	sts	0x0564, r1
    2452:	10 92 63 05 	sts	0x0563, r1
    2456:	12 c0       	rjmp	.+36     	; 0x247c <SdCardMenu+0xce>
					}
				}
				else if(encoderCcw)
    2458:	80 91 b0 05 	lds	r24, 0x05B0
    245c:	88 23       	and	r24, r24
    245e:	71 f0       	breq	.+28     	; 0x247c <SdCardMenu+0xce>
				{
					if(sdCurrentSlot==0)
    2460:	80 91 63 05 	lds	r24, 0x0563
    2464:	90 91 64 05 	lds	r25, 0x0564
    2468:	00 97       	sbiw	r24, 0x00	; 0
    246a:	19 f4       	brne	.+6      	; 0x2472 <SdCardMenu+0xc4>
					{
						sdCurrentSlot=127;
    246c:	8f e7       	ldi	r24, 0x7F	; 127
    246e:	90 e0       	ldi	r25, 0x00	; 0
    2470:	01 c0       	rjmp	.+2      	; 0x2474 <SdCardMenu+0xc6>
					}
					else
					{
						sdCurrentSlot--;
    2472:	01 97       	sbiw	r24, 0x01	; 1
    2474:	90 93 64 05 	sts	0x0564, r25
    2478:	80 93 63 05 	sts	0x0563, r24
					}
				}

				ledOnOffMask=sdCurrentSlot;		
    247c:	80 91 63 05 	lds	r24, 0x0563
    2480:	90 91 64 05 	lds	r25, 0x0564
    2484:	80 93 5d 05 	sts	0x055D, r24
				if(CheckSdSlotFull(sdCurrentSlot))		// Blink LED_7 if the slot is full.
    2488:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    248c:	88 23       	and	r24, r24
    248e:	29 f0       	breq	.+10     	; 0x249a <SdCardMenu+0xec>
				{
					BlinkLeds(1<<LED_7);
    2490:	80 e8       	ldi	r24, 0x80	; 128
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <BlinkLeds>
    2498:	07 c0       	rjmp	.+14     	; 0x24a8 <SdCardMenu+0xfa>
				}	
				else
				{
					StopBlinking();
    249a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>
					ledOnOffMask&=~(1<<LED_7);
    249e:	80 91 5d 05 	lds	r24, 0x055D
    24a2:	8f 77       	andi	r24, 0x7F	; 127
    24a4:	80 93 5d 05 	sts	0x055D, r24
				}
			}

			if(newKeys&Im_SWITCH_0)		// Stream sample
    24a8:	80 91 57 05 	lds	r24, 0x0557
    24ac:	80 ff       	sbrs	r24, 0
    24ae:	0c c0       	rjmp	.+24     	; 0x24c8 <SdCardMenu+0x11a>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    24b0:	c0 91 63 05 	lds	r28, 0x0563
    24b4:	d0 91 64 05 	lds	r29, 0x0564
    24b8:	ce 01       	movw	r24, r28
    24ba:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    24be:	88 23       	and	r24, r24
    24c0:	19 f0       	breq	.+6      	; 0x24c8 <SdCardMenu+0x11a>
				{		
					PlaySampleFromSd(sdCurrentSlot);
    24c2:	ce 01       	movw	r24, r28
    24c4:	0e 94 95 11 	call	0x232a	; 0x232a <PlaySampleFromSd>
				}
			}		
			if(newKeys&Im_SWITCH_1)		// Load sample from SD card into the current bank
    24c8:	80 91 57 05 	lds	r24, 0x0557
    24cc:	81 ff       	sbrs	r24, 1
    24ce:	5d c0       	rjmp	.+186    	; 0x258a <SdCardMenu+0x1dc>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    24d0:	00 91 63 05 	lds	r16, 0x0563
    24d4:	10 91 64 05 	lds	r17, 0x0564
    24d8:	c8 01       	movw	r24, r16
    24da:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    24de:	88 23       	and	r24, r24
    24e0:	09 f4       	brne	.+2      	; 0x24e4 <SdCardMenu+0x136>
    24e2:	53 c0       	rjmp	.+166    	; 0x258a <SdCardMenu+0x1dc>
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
    24e4:	f0 90 62 05 	lds	r15, 0x0562
// Uses the ISRs and the internal clock for the passed bank to read in the sample from the SD card to RAM.
{
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    24e8:	80 91 59 05 	lds	r24, 0x0559
    24ec:	8e 30       	cpi	r24, 0x0E	; 14
    24ee:	09 f0       	breq	.+2      	; 0x24f2 <SdCardMenu+0x144>
    24f0:	4c c0       	rjmp	.+152    	; 0x258a <SdCardMenu+0x1dc>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    24f2:	24 e2       	ldi	r18, 0x24	; 36
    24f4:	f2 9e       	mul	r15, r18
    24f6:	e0 01       	movw	r28, r0
    24f8:	11 24       	eor	r1, r1
    24fa:	cb 51       	subi	r28, 0x1B	; 27
    24fc:	da 4f       	sbci	r29, 0xFA	; 250
    24fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2500:	81 11       	cpse	r24, r1
    2502:	43 c0       	rjmp	.+134    	; 0x258a <SdCardMenu+0x1dc>
		{
			sreg=SREG;
    2504:	ef b6       	in	r14, 0x3f	; 63
			cli();		// Pause ISR
    2506:	f8 94       	cli

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
    2508:	c8 01       	movw	r24, r16
    250a:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <SdStartSampleRead>
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
    250e:	81 e0       	ldi	r24, 0x01	; 1
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	a0 e0       	ldi	r26, 0x00	; 0
    2514:	b0 e0       	ldi	r27, 0x00	; 0
    2516:	80 93 22 01 	sts	0x0122, r24
    251a:	90 93 23 01 	sts	0x0123, r25
    251e:	a0 93 24 01 	sts	0x0124, r26
    2522:	b0 93 25 01 	sts	0x0125, r27
// Tell it to take the bytes in the SD buffer and put them into SRAM in the passed bank.
{
	unsigned char
		sreg;

	sreg=SREG;
    2526:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Pause ISRs
    2528:	f8 94       	cli

	sdIsrState=SD_ISR_LOADING_RAM;		// Take bytes from the SD buffer as they come in and put them in the SRAM
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    2530:	8d 83       	std	Y+5, r24	; 0x05

	if(theBank==BANK_0)		// Pointing at this bank?
    2532:	f1 10       	cpse	r15, r1
    2534:	0b c0       	rjmp	.+22     	; 0x254c <SdCardMenu+0x19e>
	{
		sdBank0=true;
    2536:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    253a:	10 92 50 05 	sts	0x0550, r1
    253e:	10 92 51 05 	sts	0x0551, r1
    2542:	10 92 52 05 	sts	0x0552, r1
    2546:	10 92 53 05 	sts	0x0553, r1
    254a:	0e c0       	rjmp	.+28     	; 0x2568 <SdCardMenu+0x1ba>
	}
	else
	{
		sdBank0=false;
    254c:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    2550:	8f ef       	ldi	r24, 0xFF	; 255
    2552:	9f ef       	ldi	r25, 0xFF	; 255
    2554:	a7 e0       	ldi	r26, 0x07	; 7
    2556:	b0 e0       	ldi	r27, 0x00	; 0
    2558:	80 93 50 05 	sts	0x0550, r24
    255c:	90 93 51 05 	sts	0x0551, r25
    2560:	a0 93 52 05 	sts	0x0552, r26
    2564:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    2568:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    256c:	81 e6       	ldi	r24, 0x61	; 97
    256e:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2572:	8f ef       	ldi	r24, 0xFF	; 255
    2574:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2576:	80 91 70 00 	lds	r24, 0x0070
    257a:	84 60       	ori	r24, 0x04	; 4
    257c:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2580:	82 e0       	ldi	r24, 0x02	; 2
    2582:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    2586:	2f bf       	out	0x3f, r18	; 63

			SdStartSampleRead(theSlot);				// Open the SD state machine for reading from the card, init fifo
			sdRamSampleRemaining=0x01;				// Ending condition for ISR is no bytes remaining, so set this non-zero until we reas in the real number
			SdIsrStartWritingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    2588:	ef be       	out	0x3f, r14	; 63
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					ReadSampleFromSd(currentBank,sdCurrentSlot);
				}
			}		
			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
    258a:	80 91 57 05 	lds	r24, 0x0557
    258e:	82 ff       	sbrs	r24, 2
    2590:	e1 c0       	rjmp	.+450    	; 0x2754 <SdCardMenu+0x3a6>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something in the bank?
    2592:	e0 91 62 05 	lds	r30, 0x0562
    2596:	2e 2f       	mov	r18, r30
    2598:	30 e0       	ldi	r19, 0x00	; 0
    259a:	44 e2       	ldi	r20, 0x24	; 36
    259c:	e4 9f       	mul	r30, r20
    259e:	e0 01       	movw	r28, r0
    25a0:	11 24       	eor	r1, r1
    25a2:	cb 51       	subi	r28, 0x1B	; 27
    25a4:	da 4f       	sbci	r29, 0xFA	; 250
    25a6:	49 89       	ldd	r20, Y+17	; 0x11
    25a8:	5a 89       	ldd	r21, Y+18	; 0x12
    25aa:	6b 89       	ldd	r22, Y+19	; 0x13
    25ac:	7c 89       	ldd	r23, Y+20	; 0x14
    25ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    25b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    25b2:	af 85       	ldd	r26, Y+15	; 0x0f
    25b4:	b8 89       	ldd	r27, Y+16	; 0x10
    25b6:	48 17       	cp	r20, r24
    25b8:	59 07       	cpc	r21, r25
    25ba:	6a 07       	cpc	r22, r26
    25bc:	7b 07       	cpc	r23, r27
    25be:	09 f4       	brne	.+2      	; 0x25c2 <SdCardMenu+0x214>
    25c0:	c9 c0       	rjmp	.+402    	; 0x2754 <SdCardMenu+0x3a6>
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
    25c2:	10 91 63 05 	lds	r17, 0x0563
    25c6:	00 91 64 05 	lds	r16, 0x0564
	unsigned long
		theLength;
	unsigned char
		sreg;

	if(cardState==SD_IDLE)	// SD card must be ready to do any of this
    25ca:	80 91 59 05 	lds	r24, 0x0559
    25ce:	8e 30       	cpi	r24, 0x0E	; 14
    25d0:	09 f0       	breq	.+2      	; 0x25d4 <SdCardMenu+0x226>
    25d2:	bc c0       	rjmp	.+376    	; 0x274c <SdCardMenu+0x39e>
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
    25d4:	8d 81       	ldd	r24, Y+5	; 0x05
    25d6:	81 11       	cpse	r24, r1
    25d8:	b9 c0       	rjmp	.+370    	; 0x274c <SdCardMenu+0x39e>
	unsigned long
		theLength;

	if(theBank==BANK_0)
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    25da:	8f 81       	ldd	r24, Y+7	; 0x07
// Returns the length of the sample, handles my laziness.
{
	unsigned long
		theLength;

	if(theBank==BANK_0)
    25dc:	e1 11       	cpse	r30, r1
    25de:	10 c0       	rjmp	.+32     	; 0x2600 <SdCardMenu+0x252>
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    25e0:	81 11       	cpse	r24, r1
    25e2:	09 c0       	rjmp	.+18     	; 0x25f6 <SdCardMenu+0x248>
		{
			theLength=((bankStates[theBank].adjustedEndAddress)-(bankStates[theBank].adjustedStartAddress))+1;		// ### does this work if they adjust backwards?  I think but I cant remember @@@ also, end is INCLUSIVE, right?
    25e4:	8d 89       	ldd	r24, Y+21	; 0x15
    25e6:	9e 89       	ldd	r25, Y+22	; 0x16
    25e8:	af 89       	ldd	r26, Y+23	; 0x17
    25ea:	b8 8d       	ldd	r27, Y+24	; 0x18
    25ec:	49 8d       	ldd	r20, Y+25	; 0x19
    25ee:	5a 8d       	ldd	r21, Y+26	; 0x1a
    25f0:	6b 8d       	ldd	r22, Y+27	; 0x1b
    25f2:	7c 8d       	ldd	r23, Y+28	; 0x1c
    25f4:	0f c0       	rjmp	.+30     	; 0x2614 <SdCardMenu+0x266>
		}
		else
		{
			theLength=bankStates[theBank].endAddress;	// Starts at zero and isn't edited so this is the length
    25f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    25f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    25fa:	af 85       	ldd	r26, Y+15	; 0x0f
    25fc:	b8 89       	ldd	r27, Y+16	; 0x10
    25fe:	1a c0       	rjmp	.+52     	; 0x2634 <SdCardMenu+0x286>
		}
	}
	else
	{
		if(bankStates[theBank].granularSlices==0)	// Granular uses full sample now @@@
    2600:	81 11       	cpse	r24, r1
    2602:	0c c0       	rjmp	.+24     	; 0x261c <SdCardMenu+0x26e>
		{
			theLength=((bankStates[theBank].adjustedStartAddress)-(bankStates[theBank].adjustedEndAddress))+1;		// bank one grows upside down. ### does this work if they tweak backwards?  I think but I cant remember
    2604:	89 8d       	ldd	r24, Y+25	; 0x19
    2606:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2608:	ab 8d       	ldd	r26, Y+27	; 0x1b
    260a:	bc 8d       	ldd	r27, Y+28	; 0x1c
    260c:	4d 89       	ldd	r20, Y+21	; 0x15
    260e:	5e 89       	ldd	r21, Y+22	; 0x16
    2610:	6f 89       	ldd	r22, Y+23	; 0x17
    2612:	78 8d       	ldd	r23, Y+24	; 0x18
    2614:	01 96       	adiw	r24, 0x01	; 1
    2616:	a1 1d       	adc	r26, r1
    2618:	b1 1d       	adc	r27, r1
    261a:	08 c0       	rjmp	.+16     	; 0x262c <SdCardMenu+0x27e>
		}
		else
		{
			theLength=bankStates[theBank].startAddress-bankStates[theBank].endAddress;	// grows down
    261c:	89 89       	ldd	r24, Y+17	; 0x11
    261e:	9a 89       	ldd	r25, Y+18	; 0x12
    2620:	ab 89       	ldd	r26, Y+19	; 0x13
    2622:	bc 89       	ldd	r27, Y+20	; 0x14
    2624:	4d 85       	ldd	r20, Y+13	; 0x0d
    2626:	5e 85       	ldd	r21, Y+14	; 0x0e
    2628:	6f 85       	ldd	r22, Y+15	; 0x0f
    262a:	78 89       	ldd	r23, Y+16	; 0x10
    262c:	84 1b       	sub	r24, r20
    262e:	95 0b       	sbc	r25, r21
    2630:	a6 0b       	sbc	r26, r22
    2632:	b7 0b       	sbc	r27, r23
	{
		if(bankStates[theBank].isLocked==false)		// Bank must be unlocked to mess with SD transfers
		{
			theLength=GetLengthOfSample(theBank);	// Get sample length for a given bank

			sreg=SREG;
    2634:	ff b7       	in	r31, 0x3f	; 63
			cli();		// Pause ISR
    2636:	f8 94       	cli
// Thu Jun 23 00:46:03 EDT 2011 -- by using single block writes, this is REALLY slow.
{
	unsigned char
		sreg;

	sreg=SREG;
    2638:	cf b7       	in	r28, 0x3f	; 63
	cli();		// Pause ISR
    263a:	f8 94       	cli

	sdCurrentSlot=sampleSlot;					// Need this to know whether to update TOC
    263c:	10 93 63 05 	sts	0x0563, r17
    2640:	00 93 64 05 	sts	0x0564, r16
	sdSampleStartBlock=(1+(sampleSlot*1024));	// Mark this block as where we started reading (1 block plus 512k sample size times the number of samples in we are)
    2644:	71 2f       	mov	r23, r17
    2646:	77 0f       	add	r23, r23
    2648:	77 0f       	add	r23, r23
    264a:	60 e0       	ldi	r22, 0x00	; 0
    264c:	ab 01       	movw	r20, r22
    264e:	4f 5f       	subi	r20, 0xFF	; 255
    2650:	5f 4f       	sbci	r21, 0xFF	; 255
    2652:	60 e0       	ldi	r22, 0x00	; 0
    2654:	70 e0       	ldi	r23, 0x00	; 0
    2656:	40 93 b1 05 	sts	0x05B1, r20
    265a:	50 93 b2 05 	sts	0x05B2, r21
    265e:	60 93 b3 05 	sts	0x05B3, r22
    2662:	70 93 b4 05 	sts	0x05B4, r23
	sdCurrentBlockOffset=0;						// Offset to start block -- write first block first.
    2666:	10 92 b6 05 	sts	0x05B6, r1
    266a:	10 92 b5 05 	sts	0x05B5, r1

	sdFifoReadPointer=0;		// Reset FIFO variables
    266e:	10 92 2b 01 	sts	0x012B, r1
    2672:	10 92 2a 01 	sts	0x012A, r1
	sdFifoWritePointer=0;
    2676:	10 92 29 01 	sts	0x0129, r1
    267a:	10 92 28 01 	sts	0x0128, r1
	sdBytesInFifo=0;
    267e:	10 92 27 01 	sts	0x0127, r1
    2682:	10 92 26 01 	sts	0x0126, r1

	if(sampleLength<=((512UL*1024UL)-4))		// Allow for weird case where sample + 4 byte address would be bigger than a slot (bigger than 512k)
    2686:	8d 3f       	cpi	r24, 0xFD	; 253
    2688:	4f ef       	ldi	r20, 0xFF	; 255
    268a:	94 07       	cpc	r25, r20
    268c:	47 e0       	ldi	r20, 0x07	; 7
    268e:	a4 07       	cpc	r26, r20
    2690:	b1 05       	cpc	r27, r1
    2692:	08 f4       	brcc	.+2      	; 0x2696 <SdCardMenu+0x2e8>
    2694:	04 c0       	rjmp	.+8      	; 0x269e <SdCardMenu+0x2f0>
	{
		sdRamSampleRemaining=sampleLength;				// How many bytes in this sample?  Mark this many to get from RAM
	}
	else
	{
		sdRamSampleRemaining=((512UL*1024UL)-4);		// Shave off last bytes.
    2696:	8c ef       	ldi	r24, 0xFC	; 252
    2698:	9f ef       	ldi	r25, 0xFF	; 255
    269a:	a7 e0       	ldi	r26, 0x07	; 7
    269c:	b0 e0       	ldi	r27, 0x00	; 0
    269e:	80 93 22 01 	sts	0x0122, r24
    26a2:	90 93 23 01 	sts	0x0123, r25
    26a6:	a0 93 24 01 	sts	0x0124, r26
    26aa:	b0 93 25 01 	sts	0x0125, r27
	}

	sdCardSampleRemaining=sdRamSampleRemaining;		// At the start of the transfer, bytes to read from SRAM = bytes to write to card = sample length.
    26ae:	80 91 22 01 	lds	r24, 0x0122
    26b2:	90 91 23 01 	lds	r25, 0x0123
    26b6:	a0 91 24 01 	lds	r26, 0x0124
    26ba:	b0 91 25 01 	lds	r27, 0x0125
    26be:	80 93 1e 01 	sts	0x011E, r24
    26c2:	90 93 1f 01 	sts	0x011F, r25
    26c6:	a0 93 20 01 	sts	0x0120, r26
    26ca:	b0 93 21 01 	sts	0x0121, r27
	cardState=SD_WRITE_START;						// Enable state machine to handle this.  NOTE -- we'll have to have a block in the FIFO before we start
    26ce:	82 e0       	ldi	r24, 0x02	; 2
    26d0:	80 93 59 05 	sts	0x0559, r24
	SREG=sreg;	// Resume ISR
    26d4:	cf bf       	out	0x3f, r28	; 63
// Tell it to collect bytes from the passed bank and fill the buffer.
{
	unsigned char
		sreg;

	sreg=SREG;
    26d6:	4f b7       	in	r20, 0x3f	; 63
	cli();		// Pause ISRs
    26d8:	f8 94       	cli

	sdIsrState=SD_ISR_READING_RAM;		// Getting bytes from RAM and putting them in the SD card buffer
    26da:	80 93 4f 05 	sts	0x054F, r24
	bankStates[theBank].isLocked=true;	// Lock this part of RAM until we are done reading it.
    26de:	84 e2       	ldi	r24, 0x24	; 36
    26e0:	82 9f       	mul	r24, r18
    26e2:	d0 01       	movw	r26, r0
    26e4:	83 9f       	mul	r24, r19
    26e6:	b0 0d       	add	r27, r0
    26e8:	11 24       	eor	r1, r1
    26ea:	ab 51       	subi	r26, 0x1B	; 27
    26ec:	ba 4f       	sbci	r27, 0xFA	; 250
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	15 96       	adiw	r26, 0x05	; 5
    26f2:	8c 93       	st	X, r24

	if(theBank==BANK_0)		// Pointing at this bank?
    26f4:	e1 11       	cpse	r30, r1
    26f6:	0b c0       	rjmp	.+22     	; 0x270e <SdCardMenu+0x360>
	{
		sdBank0=true;
    26f8:	80 93 54 05 	sts	0x0554, r24
		sdRamAddress=BANK_0_START_ADDRESS;
    26fc:	10 92 50 05 	sts	0x0550, r1
    2700:	10 92 51 05 	sts	0x0551, r1
    2704:	10 92 52 05 	sts	0x0552, r1
    2708:	10 92 53 05 	sts	0x0553, r1
    270c:	0e c0       	rjmp	.+28     	; 0x272a <SdCardMenu+0x37c>
	}
	else
	{
		sdBank0=false;
    270e:	10 92 54 05 	sts	0x0554, r1
		sdRamAddress=BANK_1_START_ADDRESS;
    2712:	8f ef       	ldi	r24, 0xFF	; 255
    2714:	9f ef       	ldi	r25, 0xFF	; 255
    2716:	a7 e0       	ldi	r26, 0x07	; 7
    2718:	b0 e0       	ldi	r27, 0x00	; 0
    271a:	80 93 50 05 	sts	0x0550, r24
    271e:	90 93 51 05 	sts	0x0551, r25
    2722:	a0 93 52 05 	sts	0x0552, r26
    2726:	b0 93 53 05 	sts	0x0553, r27
	}

	TCNT2=0;			// Init counter reg
    272a:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=97;			// Compare match interrupt when the counter gets to this number (around 25kHz)
    272e:	81 e6       	ldi	r24, 0x61	; 97
    2730:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;					// Writing ones clears the interrupt flags.
    2734:	8f ef       	ldi	r24, 0xFF	; 255
    2736:	87 bb       	out	0x17, r24	; 23
	TIMSK2|=(1<<OCIE2B);		// Enable interrupt
    2738:	80 91 70 00 	lds	r24, 0x0070
    273c:	84 60       	ori	r24, 0x04	; 4
    273e:	80 93 70 00 	sts	0x0070, r24
	TCCR2B=0x02;				// Clock on, prescaler /8
    2742:	82 e0       	ldi	r24, 0x02	; 2
    2744:	80 93 b1 00 	sts	0x00B1, r24

	SREG=sreg;	// Resume ISRs
    2748:	4f bf       	out	0x3f, r20	; 63
			cli();		// Pause ISR

			SdStartSampleWrite(theSlot,theLength);	// Open the SD state machine for writing to the card and init the fifo
			SdIsrStartReadingRam(theBank);			// Start the ISR that deals with filling or emptying the SD's buffer -- also locks the RAM

			SREG=sreg;		// Resume ISR
    274a:	ff bf       	out	0x3f, r31	; 63
			if(newKeys&Im_SWITCH_2)		// Save sample from current bank into the current SD card slot
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something in the bank?
				{
					WriteSampleToSd(currentBank,sdCurrentSlot);
					BlinkLeds(1<<LED_7);							// Update LED to reflect that this is now full
    274c:	80 e8       	ldi	r24, 0x80	; 128
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <BlinkLeds>
				}
			}		
			if(newKeys&Im_SWITCH_3)		// "Delete" sample.  This merely clears the TOC entry.  It's more like "freeing" a sample.
    2754:	80 91 57 05 	lds	r24, 0x0557
    2758:	83 ff       	sbrs	r24, 3
    275a:	2d c0       	rjmp	.+90     	; 0x27b6 <SdCardMenu+0x408>
			{
				if(CheckSdSlotFull(sdCurrentSlot))
    275c:	c0 91 63 05 	lds	r28, 0x0563
    2760:	d0 91 64 05 	lds	r29, 0x0564
    2764:	ce 01       	movw	r24, r28
    2766:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    276a:	88 23       	and	r24, r24
    276c:	21 f1       	breq	.+72     	; 0x27b6 <SdCardMenu+0x408>
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
    276e:	80 91 59 05 	lds	r24, 0x0559
    2772:	8e 30       	cpi	r24, 0x0E	; 14
    2774:	01 f5       	brne	.+64     	; 0x27b6 <SdCardMenu+0x408>
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    2776:	fe 01       	movw	r30, r28
    2778:	13 e0       	ldi	r17, 0x03	; 3
    277a:	f6 95       	lsr	r31
    277c:	e7 95       	ror	r30
    277e:	1a 95       	dec	r17
    2780:	e1 f7       	brne	.-8      	; 0x277a <SdCardMenu+0x3cc>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    2782:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]&=~(1<<theBit);	// Clear it
    2784:	e2 59       	subi	r30, 0x92	; 146
    2786:	fa 4f       	sbci	r31, 0xFA	; 250
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    2788:	c7 70       	andi	r28, 0x07	; 7
    278a:	dd 27       	eor	r29, r29

	sampleToc[theByte]&=~(1<<theBit);	// Clear it
    278c:	81 e0       	ldi	r24, 0x01	; 1
    278e:	90 e0       	ldi	r25, 0x00	; 0
    2790:	0c 2e       	mov	r0, r28
    2792:	01 c0       	rjmp	.+2      	; 0x2796 <SdCardMenu+0x3e8>
    2794:	88 0f       	add	r24, r24
    2796:	0a 94       	dec	r0
    2798:	ea f7       	brpl	.-6      	; 0x2794 <SdCardMenu+0x3e6>
    279a:	80 95       	com	r24
    279c:	90 81       	ld	r25, Z
    279e:	89 23       	and	r24, r25
    27a0:	80 83       	st	Z, r24
				if(CheckSdSlotFull(sdCurrentSlot))
				{		
					if(cardState==SD_IDLE)	// Got what we wanted?
					{
						MarkSdSlotEmpty(sdCurrentSlot);	// Clear this in the TOC
						cardState=SD_TOC_WRITE_START;	// Start TOC write to the SD
    27a2:	86 e0       	ldi	r24, 0x06	; 6
    27a4:	80 93 59 05 	sts	0x0559, r24
						StopBlinking();					// Update LED to reflect that this is now full
    27a8:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>
						ledOnOffMask&=~(1<<LED_7);
    27ac:	80 91 5d 05 	lds	r24, 0x055D
    27b0:	8f 77       	andi	r24, 0x7F	; 127
    27b2:	80 93 5d 05 	sts	0x055D, r24
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    27b6:	80 91 57 05 	lds	r24, 0x0557
    27ba:	84 fd       	sbrc	r24, 4
    27bc:	05 c0       	rjmp	.+10     	; 0x27c8 <SdCardMenu+0x41a>
//--------------------------------------

static unsigned char
	currentBank;					// Keeps track of the bank we're thinking about.

static void SdCardMenu(void)
    27be:	98 2f       	mov	r25, r24
    27c0:	90 76       	andi	r25, 0x60	; 96
						ledOnOffMask&=~(1<<LED_7);
					}
				}
			}		
			
			if((newKeys&Im_SWITCH_4)||(newKeys&Im_SWITCH_5)||(newKeys&Im_SWITCH_6)||(newKeys&Im_SWITCH_7))		// Bail from SD card menu
    27c2:	11 f4       	brne	.+4      	; 0x27c8 <SdCardMenu+0x41a>
    27c4:	87 ff       	sbrs	r24, 7
    27c6:	0a c0       	rjmp	.+20     	; 0x27dc <SdCardMenu+0x42e>
			{
				KillLeds();
    27c8:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    27cc:	8f e6       	ldi	r24, 0x6F	; 111
    27ce:	95 e1       	ldi	r25, 0x15	; 21
    27d0:	90 93 e4 05 	sts	0x05E4, r25
    27d4:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    27d8:	10 92 5b 05 	sts	0x055B, r1
				KillLeds();
				SetState(DoSampler);
			}
		}
	}
}
    27dc:	df 91       	pop	r29
    27de:	cf 91       	pop	r28
    27e0:	1f 91       	pop	r17
    27e2:	0f 91       	pop	r16
    27e4:	ff 90       	pop	r15
    27e6:	ef 90       	pop	r14
    27e8:	08 95       	ret

000027ea <DoSawtooth>:

static void DoSawtooth(void)
// See if we can get some audio out.  And look good doing it.
// Also test to see if our flash is present and working.
{
	if(subState==SS_0)
    27ea:	80 91 5b 05 	lds	r24, 0x055B
    27ee:	81 11       	cpse	r24, r1
    27f0:	08 c0       	rjmp	.+16     	; 0x2802 <DoSawtooth+0x18>
	{
		KillLeds();							// Start with LEDs off.
    27f2:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    27f6:	80 ec       	ldi	r24, 0xC0	; 192
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <BlinkLeds>
		subState=SS_1;
    27fe:	81 e0       	ldi	r24, 0x01	; 1
    2800:	13 c0       	rjmp	.+38     	; 0x2828 <DoSawtooth+0x3e>
	}
	else if(subState==SS_1)
    2802:	81 30       	cpi	r24, 0x01	; 1
    2804:	a1 f4       	brne	.+40     	; 0x282e <DoSawtooth+0x44>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2806:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    2808:	80 93 e5 05 	sts	0x05E5, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    280c:	80 93 ef 05 	sts	0x05EF, r24

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    2810:	80 93 ef 05 	sts	0x05EF, r24
    2814:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <SetSampleClock.part.0>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2818:	85 e3       	ldi	r24, 0x35	; 53
    281a:	98 e0       	ldi	r25, 0x08	; 8
    281c:	90 93 e2 05 	sts	0x05E2, r25
    2820:	80 93 e1 05 	sts	0x05E1, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    2824:	78 94       	sei

		subState=SS_2;					// And wait forever.
    2826:	82 e0       	ldi	r24, 0x02	; 2
    2828:	80 93 5b 05 	sts	0x055B, r24
    282c:	08 95       	ret
	}
	else if(subState==SS_2)
    282e:	82 30       	cpi	r24, 0x02	; 2
    2830:	09 f0       	breq	.+2      	; 0x2834 <DoSawtooth+0x4a>
    2832:	51 c0       	rjmp	.+162    	; 0x28d6 <DoSawtooth+0xec>
	{

		if(newKeys&Im_SWITCH_0)
    2834:	80 91 57 05 	lds	r24, 0x0557
    2838:	80 ff       	sbrs	r24, 0
    283a:	06 c0       	rjmp	.+12     	; 0x2848 <DoSawtooth+0x5e>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    283c:	90 91 5d 05 	lds	r25, 0x055D
    2840:	21 e0       	ldi	r18, 0x01	; 1
    2842:	92 27       	eor	r25, r18
    2844:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_1)
    2848:	81 ff       	sbrs	r24, 1
    284a:	06 c0       	rjmp	.+12     	; 0x2858 <DoSawtooth+0x6e>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    284c:	90 91 5d 05 	lds	r25, 0x055D
    2850:	22 e0       	ldi	r18, 0x02	; 2
    2852:	92 27       	eor	r25, r18
    2854:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)
    2858:	82 ff       	sbrs	r24, 2
    285a:	06 c0       	rjmp	.+12     	; 0x2868 <DoSawtooth+0x7e>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    285c:	90 91 5d 05 	lds	r25, 0x055D
    2860:	24 e0       	ldi	r18, 0x04	; 4
    2862:	92 27       	eor	r25, r18
    2864:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_3)
    2868:	83 ff       	sbrs	r24, 3
    286a:	06 c0       	rjmp	.+12     	; 0x2878 <DoSawtooth+0x8e>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    286c:	90 91 5d 05 	lds	r25, 0x055D
    2870:	28 e0       	ldi	r18, 0x08	; 8
    2872:	92 27       	eor	r25, r18
    2874:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_4)
    2878:	84 ff       	sbrs	r24, 4
    287a:	06 c0       	rjmp	.+12     	; 0x2888 <DoSawtooth+0x9e>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    287c:	90 91 5d 05 	lds	r25, 0x055D
    2880:	20 e1       	ldi	r18, 0x10	; 16
    2882:	92 27       	eor	r25, r18
    2884:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_5)
    2888:	85 ff       	sbrs	r24, 5
    288a:	06 c0       	rjmp	.+12     	; 0x2898 <DoSawtooth+0xae>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    288c:	90 91 5d 05 	lds	r25, 0x055D
    2890:	20 e2       	ldi	r18, 0x20	; 32
    2892:	92 27       	eor	r25, r18
    2894:	90 93 5d 05 	sts	0x055D, r25
		}

		if(newKeys&Im_SWITCH_6)
    2898:	86 ff       	sbrs	r24, 6
    289a:	08 c0       	rjmp	.+16     	; 0x28ac <DoSawtooth+0xc2>
		{
			StopBlinking();
    289c:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>
			ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    28a0:	80 91 5d 05 	lds	r24, 0x055D
    28a4:	90 e4       	ldi	r25, 0x40	; 64
    28a6:	89 27       	eor	r24, r25
    28a8:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_7)
    28ac:	80 91 57 05 	lds	r24, 0x0557
    28b0:	87 ff       	sbrs	r24, 7
    28b2:	07 c0       	rjmp	.+14     	; 0x28c2 <DoSawtooth+0xd8>
		{
			StopBlinking();
    28b4:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>
			ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    28b8:	80 91 5d 05 	lds	r24, 0x055D
    28bc:	80 58       	subi	r24, 0x80	; 128
    28be:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newEncoder)	// Change the leds to the new encoder value when we get a new value.
    28c2:	80 91 6b 05 	lds	r24, 0x056B
    28c6:	88 23       	and	r24, r24
    28c8:	31 f0       	breq	.+12     	; 0x28d6 <DoSawtooth+0xec>
		{
			StopBlinking();
    28ca:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <StopBlinking>
			ledOnOffMask=encoderValue;
    28ce:	80 91 6d 05 	lds	r24, 0x056D
    28d2:	80 93 5d 05 	sts	0x055D, r24
    28d6:	08 95       	ret

000028d8 <InitSampler>:
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}

static void InitSampler(void)
// Gets all variables and data structures read and set when the sampler starts up.
{
    28d8:	cf 92       	push	r12
    28da:	df 92       	push	r13
    28dc:	ef 92       	push	r14
    28de:	ff 92       	push	r15
    28e0:	0f 93       	push	r16
    28e2:	1f 93       	push	r17
    28e4:	cf 93       	push	r28
    28e6:	df 93       	push	r29

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    28e8:	84 e0       	ldi	r24, 0x04	; 4
    28ea:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    28ee:	80 31       	cpi	r24, 0x10	; 16
    28f0:	08 f0       	brcs	.+2      	; 0x28f4 <InitSampler+0x1c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    28f2:	80 e0       	ldi	r24, 0x00	; 0
// Gets all variables and data structures read and set when the sampler starts up.
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    28f4:	80 93 2f 06 	sts	0x062F, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    28f8:	88 e0       	ldi	r24, 0x08	; 8
    28fa:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <EepromRead>
	}

	if(x<16)					// Legit number?
    28fe:	80 31       	cpi	r24, 0x10	; 16
    2900:	08 f0       	brcs	.+2      	; 0x2904 <InitSampler+0x2c>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2902:	81 e0       	ldi	r24, 0x01	; 1
{
	unsigned char
		i;

	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    2904:	80 93 48 06 	sts	0x0648, r24
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    2908:	10 92 f6 05 	sts	0x05F6, r1
    290c:	10 92 f7 05 	sts	0x05F7, r1
    2910:	10 92 f8 05 	sts	0x05F8, r1
    2914:	10 92 f9 05 	sts	0x05F9, r1
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    2918:	8f ef       	ldi	r24, 0xFF	; 255
    291a:	9f ef       	ldi	r25, 0xFF	; 255
    291c:	a7 e0       	ldi	r26, 0x07	; 7
    291e:	b0 e0       	ldi	r27, 0x00	; 0
    2920:	80 93 1a 06 	sts	0x061A, r24
    2924:	90 93 1b 06 	sts	0x061B, r25
    2928:	a0 93 1c 06 	sts	0x061C, r26
    292c:	b0 93 1d 06 	sts	0x061D, r27
    2930:	0e e5       	ldi	r16, 0x5E	; 94
    2932:	15 e0       	ldi	r17, 0x05	; 5
    2934:	c0 e0       	ldi	r28, 0x00	; 0
    2936:	d0 e0       	ldi	r29, 0x00	; 0

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    2938:	24 e2       	ldi	r18, 0x24	; 36
    293a:	e2 2e       	mov	r14, r18
		bankStates[i].loopOnce=false;
		bankStates[i].bitReduction=0;				// No crusties yet.
		bankStates[i].jitterValue=0;				// No hissies yet.
		bankStates[i].granularSlices=0;				// No remix yet.
		bankStates[i].halfSpeed=false;
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    293c:	dd 24       	eor	r13, r13
    293e:	d3 94       	inc	r13
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2940:	3c e0       	ldi	r19, 0x0C	; 12
    2942:	f3 2e       	mov	r15, r19
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
	{
		bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    2944:	ec 9e       	mul	r14, r28
    2946:	f0 01       	movw	r30, r0
    2948:	ed 9e       	mul	r14, r29
    294a:	f0 0d       	add	r31, r0
    294c:	11 24       	eor	r1, r1
    294e:	eb 51       	subi	r30, 0x1B	; 27
    2950:	fa 4f       	sbci	r31, 0xFA	; 250
    2952:	10 82       	st	Z, r1
		bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    2954:	12 86       	std	Z+10, r1	; 0x0a
		bankStates[i].loopOnce=false;
    2956:	11 82       	std	Z+1, r1	; 0x01
		bankStates[i].bitReduction=0;				// No crusties yet.
    2958:	11 86       	std	Z+9, r1	; 0x09
		bankStates[i].jitterValue=0;				// No hissies yet.
    295a:	10 86       	std	Z+8, r1	; 0x08
		bankStates[i].granularSlices=0;				// No remix yet.
    295c:	17 82       	std	Z+7, r1	; 0x07
		bankStates[i].halfSpeed=false;
    295e:	12 82       	std	Z+2, r1	; 0x02
		bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2960:	d4 82       	std	Z+4, r13	; 0x04
		bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    2962:	13 82       	std	Z+3, r1	; 0x03
		bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2964:	81 89       	ldd	r24, Z+17	; 0x11
    2966:	92 89       	ldd	r25, Z+18	; 0x12
    2968:	a3 89       	ldd	r26, Z+19	; 0x13
    296a:	b4 89       	ldd	r27, Z+20	; 0x14
    296c:	80 a3       	std	Z+32, r24	; 0x20
    296e:	91 a3       	std	Z+33, r25	; 0x21
    2970:	a2 a3       	std	Z+34, r26	; 0x22
    2972:	b3 a3       	std	Z+35, r27	; 0x23
		bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2974:	81 89       	ldd	r24, Z+17	; 0x11
    2976:	92 89       	ldd	r25, Z+18	; 0x12
    2978:	a3 89       	ldd	r26, Z+19	; 0x13
    297a:	b4 89       	ldd	r27, Z+20	; 0x14
    297c:	85 87       	std	Z+13, r24	; 0x0d
    297e:	96 87       	std	Z+14, r25	; 0x0e
    2980:	a7 87       	std	Z+15, r26	; 0x0f
    2982:	b0 8b       	std	Z+16, r27	; 0x10
		bankStates[i].realtimeOn=false;						// We'll default to playback.
    2984:	16 82       	std	Z+6, r1	; 0x06
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently
    2986:	15 82       	std	Z+5, r1	; 0x05

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.
    2988:	8c 2f       	mov	r24, r28
    298a:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <RevertSampleToUnadjusted>
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    298e:	c1 11       	cpse	r28, r1
    2990:	02 c0       	rjmp	.+4      	; 0x2996 <InitSampler+0xbe>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    2992:	87 e0       	ldi	r24, 0x07	; 7
    2994:	01 c0       	rjmp	.+2      	; 0x2998 <InitSampler+0xc0>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    2996:	8b e0       	ldi	r24, 0x0B	; 11
    2998:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <EepromRead>
	}

	if(x<90)					// Legit number?
    299c:	8a 35       	cpi	r24, 0x5A	; 90
    299e:	08 f0       	brcs	.+2      	; 0x29a2 <InitSampler+0xca>
		return(x);
	}
	else
	{
		x=MIDI_GENERIC_NOTE;			// If we've got poo poo in EEPROM or a bad address then default to C3 (or whatever).
		return(x);
    29a0:	80 e3       	ldi	r24, 0x30	; 48
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    29a2:	6f 2d       	mov	r22, r15
    29a4:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    29a8:	e9 2f       	mov	r30, r25
    29aa:	f0 e0       	ldi	r31, 0x00	; 0
    29ac:	ee 0f       	add	r30, r30
    29ae:	ff 1f       	adc	r31, r31
    29b0:	ea 5f       	subi	r30, 0xFA	; 250
    29b2:	fe 4f       	sbci	r31, 0xFE	; 254
    29b4:	20 81       	ld	r18, Z
    29b6:	31 81       	ldd	r19, Z+1	; 0x01
    29b8:	02 c0       	rjmp	.+4      	; 0x29be <InitSampler+0xe6>
    29ba:	36 95       	lsr	r19
    29bc:	27 95       	ror	r18
    29be:	8a 95       	dec	r24
    29c0:	e2 f7       	brpl	.-8      	; 0x29ba <InitSampler+0xe2>
		bankStates[i].isLocked=false;						// No functions have laid claim to the RAM currently

		RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    29c2:	f8 01       	movw	r30, r16
    29c4:	21 93       	st	Z+, r18
    29c6:	31 93       	st	Z+, r19
    29c8:	8f 01       	movw	r16, r30
    29ca:	21 96       	adiw	r28, 0x01	; 1
	midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
	midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
	bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
	bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

	for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    29cc:	c2 30       	cpi	r28, 0x02	; 2
    29ce:	d1 05       	cpc	r29, r1
    29d0:	09 f0       	breq	.+2      	; 0x29d4 <InitSampler+0xfc>
    29d2:	b8 cf       	rjmp	.-144    	; 0x2944 <InitSampler+0x6c>

		theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
		theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
	}

	UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    29d4:	85 e3       	ldi	r24, 0x35	; 53
    29d6:	98 e0       	ldi	r25, 0x08	; 8
    29d8:	90 93 e2 05 	sts	0x05E2, r25
    29dc:	80 93 e1 05 	sts	0x05E1, r24

	currentBank=BANK_0;			// Point at the first bank until we change banks.
    29e0:	10 92 62 05 	sts	0x0562, r1
	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.
    29e4:	10 92 64 05 	sts	0x0564, r1
    29e8:	10 92 63 05 	sts	0x0563, r1

	KillLeds();					// All leds off, and no blinking.
    29ec:	0e 94 8a 0e 	call	0x1d14	; 0x1d14 <KillLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    29f0:	8f e6       	ldi	r24, 0x6F	; 111
    29f2:	95 e1       	ldi	r25, 0x15	; 21
    29f4:	90 93 e4 05 	sts	0x05E4, r25
    29f8:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    29fc:	10 92 5b 05 	sts	0x055B, r1
	currentBank=BANK_0;			// Point at the first bank until we change banks.
	sdCurrentSlot=0;			// Point at the first sample slot on the SD card.

	KillLeds();					// All leds off, and no blinking.
	SetState(DoSampler);		// Get to sampling
}
    2a00:	df 91       	pop	r29
    2a02:	cf 91       	pop	r28
    2a04:	1f 91       	pop	r17
    2a06:	0f 91       	pop	r16
    2a08:	ff 90       	pop	r15
    2a0a:	ef 90       	pop	r14
    2a0c:	df 90       	pop	r13
    2a0e:	cf 90       	pop	r12
    2a10:	08 95       	ret

00002a12 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
    2a12:	80 91 5b 05 	lds	r24, 0x055B
    2a16:	81 11       	cpse	r24, r1
    2a18:	1d c0       	rjmp	.+58     	; 0x2a54 <SetMidiChannels+0x42>

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    2a1a:	84 e0       	ldi	r24, 0x04	; 4
    2a1c:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <EepromRead>
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
	}

	if(x<16)					// Legit number?
    2a20:	80 31       	cpi	r24, 0x10	; 16
    2a22:	08 f0       	brcs	.+2      	; 0x2a26 <SetMidiChannels+0x14>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2a24:	80 e0       	ldi	r24, 0x00	; 0
static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    2a26:	80 93 2f 06 	sts	0x062F, r24
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    2a2a:	88 e0       	ldi	r24, 0x08	; 8
    2a2c:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <EepromRead>
	}

	if(x<16)					// Legit number?
    2a30:	80 31       	cpi	r24, 0x10	; 16
    2a32:	08 f0       	brcs	.+2      	; 0x2a36 <SetMidiChannels+0x24>
		}
		else
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
    2a34:	81 e0       	ldi	r24, 0x01	; 1
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{
	if(subState==SS_0)
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
		midiChannelNumberB=GetMidiChannel(BANK_1);
    2a36:	80 93 48 06 	sts	0x0648, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    2a3a:	20 e1       	ldi	r18, 0x10	; 16
    2a3c:	82 9f       	mul	r24, r18
    2a3e:	c0 01       	movw	r24, r0
    2a40:	11 24       	eor	r1, r1
    2a42:	90 91 2f 06 	lds	r25, 0x062F
    2a46:	98 2b       	or	r25, r24
    2a48:	90 93 5d 05 	sts	0x055D, r25
		subState=SS_1;
    2a4c:	81 e0       	ldi	r24, 0x01	; 1
    2a4e:	80 93 5b 05 	sts	0x055B, r24
    2a52:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    2a54:	20 91 57 05 	lds	r18, 0x0557
    2a58:	20 ff       	sbrs	r18, 0
    2a5a:	12 c0       	rjmp	.+36     	; 0x2a80 <SetMidiChannels+0x6e>
		{
			midiChannelNumberA++;
    2a5c:	80 91 2f 06 	lds	r24, 0x062F
    2a60:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    2a62:	80 31       	cpi	r24, 0x10	; 16
    2a64:	18 f4       	brcc	.+6      	; 0x2a6c <SetMidiChannels+0x5a>
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
		{
			midiChannelNumberA++;
    2a66:	80 93 2f 06 	sts	0x062F, r24
    2a6a:	02 c0       	rjmp	.+4      	; 0x2a70 <SetMidiChannels+0x5e>
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberA=0;
    2a6c:	10 92 2f 06 	sts	0x062F, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    2a70:	80 91 5d 05 	lds	r24, 0x055D
    2a74:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    2a76:	90 91 2f 06 	lds	r25, 0x062F
    2a7a:	89 2b       	or	r24, r25
    2a7c:	80 93 5d 05 	sts	0x055D, r24
		}
		if(newKeys&Im_SWITCH_1)
    2a80:	21 ff       	sbrs	r18, 1
    2a82:	16 c0       	rjmp	.+44     	; 0x2ab0 <SetMidiChannels+0x9e>
		{
			midiChannelNumberB++;
    2a84:	80 91 48 06 	lds	r24, 0x0648
    2a88:	8f 5f       	subi	r24, 0xFF	; 255
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    2a8a:	80 31       	cpi	r24, 0x10	; 16
    2a8c:	18 f4       	brcc	.+6      	; 0x2a94 <SetMidiChannels+0x82>
			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
		}
		if(newKeys&Im_SWITCH_1)
		{
			midiChannelNumberB++;
    2a8e:	80 93 48 06 	sts	0x0648, r24
    2a92:	02 c0       	rjmp	.+4      	; 0x2a98 <SetMidiChannels+0x86>
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
    2a94:	10 92 48 06 	sts	0x0648, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    2a98:	80 91 48 06 	lds	r24, 0x0648
    2a9c:	30 e1       	ldi	r19, 0x10	; 16
    2a9e:	83 9f       	mul	r24, r19
    2aa0:	c0 01       	movw	r24, r0
    2aa2:	11 24       	eor	r1, r1
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
			{
				midiChannelNumberB=0;
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    2aa4:	90 91 5d 05 	lds	r25, 0x055D
    2aa8:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.
    2aaa:	98 2b       	or	r25, r24
    2aac:	90 93 5d 05 	sts	0x055D, r25
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    2ab0:	22 ff       	sbrs	r18, 2
    2ab2:	14 c0       	rjmp	.+40     	; 0x2adc <SetMidiChannels+0xca>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    2ab4:	60 91 2f 06 	lds	r22, 0x062F
    2ab8:	84 e0       	ldi	r24, 0x04	; 4
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	0e 94 d5 1e 	call	0x3daa	; 0x3daa <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    2ac0:	60 91 48 06 	lds	r22, 0x0648
    2ac4:	88 e0       	ldi	r24, 0x08	; 8
    2ac6:	90 e0       	ldi	r25, 0x00	; 0
    2ac8:	0e 94 d5 1e 	call	0x3daa	; 0x3daa <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2acc:	8c e6       	ldi	r24, 0x6C	; 108
    2ace:	94 e1       	ldi	r25, 0x14	; 20
    2ad0:	90 93 e4 05 	sts	0x05E4, r25
    2ad4:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    2ad8:	10 92 5b 05 	sts	0x055B, r1
    2adc:	08 95       	ret

00002ade <DoSampler>:
// Sampler main loop.  This handles getting switch inputs and MIDI and calling all the functions necessary to turn this stuff into audio.
// If we want to enter a "menu" we should leave this state and return when it's time to run normally again.
// An old note:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.
{
    2ade:	cf 92       	push	r12
    2ae0:	df 92       	push	r13
    2ae2:	ff 92       	push	r15
    2ae4:	0f 93       	push	r16
    2ae6:	1f 93       	push	r17
    2ae8:	cf 93       	push	r28
    2aea:	df 93       	push	r29
    2aec:	1f 92       	push	r1
    2aee:	cd b7       	in	r28, 0x3d	; 61
    2af0:	de b7       	in	r29, 0x3e	; 62
		};

	unsigned int
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    2af2:	80 91 5b 05 	lds	r24, 0x055B
    2af6:	81 11       	cpse	r24, r1
    2af8:	b2 c4       	rjmp	.+2404   	; 0x345e <DoSampler+0x980>
// Both Shift:	SD Menu		?			?			?			?			Bail		(pressed)	(pressed)
{
	// -----------------------------------------------------------------------------------
	// Two shift keys:
	// -----------------------------------------------------------------------------------
	if((keysHeld&Im_SHIFT_1)&&(keysHeld&Im_SHIFT_2))	// User holding both shift keys?
    2afa:	80 91 6a 05 	lds	r24, 0x056A
    2afe:	86 ff       	sbrs	r24, 6
    2b00:	f3 c0       	rjmp	.+486    	; 0x2ce8 <DoSampler+0x20a>
    2b02:	87 ff       	sbrs	r24, 7
    2b04:	3a c0       	rjmp	.+116    	; 0x2b7a <DoSampler+0x9c>
	{
		if(newKeys&Im_SWITCH_5)		// Bail!
    2b06:	80 91 57 05 	lds	r24, 0x0557
    2b0a:	85 ff       	sbrs	r24, 5
    2b0c:	26 c0       	rjmp	.+76     	; 0x2b5a <DoSampler+0x7c>
		{
			UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2b0e:	85 e3       	ldi	r24, 0x35	; 53
    2b10:	98 e0       	ldi	r25, 0x08	; 8
    2b12:	90 93 e2 05 	sts	0x05E2, r25
    2b16:	80 93 e1 05 	sts	0x05E1, r24
			RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
    2b1a:	10 91 62 05 	lds	r17, 0x0562
    2b1e:	81 2f       	mov	r24, r17
    2b20:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <RevertSampleToUnadjusted>
			bankStates[currentBank].bitReduction=0;			// No crusties yet.
    2b24:	24 e2       	ldi	r18, 0x24	; 36
    2b26:	12 9f       	mul	r17, r18
    2b28:	f0 01       	movw	r30, r0
    2b2a:	11 24       	eor	r1, r1
    2b2c:	eb 51       	subi	r30, 0x1B	; 27
    2b2e:	fa 4f       	sbci	r31, 0xFA	; 250
    2b30:	11 86       	std	Z+9, r1	; 0x09
			bankStates[currentBank].jitterValue=0;			// No hissies yet.
    2b32:	10 86       	std	Z+8, r1	; 0x08
			bankStates[currentBank].granularSlices=0;		// No remix yet.
    2b34:	17 82       	std	Z+7, r1	; 0x07
			bankStates[currentBank].halfSpeed=false;
    2b36:	12 82       	std	Z+2, r1	; 0x02
			bankStates[currentBank].backwardsPlayback=false;
    2b38:	13 82       	std	Z+3, r1	; 0x03
			bankStates[currentBank].sampleDirection=true;
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	84 83       	std	Z+4, r24	; 0x04
			bankStates[currentBank].loopOnce=false;
    2b3e:	11 82       	std	Z+1, r1	; 0x01
			bankStates[currentBank].realtimeOn=false;
    2b40:	16 82       	std	Z+6, r1	; 0x06
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);			// Send it out to the techno nerds.
    2b42:	20 e0       	ldi	r18, 0x00	; 0
    2b44:	42 e1       	ldi	r20, 0x12	; 18
    2b46:	64 e0       	ldi	r22, 0x04	; 4
    2b48:	81 2f       	mov	r24, r17
    2b4a:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.
    2b4e:	20 e0       	ldi	r18, 0x00	; 0
    2b50:	4b e1       	ldi	r20, 0x1B	; 27
    2b52:	64 e0       	ldi	r22, 0x04	; 4
    2b54:	80 91 62 05 	lds	r24, 0x0562
    2b58:	e4 c1       	rjmp	.+968    	; 0x2f22 <DoSampler+0x444>
		}
		else if(newKeys&Im_SWITCH_0)	// Enter SD card menu.  Sample keeps doing whatever it was.
    2b5a:	80 ff       	sbrs	r24, 0
    2b5c:	f6 c1       	rjmp	.+1004   	; 0x2f4a <DoSampler+0x46c>
		{
			if(cardState==SD_IDLE)	// Make sure an SD card is present and ready to go
    2b5e:	80 91 59 05 	lds	r24, 0x0559
    2b62:	8e 30       	cpi	r24, 0x0E	; 14
    2b64:	09 f0       	breq	.+2      	; 0x2b68 <DoSampler+0x8a>
    2b66:	f1 c1       	rjmp	.+994    	; 0x2f4a <DoSampler+0x46c>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2b68:	87 ed       	ldi	r24, 0xD7	; 215
    2b6a:	91 e1       	ldi	r25, 0x11	; 17
    2b6c:	90 93 e4 05 	sts	0x05E4, r25
    2b70:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    2b74:	10 92 5b 05 	sts	0x055B, r1
    2b78:	e8 c1       	rjmp	.+976    	; 0x2f4a <DoSampler+0x46c>
	// -----------------------------------------------------------------------------------
	// Shift 1:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_1)	// Just the first shift key held?
	{
		if(keyState&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    2b7a:	80 91 58 05 	lds	r24, 0x0558
    2b7e:	80 ff       	sbrs	r24, 0
    2b80:	17 c0       	rjmp	.+46     	; 0x2bb0 <DoSampler+0xd2>
		{
			if(newEncoder||(newKeys&Im_SWITCH_0))	// Only update when the encoder changes OR the switch just got pressed
    2b82:	80 91 6b 05 	lds	r24, 0x056B
    2b86:	81 11       	cpse	r24, r1
    2b88:	04 c0       	rjmp	.+8      	; 0x2b92 <DoSampler+0xb4>
    2b8a:	80 91 57 05 	lds	r24, 0x0557
    2b8e:	80 ff       	sbrs	r24, 0
    2b90:	0f c0       	rjmp	.+30     	; 0x2bb0 <DoSampler+0xd2>
			{
				bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    2b92:	80 91 62 05 	lds	r24, 0x0562
    2b96:	20 91 6c 05 	lds	r18, 0x056C
    2b9a:	44 e2       	ldi	r20, 0x24	; 36
    2b9c:	84 9f       	mul	r24, r20
    2b9e:	f0 01       	movw	r30, r0
    2ba0:	11 24       	eor	r1, r1
    2ba2:	eb 51       	subi	r30, 0x1B	; 27
    2ba4:	fa 4f       	sbci	r31, 0xFA	; 250
    2ba6:	21 87       	std	Z+9, r18	; 0x09
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    2ba8:	43 e1       	ldi	r20, 0x13	; 19
    2baa:	64 e0       	ldi	r22, 0x04	; 4
    2bac:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_1)		// Screw and chop (toggle)
    2bb0:	80 91 57 05 	lds	r24, 0x0557
    2bb4:	81 ff       	sbrs	r24, 1
    2bb6:	15 c0       	rjmp	.+42     	; 0x2be2 <DoSampler+0x104>
		{
			if(bankStates[currentBank].halfSpeed==false)
    2bb8:	80 91 62 05 	lds	r24, 0x0562
    2bbc:	94 e2       	ldi	r25, 0x24	; 36
    2bbe:	89 9f       	mul	r24, r25
    2bc0:	f0 01       	movw	r30, r0
    2bc2:	11 24       	eor	r1, r1
    2bc4:	eb 51       	subi	r30, 0x1B	; 27
    2bc6:	fa 4f       	sbci	r31, 0xFA	; 250
    2bc8:	92 81       	ldd	r25, Z+2	; 0x02
    2bca:	91 11       	cpse	r25, r1
    2bcc:	04 c0       	rjmp	.+8      	; 0x2bd6 <DoSampler+0xf8>
			{
				bankStates[currentBank].halfSpeed=true;
    2bce:	91 e0       	ldi	r25, 0x01	; 1
    2bd0:	92 83       	std	Z+2, r25	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2bd2:	20 e4       	ldi	r18, 0x40	; 64
    2bd4:	02 c0       	rjmp	.+4      	; 0x2bda <DoSampler+0xfc>
			}
			else
			{
				bankStates[currentBank].halfSpeed=false;
    2bd6:	12 82       	std	Z+2, r1	; 0x02
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    2bd8:	20 e0       	ldi	r18, 0x00	; 0
    2bda:	40 e1       	ldi	r20, 0x10	; 16
    2bdc:	64 e0       	ldi	r22, 0x04	; 4
    2bde:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
			}
		}
		if(newKeys&Im_SWITCH_2)		// Do realtime
    2be2:	80 91 57 05 	lds	r24, 0x0557
    2be6:	82 ff       	sbrs	r24, 2
    2be8:	0e c0       	rjmp	.+28     	; 0x2c06 <DoSampler+0x128>
		{
			StartRealtime(currentBank,CLK_EXTERNAL,0);
    2bea:	10 91 62 05 	lds	r17, 0x0562
    2bee:	40 e0       	ldi	r20, 0x00	; 0
    2bf0:	50 e0       	ldi	r21, 0x00	; 0
    2bf2:	61 e0       	ldi	r22, 0x01	; 1
    2bf4:	81 2f       	mov	r24, r17
    2bf6:	0e 94 04 11 	call	0x2208	; 0x2208 <StartRealtime>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2bfa:	20 e3       	ldi	r18, 0x30	; 48
    2bfc:	4e e0       	ldi	r20, 0x0E	; 14
    2bfe:	64 e0       	ldi	r22, 0x04	; 4
    2c00:	81 2f       	mov	r24, r17
    2c02:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
		}
		if(((keyState&Im_SWITCH_3)&&newEncoder)||(newKeys&Im_SWITCH_3))		// Granularize the sample -- reshuffle if the encoder moves OR we get a new button press, but not just while the button is held
    2c06:	80 91 58 05 	lds	r24, 0x0558
    2c0a:	83 ff       	sbrs	r24, 3
    2c0c:	04 c0       	rjmp	.+8      	; 0x2c16 <DoSampler+0x138>
    2c0e:	80 91 6b 05 	lds	r24, 0x056B
    2c12:	81 11       	cpse	r24, r1
    2c14:	04 c0       	rjmp	.+8      	; 0x2c1e <DoSampler+0x140>
    2c16:	80 91 57 05 	lds	r24, 0x0557
    2c1a:	83 ff       	sbrs	r24, 3
    2c1c:	10 c0       	rjmp	.+32     	; 0x2c3e <DoSampler+0x160>
		{
			MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.
    2c1e:	20 91 6d 05 	lds	r18, 0x056D
    2c22:	26 95       	lsr	r18
    2c24:	10 91 62 05 	lds	r17, 0x0562
    2c28:	62 2f       	mov	r22, r18
    2c2a:	81 2f       	mov	r24, r17
    2c2c:	29 83       	std	Y+1, r18	; 0x01
    2c2e:	0e 94 42 09 	call	0x1284	; 0x1284 <MakeNewGranularArray>
			PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    2c32:	29 81       	ldd	r18, Y+1	; 0x01
    2c34:	44 e1       	ldi	r20, 0x14	; 20
    2c36:	64 e0       	ldi	r22, 0x04	; 4
    2c38:	81 2f       	mov	r24, r17
    2c3a:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
		}
		if(keyState&Im_SWITCH_4)		// Assign method for combining audio channels on the output.
    2c3e:	80 91 58 05 	lds	r24, 0x0558
    2c42:	84 ff       	sbrs	r24, 4
    2c44:	33 c0       	rjmp	.+102    	; 0x2cac <DoSampler+0x1ce>
		{
			if(newEncoder)	// Only change to new values
    2c46:	80 91 6b 05 	lds	r24, 0x056B
    2c4a:	88 23       	and	r24, r24
    2c4c:	79 f1       	breq	.+94     	; 0x2cac <DoSampler+0x1ce>
			{
				switch(scaledEncoderValue)
    2c4e:	80 91 6c 05 	lds	r24, 0x056C
    2c52:	81 30       	cpi	r24, 0x01	; 1
    2c54:	71 f0       	breq	.+28     	; 0x2c72 <DoSampler+0x194>
    2c56:	28 f0       	brcs	.+10     	; 0x2c62 <DoSampler+0x184>
    2c58:	82 30       	cpi	r24, 0x02	; 2
    2c5a:	99 f0       	breq	.+38     	; 0x2c82 <DoSampler+0x1a4>
    2c5c:	83 30       	cpi	r24, 0x03	; 3
    2c5e:	31 f5       	brne	.+76     	; 0x2cac <DoSampler+0x1ce>
    2c60:	18 c0       	rjmp	.+48     	; 0x2c92 <DoSampler+0x1b4>
				{
					case 0:
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2c62:	85 e3       	ldi	r24, 0x35	; 53
    2c64:	98 e0       	ldi	r25, 0x08	; 8
    2c66:	90 93 e2 05 	sts	0x05E2, r25
    2c6a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2c6e:	20 e0       	ldi	r18, 0x00	; 0
    2c70:	17 c0       	rjmp	.+46     	; 0x2ca0 <DoSampler+0x1c2>
					break;

					case 1:
					UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2c72:	89 ee       	ldi	r24, 0xE9	; 233
    2c74:	97 e0       	ldi	r25, 0x07	; 7
    2c76:	90 93 e2 05 	sts	0x05E2, r25
    2c7a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2c7e:	21 e0       	ldi	r18, 0x01	; 1
    2c80:	0f c0       	rjmp	.+30     	; 0x2ca0 <DoSampler+0x1c2>
					break;

					case 2:
					UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2c82:	88 ea       	ldi	r24, 0xA8	; 168
    2c84:	98 e0       	ldi	r25, 0x08	; 8
    2c86:	90 93 e2 05 	sts	0x05E2, r25
    2c8a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2c8e:	22 e0       	ldi	r18, 0x02	; 2
    2c90:	07 c0       	rjmp	.+14     	; 0x2ca0 <DoSampler+0x1c2>
					break;

					case 3:
					UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2c92:	8b e6       	ldi	r24, 0x6B	; 107
    2c94:	98 e0       	ldi	r25, 0x08	; 8
    2c96:	90 93 e2 05 	sts	0x05E2, r25
    2c9a:	80 93 e1 05 	sts	0x05E1, r24
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2c9e:	23 e0       	ldi	r18, 0x03	; 3
    2ca0:	46 e1       	ldi	r20, 0x16	; 22
    2ca2:	64 e0       	ldi	r22, 0x04	; 4
    2ca4:	80 91 62 05 	lds	r24, 0x0562
    2ca8:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
					default:
					break;
				}
			}
		}
		if(newKeys&Im_SWITCH_5)		// "Paul is Dead" mask (play backwards)
    2cac:	80 91 57 05 	lds	r24, 0x0557
    2cb0:	85 ff       	sbrs	r24, 5
    2cb2:	4b c1       	rjmp	.+662    	; 0x2f4a <DoSampler+0x46c>
		{
			if(bankStates[currentBank].backwardsPlayback==false)
    2cb4:	80 91 62 05 	lds	r24, 0x0562
    2cb8:	24 e2       	ldi	r18, 0x24	; 36
    2cba:	82 9f       	mul	r24, r18
    2cbc:	f0 01       	movw	r30, r0
    2cbe:	11 24       	eor	r1, r1
    2cc0:	eb 51       	subi	r30, 0x1B	; 27
    2cc2:	fa 4f       	sbci	r31, 0xFA	; 250
    2cc4:	93 81       	ldd	r25, Z+3	; 0x03
    2cc6:	91 11       	cpse	r25, r1
    2cc8:	04 c0       	rjmp	.+8      	; 0x2cd2 <DoSampler+0x1f4>
			{
				bankStates[currentBank].backwardsPlayback=true;
    2cca:	91 e0       	ldi	r25, 0x01	; 1
    2ccc:	93 83       	std	Z+3, r25	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2cce:	20 e4       	ldi	r18, 0x40	; 64
    2cd0:	02 c0       	rjmp	.+4      	; 0x2cd6 <DoSampler+0x1f8>
			}
			else
			{
				bankStates[currentBank].backwardsPlayback=false;
    2cd2:	13 82       	std	Z+3, r1	; 0x03
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2cd4:	20 e0       	ldi	r18, 0x00	; 0
    2cd6:	41 e1       	ldi	r20, 0x11	; 17
    2cd8:	64 e0       	ldi	r22, 0x04	; 4
    2cda:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
			}

			UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2cde:	80 91 62 05 	lds	r24, 0x0562
    2ce2:	0e 94 3f 0a 	call	0x147e	; 0x147e <UpdateAdjustedSampleAddresses>
    2ce6:	31 c1       	rjmp	.+610    	; 0x2f4a <DoSampler+0x46c>
		}
	}
	// -----------------------------------------------------------------------------------
	// Shift 2:
	// -----------------------------------------------------------------------------------
	else if(keysHeld&Im_SHIFT_2)	// Just the other shift key held?
    2ce8:	87 ff       	sbrs	r24, 7
    2cea:	55 c0       	rjmp	.+170    	; 0x2d96 <DoSampler+0x2b8>
	{
		if(keyState&Im_SWITCH_0)		// Adjust sample start
    2cec:	80 91 58 05 	lds	r24, 0x0558
    2cf0:	80 ff       	sbrs	r24, 0
    2cf2:	15 c0       	rjmp	.+42     	; 0x2d1e <DoSampler+0x240>
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2cf4:	10 91 62 05 	lds	r17, 0x0562
    2cf8:	44 e2       	ldi	r20, 0x24	; 36
    2cfa:	14 9f       	mul	r17, r20
    2cfc:	f0 01       	movw	r30, r0
    2cfe:	11 24       	eor	r1, r1
    2d00:	eb 51       	subi	r30, 0x1B	; 27
    2d02:	fa 4f       	sbci	r31, 0xFA	; 250
    2d04:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d06:	00 91 6d 05 	lds	r16, 0x056D
    2d0a:	80 17       	cp	r24, r16
    2d0c:	c9 f1       	breq	.+114    	; 0x2d80 <DoSampler+0x2a2>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    2d0e:	05 8f       	std	Z+29, r16	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    2d10:	81 2f       	mov	r24, r17
    2d12:	0e 94 3f 0a 	call	0x147e	; 0x147e <UpdateAdjustedSampleAddresses>
		if(keyState&Im_SWITCH_0)		// Adjust sample start
		{
			if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleStart(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2d16:	20 2f       	mov	r18, r16
    2d18:	26 95       	lsr	r18
    2d1a:	4c e1       	ldi	r20, 0x1C	; 28
    2d1c:	2d c0       	rjmp	.+90     	; 0x2d78 <DoSampler+0x29a>
			}
		}
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
    2d1e:	81 ff       	sbrs	r24, 1
    2d20:	15 c0       	rjmp	.+42     	; 0x2d4c <DoSampler+0x26e>
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2d22:	10 91 62 05 	lds	r17, 0x0562
    2d26:	84 e2       	ldi	r24, 0x24	; 36
    2d28:	18 9f       	mul	r17, r24
    2d2a:	f0 01       	movw	r30, r0
    2d2c:	11 24       	eor	r1, r1
    2d2e:	eb 51       	subi	r30, 0x1B	; 27
    2d30:	fa 4f       	sbci	r31, 0xFA	; 250
    2d32:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d34:	00 91 6d 05 	lds	r16, 0x056D
    2d38:	80 17       	cp	r24, r16
    2d3a:	11 f1       	breq	.+68     	; 0x2d80 <DoSampler+0x2a2>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    2d3c:	06 8f       	std	Z+30, r16	; 0x1e
	UpdateAdjustedSampleAddresses(theBank);
    2d3e:	81 2f       	mov	r24, r17
    2d40:	0e 94 3f 0a 	call	0x147e	; 0x147e <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_1)		// Adjust sample end
		{
			if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleEnd(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2d44:	20 2f       	mov	r18, r16
    2d46:	26 95       	lsr	r18
    2d48:	4d e1       	ldi	r20, 0x1D	; 29
    2d4a:	16 c0       	rjmp	.+44     	; 0x2d78 <DoSampler+0x29a>
			}
		}
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
    2d4c:	82 ff       	sbrs	r24, 2
    2d4e:	18 c0       	rjmp	.+48     	; 0x2d80 <DoSampler+0x2a2>
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    2d50:	10 91 62 05 	lds	r17, 0x0562
    2d54:	94 e2       	ldi	r25, 0x24	; 36
    2d56:	19 9f       	mul	r17, r25
    2d58:	f0 01       	movw	r30, r0
    2d5a:	11 24       	eor	r1, r1
    2d5c:	eb 51       	subi	r30, 0x1B	; 27
    2d5e:	fa 4f       	sbci	r31, 0xFA	; 250
    2d60:	87 8d       	ldd	r24, Z+31	; 0x1f
    2d62:	00 91 6d 05 	lds	r16, 0x056D
    2d66:	80 17       	cp	r24, r16
    2d68:	59 f0       	breq	.+22     	; 0x2d80 <DoSampler+0x2a2>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    2d6a:	07 8f       	std	Z+31, r16	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    2d6c:	81 2f       	mov	r24, r17
    2d6e:	0e 94 3f 0a 	call	0x147e	; 0x147e <UpdateAdjustedSampleAddresses>
		else if(keyState&Im_SWITCH_2)		// Adjust sample window
		{
			if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
			{
				AdjustSampleWindow(currentBank,encoderValue);
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,(encoderValue/2));		// Make into MIDI-worthy value (this will line up with the coarse adjust messages) and send it out to the techno nerds.
    2d72:	20 2f       	mov	r18, r16
    2d74:	26 95       	lsr	r18
    2d76:	4e e1       	ldi	r20, 0x1E	; 30
    2d78:	64 e0       	ldi	r22, 0x04	; 4
    2d7a:	81 2f       	mov	r24, r17
    2d7c:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
			}
		}

		if(newKeys&Im_SWITCH_3)		// Stream sample from SD card
    2d80:	80 91 57 05 	lds	r24, 0x0557
    2d84:	83 ff       	sbrs	r24, 3
    2d86:	e1 c0       	rjmp	.+450    	; 0x2f4a <DoSampler+0x46c>
		{
			PlaySampleFromSd(sdCurrentSlot);  // @@@ check idle
    2d88:	80 91 63 05 	lds	r24, 0x0563
    2d8c:	90 91 64 05 	lds	r25, 0x0564
    2d90:	0e 94 95 11 	call	0x232a	; 0x232a <PlaySampleFromSd>
    2d94:	da c0       	rjmp	.+436    	; 0x2f4a <DoSampler+0x46c>
	// -----------------------------------------------------------------------------------
	// No shift keys pressed:
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
    2d96:	80 91 57 05 	lds	r24, 0x0557
    2d9a:	80 ff       	sbrs	r24, 0
    2d9c:	22 c0       	rjmp	.+68     	; 0x2de2 <DoSampler+0x304>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2d9e:	10 91 62 05 	lds	r17, 0x0562
    2da2:	e4 e2       	ldi	r30, 0x24	; 36
    2da4:	1e 9f       	mul	r17, r30
    2da6:	60 01       	movw	r12, r0
    2da8:	11 24       	eor	r1, r1
    2daa:	85 ee       	ldi	r24, 0xE5	; 229
    2dac:	95 e0       	ldi	r25, 0x05	; 5
    2dae:	c8 0e       	add	r12, r24
    2db0:	d9 1e       	adc	r13, r25
    2db2:	f6 01       	movw	r30, r12
    2db4:	80 81       	ld	r24, Z
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2db6:	40 e0       	ldi	r20, 0x00	; 0
    2db8:	50 e0       	ldi	r21, 0x00	; 0
    2dba:	61 e0       	ldi	r22, 0x01	; 1
	// -----------------------------------------------------------------------------------
	else	// User isn't holding shift keys, look for single key presses
	{
		if(newKeys&Im_REC)										// Record switch pressed.
		{
			if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2dbc:	83 30       	cpi	r24, 0x03	; 3
    2dbe:	49 f4       	brne	.+18     	; 0x2dd2 <DoSampler+0x2f4>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2dc0:	81 2f       	mov	r24, r17
    2dc2:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2dc6:	f6 01       	movw	r30, r12
    2dc8:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2dca:	20 e4       	ldi	r18, 0x40	; 64
    2dcc:	40 e3       	ldi	r20, 0x30	; 48
    2dce:	61 e0       	ldi	r22, 0x01	; 1
    2dd0:	06 c0       	rjmp	.+12     	; 0x2dde <DoSampler+0x300>
			}
			else											// We're not recording right now, so start doing it.
			{
				StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2dd2:	81 2f       	mov	r24, r17
    2dd4:	0e 94 70 10 	call	0x20e0	; 0x20e0 <StartRecording>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2dd8:	20 e3       	ldi	r18, 0x30	; 48
    2dda:	43 e0       	ldi	r20, 0x03	; 3
    2ddc:	64 e0       	ldi	r22, 0x04	; 4
    2dde:	81 2f       	mov	r24, r17
    2de0:	a0 c0       	rjmp	.+320    	; 0x2f22 <DoSampler+0x444>
			}
		}
		else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2de2:	81 ff       	sbrs	r24, 1
    2de4:	31 c0       	rjmp	.+98     	; 0x2e48 <DoSampler+0x36a>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    2de6:	f0 90 62 05 	lds	r15, 0x0562
    2dea:	f4 e2       	ldi	r31, 0x24	; 36
    2dec:	ff 9e       	mul	r15, r31
    2dee:	60 01       	movw	r12, r0
    2df0:	11 24       	eor	r1, r1
    2df2:	85 ee       	ldi	r24, 0xE5	; 229
    2df4:	95 e0       	ldi	r25, 0x05	; 5
    2df6:	c8 0e       	add	r12, r24
    2df8:	d9 1e       	adc	r13, r25
    2dfa:	f6 01       	movw	r30, r12
    2dfc:	80 81       	ld	r24, Z
    2dfe:	85 30       	cpi	r24, 0x05	; 5
    2e00:	51 f4       	brne	.+20     	; 0x2e16 <DoSampler+0x338>
			{
				ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
    2e02:	40 e0       	ldi	r20, 0x00	; 0
    2e04:	50 e0       	ldi	r21, 0x00	; 0
    2e06:	61 e0       	ldi	r22, 0x01	; 1
    2e08:	8f 2d       	mov	r24, r15
    2e0a:	0e 94 48 10 	call	0x2090	; 0x2090 <ContinuePlayback>
				bankStates[currentBank].loopOnce=false;
    2e0e:	f6 01       	movw	r30, r12
    2e10:	11 82       	std	Z+1, r1	; 0x01
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    2e12:	20 e0       	ldi	r18, 0x00	; 0
    2e14:	16 c0       	rjmp	.+44     	; 0x2e42 <DoSampler+0x364>
			}
			else							// We're not recording right now, so start doing it.
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    2e16:	f6 01       	movw	r30, r12
    2e18:	01 89       	ldd	r16, Z+17	; 0x11
    2e1a:	12 89       	ldd	r17, Z+18	; 0x12
    2e1c:	23 89       	ldd	r18, Z+19	; 0x13
    2e1e:	34 89       	ldd	r19, Z+20	; 0x14
    2e20:	45 85       	ldd	r20, Z+13	; 0x0d
    2e22:	56 85       	ldd	r21, Z+14	; 0x0e
    2e24:	67 85       	ldd	r22, Z+15	; 0x0f
    2e26:	70 89       	ldd	r23, Z+16	; 0x10
    2e28:	04 17       	cp	r16, r20
    2e2a:	15 07       	cpc	r17, r21
    2e2c:	26 07       	cpc	r18, r22
    2e2e:	37 07       	cpc	r19, r23
    2e30:	09 f4       	brne	.+2      	; 0x2e34 <DoSampler+0x356>
    2e32:	8b c0       	rjmp	.+278    	; 0x2f4a <DoSampler+0x46c>
				{
					StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
    2e34:	40 e0       	ldi	r20, 0x00	; 0
    2e36:	50 e0       	ldi	r21, 0x00	; 0
    2e38:	61 e0       	ldi	r22, 0x01	; 1
    2e3a:	8f 2d       	mov	r24, r15
    2e3c:	0e 94 ce 10 	call	0x219c	; 0x219c <StartOverdub>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2e40:	20 e3       	ldi	r18, 0x30	; 48
    2e42:	49 e0       	ldi	r20, 0x09	; 9
    2e44:	64 e0       	ldi	r22, 0x04	; 4
    2e46:	6c c0       	rjmp	.+216    	; 0x2f20 <DoSampler+0x442>
				}
			}
		}
		else if(newKeys&Im_RESTART_LOOP)		// Begin playing the current sample from the beginning, while looping
    2e48:	82 ff       	sbrs	r24, 2
    2e4a:	22 c0       	rjmp	.+68     	; 0x2e90 <DoSampler+0x3b2>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2e4c:	f0 90 62 05 	lds	r15, 0x0562
    2e50:	f4 e2       	ldi	r31, 0x24	; 36
    2e52:	ff 9e       	mul	r15, r31
    2e54:	60 01       	movw	r12, r0
    2e56:	11 24       	eor	r1, r1
    2e58:	85 ee       	ldi	r24, 0xE5	; 229
    2e5a:	95 e0       	ldi	r25, 0x05	; 5
    2e5c:	c8 0e       	add	r12, r24
    2e5e:	d9 1e       	adc	r13, r25
    2e60:	f6 01       	movw	r30, r12
    2e62:	01 89       	ldd	r16, Z+17	; 0x11
    2e64:	12 89       	ldd	r17, Z+18	; 0x12
    2e66:	23 89       	ldd	r18, Z+19	; 0x13
    2e68:	34 89       	ldd	r19, Z+20	; 0x14
    2e6a:	45 85       	ldd	r20, Z+13	; 0x0d
    2e6c:	56 85       	ldd	r21, Z+14	; 0x0e
    2e6e:	67 85       	ldd	r22, Z+15	; 0x0f
    2e70:	70 89       	ldd	r23, Z+16	; 0x10
    2e72:	04 17       	cp	r16, r20
    2e74:	15 07       	cpc	r17, r21
    2e76:	26 07       	cpc	r18, r22
    2e78:	37 07       	cpc	r19, r23
    2e7a:	09 f4       	brne	.+2      	; 0x2e7e <DoSampler+0x3a0>
    2e7c:	66 c0       	rjmp	.+204    	; 0x2f4a <DoSampler+0x46c>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2e7e:	40 e0       	ldi	r20, 0x00	; 0
    2e80:	50 e0       	ldi	r21, 0x00	; 0
    2e82:	61 e0       	ldi	r22, 0x01	; 1
    2e84:	8f 2d       	mov	r24, r15
    2e86:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <StartPlayback>
				bankStates[currentBank].loopOnce=false;
    2e8a:	f6 01       	movw	r30, r12
    2e8c:	11 82       	std	Z+1, r1	; 0x01
    2e8e:	45 c0       	rjmp	.+138    	; 0x2f1a <DoSampler+0x43c>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
			}
		}
		else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    2e90:	83 ff       	sbrs	r24, 3
    2e92:	23 c0       	rjmp	.+70     	; 0x2eda <DoSampler+0x3fc>
		{
			if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2e94:	f0 90 62 05 	lds	r15, 0x0562
    2e98:	f4 e2       	ldi	r31, 0x24	; 36
    2e9a:	ff 9e       	mul	r15, r31
    2e9c:	60 01       	movw	r12, r0
    2e9e:	11 24       	eor	r1, r1
    2ea0:	85 ee       	ldi	r24, 0xE5	; 229
    2ea2:	95 e0       	ldi	r25, 0x05	; 5
    2ea4:	c8 0e       	add	r12, r24
    2ea6:	d9 1e       	adc	r13, r25
    2ea8:	f6 01       	movw	r30, r12
    2eaa:	01 89       	ldd	r16, Z+17	; 0x11
    2eac:	12 89       	ldd	r17, Z+18	; 0x12
    2eae:	23 89       	ldd	r18, Z+19	; 0x13
    2eb0:	34 89       	ldd	r19, Z+20	; 0x14
    2eb2:	45 85       	ldd	r20, Z+13	; 0x0d
    2eb4:	56 85       	ldd	r21, Z+14	; 0x0e
    2eb6:	67 85       	ldd	r22, Z+15	; 0x0f
    2eb8:	70 89       	ldd	r23, Z+16	; 0x10
    2eba:	04 17       	cp	r16, r20
    2ebc:	15 07       	cpc	r17, r21
    2ebe:	26 07       	cpc	r18, r22
    2ec0:	37 07       	cpc	r19, r23
    2ec2:	09 f4       	brne	.+2      	; 0x2ec6 <DoSampler+0x3e8>
    2ec4:	42 c0       	rjmp	.+132    	; 0x2f4a <DoSampler+0x46c>
			{
				StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    2ec6:	40 e0       	ldi	r20, 0x00	; 0
    2ec8:	50 e0       	ldi	r21, 0x00	; 0
    2eca:	61 e0       	ldi	r22, 0x01	; 1
    2ecc:	8f 2d       	mov	r24, r15
    2ece:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <StartPlayback>
				bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    2ed2:	81 e0       	ldi	r24, 0x01	; 1
    2ed4:	f6 01       	movw	r30, r12
    2ed6:	81 83       	std	Z+1, r24	; 0x01
    2ed8:	20 c0       	rjmp	.+64     	; 0x2f1a <DoSampler+0x43c>
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
			}
		}
		else if(newKeys&Im_PAUSE_RESUME)		// Play / Pause switch pressed.  If anything is playing this will stop it at the current sample location.  If playback is idle it will restart it.  This will not restart a playing sample from the beginning.
    2eda:	84 ff       	sbrs	r24, 4
    2edc:	2b c0       	rjmp	.+86     	; 0x2f34 <DoSampler+0x456>
		{
			if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    2ede:	f0 90 62 05 	lds	r15, 0x0562
    2ee2:	24 e2       	ldi	r18, 0x24	; 36
    2ee4:	f2 9e       	mul	r15, r18
    2ee6:	f0 01       	movw	r30, r0
    2ee8:	11 24       	eor	r1, r1
    2eea:	eb 51       	subi	r30, 0x1B	; 27
    2eec:	fa 4f       	sbci	r31, 0xFA	; 250
    2eee:	80 81       	ld	r24, Z
    2ef0:	81 11       	cpse	r24, r1
    2ef2:	1a c0       	rjmp	.+52     	; 0x2f28 <DoSampler+0x44a>
			{
				if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    2ef4:	01 89       	ldd	r16, Z+17	; 0x11
    2ef6:	12 89       	ldd	r17, Z+18	; 0x12
    2ef8:	23 89       	ldd	r18, Z+19	; 0x13
    2efa:	34 89       	ldd	r19, Z+20	; 0x14
    2efc:	45 85       	ldd	r20, Z+13	; 0x0d
    2efe:	56 85       	ldd	r21, Z+14	; 0x0e
    2f00:	67 85       	ldd	r22, Z+15	; 0x0f
    2f02:	70 89       	ldd	r23, Z+16	; 0x10
    2f04:	04 17       	cp	r16, r20
    2f06:	15 07       	cpc	r17, r21
    2f08:	26 07       	cpc	r18, r22
    2f0a:	37 07       	cpc	r19, r23
    2f0c:	f1 f0       	breq	.+60     	; 0x2f4a <DoSampler+0x46c>
				{
					ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
    2f0e:	40 e0       	ldi	r20, 0x00	; 0
    2f10:	50 e0       	ldi	r21, 0x00	; 0
    2f12:	61 e0       	ldi	r22, 0x01	; 1
    2f14:	8f 2d       	mov	r24, r15
    2f16:	0e 94 48 10 	call	0x2090	; 0x2090 <ContinuePlayback>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2f1a:	20 e4       	ldi	r18, 0x40	; 64
    2f1c:	40 e3       	ldi	r20, 0x30	; 48
    2f1e:	61 e0       	ldi	r22, 0x01	; 1
    2f20:	8f 2d       	mov	r24, r15
    2f22:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <PutMidiMessageInOutgoingFifo>
    2f26:	11 c0       	rjmp	.+34     	; 0x2f4a <DoSampler+0x46c>
				}
			}
			else		// Pause whatever we were doing.
			{
				bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    2f28:	10 82       	st	Z, r1
				bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    2f2a:	12 86       	std	Z+10, r1	; 0x0a
				PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    2f2c:	20 e0       	ldi	r18, 0x00	; 0
    2f2e:	40 e3       	ldi	r20, 0x30	; 48
    2f30:	62 e0       	ldi	r22, 0x02	; 2
    2f32:	f6 cf       	rjmp	.-20     	; 0x2f20 <DoSampler+0x442>
			}

		}
		else if(newKeys&Im_BANK_CHANGE)		// Increment through banks when this button is pressed.
    2f34:	85 ff       	sbrs	r24, 5
    2f36:	09 c0       	rjmp	.+18     	; 0x2f4a <DoSampler+0x46c>
		{
			currentBank++;
    2f38:	80 91 62 05 	lds	r24, 0x0562
    2f3c:	8f 5f       	subi	r24, 0xFF	; 255
    2f3e:	80 93 62 05 	sts	0x0562, r24
			if(currentBank>=NUM_BANKS)
    2f42:	82 30       	cpi	r24, 0x02	; 2
    2f44:	10 f0       	brcs	.+4      	; 0x2f4a <DoSampler+0x46c>
			{
				currentBank=BANK_0;		// Loop around.
    2f46:	10 92 62 05 	sts	0x0562, r1

	if(subState==SS_0)					// Hang out here getting keypresses and MIDI and handling the different sampler functions.
	{
		UpdateUserSwitches();			// Handle keypresses coming in through front panel UI

		if(midiMessagesInIncomingFifo)	// Dealt with caveman inputs, now deal with MIDI.
    2f4a:	80 91 61 06 	lds	r24, 0x0661
    2f4e:	88 23       	and	r24, r24
    2f50:	09 f4       	brne	.+2      	; 0x2f54 <DoSampler+0x476>
    2f52:	85 c2       	rjmp	.+1290   	; 0x345e <DoSampler+0x980>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    2f54:	85 e6       	ldi	r24, 0x65	; 101
    2f56:	95 e0       	ldi	r25, 0x05	; 5
    2f58:	0e 94 69 1f 	call	0x3ed2	; 0x3ed2 <GetMidiMessageFromIncomingFifo>
//			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
//			{
//				// Do this here.
//			}

			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    2f5c:	80 91 66 05 	lds	r24, 0x0566
    2f60:	82 30       	cpi	r24, 0x02	; 2
    2f62:	11 f5       	brne	.+68     	; 0x2fa8 <DoSampler+0x4ca>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    2f64:	e0 91 65 05 	lds	r30, 0x0565
    2f68:	8e 2f       	mov	r24, r30
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	44 e2       	ldi	r20, 0x24	; 36
    2f6e:	e4 9f       	mul	r30, r20
    2f70:	f0 01       	movw	r30, r0
    2f72:	11 24       	eor	r1, r1
    2f74:	eb 51       	subi	r30, 0x1B	; 27
    2f76:	fa 4f       	sbci	r31, 0xFA	; 250
    2f78:	20 81       	ld	r18, Z
    2f7a:	24 30       	cpi	r18, 0x04	; 4
    2f7c:	21 f0       	breq	.+8      	; 0x2f86 <DoSampler+0x4a8>
    2f7e:	20 81       	ld	r18, Z
    2f80:	22 30       	cpi	r18, 0x02	; 2
    2f82:	09 f0       	breq	.+2      	; 0x2f86 <DoSampler+0x4a8>
    2f84:	6c c2       	rjmp	.+1240   	; 0x345e <DoSampler+0x980>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    2f86:	fc 01       	movw	r30, r24
    2f88:	ec 5f       	subi	r30, 0xFC	; 252
    2f8a:	fe 4f       	sbci	r31, 0xFE	; 254
    2f8c:	30 91 67 05 	lds	r19, 0x0567
    2f90:	20 81       	ld	r18, Z
    2f92:	32 13       	cpse	r19, r18
    2f94:	64 c2       	rjmp	.+1224   	; 0x345e <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    2f96:	24 e2       	ldi	r18, 0x24	; 36
    2f98:	28 9f       	mul	r18, r24
    2f9a:	f0 01       	movw	r30, r0
    2f9c:	29 9f       	mul	r18, r25
    2f9e:	f0 0d       	add	r31, r0
    2fa0:	11 24       	eor	r1, r1
    2fa2:	eb 51       	subi	r30, 0x1B	; 27
    2fa4:	fa 4f       	sbci	r31, 0xFA	; 250
    2fa6:	82 c0       	rjmp	.+260    	; 0x30ac <DoSampler+0x5ce>
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    2fa8:	81 30       	cpi	r24, 0x01	; 1
    2faa:	09 f0       	breq	.+2      	; 0x2fae <DoSampler+0x4d0>
    2fac:	4d c0       	rjmp	.+154    	; 0x3048 <DoSampler+0x56a>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    2fae:	a0 91 65 05 	lds	r26, 0x0565
    2fb2:	2a 2f       	mov	r18, r26
    2fb4:	30 e0       	ldi	r19, 0x00	; 0
    2fb6:	80 91 67 05 	lds	r24, 0x0567
    2fba:	f9 01       	movw	r30, r18
    2fbc:	ec 5f       	subi	r30, 0xFC	; 252
    2fbe:	fe 4f       	sbci	r31, 0xFE	; 254
    2fc0:	80 83       	st	Z, r24

				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
    2fc2:	94 e2       	ldi	r25, 0x24	; 36
    2fc4:	92 9f       	mul	r25, r18
    2fc6:	f0 01       	movw	r30, r0
    2fc8:	93 9f       	mul	r25, r19
    2fca:	f0 0d       	add	r31, r0
    2fcc:	11 24       	eor	r1, r1
    2fce:	eb 51       	subi	r30, 0x1B	; 27
    2fd0:	fa 4f       	sbci	r31, 0xFA	; 250
    2fd2:	96 81       	ldd	r25, Z+6	; 0x06
    2fd4:	99 23       	and	r25, r25
    2fd6:	a9 f0       	breq	.+42     	; 0x3002 <DoSampler+0x524>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    2fd8:	6c e0       	ldi	r22, 0x0C	; 12
    2fda:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    2fde:	e9 2f       	mov	r30, r25
    2fe0:	f0 e0       	ldi	r31, 0x00	; 0
    2fe2:	ee 0f       	add	r30, r30
    2fe4:	ff 1f       	adc	r31, r31
    2fe6:	ea 5f       	subi	r30, 0xFA	; 250
    2fe8:	fe 4f       	sbci	r31, 0xFE	; 254
    2fea:	40 81       	ld	r20, Z
    2fec:	51 81       	ldd	r21, Z+1	; 0x01
    2fee:	02 c0       	rjmp	.+4      	; 0x2ff4 <DoSampler+0x516>
    2ff0:	56 95       	lsr	r21
    2ff2:	47 95       	ror	r20
    2ff4:	8a 95       	dec	r24
    2ff6:	e2 f7       	brpl	.-8      	; 0x2ff0 <DoSampler+0x512>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.

				if(bankStates[currentMidiMessage.channelNumber].realtimeOn)			// Real time sound editing?
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.
    2ff8:	62 e0       	ldi	r22, 0x02	; 2
    2ffa:	8a 2f       	mov	r24, r26
    2ffc:	0e 94 04 11 	call	0x2208	; 0x2208 <StartRealtime>
    3000:	2e c2       	rjmp	.+1116   	; 0x345e <DoSampler+0x980>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    3002:	01 89       	ldd	r16, Z+17	; 0x11
    3004:	12 89       	ldd	r17, Z+18	; 0x12
    3006:	23 89       	ldd	r18, Z+19	; 0x13
    3008:	34 89       	ldd	r19, Z+20	; 0x14
    300a:	45 85       	ldd	r20, Z+13	; 0x0d
    300c:	56 85       	ldd	r21, Z+14	; 0x0e
    300e:	67 85       	ldd	r22, Z+15	; 0x0f
    3010:	70 89       	ldd	r23, Z+16	; 0x10
    3012:	04 17       	cp	r16, r20
    3014:	15 07       	cpc	r17, r21
    3016:	26 07       	cpc	r18, r22
    3018:	37 07       	cpc	r19, r23
    301a:	09 f4       	brne	.+2      	; 0x301e <DoSampler+0x540>
    301c:	20 c2       	rjmp	.+1088   	; 0x345e <DoSampler+0x980>
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    301e:	6c e0       	ldi	r22, 0x0C	; 12
    3020:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3024:	e9 2f       	mov	r30, r25
    3026:	f0 e0       	ldi	r31, 0x00	; 0
    3028:	ee 0f       	add	r30, r30
    302a:	ff 1f       	adc	r31, r31
    302c:	ea 5f       	subi	r30, 0xFA	; 250
    302e:	fe 4f       	sbci	r31, 0xFE	; 254
    3030:	40 81       	ld	r20, Z
    3032:	51 81       	ldd	r21, Z+1	; 0x01
    3034:	02 c0       	rjmp	.+4      	; 0x303a <DoSampler+0x55c>
    3036:	56 95       	lsr	r21
    3038:	47 95       	ror	r20
    303a:	8a 95       	dec	r24
    303c:	e2 f7       	brpl	.-8      	; 0x3036 <DoSampler+0x558>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    303e:	62 e0       	ldi	r22, 0x02	; 2
    3040:	8a 2f       	mov	r24, r26
    3042:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <StartPlayback>
    3046:	0b c2       	rjmp	.+1046   	; 0x345e <DoSampler+0x980>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    3048:	84 30       	cpi	r24, 0x04	; 4
    304a:	09 f0       	breq	.+2      	; 0x304e <DoSampler+0x570>
    304c:	af c1       	rjmp	.+862    	; 0x33ac <DoSampler+0x8ce>
			{
				switch(currentMidiMessage.dataByteOne)
    304e:	80 91 67 05 	lds	r24, 0x0567
    3052:	90 e0       	ldi	r25, 0x00	; 0
    3054:	fc 01       	movw	r30, r24
    3056:	33 97       	sbiw	r30, 0x03	; 3
    3058:	ec 31       	cpi	r30, 0x1C	; 28
    305a:	f1 05       	cpc	r31, r1
    305c:	08 f0       	brcs	.+2      	; 0x3060 <DoSampler+0x582>
    305e:	ff c1       	rjmp	.+1022   	; 0x345e <DoSampler+0x980>
    3060:	e2 5c       	subi	r30, 0xC2	; 194
    3062:	ff 4f       	sbci	r31, 0xFF	; 255
    3064:	0c 94 fd 29 	jmp	0x53fa	; 0x53fa <__tablejump2__>
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3068:	90 91 68 05 	lds	r25, 0x0568
    306c:	80 91 65 05 	lds	r24, 0x0565
    3070:	99 23       	and	r25, r25
    3072:	91 f0       	breq	.+36     	; 0x3098 <DoSampler+0x5ba>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    3074:	a8 2f       	mov	r26, r24
    3076:	b0 e0       	ldi	r27, 0x00	; 0
    3078:	aa 0f       	add	r26, r26
    307a:	bb 1f       	adc	r27, r27
    307c:	a2 5a       	subi	r26, 0xA2	; 162
    307e:	ba 4f       	sbci	r27, 0xFA	; 250
    3080:	4d 91       	ld	r20, X+
    3082:	5c 91       	ld	r21, X
    3084:	62 e0       	ldi	r22, 0x02	; 2
    3086:	0e 94 70 10 	call	0x20e0	; 0x20e0 <StartRecording>
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;																		// We'll default to playback after a recording.
    308a:	e0 91 65 05 	lds	r30, 0x0565
    308e:	84 e2       	ldi	r24, 0x24	; 36
    3090:	e8 9f       	mul	r30, r24
    3092:	f0 01       	movw	r30, r0
    3094:	11 24       	eor	r1, r1
    3096:	38 c0       	rjmp	.+112    	; 0x3108 <DoSampler+0x62a>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    3098:	94 e2       	ldi	r25, 0x24	; 36
    309a:	89 9f       	mul	r24, r25
    309c:	f0 01       	movw	r30, r0
    309e:	11 24       	eor	r1, r1
    30a0:	eb 51       	subi	r30, 0x1B	; 27
    30a2:	fa 4f       	sbci	r31, 0xFA	; 250
    30a4:	80 81       	ld	r24, Z
    30a6:	83 30       	cpi	r24, 0x03	; 3
    30a8:	09 f0       	breq	.+2      	; 0x30ac <DoSampler+0x5ce>
    30aa:	d9 c1       	rjmp	.+946    	; 0x345e <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    30ac:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    30ae:	12 86       	std	Z+10, r1	; 0x0a
    30b0:	d6 c1       	rjmp	.+940    	; 0x345e <DoSampler+0x980>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    30b2:	90 91 68 05 	lds	r25, 0x0568
    30b6:	80 91 65 05 	lds	r24, 0x0565
    30ba:	99 23       	and	r25, r25
    30bc:	41 f1       	breq	.+80     	; 0x310e <DoSampler+0x630>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    30be:	a8 2f       	mov	r26, r24
    30c0:	b0 e0       	ldi	r27, 0x00	; 0
    30c2:	24 e2       	ldi	r18, 0x24	; 36
    30c4:	f2 2e       	mov	r15, r18
    30c6:	fa 9e       	mul	r15, r26
    30c8:	f0 01       	movw	r30, r0
    30ca:	fb 9e       	mul	r15, r27
    30cc:	f0 0d       	add	r31, r0
    30ce:	11 24       	eor	r1, r1
    30d0:	eb 51       	subi	r30, 0x1B	; 27
    30d2:	fa 4f       	sbci	r31, 0xFA	; 250
    30d4:	01 89       	ldd	r16, Z+17	; 0x11
    30d6:	12 89       	ldd	r17, Z+18	; 0x12
    30d8:	23 89       	ldd	r18, Z+19	; 0x13
    30da:	34 89       	ldd	r19, Z+20	; 0x14
    30dc:	45 85       	ldd	r20, Z+13	; 0x0d
    30de:	56 85       	ldd	r21, Z+14	; 0x0e
    30e0:	67 85       	ldd	r22, Z+15	; 0x0f
    30e2:	70 89       	ldd	r23, Z+16	; 0x10
    30e4:	04 17       	cp	r16, r20
    30e6:	15 07       	cpc	r17, r21
    30e8:	26 07       	cpc	r18, r22
    30ea:	37 07       	cpc	r19, r23
    30ec:	09 f4       	brne	.+2      	; 0x30f0 <DoSampler+0x612>
    30ee:	b7 c1       	rjmp	.+878    	; 0x345e <DoSampler+0x980>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    30f0:	ac 5f       	subi	r26, 0xFC	; 252
    30f2:	be 4f       	sbci	r27, 0xFE	; 254
    30f4:	4c 91       	ld	r20, X
    30f6:	50 e0       	ldi	r21, 0x00	; 0
    30f8:	62 e0       	ldi	r22, 0x02	; 2
    30fa:	0e 94 ce 10 	call	0x219c	; 0x219c <StartOverdub>
							bankStates[currentMidiMessage.channelNumber].realtimeOn=false;															// We'll default to playback after a recording.
    30fe:	e0 91 65 05 	lds	r30, 0x0565
    3102:	fe 9e       	mul	r15, r30
    3104:	f0 01       	movw	r30, r0
    3106:	11 24       	eor	r1, r1
    3108:	eb 51       	subi	r30, 0x1B	; 27
    310a:	fa 4f       	sbci	r31, 0xFA	; 250
    310c:	3d c0       	rjmp	.+122    	; 0x3188 <DoSampler+0x6aa>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    310e:	28 2f       	mov	r18, r24
    3110:	30 e0       	ldi	r19, 0x00	; 0
    3112:	44 e2       	ldi	r20, 0x24	; 36
    3114:	84 9f       	mul	r24, r20
    3116:	f0 01       	movw	r30, r0
    3118:	11 24       	eor	r1, r1
    311a:	eb 51       	subi	r30, 0x1B	; 27
    311c:	fa 4f       	sbci	r31, 0xFA	; 250
    311e:	90 81       	ld	r25, Z
    3120:	95 30       	cpi	r25, 0x05	; 5
    3122:	09 f0       	breq	.+2      	; 0x3126 <DoSampler+0x648>
    3124:	9c c1       	rjmp	.+824    	; 0x345e <DoSampler+0x980>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    3126:	f9 01       	movw	r30, r18
    3128:	ec 5f       	subi	r30, 0xFC	; 252
    312a:	fe 4f       	sbci	r31, 0xFE	; 254
    312c:	40 81       	ld	r20, Z
    312e:	50 e0       	ldi	r21, 0x00	; 0
    3130:	62 e0       	ldi	r22, 0x02	; 2
    3132:	0e 94 48 10 	call	0x2090	; 0x2090 <ContinuePlayback>
    3136:	93 c1       	rjmp	.+806    	; 0x345e <DoSampler+0x980>
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3138:	90 91 68 05 	lds	r25, 0x0568
    313c:	80 91 65 05 	lds	r24, 0x0565
    3140:	99 23       	and	r25, r25
    3142:	b1 f0       	breq	.+44     	; 0x3170 <DoSampler+0x692>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    3144:	a8 2f       	mov	r26, r24
    3146:	b0 e0       	ldi	r27, 0x00	; 0
    3148:	aa 0f       	add	r26, r26
    314a:	bb 1f       	adc	r27, r27
    314c:	a2 5a       	subi	r26, 0xA2	; 162
    314e:	ba 4f       	sbci	r27, 0xFA	; 250
    3150:	4d 91       	ld	r20, X+
    3152:	5c 91       	ld	r21, X
    3154:	62 e0       	ldi	r22, 0x02	; 2
    3156:	0e 94 04 11 	call	0x2208	; 0x2208 <StartRealtime>
						bankStates[currentMidiMessage.channelNumber].realtimeOn=true;															// Set flag so that we don't stop realtime processing if we get a note off.
    315a:	e0 91 65 05 	lds	r30, 0x0565
    315e:	84 e2       	ldi	r24, 0x24	; 36
    3160:	e8 9f       	mul	r30, r24
    3162:	f0 01       	movw	r30, r0
    3164:	11 24       	eor	r1, r1
    3166:	eb 51       	subi	r30, 0x1B	; 27
    3168:	fa 4f       	sbci	r31, 0xFA	; 250
    316a:	81 e0       	ldi	r24, 0x01	; 1
    316c:	86 83       	std	Z+6, r24	; 0x06
    316e:	77 c1       	rjmp	.+750    	; 0x345e <DoSampler+0x980>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    3170:	94 e2       	ldi	r25, 0x24	; 36
    3172:	89 9f       	mul	r24, r25
    3174:	f0 01       	movw	r30, r0
    3176:	11 24       	eor	r1, r1
    3178:	eb 51       	subi	r30, 0x1B	; 27
    317a:	fa 4f       	sbci	r31, 0xFA	; 250
    317c:	80 81       	ld	r24, Z
    317e:	82 30       	cpi	r24, 0x02	; 2
    3180:	09 f0       	breq	.+2      	; 0x3184 <DoSampler+0x6a6>
    3182:	6d c1       	rjmp	.+730    	; 0x345e <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    3184:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    3186:	12 86       	std	Z+10, r1	; 0x0a
						bankStates[currentMidiMessage.channelNumber].realtimeOn=false;					// We'll default to playback.
    3188:	16 82       	std	Z+6, r1	; 0x06
    318a:	69 c1       	rjmp	.+722    	; 0x345e <DoSampler+0x980>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    318c:	80 91 68 05 	lds	r24, 0x0568
    3190:	e0 91 65 05 	lds	r30, 0x0565
    3194:	88 23       	and	r24, r24
    3196:	41 f0       	breq	.+16     	; 0x31a8 <DoSampler+0x6ca>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    3198:	24 e2       	ldi	r18, 0x24	; 36
    319a:	e2 9f       	mul	r30, r18
    319c:	f0 01       	movw	r30, r0
    319e:	11 24       	eor	r1, r1
    31a0:	eb 51       	subi	r30, 0x1B	; 27
    31a2:	fa 4f       	sbci	r31, 0xFA	; 250
    31a4:	11 82       	std	Z+1, r1	; 0x01
    31a6:	5b c1       	rjmp	.+694    	; 0x345e <DoSampler+0x980>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    31a8:	44 e2       	ldi	r20, 0x24	; 36
    31aa:	e4 9f       	mul	r30, r20
    31ac:	f0 01       	movw	r30, r0
    31ae:	11 24       	eor	r1, r1
    31b0:	eb 51       	subi	r30, 0x1B	; 27
    31b2:	fa 4f       	sbci	r31, 0xFA	; 250
    31b4:	81 e0       	ldi	r24, 0x01	; 1
    31b6:	81 83       	std	Z+1, r24	; 0x01
    31b8:	52 c1       	rjmp	.+676    	; 0x345e <DoSampler+0x980>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    31ba:	80 91 68 05 	lds	r24, 0x0568
    31be:	e0 91 65 05 	lds	r30, 0x0565
    31c2:	88 23       	and	r24, r24
    31c4:	49 f0       	breq	.+18     	; 0x31d8 <DoSampler+0x6fa>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    31c6:	84 e2       	ldi	r24, 0x24	; 36
    31c8:	e8 9f       	mul	r30, r24
    31ca:	f0 01       	movw	r30, r0
    31cc:	11 24       	eor	r1, r1
    31ce:	eb 51       	subi	r30, 0x1B	; 27
    31d0:	fa 4f       	sbci	r31, 0xFA	; 250
    31d2:	81 e0       	ldi	r24, 0x01	; 1
    31d4:	82 83       	std	Z+2, r24	; 0x02
    31d6:	43 c1       	rjmp	.+646    	; 0x345e <DoSampler+0x980>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    31d8:	94 e2       	ldi	r25, 0x24	; 36
    31da:	e9 9f       	mul	r30, r25
    31dc:	f0 01       	movw	r30, r0
    31de:	11 24       	eor	r1, r1
    31e0:	eb 51       	subi	r30, 0x1B	; 27
    31e2:	fa 4f       	sbci	r31, 0xFA	; 250
    31e4:	12 82       	std	Z+2, r1	; 0x02
    31e6:	3b c1       	rjmp	.+630    	; 0x345e <DoSampler+0x980>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    31e8:	80 91 68 05 	lds	r24, 0x0568
    31ec:	e0 91 65 05 	lds	r30, 0x0565
    31f0:	88 23       	and	r24, r24
    31f2:	49 f0       	breq	.+18     	; 0x3206 <DoSampler+0x728>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    31f4:	24 e2       	ldi	r18, 0x24	; 36
    31f6:	e2 9f       	mul	r30, r18
    31f8:	f0 01       	movw	r30, r0
    31fa:	11 24       	eor	r1, r1
    31fc:	eb 51       	subi	r30, 0x1B	; 27
    31fe:	fa 4f       	sbci	r31, 0xFA	; 250
    3200:	81 e0       	ldi	r24, 0x01	; 1
    3202:	83 83       	std	Z+3, r24	; 0x03
    3204:	07 c0       	rjmp	.+14     	; 0x3214 <DoSampler+0x736>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    3206:	44 e2       	ldi	r20, 0x24	; 36
    3208:	e4 9f       	mul	r30, r20
    320a:	f0 01       	movw	r30, r0
    320c:	11 24       	eor	r1, r1
    320e:	eb 51       	subi	r30, 0x1B	; 27
    3210:	fa 4f       	sbci	r31, 0xFA	; 250
    3212:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    3214:	80 91 65 05 	lds	r24, 0x0565
    3218:	c6 c0       	rjmp	.+396    	; 0x33a6 <DoSampler+0x8c8>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    321a:	e0 91 65 05 	lds	r30, 0x0565
    321e:	84 e2       	ldi	r24, 0x24	; 36
    3220:	e8 9f       	mul	r30, r24
    3222:	f0 01       	movw	r30, r0
    3224:	11 24       	eor	r1, r1
    3226:	eb 51       	subi	r30, 0x1B	; 27
    3228:	fa 4f       	sbci	r31, 0xFA	; 250
    322a:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    322c:	11 86       	std	Z+9, r1	; 0x09
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    322e:	10 86       	std	Z+8, r1	; 0x08
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3230:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    3232:	12 82       	std	Z+2, r1	; 0x02
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    3234:	81 e0       	ldi	r24, 0x01	; 1
    3236:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    3238:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;
    323a:	84 83       	std	Z+4, r24	; 0x04
					bankStates[currentMidiMessage.channelNumber].realtimeOn=false;			// We'll default to playback.
    323c:	16 82       	std	Z+6, r1	; 0x06
    323e:	2d c0       	rjmp	.+90     	; 0x329a <DoSampler+0x7bc>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    3240:	80 91 68 05 	lds	r24, 0x0568
    3244:	88 30       	cpi	r24, 0x08	; 8
    3246:	08 f0       	brcs	.+2      	; 0x324a <DoSampler+0x76c>
    3248:	0a c1       	rjmp	.+532    	; 0x345e <DoSampler+0x980>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;
    324a:	e0 91 65 05 	lds	r30, 0x0565
    324e:	94 e2       	ldi	r25, 0x24	; 36
    3250:	e9 9f       	mul	r30, r25
    3252:	f0 01       	movw	r30, r0
    3254:	11 24       	eor	r1, r1
    3256:	eb 51       	subi	r30, 0x1B	; 27
    3258:	fa 4f       	sbci	r31, 0xFA	; 250
    325a:	81 87       	std	Z+9, r24	; 0x09
    325c:	00 c1       	rjmp	.+512    	; 0x345e <DoSampler+0x980>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    325e:	60 91 68 05 	lds	r22, 0x0568
    3262:	80 91 65 05 	lds	r24, 0x0565
    3266:	0e 94 42 09 	call	0x1284	; 0x1284 <MakeNewGranularArray>
					break;
    326a:	f9 c0       	rjmp	.+498    	; 0x345e <DoSampler+0x980>

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;
    326c:	e0 91 65 05 	lds	r30, 0x0565
    3270:	80 91 68 05 	lds	r24, 0x0568
    3274:	24 e2       	ldi	r18, 0x24	; 36
    3276:	e2 9f       	mul	r30, r18
    3278:	f0 01       	movw	r30, r0
    327a:	11 24       	eor	r1, r1
    327c:	eb 51       	subi	r30, 0x1B	; 27
    327e:	fa 4f       	sbci	r31, 0xFA	; 250
    3280:	80 87       	std	Z+8, r24	; 0x08
					break;
    3282:	ed c0       	rjmp	.+474    	; 0x345e <DoSampler+0x980>

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    3284:	80 91 68 05 	lds	r24, 0x0568
    3288:	81 30       	cpi	r24, 0x01	; 1
    328a:	51 f0       	breq	.+20     	; 0x32a0 <DoSampler+0x7c2>
    328c:	30 f0       	brcs	.+12     	; 0x329a <DoSampler+0x7bc>
    328e:	82 30       	cpi	r24, 0x02	; 2
    3290:	71 f0       	breq	.+28     	; 0x32ae <DoSampler+0x7d0>
    3292:	83 30       	cpi	r24, 0x03	; 3
    3294:	09 f0       	breq	.+2      	; 0x3298 <DoSampler+0x7ba>
    3296:	e3 c0       	rjmp	.+454    	; 0x345e <DoSampler+0x980>
    3298:	0d c0       	rjmp	.+26     	; 0x32b4 <DoSampler+0x7d6>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    329a:	85 e3       	ldi	r24, 0x35	; 53
    329c:	98 e0       	ldi	r25, 0x08	; 8
    329e:	02 c0       	rjmp	.+4      	; 0x32a4 <DoSampler+0x7c6>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    32a0:	89 ee       	ldi	r24, 0xE9	; 233
    32a2:	97 e0       	ldi	r25, 0x07	; 7
    32a4:	90 93 e2 05 	sts	0x05E2, r25
    32a8:	80 93 e1 05 	sts	0x05E1, r24
						break;
    32ac:	d8 c0       	rjmp	.+432    	; 0x345e <DoSampler+0x980>

						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    32ae:	88 ea       	ldi	r24, 0xA8	; 168
    32b0:	98 e0       	ldi	r25, 0x08	; 8
    32b2:	f8 cf       	rjmp	.-16     	; 0x32a4 <DoSampler+0x7c6>
						break;

						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    32b4:	8b e6       	ldi	r24, 0x6B	; 107
    32b6:	98 e0       	ldi	r25, 0x08	; 8
    32b8:	f5 cf       	rjmp	.-22     	; 0x32a4 <DoSampler+0x7c6>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
    32ba:	1f b7       	in	r17, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    32bc:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    32be:	50 91 65 05 	lds	r21, 0x0565
    32c2:	a5 2f       	mov	r26, r21
    32c4:	b0 e0       	ldi	r27, 0x00	; 0
    32c6:	fd 01       	movw	r30, r26
    32c8:	ec 5f       	subi	r30, 0xFC	; 252
    32ca:	fe 4f       	sbci	r31, 0xFE	; 254
    32cc:	40 81       	ld	r20, Z
    32ce:	aa 0f       	add	r26, r26
    32d0:	bb 1f       	adc	r27, r27
    32d2:	a2 5a       	subi	r26, 0xA2	; 162
    32d4:	ba 4f       	sbci	r27, 0xFA	; 250
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    32d6:	84 2f       	mov	r24, r20
    32d8:	6c e0       	ldi	r22, 0x0C	; 12
    32da:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    32de:	e9 2f       	mov	r30, r25
    32e0:	f0 e0       	ldi	r31, 0x00	; 0
    32e2:	ee 0f       	add	r30, r30
    32e4:	ff 1f       	adc	r31, r31
    32e6:	ea 5f       	subi	r30, 0xFA	; 250
    32e8:	fe 4f       	sbci	r31, 0xFE	; 254
    32ea:	20 81       	ld	r18, Z
    32ec:	31 81       	ldd	r19, Z+1	; 0x01
    32ee:	02 c0       	rjmp	.+4      	; 0x32f4 <DoSampler+0x816>
    32f0:	36 95       	lsr	r19
    32f2:	27 95       	ror	r18
    32f4:	8a 95       	dec	r24
    32f6:	e2 f7       	brpl	.-8      	; 0x32f0 <DoSampler+0x812>
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    32f8:	2d 93       	st	X+, r18
    32fa:	3c 93       	st	X, r19
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    32fc:	51 11       	cpse	r21, r1
    32fe:	04 c0       	rjmp	.+8      	; 0x3308 <DoSampler+0x82a>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    3300:	64 2f       	mov	r22, r20
    3302:	87 e0       	ldi	r24, 0x07	; 7
    3304:	90 e0       	ldi	r25, 0x00	; 0
    3306:	05 c0       	rjmp	.+10     	; 0x3312 <DoSampler+0x834>
	}
	else if(theBank==BANK_1)
    3308:	51 30       	cpi	r21, 0x01	; 1
    330a:	29 f4       	brne	.+10     	; 0x3316 <DoSampler+0x838>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    330c:	64 2f       	mov	r22, r20
    330e:	8b e0       	ldi	r24, 0x0B	; 11
    3310:	90 e0       	ldi	r25, 0x00	; 0
    3312:	0e 94 d5 1e 	call	0x3daa	; 0x3daa <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					sreg=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=sreg;		// Re-enable interrupts.
    3316:	1f bf       	out	0x3f, r17	; 63
					break;
    3318:	a2 c0       	rjmp	.+324    	; 0x345e <DoSampler+0x980>

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    331a:	90 91 68 05 	lds	r25, 0x0568
    331e:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3322:	44 e2       	ldi	r20, 0x24	; 36
    3324:	84 9f       	mul	r24, r20
    3326:	f0 01       	movw	r30, r0
    3328:	11 24       	eor	r1, r1
    332a:	20 c0       	rjmp	.+64     	; 0x336c <DoSampler+0x88e>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    332c:	90 91 68 05 	lds	r25, 0x0568
    3330:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3334:	24 e2       	ldi	r18, 0x24	; 36
    3336:	82 9f       	mul	r24, r18
    3338:	f0 01       	movw	r30, r0
    333a:	11 24       	eor	r1, r1
    333c:	24 c0       	rjmp	.+72     	; 0x3386 <DoSampler+0x8a8>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    333e:	90 91 68 05 	lds	r25, 0x0568
    3342:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3346:	44 e2       	ldi	r20, 0x24	; 36
    3348:	84 9f       	mul	r24, r20
    334a:	f0 01       	movw	r30, r0
    334c:	11 24       	eor	r1, r1
    334e:	28 c0       	rjmp	.+80     	; 0x33a0 <DoSampler+0x8c2>
					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_REVERT_SAMPLE_TO_FULL:
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
    3350:	80 91 65 05 	lds	r24, 0x0565
    3354:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <RevertSampleToUnadjusted>
					break;
    3358:	82 c0       	rjmp	.+260    	; 0x345e <DoSampler+0x980>

					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    335a:	90 91 68 05 	lds	r25, 0x0568
    335e:	99 0f       	add	r25, r25
    3360:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3364:	24 e2       	ldi	r18, 0x24	; 36
    3366:	82 9f       	mul	r24, r18
    3368:	f0 01       	movw	r30, r0
    336a:	11 24       	eor	r1, r1
    336c:	eb 51       	subi	r30, 0x1B	; 27
    336e:	fa 4f       	sbci	r31, 0xFA	; 250
    3370:	95 8f       	std	Z+29, r25	; 0x1d
    3372:	19 c0       	rjmp	.+50     	; 0x33a6 <DoSampler+0x8c8>
					case MIDI_ADJUST_SAMPLE_START_WIDE:
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3374:	90 91 68 05 	lds	r25, 0x0568
    3378:	99 0f       	add	r25, r25
    337a:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    337e:	44 e2       	ldi	r20, 0x24	; 36
    3380:	84 9f       	mul	r24, r20
    3382:	f0 01       	movw	r30, r0
    3384:	11 24       	eor	r1, r1
    3386:	eb 51       	subi	r30, 0x1B	; 27
    3388:	fa 4f       	sbci	r31, 0xFA	; 250
    338a:	96 8f       	std	Z+30, r25	; 0x1e
    338c:	0c c0       	rjmp	.+24     	; 0x33a6 <DoSampler+0x8c8>
					case MIDI_ADJUST_SAMPLE_END_WIDE:
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    338e:	90 91 68 05 	lds	r25, 0x0568
    3392:	99 0f       	add	r25, r25
    3394:	80 91 65 05 	lds	r24, 0x0565
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3398:	24 e2       	ldi	r18, 0x24	; 36
    339a:	82 9f       	mul	r24, r18
    339c:	f0 01       	movw	r30, r0
    339e:	11 24       	eor	r1, r1
    33a0:	eb 51       	subi	r30, 0x1B	; 27
    33a2:	fa 4f       	sbci	r31, 0xFA	; 250
    33a4:	97 8f       	std	Z+31, r25	; 0x1f
	UpdateAdjustedSampleAddresses(theBank);
    33a6:	0e 94 3f 0a 	call	0x147e	; 0x147e <UpdateAdjustedSampleAddresses>
    33aa:	59 c0       	rjmp	.+178    	; 0x345e <DoSampler+0x980>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    33ac:	87 30       	cpi	r24, 0x07	; 7
    33ae:	09 f0       	breq	.+2      	; 0x33b2 <DoSampler+0x8d4>
    33b0:	56 c0       	rjmp	.+172    	; 0x345e <DoSampler+0x980>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    33b2:	80 91 68 05 	lds	r24, 0x0568
    33b6:	20 91 67 05 	lds	r18, 0x0567
    33ba:	30 e0       	ldi	r19, 0x00	; 0
    33bc:	40 e8       	ldi	r20, 0x80	; 128
    33be:	84 9f       	mul	r24, r20
    33c0:	20 0d       	add	r18, r0
    33c2:	31 1d       	adc	r19, r1
    33c4:	11 24       	eor	r1, r1
    33c6:	a0 91 65 05 	lds	r26, 0x0565

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    33ca:	21 15       	cp	r18, r1
    33cc:	80 e2       	ldi	r24, 0x20	; 32
    33ce:	38 07       	cpc	r19, r24
    33d0:	31 f1       	breq	.+76     	; 0x341e <DoSampler+0x940>
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    33d2:	b0 e0       	ldi	r27, 0x00	; 0
    33d4:	fd 01       	movw	r30, r26
    33d6:	ec 5f       	subi	r30, 0xFC	; 252
    33d8:	fe 4f       	sbci	r31, 0xFE	; 254
    33da:	80 81       	ld	r24, Z
    33dc:	40 e0       	ldi	r20, 0x00	; 0
    33de:	50 e2       	ldi	r21, 0x20	; 32
    33e0:	42 1b       	sub	r20, r18
    33e2:	53 0b       	sbc	r21, r19
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    33e4:	6c e0       	ldi	r22, 0x0C	; 12
    33e6:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    33ea:	e9 2f       	mov	r30, r25
    33ec:	f0 e0       	ldi	r31, 0x00	; 0
    33ee:	ee 0f       	add	r30, r30
    33f0:	ff 1f       	adc	r31, r31
    33f2:	ea 5f       	subi	r30, 0xFA	; 250
    33f4:	fe 4f       	sbci	r31, 0xFE	; 254
    33f6:	20 81       	ld	r18, Z
    33f8:	31 81       	ldd	r19, Z+1	; 0x01
    33fa:	02 c0       	rjmp	.+4      	; 0x3400 <DoSampler+0x922>
    33fc:	36 95       	lsr	r19
    33fe:	27 95       	ror	r18
    3400:	8a 95       	dec	r24
    3402:	e2 f7       	brpl	.-8      	; 0x33fc <DoSampler+0x91e>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    3404:	42 0f       	add	r20, r18
    3406:	53 1f       	adc	r21, r19
    3408:	84 e2       	ldi	r24, 0x24	; 36
    340a:	8a 9f       	mul	r24, r26
    340c:	f0 01       	movw	r30, r0
    340e:	8b 9f       	mul	r24, r27
    3410:	f0 0d       	add	r31, r0
    3412:	11 24       	eor	r1, r1
    3414:	eb 51       	subi	r30, 0x1B	; 27
    3416:	fa 4f       	sbci	r31, 0xFA	; 250
    3418:	54 87       	std	Z+12, r21	; 0x0c
    341a:	43 87       	std	Z+11, r20	; 0x0b
    341c:	20 c0       	rjmp	.+64     	; 0x345e <DoSampler+0x980>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    341e:	4a 2f       	mov	r20, r26
    3420:	50 e0       	ldi	r21, 0x00	; 0
    3422:	fa 01       	movw	r30, r20
    3424:	ec 5f       	subi	r30, 0xFC	; 252
    3426:	fe 4f       	sbci	r31, 0xFE	; 254
    3428:	80 81       	ld	r24, Z
	unsigned char
		theIndex,
		theOctave;

	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?
    342a:	6c e0       	ldi	r22, 0x0C	; 12
    342c:	0e 94 cf 29 	call	0x539e	; 0x539e <__udivmodqi4>

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.
    3430:	e9 2f       	mov	r30, r25
    3432:	f0 e0       	ldi	r31, 0x00	; 0
    3434:	ee 0f       	add	r30, r30
    3436:	ff 1f       	adc	r31, r31
    3438:	ea 5f       	subi	r30, 0xFA	; 250
    343a:	fe 4f       	sbci	r31, 0xFE	; 254
    343c:	20 81       	ld	r18, Z
    343e:	31 81       	ldd	r19, Z+1	; 0x01
    3440:	02 c0       	rjmp	.+4      	; 0x3446 <DoSampler+0x968>
    3442:	36 95       	lsr	r19
    3444:	27 95       	ror	r18
    3446:	8a 95       	dec	r24
    3448:	e2 f7       	brpl	.-8      	; 0x3442 <DoSampler+0x964>
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    344a:	84 e2       	ldi	r24, 0x24	; 36
    344c:	84 9f       	mul	r24, r20
    344e:	f0 01       	movw	r30, r0
    3450:	85 9f       	mul	r24, r21
    3452:	f0 0d       	add	r31, r0
    3454:	11 24       	eor	r1, r1
    3456:	eb 51       	subi	r30, 0x1B	; 27
    3458:	fa 4f       	sbci	r31, 0xFA	; 250
    345a:	34 87       	std	Z+12, r19	; 0x0c
    345c:	23 87       	std	Z+11, r18	; 0x0b
static void CleanupAudioSources(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	// If we aren't streaming from the SD, void contribution to the DAC
	if(sdIsrState!=SD_ISR_STREAMING_PLAYBACK)
    345e:	80 91 4f 05 	lds	r24, 0x054F
    3462:	83 30       	cpi	r24, 0x03	; 3
    3464:	11 f0       	breq	.+4      	; 0x346a <DoSampler+0x98c>
	{
		sdStreamOutput=0;	// @@@ Not even sure we need to do this, since we set this to 0 when the ISR stops.  If we aborted during playback, this would be necessary.
    3466:	10 92 55 05 	sts	0x0555, r1
	}

	// Turn off audio interrupts that aren't used, and void their contributions to the DAC
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    346a:	80 91 ef 05 	lds	r24, 0x05EF
    346e:	81 30       	cpi	r24, 0x01	; 1
    3470:	41 f0       	breq	.+16     	; 0x3482 <DoSampler+0x9a4>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    3472:	10 92 42 04 	sts	0x0442, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3476:	80 91 6f 00 	lds	r24, 0x006F
    347a:	8f 7d       	andi	r24, 0xDF	; 223
    347c:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.
    3480:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    3482:	80 91 13 06 	lds	r24, 0x0613
    3486:	81 30       	cpi	r24, 0x01	; 1
    3488:	31 f0       	breq	.+12     	; 0x3496 <DoSampler+0x9b8>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    348a:	10 92 45 05 	sts	0x0545, r1
		PCICR=0;			// No global PCINTS.
    348e:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    3492:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    3496:	80 91 ef 05 	lds	r24, 0x05EF
    349a:	82 30       	cpi	r24, 0x02	; 2
    349c:	41 f0       	breq	.+16     	; 0x34ae <DoSampler+0x9d0>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    349e:	10 92 48 05 	sts	0x0548, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    34a2:	80 91 6f 00 	lds	r24, 0x006F
    34a6:	8d 7f       	andi	r24, 0xFD	; 253
    34a8:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.
    34ac:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    34ae:	80 91 13 06 	lds	r24, 0x0613
    34b2:	82 30       	cpi	r24, 0x02	; 2
    34b4:	41 f0       	breq	.+16     	; 0x34c6 <DoSampler+0x9e8>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    34b6:	10 92 4c 05 	sts	0x054C, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    34ba:	80 91 6f 00 	lds	r24, 0x006F
    34be:	8b 7f       	andi	r24, 0xFB	; 251
    34c0:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.
    34c4:	b2 9a       	sbi	0x16, 2	; 22
	}

	// Unlock banks that aren't being used by RAM  -- we need to do this since we can arbitrarily stop audio functions
	if(bankStates[BANK_0].clockMode==CLK_NONE)		// Audio functions on this bank off?
    34c6:	80 91 ef 05 	lds	r24, 0x05EF
    34ca:	81 11       	cpse	r24, r1
    34cc:	0c c0       	rjmp	.+24     	; 0x34e6 <DoSampler+0xa08>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==false)	// SD ISR set such that this bank cannot be using the RAM?
    34ce:	80 91 4f 05 	lds	r24, 0x054F
    34d2:	88 23       	and	r24, r24
    34d4:	31 f0       	breq	.+12     	; 0x34e2 <DoSampler+0xa04>
    34d6:	83 30       	cpi	r24, 0x03	; 3
    34d8:	21 f0       	breq	.+8      	; 0x34e2 <DoSampler+0xa04>
    34da:	80 91 54 05 	lds	r24, 0x0554
    34de:	81 11       	cpse	r24, r1
    34e0:	02 c0       	rjmp	.+4      	; 0x34e6 <DoSampler+0xa08>
		{
			bankStates[BANK_0].isLocked=false;
    34e2:	10 92 ea 05 	sts	0x05EA, r1
		}
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)		// Audio functions on this bank off?
    34e6:	80 91 13 06 	lds	r24, 0x0613
    34ea:	81 11       	cpse	r24, r1
    34ec:	0c c0       	rjmp	.+24     	; 0x3506 <DoSampler+0xa28>
	{
		if(sdIsrState==SD_ISR_IDLE||sdIsrState==SD_ISR_STREAMING_PLAYBACK||sdBank0==true)	// SD ISR set such that this bank cannot be using the RAM?
    34ee:	80 91 4f 05 	lds	r24, 0x054F
    34f2:	88 23       	and	r24, r24
    34f4:	31 f0       	breq	.+12     	; 0x3502 <DoSampler+0xa24>
    34f6:	83 30       	cpi	r24, 0x03	; 3
    34f8:	21 f0       	breq	.+8      	; 0x3502 <DoSampler+0xa24>
    34fa:	80 91 54 05 	lds	r24, 0x0554
    34fe:	81 30       	cpi	r24, 0x01	; 1
    3500:	11 f4       	brne	.+4      	; 0x3506 <DoSampler+0xa28>
		{
			bankStates[BANK_1].isLocked=false;
    3502:	10 92 0e 06 	sts	0x060E, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    3506:	80 91 6d 05 	lds	r24, 0x056D
    350a:	82 95       	swap	r24
    350c:	86 95       	lsr	r24
    350e:	87 70       	andi	r24, 0x07	; 7
    3510:	80 93 6c 05 	sts	0x056C, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    3514:	20 91 5d 05 	lds	r18, 0x055D
    3518:	2f 71       	andi	r18, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    351a:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    351c:	20 68       	ori	r18, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    351e:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    3520:	20 64       	ori	r18, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    3522:	84 70       	andi	r24, 0x04	; 4
    3524:	09 f0       	breq	.+2      	; 0x3528 <DoSampler+0xa4a>
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    3526:	20 62       	ori	r18, 0x20	; 32
	}

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    3528:	30 91 62 05 	lds	r19, 0x0562
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    352c:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    352e:	83 2f       	mov	r24, r19
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	44 e2       	ldi	r20, 0x24	; 36
    3534:	34 9f       	mul	r19, r20
    3536:	f0 01       	movw	r30, r0
    3538:	11 24       	eor	r1, r1
    353a:	eb 51       	subi	r30, 0x1B	; 27
    353c:	fa 4f       	sbci	r31, 0xFA	; 250
    353e:	40 81       	ld	r20, Z
    3540:	43 30       	cpi	r20, 0x03	; 3
    3542:	09 f4       	brne	.+2      	; 0x3546 <DoSampler+0xa68>
	{
		temp|=Om_LED_REC;
    3544:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    3546:	44 e2       	ldi	r20, 0x24	; 36
    3548:	48 9f       	mul	r20, r24
    354a:	f0 01       	movw	r30, r0
    354c:	49 9f       	mul	r20, r25
    354e:	f0 0d       	add	r31, r0
    3550:	11 24       	eor	r1, r1
    3552:	eb 51       	subi	r30, 0x1B	; 27
    3554:	fa 4f       	sbci	r31, 0xFA	; 250
    3556:	40 81       	ld	r20, Z
    3558:	44 30       	cpi	r20, 0x04	; 4
    355a:	09 f4       	brne	.+2      	; 0x355e <DoSampler+0xa80>
	{
		temp|=Om_LED_PLAY;
    355c:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    355e:	44 e2       	ldi	r20, 0x24	; 36
    3560:	48 9f       	mul	r20, r24
    3562:	f0 01       	movw	r30, r0
    3564:	49 9f       	mul	r20, r25
    3566:	f0 0d       	add	r31, r0
    3568:	11 24       	eor	r1, r1
    356a:	eb 51       	subi	r30, 0x1B	; 27
    356c:	fa 4f       	sbci	r31, 0xFA	; 250
    356e:	40 81       	ld	r20, Z
    3570:	45 30       	cpi	r20, 0x05	; 5
    3572:	09 f4       	brne	.+2      	; 0x3576 <DoSampler+0xa98>
	{
		temp|=Om_LED_ODUB;
    3574:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    3576:	44 e2       	ldi	r20, 0x24	; 36
    3578:	48 9f       	mul	r20, r24
    357a:	f0 01       	movw	r30, r0
    357c:	49 9f       	mul	r20, r25
    357e:	f0 0d       	add	r31, r0
    3580:	11 24       	eor	r1, r1
    3582:	eb 51       	subi	r30, 0x1B	; 27
    3584:	fa 4f       	sbci	r31, 0xFA	; 250
    3586:	40 81       	ld	r20, Z
    3588:	42 30       	cpi	r20, 0x02	; 2
    358a:	09 f4       	brne	.+2      	; 0x358e <DoSampler+0xab0>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    358c:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    358e:	40 91 3f 04 	lds	r20, 0x043F
    3592:	41 30       	cpi	r20, 0x01	; 1
    3594:	09 f4       	brne	.+2      	; 0x3598 <DoSampler+0xaba>
	{
		temp|=Om_LED_OUT_OF_MEM;
    3596:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    3598:	31 30       	cpi	r19, 0x01	; 1
    359a:	09 f4       	brne	.+2      	; 0x359e <DoSampler+0xac0>
	{
		temp|=Om_LED_BANK;
    359c:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    359e:	20 93 5d 05 	sts	0x055D, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    35a2:	24 e2       	ldi	r18, 0x24	; 36
    35a4:	28 9f       	mul	r18, r24
    35a6:	f0 01       	movw	r30, r0
    35a8:	29 9f       	mul	r18, r25
    35aa:	f0 0d       	add	r31, r0
    35ac:	11 24       	eor	r1, r1
    35ae:	eb 51       	subi	r30, 0x1B	; 27
    35b0:	fa 4f       	sbci	r31, 0xFA	; 250
    35b2:	41 89       	ldd	r20, Z+17	; 0x11
    35b4:	52 89       	ldd	r21, Z+18	; 0x12
    35b6:	63 89       	ldd	r22, Z+19	; 0x13
    35b8:	74 89       	ldd	r23, Z+20	; 0x14
    35ba:	85 85       	ldd	r24, Z+13	; 0x0d
    35bc:	96 85       	ldd	r25, Z+14	; 0x0e
    35be:	a7 85       	ldd	r26, Z+15	; 0x0f
    35c0:	b0 89       	ldd	r27, Z+16	; 0x10
    35c2:	48 17       	cp	r20, r24
    35c4:	59 07       	cpc	r21, r25
    35c6:	6a 07       	cpc	r22, r26
    35c8:	7b 07       	cpc	r23, r27
    35ca:	81 f4       	brne	.+32     	; 0x35ec <DoSampler+0xb0e>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    35cc:	80 91 ae 05 	lds	r24, 0x05AE
    35d0:	82 fd       	sbrc	r24, 2
    35d2:	16 c0       	rjmp	.+44     	; 0x3600 <DoSampler+0xb22>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    35d4:	84 e0       	ldi	r24, 0x04	; 4
    35d6:	90 e0       	ldi	r25, 0x00	; 0

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    35d8:	0f 90       	pop	r0
    35da:	df 91       	pop	r29
    35dc:	cf 91       	pop	r28
    35de:	1f 91       	pop	r17
    35e0:	0f 91       	pop	r16
    35e2:	ff 90       	pop	r15
    35e4:	df 90       	pop	r13
    35e6:	cf 90       	pop	r12

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    35e8:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <BlinkLeds>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    35ec:	0f 90       	pop	r0
    35ee:	df 91       	pop	r29
    35f0:	cf 91       	pop	r28
    35f2:	1f 91       	pop	r17
    35f4:	0f 91       	pop	r16
    35f6:	ff 90       	pop	r15
    35f8:	df 90       	pop	r13
    35fa:	cf 90       	pop	r12
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
		}
	}
	else
	{
		StopBlinking();						// Right now we can do this b/c the above condition is the only blinking we do.
    35fc:	0c 94 90 0e 	jmp	0x1d20	; 0x1d20 <StopBlinking>

//	CleanupSdPlayback();			// If we've triggered another audio ISR during an SD playback, handle closing the SD block read.
	CleanupAudioSources();			// If we've enabled an interrupt and we aren't using it, disable it.  Void all audio contributions to the DAC that have become idle.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    3600:	0f 90       	pop	r0
    3602:	df 91       	pop	r29
    3604:	cf 91       	pop	r28
    3606:	1f 91       	pop	r17
    3608:	0f 91       	pop	r16
    360a:	ff 90       	pop	r15
    360c:	df 90       	pop	r13
    360e:	cf 90       	pop	r12
    3610:	08 95       	ret

00003612 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    3612:	1f 92       	push	r1
    3614:	0f 92       	push	r0
    3616:	0f b6       	in	r0, 0x3f	; 63
    3618:	0f 92       	push	r0
    361a:	11 24       	eor	r1, r1
    361c:	2f 93       	push	r18
    361e:	3f 93       	push	r19
    3620:	4f 93       	push	r20
    3622:	5f 93       	push	r21
    3624:	6f 93       	push	r22
    3626:	7f 93       	push	r23
    3628:	8f 93       	push	r24
    362a:	9f 93       	push	r25
    362c:	af 93       	push	r26
    362e:	bf 93       	push	r27
    3630:	ef 93       	push	r30
    3632:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3634:	80 91 e7 05 	lds	r24, 0x05E7
    3638:	88 23       	and	r24, r24
    363a:	41 f0       	breq	.+16     	; 0x364c <__vector_12+0x3a>
    363c:	80 91 e7 05 	lds	r24, 0x05E7
    3640:	88 23       	and	r24, r24
    3642:	41 f0       	breq	.+16     	; 0x3654 <__vector_12+0x42>
    3644:	80 91 41 04 	lds	r24, 0x0441
    3648:	88 23       	and	r24, r24
    364a:	21 f0       	breq	.+8      	; 0x3654 <__vector_12+0x42>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    364c:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    3650:	80 93 42 04 	sts	0x0442, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3654:	10 92 41 04 	sts	0x0441, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3658:	e0 91 e1 05 	lds	r30, 0x05E1
    365c:	f0 91 e2 05 	lds	r31, 0x05E2
    3660:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3662:	80 91 7a 00 	lds	r24, 0x007A
    3666:	86 fd       	sbrc	r24, 6
    3668:	0a c0       	rjmp	.+20     	; 0x367e <__vector_12+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    366a:	80 91 79 00 	lds	r24, 0x0079
    366e:	80 58       	subi	r24, 0x80	; 128
    3670:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3674:	80 91 7a 00 	lds	r24, 0x007A
    3678:	80 64       	ori	r24, 0x40	; 64
    367a:	80 93 7a 00 	sts	0x007A, r24
	}
}
    367e:	ff 91       	pop	r31
    3680:	ef 91       	pop	r30
    3682:	bf 91       	pop	r27
    3684:	af 91       	pop	r26
    3686:	9f 91       	pop	r25
    3688:	8f 91       	pop	r24
    368a:	7f 91       	pop	r23
    368c:	6f 91       	pop	r22
    368e:	5f 91       	pop	r21
    3690:	4f 91       	pop	r20
    3692:	3f 91       	pop	r19
    3694:	2f 91       	pop	r18
    3696:	0f 90       	pop	r0
    3698:	0f be       	out	0x3f, r0	; 63
    369a:	0f 90       	pop	r0
    369c:	1f 90       	pop	r1
    369e:	18 95       	reti

000036a0 <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
// It's on PC4
{
    36a0:	1f 92       	push	r1
    36a2:	0f 92       	push	r0
    36a4:	0f b6       	in	r0, 0x3f	; 63
    36a6:	0f 92       	push	r0
    36a8:	11 24       	eor	r1, r1
    36aa:	2f 93       	push	r18
    36ac:	3f 93       	push	r19
    36ae:	4f 93       	push	r20
    36b0:	5f 93       	push	r21
    36b2:	6f 93       	push	r22
    36b4:	7f 93       	push	r23
    36b6:	8f 93       	push	r24
    36b8:	9f 93       	push	r25
    36ba:	af 93       	push	r26
    36bc:	bf 93       	push	r27
    36be:	ef 93       	push	r30
    36c0:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    36c2:	80 91 0b 06 	lds	r24, 0x060B
    36c6:	88 23       	and	r24, r24
    36c8:	41 f0       	breq	.+16     	; 0x36da <__vector_6+0x3a>
    36ca:	80 91 0b 06 	lds	r24, 0x060B
    36ce:	88 23       	and	r24, r24
    36d0:	41 f0       	breq	.+16     	; 0x36e2 <__vector_6+0x42>
    36d2:	80 91 44 05 	lds	r24, 0x0544
    36d6:	88 23       	and	r24, r24
    36d8:	21 f0       	breq	.+8      	; 0x36e2 <__vector_6+0x42>
	{
		extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    36da:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    36de:	80 93 45 05 	sts	0x0545, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    36e2:	10 92 44 05 	sts	0x0544, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    36e6:	e0 91 e1 05 	lds	r30, 0x05E1
    36ea:	f0 91 e2 05 	lds	r31, 0x05E2
    36ee:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    36f0:	80 91 7a 00 	lds	r24, 0x007A
    36f4:	86 fd       	sbrc	r24, 6
    36f6:	0a c0       	rjmp	.+20     	; 0x370c <__vector_6+0x6c>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    36f8:	80 91 79 00 	lds	r24, 0x0079
    36fc:	80 58       	subi	r24, 0x80	; 128
    36fe:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3702:	80 91 7a 00 	lds	r24, 0x007A
    3706:	80 64       	ori	r24, 0x40	; 64
    3708:	80 93 7a 00 	sts	0x007A, r24
	}
	PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around from our rising edge
    370c:	da 9a       	sbi	0x1b, 2	; 27
// However, we will need to clear the pin-change interrupt flag, since it may get set again about the time this ISR is starting.  IE, we might get into the interrupt with a falling edge, the flag might clear, the edge might rise, and the flag will get set again.
// Since the pulses are so short (10 cycles) we can clear this flag at the end of this routine and be sure we're good to go.

// Fri Jun 24 11:20:40 EDT 2011
// They're more like 5uS now, but still plenty short
}
    370e:	ff 91       	pop	r31
    3710:	ef 91       	pop	r30
    3712:	bf 91       	pop	r27
    3714:	af 91       	pop	r26
    3716:	9f 91       	pop	r25
    3718:	8f 91       	pop	r24
    371a:	7f 91       	pop	r23
    371c:	6f 91       	pop	r22
    371e:	5f 91       	pop	r21
    3720:	4f 91       	pop	r20
    3722:	3f 91       	pop	r19
    3724:	2f 91       	pop	r18
    3726:	0f 90       	pop	r0
    3728:	0f be       	out	0x3f, r0	; 63
    372a:	0f 90       	pop	r0
    372c:	1f 90       	pop	r1
    372e:	18 95       	reti

00003730 <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    3730:	1f 92       	push	r1
    3732:	0f 92       	push	r0
    3734:	0f b6       	in	r0, 0x3f	; 63
    3736:	0f 92       	push	r0
    3738:	11 24       	eor	r1, r1
    373a:	0f 93       	push	r16
    373c:	1f 93       	push	r17
    373e:	2f 93       	push	r18
    3740:	3f 93       	push	r19
    3742:	4f 93       	push	r20
    3744:	5f 93       	push	r21
    3746:	6f 93       	push	r22
    3748:	7f 93       	push	r23
    374a:	8f 93       	push	r24
    374c:	9f 93       	push	r25
    374e:	af 93       	push	r26
    3750:	bf 93       	push	r27
    3752:	cf 93       	push	r28
    3754:	df 93       	push	r29
    3756:	ef 93       	push	r30
    3758:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    375a:	80 91 e7 05 	lds	r24, 0x05E7
    375e:	88 23       	and	r24, r24
    3760:	41 f0       	breq	.+16     	; 0x3772 <__vector_13+0x42>
    3762:	80 91 e7 05 	lds	r24, 0x05E7
    3766:	88 23       	and	r24, r24
    3768:	41 f0       	breq	.+16     	; 0x377a <__vector_13+0x4a>
    376a:	80 91 47 05 	lds	r24, 0x0547
    376e:	88 23       	and	r24, r24
    3770:	21 f0       	breq	.+8      	; 0x377a <__vector_13+0x4a>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    3772:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    3776:	80 93 48 05 	sts	0x0548, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
    377a:	80 91 ed 05 	lds	r24, 0x05ED
    377e:	88 23       	and	r24, r24
    3780:	a1 f1       	breq	.+104    	; 0x37ea <__vector_13+0xba>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    3782:	a0 91 ed 05 	lds	r26, 0x05ED
    3786:	20 91 f0 05 	lds	r18, 0x05F0
    378a:	30 91 f1 05 	lds	r19, 0x05F1
    378e:	b0 e0       	ldi	r27, 0x00	; 0
    3790:	0e 94 03 2a 	call	0x5406	; 0x5406 <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    3794:	2f e7       	ldi	r18, 0x7F	; 127
    3796:	30 e0       	ldi	r19, 0x00	; 0
    3798:	40 e0       	ldi	r20, 0x00	; 0
    379a:	50 e0       	ldi	r21, 0x00	; 0
    379c:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    37a0:	00 91 88 00 	lds	r16, 0x0088
    37a4:	10 91 89 00 	lds	r17, 0x0089
    37a8:	c0 91 f0 05 	lds	r28, 0x05F0
    37ac:	d0 91 f1 05 	lds	r29, 0x05F1
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?	@@@ This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down -- Thu Aug  4 11:06:19 EDT 2011 Dumbass, it's probably the mod operation.
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    37b0:	60 91 00 01 	lds	r22, 0x0100
    37b4:	70 91 01 01 	lds	r23, 0x0101
    37b8:	80 91 02 01 	lds	r24, 0x0102
    37bc:	90 91 03 01 	lds	r25, 0x0103
    37c0:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    37c4:	c0 0f       	add	r28, r16
    37c6:	d1 1f       	adc	r29, r17
    37c8:	40 91 49 05 	lds	r20, 0x0549
    37cc:	50 91 4a 05 	lds	r21, 0x054A
    37d0:	c4 0f       	add	r28, r20
    37d2:	d5 1f       	adc	r29, r21
    37d4:	c6 1b       	sub	r28, r22
    37d6:	d7 0b       	sbc	r29, r23
    37d8:	d0 93 89 00 	sts	0x0089, r29
    37dc:	c0 93 88 00 	sts	0x0088, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    37e0:	70 93 4a 05 	sts	0x054A, r23
    37e4:	60 93 49 05 	sts	0x0549, r22
    37e8:	0e c0       	rjmp	.+28     	; 0x3806 <__vector_13+0xd6>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    37ea:	20 91 88 00 	lds	r18, 0x0088
    37ee:	30 91 89 00 	lds	r19, 0x0089
    37f2:	80 91 f0 05 	lds	r24, 0x05F0
    37f6:	90 91 f1 05 	lds	r25, 0x05F1
    37fa:	82 0f       	add	r24, r18
    37fc:	93 1f       	adc	r25, r19
    37fe:	90 93 89 00 	sts	0x0089, r25
    3802:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3806:	10 92 47 05 	sts	0x0547, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    380a:	e0 91 e1 05 	lds	r30, 0x05E1
    380e:	f0 91 e2 05 	lds	r31, 0x05E2
    3812:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3814:	80 91 7a 00 	lds	r24, 0x007A
    3818:	86 fd       	sbrc	r24, 6
    381a:	0a c0       	rjmp	.+20     	; 0x3830 <__vector_13+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    381c:	80 91 79 00 	lds	r24, 0x0079
    3820:	80 58       	subi	r24, 0x80	; 128
    3822:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3826:	80 91 7a 00 	lds	r24, 0x007A
    382a:	80 64       	ori	r24, 0x40	; 64
    382c:	80 93 7a 00 	sts	0x007A, r24
	}
}
    3830:	ff 91       	pop	r31
    3832:	ef 91       	pop	r30
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
    3838:	bf 91       	pop	r27
    383a:	af 91       	pop	r26
    383c:	9f 91       	pop	r25
    383e:	8f 91       	pop	r24
    3840:	7f 91       	pop	r23
    3842:	6f 91       	pop	r22
    3844:	5f 91       	pop	r21
    3846:	4f 91       	pop	r20
    3848:	3f 91       	pop	r19
    384a:	2f 91       	pop	r18
    384c:	1f 91       	pop	r17
    384e:	0f 91       	pop	r16
    3850:	0f 90       	pop	r0
    3852:	0f be       	out	0x3f, r0	; 63
    3854:	0f 90       	pop	r0
    3856:	1f 90       	pop	r1
    3858:	18 95       	reti

0000385a <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    385a:	1f 92       	push	r1
    385c:	0f 92       	push	r0
    385e:	0f b6       	in	r0, 0x3f	; 63
    3860:	0f 92       	push	r0
    3862:	11 24       	eor	r1, r1
    3864:	0f 93       	push	r16
    3866:	1f 93       	push	r17
    3868:	2f 93       	push	r18
    386a:	3f 93       	push	r19
    386c:	4f 93       	push	r20
    386e:	5f 93       	push	r21
    3870:	6f 93       	push	r22
    3872:	7f 93       	push	r23
    3874:	8f 93       	push	r24
    3876:	9f 93       	push	r25
    3878:	af 93       	push	r26
    387a:	bf 93       	push	r27
    387c:	cf 93       	push	r28
    387e:	df 93       	push	r29
    3880:	ef 93       	push	r30
    3882:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

//	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs

	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    3884:	80 91 0b 06 	lds	r24, 0x060B
    3888:	88 23       	and	r24, r24
    388a:	41 f0       	breq	.+16     	; 0x389c <__vector_14+0x42>
    388c:	80 91 0b 06 	lds	r24, 0x060B
    3890:	88 23       	and	r24, r24
    3892:	41 f0       	breq	.+16     	; 0x38a4 <__vector_14+0x4a>
    3894:	80 91 4b 05 	lds	r24, 0x054B
    3898:	88 23       	and	r24, r24
    389a:	21 f0       	breq	.+8      	; 0x38a4 <__vector_14+0x4a>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    389c:	0e 94 27 04 	call	0x84e	; 0x84e <UpdateAudioChannel1>
    38a0:	80 93 4c 05 	sts	0x054C, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    38a4:	80 91 11 06 	lds	r24, 0x0611
    38a8:	88 23       	and	r24, r24
    38aa:	a1 f1       	breq	.+104    	; 0x3914 <__vector_14+0xba>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    38ac:	a0 91 11 06 	lds	r26, 0x0611
    38b0:	20 91 14 06 	lds	r18, 0x0614
    38b4:	30 91 15 06 	lds	r19, 0x0615
    38b8:	b0 e0       	ldi	r27, 0x00	; 0
    38ba:	0e 94 03 2a 	call	0x5406	; 0x5406 <__umulhisi3>
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    38be:	2f e7       	ldi	r18, 0x7F	; 127
    38c0:	30 e0       	ldi	r19, 0x00	; 0
    38c2:	40 e0       	ldi	r20, 0x00	; 0
    38c4:	50 e0       	ldi	r21, 0x00	; 0
    38c6:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    38ca:	00 91 8a 00 	lds	r16, 0x008A
    38ce:	10 91 8b 00 	lds	r17, 0x008B
    38d2:	c0 91 14 06 	lds	r28, 0x0614
    38d6:	d0 91 15 06 	lds	r29, 0x0615
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    38da:	60 91 00 01 	lds	r22, 0x0100
    38de:	70 91 01 01 	lds	r23, 0x0101
    38e2:	80 91 02 01 	lds	r24, 0x0102
    38e6:	90 91 03 01 	lds	r25, 0x0103
    38ea:	0e 94 db 29 	call	0x53b6	; 0x53b6 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. @@@ We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    38ee:	c0 0f       	add	r28, r16
    38f0:	d1 1f       	adc	r29, r17
    38f2:	40 91 4d 05 	lds	r20, 0x054D
    38f6:	50 91 4e 05 	lds	r21, 0x054E
    38fa:	c4 0f       	add	r28, r20
    38fc:	d5 1f       	adc	r29, r21
    38fe:	c6 1b       	sub	r28, r22
    3900:	d7 0b       	sbc	r29, r23
    3902:	d0 93 8b 00 	sts	0x008B, r29
    3906:	c0 93 8a 00 	sts	0x008A, r28
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    390a:	70 93 4e 05 	sts	0x054E, r23
    390e:	60 93 4d 05 	sts	0x054D, r22
    3912:	0e c0       	rjmp	.+28     	; 0x3930 <__vector_14+0xd6>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    3914:	20 91 8a 00 	lds	r18, 0x008A
    3918:	30 91 8b 00 	lds	r19, 0x008B
    391c:	80 91 14 06 	lds	r24, 0x0614
    3920:	90 91 15 06 	lds	r25, 0x0615
    3924:	82 0f       	add	r24, r18
    3926:	93 1f       	adc	r25, r19
    3928:	90 93 8b 00 	sts	0x008B, r25
    392c:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    3930:	10 92 4b 05 	sts	0x054B, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    3934:	e0 91 e1 05 	lds	r30, 0x05E1
    3938:	f0 91 e2 05 	lds	r31, 0x05E2
    393c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    393e:	80 91 7a 00 	lds	r24, 0x007A
    3942:	86 fd       	sbrc	r24, 6
    3944:	0a c0       	rjmp	.+20     	; 0x395a <__vector_14+0x100>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3946:	80 91 79 00 	lds	r24, 0x0079
    394a:	80 58       	subi	r24, 0x80	; 128
    394c:	80 93 2c 04 	sts	0x042C, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    3950:	80 91 7a 00 	lds	r24, 0x007A
    3954:	80 64       	ori	r24, 0x40	; 64
    3956:	80 93 7a 00 	sts	0x007A, r24
	}
}
    395a:	ff 91       	pop	r31
    395c:	ef 91       	pop	r30
    395e:	df 91       	pop	r29
    3960:	cf 91       	pop	r28
    3962:	bf 91       	pop	r27
    3964:	af 91       	pop	r26
    3966:	9f 91       	pop	r25
    3968:	8f 91       	pop	r24
    396a:	7f 91       	pop	r23
    396c:	6f 91       	pop	r22
    396e:	5f 91       	pop	r21
    3970:	4f 91       	pop	r20
    3972:	3f 91       	pop	r19
    3974:	2f 91       	pop	r18
    3976:	1f 91       	pop	r17
    3978:	0f 91       	pop	r16
    397a:	0f 90       	pop	r0
    397c:	0f be       	out	0x3f, r0	; 63
    397e:	0f 90       	pop	r0
    3980:	1f 90       	pop	r1
    3982:	18 95       	reti

00003984 <__vector_10>:

ISR(TIMER2_COMPB_vect)
// This interrupt handles data in the SD buffer and doing what needs to be done with it.
// This includes direct playback from the SD card, writing SD data to the ram banks, and reading ram data.  All of these are at a fixed period.
// When writing/reading RAM, the bank in question should be locked against other RAM accesses.
{
    3984:	1f 92       	push	r1
    3986:	0f 92       	push	r0
    3988:	0f b6       	in	r0, 0x3f	; 63
    398a:	0f 92       	push	r0
    398c:	11 24       	eor	r1, r1
    398e:	2f 93       	push	r18
    3990:	3f 93       	push	r19
    3992:	4f 93       	push	r20
    3994:	5f 93       	push	r21
    3996:	6f 93       	push	r22
    3998:	7f 93       	push	r23
    399a:	8f 93       	push	r24
    399c:	9f 93       	push	r25
    399e:	af 93       	push	r26
    39a0:	bf 93       	push	r27
    39a2:	ef 93       	push	r30
    39a4:	ff 93       	push	r31
	unsigned char
		theByte;

	if(sdIsrState==SD_ISR_LOADING_RAM)	// Putting data from the SD buffer into a RAM bank?
    39a6:	80 91 4f 05 	lds	r24, 0x054F
    39aa:	81 30       	cpi	r24, 0x01	; 1
    39ac:	09 f0       	breq	.+2      	; 0x39b0 <__vector_10+0x2c>
    39ae:	be c0       	rjmp	.+380    	; 0x3b2c <__vector_10+0x1a8>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    39b0:	80 91 22 01 	lds	r24, 0x0122
    39b4:	90 91 23 01 	lds	r25, 0x0123
    39b8:	a0 91 24 01 	lds	r26, 0x0124
    39bc:	b0 91 25 01 	lds	r27, 0x0125
    39c0:	89 2b       	or	r24, r25
    39c2:	8a 2b       	or	r24, r26
    39c4:	8b 2b       	or	r24, r27
    39c6:	09 f4       	brne	.+2      	; 0x39ca <__vector_10+0x46>
    39c8:	76 c0       	rjmp	.+236    	; 0x3ab6 <__vector_10+0x132>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    39ca:	80 91 26 01 	lds	r24, 0x0126
    39ce:	90 91 27 01 	lds	r25, 0x0127
    39d2:	89 2b       	or	r24, r25
    39d4:	09 f4       	brne	.+2      	; 0x39d8 <__vector_10+0x54>
    39d6:	a6 c1       	rjmp	.+844    	; 0x3d24 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    39d8:	e0 91 2a 01 	lds	r30, 0x012A
    39dc:	f0 91 2b 01 	lds	r31, 0x012B
    39e0:	e4 5d       	subi	r30, 0xD4	; 212
    39e2:	fe 4f       	sbci	r31, 0xFE	; 254
    39e4:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    39e6:	80 91 2a 01 	lds	r24, 0x012A
    39ea:	90 91 2b 01 	lds	r25, 0x012B
    39ee:	01 96       	adiw	r24, 0x01	; 1
    39f0:	90 93 2b 01 	sts	0x012B, r25
    39f4:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    39f8:	80 91 2a 01 	lds	r24, 0x012A
    39fc:	90 91 2b 01 	lds	r25, 0x012B
    3a00:	81 15       	cp	r24, r1
    3a02:	93 40       	sbci	r25, 0x03	; 3
    3a04:	20 f0       	brcs	.+8      	; 0x3a0e <__vector_10+0x8a>
				{
					sdFifoReadPointer=0;
    3a06:	10 92 2b 01 	sts	0x012B, r1
    3a0a:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3a0e:	80 91 26 01 	lds	r24, 0x0126
    3a12:	90 91 27 01 	lds	r25, 0x0127
    3a16:	01 97       	sbiw	r24, 0x01	; 1
    3a18:	90 93 27 01 	sts	0x0127, r25
    3a1c:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3a20:	80 91 22 01 	lds	r24, 0x0122
    3a24:	90 91 23 01 	lds	r25, 0x0123
    3a28:	a0 91 24 01 	lds	r26, 0x0124
    3a2c:	b0 91 25 01 	lds	r27, 0x0125
    3a30:	01 97       	sbiw	r24, 0x01	; 1
    3a32:	a1 09       	sbc	r26, r1
    3a34:	b1 09       	sbc	r27, r1
    3a36:	80 93 22 01 	sts	0x0122, r24
    3a3a:	90 93 23 01 	sts	0x0123, r25
    3a3e:	a0 93 24 01 	sts	0x0124, r26
    3a42:	b0 93 25 01 	sts	0x0125, r27

				// Now put this byte into the RAM bank in the correct address.

				LATCH_DDR=0xFF;								// Data bus to output -- we never need to read the RAM in this version of the ISR.
    3a46:	8f ef       	ldi	r24, 0xFF	; 255
    3a48:	84 b9       	out	0x04, r24	; 4
				LATCH_PORT=sdRamAddress;					// Put the LSB of the address on the latch.
    3a4a:	80 91 50 05 	lds	r24, 0x0550
    3a4e:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);					// Strobe it to the latch output...
    3a50:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);					// ...Keep it there.
    3a52:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);				// Put the middle byte of the address on the latch.
    3a54:	40 91 50 05 	lds	r20, 0x0550
    3a58:	50 91 51 05 	lds	r21, 0x0551
    3a5c:	60 91 52 05 	lds	r22, 0x0552
    3a60:	70 91 53 05 	lds	r23, 0x0553
    3a64:	bb 27       	eor	r27, r27
    3a66:	a7 2f       	mov	r26, r23
    3a68:	96 2f       	mov	r25, r22
    3a6a:	85 2f       	mov	r24, r21
    3a6c:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);					// Strobe it to the latch output...
    3a6e:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);					// ...Keep it there.
    3a70:	14 98       	cbi	0x02, 4	; 2
				PORTC=(0x88|((sdRamAddress>>16)&0x07));		// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3a72:	cb 01       	movw	r24, r22
    3a74:	aa 27       	eor	r26, r26
    3a76:	bb 27       	eor	r27, r27
    3a78:	87 70       	andi	r24, 0x07	; 7
    3a7a:	99 27       	eor	r25, r25
    3a7c:	aa 27       	eor	r26, r26
    3a7e:	bb 27       	eor	r27, r27
    3a80:	88 68       	ori	r24, 0x88	; 136
    3a82:	88 b9       	out	0x08, r24	; 8

				LATCH_PORT=theByte;							// Put the data to write on the RAM's input port
    3a84:	25 b9       	out	0x05, r18	; 5

				// Compute address while bus settles.
				if(sdBank0==true)		// Is this SD buffer being written to bank 0 (or bank 1)
    3a86:	80 91 54 05 	lds	r24, 0x0554
    3a8a:	81 30       	cpi	r24, 0x01	; 1
    3a8c:	29 f4       	brne	.+10     	; 0x3a98 <__vector_10+0x114>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    3a8e:	4f 5f       	subi	r20, 0xFF	; 255
    3a90:	5f 4f       	sbci	r21, 0xFF	; 255
    3a92:	6f 4f       	sbci	r22, 0xFF	; 255
    3a94:	7f 4f       	sbci	r23, 0xFF	; 255
    3a96:	04 c0       	rjmp	.+8      	; 0x3aa0 <__vector_10+0x11c>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3a98:	41 50       	subi	r20, 0x01	; 1
    3a9a:	51 09       	sbc	r21, r1
    3a9c:	61 09       	sbc	r22, r1
    3a9e:	71 09       	sbc	r23, r1
    3aa0:	40 93 50 05 	sts	0x0550, r20
    3aa4:	50 93 51 05 	sts	0x0551, r21
    3aa8:	60 93 52 05 	sts	0x0552, r22
    3aac:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish writing to RAM.
				PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    3ab0:	11 98       	cbi	0x02, 1	; 2
				PORTA|=(Om_RAM_WE);					// Disbale writes.
    3ab2:	11 9a       	sbi	0x02, 1	; 2
    3ab4:	37 c1       	rjmp	.+622    	; 0x3d24 <__vector_10+0x3a0>

			}
		}
		else	// All sample bytes processed, end ISR and unlock the bank we were using.  Mark the current write address as the last address of the sample.
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3ab6:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    3aba:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3abe:	80 91 70 00 	lds	r24, 0x0070
    3ac2:	8b 7f       	andi	r24, 0xFB	; 251
    3ac4:	80 93 70 00 	sts	0x0070, r24

			if(sdBank0==true)	// Unlock the bank for other RAM accesses, update final address
    3ac8:	20 91 54 05 	lds	r18, 0x0554
    3acc:	80 91 50 05 	lds	r24, 0x0550
    3ad0:	90 91 51 05 	lds	r25, 0x0551
    3ad4:	a0 91 52 05 	lds	r26, 0x0552
    3ad8:	b0 91 53 05 	lds	r27, 0x0553
    3adc:	21 30       	cpi	r18, 0x01	; 1
    3ade:	99 f4       	brne	.+38     	; 0x3b06 <__vector_10+0x182>
			{
				bankStates[BANK_0].isLocked=false;					// Unlock bank
    3ae0:	10 92 ea 05 	sts	0x05EA, r1
				bankStates[BANK_0].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3ae4:	80 93 f2 05 	sts	0x05F2, r24
    3ae8:	90 93 f3 05 	sts	0x05F3, r25
    3aec:	a0 93 f4 05 	sts	0x05F4, r26
    3af0:	b0 93 f5 05 	sts	0x05F5, r27
				bankStates[BANK_0].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3af4:	80 93 fa 05 	sts	0x05FA, r24
    3af8:	90 93 fb 05 	sts	0x05FB, r25
    3afc:	a0 93 fc 05 	sts	0x05FC, r26
    3b00:	b0 93 fd 05 	sts	0x05FD, r27
    3b04:	0f c1       	rjmp	.+542    	; 0x3d24 <__vector_10+0x3a0>
			}
			else
			{
				bankStates[BANK_1].isLocked=false;					// Unlock bank
    3b06:	10 92 0e 06 	sts	0x060E, r1
				bankStates[BANK_1].endAddress=sdRamAddress;			// Match ending address of the sample to the current memory address.
    3b0a:	80 93 16 06 	sts	0x0616, r24
    3b0e:	90 93 17 06 	sts	0x0617, r25
    3b12:	a0 93 18 06 	sts	0x0618, r26
    3b16:	b0 93 19 06 	sts	0x0619, r27
				bankStates[BANK_1].adjustedEndAddress=sdRamAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
    3b1a:	80 93 1e 06 	sts	0x061E, r24
    3b1e:	90 93 1f 06 	sts	0x061F, r25
    3b22:	a0 93 20 06 	sts	0x0620, r26
    3b26:	b0 93 21 06 	sts	0x0621, r27
    3b2a:	fc c0       	rjmp	.+504    	; 0x3d24 <__vector_10+0x3a0>
			}
		}
	}
	else if(sdIsrState==SD_ISR_READING_RAM)  // Putting data from RAM into the SD buffer?
    3b2c:	82 30       	cpi	r24, 0x02	; 2
    3b2e:	09 f0       	breq	.+2      	; 0x3b32 <__vector_10+0x1ae>
    3b30:	98 c0       	rjmp	.+304    	; 0x3c62 <__vector_10+0x2de>
	{
		// Reading the RAM, writing the SD -- Get bytes from RAM, put them in fifo.  When fifo fills, pause.  When the entire sample has been transferred to the FIFO, stop the ISR
		if(sdBytesInFifo<SD_FIFO_SIZE)	// Room in fifo?
    3b32:	80 91 26 01 	lds	r24, 0x0126
    3b36:	90 91 27 01 	lds	r25, 0x0127
    3b3a:	81 15       	cp	r24, r1
    3b3c:	93 40       	sbci	r25, 0x03	; 3
    3b3e:	08 f0       	brcs	.+2      	; 0x3b42 <__vector_10+0x1be>
    3b40:	f1 c0       	rjmp	.+482    	; 0x3d24 <__vector_10+0x3a0>
		{
			if(sdRamSampleRemaining)	// Any sample left in RAM?
    3b42:	80 91 22 01 	lds	r24, 0x0122
    3b46:	90 91 23 01 	lds	r25, 0x0123
    3b4a:	a0 91 24 01 	lds	r26, 0x0124
    3b4e:	b0 91 25 01 	lds	r27, 0x0125
    3b52:	89 2b       	or	r24, r25
    3b54:	8a 2b       	or	r24, r26
    3b56:	8b 2b       	or	r24, r27
    3b58:	09 f4       	brne	.+2      	; 0x3b5c <__vector_10+0x1d8>
    3b5a:	70 c0       	rjmp	.+224    	; 0x3c3c <__vector_10+0x2b8>
			{
				// Read SRAM (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
				LATCH_PORT=sdRamAddress;				// Put the LSB of the address on the latch.
    3b5c:	80 91 50 05 	lds	r24, 0x0550
    3b60:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    3b62:	13 9a       	sbi	0x02, 3	; 2
				PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    3b64:	13 98       	cbi	0x02, 3	; 2

				LATCH_PORT=(sdRamAddress>>8);			// Put the middle byte of the address on the latch.
    3b66:	40 91 50 05 	lds	r20, 0x0550
    3b6a:	50 91 51 05 	lds	r21, 0x0551
    3b6e:	60 91 52 05 	lds	r22, 0x0552
    3b72:	70 91 53 05 	lds	r23, 0x0553
    3b76:	bb 27       	eor	r27, r27
    3b78:	a7 2f       	mov	r26, r23
    3b7a:	96 2f       	mov	r25, r22
    3b7c:	85 2f       	mov	r24, r21
    3b7e:	85 b9       	out	0x05, r24	; 5
				PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    3b80:	14 9a       	sbi	0x02, 4	; 2
				PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    3b82:	14 98       	cbi	0x02, 4	; 2

				PORTC=(0x88|((sdRamAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
    3b84:	cb 01       	movw	r24, r22
    3b86:	aa 27       	eor	r26, r26
    3b88:	bb 27       	eor	r27, r27
    3b8a:	87 70       	andi	r24, 0x07	; 7
    3b8c:	99 27       	eor	r25, r25
    3b8e:	aa 27       	eor	r26, r26
    3b90:	bb 27       	eor	r27, r27
    3b92:	88 68       	ori	r24, 0x88	; 136
    3b94:	88 b9       	out	0x08, r24	; 8

				LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    3b96:	14 b8       	out	0x04, r1	; 4
				PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    3b98:	12 98       	cbi	0x02, 2	; 2

				// Calculate new addy while data bus settles
				if(sdBank0==true)		// Is this SD buffer being read from bank 0 (or bank 1)
    3b9a:	80 91 54 05 	lds	r24, 0x0554
    3b9e:	81 30       	cpi	r24, 0x01	; 1
    3ba0:	29 f4       	brne	.+10     	; 0x3bac <__vector_10+0x228>
				{
					sdRamAddress++;		// Next address is higher for bank 0...
    3ba2:	4f 5f       	subi	r20, 0xFF	; 255
    3ba4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ba6:	6f 4f       	sbci	r22, 0xFF	; 255
    3ba8:	7f 4f       	sbci	r23, 0xFF	; 255
    3baa:	04 c0       	rjmp	.+8      	; 0x3bb4 <__vector_10+0x230>
				}
				else
				{
					sdRamAddress--;		// Next address is lower for bank 1.
    3bac:	41 50       	subi	r20, 0x01	; 1
    3bae:	51 09       	sbc	r21, r1
    3bb0:	61 09       	sbc	r22, r1
    3bb2:	71 09       	sbc	r23, r1
    3bb4:	40 93 50 05 	sts	0x0550, r20
    3bb8:	50 93 51 05 	sts	0x0551, r21
    3bbc:	60 93 52 05 	sts	0x0552, r22
    3bc0:	70 93 53 05 	sts	0x0553, r23
				}

				// Finish getting the byte from RAM.

				theByte=LATCH_INPUT;				// Get the byte from this address in RAM.
    3bc4:	83 b1       	in	r24, 0x03	; 3
				PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    3bc6:	12 9a       	sbi	0x02, 2	; 2
				LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    3bc8:	9f ef       	ldi	r25, 0xFF	; 255
    3bca:	94 b9       	out	0x04, r25	; 4

				// Now put this byte from RAM into the sd fifo


				sdFifo[sdFifoWritePointer]=theByte;	// Put our byte in the fifo.
    3bcc:	e0 91 28 01 	lds	r30, 0x0128
    3bd0:	f0 91 29 01 	lds	r31, 0x0129
    3bd4:	e4 5d       	subi	r30, 0xD4	; 212
    3bd6:	fe 4f       	sbci	r31, 0xFE	; 254
    3bd8:	80 83       	st	Z, r24
				sdFifoWritePointer++;				// Move to next spot in fifo
    3bda:	80 91 28 01 	lds	r24, 0x0128
    3bde:	90 91 29 01 	lds	r25, 0x0129
    3be2:	01 96       	adiw	r24, 0x01	; 1
    3be4:	90 93 29 01 	sts	0x0129, r25
    3be8:	80 93 28 01 	sts	0x0128, r24

				if(sdFifoWritePointer>=SD_FIFO_SIZE)				// Handle wrapping around end of fifo
    3bec:	80 91 28 01 	lds	r24, 0x0128
    3bf0:	90 91 29 01 	lds	r25, 0x0129
    3bf4:	81 15       	cp	r24, r1
    3bf6:	93 40       	sbci	r25, 0x03	; 3
    3bf8:	20 f0       	brcs	.+8      	; 0x3c02 <__vector_10+0x27e>
				{
					sdFifoWritePointer=0;
    3bfa:	10 92 29 01 	sts	0x0129, r1
    3bfe:	10 92 28 01 	sts	0x0128, r1
				}

				sdBytesInFifo++;				// One more byte in the FIFO
    3c02:	80 91 26 01 	lds	r24, 0x0126
    3c06:	90 91 27 01 	lds	r25, 0x0127
    3c0a:	01 96       	adiw	r24, 0x01	; 1
    3c0c:	90 93 27 01 	sts	0x0127, r25
    3c10:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;		// One less byte in the sample
    3c14:	80 91 22 01 	lds	r24, 0x0122
    3c18:	90 91 23 01 	lds	r25, 0x0123
    3c1c:	a0 91 24 01 	lds	r26, 0x0124
    3c20:	b0 91 25 01 	lds	r27, 0x0125
    3c24:	01 97       	sbiw	r24, 0x01	; 1
    3c26:	a1 09       	sbc	r26, r1
    3c28:	b1 09       	sbc	r27, r1
    3c2a:	80 93 22 01 	sts	0x0122, r24
    3c2e:	90 93 23 01 	sts	0x0123, r25
    3c32:	a0 93 24 01 	sts	0x0124, r26
    3c36:	b0 93 25 01 	sts	0x0125, r27
    3c3a:	74 c0       	rjmp	.+232    	; 0x3d24 <__vector_10+0x3a0>

			}
			else	// No more bytes in the sample to be transferred.  Stop the ISR and unlock this RAM bank for the rest of the program
			{
				sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3c3c:	10 92 4f 05 	sts	0x054F, r1
				TCCR2B=0;					// Stop this timer
    3c40:	10 92 b1 00 	sts	0x00B1, r1
				TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3c44:	80 91 70 00 	lds	r24, 0x0070
    3c48:	8b 7f       	andi	r24, 0xFB	; 251
    3c4a:	80 93 70 00 	sts	0x0070, r24

				if(sdBank0==true)	// Unlock the bank for other RAM accesses
    3c4e:	80 91 54 05 	lds	r24, 0x0554
    3c52:	81 30       	cpi	r24, 0x01	; 1
    3c54:	19 f4       	brne	.+6      	; 0x3c5c <__vector_10+0x2d8>
				{
					bankStates[BANK_0].isLocked=false;					// Unlock bank
    3c56:	10 92 ea 05 	sts	0x05EA, r1
    3c5a:	64 c0       	rjmp	.+200    	; 0x3d24 <__vector_10+0x3a0>
				}
				else
				{
					bankStates[BANK_1].isLocked=false;					// Unlock bank
    3c5c:	10 92 0e 06 	sts	0x060E, r1
    3c60:	61 c0       	rjmp	.+194    	; 0x3d24 <__vector_10+0x3a0>
				}
			}
		}
	}
	else if(sdIsrState==SD_ISR_STREAMING_PLAYBACK)	// Streaming data directly from the SD buffer to the audio DAC?
    3c62:	83 30       	cpi	r24, 0x03	; 3
    3c64:	09 f0       	breq	.+2      	; 0x3c68 <__vector_10+0x2e4>
    3c66:	5e c0       	rjmp	.+188    	; 0x3d24 <__vector_10+0x3a0>
	{
		if(sdRamSampleRemaining)	// Bytes remaining in the sample?
    3c68:	80 91 22 01 	lds	r24, 0x0122
    3c6c:	90 91 23 01 	lds	r25, 0x0123
    3c70:	a0 91 24 01 	lds	r26, 0x0124
    3c74:	b0 91 25 01 	lds	r27, 0x0125
    3c78:	89 2b       	or	r24, r25
    3c7a:	8a 2b       	or	r24, r26
    3c7c:	8b 2b       	or	r24, r27
    3c7e:	09 f4       	brne	.+2      	; 0x3c82 <__vector_10+0x2fe>
    3c80:	46 c0       	rjmp	.+140    	; 0x3d0e <__vector_10+0x38a>
		{
			if(sdBytesInFifo)	// Anything currently in the FIFO?
    3c82:	80 91 26 01 	lds	r24, 0x0126
    3c86:	90 91 27 01 	lds	r25, 0x0127
    3c8a:	89 2b       	or	r24, r25
    3c8c:	09 f4       	brne	.+2      	; 0x3c90 <__vector_10+0x30c>
    3c8e:	4a c0       	rjmp	.+148    	; 0x3d24 <__vector_10+0x3a0>
			{
				theByte=sdFifo[sdFifoReadPointer];		// Grab data from the FIFO.
    3c90:	e0 91 2a 01 	lds	r30, 0x012A
    3c94:	f0 91 2b 01 	lds	r31, 0x012B
    3c98:	e4 5d       	subi	r30, 0xD4	; 212
    3c9a:	fe 4f       	sbci	r31, 0xFE	; 254
    3c9c:	20 81       	ld	r18, Z

				sdFifoReadPointer++;					// Move to next spot in fifo
    3c9e:	80 91 2a 01 	lds	r24, 0x012A
    3ca2:	90 91 2b 01 	lds	r25, 0x012B
    3ca6:	01 96       	adiw	r24, 0x01	; 1
    3ca8:	90 93 2b 01 	sts	0x012B, r25
    3cac:	80 93 2a 01 	sts	0x012A, r24
				if(sdFifoReadPointer>=SD_FIFO_SIZE)		// Handle wrapping around end of fifo
    3cb0:	80 91 2a 01 	lds	r24, 0x012A
    3cb4:	90 91 2b 01 	lds	r25, 0x012B
    3cb8:	81 15       	cp	r24, r1
    3cba:	93 40       	sbci	r25, 0x03	; 3
    3cbc:	20 f0       	brcs	.+8      	; 0x3cc6 <__vector_10+0x342>
				{
					sdFifoReadPointer=0;
    3cbe:	10 92 2b 01 	sts	0x012B, r1
    3cc2:	10 92 2a 01 	sts	0x012A, r1
				}

				sdBytesInFifo--;				// One less byte in the FIFO
    3cc6:	80 91 26 01 	lds	r24, 0x0126
    3cca:	90 91 27 01 	lds	r25, 0x0127
    3cce:	01 97       	sbiw	r24, 0x01	; 1
    3cd0:	90 93 27 01 	sts	0x0127, r25
    3cd4:	80 93 26 01 	sts	0x0126, r24
				sdRamSampleRemaining--;			// One less byte in the sample
    3cd8:	80 91 22 01 	lds	r24, 0x0122
    3cdc:	90 91 23 01 	lds	r25, 0x0123
    3ce0:	a0 91 24 01 	lds	r26, 0x0124
    3ce4:	b0 91 25 01 	lds	r27, 0x0125
    3ce8:	01 97       	sbiw	r24, 0x01	; 1
    3cea:	a1 09       	sbc	r26, r1
    3cec:	b1 09       	sbc	r27, r1
    3cee:	80 93 22 01 	sts	0x0122, r24
    3cf2:	90 93 23 01 	sts	0x0123, r25
    3cf6:	a0 93 24 01 	sts	0x0124, r26
    3cfa:	b0 93 25 01 	sts	0x0125, r27

				// Now spit the byte out the DAC.

				sdStreamOutput=theByte;		// Mark this byte as the one we want to go out in our DAC-updating routine
    3cfe:	20 93 55 05 	sts	0x0555, r18
				UpdateOutput();				// Update the DAC
    3d02:	e0 91 e1 05 	lds	r30, 0x05E1
    3d06:	f0 91 e2 05 	lds	r31, 0x05E2
    3d0a:	09 95       	icall
    3d0c:	0b c0       	rjmp	.+22     	; 0x3d24 <__vector_10+0x3a0>
			}
		}
		else	// All sample bytes processed, end ISR and re-set the DAC to midscale
		{
			sdIsrState=SD_ISR_IDLE;		// ISR state to idle
    3d0e:	10 92 4f 05 	sts	0x054F, r1
			TCCR2B=0;					// Stop this timer
    3d12:	10 92 b1 00 	sts	0x00B1, r1
			TIMSK2&=~(1<<OCIE2B);		// Disable interrupt
    3d16:	80 91 70 00 	lds	r24, 0x0070
    3d1a:	8b 7f       	andi	r24, 0xFB	; 251
    3d1c:	80 93 70 00 	sts	0x0070, r24

			// Set this contribution to the DAC to midscale (this output source is now quiet)
			sdStreamOutput=0;
    3d20:	10 92 55 05 	sts	0x0555, r1
		}
	}
}
    3d24:	ff 91       	pop	r31
    3d26:	ef 91       	pop	r30
    3d28:	bf 91       	pop	r27
    3d2a:	af 91       	pop	r26
    3d2c:	9f 91       	pop	r25
    3d2e:	8f 91       	pop	r24
    3d30:	7f 91       	pop	r23
    3d32:	6f 91       	pop	r22
    3d34:	5f 91       	pop	r21
    3d36:	4f 91       	pop	r20
    3d38:	3f 91       	pop	r19
    3d3a:	2f 91       	pop	r18
    3d3c:	0f 90       	pop	r0
    3d3e:	0f be       	out	0x3f, r0	; 63
    3d40:	0f 90       	pop	r0
    3d42:	1f 90       	pop	r1
    3d44:	18 95       	reti

00003d46 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our FABULOUS intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    3d46:	1f 92       	push	r1
    3d48:	0f 92       	push	r0
    3d4a:	0f b6       	in	r0, 0x3f	; 63
    3d4c:	0f 92       	push	r0
    3d4e:	11 24       	eor	r1, r1
    3d50:	8f 93       	push	r24
    3d52:	9f 93       	push	r25
	static unsigned char
		pwmCount;

	if(ledPwm>pwmCount)
    3d54:	90 91 40 04 	lds	r25, 0x0440
    3d58:	80 91 56 05 	lds	r24, 0x0556
    3d5c:	89 17       	cp	r24, r25
    3d5e:	18 f4       	brcc	.+6      	; 0x3d66 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    3d60:	9f ef       	ldi	r25, 0xFF	; 255
    3d62:	95 b9       	out	0x05, r25	; 5
    3d64:	01 c0       	rjmp	.+2      	; 0x3d68 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    3d66:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    3d68:	8f 5f       	subi	r24, 0xFF	; 255
    3d6a:	80 93 56 05 	sts	0x0556, r24
}
    3d6e:	9f 91       	pop	r25
    3d70:	8f 91       	pop	r24
    3d72:	0f 90       	pop	r0
    3d74:	0f be       	out	0x3f, r0	; 63
    3d76:	0f 90       	pop	r0
    3d78:	1f 90       	pop	r1
    3d7a:	18 95       	reti

00003d7c <__vector_default>:

ISR(__vector_default)
{
    3d7c:	1f 92       	push	r1
    3d7e:	0f 92       	push	r0
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	0f 92       	push	r0
    3d84:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    3d86:	0f 90       	pop	r0
    3d88:	0f be       	out	0x3f, r0	; 63
    3d8a:	0f 90       	pop	r0
    3d8c:	1f 90       	pop	r1
    3d8e:	18 95       	reti

00003d90 <HandleSoftclock>:

void HandleSoftclock(void)
// NOTE -- this is NOT an ISR.  That's so it doesn't mess with sampling.
// This does mean that we don't need to do atomic accesses to systemTicks, and we also can screw up our concept of time when we have a hang-ey loop.
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    3d90:	a8 9b       	sbis	0x15, 0	; 21
    3d92:	0a c0       	rjmp	.+20     	; 0x3da8 <HandleSoftclock+0x18>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    3d94:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    3d96:	80 91 2d 06 	lds	r24, 0x062D
    3d9a:	90 91 2e 06 	lds	r25, 0x062E
    3d9e:	01 96       	adiw	r24, 0x01	; 1
    3da0:	90 93 2e 06 	sts	0x062E, r25
    3da4:	80 93 2d 06 	sts	0x062D, r24
    3da8:	08 95       	ret

00003daa <EepromWrite>:
void EepromWrite(unsigned int theAddress, unsigned char theData)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3daa:	f9 99       	sbic	0x1f, 1	; 31
    3dac:	fe cf       	rjmp	.-4      	; 0x3daa <EepromWrite>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3dae:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3db0:	f8 94       	cli

	EEAR=theAddress;
    3db2:	92 bd       	out	0x22, r25	; 34
    3db4:	81 bd       	out	0x21, r24	; 33
	EEDR=theData;
    3db6:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    3db8:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    3dba:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    3dbc:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3dbe:	12 bc       	out	0x22, r1	; 34
    3dc0:	11 bc       	out	0x21, r1	; 33
    3dc2:	08 95       	ret

00003dc4 <EepromRead>:
unsigned char EepromRead(unsigned char theAddress)
{
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    3dc4:	f9 99       	sbic	0x1f, 1	; 31
    3dc6:	fe cf       	rjmp	.-4      	; 0x3dc4 <EepromRead>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    3dc8:	2f b7       	in	r18, 0x3f	; 63
	cli();		// Stop interrupts.
    3dca:	f8 94       	cli

	EEAR=theAddress;
    3dcc:	90 e0       	ldi	r25, 0x00	; 0
    3dce:	92 bd       	out	0x22, r25	; 34
    3dd0:	81 bd       	out	0x21, r24	; 33
	EECR|=(1<<EERE);	// Start reading.
    3dd2:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    3dd4:	2f bf       	out	0x3f, r18	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    3dd6:	12 bc       	out	0x22, r1	; 34
    3dd8:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    3dda:	80 b5       	in	r24, 0x20	; 32
}
    3ddc:	08 95       	ret

00003dde <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    3dde:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    3de2:	88 1f       	adc	r24, r24
    3de4:	88 27       	eor	r24, r24
    3de6:	88 1f       	adc	r24, r24
    3de8:	08 95       	ret

00003dea <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3dea:	80 91 c6 00 	lds	r24, 0x00C6
}
    3dee:	08 95       	ret

00003df0 <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    3df0:	80 91 64 00 	lds	r24, 0x0064
    3df4:	8d 7f       	andi	r24, 0xFD	; 253
    3df6:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    3dfa:	80 91 c0 00 	lds	r24, 0x00C0
    3dfe:	8d 7f       	andi	r24, 0xFD	; 253
    3e00:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    3e04:	88 e1       	ldi	r24, 0x18	; 24
    3e06:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    3e0a:	87 e2       	ldi	r24, 0x27	; 39
    3e0c:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    3e10:	86 e0       	ldi	r24, 0x06	; 6
    3e12:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    3e16:	80 91 c0 00 	lds	r24, 0x00C0
    3e1a:	85 ff       	sbrs	r24, 5
    3e1c:	fc cf       	rjmp	.-8      	; 0x3e16 <InitUart0+0x26>
    3e1e:	02 c0       	rjmp	.+4      	; 0x3e24 <InitUart0+0x34>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    3e20:	80 91 c6 00 	lds	r24, 0x00C6
	{
		;
	}

//	Uart0FlushBuffer();						// Get rid of any poo poo hanging out in the input buffer.
	while(Uart0GotByte())
    3e24:	0e 94 ef 1e 	call	0x3dde	; 0x3dde <Uart0GotByte>
    3e28:	81 11       	cpse	r24, r1
    3e2a:	fa cf       	rjmp	.-12     	; 0x3e20 <InitUart0+0x30>
	{
		Uart0GetByte();
	}		
}
    3e2c:	08 95       	ret

00003e2e <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    3e2e:	90 e0       	ldi	r25, 0x00	; 0
    3e30:	20 91 2d 06 	lds	r18, 0x062D
    3e34:	30 91 2e 06 	lds	r19, 0x062E
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	fc 01       	movw	r30, r24
    3e3e:	ec 53       	subi	r30, 0x3C	; 60
    3e40:	fa 4f       	sbci	r31, 0xFA	; 250
    3e42:	31 83       	std	Z+1, r19	; 0x01
    3e44:	20 83       	st	Z, r18
	delayTime[timerNum]=ticks_to_wait;
    3e46:	fc 01       	movw	r30, r24
    3e48:	e4 53       	subi	r30, 0x34	; 52
    3e4a:	fa 4f       	sbci	r31, 0xFA	; 250
    3e4c:	71 83       	std	Z+1, r23	; 0x01
    3e4e:	60 83       	st	Z, r22
    3e50:	08 95       	ret

00003e52 <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    3e52:	20 91 2d 06 	lds	r18, 0x062D
    3e56:	30 91 2e 06 	lds	r19, 0x062E
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	88 0f       	add	r24, r24
    3e5e:	99 1f       	adc	r25, r25
    3e60:	fc 01       	movw	r30, r24
    3e62:	ec 53       	subi	r30, 0x3C	; 60
    3e64:	fa 4f       	sbci	r31, 0xFA	; 250
    3e66:	40 81       	ld	r20, Z
    3e68:	51 81       	ldd	r21, Z+1	; 0x01
    3e6a:	24 1b       	sub	r18, r20
    3e6c:	35 0b       	sbc	r19, r21
    3e6e:	fc 01       	movw	r30, r24
    3e70:	e4 53       	subi	r30, 0x34	; 52
    3e72:	fa 4f       	sbci	r31, 0xFA	; 250
    3e74:	81 e0       	ldi	r24, 0x01	; 1
    3e76:	40 81       	ld	r20, Z
    3e78:	51 81       	ldd	r21, Z+1	; 0x01
    3e7a:	24 17       	cp	r18, r20
    3e7c:	35 07       	cpc	r19, r21
    3e7e:	08 f4       	brcc	.+2      	; 0x3e82 <CheckTimer+0x30>
    3e80:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    3e82:	08 95       	ret

00003e84 <PutMidiMessageInIncomingFifo>:
}

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
    3e84:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    3e86:	80 91 61 06 	lds	r24, 0x0661
    3e8a:	86 30       	cpi	r24, 0x06	; 6
    3e8c:	08 f5       	brcc	.+66     	; 0x3ed0 <PutMidiMessageInIncomingFifo+0x4c>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    3e8e:	90 91 d8 05 	lds	r25, 0x05D8
    3e92:	11 96       	adiw	r26, 0x01	; 1
    3e94:	2c 91       	ld	r18, X
    3e96:	11 97       	sbiw	r26, 0x01	; 1
    3e98:	34 e0       	ldi	r19, 0x04	; 4
    3e9a:	93 9f       	mul	r25, r19
    3e9c:	f0 01       	movw	r30, r0
    3e9e:	11 24       	eor	r1, r1
    3ea0:	e0 5d       	subi	r30, 0xD0	; 208
    3ea2:	f9 4f       	sbci	r31, 0xF9	; 249
    3ea4:	21 83       	std	Z+1, r18	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    3ea6:	12 96       	adiw	r26, 0x02	; 2
    3ea8:	2c 91       	ld	r18, X
    3eaa:	12 97       	sbiw	r26, 0x02	; 2
    3eac:	22 83       	std	Z+2, r18	; 0x02
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    3eae:	13 96       	adiw	r26, 0x03	; 3
    3eb0:	2c 91       	ld	r18, X
    3eb2:	13 97       	sbiw	r26, 0x03	; 3
    3eb4:	23 83       	std	Z+3, r18	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    3eb6:	2c 91       	ld	r18, X
    3eb8:	20 83       	st	Z, r18
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3eba:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3ebc:	96 30       	cpi	r25, 0x06	; 6
    3ebe:	18 f4       	brcc	.+6      	; 0x3ec6 <PutMidiMessageInIncomingFifo+0x42>
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    3ec0:	90 93 d8 05 	sts	0x05D8, r25
    3ec4:	02 c0       	rjmp	.+4      	; 0x3eca <PutMidiMessageInIncomingFifo+0x46>
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoWritePointer=0;
    3ec6:	10 92 d8 05 	sts	0x05D8, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    3eca:	8f 5f       	subi	r24, 0xFF	; 255
    3ecc:	80 93 61 06 	sts	0x0661, r24
    3ed0:	08 95       	ret

00003ed2 <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    3ed2:	dc 01       	movw	r26, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    3ed4:	80 91 61 06 	lds	r24, 0x0661
    3ed8:	88 23       	and	r24, r24
    3eda:	09 f1       	breq	.+66     	; 0x3f1e <GetMidiMessageFromIncomingFifo+0x4c>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    3edc:	90 91 d4 05 	lds	r25, 0x05D4
    3ee0:	24 e0       	ldi	r18, 0x04	; 4
    3ee2:	92 9f       	mul	r25, r18
    3ee4:	f0 01       	movw	r30, r0
    3ee6:	11 24       	eor	r1, r1
    3ee8:	e0 5d       	subi	r30, 0xD0	; 208
    3eea:	f9 4f       	sbci	r31, 0xF9	; 249
    3eec:	21 81       	ldd	r18, Z+1	; 0x01
    3eee:	11 96       	adiw	r26, 0x01	; 1
    3ef0:	2c 93       	st	X, r18
    3ef2:	11 97       	sbiw	r26, 0x01	; 1
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    3ef4:	22 81       	ldd	r18, Z+2	; 0x02
    3ef6:	12 96       	adiw	r26, 0x02	; 2
    3ef8:	2c 93       	st	X, r18
    3efa:	12 97       	sbiw	r26, 0x02	; 2
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    3efc:	23 81       	ldd	r18, Z+3	; 0x03
    3efe:	13 96       	adiw	r26, 0x03	; 3
    3f00:	2c 93       	st	X, r18
    3f02:	13 97       	sbiw	r26, 0x03	; 3
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    3f04:	20 81       	ld	r18, Z
    3f06:	2c 93       	st	X, r18

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3f08:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    3f0a:	96 30       	cpi	r25, 0x06	; 6
    3f0c:	18 f4       	brcc	.+6      	; 0x3f14 <GetMidiMessageFromIncomingFifo+0x42>
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	

		midiIncomingFifoReadPointer++;			// read from the next element next time
    3f0e:	90 93 d4 05 	sts	0x05D4, r25
    3f12:	02 c0       	rjmp	.+4      	; 0x3f18 <GetMidiMessageFromIncomingFifo+0x46>
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiIncomingFifoReadPointer=0;
    3f14:	10 92 d4 05 	sts	0x05D4, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    3f18:	81 50       	subi	r24, 0x01	; 1
    3f1a:	80 93 61 06 	sts	0x0661, r24
    3f1e:	08 95       	ret

00003f20 <PutMidiMessageInOutgoingFifo>:
void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    3f20:	80 91 62 06 	lds	r24, 0x0662
    3f24:	86 30       	cpi	r24, 0x06	; 6
    3f26:	c8 f4       	brcc	.+50     	; 0x3f5a <PutMidiMessageInOutgoingFifo+0x3a>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    3f28:	90 91 d5 05 	lds	r25, 0x05D5
    3f2c:	34 e0       	ldi	r19, 0x04	; 4
    3f2e:	93 9f       	mul	r25, r19
    3f30:	f0 01       	movw	r30, r0
    3f32:	11 24       	eor	r1, r1
    3f34:	e7 5b       	subi	r30, 0xB7	; 183
    3f36:	f9 4f       	sbci	r31, 0xF9	; 249
    3f38:	61 83       	std	Z+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    3f3a:	42 83       	std	Z+2, r20	; 0x02
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    3f3c:	23 83       	std	Z+3, r18	; 0x03
    3f3e:	20 91 2f 06 	lds	r18, 0x062F
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    3f42:	20 83       	st	Z, r18
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3f44:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    3f46:	96 30       	cpi	r25, 0x06	; 6
    3f48:	18 f4       	brcc	.+6      	; 0x3f50 <PutMidiMessageInOutgoingFifo+0x30>
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    3f4a:	90 93 d5 05 	sts	0x05D5, r25
    3f4e:	02 c0       	rjmp	.+4      	; 0x3f54 <PutMidiMessageInOutgoingFifo+0x34>
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoWritePointer=0;
    3f50:	10 92 d5 05 	sts	0x05D5, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    3f54:	8f 5f       	subi	r24, 0xFF	; 255
    3f56:	80 93 62 06 	sts	0x0662, r24
    3f5a:	08 95       	ret

00003f5c <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    3f5c:	89 e0       	ldi	r24, 0x09	; 9
    3f5e:	80 93 d6 05 	sts	0x05D6, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    3f62:	10 92 d7 05 	sts	0x05D7, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    3f66:	10 92 61 06 	sts	0x0661, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    3f6a:	10 92 d8 05 	sts	0x05D8, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    3f6e:	10 92 d4 05 	sts	0x05D4, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    3f72:	10 92 62 06 	sts	0x0662, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    3f76:	10 92 d5 05 	sts	0x05D5, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    3f7a:	10 92 d9 05 	sts	0x05D9, r1
    3f7e:	08 95       	ret

00003f80 <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    3f80:	1f 93       	push	r17
    3f82:	cf 93       	push	r28
    3f84:	df 93       	push	r29
    3f86:	00 d0       	rcall	.+0      	; 0x3f88 <HandleIncomingMidiByte+0x8>
    3f88:	00 d0       	rcall	.+0      	; 0x3f8a <HandleIncomingMidiByte+0xa>
    3f8a:	cd b7       	in	r28, 0x3d	; 61
    3f8c:	de b7       	in	r29, 0x3e	; 62
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    3f8e:	87 ff       	sbrs	r24, 7
    3f90:	2f c0       	rjmp	.+94     	; 0x3ff0 <HandleIncomingMidiByte+0x70>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    3f92:	98 2f       	mov	r25, r24
    3f94:	9f 70       	andi	r25, 0x0F	; 15
    3f96:	20 91 2f 06 	lds	r18, 0x062F
    3f9a:	92 17       	cp	r25, r18
    3f9c:	21 f0       	breq	.+8      	; 0x3fa6 <HandleIncomingMidiByte+0x26>
    3f9e:	30 91 48 06 	lds	r19, 0x0648
    3fa2:	93 13       	cpse	r25, r19
    3fa4:	9f c0       	rjmp	.+318    	; 0x40e4 <HandleIncomingMidiByte+0x164>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    3fa6:	80 7f       	andi	r24, 0xF0	; 240
    3fa8:	80 39       	cpi	r24, 0x90	; 144
    3faa:	19 f4       	brne	.+6      	; 0x3fb2 <HandleIncomingMidiByte+0x32>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    3fac:	10 92 d6 05 	sts	0x05D6, r1
    3fb0:	16 c0       	rjmp	.+44     	; 0x3fde <HandleIncomingMidiByte+0x5e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    3fb2:	80 38       	cpi	r24, 0x80	; 128
    3fb4:	31 f4       	brne	.+12     	; 0x3fc2 <HandleIncomingMidiByte+0x42>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    3fb6:	81 e0       	ldi	r24, 0x01	; 1
    3fb8:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3fbc:	92 13       	cpse	r25, r18
    3fbe:	15 c0       	rjmp	.+42     	; 0x3fea <HandleIncomingMidiByte+0x6a>
    3fc0:	10 c0       	rjmp	.+32     	; 0x3fe2 <HandleIncomingMidiByte+0x62>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    3fc2:	80 3c       	cpi	r24, 0xC0	; 192
    3fc4:	11 f4       	brne	.+4      	; 0x3fca <HandleIncomingMidiByte+0x4a>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    3fc6:	82 e0       	ldi	r24, 0x02	; 2
    3fc8:	08 c0       	rjmp	.+16     	; 0x3fda <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    3fca:	80 3e       	cpi	r24, 0xE0	; 224
    3fcc:	11 f4       	brne	.+4      	; 0x3fd2 <HandleIncomingMidiByte+0x52>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    3fce:	87 e0       	ldi	r24, 0x07	; 7
    3fd0:	04 c0       	rjmp	.+8      	; 0x3fda <HandleIncomingMidiByte+0x5a>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    3fd2:	80 3b       	cpi	r24, 0xB0	; 176
    3fd4:	09 f0       	breq	.+2      	; 0x3fd8 <HandleIncomingMidiByte+0x58>
    3fd6:	86 c0       	rjmp	.+268    	; 0x40e4 <HandleIncomingMidiByte+0x164>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    3fd8:	83 e0       	ldi	r24, 0x03	; 3
    3fda:	80 93 d6 05 	sts	0x05D6, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    3fde:	92 13       	cpse	r25, r18
    3fe0:	03 c0       	rjmp	.+6      	; 0x3fe8 <HandleIncomingMidiByte+0x68>
				{
					temporaryChannel=BANK_0;
    3fe2:	10 92 da 05 	sts	0x05DA, r1
    3fe6:	81 c0       	rjmp	.+258    	; 0x40ea <HandleIncomingMidiByte+0x16a>
				}
				else
				{
					temporaryChannel=BANK_1;
    3fe8:	81 e0       	ldi	r24, 0x01	; 1
    3fea:	80 93 da 05 	sts	0x05DA, r24
    3fee:	7d c0       	rjmp	.+250    	; 0x40ea <HandleIncomingMidiByte+0x16a>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    3ff0:	10 91 d6 05 	lds	r17, 0x05D6
    3ff4:	14 30       	cpi	r17, 0x04	; 4
    3ff6:	09 f4       	brne	.+2      	; 0x3ffa <HandleIncomingMidiByte+0x7a>
    3ff8:	53 c0       	rjmp	.+166    	; 0x40a0 <HandleIncomingMidiByte+0x120>
    3ffa:	50 f4       	brcc	.+20     	; 0x4010 <HandleIncomingMidiByte+0x90>
    3ffc:	11 30       	cpi	r17, 0x01	; 1
    3ffe:	a1 f1       	breq	.+104    	; 0x4068 <HandleIncomingMidiByte+0xe8>
    4000:	c0 f0       	brcs	.+48     	; 0x4032 <HandleIncomingMidiByte+0xb2>
    4002:	12 30       	cpi	r17, 0x02	; 2
    4004:	09 f4       	brne	.+2      	; 0x4008 <HandleIncomingMidiByte+0x88>
    4006:	43 c0       	rjmp	.+134    	; 0x408e <HandleIncomingMidiByte+0x10e>
    4008:	13 30       	cpi	r17, 0x03	; 3
    400a:	09 f0       	breq	.+2      	; 0x400e <HandleIncomingMidiByte+0x8e>
    400c:	6b c0       	rjmp	.+214    	; 0x40e4 <HandleIncomingMidiByte+0x164>
    400e:	44 c0       	rjmp	.+136    	; 0x4098 <HandleIncomingMidiByte+0x118>
    4010:	17 30       	cpi	r17, 0x07	; 7
    4012:	09 f4       	brne	.+2      	; 0x4016 <HandleIncomingMidiByte+0x96>
    4014:	53 c0       	rjmp	.+166    	; 0x40bc <HandleIncomingMidiByte+0x13c>
    4016:	30 f4       	brcc	.+12     	; 0x4024 <HandleIncomingMidiByte+0xa4>
    4018:	15 30       	cpi	r17, 0x05	; 5
    401a:	79 f0       	breq	.+30     	; 0x403a <HandleIncomingMidiByte+0xba>
    401c:	16 30       	cpi	r17, 0x06	; 6
    401e:	09 f0       	breq	.+2      	; 0x4022 <HandleIncomingMidiByte+0xa2>
    4020:	61 c0       	rjmp	.+194    	; 0x40e4 <HandleIncomingMidiByte+0x164>
    4022:	26 c0       	rjmp	.+76     	; 0x4070 <HandleIncomingMidiByte+0xf0>
    4024:	18 30       	cpi	r17, 0x08	; 8
    4026:	09 f4       	brne	.+2      	; 0x402a <HandleIncomingMidiByte+0xaa>
    4028:	4d c0       	rjmp	.+154    	; 0x40c4 <HandleIncomingMidiByte+0x144>
    402a:	19 30       	cpi	r17, 0x09	; 9
    402c:	09 f0       	breq	.+2      	; 0x4030 <HandleIncomingMidiByte+0xb0>
    402e:	5a c0       	rjmp	.+180    	; 0x40e4 <HandleIncomingMidiByte+0x164>
    4030:	5c c0       	rjmp	.+184    	; 0x40ea <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    4032:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    4036:	85 e0       	ldi	r24, 0x05	; 5
    4038:	56 c0       	rjmp	.+172    	; 0x40e6 <HandleIncomingMidiByte+0x166>
    403a:	90 91 db 05 	lds	r25, 0x05DB
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    403e:	81 11       	cpse	r24, r1
    4040:	05 c0       	rjmp	.+10     	; 0x404c <HandleIncomingMidiByte+0xcc>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    4042:	82 e0       	ldi	r24, 0x02	; 2
    4044:	8a 83       	std	Y+2, r24	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4046:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    4048:	1c 82       	std	Y+4, r1	; 0x04
    404a:	04 c0       	rjmp	.+8      	; 0x4054 <HandleIncomingMidiByte+0xd4>
				midiIncomingMessageState=IGNORE_ME;					// Something got messed up.  The velocity value is invalid.  Wait for a new status.		
			}
			else											// Real note on, real value.
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_ON;	// What kind of message is this?
    404c:	21 e0       	ldi	r18, 0x01	; 1
    404e:	2a 83       	std	Y+2, r18	; 0x02
				theMessage.dataByteOne=firstDataByte;			// For what note?
    4050:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;					// And what velocity?
    4052:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;		// And what channel?
    4054:	80 91 da 05 	lds	r24, 0x05DA
    4058:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    405a:	ce 01       	movw	r24, r28
    405c:	01 96       	adiw	r24, 0x01	; 1
    405e:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    4062:	10 92 d6 05 	sts	0x05D6, r1
    4066:	41 c0       	rjmp	.+130    	; 0x40ea <HandleIncomingMidiByte+0x16a>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    4068:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    406c:	86 e0       	ldi	r24, 0x06	; 6
    406e:	3b c0       	rjmp	.+118    	; 0x40e6 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
    4070:	92 e0       	ldi	r25, 0x02	; 2
    4072:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=firstDataByte;				// For what note?
    4074:	90 91 db 05 	lds	r25, 0x05DB
    4078:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// And what velocity?
    407a:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    407c:	80 91 da 05 	lds	r24, 0x05DA
    4080:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
    4082:	ce 01       	movw	r24, r28
    4084:	01 96       	adiw	r24, 0x01	; 1
    4086:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    408a:	81 e0       	ldi	r24, 0x01	; 1
    408c:	2c c0       	rjmp	.+88     	; 0x40e6 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
    408e:	93 e0       	ldi	r25, 0x03	; 3
    4090:	9a 83       	std	Y+2, r25	; 0x02
				theMessage.dataByteOne=theByte;							// ...To this program
    4092:	8b 83       	std	Y+3, r24	; 0x03
				theMessage.dataByteTwo=0;								// And no second data byte.
    4094:	1c 82       	std	Y+4, r1	; 0x04
    4096:	1c c0       	rjmp	.+56     	; 0x40d0 <HandleIncomingMidiByte+0x150>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    4098:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    409c:	84 e0       	ldi	r24, 0x04	; 4
    409e:	23 c0       	rjmp	.+70     	; 0x40e6 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
    40a0:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    40a2:	90 91 db 05 	lds	r25, 0x05DB
    40a6:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;							// And the value.
    40a8:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    40aa:	80 91 da 05 	lds	r24, 0x05DA
    40ae:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.
    40b0:	ce 01       	movw	r24, r28
    40b2:	01 96       	adiw	r24, 0x01	; 1
    40b4:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    40b8:	83 e0       	ldi	r24, 0x03	; 3
    40ba:	15 c0       	rjmp	.+42     	; 0x40e6 <HandleIncomingMidiByte+0x166>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    40bc:	80 93 db 05 	sts	0x05DB, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    40c0:	88 e0       	ldi	r24, 0x08	; 8
    40c2:	11 c0       	rjmp	.+34     	; 0x40e6 <HandleIncomingMidiByte+0x166>
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
    40c4:	17 e0       	ldi	r17, 0x07	; 7
    40c6:	1a 83       	std	Y+2, r17	; 0x02
				theMessage.dataByteOne=firstDataByte;				// LSB
    40c8:	90 91 db 05 	lds	r25, 0x05DB
    40cc:	9b 83       	std	Y+3, r25	; 0x03
				theMessage.dataByteTwo=theByte;						// MSB
    40ce:	8c 83       	std	Y+4, r24	; 0x04
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    40d0:	80 91 da 05 	lds	r24, 0x05DA
    40d4:	89 83       	std	Y+1, r24	; 0x01

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.
    40d6:	ce 01       	movw	r24, r28
    40d8:	01 96       	adiw	r24, 0x01	; 1
    40da:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <PutMidiMessageInIncomingFifo>

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    40de:	10 93 d6 05 	sts	0x05D6, r17
    40e2:	03 c0       	rjmp	.+6      	; 0x40ea <HandleIncomingMidiByte+0x16a>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    40e4:	89 e0       	ldi	r24, 0x09	; 9
    40e6:	80 93 d6 05 	sts	0x05D6, r24
			break;
		}	
	}
}
    40ea:	0f 90       	pop	r0
    40ec:	0f 90       	pop	r0
    40ee:	0f 90       	pop	r0
    40f0:	0f 90       	pop	r0
    40f2:	df 91       	pop	r29
    40f4:	cf 91       	pop	r28
    40f6:	1f 91       	pop	r17
    40f8:	08 95       	ret

000040fa <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    40fa:	80 91 62 06 	lds	r24, 0x0662
    40fe:	81 11       	cpse	r24, r1
    4100:	07 c0       	rjmp	.+14     	; 0x4110 <MidiTxBufferNotEmpty+0x16>
    4102:	81 e0       	ldi	r24, 0x01	; 1
    4104:	90 91 d7 05 	lds	r25, 0x05D7
    4108:	91 11       	cpse	r25, r1
    410a:	03 c0       	rjmp	.+6      	; 0x4112 <MidiTxBufferNotEmpty+0x18>
    410c:	80 e0       	ldi	r24, 0x00	; 0
    410e:	08 95       	ret
	{
		return(true);
    4110:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    4112:	08 95       	ret

00004114 <PopOutgoingMidiByte>:
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    4114:	80 91 d7 05 	lds	r24, 0x05D7
    4118:	83 30       	cpi	r24, 0x03	; 3
    411a:	09 f4       	brne	.+2      	; 0x411e <PopOutgoingMidiByte+0xa>
    411c:	87 c0       	rjmp	.+270    	; 0x422c <PopOutgoingMidiByte+0x118>
    411e:	30 f4       	brcc	.+12     	; 0x412c <PopOutgoingMidiByte+0x18>
    4120:	81 30       	cpi	r24, 0x01	; 1
    4122:	09 f4       	brne	.+2      	; 0x4126 <PopOutgoingMidiByte+0x12>
    4124:	7b c0       	rjmp	.+246    	; 0x421c <PopOutgoingMidiByte+0x108>
    4126:	08 f0       	brcs	.+2      	; 0x412a <PopOutgoingMidiByte+0x16>
    4128:	7b c0       	rjmp	.+246    	; 0x4220 <PopOutgoingMidiByte+0x10c>
    412a:	0c c0       	rjmp	.+24     	; 0x4144 <PopOutgoingMidiByte+0x30>
    412c:	85 30       	cpi	r24, 0x05	; 5
    412e:	09 f4       	brne	.+2      	; 0x4132 <PopOutgoingMidiByte+0x1e>
    4130:	84 c0       	rjmp	.+264    	; 0x423a <PopOutgoingMidiByte+0x126>
    4132:	08 f4       	brcc	.+2      	; 0x4136 <PopOutgoingMidiByte+0x22>
    4134:	7f c0       	rjmp	.+254    	; 0x4234 <PopOutgoingMidiByte+0x120>
    4136:	86 30       	cpi	r24, 0x06	; 6
    4138:	09 f4       	brne	.+2      	; 0x413c <PopOutgoingMidiByte+0x28>
    413a:	82 c0       	rjmp	.+260    	; 0x4240 <PopOutgoingMidiByte+0x12c>
    413c:	87 30       	cpi	r24, 0x07	; 7
    413e:	09 f0       	breq	.+2      	; 0x4142 <PopOutgoingMidiByte+0x2e>
    4140:	86 c0       	rjmp	.+268    	; 0x424e <PopOutgoingMidiByte+0x13a>
    4142:	80 c0       	rjmp	.+256    	; 0x4244 <PopOutgoingMidiByte+0x130>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    4144:	80 91 62 06 	lds	r24, 0x0662
    4148:	88 23       	and	r24, r24
    414a:	f9 f0       	breq	.+62     	; 0x418a <PopOutgoingMidiByte+0x76>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    414c:	90 91 d9 05 	lds	r25, 0x05D9
    4150:	24 e0       	ldi	r18, 0x04	; 4
    4152:	92 9f       	mul	r25, r18
    4154:	f0 01       	movw	r30, r0
    4156:	11 24       	eor	r1, r1
    4158:	e7 5b       	subi	r30, 0xB7	; 183
    415a:	f9 4f       	sbci	r31, 0xF9	; 249
    415c:	21 81       	ldd	r18, Z+1	; 0x01
    415e:	20 93 dd 05 	sts	0x05DD, r18
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    4162:	22 81       	ldd	r18, Z+2	; 0x02
    4164:	20 93 de 05 	sts	0x05DE, r18
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    4168:	23 81       	ldd	r18, Z+3	; 0x03
    416a:	20 93 df 05 	sts	0x05DF, r18
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    416e:	20 81       	ld	r18, Z
    4170:	20 93 dc 05 	sts	0x05DC, r18

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    4174:	9f 5f       	subi	r25, 0xFF	; 255
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    4176:	96 30       	cpi	r25, 0x06	; 6
    4178:	18 f4       	brcc	.+6      	; 0x4180 <PopOutgoingMidiByte+0x6c>
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    417a:	90 93 d9 05 	sts	0x05D9, r25
    417e:	02 c0       	rjmp	.+4      	; 0x4184 <PopOutgoingMidiByte+0x70>
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
		{
			midiOutgoingFifoReadPointer=0;
    4180:	10 92 d9 05 	sts	0x05D9, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    4184:	81 50       	subi	r24, 0x01	; 1
    4186:	80 93 62 06 	sts	0x0662, r24
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    418a:	90 91 dd 05 	lds	r25, 0x05DD
    418e:	92 30       	cpi	r25, 0x02	; 2
    4190:	b1 f0       	breq	.+44     	; 0x41be <PopOutgoingMidiByte+0xaa>
    4192:	20 f4       	brcc	.+8      	; 0x419c <PopOutgoingMidiByte+0x88>
    4194:	91 30       	cpi	r25, 0x01	; 1
    4196:	09 f0       	breq	.+2      	; 0x419a <PopOutgoingMidiByte+0x86>
    4198:	5a c0       	rjmp	.+180    	; 0x424e <PopOutgoingMidiByte+0x13a>
    419a:	06 c0       	rjmp	.+12     	; 0x41a8 <PopOutgoingMidiByte+0x94>
    419c:	93 30       	cpi	r25, 0x03	; 3
    419e:	e9 f0       	breq	.+58     	; 0x41da <PopOutgoingMidiByte+0xc6>
    41a0:	94 30       	cpi	r25, 0x04	; 4
    41a2:	09 f0       	breq	.+2      	; 0x41a6 <PopOutgoingMidiByte+0x92>
    41a4:	54 c0       	rjmp	.+168    	; 0x424e <PopOutgoingMidiByte+0x13a>
    41a6:	29 c0       	rjmp	.+82     	; 0x41fa <PopOutgoingMidiByte+0xe6>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    41a8:	80 91 dc 05 	lds	r24, 0x05DC
    41ac:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    41ae:	20 91 e0 05 	lds	r18, 0x05E0
    41b2:	28 13       	cpse	r18, r24
    41b4:	0f c0       	rjmp	.+30     	; 0x41d4 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    41b6:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    41ba:	93 e0       	ldi	r25, 0x03	; 3
    41bc:	2c c0       	rjmp	.+88     	; 0x4216 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    41be:	80 91 dc 05 	lds	r24, 0x05DC
    41c2:	80 69       	ori	r24, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    41c4:	20 91 e0 05 	lds	r18, 0x05E0
    41c8:	28 13       	cpse	r18, r24
    41ca:	04 c0       	rjmp	.+8      	; 0x41d4 <PopOutgoingMidiByte+0xc0>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    41cc:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    41d0:	94 e0       	ldi	r25, 0x04	; 4
    41d2:	21 c0       	rjmp	.+66     	; 0x4216 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    41d4:	80 93 e0 05 	sts	0x05E0, r24
    41d8:	1e c0       	rjmp	.+60     	; 0x4216 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    41da:	80 91 dc 05 	lds	r24, 0x05DC
    41de:	80 6c       	ori	r24, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    41e0:	90 91 e0 05 	lds	r25, 0x05E0
    41e4:	98 13       	cpse	r25, r24
    41e6:	05 c0       	rjmp	.+10     	; 0x41f2 <PopOutgoingMidiByte+0xde>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    41e8:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    41ec:	10 92 d7 05 	sts	0x05D7, r1
    41f0:	08 95       	ret
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    41f2:	80 93 e0 05 	sts	0x05E0, r24
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    41f6:	95 e0       	ldi	r25, 0x05	; 5
    41f8:	0e c0       	rjmp	.+28     	; 0x4216 <PopOutgoingMidiByte+0x102>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    41fa:	80 91 dc 05 	lds	r24, 0x05DC
    41fe:	80 6b       	ori	r24, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    4200:	90 91 e0 05 	lds	r25, 0x05E0
    4204:	98 13       	cpse	r25, r24
    4206:	04 c0       	rjmp	.+8      	; 0x4210 <PopOutgoingMidiByte+0xfc>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    4208:	80 91 de 05 	lds	r24, 0x05DE
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    420c:	97 e0       	ldi	r25, 0x07	; 7
    420e:	03 c0       	rjmp	.+6      	; 0x4216 <PopOutgoingMidiByte+0x102>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    4210:	80 93 e0 05 	sts	0x05E0, r24
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    4214:	96 e0       	ldi	r25, 0x06	; 6
    4216:	90 93 d7 05 	sts	0x05D7, r25
    421a:	08 95       	ret
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    421c:	83 e0       	ldi	r24, 0x03	; 3
    421e:	01 c0       	rjmp	.+2      	; 0x4222 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    4220:	84 e0       	ldi	r24, 0x04	; 4
    4222:	80 93 d7 05 	sts	0x05D7, r24
		return(theMessage.dataByteOne);						// Return the first data byte.
    4226:	80 91 de 05 	lds	r24, 0x05DE
    422a:	08 95       	ret
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    422c:	10 92 d7 05 	sts	0x05D7, r1
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
    4230:	80 e4       	ldi	r24, 0x40	; 64
    4232:	08 95       	ret
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4234:	10 92 d7 05 	sts	0x05D7, r1
    4238:	0a c0       	rjmp	.+20     	; 0x424e <PopOutgoingMidiByte+0x13a>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    423a:	10 92 d7 05 	sts	0x05D7, r1
    423e:	f3 cf       	rjmp	.-26     	; 0x4226 <PopOutgoingMidiByte+0x112>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4240:	87 e0       	ldi	r24, 0x07	; 7
    4242:	ef cf       	rjmp	.-34     	; 0x4222 <PopOutgoingMidiByte+0x10e>
		return(theMessage.dataByteOne);								// Return the first data byte.
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4244:	10 92 d7 05 	sts	0x05D7, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    4248:	80 91 df 05 	lds	r24, 0x05DF
    424c:	08 95       	ret

			}
			break;

			default:
			theByte=0;		// Make compiler happy.
    424e:	80 e0       	ldi	r24, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    4250:	08 95       	ret

00004252 <UnInitSdInterface>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void UnInitSdInterface(void)
{
	DDRD&=~(Om_SD_CS|Om_SD_CLK);	// Flash specific outputs back to inputs.
    4252:	8a b1       	in	r24, 0x0a	; 10
    4254:	8f 7c       	andi	r24, 0xCF	; 207
    4256:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_SD_CS|Om_SD_CLK);	// Pullup pins so they don't float
    4258:	8b b1       	in	r24, 0x0b	; 11
    425a:	80 63       	ori	r24, 0x30	; 48
    425c:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    425e:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    4262:	e4 e6       	ldi	r30, 0x64	; 100
    4264:	f0 e0       	ldi	r31, 0x00	; 0
    4266:	80 81       	ld	r24, Z
    4268:	80 61       	ori	r24, 0x10	; 16
    426a:	80 83       	st	Z, r24
    426c:	08 95       	ret

0000426e <InitSdInterface>:
// Because the command sequence which initializes the SD card needs CS to be high (CMD is what the card thinks, SPI not yet active) we exit with CS high.
// SD cards prefer SPI mode 0, although they can apparently work OK in mode 3.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    426e:	e4 e6       	ldi	r30, 0x64	; 100
    4270:	f0 e0       	ldi	r31, 0x00	; 0
    4272:	80 81       	ld	r24, Z
    4274:	8f 7e       	andi	r24, 0xEF	; 239
    4276:	80 83       	st	Z, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    4278:	ec ec       	ldi	r30, 0xCC	; 204
    427a:	f0 e0       	ldi	r31, 0x00	; 0
    427c:	11 82       	std	Z+1, r1	; 0x01
    427e:	10 82       	st	Z, r1
	DDRD|=(Om_SD_CLK);					// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    4280:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10));	// Set the USART to MPSIM mode, SPI mode 0, MSB first.
    4282:	80 ec       	ldi	r24, 0xC0	; 192
    4284:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    4288:	88 e1       	ldi	r24, 0x18	; 24
    428a:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    428e:	81 e0       	ldi	r24, 0x01	; 1
    4290:	90 e0       	ldi	r25, 0x00	; 0
    4292:	91 83       	std	Z+1, r25	; 0x01
    4294:	80 83       	st	Z, r24
//	UBRR1=99;							// 100kHz clock for testing

	DDRD|=Om_SD_CS;			// CS pin to output.
    4296:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_SD_CS;		// And start with CS high.
    4298:	5d 9a       	sbi	0x0b, 5	; 11
    429a:	08 95       	ret

0000429c <EndSdTransfer>:
//-----------------------------------------------------------------------

void EndSdTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    429c:	5d 9a       	sbi	0x0b, 5	; 11
    429e:	08 95       	ret

000042a0 <StartSdTransfer>:

void StartSdTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_SD_CS;				// Make sure the CS (SS) line is high.
    42a0:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_SD_CS;				// Then bring it low.
    42a2:	5d 98       	cbi	0x0b, 5	; 11
    42a4:	08 95       	ret

000042a6 <TransferSdByte>:
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    42a6:	90 91 c8 00 	lds	r25, 0x00C8
    42aa:	95 ff       	sbrs	r25, 5
    42ac:	fc cf       	rjmp	.-8      	; 0x42a6 <TransferSdByte>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    42ae:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    42b2:	80 91 c8 00 	lds	r24, 0x00C8
    42b6:	87 ff       	sbrs	r24, 7
    42b8:	fc cf       	rjmp	.-8      	; 0x42b2 <TransferSdByte+0xc>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    42ba:	80 91 ce 00 	lds	r24, 0x00CE
}
    42be:	08 95       	ret

000042c0 <SendDummyByte>:

static void SendDummyByte(void)
// Needed to sync the card in some weird cases
{
	UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    42c0:	80 91 c8 00 	lds	r24, 0x00C8
    42c4:	80 64       	ori	r24, 0x40	; 64
    42c6:	80 93 c8 00 	sts	0x00C8, r24
	TransferSdByte(0xFF);	
    42ca:	8f ef       	ldi	r24, 0xFF	; 255
    42cc:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    42d0:	80 91 c8 00 	lds	r24, 0x00C8
    42d4:	86 ff       	sbrs	r24, 6
    42d6:	fc cf       	rjmp	.-8      	; 0x42d0 <SendDummyByte+0x10>
		;
}
    42d8:	08 95       	ret

000042da <SendSdCommand>:
unsigned char SendSdCommand(unsigned char cmdIndex,unsigned long argument)
// Sends out your standard 6-byte SD command.  Uses the passed index and argument.
// Will append CRC when necessary or leave it blank if not.
// This function will always assert CS, since it's needed to give a command, however frequently it is necessary to leave CS low for a transfer, so the function exits with CS still asserted.
// That means the caller must remember to bring it high again when they're done.
{
    42da:	df 92       	push	r13
    42dc:	ef 92       	push	r14
    42de:	ff 92       	push	r15
    42e0:	0f 93       	push	r16
    42e2:	1f 93       	push	r17
    42e4:	cf 93       	push	r28
    42e6:	df 93       	push	r29
    42e8:	c8 2f       	mov	r28, r24
    42ea:	04 2f       	mov	r16, r20
    42ec:	f5 2e       	mov	r15, r21
    42ee:	e6 2e       	mov	r14, r22
    42f0:	d7 2e       	mov	r13, r23
	unsigned char
		i,
		response,
		tmpCrc;

	StartSdTransfer();		// Assert CS
    42f2:	0e 94 50 21 	call	0x42a0	; 0x42a0 <StartSdTransfer>
	TransferSdByte(0xFF);	// Initial pad to make sure card is in the correct state for the command.
    42f6:	8f ef       	ldi	r24, 0xFF	; 255
    42f8:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>

	if(cmdIndex&0x80)	// We mark an ACMD with a 1 in bit 7 (no commands have this; the start bit is always zero).  Therefor this is an ACMD, so send CMD55 first
    42fc:	c7 ff       	sbrs	r28, 7
    42fe:	31 c0       	rjmp	.+98     	; 0x4362 <SendSdCommand+0x88>
	{
		TransferSdByte(0x40|CMD55);		// Put the start and transmission bits on the front of the command index
    4300:	87 e7       	ldi	r24, 0x77	; 119
    4302:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4306:	80 e0       	ldi	r24, 0x00	; 0
    4308:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    430c:	80 e0       	ldi	r24, 0x00	; 0
    430e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		TransferSdByte(0);				// No argument			
    4312:	80 e0       	ldi	r24, 0x00	; 0
    4314:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		TransferSdByte(0);				// No argument					
    4318:	80 e0       	ldi	r24, 0x00	; 0
    431a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		TransferSdByte(0x01);			// Send the CRC7 byte (and stop bit)
    431e:	81 e0       	ldi	r24, 0x01	; 1
    4320:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4324:	1a e0       	ldi	r17, 0x0A	; 10

		i=10;		// Give the SD card a 10 byte timeout in which to respond.
		do			
		{
			response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    4326:	8f ef       	ldi	r24, 0xFF	; 255
    4328:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    432c:	d8 2f       	mov	r29, r24
		}
		while((response==0xFF)&&--i);		// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.		
    432e:	8f 3f       	cpi	r24, 0xFF	; 255
    4330:	11 f4       	brne	.+4      	; 0x4336 <SendSdCommand+0x5c>
    4332:	11 50       	subi	r17, 0x01	; 1
    4334:	c1 f7       	brne	.-16     	; 0x4326 <SendSdCommand+0x4c>

		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4336:	90 91 c8 00 	lds	r25, 0x00C8
    433a:	90 64       	ori	r25, 0x40	; 64
    433c:	90 93 c8 00 	sts	0x00C8, r25
		TransferSdByte(0xFF);		//	@@@ -- SOME CARDS NEED THIS.  See notes.
    4340:	8f ef       	ldi	r24, 0xFF	; 255
    4342:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
		while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4346:	80 91 c8 00 	lds	r24, 0x00C8
    434a:	86 ff       	sbrs	r24, 6
    434c:	fc cf       	rjmp	.-8      	; 0x4346 <SendSdCommand+0x6c>
			;

		if(response>1)				// Something wrong?
    434e:	d2 30       	cpi	r29, 0x02	; 2
    4350:	18 f0       	brcs	.+6      	; 0x4358 <SendSdCommand+0x7e>
		{
			EndSdTransfer();	// Bring CS high
    4352:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
			return(response);	// ACMD preambe returned something weird.  Bail.
    4356:	34 c0       	rjmp	.+104    	; 0x43c0 <SendSdCommand+0xe6>
		}

		EndSdTransfer();	// Bring CS high
    4358:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
		cmdIndex&=0x7F;		// Handled ACMD, so get rid of leading marker bit
    435c:	cf 77       	andi	r28, 0x7F	; 127
		StartSdTransfer();	// Assert CS
    435e:	0e 94 50 21 	call	0x42a0	; 0x42a0 <StartSdTransfer>
	}

	// Handled beginning an "application specific" command above, so do proper part of command now (commands are from 0-63)
		
	TransferSdByte(0x40|cmdIndex);						// Put the start and transmission bits on the front of the command index
    4362:	8c 2f       	mov	r24, r28
    4364:	80 64       	ori	r24, 0x40	; 64
    4366:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
    436a:	8d 2d       	mov	r24, r13
    436c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
    4370:	8e 2d       	mov	r24, r14
    4372:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
    4376:	8f 2d       	mov	r24, r15
    4378:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	TransferSdByte((unsigned char)argument);			// LSB of argument
    437c:	80 2f       	mov	r24, r16
    437e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
    4382:	cc 23       	and	r28, r28
    4384:	21 f0       	breq	.+8      	; 0x438e <SendSdCommand+0xb4>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
    4386:	c8 30       	cpi	r28, 0x08	; 8
    4388:	21 f0       	breq	.+8      	; 0x4392 <SendSdCommand+0xb8>
	TransferSdByte((unsigned char)(argument>>24));		// MSB of argument
	TransferSdByte((unsigned char)(argument>>16));		// next byte of argument
	TransferSdByte((unsigned char)(argument>>8));		// next byte of argument
	TransferSdByte((unsigned char)argument);			// LSB of argument
	
	tmpCrc=0x01;		// Fake CRC with stop bit (most cases)
    438a:	81 e0       	ldi	r24, 0x01	; 1
    438c:	03 c0       	rjmp	.+6      	; 0x4394 <SendSdCommand+0xba>

	if(cmdIndex==CMD0)	// except here where we actually need a real CRC
	{
		tmpCrc=0x95;
    438e:	85 e9       	ldi	r24, 0x95	; 149
    4390:	01 c0       	rjmp	.+2      	; 0x4394 <SendSdCommand+0xba>
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    4392:	87 e8       	ldi	r24, 0x87	; 135
	}
	
	TransferSdByte(tmpCrc);		// Send the CRC7 byte
    4394:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	
	// Now handle a response.
	
	if(cmdIndex==CMD12)	// This is a stop transmission command -- one byte of padding comes in before the real response.
    4398:	cc 30       	cpi	r28, 0x0C	; 12
    439a:	19 f4       	brne	.+6      	; 0x43a2 <SendSdCommand+0xc8>
	{
		TransferSdByte(DUMMY_BYTE);		// Skip "stuff byte".
    439c:	8f ef       	ldi	r24, 0xFF	; 255
    439e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
	{
		tmpCrc=0x95;
	}
	if(cmdIndex==CMD8)	// and here where we actually need a real CRC
	{
		tmpCrc=0x87;
    43a2:	1a e0       	ldi	r17, 0x0A	; 10
	
	i=10;		// Give the SD card a 10 byte timeout in which to respond.
	
	do			
	{
		response=TransferSdByte(DUMMY_BYTE);		// Get response byte
    43a4:	8f ef       	ldi	r24, 0xFF	; 255
    43a6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    43aa:	d8 2f       	mov	r29, r24
	}
	while((response==0xFF)&&--i);				// A valid response has a leading zero.  Wait for that or for 10 bytes to pass.
    43ac:	8f 3f       	cpi	r24, 0xFF	; 255
    43ae:	11 f4       	brne	.+4      	; 0x43b4 <SendSdCommand+0xda>
    43b0:	11 50       	subi	r17, 0x01	; 1
    43b2:	c1 f7       	brne	.-16     	; 0x43a4 <SendSdCommand+0xca>

// If we're not a command which has a multi-byte response, put in an extra 0xFF here.
	if(cmdIndex!=CMD8&&cmdIndex!=CMD58)		// Add post-command padding.  We add this pad byte manually to commands with a longer-than-one-byte response.
    43b4:	c8 30       	cpi	r28, 0x08	; 8
    43b6:	21 f0       	breq	.+8      	; 0x43c0 <SendSdCommand+0xe6>
    43b8:	ca 33       	cpi	r28, 0x3A	; 58
    43ba:	11 f0       	breq	.+4      	; 0x43c0 <SendSdCommand+0xe6>
	{
		SendDummyByte();	
    43bc:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
	}

	return(response);		// Will be 0xFF if we timed out.  This should almost always be 0 or 1.
}
    43c0:	8d 2f       	mov	r24, r29
    43c2:	df 91       	pop	r29
    43c4:	cf 91       	pop	r28
    43c6:	1f 91       	pop	r17
    43c8:	0f 91       	pop	r16
    43ca:	ff 90       	pop	r15
    43cc:	ef 90       	pop	r14
    43ce:	df 90       	pop	r13
    43d0:	08 95       	ret

000043d2 <SdHandshake>:
// Tries to talk to the inserted SD card and set up an SPI interface.
// Since this is a micro SD slot, we don't need to support MMC cards (they wouldn't fit in the slot).
// We also do not support SDHC, since it costs more, we have orders of magnitude more storage than necessary as is, and the interface is a BIT different.  Could fix this if people whine.
// Returns true if we successfully initialize the all the stuff we need to do to talk to the card.
// NOTE -- this process takes time, and will hang operation for hundreds of milliseconds on a successful call.
{
    43d2:	ef 92       	push	r14
    43d4:	ff 92       	push	r15
    43d6:	0f 93       	push	r16
    43d8:	1f 93       	push	r17
    43da:	cf 93       	push	r28
    43dc:	df 93       	push	r29
    43de:	00 d0       	rcall	.+0      	; 0x43e0 <SdHandshake+0xe>
    43e0:	00 d0       	rcall	.+0      	; 0x43e2 <SdHandshake+0x10>
    43e2:	1f 92       	push	r1
    43e4:	cd b7       	in	r28, 0x3d	; 61
    43e6:	de b7       	in	r29, 0x3e	; 62
	bool
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
    43e8:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
    43ec:	14 e1       	ldi	r17, 0x14	; 20
	for(i=0;i<20;i++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    43ee:	80 91 c8 00 	lds	r24, 0x00C8
    43f2:	80 64       	ori	r24, 0x40	; 64
    43f4:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
    43f8:	8f ef       	ldi	r24, 0xFF	; 255
    43fa:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    43fe:	11 50       	subi	r17, 0x01	; 1
		cardValid;	// Is this a micro SD card or some random bit of plastic and silicon?

	// Card starts in SD mode, and needs a bunch of clocks (74 at least) to reach "idle" state.  CS must be high.  ChaN suggest MOSI stays high too which makes sense.

	EndSdTransfer();	// Bring CS high
	for(i=0;i<20;i++)
    4400:	b1 f7       	brne	.-20     	; 0x43ee <SdHandshake+0x1c>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(DUMMY_BYTE);	// Transfer ten dummy bytes (80 clocks).
	}	
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4402:	80 91 c8 00 	lds	r24, 0x00C8
    4406:	86 ff       	sbrs	r24, 6
    4408:	fc cf       	rjmp	.-8      	; 0x4402 <SdHandshake+0x30>


	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
    440a:	0e 94 50 21 	call	0x42a0	; 0x42a0 <StartSdTransfer>
    440e:	00 e0       	ldi	r16, 0x00	; 0
    4410:	12 e0       	ldi	r17, 0x02	; 2
	for(n=0;n<SD_BLOCK_LENGTH;n++)
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
    4412:	80 91 c8 00 	lds	r24, 0x00C8
    4416:	80 64       	ori	r24, 0x40	; 64
    4418:	80 93 c8 00 	sts	0x00C8, r24
		TransferSdByte(0xFF);	
    441c:	8f ef       	ldi	r24, 0xFF	; 255
    441e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4422:	01 50       	subi	r16, 0x01	; 1
    4424:	11 09       	sbc	r17, r1

	// Jacked from SD Fat lib, which suggests doing the following to prevent "re-init hang from cards in partial read".  Makes sense.
	// Thu Jul 28 14:15:53 EDT 2011	-- Totally just experienced this hang, and understand this now.

	StartSdTransfer();						
	for(n=0;n<SD_BLOCK_LENGTH;n++)
    4426:	a9 f7       	brne	.-22     	; 0x4412 <SdHandshake+0x40>
	{
		UCSR1A|=(1<<TXC1);			// Clear transmit complete flag
		TransferSdByte(0xFF);	
	}
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4428:	80 91 c8 00 	lds	r24, 0x00C8
    442c:	86 ff       	sbrs	r24, 6
    442e:	fc cf       	rjmp	.-8      	; 0x4428 <SdHandshake+0x56>
		;
	EndSdTransfer();
    4430:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
	SendSdCommand(CMD0,0);		// Send first time for good measure, also to make sure onboard pullups get to where they need to be.
    4434:	40 e0       	ldi	r20, 0x00	; 0
    4436:	50 e0       	ldi	r21, 0x00	; 0
    4438:	ba 01       	movw	r22, r20
    443a:	80 e0       	ldi	r24, 0x00	; 0
    443c:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4440:	80 91 c8 00 	lds	r24, 0x00C8
    4444:	86 ff       	sbrs	r24, 6
    4446:	fc cf       	rjmp	.-8      	; 0x4440 <SdHandshake+0x6e>
		;
	EndSdTransfer();
    4448:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
    444c:	40 e0       	ldi	r20, 0x00	; 0
    444e:	50 e0       	ldi	r21, 0x00	; 0
    4450:	ba 01       	movw	r22, r20
    4452:	80 e0       	ldi	r24, 0x00	; 0
    4454:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    4458:	81 30       	cpi	r24, 0x01	; 1
    445a:	11 f0       	breq	.+4      	; 0x4460 <SdHandshake+0x8e>
	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
		;
	EndSdTransfer();

	// Should be in "idle mode" now.  Set SPI mode by asserting the CS and sending CMD 0.
	cardValid=false;			// Card not valid until we say it is.	
    445c:	80 e0       	ldi	r24, 0x00	; 0
    445e:	b1 c0       	rjmp	.+354    	; 0x45c2 <SdHandshake+0x1f0>
	EndSdTransfer();

	// Send CMD0 again, actually check response now.
	if(SendSdCommand(CMD0,0)==0x01)		// Tell card to enter idle state.  If we get the right response, keep going.
	{
		EndSdTransfer();					// Bring CS high
    4460:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
    4464:	4a ea       	ldi	r20, 0xAA	; 170
    4466:	51 e0       	ldi	r21, 0x01	; 1
    4468:	60 e0       	ldi	r22, 0x00	; 0
    446a:	70 e0       	ldi	r23, 0x00	; 0
    446c:	88 e0       	ldi	r24, 0x08	; 8
    446e:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    4472:	81 30       	cpi	r24, 0x01	; 1
    4474:	09 f0       	breq	.+2      	; 0x4478 <SdHandshake+0xa6>
    4476:	6e c0       	rjmp	.+220    	; 0x4554 <SdHandshake+0x182>
    4478:	8e 01       	movw	r16, r28
    447a:	0f 5f       	subi	r16, 0xFF	; 255
    447c:	1f 4f       	sbci	r17, 0xFF	; 255
//-----------------------------------------------------------------------
// SD SPI Mode and Initialization Functions
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

bool SdHandshake(void)
    447e:	7e 01       	movw	r14, r28
    4480:	85 e0       	ldi	r24, 0x05	; 5
    4482:	e8 0e       	add	r14, r24
    4484:	f1 1c       	adc	r15, r1

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    4486:	8f ef       	ldi	r24, 0xFF	; 255
    4488:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    448c:	f8 01       	movw	r30, r16
    448e:	81 93       	st	Z+, r24
    4490:	8f 01       	movw	r16, r30
	{
		EndSdTransfer();					// Bring CS high

		if(SendSdCommand(CMD8,0x1AA)==1)	// Check card voltage.  This is only supported in SDC v2, so we're either a v2 standard density card or an SDHC card
		{
			for(i=0;i<4;i++)						// This is an "R7" response, so we need to grab four more bytes.
    4492:	ee 15       	cp	r30, r14
    4494:	ff 05       	cpc	r31, r15
    4496:	b9 f7       	brne	.-18     	; 0x4486 <SdHandshake+0xb4>
			{
				ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
			}

			SendDummyByte();		// Send extra FF after multibyte response. 
    4498:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
			EndSdTransfer();		// Bring CS high
    449c:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
    44a0:	8b 81       	ldd	r24, Y+3	; 0x03
    44a2:	81 30       	cpi	r24, 0x01	; 1
    44a4:	d9 f6       	brne	.-74     	; 0x445c <SdHandshake+0x8a>
    44a6:	8c 81       	ldd	r24, Y+4	; 0x04
    44a8:	8a 3a       	cpi	r24, 0xAA	; 170
    44aa:	c1 f6       	brne	.-80     	; 0x445c <SdHandshake+0x8a>
			{				
				SetTimer(TIMER_SD,SECOND);
    44ac:	64 ec       	ldi	r22, 0xC4	; 196
    44ae:	74 e0       	ldi	r23, 0x04	; 4
    44b0:	83 e0       	ldi	r24, 0x03	; 3
    44b2:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    44b6:	04 c0       	rjmp	.+8      	; 0x44c0 <SdHandshake+0xee>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    44b8:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
    44bc:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <HandleSoftclock>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    44c0:	83 e0       	ldi	r24, 0x03	; 3
    44c2:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    44c6:	88 23       	and	r24, r24
    44c8:	31 f0       	breq	.+12     	; 0x44d6 <SdHandshake+0x104>
				{
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
    44ca:	83 e0       	ldi	r24, 0x03	; 3
    44cc:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    44d0:	88 23       	and	r24, r24
    44d2:	81 f0       	breq	.+32     	; 0x44f4 <SdHandshake+0x122>
    44d4:	c3 cf       	rjmp	.-122    	; 0x445c <SdHandshake+0x8a>

			if(ocr[2] == 0x01 && ocr[3] == 0xAA)	// The card can work at vdd range of 2.7-3.6V (bail if it can't)
			{				
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go (0 is the result once the card is done initializing, takes a long time (we give it a second per the SD spec))
    44d6:	40 e0       	ldi	r20, 0x00	; 0
    44d8:	50 e0       	ldi	r21, 0x00	; 0
    44da:	ba 01       	movw	r22, r20
    44dc:	89 ea       	ldi	r24, 0xA9	; 169
    44de:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    44e2:	81 11       	cpse	r24, r1
    44e4:	e9 cf       	rjmp	.-46     	; 0x44b8 <SdHandshake+0xe6>
    44e6:	f1 cf       	rjmp	.-30     	; 0x44ca <SdHandshake+0xf8>
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
					{
						SendDummyByte();		// Send extra FF (it's busy)
    44e8:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
						HandleSoftclock();	// Keep the timer timing.
    44ec:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <HandleSoftclock>
						EndSdTransfer();		// Bring CS high.
    44f0:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    44f4:	83 e0       	ldi	r24, 0x03	; 3
    44f6:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    44fa:	88 23       	and	r24, r24
    44fc:	31 f0       	breq	.+12     	; 0x450a <SdHandshake+0x138>
					{
						SendDummyByte();		// Send extra FF (it's busy)
						HandleSoftclock();	// Keep the timer timing.
						EndSdTransfer();		// Bring CS high.
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
    44fe:	83 e0       	ldi	r24, 0x03	; 3
    4500:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4504:	88 23       	and	r24, r24
    4506:	51 f0       	breq	.+20     	; 0x451c <SdHandshake+0x14a>
    4508:	a9 cf       	rjmp	.-174    	; 0x445c <SdHandshake+0x8a>
					HandleSoftclock();	// Keep the timer timing.
				}		
				
				if(!(CheckTimer(TIMER_SD)))		// Initialized! (didn't time out)
				{
					while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(CMD58,0)!=0))	// Read card capacity -- I think we might need to do this even though we throw out the results.
    450a:	40 e0       	ldi	r20, 0x00	; 0
    450c:	50 e0       	ldi	r21, 0x00	; 0
    450e:	ba 01       	movw	r22, r20
    4510:	8a e3       	ldi	r24, 0x3A	; 58
    4512:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    4516:	81 11       	cpse	r24, r1
    4518:	e7 cf       	rjmp	.-50     	; 0x44e8 <SdHandshake+0x116>
    451a:	f1 cf       	rjmp	.-30     	; 0x44fe <SdHandshake+0x12c>
					}
					if(!(CheckTimer(TIMER_SD)))		// Didn't time out.
					{
						for(i=0;i<4;i++)						// This is an "R3" response, so we need to grab four more bytes.
						{
							ocr[i]=TransferSdByte(DUMMY_BYTE);	// Inhale OCR bytes
    451c:	8f ef       	ldi	r24, 0xFF	; 255
    451e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4522:	8f ef       	ldi	r24, 0xFF	; 255
    4524:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4528:	8f ef       	ldi	r24, 0xFF	; 255
    452a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    452e:	8f ef       	ldi	r24, 0xFF	; 255
    4530:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
						}

						SendDummyByte();			// Send extra FF after multibyte response. 
    4534:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
						EndSdTransfer();			// Bring CS high.
    4538:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>

						SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    453c:	40 e0       	ldi	r20, 0x00	; 0
    453e:	52 e0       	ldi	r21, 0x02	; 2
    4540:	60 e0       	ldi	r22, 0x00	; 0
    4542:	70 e0       	ldi	r23, 0x00	; 0
    4544:	80 e1       	ldi	r24, 0x10	; 16
    4546:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
						EndSdTransfer();						// Bring CS high.
    454a:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
						SendDummyByte();						
    454e:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
    4552:	36 c0       	rjmp	.+108    	; 0x45c0 <SdHandshake+0x1ee>
				}
			}
		}
		else	// We're either an SDC v1 card or an MMC.  SDC v1 is OK.
		{
			SendDummyByte();					// Send extra FF after multibyte response. 
    4554:	0e 94 60 21 	call	0x42c0	; 0x42c0 <SendDummyByte>
			EndSdTransfer();					// Bring CS high
    4558:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
    455c:	40 e0       	ldi	r20, 0x00	; 0
    455e:	50 e0       	ldi	r21, 0x00	; 0
    4560:	ba 01       	movw	r22, r20
    4562:	89 ea       	ldi	r24, 0xA9	; 169
    4564:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    4568:	82 30       	cpi	r24, 0x02	; 2
    456a:	08 f0       	brcs	.+2      	; 0x456e <SdHandshake+0x19c>
    456c:	77 cf       	rjmp	.-274    	; 0x445c <SdHandshake+0x8a>
			{
				EndSdTransfer();			// Bring CS high.
    456e:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
				SetTimer(TIMER_SD,SECOND);
    4572:	64 ec       	ldi	r22, 0xC4	; 196
    4574:	74 e0       	ldi	r23, 0x04	; 4
    4576:	83 e0       	ldi	r24, 0x03	; 3
    4578:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    457c:	04 c0       	rjmp	.+8      	; 0x4586 <SdHandshake+0x1b4>
				{
					HandleSoftclock();	// Keep the timer timing.
    457e:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <HandleSoftclock>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
    4582:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    4586:	83 e0       	ldi	r24, 0x03	; 3
    4588:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    458c:	88 23       	and	r24, r24
    458e:	31 f0       	breq	.+12     	; 0x459c <SdHandshake+0x1ca>
				{
					HandleSoftclock();	// Keep the timer timing.
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
    4590:	83 e0       	ldi	r24, 0x03	; 3
    4592:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4596:	81 11       	cpse	r24, r1
    4598:	61 cf       	rjmp	.-318    	; 0x445c <SdHandshake+0x8a>
    459a:	09 c0       	rjmp	.+18     	; 0x45ae <SdHandshake+0x1dc>
			if(SendSdCommand(ACMD41,0)<=1)		// If we don't get an error trying to initialize the SD card, keep going (MMC will bail)	
			{
				EndSdTransfer();			// Bring CS high.
				SetTimer(TIMER_SD,SECOND);

				while((!(CheckTimer(TIMER_SD)))&&(SendSdCommand(ACMD41,0)!=0))	// Initialize card, disable high capacity.  If this returns 0, we're good to go 
    459c:	40 e0       	ldi	r20, 0x00	; 0
    459e:	50 e0       	ldi	r21, 0x00	; 0
    45a0:	ba 01       	movw	r22, r20
    45a2:	89 ea       	ldi	r24, 0xA9	; 169
    45a4:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    45a8:	81 11       	cpse	r24, r1
    45aa:	e9 cf       	rjmp	.-46     	; 0x457e <SdHandshake+0x1ac>
    45ac:	f1 cf       	rjmp	.-30     	; 0x4590 <SdHandshake+0x1be>
					EndSdTransfer();	// Bring CS high. NOTE -- Sending an ACMD41 with the HCS bit set will tell the card we're cool with HIGH CAPACITY SD cards.  If we don't set this bit, and we're talking to an SDHC card, the card will always return busy.  This is what we want.
				}		

				if(!(CheckTimer(TIMER_SD)))		// Initialized!
				{
					SendSdCommand(CMD16,SD_BLOCK_LENGTH);	// Set block length to 512.
    45ae:	40 e0       	ldi	r20, 0x00	; 0
    45b0:	52 e0       	ldi	r21, 0x02	; 2
    45b2:	60 e0       	ldi	r22, 0x00	; 0
    45b4:	70 e0       	ldi	r23, 0x00	; 0
    45b6:	80 e1       	ldi	r24, 0x10	; 16
    45b8:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
					EndSdTransfer();						// Bring CS high.
    45bc:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					cardValid=true;							// SDC v1 card, good to go
    45c0:	81 e0       	ldi	r24, 0x01	; 1
				}
			}
		}
	}

	EndSdTransfer();	// Bring CS high
    45c2:	8d 83       	std	Y+5, r24	; 0x05
    45c4:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
	return(cardValid);	// Report success or failure of initialization -- fails on timeout or bad response.  Bad response is an invalid card or no card, timeout means card didn't initialize (which might mean it's high capacity).
}
    45c8:	8d 81       	ldd	r24, Y+5	; 0x05
    45ca:	0f 90       	pop	r0
    45cc:	0f 90       	pop	r0
    45ce:	0f 90       	pop	r0
    45d0:	0f 90       	pop	r0
    45d2:	0f 90       	pop	r0
    45d4:	df 91       	pop	r29
    45d6:	cf 91       	pop	r28
    45d8:	1f 91       	pop	r17
    45da:	0f 91       	pop	r16
    45dc:	ff 90       	pop	r15
    45de:	ef 90       	pop	r14
    45e0:	08 95       	ret

000045e2 <SdBeginSingleBlockRead>:
// Send the command.  Get the response from the SD card (no errors)
// SD card waits some number of bytes with DATA OUT high, then the SD card sends the data token (0xFE) followed by the block, followed by a 2-byte CRC which we throw out.
// NOTE -- per the SD spec, this delay before timeout can be as long as 100mSec worst case.  If (TAAC + NSAC) are less, then that sum is the worst case.  A qucik troll on the internet shows the slowest cards people polled at 40mS, some at 5, 1.5, or 1mSec, and a lot at 500uSec.
// These are all based on TAAC and not NSAC (which always seems to be 0).
// Either way, best to open with this command, then do your polling for the data token somewhere else since it could be a lot of time.  If we were ballers we would check the access speeds...
{
    45e2:	ab 01       	movw	r20, r22
    45e4:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    45e6:	89 e0       	ldi	r24, 0x09	; 9
    45e8:	44 0f       	add	r20, r20
    45ea:	55 1f       	adc	r21, r21
    45ec:	66 1f       	adc	r22, r22
    45ee:	77 1f       	adc	r23, r23
    45f0:	8a 95       	dec	r24
    45f2:	d1 f7       	brne	.-12     	; 0x45e8 <SdBeginSingleBlockRead+0x6>

	if(SendSdCommand(CMD17,theBlock)==0)	// If we send the command and get the correct response...
    45f4:	81 e1       	ldi	r24, 0x11	; 17
    45f6:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    45fa:	91 e0       	ldi	r25, 0x01	; 1
    45fc:	81 11       	cpse	r24, r1
    45fe:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    4600:	89 2f       	mov	r24, r25
    4602:	08 95       	ret

00004604 <SdBeginSingleBlockWrite>:

bool SdBeginSingleBlockWrite(unsigned long theBlock)
// Opens up the SD card for a single block write, starting at the beginning of the passed block.
// Returns false if something goes wrong.  Otherwise, we exit ready to write bytes to the block.
{
    4604:	ab 01       	movw	r20, r22
    4606:	bc 01       	movw	r22, r24
	theBlock*=SD_BLOCK_LENGTH;		// SDSC cards want read addresses in bytes, not blocks, so translate the block addy into the byte addy
    4608:	99 e0       	ldi	r25, 0x09	; 9
    460a:	44 0f       	add	r20, r20
    460c:	55 1f       	adc	r21, r21
    460e:	66 1f       	adc	r22, r22
    4610:	77 1f       	adc	r23, r23
    4612:	9a 95       	dec	r25
    4614:	d1 f7       	brne	.-12     	; 0x460a <SdBeginSingleBlockWrite+0x6>

	if(SendSdCommand(CMD24,theBlock)==0)	// If we send the command and get the correct response...
    4616:	88 e1       	ldi	r24, 0x18	; 24
    4618:	0e 94 6d 21 	call	0x42da	; 0x42da <SendSdCommand>
    461c:	91 e0       	ldi	r25, 0x01	; 1
    461e:	81 11       	cpse	r24, r1
    4620:	90 e0       	ldi	r25, 0x00	; 0
	}
	else
	{
		return(false);
	}
}
    4622:	89 2f       	mov	r24, r25
    4624:	08 95       	ret

00004626 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    4626:	cf 93       	push	r28
    4628:	df 93       	push	r29
    462a:	cd b7       	in	r28, 0x3d	; 61
    462c:	de b7       	in	r29, 0x3e	; 62
    462e:	28 97       	sbiw	r28, 0x08	; 8
    4630:	0f b6       	in	r0, 0x3f	; 63
    4632:	f8 94       	cli
    4634:	de bf       	out	0x3e, r29	; 62
    4636:	0f be       	out	0x3f, r0	; 63
    4638:	cd bf       	out	0x3d, r28	; 61
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    463a:	1f ef       	ldi	r17, 0xFF	; 255
    463c:	10 93 64 00 	sts	0x0064, r17
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    4640:	85 b7       	in	r24, 0x35	; 53
    4642:	8f 7e       	andi	r24, 0xEF	; 239
    4644:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    4646:	8f ee       	ldi	r24, 0xEF	; 239
    4648:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    464a:	88 e0       	ldi	r24, 0x08	; 8
    464c:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    464e:	80 e8       	ldi	r24, 0x80	; 128
    4650:	8a b9       	out	0x0a, r24	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    4652:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    4654:	96 e0       	ldi	r25, 0x06	; 6
    4656:	92 b9       	out	0x02, r25	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    4658:	9e e3       	ldi	r25, 0x3E	; 62
    465a:	91 b9       	out	0x01, r25	; 1

	DDRB=0xFF;			// Latch port to OP.
    465c:	14 b9       	out	0x04, r17	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    465e:	85 b9       	out	0x05, r24	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    4660:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    4662:	14 b9       	out	0x04, r17	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    4664:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    4666:	15 98       	cbi	0x02, 5	; 2

	InitSdInterface();		// Turn on SD hardware
    4668:	0e 94 37 21 	call	0x426e	; 0x426e <InitSdInterface>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    466c:	66 e2       	ldi	r22, 0x26	; 38
    466e:	70 e0       	ldi	r23, 0x00	; 0
    4670:	81 e0       	ldi	r24, 0x01	; 1
    4672:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>

	DDRC&=~Im_CARD_DETECT;	// Card detect pin to input.
    4676:	3d 98       	cbi	0x07, 5	; 7
	PORTC|=Im_CARD_DETECT;	// Pull it up.
    4678:	45 9a       	sbi	0x08, 5	; 8
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    467a:	80 b1       	in	r24, 0x00	; 0
    467c:	80 7c       	andi	r24, 0xC0	; 192
    467e:	80 93 bb 05 	sts	0x05BB, r24
	encoderValue=0;							// zero our relative position.
    4682:	10 92 6d 05 	sts	0x056D, r1
	newEncoder=false;
    4686:	10 92 6b 05 	sts	0x056B, r1
	encoderCw=false;
    468a:	10 92 af 05 	sts	0x05AF, r1
	encoderCcw=false;
    468e:	10 92 b0 05 	sts	0x05B0, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    4692:	10 92 5d 05 	sts	0x055D, r1
	ledBlinkMask=0;
    4696:	10 92 ae 05 	sts	0x05AE, r1
	WriteLedLatch(0);	// ...send the LED value to the latch.
    469a:	80 e0       	ldi	r24, 0x00	; 0
    469c:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>

	InitSdInterface();		// Turn on SD hardware
	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    46a0:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <InitMidi>
	InitUart0();
    46a4:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    46a8:	80 91 64 00 	lds	r24, 0x0064
    46ac:	8e 7f       	andi	r24, 0xFE	; 254
    46ae:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    46b2:	80 e6       	ldi	r24, 0x60	; 96
    46b4:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    46b8:	81 e0       	ldi	r24, 0x01	; 1
    46ba:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    46be:	85 e9       	ldi	r24, 0x95	; 149
    46c0:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    46c4:	80 91 7a 00 	lds	r24, 0x007A
    46c8:	80 64       	ori	r24, 0x40	; 64
    46ca:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    46ce:	80 91 64 00 	lds	r24, 0x0064
    46d2:	8f 7d       	andi	r24, 0xDF	; 223
    46d4:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    46d8:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    46dc:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    46de:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    46e0:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    46e2:	10 92 2e 06 	sts	0x062E, r1
    46e6:	10 92 2d 06 	sts	0x062D, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    46ea:	83 e0       	ldi	r24, 0x03	; 3
    46ec:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    46ee:	80 91 64 00 	lds	r24, 0x0064
    46f2:	87 7f       	andi	r24, 0xF7	; 247
    46f4:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    46f8:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    46fc:	8f ef       	ldi	r24, 0xFF	; 255
    46fe:	9f ef       	ldi	r25, 0xFF	; 255
    4700:	90 93 89 00 	sts	0x0089, r25
    4704:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    4708:	90 93 8b 00 	sts	0x008B, r25
    470c:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    4710:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    4714:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    4718:	10 92 85 00 	sts	0x0085, r1
    471c:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    4720:	16 bb       	out	0x16, r17	; 22
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.

	newKeys=0;
    4722:	10 92 57 05 	sts	0x0557, r1
	keyState=0;
    4726:	10 92 58 05 	sts	0x0558, r1
	cardState=SD_NOT_PRESENT;	// No card yet
    472a:	10 92 59 05 	sts	0x0559, r1
	cardDetect=false;
    472e:	10 92 5a 05 	sts	0x055A, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    4732:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4734:	84 e9       	ldi	r24, 0x94	; 148
    4736:	9e e0       	ldi	r25, 0x0E	; 14
    4738:	90 93 e4 05 	sts	0x05E4, r25
    473c:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    4740:	10 92 5b 05 	sts	0x055B, r1
	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
		cli();						// Store sreg, pause interrupts.
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    4744:	aa 24       	eor	r10, r10
    4746:	aa 94       	dec	r10
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    4748:	ee 24       	eor	r14, r14
    474a:	e3 94       	inc	r14
    474c:	f1 2c       	mov	r15, r1
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    474e:	00 e0       	ldi	r16, 0x00	; 0
    4750:	12 e0       	ldi	r17, 0x02	; 2
				TransferSdByte('S');				// These four characters indicate this card holds sample data (as opposed to Nintendo DPCMs, or a boot image)
				TransferSdByte('A');
				TransferSdByte('M');
				TransferSdByte('P');

				bytesLeftInBlock-=8;
    4752:	f8 e0       	ldi	r31, 0x08	; 8
    4754:	8f 2e       	mov	r8, r31
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4756:	a7 e0       	ldi	r26, 0x07	; 7
    4758:	7a 2e       	mov	r7, r26
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
						;

					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    475a:	bb e0       	ldi	r27, 0x0B	; 11
    475c:	6b 2e       	mov	r6, r27

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    475e:	8e e0       	ldi	r24, 0x0E	; 14
    4760:	b8 2e       	mov	r11, r24
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
			{
				cardState=SD_READ_ABORT;
    4762:	9d e0       	ldi	r25, 0x0D	; 13
    4764:	99 2e       	mov	r9, r25
//-----------------------------------------------------------------------
// Program main loop.
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
    4766:	6e 01       	movw	r12, r28
    4768:	29 e0       	ldi	r18, 0x09	; 9
    476a:	c2 0e       	add	r12, r18
    476c:	d1 1c       	adc	r13, r1
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    476e:	81 e0       	ldi	r24, 0x01	; 1
    4770:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4774:	88 23       	and	r24, r24
    4776:	d9 f0       	breq	.+54     	; 0x47ae <main+0x188>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    4778:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    477a:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    477c:	a5 b8       	out	0x05, r10	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    477e:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    4780:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    4782:	00 00       	nop
		asm volatile("nop"::);
    4784:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    4786:	83 b1       	in	r24, 0x03	; 3
    4788:	80 95       	com	r24
    478a:	80 93 58 05 	sts	0x0558, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    478e:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    4790:	a4 b8       	out	0x04, r10	; 4
		SREG=sreg;					// Stop tying up interrupts
    4792:	9f bf       	out	0x3f, r25	; 63

		if(!(PINC&Im_CARD_DETECT))	// Handle SD card switch (has a real hardware pin)
    4794:	35 99       	sbic	0x06, 5	; 6
    4796:	04 c0       	rjmp	.+8      	; 0x47a0 <main+0x17a>
		{
			cardDetect=true;
    4798:	81 e0       	ldi	r24, 0x01	; 1
    479a:	80 93 5a 05 	sts	0x055A, r24
    479e:	02 c0       	rjmp	.+4      	; 0x47a4 <main+0x17e>
		}
		else
		{
			cardDetect=false;
    47a0:	10 92 5a 05 	sts	0x055A, r1
		}

		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)
    47a4:	66 e2       	ldi	r22, 0x26	; 38
    47a6:	70 e0       	ldi	r23, 0x00	; 0
    47a8:	81 e0       	ldi	r24, 0x01	; 1
    47aa:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    47ae:	90 91 58 05 	lds	r25, 0x0558
    47b2:	80 91 bc 05 	lds	r24, 0x05BC
    47b6:	80 95       	com	r24
    47b8:	89 23       	and	r24, r25
    47ba:	80 93 57 05 	sts	0x0557, r24
	keysHeld=keyState&(~newKeys);						// Separate out keys which are NOT newly pressed, but have been held for more than one debounce loop.
    47be:	80 95       	com	r24
    47c0:	89 23       	and	r24, r25
    47c2:	80 93 6a 05 	sts	0x056A, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    47c6:	90 93 bc 05 	sts	0x05BC, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;

	newEncoder=false;	// Clear variables which indicate changes in encoder readings
    47ca:	10 92 6b 05 	sts	0x056B, r1
	encoderCw=false;
    47ce:	10 92 af 05 	sts	0x05AF, r1
	encoderCcw=false;
    47d2:	10 92 b0 05 	sts	0x05B0, r1

	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    47d6:	20 91 2d 06 	lds	r18, 0x062D
    47da:	30 91 2e 06 	lds	r19, 0x062E
    47de:	80 91 bd 05 	lds	r24, 0x05BD
    47e2:	90 91 be 05 	lds	r25, 0x05BE
    47e6:	28 17       	cp	r18, r24
    47e8:	39 07       	cpc	r19, r25
    47ea:	09 f4       	brne	.+2      	; 0x47ee <main+0x1c8>
    47ec:	43 c0       	rjmp	.+134    	; 0x4874 <main+0x24e>
	{
		lastEncTime=systemTicks;					// update last read time.
    47ee:	80 91 2d 06 	lds	r24, 0x062D
    47f2:	90 91 2e 06 	lds	r25, 0x062E
    47f6:	90 93 be 05 	sts	0x05BE, r25
    47fa:	80 93 bd 05 	sts	0x05BD, r24

		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    47fe:	80 b1       	in	r24, 0x00	; 0
    4800:	80 7c       	andi	r24, 0xC0	; 192
    4802:	80 93 bb 05 	sts	0x05BB, r24

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    4806:	90 91 bf 05 	lds	r25, 0x05BF
    480a:	89 17       	cp	r24, r25
    480c:	99 f1       	breq	.+102    	; 0x4874 <main+0x24e>
		{
			if(encoderState==ENC_POS_A)
    480e:	81 11       	cpse	r24, r1
    4810:	06 c0       	rjmp	.+12     	; 0x481e <main+0x1f8>
			{
				if(lastEncoderState==ENC_POS_D)
    4812:	90 38       	cpi	r25, 0x80	; 128
    4814:	09 f4       	brne	.+2      	; 0x4818 <main+0x1f2>
    4816:	17 c0       	rjmp	.+46     	; 0x4846 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_B)
    4818:	90 34       	cpi	r25, 0x40	; 64
    481a:	51 f5       	brne	.+84     	; 0x4870 <main+0x24a>
    481c:	1f c0       	rjmp	.+62     	; 0x485c <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_B)
    481e:	80 34       	cpi	r24, 0x40	; 64
    4820:	31 f4       	brne	.+12     	; 0x482e <main+0x208>
			{
				if(lastEncoderState==ENC_POS_A)
    4822:	91 11       	cpse	r25, r1
    4824:	01 c0       	rjmp	.+2      	; 0x4828 <main+0x202>
    4826:	0f c0       	rjmp	.+30     	; 0x4846 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_C)
    4828:	90 3c       	cpi	r25, 0xC0	; 192
    482a:	11 f5       	brne	.+68     	; 0x4870 <main+0x24a>
    482c:	17 c0       	rjmp	.+46     	; 0x485c <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_C)
    482e:	80 3c       	cpi	r24, 0xC0	; 192
    4830:	31 f4       	brne	.+12     	; 0x483e <main+0x218>
			{
				if(lastEncoderState==ENC_POS_B)
    4832:	90 34       	cpi	r25, 0x40	; 64
    4834:	09 f4       	brne	.+2      	; 0x4838 <main+0x212>
    4836:	07 c0       	rjmp	.+14     	; 0x4846 <main+0x220>
//					encoderValue++;
					encoderValue--;
					encoderCcw=true;
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_D)
    4838:	90 38       	cpi	r25, 0x80	; 128
    483a:	d1 f4       	brne	.+52     	; 0x4870 <main+0x24a>
    483c:	0f c0       	rjmp	.+30     	; 0x485c <main+0x236>
					encoderValue++;
					encoderCw=true;
					newEncoder=true;
				}
			}
			else if(encoderState==ENC_POS_D)
    483e:	80 38       	cpi	r24, 0x80	; 128
    4840:	b9 f4       	brne	.+46     	; 0x4870 <main+0x24a>
			{
				if(lastEncoderState==ENC_POS_C)
    4842:	90 3c       	cpi	r25, 0xC0	; 192
    4844:	49 f4       	brne	.+18     	; 0x4858 <main+0x232>
				{
//					encoderValue++;
					encoderValue--;
    4846:	90 91 6d 05 	lds	r25, 0x056D
    484a:	91 50       	subi	r25, 0x01	; 1
    484c:	90 93 6d 05 	sts	0x056D, r25
					encoderCcw=true;
    4850:	91 e0       	ldi	r25, 0x01	; 1
    4852:	90 93 b0 05 	sts	0x05B0, r25
    4856:	0a c0       	rjmp	.+20     	; 0x486c <main+0x246>
					newEncoder=true;
				}
				else if(lastEncoderState==ENC_POS_A)
    4858:	91 11       	cpse	r25, r1
    485a:	0a c0       	rjmp	.+20     	; 0x4870 <main+0x24a>
				{
//					encoderValue--;
					encoderValue++;
    485c:	90 91 6d 05 	lds	r25, 0x056D
    4860:	9f 5f       	subi	r25, 0xFF	; 255
    4862:	90 93 6d 05 	sts	0x056D, r25
					encoderCw=true;
    4866:	91 e0       	ldi	r25, 0x01	; 1
    4868:	90 93 af 05 	sts	0x05AF, r25
					newEncoder=true;
    486c:	90 93 6b 05 	sts	0x056B, r25
				}
			}

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    4870:	80 93 bf 05 	sts	0x05BF, r24

	while(1)
	{
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
    4874:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <HandleSoftclock>
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    4878:	80 91 ae 05 	lds	r24, 0x05AE
    487c:	88 23       	and	r24, r24
    487e:	e1 f1       	breq	.+120    	; 0x48f8 <main+0x2d2>
    4880:	82 e0       	ldi	r24, 0x02	; 2
    4882:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4886:	88 23       	and	r24, r24
    4888:	b9 f1       	breq	.+110    	; 0x48f8 <main+0x2d2>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    488a:	20 91 ae 05 	lds	r18, 0x05AE
    488e:	30 e0       	ldi	r19, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    4890:	f0 91 c0 05 	lds	r31, 0x05C0
    4894:	e0 91 5d 05 	lds	r30, 0x055D
    4898:	80 e0       	ldi	r24, 0x00	; 0
    489a:	90 e0       	ldi	r25, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    489c:	b9 01       	movw	r22, r18
    489e:	08 2e       	mov	r0, r24
    48a0:	02 c0       	rjmp	.+4      	; 0x48a6 <main+0x280>
    48a2:	75 95       	asr	r23
    48a4:	67 95       	ror	r22
    48a6:	0a 94       	dec	r0
    48a8:	e2 f7       	brpl	.-8      	; 0x48a2 <main+0x27c>
    48aa:	60 ff       	sbrs	r22, 0
    48ac:	0e c0       	rjmp	.+28     	; 0x48ca <main+0x2a4>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
				{
					ledOnOffMask|=(1<<i);
    48ae:	b7 01       	movw	r22, r14
    48b0:	08 2e       	mov	r0, r24
    48b2:	02 c0       	rjmp	.+4      	; 0x48b8 <main+0x292>
    48b4:	66 0f       	add	r22, r22
    48b6:	77 1f       	adc	r23, r23
    48b8:	0a 94       	dec	r0
    48ba:	e2 f7       	brpl	.-8      	; 0x48b4 <main+0x28e>
    48bc:	ab 01       	movw	r20, r22
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    48be:	ff 23       	and	r31, r31
    48c0:	11 f0       	breq	.+4      	; 0x48c6 <main+0x2a0>
				{
					ledOnOffMask|=(1<<i);
    48c2:	e6 2b       	or	r30, r22
    48c4:	02 c0       	rjmp	.+4      	; 0x48ca <main+0x2a4>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    48c6:	40 95       	com	r20
    48c8:	e4 23       	and	r30, r20
    48ca:	01 96       	adiw	r24, 0x01	; 1
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    48cc:	88 30       	cpi	r24, 0x08	; 8
    48ce:	91 05       	cpc	r25, r1
    48d0:	29 f7       	brne	.-54     	; 0x489c <main+0x276>
    48d2:	e0 93 5d 05 	sts	0x055D, r30
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    48d6:	81 e0       	ldi	r24, 0x01	; 1
    48d8:	90 91 c0 05 	lds	r25, 0x05C0
    48dc:	91 11       	cpse	r25, r1
    48de:	80 e0       	ldi	r24, 0x00	; 0
    48e0:	80 93 c0 05 	sts	0x05C0, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    48e4:	68 e9       	ldi	r22, 0x98	; 152
    48e6:	70 e0       	ldi	r23, 0x00	; 0
    48e8:	82 e0       	ldi	r24, 0x02	; 2
    48ea:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    48ee:	80 91 5d 05 	lds	r24, 0x055D
    48f2:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
    48f6:	0b c0       	rjmp	.+22     	; 0x490e <main+0x2e8>
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    48f8:	50 90 5d 05 	lds	r5, 0x055D
    48fc:	80 91 c1 05 	lds	r24, 0x05C1
    4900:	85 15       	cp	r24, r5
    4902:	29 f0       	breq	.+10     	; 0x490e <main+0x2e8>
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
    4904:	85 2d       	mov	r24, r5
    4906:	0e 94 e5 08 	call	0x11ca	; 0x11ca <WriteLedLatch>
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    490a:	50 92 c1 05 	sts	0x05C1, r5
		numTransferBytes;

	static unsigned int
		bytesLeftInBlock;	// How many bytes left in the given block

	if(cardDetect==false)		// No card in the slot?
    490e:	90 91 5a 05 	lds	r25, 0x055A
    4912:	80 91 59 05 	lds	r24, 0x0559
    4916:	91 11       	cpse	r25, r1
    4918:	06 c0       	rjmp	.+12     	; 0x4926 <main+0x300>
	{
		if(cardState!=SD_NOT_PRESENT)	// Was there a card in the slot before?
    491a:	88 23       	and	r24, r24
    491c:	09 f4       	brne	.+2      	; 0x4920 <main+0x2fa>
    491e:	17 c5       	rjmp	.+2606   	; 0x534e <main+0xd28>
		{
			ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
    4920:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <ResetSdCard>
    4924:	14 c5       	rjmp	.+2600   	; 0x534e <main+0xd28>
		}
	}
	else	// Yup, got a card
	{
		switch(cardState)
    4926:	86 30       	cpi	r24, 0x06	; 6
    4928:	09 f4       	brne	.+2      	; 0x492c <main+0x306>
    492a:	8d c2       	rjmp	.+1306   	; 0x4e46 <main+0x820>
    492c:	80 f4       	brcc	.+32     	; 0x494e <main+0x328>
    492e:	82 30       	cpi	r24, 0x02	; 2
    4930:	09 f4       	brne	.+2      	; 0x4934 <main+0x30e>
    4932:	0e c1       	rjmp	.+540    	; 0x4b50 <main+0x52a>
    4934:	30 f4       	brcc	.+12     	; 0x4942 <main+0x31c>
    4936:	88 23       	and	r24, r24
    4938:	e9 f0       	breq	.+58     	; 0x4974 <main+0x34e>
    493a:	81 30       	cpi	r24, 0x01	; 1
    493c:	09 f0       	breq	.+2      	; 0x4940 <main+0x31a>
    493e:	07 c5       	rjmp	.+2574   	; 0x534e <main+0xd28>
    4940:	22 c0       	rjmp	.+68     	; 0x4986 <main+0x360>
    4942:	84 30       	cpi	r24, 0x04	; 4
    4944:	09 f4       	brne	.+2      	; 0x4948 <main+0x322>
    4946:	f4 c1       	rjmp	.+1000   	; 0x4d30 <main+0x70a>
    4948:	08 f0       	brcs	.+2      	; 0x494c <main+0x326>
    494a:	34 c2       	rjmp	.+1128   	; 0x4db4 <main+0x78e>
    494c:	6d c1       	rjmp	.+730    	; 0x4c28 <main+0x602>
    494e:	8a 30       	cpi	r24, 0x0A	; 10
    4950:	09 f4       	brne	.+2      	; 0x4954 <main+0x32e>
    4952:	b0 c3       	rjmp	.+1888   	; 0x50b4 <main+0xa8e>
    4954:	30 f4       	brcc	.+12     	; 0x4962 <main+0x33c>
    4956:	88 30       	cpi	r24, 0x08	; 8
    4958:	09 f4       	brne	.+2      	; 0x495c <main+0x336>
    495a:	11 c3       	rjmp	.+1570   	; 0x4f7e <main+0x958>
    495c:	08 f0       	brcs	.+2      	; 0x4960 <main+0x33a>
    495e:	24 c3       	rjmp	.+1608   	; 0x4fa8 <main+0x982>
    4960:	d3 c2       	rjmp	.+1446   	; 0x4f08 <main+0x8e2>
    4962:	8c 30       	cpi	r24, 0x0C	; 12
    4964:	09 f4       	brne	.+2      	; 0x4968 <main+0x342>
    4966:	8a c4       	rjmp	.+2324   	; 0x527c <main+0xc56>
    4968:	08 f4       	brcc	.+2      	; 0x496c <main+0x346>
    496a:	3d c4       	rjmp	.+2170   	; 0x51e6 <main+0xbc0>
    496c:	8d 30       	cpi	r24, 0x0D	; 13
    496e:	09 f0       	breq	.+2      	; 0x4972 <main+0x34c>
    4970:	ee c4       	rjmp	.+2524   	; 0x534e <main+0xd28>
    4972:	a7 c4       	rjmp	.+2382   	; 0x52c2 <main+0xc9c>
// --------------------------------------------------------------------------------------------------------------------------------------
// Warmup / Init	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_NOT_PRESENT:	// Card just inserted
			cardState=SD_WARMUP;	// Let card get power settled before trying to do anything.
    4974:	81 e0       	ldi	r24, 0x01	; 1
    4976:	80 93 59 05 	sts	0x0559, r24
			SetTimer(TIMER_SD,SD_WARMUP_TIME);		// Give card this long
    497a:	64 ec       	ldi	r22, 0xC4	; 196
    497c:	74 e0       	ldi	r23, 0x04	; 4
    497e:	83 e0       	ldi	r24, 0x03	; 3
    4980:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
    4984:	e4 c4       	rjmp	.+2504   	; 0x534e <main+0xd28>
			break;

			case SD_WARMUP:				// Card inserted, timer has been started.
			if(CheckTimer(TIMER_SD))	// Card had long enough to power up?
    4986:	83 e0       	ldi	r24, 0x03	; 3
    4988:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    498c:	88 23       	and	r24, r24
    498e:	09 f4       	brne	.+2      	; 0x4992 <main+0x36c>
    4990:	de c4       	rjmp	.+2492   	; 0x534e <main+0xd28>
			{
				sdPlaybackQueued=false;
    4992:	10 92 ba 05 	sts	0x05BA, r1
				sdAbortRead=false;
    4996:	10 92 b7 05 	sts	0x05B7, r1

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
    499a:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <SdHandshake>
    499e:	81 30       	cpi	r24, 0x01	; 1
    49a0:	09 f0       	breq	.+2      	; 0x49a4 <main+0x37e>
    49a2:	d4 c0       	rjmp	.+424    	; 0x4b4c <main+0x526>
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem

	if(SdBeginSingleBlockRead(0)==true)		// Start reading at block 0.
    49a4:	60 e0       	ldi	r22, 0x00	; 0
    49a6:	70 e0       	ldi	r23, 0x00	; 0
    49a8:	cb 01       	movw	r24, r22
    49aa:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <SdBeginSingleBlockRead>
    49ae:	81 30       	cpi	r24, 0x01	; 1
    49b0:	09 f0       	breq	.+2      	; 0x49b4 <main+0x38e>
    49b2:	8f c0       	rjmp	.+286    	; 0x4ad2 <main+0x4ac>
 		// Tue Jun 21 17:11:28 EDT 2011
 		// @@@ this appears to be bad news.  Tends to leave DO low.
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout
    49b4:	6a e7       	ldi	r22, 0x7A	; 122
    49b6:	70 e0       	ldi	r23, 0x00	; 0
    49b8:	83 e0       	ldi	r24, 0x03	; 3
    49ba:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
    49be:	02 c0       	rjmp	.+4      	; 0x49c4 <main+0x39e>

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
    49c0:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <HandleSoftclock>
		// So --
		// Read the first four bytes and test them, then read the remainder of the block and checksum and toss it.

		SetTimer(TIMER_SD,(SECOND/10));		// 100mSecs timeout

		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
    49c4:	83 e0       	ldi	r24, 0x03	; 3
    49c6:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    49ca:	88 23       	and	r24, r24
    49cc:	31 f0       	breq	.+12     	; 0x49da <main+0x3b4>
    49ce:	44 24       	eor	r4, r4
    49d0:	43 94       	inc	r4
    49d2:	51 2c       	mov	r5, r1
    49d4:	4c 0e       	add	r4, r28
    49d6:	5d 1e       	adc	r5, r29
    49d8:	06 c0       	rjmp	.+12     	; 0x49e6 <main+0x3c0>
    49da:	8f ef       	ldi	r24, 0xFF	; 255
    49dc:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    49e0:	8e 3f       	cpi	r24, 0xFE	; 254
    49e2:	71 f7       	brne	.-36     	; 0x49c0 <main+0x39a>
    49e4:	f4 cf       	rjmp	.-24     	; 0x49ce <main+0x3a8>
			HandleSoftclock();	// Kludgy
		}

		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
    49e6:	8f ef       	ldi	r24, 0xFF	; 255
    49e8:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    49ec:	f2 01       	movw	r30, r4
    49ee:	81 93       	st	Z+, r24
    49f0:	2f 01       	movw	r4, r30
		while((!(CheckTimer(TIMER_SD)))&&(TransferSdByte(DUMMY_BYTE)!=0xFE))	// Wait for the start of the packet.  Could take 100mS
		{
			HandleSoftclock();	// Kludgy
		}

		for(i=0;i<8;i++)	// Get the first 8 bytes of the header and use them to determine the filesystem
    49f2:	ec 15       	cp	r30, r12
    49f4:	fd 05       	cpc	r31, r13
    49f6:	b9 f7       	brne	.-18     	; 0x49e6 <main+0x3c0>
		{
			sdTypeBuffer[i]=TransferSdByte(DUMMY_BYTE);
		}

		if((sdTypeBuffer[0]=='W')&&(sdTypeBuffer[1]=='T')&&(sdTypeBuffer[2]=='P')&&(sdTypeBuffer[3]=='A'))	// SOME kind of WTPA card, most likely (first four chars are always WTPA)
    49f8:	89 81       	ldd	r24, Y+1	; 0x01
    49fa:	87 35       	cpi	r24, 0x57	; 87
    49fc:	09 f0       	breq	.+2      	; 0x4a00 <main+0x3da>
    49fe:	34 c0       	rjmp	.+104    	; 0x4a68 <main+0x442>
    4a00:	8a 81       	ldd	r24, Y+2	; 0x02
    4a02:	84 35       	cpi	r24, 0x54	; 84
    4a04:	89 f5       	brne	.+98     	; 0x4a68 <main+0x442>
    4a06:	8b 81       	ldd	r24, Y+3	; 0x03
    4a08:	80 35       	cpi	r24, 0x50	; 80
    4a0a:	71 f5       	brne	.+92     	; 0x4a68 <main+0x442>
    4a0c:	8c 81       	ldd	r24, Y+4	; 0x04
    4a0e:	81 34       	cpi	r24, 0x41	; 65
    4a10:	59 f5       	brne	.+86     	; 0x4a68 <main+0x442>
		{
			if((sdTypeBuffer[4]=='S')&&(sdTypeBuffer[5]=='A')&&(sdTypeBuffer[6]=='M')&&(sdTypeBuffer[7]=='P'))		// Samples?
    4a12:	8d 81       	ldd	r24, Y+5	; 0x05
    4a14:	83 35       	cpi	r24, 0x53	; 83
    4a16:	61 f4       	brne	.+24     	; 0x4a30 <main+0x40a>
    4a18:	8e 81       	ldd	r24, Y+6	; 0x06
    4a1a:	81 34       	cpi	r24, 0x41	; 65
    4a1c:	29 f5       	brne	.+74     	; 0x4a68 <main+0x442>
    4a1e:	8f 81       	ldd	r24, Y+7	; 0x07
    4a20:	8d 34       	cpi	r24, 0x4D	; 77
    4a22:	11 f5       	brne	.+68     	; 0x4a68 <main+0x442>
    4a24:	33 24       	eor	r3, r3
    4a26:	33 94       	inc	r3
    4a28:	88 85       	ldd	r24, Y+8	; 0x08
    4a2a:	80 35       	cpi	r24, 0x50	; 80
    4a2c:	f1 f0       	breq	.+60     	; 0x4a6a <main+0x444>
    4a2e:	1c c0       	rjmp	.+56     	; 0x4a68 <main+0x442>
			{
				filesystemType=SD_TYPE_SAMPLES;
			}
			else if((sdTypeBuffer[4]=='D')&&(sdTypeBuffer[5]=='P')&&(sdTypeBuffer[6]=='C')&&(sdTypeBuffer[7]=='M'))	// Andrew's Nintendo DPCM samples?
    4a30:	84 34       	cpi	r24, 0x44	; 68
    4a32:	61 f4       	brne	.+24     	; 0x4a4c <main+0x426>
    4a34:	8e 81       	ldd	r24, Y+6	; 0x06
    4a36:	80 35       	cpi	r24, 0x50	; 80
    4a38:	b9 f4       	brne	.+46     	; 0x4a68 <main+0x442>
    4a3a:	8f 81       	ldd	r24, Y+7	; 0x07
    4a3c:	83 34       	cpi	r24, 0x43	; 67
    4a3e:	a1 f4       	brne	.+40     	; 0x4a68 <main+0x442>
    4a40:	88 85       	ldd	r24, Y+8	; 0x08
    4a42:	8d 34       	cpi	r24, 0x4D	; 77
    4a44:	89 f4       	brne	.+34     	; 0x4a68 <main+0x442>
			{
				filesystemType=SD_TYPE_DPCM;			
    4a46:	62 e0       	ldi	r22, 0x02	; 2
    4a48:	36 2e       	mov	r3, r22
    4a4a:	0f c0       	rjmp	.+30     	; 0x4a6a <main+0x444>
			}
			else if((sdTypeBuffer[4]=='B')&&(sdTypeBuffer[5]=='O')&&(sdTypeBuffer[6]=='O')&&(sdTypeBuffer[7]=='T'))	// Program image for bootloader?
    4a4c:	82 34       	cpi	r24, 0x42	; 66
    4a4e:	61 f4       	brne	.+24     	; 0x4a68 <main+0x442>
    4a50:	8e 81       	ldd	r24, Y+6	; 0x06
    4a52:	8f 34       	cpi	r24, 0x4F	; 79
    4a54:	49 f4       	brne	.+18     	; 0x4a68 <main+0x442>
    4a56:	8f 81       	ldd	r24, Y+7	; 0x07
    4a58:	8f 34       	cpi	r24, 0x4F	; 79
    4a5a:	31 f4       	brne	.+12     	; 0x4a68 <main+0x442>
    4a5c:	88 85       	ldd	r24, Y+8	; 0x08
    4a5e:	84 35       	cpi	r24, 0x54	; 84
    4a60:	19 f4       	brne	.+6      	; 0x4a68 <main+0x442>
			{
				filesystemType=SD_TYPE_BOOT;						
    4a62:	53 e0       	ldi	r21, 0x03	; 3
    4a64:	35 2e       	mov	r3, r21
    4a66:	01 c0       	rjmp	.+2      	; 0x4a6a <main+0x444>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    4a68:	31 2c       	mov	r3, r1
    4a6a:	48 e0       	ldi	r20, 0x08	; 8
    4a6c:	44 2e       	mov	r4, r20
    4a6e:	51 2c       	mov	r5, r1
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
    4a70:	8f ef       	ldi	r24, 0xFF	; 255
    4a72:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4a76:	f1 e0       	ldi	r31, 0x01	; 1
    4a78:	4f 1a       	sub	r4, r31
    4a7a:	51 08       	sbc	r5, r1
			{
				filesystemType=SD_TYPE_BOOT;						
			}
		}

		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
    4a7c:	c9 f7       	brne	.-14     	; 0x4a70 <main+0x44a>
		{
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
    4a7e:	21 e0       	ldi	r18, 0x01	; 1
    4a80:	32 12       	cpse	r3, r18
    4a82:	14 c0       	rjmp	.+40     	; 0x4aac <main+0x486>
    4a84:	3e e6       	ldi	r19, 0x6E	; 110
    4a86:	43 2e       	mov	r4, r19
    4a88:	35 e0       	ldi	r19, 0x05	; 5
    4a8a:	53 2e       	mov	r5, r19
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
			{
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
    4a8c:	8f ef       	ldi	r24, 0xFF	; 255
    4a8e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4a92:	f2 01       	movw	r30, r4
    4a94:	81 93       	st	Z+, r24
    4a96:	2f 01       	movw	r4, r30
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
		{
			for(i=0;i<64;i++)							// For all TOC entries (64 bytes / 512 bits)
    4a98:	fe ea       	ldi	r31, 0xAE	; 174
    4a9a:	4f 16       	cp	r4, r31
    4a9c:	f5 e0       	ldi	r31, 0x05	; 5
    4a9e:	5f 06       	cpc	r5, r31
    4aa0:	a9 f7       	brne	.-22     	; 0x4a8c <main+0x466>
		for(i=0;i<8;i++)					// 8 don't care bytes left (16 bytes at the beginning of the card for a string)
		{
			TransferSdByte(0xFF);
		}

		if(filesystemType==SD_TYPE_SAMPLES)				// Load TOC if this is a legit card
    4aa2:	22 eb       	ldi	r18, 0xB2	; 178
    4aa4:	42 2e       	mov	r4, r18
    4aa6:	55 24       	eor	r5, r5
    4aa8:	53 94       	inc	r5
    4aaa:	0b c0       	rjmp	.+22     	; 0x4ac2 <main+0x49c>
    4aac:	90 e4       	ldi	r25, 0x40	; 64
    4aae:	49 2e       	mov	r4, r25
    4ab0:	51 2c       	mov	r5, r1
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
			{
				TransferSdByte(0xFF);
    4ab2:	8f ef       	ldi	r24, 0xFF	; 255
    4ab4:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4ab8:	21 e0       	ldi	r18, 0x01	; 1
    4aba:	42 1a       	sub	r4, r18
    4abc:	51 08       	sbc	r5, r1
				sampleToc[i]=TransferSdByte(0xFF);		// Load toc into RAM
			}
		}
		else
		{
			for(i=0;i<64;i++)				// Get bytes but don't put them in the toc
    4abe:	c9 f7       	brne	.-14     	; 0x4ab2 <main+0x48c>
    4ac0:	f0 cf       	rjmp	.-32     	; 0x4aa2 <main+0x47c>
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
		{
			TransferSdByte(0xFF);
    4ac2:	8f ef       	ldi	r24, 0xFF	; 255
    4ac4:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4ac8:	31 e0       	ldi	r19, 0x01	; 1
    4aca:	43 1a       	sub	r4, r19
    4acc:	51 08       	sbc	r5, r1
			{
				TransferSdByte(0xFF);
			}

		}
		for(i=0;i<(432+2);i++)					// Read don't cares and CRC
    4ace:	c9 f7       	brne	.-14     	; 0x4ac2 <main+0x49c>
    4ad0:	01 c0       	rjmp	.+2      	; 0x4ad4 <main+0x4ae>
	unsigned char
		sdTypeBuffer[8];
	unsigned int
		i;

	filesystemType=SD_TYPE_UNFORMATTED;		// Start assuming no filesystem
    4ad2:	31 2c       	mov	r3, r1
		{
			TransferSdByte(0xFF);
		}
	}

	while(!(UCSR1A&(1<<TXC1)))	// Spin until the last clocks go out
    4ad4:	80 91 c8 00 	lds	r24, 0x00C8
    4ad8:	86 ff       	sbrs	r24, 6
    4ada:	fc cf       	rjmp	.-8      	; 0x4ad4 <main+0x4ae>
		;

	EndSdTransfer();				// Bring CS high
    4adc:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
	TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    4ae0:	8f ef       	ldi	r24, 0xFF	; 255
    4ae2:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>

				if(SdHandshake()==true)				// See if this is a valid SD standard capacity card that we can talk to.
				{
					theByte=GetCardFilesystem();	// Can talk to it.  Try and figure out the type of data that might be on the card.

					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
    4ae6:	41 e0       	ldi	r20, 0x01	; 1
    4ae8:	34 12       	cpse	r3, r20
    4aea:	19 c0       	rjmp	.+50     	; 0x4b1e <main+0x4f8>
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
    4aec:	b0 92 59 05 	sts	0x0559, r11
// Listening to some tests on the internet I can't tell the difference, so we do this the easy way here.
// (Reading and writing don't matter, since we don't hear them and a small percentage difference won't affect performance)
{
	// Set up timer 2 OC2B to make SD buffer interrupts

	PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.
    4af0:	80 91 64 00 	lds	r24, 0x0064
    4af4:	8f 7b       	andi	r24, 0xBF	; 191
    4af6:	80 93 64 00 	sts	0x0064, r24

	TCCR2A=0x02;		// Normal ports, begin setting CTC mode.
    4afa:	82 e0       	ldi	r24, 0x02	; 2
    4afc:	80 93 b0 00 	sts	0x00B0, r24
	TCCR2B=0x00;		// Finish setting CTC, turn clock off.
    4b00:	10 92 b1 00 	sts	0x00B1, r1
	TCNT2=0;			// Init counter reg
    4b04:	10 92 b2 00 	sts	0x00B2, r1
	OCR2A=113;			// Compare match interrupt when the counter gets to this number (see above for pitch analysis)
    4b08:	81 e7       	ldi	r24, 0x71	; 113
    4b0a:	80 93 b3 00 	sts	0x00B3, r24
	TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    4b0e:	a7 ba       	out	0x17, r10	; 23
	TIMSK2=0x00;		// Disable interrupts (no interrupts yet)
    4b10:	10 92 70 00 	sts	0x0070, r1

	sdIsrState=SD_ISR_IDLE;	// ISR doing nothing right now.
    4b14:	10 92 4f 05 	sts	0x054F, r1
	sdStreamOutput=0;		// Initialize the contribution to the DAC to zero.
    4b18:	10 92 55 05 	sts	0x0555, r1
    4b1c:	18 c4       	rjmp	.+2096   	; 0x534e <main+0xd28>
					if(theByte==SD_TYPE_SAMPLES)	// Looks like WTPA-formatted samples.
					{
						cardState=SD_IDLE;			// Card is legit and ready to go.
						InitSdIsr();				// Enable the timers necessary to give the SD card its own IRQ
					}
					else if(theByte==SD_TYPE_DPCM)	// Looks like Nintendo samples, uninitialize the normal sampler routines and get that going.
    4b1e:	52 e0       	ldi	r21, 0x02	; 2
    4b20:	35 16       	cp	r3, r21
    4b22:	09 f4       	brne	.+2      	; 0x4b26 <main+0x500>
    4b24:	14 c4       	rjmp	.+2088   	; 0x534e <main+0xd28>
						// @@@ Load up DPCM stuff
					}

					else	// Valid card, but either invalid filesystem or BOOT card.  Vector to "are you sure" state and give user the option to Format the card.
					{
						cardState=SD_INVALID;	// Don't let the state machine mess with the card while it's being Formatted.
    4b26:	8f e0       	ldi	r24, 0x0F	; 15
    4b28:	80 93 59 05 	sts	0x0559, r24
    4b2c:	ee e6       	ldi	r30, 0x6E	; 110
    4b2e:	f5 e0       	ldi	r31, 0x05	; 5
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
	{
		sampleToc[i]=0x00;		// 8 bits of "no sample present"
    4b30:	11 92       	st	Z+, r1
// Empties the TOC of samples in local ram.
{
	unsigned char
		i;

	for(i=0;i<64;i++)			// For all TOC entries (64 bytes / 512 bits)
    4b32:	65 e0       	ldi	r22, 0x05	; 5
    4b34:	ee 3a       	cpi	r30, 0xAE	; 174
    4b36:	f6 07       	cpc	r31, r22
    4b38:	d9 f7       	brne	.-10     	; 0x4b30 <main+0x50a>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    4b3a:	82 e2       	ldi	r24, 0x22	; 34
    4b3c:	91 e1       	ldi	r25, 0x11	; 17
    4b3e:	90 93 e4 05 	sts	0x05E4, r25
    4b42:	80 93 e3 05 	sts	0x05E3, r24
	subState=SS_0;
    4b46:	10 92 5b 05 	sts	0x055B, r1
    4b4a:	01 c4       	rjmp	.+2050   	; 0x534e <main+0xd28>
						SetState(DoFormatCard);	// Go here and let the user decide if they REALLY want to commit to making this a WTPA specific card
					}
				}
				else	// Not a valid handshake.  Get on with our lives.
				{
					cardState=SD_INVALID;
    4b4c:	8f e0       	ldi	r24, 0x0F	; 15
    4b4e:	91 c3       	rjmp	.+1826   	; 0x5272 <main+0xc4c>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing Samples to the Card	---------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_WRITE_START:		// Wait until the fifo has a block, then start the write beginning with the length of the sample.
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    4b50:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4b52:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR our sample is less than a block AND loaded in the FIFO.
    4b54:	80 91 26 01 	lds	r24, 0x0126
    4b58:	90 91 27 01 	lds	r25, 0x0127
    4b5c:	81 15       	cp	r24, r1
    4b5e:	92 40       	sbci	r25, 0x02	; 2
    4b60:	a0 f4       	brcc	.+40     	; 0x4b8a <main+0x564>
    4b62:	80 91 26 01 	lds	r24, 0x0126
    4b66:	90 91 27 01 	lds	r25, 0x0127
    4b6a:	40 91 1e 01 	lds	r20, 0x011E
    4b6e:	50 91 1f 01 	lds	r21, 0x011F
    4b72:	60 91 20 01 	lds	r22, 0x0120
    4b76:	70 91 21 01 	lds	r23, 0x0121
    4b7a:	a0 e0       	ldi	r26, 0x00	; 0
    4b7c:	b0 e0       	ldi	r27, 0x00	; 0
    4b7e:	84 17       	cp	r24, r20
    4b80:	95 07       	cpc	r25, r21
    4b82:	a6 07       	cpc	r26, r22
    4b84:	b7 07       	cpc	r27, r23
    4b86:	08 f4       	brcc	.+2      	; 0x4b8a <main+0x564>
    4b88:	5c c1       	rjmp	.+696    	; 0x4e42 <main+0x81c>
			{
				SREG=sreg;	// Done reading ISR variables.
    4b8a:	2f bf       	out	0x3f, r18	; 63
				if(SdBeginSingleBlockWrite(sdSampleStartBlock)==true)	// Try to open the card for a single block write.
    4b8c:	60 91 b1 05 	lds	r22, 0x05B1
    4b90:	70 91 b2 05 	lds	r23, 0x05B2
    4b94:	80 91 b3 05 	lds	r24, 0x05B3
    4b98:	90 91 b4 05 	lds	r25, 0x05B4
    4b9c:	0e 94 02 23 	call	0x4604	; 0x4604 <SdBeginSingleBlockWrite>
    4ba0:	81 30       	cpi	r24, 0x01	; 1
    4ba2:	09 f0       	breq	.+2      	; 0x4ba6 <main+0x580>
    4ba4:	bd ce       	rjmp	.-646    	; 0x4920 <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4ba6:	10 93 c3 05 	sts	0x05C3, r17
    4baa:	00 93 c2 05 	sts	0x05C2, r16

					TransferSdByte(DUMMY_BYTE);							// Send a pad
    4bae:	8f ef       	ldi	r24, 0xFF	; 255
    4bb0:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);							// Send another pad
    4bb4:	8f ef       	ldi	r24, 0xFF	; 255
    4bb6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(0xFE);								// Send DATA_START token
    4bba:	8e ef       	ldi	r24, 0xFE	; 254
    4bbc:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>24)&0xFF);		// Sample length MSB
    4bc0:	80 91 1e 01 	lds	r24, 0x011E
    4bc4:	90 91 1f 01 	lds	r25, 0x011F
    4bc8:	a0 91 20 01 	lds	r26, 0x0120
    4bcc:	b0 91 21 01 	lds	r27, 0x0121
    4bd0:	8b 2f       	mov	r24, r27
    4bd2:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>16)&0xFF);		// Sample length
    4bd6:	60 91 1e 01 	lds	r22, 0x011E
    4bda:	70 91 1f 01 	lds	r23, 0x011F
    4bde:	80 91 20 01 	lds	r24, 0x0120
    4be2:	90 91 21 01 	lds	r25, 0x0121
    4be6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte((sdCardSampleRemaining>>8)&0xFF);		// Sample length
    4bea:	80 91 1e 01 	lds	r24, 0x011E
    4bee:	90 91 1f 01 	lds	r25, 0x011F
    4bf2:	a0 91 20 01 	lds	r26, 0x0120
    4bf6:	b0 91 21 01 	lds	r27, 0x0121
    4bfa:	89 2f       	mov	r24, r25
    4bfc:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(sdCardSampleRemaining&0xFF);				// Sample length LSB
    4c00:	80 91 1e 01 	lds	r24, 0x011E
    4c04:	90 91 1f 01 	lds	r25, 0x011F
    4c08:	a0 91 20 01 	lds	r26, 0x0120
    4c0c:	b0 91 21 01 	lds	r27, 0x0121
    4c10:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>

					bytesLeftInBlock-=4;							// Keep track of where we are in the block
    4c14:	80 91 c2 05 	lds	r24, 0x05C2
    4c18:	90 91 c3 05 	lds	r25, 0x05C3
    4c1c:	04 97       	sbiw	r24, 0x04	; 4
    4c1e:	90 93 c3 05 	sts	0x05C3, r25
    4c22:	80 93 c2 05 	sts	0x05C2, r24
    4c26:	0b c1       	rjmp	.+534    	; 0x4e3e <main+0x818>
    4c28:	40 90 c2 05 	lds	r4, 0x05C2
    4c2c:	50 90 c3 05 	lds	r5, 0x05C3
    4c30:	81 e4       	ldi	r24, 0x41	; 65
    4c32:	48 16       	cp	r4, r24
    4c34:	51 04       	cpc	r5, r1
    4c36:	18 f0       	brcs	.+6      	; 0x4c3e <main+0x618>
    4c38:	80 e4       	ldi	r24, 0x40	; 64
    4c3a:	48 2e       	mov	r4, r24
    4c3c:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4c3e:	31 2c       	mov	r3, r1
    4c40:	56 c0       	rjmp	.+172    	; 0x4cee <main+0x6c8>
			{
				if(sdCardSampleRemaining)							// Bytes left in our sample?  If so, write them.
    4c42:	80 91 1e 01 	lds	r24, 0x011E
    4c46:	90 91 1f 01 	lds	r25, 0x011F
    4c4a:	a0 91 20 01 	lds	r26, 0x0120
    4c4e:	b0 91 21 01 	lds	r27, 0x0121
    4c52:	89 2b       	or	r24, r25
    4c54:	8a 2b       	or	r24, r26
    4c56:	8b 2b       	or	r24, r27
    4c58:	e9 f1       	breq	.+122    	; 0x4cd4 <main+0x6ae>
				{
					TransferSdByte(sdFifo[sdFifoReadPointer]);		// Put byte from fifo into SD
    4c5a:	e0 91 2a 01 	lds	r30, 0x012A
    4c5e:	f0 91 2b 01 	lds	r31, 0x012B
    4c62:	e4 5d       	subi	r30, 0xD4	; 212
    4c64:	fe 4f       	sbci	r31, 0xFE	; 254
    4c66:	80 81       	ld	r24, Z
    4c68:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					sdCardSampleRemaining--;						// One less sample byte to go into the card
    4c6c:	80 91 1e 01 	lds	r24, 0x011E
    4c70:	90 91 1f 01 	lds	r25, 0x011F
    4c74:	a0 91 20 01 	lds	r26, 0x0120
    4c78:	b0 91 21 01 	lds	r27, 0x0121
    4c7c:	01 97       	sbiw	r24, 0x01	; 1
    4c7e:	a1 09       	sbc	r26, r1
    4c80:	b1 09       	sbc	r27, r1
    4c82:	80 93 1e 01 	sts	0x011E, r24
    4c86:	90 93 1f 01 	sts	0x011F, r25
    4c8a:	a0 93 20 01 	sts	0x0120, r26
    4c8e:	b0 93 21 01 	sts	0x0121, r27

					sdFifoReadPointer++;			// Move to next spot in fifo
    4c92:	80 91 2a 01 	lds	r24, 0x012A
    4c96:	90 91 2b 01 	lds	r25, 0x012B
    4c9a:	01 96       	adiw	r24, 0x01	; 1
    4c9c:	90 93 2b 01 	sts	0x012B, r25
    4ca0:	80 93 2a 01 	sts	0x012A, r24

					if(sdFifoReadPointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    4ca4:	80 91 2a 01 	lds	r24, 0x012A
    4ca8:	90 91 2b 01 	lds	r25, 0x012B
    4cac:	81 15       	cp	r24, r1
    4cae:	93 40       	sbci	r25, 0x03	; 3
    4cb0:	20 f0       	brcs	.+8      	; 0x4cba <main+0x694>
					{
						sdFifoReadPointer=0;
    4cb2:	10 92 2b 01 	sts	0x012B, r1
    4cb6:	10 92 2a 01 	sts	0x012A, r1
					}

					sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    4cba:	2f b7       	in	r18, 0x3f	; 63
					cli();
    4cbc:	f8 94       	cli
					sdBytesInFifo--;	// Stored one more byte.
    4cbe:	80 91 26 01 	lds	r24, 0x0126
    4cc2:	90 91 27 01 	lds	r25, 0x0127
    4cc6:	01 97       	sbiw	r24, 0x01	; 1
    4cc8:	90 93 27 01 	sts	0x0127, r25
    4ccc:	80 93 26 01 	sts	0x0126, r24
					SREG=sreg;
    4cd0:	2f bf       	out	0x3f, r18	; 63
    4cd2:	03 c0       	rjmp	.+6      	; 0x4cda <main+0x6b4>
				}
				else	// If sample has been loaded already
				{
					TransferSdByte(DUMMY_BYTE);		// Send a padding byte to the SD
    4cd4:	8f ef       	ldi	r24, 0xFF	; 255
    4cd6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				}

				bytesLeftInBlock--;			// One less byte in the block write.
    4cda:	80 91 c2 05 	lds	r24, 0x05C2
    4cde:	90 91 c3 05 	lds	r25, 0x05C3
    4ce2:	01 97       	sbiw	r24, 0x01	; 1
    4ce4:	90 93 c3 05 	sts	0x05C3, r25
    4ce8:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)				// Loop through bytes to send to card (note, this executes zero times if there are no bytes left)
    4cec:	33 94       	inc	r3
    4cee:	83 2d       	mov	r24, r3
    4cf0:	90 e0       	ldi	r25, 0x00	; 0
    4cf2:	84 15       	cp	r24, r4
    4cf4:	95 05       	cpc	r25, r5
    4cf6:	08 f4       	brcc	.+2      	; 0x4cfa <main+0x6d4>
    4cf8:	a4 cf       	rjmp	.-184    	; 0x4c42 <main+0x61c>

				bytesLeftInBlock--;			// One less byte in the block write.
			}

			// Have we written an entire block?
			if(bytesLeftInBlock==0)		// Handle closing this block
    4cfa:	80 91 c2 05 	lds	r24, 0x05C2
    4cfe:	90 91 c3 05 	lds	r25, 0x05C3
    4d02:	89 2b       	or	r24, r25
    4d04:	09 f0       	breq	.+2      	; 0x4d08 <main+0x6e2>
    4d06:	23 c3       	rjmp	.+1606   	; 0x534e <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4d08:	8f ef       	ldi	r24, 0xFF	; 255
    4d0a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4d0e:	8f ef       	ldi	r24, 0xFF	; 255
    4d10:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4d14:	8f ef       	ldi	r24, 0xFF	; 255
    4d16:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4d1a:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4d1c:	85 30       	cpi	r24, 0x05	; 5
    4d1e:	09 f0       	breq	.+2      	; 0x4d22 <main+0x6fc>
    4d20:	ff cd       	rjmp	.-1026   	; 0x4920 <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4d22:	62 e6       	ldi	r22, 0x62	; 98
    4d24:	72 e0       	ldi	r23, 0x02	; 2
    4d26:	83 e0       	ldi	r24, 0x03	; 3
    4d28:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
					cardState=SD_WRITE_CARD_WAIT;			// Hang while card is writing and wait until we can move on.
    4d2c:	84 e0       	ldi	r24, 0x04	; 4
    4d2e:	a1 c2       	rjmp	.+1346   	; 0x5272 <main+0xc4c>
				}
			}
			break;

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
    4d30:	83 e0       	ldi	r24, 0x03	; 3
    4d32:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4d36:	81 11       	cpse	r24, r1
    4d38:	f3 cd       	rjmp	.-1050   	; 0x4920 <main+0x2fa>
    4d3a:	b4 e0       	ldi	r27, 0x04	; 4
    4d3c:	5b 2e       	mov	r5, r27
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4d3e:	8f ef       	ldi	r24, 0xFF	; 255
    4d40:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4d44:	8f 3f       	cpi	r24, 0xFF	; 255
    4d46:	09 f4       	brne	.+2      	; 0x4d4a <main+0x724>
    4d48:	1e c3       	rjmp	.+1596   	; 0x5386 <main+0xd60>
    4d4a:	5a 94       	dec	r5

			case SD_WRITE_CARD_WAIT:				// The SD card is spinning and we're waiting on it to continue writing (or ending the sample transfer)
			if(!(CheckTimer(TIMER_SD)))				// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4d4c:	c1 f7       	brne	.-16     	; 0x4d3e <main+0x718>
    4d4e:	ff c2       	rjmp	.+1534   	; 0x534e <main+0xd28>

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4d50:	80 91 c8 00 	lds	r24, 0x00C8
    4d54:	86 ff       	sbrs	r24, 6
    4d56:	fc cf       	rjmp	.-8      	; 0x4d50 <main+0x72a>
						;

					if(sdCardSampleRemaining)	// This block is done.  Any bytes still need to be written to the card?
    4d58:	80 91 1e 01 	lds	r24, 0x011E
    4d5c:	90 91 1f 01 	lds	r25, 0x011F
    4d60:	a0 91 20 01 	lds	r26, 0x0120
    4d64:	b0 91 21 01 	lds	r27, 0x0121
    4d68:	89 2b       	or	r24, r25
    4d6a:	8a 2b       	or	r24, r26
    4d6c:	8b 2b       	or	r24, r27
    4d6e:	11 f0       	breq	.+4      	; 0x4d74 <main+0x74e>
					{
						cardState=SD_WRITE_FIFO_WAIT;	// Poll the FIFO until we have enough bytes in it to start another block write
    4d70:	85 e0       	ldi	r24, 0x05	; 5
    4d72:	7f c2       	rjmp	.+1278   	; 0x5272 <main+0xc4c>
					}
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
    4d74:	40 90 63 05 	lds	r4, 0x0563
    4d78:	50 90 64 05 	lds	r5, 0x0564
    4d7c:	c2 01       	movw	r24, r4
    4d7e:	0e 94 ee 08 	call	0x11dc	; 0x11dc <CheckSdSlotFull>
    4d82:	81 11       	cpse	r24, r1
    4d84:	2d c2       	rjmp	.+1114   	; 0x51e0 <main+0xbba>
{
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
    4d86:	f2 01       	movw	r30, r4
    4d88:	a3 e0       	ldi	r26, 0x03	; 3
    4d8a:	f6 95       	lsr	r31
    4d8c:	e7 95       	ror	r30
    4d8e:	aa 95       	dec	r26
    4d90:	e1 f7       	brne	.-8      	; 0x4d8a <main+0x764>
		}

		State();				// Execute the current program state.
	}
	return(0);
}
    4d92:	ff 27       	eor	r31, r31
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)

	sampleToc[theByte]|=(1<<theBit);	// Set it
    4d94:	e2 59       	subi	r30, 0x92	; 146
    4d96:	fa 4f       	sbci	r31, 0xFA	; 250
	unsigned char
		theByte,
		theBit;

	theByte=theSlot/8;		// Get the byte the bit is in (ie, slot 1 is in 1/8 = byte 0)
	theBit=theSlot%8;		// Get the bit within the byte that is our flag (ie, slot one is 1 mod 8, or 1)
    4d98:	27 e0       	ldi	r18, 0x07	; 7
    4d9a:	42 22       	and	r4, r18
    4d9c:	55 24       	eor	r5, r5

	sampleToc[theByte]|=(1<<theBit);	// Set it
    4d9e:	a7 01       	movw	r20, r14
    4da0:	02 c0       	rjmp	.+4      	; 0x4da6 <main+0x780>
    4da2:	44 0f       	add	r20, r20
    4da4:	55 1f       	adc	r21, r21
    4da6:	4a 94       	dec	r4
    4da8:	e2 f7       	brpl	.-8      	; 0x4da2 <main+0x77c>
    4daa:	80 81       	ld	r24, Z
    4dac:	84 2b       	or	r24, r20
    4dae:	80 83       	st	Z, r24
					else	// We've written the entire sample to the SD card, and the SD card block write is done.  Write the TOC if needed.
					{
						if(!(CheckSdSlotFull(sdCurrentSlot)))		// Don't bother updating TOC on SD if this slot is already full.
						{
							MarkSdSlotFull(sdCurrentSlot);			// Update toc on card to show that this slot has been filled.
							cardState=SD_TOC_WRITE_START;					// Now write the table of contents
    4db0:	86 e0       	ldi	r24, 0x06	; 6
    4db2:	5f c2       	rjmp	.+1214   	; 0x5272 <main+0xc4c>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_WRITE_FIFO_WAIT:		// After we write a block to the card, we wait for the fifo to be full (or full enough) to do another block write.
			sreg=SREG;						// Pause ISR since ISR can be messing with the following variable
    4db4:	2f b7       	in	r18, 0x3f	; 63
			cli();
    4db6:	f8 94       	cli
			if((sdBytesInFifo>=SD_BLOCK_LENGTH)||(sdBytesInFifo>=sdCardSampleRemaining))	// Fifo has full block OR what's left of the sample is less than a block AND loaded in the FIFO.
    4db8:	80 91 26 01 	lds	r24, 0x0126
    4dbc:	90 91 27 01 	lds	r25, 0x0127
    4dc0:	81 15       	cp	r24, r1
    4dc2:	92 40       	sbci	r25, 0x02	; 2
    4dc4:	98 f4       	brcc	.+38     	; 0x4dec <main+0x7c6>
    4dc6:	80 91 26 01 	lds	r24, 0x0126
    4dca:	90 91 27 01 	lds	r25, 0x0127
    4dce:	40 91 1e 01 	lds	r20, 0x011E
    4dd2:	50 91 1f 01 	lds	r21, 0x011F
    4dd6:	60 91 20 01 	lds	r22, 0x0120
    4dda:	70 91 21 01 	lds	r23, 0x0121
    4dde:	a0 e0       	ldi	r26, 0x00	; 0
    4de0:	b0 e0       	ldi	r27, 0x00	; 0
    4de2:	84 17       	cp	r24, r20
    4de4:	95 07       	cpc	r25, r21
    4de6:	a6 07       	cpc	r26, r22
    4de8:	b7 07       	cpc	r27, r23
    4dea:	58 f1       	brcs	.+86     	; 0x4e42 <main+0x81c>
			{
				SREG=sreg;																	// Done reading ISR variables.
    4dec:	2f bf       	out	0x3f, r18	; 63
				sdCurrentBlockOffset++;		// On to the next
    4dee:	20 91 b5 05 	lds	r18, 0x05B5
    4df2:	30 91 b6 05 	lds	r19, 0x05B6
    4df6:	2f 5f       	subi	r18, 0xFF	; 255
    4df8:	3f 4f       	sbci	r19, 0xFF	; 255
    4dfa:	30 93 b6 05 	sts	0x05B6, r19
    4dfe:	20 93 b5 05 	sts	0x05B5, r18

				if(SdBeginSingleBlockWrite(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block write.
    4e02:	60 91 b1 05 	lds	r22, 0x05B1
    4e06:	70 91 b2 05 	lds	r23, 0x05B2
    4e0a:	80 91 b3 05 	lds	r24, 0x05B3
    4e0e:	90 91 b4 05 	lds	r25, 0x05B4
    4e12:	62 0f       	add	r22, r18
    4e14:	73 1f       	adc	r23, r19
    4e16:	81 1d       	adc	r24, r1
    4e18:	91 1d       	adc	r25, r1
    4e1a:	0e 94 02 23 	call	0x4604	; 0x4604 <SdBeginSingleBlockWrite>
    4e1e:	81 30       	cpi	r24, 0x01	; 1
    4e20:	09 f0       	breq	.+2      	; 0x4e24 <main+0x7fe>
    4e22:	7e cd       	rjmp	.-1284   	; 0x4920 <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;			// Entire block left
    4e24:	10 93 c3 05 	sts	0x05C3, r17
    4e28:	00 93 c2 05 	sts	0x05C2, r16

					TransferSdByte(DUMMY_BYTE);			// Send a pad
    4e2c:	8f ef       	ldi	r24, 0xFF	; 255
    4e2e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);			// Send another pad
    4e32:	8f ef       	ldi	r24, 0xFF	; 255
    4e34:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(0xFE);				// Send DATA_START token
    4e38:	8e ef       	ldi	r24, 0xFE	; 254
    4e3a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					cardState=SD_WRITING_BLOCK;			// Return to regular write state (fifo has filled)
    4e3e:	83 e0       	ldi	r24, 0x03	; 3
    4e40:	18 c2       	rjmp	.+1072   	; 0x5272 <main+0xc4c>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// Bytes remaining in sample, but not enough in the fifo yet
			{
				SREG=sreg;			// Done reading ISR variables.
    4e42:	2f bf       	out	0x3f, r18	; 63
    4e44:	84 c2       	rjmp	.+1288   	; 0x534e <main+0xd28>
// --------------------------------------------------------------------------------------------------------------------------------------
// Writing TOC to the Card	-------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_TOC_WRITE_START:					// Write important stuff to TOC first, then transfer the rest via normal write procedure
			if(SdBeginSingleBlockWrite(0)==true)		// Start writing to block 0.
    4e46:	60 e0       	ldi	r22, 0x00	; 0
    4e48:	70 e0       	ldi	r23, 0x00	; 0
    4e4a:	cb 01       	movw	r24, r22
    4e4c:	0e 94 02 23 	call	0x4604	; 0x4604 <SdBeginSingleBlockWrite>
    4e50:	81 30       	cpi	r24, 0x01	; 1
    4e52:	09 f0       	breq	.+2      	; 0x4e56 <main+0x830>
    4e54:	65 cd       	rjmp	.-1334   	; 0x4920 <main+0x2fa>
			{
				bytesLeftInBlock=SD_BLOCK_LENGTH;	// Whole block left
    4e56:	10 93 c3 05 	sts	0x05C3, r17
    4e5a:	00 93 c2 05 	sts	0x05C2, r16

				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4e5e:	8f ef       	ldi	r24, 0xFF	; 255
    4e60:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);			// Send another pad
    4e64:	8f ef       	ldi	r24, 0xFF	; 255
    4e66:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte(0xFE);				// Send DATA_START token
    4e6a:	8e ef       	ldi	r24, 0xFE	; 254
    4e6c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('W');				// Write out string to indicate that this is a WTPA card
    4e70:	87 e5       	ldi	r24, 0x57	; 87
    4e72:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('T');
    4e76:	84 e5       	ldi	r24, 0x54	; 84
    4e78:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('P');
    4e7c:	80 e5       	ldi	r24, 0x50	; 80
    4e7e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('A');
    4e82:	81 e4       	ldi	r24, 0x41	; 65
    4e84:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('S');				// These four characters indicate this card holds sample data (as opposed to Nintendo DPCMs, or a boot image)
    4e88:	83 e5       	ldi	r24, 0x53	; 83
    4e8a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('A');
    4e8e:	81 e4       	ldi	r24, 0x41	; 65
    4e90:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('M');
    4e94:	8d e4       	ldi	r24, 0x4D	; 77
    4e96:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte('P');
    4e9a:	80 e5       	ldi	r24, 0x50	; 80
    4e9c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>

				bytesLeftInBlock-=8;
    4ea0:	80 91 c2 05 	lds	r24, 0x05C2
    4ea4:	90 91 c3 05 	lds	r25, 0x05C3
    4ea8:	08 97       	sbiw	r24, 0x08	; 8
    4eaa:	90 93 c3 05 	sts	0x05C3, r25
    4eae:	80 93 c2 05 	sts	0x05C2, r24
    4eb2:	e8 e0       	ldi	r30, 0x08	; 8
    4eb4:	5e 2e       	mov	r5, r30

				for(i=0;i<8;i++)					// 8 don't care bytes
				{
					TransferSdByte('x');
    4eb6:	88 e7       	ldi	r24, 0x78	; 120
    4eb8:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4ebc:	5a 94       	dec	r5
				TransferSdByte('M');
				TransferSdByte('P');

				bytesLeftInBlock-=8;

				for(i=0;i<8;i++)					// 8 don't care bytes
    4ebe:	d9 f7       	brne	.-10     	; 0x4eb6 <main+0x890>
				{
					TransferSdByte('x');
				}

				bytesLeftInBlock-=8;
    4ec0:	80 91 c2 05 	lds	r24, 0x05C2
    4ec4:	90 91 c3 05 	lds	r25, 0x05C3
    4ec8:	08 97       	sbiw	r24, 0x08	; 8
    4eca:	90 93 c3 05 	sts	0x05C3, r25
    4ece:	80 93 c2 05 	sts	0x05C2, r24
    4ed2:	7e e6       	ldi	r23, 0x6E	; 110
    4ed4:	47 2e       	mov	r4, r23
    4ed6:	75 e0       	ldi	r23, 0x05	; 5
    4ed8:	57 2e       	mov	r5, r23

				for(i=0;i<64;i++)					// Write table of contents.
				{
					TransferSdByte(sampleToc[i]);
    4eda:	f2 01       	movw	r30, r4
    4edc:	81 91       	ld	r24, Z+
    4ede:	2f 01       	movw	r4, r30
    4ee0:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte('x');
				}

				bytesLeftInBlock-=8;

				for(i=0;i<64;i++)					// Write table of contents.
    4ee4:	fe ea       	ldi	r31, 0xAE	; 174
    4ee6:	4f 16       	cp	r4, r31
    4ee8:	f5 e0       	ldi	r31, 0x05	; 5
    4eea:	5f 06       	cpc	r5, r31
    4eec:	b1 f7       	brne	.-20     	; 0x4eda <main+0x8b4>
				{
					TransferSdByte(sampleToc[i]);
				}

				bytesLeftInBlock-=64;						// shave off bytes from block counter
    4eee:	80 91 c2 05 	lds	r24, 0x05C2
    4ef2:	90 91 c3 05 	lds	r25, 0x05C3
    4ef6:	80 54       	subi	r24, 0x40	; 64
    4ef8:	91 09       	sbc	r25, r1
    4efa:	90 93 c3 05 	sts	0x05C3, r25
    4efe:	80 93 c2 05 	sts	0x05C2, r24
				cardState=SD_TOC_WRITE_CONTINUE;			// Now update the rest of the TOC block until it is full.
    4f02:	70 92 59 05 	sts	0x0559, r7
    4f06:	23 c2       	rjmp	.+1094   	; 0x534e <main+0xd28>
    4f08:	40 90 c2 05 	lds	r4, 0x05C2
    4f0c:	50 90 c3 05 	lds	r5, 0x05C3
    4f10:	21 e4       	ldi	r18, 0x41	; 65
    4f12:	42 16       	cp	r4, r18
    4f14:	51 04       	cpc	r5, r1
    4f16:	18 f0       	brcs	.+6      	; 0x4f1e <main+0x8f8>
    4f18:	60 e4       	ldi	r22, 0x40	; 64
    4f1a:	46 2e       	mov	r4, r22
    4f1c:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4f1e:	31 2c       	mov	r3, r1
    4f20:	0d c0       	rjmp	.+26     	; 0x4f3c <main+0x916>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
    4f22:	8f ef       	ldi	r24, 0xFF	; 255
    4f24:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				bytesLeftInBlock--;					// One less byte to send.
    4f28:	80 91 c2 05 	lds	r24, 0x05C2
    4f2c:	90 91 c3 05 	lds	r25, 0x05C3
    4f30:	01 97       	sbiw	r24, 0x01	; 1
    4f32:	90 93 c3 05 	sts	0x05C3, r25
    4f36:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, send the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)
    4f3a:	33 94       	inc	r3
    4f3c:	83 2d       	mov	r24, r3
    4f3e:	90 e0       	ldi	r25, 0x00	; 0
    4f40:	84 15       	cp	r24, r4
    4f42:	95 05       	cpc	r25, r5
    4f44:	70 f3       	brcs	.-36     	; 0x4f22 <main+0x8fc>
			{
				TransferSdByte(DUMMY_BYTE);			// Send a pad
				bytesLeftInBlock--;					// One less byte to send.
			}

			if(bytesLeftInBlock==0)					// Handle closing this block
    4f46:	80 91 c2 05 	lds	r24, 0x05C2
    4f4a:	90 91 c3 05 	lds	r25, 0x05C3
    4f4e:	89 2b       	or	r24, r25
    4f50:	09 f0       	breq	.+2      	; 0x4f54 <main+0x92e>
    4f52:	fd c1       	rjmp	.+1018   	; 0x534e <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4f54:	8f ef       	ldi	r24, 0xFF	; 255
    4f56:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);				// Send poo poo checksum
    4f5a:	8f ef       	ldi	r24, 0xFF	; 255
    4f5c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				theByte=(TransferSdByte(DUMMY_BYTE)&0x1F);	//	Get Error code
    4f60:	8f ef       	ldi	r24, 0xFF	; 255
    4f62:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4f66:	8f 71       	andi	r24, 0x1F	; 31

				if(theByte==0x05)							// 	A good write!  Expect to be busy for a long time.
    4f68:	85 30       	cpi	r24, 0x05	; 5
    4f6a:	09 f0       	breq	.+2      	; 0x4f6e <main+0x948>
    4f6c:	d9 cc       	rjmp	.-1614   	; 0x4920 <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/2));			// 500mS timeout, card is busy.
    4f6e:	62 e6       	ldi	r22, 0x62	; 98
    4f70:	72 e0       	ldi	r23, 0x02	; 2
    4f72:	83 e0       	ldi	r24, 0x03	; 3
    4f74:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
					cardState=SD_TOC_WRITE_FINISH;			// Now wait for the TOC to get done writing
    4f78:	80 92 59 05 	sts	0x0559, r8
    4f7c:	e8 c1       	rjmp	.+976    	; 0x534e <main+0xd28>
				}
			}
			break;

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4f7e:	83 e0       	ldi	r24, 0x03	; 3
    4f80:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4f84:	81 11       	cpse	r24, r1
    4f86:	cc cc       	rjmp	.-1640   	; 0x4920 <main+0x2fa>
    4f88:	54 e0       	ldi	r21, 0x04	; 4
    4f8a:	55 2e       	mov	r5, r21
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4f8c:	8f ef       	ldi	r24, 0xFF	; 255
    4f8e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					if(theByte!=0xFF)					// Line should send zeros while programming, and send return high when programming is done.
    4f92:	8f 3f       	cpi	r24, 0xFF	; 255
    4f94:	09 f4       	brne	.+2      	; 0x4f98 <main+0x972>
    4f96:	fd c1       	rjmp	.+1018   	; 0x5392 <main+0xd6c>
    4f98:	5a 94       	dec	r5

			case SD_TOC_WRITE_FINISH:			// Spin until the TOC has finished writing.
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is done writing
    4f9a:	c1 f7       	brne	.-16     	; 0x4f8c <main+0x966>
    4f9c:	d8 c1       	rjmp	.+944    	; 0x534e <main+0xd28>

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    4f9e:	80 91 c8 00 	lds	r24, 0x00C8
    4fa2:	86 ff       	sbrs	r24, 6
    4fa4:	fc cf       	rjmp	.-8      	; 0x4f9e <main+0x978>
    4fa6:	1c c1       	rjmp	.+568    	; 0x51e0 <main+0xbba>
// --------------------------------------------------------------------------------------------------------------------------------------
// Reading Samples from the Card -------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------------------------

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
    4fa8:	83 e0       	ldi	r24, 0x03	; 3
    4faa:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    4fae:	81 11       	cpse	r24, r1
    4fb0:	b7 cc       	rjmp	.-1682   	; 0x4920 <main+0x2fa>
    4fb2:	44 e0       	ldi	r20, 0x04	; 4
    4fb4:	54 2e       	mov	r5, r20
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    4fb6:	8f ef       	ldi	r24, 0xFF	; 255
    4fb8:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    4fbc:	8f 3f       	cpi	r24, 0xFF	; 255
    4fbe:	19 f4       	brne	.+6      	; 0x4fc6 <main+0x9a0>
    4fc0:	5a 94       	dec	r5

			case SD_READ_START:					// We already sent the first read command.  Wait for the correct token to come up, then get length of sample and start the state machine moving
			if(!(CheckTimer(TIMER_SD)))			// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    4fc2:	c9 f7       	brne	.-14     	; 0x4fb6 <main+0x990>
    4fc4:	c4 c1       	rjmp	.+904    	; 0x534e <main+0xd28>
					{
						i=4;	// Got a result, stop polling
					}
				}

				if(theByte==0xFE)	// Got a start token!
    4fc6:	8e 3f       	cpi	r24, 0xFE	; 254
    4fc8:	09 f0       	breq	.+2      	; 0x4fcc <main+0x9a6>
    4fca:	aa cc       	rjmp	.-1708   	; 0x4920 <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;		// Entire read block left
    4fcc:	10 93 c3 05 	sts	0x05C3, r17
    4fd0:	00 93 c2 05 	sts	0x05C2, r16

					sdCardSampleRemaining=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<24);		// First four bytes are the 32-bit sample length.  Get it, and mark this as the amount of sample left to pull from the SD.
    4fd4:	8f ef       	ldi	r24, 0xFF	; 255
    4fd6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    4fda:	90 e0       	ldi	r25, 0x00	; 0
    4fdc:	a0 e0       	ldi	r26, 0x00	; 0
    4fde:	b0 e0       	ldi	r27, 0x00	; 0
    4fe0:	b8 2f       	mov	r27, r24
    4fe2:	aa 27       	eor	r26, r26
    4fe4:	99 27       	eor	r25, r25
    4fe6:	88 27       	eor	r24, r24
    4fe8:	80 93 1e 01 	sts	0x011E, r24
    4fec:	90 93 1f 01 	sts	0x011F, r25
    4ff0:	a0 93 20 01 	sts	0x0120, r26
    4ff4:	b0 93 21 01 	sts	0x0121, r27
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<16);
    4ff8:	20 90 1e 01 	lds	r2, 0x011E
    4ffc:	30 90 1f 01 	lds	r3, 0x011F
    5000:	40 90 20 01 	lds	r4, 0x0120
    5004:	50 90 21 01 	lds	r5, 0x0121
    5008:	8f ef       	ldi	r24, 0xFF	; 255
    500a:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    500e:	b2 01       	movw	r22, r4
    5010:	a1 01       	movw	r20, r2
    5012:	68 2b       	or	r22, r24
    5014:	40 93 1e 01 	sts	0x011E, r20
    5018:	50 93 1f 01 	sts	0x011F, r21
    501c:	60 93 20 01 	sts	0x0120, r22
    5020:	70 93 21 01 	sts	0x0121, r23
					sdCardSampleRemaining|=(((unsigned long)(TransferSdByte(DUMMY_BYTE))&0xFF)<<8);
    5024:	20 90 1e 01 	lds	r2, 0x011E
    5028:	30 90 1f 01 	lds	r3, 0x011F
    502c:	40 90 20 01 	lds	r4, 0x0120
    5030:	50 90 21 01 	lds	r5, 0x0121
    5034:	8f ef       	ldi	r24, 0xFF	; 255
    5036:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    503a:	a2 01       	movw	r20, r4
    503c:	91 01       	movw	r18, r2
    503e:	38 2b       	or	r19, r24
    5040:	20 93 1e 01 	sts	0x011E, r18
    5044:	30 93 1f 01 	sts	0x011F, r19
    5048:	40 93 20 01 	sts	0x0120, r20
    504c:	50 93 21 01 	sts	0x0121, r21
					sdCardSampleRemaining|=(TransferSdByte(DUMMY_BYTE));
    5050:	20 90 1e 01 	lds	r2, 0x011E
    5054:	30 90 1f 01 	lds	r3, 0x011F
    5058:	40 90 20 01 	lds	r4, 0x0120
    505c:	50 90 21 01 	lds	r5, 0x0121
    5060:	8f ef       	ldi	r24, 0xFF	; 255
    5062:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    5066:	b2 01       	movw	r22, r4
    5068:	a1 01       	movw	r20, r2
    506a:	48 2b       	or	r20, r24
    506c:	db 01       	movw	r26, r22
    506e:	ca 01       	movw	r24, r20
    5070:	80 93 1e 01 	sts	0x011E, r24
    5074:	90 93 1f 01 	sts	0x011F, r25
    5078:	a0 93 20 01 	sts	0x0120, r26
    507c:	b0 93 21 01 	sts	0x0121, r27

					sdRamSampleRemaining=sdCardSampleRemaining;	// Entire sample == amount to pull from the SD == amount to write to RAM
    5080:	80 91 1e 01 	lds	r24, 0x011E
    5084:	90 91 1f 01 	lds	r25, 0x011F
    5088:	a0 91 20 01 	lds	r26, 0x0120
    508c:	b0 91 21 01 	lds	r27, 0x0121
    5090:	80 93 22 01 	sts	0x0122, r24
    5094:	90 93 23 01 	sts	0x0123, r25
    5098:	a0 93 24 01 	sts	0x0124, r26
    509c:	b0 93 25 01 	sts	0x0125, r27

					bytesLeftInBlock-=4;				// Keep track of where we are in the block
    50a0:	80 91 c2 05 	lds	r24, 0x05C2
    50a4:	90 91 c3 05 	lds	r25, 0x05C3
    50a8:	04 97       	sbiw	r24, 0x04	; 4
    50aa:	90 93 c3 05 	sts	0x05C3, r25
    50ae:	80 93 c2 05 	sts	0x05C2, r24
    50b2:	fa c0       	rjmp	.+500    	; 0x52a8 <main+0xc82>
				ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
			}
			break;

			case SD_READING_BLOCK:			// Block has been successfully opened for reading.  Keep getting bytes are reading them into the FIFO until we're done with the block OR done with the sample.
			if(sdAbortRead==true)			// If we need to abort the read, we can do it right away since we are inhaling data bytes
    50b4:	80 91 b7 05 	lds	r24, 0x05B7
    50b8:	81 30       	cpi	r24, 0x01	; 1
    50ba:	09 f4       	brne	.+2      	; 0x50be <main+0xa98>
    50bc:	fd c0       	rjmp	.+506    	; 0x52b8 <main+0xc92>
    50be:	40 90 c2 05 	lds	r4, 0x05C2
    50c2:	50 90 c3 05 	lds	r5, 0x05C3
    50c6:	51 e4       	ldi	r21, 0x41	; 65
    50c8:	45 16       	cp	r4, r21
    50ca:	51 04       	cpc	r5, r1
    50cc:	18 f0       	brcs	.+6      	; 0x50d4 <main+0xaae>
    50ce:	20 e4       	ldi	r18, 0x40	; 64
    50d0:	42 2e       	mov	r4, r18
    50d2:	51 2c       	mov	r5, r1
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    50d4:	31 2c       	mov	r3, r1
    50d6:	55 c0       	rjmp	.+170    	; 0x5182 <main+0xb5c>
				{
					tempSample=TransferSdByte(DUMMY_BYTE);	// Get the byte (keep it signed, since it's a likely to be a sample)
    50d8:	8f ef       	ldi	r24, 0xFF	; 255
    50da:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					bytesLeftInBlock--;						// One less byte in the block read.
    50de:	20 91 c2 05 	lds	r18, 0x05C2
    50e2:	30 91 c3 05 	lds	r19, 0x05C3
    50e6:	21 50       	subi	r18, 0x01	; 1
    50e8:	31 09       	sbc	r19, r1
    50ea:	30 93 c3 05 	sts	0x05C3, r19
    50ee:	20 93 c2 05 	sts	0x05C2, r18

					if(sdCardSampleRemaining)					// Was that a byte of the sample?  If not just do nothing with it.
    50f2:	40 91 1e 01 	lds	r20, 0x011E
    50f6:	50 91 1f 01 	lds	r21, 0x011F
    50fa:	60 91 20 01 	lds	r22, 0x0120
    50fe:	70 91 21 01 	lds	r23, 0x0121
    5102:	45 2b       	or	r20, r21
    5104:	46 2b       	or	r20, r22
    5106:	47 2b       	or	r20, r23
    5108:	d9 f1       	breq	.+118    	; 0x5180 <main+0xb5a>
					{
						sdCardSampleRemaining--;				// One less sample byte.
    510a:	40 91 1e 01 	lds	r20, 0x011E
    510e:	50 91 1f 01 	lds	r21, 0x011F
    5112:	60 91 20 01 	lds	r22, 0x0120
    5116:	70 91 21 01 	lds	r23, 0x0121
    511a:	41 50       	subi	r20, 0x01	; 1
    511c:	51 09       	sbc	r21, r1
    511e:	61 09       	sbc	r22, r1
    5120:	71 09       	sbc	r23, r1
    5122:	40 93 1e 01 	sts	0x011E, r20
    5126:	50 93 1f 01 	sts	0x011F, r21
    512a:	60 93 20 01 	sts	0x0120, r22
    512e:	70 93 21 01 	sts	0x0121, r23

						sdFifo[sdFifoWritePointer]=tempSample;	// Put it in the fifo
    5132:	e0 91 28 01 	lds	r30, 0x0128
    5136:	f0 91 29 01 	lds	r31, 0x0129
    513a:	e4 5d       	subi	r30, 0xD4	; 212
    513c:	fe 4f       	sbci	r31, 0xFE	; 254
    513e:	80 83       	st	Z, r24
						sdFifoWritePointer++;				// Move to next spot in fifo
    5140:	80 91 28 01 	lds	r24, 0x0128
    5144:	90 91 29 01 	lds	r25, 0x0129
    5148:	01 96       	adiw	r24, 0x01	; 1
    514a:	90 93 29 01 	sts	0x0129, r25
    514e:	80 93 28 01 	sts	0x0128, r24

						if(sdFifoWritePointer>=SD_FIFO_SIZE)	// Handle wrapping around end of fifo
    5152:	80 91 28 01 	lds	r24, 0x0128
    5156:	90 91 29 01 	lds	r25, 0x0129
    515a:	81 15       	cp	r24, r1
    515c:	93 40       	sbci	r25, 0x03	; 3
    515e:	20 f0       	brcs	.+8      	; 0x5168 <main+0xb42>
						{
							sdFifoWritePointer=0;
    5160:	10 92 29 01 	sts	0x0129, r1
    5164:	10 92 28 01 	sts	0x0128, r1
						}

						sreg=SREG;			// Pause ISR since ISR can be messing with the following variable
    5168:	2f b7       	in	r18, 0x3f	; 63
						cli();
    516a:	f8 94       	cli
						sdBytesInFifo++;	// Stored one more byte.
    516c:	80 91 26 01 	lds	r24, 0x0126
    5170:	90 91 27 01 	lds	r25, 0x0127
    5174:	01 96       	adiw	r24, 0x01	; 1
    5176:	90 93 27 01 	sts	0x0127, r25
    517a:	80 93 26 01 	sts	0x0126, r24
						SREG=sreg;
    517e:	2f bf       	out	0x3f, r18	; 63
				else	// Less than a chunk left in the block, read the rest of the block.
				{
					numTransferBytes=bytesLeftInBlock;
				}

				for(i=0;i<numTransferBytes;i++)				// Loop through bytes to get from card (note, this executes zero times if we are waiting for our fifo to have space)
    5180:	33 94       	inc	r3
    5182:	83 2d       	mov	r24, r3
    5184:	90 e0       	ldi	r25, 0x00	; 0
    5186:	84 15       	cp	r24, r4
    5188:	95 05       	cpc	r25, r5
    518a:	08 f4       	brcc	.+2      	; 0x518e <main+0xb68>
    518c:	a5 cf       	rjmp	.-182    	; 0x50d8 <main+0xab2>
						SREG=sreg;
					}
				}

				// Check done-ness of block read:
				if(bytesLeftInBlock==0)		// Handle closing this block
    518e:	80 91 c2 05 	lds	r24, 0x05C2
    5192:	90 91 c3 05 	lds	r25, 0x05C3
    5196:	89 2b       	or	r24, r25
    5198:	09 f0       	breq	.+2      	; 0x519c <main+0xb76>
    519a:	d9 c0       	rjmp	.+434    	; 0x534e <main+0xd28>
				{
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    519c:	8f ef       	ldi	r24, 0xFF	; 255
    519e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    51a2:	8f ef       	ldi	r24, 0xFF	; 255
    51a4:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    51a8:	80 91 c8 00 	lds	r24, 0x00C8
    51ac:	86 ff       	sbrs	r24, 6
    51ae:	fc cf       	rjmp	.-8      	; 0x51a8 <main+0xb82>
						;

					EndSdTransfer();				// Bring CS high
    51b0:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    51b4:	8f ef       	ldi	r24, 0xFF	; 255
    51b6:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					cardState=SD_READ_FIFO_WAIT;	// Wait for fifo have enough room for another block OR the remainder of the sample
    51ba:	60 92 59 05 	sts	0x0559, r6

					if(sdCardSampleRemaining==0)	// Block is done AND sample is done too.  Make SD state machine idle (ready) again.
    51be:	80 91 1e 01 	lds	r24, 0x011E
    51c2:	90 91 1f 01 	lds	r25, 0x011F
    51c6:	a0 91 20 01 	lds	r26, 0x0120
    51ca:	b0 91 21 01 	lds	r27, 0x0121
    51ce:	89 2b       	or	r24, r25
    51d0:	8a 2b       	or	r24, r26
    51d2:	8b 2b       	or	r24, r27
    51d4:	09 f0       	breq	.+2      	; 0x51d8 <main+0xbb2>
    51d6:	bb c0       	rjmp	.+374    	; 0x534e <main+0xd28>
					{
						while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    51d8:	80 91 c8 00 	lds	r24, 0x00C8
    51dc:	86 ff       	sbrs	r24, 6
    51de:	fc cf       	rjmp	.-8      	; 0x51d8 <main+0xbb2>
							;
						cardState=SD_IDLE;				// DONE!  Reset SD state machine for next time.
    51e0:	b0 92 59 05 	sts	0x0559, r11
    51e4:	b4 c0       	rjmp	.+360    	; 0x534e <main+0xd28>
				}
			}
			break;

			case SD_READ_FIFO_WAIT:		// Have finished reading a block, wait until the ISR has gone through enough of the sample such that there's either room for another whole block in the FIFO, or room for the remaining sample
			sreg=SREG;					// Pause ISR since ISR can be messing with the following variable
    51e6:	ef b7       	in	r30, 0x3f	; 63
			cli();
    51e8:	f8 94       	cli

			if(((SD_FIFO_SIZE-sdBytesInFifo)>=SD_BLOCK_LENGTH)||((SD_FIFO_SIZE-sdBytesInFifo)>=sdCardSampleRemaining))			// We have a block of space available in our fifo OR do we have enough room for the entire remainder of the sample?
    51ea:	20 91 26 01 	lds	r18, 0x0126
    51ee:	30 91 27 01 	lds	r19, 0x0127
    51f2:	80 e0       	ldi	r24, 0x00	; 0
    51f4:	93 e0       	ldi	r25, 0x03	; 3
    51f6:	ac 01       	movw	r20, r24
    51f8:	42 1b       	sub	r20, r18
    51fa:	53 0b       	sbc	r21, r19
    51fc:	9a 01       	movw	r18, r20
    51fe:	21 15       	cp	r18, r1
    5200:	32 40       	sbci	r19, 0x02	; 2
    5202:	a8 f4       	brcc	.+42     	; 0x522e <main+0xc08>
    5204:	20 91 26 01 	lds	r18, 0x0126
    5208:	30 91 27 01 	lds	r19, 0x0127
    520c:	40 91 1e 01 	lds	r20, 0x011E
    5210:	50 91 1f 01 	lds	r21, 0x011F
    5214:	60 91 20 01 	lds	r22, 0x0120
    5218:	70 91 21 01 	lds	r23, 0x0121
    521c:	82 1b       	sub	r24, r18
    521e:	93 0b       	sbc	r25, r19
    5220:	a0 e0       	ldi	r26, 0x00	; 0
    5222:	b0 e0       	ldi	r27, 0x00	; 0
    5224:	84 17       	cp	r24, r20
    5226:	95 07       	cpc	r25, r21
    5228:	a6 07       	cpc	r26, r22
    522a:	b7 07       	cpc	r27, r23
    522c:	28 f1       	brcs	.+74     	; 0x5278 <main+0xc52>
			{
				SREG=sreg;				// ISR back on.
    522e:	ef bf       	out	0x3f, r30	; 63
				sdCurrentBlockOffset++;	// Point at next block
    5230:	20 91 b5 05 	lds	r18, 0x05B5
    5234:	30 91 b6 05 	lds	r19, 0x05B6
    5238:	2f 5f       	subi	r18, 0xFF	; 255
    523a:	3f 4f       	sbci	r19, 0xFF	; 255
    523c:	30 93 b6 05 	sts	0x05B6, r19
    5240:	20 93 b5 05 	sts	0x05B5, r18

				if(SdBeginSingleBlockRead(sdSampleStartBlock+sdCurrentBlockOffset)==true)	// Try to open the card for a single block read.
    5244:	60 91 b1 05 	lds	r22, 0x05B1
    5248:	70 91 b2 05 	lds	r23, 0x05B2
    524c:	80 91 b3 05 	lds	r24, 0x05B3
    5250:	90 91 b4 05 	lds	r25, 0x05B4
    5254:	62 0f       	add	r22, r18
    5256:	73 1f       	adc	r23, r19
    5258:	81 1d       	adc	r24, r1
    525a:	91 1d       	adc	r25, r1
    525c:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <SdBeginSingleBlockRead>
    5260:	81 30       	cpi	r24, 0x01	; 1
    5262:	09 f0       	breq	.+2      	; 0x5266 <main+0xc40>
    5264:	5d cb       	rjmp	.-2374   	; 0x4920 <main+0x2fa>
				{
					SetTimer(TIMER_SD,(SECOND/10));			// 100 mS timeout (God Forbid)
    5266:	6a e7       	ldi	r22, 0x7A	; 122
    5268:	70 e0       	ldi	r23, 0x00	; 0
    526a:	83 e0       	ldi	r24, 0x03	; 3
    526c:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <SetTimer>
					cardState=SD_READ_TOKEN_WAIT;			// SD card hasn't sent a read token yet (it'll take a bit to become ready)
    5270:	8c e0       	ldi	r24, 0x0C	; 12
    5272:	80 93 59 05 	sts	0x0559, r24
    5276:	6b c0       	rjmp	.+214    	; 0x534e <main+0xd28>
					ResetSdCard();	// Uninit any filesystem shizz, stop any transfers in progress gracefully
				}
			}
			else	// ISR has not cleared enough of the sample out of the FIFO yet.
			{
				SREG=sreg;	// ISR back on.
    5278:	ef bf       	out	0x3f, r30	; 63
    527a:	69 c0       	rjmp	.+210    	; 0x534e <main+0xd28>
			}
			break;


			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
    527c:	83 e0       	ldi	r24, 0x03	; 3
    527e:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <CheckTimer>
    5282:	81 11       	cpse	r24, r1
    5284:	4d cb       	rjmp	.-2406   	; 0x4920 <main+0x2fa>
    5286:	94 e0       	ldi	r25, 0x04	; 4
    5288:	59 2e       	mov	r5, r25
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
				{
					theByte=TransferSdByte(DUMMY_BYTE);	// Check card
    528a:	8f ef       	ldi	r24, 0xFF	; 255
    528c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
					if(theByte==0xFF)					// Line still high?  Unlike writing, the wait state here sends 0xFF
    5290:	8f 3f       	cpi	r24, 0xFF	; 255
    5292:	19 f4       	brne	.+6      	; 0x529a <main+0xc74>
    5294:	5a 94       	dec	r5

			case SD_READ_TOKEN_WAIT:		// Ready to start reading a new block as soon as we get a valid token back.
			if(!(CheckTimer(TIMER_SD)))		// Didn't timeout yet
			{
				i=0;
				while(i<4)		// Try a few times to see if the card is ready to give us data
    5296:	c9 f7       	brne	.-14     	; 0x528a <main+0xc64>
    5298:	5a c0       	rjmp	.+180    	; 0x534e <main+0xd28>
					else
					{
						i=4;	// Got a result, stop polling
					}
				}
				if(theByte==0xFE)	// Got a start token!
    529a:	8e 3f       	cpi	r24, 0xFE	; 254
    529c:	09 f0       	breq	.+2      	; 0x52a0 <main+0xc7a>
    529e:	40 cb       	rjmp	.-2432   	; 0x4920 <main+0x2fa>
				{
					bytesLeftInBlock=SD_BLOCK_LENGTH;	// Entire read block left
    52a0:	10 93 c3 05 	sts	0x05C3, r17
    52a4:	00 93 c2 05 	sts	0x05C2, r16

					cardState=SD_READING_BLOCK;		// Handle reading in the sample, or...
    52a8:	8a e0       	ldi	r24, 0x0A	; 10
    52aa:	80 93 59 05 	sts	0x0559, r24
					if(sdAbortRead==true)			// It's OK to throw away incoming bytes now if we're supposed to abort this read, since we safely got a token (if we abort pre-token, our block byte count will get messed up)
    52ae:	80 91 b7 05 	lds	r24, 0x05B7
    52b2:	81 30       	cpi	r24, 0x01	; 1
    52b4:	09 f0       	breq	.+2      	; 0x52b8 <main+0xc92>
    52b6:	4b c0       	rjmp	.+150    	; 0x534e <main+0xd28>
					{
						cardState=SD_READ_ABORT;
    52b8:	90 92 59 05 	sts	0x0559, r9
						sdAbortRead=false;
    52bc:	10 92 b7 05 	sts	0x05B7, r1
    52c0:	46 c0       	rjmp	.+140    	; 0x534e <main+0xd28>
    52c2:	40 90 c2 05 	lds	r4, 0x05C2
    52c6:	50 90 c3 05 	lds	r5, 0x05C3
    52ca:	61 e4       	ldi	r22, 0x41	; 65
    52cc:	46 16       	cp	r4, r22
    52ce:	51 04       	cpc	r5, r1
    52d0:	18 f0       	brcs	.+6      	; 0x52d8 <main+0xcb2>
    52d2:	80 e4       	ldi	r24, 0x40	; 64
    52d4:	48 2e       	mov	r4, r24
    52d6:	51 2c       	mov	r5, r1
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    52d8:	31 2c       	mov	r3, r1
    52da:	0d c0       	rjmp	.+26     	; 0x52f6 <main+0xcd0>
			{
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
    52dc:	8f ef       	ldi	r24, 0xFF	; 255
    52de:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				bytesLeftInBlock--;				// One less byte in the block read.
    52e2:	80 91 c2 05 	lds	r24, 0x05C2
    52e6:	90 91 c3 05 	lds	r25, 0x05C3
    52ea:	01 97       	sbiw	r24, 0x01	; 1
    52ec:	90 93 c3 05 	sts	0x05C3, r25
    52f0:	80 93 c2 05 	sts	0x05C2, r24
			else	// Less than a chunk left in the block, read the rest of the block.
			{
				numTransferBytes=bytesLeftInBlock;
			}

			for(i=0;i<numTransferBytes;i++)		// Loop through bytes to get from card (note, this executes zero times if for whatever reason the block is empty)
    52f4:	33 94       	inc	r3
    52f6:	83 2d       	mov	r24, r3
    52f8:	90 e0       	ldi	r25, 0x00	; 0
    52fa:	84 15       	cp	r24, r4
    52fc:	95 05       	cpc	r25, r5
    52fe:	70 f3       	brcs	.-36     	; 0x52dc <main+0xcb6>
				TransferSdByte(DUMMY_BYTE);		// Get byte and chuck it
				bytesLeftInBlock--;				// One less byte in the block read.
			}

			// Check done-ness of block read:
			if(bytesLeftInBlock==0)				// Handle closing this block
    5300:	80 91 c2 05 	lds	r24, 0x05C2
    5304:	90 91 c3 05 	lds	r25, 0x05C3
    5308:	89 2b       	or	r24, r25
    530a:	09 f5       	brne	.+66     	; 0x534e <main+0xd28>
			{
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    530c:	8f ef       	ldi	r24, 0xFF	; 255
    530e:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				TransferSdByte(DUMMY_BYTE);		// Throw out CRC
    5312:	8f ef       	ldi	r24, 0xFF	; 255
    5314:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    5318:	80 91 c8 00 	lds	r24, 0x00C8
    531c:	86 ff       	sbrs	r24, 6
    531e:	fc cf       	rjmp	.-8      	; 0x5318 <main+0xcf2>
					;

				EndSdTransfer();				// Bring CS high
    5320:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
				TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5324:	8f ef       	ldi	r24, 0xFF	; 255
    5326:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>

				while(!(UCSR1A&(1<<TXC1)))		// Spin until the last clocks go out
    532a:	80 91 c8 00 	lds	r24, 0x00C8
    532e:	86 ff       	sbrs	r24, 6
    5330:	fc cf       	rjmp	.-8      	; 0x532a <main+0xd04>
					;
				cardState=SD_IDLE;								// DONE!  Reset SD state machine....
    5332:	b0 92 59 05 	sts	0x0559, r11

				if(sdPlaybackQueued==true)	// Another SD sample queued right away?
    5336:	80 91 ba 05 	lds	r24, 0x05BA
    533a:	81 30       	cpi	r24, 0x01	; 1
    533c:	41 f4       	brne	.+16     	; 0x534e <main+0xd28>
				{
					sdPlaybackQueued=false;
    533e:	10 92 ba 05 	sts	0x05BA, r1
					PlaySampleFromSd(sdQueuedSlot);	// Trigger the next stream immediately
    5342:	80 91 b8 05 	lds	r24, 0x05B8
    5346:	90 91 b9 05 	lds	r25, 0x05B9
    534a:	0e 94 95 11 	call	0x232a	; 0x232a <PlaySampleFromSd>
		HandleSwitches();		// Flag newKeys.
		HandleEncoder();		// Keep track of encoder states and increment values.
		HandleSoftclock();		// Keep the timer timing.
		HandleLeds();			// Keep LEDs updated.
		UpdateCard();			// Keep the SD card state machine running.
		GetRandomLongInt();		// Keep random numbers rolling.
    534e:	0e 94 19 09 	call	0x1232	; 0x1232 <GetRandomLongInt>

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    5352:	0e 94 ef 1e 	call	0x3dde	; 0x3dde <Uart0GotByte>
    5356:	88 23       	and	r24, r24
    5358:	21 f0       	breq	.+8      	; 0x5362 <main+0xd3c>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    535a:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <Uart0GetByte>
    535e:	0e 94 c0 1f 	call	0x3f80	; 0x3f80 <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    5362:	0e 94 7d 20 	call	0x40fa	; 0x40fa <MidiTxBufferNotEmpty>
    5366:	88 23       	and	r24, r24
    5368:	41 f0       	breq	.+16     	; 0x537a <main+0xd54>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    536a:	80 91 c0 00 	lds	r24, 0x00C0
    536e:	85 ff       	sbrs	r24, 5
    5370:	04 c0       	rjmp	.+8      	; 0x537a <main+0xd54>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send and push it over the UART
    5372:	0e 94 8a 20 	call	0x4114	; 0x4114 <PopOutgoingMidiByte>
    5376:	80 93 c6 00 	sts	0x00C6, r24
			}
		}

		State();				// Execute the current program state.
    537a:	e0 91 e3 05 	lds	r30, 0x05E3
    537e:	f0 91 e4 05 	lds	r31, 0x05E4
    5382:	09 95       	icall
	}
    5384:	f4 c9       	rjmp	.-3096   	; 0x476e <main+0x148>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle), end transfer and figure what to do next.
				{
					EndSdTransfer();				// Bring CS high
    5386:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    538a:	8f ef       	ldi	r24, 0xFF	; 255
    538c:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    5390:	df cc       	rjmp	.-1602   	; 0x4d50 <main+0x72a>
					}
				}

				if(theByte==0xFF)	// Got a proper reply (line idle) end transfer mark IDLE
				{
					EndSdTransfer();				// Bring CS high
    5392:	0e 94 4e 21 	call	0x429c	; 0x429c <EndSdTransfer>
					TransferSdByte(DUMMY_BYTE);		// Send some clocks to make sure the state machine gets back to where it needs to go.
    5396:	8f ef       	ldi	r24, 0xFF	; 255
    5398:	0e 94 53 21 	call	0x42a6	; 0x42a6 <TransferSdByte>
    539c:	00 ce       	rjmp	.-1024   	; 0x4f9e <main+0x978>

0000539e <__udivmodqi4>:
    539e:	99 1b       	sub	r25, r25
    53a0:	79 e0       	ldi	r23, 0x09	; 9
    53a2:	04 c0       	rjmp	.+8      	; 0x53ac <__udivmodqi4_ep>

000053a4 <__udivmodqi4_loop>:
    53a4:	99 1f       	adc	r25, r25
    53a6:	96 17       	cp	r25, r22
    53a8:	08 f0       	brcs	.+2      	; 0x53ac <__udivmodqi4_ep>
    53aa:	96 1b       	sub	r25, r22

000053ac <__udivmodqi4_ep>:
    53ac:	88 1f       	adc	r24, r24
    53ae:	7a 95       	dec	r23
    53b0:	c9 f7       	brne	.-14     	; 0x53a4 <__udivmodqi4_loop>
    53b2:	80 95       	com	r24
    53b4:	08 95       	ret

000053b6 <__udivmodsi4>:
    53b6:	a1 e2       	ldi	r26, 0x21	; 33
    53b8:	1a 2e       	mov	r1, r26
    53ba:	aa 1b       	sub	r26, r26
    53bc:	bb 1b       	sub	r27, r27
    53be:	fd 01       	movw	r30, r26
    53c0:	0d c0       	rjmp	.+26     	; 0x53dc <__udivmodsi4_ep>

000053c2 <__udivmodsi4_loop>:
    53c2:	aa 1f       	adc	r26, r26
    53c4:	bb 1f       	adc	r27, r27
    53c6:	ee 1f       	adc	r30, r30
    53c8:	ff 1f       	adc	r31, r31
    53ca:	a2 17       	cp	r26, r18
    53cc:	b3 07       	cpc	r27, r19
    53ce:	e4 07       	cpc	r30, r20
    53d0:	f5 07       	cpc	r31, r21
    53d2:	20 f0       	brcs	.+8      	; 0x53dc <__udivmodsi4_ep>
    53d4:	a2 1b       	sub	r26, r18
    53d6:	b3 0b       	sbc	r27, r19
    53d8:	e4 0b       	sbc	r30, r20
    53da:	f5 0b       	sbc	r31, r21

000053dc <__udivmodsi4_ep>:
    53dc:	66 1f       	adc	r22, r22
    53de:	77 1f       	adc	r23, r23
    53e0:	88 1f       	adc	r24, r24
    53e2:	99 1f       	adc	r25, r25
    53e4:	1a 94       	dec	r1
    53e6:	69 f7       	brne	.-38     	; 0x53c2 <__udivmodsi4_loop>
    53e8:	60 95       	com	r22
    53ea:	70 95       	com	r23
    53ec:	80 95       	com	r24
    53ee:	90 95       	com	r25
    53f0:	9b 01       	movw	r18, r22
    53f2:	ac 01       	movw	r20, r24
    53f4:	bd 01       	movw	r22, r26
    53f6:	cf 01       	movw	r24, r30
    53f8:	08 95       	ret

000053fa <__tablejump2__>:
    53fa:	ee 0f       	add	r30, r30
    53fc:	ff 1f       	adc	r31, r31

000053fe <__tablejump__>:
    53fe:	05 90       	lpm	r0, Z+
    5400:	f4 91       	lpm	r31, Z
    5402:	e0 2d       	mov	r30, r0
    5404:	09 94       	ijmp

00005406 <__umulhisi3>:
    5406:	a2 9f       	mul	r26, r18
    5408:	b0 01       	movw	r22, r0
    540a:	b3 9f       	mul	r27, r19
    540c:	c0 01       	movw	r24, r0
    540e:	a3 9f       	mul	r26, r19
    5410:	01 d0       	rcall	.+2      	; 0x5414 <__umulhisi3+0xe>
    5412:	b2 9f       	mul	r27, r18
    5414:	70 0d       	add	r23, r0
    5416:	81 1d       	adc	r24, r1
    5418:	11 24       	eor	r1, r1
    541a:	91 1d       	adc	r25, r1
    541c:	08 95       	ret

0000541e <__muluhisi3>:
    541e:	0e 94 03 2a 	call	0x5406	; 0x5406 <__umulhisi3>
    5422:	a5 9f       	mul	r26, r21
    5424:	90 0d       	add	r25, r0
    5426:	b4 9f       	mul	r27, r20
    5428:	90 0d       	add	r25, r0
    542a:	a4 9f       	mul	r26, r20
    542c:	80 0d       	add	r24, r0
    542e:	91 1d       	adc	r25, r1
    5430:	11 24       	eor	r1, r1
    5432:	08 95       	ret

00005434 <_exit>:
    5434:	f8 94       	cli

00005436 <__stop_program>:
    5436:	ff cf       	rjmp	.-2      	; 0x5436 <__stop_program>
