   1               		.file	"eeprom.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	EepromWrite
  12               	EepromWrite:
  13               	.LFB1:
  14               		.file 1 "eeprom.c"
   1:eeprom.c      **** // EEPROM Read and Write Functions
   2:eeprom.c      **** // TMB
   3:eeprom.c      **** // Thu Nov 13 23:55:06 CST 2008
   4:eeprom.c      **** 
   5:eeprom.c      **** // Taken from the ATMEGA164p datasheet more or less.
   6:eeprom.c      **** // Remember that these don't check for flash programming!
   7:eeprom.c      **** // NOTE:  Accepted lore is not to use eeprom address 0 since it's the most likely one to get bugger
   8:eeprom.c      **** 
   9:eeprom.c      **** #include "includes.h"
  10:eeprom.c      **** 
  11:eeprom.c      **** void EepromWrite(unsigned int theAddress, unsigned char theData)
  12:eeprom.c      **** {
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.LVL0:
  22               	.L2:
  13:eeprom.c      **** 	unsigned char 
  14:eeprom.c      **** 		sreg;
  15:eeprom.c      **** 
  16:eeprom.c      **** 	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
  23               		.loc 1 16 0 discriminator 1
  24 0000 F999      		sbic 0x1f,1
  25 0002 00C0      		rjmp .L2
  17:eeprom.c      **** 		;
  18:eeprom.c      **** 
  19:eeprom.c      **** 	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
  26               		.loc 1 19 0
  27 0004 2FB7      		in r18,__SREG__
  28               	.LVL1:
  20:eeprom.c      **** 	cli();		// Stop interrupts.
  29               		.loc 1 20 0
  30               	/* #APP */
  31               	 ;  20 "eeprom.c" 1
  32 0006 F894      		cli
  33               	 ;  0 "" 2
  21:eeprom.c      **** 
  22:eeprom.c      **** 	EEAR=theAddress;
  34               		.loc 1 22 0
  35               	/* #NOAPP */
  36 0008 92BD      		out 0x21+1,r25
  37 000a 81BD      		out 0x21,r24
  23:eeprom.c      **** 	EEDR=theData;
  38               		.loc 1 23 0
  39 000c 60BD      		out 0x20,r22
  24:eeprom.c      **** 	EECR|=(1<<EEMPE);	// Start the write.
  40               		.loc 1 24 0
  41 000e FA9A      		sbi 0x1f,2
  25:eeprom.c      **** 	EECR|=(1<<EEPE);	// Second start-write command.
  42               		.loc 1 25 0
  43 0010 F99A      		sbi 0x1f,1
  26:eeprom.c      **** 
  27:eeprom.c      **** 	SREG=sreg;			// Restore interrupts.
  44               		.loc 1 27 0
  45 0012 2FBF      		out __SREG__,r18
  28:eeprom.c      **** 	EEAR=0;				// Point the address away from the registers we care about.
  46               		.loc 1 28 0
  47 0014 12BC      		out 0x21+1,__zero_reg__
  48 0016 11BC      		out 0x21,__zero_reg__
  49 0018 0895      		ret
  50               		.cfi_endproc
  51               	.LFE1:
  53               	.global	EepromRead
  55               	EepromRead:
  56               	.LFB2:
  29:eeprom.c      **** }
  30:eeprom.c      **** 
  31:eeprom.c      **** unsigned char EepromRead(unsigned char theAddress)
  32:eeprom.c      **** {
  57               		.loc 1 32 0
  58               		.cfi_startproc
  59               	/* prologue: function */
  60               	/* frame size = 0 */
  61               	/* stack size = 0 */
  62               	.L__stack_usage = 0
  63               	.LVL2:
  64               	.L5:
  33:eeprom.c      **** 	unsigned char 
  34:eeprom.c      **** 		sreg;
  35:eeprom.c      **** 
  36:eeprom.c      **** 	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
  65               		.loc 1 36 0 discriminator 1
  66 001a F999      		sbic 0x1f,1
  67 001c 00C0      		rjmp .L5
  37:eeprom.c      **** 		;
  38:eeprom.c      **** 
  39:eeprom.c      **** 	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
  68               		.loc 1 39 0
  69 001e 2FB7      		in r18,__SREG__
  70               	.LVL3:
  40:eeprom.c      **** 	cli();		// Stop interrupts.
  71               		.loc 1 40 0
  72               	/* #APP */
  73               	 ;  40 "eeprom.c" 1
  74 0020 F894      		cli
  75               	 ;  0 "" 2
  41:eeprom.c      **** 
  42:eeprom.c      **** 	EEAR=theAddress;
  76               		.loc 1 42 0
  77               	/* #NOAPP */
  78 0022 90E0      		ldi r25,0
  79 0024 92BD      		out 0x21+1,r25
  80 0026 81BD      		out 0x21,r24
  43:eeprom.c      **** 	EECR|=(1<<EERE);	// Start reading.
  81               		.loc 1 43 0
  82 0028 F89A      		sbi 0x1f,0
  44:eeprom.c      **** 
  45:eeprom.c      **** 	SREG=sreg;			// Restore interrupts.
  83               		.loc 1 45 0
  84 002a 2FBF      		out __SREG__,r18
  46:eeprom.c      **** 	EEAR=0;				// Point the address away from the registers we care about.
  85               		.loc 1 46 0
  86 002c 12BC      		out 0x21+1,__zero_reg__
  87 002e 11BC      		out 0x21,__zero_reg__
  47:eeprom.c      **** 	
  48:eeprom.c      **** 	return(EEDR);		// Pass the data back from eeprom.
  88               		.loc 1 48 0
  89 0030 80B5      		in r24,0x20
  90               	.LVL4:
  49:eeprom.c      **** }
  91               		.loc 1 49 0
  92 0032 0895      		ret
  93               		.cfi_endproc
  94               	.LFE2:
  96               	.Letext0:
  97               		.file 2 "/usr/local/avr/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 eeprom.c
     /tmp/ccM0zEpc.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccM0zEpc.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccM0zEpc.s:4      *ABS*:0000003f __SREG__
     /tmp/ccM0zEpc.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccM0zEpc.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccM0zEpc.s:12     .text:00000000 EepromWrite
     /tmp/ccM0zEpc.s:55     .text:0000001a EepromRead

NO UNDEFINED SYMBOLS
