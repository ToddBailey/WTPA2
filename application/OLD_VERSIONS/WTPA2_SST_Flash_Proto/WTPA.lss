
WTPA.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  000052f6  0000538a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000052f6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000215  0080011e  0080011e  000053a8  2**0
                  ALLOC
  3 .stab         000006b4  00000000  00000000  000053a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000054  00000000  00000000  00005a5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00005ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000365  00000000  00000000  00005b70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002ba5  00000000  00000000  00005ed5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000969  00000000  00000000  00008a7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00003771  00000000  00000000  000093e3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000003b0  00000000  00000000  0000cb54  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000010f0  00000000  00000000  0000cf04  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000ebc  00000000  00000000  0000dff4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000190  00000000  00000000  0000eeb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
       4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
       c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      18:	0c 94 54 09 	jmp	0x12a8	; 0x12a8 <__vector_6>
      1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      24:	0c 94 d2 0a 	jmp	0x15a4	; 0x15a4 <__vector_9>
      28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      30:	0c 94 0c 09 	jmp	0x1218	; 0x1218 <__vector_12>
      34:	0c 94 9e 09 	jmp	0x133c	; 0x133c <__vector_13>
      38:	0c 94 38 0a 	jmp	0x1470	; 0x1470 <__vector_14>
      3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
      7c:	c8 1a       	sub	r12, r24
      7e:	86 1e       	adc	r8, r22
      80:	86 1e       	adc	r8, r22
      82:	86 1e       	adc	r8, r22
      84:	86 1e       	adc	r8, r22
      86:	86 1e       	adc	r8, r22
      88:	0d 1b       	sub	r16, r29
      8a:	86 1e       	adc	r8, r22
      8c:	86 1e       	adc	r8, r22
      8e:	86 1e       	adc	r8, r22
      90:	86 1e       	adc	r8, r22
      92:	8c 1b       	sub	r24, r28
      94:	da 1b       	sub	r29, r26
      96:	01 1c       	adc	r0, r1
      98:	28 1c       	adc	r2, r8
      9a:	51 1c       	adc	r5, r1
      9c:	d0 1c       	adc	r13, r0
      9e:	e6 1c       	adc	r14, r6
      a0:	ed 1c       	adc	r14, r13
      a2:	00 1d       	adc	r16, r0
      a4:	1c 1d       	adc	r17, r12
      a6:	43 1d       	adc	r20, r3
      a8:	57 1d       	adc	r21, r7
      aa:	6b 1d       	adc	r22, r11
      ac:	7f 1d       	adc	r23, r15
      ae:	fa 1d       	adc	r31, r10
      b0:	11 1e       	adc	r1, r17
      b2:	28 1e       	adc	r2, r24

000000b4 <__ctors_end>:
      b4:	11 24       	eor	r1, r1
      b6:	1f be       	out	0x3f, r1	; 63
      b8:	cf ef       	ldi	r28, 0xFF	; 255
      ba:	d0 e1       	ldi	r29, 0x10	; 16
      bc:	de bf       	out	0x3e, r29	; 62
      be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
      c0:	11 e0       	ldi	r17, 0x01	; 1
      c2:	a0 e0       	ldi	r26, 0x00	; 0
      c4:	b1 e0       	ldi	r27, 0x01	; 1
      c6:	e6 ef       	ldi	r30, 0xF6	; 246
      c8:	f2 e5       	ldi	r31, 0x52	; 82
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <.do_copy_data_start>

000000cc <.do_copy_data_loop>:
      cc:	05 90       	lpm	r0, Z+
      ce:	0d 92       	st	X+, r0

000000d0 <.do_copy_data_start>:
      d0:	ae 31       	cpi	r26, 0x1E	; 30
      d2:	b1 07       	cpc	r27, r17
      d4:	d9 f7       	brne	.-10     	; 0xcc <.do_copy_data_loop>

000000d6 <__do_clear_bss>:
      d6:	13 e0       	ldi	r17, 0x03	; 3
      d8:	ae e1       	ldi	r26, 0x1E	; 30
      da:	b1 e0       	ldi	r27, 0x01	; 1
      dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
      de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
      e0:	a3 33       	cpi	r26, 0x33	; 51
      e2:	b1 07       	cpc	r27, r17
      e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
      e6:	0e 94 84 12 	call	0x2508	; 0x2508 <main>
      ea:	0c 94 79 29 	jmp	0x52f2	; 0x52f2 <_exit>

000000ee <__bad_interrupt>:
      ee:	0c 94 ed 0a 	jmp	0x15da	; 0x15da <__vector_default>

000000f2 <UpdateAudioChannel0>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_0].audioFunction)
      f2:	80 91 7d 02 	lds	r24, 0x027D
      f6:	83 30       	cpi	r24, 0x03	; 3
      f8:	c9 f0       	breq	.+50     	; 0x12c <UpdateAudioChannel0+0x3a>
      fa:	84 30       	cpi	r24, 0x04	; 4
      fc:	30 f4       	brcc	.+12     	; 0x10a <UpdateAudioChannel0+0x18>
      fe:	81 30       	cpi	r24, 0x01	; 1
     100:	59 f0       	breq	.+22     	; 0x118 <UpdateAudioChannel0+0x26>
     102:	82 30       	cpi	r24, 0x02	; 2
     104:	09 f0       	breq	.+2      	; 0x108 <UpdateAudioChannel0+0x16>
     106:	8e c0       	rjmp	.+284    	; 0x224 <UpdateAudioChannel0+0x132>
     108:	0e c0       	rjmp	.+28     	; 0x126 <UpdateAudioChannel0+0x34>
     10a:	84 30       	cpi	r24, 0x04	; 4
     10c:	09 f4       	brne	.+2      	; 0x110 <UpdateAudioChannel0+0x1e>
     10e:	8c c0       	rjmp	.+280    	; 0x228 <UpdateAudioChannel0+0x136>
     110:	85 30       	cpi	r24, 0x05	; 5
     112:	09 f0       	breq	.+2      	; 0x116 <UpdateAudioChannel0+0x24>
     114:	87 c0       	rjmp	.+270    	; 0x224 <UpdateAudioChannel0+0x132>
     116:	0d c2       	rjmp	.+1050   	; 0x532 <UpdateAudioChannel0+0x440>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     118:	40 91 36 01 	lds	r20, 0x0136
     11c:	4f 5f       	subi	r20, 0xFF	; 255
     11e:	40 93 36 01 	sts	0x0136, r20
     122:	41 50       	subi	r20, 0x01	; 1
     124:	a3 c3       	rjmp	.+1862   	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     126:	40 91 56 02 	lds	r20, 0x0256
     12a:	f1 c1       	rjmp	.+994    	; 0x50e <UpdateAudioChannel0+0x41c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     12c:	8f ef       	ldi	r24, 0xFF	; 255
     12e:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     130:	80 91 9b 02 	lds	r24, 0x029B
     134:	90 91 9c 02 	lds	r25, 0x029C
     138:	a0 91 9d 02 	lds	r26, 0x029D
     13c:	b0 91 9e 02 	lds	r27, 0x029E
     140:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     142:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     144:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     146:	80 91 9b 02 	lds	r24, 0x029B
     14a:	90 91 9c 02 	lds	r25, 0x029C
     14e:	a0 91 9d 02 	lds	r26, 0x029D
     152:	b0 91 9e 02 	lds	r27, 0x029E
     156:	89 2f       	mov	r24, r25
     158:	9a 2f       	mov	r25, r26
     15a:	ab 2f       	mov	r26, r27
     15c:	bb 27       	eor	r27, r27
     15e:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     160:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     162:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     164:	80 91 9b 02 	lds	r24, 0x029B
     168:	90 91 9c 02 	lds	r25, 0x029C
     16c:	a0 91 9d 02 	lds	r26, 0x029D
     170:	b0 91 9e 02 	lds	r27, 0x029E
     174:	cd 01       	movw	r24, r26
     176:	aa 27       	eor	r26, r26
     178:	bb 27       	eor	r27, r27
     17a:	87 70       	andi	r24, 0x07	; 7
     17c:	88 68       	ori	r24, 0x88	; 136
     17e:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     180:	80 91 56 02 	lds	r24, 0x0256
     184:	85 b9       	out	0x05, r24	; 5

		// Compute address while bus settles.

		bankStates[BANK_0].currentAddress++;										// Next address please.
     186:	80 91 9b 02 	lds	r24, 0x029B
     18a:	90 91 9c 02 	lds	r25, 0x029C
     18e:	a0 91 9d 02 	lds	r26, 0x029D
     192:	b0 91 9e 02 	lds	r27, 0x029E
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	a1 1d       	adc	r26, r1
     19a:	b1 1d       	adc	r27, r1
     19c:	80 93 9b 02 	sts	0x029B, r24
     1a0:	90 93 9c 02 	sts	0x029C, r25
     1a4:	a0 93 9d 02 	sts	0x029D, r26
     1a8:	b0 93 9e 02 	sts	0x029E, r27
		bankStates[BANK_0].endAddress=bankStates[BANK_0].currentAddress;			// Match ending address of the sample to the current memory address.
     1ac:	80 91 9b 02 	lds	r24, 0x029B
     1b0:	90 91 9c 02 	lds	r25, 0x029C
     1b4:	a0 91 9d 02 	lds	r26, 0x029D
     1b8:	b0 91 9e 02 	lds	r27, 0x029E
     1bc:	80 93 88 02 	sts	0x0288, r24
     1c0:	90 93 89 02 	sts	0x0289, r25
     1c4:	a0 93 8a 02 	sts	0x028A, r26
     1c8:	b0 93 8b 02 	sts	0x028B, r27
		bankStates[BANK_0].adjustedEndAddress=bankStates[BANK_0].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     1cc:	80 91 9b 02 	lds	r24, 0x029B
     1d0:	90 91 9c 02 	lds	r25, 0x029C
     1d4:	a0 91 9d 02 	lds	r26, 0x029D
     1d8:	b0 91 9e 02 	lds	r27, 0x029E
     1dc:	80 93 90 02 	sts	0x0290, r24
     1e0:	90 93 91 02 	sts	0x0291, r25
     1e4:	a0 93 92 02 	sts	0x0292, r26
     1e8:	b0 93 93 02 	sts	0x0293, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     1ec:	20 91 88 02 	lds	r18, 0x0288
     1f0:	30 91 89 02 	lds	r19, 0x0289
     1f4:	40 91 8a 02 	lds	r20, 0x028A
     1f8:	50 91 8b 02 	lds	r21, 0x028B
     1fc:	80 91 aa 02 	lds	r24, 0x02AA
     200:	90 91 ab 02 	lds	r25, 0x02AB
     204:	a0 91 ac 02 	lds	r26, 0x02AC
     208:	b0 91 ad 02 	lds	r27, 0x02AD
     20c:	28 17       	cp	r18, r24
     20e:	39 07       	cpc	r19, r25
     210:	4a 07       	cpc	r20, r26
     212:	5b 07       	cpc	r21, r27
     214:	28 f0       	brcs	.+10     	; 0x220 <UpdateAudioChannel0+0x12e>
		{
			bankStates[BANK_0].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     216:	10 92 7d 02 	sts	0x027D, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     21a:	81 e0       	ldi	r24, 0x01	; 1
     21c:	80 93 40 01 	sts	0x0140, r24
		}

		// Finish writing to RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     220:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     222:	11 9a       	sbi	0x02, 1	; 2
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	22 c3       	rjmp	.+1604   	; 0x86c <UpdateAudioChannel0+0x77a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     228:	80 91 9b 02 	lds	r24, 0x029B
     22c:	90 91 9c 02 	lds	r25, 0x029C
     230:	a0 91 9d 02 	lds	r26, 0x029D
     234:	b0 91 9e 02 	lds	r27, 0x029E
     238:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     23a:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     23c:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     23e:	80 91 9b 02 	lds	r24, 0x029B
     242:	90 91 9c 02 	lds	r25, 0x029C
     246:	a0 91 9d 02 	lds	r26, 0x029D
     24a:	b0 91 9e 02 	lds	r27, 0x029E
     24e:	89 2f       	mov	r24, r25
     250:	9a 2f       	mov	r25, r26
     252:	ab 2f       	mov	r26, r27
     254:	bb 27       	eor	r27, r27
     256:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     258:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     25a:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     25c:	80 91 9b 02 	lds	r24, 0x029B
     260:	90 91 9c 02 	lds	r25, 0x029C
     264:	a0 91 9d 02 	lds	r26, 0x029D
     268:	b0 91 9e 02 	lds	r27, 0x029E
     26c:	cd 01       	movw	r24, r26
     26e:	aa 27       	eor	r26, r26
     270:	bb 27       	eor	r27, r27
     272:	87 70       	andi	r24, 0x07	; 7
     274:	88 68       	ori	r24, 0x88	; 136
     276:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     278:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     27a:	12 98       	cbi	0x02, 2	; 2

		// Calculate new addy while data bus settles

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     27c:	80 91 82 02 	lds	r24, 0x0282
     280:	88 23       	and	r24, r24
     282:	09 f4       	brne	.+2      	; 0x286 <UpdateAudioChannel0+0x194>
     284:	6c c0       	rjmp	.+216    	; 0x35e <UpdateAudioChannel0+0x26c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     286:	80 91 4e 01 	lds	r24, 0x014E
     28a:	90 91 4f 01 	lds	r25, 0x014F
     28e:	a0 91 50 01 	lds	r26, 0x0150
     292:	b0 91 51 01 	lds	r27, 0x0151
     296:	00 97       	sbiw	r24, 0x00	; 0
     298:	a1 05       	cpc	r26, r1
     29a:	b1 05       	cpc	r27, r1
     29c:	39 f1       	breq	.+78     	; 0x2ec <UpdateAudioChannel0+0x1fa>
			{
				bankStates[BANK_0].currentAddress++;
     29e:	80 91 9b 02 	lds	r24, 0x029B
     2a2:	90 91 9c 02 	lds	r25, 0x029C
     2a6:	a0 91 9d 02 	lds	r26, 0x029D
     2aa:	b0 91 9e 02 	lds	r27, 0x029E
     2ae:	01 96       	adiw	r24, 0x01	; 1
     2b0:	a1 1d       	adc	r26, r1
     2b2:	b1 1d       	adc	r27, r1
     2b4:	80 93 9b 02 	sts	0x029B, r24
     2b8:	90 93 9c 02 	sts	0x029C, r25
     2bc:	a0 93 9d 02 	sts	0x029D, r26
     2c0:	b0 93 9e 02 	sts	0x029E, r27
				sliceRemaining[BANK_0]--;
     2c4:	80 91 4e 01 	lds	r24, 0x014E
     2c8:	90 91 4f 01 	lds	r25, 0x014F
     2cc:	a0 91 50 01 	lds	r26, 0x0150
     2d0:	b0 91 51 01 	lds	r27, 0x0151
     2d4:	01 97       	sbiw	r24, 0x01	; 1
     2d6:	a1 09       	sbc	r26, r1
     2d8:	b1 09       	sbc	r27, r1
     2da:	80 93 4e 01 	sts	0x014E, r24
     2de:	90 93 4f 01 	sts	0x014F, r25
     2e2:	a0 93 50 01 	sts	0x0150, r26
     2e6:	b0 93 51 01 	sts	0x0151, r27
     2ea:	0d c1       	rjmp	.+538    	; 0x506 <UpdateAudioChannel0+0x414>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     2ec:	80 91 46 01 	lds	r24, 0x0146
     2f0:	90 91 47 01 	lds	r25, 0x0147
     2f4:	a0 91 48 01 	lds	r26, 0x0148
     2f8:	b0 91 49 01 	lds	r27, 0x0149
     2fc:	80 93 4e 01 	sts	0x014E, r24
     300:	90 93 4f 01 	sts	0x014F, r25
     304:	a0 93 50 01 	sts	0x0150, r26
     308:	b0 93 51 01 	sts	0x0151, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     30c:	80 91 44 01 	lds	r24, 0x0144
     310:	8f 5f       	subi	r24, 0xFF	; 255
     312:	80 93 44 01 	sts	0x0144, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     316:	90 91 44 01 	lds	r25, 0x0144
     31a:	80 91 82 02 	lds	r24, 0x0282
     31e:	98 17       	cp	r25, r24
     320:	11 f4       	brne	.+4      	; 0x326 <UpdateAudioChannel0+0x234>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     322:	10 92 44 01 	sts	0x0144, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     326:	e0 91 44 01 	lds	r30, 0x0144
     32a:	20 91 46 01 	lds	r18, 0x0146
     32e:	30 91 47 01 	lds	r19, 0x0147
     332:	40 91 48 01 	lds	r20, 0x0148
     336:	50 91 49 01 	lds	r21, 0x0149
     33a:	f0 e0       	ldi	r31, 0x00	; 0
     33c:	ea 5a       	subi	r30, 0xAA	; 170
     33e:	fe 4f       	sbci	r31, 0xFE	; 254
     340:	60 81       	ld	r22, Z
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 e0       	ldi	r24, 0x00	; 0
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
     34c:	60 93 9b 02 	sts	0x029B, r22
     350:	70 93 9c 02 	sts	0x029C, r23
     354:	80 93 9d 02 	sts	0x029D, r24
     358:	90 93 9e 02 	sts	0x029E, r25
     35c:	d4 c0       	rjmp	.+424    	; 0x506 <UpdateAudioChannel0+0x414>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     35e:	80 91 81 02 	lds	r24, 0x0281
     362:	88 23       	and	r24, r24
     364:	09 f0       	breq	.+2      	; 0x368 <UpdateAudioChannel0+0x276>
     366:	62 c0       	rjmp	.+196    	; 0x42c <UpdateAudioChannel0+0x33a>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     368:	20 91 9b 02 	lds	r18, 0x029B
     36c:	30 91 9c 02 	lds	r19, 0x029C
     370:	40 91 9d 02 	lds	r20, 0x029D
     374:	50 91 9e 02 	lds	r21, 0x029E
     378:	80 91 94 02 	lds	r24, 0x0294
     37c:	90 91 95 02 	lds	r25, 0x0295
     380:	a0 91 96 02 	lds	r26, 0x0296
     384:	b0 91 97 02 	lds	r27, 0x0297
     388:	28 17       	cp	r18, r24
     38a:	39 07       	cpc	r19, r25
     38c:	4a 07       	cpc	r20, r26
     38e:	5b 07       	cpc	r21, r27
     390:	29 f4       	brne	.+10     	; 0x39c <UpdateAudioChannel0+0x2aa>
     392:	80 91 7e 02 	lds	r24, 0x027E
     396:	81 30       	cpi	r24, 0x01	; 1
     398:	09 f4       	brne	.+2      	; 0x39c <UpdateAudioChannel0+0x2aa>
     39a:	61 c0       	rjmp	.+194    	; 0x45e <UpdateAudioChannel0+0x36c>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     39c:	20 91 9b 02 	lds	r18, 0x029B
     3a0:	30 91 9c 02 	lds	r19, 0x029C
     3a4:	40 91 9d 02 	lds	r20, 0x029D
     3a8:	50 91 9e 02 	lds	r21, 0x029E
     3ac:	80 91 94 02 	lds	r24, 0x0294
     3b0:	90 91 95 02 	lds	r25, 0x0295
     3b4:	a0 91 96 02 	lds	r26, 0x0296
     3b8:	b0 91 97 02 	lds	r27, 0x0297
     3bc:	28 17       	cp	r18, r24
     3be:	39 07       	cpc	r19, r25
     3c0:	4a 07       	cpc	r20, r26
     3c2:	5b 07       	cpc	r21, r27
     3c4:	49 f4       	brne	.+18     	; 0x3d8 <UpdateAudioChannel0+0x2e6>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     3c6:	80 91 90 02 	lds	r24, 0x0290
     3ca:	90 91 91 02 	lds	r25, 0x0291
     3ce:	a0 91 92 02 	lds	r26, 0x0292
     3d2:	b0 91 93 02 	lds	r27, 0x0293
     3d6:	8f c0       	rjmp	.+286    	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     3d8:	20 91 9b 02 	lds	r18, 0x029B
     3dc:	30 91 9c 02 	lds	r19, 0x029C
     3e0:	40 91 9d 02 	lds	r20, 0x029D
     3e4:	50 91 9e 02 	lds	r21, 0x029E
     3e8:	80 91 8c 02 	lds	r24, 0x028C
     3ec:	90 91 8d 02 	lds	r25, 0x028D
     3f0:	a0 91 8e 02 	lds	r26, 0x028E
     3f4:	b0 91 8f 02 	lds	r27, 0x028F
     3f8:	28 17       	cp	r18, r24
     3fa:	39 07       	cpc	r19, r25
     3fc:	4a 07       	cpc	r20, r26
     3fe:	5b 07       	cpc	r21, r27
     400:	49 f4       	brne	.+18     	; 0x414 <UpdateAudioChannel0+0x322>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     402:	80 91 88 02 	lds	r24, 0x0288
     406:	90 91 89 02 	lds	r25, 0x0289
     40a:	a0 91 8a 02 	lds	r26, 0x028A
     40e:	b0 91 8b 02 	lds	r27, 0x028B
     412:	71 c0       	rjmp	.+226    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     414:	80 91 9b 02 	lds	r24, 0x029B
     418:	90 91 9c 02 	lds	r25, 0x029C
     41c:	a0 91 9d 02 	lds	r26, 0x029D
     420:	b0 91 9e 02 	lds	r27, 0x029E
     424:	01 97       	sbiw	r24, 0x01	; 1
     426:	a1 09       	sbc	r26, r1
     428:	b1 09       	sbc	r27, r1
     42a:	65 c0       	rjmp	.+202    	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     42c:	20 91 9b 02 	lds	r18, 0x029B
     430:	30 91 9c 02 	lds	r19, 0x029C
     434:	40 91 9d 02 	lds	r20, 0x029D
     438:	50 91 9e 02 	lds	r21, 0x029E
     43c:	80 91 90 02 	lds	r24, 0x0290
     440:	90 91 91 02 	lds	r25, 0x0291
     444:	a0 91 92 02 	lds	r26, 0x0292
     448:	b0 91 93 02 	lds	r27, 0x0293
     44c:	28 17       	cp	r18, r24
     44e:	39 07       	cpc	r19, r25
     450:	4a 07       	cpc	r20, r26
     452:	5b 07       	cpc	r21, r27
     454:	49 f4       	brne	.+18     	; 0x468 <UpdateAudioChannel0+0x376>
     456:	80 91 7e 02 	lds	r24, 0x027E
     45a:	81 30       	cpi	r24, 0x01	; 1
     45c:	29 f4       	brne	.+10     	; 0x468 <UpdateAudioChannel0+0x376>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     45e:	10 92 7d 02 	sts	0x027D, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     462:	10 92 85 02 	sts	0x0285, r1
     466:	4f c0       	rjmp	.+158    	; 0x506 <UpdateAudioChannel0+0x414>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     468:	20 91 9b 02 	lds	r18, 0x029B
     46c:	30 91 9c 02 	lds	r19, 0x029C
     470:	40 91 9d 02 	lds	r20, 0x029D
     474:	50 91 9e 02 	lds	r21, 0x029E
     478:	80 91 90 02 	lds	r24, 0x0290
     47c:	90 91 91 02 	lds	r25, 0x0291
     480:	a0 91 92 02 	lds	r26, 0x0292
     484:	b0 91 93 02 	lds	r27, 0x0293
     488:	28 17       	cp	r18, r24
     48a:	39 07       	cpc	r19, r25
     48c:	4a 07       	cpc	r20, r26
     48e:	5b 07       	cpc	r21, r27
     490:	49 f4       	brne	.+18     	; 0x4a4 <UpdateAudioChannel0+0x3b2>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     492:	80 91 94 02 	lds	r24, 0x0294
     496:	90 91 95 02 	lds	r25, 0x0295
     49a:	a0 91 96 02 	lds	r26, 0x0296
     49e:	b0 91 97 02 	lds	r27, 0x0297
     4a2:	29 c0       	rjmp	.+82     	; 0x4f6 <UpdateAudioChannel0+0x404>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     4a4:	20 91 9b 02 	lds	r18, 0x029B
     4a8:	30 91 9c 02 	lds	r19, 0x029C
     4ac:	40 91 9d 02 	lds	r20, 0x029D
     4b0:	50 91 9e 02 	lds	r21, 0x029E
     4b4:	80 91 88 02 	lds	r24, 0x0288
     4b8:	90 91 89 02 	lds	r25, 0x0289
     4bc:	a0 91 8a 02 	lds	r26, 0x028A
     4c0:	b0 91 8b 02 	lds	r27, 0x028B
     4c4:	28 17       	cp	r18, r24
     4c6:	39 07       	cpc	r19, r25
     4c8:	4a 07       	cpc	r20, r26
     4ca:	5b 07       	cpc	r21, r27
     4cc:	49 f4       	brne	.+18     	; 0x4e0 <UpdateAudioChannel0+0x3ee>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     4ce:	80 91 8c 02 	lds	r24, 0x028C
     4d2:	90 91 8d 02 	lds	r25, 0x028D
     4d6:	a0 91 8e 02 	lds	r26, 0x028E
     4da:	b0 91 8f 02 	lds	r27, 0x028F
     4de:	0b c0       	rjmp	.+22     	; 0x4f6 <UpdateAudioChannel0+0x404>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     4e0:	80 91 9b 02 	lds	r24, 0x029B
     4e4:	90 91 9c 02 	lds	r25, 0x029C
     4e8:	a0 91 9d 02 	lds	r26, 0x029D
     4ec:	b0 91 9e 02 	lds	r27, 0x029E
     4f0:	01 96       	adiw	r24, 0x01	; 1
     4f2:	a1 1d       	adc	r26, r1
     4f4:	b1 1d       	adc	r27, r1
     4f6:	80 93 9b 02 	sts	0x029B, r24
     4fa:	90 93 9c 02 	sts	0x029C, r25
     4fe:	a0 93 9d 02 	sts	0x029D, r26
     502:	b0 93 9e 02 	sts	0x029E, r27
		}

*/
		// Finish getting the byte from RAM.

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     506:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     508:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     50a:	8f ef       	ldi	r24, 0xFF	; 255
     50c:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     50e:	80 91 84 02 	lds	r24, 0x0284
     512:	88 23       	and	r24, r24
     514:	09 f4       	brne	.+2      	; 0x518 <UpdateAudioChannel0+0x426>
     516:	aa c1       	rjmp	.+852    	; 0x86c <UpdateAudioChannel0+0x77a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     518:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     51a:	20 91 84 02 	lds	r18, 0x0284
     51e:	8f ef       	ldi	r24, 0xFF	; 255
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	02 c0       	rjmp	.+4      	; 0x528 <UpdateAudioChannel0+0x436>
     524:	88 0f       	add	r24, r24
     526:	99 1f       	adc	r25, r25
     528:	2a 95       	dec	r18
     52a:	e2 f7       	brpl	.-8      	; 0x524 <UpdateAudioChannel0+0x432>
     52c:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     52e:	40 58       	subi	r20, 0x80	; 128
     530:	9d c1       	rjmp	.+826    	; 0x86c <UpdateAudioChannel0+0x77a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_0].currentAddress);	// Put the LSB of the address on the latch.
     532:	80 91 9b 02 	lds	r24, 0x029B
     536:	90 91 9c 02 	lds	r25, 0x029C
     53a:	a0 91 9d 02 	lds	r26, 0x029D
     53e:	b0 91 9e 02 	lds	r27, 0x029E
     542:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     544:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     546:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_0].currentAddress>>8));	// Put the middle byte of the address on the latch.
     548:	80 91 9b 02 	lds	r24, 0x029B
     54c:	90 91 9c 02 	lds	r25, 0x029C
     550:	a0 91 9d 02 	lds	r26, 0x029D
     554:	b0 91 9e 02 	lds	r27, 0x029E
     558:	89 2f       	mov	r24, r25
     55a:	9a 2f       	mov	r25, r26
     55c:	ab 2f       	mov	r26, r27
     55e:	bb 27       	eor	r27, r27
     560:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     562:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     564:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_0].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     566:	80 91 9b 02 	lds	r24, 0x029B
     56a:	90 91 9c 02 	lds	r25, 0x029C
     56e:	a0 91 9d 02 	lds	r26, 0x029D
     572:	b0 91 9e 02 	lds	r27, 0x029E
     576:	cd 01       	movw	r24, r26
     578:	aa 27       	eor	r26, r26
     57a:	bb 27       	eor	r27, r27
     57c:	87 70       	andi	r24, 0x07	; 7
     57e:	88 68       	ori	r24, 0x88	; 136
     580:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     582:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     584:	12 98       	cbi	0x02, 2	; 2

		// Calculate new address while bus settles (were nops in here)

		if(bankStates[BANK_0].granularSlices)		// Big ugly conditional branch
     586:	80 91 82 02 	lds	r24, 0x0282
     58a:	88 23       	and	r24, r24
     58c:	09 f4       	brne	.+2      	; 0x590 <UpdateAudioChannel0+0x49e>
     58e:	6c c0       	rjmp	.+216    	; 0x668 <UpdateAudioChannel0+0x576>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_0])	// Moving through our current slice?
     590:	80 91 4e 01 	lds	r24, 0x014E
     594:	90 91 4f 01 	lds	r25, 0x014F
     598:	a0 91 50 01 	lds	r26, 0x0150
     59c:	b0 91 51 01 	lds	r27, 0x0151
     5a0:	00 97       	sbiw	r24, 0x00	; 0
     5a2:	a1 05       	cpc	r26, r1
     5a4:	b1 05       	cpc	r27, r1
     5a6:	39 f1       	breq	.+78     	; 0x5f6 <UpdateAudioChannel0+0x504>
			{
				bankStates[BANK_0].currentAddress++;
     5a8:	80 91 9b 02 	lds	r24, 0x029B
     5ac:	90 91 9c 02 	lds	r25, 0x029C
     5b0:	a0 91 9d 02 	lds	r26, 0x029D
     5b4:	b0 91 9e 02 	lds	r27, 0x029E
     5b8:	01 96       	adiw	r24, 0x01	; 1
     5ba:	a1 1d       	adc	r26, r1
     5bc:	b1 1d       	adc	r27, r1
     5be:	80 93 9b 02 	sts	0x029B, r24
     5c2:	90 93 9c 02 	sts	0x029C, r25
     5c6:	a0 93 9d 02 	sts	0x029D, r26
     5ca:	b0 93 9e 02 	sts	0x029E, r27
				sliceRemaining[BANK_0]--;
     5ce:	80 91 4e 01 	lds	r24, 0x014E
     5d2:	90 91 4f 01 	lds	r25, 0x014F
     5d6:	a0 91 50 01 	lds	r26, 0x0150
     5da:	b0 91 51 01 	lds	r27, 0x0151
     5de:	01 97       	sbiw	r24, 0x01	; 1
     5e0:	a1 09       	sbc	r26, r1
     5e2:	b1 09       	sbc	r27, r1
     5e4:	80 93 4e 01 	sts	0x014E, r24
     5e8:	90 93 4f 01 	sts	0x014F, r25
     5ec:	a0 93 50 01 	sts	0x0150, r26
     5f0:	b0 93 51 01 	sts	0x0151, r27
     5f4:	0d c1       	rjmp	.+538    	; 0x810 <UpdateAudioChannel0+0x71e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_0]=sliceSize[BANK_0];	// Reload the slice counter.
     5f6:	80 91 46 01 	lds	r24, 0x0146
     5fa:	90 91 47 01 	lds	r25, 0x0147
     5fe:	a0 91 48 01 	lds	r26, 0x0148
     602:	b0 91 49 01 	lds	r27, 0x0149
     606:	80 93 4e 01 	sts	0x014E, r24
     60a:	90 93 4f 01 	sts	0x014F, r25
     60e:	a0 93 50 01 	sts	0x0150, r26
     612:	b0 93 51 01 	sts	0x0151, r27
				granularPositionArrayPointer[BANK_0]++;	// Point to the next slice in memory.
     616:	80 91 44 01 	lds	r24, 0x0144
     61a:	8f 5f       	subi	r24, 0xFF	; 255
     61c:	80 93 44 01 	sts	0x0144, r24

				if(granularPositionArrayPointer[BANK_0]==bankStates[BANK_0].granularSlices)
     620:	90 91 44 01 	lds	r25, 0x0144
     624:	80 91 82 02 	lds	r24, 0x0282
     628:	98 17       	cp	r25, r24
     62a:	11 f4       	brne	.+4      	; 0x630 <UpdateAudioChannel0+0x53e>
				{
					granularPositionArrayPointer[BANK_0]=0;	// Point back at the first slice.
     62c:	10 92 44 01 	sts	0x0144, r1
				}

				bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][granularPositionArrayPointer[BANK_0]]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);									
     630:	e0 91 44 01 	lds	r30, 0x0144
     634:	20 91 46 01 	lds	r18, 0x0146
     638:	30 91 47 01 	lds	r19, 0x0147
     63c:	40 91 48 01 	lds	r20, 0x0148
     640:	50 91 49 01 	lds	r21, 0x0149
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	ea 5a       	subi	r30, 0xAA	; 170
     648:	fe 4f       	sbci	r31, 0xFE	; 254
     64a:	60 81       	ld	r22, Z
     64c:	70 e0       	ldi	r23, 0x00	; 0
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
     656:	60 93 9b 02 	sts	0x029B, r22
     65a:	70 93 9c 02 	sts	0x029C, r23
     65e:	80 93 9d 02 	sts	0x029D, r24
     662:	90 93 9e 02 	sts	0x029E, r25
     666:	d4 c0       	rjmp	.+424    	; 0x810 <UpdateAudioChannel0+0x71e>
			}		
		}
		else
		{
			if(bankStates[BANK_0].sampleDirection==false)	// Paul is dead?  Devil voices?
     668:	80 91 81 02 	lds	r24, 0x0281
     66c:	88 23       	and	r24, r24
     66e:	09 f0       	breq	.+2      	; 0x672 <UpdateAudioChannel0+0x580>
     670:	62 c0       	rjmp	.+196    	; 0x736 <UpdateAudioChannel0+0x644>
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     672:	20 91 9b 02 	lds	r18, 0x029B
     676:	30 91 9c 02 	lds	r19, 0x029C
     67a:	40 91 9d 02 	lds	r20, 0x029D
     67e:	50 91 9e 02 	lds	r21, 0x029E
     682:	80 91 94 02 	lds	r24, 0x0294
     686:	90 91 95 02 	lds	r25, 0x0295
     68a:	a0 91 96 02 	lds	r26, 0x0296
     68e:	b0 91 97 02 	lds	r27, 0x0297
     692:	28 17       	cp	r18, r24
     694:	39 07       	cpc	r19, r25
     696:	4a 07       	cpc	r20, r26
     698:	5b 07       	cpc	r21, r27
     69a:	29 f4       	brne	.+10     	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     69c:	80 91 7e 02 	lds	r24, 0x027E
     6a0:	81 30       	cpi	r24, 0x01	; 1
     6a2:	09 f4       	brne	.+2      	; 0x6a6 <UpdateAudioChannel0+0x5b4>
     6a4:	61 c0       	rjmp	.+194    	; 0x768 <UpdateAudioChannel0+0x676>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
					bankStates[BANK_0].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     6a6:	20 91 9b 02 	lds	r18, 0x029B
     6aa:	30 91 9c 02 	lds	r19, 0x029C
     6ae:	40 91 9d 02 	lds	r20, 0x029D
     6b2:	50 91 9e 02 	lds	r21, 0x029E
     6b6:	80 91 94 02 	lds	r24, 0x0294
     6ba:	90 91 95 02 	lds	r25, 0x0295
     6be:	a0 91 96 02 	lds	r26, 0x0296
     6c2:	b0 91 97 02 	lds	r27, 0x0297
     6c6:	28 17       	cp	r18, r24
     6c8:	39 07       	cpc	r19, r25
     6ca:	4a 07       	cpc	r20, r26
     6cc:	5b 07       	cpc	r21, r27
     6ce:	49 f4       	brne	.+18     	; 0x6e2 <UpdateAudioChannel0+0x5f0>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;			// Back to the, um, future.
     6d0:	80 91 90 02 	lds	r24, 0x0290
     6d4:	90 91 91 02 	lds	r25, 0x0291
     6d8:	a0 91 92 02 	lds	r26, 0x0292
     6dc:	b0 91 93 02 	lds	r27, 0x0293
     6e0:	8f c0       	rjmp	.+286    	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     6e2:	20 91 9b 02 	lds	r18, 0x029B
     6e6:	30 91 9c 02 	lds	r19, 0x029C
     6ea:	40 91 9d 02 	lds	r20, 0x029D
     6ee:	50 91 9e 02 	lds	r21, 0x029E
     6f2:	80 91 8c 02 	lds	r24, 0x028C
     6f6:	90 91 8d 02 	lds	r25, 0x028D
     6fa:	a0 91 8e 02 	lds	r26, 0x028E
     6fe:	b0 91 8f 02 	lds	r27, 0x028F
     702:	28 17       	cp	r18, r24
     704:	39 07       	cpc	r19, r25
     706:	4a 07       	cpc	r20, r26
     708:	5b 07       	cpc	r21, r27
     70a:	49 f4       	brne	.+18     	; 0x71e <UpdateAudioChannel0+0x62c>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].endAddress;		// Assume we're looping through to some relative start and end.
     70c:	80 91 88 02 	lds	r24, 0x0288
     710:	90 91 89 02 	lds	r25, 0x0289
     714:	a0 91 8a 02 	lds	r26, 0x028A
     718:	b0 91 8b 02 	lds	r27, 0x028B
     71c:	71 c0       	rjmp	.+226    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress--;		// In BANK_0, the beginning is low.
     71e:	80 91 9b 02 	lds	r24, 0x029B
     722:	90 91 9c 02 	lds	r25, 0x029C
     726:	a0 91 9d 02 	lds	r26, 0x029D
     72a:	b0 91 9e 02 	lds	r27, 0x029E
     72e:	01 97       	sbiw	r24, 0x01	; 1
     730:	a1 09       	sbc	r26, r1
     732:	b1 09       	sbc	r27, r1
     734:	65 c0       	rjmp	.+202    	; 0x800 <UpdateAudioChannel0+0x70e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)&&(bankStates[BANK_0].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     736:	20 91 9b 02 	lds	r18, 0x029B
     73a:	30 91 9c 02 	lds	r19, 0x029C
     73e:	40 91 9d 02 	lds	r20, 0x029D
     742:	50 91 9e 02 	lds	r21, 0x029E
     746:	80 91 90 02 	lds	r24, 0x0290
     74a:	90 91 91 02 	lds	r25, 0x0291
     74e:	a0 91 92 02 	lds	r26, 0x0292
     752:	b0 91 93 02 	lds	r27, 0x0293
     756:	28 17       	cp	r18, r24
     758:	39 07       	cpc	r19, r25
     75a:	4a 07       	cpc	r20, r26
     75c:	5b 07       	cpc	r21, r27
     75e:	49 f4       	brne	.+18     	; 0x772 <UpdateAudioChannel0+0x680>
     760:	80 91 7e 02 	lds	r24, 0x027E
     764:	81 30       	cpi	r24, 0x01	; 1
     766:	29 f4       	brne	.+10     	; 0x772 <UpdateAudioChannel0+0x680>
				{
					bankStates[BANK_0].audioFunction=AUDIO_IDLE;
     768:	10 92 7d 02 	sts	0x027D, r1
					bankStates[BANK_0].clockMode=CLK_NONE;
     76c:	10 92 85 02 	sts	0x0285, r1
     770:	4f c0       	rjmp	.+158    	; 0x810 <UpdateAudioChannel0+0x71e>
				}
				else if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     772:	20 91 9b 02 	lds	r18, 0x029B
     776:	30 91 9c 02 	lds	r19, 0x029C
     77a:	40 91 9d 02 	lds	r20, 0x029D
     77e:	50 91 9e 02 	lds	r21, 0x029E
     782:	80 91 90 02 	lds	r24, 0x0290
     786:	90 91 91 02 	lds	r25, 0x0291
     78a:	a0 91 92 02 	lds	r26, 0x0292
     78e:	b0 91 93 02 	lds	r27, 0x0293
     792:	28 17       	cp	r18, r24
     794:	39 07       	cpc	r19, r25
     796:	4a 07       	cpc	r20, r26
     798:	5b 07       	cpc	r21, r27
     79a:	49 f4       	brne	.+18     	; 0x7ae <UpdateAudioChannel0+0x6bc>
				{
					bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;			// Loop around to the beginning.
     79c:	80 91 94 02 	lds	r24, 0x0294
     7a0:	90 91 95 02 	lds	r25, 0x0295
     7a4:	a0 91 96 02 	lds	r26, 0x0296
     7a8:	b0 91 97 02 	lds	r27, 0x0297
     7ac:	29 c0       	rjmp	.+82     	; 0x800 <UpdateAudioChannel0+0x70e>
				}
				else
				{
					if(bankStates[BANK_0].currentAddress==bankStates[BANK_0].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     7ae:	20 91 9b 02 	lds	r18, 0x029B
     7b2:	30 91 9c 02 	lds	r19, 0x029C
     7b6:	40 91 9d 02 	lds	r20, 0x029D
     7ba:	50 91 9e 02 	lds	r21, 0x029E
     7be:	80 91 88 02 	lds	r24, 0x0288
     7c2:	90 91 89 02 	lds	r25, 0x0289
     7c6:	a0 91 8a 02 	lds	r26, 0x028A
     7ca:	b0 91 8b 02 	lds	r27, 0x028B
     7ce:	28 17       	cp	r18, r24
     7d0:	39 07       	cpc	r19, r25
     7d2:	4a 07       	cpc	r20, r26
     7d4:	5b 07       	cpc	r21, r27
     7d6:	49 f4       	brne	.+18     	; 0x7ea <UpdateAudioChannel0+0x6f8>
					{
						bankStates[BANK_0].currentAddress=bankStates[BANK_0].startAddress;	// Assume we're looping through to some relative start and end.
     7d8:	80 91 8c 02 	lds	r24, 0x028C
     7dc:	90 91 8d 02 	lds	r25, 0x028D
     7e0:	a0 91 8e 02 	lds	r26, 0x028E
     7e4:	b0 91 8f 02 	lds	r27, 0x028F
     7e8:	0b c0       	rjmp	.+22     	; 0x800 <UpdateAudioChannel0+0x70e>
					}
					else
					{
						bankStates[BANK_0].currentAddress++;		// In BANK_0, the end is high.
     7ea:	80 91 9b 02 	lds	r24, 0x029B
     7ee:	90 91 9c 02 	lds	r25, 0x029C
     7f2:	a0 91 9d 02 	lds	r26, 0x029D
     7f6:	b0 91 9e 02 	lds	r27, 0x029E
     7fa:	01 96       	adiw	r24, 0x01	; 1
     7fc:	a1 1d       	adc	r26, r1
     7fe:	b1 1d       	adc	r27, r1
     800:	80 93 9b 02 	sts	0x029B, r24
     804:	90 93 9c 02 	sts	0x029C, r25
     808:	a0 93 9d 02 	sts	0x029D, r26
     80c:	b0 93 9e 02 	sts	0x029E, r27
			}
		}

		// Finished calculating address, bus should be settled, so finish the exchange with RAM		

		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     810:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     812:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     814:	8f ef       	ldi	r24, 0xFF	; 255
     816:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_0].bitReduction)	// Low bit rate?
     818:	80 91 84 02 	lds	r24, 0x0284
     81c:	88 23       	and	r24, r24
     81e:	61 f0       	breq	.+24     	; 0x838 <UpdateAudioChannel0+0x746>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     820:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_0].bitReduction);		// Mask off however many bits we're supposed to.
     822:	20 91 84 02 	lds	r18, 0x0284
     826:	8f ef       	ldi	r24, 0xFF	; 255
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	02 c0       	rjmp	.+4      	; 0x830 <UpdateAudioChannel0+0x73e>
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	2a 95       	dec	r18
     832:	e2 f7       	brpl	.-8      	; 0x82c <UpdateAudioChannel0+0x73a>
     834:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     836:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     838:	24 2f       	mov	r18, r20
     83a:	33 27       	eor	r19, r19
     83c:	27 fd       	sbrc	r18, 7
     83e:	30 95       	com	r19
     840:	80 91 56 02 	lds	r24, 0x0256
     844:	99 27       	eor	r25, r25
     846:	87 fd       	sbrc	r24, 7
     848:	90 95       	com	r25
     84a:	28 0f       	add	r18, r24
     84c:	39 1f       	adc	r19, r25
     84e:	8f ef       	ldi	r24, 0xFF	; 255
     850:	20 38       	cpi	r18, 0x80	; 128
     852:	38 07       	cpc	r19, r24
     854:	14 f4       	brge	.+4      	; 0x85a <UpdateAudioChannel0+0x768>
     856:	20 e8       	ldi	r18, 0x80	; 128
     858:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     85a:	c9 01       	movw	r24, r18
     85c:	20 38       	cpi	r18, 0x80	; 128
     85e:	31 05       	cpc	r19, r1
     860:	14 f0       	brlt	.+4      	; 0x866 <UpdateAudioChannel0+0x774>
     862:	8f e7       	ldi	r24, 0x7F	; 127
     864:	90 e0       	ldi	r25, 0x00	; 0
     866:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
     868:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
     86a:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
     86c:	84 2f       	mov	r24, r20
     86e:	08 95       	ret

00000870 <UpdateAudioChannel1>:
	static unsigned char
		sawtooth;		// Used for generating sawteeth.

	outputByte=0;		// Pass out midscale by default.

	switch(bankStates[BANK_1].audioFunction)
     870:	80 91 9f 02 	lds	r24, 0x029F
     874:	83 30       	cpi	r24, 0x03	; 3
     876:	c9 f0       	breq	.+50     	; 0x8aa <UpdateAudioChannel1+0x3a>
     878:	84 30       	cpi	r24, 0x04	; 4
     87a:	30 f4       	brcc	.+12     	; 0x888 <UpdateAudioChannel1+0x18>
     87c:	81 30       	cpi	r24, 0x01	; 1
     87e:	59 f0       	breq	.+22     	; 0x896 <UpdateAudioChannel1+0x26>
     880:	82 30       	cpi	r24, 0x02	; 2
     882:	09 f0       	breq	.+2      	; 0x886 <UpdateAudioChannel1+0x16>
     884:	8e c0       	rjmp	.+284    	; 0x9a2 <UpdateAudioChannel1+0x132>
     886:	0e c0       	rjmp	.+28     	; 0x8a4 <UpdateAudioChannel1+0x34>
     888:	84 30       	cpi	r24, 0x04	; 4
     88a:	09 f4       	brne	.+2      	; 0x88e <UpdateAudioChannel1+0x1e>
     88c:	8c c0       	rjmp	.+280    	; 0x9a6 <UpdateAudioChannel1+0x136>
     88e:	85 30       	cpi	r24, 0x05	; 5
     890:	09 f0       	breq	.+2      	; 0x894 <UpdateAudioChannel1+0x24>
     892:	87 c0       	rjmp	.+270    	; 0x9a2 <UpdateAudioChannel1+0x132>
     894:	15 c2       	rjmp	.+1066   	; 0xcc0 <UpdateAudioChannel1+0x450>
	{

		case AUDIO_SAWTOOTH:
		// Puts out a noble sawtooth wave.  Doesn't talk to the RAM at all.
		outputByte=sawtooth++;			// Increment a variable for the dac and just pass it back out.
     896:	40 91 32 01 	lds	r20, 0x0132
     89a:	4f 5f       	subi	r20, 0xFF	; 255
     89c:	40 93 32 01 	sts	0x0132, r20
     8a0:	41 50       	subi	r20, 0x01	; 1
     8a2:	b3 c3       	rjmp	.+1894   	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_REALTIME:
		// Does FX in realtime to the input -- just grabs an ADC byte, effects it, and spits it out.  No RAM usage.  Used to bit reduce, alias, or multiply an input in real time.
		outputByte=adcByte;				// Grab the value from the ADC, and put it back out.
     8a4:	40 91 56 02 	lds	r20, 0x0256
     8a8:	f9 c1       	rjmp	.+1010   	; 0xc9c <UpdateAudioChannel1+0x42c>
		}		
		break;

		case AUDIO_RECORD:
		// Samples the current ADC channel and loads it into RAM.  Overwrites whatever is there and ALWAYS writes from the beginning of the sample to the end.
		LATCH_DDR=0xFF;						// Data bus to output -- we never need to read the RAM in this version of the ISR.
     8aa:	8f ef       	ldi	r24, 0xFF	; 255
     8ac:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     8ae:	80 91 bd 02 	lds	r24, 0x02BD
     8b2:	90 91 be 02 	lds	r25, 0x02BE
     8b6:	a0 91 bf 02 	lds	r26, 0x02BF
     8ba:	b0 91 c0 02 	lds	r27, 0x02C0
     8be:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     8c0:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     8c2:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     8c4:	80 91 bd 02 	lds	r24, 0x02BD
     8c8:	90 91 be 02 	lds	r25, 0x02BE
     8cc:	a0 91 bf 02 	lds	r26, 0x02BF
     8d0:	b0 91 c0 02 	lds	r27, 0x02C0
     8d4:	89 2f       	mov	r24, r25
     8d6:	9a 2f       	mov	r25, r26
     8d8:	ab 2f       	mov	r26, r27
     8da:	bb 27       	eor	r27, r27
     8dc:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     8de:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     8e0:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     8e2:	80 91 bd 02 	lds	r24, 0x02BD
     8e6:	90 91 be 02 	lds	r25, 0x02BE
     8ea:	a0 91 bf 02 	lds	r26, 0x02BF
     8ee:	b0 91 c0 02 	lds	r27, 0x02C0
     8f2:	cd 01       	movw	r24, r26
     8f4:	aa 27       	eor	r26, r26
     8f6:	bb 27       	eor	r27, r27
     8f8:	87 70       	andi	r24, 0x07	; 7
     8fa:	88 68       	ori	r24, 0x88	; 136
     8fc:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=adcByte;				// Put the data to write on the RAM's input port
     8fe:	80 91 56 02 	lds	r24, 0x0256
     902:	85 b9       	out	0x05, r24	; 5

		// Handle address calcs while bus settles.

		bankStates[BANK_1].currentAddress--;									// Next address please.
     904:	80 91 bd 02 	lds	r24, 0x02BD
     908:	90 91 be 02 	lds	r25, 0x02BE
     90c:	a0 91 bf 02 	lds	r26, 0x02BF
     910:	b0 91 c0 02 	lds	r27, 0x02C0
     914:	01 97       	sbiw	r24, 0x01	; 1
     916:	a1 09       	sbc	r26, r1
     918:	b1 09       	sbc	r27, r1
     91a:	80 93 bd 02 	sts	0x02BD, r24
     91e:	90 93 be 02 	sts	0x02BE, r25
     922:	a0 93 bf 02 	sts	0x02BF, r26
     926:	b0 93 c0 02 	sts	0x02C0, r27
		bankStates[BANK_1].endAddress=bankStates[BANK_1].currentAddress;			// Match ending address of the sample to the current memory address.
     92a:	80 91 bd 02 	lds	r24, 0x02BD
     92e:	90 91 be 02 	lds	r25, 0x02BE
     932:	a0 91 bf 02 	lds	r26, 0x02BF
     936:	b0 91 c0 02 	lds	r27, 0x02C0
     93a:	80 93 aa 02 	sts	0x02AA, r24
     93e:	90 93 ab 02 	sts	0x02AB, r25
     942:	a0 93 ac 02 	sts	0x02AC, r26
     946:	b0 93 ad 02 	sts	0x02AD, r27
		bankStates[BANK_1].adjustedEndAddress=bankStates[BANK_1].currentAddress;	// Match ending address of our user-trimmed loop (user has not done trimming yet).
     94a:	80 91 bd 02 	lds	r24, 0x02BD
     94e:	90 91 be 02 	lds	r25, 0x02BE
     952:	a0 91 bf 02 	lds	r26, 0x02BF
     956:	b0 91 c0 02 	lds	r27, 0x02C0
     95a:	80 93 b2 02 	sts	0x02B2, r24
     95e:	90 93 b3 02 	sts	0x02B3, r25
     962:	a0 93 b4 02 	sts	0x02B4, r26
     966:	b0 93 b5 02 	sts	0x02B5, r27

		if(bankStates[BANK_0].endAddress>=bankStates[BANK_1].endAddress)	// Banks stepping on each other?  Note, this test will result in one overlapping RAM location.
     96a:	20 91 88 02 	lds	r18, 0x0288
     96e:	30 91 89 02 	lds	r19, 0x0289
     972:	40 91 8a 02 	lds	r20, 0x028A
     976:	50 91 8b 02 	lds	r21, 0x028B
     97a:	80 91 aa 02 	lds	r24, 0x02AA
     97e:	90 91 ab 02 	lds	r25, 0x02AB
     982:	a0 91 ac 02 	lds	r26, 0x02AC
     986:	b0 91 ad 02 	lds	r27, 0x02AD
     98a:	28 17       	cp	r18, r24
     98c:	39 07       	cpc	r19, r25
     98e:	4a 07       	cpc	r20, r26
     990:	5b 07       	cpc	r21, r27
     992:	28 f0       	brcs	.+10     	; 0x99e <UpdateAudioChannel1+0x12e>
		{
			bankStates[BANK_1].audioFunction=AUDIO_IDLE;	// Stop recording on this channel.
     994:	10 92 9f 02 	sts	0x029F, r1
			outOfRam=true;									// Signal mainline code that we're out of memory.
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	80 93 40 01 	sts	0x0140, r24
		}

		// Put data into RAM.
		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
     99e:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
     9a0:	11 9a       	sbi	0x02, 1	; 2
     9a2:	40 e0       	ldi	r20, 0x00	; 0
     9a4:	32 c3       	rjmp	.+1636   	; 0x100a <UpdateAudioChannel1+0x79a>
		// Goes through RAM and spits out bytes, looping (usually) from the beginning of the sample to the end.
		// The playback ISR also allows the various effects to change the output.
		// Since we cannot count on the OE staying low or the AVR's DDR remaining an input, we will explicitly set all the registers we need to every time through this ISR.

		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     9a6:	80 91 bd 02 	lds	r24, 0x02BD
     9aa:	90 91 be 02 	lds	r25, 0x02BE
     9ae:	a0 91 bf 02 	lds	r26, 0x02BF
     9b2:	b0 91 c0 02 	lds	r27, 0x02C0
     9b6:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     9b8:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     9ba:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     9bc:	80 91 bd 02 	lds	r24, 0x02BD
     9c0:	90 91 be 02 	lds	r25, 0x02BE
     9c4:	a0 91 bf 02 	lds	r26, 0x02BF
     9c8:	b0 91 c0 02 	lds	r27, 0x02C0
     9cc:	89 2f       	mov	r24, r25
     9ce:	9a 2f       	mov	r25, r26
     9d0:	ab 2f       	mov	r26, r27
     9d2:	bb 27       	eor	r27, r27
     9d4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     9d6:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     9d8:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     9da:	80 91 bd 02 	lds	r24, 0x02BD
     9de:	90 91 be 02 	lds	r25, 0x02BE
     9e2:	a0 91 bf 02 	lds	r26, 0x02BF
     9e6:	b0 91 c0 02 	lds	r27, 0x02C0
     9ea:	cd 01       	movw	r24, r26
     9ec:	aa 27       	eor	r26, r26
     9ee:	bb 27       	eor	r27, r27
     9f0:	87 70       	andi	r24, 0x07	; 7
     9f2:	88 68       	ori	r24, 0x88	; 136
     9f4:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     9f6:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     9f8:	12 98       	cbi	0x02, 2	; 2

		// Calculate addy while bus settles (used to be nops here)

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     9fa:	80 91 a4 02 	lds	r24, 0x02A4
     9fe:	88 23       	and	r24, r24
     a00:	09 f4       	brne	.+2      	; 0xa04 <UpdateAudioChannel1+0x194>
     a02:	74 c0       	rjmp	.+232    	; 0xaec <UpdateAudioChannel1+0x27c>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     a04:	80 91 52 01 	lds	r24, 0x0152
     a08:	90 91 53 01 	lds	r25, 0x0153
     a0c:	a0 91 54 01 	lds	r26, 0x0154
     a10:	b0 91 55 01 	lds	r27, 0x0155
     a14:	00 97       	sbiw	r24, 0x00	; 0
     a16:	a1 05       	cpc	r26, r1
     a18:	b1 05       	cpc	r27, r1
     a1a:	39 f1       	breq	.+78     	; 0xa6a <UpdateAudioChannel1+0x1fa>
			{
				bankStates[BANK_1].currentAddress--;
     a1c:	80 91 bd 02 	lds	r24, 0x02BD
     a20:	90 91 be 02 	lds	r25, 0x02BE
     a24:	a0 91 bf 02 	lds	r26, 0x02BF
     a28:	b0 91 c0 02 	lds	r27, 0x02C0
     a2c:	01 97       	sbiw	r24, 0x01	; 1
     a2e:	a1 09       	sbc	r26, r1
     a30:	b1 09       	sbc	r27, r1
     a32:	80 93 bd 02 	sts	0x02BD, r24
     a36:	90 93 be 02 	sts	0x02BE, r25
     a3a:	a0 93 bf 02 	sts	0x02BF, r26
     a3e:	b0 93 c0 02 	sts	0x02C0, r27
				sliceRemaining[BANK_1]--;
     a42:	80 91 52 01 	lds	r24, 0x0152
     a46:	90 91 53 01 	lds	r25, 0x0153
     a4a:	a0 91 54 01 	lds	r26, 0x0154
     a4e:	b0 91 55 01 	lds	r27, 0x0155
     a52:	01 97       	sbiw	r24, 0x01	; 1
     a54:	a1 09       	sbc	r26, r1
     a56:	b1 09       	sbc	r27, r1
     a58:	80 93 52 01 	sts	0x0152, r24
     a5c:	90 93 53 01 	sts	0x0153, r25
     a60:	a0 93 54 01 	sts	0x0154, r26
     a64:	b0 93 55 01 	sts	0x0155, r27
     a68:	15 c1       	rjmp	.+554    	; 0xc94 <UpdateAudioChannel1+0x424>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     a6a:	80 91 4a 01 	lds	r24, 0x014A
     a6e:	90 91 4b 01 	lds	r25, 0x014B
     a72:	a0 91 4c 01 	lds	r26, 0x014C
     a76:	b0 91 4d 01 	lds	r27, 0x014D
     a7a:	80 93 52 01 	sts	0x0152, r24
     a7e:	90 93 53 01 	sts	0x0153, r25
     a82:	a0 93 54 01 	sts	0x0154, r26
     a86:	b0 93 55 01 	sts	0x0155, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     a8a:	80 91 45 01 	lds	r24, 0x0145
     a8e:	8f 5f       	subi	r24, 0xFF	; 255
     a90:	80 93 45 01 	sts	0x0145, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     a94:	90 91 45 01 	lds	r25, 0x0145
     a98:	80 91 a4 02 	lds	r24, 0x02A4
     a9c:	98 17       	cp	r25, r24
     a9e:	11 f4       	brne	.+4      	; 0xaa4 <UpdateAudioChannel1+0x234>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     aa0:	10 92 45 01 	sts	0x0145, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     aa4:	e0 91 45 01 	lds	r30, 0x0145
     aa8:	20 91 4a 01 	lds	r18, 0x014A
     aac:	30 91 4b 01 	lds	r19, 0x014B
     ab0:	40 91 4c 01 	lds	r20, 0x014C
     ab4:	50 91 4d 01 	lds	r21, 0x014D
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	ea 52       	subi	r30, 0x2A	; 42
     abc:	fe 4f       	sbci	r31, 0xFE	; 254
     abe:	60 81       	ld	r22, Z
     ac0:	70 e0       	ldi	r23, 0x00	; 0
     ac2:	80 e0       	ldi	r24, 0x00	; 0
     ac4:	90 e0       	ldi	r25, 0x00	; 0
     ac6:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
     aca:	2f ef       	ldi	r18, 0xFF	; 255
     acc:	3f ef       	ldi	r19, 0xFF	; 255
     ace:	47 e0       	ldi	r20, 0x07	; 7
     ad0:	50 e0       	ldi	r21, 0x00	; 0
     ad2:	26 1b       	sub	r18, r22
     ad4:	37 0b       	sbc	r19, r23
     ad6:	48 0b       	sbc	r20, r24
     ad8:	59 0b       	sbc	r21, r25
     ada:	20 93 bd 02 	sts	0x02BD, r18
     ade:	30 93 be 02 	sts	0x02BE, r19
     ae2:	40 93 bf 02 	sts	0x02BF, r20
     ae6:	50 93 c0 02 	sts	0x02C0, r21
     aea:	d4 c0       	rjmp	.+424    	; 0xc94 <UpdateAudioChannel1+0x424>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     aec:	80 91 a3 02 	lds	r24, 0x02A3
     af0:	88 23       	and	r24, r24
     af2:	09 f0       	breq	.+2      	; 0xaf6 <UpdateAudioChannel1+0x286>
     af4:	62 c0       	rjmp	.+196    	; 0xbba <UpdateAudioChannel1+0x34a>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     af6:	20 91 bd 02 	lds	r18, 0x02BD
     afa:	30 91 be 02 	lds	r19, 0x02BE
     afe:	40 91 bf 02 	lds	r20, 0x02BF
     b02:	50 91 c0 02 	lds	r21, 0x02C0
     b06:	80 91 b6 02 	lds	r24, 0x02B6
     b0a:	90 91 b7 02 	lds	r25, 0x02B7
     b0e:	a0 91 b8 02 	lds	r26, 0x02B8
     b12:	b0 91 b9 02 	lds	r27, 0x02B9
     b16:	28 17       	cp	r18, r24
     b18:	39 07       	cpc	r19, r25
     b1a:	4a 07       	cpc	r20, r26
     b1c:	5b 07       	cpc	r21, r27
     b1e:	29 f4       	brne	.+10     	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b20:	80 91 a0 02 	lds	r24, 0x02A0
     b24:	81 30       	cpi	r24, 0x01	; 1
     b26:	09 f4       	brne	.+2      	; 0xb2a <UpdateAudioChannel1+0x2ba>
     b28:	61 c0       	rjmp	.+194    	; 0xbec <UpdateAudioChannel1+0x37c>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     b2a:	20 91 bd 02 	lds	r18, 0x02BD
     b2e:	30 91 be 02 	lds	r19, 0x02BE
     b32:	40 91 bf 02 	lds	r20, 0x02BF
     b36:	50 91 c0 02 	lds	r21, 0x02C0
     b3a:	80 91 b6 02 	lds	r24, 0x02B6
     b3e:	90 91 b7 02 	lds	r25, 0x02B7
     b42:	a0 91 b8 02 	lds	r26, 0x02B8
     b46:	b0 91 b9 02 	lds	r27, 0x02B9
     b4a:	28 17       	cp	r18, r24
     b4c:	39 07       	cpc	r19, r25
     b4e:	4a 07       	cpc	r20, r26
     b50:	5b 07       	cpc	r21, r27
     b52:	49 f4       	brne	.+18     	; 0xb66 <UpdateAudioChannel1+0x2f6>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     b54:	80 91 b2 02 	lds	r24, 0x02B2
     b58:	90 91 b3 02 	lds	r25, 0x02B3
     b5c:	a0 91 b4 02 	lds	r26, 0x02B4
     b60:	b0 91 b5 02 	lds	r27, 0x02B5
     b64:	8f c0       	rjmp	.+286    	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     b66:	20 91 bd 02 	lds	r18, 0x02BD
     b6a:	30 91 be 02 	lds	r19, 0x02BE
     b6e:	40 91 bf 02 	lds	r20, 0x02BF
     b72:	50 91 c0 02 	lds	r21, 0x02C0
     b76:	80 91 ae 02 	lds	r24, 0x02AE
     b7a:	90 91 af 02 	lds	r25, 0x02AF
     b7e:	a0 91 b0 02 	lds	r26, 0x02B0
     b82:	b0 91 b1 02 	lds	r27, 0x02B1
     b86:	28 17       	cp	r18, r24
     b88:	39 07       	cpc	r19, r25
     b8a:	4a 07       	cpc	r20, r26
     b8c:	5b 07       	cpc	r21, r27
     b8e:	49 f4       	brne	.+18     	; 0xba2 <UpdateAudioChannel1+0x332>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     b90:	80 91 aa 02 	lds	r24, 0x02AA
     b94:	90 91 ab 02 	lds	r25, 0x02AB
     b98:	a0 91 ac 02 	lds	r26, 0x02AC
     b9c:	b0 91 ad 02 	lds	r27, 0x02AD
     ba0:	71 c0       	rjmp	.+226    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ba2:	80 91 bd 02 	lds	r24, 0x02BD
     ba6:	90 91 be 02 	lds	r25, 0x02BE
     baa:	a0 91 bf 02 	lds	r26, 0x02BF
     bae:	b0 91 c0 02 	lds	r27, 0x02C0
     bb2:	01 96       	adiw	r24, 0x01	; 1
     bb4:	a1 1d       	adc	r26, r1
     bb6:	b1 1d       	adc	r27, r1
     bb8:	65 c0       	rjmp	.+202    	; 0xc84 <UpdateAudioChannel1+0x414>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     bba:	20 91 bd 02 	lds	r18, 0x02BD
     bbe:	30 91 be 02 	lds	r19, 0x02BE
     bc2:	40 91 bf 02 	lds	r20, 0x02BF
     bc6:	50 91 c0 02 	lds	r21, 0x02C0
     bca:	80 91 b2 02 	lds	r24, 0x02B2
     bce:	90 91 b3 02 	lds	r25, 0x02B3
     bd2:	a0 91 b4 02 	lds	r26, 0x02B4
     bd6:	b0 91 b5 02 	lds	r27, 0x02B5
     bda:	28 17       	cp	r18, r24
     bdc:	39 07       	cpc	r19, r25
     bde:	4a 07       	cpc	r20, r26
     be0:	5b 07       	cpc	r21, r27
     be2:	49 f4       	brne	.+18     	; 0xbf6 <UpdateAudioChannel1+0x386>
     be4:	80 91 a0 02 	lds	r24, 0x02A0
     be8:	81 30       	cpi	r24, 0x01	; 1
     bea:	29 f4       	brne	.+10     	; 0xbf6 <UpdateAudioChannel1+0x386>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     bec:	10 92 9f 02 	sts	0x029F, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     bf0:	10 92 a7 02 	sts	0x02A7, r1
     bf4:	4f c0       	rjmp	.+158    	; 0xc94 <UpdateAudioChannel1+0x424>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     bf6:	20 91 bd 02 	lds	r18, 0x02BD
     bfa:	30 91 be 02 	lds	r19, 0x02BE
     bfe:	40 91 bf 02 	lds	r20, 0x02BF
     c02:	50 91 c0 02 	lds	r21, 0x02C0
     c06:	80 91 b2 02 	lds	r24, 0x02B2
     c0a:	90 91 b3 02 	lds	r25, 0x02B3
     c0e:	a0 91 b4 02 	lds	r26, 0x02B4
     c12:	b0 91 b5 02 	lds	r27, 0x02B5
     c16:	28 17       	cp	r18, r24
     c18:	39 07       	cpc	r19, r25
     c1a:	4a 07       	cpc	r20, r26
     c1c:	5b 07       	cpc	r21, r27
     c1e:	49 f4       	brne	.+18     	; 0xc32 <UpdateAudioChannel1+0x3c2>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     c20:	80 91 b6 02 	lds	r24, 0x02B6
     c24:	90 91 b7 02 	lds	r25, 0x02B7
     c28:	a0 91 b8 02 	lds	r26, 0x02B8
     c2c:	b0 91 b9 02 	lds	r27, 0x02B9
     c30:	29 c0       	rjmp	.+82     	; 0xc84 <UpdateAudioChannel1+0x414>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     c32:	20 91 bd 02 	lds	r18, 0x02BD
     c36:	30 91 be 02 	lds	r19, 0x02BE
     c3a:	40 91 bf 02 	lds	r20, 0x02BF
     c3e:	50 91 c0 02 	lds	r21, 0x02C0
     c42:	80 91 aa 02 	lds	r24, 0x02AA
     c46:	90 91 ab 02 	lds	r25, 0x02AB
     c4a:	a0 91 ac 02 	lds	r26, 0x02AC
     c4e:	b0 91 ad 02 	lds	r27, 0x02AD
     c52:	28 17       	cp	r18, r24
     c54:	39 07       	cpc	r19, r25
     c56:	4a 07       	cpc	r20, r26
     c58:	5b 07       	cpc	r21, r27
     c5a:	49 f4       	brne	.+18     	; 0xc6e <UpdateAudioChannel1+0x3fe>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     c5c:	80 91 ae 02 	lds	r24, 0x02AE
     c60:	90 91 af 02 	lds	r25, 0x02AF
     c64:	a0 91 b0 02 	lds	r26, 0x02B0
     c68:	b0 91 b1 02 	lds	r27, 0x02B1
     c6c:	0b c0       	rjmp	.+22     	; 0xc84 <UpdateAudioChannel1+0x414>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     c6e:	80 91 bd 02 	lds	r24, 0x02BD
     c72:	90 91 be 02 	lds	r25, 0x02BE
     c76:	a0 91 bf 02 	lds	r26, 0x02BF
     c7a:	b0 91 c0 02 	lds	r27, 0x02C0
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	a1 09       	sbc	r26, r1
     c82:	b1 09       	sbc	r27, r1
     c84:	80 93 bd 02 	sts	0x02BD, r24
     c88:	90 93 be 02 	sts	0x02BE, r25
     c8c:	a0 93 bf 02 	sts	0x02BF, r26
     c90:	b0 93 c0 02 	sts	0x02C0, r27
			}
		}
		
		// Done with addy, read RAM.
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM.
     c94:	43 b1       	in	r20, 0x03	; 3
		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     c96:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     c98:	8f ef       	ldi	r24, 0xFF	; 255
     c9a:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     c9c:	80 91 a6 02 	lds	r24, 0x02A6
     ca0:	88 23       	and	r24, r24
     ca2:	09 f4       	brne	.+2      	; 0xca6 <UpdateAudioChannel1+0x436>
     ca4:	b2 c1       	rjmp	.+868    	; 0x100a <UpdateAudioChannel1+0x79a>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     ca6:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     ca8:	20 91 a6 02 	lds	r18, 0x02A6
     cac:	8f ef       	ldi	r24, 0xFF	; 255
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	02 c0       	rjmp	.+4      	; 0xcb6 <UpdateAudioChannel1+0x446>
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	2a 95       	dec	r18
     cb8:	e2 f7       	brpl	.-8      	; 0xcb2 <UpdateAudioChannel1+0x442>
     cba:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     cbc:	40 58       	subi	r20, 0x80	; 128
     cbe:	a5 c1       	rjmp	.+842    	; 0x100a <UpdateAudioChannel1+0x79a>
		break;

		case AUDIO_OVERDUB:
		// WTPA has a destructive overdub as of now.
		// Read memory (as of now all audio functions end with the LATCH_DDR as an output so we don't need to set it at the beginning of this function)
		LATCH_PORT=(bankStates[BANK_1].currentAddress);	// Put the LSB of the address on the latch.
     cc0:	80 91 bd 02 	lds	r24, 0x02BD
     cc4:	90 91 be 02 	lds	r25, 0x02BE
     cc8:	a0 91 bf 02 	lds	r26, 0x02BF
     ccc:	b0 91 c0 02 	lds	r27, 0x02C0
     cd0:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
     cd2:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
     cd4:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[BANK_1].currentAddress>>8));	// Put the middle byte of the address on the latch.
     cd6:	80 91 bd 02 	lds	r24, 0x02BD
     cda:	90 91 be 02 	lds	r25, 0x02BE
     cde:	a0 91 bf 02 	lds	r26, 0x02BF
     ce2:	b0 91 c0 02 	lds	r27, 0x02C0
     ce6:	89 2f       	mov	r24, r25
     ce8:	9a 2f       	mov	r25, r26
     cea:	ab 2f       	mov	r26, r27
     cec:	bb 27       	eor	r27, r27
     cee:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
     cf0:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
     cf2:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x88|((bankStates[BANK_1].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3), test pin high (PC7 used to time isrs), and the unused pins (PC4-6) low, and put the high addy bits on 0-2.
     cf4:	80 91 bd 02 	lds	r24, 0x02BD
     cf8:	90 91 be 02 	lds	r25, 0x02BE
     cfc:	a0 91 bf 02 	lds	r26, 0x02BF
     d00:	b0 91 c0 02 	lds	r27, 0x02C0
     d04:	cd 01       	movw	r24, r26
     d06:	aa 27       	eor	r26, r26
     d08:	bb 27       	eor	r27, r27
     d0a:	87 70       	andi	r24, 0x07	; 7
     d0c:	88 68       	ori	r24, 0x88	; 136
     d0e:	88 b9       	out	0x08, r24	; 8

		LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
     d10:	14 b8       	out	0x04, r1	; 4
		PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
     d12:	12 98       	cbi	0x02, 2	; 2

		// Do some operations while we wait for the data bus to settle from turnaround.

		if(bankStates[BANK_1].granularSlices)		// Big ugly conditional branch
     d14:	80 91 a4 02 	lds	r24, 0x02A4
     d18:	88 23       	and	r24, r24
     d1a:	09 f4       	brne	.+2      	; 0xd1e <UpdateAudioChannel1+0x4ae>
     d1c:	74 c0       	rjmp	.+232    	; 0xe06 <UpdateAudioChannel1+0x596>
		{
			// Slice first, only worry about forward ###
			
			if(sliceRemaining[BANK_1])	// Moving through our current slice?
     d1e:	80 91 52 01 	lds	r24, 0x0152
     d22:	90 91 53 01 	lds	r25, 0x0153
     d26:	a0 91 54 01 	lds	r26, 0x0154
     d2a:	b0 91 55 01 	lds	r27, 0x0155
     d2e:	00 97       	sbiw	r24, 0x00	; 0
     d30:	a1 05       	cpc	r26, r1
     d32:	b1 05       	cpc	r27, r1
     d34:	39 f1       	breq	.+78     	; 0xd84 <UpdateAudioChannel1+0x514>
			{
				bankStates[BANK_1].currentAddress--;
     d36:	80 91 bd 02 	lds	r24, 0x02BD
     d3a:	90 91 be 02 	lds	r25, 0x02BE
     d3e:	a0 91 bf 02 	lds	r26, 0x02BF
     d42:	b0 91 c0 02 	lds	r27, 0x02C0
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	a1 09       	sbc	r26, r1
     d4a:	b1 09       	sbc	r27, r1
     d4c:	80 93 bd 02 	sts	0x02BD, r24
     d50:	90 93 be 02 	sts	0x02BE, r25
     d54:	a0 93 bf 02 	sts	0x02BF, r26
     d58:	b0 93 c0 02 	sts	0x02C0, r27
				sliceRemaining[BANK_1]--;
     d5c:	80 91 52 01 	lds	r24, 0x0152
     d60:	90 91 53 01 	lds	r25, 0x0153
     d64:	a0 91 54 01 	lds	r26, 0x0154
     d68:	b0 91 55 01 	lds	r27, 0x0155
     d6c:	01 97       	sbiw	r24, 0x01	; 1
     d6e:	a1 09       	sbc	r26, r1
     d70:	b1 09       	sbc	r27, r1
     d72:	80 93 52 01 	sts	0x0152, r24
     d76:	90 93 53 01 	sts	0x0153, r25
     d7a:	a0 93 54 01 	sts	0x0154, r26
     d7e:	b0 93 55 01 	sts	0x0155, r27
     d82:	15 c1       	rjmp	.+554    	; 0xfae <UpdateAudioChannel1+0x73e>
			}
			else	// Slice done, jump to new slice.
			{
				sliceRemaining[BANK_1]=sliceSize[BANK_1];	// Reload the slice counter.
     d84:	80 91 4a 01 	lds	r24, 0x014A
     d88:	90 91 4b 01 	lds	r25, 0x014B
     d8c:	a0 91 4c 01 	lds	r26, 0x014C
     d90:	b0 91 4d 01 	lds	r27, 0x014D
     d94:	80 93 52 01 	sts	0x0152, r24
     d98:	90 93 53 01 	sts	0x0153, r25
     d9c:	a0 93 54 01 	sts	0x0154, r26
     da0:	b0 93 55 01 	sts	0x0155, r27
				granularPositionArrayPointer[BANK_1]++;	// Point to the next slice in memory.
     da4:	80 91 45 01 	lds	r24, 0x0145
     da8:	8f 5f       	subi	r24, 0xFF	; 255
     daa:	80 93 45 01 	sts	0x0145, r24

				if(granularPositionArrayPointer[BANK_1]==bankStates[BANK_1].granularSlices)
     dae:	90 91 45 01 	lds	r25, 0x0145
     db2:	80 91 a4 02 	lds	r24, 0x02A4
     db6:	98 17       	cp	r25, r24
     db8:	11 f4       	brne	.+4      	; 0xdbe <UpdateAudioChannel1+0x54e>
				{
					granularPositionArrayPointer[BANK_1]=0;	// Point back at the first slice.
     dba:	10 92 45 01 	sts	0x0145, r1
				}

				bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][granularPositionArrayPointer[BANK_1]]*sliceSize[BANK_1]));								
     dbe:	e0 91 45 01 	lds	r30, 0x0145
     dc2:	20 91 4a 01 	lds	r18, 0x014A
     dc6:	30 91 4b 01 	lds	r19, 0x014B
     dca:	40 91 4c 01 	lds	r20, 0x014C
     dce:	50 91 4d 01 	lds	r21, 0x014D
     dd2:	f0 e0       	ldi	r31, 0x00	; 0
     dd4:	ea 52       	subi	r30, 0x2A	; 42
     dd6:	fe 4f       	sbci	r31, 0xFE	; 254
     dd8:	60 81       	ld	r22, Z
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	90 e0       	ldi	r25, 0x00	; 0
     de0:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
     de4:	2f ef       	ldi	r18, 0xFF	; 255
     de6:	3f ef       	ldi	r19, 0xFF	; 255
     de8:	47 e0       	ldi	r20, 0x07	; 7
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	26 1b       	sub	r18, r22
     dee:	37 0b       	sbc	r19, r23
     df0:	48 0b       	sbc	r20, r24
     df2:	59 0b       	sbc	r21, r25
     df4:	20 93 bd 02 	sts	0x02BD, r18
     df8:	30 93 be 02 	sts	0x02BE, r19
     dfc:	40 93 bf 02 	sts	0x02BF, r20
     e00:	50 93 c0 02 	sts	0x02C0, r21
     e04:	d4 c0       	rjmp	.+424    	; 0xfae <UpdateAudioChannel1+0x73e>
			}		
		}
		else
		{
			if(bankStates[BANK_1].sampleDirection==false)	// Paul is dead?  Devil voices?
     e06:	80 91 a3 02 	lds	r24, 0x02A3
     e0a:	88 23       	and	r24, r24
     e0c:	09 f0       	breq	.+2      	; 0xe10 <UpdateAudioChannel1+0x5a0>
     e0e:	62 c0       	rjmp	.+196    	; 0xed4 <UpdateAudioChannel1+0x664>
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the beginning of the sample, stop playing back.
     e10:	20 91 bd 02 	lds	r18, 0x02BD
     e14:	30 91 be 02 	lds	r19, 0x02BE
     e18:	40 91 bf 02 	lds	r20, 0x02BF
     e1c:	50 91 c0 02 	lds	r21, 0x02C0
     e20:	80 91 b6 02 	lds	r24, 0x02B6
     e24:	90 91 b7 02 	lds	r25, 0x02B7
     e28:	a0 91 b8 02 	lds	r26, 0x02B8
     e2c:	b0 91 b9 02 	lds	r27, 0x02B9
     e30:	28 17       	cp	r18, r24
     e32:	39 07       	cpc	r19, r25
     e34:	4a 07       	cpc	r20, r26
     e36:	5b 07       	cpc	r21, r27
     e38:	29 f4       	brne	.+10     	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e3a:	80 91 a0 02 	lds	r24, 0x02A0
     e3e:	81 30       	cpi	r24, 0x01	; 1
     e40:	09 f4       	brne	.+2      	; 0xe44 <UpdateAudioChannel1+0x5d4>
     e42:	61 c0       	rjmp	.+194    	; 0xf06 <UpdateAudioChannel1+0x696>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
					bankStates[BANK_1].clockMode=CLK_NONE;
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedStartAddress)	// We're looping and have reached the beginning of the sample, so...
     e44:	20 91 bd 02 	lds	r18, 0x02BD
     e48:	30 91 be 02 	lds	r19, 0x02BE
     e4c:	40 91 bf 02 	lds	r20, 0x02BF
     e50:	50 91 c0 02 	lds	r21, 0x02C0
     e54:	80 91 b6 02 	lds	r24, 0x02B6
     e58:	90 91 b7 02 	lds	r25, 0x02B7
     e5c:	a0 91 b8 02 	lds	r26, 0x02B8
     e60:	b0 91 b9 02 	lds	r27, 0x02B9
     e64:	28 17       	cp	r18, r24
     e66:	39 07       	cpc	r19, r25
     e68:	4a 07       	cpc	r20, r26
     e6a:	5b 07       	cpc	r21, r27
     e6c:	49 f4       	brne	.+18     	; 0xe80 <UpdateAudioChannel1+0x610>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;			// Back to the, um, future.
     e6e:	80 91 b2 02 	lds	r24, 0x02B2
     e72:	90 91 b3 02 	lds	r25, 0x02B3
     e76:	a0 91 b4 02 	lds	r26, 0x02B4
     e7a:	b0 91 b5 02 	lds	r27, 0x02B5
     e7e:	8f c0       	rjmp	.+286    	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].startAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     e80:	20 91 bd 02 	lds	r18, 0x02BD
     e84:	30 91 be 02 	lds	r19, 0x02BE
     e88:	40 91 bf 02 	lds	r20, 0x02BF
     e8c:	50 91 c0 02 	lds	r21, 0x02C0
     e90:	80 91 ae 02 	lds	r24, 0x02AE
     e94:	90 91 af 02 	lds	r25, 0x02AF
     e98:	a0 91 b0 02 	lds	r26, 0x02B0
     e9c:	b0 91 b1 02 	lds	r27, 0x02B1
     ea0:	28 17       	cp	r18, r24
     ea2:	39 07       	cpc	r19, r25
     ea4:	4a 07       	cpc	r20, r26
     ea6:	5b 07       	cpc	r21, r27
     ea8:	49 f4       	brne	.+18     	; 0xebc <UpdateAudioChannel1+0x64c>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].endAddress;		// Assume we're looping through to some relative start and end.
     eaa:	80 91 aa 02 	lds	r24, 0x02AA
     eae:	90 91 ab 02 	lds	r25, 0x02AB
     eb2:	a0 91 ac 02 	lds	r26, 0x02AC
     eb6:	b0 91 ad 02 	lds	r27, 0x02AD
     eba:	71 c0       	rjmp	.+226    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else	// We're not at the beginning of the loop, keep heading there.
					{
						bankStates[BANK_1].currentAddress++;		// In BANK_1, the beginning is high.
     ebc:	80 91 bd 02 	lds	r24, 0x02BD
     ec0:	90 91 be 02 	lds	r25, 0x02BE
     ec4:	a0 91 bf 02 	lds	r26, 0x02BF
     ec8:	b0 91 c0 02 	lds	r27, 0x02C0
     ecc:	01 96       	adiw	r24, 0x01	; 1
     ece:	a1 1d       	adc	r26, r1
     ed0:	b1 1d       	adc	r27, r1
     ed2:	65 c0       	rjmp	.+202    	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
				}
			}
			else	// Going forward through the sample.
			{
				if((bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)&&(bankStates[BANK_1].loopOnce==true))	// If we're looping once AND we're at the end of the sample, stop playing back.
     ed4:	20 91 bd 02 	lds	r18, 0x02BD
     ed8:	30 91 be 02 	lds	r19, 0x02BE
     edc:	40 91 bf 02 	lds	r20, 0x02BF
     ee0:	50 91 c0 02 	lds	r21, 0x02C0
     ee4:	80 91 b2 02 	lds	r24, 0x02B2
     ee8:	90 91 b3 02 	lds	r25, 0x02B3
     eec:	a0 91 b4 02 	lds	r26, 0x02B4
     ef0:	b0 91 b5 02 	lds	r27, 0x02B5
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	4a 07       	cpc	r20, r26
     efa:	5b 07       	cpc	r21, r27
     efc:	49 f4       	brne	.+18     	; 0xf10 <UpdateAudioChannel1+0x6a0>
     efe:	80 91 a0 02 	lds	r24, 0x02A0
     f02:	81 30       	cpi	r24, 0x01	; 1
     f04:	29 f4       	brne	.+10     	; 0xf10 <UpdateAudioChannel1+0x6a0>
				{
					bankStates[BANK_1].audioFunction=AUDIO_IDLE;
     f06:	10 92 9f 02 	sts	0x029F, r1
					bankStates[BANK_1].clockMode=CLK_NONE;
     f0a:	10 92 a7 02 	sts	0x02A7, r1
     f0e:	4f c0       	rjmp	.+158    	; 0xfae <UpdateAudioChannel1+0x73e>
				}
				else if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].adjustedEndAddress)		// We're looping and have reached the end of the sample, so...
     f10:	20 91 bd 02 	lds	r18, 0x02BD
     f14:	30 91 be 02 	lds	r19, 0x02BE
     f18:	40 91 bf 02 	lds	r20, 0x02BF
     f1c:	50 91 c0 02 	lds	r21, 0x02C0
     f20:	80 91 b2 02 	lds	r24, 0x02B2
     f24:	90 91 b3 02 	lds	r25, 0x02B3
     f28:	a0 91 b4 02 	lds	r26, 0x02B4
     f2c:	b0 91 b5 02 	lds	r27, 0x02B5
     f30:	28 17       	cp	r18, r24
     f32:	39 07       	cpc	r19, r25
     f34:	4a 07       	cpc	r20, r26
     f36:	5b 07       	cpc	r21, r27
     f38:	49 f4       	brne	.+18     	; 0xf4c <UpdateAudioChannel1+0x6dc>
				{
					bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;			// Loop around to the beginning.
     f3a:	80 91 b6 02 	lds	r24, 0x02B6
     f3e:	90 91 b7 02 	lds	r25, 0x02B7
     f42:	a0 91 b8 02 	lds	r26, 0x02B8
     f46:	b0 91 b9 02 	lds	r27, 0x02B9
     f4a:	29 c0       	rjmp	.+82     	; 0xf9e <UpdateAudioChannel1+0x72e>
				}
				else
				{
					if(bankStates[BANK_1].currentAddress==bankStates[BANK_1].endAddress)	// Make sure we can loop through the absolute ends of the sample in the event the sample has been trimmed.
     f4c:	20 91 bd 02 	lds	r18, 0x02BD
     f50:	30 91 be 02 	lds	r19, 0x02BE
     f54:	40 91 bf 02 	lds	r20, 0x02BF
     f58:	50 91 c0 02 	lds	r21, 0x02C0
     f5c:	80 91 aa 02 	lds	r24, 0x02AA
     f60:	90 91 ab 02 	lds	r25, 0x02AB
     f64:	a0 91 ac 02 	lds	r26, 0x02AC
     f68:	b0 91 ad 02 	lds	r27, 0x02AD
     f6c:	28 17       	cp	r18, r24
     f6e:	39 07       	cpc	r19, r25
     f70:	4a 07       	cpc	r20, r26
     f72:	5b 07       	cpc	r21, r27
     f74:	49 f4       	brne	.+18     	; 0xf88 <UpdateAudioChannel1+0x718>
					{
						bankStates[BANK_1].currentAddress=bankStates[BANK_1].startAddress;	// Assume we're looping through to some relative start and end.
     f76:	80 91 ae 02 	lds	r24, 0x02AE
     f7a:	90 91 af 02 	lds	r25, 0x02AF
     f7e:	a0 91 b0 02 	lds	r26, 0x02B0
     f82:	b0 91 b1 02 	lds	r27, 0x02B1
     f86:	0b c0       	rjmp	.+22     	; 0xf9e <UpdateAudioChannel1+0x72e>
					}
					else
					{
						bankStates[BANK_1].currentAddress--;		// In BANK_1, the end is low.
     f88:	80 91 bd 02 	lds	r24, 0x02BD
     f8c:	90 91 be 02 	lds	r25, 0x02BE
     f90:	a0 91 bf 02 	lds	r26, 0x02BF
     f94:	b0 91 c0 02 	lds	r27, 0x02C0
     f98:	01 97       	sbiw	r24, 0x01	; 1
     f9a:	a1 09       	sbc	r26, r1
     f9c:	b1 09       	sbc	r27, r1
     f9e:	80 93 bd 02 	sts	0x02BD, r24
     fa2:	90 93 be 02 	sts	0x02BE, r25
     fa6:	a0 93 bf 02 	sts	0x02BF, r26
     faa:	b0 93 c0 02 	sts	0x02C0, r27
			}
		}
		
		// Finished with addy stuff, now finish data transfer
		
		outputByte=LATCH_INPUT;				// Get the byte from this address in RAM -- this will get sent to the DAC.
     fae:	43 b1       	in	r20, 0x03	; 3

		PORTA|=(Om_RAM_OE);					// Tristate the RAM.
     fb0:	12 9a       	sbi	0x02, 2	; 2
		LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
     fb2:	8f ef       	ldi	r24, 0xFF	; 255
     fb4:	84 b9       	out	0x04, r24	; 4

		if(bankStates[BANK_1].bitReduction)	// Low bit rate?
     fb6:	80 91 a6 02 	lds	r24, 0x02A6
     fba:	88 23       	and	r24, r24
     fbc:	61 f0       	breq	.+24     	; 0xfd6 <UpdateAudioChannel1+0x766>
		{
			outputByte^=0x80;											// Bring the signed char back to unsigned for the bitmask.				
     fbe:	40 58       	subi	r20, 0x80	; 128
			outputByte&=(0xFF<<bankStates[BANK_1].bitReduction);		// Mask off however many bits we're supposed to.
     fc0:	20 91 a6 02 	lds	r18, 0x02A6
     fc4:	8f ef       	ldi	r24, 0xFF	; 255
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	02 c0       	rjmp	.+4      	; 0xfce <UpdateAudioChannel1+0x75e>
     fca:	88 0f       	add	r24, r24
     fcc:	99 1f       	adc	r25, r25
     fce:	2a 95       	dec	r18
     fd0:	e2 f7       	brpl	.-8      	; 0xfca <UpdateAudioChannel1+0x75a>
     fd2:	48 23       	and	r20, r24
			outputByte^=0x80;											// Bring it back to signed.
     fd4:	40 58       	subi	r20, 0x80	; 128
		}

		sum=outputByte+adcByte;			// Do saturated add mess.
     fd6:	24 2f       	mov	r18, r20
     fd8:	33 27       	eor	r19, r19
     fda:	27 fd       	sbrc	r18, 7
     fdc:	30 95       	com	r19
     fde:	80 91 56 02 	lds	r24, 0x0256
     fe2:	99 27       	eor	r25, r25
     fe4:	87 fd       	sbrc	r24, 7
     fe6:	90 95       	com	r25
     fe8:	28 0f       	add	r18, r24
     fea:	39 1f       	adc	r19, r25
     fec:	8f ef       	ldi	r24, 0xFF	; 255
     fee:	20 38       	cpi	r18, 0x80	; 128
     ff0:	38 07       	cpc	r19, r24
     ff2:	14 f4       	brge	.+4      	; 0xff8 <UpdateAudioChannel1+0x788>
     ff4:	20 e8       	ldi	r18, 0x80	; 128
     ff6:	3f ef       	ldi	r19, 0xFF	; 255
		else if(sum<-128) // Saturate to bottom rail.
		{
			sum=-128;
		}

		LATCH_PORT=(signed char)sum;	// Now replace the data at this RAM location with the data summed from the ADC and output bytes.
     ff8:	c9 01       	movw	r24, r18
     ffa:	20 38       	cpi	r18, 0x80	; 128
     ffc:	31 05       	cpc	r19, r1
     ffe:	14 f0       	brlt	.+4      	; 0x1004 <UpdateAudioChannel1+0x794>
    1000:	8f e7       	ldi	r24, 0x7F	; 127
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	85 b9       	out	0x05, r24	; 5
		PORTA&=~(Om_RAM_WE);		// Strobe Write Enable low.  This latches the data in.
    1006:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);			// Disbale writes.
    1008:	11 9a       	sbi	0x02, 1	; 2
		break;
	}

	return(outputByte);
}
    100a:	84 2f       	mov	r24, r20
    100c:	08 95       	ret

0000100e <OutputMultiplyBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    100e:	80 91 59 02 	lds	r24, 0x0259
    1012:	68 2f       	mov	r22, r24
    1014:	77 27       	eor	r23, r23
    1016:	67 fd       	sbrc	r22, 7
    1018:	70 95       	com	r23
    101a:	80 91 57 02 	lds	r24, 0x0257
    101e:	99 27       	eor	r25, r25
    1020:	87 fd       	sbrc	r24, 7
    1022:	90 95       	com	r25
    1024:	68 0f       	add	r22, r24
    1026:	79 1f       	adc	r23, r25
    1028:	8f ef       	ldi	r24, 0xFF	; 255
    102a:	60 38       	cpi	r22, 0x80	; 128
    102c:	78 07       	cpc	r23, r24
    102e:	14 f4       	brge	.+4      	; 0x1034 <OutputMultiplyBanks+0x26>
    1030:	60 e8       	ldi	r22, 0x80	; 128
    1032:	7f ef       	ldi	r23, 0xFF	; 255
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}

	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1034:	80 91 5a 02 	lds	r24, 0x025A
    1038:	28 2f       	mov	r18, r24
    103a:	33 27       	eor	r19, r19
    103c:	27 fd       	sbrc	r18, 7
    103e:	30 95       	com	r19
    1040:	80 91 58 02 	lds	r24, 0x0258
    1044:	99 27       	eor	r25, r25
    1046:	87 fd       	sbrc	r24, 7
    1048:	90 95       	com	r25
    104a:	28 0f       	add	r18, r24
    104c:	39 1f       	adc	r19, r25
    104e:	8f ef       	ldi	r24, 0xFF	; 255
    1050:	21 38       	cpi	r18, 0x81	; 129
    1052:	38 07       	cpc	r19, r24
    1054:	14 f4       	brge	.+4      	; 0x105a <OutputMultiplyBanks+0x4c>
    1056:	21 e8       	ldi	r18, 0x81	; 129
    1058:	3f ef       	ldi	r19, 0xFF	; 255
	else if(sum1<-127)		// Pin low.  (was pegged to -128)
	{
		sum1=-127;
	}

	sum0=((sum0*sum1)/64);				// Multiply the sums of the banks, and divide them down to full scale output.  If this sounds too tame, we may want to make the divisor smaller and pin this to range as above.
    105a:	a9 01       	movw	r20, r18
    105c:	20 38       	cpi	r18, 0x80	; 128
    105e:	31 05       	cpc	r19, r1
    1060:	14 f0       	brlt	.+4      	; 0x1066 <OutputMultiplyBanks+0x58>
    1062:	4f e7       	ldi	r20, 0x7F	; 127
    1064:	50 e0       	ldi	r21, 0x00	; 0
    1066:	9b 01       	movw	r18, r22
    1068:	60 38       	cpi	r22, 0x80	; 128
    106a:	71 05       	cpc	r23, r1
    106c:	14 f0       	brlt	.+4      	; 0x1072 <OutputMultiplyBanks+0x64>
    106e:	2f e7       	ldi	r18, 0x7F	; 127
    1070:	30 e0       	ldi	r19, 0x00	; 0
	output=(((signed char)sum0)^0x80);	// Cast the output back to 8 bits and then make it unsigned.
    1072:	42 9f       	mul	r20, r18
    1074:	c0 01       	movw	r24, r0
    1076:	43 9f       	mul	r20, r19
    1078:	90 0d       	add	r25, r0
    107a:	52 9f       	mul	r21, r18
    107c:	90 0d       	add	r25, r0
    107e:	11 24       	eor	r1, r1
    1080:	60 e4       	ldi	r22, 0x40	; 64
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	0e 94 30 29 	call	0x5260	; 0x5260 <__divmodhi4>
    1088:	60 58       	subi	r22, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    108a:	80 91 5b 02 	lds	r24, 0x025B
    108e:	68 17       	cp	r22, r24
    1090:	29 f0       	breq	.+10     	; 0x109c <OutputMultiplyBanks+0x8e>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1096:	65 b9       	out	0x05, r22	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1098:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    109a:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    109c:	60 93 5b 02 	sts	0x025B, r22
	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
    10a0:	47 98       	cbi	0x08, 7	; 8
}
    10a2:	08 95       	ret

000010a4 <OutputAddBanks>:
		sum0;				// Temporary variables for saturated adds, multiplies, other math.

	unsigned char
		output;			// What to put on the DAC
	
	sum0=(extIsrOutputBank0+extIsrOutputBank1+midiOutputBank0+midiOutputBank1);		// Sum everything that might be involved in our output waveform:
    10a4:	80 91 58 02 	lds	r24, 0x0258
    10a8:	28 2f       	mov	r18, r24
    10aa:	33 27       	eor	r19, r19
    10ac:	27 fd       	sbrc	r18, 7
    10ae:	30 95       	com	r19
    10b0:	80 91 57 02 	lds	r24, 0x0257
    10b4:	99 27       	eor	r25, r25
    10b6:	87 fd       	sbrc	r24, 7
    10b8:	90 95       	com	r25
    10ba:	28 0f       	add	r18, r24
    10bc:	39 1f       	adc	r19, r25
    10be:	80 91 59 02 	lds	r24, 0x0259
    10c2:	99 27       	eor	r25, r25
    10c4:	87 fd       	sbrc	r24, 7
    10c6:	90 95       	com	r25
    10c8:	28 0f       	add	r18, r24
    10ca:	39 1f       	adc	r19, r25
    10cc:	80 91 5a 02 	lds	r24, 0x025A
    10d0:	99 27       	eor	r25, r25
    10d2:	87 fd       	sbrc	r24, 7
    10d4:	90 95       	com	r25
    10d6:	28 0f       	add	r18, r24
    10d8:	39 1f       	adc	r19, r25
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	20 38       	cpi	r18, 0x80	; 128
    10de:	38 07       	cpc	r19, r24
    10e0:	14 f4       	brge	.+4      	; 0x10e6 <OutputAddBanks+0x42>
    10e2:	20 e8       	ldi	r18, 0x80	; 128
    10e4:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	output=(signed char)sum0;		// Cast back to 8 bits.
    10e6:	c9 01       	movw	r24, r18
    10e8:	20 38       	cpi	r18, 0x80	; 128
    10ea:	31 05       	cpc	r19, r1
    10ec:	14 f0       	brlt	.+4      	; 0x10f2 <OutputAddBanks+0x4e>
    10ee:	8f e7       	ldi	r24, 0x7F	; 127
    10f0:	90 e0       	ldi	r25, 0x00	; 0
	output^=(0x80);				// Make unsigned again (shift 0 up to 128, -127 up to 0, etc)
    10f2:	98 2f       	mov	r25, r24
    10f4:	90 58       	subi	r25, 0x80	; 128

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    10f6:	80 91 5b 02 	lds	r24, 0x025B
    10fa:	98 17       	cp	r25, r24
    10fc:	29 f0       	breq	.+10     	; 0x1108 <__stack+0x9>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    10fe:	8f ef       	ldi	r24, 0xFF	; 255
    1100:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1102:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1104:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1106:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1108:	90 93 5b 02 	sts	0x025B, r25
	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
    110c:	47 98       	cbi	0x08, 7	; 8
}
    110e:	08 95       	ret

00001110 <OutputXorBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1110:	80 91 59 02 	lds	r24, 0x0259
    1114:	48 2f       	mov	r20, r24
    1116:	55 27       	eor	r21, r21
    1118:	47 fd       	sbrc	r20, 7
    111a:	50 95       	com	r21
    111c:	80 91 57 02 	lds	r24, 0x0257
    1120:	99 27       	eor	r25, r25
    1122:	87 fd       	sbrc	r24, 7
    1124:	90 95       	com	r25
    1126:	48 0f       	add	r20, r24
    1128:	59 1f       	adc	r21, r25
    112a:	8f ef       	ldi	r24, 0xFF	; 255
    112c:	40 38       	cpi	r20, 0x80	; 128
    112e:	58 07       	cpc	r21, r24
    1130:	14 f4       	brge	.+4      	; 0x1136 <OutputXorBanks+0x26>
    1132:	40 e8       	ldi	r20, 0x80	; 128
    1134:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    1136:	80 91 5a 02 	lds	r24, 0x025A
    113a:	28 2f       	mov	r18, r24
    113c:	33 27       	eor	r19, r19
    113e:	27 fd       	sbrc	r18, 7
    1140:	30 95       	com	r19
    1142:	80 91 58 02 	lds	r24, 0x0258
    1146:	99 27       	eor	r25, r25
    1148:	87 fd       	sbrc	r24, 7
    114a:	90 95       	com	r25
    114c:	28 0f       	add	r18, r24
    114e:	39 1f       	adc	r19, r25
    1150:	8f ef       	ldi	r24, 0xFF	; 255
    1152:	20 38       	cpi	r18, 0x80	; 128
    1154:	38 07       	cpc	r19, r24
    1156:	14 f4       	brge	.+4      	; 0x115c <OutputXorBanks+0x4c>
    1158:	20 e8       	ldi	r18, 0x80	; 128
    115a:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}		
	output=(((signed char)sum0)^0x80)^(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then xor them.		
    115c:	20 38       	cpi	r18, 0x80	; 128
    115e:	31 05       	cpc	r19, r1
    1160:	14 f0       	brlt	.+4      	; 0x1166 <OutputXorBanks+0x56>
    1162:	2f e7       	ldi	r18, 0x7F	; 127
    1164:	30 e0       	ldi	r19, 0x00	; 0
    1166:	ca 01       	movw	r24, r20
    1168:	40 38       	cpi	r20, 0x80	; 128
    116a:	51 05       	cpc	r21, r1
    116c:	14 f0       	brlt	.+4      	; 0x1172 <OutputXorBanks+0x62>
    116e:	8f e7       	ldi	r24, 0x7F	; 127
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	92 2f       	mov	r25, r18
    1174:	98 27       	eor	r25, r24

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    1176:	80 91 5b 02 	lds	r24, 0x025B
    117a:	98 17       	cp	r25, r24
    117c:	29 f0       	breq	.+10     	; 0x1188 <OutputXorBanks+0x78>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    117e:	8f ef       	ldi	r24, 0xFF	; 255
    1180:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    1182:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    1184:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    1186:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1188:	90 93 5b 02 	sts	0x025B, r25
	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
    118c:	47 98       	cbi	0x08, 7	; 8
}
    118e:	08 95       	ret

00001190 <OutputAndBanks>:
		sum1;

	unsigned char
		output;			// What to put on the DAC
	
	sum0=extIsrOutputBank0+midiOutputBank0;		// Get anything bank0 might be doing.
    1190:	80 91 59 02 	lds	r24, 0x0259
    1194:	48 2f       	mov	r20, r24
    1196:	55 27       	eor	r21, r21
    1198:	47 fd       	sbrc	r20, 7
    119a:	50 95       	com	r21
    119c:	80 91 57 02 	lds	r24, 0x0257
    11a0:	99 27       	eor	r25, r25
    11a2:	87 fd       	sbrc	r24, 7
    11a4:	90 95       	com	r25
    11a6:	48 0f       	add	r20, r24
    11a8:	59 1f       	adc	r21, r25
    11aa:	8f ef       	ldi	r24, 0xFF	; 255
    11ac:	40 38       	cpi	r20, 0x80	; 128
    11ae:	58 07       	cpc	r21, r24
    11b0:	14 f4       	brge	.+4      	; 0x11b6 <OutputAndBanks+0x26>
    11b2:	40 e8       	ldi	r20, 0x80	; 128
    11b4:	5f ef       	ldi	r21, 0xFF	; 255
	}
	else if(sum0<-128)		// Pin low.
	{
		sum0=-128;
	}
	sum1=extIsrOutputBank1+midiOutputBank1;		// Get anything bank1 might be doing.
    11b6:	80 91 5a 02 	lds	r24, 0x025A
    11ba:	28 2f       	mov	r18, r24
    11bc:	33 27       	eor	r19, r19
    11be:	27 fd       	sbrc	r18, 7
    11c0:	30 95       	com	r19
    11c2:	80 91 58 02 	lds	r24, 0x0258
    11c6:	99 27       	eor	r25, r25
    11c8:	87 fd       	sbrc	r24, 7
    11ca:	90 95       	com	r25
    11cc:	28 0f       	add	r18, r24
    11ce:	39 1f       	adc	r19, r25
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	20 38       	cpi	r18, 0x80	; 128
    11d4:	38 07       	cpc	r19, r24
    11d6:	14 f4       	brge	.+4      	; 0x11dc <OutputAndBanks+0x4c>
    11d8:	20 e8       	ldi	r18, 0x80	; 128
    11da:	3f ef       	ldi	r19, 0xFF	; 255
	}
	else if(sum1<-128)		// Pin low.
	{
		sum1=-128;
	}
	output=(((signed char)sum0)^0x80)&(((signed char)sum1)^0x80);		// Cast each sum back to 8 bits, make them unsigned, then and them.		
    11dc:	c9 01       	movw	r24, r18
    11de:	20 38       	cpi	r18, 0x80	; 128
    11e0:	31 05       	cpc	r19, r1
    11e2:	14 f0       	brlt	.+4      	; 0x11e8 <OutputAndBanks+0x58>
    11e4:	8f e7       	ldi	r24, 0x7F	; 127
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	28 2f       	mov	r18, r24
    11ea:	20 58       	subi	r18, 0x80	; 128
    11ec:	ca 01       	movw	r24, r20
    11ee:	40 38       	cpi	r20, 0x80	; 128
    11f0:	51 05       	cpc	r21, r1
    11f2:	14 f0       	brlt	.+4      	; 0x11f8 <OutputAndBanks+0x68>
    11f4:	8f e7       	ldi	r24, 0x7F	; 127
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	98 2f       	mov	r25, r24
    11fa:	90 58       	subi	r25, 0x80	; 128
    11fc:	92 23       	and	r25, r18

	if(output!=lastDacByte)	// Don't toggle PORTA pins if you don't have to (keep ADC noise down)
    11fe:	80 91 5b 02 	lds	r24, 0x025B
    1202:	98 17       	cp	r25, r24
    1204:	29 f0       	breq	.+10     	; 0x1210 <OutputAndBanks+0x80>
	{
		LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    1206:	8f ef       	ldi	r24, 0xFF	; 255
    1208:	84 b9       	out	0x04, r24	; 4

		LATCH_PORT=output;		// Put the output on the output latch's input.
    120a:	95 b9       	out	0x05, r25	; 5
		PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the output on the 373's output...
    120c:	15 9a       	sbi	0x02, 5	; 2
		PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    120e:	15 98       	cbi	0x02, 5	; 2
	}

	lastDacByte=output;		// Flag this byte has having been spit out last time.
    1210:	90 93 5b 02 	sts	0x025B, r25
	PORTC&=~Om_TEST_PIN;		// @@@ Used to time ISRs
    1214:	47 98       	cbi	0x08, 7	; 8
}
    1216:	08 95       	ret

00001218 <__vector_12>:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

ISR(TIMER1_CAPT_vect)
// The vector triggered by an external clock edge and associated with Bank0
{
    1218:	1f 92       	push	r1
    121a:	0f 92       	push	r0
    121c:	0f b6       	in	r0, 0x3f	; 63
    121e:	0f 92       	push	r0
    1220:	11 24       	eor	r1, r1
    1222:	2f 93       	push	r18
    1224:	3f 93       	push	r19
    1226:	4f 93       	push	r20
    1228:	5f 93       	push	r21
    122a:	6f 93       	push	r22
    122c:	7f 93       	push	r23
    122e:	8f 93       	push	r24
    1230:	9f 93       	push	r25
    1232:	af 93       	push	r26
    1234:	bf 93       	push	r27
    1236:	ef 93       	push	r30
    1238:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
    123a:	47 9a       	sbi	0x08, 7	; 8
	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    123c:	80 91 7f 02 	lds	r24, 0x027F
    1240:	88 23       	and	r24, r24
    1242:	41 f0       	breq	.+16     	; 0x1254 <__vector_12+0x3c>
    1244:	80 91 7f 02 	lds	r24, 0x027F
    1248:	88 23       	and	r24, r24
    124a:	41 f0       	breq	.+16     	; 0x125c <__vector_12+0x44>
    124c:	80 91 38 01 	lds	r24, 0x0138
    1250:	88 23       	and	r24, r24
    1252:	21 f0       	breq	.+8      	; 0x125c <__vector_12+0x44>
	{
		extIsrOutputBank0=UpdateAudioChannel0();		// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    1254:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    1258:	80 93 57 02 	sts	0x0257, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    125c:	10 92 38 01 	sts	0x0138, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1260:	e0 91 79 02 	lds	r30, 0x0279
    1264:	f0 91 7a 02 	lds	r31, 0x027A
    1268:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    126a:	80 91 7a 00 	lds	r24, 0x007A
    126e:	86 fd       	sbrc	r24, 6
    1270:	0a c0       	rjmp	.+20     	; 0x1286 <__vector_12+0x6e>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1272:	80 91 79 00 	lds	r24, 0x0079
    1276:	80 58       	subi	r24, 0x80	; 128
    1278:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    127c:	80 91 7a 00 	lds	r24, 0x007A
    1280:	80 64       	ori	r24, 0x40	; 64
    1282:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1286:	ff 91       	pop	r31
    1288:	ef 91       	pop	r30
    128a:	bf 91       	pop	r27
    128c:	af 91       	pop	r26
    128e:	9f 91       	pop	r25
    1290:	8f 91       	pop	r24
    1292:	7f 91       	pop	r23
    1294:	6f 91       	pop	r22
    1296:	5f 91       	pop	r21
    1298:	4f 91       	pop	r20
    129a:	3f 91       	pop	r19
    129c:	2f 91       	pop	r18
    129e:	0f 90       	pop	r0
    12a0:	0f be       	out	0x3f, r0	; 63
    12a2:	0f 90       	pop	r0
    12a4:	1f 90       	pop	r1
    12a6:	18 95       	reti

000012a8 <__vector_6>:

ISR(PCINT2_vect)
// The vector triggered by a pin change and associated with Bank1
{
    12a8:	1f 92       	push	r1
    12aa:	0f 92       	push	r0
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	0f 92       	push	r0
    12b0:	11 24       	eor	r1, r1
    12b2:	2f 93       	push	r18
    12b4:	3f 93       	push	r19
    12b6:	4f 93       	push	r20
    12b8:	5f 93       	push	r21
    12ba:	6f 93       	push	r22
    12bc:	7f 93       	push	r23
    12be:	8f 93       	push	r24
    12c0:	9f 93       	push	r25
    12c2:	af 93       	push	r26
    12c4:	bf 93       	push	r27
    12c6:	ef 93       	push	r30
    12c8:	ff 93       	push	r31
	static bool
		flipFlop;		// Used for half-time

	if(PINC&(1<<PC4))	// Skip every other interrupt (the clock going low).  Annoying.
    12ca:	34 9b       	sbis	0x06, 4	; 6
    12cc:	26 c0       	rjmp	.+76     	; 0x131a <__vector_6+0x72>
	{
		PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
    12ce:	47 9a       	sbi	0x08, 7	; 8
		if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    12d0:	80 91 a1 02 	lds	r24, 0x02A1
    12d4:	88 23       	and	r24, r24
    12d6:	41 f0       	breq	.+16     	; 0x12e8 <__vector_6+0x40>
    12d8:	80 91 a1 02 	lds	r24, 0x02A1
    12dc:	88 23       	and	r24, r24
    12de:	41 f0       	breq	.+16     	; 0x12f0 <__vector_6+0x48>
    12e0:	80 91 37 01 	lds	r24, 0x0137
    12e4:	88 23       	and	r24, r24
    12e6:	21 f0       	breq	.+8      	; 0x12f0 <__vector_6+0x48>
		{
			extIsrOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    12e8:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    12ec:	80 93 58 02 	sts	0x0258, r24
		}	
		flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    12f0:	10 92 37 01 	sts	0x0137, r1
		UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    12f4:	e0 91 79 02 	lds	r30, 0x0279
    12f8:	f0 91 7a 02 	lds	r31, 0x027A
    12fc:	09 95       	icall
		if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    12fe:	80 91 7a 00 	lds	r24, 0x007A
    1302:	86 fd       	sbrc	r24, 6
    1304:	0a c0       	rjmp	.+20     	; 0x131a <__vector_6+0x72>
		{
			adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1306:	80 91 79 00 	lds	r24, 0x0079
    130a:	80 58       	subi	r24, 0x80	; 128
    130c:	80 93 56 02 	sts	0x0256, r24
			ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    1310:	80 91 7a 00 	lds	r24, 0x007A
    1314:	80 64       	ori	r24, 0x40	; 64
    1316:	80 93 7a 00 	sts	0x007A, r24
		}
	}
}
    131a:	ff 91       	pop	r31
    131c:	ef 91       	pop	r30
    131e:	bf 91       	pop	r27
    1320:	af 91       	pop	r26
    1322:	9f 91       	pop	r25
    1324:	8f 91       	pop	r24
    1326:	7f 91       	pop	r23
    1328:	6f 91       	pop	r22
    132a:	5f 91       	pop	r21
    132c:	4f 91       	pop	r20
    132e:	3f 91       	pop	r19
    1330:	2f 91       	pop	r18
    1332:	0f 90       	pop	r0
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	0f 90       	pop	r0
    1338:	1f 90       	pop	r1
    133a:	18 95       	reti

0000133c <__vector_13>:

ISR(TIMER1_COMPA_vect)
// The bank0 internal timer vectors here on an interrupt.
{
    133c:	1f 92       	push	r1
    133e:	0f 92       	push	r0
    1340:	0f b6       	in	r0, 0x3f	; 63
    1342:	0f 92       	push	r0
    1344:	11 24       	eor	r1, r1
    1346:	ef 92       	push	r14
    1348:	ff 92       	push	r15
    134a:	0f 93       	push	r16
    134c:	1f 93       	push	r17
    134e:	2f 93       	push	r18
    1350:	3f 93       	push	r19
    1352:	4f 93       	push	r20
    1354:	5f 93       	push	r21
    1356:	6f 93       	push	r22
    1358:	7f 93       	push	r23
    135a:	8f 93       	push	r24
    135c:	9f 93       	push	r25
    135e:	af 93       	push	r26
    1360:	bf 93       	push	r27
    1362:	ef 93       	push	r30
    1364:	ff 93       	push	r31
	static unsigned int
		lastJitterValue;
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
    1366:	47 9a       	sbi	0x08, 7	; 8

	if((bankStates[BANK_0].halfSpeed==false)||(bankStates[BANK_0].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    1368:	80 91 7f 02 	lds	r24, 0x027F
    136c:	88 23       	and	r24, r24
    136e:	41 f0       	breq	.+16     	; 0x1380 <__vector_13+0x44>
    1370:	80 91 7f 02 	lds	r24, 0x027F
    1374:	88 23       	and	r24, r24
    1376:	41 f0       	breq	.+16     	; 0x1388 <__vector_13+0x4c>
    1378:	80 91 33 01 	lds	r24, 0x0133
    137c:	88 23       	and	r24, r24
    137e:	21 f0       	breq	.+8      	; 0x1388 <__vector_13+0x4c>
	{
		midiOutputBank0=UpdateAudioChannel0();			// If so, then call the audioIsr for bank 0 and do whatever it's currently supposed to do.
    1380:	0e 94 79 00 	call	0xf2	; 0xf2 <UpdateAudioChannel0>
    1384:	80 93 59 02 	sts	0x0259, r24
	}
	if(bankStates[BANK_0].jitterValue)				// Jitter on?		### This math is wrong, or, more likely, this routine is too slow.  Once the jitterValue gets reasonably high we here the samples slow down...
    1388:	80 91 83 02 	lds	r24, 0x0283
    138c:	88 23       	and	r24, r24
    138e:	c1 f1       	breq	.+112    	; 0x1400 <__vector_13+0xc4>
	{
		jitterTemp=bankStates[BANK_0].jitterValue*(unsigned long)bankStates[BANK_0].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    1390:	20 91 83 02 	lds	r18, 0x0283
    1394:	60 91 86 02 	lds	r22, 0x0286
    1398:	70 91 87 02 	lds	r23, 0x0287
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    139c:	80 e0       	ldi	r24, 0x00	; 0
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	30 e0       	ldi	r19, 0x00	; 0
    13a2:	40 e0       	ldi	r20, 0x00	; 0
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    13aa:	2f e7       	ldi	r18, 0x7F	; 127
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	40 e0       	ldi	r20, 0x00	; 0
    13b0:	50 e0       	ldi	r21, 0x00	; 0
    13b2:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
		OCR1A+=(bankStates[BANK_0].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. ### We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    13b6:	e0 90 88 00 	lds	r14, 0x0088
    13ba:	f0 90 89 00 	lds	r15, 0x0089
    13be:	00 91 86 02 	lds	r16, 0x0286
    13c2:	10 91 87 02 	lds	r17, 0x0287
    13c6:	60 91 00 01 	lds	r22, 0x0100
    13ca:	70 91 01 01 	lds	r23, 0x0101
    13ce:	80 91 02 01 	lds	r24, 0x0102
    13d2:	90 91 03 01 	lds	r25, 0x0103
    13d6:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
    13da:	0e 0d       	add	r16, r14
    13dc:	1f 1d       	adc	r17, r15
    13de:	20 91 34 01 	lds	r18, 0x0134
    13e2:	30 91 35 01 	lds	r19, 0x0135
    13e6:	02 0f       	add	r16, r18
    13e8:	13 1f       	adc	r17, r19
    13ea:	06 1b       	sub	r16, r22
    13ec:	17 0b       	sbc	r17, r23
    13ee:	10 93 89 00 	sts	0x0089, r17
    13f2:	00 93 88 00 	sts	0x0088, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    13f6:	70 93 35 01 	sts	0x0135, r23
    13fa:	60 93 34 01 	sts	0x0134, r22
    13fe:	0e c0       	rjmp	.+28     	; 0x141c <__vector_13+0xe0>
	}
	else
	{
		OCR1A+=bankStates[BANK_0].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    1400:	20 91 88 00 	lds	r18, 0x0088
    1404:	30 91 89 00 	lds	r19, 0x0089
    1408:	80 91 86 02 	lds	r24, 0x0286
    140c:	90 91 87 02 	lds	r25, 0x0287
    1410:	82 0f       	add	r24, r18
    1412:	93 1f       	adc	r25, r19
    1414:	90 93 89 00 	sts	0x0089, r25
    1418:	80 93 88 00 	sts	0x0088, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    141c:	10 92 33 01 	sts	0x0133, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1420:	e0 91 79 02 	lds	r30, 0x0279
    1424:	f0 91 7a 02 	lds	r31, 0x027A
    1428:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    142a:	80 91 7a 00 	lds	r24, 0x007A
    142e:	86 fd       	sbrc	r24, 6
    1430:	0a c0       	rjmp	.+20     	; 0x1446 <__vector_13+0x10a>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1432:	80 91 79 00 	lds	r24, 0x0079
    1436:	80 58       	subi	r24, 0x80	; 128
    1438:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    143c:	80 91 7a 00 	lds	r24, 0x007A
    1440:	80 64       	ori	r24, 0x40	; 64
    1442:	80 93 7a 00 	sts	0x007A, r24
	}
}
    1446:	ff 91       	pop	r31
    1448:	ef 91       	pop	r30
    144a:	bf 91       	pop	r27
    144c:	af 91       	pop	r26
    144e:	9f 91       	pop	r25
    1450:	8f 91       	pop	r24
    1452:	7f 91       	pop	r23
    1454:	6f 91       	pop	r22
    1456:	5f 91       	pop	r21
    1458:	4f 91       	pop	r20
    145a:	3f 91       	pop	r19
    145c:	2f 91       	pop	r18
    145e:	1f 91       	pop	r17
    1460:	0f 91       	pop	r16
    1462:	ff 90       	pop	r15
    1464:	ef 90       	pop	r14
    1466:	0f 90       	pop	r0
    1468:	0f be       	out	0x3f, r0	; 63
    146a:	0f 90       	pop	r0
    146c:	1f 90       	pop	r1
    146e:	18 95       	reti

00001470 <__vector_14>:

ISR(TIMER1_COMPB_vect)
// The interrupt associated with bank1 when it's using internal interrupts goes here.
{
    1470:	1f 92       	push	r1
    1472:	0f 92       	push	r0
    1474:	0f b6       	in	r0, 0x3f	; 63
    1476:	0f 92       	push	r0
    1478:	11 24       	eor	r1, r1
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	2f 93       	push	r18
    1484:	3f 93       	push	r19
    1486:	4f 93       	push	r20
    1488:	5f 93       	push	r21
    148a:	6f 93       	push	r22
    148c:	7f 93       	push	r23
    148e:	8f 93       	push	r24
    1490:	9f 93       	push	r25
    1492:	af 93       	push	r26
    1494:	bf 93       	push	r27
    1496:	ef 93       	push	r30
    1498:	ff 93       	push	r31
	static unsigned int
		lastJitterValue;
	static bool
		flipFlop;		// Used for half-time

	PORTC|=Om_TEST_PIN;		// @@@ Used to time ISRs
    149a:	47 9a       	sbi	0x08, 7	; 8
	if((bankStates[BANK_1].halfSpeed==false)||(bankStates[BANK_1].halfSpeed&&flipFlop))		// Update the sample every ISR if we aren't at half speed, OR every other time if we are.
    149c:	80 91 a1 02 	lds	r24, 0x02A1
    14a0:	88 23       	and	r24, r24
    14a2:	41 f0       	breq	.+16     	; 0x14b4 <__vector_14+0x44>
    14a4:	80 91 a1 02 	lds	r24, 0x02A1
    14a8:	88 23       	and	r24, r24
    14aa:	41 f0       	breq	.+16     	; 0x14bc <__vector_14+0x4c>
    14ac:	80 91 2f 01 	lds	r24, 0x012F
    14b0:	88 23       	and	r24, r24
    14b2:	21 f0       	breq	.+8      	; 0x14bc <__vector_14+0x4c>
	{
		midiOutputBank1=UpdateAudioChannel1();		// If so, then call the audioIsr for bank 1 and do whatever it's currently supposed to do.
    14b4:	0e 94 38 04 	call	0x870	; 0x870 <UpdateAudioChannel1>
    14b8:	80 93 5a 02 	sts	0x025A, r24
	}
	if(bankStates[BANK_1].jitterValue)				// Jitter on?
    14bc:	80 91 a5 02 	lds	r24, 0x02A5
    14c0:	88 23       	and	r24, r24
    14c2:	c1 f1       	breq	.+112    	; 0x1534 <__vector_14+0xc4>
	{
		jitterTemp=bankStates[BANK_1].jitterValue*(unsigned long)bankStates[BANK_1].timerCyclesForNextNote;	// Scale the jitter value to our clock.
    14c4:	20 91 a5 02 	lds	r18, 0x02A5
    14c8:	60 91 a8 02 	lds	r22, 0x02A8
    14cc:	70 91 a9 02 	lds	r23, 0x02A9
		jitterTemp=random31%(jitterTemp/JITTER_VALUE_MAX);									// Pick a random value between max and min possible jitter (when jitterValue == JITTER_VALUE_MAX this will be a random number from 0 to timerCyclesForNextNote).
    14d0:	80 e0       	ldi	r24, 0x00	; 0
    14d2:	90 e0       	ldi	r25, 0x00	; 0
    14d4:	30 e0       	ldi	r19, 0x00	; 0
    14d6:	40 e0       	ldi	r20, 0x00	; 0
    14d8:	50 e0       	ldi	r21, 0x00	; 0
    14da:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    14de:	2f e7       	ldi	r18, 0x7F	; 127
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	40 e0       	ldi	r20, 0x00	; 0
    14e4:	50 e0       	ldi	r21, 0x00	; 0
    14e6:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
		OCR1B+=(bankStates[BANK_1].timerCyclesForNextNote-jitterTemp)+lastJitterValue;		// To our OCR value we now add the normal time until the next interrupt MINUS some random number.  This gives us the jitter.  Then we add in the leftovers from the last jitter event, and this keeps our period constant. ### We can easily roll this register around for slow notes, but fuck it, this is about jitter, right?
    14ea:	e0 90 8a 00 	lds	r14, 0x008A
    14ee:	f0 90 8b 00 	lds	r15, 0x008B
    14f2:	00 91 a8 02 	lds	r16, 0x02A8
    14f6:	10 91 a9 02 	lds	r17, 0x02A9
    14fa:	60 91 00 01 	lds	r22, 0x0100
    14fe:	70 91 01 01 	lds	r23, 0x0101
    1502:	80 91 02 01 	lds	r24, 0x0102
    1506:	90 91 03 01 	lds	r25, 0x0103
    150a:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
    150e:	0e 0d       	add	r16, r14
    1510:	1f 1d       	adc	r17, r15
    1512:	20 91 30 01 	lds	r18, 0x0130
    1516:	30 91 31 01 	lds	r19, 0x0131
    151a:	02 0f       	add	r16, r18
    151c:	13 1f       	adc	r17, r19
    151e:	06 1b       	sub	r16, r22
    1520:	17 0b       	sbc	r17, r23
    1522:	10 93 8b 00 	sts	0x008B, r17
    1526:	00 93 8a 00 	sts	0x008A, r16
		lastJitterValue=(unsigned int)jitterTemp;											// Store our jitter as an offset for next time; this keeps our period constant.
    152a:	70 93 31 01 	sts	0x0131, r23
    152e:	60 93 30 01 	sts	0x0130, r22
    1532:	0e c0       	rjmp	.+28     	; 0x1550 <__vector_14+0xe0>
	}
	else
	{
		OCR1B+=bankStates[BANK_1].timerCyclesForNextNote;		// Set the interrupt register correctly for the next interrupt time.
    1534:	20 91 8a 00 	lds	r18, 0x008A
    1538:	30 91 8b 00 	lds	r19, 0x008B
    153c:	80 91 a8 02 	lds	r24, 0x02A8
    1540:	90 91 a9 02 	lds	r25, 0x02A9
    1544:	82 0f       	add	r24, r18
    1546:	93 1f       	adc	r25, r19
    1548:	90 93 8b 00 	sts	0x008B, r25
    154c:	80 93 8a 00 	sts	0x008A, r24
	}
	flipFlop^=flipFlop;		// Toggle our half-speed flip flop.
    1550:	10 92 2f 01 	sts	0x012F, r1
	UpdateOutput();			// Points to our current OP function.  Combines outputs from different sources and puts them on the DAC.
    1554:	e0 91 79 02 	lds	r30, 0x0279
    1558:	f0 91 7a 02 	lds	r31, 0x027A
    155c:	09 95       	icall
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    155e:	80 91 7a 00 	lds	r24, 0x007A
    1562:	86 fd       	sbrc	r24, 6
    1564:	0a c0       	rjmp	.+20     	; 0x157a <__vector_14+0x10a>
	{
		adcByte=(ADCH^0x80);	// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1566:	80 91 79 00 	lds	r24, 0x0079
    156a:	80 58       	subi	r24, 0x80	; 128
    156c:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  	// Start the next ADC conversion (do it here so the ADC S/H acquires the sample after noisy RAM/DAC activity on PORTA)
    1570:	80 91 7a 00 	lds	r24, 0x007A
    1574:	80 64       	ori	r24, 0x40	; 64
    1576:	80 93 7a 00 	sts	0x007A, r24
	}
}
    157a:	ff 91       	pop	r31
    157c:	ef 91       	pop	r30
    157e:	bf 91       	pop	r27
    1580:	af 91       	pop	r26
    1582:	9f 91       	pop	r25
    1584:	8f 91       	pop	r24
    1586:	7f 91       	pop	r23
    1588:	6f 91       	pop	r22
    158a:	5f 91       	pop	r21
    158c:	4f 91       	pop	r20
    158e:	3f 91       	pop	r19
    1590:	2f 91       	pop	r18
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	ff 90       	pop	r15
    1598:	ef 90       	pop	r14
    159a:	0f 90       	pop	r0
    159c:	0f be       	out	0x3f, r0	; 63
    159e:	0f 90       	pop	r0
    15a0:	1f 90       	pop	r1
    15a2:	18 95       	reti

000015a4 <__vector_9>:

ISR(TIMER2_COMPA_vect)
// Serves exclusively to make our gay intro happen
// As far as the PWM goes, this should happen as often as possible.
{
    15a4:	1f 92       	push	r1
    15a6:	0f 92       	push	r0
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	0f 92       	push	r0
    15ac:	11 24       	eor	r1, r1
    15ae:	8f 93       	push	r24
    15b0:	9f 93       	push	r25
	static unsigned char
		pwmCount;
	
	if(ledPwm>pwmCount)
    15b2:	80 91 3b 01 	lds	r24, 0x013B
    15b6:	90 91 2e 01 	lds	r25, 0x012E
    15ba:	98 17       	cp	r25, r24
    15bc:	18 f4       	brcc	.+6      	; 0x15c4 <__vector_9+0x20>
	{
		LATCH_PORT=0xFF;	// LEDs go on.
    15be:	8f ef       	ldi	r24, 0xFF	; 255
    15c0:	85 b9       	out	0x05, r24	; 5
    15c2:	01 c0       	rjmp	.+2      	; 0x15c6 <__vector_9+0x22>
	}
	else
	{
		LATCH_PORT=0x00;	// LEDs go off.
    15c4:	15 b8       	out	0x05, r1	; 5
	}
	pwmCount++;
    15c6:	9f 5f       	subi	r25, 0xFF	; 255
    15c8:	90 93 2e 01 	sts	0x012E, r25
}
    15cc:	9f 91       	pop	r25
    15ce:	8f 91       	pop	r24
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	0f 90       	pop	r0
    15d6:	1f 90       	pop	r1
    15d8:	18 95       	reti

000015da <__vector_default>:


ISR(__vector_default)
{
    15da:	1f 92       	push	r1
    15dc:	0f 92       	push	r0
    15de:	0f b6       	in	r0, 0x3f	; 63
    15e0:	0f 92       	push	r0
    15e2:	11 24       	eor	r1, r1
    //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went here, the default interrupt vector.
	//	printf("Buggy Interrupt Generated!  Flags = ");
	//  printf("*****put interrupt register values here****");
}
    15e4:	0f 90       	pop	r0
    15e6:	0f be       	out	0x3f, r0	; 63
    15e8:	0f 90       	pop	r0
    15ea:	1f 90       	pop	r1
    15ec:	18 95       	reti

000015ee <SetSampleClock>:
//  On the mega164p this is two, there are newer devices with more 16 bit timers, and more interrupts per timer.

static void SetSampleClock(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// This code is common to all the requests to start different audio modes (record, playback, overdub, etc) and sets the correct clock source for a given bank.
// Timer interrupts should be disabled when you call this!
{
    15ee:	28 2f       	mov	r18, r24
	bankStates[theBank].clockMode=theClock;	// What type of interrupt should trigger this sample bank?  Put this in the bank variables so other functions can see.
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	fc 01       	movw	r30, r24
    15f4:	b5 e0       	ldi	r27, 0x05	; 5
    15f6:	ee 0f       	add	r30, r30
    15f8:	ff 1f       	adc	r31, r31
    15fa:	ba 95       	dec	r27
    15fc:	e1 f7       	brne	.-8      	; 0x15f6 <SetSampleClock+0x8>
    15fe:	88 0f       	add	r24, r24
    1600:	99 1f       	adc	r25, r25
    1602:	e8 0f       	add	r30, r24
    1604:	f9 1f       	adc	r31, r25
    1606:	e3 58       	subi	r30, 0x83	; 131
    1608:	fd 4f       	sbci	r31, 0xFD	; 253
    160a:	60 87       	std	Z+8, r22	; 0x08

	if(theClock==CLK_INTERNAL)				// The internally counted clock is usually associated with MIDI-controlled sampling (output capture on timer 1)
    160c:	62 30       	cpi	r22, 0x02	; 2
    160e:	a9 f5       	brne	.+106    	; 0x167a <SetSampleClock+0x8c>
	{
		bankStates[theBank].timerCyclesForNextNote=theRate;	// No matter what bank we're in, keep this value so we can use it to keep setting interrupt times.
    1610:	82 2f       	mov	r24, r18
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	fc 01       	movw	r30, r24
    1616:	75 e0       	ldi	r23, 0x05	; 5
    1618:	ee 0f       	add	r30, r30
    161a:	ff 1f       	adc	r31, r31
    161c:	7a 95       	dec	r23
    161e:	e1 f7       	brne	.-8      	; 0x1618 <SetSampleClock+0x2a>
    1620:	88 0f       	add	r24, r24
    1622:	99 1f       	adc	r25, r25
    1624:	e8 0f       	add	r30, r24
    1626:	f9 1f       	adc	r31, r25
    1628:	e3 58       	subi	r30, 0x83	; 131
    162a:	fd 4f       	sbci	r31, 0xFD	; 253
    162c:	52 87       	std	Z+10, r21	; 0x0a
    162e:	41 87       	std	Z+9, r20	; 0x09

		if(theBank==BANK_0)		// Bank 0 is associated with OCR1A
    1630:	22 23       	and	r18, r18
    1632:	79 f4       	brne	.+30     	; 0x1652 <SetSampleClock+0x64>
		{
			OCR1A=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    1634:	80 91 84 00 	lds	r24, 0x0084
    1638:	90 91 85 00 	lds	r25, 0x0085
    163c:	84 0f       	add	r24, r20
    163e:	95 1f       	adc	r25, r21
    1640:	90 93 89 00 	sts	0x0089, r25
    1644:	80 93 88 00 	sts	0x0088, r24
			TIFR1|=(1<<OCF1A);		// Clear the interrupt flag.
    1648:	b1 9a       	sbi	0x16, 1	; 22
			TIMSK1|=(1<<OCIE1A);	// Enable the compare match interrupt.
    164a:	80 91 6f 00 	lds	r24, 0x006F
    164e:	82 60       	ori	r24, 0x02	; 2
    1650:	0e c0       	rjmp	.+28     	; 0x166e <SetSampleClock+0x80>
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.
		}
		else					// Bank 1 is associated with OCR1B
		{
			OCR1B=(theRate+TCNT1);	// Find spot for next interrupt to give the right pitch.		
    1652:	80 91 84 00 	lds	r24, 0x0084
    1656:	90 91 85 00 	lds	r25, 0x0085
    165a:	84 0f       	add	r24, r20
    165c:	95 1f       	adc	r25, r21
    165e:	90 93 8b 00 	sts	0x008B, r25
    1662:	80 93 8a 00 	sts	0x008A, r24
			TIFR1|=(1<<OCF1B);		// Clear the interrupt flag.
    1666:	b2 9a       	sbi	0x16, 2	; 22
			TIMSK1|=(1<<OCIE1B);	// Enable the compare match interrupt.
    1668:	80 91 6f 00 	lds	r24, 0x006F
    166c:	84 60       	ori	r24, 0x04	; 4
    166e:	80 93 6f 00 	sts	0x006F, r24
			TCCR1B=0x01;			// Make sure TIMER1 is going, and in normal mode.			
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	80 93 81 00 	sts	0x0081, r24
    1678:	08 95       	ret
		}
	}
	else if(theClock==CLK_EXTERNAL)	// External clock.
    167a:	61 30       	cpi	r22, 0x01	; 1
    167c:	a9 f4       	brne	.+42     	; 0x16a8 <SetSampleClock+0xba>
	{
		if(theBank==BANK_0)		// Bank 0 is based on Input Capture interrupts (rising edge from the sample clock oscillator)
    167e:	22 23       	and	r18, r18
    1680:	61 f4       	brne	.+24     	; 0x169a <SetSampleClock+0xac>
		{
			TCCR1B|=(1<<ICES1);		// Trigger on a rising edge.
    1682:	80 91 81 00 	lds	r24, 0x0081
    1686:	80 64       	ori	r24, 0x40	; 64
    1688:	80 93 81 00 	sts	0x0081, r24
			TIFR1|=(1<<ICF1);		// Clear Input Capture interrupt flag.
    168c:	b5 9a       	sbi	0x16, 5	; 22
			TIMSK1|=(1<<ICIE1);		// Enable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    168e:	80 91 6f 00 	lds	r24, 0x006F
    1692:	80 62       	ori	r24, 0x20	; 32
    1694:	80 93 6f 00 	sts	0x006F, r24
    1698:	08 95       	ret
		}
		else					// Bank1 is based on PC4's pin change interrupt (PCINT20, which is associated with PC interrupt 2)
		{
			PCIFR|=(1<<PCIF2);		// Clear any pending interrupts hanging around.
    169a:	da 9a       	sbi	0x1b, 2	; 27
			PCICR=(1<<PCIE2);		// Enable the pin change interrupt for PORTC.
    169c:	84 e0       	ldi	r24, 0x04	; 4
    169e:	80 93 68 00 	sts	0x0068, r24
			PCMSK2=0x10;			// PORTC pin 4 generates interrupt
    16a2:	80 e1       	ldi	r24, 0x10	; 16
    16a4:	80 93 6d 00 	sts	0x006D, r24
    16a8:	08 95       	ret

000016aa <StartRecording>:

static void StartRecording(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Set the memory pointer to the start of RAM, set up the clock source, set the interrupt to the recording handler, and enable interrupts.
// If we're using the internal clock, set the rate.
// Sat Apr 11 13:49:31 CDT 2009
{
    16aa:	df 92       	push	r13
    16ac:	ef 92       	push	r14
    16ae:	ff 92       	push	r15
    16b0:	0f 93       	push	r16
    16b2:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    16b4:	df b6       	in	r13, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    16b6:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_RECORD;							// What should we be doing when we get into the ISR?
    16b8:	28 2f       	mov	r18, r24
    16ba:	30 e0       	ldi	r19, 0x00	; 0
    16bc:	f9 01       	movw	r30, r18
    16be:	05 e0       	ldi	r16, 0x05	; 5
    16c0:	ee 0f       	add	r30, r30
    16c2:	ff 1f       	adc	r31, r31
    16c4:	0a 95       	dec	r16
    16c6:	e1 f7       	brne	.-8      	; 0x16c0 <StartRecording+0x16>
    16c8:	22 0f       	add	r18, r18
    16ca:	33 1f       	adc	r19, r19
    16cc:	e2 0f       	add	r30, r18
    16ce:	f3 1f       	adc	r31, r19
    16d0:	e3 58       	subi	r30, 0x83	; 131
    16d2:	fd 4f       	sbci	r31, 0xFD	; 253
    16d4:	93 e0       	ldi	r25, 0x03	; 3
    16d6:	90 83       	st	Z, r25

	bankStates[theBank].currentAddress=bankStates[theBank].startAddress;		// Point to the beginning of our allocated sampling area.
    16d8:	28 2f       	mov	r18, r24
    16da:	30 e0       	ldi	r19, 0x00	; 0
    16dc:	f9 01       	movw	r30, r18
    16de:	b5 e0       	ldi	r27, 0x05	; 5
    16e0:	ee 0f       	add	r30, r30
    16e2:	ff 1f       	adc	r31, r31
    16e4:	ba 95       	dec	r27
    16e6:	e1 f7       	brne	.-8      	; 0x16e0 <StartRecording+0x36>
    16e8:	22 0f       	add	r18, r18
    16ea:	33 1f       	adc	r19, r19
    16ec:	e2 0f       	add	r30, r18
    16ee:	f3 1f       	adc	r31, r19
    16f0:	e3 58       	subi	r30, 0x83	; 131
    16f2:	fd 4f       	sbci	r31, 0xFD	; 253
    16f4:	e7 84       	ldd	r14, Z+15	; 0x0f
    16f6:	f0 88       	ldd	r15, Z+16	; 0x10
    16f8:	01 89       	ldd	r16, Z+17	; 0x11
    16fa:	12 89       	ldd	r17, Z+18	; 0x12
    16fc:	28 2f       	mov	r18, r24
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	f9 01       	movw	r30, r18
    1702:	75 e0       	ldi	r23, 0x05	; 5
    1704:	ee 0f       	add	r30, r30
    1706:	ff 1f       	adc	r31, r31
    1708:	7a 95       	dec	r23
    170a:	e1 f7       	brne	.-8      	; 0x1704 <StartRecording+0x5a>
    170c:	22 0f       	add	r18, r18
    170e:	33 1f       	adc	r19, r19
    1710:	e2 0f       	add	r30, r18
    1712:	f3 1f       	adc	r31, r19
    1714:	e3 58       	subi	r30, 0x83	; 131
    1716:	fd 4f       	sbci	r31, 0xFD	; 253
    1718:	e6 8e       	std	Z+30, r14	; 0x1e
    171a:	f7 8e       	std	Z+31, r15	; 0x1f
    171c:	00 a3       	std	Z+32, r16	; 0x20
    171e:	11 a3       	std	Z+33, r17	; 0x21
	bankStates[theBank].endAddress=bankStates[theBank].startAddress;			// And indicate that our sample is now 0 samples big.
    1720:	28 2f       	mov	r18, r24
    1722:	30 e0       	ldi	r19, 0x00	; 0
    1724:	f9 01       	movw	r30, r18
    1726:	b5 e0       	ldi	r27, 0x05	; 5
    1728:	ee 0f       	add	r30, r30
    172a:	ff 1f       	adc	r31, r31
    172c:	ba 95       	dec	r27
    172e:	e1 f7       	brne	.-8      	; 0x1728 <StartRecording+0x7e>
    1730:	22 0f       	add	r18, r18
    1732:	33 1f       	adc	r19, r19
    1734:	e2 0f       	add	r30, r18
    1736:	f3 1f       	adc	r31, r19
    1738:	e3 58       	subi	r30, 0x83	; 131
    173a:	fd 4f       	sbci	r31, 0xFD	; 253
    173c:	e7 84       	ldd	r14, Z+15	; 0x0f
    173e:	f0 88       	ldd	r15, Z+16	; 0x10
    1740:	01 89       	ldd	r16, Z+17	; 0x11
    1742:	12 89       	ldd	r17, Z+18	; 0x12
    1744:	28 2f       	mov	r18, r24
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	f9 01       	movw	r30, r18
    174a:	75 e0       	ldi	r23, 0x05	; 5
    174c:	ee 0f       	add	r30, r30
    174e:	ff 1f       	adc	r31, r31
    1750:	7a 95       	dec	r23
    1752:	e1 f7       	brne	.-8      	; 0x174c <StartRecording+0xa2>
    1754:	22 0f       	add	r18, r18
    1756:	33 1f       	adc	r19, r19
    1758:	e2 0f       	add	r30, r18
    175a:	f3 1f       	adc	r31, r19
    175c:	e3 58       	subi	r30, 0x83	; 131
    175e:	fd 4f       	sbci	r31, 0xFD	; 253
    1760:	e3 86       	std	Z+11, r14	; 0x0b
    1762:	f4 86       	std	Z+12, r15	; 0x0c
    1764:	05 87       	std	Z+13, r16	; 0x0d
    1766:	16 87       	std	Z+14, r17	; 0x0e
	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;	// No user trimming yet
    1768:	28 2f       	mov	r18, r24
    176a:	30 e0       	ldi	r19, 0x00	; 0
    176c:	f9 01       	movw	r30, r18
    176e:	b5 e0       	ldi	r27, 0x05	; 5
    1770:	ee 0f       	add	r30, r30
    1772:	ff 1f       	adc	r31, r31
    1774:	ba 95       	dec	r27
    1776:	e1 f7       	brne	.-8      	; 0x1770 <StartRecording+0xc6>
    1778:	22 0f       	add	r18, r18
    177a:	33 1f       	adc	r19, r19
    177c:	e2 0f       	add	r30, r18
    177e:	f3 1f       	adc	r31, r19
    1780:	e3 58       	subi	r30, 0x83	; 131
    1782:	fd 4f       	sbci	r31, 0xFD	; 253
    1784:	e7 84       	ldd	r14, Z+15	; 0x0f
    1786:	f0 88       	ldd	r15, Z+16	; 0x10
    1788:	01 89       	ldd	r16, Z+17	; 0x11
    178a:	12 89       	ldd	r17, Z+18	; 0x12
    178c:	28 2f       	mov	r18, r24
    178e:	30 e0       	ldi	r19, 0x00	; 0
    1790:	f9 01       	movw	r30, r18
    1792:	75 e0       	ldi	r23, 0x05	; 5
    1794:	ee 0f       	add	r30, r30
    1796:	ff 1f       	adc	r31, r31
    1798:	7a 95       	dec	r23
    179a:	e1 f7       	brne	.-8      	; 0x1794 <StartRecording+0xea>
    179c:	22 0f       	add	r18, r18
    179e:	33 1f       	adc	r19, r19
    17a0:	e2 0f       	add	r30, r18
    17a2:	f3 1f       	adc	r31, r19
    17a4:	e3 58       	subi	r30, 0x83	; 131
    17a6:	fd 4f       	sbci	r31, 0xFD	; 253
    17a8:	e7 8a       	std	Z+23, r14	; 0x17
    17aa:	f0 8e       	std	Z+24, r15	; 0x18
    17ac:	01 8f       	std	Z+25, r16	; 0x19
    17ae:	12 8f       	std	Z+26, r17	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].startAddress;	// "
    17b0:	28 2f       	mov	r18, r24
    17b2:	30 e0       	ldi	r19, 0x00	; 0
    17b4:	f9 01       	movw	r30, r18
    17b6:	b5 e0       	ldi	r27, 0x05	; 5
    17b8:	ee 0f       	add	r30, r30
    17ba:	ff 1f       	adc	r31, r31
    17bc:	ba 95       	dec	r27
    17be:	e1 f7       	brne	.-8      	; 0x17b8 <StartRecording+0x10e>
    17c0:	22 0f       	add	r18, r18
    17c2:	33 1f       	adc	r19, r19
    17c4:	e2 0f       	add	r30, r18
    17c6:	f3 1f       	adc	r31, r19
    17c8:	e3 58       	subi	r30, 0x83	; 131
    17ca:	fd 4f       	sbci	r31, 0xFD	; 253
    17cc:	e7 84       	ldd	r14, Z+15	; 0x0f
    17ce:	f0 88       	ldd	r15, Z+16	; 0x10
    17d0:	01 89       	ldd	r16, Z+17	; 0x11
    17d2:	12 89       	ldd	r17, Z+18	; 0x12
    17d4:	28 2f       	mov	r18, r24
    17d6:	30 e0       	ldi	r19, 0x00	; 0
    17d8:	f9 01       	movw	r30, r18
    17da:	75 e0       	ldi	r23, 0x05	; 5
    17dc:	ee 0f       	add	r30, r30
    17de:	ff 1f       	adc	r31, r31
    17e0:	7a 95       	dec	r23
    17e2:	e1 f7       	brne	.-8      	; 0x17dc <StartRecording+0x132>
    17e4:	22 0f       	add	r18, r18
    17e6:	33 1f       	adc	r19, r19
    17e8:	e2 0f       	add	r30, r18
    17ea:	f3 1f       	adc	r31, r19
    17ec:	e3 58       	subi	r30, 0x83	; 131
    17ee:	fd 4f       	sbci	r31, 0xFD	; 253
    17f0:	e3 8a       	std	Z+19, r14	; 0x13
    17f2:	f4 8a       	std	Z+20, r15	; 0x14
    17f4:	05 8b       	std	Z+21, r16	; 0x15
    17f6:	16 8b       	std	Z+22, r17	; 0x16
	bankStates[theBank].sampleWindowOffset=0;									// "
    17f8:	28 2f       	mov	r18, r24
    17fa:	30 e0       	ldi	r19, 0x00	; 0
    17fc:	f9 01       	movw	r30, r18
    17fe:	05 e0       	ldi	r16, 0x05	; 5
    1800:	ee 0f       	add	r30, r30
    1802:	ff 1f       	adc	r31, r31
    1804:	0a 95       	dec	r16
    1806:	e1 f7       	brne	.-8      	; 0x1800 <StartRecording+0x156>
    1808:	22 0f       	add	r18, r18
    180a:	33 1f       	adc	r19, r19
    180c:	e2 0f       	add	r30, r18
    180e:	f3 1f       	adc	r31, r19
    1810:	e3 58       	subi	r30, 0x83	; 131
    1812:	fd 4f       	sbci	r31, 0xFD	; 253
    1814:	15 8e       	std	Z+29, r1	; 0x1d

	outOfRam=false;						// Plenty of ram left...
    1816:	10 92 40 01 	sts	0x0140, r1

	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    181a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    181e:	df be       	out	0x3f, r13	; 63

// Throw out the results of an old conversion since it could be very old (unless it's already going)
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    1820:	80 91 7a 00 	lds	r24, 0x007A
    1824:	86 fd       	sbrc	r24, 6
    1826:	0a c0       	rjmp	.+20     	; 0x183c <StartRecording+0x192>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    1828:	80 91 79 00 	lds	r24, 0x0079
    182c:	80 58       	subi	r24, 0x80	; 128
    182e:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    1832:	80 91 7a 00 	lds	r24, 0x007A
    1836:	80 64       	ori	r24, 0x40	; 64
    1838:	80 93 7a 00 	sts	0x007A, r24
	}
}
    183c:	1f 91       	pop	r17
    183e:	0f 91       	pop	r16
    1840:	ff 90       	pop	r15
    1842:	ef 90       	pop	r14
    1844:	df 90       	pop	r13
    1846:	08 95       	ret

00001848 <StartPlayback>:
static void StartPlayback(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Point to the beginning of the sample, select the clock source, and get the interrupts going.
// Set the clock rate if we're using the internal clock.
// Mon Jul  6 19:05:04 CDT 2009
// We've made it clear that the beginning of the sample is relative, in the sense that if we're playing backwards we should point to the last sample address.
{
    1848:	1f 93       	push	r17
    184a:	78 2f       	mov	r23, r24
    184c:	da 01       	movw	r26, r20
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    184e:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    1850:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;						// What should we be doing when we get into the ISR?
    1852:	90 e0       	ldi	r25, 0x00	; 0
    1854:	fc 01       	movw	r30, r24
    1856:	35 e0       	ldi	r19, 0x05	; 5
    1858:	ee 0f       	add	r30, r30
    185a:	ff 1f       	adc	r31, r31
    185c:	3a 95       	dec	r19
    185e:	e1 f7       	brne	.-8      	; 0x1858 <StartPlayback+0x10>
    1860:	88 0f       	add	r24, r24
    1862:	99 1f       	adc	r25, r25
    1864:	e8 0f       	add	r30, r24
    1866:	f9 1f       	adc	r31, r25
    1868:	e3 58       	subi	r30, 0x83	; 131
    186a:	fd 4f       	sbci	r31, 0xFD	; 253
    186c:	84 e0       	ldi	r24, 0x04	; 4
    186e:	80 83       	st	Z, r24

	if(bankStates[theBank].backwardsPlayback)		// Playing backwards?
    1870:	87 2f       	mov	r24, r23
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	fc 01       	movw	r30, r24
    1876:	55 e0       	ldi	r21, 0x05	; 5
    1878:	ee 0f       	add	r30, r30
    187a:	ff 1f       	adc	r31, r31
    187c:	5a 95       	dec	r21
    187e:	e1 f7       	brne	.-8      	; 0x1878 <StartPlayback+0x30>
    1880:	88 0f       	add	r24, r24
    1882:	99 1f       	adc	r25, r25
    1884:	e8 0f       	add	r30, r24
    1886:	f9 1f       	adc	r31, r25
    1888:	e3 58       	subi	r30, 0x83	; 131
    188a:	fd 4f       	sbci	r31, 0xFD	; 253
    188c:	83 81       	ldd	r24, Z+3	; 0x03
    188e:	88 23       	and	r24, r24
    1890:	a9 f1       	breq	.+106    	; 0x18fc <StartPlayback+0xb4>
	{
		bankStates[theBank].currentAddress=bankStates[theBank].adjustedEndAddress;	// Point to the "beginning" of our sample.
    1892:	87 2f       	mov	r24, r23
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	fc 01       	movw	r30, r24
    1898:	35 e0       	ldi	r19, 0x05	; 5
    189a:	ee 0f       	add	r30, r30
    189c:	ff 1f       	adc	r31, r31
    189e:	3a 95       	dec	r19
    18a0:	e1 f7       	brne	.-8      	; 0x189a <StartPlayback+0x52>
    18a2:	88 0f       	add	r24, r24
    18a4:	99 1f       	adc	r25, r25
    18a6:	e8 0f       	add	r30, r24
    18a8:	f9 1f       	adc	r31, r25
    18aa:	e3 58       	subi	r30, 0x83	; 131
    18ac:	fd 4f       	sbci	r31, 0xFD	; 253
    18ae:	23 89       	ldd	r18, Z+19	; 0x13
    18b0:	34 89       	ldd	r19, Z+20	; 0x14
    18b2:	45 89       	ldd	r20, Z+21	; 0x15
    18b4:	56 89       	ldd	r21, Z+22	; 0x16
    18b6:	87 2f       	mov	r24, r23
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	fc 01       	movw	r30, r24
    18bc:	68 94       	set
    18be:	14 f8       	bld	r1, 4
    18c0:	ee 0f       	add	r30, r30
    18c2:	ff 1f       	adc	r31, r31
    18c4:	16 94       	lsr	r1
    18c6:	e1 f7       	brne	.-8      	; 0x18c0 <StartPlayback+0x78>
    18c8:	88 0f       	add	r24, r24
    18ca:	99 1f       	adc	r25, r25
    18cc:	e8 0f       	add	r30, r24
    18ce:	f9 1f       	adc	r31, r25
    18d0:	e3 58       	subi	r30, 0x83	; 131
    18d2:	fd 4f       	sbci	r31, 0xFD	; 253
    18d4:	26 8f       	std	Z+30, r18	; 0x1e
    18d6:	37 8f       	std	Z+31, r19	; 0x1f
    18d8:	40 a3       	std	Z+32, r20	; 0x20
    18da:	51 a3       	std	Z+33, r21	; 0x21
		bankStates[theBank].sampleDirection=false;	// make us run backwards.
    18dc:	87 2f       	mov	r24, r23
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	fc 01       	movw	r30, r24
    18e2:	55 e0       	ldi	r21, 0x05	; 5
    18e4:	ee 0f       	add	r30, r30
    18e6:	ff 1f       	adc	r31, r31
    18e8:	5a 95       	dec	r21
    18ea:	e1 f7       	brne	.-8      	; 0x18e4 <StartPlayback+0x9c>
    18ec:	88 0f       	add	r24, r24
    18ee:	99 1f       	adc	r25, r25
    18f0:	e8 0f       	add	r30, r24
    18f2:	f9 1f       	adc	r31, r25
    18f4:	e3 58       	subi	r30, 0x83	; 131
    18f6:	fd 4f       	sbci	r31, 0xFD	; 253
    18f8:	14 82       	std	Z+4, r1	; 0x04
    18fa:	35 c0       	rjmp	.+106    	; 0x1966 <StartPlayback+0x11e>
	}
	else
	{
		bankStates[theBank].currentAddress=bankStates[theBank].adjustedStartAddress;	// Point to the beginning of our sample.	
    18fc:	87 2f       	mov	r24, r23
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	fc 01       	movw	r30, r24
    1902:	35 e0       	ldi	r19, 0x05	; 5
    1904:	ee 0f       	add	r30, r30
    1906:	ff 1f       	adc	r31, r31
    1908:	3a 95       	dec	r19
    190a:	e1 f7       	brne	.-8      	; 0x1904 <StartPlayback+0xbc>
    190c:	88 0f       	add	r24, r24
    190e:	99 1f       	adc	r25, r25
    1910:	e8 0f       	add	r30, r24
    1912:	f9 1f       	adc	r31, r25
    1914:	e3 58       	subi	r30, 0x83	; 131
    1916:	fd 4f       	sbci	r31, 0xFD	; 253
    1918:	27 89       	ldd	r18, Z+23	; 0x17
    191a:	30 8d       	ldd	r19, Z+24	; 0x18
    191c:	41 8d       	ldd	r20, Z+25	; 0x19
    191e:	52 8d       	ldd	r21, Z+26	; 0x1a
    1920:	87 2f       	mov	r24, r23
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	fc 01       	movw	r30, r24
    1926:	68 94       	set
    1928:	14 f8       	bld	r1, 4
    192a:	ee 0f       	add	r30, r30
    192c:	ff 1f       	adc	r31, r31
    192e:	16 94       	lsr	r1
    1930:	e1 f7       	brne	.-8      	; 0x192a <StartPlayback+0xe2>
    1932:	88 0f       	add	r24, r24
    1934:	99 1f       	adc	r25, r25
    1936:	e8 0f       	add	r30, r24
    1938:	f9 1f       	adc	r31, r25
    193a:	e3 58       	subi	r30, 0x83	; 131
    193c:	fd 4f       	sbci	r31, 0xFD	; 253
    193e:	26 8f       	std	Z+30, r18	; 0x1e
    1940:	37 8f       	std	Z+31, r19	; 0x1f
    1942:	40 a3       	std	Z+32, r20	; 0x20
    1944:	51 a3       	std	Z+33, r21	; 0x21
		bankStates[theBank].sampleDirection=true;	// make us run forwards.
    1946:	87 2f       	mov	r24, r23
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	fc 01       	movw	r30, r24
    194c:	35 e0       	ldi	r19, 0x05	; 5
    194e:	ee 0f       	add	r30, r30
    1950:	ff 1f       	adc	r31, r31
    1952:	3a 95       	dec	r19
    1954:	e1 f7       	brne	.-8      	; 0x194e <StartPlayback+0x106>
    1956:	88 0f       	add	r24, r24
    1958:	99 1f       	adc	r25, r25
    195a:	e8 0f       	add	r30, r24
    195c:	f9 1f       	adc	r31, r25
    195e:	e3 58       	subi	r30, 0x83	; 131
    1960:	fd 4f       	sbci	r31, 0xFD	; 253
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	84 83       	std	Z+4, r24	; 0x04
	}
	
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    1966:	87 2f       	mov	r24, r23
    1968:	ad 01       	movw	r20, r26
    196a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    196e:	1f bf       	out	0x3f, r17	; 63
}
    1970:	1f 91       	pop	r17
    1972:	08 95       	ret

00001974 <StartRealtime>:
	}
}

static void StartRealtime(unsigned char theBank, unsigned char theClock, unsigned int theRate)
// Begins processing audio in realtime on the passed channel using the passed clock source.
{
    1974:	1f 93       	push	r17
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    1976:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    1978:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_REALTIME;	// What should we be doing when we get into the ISR?
    197a:	28 2f       	mov	r18, r24
    197c:	30 e0       	ldi	r19, 0x00	; 0
    197e:	f9 01       	movw	r30, r18
    1980:	a5 e0       	ldi	r26, 0x05	; 5
    1982:	ee 0f       	add	r30, r30
    1984:	ff 1f       	adc	r31, r31
    1986:	aa 95       	dec	r26
    1988:	e1 f7       	brne	.-8      	; 0x1982 <StartRealtime+0xe>
    198a:	22 0f       	add	r18, r18
    198c:	33 1f       	adc	r19, r19
    198e:	e2 0f       	add	r30, r18
    1990:	f3 1f       	adc	r31, r19
    1992:	e3 58       	subi	r30, 0x83	; 131
    1994:	fd 4f       	sbci	r31, 0xFD	; 253
    1996:	92 e0       	ldi	r25, 0x02	; 2
    1998:	90 83       	st	Z, r25
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    199a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    199e:	1f bf       	out	0x3f, r17	; 63

	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    19a0:	80 91 7a 00 	lds	r24, 0x007A
    19a4:	86 fd       	sbrc	r24, 6
    19a6:	0a c0       	rjmp	.+20     	; 0x19bc <StartRealtime+0x48>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    19a8:	80 91 79 00 	lds	r24, 0x0079
    19ac:	80 58       	subi	r24, 0x80	; 128
    19ae:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    19b2:	80 91 7a 00 	lds	r24, 0x007A
    19b6:	80 64       	ori	r24, 0x40	; 64
    19b8:	80 93 7a 00 	sts	0x007A, r24
	}
}
    19bc:	1f 91       	pop	r17
    19be:	08 95       	ret

000019c0 <GetPlaybackRateFromNote>:
	B_NOTE,
};

static unsigned int	GetPlaybackRateFromNote(unsigned char theNote)
// Here we take a midi note number and turn it into the timer one compare match interrupt value.
{
    19c0:	28 2f       	mov	r18, r24
    19c2:	6c e0       	ldi	r22, 0x0C	; 12
    19c4:	0e 94 24 29 	call	0x5248	; 0x5248 <__udivmodqi4>
    19c8:	e9 2f       	mov	r30, r25
    19ca:	f0 e0       	ldi	r31, 0x00	; 0
    19cc:	ee 0f       	add	r30, r30
    19ce:	ff 1f       	adc	r31, r31
    19d0:	ea 5f       	subi	r30, 0xFA	; 250
    19d2:	fe 4f       	sbci	r31, 0xFE	; 254
    19d4:	82 2f       	mov	r24, r18
    19d6:	0e 94 24 29 	call	0x5248	; 0x5248 <__udivmodqi4>
    19da:	20 81       	ld	r18, Z
    19dc:	31 81       	ldd	r19, Z+1	; 0x01
    19de:	02 c0       	rjmp	.+4      	; 0x19e4 <GetPlaybackRateFromNote+0x24>
    19e0:	36 95       	lsr	r19
    19e2:	27 95       	ror	r18
    19e4:	8a 95       	dec	r24
    19e6:	e2 f7       	brpl	.-8      	; 0x19e0 <GetPlaybackRateFromNote+0x20>
	theOctave=(theNote/12);	// Which octave?
	theIndex=(theNote%12);	// Which note inside the octave?

	return((OctaveZeroCompareMatches[theIndex])>>theOctave);		// Return our value using the lookup table.

}
    19e8:	c9 01       	movw	r24, r18
    19ea:	08 95       	ret

000019ec <MakeNewGranularArray>:
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    19ec:	2f 92       	push	r2
    19ee:	3f 92       	push	r3
    19f0:	4f 92       	push	r4
    19f2:	5f 92       	push	r5
    19f4:	6f 92       	push	r6
    19f6:	7f 92       	push	r7
    19f8:	8f 92       	push	r8
    19fa:	9f 92       	push	r9
    19fc:	af 92       	push	r10
    19fe:	bf 92       	push	r11
    1a00:	cf 92       	push	r12
    1a02:	df 92       	push	r13
    1a04:	ef 92       	push	r14
    1a06:	ff 92       	push	r15
    1a08:	0f 93       	push	r16
    1a0a:	1f 93       	push	r17
    1a0c:	df 93       	push	r29
    1a0e:	cf 93       	push	r28
    1a10:	00 d0       	rcall	.+0      	; 0x1a12 <MakeNewGranularArray+0x26>
    1a12:	0f 92       	push	r0
    1a14:	cd b7       	in	r28, 0x3d	; 61
    1a16:	de b7       	in	r29, 0x3e	; 62
    1a18:	28 2e       	mov	r2, r24
		i,
		origContents,
		randIndex,
		randContents;

	if(numSlices>1)		// Enough slices to do something?
    1a1a:	62 30       	cpi	r22, 0x02	; 2
    1a1c:	08 f4       	brcc	.+2      	; 0x1a20 <MakeNewGranularArray+0x34>
    1a1e:	f4 c0       	rjmp	.+488    	; 0x1c08 <MakeNewGranularArray+0x21c>
	{
		sreg=SREG;
    1a20:	8f b7       	in	r24, 0x3f	; 63
    1a22:	89 83       	std	Y+1, r24	; 0x01
		cli();			// Pause interrupts while we non-atomically mess with variables the ISR be reading.
    1a24:	f8 94       	cli
    1a26:	66 2e       	mov	r6, r22
    1a28:	90 e8       	ldi	r25, 0x80	; 128
    1a2a:	96 17       	cp	r25, r22
    1a2c:	10 f4       	brcc	.+4      	; 0x1a32 <MakeNewGranularArray+0x46>
    1a2e:	70 e8       	ldi	r23, 0x80	; 128
    1a30:	67 2e       	mov	r6, r23
static void MakeNewGranularArray(unsigned char theBank, unsigned char numSlices)
// Make a new random order of slices as big as the user wants, up to MAX_SLICES.
// We will first fill an array with incrementing numbers up to the number of slices we care about, then we'll shuffle that much of the array into a random order.
// Leave this function having updated the number of slices our sample will be divided into and the size of those slices.
// Further, point to the first random slice in the randomized array, and point the sample address to the beginning of the first slice in RAM. 
{
    1a32:	82 2c       	mov	r8, r2
    1a34:	99 24       	eor	r9, r9
    1a36:	d4 01       	movw	r26, r8
    1a38:	b6 95       	lsr	r27
    1a3a:	ba 2f       	mov	r27, r26
    1a3c:	aa 27       	eor	r26, r26
    1a3e:	b7 95       	ror	r27
    1a40:	a7 95       	ror	r26
    1a42:	aa 5a       	subi	r26, 0xAA	; 170
    1a44:	be 4f       	sbci	r27, 0xFE	; 254
    1a46:	bb 83       	std	Y+3, r27	; 0x03
    1a48:	aa 83       	std	Y+2, r26	; 0x02
    1a4a:	fd 01       	movw	r30, r26
    1a4c:	80 e0       	ldi	r24, 0x00	; 0
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
    1a4e:	81 93       	st	Z+, r24
		if(numSlices>MAX_SLICES)
		{
			numSlices=MAX_SLICES;
		}

		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
    1a50:	8f 5f       	subi	r24, 0xFF	; 255
    1a52:	86 15       	cp	r24, r6
    1a54:	e0 f3       	brcs	.-8      	; 0x1a4e <MakeNewGranularArray+0x62>
    1a56:	e0 90 00 01 	lds	r14, 0x0100
    1a5a:	f0 90 01 01 	lds	r15, 0x0101
    1a5e:	00 91 02 01 	lds	r16, 0x0102
    1a62:	10 91 03 01 	lds	r17, 0x0103
    1a66:	77 24       	eor	r7, r7
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
    1a68:	a6 2c       	mov	r10, r6
    1a6a:	bb 24       	eor	r11, r11
    1a6c:	cc 24       	eor	r12, r12
    1a6e:	dd 24       	eor	r13, r13
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1a70:	24 01       	movw	r4, r8
    1a72:	56 94       	lsr	r5
    1a74:	54 2c       	mov	r5, r4
    1a76:	44 24       	eor	r4, r4
    1a78:	57 94       	ror	r5
    1a7a:	47 94       	ror	r4
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
    1a7c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a7e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a80:	30 80       	ld	r3, Z
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    1a82:	ee 0c       	add	r14, r14
    1a84:	ff 1c       	adc	r15, r15
    1a86:	00 1f       	adc	r16, r16
    1a88:	11 1f       	adc	r17, r17
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    1a8a:	17 ff       	sbrs	r17, 7
    1a8c:	08 c0       	rjmp	.+16     	; 0x1a9e <MakeNewGranularArray+0xb2>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    1a8e:	85 eb       	ldi	r24, 0xB5	; 181
    1a90:	95 e9       	ldi	r25, 0x95	; 149
    1a92:	aa ea       	ldi	r26, 0xAA	; 170
    1a94:	b0 e2       	ldi	r27, 0x20	; 32
    1a96:	e8 26       	eor	r14, r24
    1a98:	f9 26       	eor	r15, r25
    1a9a:	0a 27       	eor	r16, r26
    1a9c:	1b 27       	eor	r17, r27

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
		{
			origContents=granularPositionArray[theBank][i];				// Store the contents of the current array address.
			randIndex=(GetRandomLongInt()%numSlices);					// Get random array address up to what we care about.
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
    1a9e:	c8 01       	movw	r24, r16
    1aa0:	b7 01       	movw	r22, r14
    1aa2:	a6 01       	movw	r20, r12
    1aa4:	95 01       	movw	r18, r10
    1aa6:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
    1aaa:	f2 01       	movw	r30, r4
    1aac:	e6 0f       	add	r30, r22
    1aae:	f1 1d       	adc	r31, r1
    1ab0:	ea 5a       	subi	r30, 0xAA	; 170
    1ab2:	fe 4f       	sbci	r31, 0xFE	; 254
    1ab4:	80 81       	ld	r24, Z
    1ab6:	aa 81       	ldd	r26, Y+2	; 0x02
    1ab8:	bb 81       	ldd	r27, Y+3	; 0x03
    1aba:	8d 93       	st	X+, r24
    1abc:	bb 83       	std	Y+3, r27	; 0x03
    1abe:	aa 83       	std	Y+2, r26	; 0x02
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
    1ac0:	30 82       	st	Z, r3
		for(i=0;i<numSlices;i++)	// Fill our array up to the number of slices we care about.
		{
			granularPositionArray[theBank][i]=i;		// Our array starts as a list of numbers incrementing upwards.
		}

		for(i=0;i<numSlices;i++)	// Now, for each element in the array, exchange it with another.  Shuffle the deck.
    1ac2:	73 94       	inc	r7
    1ac4:	76 14       	cp	r7, r6
    1ac6:	d0 f2       	brcs	.-76     	; 0x1a7c <MakeNewGranularArray+0x90>
    1ac8:	e0 92 00 01 	sts	0x0100, r14
    1acc:	f0 92 01 01 	sts	0x0101, r15
    1ad0:	00 93 02 01 	sts	0x0102, r16
    1ad4:	10 93 03 01 	sts	0x0103, r17
			randContents=granularPositionArray[theBank][randIndex];		// Store the contents of the mystery address.
			granularPositionArray[theBank][i]=randContents;				// Put the mystery register contents into the current register.
			granularPositionArray[theBank][randIndex]=origContents;		// And the contents of the original register into the mystery register.
		}

		if(theBank==BANK_0)		// Get slice size assuming banks grow upwards
    1ad8:	22 20       	and	r2, r2
    1ada:	b9 f4       	brne	.+46     	; 0x1b0a <MakeNewGranularArray+0x11e>
		{
			sliceSize[BANK_0]=(bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)/numSlices;
    1adc:	60 91 88 02 	lds	r22, 0x0288
    1ae0:	70 91 89 02 	lds	r23, 0x0289
    1ae4:	80 91 8a 02 	lds	r24, 0x028A
    1ae8:	90 91 8b 02 	lds	r25, 0x028B
    1aec:	a6 01       	movw	r20, r12
    1aee:	95 01       	movw	r18, r10
    1af0:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
    1af4:	c9 01       	movw	r24, r18
    1af6:	da 01       	movw	r26, r20
    1af8:	80 93 46 01 	sts	0x0146, r24
    1afc:	90 93 47 01 	sts	0x0147, r25
    1b00:	a0 93 48 01 	sts	0x0148, r26
    1b04:	b0 93 49 01 	sts	0x0149, r27
    1b08:	1e c0       	rjmp	.+60     	; 0x1b46 <MakeNewGranularArray+0x15a>
		}	
		else					// Otherwise assume banks grow down.
		{
			sliceSize[BANK_1]=(BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)/numSlices;		
    1b0a:	20 91 aa 02 	lds	r18, 0x02AA
    1b0e:	30 91 ab 02 	lds	r19, 0x02AB
    1b12:	40 91 ac 02 	lds	r20, 0x02AC
    1b16:	50 91 ad 02 	lds	r21, 0x02AD
    1b1a:	6f ef       	ldi	r22, 0xFF	; 255
    1b1c:	7f ef       	ldi	r23, 0xFF	; 255
    1b1e:	87 e0       	ldi	r24, 0x07	; 7
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	62 1b       	sub	r22, r18
    1b24:	73 0b       	sbc	r23, r19
    1b26:	84 0b       	sbc	r24, r20
    1b28:	95 0b       	sbc	r25, r21
    1b2a:	a6 01       	movw	r20, r12
    1b2c:	95 01       	movw	r18, r10
    1b2e:	0e 94 43 29 	call	0x5286	; 0x5286 <__udivmodsi4>
    1b32:	c9 01       	movw	r24, r18
    1b34:	da 01       	movw	r26, r20
    1b36:	80 93 4a 01 	sts	0x014A, r24
    1b3a:	90 93 4b 01 	sts	0x014B, r25
    1b3e:	a0 93 4c 01 	sts	0x014C, r26
    1b42:	b0 93 4d 01 	sts	0x014D, r27
		}

		bankStates[theBank].granularSlices=numSlices;	// How many slices is our entire sample divided into?
    1b46:	f4 01       	movw	r30, r8
    1b48:	ee 0f       	add	r30, r30
    1b4a:	ff 1f       	adc	r31, r31
    1b4c:	c4 01       	movw	r24, r8
    1b4e:	25 e0       	ldi	r18, 0x05	; 5
    1b50:	88 0f       	add	r24, r24
    1b52:	99 1f       	adc	r25, r25
    1b54:	2a 95       	dec	r18
    1b56:	e1 f7       	brne	.-8      	; 0x1b50 <MakeNewGranularArray+0x164>
    1b58:	e8 0f       	add	r30, r24
    1b5a:	f9 1f       	adc	r31, r25
    1b5c:	e3 58       	subi	r30, 0x83	; 131
    1b5e:	fd 4f       	sbci	r31, 0xFD	; 253
    1b60:	65 82       	std	Z+5, r6	; 0x05
		granularPositionArrayPointer[theBank]=0;		// Point to the first element of our shuffled array.
    1b62:	f4 01       	movw	r30, r8
    1b64:	ec 5b       	subi	r30, 0xBC	; 188
    1b66:	fe 4f       	sbci	r31, 0xFE	; 254
    1b68:	10 82       	st	Z, r1
		sliceRemaining[theBank]=sliceSize[theBank];		// One entire slice to go.
    1b6a:	f4 01       	movw	r30, r8
    1b6c:	ee 0f       	add	r30, r30
    1b6e:	ff 1f       	adc	r31, r31
    1b70:	ee 0f       	add	r30, r30
    1b72:	ff 1f       	adc	r31, r31
    1b74:	df 01       	movw	r26, r30
    1b76:	aa 5b       	subi	r26, 0xBA	; 186
    1b78:	be 4f       	sbci	r27, 0xFE	; 254
    1b7a:	8d 91       	ld	r24, X+
    1b7c:	9d 91       	ld	r25, X+
    1b7e:	0d 90       	ld	r0, X+
    1b80:	bc 91       	ld	r27, X
    1b82:	a0 2d       	mov	r26, r0
    1b84:	e2 5b       	subi	r30, 0xB2	; 178
    1b86:	fe 4f       	sbci	r31, 0xFE	; 254
    1b88:	80 83       	st	Z, r24
    1b8a:	91 83       	std	Z+1, r25	; 0x01
    1b8c:	a2 83       	std	Z+2, r26	; 0x02
    1b8e:	b3 83       	std	Z+3, r27	; 0x03

		if(theBank==BANK_0)		// Set the current address of the sample pointer to the beginning of the first slice.
    1b90:	22 20       	and	r2, r2
    1b92:	c1 f4       	brne	.+48     	; 0x1bc4 <MakeNewGranularArray+0x1d8>
		{
			bankStates[BANK_0].currentAddress=((granularPositionArray[BANK_0][0]*sliceSize[BANK_0])+BANK_0_START_ADDRESS);
    1b94:	20 91 46 01 	lds	r18, 0x0146
    1b98:	30 91 47 01 	lds	r19, 0x0147
    1b9c:	40 91 48 01 	lds	r20, 0x0148
    1ba0:	50 91 49 01 	lds	r21, 0x0149
    1ba4:	60 91 56 01 	lds	r22, 0x0156
    1ba8:	70 e0       	ldi	r23, 0x00	; 0
    1baa:	80 e0       	ldi	r24, 0x00	; 0
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    1bb2:	60 93 9b 02 	sts	0x029B, r22
    1bb6:	70 93 9c 02 	sts	0x029C, r23
    1bba:	80 93 9d 02 	sts	0x029D, r24
    1bbe:	90 93 9e 02 	sts	0x029E, r25
    1bc2:	1f c0       	rjmp	.+62     	; 0x1c02 <MakeNewGranularArray+0x216>
		}
		else
		{
			bankStates[BANK_1].currentAddress=(BANK_1_START_ADDRESS-(granularPositionArray[BANK_1][0]*sliceSize[BANK_1]));								
    1bc4:	20 91 4a 01 	lds	r18, 0x014A
    1bc8:	30 91 4b 01 	lds	r19, 0x014B
    1bcc:	40 91 4c 01 	lds	r20, 0x014C
    1bd0:	50 91 4d 01 	lds	r21, 0x014D
    1bd4:	60 91 d6 01 	lds	r22, 0x01D6
    1bd8:	70 e0       	ldi	r23, 0x00	; 0
    1bda:	80 e0       	ldi	r24, 0x00	; 0
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    1be2:	2f ef       	ldi	r18, 0xFF	; 255
    1be4:	3f ef       	ldi	r19, 0xFF	; 255
    1be6:	47 e0       	ldi	r20, 0x07	; 7
    1be8:	50 e0       	ldi	r21, 0x00	; 0
    1bea:	26 1b       	sub	r18, r22
    1bec:	37 0b       	sbc	r19, r23
    1bee:	48 0b       	sbc	r20, r24
    1bf0:	59 0b       	sbc	r21, r25
    1bf2:	20 93 bd 02 	sts	0x02BD, r18
    1bf6:	30 93 be 02 	sts	0x02BE, r19
    1bfa:	40 93 bf 02 	sts	0x02BF, r20
    1bfe:	50 93 c0 02 	sts	0x02C0, r21
		}

		SREG=sreg;		// Restore interrupts.
    1c02:	b9 81       	ldd	r27, Y+1	; 0x01
    1c04:	bf bf       	out	0x3f, r27	; 63
    1c06:	0e c0       	rjmp	.+28     	; 0x1c24 <MakeNewGranularArray+0x238>
	}
	else
	{
		bankStates[theBank].granularSlices=0;	//	Flag the ISR to stop granular business.	
    1c08:	90 e0       	ldi	r25, 0x00	; 0
    1c0a:	fc 01       	movw	r30, r24
    1c0c:	05 e0       	ldi	r16, 0x05	; 5
    1c0e:	ee 0f       	add	r30, r30
    1c10:	ff 1f       	adc	r31, r31
    1c12:	0a 95       	dec	r16
    1c14:	e1 f7       	brne	.-8      	; 0x1c0e <MakeNewGranularArray+0x222>
    1c16:	88 0f       	add	r24, r24
    1c18:	99 1f       	adc	r25, r25
    1c1a:	e8 0f       	add	r30, r24
    1c1c:	f9 1f       	adc	r31, r25
    1c1e:	e3 58       	subi	r30, 0x83	; 131
    1c20:	fd 4f       	sbci	r31, 0xFD	; 253
    1c22:	15 82       	std	Z+5, r1	; 0x05
	}
}
    1c24:	0f 90       	pop	r0
    1c26:	0f 90       	pop	r0
    1c28:	0f 90       	pop	r0
    1c2a:	cf 91       	pop	r28
    1c2c:	df 91       	pop	r29
    1c2e:	1f 91       	pop	r17
    1c30:	0f 91       	pop	r16
    1c32:	ff 90       	pop	r15
    1c34:	ef 90       	pop	r14
    1c36:	df 90       	pop	r13
    1c38:	cf 90       	pop	r12
    1c3a:	bf 90       	pop	r11
    1c3c:	af 90       	pop	r10
    1c3e:	9f 90       	pop	r9
    1c40:	8f 90       	pop	r8
    1c42:	7f 90       	pop	r7
    1c44:	6f 90       	pop	r6
    1c46:	5f 90       	pop	r5
    1c48:	4f 90       	pop	r4
    1c4a:	3f 90       	pop	r3
    1c4c:	2f 90       	pop	r2
    1c4e:	08 95       	ret

00001c50 <UpdateAdjustedSampleAddresses>:
// This system lets us arbitrarily set the way we want the sample to go, and then reverse it when the sample end and start points are switched.  Using these two variables makes this decision deterministic in all cases.

static void UpdateAdjustedSampleAddresses(unsigned char theBank)
// Using window, start, and stop info, this routine sets the beginning and end point within a sample that's been trimmed.
// We trim in "chunks" which are 1/256ths of the entire sample (because that's the resolution of the shuttle)
{
    1c50:	2f 92       	push	r2
    1c52:	3f 92       	push	r3
    1c54:	4f 92       	push	r4
    1c56:	5f 92       	push	r5
    1c58:	6f 92       	push	r6
    1c5a:	7f 92       	push	r7
    1c5c:	8f 92       	push	r8
    1c5e:	9f 92       	push	r9
    1c60:	af 92       	push	r10
    1c62:	bf 92       	push	r11
    1c64:	cf 92       	push	r12
    1c66:	df 92       	push	r13
    1c68:	ef 92       	push	r14
    1c6a:	ff 92       	push	r15
    1c6c:	0f 93       	push	r16
    1c6e:	1f 93       	push	r17
    1c70:	df 93       	push	r29
    1c72:	cf 93       	push	r28
    1c74:	0f 92       	push	r0
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
	unsigned char 
		sreg;
	unsigned long
		chunkSize;
		
	sreg=SREG;
    1c7a:	9f b7       	in	r25, 0x3f	; 63
    1c7c:	99 83       	std	Y+1, r25	; 0x01
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    1c7e:	f8 94       	cli

	if(theBank==BANK_0)		// Get chunk size assuming banks grow upwards
    1c80:	88 23       	and	r24, r24
    1c82:	09 f0       	breq	.+2      	; 0x1c86 <UpdateAdjustedSampleAddresses+0x36>
    1c84:	f4 c1       	rjmp	.+1000   	; 0x206e <UpdateAdjustedSampleAddresses+0x41e>
	{
		chunkSize=(((bankStates[BANK_0].endAddress-BANK_0_START_ADDRESS)<<3)/256);			// Get chunk size of current sample (shift this up to get some more resolution)
    1c86:	a0 90 88 02 	lds	r10, 0x0288
    1c8a:	b0 90 89 02 	lds	r11, 0x0289
    1c8e:	c0 90 8a 02 	lds	r12, 0x028A
    1c92:	d0 90 8b 02 	lds	r13, 0x028B
    1c96:	73 e0       	ldi	r23, 0x03	; 3
    1c98:	aa 0c       	add	r10, r10
    1c9a:	bb 1c       	adc	r11, r11
    1c9c:	cc 1c       	adc	r12, r12
    1c9e:	dd 1c       	adc	r13, r13
    1ca0:	7a 95       	dec	r23
    1ca2:	d1 f7       	brne	.-12     	; 0x1c98 <UpdateAdjustedSampleAddresses+0x48>
    1ca4:	ab 2c       	mov	r10, r11
    1ca6:	bc 2c       	mov	r11, r12
    1ca8:	cd 2c       	mov	r12, r13
    1caa:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_0].adjustedStartAddress=(BANK_0_START_ADDRESS+((chunkSize*(bankStates[BANK_0].sampleStartOffset+(unsigned int)bankStates[BANK_0].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    1cac:	60 91 98 02 	lds	r22, 0x0298
    1cb0:	20 91 9a 02 	lds	r18, 0x029A
    1cb4:	70 e0       	ldi	r23, 0x00	; 0
    1cb6:	62 0f       	add	r22, r18
    1cb8:	71 1d       	adc	r23, r1
    1cba:	80 e0       	ldi	r24, 0x00	; 0
    1cbc:	90 e0       	ldi	r25, 0x00	; 0
    1cbe:	a6 01       	movw	r20, r12
    1cc0:	95 01       	movw	r18, r10
    1cc2:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    1cc6:	53 e0       	ldi	r21, 0x03	; 3
    1cc8:	96 95       	lsr	r25
    1cca:	87 95       	ror	r24
    1ccc:	77 95       	ror	r23
    1cce:	67 95       	ror	r22
    1cd0:	5a 95       	dec	r21
    1cd2:	d1 f7       	brne	.-12     	; 0x1cc8 <UpdateAdjustedSampleAddresses+0x78>
    1cd4:	60 93 94 02 	sts	0x0294, r22
    1cd8:	70 93 95 02 	sts	0x0295, r23
    1cdc:	80 93 96 02 	sts	0x0296, r24
    1ce0:	90 93 97 02 	sts	0x0297, r25
		bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].endAddress-((chunkSize*bankStates[BANK_0].sampleEndOffset)>>3))+((chunkSize*bankStates[BANK_0].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    1ce4:	20 90 88 02 	lds	r2, 0x0288
    1ce8:	30 90 89 02 	lds	r3, 0x0289
    1cec:	40 90 8a 02 	lds	r4, 0x028A
    1cf0:	50 90 8b 02 	lds	r5, 0x028B
    1cf4:	60 90 99 02 	lds	r6, 0x0299
    1cf8:	20 91 9a 02 	lds	r18, 0x029A
    1cfc:	30 e0       	ldi	r19, 0x00	; 0
    1cfe:	40 e0       	ldi	r20, 0x00	; 0
    1d00:	50 e0       	ldi	r21, 0x00	; 0
    1d02:	c6 01       	movw	r24, r12
    1d04:	b5 01       	movw	r22, r10
    1d06:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    1d0a:	7b 01       	movw	r14, r22
    1d0c:	8c 01       	movw	r16, r24
    1d0e:	43 e0       	ldi	r20, 0x03	; 3
    1d10:	16 95       	lsr	r17
    1d12:	07 95       	ror	r16
    1d14:	f7 94       	ror	r15
    1d16:	e7 94       	ror	r14
    1d18:	4a 95       	dec	r20
    1d1a:	d1 f7       	brne	.-12     	; 0x1d10 <UpdateAdjustedSampleAddresses+0xc0>
    1d1c:	e2 0c       	add	r14, r2
    1d1e:	f3 1c       	adc	r15, r3
    1d20:	04 1d       	adc	r16, r4
    1d22:	15 1d       	adc	r17, r5
    1d24:	77 24       	eor	r7, r7
    1d26:	88 24       	eor	r8, r8
    1d28:	99 24       	eor	r9, r9
    1d2a:	c6 01       	movw	r24, r12
    1d2c:	b5 01       	movw	r22, r10
    1d2e:	a4 01       	movw	r20, r8
    1d30:	93 01       	movw	r18, r6
    1d32:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    1d36:	33 e0       	ldi	r19, 0x03	; 3
    1d38:	96 95       	lsr	r25
    1d3a:	87 95       	ror	r24
    1d3c:	77 95       	ror	r23
    1d3e:	67 95       	ror	r22
    1d40:	3a 95       	dec	r19
    1d42:	d1 f7       	brne	.-12     	; 0x1d38 <UpdateAdjustedSampleAddresses+0xe8>
    1d44:	e6 1a       	sub	r14, r22
    1d46:	f7 0a       	sbc	r15, r23
    1d48:	08 0b       	sbc	r16, r24
    1d4a:	19 0b       	sbc	r17, r25
    1d4c:	e0 92 90 02 	sts	0x0290, r14
    1d50:	f0 92 91 02 	sts	0x0291, r15
    1d54:	00 93 92 02 	sts	0x0292, r16
    1d58:	10 93 93 02 	sts	0x0293, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    1d5c:	20 91 94 02 	lds	r18, 0x0294
    1d60:	30 91 95 02 	lds	r19, 0x0295
    1d64:	40 91 96 02 	lds	r20, 0x0296
    1d68:	50 91 97 02 	lds	r21, 0x0297
    1d6c:	80 91 90 02 	lds	r24, 0x0290
    1d70:	90 91 91 02 	lds	r25, 0x0291
    1d74:	a0 91 92 02 	lds	r26, 0x0292
    1d78:	b0 91 93 02 	lds	r27, 0x0293
    1d7c:	82 17       	cp	r24, r18
    1d7e:	93 07       	cpc	r25, r19
    1d80:	a4 07       	cpc	r26, r20
    1d82:	b5 07       	cpc	r27, r21
    1d84:	50 f5       	brcc	.+84     	; 0x1dda <UpdateAdjustedSampleAddresses+0x18a>
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    1d86:	80 91 80 02 	lds	r24, 0x0280
    1d8a:	81 30       	cpi	r24, 0x01	; 1
    1d8c:	19 f4       	brne	.+6      	; 0x1d94 <UpdateAdjustedSampleAddresses+0x144>
			{
				bankStates[BANK_0].sampleDirection=true;
    1d8e:	80 93 81 02 	sts	0x0281, r24
    1d92:	02 c0       	rjmp	.+4      	; 0x1d98 <UpdateAdjustedSampleAddresses+0x148>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=false;
    1d94:	10 92 81 02 	sts	0x0281, r1
			}			

			chunkSize=bankStates[BANK_0].adjustedStartAddress;								// move start to temp
    1d98:	20 91 94 02 	lds	r18, 0x0294
    1d9c:	30 91 95 02 	lds	r19, 0x0295
    1da0:	40 91 96 02 	lds	r20, 0x0296
    1da4:	50 91 97 02 	lds	r21, 0x0297
			bankStates[BANK_0].adjustedStartAddress=bankStates[BANK_0].adjustedEndAddress;	// move end to start
    1da8:	80 91 90 02 	lds	r24, 0x0290
    1dac:	90 91 91 02 	lds	r25, 0x0291
    1db0:	a0 91 92 02 	lds	r26, 0x0292
    1db4:	b0 91 93 02 	lds	r27, 0x0293
    1db8:	80 93 94 02 	sts	0x0294, r24
    1dbc:	90 93 95 02 	sts	0x0295, r25
    1dc0:	a0 93 96 02 	sts	0x0296, r26
    1dc4:	b0 93 97 02 	sts	0x0297, r27
			bankStates[BANK_0].adjustedEndAddress=chunkSize;								// move temp to end
    1dc8:	20 93 90 02 	sts	0x0290, r18
    1dcc:	30 93 91 02 	sts	0x0291, r19
    1dd0:	40 93 92 02 	sts	0x0292, r20
    1dd4:	50 93 93 02 	sts	0x0293, r21
    1dd8:	0a c0       	rjmp	.+20     	; 0x1dee <UpdateAdjustedSampleAddresses+0x19e>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_0].backwardsPlayback==true)			// Play direction accordingly.
    1dda:	80 91 80 02 	lds	r24, 0x0280
    1dde:	81 30       	cpi	r24, 0x01	; 1
    1de0:	19 f4       	brne	.+6      	; 0x1de8 <UpdateAdjustedSampleAddresses+0x198>
			{
				bankStates[BANK_0].sampleDirection=false;
    1de2:	10 92 81 02 	sts	0x0281, r1
    1de6:	03 c0       	rjmp	.+6      	; 0x1dee <UpdateAdjustedSampleAddresses+0x19e>
			}
			else
			{
				bankStates[BANK_0].sampleDirection=true;
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	80 93 81 02 	sts	0x0281, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].endAddress)	// Start addy off the end of the scale?
    1dee:	20 91 94 02 	lds	r18, 0x0294
    1df2:	30 91 95 02 	lds	r19, 0x0295
    1df6:	40 91 96 02 	lds	r20, 0x0296
    1dfa:	50 91 97 02 	lds	r21, 0x0297
    1dfe:	80 91 88 02 	lds	r24, 0x0288
    1e02:	90 91 89 02 	lds	r25, 0x0289
    1e06:	a0 91 8a 02 	lds	r26, 0x028A
    1e0a:	b0 91 8b 02 	lds	r27, 0x028B
    1e0e:	82 17       	cp	r24, r18
    1e10:	93 07       	cpc	r25, r19
    1e12:	a4 07       	cpc	r26, r20
    1e14:	b5 07       	cpc	r27, r21
    1e16:	e0 f4       	brcc	.+56     	; 0x1e50 <UpdateAdjustedSampleAddresses+0x200>
		{
			bankStates[BANK_0].adjustedStartAddress=(bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1e18:	80 91 94 02 	lds	r24, 0x0294
    1e1c:	90 91 95 02 	lds	r25, 0x0295
    1e20:	a0 91 96 02 	lds	r26, 0x0296
    1e24:	b0 91 97 02 	lds	r27, 0x0297
    1e28:	20 91 88 02 	lds	r18, 0x0288
    1e2c:	30 91 89 02 	lds	r19, 0x0289
    1e30:	40 91 8a 02 	lds	r20, 0x028A
    1e34:	50 91 8b 02 	lds	r21, 0x028B
    1e38:	82 1b       	sub	r24, r18
    1e3a:	93 0b       	sbc	r25, r19
    1e3c:	a4 0b       	sbc	r26, r20
    1e3e:	b5 0b       	sbc	r27, r21
    1e40:	80 93 94 02 	sts	0x0294, r24
    1e44:	90 93 95 02 	sts	0x0295, r25
    1e48:	a0 93 96 02 	sts	0x0296, r26
    1e4c:	b0 93 97 02 	sts	0x0297, r27
		}
		if(bankStates[BANK_0].adjustedEndAddress>bankStates[BANK_0].endAddress)
    1e50:	20 91 90 02 	lds	r18, 0x0290
    1e54:	30 91 91 02 	lds	r19, 0x0291
    1e58:	40 91 92 02 	lds	r20, 0x0292
    1e5c:	50 91 93 02 	lds	r21, 0x0293
    1e60:	80 91 88 02 	lds	r24, 0x0288
    1e64:	90 91 89 02 	lds	r25, 0x0289
    1e68:	a0 91 8a 02 	lds	r26, 0x028A
    1e6c:	b0 91 8b 02 	lds	r27, 0x028B
    1e70:	82 17       	cp	r24, r18
    1e72:	93 07       	cpc	r25, r19
    1e74:	a4 07       	cpc	r26, r20
    1e76:	b5 07       	cpc	r27, r21
    1e78:	08 f0       	brcs	.+2      	; 0x1e7c <UpdateAdjustedSampleAddresses+0x22c>
    1e7a:	44 c0       	rjmp	.+136    	; 0x1f04 <UpdateAdjustedSampleAddresses+0x2b4>
		{
			bankStates[BANK_0].adjustedEndAddress=(bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].endAddress)+BANK_0_START_ADDRESS;	// Wrap it around.
    1e7c:	80 91 90 02 	lds	r24, 0x0290
    1e80:	90 91 91 02 	lds	r25, 0x0291
    1e84:	a0 91 92 02 	lds	r26, 0x0292
    1e88:	b0 91 93 02 	lds	r27, 0x0293
    1e8c:	20 91 88 02 	lds	r18, 0x0288
    1e90:	30 91 89 02 	lds	r19, 0x0289
    1e94:	40 91 8a 02 	lds	r20, 0x028A
    1e98:	50 91 8b 02 	lds	r21, 0x028B
    1e9c:	82 1b       	sub	r24, r18
    1e9e:	93 0b       	sbc	r25, r19
    1ea0:	a4 0b       	sbc	r26, r20
    1ea2:	b5 0b       	sbc	r27, r21
    1ea4:	80 93 90 02 	sts	0x0290, r24
    1ea8:	90 93 91 02 	sts	0x0291, r25
    1eac:	a0 93 92 02 	sts	0x0292, r26
    1eb0:	b0 93 93 02 	sts	0x0293, r27

			if(bankStates[BANK_0].adjustedEndAddress==bankStates[BANK_0].adjustedStartAddress)	// Did we wrap a full sized sample?
    1eb4:	20 91 90 02 	lds	r18, 0x0290
    1eb8:	30 91 91 02 	lds	r19, 0x0291
    1ebc:	40 91 92 02 	lds	r20, 0x0292
    1ec0:	50 91 93 02 	lds	r21, 0x0293
    1ec4:	80 91 94 02 	lds	r24, 0x0294
    1ec8:	90 91 95 02 	lds	r25, 0x0295
    1ecc:	a0 91 96 02 	lds	r26, 0x0296
    1ed0:	b0 91 97 02 	lds	r27, 0x0297
    1ed4:	28 17       	cp	r18, r24
    1ed6:	39 07       	cpc	r19, r25
    1ed8:	4a 07       	cpc	r20, r26
    1eda:	5b 07       	cpc	r21, r27
    1edc:	99 f4       	brne	.+38     	; 0x1f04 <UpdateAdjustedSampleAddresses+0x2b4>
			{
				bankStates[BANK_0].adjustedEndAddress--;			// Trim it down so we don't have the start and end address equal.
    1ede:	80 91 90 02 	lds	r24, 0x0290
    1ee2:	90 91 91 02 	lds	r25, 0x0291
    1ee6:	a0 91 92 02 	lds	r26, 0x0292
    1eea:	b0 91 93 02 	lds	r27, 0x0293
    1eee:	01 97       	sbiw	r24, 0x01	; 1
    1ef0:	a1 09       	sbc	r26, r1
    1ef2:	b1 09       	sbc	r27, r1
    1ef4:	80 93 90 02 	sts	0x0290, r24
    1ef8:	90 93 91 02 	sts	0x0291, r25
    1efc:	a0 93 92 02 	sts	0x0292, r26
    1f00:	b0 93 93 02 	sts	0x0293, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_0].adjustedStartAddress>bankStates[BANK_0].adjustedEndAddress)	// Are we wrapping around the end?
    1f04:	20 91 94 02 	lds	r18, 0x0294
    1f08:	30 91 95 02 	lds	r19, 0x0295
    1f0c:	40 91 96 02 	lds	r20, 0x0296
    1f10:	50 91 97 02 	lds	r21, 0x0297
    1f14:	80 91 90 02 	lds	r24, 0x0290
    1f18:	90 91 91 02 	lds	r25, 0x0291
    1f1c:	a0 91 92 02 	lds	r26, 0x0292
    1f20:	b0 91 93 02 	lds	r27, 0x0293
    1f24:	82 17       	cp	r24, r18
    1f26:	93 07       	cpc	r25, r19
    1f28:	a4 07       	cpc	r26, r20
    1f2a:	b5 07       	cpc	r27, r21
    1f2c:	08 f0       	brcs	.+2      	; 0x1f30 <UpdateAdjustedSampleAddresses+0x2e0>
    1f2e:	5a c0       	rjmp	.+180    	; 0x1fe4 <UpdateAdjustedSampleAddresses+0x394>
		{
			if((bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)&&(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    1f30:	20 91 9b 02 	lds	r18, 0x029B
    1f34:	30 91 9c 02 	lds	r19, 0x029C
    1f38:	40 91 9d 02 	lds	r20, 0x029D
    1f3c:	50 91 9e 02 	lds	r21, 0x029E
    1f40:	80 91 94 02 	lds	r24, 0x0294
    1f44:	90 91 95 02 	lds	r25, 0x0295
    1f48:	a0 91 96 02 	lds	r26, 0x0296
    1f4c:	b0 91 97 02 	lds	r27, 0x0297
    1f50:	28 17       	cp	r18, r24
    1f52:	39 07       	cpc	r19, r25
    1f54:	4a 07       	cpc	r20, r26
    1f56:	5b 07       	cpc	r21, r27
    1f58:	08 f0       	brcs	.+2      	; 0x1f5c <UpdateAdjustedSampleAddresses+0x30c>
    1f5a:	94 c2       	rjmp	.+1320   	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
    1f5c:	20 91 9b 02 	lds	r18, 0x029B
    1f60:	30 91 9c 02 	lds	r19, 0x029C
    1f64:	40 91 9d 02 	lds	r20, 0x029D
    1f68:	50 91 9e 02 	lds	r21, 0x029E
    1f6c:	80 91 90 02 	lds	r24, 0x0290
    1f70:	90 91 91 02 	lds	r25, 0x0291
    1f74:	a0 91 92 02 	lds	r26, 0x0292
    1f78:	b0 91 93 02 	lds	r27, 0x0293
    1f7c:	82 17       	cp	r24, r18
    1f7e:	93 07       	cpc	r25, r19
    1f80:	a4 07       	cpc	r26, r20
    1f82:	b5 07       	cpc	r27, r21
    1f84:	08 f0       	brcs	.+2      	; 0x1f88 <UpdateAdjustedSampleAddresses+0x338>
    1f86:	7e c2       	rjmp	.+1276   	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_0].adjustedStartAddress-bankStates[BANK_0].currentAddress)>=(bankStates[BANK_0].currentAddress-bankStates[BANK_0].adjustedEndAddress))	// Closer to the start?	
    1f88:	20 91 94 02 	lds	r18, 0x0294
    1f8c:	30 91 95 02 	lds	r19, 0x0295
    1f90:	40 91 96 02 	lds	r20, 0x0296
    1f94:	50 91 97 02 	lds	r21, 0x0297
    1f98:	a0 90 9b 02 	lds	r10, 0x029B
    1f9c:	b0 90 9c 02 	lds	r11, 0x029C
    1fa0:	c0 90 9d 02 	lds	r12, 0x029D
    1fa4:	d0 90 9e 02 	lds	r13, 0x029E
    1fa8:	80 91 9b 02 	lds	r24, 0x029B
    1fac:	90 91 9c 02 	lds	r25, 0x029C
    1fb0:	a0 91 9d 02 	lds	r26, 0x029D
    1fb4:	b0 91 9e 02 	lds	r27, 0x029E
    1fb8:	e0 90 90 02 	lds	r14, 0x0290
    1fbc:	f0 90 91 02 	lds	r15, 0x0291
    1fc0:	00 91 92 02 	lds	r16, 0x0292
    1fc4:	10 91 93 02 	lds	r17, 0x0293
    1fc8:	2a 19       	sub	r18, r10
    1fca:	3b 09       	sbc	r19, r11
    1fcc:	4c 09       	sbc	r20, r12
    1fce:	5d 09       	sbc	r21, r13
    1fd0:	8e 19       	sub	r24, r14
    1fd2:	9f 09       	sbc	r25, r15
    1fd4:	a0 0b       	sbc	r26, r16
    1fd6:	b1 0b       	sbc	r27, r17
    1fd8:	28 17       	cp	r18, r24
    1fda:	39 07       	cpc	r19, r25
    1fdc:	4a 07       	cpc	r20, r26
    1fde:	5b 07       	cpc	r21, r27
    1fe0:	a8 f1       	brcs	.+106    	; 0x204c <UpdateAdjustedSampleAddresses+0x3fc>
    1fe2:	15 c0       	rjmp	.+42     	; 0x200e <UpdateAdjustedSampleAddresses+0x3be>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is before the end).
		{
			if(bankStates[BANK_0].currentAddress<bankStates[BANK_0].adjustedStartAddress)
    1fe4:	20 91 9b 02 	lds	r18, 0x029B
    1fe8:	30 91 9c 02 	lds	r19, 0x029C
    1fec:	40 91 9d 02 	lds	r20, 0x029D
    1ff0:	50 91 9e 02 	lds	r21, 0x029E
    1ff4:	80 91 94 02 	lds	r24, 0x0294
    1ff8:	90 91 95 02 	lds	r25, 0x0295
    1ffc:	a0 91 96 02 	lds	r26, 0x0296
    2000:	b0 91 97 02 	lds	r27, 0x0297
    2004:	28 17       	cp	r18, r24
    2006:	39 07       	cpc	r19, r25
    2008:	4a 07       	cpc	r20, r26
    200a:	5b 07       	cpc	r21, r27
    200c:	48 f4       	brcc	.+18     	; 0x2020 <UpdateAdjustedSampleAddresses+0x3d0>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    200e:	80 91 94 02 	lds	r24, 0x0294
    2012:	90 91 95 02 	lds	r25, 0x0295
    2016:	a0 91 96 02 	lds	r26, 0x0296
    201a:	b0 91 97 02 	lds	r27, 0x0297
    201e:	1e c0       	rjmp	.+60     	; 0x205c <UpdateAdjustedSampleAddresses+0x40c>
			}				
			else if(bankStates[BANK_0].currentAddress>bankStates[BANK_0].adjustedEndAddress)
    2020:	20 91 9b 02 	lds	r18, 0x029B
    2024:	30 91 9c 02 	lds	r19, 0x029C
    2028:	40 91 9d 02 	lds	r20, 0x029D
    202c:	50 91 9e 02 	lds	r21, 0x029E
    2030:	80 91 90 02 	lds	r24, 0x0290
    2034:	90 91 91 02 	lds	r25, 0x0291
    2038:	a0 91 92 02 	lds	r26, 0x0292
    203c:	b0 91 93 02 	lds	r27, 0x0293
    2040:	82 17       	cp	r24, r18
    2042:	93 07       	cpc	r25, r19
    2044:	a4 07       	cpc	r26, r20
    2046:	b5 07       	cpc	r27, r21
    2048:	08 f0       	brcs	.+2      	; 0x204c <UpdateAdjustedSampleAddresses+0x3fc>
    204a:	1c c2       	rjmp	.+1080   	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_0].currentAddress=bankStates[BANK_0].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    204c:	80 91 90 02 	lds	r24, 0x0290
    2050:	90 91 91 02 	lds	r25, 0x0291
    2054:	a0 91 92 02 	lds	r26, 0x0292
    2058:	b0 91 93 02 	lds	r27, 0x0293
    205c:	80 93 9b 02 	sts	0x029B, r24
    2060:	90 93 9c 02 	sts	0x029C, r25
    2064:	a0 93 9d 02 	sts	0x029D, r26
    2068:	b0 93 9e 02 	sts	0x029E, r27
    206c:	0b c2       	rjmp	.+1046   	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
		}
	}	
	else	// Otherwise assume banks grow down and do the same procedure for bank 1.
	{
		// @@@ BANK 1 grows down, so the signs and comments here may not always agree.
		chunkSize=(((BANK_1_START_ADDRESS-bankStates[BANK_1].endAddress)<<3)/256);		// Get chunk size of current sample (shift this up to get some more resolution)
    206e:	80 91 aa 02 	lds	r24, 0x02AA
    2072:	90 91 ab 02 	lds	r25, 0x02AB
    2076:	a0 91 ac 02 	lds	r26, 0x02AC
    207a:	b0 91 ad 02 	lds	r27, 0x02AD
    207e:	2f ef       	ldi	r18, 0xFF	; 255
    2080:	e2 2e       	mov	r14, r18
    2082:	2f ef       	ldi	r18, 0xFF	; 255
    2084:	f2 2e       	mov	r15, r18
    2086:	27 e0       	ldi	r18, 0x07	; 7
    2088:	02 2f       	mov	r16, r18
    208a:	11 2d       	mov	r17, r1
    208c:	57 01       	movw	r10, r14
    208e:	68 01       	movw	r12, r16
    2090:	a8 1a       	sub	r10, r24
    2092:	b9 0a       	sbc	r11, r25
    2094:	ca 0a       	sbc	r12, r26
    2096:	db 0a       	sbc	r13, r27
    2098:	83 e0       	ldi	r24, 0x03	; 3
    209a:	aa 0c       	add	r10, r10
    209c:	bb 1c       	adc	r11, r11
    209e:	cc 1c       	adc	r12, r12
    20a0:	dd 1c       	adc	r13, r13
    20a2:	8a 95       	dec	r24
    20a4:	d1 f7       	brne	.-12     	; 0x209a <UpdateAdjustedSampleAddresses+0x44a>
    20a6:	ab 2c       	mov	r10, r11
    20a8:	bc 2c       	mov	r11, r12
    20aa:	cd 2c       	mov	r12, r13
    20ac:	dd 24       	eor	r13, r13

		// Move the start and end points.  Removed fixed decimal points.

		bankStates[BANK_1].adjustedStartAddress=(BANK_1_START_ADDRESS-((chunkSize*(bankStates[BANK_1].sampleStartOffset+(unsigned int)bankStates[BANK_1].sampleWindowOffset))>>3));			// multiply chunk size times desired offset (calculated from start and window offsets) and add it to the start address to get new working start address.
    20ae:	60 91 ba 02 	lds	r22, 0x02BA
    20b2:	20 91 bc 02 	lds	r18, 0x02BC
    20b6:	70 e0       	ldi	r23, 0x00	; 0
    20b8:	62 0f       	add	r22, r18
    20ba:	71 1d       	adc	r23, r1
    20bc:	80 e0       	ldi	r24, 0x00	; 0
    20be:	90 e0       	ldi	r25, 0x00	; 0
    20c0:	a6 01       	movw	r20, r12
    20c2:	95 01       	movw	r18, r10
    20c4:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    20c8:	a3 e0       	ldi	r26, 0x03	; 3
    20ca:	96 95       	lsr	r25
    20cc:	87 95       	ror	r24
    20ce:	77 95       	ror	r23
    20d0:	67 95       	ror	r22
    20d2:	aa 95       	dec	r26
    20d4:	d1 f7       	brne	.-12     	; 0x20ca <UpdateAdjustedSampleAddresses+0x47a>
    20d6:	e6 1a       	sub	r14, r22
    20d8:	f7 0a       	sbc	r15, r23
    20da:	08 0b       	sbc	r16, r24
    20dc:	19 0b       	sbc	r17, r25
    20de:	e0 92 b6 02 	sts	0x02B6, r14
    20e2:	f0 92 b7 02 	sts	0x02B7, r15
    20e6:	00 93 b8 02 	sts	0x02B8, r16
    20ea:	10 93 b9 02 	sts	0x02B9, r17
		bankStates[BANK_1].adjustedEndAddress=(bankStates[BANK_1].endAddress+((chunkSize*bankStates[BANK_1].sampleEndOffset)>>3))-((chunkSize*bankStates[BANK_1].sampleWindowOffset)>>3);	// Same idea as above, except move end back and push forward with window.
    20ee:	20 90 aa 02 	lds	r2, 0x02AA
    20f2:	30 90 ab 02 	lds	r3, 0x02AB
    20f6:	40 90 ac 02 	lds	r4, 0x02AC
    20fa:	50 90 ad 02 	lds	r5, 0x02AD
    20fe:	20 91 bb 02 	lds	r18, 0x02BB
    2102:	60 90 bc 02 	lds	r6, 0x02BC
    2106:	30 e0       	ldi	r19, 0x00	; 0
    2108:	40 e0       	ldi	r20, 0x00	; 0
    210a:	50 e0       	ldi	r21, 0x00	; 0
    210c:	c6 01       	movw	r24, r12
    210e:	b5 01       	movw	r22, r10
    2110:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    2114:	7b 01       	movw	r14, r22
    2116:	8c 01       	movw	r16, r24
    2118:	f3 e0       	ldi	r31, 0x03	; 3
    211a:	16 95       	lsr	r17
    211c:	07 95       	ror	r16
    211e:	f7 94       	ror	r15
    2120:	e7 94       	ror	r14
    2122:	fa 95       	dec	r31
    2124:	d1 f7       	brne	.-12     	; 0x211a <UpdateAdjustedSampleAddresses+0x4ca>
    2126:	e2 0c       	add	r14, r2
    2128:	f3 1c       	adc	r15, r3
    212a:	04 1d       	adc	r16, r4
    212c:	15 1d       	adc	r17, r5
    212e:	77 24       	eor	r7, r7
    2130:	88 24       	eor	r8, r8
    2132:	99 24       	eor	r9, r9
    2134:	c6 01       	movw	r24, r12
    2136:	b5 01       	movw	r22, r10
    2138:	a4 01       	movw	r20, r8
    213a:	93 01       	movw	r18, r6
    213c:	0e 94 05 29 	call	0x520a	; 0x520a <__mulsi3>
    2140:	e3 e0       	ldi	r30, 0x03	; 3
    2142:	96 95       	lsr	r25
    2144:	87 95       	ror	r24
    2146:	77 95       	ror	r23
    2148:	67 95       	ror	r22
    214a:	ea 95       	dec	r30
    214c:	d1 f7       	brne	.-12     	; 0x2142 <UpdateAdjustedSampleAddresses+0x4f2>
    214e:	e6 1a       	sub	r14, r22
    2150:	f7 0a       	sbc	r15, r23
    2152:	08 0b       	sbc	r16, r24
    2154:	19 0b       	sbc	r17, r25
    2156:	e0 92 b2 02 	sts	0x02B2, r14
    215a:	f0 92 b3 02 	sts	0x02B3, r15
    215e:	00 93 b4 02 	sts	0x02B4, r16
    2162:	10 93 b5 02 	sts	0x02B5, r17

		// Now check to see whether the end is before or after the start, and if that's changed, reverse the sample.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Reverse playback direction on this bank and flip the start and end addresses.
    2166:	20 91 b6 02 	lds	r18, 0x02B6
    216a:	30 91 b7 02 	lds	r19, 0x02B7
    216e:	40 91 b8 02 	lds	r20, 0x02B8
    2172:	50 91 b9 02 	lds	r21, 0x02B9
    2176:	80 91 b2 02 	lds	r24, 0x02B2
    217a:	90 91 b3 02 	lds	r25, 0x02B3
    217e:	a0 91 b4 02 	lds	r26, 0x02B4
    2182:	b0 91 b5 02 	lds	r27, 0x02B5
    2186:	28 17       	cp	r18, r24
    2188:	39 07       	cpc	r19, r25
    218a:	4a 07       	cpc	r20, r26
    218c:	5b 07       	cpc	r21, r27
    218e:	50 f5       	brcc	.+84     	; 0x21e4 <UpdateAdjustedSampleAddresses+0x594>
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Toggle the direction our sample is playing.
    2190:	80 91 a2 02 	lds	r24, 0x02A2
    2194:	81 30       	cpi	r24, 0x01	; 1
    2196:	19 f4       	brne	.+6      	; 0x219e <UpdateAdjustedSampleAddresses+0x54e>
			{
				bankStates[BANK_1].sampleDirection=true;
    2198:	80 93 a3 02 	sts	0x02A3, r24
    219c:	02 c0       	rjmp	.+4      	; 0x21a2 <UpdateAdjustedSampleAddresses+0x552>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=false;
    219e:	10 92 a3 02 	sts	0x02A3, r1
			}			

			chunkSize=bankStates[BANK_1].adjustedStartAddress;								// move start to temp
    21a2:	20 91 b6 02 	lds	r18, 0x02B6
    21a6:	30 91 b7 02 	lds	r19, 0x02B7
    21aa:	40 91 b8 02 	lds	r20, 0x02B8
    21ae:	50 91 b9 02 	lds	r21, 0x02B9
			bankStates[BANK_1].adjustedStartAddress=bankStates[BANK_1].adjustedEndAddress;	// move end to start
    21b2:	80 91 b2 02 	lds	r24, 0x02B2
    21b6:	90 91 b3 02 	lds	r25, 0x02B3
    21ba:	a0 91 b4 02 	lds	r26, 0x02B4
    21be:	b0 91 b5 02 	lds	r27, 0x02B5
    21c2:	80 93 b6 02 	sts	0x02B6, r24
    21c6:	90 93 b7 02 	sts	0x02B7, r25
    21ca:	a0 93 b8 02 	sts	0x02B8, r26
    21ce:	b0 93 b9 02 	sts	0x02B9, r27
			bankStates[BANK_1].adjustedEndAddress=chunkSize;								// move temp to end
    21d2:	20 93 b2 02 	sts	0x02B2, r18
    21d6:	30 93 b3 02 	sts	0x02B3, r19
    21da:	40 93 b4 02 	sts	0x02B4, r20
    21de:	50 93 b5 02 	sts	0x02B5, r21
    21e2:	0a c0       	rjmp	.+20     	; 0x21f8 <UpdateAdjustedSampleAddresses+0x5a8>
		}
		else	// Sample is in a "normal" orientation.  Make sure it plays right.
		{
			if(bankStates[BANK_1].backwardsPlayback==true)			// Play direction accordingly.
    21e4:	80 91 a2 02 	lds	r24, 0x02A2
    21e8:	81 30       	cpi	r24, 0x01	; 1
    21ea:	19 f4       	brne	.+6      	; 0x21f2 <UpdateAdjustedSampleAddresses+0x5a2>
			{
				bankStates[BANK_1].sampleDirection=false;
    21ec:	10 92 a3 02 	sts	0x02A3, r1
    21f0:	03 c0       	rjmp	.+6      	; 0x21f8 <UpdateAdjustedSampleAddresses+0x5a8>
			}
			else
			{
				bankStates[BANK_1].sampleDirection=true;
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	80 93 a3 02 	sts	0x02A3, r24
			}						
		}		

		// Now test to see if adjusted sample endpoints are outside of the absolute sample address space, and wrap if they are:
		
		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].endAddress)	// Start addy off the end of the scale?
    21f8:	20 91 b6 02 	lds	r18, 0x02B6
    21fc:	30 91 b7 02 	lds	r19, 0x02B7
    2200:	40 91 b8 02 	lds	r20, 0x02B8
    2204:	50 91 b9 02 	lds	r21, 0x02B9
    2208:	80 91 aa 02 	lds	r24, 0x02AA
    220c:	90 91 ab 02 	lds	r25, 0x02AB
    2210:	a0 91 ac 02 	lds	r26, 0x02AC
    2214:	b0 91 ad 02 	lds	r27, 0x02AD
    2218:	28 17       	cp	r18, r24
    221a:	39 07       	cpc	r19, r25
    221c:	4a 07       	cpc	r20, r26
    221e:	5b 07       	cpc	r21, r27
    2220:	00 f5       	brcc	.+64     	; 0x2262 <UpdateAdjustedSampleAddresses+0x612>
		{
			bankStates[BANK_1].adjustedStartAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedStartAddress);	// Wrap it around.
    2222:	80 91 b6 02 	lds	r24, 0x02B6
    2226:	90 91 b7 02 	lds	r25, 0x02B7
    222a:	a0 91 b8 02 	lds	r26, 0x02B8
    222e:	b0 91 b9 02 	lds	r27, 0x02B9
    2232:	20 91 aa 02 	lds	r18, 0x02AA
    2236:	30 91 ab 02 	lds	r19, 0x02AB
    223a:	40 91 ac 02 	lds	r20, 0x02AC
    223e:	50 91 ad 02 	lds	r21, 0x02AD
    2242:	81 50       	subi	r24, 0x01	; 1
    2244:	90 40       	sbci	r25, 0x00	; 0
    2246:	a8 4f       	sbci	r26, 0xF8	; 248
    2248:	bf 4f       	sbci	r27, 0xFF	; 255
    224a:	82 1b       	sub	r24, r18
    224c:	93 0b       	sbc	r25, r19
    224e:	a4 0b       	sbc	r26, r20
    2250:	b5 0b       	sbc	r27, r21
    2252:	80 93 b6 02 	sts	0x02B6, r24
    2256:	90 93 b7 02 	sts	0x02B7, r25
    225a:	a0 93 b8 02 	sts	0x02B8, r26
    225e:	b0 93 b9 02 	sts	0x02B9, r27
		}
		if(bankStates[BANK_1].adjustedEndAddress<bankStates[BANK_1].endAddress)
    2262:	20 91 b2 02 	lds	r18, 0x02B2
    2266:	30 91 b3 02 	lds	r19, 0x02B3
    226a:	40 91 b4 02 	lds	r20, 0x02B4
    226e:	50 91 b5 02 	lds	r21, 0x02B5
    2272:	80 91 aa 02 	lds	r24, 0x02AA
    2276:	90 91 ab 02 	lds	r25, 0x02AB
    227a:	a0 91 ac 02 	lds	r26, 0x02AC
    227e:	b0 91 ad 02 	lds	r27, 0x02AD
    2282:	28 17       	cp	r18, r24
    2284:	39 07       	cpc	r19, r25
    2286:	4a 07       	cpc	r20, r26
    2288:	5b 07       	cpc	r21, r27
    228a:	08 f0       	brcs	.+2      	; 0x228e <UpdateAdjustedSampleAddresses+0x63e>
    228c:	48 c0       	rjmp	.+144    	; 0x231e <UpdateAdjustedSampleAddresses+0x6ce>
		{
			bankStates[BANK_1].adjustedEndAddress=BANK_1_START_ADDRESS-(bankStates[BANK_1].endAddress-bankStates[BANK_1].adjustedEndAddress);	// Wrap it around.
    228e:	80 91 b2 02 	lds	r24, 0x02B2
    2292:	90 91 b3 02 	lds	r25, 0x02B3
    2296:	a0 91 b4 02 	lds	r26, 0x02B4
    229a:	b0 91 b5 02 	lds	r27, 0x02B5
    229e:	20 91 aa 02 	lds	r18, 0x02AA
    22a2:	30 91 ab 02 	lds	r19, 0x02AB
    22a6:	40 91 ac 02 	lds	r20, 0x02AC
    22aa:	50 91 ad 02 	lds	r21, 0x02AD
    22ae:	81 50       	subi	r24, 0x01	; 1
    22b0:	90 40       	sbci	r25, 0x00	; 0
    22b2:	a8 4f       	sbci	r26, 0xF8	; 248
    22b4:	bf 4f       	sbci	r27, 0xFF	; 255
    22b6:	82 1b       	sub	r24, r18
    22b8:	93 0b       	sbc	r25, r19
    22ba:	a4 0b       	sbc	r26, r20
    22bc:	b5 0b       	sbc	r27, r21
    22be:	80 93 b2 02 	sts	0x02B2, r24
    22c2:	90 93 b3 02 	sts	0x02B3, r25
    22c6:	a0 93 b4 02 	sts	0x02B4, r26
    22ca:	b0 93 b5 02 	sts	0x02B5, r27

			if(bankStates[BANK_1].adjustedEndAddress==bankStates[BANK_1].adjustedStartAddress)	// Did we wrap a full sized sample?
    22ce:	20 91 b2 02 	lds	r18, 0x02B2
    22d2:	30 91 b3 02 	lds	r19, 0x02B3
    22d6:	40 91 b4 02 	lds	r20, 0x02B4
    22da:	50 91 b5 02 	lds	r21, 0x02B5
    22de:	80 91 b6 02 	lds	r24, 0x02B6
    22e2:	90 91 b7 02 	lds	r25, 0x02B7
    22e6:	a0 91 b8 02 	lds	r26, 0x02B8
    22ea:	b0 91 b9 02 	lds	r27, 0x02B9
    22ee:	28 17       	cp	r18, r24
    22f0:	39 07       	cpc	r19, r25
    22f2:	4a 07       	cpc	r20, r26
    22f4:	5b 07       	cpc	r21, r27
    22f6:	99 f4       	brne	.+38     	; 0x231e <UpdateAdjustedSampleAddresses+0x6ce>
			{
				bankStates[BANK_1].adjustedEndAddress++;			// Trim it down so we don't have the start and end address equal.
    22f8:	80 91 b2 02 	lds	r24, 0x02B2
    22fc:	90 91 b3 02 	lds	r25, 0x02B3
    2300:	a0 91 b4 02 	lds	r26, 0x02B4
    2304:	b0 91 b5 02 	lds	r27, 0x02B5
    2308:	01 96       	adiw	r24, 0x01	; 1
    230a:	a1 1d       	adc	r26, r1
    230c:	b1 1d       	adc	r27, r1
    230e:	80 93 b2 02 	sts	0x02B2, r24
    2312:	90 93 b3 02 	sts	0x02B3, r25
    2316:	a0 93 b4 02 	sts	0x02B4, r26
    231a:	b0 93 b5 02 	sts	0x02B5, r27
			}
		}

		// Finally, if the current sample address pointer is not in between the start and end points anymore, put it there.

		if(bankStates[BANK_1].adjustedStartAddress<bankStates[BANK_1].adjustedEndAddress)	// Are we wrapping around the end?
    231e:	20 91 b6 02 	lds	r18, 0x02B6
    2322:	30 91 b7 02 	lds	r19, 0x02B7
    2326:	40 91 b8 02 	lds	r20, 0x02B8
    232a:	50 91 b9 02 	lds	r21, 0x02B9
    232e:	80 91 b2 02 	lds	r24, 0x02B2
    2332:	90 91 b3 02 	lds	r25, 0x02B3
    2336:	a0 91 b4 02 	lds	r26, 0x02B4
    233a:	b0 91 b5 02 	lds	r27, 0x02B5
    233e:	28 17       	cp	r18, r24
    2340:	39 07       	cpc	r19, r25
    2342:	4a 07       	cpc	r20, r26
    2344:	5b 07       	cpc	r21, r27
    2346:	08 f0       	brcs	.+2      	; 0x234a <UpdateAdjustedSampleAddresses+0x6fa>
    2348:	5a c0       	rjmp	.+180    	; 0x23fe <UpdateAdjustedSampleAddresses+0x7ae>
		{
			if((bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)&&(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress))	// If so, is our current pointer out of bounds?
    234a:	20 91 bd 02 	lds	r18, 0x02BD
    234e:	30 91 be 02 	lds	r19, 0x02BE
    2352:	40 91 bf 02 	lds	r20, 0x02BF
    2356:	50 91 c0 02 	lds	r21, 0x02C0
    235a:	80 91 b6 02 	lds	r24, 0x02B6
    235e:	90 91 b7 02 	lds	r25, 0x02B7
    2362:	a0 91 b8 02 	lds	r26, 0x02B8
    2366:	b0 91 b9 02 	lds	r27, 0x02B9
    236a:	82 17       	cp	r24, r18
    236c:	93 07       	cpc	r25, r19
    236e:	a4 07       	cpc	r26, r20
    2370:	b5 07       	cpc	r27, r21
    2372:	08 f0       	brcs	.+2      	; 0x2376 <UpdateAdjustedSampleAddresses+0x726>
    2374:	87 c0       	rjmp	.+270    	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
    2376:	20 91 bd 02 	lds	r18, 0x02BD
    237a:	30 91 be 02 	lds	r19, 0x02BE
    237e:	40 91 bf 02 	lds	r20, 0x02BF
    2382:	50 91 c0 02 	lds	r21, 0x02C0
    2386:	80 91 b2 02 	lds	r24, 0x02B2
    238a:	90 91 b3 02 	lds	r25, 0x02B3
    238e:	a0 91 b4 02 	lds	r26, 0x02B4
    2392:	b0 91 b5 02 	lds	r27, 0x02B5
    2396:	28 17       	cp	r18, r24
    2398:	39 07       	cpc	r19, r25
    239a:	4a 07       	cpc	r20, r26
    239c:	5b 07       	cpc	r21, r27
    239e:	08 f0       	brcs	.+2      	; 0x23a2 <UpdateAdjustedSampleAddresses+0x752>
    23a0:	71 c0       	rjmp	.+226    	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
			{
				if((bankStates[BANK_1].currentAddress-bankStates[BANK_1].adjustedStartAddress)<=(bankStates[BANK_1].adjustedEndAddress-bankStates[BANK_1].currentAddress))	// Closer to the start?	
    23a2:	20 91 bd 02 	lds	r18, 0x02BD
    23a6:	30 91 be 02 	lds	r19, 0x02BE
    23aa:	40 91 bf 02 	lds	r20, 0x02BF
    23ae:	50 91 c0 02 	lds	r21, 0x02C0
    23b2:	a0 90 b6 02 	lds	r10, 0x02B6
    23b6:	b0 90 b7 02 	lds	r11, 0x02B7
    23ba:	c0 90 b8 02 	lds	r12, 0x02B8
    23be:	d0 90 b9 02 	lds	r13, 0x02B9
    23c2:	80 91 b2 02 	lds	r24, 0x02B2
    23c6:	90 91 b3 02 	lds	r25, 0x02B3
    23ca:	a0 91 b4 02 	lds	r26, 0x02B4
    23ce:	b0 91 b5 02 	lds	r27, 0x02B5
    23d2:	e0 90 bd 02 	lds	r14, 0x02BD
    23d6:	f0 90 be 02 	lds	r15, 0x02BE
    23da:	00 91 bf 02 	lds	r16, 0x02BF
    23de:	10 91 c0 02 	lds	r17, 0x02C0
    23e2:	2a 19       	sub	r18, r10
    23e4:	3b 09       	sbc	r19, r11
    23e6:	4c 09       	sbc	r20, r12
    23e8:	5d 09       	sbc	r21, r13
    23ea:	8e 19       	sub	r24, r14
    23ec:	9f 09       	sbc	r25, r15
    23ee:	a0 0b       	sbc	r26, r16
    23f0:	b1 0b       	sbc	r27, r17
    23f2:	82 17       	cp	r24, r18
    23f4:	93 07       	cpc	r25, r19
    23f6:	a4 07       	cpc	r26, r20
    23f8:	b5 07       	cpc	r27, r21
    23fa:	a0 f1       	brcs	.+104    	; 0x2464 <UpdateAdjustedSampleAddresses+0x814>
    23fc:	15 c0       	rjmp	.+42     	; 0x2428 <UpdateAdjustedSampleAddresses+0x7d8>
				}
			}
		}
		else	// Not wrapping around the end (this means the start addy is xxx the end).
		{
			if(bankStates[BANK_1].currentAddress>bankStates[BANK_1].adjustedStartAddress)
    23fe:	20 91 bd 02 	lds	r18, 0x02BD
    2402:	30 91 be 02 	lds	r19, 0x02BE
    2406:	40 91 bf 02 	lds	r20, 0x02BF
    240a:	50 91 c0 02 	lds	r21, 0x02C0
    240e:	80 91 b6 02 	lds	r24, 0x02B6
    2412:	90 91 b7 02 	lds	r25, 0x02B7
    2416:	a0 91 b8 02 	lds	r26, 0x02B8
    241a:	b0 91 b9 02 	lds	r27, 0x02B9
    241e:	82 17       	cp	r24, r18
    2420:	93 07       	cpc	r25, r19
    2422:	a4 07       	cpc	r26, r20
    2424:	b5 07       	cpc	r27, r21
    2426:	48 f4       	brcc	.+18     	; 0x243a <UpdateAdjustedSampleAddresses+0x7ea>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedStartAddress;		// If we moved the beginning of the sample up past our current pointer, bring our current memory location up to the start.
    2428:	80 91 b6 02 	lds	r24, 0x02B6
    242c:	90 91 b7 02 	lds	r25, 0x02B7
    2430:	a0 91 b8 02 	lds	r26, 0x02B8
    2434:	b0 91 b9 02 	lds	r27, 0x02B9
    2438:	1d c0       	rjmp	.+58     	; 0x2474 <UpdateAdjustedSampleAddresses+0x824>
			}				
			else if(bankStates[BANK_1].currentAddress<bankStates[BANK_1].adjustedEndAddress)
    243a:	20 91 bd 02 	lds	r18, 0x02BD
    243e:	30 91 be 02 	lds	r19, 0x02BE
    2442:	40 91 bf 02 	lds	r20, 0x02BF
    2446:	50 91 c0 02 	lds	r21, 0x02C0
    244a:	80 91 b2 02 	lds	r24, 0x02B2
    244e:	90 91 b3 02 	lds	r25, 0x02B3
    2452:	a0 91 b4 02 	lds	r26, 0x02B4
    2456:	b0 91 b5 02 	lds	r27, 0x02B5
    245a:	28 17       	cp	r18, r24
    245c:	39 07       	cpc	r19, r25
    245e:	4a 07       	cpc	r20, r26
    2460:	5b 07       	cpc	r21, r27
    2462:	80 f4       	brcc	.+32     	; 0x2484 <UpdateAdjustedSampleAddresses+0x834>
			{
				bankStates[BANK_1].currentAddress=bankStates[BANK_1].adjustedEndAddress;		// If we moved the beginning of the sample down past our current end pointer, bring our current memory location down to the end.
    2464:	80 91 b2 02 	lds	r24, 0x02B2
    2468:	90 91 b3 02 	lds	r25, 0x02B3
    246c:	a0 91 b4 02 	lds	r26, 0x02B4
    2470:	b0 91 b5 02 	lds	r27, 0x02B5
    2474:	80 93 bd 02 	sts	0x02BD, r24
    2478:	90 93 be 02 	sts	0x02BE, r25
    247c:	a0 93 bf 02 	sts	0x02BF, r26
    2480:	b0 93 c0 02 	sts	0x02C0, r27
			}
		}
	}

	SREG=sreg;		// Restore interrupts.
    2484:	e9 81       	ldd	r30, Y+1	; 0x01
    2486:	ef bf       	out	0x3f, r30	; 63
}
    2488:	0f 90       	pop	r0
    248a:	cf 91       	pop	r28
    248c:	df 91       	pop	r29
    248e:	1f 91       	pop	r17
    2490:	0f 91       	pop	r16
    2492:	ff 90       	pop	r15
    2494:	ef 90       	pop	r14
    2496:	df 90       	pop	r13
    2498:	cf 90       	pop	r12
    249a:	bf 90       	pop	r11
    249c:	af 90       	pop	r10
    249e:	9f 90       	pop	r9
    24a0:	8f 90       	pop	r8
    24a2:	7f 90       	pop	r7
    24a4:	6f 90       	pop	r6
    24a6:	5f 90       	pop	r5
    24a8:	4f 90       	pop	r4
    24aa:	3f 90       	pop	r3
    24ac:	2f 90       	pop	r2
    24ae:	08 95       	ret

000024b0 <BlinkLeds>:

static void BlinkLeds(unsigned int theMask)
// Sets up the mask of leds to blink and their blink rate.
// NOTE:  All leds made to blink will blink synchronously at the rate last set.  This saves us from having 8 separate software clocks.
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
    24b0:	a8 2f       	mov	r26, r24
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    24b2:	80 91 3a 01 	lds	r24, 0x013A
    24b6:	68 2f       	mov	r22, r24
    24b8:	70 e0       	ldi	r23, 0x00	; 0
    24ba:	50 91 39 01 	lds	r21, 0x0139
    24be:	20 e0       	ldi	r18, 0x00	; 0
    24c0:	30 e0       	ldi	r19, 0x00	; 0
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    24c2:	e1 e0       	ldi	r30, 0x01	; 1
    24c4:	f0 e0       	ldi	r31, 0x00	; 0
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
	{
		if(ledBlinkMask&(1<<i))		// ...and if a LED was supposed to be blinking...
    24c6:	cb 01       	movw	r24, r22
    24c8:	02 2e       	mov	r0, r18
    24ca:	02 c0       	rjmp	.+4      	; 0x24d0 <BlinkLeds+0x20>
    24cc:	95 95       	asr	r25
    24ce:	87 95       	ror	r24
    24d0:	0a 94       	dec	r0
    24d2:	e2 f7       	brpl	.-8      	; 0x24cc <BlinkLeds+0x1c>
    24d4:	80 ff       	sbrs	r24, 0
    24d6:	09 c0       	rjmp	.+18     	; 0x24ea <BlinkLeds+0x3a>
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
    24d8:	cf 01       	movw	r24, r30
    24da:	02 2e       	mov	r0, r18
    24dc:	02 c0       	rjmp	.+4      	; 0x24e2 <BlinkLeds+0x32>
    24de:	88 0f       	add	r24, r24
    24e0:	99 1f       	adc	r25, r25
    24e2:	0a 94       	dec	r0
    24e4:	e2 f7       	brpl	.-8      	; 0x24de <BlinkLeds+0x2e>
    24e6:	80 95       	com	r24
    24e8:	58 23       	and	r21, r24
    24ea:	2f 5f       	subi	r18, 0xFF	; 255
    24ec:	3f 4f       	sbci	r19, 0xFF	; 255
// NOTE:  When an LED is told to stop blinking it will revert to OFF, even if the LED was ON when we told it to blink.  I can live with this.
{
	unsigned char
		i;

	for(i=0; i<NUM_LEDS; i++)		// Go through all the LEDs...
    24ee:	28 30       	cpi	r18, 0x08	; 8
    24f0:	31 05       	cpc	r19, r1
    24f2:	49 f7       	brne	.-46     	; 0x24c6 <BlinkLeds+0x16>
    24f4:	50 93 39 01 	sts	0x0139, r21
		{
			ledOnOffMask&=~(1<<i);		// ...turn it off.  This makes sure any blinking LEDs don't stop their blinks in the 'on' state.
		}
	}

	ledBlinkMask=theMask;				// Now assign new leds to blink.
    24f8:	a0 93 3a 01 	sts	0x013A, r26
	SetTimer(TIMER_BLINK,BLINK_TIME);	// And the time that they will all blink to.
    24fc:	82 e0       	ldi	r24, 0x02	; 2
    24fe:	68 e9       	ldi	r22, 0x98	; 152
    2500:	70 e0       	ldi	r23, 0x00	; 0
    2502:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
}
    2506:	08 95       	ret

00002508 <main>:
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

int main(void)
// Initialize this mess.
{
    2508:	cf 92       	push	r12
    250a:	df 92       	push	r13
    250c:	ef 92       	push	r14
    250e:	ff 92       	push	r15
    2510:	1f 93       	push	r17
    2512:	cf 93       	push	r28
    2514:	df 93       	push	r29
	PRR=0xFF;			// Power off everything, let the initialization routines turn on modules you need.
    2516:	9f ef       	ldi	r25, 0xFF	; 255
    2518:	90 93 64 00 	sts	0x0064, r25
	MCUCR&=~(1<<PUD);	// Globally enable pullups (we need them for the encoder)
    251c:	85 b7       	in	r24, 0x35	; 53
    251e:	8f 7e       	andi	r24, 0xEF	; 239
    2520:	85 bf       	out	0x35, r24	; 53

	// Set the DDRs for all RAM, DAC, latch related pins here.  Any non-SFR related IO pin gets initialized here.  ADC and anything else with a specific init routine will be intialized separately.

	DDRC=0xEF;			// PORTC is the switch latch OE and direct address line outputs which must be initialized here.  PC4 is the interrupt for the bank1 clock.  Pins PC5-PC7 are unused now, so pull them low.
    2522:	8f ee       	ldi	r24, 0xEF	; 239
    2524:	87 b9       	out	0x07, r24	; 7
	PORTC=0x08;			// 0, 1, 2 are the address lines, pull them low.  Pull bit 3 high to tristate the switch latch.  Pull unused pins low.
    2526:	88 e0       	ldi	r24, 0x08	; 8
    2528:	88 b9       	out	0x08, r24	; 8

	DDRD=0x80;			// PORTD is the UART (midi) the Flash interface (SPI) the ACLK input and the LED latch enable.  Make UART and Flash input for now and the rest make appropriate (LE is an output) .
    252a:	20 e8       	ldi	r18, 0x80	; 128
    252c:	2a b9       	out	0x0a, r18	; 10
	PORTD=0x00;			// Drive the LE for the LEDs low and leave the rest floating.
    252e:	1b b8       	out	0x0b, r1	; 11

//	PORTA=0xC6;			// OE and WE high, latch enables low, no pullup on AIN0, pullups on the encoder pins.
	PORTA=0x06;			// OE and WE high, latch enables low, no pullup on AIN0, encoder now has hardware pullups.
    2530:	86 e0       	ldi	r24, 0x06	; 6
    2532:	82 b9       	out	0x02, r24	; 2
	DDRA=0x3E;			// PORTA is digital outputs (latch strobe lines and OE/WE lines PA1-5), the analog in (on PA0) and the encoder inputs (PA6 and PA7)
    2534:	8e e3       	ldi	r24, 0x3E	; 62
    2536:	81 b9       	out	0x01, r24	; 1

	DDRB=0xFF;			// Latch port to OP.
    2538:	94 b9       	out	0x04, r25	; 4
	LATCH_PORT=128;		// And set it equal to midscale for the DAC.
    253a:	25 b9       	out	0x05, r18	; 5

	// Set the DAC to midscale to avoid pops on the first interrupt call.
	PORTA|=(Om_RAM_OE);		// Tristate the RAM.
    253c:	12 9a       	sbi	0x02, 2	; 2
	LATCH_DDR=0xFF;			// Turn the data bus around (AVR's data port to outputs)
    253e:	94 b9       	out	0x04, r25	; 4
	PORTA|=(Om_DAC_LA);		// Strobe dac latch enable high -- this puts the dacByte on the 373's output...
    2540:	15 9a       	sbi	0x02, 5	; 2
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.
    2542:	15 98       	cbi	0x02, 5	; 2
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void InitSwitches(void)
{
	SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Start debounce counter.
    2544:	81 e0       	ldi	r24, 0x01	; 1
    2546:	66 e2       	ldi	r22, 0x26	; 38
    2548:	70 e0       	ldi	r23, 0x00	; 0
    254a:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
#define	ENC_POS_C	0xC0
#define	ENC_POS_D	0x80

static void InitEncoder(void)
{
	encoderState=(PINA&Im_ENCODER_PINS);	// Initial encoder state read from pins directly.
    254e:	80 b1       	in	r24, 0x00	; 0
    2550:	80 7c       	andi	r24, 0xC0	; 192
    2552:	80 93 41 01 	sts	0x0141, r24
	encoderValue=0;							// zero our relative position.
    2556:	10 92 42 01 	sts	0x0142, r1
	}
}

static void InitLeds(void)
{
	ledOnOffMask=0;
    255a:	10 92 39 01 	sts	0x0139, r1
	ledBlinkMask=0;
    255e:	10 92 3a 01 	sts	0x013A, r1
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2562:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2564:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    2566:	15 b8       	out	0x05, r1	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    2568:	1f ef       	ldi	r17, 0xFF	; 255
    256a:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    256c:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    256e:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    2570:	8f bf       	out	0x3f, r24	; 63
	PORTA&=~(Om_DAC_LA);	// ...And keeps it there.

	InitSwitches();
	InitEncoder();
	InitLeds();
	InitMidi();					// Get the MIDI stack initialized.
    2572:	0e 94 22 21 	call	0x4244	; 0x4244 <InitMidi>
	InitUart0();
    2576:	0e 94 84 20 	call	0x4108	; 0x4108 <InitUart0>
*/

static void InitAdc(void)
// Note, we don't set up the Adc to trigger on anything right away.
{
	PRR&=~(1<<PRADC);		// Turn the ADC power on (clear the bit to power on).
    257a:	80 91 64 00 	lds	r24, 0x0064
    257e:	8e 7f       	andi	r24, 0xFE	; 254
    2580:	80 93 64 00 	sts	0x0064, r24
	ADMUX = 0x60; 			// 0110 0000.  AVCC is the reference (w/ ext cap), left justify the result, start with ADC0 as the channel.  The ADC always wants to see a cap at AREF if the internal references or VCC are used.
    2584:	80 e6       	ldi	r24, 0x60	; 96
    2586:	80 93 7c 00 	sts	0x007C, r24
	DIDR0 = 0x01;			// Disable the digital input for ADC0.
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	80 93 7e 00 	sts	0x007E, r24
	ADCSRA = 0x95;			// 1001 0101 (prescaler to 32 = ~48kHz sample rate, (64 = 24kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
    2590:	85 e9       	ldi	r24, 0x95	; 149
    2592:	80 93 7a 00 	sts	0x007A, r24
//	ADCSRA = 0x96;			// 1001 0110 (prescaler to 64 = ~24kHz sample rate, (32 = 48kHz).  Enable the ADC, no autotrigger or interrupts. (For ex: at 8MHz sysclk and 1/64, ADC clock = 125kHz, normal conversion ~= 10kHz (13 samples per conversion).  According to the datasheet, to get max resolution from the converter, the ADC clock must be between 50 and 200kHz.)
	ADCSRA |= (1<<ADSC);  	// Start the first conversion to initialize the ADC.
    2596:	80 91 7a 00 	lds	r24, 0x007A
    259a:	80 64       	ori	r24, 0x40	; 64
    259c:	80 93 7a 00 	sts	0x007A, r24
// NOTE:  w/ 16-bit system ticks we can only time 214 seconds at this rate.

// With /64 those times are 0.8192 mSecs and 53 seconds.  We did this for the sake of not missing encoder states.

{
	PRR&=~(1<<PRTIM0);	// Turn the TMR0 power on.
    25a0:	80 91 64 00 	lds	r24, 0x0064
    25a4:	8f 7d       	andi	r24, 0xDF	; 223
    25a6:	80 93 64 00 	sts	0x0064, r24
	TIMSK0=0x00;		// Disable all Timer 0 associated interrupts.
    25aa:	10 92 6e 00 	sts	0x006E, r1
	TCCR0A=0;			// Normal Ports.
    25ae:	14 bc       	out	0x24, r1	; 36
	TCNT0=0;			// Initialize the counter to 0.
    25b0:	16 bc       	out	0x26, r1	; 38
	TIFR0=0xFF;			// Clear the interrupt flags by writing ones.
    25b2:	15 bb       	out	0x15, r17	; 21
	systemTicks=0;
    25b4:	10 92 c2 02 	sts	0x02C2, r1
    25b8:	10 92 c1 02 	sts	0x02C1, r1
//	TCCR0B=0x04;		// Start the timer in Normal mode, prescaler at 1/256
	TCCR0B=0x03;		// Start the timer in Normal mode, prescaler at 1/64
    25bc:	83 e0       	ldi	r24, 0x03	; 3
    25be:	85 bd       	out	0x25, r24	; 37

static void InitSampleClock(void)
// Get TMR1 ready to generate some equal temperament, or as equal as I can do (for MIDI)
// Or just turn it on so we can use the Input Capture pin to generate interrupts for the external clock (for the loop sampler).
{
	PRR&=~(1<<PRTIM1);	// Turn the TMR1 power on.
    25c0:	80 91 64 00 	lds	r24, 0x0064
    25c4:	87 7f       	andi	r24, 0xF7	; 247
    25c6:	80 93 64 00 	sts	0x0064, r24
	TIMSK1=0x00;		// Disable all Timer 1 associated interrupts.
    25ca:	10 92 6f 00 	sts	0x006F, r1
	OCR1A=65535;		// Set the compare register arbitrarily
    25ce:	8f ef       	ldi	r24, 0xFF	; 255
    25d0:	9f ef       	ldi	r25, 0xFF	; 255
    25d2:	90 93 89 00 	sts	0x0089, r25
    25d6:	80 93 88 00 	sts	0x0088, r24
	OCR1B=65535;		// Set the compare register arbitrarily
    25da:	90 93 8b 00 	sts	0x008B, r25
    25de:	80 93 8a 00 	sts	0x008A, r24
	TCCR1A=0;			// Normal Ports.
    25e2:	10 92 80 00 	sts	0x0080, r1
	TCCR1B=0;			// Stop the timer.
    25e6:	10 92 81 00 	sts	0x0081, r1
	TCNT1=0;			// Initialize the counter to 0.
    25ea:	10 92 85 00 	sts	0x0085, r1
    25ee:	10 92 84 00 	sts	0x0084, r1
	TIFR1=0xFF;			// Clear the interrupt flags by writing ones.
    25f2:	16 bb       	out	0x16, r17	; 22
//	InitUart1();
	InitAdc();
	InitSoftclock();
//	InitRandom();
	InitSampleClock();	// Turns on TIMER1 and gets it ready to generate interrupts.
	externalFlashEnabled=InitFlashStorage();	// Tries to initialize any external flash, and if it's there, lets the program know.
    25f4:	0e 94 2c 28 	call	0x5058	; 0x5058 <InitFlashStorage>
    25f8:	80 93 3c 01 	sts	0x013C, r24

	newKeys=0;
    25fc:	10 92 3e 01 	sts	0x013E, r1
	keyState=0;
    2600:	10 92 3d 01 	sts	0x013D, r1

	sei();						// THE ONLY PLACE we should globally enable interrupts in this code.
    2604:	78 94       	sei
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    2606:	8e e1       	ldi	r24, 0x1E	; 30
    2608:	94 e1       	ldi	r25, 0x14	; 20
    260a:	90 93 7c 02 	sts	0x027C, r25
    260e:	80 93 7b 02 	sts	0x027B, r24
	subState=SS_0;
    2612:	10 92 3f 01 	sts	0x013F, r1
				{
					ledOnOffMask|=(1<<i);
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    2616:	c1 e0       	ldi	r28, 0x01	; 1
    2618:	d0 e0       	ldi	r29, 0x00	; 0
static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    261a:	f5 eb       	ldi	r31, 0xB5	; 181
    261c:	cf 2e       	mov	r12, r31
    261e:	f5 e9       	ldi	r31, 0x95	; 149
    2620:	df 2e       	mov	r13, r31
    2622:	fa ea       	ldi	r31, 0xAA	; 170
    2624:	ef 2e       	mov	r14, r31
    2626:	f0 e2       	ldi	r31, 0x20	; 32
    2628:	ff 2e       	mov	r15, r31
	static unsigned char
		lastKeyState;
	unsigned char
		sreg;

	if(CheckTimer(TIMER_DEBOUNCE))	// Time to read switches?
    262a:	81 e0       	ldi	r24, 0x01	; 1
    262c:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    2630:	88 23       	and	r24, r24
    2632:	99 f0       	breq	.+38     	; 0x265a <main+0x152>
	{
		// Pause interrupts, monkey with datalatch, get switch data, resume interrupts.
		sreg=SREG;
    2634:	9f b7       	in	r25, 0x3f	; 63
		cli();						// Store sreg, pause interrupts.
    2636:	f8 94       	cli
		LATCH_PORT=0xFF;			// @@@ Pullups here seem to make the bus turn around less of a mess.
    2638:	15 b9       	out	0x05, r17	; 5
		LATCH_DDR=0x00;				// Turn the data bus around (AVR's data port to inputs)
    263a:	14 b8       	out	0x04, r1	; 4
		PORTC&=~Om_SWITCH_LA;		// Enable switch latch outputs (OE Low)
    263c:	43 98       	cbi	0x08, 3	; 8
		asm volatile("nop"::);		// Needed for bus turnaround time (2 nops)
    263e:	00 00       	nop
		asm volatile("nop"::);
    2640:	00 00       	nop
		keyState=~LATCH_INPUT;		// Grab new keystate and invert so that pressed keys are 1s
    2642:	83 b1       	in	r24, 0x03	; 3
    2644:	80 95       	com	r24
    2646:	80 93 3d 01 	sts	0x013D, r24
		PORTC|=Om_SWITCH_LA;		// Tristate switch latch outputs (OE high)
    264a:	43 9a       	sbi	0x08, 3	; 8
		LATCH_DDR=0xFF;				// Turn the data bus rightside up (AVR gots the bus)
    264c:	14 b9       	out	0x04, r17	; 4
		SREG=sreg;					// Stop tying up interrupts		
    264e:	9f bf       	out	0x3f, r25	; 63
		SetTimer(TIMER_DEBOUNCE,(SECOND/32));	// Reset timer (allow time for bus to turn around)		
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	66 e2       	ldi	r22, 0x26	; 38
    2654:	70 e0       	ldi	r23, 0x00	; 0
    2656:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
	}

	newKeys=((keyState^lastKeyState)&(keyState));		// Flag the keys which have been pressed since the last test.
    265a:	90 91 3d 01 	lds	r25, 0x013D
    265e:	80 91 1e 01 	lds	r24, 0x011E
    2662:	80 95       	com	r24
    2664:	89 23       	and	r24, r25
    2666:	80 93 3e 01 	sts	0x013E, r24
	lastKeyState=keyState;								// And store this keystate as old news.
    266a:	90 93 1e 01 	sts	0x011E, r25
	static unsigned char
		lastEncoderState=0;
	static unsigned int
		lastEncTime=0;
		
	if(systemTicks!=lastEncTime)		// Read encoder once every system tick (around 0.8 mSecs)
    266e:	20 91 c1 02 	lds	r18, 0x02C1
    2672:	30 91 c2 02 	lds	r19, 0x02C2
    2676:	80 91 1f 01 	lds	r24, 0x011F
    267a:	90 91 20 01 	lds	r25, 0x0120
    267e:	28 17       	cp	r18, r24
    2680:	39 07       	cpc	r19, r25
    2682:	b1 f1       	breq	.+108    	; 0x26f0 <main+0x1e8>
	{
		lastEncTime=systemTicks;					// update last read time.
    2684:	80 91 c1 02 	lds	r24, 0x02C1
    2688:	90 91 c2 02 	lds	r25, 0x02C2
    268c:	90 93 20 01 	sts	0x0120, r25
    2690:	80 93 1f 01 	sts	0x011F, r24
		encoderState=(PINA&Im_ENCODER_PINS);		// Read encoder state from pins directly.
    2694:	90 b1       	in	r25, 0x00	; 0
    2696:	90 7c       	andi	r25, 0xC0	; 192
    2698:	90 93 41 01 	sts	0x0141, r25

		if(encoderState!=lastEncoderState)	// Has the encoder value changed?  If so, update the value if the change looks valid.
    269c:	80 91 21 01 	lds	r24, 0x0121
    26a0:	98 17       	cp	r25, r24
    26a2:	31 f1       	breq	.+76     	; 0x26f0 <main+0x1e8>
		{
			if(encoderState==ENC_POS_A)
    26a4:	99 23       	and	r25, r25
    26a6:	29 f4       	brne	.+10     	; 0x26b2 <main+0x1aa>
			{
				if(lastEncoderState==ENC_POS_D)
    26a8:	80 38       	cpi	r24, 0x80	; 128
    26aa:	a9 f0       	breq	.+42     	; 0x26d6 <main+0x1ce>
				{
					encoderValue++;
				}
				else if(lastEncoderState==ENC_POS_B)
    26ac:	80 34       	cpi	r24, 0x40	; 64
    26ae:	f1 f4       	brne	.+60     	; 0x26ec <main+0x1e4>
    26b0:	18 c0       	rjmp	.+48     	; 0x26e2 <main+0x1da>
				{
					encoderValue--;
				}
			}		
			else if(encoderState==ENC_POS_B)
    26b2:	90 34       	cpi	r25, 0x40	; 64
    26b4:	29 f4       	brne	.+10     	; 0x26c0 <main+0x1b8>
			{
				if(lastEncoderState==ENC_POS_A)
    26b6:	88 23       	and	r24, r24
    26b8:	71 f0       	breq	.+28     	; 0x26d6 <main+0x1ce>
				{
					encoderValue++;
				}
				else if(lastEncoderState==ENC_POS_C)
    26ba:	80 3c       	cpi	r24, 0xC0	; 192
    26bc:	b9 f4       	brne	.+46     	; 0x26ec <main+0x1e4>
    26be:	11 c0       	rjmp	.+34     	; 0x26e2 <main+0x1da>
				{
					encoderValue--;
				}
			}		
			else if(encoderState==ENC_POS_C)
    26c0:	90 3c       	cpi	r25, 0xC0	; 192
    26c2:	29 f4       	brne	.+10     	; 0x26ce <main+0x1c6>
			{
				if(lastEncoderState==ENC_POS_B)
    26c4:	80 34       	cpi	r24, 0x40	; 64
    26c6:	39 f0       	breq	.+14     	; 0x26d6 <main+0x1ce>
				{
					encoderValue++;
				}
				else if(lastEncoderState==ENC_POS_D)
    26c8:	80 38       	cpi	r24, 0x80	; 128
    26ca:	81 f4       	brne	.+32     	; 0x26ec <main+0x1e4>
    26cc:	0a c0       	rjmp	.+20     	; 0x26e2 <main+0x1da>
				{
					encoderValue--;
				}
			}		
			else if(encoderState==ENC_POS_D)
    26ce:	90 38       	cpi	r25, 0x80	; 128
    26d0:	69 f4       	brne	.+26     	; 0x26ec <main+0x1e4>
			{
				if(lastEncoderState==ENC_POS_C)
    26d2:	80 3c       	cpi	r24, 0xC0	; 192
    26d4:	21 f4       	brne	.+8      	; 0x26de <main+0x1d6>
				{
					encoderValue++;
    26d6:	80 91 42 01 	lds	r24, 0x0142
    26da:	8f 5f       	subi	r24, 0xFF	; 255
    26dc:	05 c0       	rjmp	.+10     	; 0x26e8 <main+0x1e0>
				}
				else if(lastEncoderState==ENC_POS_A)
    26de:	88 23       	and	r24, r24
    26e0:	29 f4       	brne	.+10     	; 0x26ec <main+0x1e4>
				{
					encoderValue--;
    26e2:	80 91 42 01 	lds	r24, 0x0142
    26e6:	81 50       	subi	r24, 0x01	; 1
    26e8:	80 93 42 01 	sts	0x0142, r24
				}
			}		

			lastEncoderState=encoderState;		// Keep this state around to evaluate the next one.
    26ec:	90 93 21 01 	sts	0x0121, r25
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void HandleSoftclock(void)
{
	if(TIFR0&(1<<TOV0))		// Got a timer overflow flag?
    26f0:	a8 9b       	sbis	0x15, 0	; 21
    26f2:	0a c0       	rjmp	.+20     	; 0x2708 <main+0x200>
	{
		TIFR0 |= (1<<TOV0);		// Reset the flag (by writing a one).
    26f4:	a8 9a       	sbi	0x15, 0	; 21
		systemTicks++;			// Increment the system ticks.
    26f6:	80 91 c1 02 	lds	r24, 0x02C1
    26fa:	90 91 c2 02 	lds	r25, 0x02C2
    26fe:	01 96       	adiw	r24, 0x01	; 1
    2700:	90 93 c2 02 	sts	0x02C2, r25
    2704:	80 93 c1 02 	sts	0x02C1, r24
	static bool
		toggle;				// Flip flop for blinking.
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
    2708:	80 91 3a 01 	lds	r24, 0x013A
    270c:	88 23       	and	r24, r24
    270e:	09 f4       	brne	.+2      	; 0x2712 <main+0x20a>
    2710:	4a c0       	rjmp	.+148    	; 0x27a6 <main+0x29e>
    2712:	82 e0       	ldi	r24, 0x02	; 2
    2714:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    2718:	88 23       	and	r24, r24
    271a:	09 f4       	brne	.+2      	; 0x271e <main+0x216>
    271c:	44 c0       	rjmp	.+136    	; 0x27a6 <main+0x29e>
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    271e:	80 91 3a 01 	lds	r24, 0x013A
    2722:	68 2f       	mov	r22, r24
    2724:	70 e0       	ldi	r23, 0x00	; 0
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    2726:	e0 91 23 01 	lds	r30, 0x0123
    272a:	50 91 39 01 	lds	r21, 0x0139
    272e:	20 e0       	ldi	r18, 0x00	; 0
    2730:	30 e0       	ldi	r19, 0x00	; 0

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
		{
			if(ledBlinkMask&(1<<i))
    2732:	cb 01       	movw	r24, r22
    2734:	02 2e       	mov	r0, r18
    2736:	02 c0       	rjmp	.+4      	; 0x273c <main+0x234>
    2738:	95 95       	asr	r25
    273a:	87 95       	ror	r24
    273c:	0a 94       	dec	r0
    273e:	e2 f7       	brpl	.-8      	; 0x2738 <main+0x230>
    2740:	80 ff       	sbrs	r24, 0
    2742:	14 c0       	rjmp	.+40     	; 0x276c <main+0x264>
			{
				if(toggle)			// Flip flop the LEDs we're blinking every time the timer runs out.
    2744:	ee 23       	and	r30, r30
    2746:	49 f0       	breq	.+18     	; 0x275a <main+0x252>
				{
					ledOnOffMask|=(1<<i);
    2748:	ce 01       	movw	r24, r28
    274a:	02 2e       	mov	r0, r18
    274c:	02 c0       	rjmp	.+4      	; 0x2752 <main+0x24a>
    274e:	88 0f       	add	r24, r24
    2750:	99 1f       	adc	r25, r25
    2752:	0a 94       	dec	r0
    2754:	e2 f7       	brpl	.-8      	; 0x274e <main+0x246>
    2756:	58 2b       	or	r21, r24
    2758:	09 c0       	rjmp	.+18     	; 0x276c <main+0x264>
				}
				else
				{
					ledOnOffMask&=~(1<<i);
    275a:	ce 01       	movw	r24, r28
    275c:	02 2e       	mov	r0, r18
    275e:	02 c0       	rjmp	.+4      	; 0x2764 <main+0x25c>
    2760:	88 0f       	add	r24, r24
    2762:	99 1f       	adc	r25, r25
    2764:	0a 94       	dec	r0
    2766:	e2 f7       	brpl	.-8      	; 0x2760 <main+0x258>
    2768:	80 95       	com	r24
    276a:	58 23       	and	r21, r24
    276c:	2f 5f       	subi	r18, 0xFF	; 255
    276e:	3f 4f       	sbci	r19, 0xFF	; 255
	static unsigned char
		lastLedMask=0;		// Used to see if LEDs have been changed during a given loop.

	if(ledBlinkMask&&CheckTimer(TIMER_BLINK))		// Are we blinking and is it time to toggle?
	{
		for(i=0; i<NUM_LEDS; i++)	// Which LEDs are we blinking?
    2770:	28 30       	cpi	r18, 0x08	; 8
    2772:	31 05       	cpc	r19, r1
    2774:	f1 f6       	brne	.-68     	; 0x2732 <main+0x22a>
    2776:	50 93 39 01 	sts	0x0139, r21
					ledOnOffMask&=~(1<<i);
				}
			}
		}

		toggle=(!toggle);						// flip the sign of the led for next time.
    277a:	10 92 23 01 	sts	0x0123, r1
    277e:	ee 23       	and	r30, r30
    2780:	19 f4       	brne	.+6      	; 0x2788 <main+0x280>
    2782:	81 e0       	ldi	r24, 0x01	; 1
    2784:	80 93 23 01 	sts	0x0123, r24
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
    2788:	82 e0       	ldi	r24, 0x02	; 2
    278a:	68 e9       	ldi	r22, 0x98	; 152
    278c:	70 e0       	ldi	r23, 0x00	; 0
    278e:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
    2792:	80 91 39 01 	lds	r24, 0x0139
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    2796:	9f b7       	in	r25, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    2798:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    279a:	85 b9       	out	0x05, r24	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    279c:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    279e:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    27a0:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    27a2:	9f bf       	out	0x3f, r25	; 63
    27a4:	0f c0       	rjmp	.+30     	; 0x27c4 <main+0x2bc>

		toggle=(!toggle);						// flip the sign of the led for next time.
		SetTimer(TIMER_BLINK,BLINK_TIME);		// And wait until next time.
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
    27a6:	90 91 39 01 	lds	r25, 0x0139
    27aa:	80 91 22 01 	lds	r24, 0x0122
    27ae:	89 17       	cp	r24, r25
    27b0:	49 f0       	breq	.+18     	; 0x27c4 <main+0x2bc>
// This and the switch handler are the only mainline (non IRQ) code that messes with the databus.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state
    27b2:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Clear global interrupts (so we don't get an audio interrupt while messing with OE and WE)
    27b4:	f8 94       	cli

	LATCH_PORT=theMask;				// Put passed data onto bus.
    27b6:	95 b9       	out	0x05, r25	; 5
	LATCH_DDR=0xFF;					// Make sure the bus is an output.
    27b8:	14 b9       	out	0x04, r17	; 4
	PORTD|=(Om_LED_LA);				// Strobe it to the latch output...
    27ba:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD&=~(Om_LED_LA);			// ...Keep it there.
    27bc:	5f 98       	cbi	0x0b, 7	; 11

	SREG=sreg;						// Restore interrupts.
    27be:	8f bf       	out	0x3f, r24	; 63
		WriteLedLatch(ledOnOffMask);			// Send the LED value to the latch.
	}
	else if(lastLedMask!=ledOnOffMask) // If we're not blinking, but our LEDs have been instructed to change...
	{
		WriteLedLatch(ledOnOffMask);	// ...send the LED value to the latch.
		lastLedMask=ledOnOffMask;		// And mark it as sent.
    27c0:	90 93 22 01 	sts	0x0122, r25
//--------------------------------------
//--------------------------------------

static unsigned long GetRandomLongInt(void)
{
	random31=(random31<<1);		// Update Random Number.  Roll the random number left.
    27c4:	80 91 00 01 	lds	r24, 0x0100
    27c8:	90 91 01 01 	lds	r25, 0x0101
    27cc:	a0 91 02 01 	lds	r26, 0x0102
    27d0:	b0 91 03 01 	lds	r27, 0x0103
    27d4:	88 0f       	add	r24, r24
    27d6:	99 1f       	adc	r25, r25
    27d8:	aa 1f       	adc	r26, r26
    27da:	bb 1f       	adc	r27, r27
    27dc:	80 93 00 01 	sts	0x0100, r24
    27e0:	90 93 01 01 	sts	0x0101, r25
    27e4:	a0 93 02 01 	sts	0x0102, r26
    27e8:	b0 93 03 01 	sts	0x0103, r27
	if(random31 & 0x80000000)	// If bit31 set, do the xor.
    27ec:	b7 ff       	sbrs	r27, 7
    27ee:	0c c0       	rjmp	.+24     	; 0x2808 <main+0x300>
	{
		random31^=0x20AA95B5;	//xor magic number (taps)
    27f0:	8c 25       	eor	r24, r12
    27f2:	9d 25       	eor	r25, r13
    27f4:	ae 25       	eor	r26, r14
    27f6:	bf 25       	eor	r27, r15
    27f8:	80 93 00 01 	sts	0x0100, r24
    27fc:	90 93 01 01 	sts	0x0101, r25
    2800:	a0 93 02 01 	sts	0x0102, r26
    2804:	b0 93 03 01 	sts	0x0103, r27
		GetRandomLongInt();		// Keep random numbers rolling.

//daNextJump=random31;
//daNextJumpPrime=(keyState+systemTicks);

		if(Uart0GotByte())		// Handle receiving midi messages: Parse any bytes coming in over the UART into MIDI messages we can use.
    2808:	0e 94 7b 20 	call	0x40f6	; 0x40f6 <Uart0GotByte>
    280c:	88 23       	and	r24, r24
    280e:	21 f0       	breq	.+8      	; 0x2818 <main+0x310>
		{
			HandleIncomingMidiByte(Uart0GetByte());		// Deal with the UART message and put it in the incoming MIDI FIFO if relevant.
    2810:	0e 94 81 20 	call	0x4102	; 0x4102 <Uart0GetByte>
    2814:	0e 94 34 21 	call	0x4268	; 0x4268 <HandleIncomingMidiByte>
		}

		if(MidiTxBufferNotEmpty())			// Got something to say?
    2818:	0e 94 8d 22 	call	0x451a	; 0x451a <MidiTxBufferNotEmpty>
    281c:	88 23       	and	r24, r24
    281e:	41 f0       	breq	.+16     	; 0x2830 <main+0x328>
		{
			if(UCSR0A&(1<<UDRE0))			// UART0 ready to receive new data?
    2820:	80 91 c0 00 	lds	r24, 0x00C0
    2824:	85 ff       	sbrs	r24, 5
    2826:	04 c0       	rjmp	.+8      	; 0x2830 <main+0x328>
			{
				UDR0=PopOutgoingMidiByte();	// Get the next byte to send.
    2828:	0e 94 98 22 	call	0x4530	; 0x4530 <PopOutgoingMidiByte>
    282c:	80 93 c6 00 	sts	0x00C6, r24
			}				
		}

		State();				// Execute the current program state.
    2830:	e0 91 7b 02 	lds	r30, 0x027B
    2834:	f0 91 7c 02 	lds	r31, 0x027C
    2838:	09 95       	icall
    283a:	f7 ce       	rjmp	.-530    	; 0x262a <main+0x122>

0000283c <DoFruitcakeIntro>:
	}
}

static void DoFruitcakeIntro(void)
// Oh god why.
{
    283c:	1f 93       	push	r17
	static unsigned char
		i;
		
	if(subState==SS_0)
    283e:	10 91 3f 01 	lds	r17, 0x013F
    2842:	11 23       	and	r17, r17
    2844:	89 f4       	brne	.+34     	; 0x2868 <DoFruitcakeIntro+0x2c>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2846:	10 92 39 01 	sts	0x0139, r1
	BlinkLeds(0);		// Durrrr.....
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	90 e0       	ldi	r25, 0x00	; 0
    284e:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
		i;
		
	if(subState==SS_0)
	{
		KillLeds();
		i=0;
    2852:	10 92 24 01 	sts	0x0124, r1
		ledOnOffMask=0;
    2856:	10 92 39 01 	sts	0x0139, r1
		subState=SS_1;
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	80 93 3f 01 	sts	0x013F, r24
		SetTimer(TIMER_1,(SECOND/4));
    2860:	80 e0       	ldi	r24, 0x00	; 0
    2862:	61 e3       	ldi	r22, 0x31	; 49
    2864:	71 e0       	ldi	r23, 0x01	; 1
    2866:	6b c0       	rjmp	.+214    	; 0x293e <DoFruitcakeIntro+0x102>
	}
	else if(subState==SS_1)
    2868:	11 30       	cpi	r17, 0x01	; 1
    286a:	41 f4       	brne	.+16     	; 0x287c <DoFruitcakeIntro+0x40>
	{
		if(CheckTimer(TIMER_1))
    286c:	80 e0       	ldi	r24, 0x00	; 0
    286e:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    2872:	88 23       	and	r24, r24
    2874:	09 f4       	brne	.+2      	; 0x2878 <DoFruitcakeIntro+0x3c>
    2876:	9a c0       	rjmp	.+308    	; 0x29ac <DoFruitcakeIntro+0x170>
		{
			subState=SS_2;
    2878:	82 e0       	ldi	r24, 0x02	; 2
    287a:	80 c0       	rjmp	.+256    	; 0x297c <DoFruitcakeIntro+0x140>
		}
	}

	else if(subState==SS_2)
    287c:	12 30       	cpi	r17, 0x02	; 2
    287e:	09 f0       	breq	.+2      	; 0x2882 <DoFruitcakeIntro+0x46>
    2880:	4a c0       	rjmp	.+148    	; 0x2916 <DoFruitcakeIntro+0xda>
	{
		if(i<NUM_LEDS)
    2882:	80 91 24 01 	lds	r24, 0x0124
    2886:	88 30       	cpi	r24, 0x08	; 8
    2888:	f8 f4       	brcc	.+62     	; 0x28c8 <DoFruitcakeIntro+0x8c>
		{
			if(CheckTimer(TIMER_1))
    288a:	80 e0       	ldi	r24, 0x00	; 0
    288c:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    2890:	88 23       	and	r24, r24
    2892:	09 f4       	brne	.+2      	; 0x2896 <DoFruitcakeIntro+0x5a>
    2894:	8b c0       	rjmp	.+278    	; 0x29ac <DoFruitcakeIntro+0x170>
			{		
				ledOnOffMask|=(1<<i);
    2896:	81 e0       	ldi	r24, 0x01	; 1
    2898:	90 e0       	ldi	r25, 0x00	; 0
    289a:	00 90 24 01 	lds	r0, 0x0124
    289e:	02 c0       	rjmp	.+4      	; 0x28a4 <DoFruitcakeIntro+0x68>
    28a0:	88 0f       	add	r24, r24
    28a2:	99 1f       	adc	r25, r25
    28a4:	0a 94       	dec	r0
    28a6:	e2 f7       	brpl	.-8      	; 0x28a0 <DoFruitcakeIntro+0x64>
    28a8:	20 91 39 01 	lds	r18, 0x0139
    28ac:	28 2b       	or	r18, r24
    28ae:	20 93 39 01 	sts	0x0139, r18
				SetTimer(TIMER_1,(SECOND/20));		
    28b2:	80 e0       	ldi	r24, 0x00	; 0
    28b4:	6d e3       	ldi	r22, 0x3D	; 61
    28b6:	70 e0       	ldi	r23, 0x00	; 0
    28b8:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
				i++;
    28bc:	80 91 24 01 	lds	r24, 0x0124
    28c0:	8f 5f       	subi	r24, 0xFF	; 255
    28c2:	80 93 24 01 	sts	0x0124, r24
    28c6:	72 c0       	rjmp	.+228    	; 0x29ac <DoFruitcakeIntro+0x170>
			}
		}
		else
		{
			if(CheckTimer(TIMER_1))
    28c8:	80 e0       	ldi	r24, 0x00	; 0
    28ca:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    28ce:	88 23       	and	r24, r24
    28d0:	09 f4       	brne	.+2      	; 0x28d4 <DoFruitcakeIntro+0x98>
    28d2:	6c c0       	rjmp	.+216    	; 0x29ac <DoFruitcakeIntro+0x170>
			{
				SetTimer(TIMER_1,(SECOND/8));
    28d4:	80 e0       	ldi	r24, 0x00	; 0
    28d6:	68 e9       	ldi	r22, 0x98	; 152
    28d8:	70 e0       	ldi	r23, 0x00	; 0
    28da:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
				ledPwm=255;
    28de:	9f ef       	ldi	r25, 0xFF	; 255
    28e0:	90 93 3b 01 	sts	0x013B, r25
				// Grudgingly enable pwm hackery.

				PRR&=~(1<<PRTIM2);	// Turn the TMR2 power on.	
    28e4:	80 91 64 00 	lds	r24, 0x0064
    28e8:	8f 7b       	andi	r24, 0xBF	; 191
    28ea:	80 93 64 00 	sts	0x0064, r24

				TCCR2A=0x02;		// Normal ports, begin setting CTC mode.	
    28ee:	10 93 b0 00 	sts	0x00B0, r17
				TCCR2B=0x01;		// Finish setting CTC, prescaler to /1, turn clock on.
    28f2:	81 e0       	ldi	r24, 0x01	; 1
    28f4:	80 93 b1 00 	sts	0x00B1, r24
				TCNT2=0;			// Init counter reg
    28f8:	10 92 b2 00 	sts	0x00B2, r1
				OCR2A=128;			// Compare match interrupt when the counter gets to this number.
    28fc:	80 e8       	ldi	r24, 0x80	; 128
    28fe:	80 93 b3 00 	sts	0x00B3, r24
				TIFR2=0xFF;			// Writing ones clears the interrupt flags.
    2902:	97 bb       	out	0x17, r25	; 23
				TIMSK2=0x02;		// Enable the compare match interrupt.
    2904:	10 93 70 00 	sts	0x0070, r17

				PORTA|=(Om_RAM_OE|Om_RAM_WE);	// Disable reading and writing to RAM.
    2908:	82 b1       	in	r24, 0x02	; 2
    290a:	86 60       	ori	r24, 0x06	; 6
    290c:	82 b9       	out	0x02, r24	; 2
				LATCH_DDR=0xFF;					// Make sure the bus is an output.
    290e:	94 b9       	out	0x04, r25	; 4
				PORTD|=(Om_LED_LA);				// Make our led latch transparent....
    2910:	5f 9a       	sbi	0x0b, 7	; 11

				subState=SS_3;		
    2912:	83 e0       	ldi	r24, 0x03	; 3
    2914:	33 c0       	rjmp	.+102    	; 0x297c <DoFruitcakeIntro+0x140>
			}
		}
	}
	else if(subState==SS_3)
    2916:	13 30       	cpi	r17, 0x03	; 3
    2918:	a1 f5       	brne	.+104    	; 0x2982 <DoFruitcakeIntro+0x146>
	{		
		if(CheckTimer(TIMER_1))
    291a:	80 e0       	ldi	r24, 0x00	; 0
    291c:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    2920:	88 23       	and	r24, r24
    2922:	09 f4       	brne	.+2      	; 0x2926 <DoFruitcakeIntro+0xea>
    2924:	43 c0       	rjmp	.+134    	; 0x29ac <DoFruitcakeIntro+0x170>
		{
			if(ledPwm>1)
    2926:	80 91 3b 01 	lds	r24, 0x013B
    292a:	82 30       	cpi	r24, 0x02	; 2
    292c:	58 f0       	brcs	.+22     	; 0x2944 <DoFruitcakeIntro+0x108>
			{
				ledPwm-=2;
    292e:	80 91 3b 01 	lds	r24, 0x013B
    2932:	82 50       	subi	r24, 0x02	; 2
    2934:	80 93 3b 01 	sts	0x013B, r24
				SetTimer(TIMER_1,(SECOND/256));
    2938:	80 e0       	ldi	r24, 0x00	; 0
    293a:	64 e0       	ldi	r22, 0x04	; 4
    293c:	70 e0       	ldi	r23, 0x00	; 0
    293e:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
    2942:	34 c0       	rjmp	.+104    	; 0x29ac <DoFruitcakeIntro+0x170>
			}
			else
			{
				// Gleefully disable PWM.
				TIMSK2=0x00;		// Disable all timer 0 interrupts.
    2944:	10 92 70 00 	sts	0x0070, r1
				TCCR2A=0x00;		// Normal ports, begin setting CTC mode.	
    2948:	10 92 b0 00 	sts	0x00B0, r1
				TCCR2B=0x00;		// Turn clock off.
    294c:	10 92 b1 00 	sts	0x00B1, r1
				PRR|=(1<<PRTIM2);	// Turn the TMR2 power off.	
    2950:	80 91 64 00 	lds	r24, 0x0064
    2954:	80 64       	ori	r24, 0x40	; 64
    2956:	80 93 64 00 	sts	0x0064, r24

				LATCH_PORT=0x00;		// LEDs off.
    295a:	15 b8       	out	0x05, r1	; 5
				PORTD&=~(Om_LED_LA);	// ...Keep them off.
    295c:	5f 98       	cbi	0x0b, 7	; 11
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    295e:	10 92 39 01 	sts	0x0139, r1
	BlinkLeds(0);		// Durrrr.....
    2962:	80 e0       	ldi	r24, 0x00	; 0
    2964:	90 e0       	ldi	r25, 0x00	; 0
    2966:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>

				LATCH_PORT=0x00;		// LEDs off.
				PORTD&=~(Om_LED_LA);	// ...Keep them off.

				KillLeds();				// App knows leds are off.
				ledOnOffMask=CURRENT_FIRMWARE_VERSION;	// Convey some useful information at the end of this boondoggle
    296a:	80 e1       	ldi	r24, 0x10	; 16
    296c:	80 93 39 01 	sts	0x0139, r24
				SetTimer(TIMER_1,(SECOND/2));
    2970:	80 e0       	ldi	r24, 0x00	; 0
    2972:	62 e6       	ldi	r22, 0x62	; 98
    2974:	72 e0       	ldi	r23, 0x02	; 2
    2976:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
				subState=SS_4;
    297a:	84 e0       	ldi	r24, 0x04	; 4
    297c:	80 93 3f 01 	sts	0x013F, r24
    2980:	15 c0       	rjmp	.+42     	; 0x29ac <DoFruitcakeIntro+0x170>
			}
		}
	}
	else if(subState==SS_4)
    2982:	14 30       	cpi	r17, 0x04	; 4
    2984:	99 f4       	brne	.+38     	; 0x29ac <DoFruitcakeIntro+0x170>
	{
		if(CheckTimer(TIMER_1))
    2986:	80 e0       	ldi	r24, 0x00	; 0
    2988:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    298c:	88 23       	and	r24, r24
    298e:	71 f0       	breq	.+28     	; 0x29ac <DoFruitcakeIntro+0x170>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2990:	10 92 39 01 	sts	0x0139, r1
	BlinkLeds(0);		// Durrrr.....
    2994:	80 e0       	ldi	r24, 0x00	; 0
    2996:	90 e0       	ldi	r25, 0x00	; 0
    2998:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    299c:	88 ed       	ldi	r24, 0xD8	; 216
    299e:	94 e1       	ldi	r25, 0x14	; 20
    29a0:	90 93 7c 02 	sts	0x027C, r25
    29a4:	80 93 7b 02 	sts	0x027B, r24
	subState=SS_0;
    29a8:	10 92 3f 01 	sts	0x013F, r1
		{
			KillLeds();
			SetState(DoStartupSelect);		// Get crackin.
		}
	}
}
    29ac:	1f 91       	pop	r17
    29ae:	08 95       	ret

000029b0 <DoStartupSelect>:

static void DoStartupSelect(void)
// Make all our initial state decisions.
// Give switches time to settle.
{
	if(subState==SS_0)
    29b0:	80 91 3f 01 	lds	r24, 0x013F
    29b4:	88 23       	and	r24, r24
    29b6:	41 f4       	brne	.+16     	; 0x29c8 <DoStartupSelect+0x18>
	{
		SetTimer(TIMER_1,(SECOND/8));
    29b8:	68 e9       	ldi	r22, 0x98	; 152
    29ba:	70 e0       	ldi	r23, 0x00	; 0
    29bc:	0e 94 a3 20 	call	0x4146	; 0x4146 <SetTimer>
		subState=SS_1;
    29c0:	81 e0       	ldi	r24, 0x01	; 1
    29c2:	80 93 3f 01 	sts	0x013F, r24
    29c6:	08 95       	ret
	}
	else
	{
		if(CheckTimer(TIMER_1))
    29c8:	80 e0       	ldi	r24, 0x00	; 0
    29ca:	0e 94 b5 20 	call	0x416a	; 0x416a <CheckTimer>
    29ce:	88 23       	and	r24, r24
    29d0:	d1 f0       	breq	.+52     	; 0x2a06 <DoStartupSelect+0x56>
		{
			if(keyState&Im_SWITCH_0)
    29d2:	80 91 3d 01 	lds	r24, 0x013D
    29d6:	80 ff       	sbrs	r24, 0
    29d8:	03 c0       	rjmp	.+6      	; 0x29e0 <DoStartupSelect+0x30>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    29da:	83 ec       	ldi	r24, 0xC3	; 195
    29dc:	9f e1       	ldi	r25, 0x1F	; 31
    29de:	04 c0       	rjmp	.+8      	; 0x29e8 <DoStartupSelect+0x38>
		{
			if(keyState&Im_SWITCH_0)
			{
				SetState(DoSawtooth);
			}
			else if(keyState&Im_SWITCH_5)
    29e0:	85 ff       	sbrs	r24, 5
    29e2:	09 c0       	rjmp	.+18     	; 0x29f6 <DoStartupSelect+0x46>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    29e4:	89 e6       	ldi	r24, 0x69	; 105
    29e6:	9f e1       	ldi	r25, 0x1F	; 31
    29e8:	90 93 7c 02 	sts	0x027C, r25
    29ec:	80 93 7b 02 	sts	0x027B, r24
	subState=SS_0;
    29f0:	10 92 3f 01 	sts	0x013F, r1
    29f4:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    29f6:	88 e1       	ldi	r24, 0x18	; 24
    29f8:	95 e1       	ldi	r25, 0x15	; 21
    29fa:	90 93 7c 02 	sts	0x027C, r25
    29fe:	80 93 7b 02 	sts	0x027B, r24
	subState=SS_0;
    2a02:	10 92 3f 01 	sts	0x013F, r1
    2a06:	08 95       	ret

00002a08 <GetMidiChannel>:
}


static unsigned char GetMidiChannel(unsigned char theBank)
// Get the midi channel we stored in EEPROM.
{
    2a08:	1f 93       	push	r17
    2a0a:	18 2f       	mov	r17, r24
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    2a0c:	88 23       	and	r24, r24
    2a0e:	11 f4       	brne	.+4      	; 0x2a14 <GetMidiChannel+0xc>
	{
		x=EepromRead(4);		// Get the channel from EEPROM.
    2a10:	84 e0       	ldi	r24, 0x04	; 4
    2a12:	05 c0       	rjmp	.+10     	; 0x2a1e <GetMidiChannel+0x16>
	}
	else if(theBank==BANK_1)
    2a14:	81 30       	cpi	r24, 0x01	; 1
    2a16:	11 f0       	breq	.+4      	; 0x2a1c <GetMidiChannel+0x14>
    2a18:	80 e0       	ldi	r24, 0x00	; 0
    2a1a:	08 c0       	rjmp	.+16     	; 0x2a2c <GetMidiChannel+0x24>
	{
		x=EepromRead(8);		// Get the channel from EEPROM.
    2a1c:	88 e0       	ldi	r24, 0x08	; 8
    2a1e:	0e 94 6d 20 	call	0x40da	; 0x40da <EepromRead>
	}

	if(x<16)					// Legit number?
    2a22:	80 31       	cpi	r24, 0x10	; 16
    2a24:	18 f0       	brcs	.+6      	; 0x2a2c <GetMidiChannel+0x24>
    2a26:	81 2f       	mov	r24, r17
    2a28:	11 11       	cpse	r17, r1
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
		{
			x=1;			// Return midi channel 2 if we're screwing up the second bank.
		}
		return(x);
	}	
}
    2a2c:	1f 91       	pop	r17
    2a2e:	08 95       	ret

00002a30 <DoSampler>:
// Also, I'm not sure the blinking really helps the user (it used to indicate "ready" to do something) but the sampler is basically either doing something or ready to do it, with the exception
// power up where it has no sample stored yet and is not ready to play.  Perhaps blinking would be useful to indicate "not ready" since this is uncommon.  It'd only ever be useful for the play indicator, though.

// Wed Apr  8 11:42:07 CDT 2009
// This state is based on the idea that playing, recording, and overdubbing are all discrete things and that if you're doing one you can't be doing another.
{
    2a30:	cf 92       	push	r12
    2a32:	df 92       	push	r13
    2a34:	ef 92       	push	r14
    2a36:	ff 92       	push	r15
    2a38:	0f 93       	push	r16
    2a3a:	1f 93       	push	r17
    2a3c:	cf 93       	push	r28
    2a3e:	df 93       	push	r29
		pitchWheelValue;				// Figures out what to do with the pitchbend data.

	static bool
		editModeEntered;				// I DONT LIKE MODALITY, but the forum dudes do, so there's an edit mode we enter sometimes.  This bool keeps track of whether we're there.

	if(subState==SS_0)
    2a40:	10 91 3f 01 	lds	r17, 0x013F
    2a44:	11 23       	and	r17, r17
    2a46:	09 f0       	breq	.+2      	; 0x2a4a <DoSampler+0x1a>
    2a48:	ac c0       	rjmp	.+344    	; 0x2ba2 <DoSampler+0x172>
	// Initialize everything.
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
    2a4a:	80 e0       	ldi	r24, 0x00	; 0
    2a4c:	0e 94 04 15 	call	0x2a08	; 0x2a08 <GetMidiChannel>
    2a50:	80 93 c3 02 	sts	0x02C3, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	0e 94 04 15 	call	0x2a08	; 0x2a08 <GetMidiChannel>
    2a5a:	80 93 dc 02 	sts	0x02DC, r24
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
    2a5e:	10 92 8c 02 	sts	0x028C, r1
    2a62:	10 92 8d 02 	sts	0x028D, r1
    2a66:	10 92 8e 02 	sts	0x028E, r1
    2a6a:	10 92 8f 02 	sts	0x028F, r1
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).
    2a6e:	8f ef       	ldi	r24, 0xFF	; 255
    2a70:	9f ef       	ldi	r25, 0xFF	; 255
    2a72:	a7 e0       	ldi	r26, 0x07	; 7
    2a74:	b0 e0       	ldi	r27, 0x00	; 0
    2a76:	80 93 ae 02 	sts	0x02AE, r24
    2a7a:	90 93 af 02 	sts	0x02AF, r25
    2a7e:	a0 93 b0 02 	sts	0x02B0, r26
    2a82:	b0 93 b1 02 	sts	0x02B1, r27
    2a86:	0c e5       	ldi	r16, 0x5C	; 92
    2a88:	12 e0       	ldi	r17, 0x02	; 2
    2a8a:	c0 e0       	ldi	r28, 0x00	; 0
    2a8c:	d0 e0       	ldi	r29, 0x00	; 0
			bankStates[i].loopOnce=false;
			bankStates[i].bitReduction=0;				// No crusties yet.
			bankStates[i].jitterValue=0;				// No hissies yet.
			bankStates[i].granularSlices=0;				// No remix yet.
			bankStates[i].halfSpeed=false;
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2a8e:	ee 24       	eor	r14, r14
    2a90:	e3 94       	inc	r14
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
		{
			bankStates[i].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR yet.
    2a92:	9e 01       	movw	r18, r28
    2a94:	22 0f       	add	r18, r18
    2a96:	33 1f       	adc	r19, r19
    2a98:	ce 01       	movw	r24, r28
    2a9a:	75 e0       	ldi	r23, 0x05	; 5
    2a9c:	88 0f       	add	r24, r24
    2a9e:	99 1f       	adc	r25, r25
    2aa0:	7a 95       	dec	r23
    2aa2:	e1 f7       	brne	.-8      	; 0x2a9c <DoSampler+0x6c>
    2aa4:	28 0f       	add	r18, r24
    2aa6:	39 1f       	adc	r19, r25
    2aa8:	23 58       	subi	r18, 0x83	; 131
    2aaa:	3d 4f       	sbci	r19, 0xFD	; 253
    2aac:	f9 01       	movw	r30, r18
    2aae:	10 82       	st	Z, r1
			bankStates[i].clockMode=CLK_NONE;			// This bank doesn't do anything on any clock interrupts yet.
    2ab0:	10 86       	std	Z+8, r1	; 0x08
			bankStates[i].loopOnce=false;
    2ab2:	11 82       	std	Z+1, r1	; 0x01
			bankStates[i].bitReduction=0;				// No crusties yet.
    2ab4:	17 82       	std	Z+7, r1	; 0x07
			bankStates[i].jitterValue=0;				// No hissies yet.
    2ab6:	16 82       	std	Z+6, r1	; 0x06
			bankStates[i].granularSlices=0;				// No remix yet.
    2ab8:	15 82       	std	Z+5, r1	; 0x05
			bankStates[i].halfSpeed=false;
    2aba:	fe 01       	movw	r30, r28
    2abc:	64 e0       	ldi	r22, 0x04	; 4
    2abe:	ee 0f       	add	r30, r30
    2ac0:	ff 1f       	adc	r31, r31
    2ac2:	6a 95       	dec	r22
    2ac4:	e1 f7       	brne	.-8      	; 0x2abe <DoSampler+0x8e>
    2ac6:	ec 0f       	add	r30, r28
    2ac8:	fd 1f       	adc	r31, r29
    2aca:	ee 0f       	add	r30, r30
    2acc:	ff 1f       	adc	r31, r31
    2ace:	e1 58       	subi	r30, 0x81	; 129
    2ad0:	fd 4f       	sbci	r31, 0xFD	; 253
    2ad2:	10 82       	st	Z, r1
			bankStates[i].sampleDirection=true;			// Samples go forward normally (no editing has happend yet)
    2ad4:	f9 01       	movw	r30, r18
    2ad6:	e4 82       	std	Z+4, r14	; 0x04
			bankStates[i].backwardsPlayback=false;		// User hasn't said reverse normal direction
    2ad8:	13 82       	std	Z+3, r1	; 0x03
			bankStates[i].currentAddress=bankStates[i].startAddress;	// Point initial ram address to the beginning of the bank.
    2ada:	87 85       	ldd	r24, Z+15	; 0x0f
    2adc:	90 89       	ldd	r25, Z+16	; 0x10
    2ade:	a1 89       	ldd	r26, Z+17	; 0x11
    2ae0:	b2 89       	ldd	r27, Z+18	; 0x12
    2ae2:	86 8f       	std	Z+30, r24	; 0x1e
    2ae4:	97 8f       	std	Z+31, r25	; 0x1f
    2ae6:	a0 a3       	std	Z+32, r26	; 0x20
    2ae8:	b1 a3       	std	Z+33, r27	; 0x21
			bankStates[i].endAddress=bankStates[i].startAddress;		// ...And indicate that the sample is 0 samples big.
    2aea:	87 85       	ldd	r24, Z+15	; 0x0f
    2aec:	90 89       	ldd	r25, Z+16	; 0x10
    2aee:	a1 89       	ldd	r26, Z+17	; 0x11
    2af0:	b2 89       	ldd	r27, Z+18	; 0x12
    2af2:	83 87       	std	Z+11, r24	; 0x0b
    2af4:	94 87       	std	Z+12, r25	; 0x0c
    2af6:	a5 87       	std	Z+13, r26	; 0x0d
    2af8:	b6 87       	std	Z+14, r27	; 0x0e
			realtimeOn[i]=false;								// We'll default to playback.	
    2afa:	fe 01       	movw	r30, r28
    2afc:	ea 5d       	subi	r30, 0xDA	; 218
    2afe:	fe 4f       	sbci	r31, 0xFE	; 254
    2b00:	10 82       	st	Z, r1
			editModeEntered=false;
    2b02:	10 92 25 01 	sts	0x0125, r1
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    2b06:	2f b7       	in	r18, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    2b08:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    2b0a:	fe 01       	movw	r30, r28
    2b0c:	ee 0f       	add	r30, r30
    2b0e:	ff 1f       	adc	r31, r31
    2b10:	ce 01       	movw	r24, r28
    2b12:	35 e0       	ldi	r19, 0x05	; 5
    2b14:	88 0f       	add	r24, r24
    2b16:	99 1f       	adc	r25, r25
    2b18:	3a 95       	dec	r19
    2b1a:	e1 f7       	brne	.-8      	; 0x2b14 <DoSampler+0xe4>
    2b1c:	e8 0f       	add	r30, r24
    2b1e:	f9 1f       	adc	r31, r25
    2b20:	e3 58       	subi	r30, 0x83	; 131
    2b22:	fd 4f       	sbci	r31, 0xFD	; 253
    2b24:	87 85       	ldd	r24, Z+15	; 0x0f
    2b26:	90 89       	ldd	r25, Z+16	; 0x10
    2b28:	a1 89       	ldd	r26, Z+17	; 0x11
    2b2a:	b2 89       	ldd	r27, Z+18	; 0x12
    2b2c:	87 8b       	std	Z+23, r24	; 0x17
    2b2e:	90 8f       	std	Z+24, r25	; 0x18
    2b30:	a1 8f       	std	Z+25, r26	; 0x19
    2b32:	b2 8f       	std	Z+26, r27	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    2b34:	83 85       	ldd	r24, Z+11	; 0x0b
    2b36:	94 85       	ldd	r25, Z+12	; 0x0c
    2b38:	a5 85       	ldd	r26, Z+13	; 0x0d
    2b3a:	b6 85       	ldd	r27, Z+14	; 0x0e
    2b3c:	83 8b       	std	Z+19, r24	; 0x13
    2b3e:	94 8b       	std	Z+20, r25	; 0x14
    2b40:	a5 8b       	std	Z+21, r26	; 0x15
    2b42:	b6 8b       	std	Z+22, r27	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    2b44:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    2b46:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    2b48:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    2b4a:	2f bf       	out	0x3f, r18	; 63
	unsigned char
		x;

	x=0;		// Return something non-gibberish, always.

	if(theBank==BANK_0)
    2b4c:	cc 23       	and	r28, r28
    2b4e:	11 f4       	brne	.+4      	; 0x2b54 <DoSampler+0x124>
	{
		x=EepromRead(7);		// Get the channel from EEPROM.
    2b50:	87 e0       	ldi	r24, 0x07	; 7
    2b52:	01 c0       	rjmp	.+2      	; 0x2b56 <DoSampler+0x126>
	}
	else if(theBank==BANK_1)
	{
		x=EepromRead(11);		// Get the channel from EEPROM.
    2b54:	8b e0       	ldi	r24, 0x0B	; 11
    2b56:	0e 94 6d 20 	call	0x40da	; 0x40da <EepromRead>
	}

	if(x<90)					// Legit number?
    2b5a:	8a 35       	cpi	r24, 0x5A	; 90
    2b5c:	08 f0       	brcs	.+2      	; 0x2b60 <DoSampler+0x130>
    2b5e:	80 e3       	ldi	r24, 0x30	; 48
			realtimeOn[i]=false;								// We'll default to playback.	
			editModeEntered=false;

			RevertSampleToUnadjusted(i);						// Zero out all trimming variables.

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
    2b60:	f8 01       	movw	r30, r16
    2b62:	80 83       	st	Z, r24
    2b64:	11 82       	std	Z+1, r1	; 0x01
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
    2b66:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    2b6a:	f8 01       	movw	r30, r16
    2b6c:	81 93       	st	Z+, r24
    2b6e:	91 93       	st	Z+, r25
    2b70:	8f 01       	movw	r16, r30
    2b72:	21 96       	adiw	r28, 0x01	; 1
		midiChannelNumberA=GetMidiChannel(BANK_0);				// Get our MIDI channel from Eeprom.
		midiChannelNumberB=GetMidiChannel(BANK_1);				// Get our MIDI channel from Eeprom.
		bankStates[BANK_0].startAddress=BANK_0_START_ADDRESS;	// Link indexable bank 0 variable to hardcoded start address at the beginning of RAM
		bankStates[BANK_1].startAddress=BANK_1_START_ADDRESS;	// Link indexable bank 1 variable to hardcoded start address at the end of RAM (it will count down).

		for(i=0;i<NUM_BANKS;i++)		// Initialize all the banks.
    2b74:	c2 30       	cpi	r28, 0x02	; 2
    2b76:	d1 05       	cpc	r29, r1
    2b78:	09 f0       	breq	.+2      	; 0x2b7c <DoSampler+0x14c>
    2b7a:	8b cf       	rjmp	.-234    	; 0x2a92 <DoSampler+0x62>

			theMidiRecordRate[i]=GetMidiRecordNote(i);							// First get the proper note.
			theMidiRecordRate[i]=GetPlaybackRateFromNote(theMidiRecordRate[i]);  // Now make it a useful number.
		}

		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2b7c:	82 e5       	ldi	r24, 0x52	; 82
    2b7e:	98 e0       	ldi	r25, 0x08	; 8
    2b80:	90 93 7a 02 	sts	0x027A, r25
    2b84:	80 93 79 02 	sts	0x0279, r24

		currentBank=BANK_0;			// Point at the first bank until we change banks.
    2b88:	10 92 2c 01 	sts	0x012C, r1
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    2b8c:	10 92 39 01 	sts	0x0139, r1
	BlinkLeds(0);		// Durrrr.....
    2b90:	80 e0       	ldi	r24, 0x00	; 0
    2b92:	90 e0       	ldi	r25, 0x00	; 0
    2b94:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.

		currentBank=BANK_0;			// Point at the first bank until we change banks.

		KillLeds();					// All leds off, and no blinking.
		subState=SS_1;
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	80 93 3f 01 	sts	0x013F, r24
    2b9e:	0c 94 86 1e 	jmp	0x3d0c	; 0x3d0c <DoSampler+0x12dc>
	}

	else if(subState==SS_1)		// Hang out here getting keypresses and MIDI and handling the different sampler functions.
    2ba2:	11 30       	cpi	r17, 0x01	; 1
    2ba4:	11 f0       	breq	.+4      	; 0x2baa <DoSampler+0x17a>
    2ba6:	0c 94 86 1e 	jmp	0x3d0c	; 0x3d0c <DoSampler+0x12dc>
	{
		if(editModeEntered==false)	// Normal functions for buttons?
    2baa:	80 91 25 01 	lds	r24, 0x0125
    2bae:	90 91 3d 01 	lds	r25, 0x013D
    2bb2:	88 23       	and	r24, r24
    2bb4:	09 f0       	breq	.+2      	; 0x2bb8 <DoSampler+0x188>
    2bb6:	b9 c3       	rjmp	.+1906   	; 0x332a <DoSampler+0x8fa>
		{
			if(keyState&Im_EFFECT)			// If we're holding the effect switch, our other switches call up patches instead of their normal functions.  It's like a shift key.
    2bb8:	29 2f       	mov	r18, r25
    2bba:	30 e0       	ldi	r19, 0x00	; 0
    2bbc:	95 ff       	sbrs	r25, 5
    2bbe:	f6 c1       	rjmp	.+1004   	; 0x2fac <DoSampler+0x57c>
			{
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
    2bc0:	b9 01       	movw	r22, r18
    2bc2:	68 70       	andi	r22, 0x08	; 8
    2bc4:	70 70       	andi	r23, 0x00	; 0
    2bc6:	93 ff       	sbrs	r25, 3
    2bc8:	04 c0       	rjmp	.+8      	; 0x2bd2 <DoSampler+0x1a2>
    2bca:	80 91 3e 01 	lds	r24, 0x013E
    2bce:	84 fd       	sbrc	r24, 4
    2bd0:	0a c0       	rjmp	.+20     	; 0x2be6 <DoSampler+0x1b6>
    2bd2:	80 91 3e 01 	lds	r24, 0x013E
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	ac 01       	movw	r20, r24
    2bda:	48 70       	andi	r20, 0x08	; 8
    2bdc:	50 70       	andi	r21, 0x00	; 0
    2bde:	83 ff       	sbrs	r24, 3
    2be0:	f8 c0       	rjmp	.+496    	; 0x2dd2 <DoSampler+0x3a2>
    2be2:	24 ff       	sbrs	r18, 4
    2be4:	f6 c0       	rjmp	.+492    	; 0x2dd2 <DoSampler+0x3a2>
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2be6:	82 e5       	ldi	r24, 0x52	; 82
    2be8:	98 e0       	ldi	r25, 0x08	; 8
    2bea:	90 93 7a 02 	sts	0x027A, r25
    2bee:	80 93 79 02 	sts	0x0279, r24
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    2bf2:	9f b7       	in	r25, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    2bf4:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    2bf6:	80 91 2c 01 	lds	r24, 0x012C
    2bfa:	28 2f       	mov	r18, r24
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	f9 01       	movw	r30, r18
    2c00:	05 e0       	ldi	r16, 0x05	; 5
    2c02:	ee 0f       	add	r30, r30
    2c04:	ff 1f       	adc	r31, r31
    2c06:	0a 95       	dec	r16
    2c08:	e1 f7       	brne	.-8      	; 0x2c02 <DoSampler+0x1d2>
    2c0a:	22 0f       	add	r18, r18
    2c0c:	33 1f       	adc	r19, r19
    2c0e:	e2 0f       	add	r30, r18
    2c10:	f3 1f       	adc	r31, r19
    2c12:	e3 58       	subi	r30, 0x83	; 131
    2c14:	fd 4f       	sbci	r31, 0xFD	; 253
    2c16:	47 85       	ldd	r20, Z+15	; 0x0f
    2c18:	50 89       	ldd	r21, Z+16	; 0x10
    2c1a:	61 89       	ldd	r22, Z+17	; 0x11
    2c1c:	72 89       	ldd	r23, Z+18	; 0x12
    2c1e:	28 2f       	mov	r18, r24
    2c20:	30 e0       	ldi	r19, 0x00	; 0
    2c22:	f9 01       	movw	r30, r18
    2c24:	b5 e0       	ldi	r27, 0x05	; 5
    2c26:	ee 0f       	add	r30, r30
    2c28:	ff 1f       	adc	r31, r31
    2c2a:	ba 95       	dec	r27
    2c2c:	e1 f7       	brne	.-8      	; 0x2c26 <DoSampler+0x1f6>
    2c2e:	22 0f       	add	r18, r18
    2c30:	33 1f       	adc	r19, r19
    2c32:	e2 0f       	add	r30, r18
    2c34:	f3 1f       	adc	r31, r19
    2c36:	e3 58       	subi	r30, 0x83	; 131
    2c38:	fd 4f       	sbci	r31, 0xFD	; 253
    2c3a:	47 8b       	std	Z+23, r20	; 0x17
    2c3c:	50 8f       	std	Z+24, r21	; 0x18
    2c3e:	61 8f       	std	Z+25, r22	; 0x19
    2c40:	72 8f       	std	Z+26, r23	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    2c42:	28 2f       	mov	r18, r24
    2c44:	30 e0       	ldi	r19, 0x00	; 0
    2c46:	f9 01       	movw	r30, r18
    2c48:	45 e0       	ldi	r20, 0x05	; 5
    2c4a:	ee 0f       	add	r30, r30
    2c4c:	ff 1f       	adc	r31, r31
    2c4e:	4a 95       	dec	r20
    2c50:	e1 f7       	brne	.-8      	; 0x2c4a <DoSampler+0x21a>
    2c52:	22 0f       	add	r18, r18
    2c54:	33 1f       	adc	r19, r19
    2c56:	e2 0f       	add	r30, r18
    2c58:	f3 1f       	adc	r31, r19
    2c5a:	e3 58       	subi	r30, 0x83	; 131
    2c5c:	fd 4f       	sbci	r31, 0xFD	; 253
    2c5e:	43 85       	ldd	r20, Z+11	; 0x0b
    2c60:	54 85       	ldd	r21, Z+12	; 0x0c
    2c62:	65 85       	ldd	r22, Z+13	; 0x0d
    2c64:	76 85       	ldd	r23, Z+14	; 0x0e
    2c66:	28 2f       	mov	r18, r24
    2c68:	30 e0       	ldi	r19, 0x00	; 0
    2c6a:	f9 01       	movw	r30, r18
    2c6c:	15 e0       	ldi	r17, 0x05	; 5
    2c6e:	ee 0f       	add	r30, r30
    2c70:	ff 1f       	adc	r31, r31
    2c72:	1a 95       	dec	r17
    2c74:	e1 f7       	brne	.-8      	; 0x2c6e <DoSampler+0x23e>
    2c76:	22 0f       	add	r18, r18
    2c78:	33 1f       	adc	r19, r19
    2c7a:	e2 0f       	add	r30, r18
    2c7c:	f3 1f       	adc	r31, r19
    2c7e:	e3 58       	subi	r30, 0x83	; 131
    2c80:	fd 4f       	sbci	r31, 0xFD	; 253
    2c82:	43 8b       	std	Z+19, r20	; 0x13
    2c84:	54 8b       	std	Z+20, r21	; 0x14
    2c86:	65 8b       	std	Z+21, r22	; 0x15
    2c88:	76 8b       	std	Z+22, r23	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    2c8a:	28 2f       	mov	r18, r24
    2c8c:	30 e0       	ldi	r19, 0x00	; 0
    2c8e:	f9 01       	movw	r30, r18
    2c90:	a5 e0       	ldi	r26, 0x05	; 5
    2c92:	ee 0f       	add	r30, r30
    2c94:	ff 1f       	adc	r31, r31
    2c96:	aa 95       	dec	r26
    2c98:	e1 f7       	brne	.-8      	; 0x2c92 <DoSampler+0x262>
    2c9a:	22 0f       	add	r18, r18
    2c9c:	33 1f       	adc	r19, r19
    2c9e:	e2 0f       	add	r30, r18
    2ca0:	f3 1f       	adc	r31, r19
    2ca2:	e3 58       	subi	r30, 0x83	; 131
    2ca4:	fd 4f       	sbci	r31, 0xFD	; 253
    2ca6:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    2ca8:	28 2f       	mov	r18, r24
    2caa:	30 e0       	ldi	r19, 0x00	; 0
    2cac:	f9 01       	movw	r30, r18
    2cae:	65 e0       	ldi	r22, 0x05	; 5
    2cb0:	ee 0f       	add	r30, r30
    2cb2:	ff 1f       	adc	r31, r31
    2cb4:	6a 95       	dec	r22
    2cb6:	e1 f7       	brne	.-8      	; 0x2cb0 <DoSampler+0x280>
    2cb8:	22 0f       	add	r18, r18
    2cba:	33 1f       	adc	r19, r19
    2cbc:	e2 0f       	add	r30, r18
    2cbe:	f3 1f       	adc	r31, r19
    2cc0:	e3 58       	subi	r30, 0x83	; 131
    2cc2:	fd 4f       	sbci	r31, 0xFD	; 253
    2cc4:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    2cc6:	28 2f       	mov	r18, r24
    2cc8:	30 e0       	ldi	r19, 0x00	; 0
    2cca:	f9 01       	movw	r30, r18
    2ccc:	45 e0       	ldi	r20, 0x05	; 5
    2cce:	ee 0f       	add	r30, r30
    2cd0:	ff 1f       	adc	r31, r31
    2cd2:	4a 95       	dec	r20
    2cd4:	e1 f7       	brne	.-8      	; 0x2cce <DoSampler+0x29e>
    2cd6:	22 0f       	add	r18, r18
    2cd8:	33 1f       	adc	r19, r19
    2cda:	e2 0f       	add	r30, r18
    2cdc:	f3 1f       	adc	r31, r19
    2cde:	e3 58       	subi	r30, 0x83	; 131
    2ce0:	fd 4f       	sbci	r31, 0xFD	; 253
    2ce2:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    2ce4:	9f bf       	out	0x3f, r25	; 63
				// Multiple Held-key combinations:
				if(((keyState&Im_SWITCH_3)&&(newKeys&Im_SWITCH_4))||((newKeys&Im_SWITCH_3)&&(keyState&Im_SWITCH_4)))	// Bail!
				{
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					RevertSampleToUnadjusted(currentBank);			// Get rid of any trimming on the sample.
					bankStates[currentBank].bitReduction=0;			// No crusties yet.
    2ce6:	28 2f       	mov	r18, r24
    2ce8:	30 e0       	ldi	r19, 0x00	; 0
    2cea:	f9 01       	movw	r30, r18
    2cec:	15 e0       	ldi	r17, 0x05	; 5
    2cee:	ee 0f       	add	r30, r30
    2cf0:	ff 1f       	adc	r31, r31
    2cf2:	1a 95       	dec	r17
    2cf4:	e1 f7       	brne	.-8      	; 0x2cee <DoSampler+0x2be>
    2cf6:	22 0f       	add	r18, r18
    2cf8:	33 1f       	adc	r19, r19
    2cfa:	e2 0f       	add	r30, r18
    2cfc:	f3 1f       	adc	r31, r19
    2cfe:	e3 58       	subi	r30, 0x83	; 131
    2d00:	fd 4f       	sbci	r31, 0xFD	; 253
    2d02:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentBank].jitterValue=0;			// No hissies yet.
    2d04:	28 2f       	mov	r18, r24
    2d06:	30 e0       	ldi	r19, 0x00	; 0
    2d08:	f9 01       	movw	r30, r18
    2d0a:	a5 e0       	ldi	r26, 0x05	; 5
    2d0c:	ee 0f       	add	r30, r30
    2d0e:	ff 1f       	adc	r31, r31
    2d10:	aa 95       	dec	r26
    2d12:	e1 f7       	brne	.-8      	; 0x2d0c <DoSampler+0x2dc>
    2d14:	22 0f       	add	r18, r18
    2d16:	33 1f       	adc	r19, r19
    2d18:	e2 0f       	add	r30, r18
    2d1a:	f3 1f       	adc	r31, r19
    2d1c:	e3 58       	subi	r30, 0x83	; 131
    2d1e:	fd 4f       	sbci	r31, 0xFD	; 253
    2d20:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentBank].granularSlices=0;		// No remix yet.
    2d22:	28 2f       	mov	r18, r24
    2d24:	30 e0       	ldi	r19, 0x00	; 0
    2d26:	f9 01       	movw	r30, r18
    2d28:	65 e0       	ldi	r22, 0x05	; 5
    2d2a:	ee 0f       	add	r30, r30
    2d2c:	ff 1f       	adc	r31, r31
    2d2e:	6a 95       	dec	r22
    2d30:	e1 f7       	brne	.-8      	; 0x2d2a <DoSampler+0x2fa>
    2d32:	22 0f       	add	r18, r18
    2d34:	33 1f       	adc	r19, r19
    2d36:	e2 0f       	add	r30, r18
    2d38:	f3 1f       	adc	r31, r19
    2d3a:	e3 58       	subi	r30, 0x83	; 131
    2d3c:	fd 4f       	sbci	r31, 0xFD	; 253
    2d3e:	15 82       	std	Z+5, r1	; 0x05
					bankStates[currentBank].halfSpeed=false;
    2d40:	28 2f       	mov	r18, r24
    2d42:	30 e0       	ldi	r19, 0x00	; 0
    2d44:	f9 01       	movw	r30, r18
    2d46:	44 e0       	ldi	r20, 0x04	; 4
    2d48:	ee 0f       	add	r30, r30
    2d4a:	ff 1f       	adc	r31, r31
    2d4c:	4a 95       	dec	r20
    2d4e:	e1 f7       	brne	.-8      	; 0x2d48 <DoSampler+0x318>
    2d50:	e2 0f       	add	r30, r18
    2d52:	f3 1f       	adc	r31, r19
    2d54:	ee 0f       	add	r30, r30
    2d56:	ff 1f       	adc	r31, r31
    2d58:	e1 58       	subi	r30, 0x81	; 129
    2d5a:	fd 4f       	sbci	r31, 0xFD	; 253
    2d5c:	10 82       	st	Z, r1
					bankStates[currentBank].backwardsPlayback=false;					
    2d5e:	28 2f       	mov	r18, r24
    2d60:	30 e0       	ldi	r19, 0x00	; 0
    2d62:	f9 01       	movw	r30, r18
    2d64:	95 e0       	ldi	r25, 0x05	; 5
    2d66:	ee 0f       	add	r30, r30
    2d68:	ff 1f       	adc	r31, r31
    2d6a:	9a 95       	dec	r25
    2d6c:	e1 f7       	brne	.-8      	; 0x2d66 <DoSampler+0x336>
    2d6e:	22 0f       	add	r18, r18
    2d70:	33 1f       	adc	r19, r19
    2d72:	e2 0f       	add	r30, r18
    2d74:	f3 1f       	adc	r31, r19
    2d76:	e3 58       	subi	r30, 0x83	; 131
    2d78:	fd 4f       	sbci	r31, 0xFD	; 253
    2d7a:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentBank].sampleDirection=true;					
    2d7c:	28 2f       	mov	r18, r24
    2d7e:	30 e0       	ldi	r19, 0x00	; 0
    2d80:	f9 01       	movw	r30, r18
    2d82:	15 e0       	ldi	r17, 0x05	; 5
    2d84:	ee 0f       	add	r30, r30
    2d86:	ff 1f       	adc	r31, r31
    2d88:	1a 95       	dec	r17
    2d8a:	e1 f7       	brne	.-8      	; 0x2d84 <DoSampler+0x354>
    2d8c:	22 0f       	add	r18, r18
    2d8e:	33 1f       	adc	r19, r19
    2d90:	e2 0f       	add	r30, r18
    2d92:	f3 1f       	adc	r31, r19
    2d94:	e3 58       	subi	r30, 0x83	; 131
    2d96:	fd 4f       	sbci	r31, 0xFD	; 253
    2d98:	91 e0       	ldi	r25, 0x01	; 1
    2d9a:	94 83       	std	Z+4, r25	; 0x04
					bankStates[currentBank].loopOnce=false;				
    2d9c:	28 2f       	mov	r18, r24
    2d9e:	30 e0       	ldi	r19, 0x00	; 0
    2da0:	f9 01       	movw	r30, r18
    2da2:	a5 e0       	ldi	r26, 0x05	; 5
    2da4:	ee 0f       	add	r30, r30
    2da6:	ff 1f       	adc	r31, r31
    2da8:	aa 95       	dec	r26
    2daa:	e1 f7       	brne	.-8      	; 0x2da4 <DoSampler+0x374>
    2dac:	22 0f       	add	r18, r18
    2dae:	33 1f       	adc	r19, r19
    2db0:	e2 0f       	add	r30, r18
    2db2:	f3 1f       	adc	r31, r19
    2db4:	e3 58       	subi	r30, 0x83	; 131
    2db6:	fd 4f       	sbci	r31, 0xFD	; 253
    2db8:	11 82       	std	Z+1, r1	; 0x01
					editModeEntered=false;
    2dba:	10 92 25 01 	sts	0x0125, r1
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_CANCEL_EFFECTS,0);		// Send it out to the techno nerds.			
    2dbe:	64 e0       	ldi	r22, 0x04	; 4
    2dc0:	42 e1       	ldi	r20, 0x12	; 18
    2dc2:	20 e0       	ldi	r18, 0x00	; 0
    2dc4:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <PutMidiMessageInOutgoingFifo>
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REVERT_SAMPLE_TO_FULL,0);		// Send it out to the techno nerds.			
    2dc8:	80 91 2c 01 	lds	r24, 0x012C
    2dcc:	64 e0       	ldi	r22, 0x04	; 4
    2dce:	4b e1       	ldi	r20, 0x1B	; 27
    2dd0:	57 c1       	rjmp	.+686    	; 0x3080 <DoSampler+0x650>
				}
				else if(keyState&Im_SWITCH_3)	// Sample trimming
    2dd2:	67 2b       	or	r22, r23
    2dd4:	59 f1       	breq	.+86     	; 0x2e2c <DoSampler+0x3fc>
				{
					if(keyState&Im_SWITCH_0||keyState&Im_SWITCH_1||keyState&Im_SWITCH_2)	// These are all edit commands, if we hit them then enter edit mode.
    2dd6:	20 fd       	sbrc	r18, 0
    2dd8:	04 c0       	rjmp	.+8      	; 0x2de2 <DoSampler+0x3b2>
    2dda:	26 70       	andi	r18, 0x06	; 6
    2ddc:	30 70       	andi	r19, 0x00	; 0
    2dde:	23 2b       	or	r18, r19
    2de0:	21 f0       	breq	.+8      	; 0x2dea <DoSampler+0x3ba>
					{
						editModeEntered=true;
    2de2:	81 e0       	ldi	r24, 0x01	; 1
    2de4:	80 93 25 01 	sts	0x0125, r24
    2de8:	43 c3       	rjmp	.+1670   	; 0x3470 <DoSampler+0xa40>
					}
					else if(newKeys&Im_SWITCH_3)		// Screw and chop (toggle) (default two key combo)
    2dea:	45 2b       	or	r20, r21
    2dec:	09 f4       	brne	.+2      	; 0x2df0 <DoSampler+0x3c0>
    2dee:	40 c3       	rjmp	.+1664   	; 0x3470 <DoSampler+0xa40>
					{
						if(bankStates[currentBank].halfSpeed==false)
    2df0:	20 91 2c 01 	lds	r18, 0x012C
    2df4:	82 2f       	mov	r24, r18
    2df6:	90 e0       	ldi	r25, 0x00	; 0
    2df8:	fc 01       	movw	r30, r24
    2dfa:	64 e0       	ldi	r22, 0x04	; 4
    2dfc:	ee 0f       	add	r30, r30
    2dfe:	ff 1f       	adc	r31, r31
    2e00:	6a 95       	dec	r22
    2e02:	e1 f7       	brne	.-8      	; 0x2dfc <DoSampler+0x3cc>
    2e04:	e8 0f       	add	r30, r24
    2e06:	f9 1f       	adc	r31, r25
    2e08:	ee 0f       	add	r30, r30
    2e0a:	ff 1f       	adc	r31, r31
    2e0c:	e1 58       	subi	r30, 0x81	; 129
    2e0e:	fd 4f       	sbci	r31, 0xFD	; 253
    2e10:	80 81       	ld	r24, Z
    2e12:	88 23       	and	r24, r24
    2e14:	31 f4       	brne	.+12     	; 0x2e22 <DoSampler+0x3f2>
						{
							bankStates[currentBank].halfSpeed=true;
    2e16:	81 e0       	ldi	r24, 0x01	; 1
    2e18:	80 83       	st	Z, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2e1a:	82 2f       	mov	r24, r18
    2e1c:	64 e0       	ldi	r22, 0x04	; 4
    2e1e:	40 e1       	ldi	r20, 0x10	; 16
    2e20:	f4 c1       	rjmp	.+1000   	; 0x320a <DoSampler+0x7da>
						}
						else
						{
							bankStates[currentBank].halfSpeed=false;				
    2e22:	10 82       	st	Z, r1
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_HALF_SPEED,0);		// Send it out to the techno nerds.
    2e24:	82 2f       	mov	r24, r18
    2e26:	64 e0       	ldi	r22, 0x04	; 4
    2e28:	40 e1       	ldi	r20, 0x10	; 16
    2e2a:	2a c1       	rjmp	.+596    	; 0x3080 <DoSampler+0x650>
						}
					}
				}
				else if(keyState&Im_SWITCH_4)		// Realtime.
    2e2c:	24 ff       	sbrs	r18, 4
    2e2e:	52 c0       	rjmp	.+164    	; 0x2ed4 <DoSampler+0x4a4>
				{
					if(newKeys&Im_SWITCH_2)		// Do realtime (three button combo)
    2e30:	82 ff       	sbrs	r24, 2
    2e32:	0c c0       	rjmp	.+24     	; 0x2e4c <DoSampler+0x41c>
					{
						StartRealtime(currentBank,CLK_EXTERNAL,0);
    2e34:	80 91 2c 01 	lds	r24, 0x012C
    2e38:	61 e0       	ldi	r22, 0x01	; 1
    2e3a:	40 e0       	ldi	r20, 0x00	; 0
    2e3c:	50 e0       	ldi	r21, 0x00	; 0
    2e3e:	0e 94 ba 0c 	call	0x1974	; 0x1974 <StartRealtime>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_REALTIME,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2e42:	80 91 2c 01 	lds	r24, 0x012C
    2e46:	64 e0       	ldi	r22, 0x04	; 4
    2e48:	4e e0       	ldi	r20, 0x0E	; 14
    2e4a:	71 c1       	rjmp	.+738    	; 0x312e <DoSampler+0x6fe>
					}
					else if(newKeys&Im_SWITCH_4)		// "Paul is Dead" mask (only pressing two keys)
    2e4c:	84 ff       	sbrs	r24, 4
    2e4e:	10 c3       	rjmp	.+1568   	; 0x3470 <DoSampler+0xa40>
					{
						if(bankStates[currentBank].backwardsPlayback==false)
    2e50:	20 91 2c 01 	lds	r18, 0x012C
    2e54:	82 2f       	mov	r24, r18
    2e56:	90 e0       	ldi	r25, 0x00	; 0
    2e58:	fc 01       	movw	r30, r24
    2e5a:	45 e0       	ldi	r20, 0x05	; 5
    2e5c:	ee 0f       	add	r30, r30
    2e5e:	ff 1f       	adc	r31, r31
    2e60:	4a 95       	dec	r20
    2e62:	e1 f7       	brne	.-8      	; 0x2e5c <DoSampler+0x42c>
    2e64:	88 0f       	add	r24, r24
    2e66:	99 1f       	adc	r25, r25
    2e68:	e8 0f       	add	r30, r24
    2e6a:	f9 1f       	adc	r31, r25
    2e6c:	e3 58       	subi	r30, 0x83	; 131
    2e6e:	fd 4f       	sbci	r31, 0xFD	; 253
    2e70:	83 81       	ldd	r24, Z+3	; 0x03
    2e72:	88 23       	and	r24, r24
    2e74:	a9 f4       	brne	.+42     	; 0x2ea0 <DoSampler+0x470>
						{
							bankStates[currentBank].backwardsPlayback=true;
    2e76:	82 2f       	mov	r24, r18
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	05 e0       	ldi	r16, 0x05	; 5
    2e7e:	ee 0f       	add	r30, r30
    2e80:	ff 1f       	adc	r31, r31
    2e82:	0a 95       	dec	r16
    2e84:	e1 f7       	brne	.-8      	; 0x2e7e <DoSampler+0x44e>
    2e86:	88 0f       	add	r24, r24
    2e88:	99 1f       	adc	r25, r25
    2e8a:	e8 0f       	add	r30, r24
    2e8c:	f9 1f       	adc	r31, r25
    2e8e:	e3 58       	subi	r30, 0x83	; 131
    2e90:	fd 4f       	sbci	r31, 0xFD	; 253
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	83 83       	std	Z+3, r24	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
    2e96:	82 2f       	mov	r24, r18
    2e98:	64 e0       	ldi	r22, 0x04	; 4
    2e9a:	41 e1       	ldi	r20, 0x11	; 17
    2e9c:	20 e4       	ldi	r18, 0x40	; 64
    2e9e:	13 c0       	rjmp	.+38     	; 0x2ec6 <DoSampler+0x496>
						}
						else
						{
							bankStates[currentBank].backwardsPlayback=false;				
    2ea0:	82 2f       	mov	r24, r18
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	b5 e0       	ldi	r27, 0x05	; 5
    2ea8:	ee 0f       	add	r30, r30
    2eaa:	ff 1f       	adc	r31, r31
    2eac:	ba 95       	dec	r27
    2eae:	e1 f7       	brne	.-8      	; 0x2ea8 <DoSampler+0x478>
    2eb0:	88 0f       	add	r24, r24
    2eb2:	99 1f       	adc	r25, r25
    2eb4:	e8 0f       	add	r30, r24
    2eb6:	f9 1f       	adc	r31, r25
    2eb8:	e3 58       	subi	r30, 0x83	; 131
    2eba:	fd 4f       	sbci	r31, 0xFD	; 253
    2ebc:	13 82       	std	Z+3, r1	; 0x03
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_PLAY_BACKWARDS,0);		// Send it out to the techno nerds.
    2ebe:	82 2f       	mov	r24, r18
    2ec0:	64 e0       	ldi	r22, 0x04	; 4
    2ec2:	41 e1       	ldi	r20, 0x11	; 17
    2ec4:	20 e0       	ldi	r18, 0x00	; 0
    2ec6:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <PutMidiMessageInOutgoingFifo>
						}										
						
						UpdateAdjustedSampleAddresses(currentBank);	// @@@ make sure we handle going backwards when considering edited samples.
    2eca:	80 91 2c 01 	lds	r24, 0x012C
    2ece:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <UpdateAdjustedSampleAddresses>
    2ed2:	ce c2       	rjmp	.+1436   	; 0x3470 <DoSampler+0xa40>
					}
				}			
				else
				{
					if(newKeys&Im_SWITCH_0)		// Switch 0 (the left most) handles bit reduction.
    2ed4:	80 ff       	sbrs	r24, 0
    2ed6:	17 c0       	rjmp	.+46     	; 0x2f06 <DoSampler+0x4d6>
					{
						bankStates[currentBank].bitReduction=scaledEncoderValue;	// Reduce bit depth by 0-7.
    2ed8:	80 91 2c 01 	lds	r24, 0x012C
    2edc:	20 91 43 01 	lds	r18, 0x0143
    2ee0:	48 2f       	mov	r20, r24
    2ee2:	50 e0       	ldi	r21, 0x00	; 0
    2ee4:	fa 01       	movw	r30, r20
    2ee6:	75 e0       	ldi	r23, 0x05	; 5
    2ee8:	ee 0f       	add	r30, r30
    2eea:	ff 1f       	adc	r31, r31
    2eec:	7a 95       	dec	r23
    2eee:	e1 f7       	brne	.-8      	; 0x2ee8 <DoSampler+0x4b8>
    2ef0:	44 0f       	add	r20, r20
    2ef2:	55 1f       	adc	r21, r21
    2ef4:	e4 0f       	add	r30, r20
    2ef6:	f5 1f       	adc	r31, r21
    2ef8:	e3 58       	subi	r30, 0x83	; 131
    2efa:	fd 4f       	sbci	r31, 0xFD	; 253
    2efc:	27 83       	std	Z+7, r18	; 0x07
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_BIT_REDUCTION,scaledEncoderValue);		// Send it out to the techno nerds.
    2efe:	64 e0       	ldi	r22, 0x04	; 4
    2f00:	43 e1       	ldi	r20, 0x13	; 19
    2f02:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_1)		// Switch 1 sends granular data.
    2f06:	80 91 3e 01 	lds	r24, 0x013E
    2f0a:	81 ff       	sbrs	r24, 1
    2f0c:	10 c0       	rjmp	.+32     	; 0x2f2e <DoSampler+0x4fe>
					{
						MakeNewGranularArray(currentBank,(encoderValue/2));			// Start or stop granularization.	
    2f0e:	60 91 42 01 	lds	r22, 0x0142
    2f12:	66 95       	lsr	r22
    2f14:	80 91 2c 01 	lds	r24, 0x012C
    2f18:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <MakeNewGranularArray>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_GRANULARITY,(encoderValue/2));		// Send it out to the techno nerds.
    2f1c:	20 91 42 01 	lds	r18, 0x0142
    2f20:	26 95       	lsr	r18
    2f22:	80 91 2c 01 	lds	r24, 0x012C
    2f26:	64 e0       	ldi	r22, 0x04	; 4
    2f28:	44 e1       	ldi	r20, 0x14	; 20
    2f2a:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <PutMidiMessageInOutgoingFifo>
					}
					if(newKeys&Im_SWITCH_2)		// Switch 2 assigns our different ways of combining audio channels on the output.
    2f2e:	80 91 3e 01 	lds	r24, 0x013E
    2f32:	82 ff       	sbrs	r24, 2
    2f34:	9d c2       	rjmp	.+1338   	; 0x3470 <DoSampler+0xa40>
					{
						switch(scaledEncoderValue)
    2f36:	20 91 43 01 	lds	r18, 0x0143
    2f3a:	21 30       	cpi	r18, 0x01	; 1
    2f3c:	99 f0       	breq	.+38     	; 0x2f64 <DoSampler+0x534>
    2f3e:	21 30       	cpi	r18, 0x01	; 1
    2f40:	30 f0       	brcs	.+12     	; 0x2f4e <DoSampler+0x51e>
    2f42:	22 30       	cpi	r18, 0x02	; 2
    2f44:	d9 f0       	breq	.+54     	; 0x2f7c <DoSampler+0x54c>
    2f46:	23 30       	cpi	r18, 0x03	; 3
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <DoSampler+0x51c>
    2f4a:	92 c2       	rjmp	.+1316   	; 0x3470 <DoSampler+0xa40>
    2f4c:	23 c0       	rjmp	.+70     	; 0x2f94 <DoSampler+0x564>
						{
							case 0:
							UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    2f4e:	82 e5       	ldi	r24, 0x52	; 82
    2f50:	98 e0       	ldi	r25, 0x08	; 8
    2f52:	90 93 7a 02 	sts	0x027A, r25
    2f56:	80 93 79 02 	sts	0x0279, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2f5a:	80 91 2c 01 	lds	r24, 0x012C
    2f5e:	64 e0       	ldi	r22, 0x04	; 4
    2f60:	46 e1       	ldi	r20, 0x16	; 22
    2f62:	15 c2       	rjmp	.+1066   	; 0x338e <DoSampler+0x95e>
							break;

							case 1:
							UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    2f64:	87 e0       	ldi	r24, 0x07	; 7
    2f66:	98 e0       	ldi	r25, 0x08	; 8
    2f68:	90 93 7a 02 	sts	0x027A, r25
    2f6c:	80 93 79 02 	sts	0x0279, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2f70:	80 91 2c 01 	lds	r24, 0x012C
    2f74:	64 e0       	ldi	r22, 0x04	; 4
    2f76:	46 e1       	ldi	r20, 0x16	; 22
    2f78:	21 e0       	ldi	r18, 0x01	; 1
    2f7a:	09 c2       	rjmp	.+1042   	; 0x338e <DoSampler+0x95e>
							break;
							
							case 2:
							UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    2f7c:	88 ec       	ldi	r24, 0xC8	; 200
    2f7e:	98 e0       	ldi	r25, 0x08	; 8
    2f80:	90 93 7a 02 	sts	0x027A, r25
    2f84:	80 93 79 02 	sts	0x0279, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2f88:	80 91 2c 01 	lds	r24, 0x012C
    2f8c:	64 e0       	ldi	r22, 0x04	; 4
    2f8e:	46 e1       	ldi	r20, 0x16	; 22
    2f90:	22 e0       	ldi	r18, 0x02	; 2
    2f92:	fd c1       	rjmp	.+1018   	; 0x338e <DoSampler+0x95e>
							break;
							
							case 3:
							UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    2f94:	88 e8       	ldi	r24, 0x88	; 136
    2f96:	98 e0       	ldi	r25, 0x08	; 8
    2f98:	90 93 7a 02 	sts	0x027A, r25
    2f9c:	80 93 79 02 	sts	0x0279, r24
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OUTPUT_COMBINATION,scaledEncoderValue);		// Send it out to the techno nerds.
    2fa0:	80 91 2c 01 	lds	r24, 0x012C
    2fa4:	64 e0       	ldi	r22, 0x04	; 4
    2fa6:	46 e1       	ldi	r20, 0x16	; 22
    2fa8:	23 e0       	ldi	r18, 0x03	; 3
    2faa:	f1 c1       	rjmp	.+994    	; 0x338e <DoSampler+0x95e>
					}
				}
			}
			else
			{
				if(newKeys&Im_REC)										// Record switch pressed.
    2fac:	90 91 3e 01 	lds	r25, 0x013E
    2fb0:	90 ff       	sbrs	r25, 0
    2fb2:	25 c0       	rjmp	.+74     	; 0x2ffe <DoSampler+0x5ce>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_RECORD)			// Were we recording already?
    2fb4:	20 91 2c 01 	lds	r18, 0x012C
    2fb8:	82 2f       	mov	r24, r18
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	35 e0       	ldi	r19, 0x05	; 5
    2fc0:	ee 0f       	add	r30, r30
    2fc2:	ff 1f       	adc	r31, r31
    2fc4:	3a 95       	dec	r19
    2fc6:	e1 f7       	brne	.-8      	; 0x2fc0 <DoSampler+0x590>
    2fc8:	88 0f       	add	r24, r24
    2fca:	99 1f       	adc	r25, r25
    2fcc:	e8 0f       	add	r30, r24
    2fce:	f9 1f       	adc	r31, r25
    2fd0:	e3 58       	subi	r30, 0x83	; 131
    2fd2:	fd 4f       	sbci	r31, 0xFD	; 253
    2fd4:	80 81       	ld	r24, Z
    2fd6:	83 30       	cpi	r24, 0x03	; 3
    2fd8:	39 f4       	brne	.+14     	; 0x2fe8 <DoSampler+0x5b8>
					{
						StartPlayback(currentBank,CLK_EXTERNAL,0);					// Begin playing back the loop we just recorded (ext clock)
    2fda:	82 2f       	mov	r24, r18
    2fdc:	61 e0       	ldi	r22, 0x01	; 1
    2fde:	40 e0       	ldi	r20, 0x00	; 0
    2fe0:	50 e0       	ldi	r21, 0x00	; 0
    2fe2:	0e 94 24 0c 	call	0x1848	; 0x1848 <StartPlayback>
    2fe6:	fe c0       	rjmp	.+508    	; 0x31e4 <DoSampler+0x7b4>
						bankStates[currentBank].loopOnce=false;
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.
					}
					else											// We're not recording right now, so start doing it.
					{
						StartRecording(currentBank,CLK_EXTERNAL,0);	// Start recording (ext clock)
    2fe8:	82 2f       	mov	r24, r18
    2fea:	61 e0       	ldi	r22, 0x01	; 1
    2fec:	40 e0       	ldi	r20, 0x00	; 0
    2fee:	50 e0       	ldi	r21, 0x00	; 0
    2ff0:	0e 94 55 0b 	call	0x16aa	; 0x16aa <StartRecording>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_RECORDING,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    2ff4:	80 91 2c 01 	lds	r24, 0x012C
    2ff8:	64 e0       	ldi	r22, 0x04	; 4
    2ffa:	43 e0       	ldi	r20, 0x03	; 3
    2ffc:	98 c0       	rjmp	.+304    	; 0x312e <DoSampler+0x6fe>
					}
				}

				else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
    2ffe:	91 ff       	sbrs	r25, 1
    3000:	98 c0       	rjmp	.+304    	; 0x3132 <DoSampler+0x702>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
    3002:	60 91 2c 01 	lds	r22, 0x012C
    3006:	86 2f       	mov	r24, r22
    3008:	90 e0       	ldi	r25, 0x00	; 0
    300a:	fc 01       	movw	r30, r24
    300c:	15 e0       	ldi	r17, 0x05	; 5
    300e:	ee 0f       	add	r30, r30
    3010:	ff 1f       	adc	r31, r31
    3012:	1a 95       	dec	r17
    3014:	e1 f7       	brne	.-8      	; 0x300e <DoSampler+0x5de>
    3016:	88 0f       	add	r24, r24
    3018:	99 1f       	adc	r25, r25
    301a:	e8 0f       	add	r30, r24
    301c:	f9 1f       	adc	r31, r25
    301e:	e3 58       	subi	r30, 0x83	; 131
    3020:	fd 4f       	sbci	r31, 0xFD	; 253
    3022:	80 81       	ld	r24, Z
    3024:	85 30       	cpi	r24, 0x05	; 5
    3026:	71 f5       	brne	.+92     	; 0x3084 <DoSampler+0x654>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    3028:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    302a:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    302c:	86 2f       	mov	r24, r22
    302e:	90 e0       	ldi	r25, 0x00	; 0
    3030:	fc 01       	movw	r30, r24
    3032:	a5 e0       	ldi	r26, 0x05	; 5
    3034:	ee 0f       	add	r30, r30
    3036:	ff 1f       	adc	r31, r31
    3038:	aa 95       	dec	r26
    303a:	e1 f7       	brne	.-8      	; 0x3034 <DoSampler+0x604>
    303c:	88 0f       	add	r24, r24
    303e:	99 1f       	adc	r25, r25
    3040:	e8 0f       	add	r30, r24
    3042:	f9 1f       	adc	r31, r25
    3044:	e3 58       	subi	r30, 0x83	; 131
    3046:	fd 4f       	sbci	r31, 0xFD	; 253
    3048:	84 e0       	ldi	r24, 0x04	; 4
    304a:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    304c:	86 2f       	mov	r24, r22
    304e:	61 e0       	ldi	r22, 0x01	; 1
    3050:	40 e0       	ldi	r20, 0x00	; 0
    3052:	50 e0       	ldi	r21, 0x00	; 0
    3054:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    3058:	1f bf       	out	0x3f, r17	; 63
				else if(newKeys&Im_ODUB)			// Overdub switch pressed.  Odub is similar to record except it takes its recording from a different analog input, and it cannot be invoked unless there is already a sample in the bank.
				{
					if(bankStates[currentBank].audioFunction==AUDIO_OVERDUB)		// Were we overdubbing already?
					{
						ContinuePlayback(currentBank,CLK_EXTERNAL,0);				// Begin playing back the loop we just recorded (ext clock, not from the beginning)
						bankStates[currentBank].loopOnce=false;
    305a:	80 91 2c 01 	lds	r24, 0x012C
    305e:	28 2f       	mov	r18, r24
    3060:	30 e0       	ldi	r19, 0x00	; 0
    3062:	f9 01       	movw	r30, r18
    3064:	55 e0       	ldi	r21, 0x05	; 5
    3066:	ee 0f       	add	r30, r30
    3068:	ff 1f       	adc	r31, r31
    306a:	5a 95       	dec	r21
    306c:	e1 f7       	brne	.-8      	; 0x3066 <DoSampler+0x636>
    306e:	22 0f       	add	r18, r18
    3070:	33 1f       	adc	r19, r19
    3072:	e2 0f       	add	r30, r18
    3074:	f3 1f       	adc	r31, r19
    3076:	e3 58       	subi	r30, 0x83	; 131
    3078:	fd 4f       	sbci	r31, 0xFD	; 253
    307a:	11 82       	std	Z+1, r1	; 0x01
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,0);		// Send it out to the techno nerds.
    307c:	64 e0       	ldi	r22, 0x04	; 4
    307e:	49 e0       	ldi	r20, 0x09	; 9
    3080:	20 e0       	ldi	r18, 0x00	; 0
    3082:	85 c1       	rjmp	.+778    	; 0x338e <DoSampler+0x95e>
					}
					else							// We're not recording right now, so start doing it.
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    3084:	86 2f       	mov	r24, r22
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	fc 01       	movw	r30, r24
    308a:	25 e0       	ldi	r18, 0x05	; 5
    308c:	ee 0f       	add	r30, r30
    308e:	ff 1f       	adc	r31, r31
    3090:	2a 95       	dec	r18
    3092:	e1 f7       	brne	.-8      	; 0x308c <DoSampler+0x65c>
    3094:	88 0f       	add	r24, r24
    3096:	99 1f       	adc	r25, r25
    3098:	e8 0f       	add	r30, r24
    309a:	f9 1f       	adc	r31, r25
    309c:	e3 58       	subi	r30, 0x83	; 131
    309e:	fd 4f       	sbci	r31, 0xFD	; 253
    30a0:	27 85       	ldd	r18, Z+15	; 0x0f
    30a2:	30 89       	ldd	r19, Z+16	; 0x10
    30a4:	41 89       	ldd	r20, Z+17	; 0x11
    30a6:	52 89       	ldd	r21, Z+18	; 0x12
    30a8:	86 2f       	mov	r24, r22
    30aa:	90 e0       	ldi	r25, 0x00	; 0
    30ac:	fc 01       	movw	r30, r24
    30ae:	15 e0       	ldi	r17, 0x05	; 5
    30b0:	ee 0f       	add	r30, r30
    30b2:	ff 1f       	adc	r31, r31
    30b4:	1a 95       	dec	r17
    30b6:	e1 f7       	brne	.-8      	; 0x30b0 <DoSampler+0x680>
    30b8:	88 0f       	add	r24, r24
    30ba:	99 1f       	adc	r25, r25
    30bc:	e8 0f       	add	r30, r24
    30be:	f9 1f       	adc	r31, r25
    30c0:	e3 58       	subi	r30, 0x83	; 131
    30c2:	fd 4f       	sbci	r31, 0xFD	; 253
    30c4:	83 85       	ldd	r24, Z+11	; 0x0b
    30c6:	94 85       	ldd	r25, Z+12	; 0x0c
    30c8:	a5 85       	ldd	r26, Z+13	; 0x0d
    30ca:	b6 85       	ldd	r27, Z+14	; 0x0e
    30cc:	28 17       	cp	r18, r24
    30ce:	39 07       	cpc	r19, r25
    30d0:	4a 07       	cpc	r20, r26
    30d2:	5b 07       	cpc	r21, r27
    30d4:	09 f4       	brne	.+2      	; 0x30d8 <DoSampler+0x6a8>
    30d6:	cc c1       	rjmp	.+920    	; 0x3470 <DoSampler+0xa40>
// Continue playing back from that address, too.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    30d8:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    30da:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    30dc:	86 2f       	mov	r24, r22
    30de:	90 e0       	ldi	r25, 0x00	; 0
    30e0:	fc 01       	movw	r30, r24
    30e2:	a5 e0       	ldi	r26, 0x05	; 5
    30e4:	ee 0f       	add	r30, r30
    30e6:	ff 1f       	adc	r31, r31
    30e8:	aa 95       	dec	r26
    30ea:	e1 f7       	brne	.-8      	; 0x30e4 <DoSampler+0x6b4>
    30ec:	88 0f       	add	r24, r24
    30ee:	99 1f       	adc	r25, r25
    30f0:	e8 0f       	add	r30, r24
    30f2:	f9 1f       	adc	r31, r25
    30f4:	e3 58       	subi	r30, 0x83	; 131
    30f6:	fd 4f       	sbci	r31, 0xFD	; 253
    30f8:	85 e0       	ldi	r24, 0x05	; 5
    30fa:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    30fc:	86 2f       	mov	r24, r22
    30fe:	61 e0       	ldi	r22, 0x01	; 1
    3100:	40 e0       	ldi	r20, 0x00	; 0
    3102:	50 e0       	ldi	r21, 0x00	; 0
    3104:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>
	SREG=sreg;		// Restore interrupts.
    3108:	1f bf       	out	0x3f, r17	; 63
// Throw out the results of an old conversion since it could be very old (unless it's already going)
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    310a:	80 91 7a 00 	lds	r24, 0x007A
    310e:	86 fd       	sbrc	r24, 6
    3110:	0a c0       	rjmp	.+20     	; 0x3126 <DoSampler+0x6f6>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    3112:	80 91 79 00 	lds	r24, 0x0079
    3116:	80 58       	subi	r24, 0x80	; 128
    3118:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    311c:	80 91 7a 00 	lds	r24, 0x007A
    3120:	80 64       	ori	r24, 0x40	; 64
    3122:	80 93 7a 00 	sts	0x007A, r24
					else							// We're not recording right now, so start doing it.
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
						{
							StartOverdub(currentBank,CLK_EXTERNAL,0);					// Get bizzy (ext clock).
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_OVERDUB,MIDI_GENERIC_NOTE);		// Send it out to the techno nerds.
    3126:	80 91 2c 01 	lds	r24, 0x012C
    312a:	64 e0       	ldi	r22, 0x04	; 4
    312c:	49 e0       	ldi	r20, 0x09	; 9
    312e:	20 e3       	ldi	r18, 0x30	; 48
    3130:	2e c1       	rjmp	.+604    	; 0x338e <DoSampler+0x95e>
						}
					}
				}
				else if(newKeys&Im_PLAY_PAUSE)		// Play / Pause switch pressed.  If anything is happening this will stop it.  Otherwise, this will start playing back AS A LOOP.  This will not restart a playing sample from the beginning.
    3132:	92 ff       	sbrs	r25, 2
    3134:	8e c0       	rjmp	.+284    	; 0x3252 <DoSampler+0x822>
				{
					if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
    3136:	60 91 2c 01 	lds	r22, 0x012C
    313a:	86 2f       	mov	r24, r22
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	fc 01       	movw	r30, r24
    3140:	55 e0       	ldi	r21, 0x05	; 5
    3142:	ee 0f       	add	r30, r30
    3144:	ff 1f       	adc	r31, r31
    3146:	5a 95       	dec	r21
    3148:	e1 f7       	brne	.-8      	; 0x3142 <DoSampler+0x712>
    314a:	88 0f       	add	r24, r24
    314c:	99 1f       	adc	r25, r25
    314e:	e8 0f       	add	r30, r24
    3150:	f9 1f       	adc	r31, r25
    3152:	e3 58       	subi	r30, 0x83	; 131
    3154:	fd 4f       	sbci	r31, 0xFD	; 253
    3156:	80 81       	ld	r24, Z
    3158:	88 23       	and	r24, r24
    315a:	09 f0       	breq	.+2      	; 0x315e <DoSampler+0x72e>
    315c:	58 c0       	rjmp	.+176    	; 0x320e <DoSampler+0x7de>
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    315e:	86 2f       	mov	r24, r22
    3160:	90 e0       	ldi	r25, 0x00	; 0
    3162:	fc 01       	movw	r30, r24
    3164:	35 e0       	ldi	r19, 0x05	; 5
    3166:	ee 0f       	add	r30, r30
    3168:	ff 1f       	adc	r31, r31
    316a:	3a 95       	dec	r19
    316c:	e1 f7       	brne	.-8      	; 0x3166 <DoSampler+0x736>
    316e:	88 0f       	add	r24, r24
    3170:	99 1f       	adc	r25, r25
    3172:	e8 0f       	add	r30, r24
    3174:	f9 1f       	adc	r31, r25
    3176:	e3 58       	subi	r30, 0x83	; 131
    3178:	fd 4f       	sbci	r31, 0xFD	; 253
    317a:	27 85       	ldd	r18, Z+15	; 0x0f
    317c:	30 89       	ldd	r19, Z+16	; 0x10
    317e:	41 89       	ldd	r20, Z+17	; 0x11
    3180:	52 89       	ldd	r21, Z+18	; 0x12
    3182:	86 2f       	mov	r24, r22
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	fc 01       	movw	r30, r24
    3188:	05 e0       	ldi	r16, 0x05	; 5
    318a:	ee 0f       	add	r30, r30
    318c:	ff 1f       	adc	r31, r31
    318e:	0a 95       	dec	r16
    3190:	e1 f7       	brne	.-8      	; 0x318a <DoSampler+0x75a>
    3192:	88 0f       	add	r24, r24
    3194:	99 1f       	adc	r25, r25
    3196:	e8 0f       	add	r30, r24
    3198:	f9 1f       	adc	r31, r25
    319a:	e3 58       	subi	r30, 0x83	; 131
    319c:	fd 4f       	sbci	r31, 0xFD	; 253
    319e:	83 85       	ldd	r24, Z+11	; 0x0b
    31a0:	94 85       	ldd	r25, Z+12	; 0x0c
    31a2:	a5 85       	ldd	r26, Z+13	; 0x0d
    31a4:	b6 85       	ldd	r27, Z+14	; 0x0e
    31a6:	28 17       	cp	r18, r24
    31a8:	39 07       	cpc	r19, r25
    31aa:	4a 07       	cpc	r20, r26
    31ac:	5b 07       	cpc	r21, r27
    31ae:	09 f4       	brne	.+2      	; 0x31b2 <DoSampler+0x782>
    31b0:	5f c1       	rjmp	.+702    	; 0x3470 <DoSampler+0xa40>
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    31b2:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    31b4:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    31b6:	86 2f       	mov	r24, r22
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	fc 01       	movw	r30, r24
    31bc:	b5 e0       	ldi	r27, 0x05	; 5
    31be:	ee 0f       	add	r30, r30
    31c0:	ff 1f       	adc	r31, r31
    31c2:	ba 95       	dec	r27
    31c4:	e1 f7       	brne	.-8      	; 0x31be <DoSampler+0x78e>
    31c6:	88 0f       	add	r24, r24
    31c8:	99 1f       	adc	r25, r25
    31ca:	e8 0f       	add	r30, r24
    31cc:	f9 1f       	adc	r31, r25
    31ce:	e3 58       	subi	r30, 0x83	; 131
    31d0:	fd 4f       	sbci	r31, 0xFD	; 253
    31d2:	84 e0       	ldi	r24, 0x04	; 4
    31d4:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    31d6:	86 2f       	mov	r24, r22
    31d8:	61 e0       	ldi	r22, 0x01	; 1
    31da:	40 e0       	ldi	r20, 0x00	; 0
    31dc:	50 e0       	ldi	r21, 0x00	; 0
    31de:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    31e2:	1f bf       	out	0x3f, r17	; 63
					if(bankStates[currentBank].audioFunction==AUDIO_IDLE)		// Doing nothing?
					{
						if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
						{
							ContinuePlayback(currentBank,CLK_EXTERNAL,0);			// Continue playing back from wherever we are in the sample memory (ext clock, not from the beginning) @@@ So as of now, this will begin playback at the END of a sample if we've just finished recording.  Ugly.
							bankStates[currentBank].loopOnce=false;
    31e4:	80 91 2c 01 	lds	r24, 0x012C
    31e8:	28 2f       	mov	r18, r24
    31ea:	30 e0       	ldi	r19, 0x00	; 0
    31ec:	f9 01       	movw	r30, r18
    31ee:	75 e0       	ldi	r23, 0x05	; 5
    31f0:	ee 0f       	add	r30, r30
    31f2:	ff 1f       	adc	r31, r31
    31f4:	7a 95       	dec	r23
    31f6:	e1 f7       	brne	.-8      	; 0x31f0 <DoSampler+0x7c0>
    31f8:	22 0f       	add	r18, r18
    31fa:	33 1f       	adc	r19, r19
    31fc:	e2 0f       	add	r30, r18
    31fe:	f3 1f       	adc	r31, r19
    3200:	e3 58       	subi	r30, 0x83	; 131
    3202:	fd 4f       	sbci	r31, 0xFD	; 253
    3204:	11 82       	std	Z+1, r1	; 0x01
							PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    3206:	61 e0       	ldi	r22, 0x01	; 1
    3208:	40 e3       	ldi	r20, 0x30	; 48
    320a:	20 e4       	ldi	r18, 0x40	; 64
    320c:	c0 c0       	rjmp	.+384    	; 0x338e <DoSampler+0x95e>
						}
					}
					else		// Pause whatever we were doing.
					{
						bankStates[currentBank].audioFunction=AUDIO_IDLE;		// Nothing to do in the ISR
    320e:	86 2f       	mov	r24, r22
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	fc 01       	movw	r30, r24
    3214:	55 e0       	ldi	r21, 0x05	; 5
    3216:	ee 0f       	add	r30, r30
    3218:	ff 1f       	adc	r31, r31
    321a:	5a 95       	dec	r21
    321c:	e1 f7       	brne	.-8      	; 0x3216 <DoSampler+0x7e6>
    321e:	88 0f       	add	r24, r24
    3220:	99 1f       	adc	r25, r25
    3222:	e8 0f       	add	r30, r24
    3224:	f9 1f       	adc	r31, r25
    3226:	e3 58       	subi	r30, 0x83	; 131
    3228:	fd 4f       	sbci	r31, 0xFD	; 253
    322a:	10 82       	st	Z, r1
						bankStates[currentBank].clockMode=CLK_NONE;				// Don't trigger this bank.
    322c:	86 2f       	mov	r24, r22
    322e:	90 e0       	ldi	r25, 0x00	; 0
    3230:	fc 01       	movw	r30, r24
    3232:	35 e0       	ldi	r19, 0x05	; 5
    3234:	ee 0f       	add	r30, r30
    3236:	ff 1f       	adc	r31, r31
    3238:	3a 95       	dec	r19
    323a:	e1 f7       	brne	.-8      	; 0x3234 <DoSampler+0x804>
    323c:	88 0f       	add	r24, r24
    323e:	99 1f       	adc	r25, r25
    3240:	e8 0f       	add	r30, r24
    3242:	f9 1f       	adc	r31, r25
    3244:	e3 58       	subi	r30, 0x83	; 131
    3246:	fd 4f       	sbci	r31, 0xFD	; 253
    3248:	10 86       	std	Z+8, r1	; 0x08
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_OFF,MIDI_GENERIC_NOTE,0);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
    324a:	86 2f       	mov	r24, r22
    324c:	62 e0       	ldi	r22, 0x02	; 2
    324e:	40 e3       	ldi	r20, 0x30	; 48
    3250:	17 cf       	rjmp	.-466    	; 0x3080 <DoSampler+0x650>
					}

				}
				else if(newKeys&Im_SINGLE_PLAY)		// Stop whatever we're doing and play the sample from the beginning, one time.
    3252:	93 ff       	sbrs	r25, 3
    3254:	44 c0       	rjmp	.+136    	; 0x32de <DoSampler+0x8ae>
				{
					if(bankStates[currentBank].startAddress!=bankStates[currentBank].endAddress)	// Do we have something to play?
    3256:	60 91 2c 01 	lds	r22, 0x012C
    325a:	86 2f       	mov	r24, r22
    325c:	90 e0       	ldi	r25, 0x00	; 0
    325e:	fc 01       	movw	r30, r24
    3260:	05 e0       	ldi	r16, 0x05	; 5
    3262:	ee 0f       	add	r30, r30
    3264:	ff 1f       	adc	r31, r31
    3266:	0a 95       	dec	r16
    3268:	e1 f7       	brne	.-8      	; 0x3262 <DoSampler+0x832>
    326a:	88 0f       	add	r24, r24
    326c:	99 1f       	adc	r25, r25
    326e:	e8 0f       	add	r30, r24
    3270:	f9 1f       	adc	r31, r25
    3272:	e3 58       	subi	r30, 0x83	; 131
    3274:	fd 4f       	sbci	r31, 0xFD	; 253
    3276:	27 85       	ldd	r18, Z+15	; 0x0f
    3278:	30 89       	ldd	r19, Z+16	; 0x10
    327a:	41 89       	ldd	r20, Z+17	; 0x11
    327c:	52 89       	ldd	r21, Z+18	; 0x12
    327e:	86 2f       	mov	r24, r22
    3280:	90 e0       	ldi	r25, 0x00	; 0
    3282:	fc 01       	movw	r30, r24
    3284:	a5 e0       	ldi	r26, 0x05	; 5
    3286:	ee 0f       	add	r30, r30
    3288:	ff 1f       	adc	r31, r31
    328a:	aa 95       	dec	r26
    328c:	e1 f7       	brne	.-8      	; 0x3286 <DoSampler+0x856>
    328e:	88 0f       	add	r24, r24
    3290:	99 1f       	adc	r25, r25
    3292:	e8 0f       	add	r30, r24
    3294:	f9 1f       	adc	r31, r25
    3296:	e3 58       	subi	r30, 0x83	; 131
    3298:	fd 4f       	sbci	r31, 0xFD	; 253
    329a:	83 85       	ldd	r24, Z+11	; 0x0b
    329c:	94 85       	ldd	r25, Z+12	; 0x0c
    329e:	a5 85       	ldd	r26, Z+13	; 0x0d
    32a0:	b6 85       	ldd	r27, Z+14	; 0x0e
    32a2:	28 17       	cp	r18, r24
    32a4:	39 07       	cpc	r19, r25
    32a6:	4a 07       	cpc	r20, r26
    32a8:	5b 07       	cpc	r21, r27
    32aa:	09 f4       	brne	.+2      	; 0x32ae <DoSampler+0x87e>
    32ac:	e1 c0       	rjmp	.+450    	; 0x3470 <DoSampler+0xa40>
					{
						StartPlayback(currentBank,CLK_EXTERNAL,0);			// Play back this sample.
    32ae:	86 2f       	mov	r24, r22
    32b0:	61 e0       	ldi	r22, 0x01	; 1
    32b2:	40 e0       	ldi	r20, 0x00	; 0
    32b4:	50 e0       	ldi	r21, 0x00	; 0
    32b6:	0e 94 24 0c 	call	0x1848	; 0x1848 <StartPlayback>
						bankStates[currentBank].loopOnce=true;				// And do it one time, for your mind.
    32ba:	80 91 2c 01 	lds	r24, 0x012C
    32be:	28 2f       	mov	r18, r24
    32c0:	30 e0       	ldi	r19, 0x00	; 0
    32c2:	f9 01       	movw	r30, r18
    32c4:	05 e0       	ldi	r16, 0x05	; 5
    32c6:	ee 0f       	add	r30, r30
    32c8:	ff 1f       	adc	r31, r31
    32ca:	0a 95       	dec	r16
    32cc:	e1 f7       	brne	.-8      	; 0x32c6 <DoSampler+0x896>
    32ce:	22 0f       	add	r18, r18
    32d0:	33 1f       	adc	r19, r19
    32d2:	e2 0f       	add	r30, r18
    32d4:	f3 1f       	adc	r31, r19
    32d6:	e3 58       	subi	r30, 0x83	; 131
    32d8:	fd 4f       	sbci	r31, 0xFD	; 253
    32da:	11 83       	std	Z+1, r17	; 0x01
    32dc:	94 cf       	rjmp	.-216    	; 0x3206 <DoSampler+0x7d6>
						PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_NOTE_ON,MIDI_GENERIC_NOTE,MIDI_GENERIC_VELOCITY);		// Send it out to the techno nerds.  @@@ This is wrong, but there's no concept of "continue" in the MIDI section.
					}				
				}
				else if(newKeys&Im_BANK)		// Increment through banks when this button is pressed.
    32de:	94 ff       	sbrs	r25, 4
    32e0:	0b c0       	rjmp	.+22     	; 0x32f8 <DoSampler+0x8c8>
				{
					currentBank++;
    32e2:	80 91 2c 01 	lds	r24, 0x012C
    32e6:	8f 5f       	subi	r24, 0xFF	; 255
    32e8:	80 93 2c 01 	sts	0x012C, r24
					if(currentBank>=NUM_BANKS)
    32ec:	82 30       	cpi	r24, 0x02	; 2
    32ee:	08 f4       	brcc	.+2      	; 0x32f2 <DoSampler+0x8c2>
    32f0:	bf c0       	rjmp	.+382    	; 0x3470 <DoSampler+0xa40>
					{
						currentBank=BANK_0;		// Loop around.
    32f2:	10 92 2c 01 	sts	0x012C, r1
    32f6:	bc c0       	rjmp	.+376    	; 0x3470 <DoSampler+0xa40>
					}
				}

// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Test flash storage
				
				else if(newKeys&Im_SWITCH_6)
    32f8:	96 ff       	sbrs	r25, 6
    32fa:	0e c0       	rjmp	.+28     	; 0x3318 <DoSampler+0x8e8>
				{
					if(IsFlashSlotFull(scaledEncoderValue))
    32fc:	80 91 43 01 	lds	r24, 0x0143
    3300:	0e 94 f5 24 	call	0x49ea	; 0x49ea <IsFlashSlotFull>
    3304:	88 23       	and	r24, r24
    3306:	09 f4       	brne	.+2      	; 0x330a <DoSampler+0x8da>
    3308:	b3 c0       	rjmp	.+358    	; 0x3470 <DoSampler+0xa40>
					{
						ReadSampleFromSlot(currentBank,scaledEncoderValue);	// Save in different slots.
    330a:	80 91 2c 01 	lds	r24, 0x012C
    330e:	60 91 43 01 	lds	r22, 0x0143
    3312:	0e 94 ba 26 	call	0x4d74	; 0x4d74 <ReadSampleFromSlot>
    3316:	ac c0       	rjmp	.+344    	; 0x3470 <DoSampler+0xa40>
					}
				}
				else if(newKeys&Im_SWITCH_7)
    3318:	97 ff       	sbrs	r25, 7
    331a:	aa c0       	rjmp	.+340    	; 0x3470 <DoSampler+0xa40>
				{
					WriteSampleToSlot(currentBank,scaledEncoderValue);
    331c:	80 91 2c 01 	lds	r24, 0x012C
    3320:	60 91 43 01 	lds	r22, 0x0143
    3324:	0e 94 0a 25 	call	0x4a14	; 0x4a14 <WriteSampleToSlot>
    3328:	a3 c0       	rjmp	.+326    	; 0x3470 <DoSampler+0xa40>
				}
			}
		}
		else	// In edit mode.
		{
			if(keyState&Im_SWITCH_0)		// Adjust start (three button combo)
    332a:	89 2f       	mov	r24, r25
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	80 ff       	sbrs	r24, 0
    3330:	31 c0       	rjmp	.+98     	; 0x3394 <DoSampler+0x964>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    3332:	20 91 2c 01 	lds	r18, 0x012C
    3336:	82 2f       	mov	r24, r18
    3338:	fc 01       	movw	r30, r24
    333a:	a5 e0       	ldi	r26, 0x05	; 5
    333c:	ee 0f       	add	r30, r30
    333e:	ff 1f       	adc	r31, r31
    3340:	aa 95       	dec	r26
    3342:	e1 f7       	brne	.-8      	; 0x333c <DoSampler+0x90c>
    3344:	88 0f       	add	r24, r24
    3346:	99 1f       	adc	r25, r25
    3348:	e8 0f       	add	r30, r24
    334a:	f9 1f       	adc	r31, r25
    334c:	e3 58       	subi	r30, 0x83	; 131
    334e:	fd 4f       	sbci	r31, 0xFD	; 253
    3350:	83 8d       	ldd	r24, Z+27	; 0x1b
    3352:	30 91 42 01 	lds	r19, 0x0142
    3356:	83 17       	cp	r24, r19
    3358:	09 f4       	brne	.+2      	; 0x335c <DoSampler+0x92c>
    335a:	8a c0       	rjmp	.+276    	; 0x3470 <DoSampler+0xa40>
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    335c:	82 2f       	mov	r24, r18
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	fc 01       	movw	r30, r24
    3362:	65 e0       	ldi	r22, 0x05	; 5
    3364:	ee 0f       	add	r30, r30
    3366:	ff 1f       	adc	r31, r31
    3368:	6a 95       	dec	r22
    336a:	e1 f7       	brne	.-8      	; 0x3364 <DoSampler+0x934>
    336c:	88 0f       	add	r24, r24
    336e:	99 1f       	adc	r25, r25
    3370:	e8 0f       	add	r30, r24
    3372:	f9 1f       	adc	r31, r25
    3374:	e3 58       	subi	r30, 0x83	; 131
    3376:	fd 4f       	sbci	r31, 0xFD	; 253
    3378:	33 8f       	std	Z+27, r19	; 0x1b
	UpdateAdjustedSampleAddresses(theBank);
    337a:	82 2f       	mov	r24, r18
    337c:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleStartOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleStart(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_START_WIDE,i);		// Send it out to the techno nerds.			
    3380:	20 91 42 01 	lds	r18, 0x0142
    3384:	26 95       	lsr	r18
    3386:	80 91 2c 01 	lds	r24, 0x012C
    338a:	64 e0       	ldi	r22, 0x04	; 4
    338c:	4c e1       	ldi	r20, 0x1C	; 28
    338e:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <PutMidiMessageInOutgoingFifo>
    3392:	6e c0       	rjmp	.+220    	; 0x3470 <DoSampler+0xa40>
				}
			}
			else if(keyState&Im_SWITCH_1)		// Adjust end (three button combo)
    3394:	81 ff       	sbrs	r24, 1
    3396:	30 c0       	rjmp	.+96     	; 0x33f8 <DoSampler+0x9c8>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    3398:	20 91 2c 01 	lds	r18, 0x012C
    339c:	82 2f       	mov	r24, r18
    339e:	90 e0       	ldi	r25, 0x00	; 0
    33a0:	fc 01       	movw	r30, r24
    33a2:	45 e0       	ldi	r20, 0x05	; 5
    33a4:	ee 0f       	add	r30, r30
    33a6:	ff 1f       	adc	r31, r31
    33a8:	4a 95       	dec	r20
    33aa:	e1 f7       	brne	.-8      	; 0x33a4 <DoSampler+0x974>
    33ac:	88 0f       	add	r24, r24
    33ae:	99 1f       	adc	r25, r25
    33b0:	e8 0f       	add	r30, r24
    33b2:	f9 1f       	adc	r31, r25
    33b4:	e3 58       	subi	r30, 0x83	; 131
    33b6:	fd 4f       	sbci	r31, 0xFD	; 253
    33b8:	84 8d       	ldd	r24, Z+28	; 0x1c
    33ba:	30 91 42 01 	lds	r19, 0x0142
    33be:	83 17       	cp	r24, r19
    33c0:	09 f4       	brne	.+2      	; 0x33c4 <DoSampler+0x994>
    33c2:	56 c0       	rjmp	.+172    	; 0x3470 <DoSampler+0xa40>
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    33c4:	82 2f       	mov	r24, r18
    33c6:	90 e0       	ldi	r25, 0x00	; 0
    33c8:	fc 01       	movw	r30, r24
    33ca:	05 e0       	ldi	r16, 0x05	; 5
    33cc:	ee 0f       	add	r30, r30
    33ce:	ff 1f       	adc	r31, r31
    33d0:	0a 95       	dec	r16
    33d2:	e1 f7       	brne	.-8      	; 0x33cc <DoSampler+0x99c>
    33d4:	88 0f       	add	r24, r24
    33d6:	99 1f       	adc	r25, r25
    33d8:	e8 0f       	add	r30, r24
    33da:	f9 1f       	adc	r31, r25
    33dc:	e3 58       	subi	r30, 0x83	; 131
    33de:	fd 4f       	sbci	r31, 0xFD	; 253
    33e0:	34 8f       	std	Z+28, r19	; 0x1c
	UpdateAdjustedSampleAddresses(theBank);
    33e2:	82 2f       	mov	r24, r18
    33e4:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleEndOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleEnd(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_END_WIDE,i);		// Send it out to the techno nerds.			
    33e8:	20 91 42 01 	lds	r18, 0x0142
    33ec:	26 95       	lsr	r18
    33ee:	80 91 2c 01 	lds	r24, 0x012C
    33f2:	64 e0       	ldi	r22, 0x04	; 4
    33f4:	4d e1       	ldi	r20, 0x1D	; 29
    33f6:	cb cf       	rjmp	.-106    	; 0x338e <DoSampler+0x95e>
				}
			}
			else if(keyState&Im_SWITCH_2)		// Adjust window (three button combo)
    33f8:	82 ff       	sbrs	r24, 2
    33fa:	2f c0       	rjmp	.+94     	; 0x345a <DoSampler+0xa2a>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
    33fc:	20 91 2c 01 	lds	r18, 0x012C
    3400:	82 2f       	mov	r24, r18
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	fc 01       	movw	r30, r24
    3406:	b5 e0       	ldi	r27, 0x05	; 5
    3408:	ee 0f       	add	r30, r30
    340a:	ff 1f       	adc	r31, r31
    340c:	ba 95       	dec	r27
    340e:	e1 f7       	brne	.-8      	; 0x3408 <DoSampler+0x9d8>
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	e8 0f       	add	r30, r24
    3416:	f9 1f       	adc	r31, r25
    3418:	e3 58       	subi	r30, 0x83	; 131
    341a:	fd 4f       	sbci	r31, 0xFD	; 253
    341c:	85 8d       	ldd	r24, Z+29	; 0x1d
    341e:	30 91 42 01 	lds	r19, 0x0142
    3422:	83 17       	cp	r24, r19
    3424:	29 f1       	breq	.+74     	; 0x3470 <DoSampler+0xa40>
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3426:	82 2f       	mov	r24, r18
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	fc 01       	movw	r30, r24
    342c:	75 e0       	ldi	r23, 0x05	; 5
    342e:	ee 0f       	add	r30, r30
    3430:	ff 1f       	adc	r31, r31
    3432:	7a 95       	dec	r23
    3434:	e1 f7       	brne	.-8      	; 0x342e <DoSampler+0x9fe>
    3436:	88 0f       	add	r24, r24
    3438:	99 1f       	adc	r25, r25
    343a:	e8 0f       	add	r30, r24
    343c:	f9 1f       	adc	r31, r25
    343e:	e3 58       	subi	r30, 0x83	; 131
    3440:	fd 4f       	sbci	r31, 0xFD	; 253
    3442:	35 8f       	std	Z+29, r19	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    3444:	82 2f       	mov	r24, r18
    3446:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <UpdateAdjustedSampleAddresses>
			{
				if(bankStates[currentBank].sampleWindowOffset!=encoderValue)	// Adjust in real time ONLY if we have an updated value.
				{
					AdjustSampleWindow(currentBank,encoderValue);
					i=encoderValue/2;		// Make into MIDI-worthy value (this will line up with the coarse adjust messages)
					PutMidiMessageInOutgoingFifo(currentBank,MESSAGE_TYPE_CONTROL_CHANGE,MIDI_ADJUST_SAMPLE_WINDOW_WIDE,i);		// Send it out to the techno nerds.			
    344a:	20 91 42 01 	lds	r18, 0x0142
    344e:	26 95       	lsr	r18
    3450:	80 91 2c 01 	lds	r24, 0x012C
    3454:	64 e0       	ldi	r22, 0x04	; 4
    3456:	4e e1       	ldi	r20, 0x1E	; 30
    3458:	9a cf       	rjmp	.-204    	; 0x338e <DoSampler+0x95e>
				}
			}
			else if(newKeys&Im_SWITCH_3||newKeys&Im_SWITCH_4||newKeys&Im_SWITCH_5)	// Non edit-mode key hit, bail from edit mode.
    345a:	80 91 3e 01 	lds	r24, 0x013E
    345e:	90 e0       	ldi	r25, 0x00	; 0
    3460:	83 fd       	sbrc	r24, 3
    3462:	04 c0       	rjmp	.+8      	; 0x346c <DoSampler+0xa3c>
    3464:	80 73       	andi	r24, 0x30	; 48
    3466:	90 70       	andi	r25, 0x00	; 0
    3468:	89 2b       	or	r24, r25
    346a:	11 f0       	breq	.+4      	; 0x3470 <DoSampler+0xa40>
			{
				editModeEntered=false;				
    346c:	10 92 25 01 	sts	0x0125, r1
			}		
		}
		
// Dealt with Caveman inputs, now deal with MIDI.

		if(midiMessagesInIncomingFifo)
    3470:	80 91 f5 02 	lds	r24, 0x02F5
    3474:	88 23       	and	r24, r24
    3476:	09 f4       	brne	.+2      	; 0x347a <DoSampler+0xa4a>
    3478:	49 c4       	rjmp	.+2194   	; 0x3d0c <DoSampler+0x12dc>
		{
			GetMidiMessageFromIncomingFifo(&currentMidiMessage);
    347a:	88 e2       	ldi	r24, 0x28	; 40
    347c:	91 e0       	ldi	r25, 0x01	; 1
    347e:	0e 94 cf 20 	call	0x419e	; 0x419e <GetMidiMessageFromIncomingFifo>
			if(currentMidiMessage.messageType==REAL_TIME_STUFF)
			{
				// Do this here.
			}
*/
			if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_OFF)		//  Note off.  Do it.  NOTE:  Our serial-to-midi functions handle turning velocity 0 NOTE_ON messages into NOTE_OFFs.
    3482:	80 91 29 01 	lds	r24, 0x0129
    3486:	82 30       	cpi	r24, 0x02	; 2
    3488:	89 f5       	brne	.+98     	; 0x34ec <DoSampler+0xabc>
			{
				if((bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_PLAYBACK)||(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME))	// Are we playing a sample to begin with, or running audio through in realtime?
    348a:	80 91 28 01 	lds	r24, 0x0128
    348e:	28 2f       	mov	r18, r24
    3490:	30 e0       	ldi	r19, 0x00	; 0
    3492:	f9 01       	movw	r30, r18
    3494:	ee 0f       	add	r30, r30
    3496:	ff 1f       	adc	r31, r31
    3498:	c9 01       	movw	r24, r18
    349a:	45 e0       	ldi	r20, 0x05	; 5
    349c:	88 0f       	add	r24, r24
    349e:	99 1f       	adc	r25, r25
    34a0:	4a 95       	dec	r20
    34a2:	e1 f7       	brne	.-8      	; 0x349c <DoSampler+0xa6c>
    34a4:	e8 0f       	add	r30, r24
    34a6:	f9 1f       	adc	r31, r25
    34a8:	e3 58       	subi	r30, 0x83	; 131
    34aa:	fd 4f       	sbci	r31, 0xFD	; 253
    34ac:	80 81       	ld	r24, Z
    34ae:	84 30       	cpi	r24, 0x04	; 4
    34b0:	21 f0       	breq	.+8      	; 0x34ba <DoSampler+0xa8a>
    34b2:	80 81       	ld	r24, Z
    34b4:	82 30       	cpi	r24, 0x02	; 2
    34b6:	09 f0       	breq	.+2      	; 0x34ba <DoSampler+0xa8a>
    34b8:	29 c4       	rjmp	.+2130   	; 0x3d0c <DoSampler+0x12dc>
				{
					if(currentMidiMessage.dataByteOne==currentNoteOn[currentMidiMessage.channelNumber])			// Sampler channels are mono.  Only turn off the last note we turned on.
    34ba:	f9 01       	movw	r30, r18
    34bc:	ec 5f       	subi	r30, 0xFC	; 252
    34be:	fe 4f       	sbci	r31, 0xFE	; 254
    34c0:	90 91 2a 01 	lds	r25, 0x012A
    34c4:	80 81       	ld	r24, Z
    34c6:	98 17       	cp	r25, r24
    34c8:	09 f0       	breq	.+2      	; 0x34cc <DoSampler+0xa9c>
    34ca:	20 c4       	rjmp	.+2112   	; 0x3d0c <DoSampler+0x12dc>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;	// Nothing to do in the ISR
    34cc:	f9 01       	movw	r30, r18
    34ce:	95 e0       	ldi	r25, 0x05	; 5
    34d0:	ee 0f       	add	r30, r30
    34d2:	ff 1f       	adc	r31, r31
    34d4:	9a 95       	dec	r25
    34d6:	e1 f7       	brne	.-8      	; 0x34d0 <DoSampler+0xaa0>
    34d8:	22 0f       	add	r18, r18
    34da:	33 1f       	adc	r19, r19
    34dc:	e2 0f       	add	r30, r18
    34de:	f3 1f       	adc	r31, r19
    34e0:	e3 58       	subi	r30, 0x83	; 131
    34e2:	fd 4f       	sbci	r31, 0xFD	; 253
    34e4:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;		// Don't trigger this bank.
    34e6:	80 91 28 01 	lds	r24, 0x0128
    34ea:	88 c0       	rjmp	.+272    	; 0x35fc <DoSampler+0xbcc>
					}
				}
			}
			else if(currentMidiMessage.messageType==MESSAGE_TYPE_NOTE_ON)		// Note on.
    34ec:	81 30       	cpi	r24, 0x01	; 1
    34ee:	e1 f5       	brne	.+120    	; 0x3568 <DoSampler+0xb38>
			{
				currentNoteOn[currentMidiMessage.channelNumber]=currentMidiMessage.dataByteOne;			// This is our new note.
    34f0:	10 91 28 01 	lds	r17, 0x0128
    34f4:	21 2f       	mov	r18, r17
    34f6:	30 e0       	ldi	r19, 0x00	; 0
    34f8:	f9 01       	movw	r30, r18
    34fa:	ec 5f       	subi	r30, 0xFC	; 252
    34fc:	fe 4f       	sbci	r31, 0xFE	; 254
    34fe:	60 91 2a 01 	lds	r22, 0x012A
    3502:	60 83       	st	Z, r22

				if(realtimeOn[currentMidiMessage.channelNumber])			// Real time sound editing?
    3504:	f9 01       	movw	r30, r18
    3506:	ea 5d       	subi	r30, 0xDA	; 218
    3508:	fe 4f       	sbci	r31, 0xFE	; 254
    350a:	80 81       	ld	r24, Z
    350c:	88 23       	and	r24, r24
    350e:	49 f0       	breq	.+18     	; 0x3522 <DoSampler+0xaf2>
				{
					StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// Yes, do realtime.		
    3510:	86 2f       	mov	r24, r22
    3512:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    3516:	ac 01       	movw	r20, r24
    3518:	81 2f       	mov	r24, r17
    351a:	62 e0       	ldi	r22, 0x02	; 2
    351c:	0e 94 ba 0c 	call	0x1974	; 0x1974 <StartRealtime>
    3520:	f5 c3       	rjmp	.+2026   	; 0x3d0c <DoSampler+0x12dc>
				}
				else
				{
					if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Something to play?
    3522:	f9 01       	movw	r30, r18
    3524:	05 e0       	ldi	r16, 0x05	; 5
    3526:	ee 0f       	add	r30, r30
    3528:	ff 1f       	adc	r31, r31
    352a:	0a 95       	dec	r16
    352c:	e1 f7       	brne	.-8      	; 0x3526 <DoSampler+0xaf6>
    352e:	22 0f       	add	r18, r18
    3530:	33 1f       	adc	r19, r19
    3532:	e2 0f       	add	r30, r18
    3534:	f3 1f       	adc	r31, r19
    3536:	e3 58       	subi	r30, 0x83	; 131
    3538:	fd 4f       	sbci	r31, 0xFD	; 253
    353a:	27 85       	ldd	r18, Z+15	; 0x0f
    353c:	30 89       	ldd	r19, Z+16	; 0x10
    353e:	41 89       	ldd	r20, Z+17	; 0x11
    3540:	52 89       	ldd	r21, Z+18	; 0x12
    3542:	83 85       	ldd	r24, Z+11	; 0x0b
    3544:	94 85       	ldd	r25, Z+12	; 0x0c
    3546:	a5 85       	ldd	r26, Z+13	; 0x0d
    3548:	b6 85       	ldd	r27, Z+14	; 0x0e
    354a:	28 17       	cp	r18, r24
    354c:	39 07       	cpc	r19, r25
    354e:	4a 07       	cpc	r20, r26
    3550:	5b 07       	cpc	r21, r27
    3552:	09 f4       	brne	.+2      	; 0x3556 <DoSampler+0xb26>
    3554:	db c3       	rjmp	.+1974   	; 0x3d0c <DoSampler+0x12dc>
					{
						StartPlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));	// No realtime, sample in memory, do playback.
    3556:	86 2f       	mov	r24, r22
    3558:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    355c:	ac 01       	movw	r20, r24
    355e:	81 2f       	mov	r24, r17
    3560:	62 e0       	ldi	r22, 0x02	; 2
    3562:	0e 94 24 0c 	call	0x1848	; 0x1848 <StartPlayback>
    3566:	d2 c3       	rjmp	.+1956   	; 0x3d0c <DoSampler+0x12dc>
					}
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_CONTROL_CHANGE)	// We use Control Change messages to give the sample non-note commands -- record, set jitter rate, etc.  Binary options (things with two choices, like backwards playback) just look for a 0 or non-zero value byte.
    3568:	84 30       	cpi	r24, 0x04	; 4
    356a:	09 f0       	breq	.+2      	; 0x356e <DoSampler+0xb3e>
    356c:	8a c3       	rjmp	.+1812   	; 0x3c82 <DoSampler+0x1252>
			{
				switch(currentMidiMessage.dataByteOne)
    356e:	80 91 2a 01 	lds	r24, 0x012A
    3572:	90 e0       	ldi	r25, 0x00	; 0
    3574:	fc 01       	movw	r30, r24
    3576:	33 97       	sbiw	r30, 0x03	; 3
    3578:	ec 31       	cpi	r30, 0x1C	; 28
    357a:	f1 05       	cpc	r31, r1
    357c:	08 f0       	brcs	.+2      	; 0x3580 <DoSampler+0xb50>
    357e:	c6 c3       	rjmp	.+1932   	; 0x3d0c <DoSampler+0x12dc>
    3580:	e2 5c       	subi	r30, 0xC2	; 194
    3582:	ff 4f       	sbci	r31, 0xFF	; 255
    3584:	ee 0f       	add	r30, r30
    3586:	ff 1f       	adc	r31, r31
    3588:	05 90       	lpm	r0, Z+
    358a:	f4 91       	lpm	r31, Z
    358c:	e0 2d       	mov	r30, r0
    358e:	09 94       	ijmp
				{
					case MIDI_RECORDING:						// Can re-start recording arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3590:	80 91 2b 01 	lds	r24, 0x012B
    3594:	88 23       	and	r24, r24
    3596:	71 f0       	breq	.+28     	; 0x35b4 <DoSampler+0xb84>
					{
						StartRecording(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);					// We set the record rate with this call.  Historically it's been note 60 (midi c4)
    3598:	80 91 28 01 	lds	r24, 0x0128
    359c:	e8 2f       	mov	r30, r24
    359e:	f0 e0       	ldi	r31, 0x00	; 0
    35a0:	ee 0f       	add	r30, r30
    35a2:	ff 1f       	adc	r31, r31
    35a4:	e4 5a       	subi	r30, 0xA4	; 164
    35a6:	fd 4f       	sbci	r31, 0xFD	; 253
    35a8:	40 81       	ld	r20, Z
    35aa:	51 81       	ldd	r21, Z+1	; 0x01
    35ac:	62 e0       	ldi	r22, 0x02	; 2
    35ae:	0e 94 55 0b 	call	0x16aa	; 0x16aa <StartRecording>
    35b2:	7f c0       	rjmp	.+254    	; 0x36b2 <DoSampler+0xc82>
						realtimeOn[currentMidiMessage.channelNumber]=false;													// We'll default to playback after a recording.	
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_RECORD)	// Must already be recording to stop.
    35b4:	20 91 28 01 	lds	r18, 0x0128
    35b8:	82 2f       	mov	r24, r18
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	fc 01       	movw	r30, r24
    35be:	75 e0       	ldi	r23, 0x05	; 5
    35c0:	ee 0f       	add	r30, r30
    35c2:	ff 1f       	adc	r31, r31
    35c4:	7a 95       	dec	r23
    35c6:	e1 f7       	brne	.-8      	; 0x35c0 <DoSampler+0xb90>
    35c8:	88 0f       	add	r24, r24
    35ca:	99 1f       	adc	r25, r25
    35cc:	e8 0f       	add	r30, r24
    35ce:	f9 1f       	adc	r31, r25
    35d0:	e3 58       	subi	r30, 0x83	; 131
    35d2:	fd 4f       	sbci	r31, 0xFD	; 253
    35d4:	80 81       	ld	r24, Z
    35d6:	83 30       	cpi	r24, 0x03	; 3
    35d8:	09 f0       	breq	.+2      	; 0x35dc <DoSampler+0xbac>
    35da:	98 c3       	rjmp	.+1840   	; 0x3d0c <DoSampler+0x12dc>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    35dc:	82 2f       	mov	r24, r18
    35de:	90 e0       	ldi	r25, 0x00	; 0
    35e0:	fc 01       	movw	r30, r24
    35e2:	55 e0       	ldi	r21, 0x05	; 5
    35e4:	ee 0f       	add	r30, r30
    35e6:	ff 1f       	adc	r31, r31
    35e8:	5a 95       	dec	r21
    35ea:	e1 f7       	brne	.-8      	; 0x35e4 <DoSampler+0xbb4>
    35ec:	88 0f       	add	r24, r24
    35ee:	99 1f       	adc	r25, r25
    35f0:	e8 0f       	add	r30, r24
    35f2:	f9 1f       	adc	r31, r25
    35f4:	e3 58       	subi	r30, 0x83	; 131
    35f6:	fd 4f       	sbci	r31, 0xFD	; 253
    35f8:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    35fa:	82 2f       	mov	r24, r18
    35fc:	90 e0       	ldi	r25, 0x00	; 0
    35fe:	fc 01       	movw	r30, r24
    3600:	35 e0       	ldi	r19, 0x05	; 5
    3602:	ee 0f       	add	r30, r30
    3604:	ff 1f       	adc	r31, r31
    3606:	3a 95       	dec	r19
    3608:	e1 f7       	brne	.-8      	; 0x3602 <DoSampler+0xbd2>
    360a:	88 0f       	add	r24, r24
    360c:	99 1f       	adc	r25, r25
    360e:	e8 0f       	add	r30, r24
    3610:	f9 1f       	adc	r31, r25
    3612:	e3 58       	subi	r30, 0x83	; 131
    3614:	fd 4f       	sbci	r31, 0xFD	; 253
    3616:	10 86       	std	Z+8, r1	; 0x08
    3618:	79 c3       	rjmp	.+1778   	; 0x3d0c <DoSampler+0x12dc>
					}
					break;

					case MIDI_OVERDUB:							// Can re-start overdubbing arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    361a:	80 91 2b 01 	lds	r24, 0x012B
    361e:	88 23       	and	r24, r24
    3620:	09 f4       	brne	.+2      	; 0x3624 <DoSampler+0xbf4>
    3622:	4a c0       	rjmp	.+148    	; 0x36b8 <DoSampler+0xc88>
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
    3624:	00 91 28 01 	lds	r16, 0x0128
    3628:	60 2f       	mov	r22, r16
    362a:	70 e0       	ldi	r23, 0x00	; 0
    362c:	fb 01       	movw	r30, r22
    362e:	ee 0f       	add	r30, r30
    3630:	ff 1f       	adc	r31, r31
    3632:	cb 01       	movw	r24, r22
    3634:	15 e0       	ldi	r17, 0x05	; 5
    3636:	88 0f       	add	r24, r24
    3638:	99 1f       	adc	r25, r25
    363a:	1a 95       	dec	r17
    363c:	e1 f7       	brne	.-8      	; 0x3636 <DoSampler+0xc06>
    363e:	e8 0f       	add	r30, r24
    3640:	f9 1f       	adc	r31, r25
    3642:	e3 58       	subi	r30, 0x83	; 131
    3644:	fd 4f       	sbci	r31, 0xFD	; 253
    3646:	27 85       	ldd	r18, Z+15	; 0x0f
    3648:	30 89       	ldd	r19, Z+16	; 0x10
    364a:	41 89       	ldd	r20, Z+17	; 0x11
    364c:	52 89       	ldd	r21, Z+18	; 0x12
    364e:	83 85       	ldd	r24, Z+11	; 0x0b
    3650:	94 85       	ldd	r25, Z+12	; 0x0c
    3652:	a5 85       	ldd	r26, Z+13	; 0x0d
    3654:	b6 85       	ldd	r27, Z+14	; 0x0e
    3656:	28 17       	cp	r18, r24
    3658:	39 07       	cpc	r19, r25
    365a:	4a 07       	cpc	r20, r26
    365c:	5b 07       	cpc	r21, r27
    365e:	09 f4       	brne	.+2      	; 0x3662 <DoSampler+0xc32>
    3660:	55 c3       	rjmp	.+1706   	; 0x3d0c <DoSampler+0x12dc>
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
    3662:	fb 01       	movw	r30, r22
    3664:	ec 5f       	subi	r30, 0xFC	; 252
    3666:	fe 4f       	sbci	r31, 0xFE	; 254
    3668:	40 81       	ld	r20, Z
// Continue playing back from that address, too.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    366a:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    366c:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_OVERDUB;	// What should we be doing when we get into the ISR?
    366e:	fb 01       	movw	r30, r22
    3670:	b5 e0       	ldi	r27, 0x05	; 5
    3672:	ee 0f       	add	r30, r30
    3674:	ff 1f       	adc	r31, r31
    3676:	ba 95       	dec	r27
    3678:	e1 f7       	brne	.-8      	; 0x3672 <DoSampler+0xc42>
    367a:	66 0f       	add	r22, r22
    367c:	77 1f       	adc	r23, r23
    367e:	e6 0f       	add	r30, r22
    3680:	f7 1f       	adc	r31, r23
    3682:	e3 58       	subi	r30, 0x83	; 131
    3684:	fd 4f       	sbci	r31, 0xFD	; 253
    3686:	85 e0       	ldi	r24, 0x05	; 5
    3688:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    368a:	80 2f       	mov	r24, r16
    368c:	62 e0       	ldi	r22, 0x02	; 2
    368e:	50 e0       	ldi	r21, 0x00	; 0
    3690:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>
	SREG=sreg;		// Restore interrupts.
    3694:	1f bf       	out	0x3f, r17	; 63
// Throw out the results of an old conversion since it could be very old (unless it's already going)
	if(!(ADCSRA&(1<<ADSC)))			// Last conversion done (note that once we start using different clock sources it's really possible to read this too often, so always check to make sure a conversion is done)
    3696:	80 91 7a 00 	lds	r24, 0x007A
    369a:	86 fd       	sbrc	r24, 6
    369c:	0a c0       	rjmp	.+20     	; 0x36b2 <DoSampler+0xc82>
	{
		adcByte=(ADCH^0x80);		// Update our ADC conversion variable.  If we're really flying or using both interrupt sources we may use this value more than once.  Make it a signed char.
    369e:	80 91 79 00 	lds	r24, 0x0079
    36a2:	80 58       	subi	r24, 0x80	; 128
    36a4:	80 93 56 02 	sts	0x0256, r24
		ADCSRA |= (1<<ADSC);  		// Start the next conversion.
    36a8:	80 91 7a 00 	lds	r24, 0x007A
    36ac:	80 64       	ori	r24, 0x40	; 64
    36ae:	80 93 7a 00 	sts	0x007A, r24
					if(currentMidiMessage.dataByteTwo)
					{
						if(bankStates[currentMidiMessage.channelNumber].startAddress!=bankStates[currentMidiMessage.channelNumber].endAddress)		// Because of how OVERDUB thinks about memory we can't do it unless you there's already a sample in the bank.
						{
							StartOverdub(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);			// We set the record rate with this call.  For ovverdub, we'll just set it equal to the last note played.
							realtimeOn[currentMidiMessage.channelNumber]=false;																		// We'll default to playback after a recording.	
    36b2:	e0 91 28 01 	lds	r30, 0x0128
    36b6:	7a c0       	rjmp	.+244    	; 0x37ac <DoSampler+0xd7c>
						}
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_OVERDUB)	// Must already be overdubbing to stop.
    36b8:	50 91 28 01 	lds	r21, 0x0128
    36bc:	25 2f       	mov	r18, r21
    36be:	30 e0       	ldi	r19, 0x00	; 0
    36c0:	f9 01       	movw	r30, r18
    36c2:	ee 0f       	add	r30, r30
    36c4:	ff 1f       	adc	r31, r31
    36c6:	c9 01       	movw	r24, r18
    36c8:	45 e0       	ldi	r20, 0x05	; 5
    36ca:	88 0f       	add	r24, r24
    36cc:	99 1f       	adc	r25, r25
    36ce:	4a 95       	dec	r20
    36d0:	e1 f7       	brne	.-8      	; 0x36ca <DoSampler+0xc9a>
    36d2:	e8 0f       	add	r30, r24
    36d4:	f9 1f       	adc	r31, r25
    36d6:	e3 58       	subi	r30, 0x83	; 131
    36d8:	fd 4f       	sbci	r31, 0xFD	; 253
    36da:	80 81       	ld	r24, Z
    36dc:	85 30       	cpi	r24, 0x05	; 5
    36de:	09 f0       	breq	.+2      	; 0x36e2 <DoSampler+0xcb2>
    36e0:	15 c3       	rjmp	.+1578   	; 0x3d0c <DoSampler+0x12dc>
					{
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
    36e2:	f9 01       	movw	r30, r18
    36e4:	ec 5f       	subi	r30, 0xFC	; 252
    36e6:	fe 4f       	sbci	r31, 0xFE	; 254
    36e8:	40 81       	ld	r20, Z
// Used if we pause playback and want to continue where we left off, or stop overdubbing and jump right back into playback.
{
	unsigned char
		sreg;

	sreg=SREG;	// Store global interrupt state.
    36ea:	1f b7       	in	r17, 0x3f	; 63
	cli();		// Disable interrupts while we muck with the settings.
    36ec:	f8 94       	cli

	bankStates[theBank].audioFunction=AUDIO_PLAYBACK;	// What should we be doing when we get into the ISR?
    36ee:	f9 01       	movw	r30, r18
    36f0:	85 e0       	ldi	r24, 0x05	; 5
    36f2:	ee 0f       	add	r30, r30
    36f4:	ff 1f       	adc	r31, r31
    36f6:	8a 95       	dec	r24
    36f8:	e1 f7       	brne	.-8      	; 0x36f2 <DoSampler+0xcc2>
    36fa:	22 0f       	add	r18, r18
    36fc:	33 1f       	adc	r19, r19
    36fe:	e2 0f       	add	r30, r18
    3700:	f3 1f       	adc	r31, r19
    3702:	e3 58       	subi	r30, 0x83	; 131
    3704:	fd 4f       	sbci	r31, 0xFD	; 253
    3706:	84 e0       	ldi	r24, 0x04	; 4
    3708:	80 83       	st	Z, r24
	SetSampleClock(theBank,theClock,theRate);			// Set the appropriate clock source for this audio function.
    370a:	85 2f       	mov	r24, r21
    370c:	62 e0       	ldi	r22, 0x02	; 2
    370e:	50 e0       	ldi	r21, 0x00	; 0
    3710:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>

	SREG=sreg;		// Restore interrupts.
    3714:	1f bf       	out	0x3f, r17	; 63
    3716:	fa c2       	rjmp	.+1524   	; 0x3d0c <DoSampler+0x12dc>
						ContinuePlayback(currentMidiMessage.channelNumber,CLK_INTERNAL,currentNoteOn[currentMidiMessage.channelNumber]);	// Begin playing back the loop we just recorded.
					}
					break;

					case MIDI_REALTIME:							// Can re-start realtime arbitrarily.
					if(currentMidiMessage.dataByteTwo)
    3718:	80 91 2b 01 	lds	r24, 0x012B
    371c:	88 23       	and	r24, r24
    371e:	99 f0       	breq	.+38     	; 0x3746 <DoSampler+0xd16>
					{
						StartRealtime(currentMidiMessage.channelNumber,CLK_INTERNAL,theMidiRecordRate[currentMidiMessage.channelNumber]);		// Set initial realtime rate.
    3720:	80 91 28 01 	lds	r24, 0x0128
    3724:	e8 2f       	mov	r30, r24
    3726:	f0 e0       	ldi	r31, 0x00	; 0
    3728:	ee 0f       	add	r30, r30
    372a:	ff 1f       	adc	r31, r31
    372c:	e4 5a       	subi	r30, 0xA4	; 164
    372e:	fd 4f       	sbci	r31, 0xFD	; 253
    3730:	40 81       	ld	r20, Z
    3732:	51 81       	ldd	r21, Z+1	; 0x01
    3734:	62 e0       	ldi	r22, 0x02	; 2
    3736:	0e 94 ba 0c 	call	0x1974	; 0x1974 <StartRealtime>
						realtimeOn[currentMidiMessage.channelNumber]=true;									// Set flag so that we don't stop realtime processing if we get a note off.
    373a:	e0 91 28 01 	lds	r30, 0x0128
    373e:	f0 e0       	ldi	r31, 0x00	; 0
    3740:	ea 5d       	subi	r30, 0xDA	; 218
    3742:	fe 4f       	sbci	r31, 0xFE	; 254
    3744:	71 c0       	rjmp	.+226    	; 0x3828 <DoSampler+0xdf8>
					}
					else if(bankStates[currentMidiMessage.channelNumber].audioFunction==AUDIO_REALTIME)	// Must be doing realtime to stop.
    3746:	20 91 28 01 	lds	r18, 0x0128
    374a:	82 2f       	mov	r24, r18
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	fc 01       	movw	r30, r24
    3750:	a5 e0       	ldi	r26, 0x05	; 5
    3752:	ee 0f       	add	r30, r30
    3754:	ff 1f       	adc	r31, r31
    3756:	aa 95       	dec	r26
    3758:	e1 f7       	brne	.-8      	; 0x3752 <DoSampler+0xd22>
    375a:	88 0f       	add	r24, r24
    375c:	99 1f       	adc	r25, r25
    375e:	e8 0f       	add	r30, r24
    3760:	f9 1f       	adc	r31, r25
    3762:	e3 58       	subi	r30, 0x83	; 131
    3764:	fd 4f       	sbci	r31, 0xFD	; 253
    3766:	80 81       	ld	r24, Z
    3768:	82 30       	cpi	r24, 0x02	; 2
    376a:	09 f0       	breq	.+2      	; 0x376e <DoSampler+0xd3e>
    376c:	cf c2       	rjmp	.+1438   	; 0x3d0c <DoSampler+0x12dc>
					{
						bankStates[currentMidiMessage.channelNumber].audioFunction=AUDIO_IDLE;			// Nothing to do in the ISR
    376e:	82 2f       	mov	r24, r18
    3770:	90 e0       	ldi	r25, 0x00	; 0
    3772:	fc 01       	movw	r30, r24
    3774:	65 e0       	ldi	r22, 0x05	; 5
    3776:	ee 0f       	add	r30, r30
    3778:	ff 1f       	adc	r31, r31
    377a:	6a 95       	dec	r22
    377c:	e1 f7       	brne	.-8      	; 0x3776 <DoSampler+0xd46>
    377e:	88 0f       	add	r24, r24
    3780:	99 1f       	adc	r25, r25
    3782:	e8 0f       	add	r30, r24
    3784:	f9 1f       	adc	r31, r25
    3786:	e3 58       	subi	r30, 0x83	; 131
    3788:	fd 4f       	sbci	r31, 0xFD	; 253
    378a:	10 82       	st	Z, r1
						bankStates[currentMidiMessage.channelNumber].clockMode=CLK_NONE;				// Don't trigger this bank.
    378c:	82 2f       	mov	r24, r18
    378e:	90 e0       	ldi	r25, 0x00	; 0
    3790:	fc 01       	movw	r30, r24
    3792:	45 e0       	ldi	r20, 0x05	; 5
    3794:	ee 0f       	add	r30, r30
    3796:	ff 1f       	adc	r31, r31
    3798:	4a 95       	dec	r20
    379a:	e1 f7       	brne	.-8      	; 0x3794 <DoSampler+0xd64>
    379c:	88 0f       	add	r24, r24
    379e:	99 1f       	adc	r25, r25
    37a0:	e8 0f       	add	r30, r24
    37a2:	f9 1f       	adc	r31, r25
    37a4:	e3 58       	subi	r30, 0x83	; 131
    37a6:	fd 4f       	sbci	r31, 0xFD	; 253
    37a8:	10 86       	std	Z+8, r1	; 0x08
						realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    37aa:	e2 2f       	mov	r30, r18
    37ac:	f0 e0       	ldi	r31, 0x00	; 0
    37ae:	ea 5d       	subi	r30, 0xDA	; 218
    37b0:	fe 4f       	sbci	r31, 0xFE	; 254
    37b2:	4c c0       	rjmp	.+152    	; 0x384c <DoSampler+0xe1c>
					}

					break;

					case MIDI_LOOP:							// Keep playing samples over again until note off.
					if(currentMidiMessage.dataByteTwo)
    37b4:	80 91 2b 01 	lds	r24, 0x012B
    37b8:	88 23       	and	r24, r24
    37ba:	89 f0       	breq	.+34     	; 0x37de <DoSampler+0xdae>
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    37bc:	80 91 28 01 	lds	r24, 0x0128
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	fc 01       	movw	r30, r24
    37c4:	05 e0       	ldi	r16, 0x05	; 5
    37c6:	ee 0f       	add	r30, r30
    37c8:	ff 1f       	adc	r31, r31
    37ca:	0a 95       	dec	r16
    37cc:	e1 f7       	brne	.-8      	; 0x37c6 <DoSampler+0xd96>
    37ce:	88 0f       	add	r24, r24
    37d0:	99 1f       	adc	r25, r25
    37d2:	e8 0f       	add	r30, r24
    37d4:	f9 1f       	adc	r31, r25
    37d6:	e3 58       	subi	r30, 0x83	; 131
    37d8:	fd 4f       	sbci	r31, 0xFD	; 253
    37da:	11 82       	std	Z+1, r1	; 0x01
    37dc:	97 c2       	rjmp	.+1326   	; 0x3d0c <DoSampler+0x12dc>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].loopOnce=true;
    37de:	80 91 28 01 	lds	r24, 0x0128
    37e2:	90 e0       	ldi	r25, 0x00	; 0
    37e4:	fc 01       	movw	r30, r24
    37e6:	b5 e0       	ldi	r27, 0x05	; 5
    37e8:	ee 0f       	add	r30, r30
    37ea:	ff 1f       	adc	r31, r31
    37ec:	ba 95       	dec	r27
    37ee:	e1 f7       	brne	.-8      	; 0x37e8 <DoSampler+0xdb8>
    37f0:	88 0f       	add	r24, r24
    37f2:	99 1f       	adc	r25, r25
    37f4:	e8 0f       	add	r30, r24
    37f6:	f9 1f       	adc	r31, r25
    37f8:	e3 58       	subi	r30, 0x83	; 131
    37fa:	fd 4f       	sbci	r31, 0xFD	; 253
    37fc:	81 e0       	ldi	r24, 0x01	; 1
    37fe:	81 83       	std	Z+1, r24	; 0x01
    3800:	85 c2       	rjmp	.+1290   	; 0x3d0c <DoSampler+0x12dc>
					}
					break;

					case MIDI_HALF_SPEED:							// Skrew and chop.
					if(currentMidiMessage.dataByteTwo)
    3802:	80 91 2b 01 	lds	r24, 0x012B
    3806:	88 23       	and	r24, r24
    3808:	91 f0       	breq	.+36     	; 0x382e <DoSampler+0xdfe>
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=true;
    380a:	80 91 28 01 	lds	r24, 0x0128
    380e:	90 e0       	ldi	r25, 0x00	; 0
    3810:	fc 01       	movw	r30, r24
    3812:	74 e0       	ldi	r23, 0x04	; 4
    3814:	ee 0f       	add	r30, r30
    3816:	ff 1f       	adc	r31, r31
    3818:	7a 95       	dec	r23
    381a:	e1 f7       	brne	.-8      	; 0x3814 <DoSampler+0xde4>
    381c:	e8 0f       	add	r30, r24
    381e:	f9 1f       	adc	r31, r25
    3820:	ee 0f       	add	r30, r30
    3822:	ff 1f       	adc	r31, r31
    3824:	e1 58       	subi	r30, 0x81	; 129
    3826:	fd 4f       	sbci	r31, 0xFD	; 253
    3828:	81 e0       	ldi	r24, 0x01	; 1
    382a:	80 83       	st	Z, r24
    382c:	6f c2       	rjmp	.+1246   	; 0x3d0c <DoSampler+0x12dc>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    382e:	80 91 28 01 	lds	r24, 0x0128
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	fc 01       	movw	r30, r24
    3836:	54 e0       	ldi	r21, 0x04	; 4
    3838:	ee 0f       	add	r30, r30
    383a:	ff 1f       	adc	r31, r31
    383c:	5a 95       	dec	r21
    383e:	e1 f7       	brne	.-8      	; 0x3838 <DoSampler+0xe08>
    3840:	e8 0f       	add	r30, r24
    3842:	f9 1f       	adc	r31, r25
    3844:	ee 0f       	add	r30, r30
    3846:	ff 1f       	adc	r31, r31
    3848:	e1 58       	subi	r30, 0x81	; 129
    384a:	fd 4f       	sbci	r31, 0xFD	; 253
    384c:	10 82       	st	Z, r1
    384e:	5e c2       	rjmp	.+1212   	; 0x3d0c <DoSampler+0x12dc>
					}
					break;

					case MIDI_PLAY_BACKWARDS:						// "Paul is Dead"
					if(currentMidiMessage.dataByteTwo)
    3850:	80 91 2b 01 	lds	r24, 0x012B
    3854:	88 23       	and	r24, r24
    3856:	91 f0       	breq	.+36     	; 0x387c <DoSampler+0xe4c>
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=true;
    3858:	80 91 28 01 	lds	r24, 0x0128
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	fc 01       	movw	r30, r24
    3860:	35 e0       	ldi	r19, 0x05	; 5
    3862:	ee 0f       	add	r30, r30
    3864:	ff 1f       	adc	r31, r31
    3866:	3a 95       	dec	r19
    3868:	e1 f7       	brne	.-8      	; 0x3862 <DoSampler+0xe32>
    386a:	88 0f       	add	r24, r24
    386c:	99 1f       	adc	r25, r25
    386e:	e8 0f       	add	r30, r24
    3870:	f9 1f       	adc	r31, r25
    3872:	e3 58       	subi	r30, 0x83	; 131
    3874:	fd 4f       	sbci	r31, 0xFD	; 253
    3876:	81 e0       	ldi	r24, 0x01	; 1
    3878:	83 83       	std	Z+3, r24	; 0x03
    387a:	10 c0       	rjmp	.+32     	; 0x389c <DoSampler+0xe6c>
					}
					else
					{
						bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;
    387c:	80 91 28 01 	lds	r24, 0x0128
    3880:	90 e0       	ldi	r25, 0x00	; 0
    3882:	fc 01       	movw	r30, r24
    3884:	05 e0       	ldi	r16, 0x05	; 5
    3886:	ee 0f       	add	r30, r30
    3888:	ff 1f       	adc	r31, r31
    388a:	0a 95       	dec	r16
    388c:	e1 f7       	brne	.-8      	; 0x3886 <DoSampler+0xe56>
    388e:	88 0f       	add	r24, r24
    3890:	99 1f       	adc	r25, r25
    3892:	e8 0f       	add	r30, r24
    3894:	f9 1f       	adc	r31, r25
    3896:	e3 58       	subi	r30, 0x83	; 131
    3898:	fd 4f       	sbci	r31, 0xFD	; 253
    389a:	13 82       	std	Z+3, r1	; 0x03
					}
					UpdateAdjustedSampleAddresses(currentMidiMessage.channelNumber);	// @@@ make sure we handle going backwards when considering edited samples.
    389c:	80 91 28 01 	lds	r24, 0x0128
    38a0:	ed c1       	rjmp	.+986    	; 0x3c7c <DoSampler+0x124c>
					break;

					case MIDI_CANCEL_EFFECTS:						// Escape from audio mess please.
					bankStates[currentMidiMessage.channelNumber].loopOnce=false;
    38a2:	20 91 28 01 	lds	r18, 0x0128
    38a6:	82 2f       	mov	r24, r18
    38a8:	90 e0       	ldi	r25, 0x00	; 0
    38aa:	fc 01       	movw	r30, r24
    38ac:	b5 e0       	ldi	r27, 0x05	; 5
    38ae:	ee 0f       	add	r30, r30
    38b0:	ff 1f       	adc	r31, r31
    38b2:	ba 95       	dec	r27
    38b4:	e1 f7       	brne	.-8      	; 0x38ae <DoSampler+0xe7e>
    38b6:	88 0f       	add	r24, r24
    38b8:	99 1f       	adc	r25, r25
    38ba:	e8 0f       	add	r30, r24
    38bc:	f9 1f       	adc	r31, r25
    38be:	e3 58       	subi	r30, 0x83	; 131
    38c0:	fd 4f       	sbci	r31, 0xFD	; 253
    38c2:	11 82       	std	Z+1, r1	; 0x01
					bankStates[currentMidiMessage.channelNumber].bitReduction=0;			// No crusties yet.
    38c4:	82 2f       	mov	r24, r18
    38c6:	90 e0       	ldi	r25, 0x00	; 0
    38c8:	fc 01       	movw	r30, r24
    38ca:	75 e0       	ldi	r23, 0x05	; 5
    38cc:	ee 0f       	add	r30, r30
    38ce:	ff 1f       	adc	r31, r31
    38d0:	7a 95       	dec	r23
    38d2:	e1 f7       	brne	.-8      	; 0x38cc <DoSampler+0xe9c>
    38d4:	88 0f       	add	r24, r24
    38d6:	99 1f       	adc	r25, r25
    38d8:	e8 0f       	add	r30, r24
    38da:	f9 1f       	adc	r31, r25
    38dc:	e3 58       	subi	r30, 0x83	; 131
    38de:	fd 4f       	sbci	r31, 0xFD	; 253
    38e0:	17 82       	std	Z+7, r1	; 0x07
					bankStates[currentMidiMessage.channelNumber].jitterValue=0;			// No hissies yet.
    38e2:	82 2f       	mov	r24, r18
    38e4:	90 e0       	ldi	r25, 0x00	; 0
    38e6:	fc 01       	movw	r30, r24
    38e8:	55 e0       	ldi	r21, 0x05	; 5
    38ea:	ee 0f       	add	r30, r30
    38ec:	ff 1f       	adc	r31, r31
    38ee:	5a 95       	dec	r21
    38f0:	e1 f7       	brne	.-8      	; 0x38ea <DoSampler+0xeba>
    38f2:	88 0f       	add	r24, r24
    38f4:	99 1f       	adc	r25, r25
    38f6:	e8 0f       	add	r30, r24
    38f8:	f9 1f       	adc	r31, r25
    38fa:	e3 58       	subi	r30, 0x83	; 131
    38fc:	fd 4f       	sbci	r31, 0xFD	; 253
    38fe:	16 82       	std	Z+6, r1	; 0x06
					bankStates[currentMidiMessage.channelNumber].granularSlices=0;		// No remix yet.
    3900:	82 2f       	mov	r24, r18
    3902:	90 e0       	ldi	r25, 0x00	; 0
    3904:	fc 01       	movw	r30, r24
    3906:	35 e0       	ldi	r19, 0x05	; 5
    3908:	ee 0f       	add	r30, r30
    390a:	ff 1f       	adc	r31, r31
    390c:	3a 95       	dec	r19
    390e:	e1 f7       	brne	.-8      	; 0x3908 <DoSampler+0xed8>
    3910:	88 0f       	add	r24, r24
    3912:	99 1f       	adc	r25, r25
    3914:	e8 0f       	add	r30, r24
    3916:	f9 1f       	adc	r31, r25
    3918:	e3 58       	subi	r30, 0x83	; 131
    391a:	fd 4f       	sbci	r31, 0xFD	; 253
    391c:	15 82       	std	Z+5, r1	; 0x05
					bankStates[currentMidiMessage.channelNumber].halfSpeed=false;
    391e:	a2 2f       	mov	r26, r18
    3920:	b0 e0       	ldi	r27, 0x00	; 0
    3922:	fd 01       	movw	r30, r26
    3924:	14 e0       	ldi	r17, 0x04	; 4
    3926:	ee 0f       	add	r30, r30
    3928:	ff 1f       	adc	r31, r31
    392a:	1a 95       	dec	r17
    392c:	e1 f7       	brne	.-8      	; 0x3926 <DoSampler+0xef6>
    392e:	ea 0f       	add	r30, r26
    3930:	fb 1f       	adc	r31, r27
    3932:	ee 0f       	add	r30, r30
    3934:	ff 1f       	adc	r31, r31
    3936:	e1 58       	subi	r30, 0x81	; 129
    3938:	fd 4f       	sbci	r31, 0xFD	; 253
    393a:	10 82       	st	Z, r1
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    393c:	82 2f       	mov	r24, r18
    393e:	90 e0       	ldi	r25, 0x00	; 0
    3940:	fc 01       	movw	r30, r24
    3942:	65 e0       	ldi	r22, 0x05	; 5
    3944:	ee 0f       	add	r30, r30
    3946:	ff 1f       	adc	r31, r31
    3948:	6a 95       	dec	r22
    394a:	e1 f7       	brne	.-8      	; 0x3944 <DoSampler+0xf14>
    394c:	88 0f       	add	r24, r24
    394e:	99 1f       	adc	r25, r25
    3950:	e8 0f       	add	r30, r24
    3952:	f9 1f       	adc	r31, r25
    3954:	e3 58       	subi	r30, 0x83	; 131
    3956:	fd 4f       	sbci	r31, 0xFD	; 253
    3958:	31 e0       	ldi	r19, 0x01	; 1
    395a:	34 83       	std	Z+4, r19	; 0x04
					bankStates[currentMidiMessage.channelNumber].backwardsPlayback=false;					
    395c:	82 2f       	mov	r24, r18
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	fc 01       	movw	r30, r24
    3962:	45 e0       	ldi	r20, 0x05	; 5
    3964:	ee 0f       	add	r30, r30
    3966:	ff 1f       	adc	r31, r31
    3968:	4a 95       	dec	r20
    396a:	e1 f7       	brne	.-8      	; 0x3964 <DoSampler+0xf34>
    396c:	88 0f       	add	r24, r24
    396e:	99 1f       	adc	r25, r25
    3970:	e8 0f       	add	r30, r24
    3972:	f9 1f       	adc	r31, r25
    3974:	e3 58       	subi	r30, 0x83	; 131
    3976:	fd 4f       	sbci	r31, 0xFD	; 253
    3978:	13 82       	std	Z+3, r1	; 0x03
					bankStates[currentMidiMessage.channelNumber].sampleDirection=true;					
    397a:	82 2f       	mov	r24, r18
    397c:	90 e0       	ldi	r25, 0x00	; 0
    397e:	fc 01       	movw	r30, r24
    3980:	15 e0       	ldi	r17, 0x05	; 5
    3982:	ee 0f       	add	r30, r30
    3984:	ff 1f       	adc	r31, r31
    3986:	1a 95       	dec	r17
    3988:	e1 f7       	brne	.-8      	; 0x3982 <DoSampler+0xf52>
    398a:	88 0f       	add	r24, r24
    398c:	99 1f       	adc	r25, r25
    398e:	e8 0f       	add	r30, r24
    3990:	f9 1f       	adc	r31, r25
    3992:	e3 58       	subi	r30, 0x83	; 131
    3994:	fd 4f       	sbci	r31, 0xFD	; 253
    3996:	34 83       	std	Z+4, r19	; 0x04
					realtimeOn[currentMidiMessage.channelNumber]=false;								// We'll default to playback.	
    3998:	aa 5d       	subi	r26, 0xDA	; 218
    399a:	be 4f       	sbci	r27, 0xFE	; 254
    399c:	1c 92       	st	X, r1
    399e:	3c c0       	rjmp	.+120    	; 0x3a18 <DoSampler+0xfe8>
					UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
					break;

					case MIDI_BIT_REDUCTION:					// Crustiness quotient.
					if(currentMidiMessage.dataByteTwo<8)
    39a0:	20 91 2b 01 	lds	r18, 0x012B
    39a4:	28 30       	cpi	r18, 0x08	; 8
    39a6:	08 f0       	brcs	.+2      	; 0x39aa <DoSampler+0xf7a>
    39a8:	b1 c1       	rjmp	.+866    	; 0x3d0c <DoSampler+0x12dc>
					{
						bankStates[currentMidiMessage.channelNumber].bitReduction=currentMidiMessage.dataByteTwo;				
    39aa:	80 91 28 01 	lds	r24, 0x0128
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	fc 01       	movw	r30, r24
    39b2:	65 e0       	ldi	r22, 0x05	; 5
    39b4:	ee 0f       	add	r30, r30
    39b6:	ff 1f       	adc	r31, r31
    39b8:	6a 95       	dec	r22
    39ba:	e1 f7       	brne	.-8      	; 0x39b4 <DoSampler+0xf84>
    39bc:	88 0f       	add	r24, r24
    39be:	99 1f       	adc	r25, r25
    39c0:	e8 0f       	add	r30, r24
    39c2:	f9 1f       	adc	r31, r25
    39c4:	e3 58       	subi	r30, 0x83	; 131
    39c6:	fd 4f       	sbci	r31, 0xFD	; 253
    39c8:	27 83       	std	Z+7, r18	; 0x07
    39ca:	a0 c1       	rjmp	.+832    	; 0x3d0c <DoSampler+0x12dc>
					}
					break;

					case MIDI_GRANULARITY:						// Beatbox.
					MakeNewGranularArray(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    39cc:	80 91 28 01 	lds	r24, 0x0128
    39d0:	60 91 2b 01 	lds	r22, 0x012B
    39d4:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <MakeNewGranularArray>
    39d8:	99 c1       	rjmp	.+818    	; 0x3d0c <DoSampler+0x12dc>
					break;

					case MIDI_JITTER:							// Hisssss
					bankStates[currentMidiMessage.channelNumber].jitterValue=currentMidiMessage.dataByteTwo;				
    39da:	80 91 2b 01 	lds	r24, 0x012B
    39de:	20 91 28 01 	lds	r18, 0x0128
    39e2:	30 e0       	ldi	r19, 0x00	; 0
    39e4:	f9 01       	movw	r30, r18
    39e6:	45 e0       	ldi	r20, 0x05	; 5
    39e8:	ee 0f       	add	r30, r30
    39ea:	ff 1f       	adc	r31, r31
    39ec:	4a 95       	dec	r20
    39ee:	e1 f7       	brne	.-8      	; 0x39e8 <DoSampler+0xfb8>
    39f0:	22 0f       	add	r18, r18
    39f2:	33 1f       	adc	r19, r19
    39f4:	e2 0f       	add	r30, r18
    39f6:	f3 1f       	adc	r31, r19
    39f8:	e3 58       	subi	r30, 0x83	; 131
    39fa:	fd 4f       	sbci	r31, 0xFD	; 253
    39fc:	86 83       	std	Z+6, r24	; 0x06
    39fe:	86 c1       	rjmp	.+780    	; 0x3d0c <DoSampler+0x12dc>
					break;

					case MIDI_OUTPUT_COMBINATION:				// Set the output (SUM, XOR, AND, MULT) with this message.
					switch(currentMidiMessage.dataByteTwo)
    3a00:	80 91 2b 01 	lds	r24, 0x012B
    3a04:	81 30       	cpi	r24, 0x01	; 1
    3a06:	59 f0       	breq	.+22     	; 0x3a1e <DoSampler+0xfee>
    3a08:	81 30       	cpi	r24, 0x01	; 1
    3a0a:	30 f0       	brcs	.+12     	; 0x3a18 <DoSampler+0xfe8>
    3a0c:	82 30       	cpi	r24, 0x02	; 2
    3a0e:	51 f0       	breq	.+20     	; 0x3a24 <DoSampler+0xff4>
    3a10:	83 30       	cpi	r24, 0x03	; 3
    3a12:	09 f0       	breq	.+2      	; 0x3a16 <DoSampler+0xfe6>
    3a14:	7b c1       	rjmp	.+758    	; 0x3d0c <DoSampler+0x12dc>
    3a16:	09 c0       	rjmp	.+18     	; 0x3a2a <DoSampler+0xffa>
					{
						case 0:
						UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3a18:	82 e5       	ldi	r24, 0x52	; 82
    3a1a:	98 e0       	ldi	r25, 0x08	; 8
    3a1c:	08 c0       	rjmp	.+16     	; 0x3a2e <DoSampler+0xffe>
						break;

						case 1:
						UpdateOutput=OutputMultiplyBanks;	// Set our output function pointer to call this type of combination.
    3a1e:	87 e0       	ldi	r24, 0x07	; 7
    3a20:	98 e0       	ldi	r25, 0x08	; 8
    3a22:	05 c0       	rjmp	.+10     	; 0x3a2e <DoSampler+0xffe>
						break;
						
						case 2:
						UpdateOutput=OutputAndBanks;	// Set our output function pointer to call this type of combination.
    3a24:	88 ec       	ldi	r24, 0xC8	; 200
    3a26:	98 e0       	ldi	r25, 0x08	; 8
    3a28:	02 c0       	rjmp	.+4      	; 0x3a2e <DoSampler+0xffe>
						break;
						
						case 3:
						UpdateOutput=OutputXorBanks;	// Set our output function pointer to call this type of combination.
    3a2a:	88 e8       	ldi	r24, 0x88	; 136
    3a2c:	98 e0       	ldi	r25, 0x08	; 8
    3a2e:	90 93 7a 02 	sts	0x027A, r25
    3a32:	80 93 79 02 	sts	0x0279, r24
    3a36:	6a c1       	rjmp	.+724    	; 0x3d0c <DoSampler+0x12dc>
						break;
					}
					break;

					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
    3a38:	cf b6       	in	r12, 0x3f	; 63
					cli();		// Disable interrupts while we write to eeprom.
    3a3a:	f8 94       	cli
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
    3a3c:	d0 90 28 01 	lds	r13, 0x0128
    3a40:	0d 2d       	mov	r16, r13
    3a42:	10 e0       	ldi	r17, 0x00	; 0
    3a44:	84 e0       	ldi	r24, 0x04	; 4
    3a46:	e8 2e       	mov	r14, r24
    3a48:	81 e0       	ldi	r24, 0x01	; 1
    3a4a:	f8 2e       	mov	r15, r24
    3a4c:	e0 0e       	add	r14, r16
    3a4e:	f1 1e       	adc	r15, r17
    3a50:	f7 01       	movw	r30, r14
    3a52:	80 81       	ld	r24, Z
    3a54:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    3a58:	00 0f       	add	r16, r16
    3a5a:	11 1f       	adc	r17, r17
    3a5c:	04 5a       	subi	r16, 0xA4	; 164
    3a5e:	1d 4f       	sbci	r17, 0xFD	; 253
    3a60:	f8 01       	movw	r30, r16
    3a62:	91 83       	std	Z+1, r25	; 0x01
    3a64:	80 83       	st	Z, r24
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
    3a66:	f7 01       	movw	r30, r14
    3a68:	60 81       	ld	r22, Z
// Display update stuff, housekeeping:

static void StoreMidiRecordNote(unsigned char theBank, unsigned char theNote)
// We store the note which corresponds to our record rate in the 7th and 11th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
    3a6a:	dd 20       	and	r13, r13
    3a6c:	19 f4       	brne	.+6      	; 0x3a74 <DoSampler+0x1044>
	{
		EepromWrite(7,theNote);	// Write the channel to EEPROM.
    3a6e:	87 e0       	ldi	r24, 0x07	; 7
    3a70:	90 e0       	ldi	r25, 0x00	; 0
    3a72:	05 c0       	rjmp	.+10     	; 0x3a7e <DoSampler+0x104e>
	}
	else if(theBank==BANK_1)
    3a74:	f1 e0       	ldi	r31, 0x01	; 1
    3a76:	df 16       	cp	r13, r31
    3a78:	21 f4       	brne	.+8      	; 0x3a82 <DoSampler+0x1052>
	{
		EepromWrite(11,theNote);	// Write the channel to EEPROM.
    3a7a:	8b e0       	ldi	r24, 0x0B	; 11
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	0e 94 5f 20 	call	0x40be	; 0x40be <EepromWrite>
					case MIDI_STORE_RECORD_NOTE:				// Turn the last note on into the note we always record at.
					i=SREG;
					cli();		// Disable interrupts while we write to eeprom.
					theMidiRecordRate[currentMidiMessage.channelNumber]=GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]);		// First get the proper note.
					StoreMidiRecordNote(currentMidiMessage.channelNumber,currentNoteOn[currentMidiMessage.channelNumber]);								// Put it in eeprom.
					SREG=i;		// Re-enable interrupts.
    3a82:	cf be       	out	0x3f, r12	; 63
    3a84:	43 c1       	rjmp	.+646    	; 0x3d0c <DoSampler+0x12dc>
					break;

//	Editing functions (resolute and wide are whether we want a MIDI step to correspond to 1 edit-sized chunk per increase in value or 2):

					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3a86:	80 91 28 01 	lds	r24, 0x0128
    3a8a:	90 91 2b 01 	lds	r25, 0x012B
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3a8e:	28 2f       	mov	r18, r24
    3a90:	30 e0       	ldi	r19, 0x00	; 0
    3a92:	f9 01       	movw	r30, r18
    3a94:	a5 e0       	ldi	r26, 0x05	; 5
    3a96:	ee 0f       	add	r30, r30
    3a98:	ff 1f       	adc	r31, r31
    3a9a:	aa 95       	dec	r26
    3a9c:	e1 f7       	brne	.-8      	; 0x3a96 <DoSampler+0x1066>
    3a9e:	22 0f       	add	r18, r18
    3aa0:	33 1f       	adc	r19, r19
    3aa2:	e2 0f       	add	r30, r18
    3aa4:	f3 1f       	adc	r31, r19
    3aa6:	e3 58       	subi	r30, 0x83	; 131
    3aa8:	fd 4f       	sbci	r31, 0xFD	; 253
    3aaa:	93 8f       	std	Z+27, r25	; 0x1b
    3aac:	e7 c0       	rjmp	.+462    	; 0x3c7c <DoSampler+0x124c>
					case MIDI_ADJUST_SAMPLE_START_RESOLUTE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3aae:	80 91 28 01 	lds	r24, 0x0128
    3ab2:	90 91 2b 01 	lds	r25, 0x012B
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3ab6:	28 2f       	mov	r18, r24
    3ab8:	30 e0       	ldi	r19, 0x00	; 0
    3aba:	f9 01       	movw	r30, r18
    3abc:	65 e0       	ldi	r22, 0x05	; 5
    3abe:	ee 0f       	add	r30, r30
    3ac0:	ff 1f       	adc	r31, r31
    3ac2:	6a 95       	dec	r22
    3ac4:	e1 f7       	brne	.-8      	; 0x3abe <DoSampler+0x108e>
    3ac6:	22 0f       	add	r18, r18
    3ac8:	33 1f       	adc	r19, r19
    3aca:	e2 0f       	add	r30, r18
    3acc:	f3 1f       	adc	r31, r19
    3ace:	e3 58       	subi	r30, 0x83	; 131
    3ad0:	fd 4f       	sbci	r31, 0xFD	; 253
    3ad2:	94 8f       	std	Z+28, r25	; 0x1c
    3ad4:	d3 c0       	rjmp	.+422    	; 0x3c7c <DoSampler+0x124c>
					case MIDI_ADJUST_SAMPLE_END_RESOLUTE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_RESOLUTE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,currentMidiMessage.dataByteTwo);
    3ad6:	80 91 28 01 	lds	r24, 0x0128
    3ada:	90 91 2b 01 	lds	r25, 0x012B
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3ade:	28 2f       	mov	r18, r24
    3ae0:	30 e0       	ldi	r19, 0x00	; 0
    3ae2:	f9 01       	movw	r30, r18
    3ae4:	45 e0       	ldi	r20, 0x05	; 5
    3ae6:	ee 0f       	add	r30, r30
    3ae8:	ff 1f       	adc	r31, r31
    3aea:	4a 95       	dec	r20
    3aec:	e1 f7       	brne	.-8      	; 0x3ae6 <DoSampler+0x10b6>
    3aee:	22 0f       	add	r18, r18
    3af0:	33 1f       	adc	r19, r19
    3af2:	e2 0f       	add	r30, r18
    3af4:	f3 1f       	adc	r31, r19
    3af6:	e3 58       	subi	r30, 0x83	; 131
    3af8:	fd 4f       	sbci	r31, 0xFD	; 253
    3afa:	95 8f       	std	Z+29, r25	; 0x1d
    3afc:	bf c0       	rjmp	.+382    	; 0x3c7c <DoSampler+0x124c>
// @@@ Mon Nov  9 22:52:08 EST 2009 -- Is this true?  Yes, I think so.
{
	unsigned char 
		sreg;
		
	sreg=SREG;
    3afe:	7f b7       	in	r23, 0x3f	; 63
	cli();			// Pause interrupts while we non-atomically mess with variables the ISR might be reading.
    3b00:	f8 94       	cli

	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    3b02:	60 91 28 01 	lds	r22, 0x0128
    3b06:	86 2f       	mov	r24, r22
    3b08:	90 e0       	ldi	r25, 0x00	; 0
    3b0a:	fc 01       	movw	r30, r24
    3b0c:	15 e0       	ldi	r17, 0x05	; 5
    3b0e:	ee 0f       	add	r30, r30
    3b10:	ff 1f       	adc	r31, r31
    3b12:	1a 95       	dec	r17
    3b14:	e1 f7       	brne	.-8      	; 0x3b0e <DoSampler+0x10de>
    3b16:	88 0f       	add	r24, r24
    3b18:	99 1f       	adc	r25, r25
    3b1a:	e8 0f       	add	r30, r24
    3b1c:	f9 1f       	adc	r31, r25
    3b1e:	e3 58       	subi	r30, 0x83	; 131
    3b20:	fd 4f       	sbci	r31, 0xFD	; 253
    3b22:	27 85       	ldd	r18, Z+15	; 0x0f
    3b24:	30 89       	ldd	r19, Z+16	; 0x10
    3b26:	41 89       	ldd	r20, Z+17	; 0x11
    3b28:	52 89       	ldd	r21, Z+18	; 0x12
    3b2a:	86 2f       	mov	r24, r22
    3b2c:	90 e0       	ldi	r25, 0x00	; 0
    3b2e:	fc 01       	movw	r30, r24
    3b30:	a5 e0       	ldi	r26, 0x05	; 5
    3b32:	ee 0f       	add	r30, r30
    3b34:	ff 1f       	adc	r31, r31
    3b36:	aa 95       	dec	r26
    3b38:	e1 f7       	brne	.-8      	; 0x3b32 <DoSampler+0x1102>
    3b3a:	88 0f       	add	r24, r24
    3b3c:	99 1f       	adc	r25, r25
    3b3e:	e8 0f       	add	r30, r24
    3b40:	f9 1f       	adc	r31, r25
    3b42:	e3 58       	subi	r30, 0x83	; 131
    3b44:	fd 4f       	sbci	r31, 0xFD	; 253
    3b46:	27 8b       	std	Z+23, r18	; 0x17
    3b48:	30 8f       	std	Z+24, r19	; 0x18
    3b4a:	41 8f       	std	Z+25, r20	; 0x19
    3b4c:	52 8f       	std	Z+26, r21	; 0x1a
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].endAddress;
    3b4e:	86 2f       	mov	r24, r22
    3b50:	90 e0       	ldi	r25, 0x00	; 0
    3b52:	fc 01       	movw	r30, r24
    3b54:	15 e0       	ldi	r17, 0x05	; 5
    3b56:	ee 0f       	add	r30, r30
    3b58:	ff 1f       	adc	r31, r31
    3b5a:	1a 95       	dec	r17
    3b5c:	e1 f7       	brne	.-8      	; 0x3b56 <DoSampler+0x1126>
    3b5e:	88 0f       	add	r24, r24
    3b60:	99 1f       	adc	r25, r25
    3b62:	e8 0f       	add	r30, r24
    3b64:	f9 1f       	adc	r31, r25
    3b66:	e3 58       	subi	r30, 0x83	; 131
    3b68:	fd 4f       	sbci	r31, 0xFD	; 253
    3b6a:	23 85       	ldd	r18, Z+11	; 0x0b
    3b6c:	34 85       	ldd	r19, Z+12	; 0x0c
    3b6e:	45 85       	ldd	r20, Z+13	; 0x0d
    3b70:	56 85       	ldd	r21, Z+14	; 0x0e
    3b72:	86 2f       	mov	r24, r22
    3b74:	90 e0       	ldi	r25, 0x00	; 0
    3b76:	fc 01       	movw	r30, r24
    3b78:	a5 e0       	ldi	r26, 0x05	; 5
    3b7a:	ee 0f       	add	r30, r30
    3b7c:	ff 1f       	adc	r31, r31
    3b7e:	aa 95       	dec	r26
    3b80:	e1 f7       	brne	.-8      	; 0x3b7a <DoSampler+0x114a>
    3b82:	88 0f       	add	r24, r24
    3b84:	99 1f       	adc	r25, r25
    3b86:	e8 0f       	add	r30, r24
    3b88:	f9 1f       	adc	r31, r25
    3b8a:	e3 58       	subi	r30, 0x83	; 131
    3b8c:	fd 4f       	sbci	r31, 0xFD	; 253
    3b8e:	23 8b       	std	Z+19, r18	; 0x13
    3b90:	34 8b       	std	Z+20, r19	; 0x14
    3b92:	45 8b       	std	Z+21, r20	; 0x15
    3b94:	56 8b       	std	Z+22, r21	; 0x16
	bankStates[theBank].sampleStartOffset=0;
    3b96:	86 2f       	mov	r24, r22
    3b98:	90 e0       	ldi	r25, 0x00	; 0
    3b9a:	fc 01       	movw	r30, r24
    3b9c:	15 e0       	ldi	r17, 0x05	; 5
    3b9e:	ee 0f       	add	r30, r30
    3ba0:	ff 1f       	adc	r31, r31
    3ba2:	1a 95       	dec	r17
    3ba4:	e1 f7       	brne	.-8      	; 0x3b9e <DoSampler+0x116e>
    3ba6:	88 0f       	add	r24, r24
    3ba8:	99 1f       	adc	r25, r25
    3baa:	e8 0f       	add	r30, r24
    3bac:	f9 1f       	adc	r31, r25
    3bae:	e3 58       	subi	r30, 0x83	; 131
    3bb0:	fd 4f       	sbci	r31, 0xFD	; 253
    3bb2:	13 8e       	std	Z+27, r1	; 0x1b
	bankStates[theBank].sampleEndOffset=0;
    3bb4:	86 2f       	mov	r24, r22
    3bb6:	90 e0       	ldi	r25, 0x00	; 0
    3bb8:	fc 01       	movw	r30, r24
    3bba:	a5 e0       	ldi	r26, 0x05	; 5
    3bbc:	ee 0f       	add	r30, r30
    3bbe:	ff 1f       	adc	r31, r31
    3bc0:	aa 95       	dec	r26
    3bc2:	e1 f7       	brne	.-8      	; 0x3bbc <DoSampler+0x118c>
    3bc4:	88 0f       	add	r24, r24
    3bc6:	99 1f       	adc	r25, r25
    3bc8:	e8 0f       	add	r30, r24
    3bca:	f9 1f       	adc	r31, r25
    3bcc:	e3 58       	subi	r30, 0x83	; 131
    3bce:	fd 4f       	sbci	r31, 0xFD	; 253
    3bd0:	14 8e       	std	Z+28, r1	; 0x1c
	bankStates[theBank].sampleWindowOffset=0;
    3bd2:	86 2f       	mov	r24, r22
    3bd4:	90 e0       	ldi	r25, 0x00	; 0
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	45 e0       	ldi	r20, 0x05	; 5
    3bda:	ee 0f       	add	r30, r30
    3bdc:	ff 1f       	adc	r31, r31
    3bde:	4a 95       	dec	r20
    3be0:	e1 f7       	brne	.-8      	; 0x3bda <DoSampler+0x11aa>
    3be2:	88 0f       	add	r24, r24
    3be4:	99 1f       	adc	r25, r25
    3be6:	e8 0f       	add	r30, r24
    3be8:	f9 1f       	adc	r31, r25
    3bea:	e3 58       	subi	r30, 0x83	; 131
    3bec:	fd 4f       	sbci	r31, 0xFD	; 253
    3bee:	15 8e       	std	Z+29, r1	; 0x1d
	SREG=sreg;		// Restore interrupts.
    3bf0:	7f bf       	out	0x3f, r23	; 63
    3bf2:	8c c0       	rjmp	.+280    	; 0x3d0c <DoSampler+0x12dc>
					case MIDI_REVERT_SAMPLE_TO_FULL:						
					RevertSampleToUnadjusted(currentMidiMessage.channelNumber);
					break;

					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3bf4:	80 91 28 01 	lds	r24, 0x0128
    3bf8:	40 91 2b 01 	lds	r20, 0x012B
    3bfc:	50 e0       	ldi	r21, 0x00	; 0
    3bfe:	44 0f       	add	r20, r20
    3c00:	55 1f       	adc	r21, r21
static void AdjustSampleStart(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample begins (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleStartOffset=theAmount;	// Store this for real.
    3c02:	28 2f       	mov	r18, r24
    3c04:	30 e0       	ldi	r19, 0x00	; 0
    3c06:	f9 01       	movw	r30, r18
    3c08:	95 e0       	ldi	r25, 0x05	; 5
    3c0a:	ee 0f       	add	r30, r30
    3c0c:	ff 1f       	adc	r31, r31
    3c0e:	9a 95       	dec	r25
    3c10:	e1 f7       	brne	.-8      	; 0x3c0a <DoSampler+0x11da>
    3c12:	22 0f       	add	r18, r18
    3c14:	33 1f       	adc	r19, r19
    3c16:	e2 0f       	add	r30, r18
    3c18:	f3 1f       	adc	r31, r19
    3c1a:	e3 58       	subi	r30, 0x83	; 131
    3c1c:	fd 4f       	sbci	r31, 0xFD	; 253
    3c1e:	43 8f       	std	Z+27, r20	; 0x1b
    3c20:	2d c0       	rjmp	.+90     	; 0x3c7c <DoSampler+0x124c>
					case MIDI_ADJUST_SAMPLE_START_WIDE:						
					AdjustSampleStart(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3c22:	80 91 28 01 	lds	r24, 0x0128
    3c26:	40 91 2b 01 	lds	r20, 0x012B
    3c2a:	50 e0       	ldi	r21, 0x00	; 0
    3c2c:	44 0f       	add	r20, r20
    3c2e:	55 1f       	adc	r21, r21
static void AdjustSampleEnd(unsigned char theBank, unsigned char theAmount)
// Moves the memory location where the sample ENDS (or loops) playback farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleEndOffset=theAmount;	// Store this for real.
    3c30:	28 2f       	mov	r18, r24
    3c32:	30 e0       	ldi	r19, 0x00	; 0
    3c34:	f9 01       	movw	r30, r18
    3c36:	b5 e0       	ldi	r27, 0x05	; 5
    3c38:	ee 0f       	add	r30, r30
    3c3a:	ff 1f       	adc	r31, r31
    3c3c:	ba 95       	dec	r27
    3c3e:	e1 f7       	brne	.-8      	; 0x3c38 <DoSampler+0x1208>
    3c40:	22 0f       	add	r18, r18
    3c42:	33 1f       	adc	r19, r19
    3c44:	e2 0f       	add	r30, r18
    3c46:	f3 1f       	adc	r31, r19
    3c48:	e3 58       	subi	r30, 0x83	; 131
    3c4a:	fd 4f       	sbci	r31, 0xFD	; 253
    3c4c:	44 8f       	std	Z+28, r20	; 0x1c
    3c4e:	16 c0       	rjmp	.+44     	; 0x3c7c <DoSampler+0x124c>
					case MIDI_ADJUST_SAMPLE_END_WIDE:						
					AdjustSampleEnd(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
					break;

					case MIDI_ADJUST_SAMPLE_WINDOW_WIDE:						
					AdjustSampleWindow(currentMidiMessage.channelNumber,(currentMidiMessage.dataByteTwo*2));
    3c50:	80 91 28 01 	lds	r24, 0x0128
    3c54:	40 91 2b 01 	lds	r20, 0x012B
    3c58:	50 e0       	ldi	r21, 0x00	; 0
    3c5a:	44 0f       	add	r20, r20
    3c5c:	55 1f       	adc	r21, r21
static void AdjustSampleWindow(unsigned char theBank, unsigned char theAmount)
// Shuttles the entire adjusted sample window farther into the sample.
// This divides the current sample size by the value of an unsigned char and places the new boundary according to the value passed.
// Note:  If the current sample address is out of the new range, this will pull it in.
{		
	bankStates[theBank].sampleWindowOffset=theAmount;	// Store this for real.
    3c5e:	28 2f       	mov	r18, r24
    3c60:	30 e0       	ldi	r19, 0x00	; 0
    3c62:	f9 01       	movw	r30, r18
    3c64:	65 e0       	ldi	r22, 0x05	; 5
    3c66:	ee 0f       	add	r30, r30
    3c68:	ff 1f       	adc	r31, r31
    3c6a:	6a 95       	dec	r22
    3c6c:	e1 f7       	brne	.-8      	; 0x3c66 <DoSampler+0x1236>
    3c6e:	22 0f       	add	r18, r18
    3c70:	33 1f       	adc	r19, r19
    3c72:	e2 0f       	add	r30, r18
    3c74:	f3 1f       	adc	r31, r19
    3c76:	e3 58       	subi	r30, 0x83	; 131
    3c78:	fd 4f       	sbci	r31, 0xFD	; 253
    3c7a:	45 8f       	std	Z+29, r20	; 0x1d
	UpdateAdjustedSampleAddresses(theBank);
    3c7c:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <UpdateAdjustedSampleAddresses>
    3c80:	45 c0       	rjmp	.+138    	; 0x3d0c <DoSampler+0x12dc>
					default:
					break;
				}
			}

			else if(currentMidiMessage.messageType==MESSAGE_TYPE_PITCH_WHEEL)		// @@@ ought to make this into signed data also?
    3c82:	87 30       	cpi	r24, 0x07	; 7
    3c84:	09 f0       	breq	.+2      	; 0x3c88 <DoSampler+0x1258>
    3c86:	42 c0       	rjmp	.+132    	; 0x3d0c <DoSampler+0x12dc>
			{
				pitchWheelValue=((currentMidiMessage.dataByteTwo<<7)+currentMidiMessage.dataByteOne);		// Turn the two data bytes into a single 14-bit number (that's how pitch wheel rolls).
    3c88:	80 91 2b 01 	lds	r24, 0x012B
    3c8c:	c8 2f       	mov	r28, r24
    3c8e:	d0 e0       	ldi	r29, 0x00	; 0
    3c90:	d6 95       	lsr	r29
    3c92:	dc 2f       	mov	r29, r28
    3c94:	cc 27       	eor	r28, r28
    3c96:	d7 95       	ror	r29
    3c98:	c7 95       	ror	r28
    3c9a:	80 91 2a 01 	lds	r24, 0x012A
    3c9e:	c8 0f       	add	r28, r24
    3ca0:	d1 1d       	adc	r29, r1

				if(pitchWheelValue!=0x2000)		// Pitch wheel being wanked?
    3ca2:	80 e2       	ldi	r24, 0x20	; 32
    3ca4:	c0 30       	cpi	r28, 0x00	; 0
    3ca6:	d8 07       	cpc	r29, r24
    3ca8:	d1 f0       	breq	.+52     	; 0x3cde <DoSampler+0x12ae>
    3caa:	00 91 28 01 	lds	r16, 0x0128
				{
					if(pitchWheelValue<0x2000)	// Lower the note by some amount (add value to the OCR1A).	@@@ This wraps around 0 but it sounds cool, sort of.
    3cae:	e0 e2       	ldi	r30, 0x20	; 32
    3cb0:	c0 30       	cpi	r28, 0x00	; 0
    3cb2:	de 07       	cpc	r29, r30
    3cb4:	40 f4       	brcc	.+16     	; 0x3cc6 <DoSampler+0x1296>
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])+(0x2000-pitchWheelValue));
    3cb6:	10 e0       	ldi	r17, 0x00	; 0
    3cb8:	f8 01       	movw	r30, r16
    3cba:	ec 5f       	subi	r30, 0xFC	; 252
    3cbc:	fe 4f       	sbci	r31, 0xFE	; 254
    3cbe:	80 81       	ld	r24, Z
    3cc0:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    3cc4:	07 c0       	rjmp	.+14     	; 0x3cd4 <DoSampler+0x12a4>
					}
					else						// Pitch the note by some amount (add value to the OCR1A).
					{
						bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber])-(pitchWheelValue-0x2000));
    3cc6:	10 e0       	ldi	r17, 0x00	; 0
    3cc8:	f8 01       	movw	r30, r16
    3cca:	ec 5f       	subi	r30, 0xFC	; 252
    3ccc:	fe 4f       	sbci	r31, 0xFE	; 254
    3cce:	80 81       	ld	r24, Z
    3cd0:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    3cd4:	80 50       	subi	r24, 0x00	; 0
    3cd6:	90 4e       	sbci	r25, 0xE0	; 224
    3cd8:	8c 1b       	sub	r24, r28
    3cda:	9d 0b       	sbc	r25, r29
    3cdc:	09 c0       	rjmp	.+18     	; 0x3cf0 <DoSampler+0x12c0>
					}
				}
				else
				{
					bankStates[currentMidiMessage.channelNumber].timerCyclesForNextNote=(GetPlaybackRateFromNote(currentNoteOn[currentMidiMessage.channelNumber]));		// Got told to center the note, just do it.
    3cde:	00 91 28 01 	lds	r16, 0x0128
    3ce2:	10 e0       	ldi	r17, 0x00	; 0
    3ce4:	f8 01       	movw	r30, r16
    3ce6:	ec 5f       	subi	r30, 0xFC	; 252
    3ce8:	fe 4f       	sbci	r31, 0xFE	; 254
    3cea:	80 81       	ld	r24, Z
    3cec:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <GetPlaybackRateFromNote>
    3cf0:	f8 01       	movw	r30, r16
    3cf2:	35 e0       	ldi	r19, 0x05	; 5
    3cf4:	ee 0f       	add	r30, r30
    3cf6:	ff 1f       	adc	r31, r31
    3cf8:	3a 95       	dec	r19
    3cfa:	e1 f7       	brne	.-8      	; 0x3cf4 <DoSampler+0x12c4>
    3cfc:	00 0f       	add	r16, r16
    3cfe:	11 1f       	adc	r17, r17
    3d00:	e0 0f       	add	r30, r16
    3d02:	f1 1f       	adc	r31, r17
    3d04:	e3 58       	subi	r30, 0x83	; 131
    3d06:	fd 4f       	sbci	r31, 0xFD	; 253
    3d08:	92 87       	std	Z+10, r25	; 0x0a
    3d0a:	81 87       	std	Z+9, r24	; 0x09

static void StopUnusedInterrupts(void)
// Look through all the banks, and if none are using a given interrupt source, disable that interrupt source.
// Also voids the contributions those interrupts have to the audio output.
{
	if(bankStates[BANK_0].clockMode!=CLK_EXTERNAL)	// If bank0 isn't using the external interrupt...
    3d0c:	80 91 85 02 	lds	r24, 0x0285
    3d10:	81 30       	cpi	r24, 0x01	; 1
    3d12:	41 f0       	breq	.+16     	; 0x3d24 <DoSampler+0x12f4>
	{
		extIsrOutputBank0=0;		// Voids contribution that this audio source has to the output.
    3d14:	10 92 57 02 	sts	0x0257, r1
		TIMSK1&=~(1<<ICIE1);		// Disable Input Capture Interrupt (yo, son, I thought I was the Icy One?)
    3d18:	80 91 6f 00 	lds	r24, 0x006F
    3d1c:	8f 7d       	andi	r24, 0xDF	; 223
    3d1e:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<ICF1);			// Clear the interrupt flag by writing a 1.	
    3d22:	b5 9a       	sbi	0x16, 5	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_EXTERNAL)
    3d24:	80 91 a7 02 	lds	r24, 0x02A7
    3d28:	81 30       	cpi	r24, 0x01	; 1
    3d2a:	31 f0       	breq	.+12     	; 0x3d38 <DoSampler+0x1308>
	{
		extIsrOutputBank1=0;// Voids contribution that this audio source has to the output.
    3d2c:	10 92 58 02 	sts	0x0258, r1
		PCICR=0;			// No global PCINTS.
    3d30:	10 92 68 00 	sts	0x0068, r1
		PCMSK2=0;			// No PORTC interrupts enabled.
    3d34:	10 92 6d 00 	sts	0x006D, r1
	}
	if(bankStates[BANK_0].clockMode!=CLK_INTERNAL)		// OC1A in use?
    3d38:	80 91 85 02 	lds	r24, 0x0285
    3d3c:	82 30       	cpi	r24, 0x02	; 2
    3d3e:	41 f0       	breq	.+16     	; 0x3d50 <DoSampler+0x1320>
	{
		midiOutputBank0=0;		// Voids contribution that this audio source has to the output.
    3d40:	10 92 59 02 	sts	0x0259, r1
		TIMSK1&=~(1<<OCIE1A);	// Disable the compare match interrupt.
    3d44:	80 91 6f 00 	lds	r24, 0x006F
    3d48:	8d 7f       	andi	r24, 0xFD	; 253
    3d4a:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1A);		// Clear the interrupt flag by writing a 1.	
    3d4e:	b1 9a       	sbi	0x16, 1	; 22
	}
	if(bankStates[BANK_1].clockMode!=CLK_INTERNAL)		// OC1B in use?
    3d50:	80 91 a7 02 	lds	r24, 0x02A7
    3d54:	82 30       	cpi	r24, 0x02	; 2
    3d56:	41 f0       	breq	.+16     	; 0x3d68 <DoSampler+0x1338>
	{
		midiOutputBank1=0;		// Voids contribution that this audio source has to the output.
    3d58:	10 92 5a 02 	sts	0x025A, r1
		TIMSK1&=~(1<<OCIE1B);	// Disable the compare match interrupt.
    3d5c:	80 91 6f 00 	lds	r24, 0x006F
    3d60:	8b 7f       	andi	r24, 0xFB	; 251
    3d62:	80 93 6f 00 	sts	0x006F, r24
		TIFR1|=(1<<OCF1B);		// Clear the interrupt flag by writing a 1.	
    3d66:	b2 9a       	sbi	0x16, 2	; 22
	}

// If there's no clock to a given bank, void all its contributions to the DAC.

	if(bankStates[BANK_0].clockMode==CLK_NONE)
    3d68:	80 91 85 02 	lds	r24, 0x0285
    3d6c:	88 23       	and	r24, r24
    3d6e:	21 f4       	brne	.+8      	; 0x3d78 <DoSampler+0x1348>
	{
		extIsrOutputBank0=0;
    3d70:	10 92 57 02 	sts	0x0257, r1
		midiOutputBank0=0;
    3d74:	10 92 59 02 	sts	0x0259, r1
	}
	if(bankStates[BANK_1].clockMode==CLK_NONE)
    3d78:	80 91 a7 02 	lds	r24, 0x02A7
    3d7c:	88 23       	and	r24, r24
    3d7e:	21 f4       	brne	.+8      	; 0x3d88 <DoSampler+0x1358>
	{
		extIsrOutputBank1=0;
    3d80:	10 92 58 02 	sts	0x0258, r1
		midiOutputBank1=0;
    3d84:	10 92 5a 02 	sts	0x025A, r1
// @@@ Note, this is a badly named function since it both generates the scaled global pot value AND displays it on the LEDs.
{
	unsigned char
		temp;

	scaledEncoderValue=(encoderValue/32);		// Divide our pot's throw into 8 sections (assumes 8-bit range).
    3d88:	80 91 42 01 	lds	r24, 0x0142
    3d8c:	82 95       	swap	r24
    3d8e:	86 95       	lsr	r24
    3d90:	87 70       	andi	r24, 0x07	; 7
    3d92:	80 93 43 01 	sts	0x0143, r24
	temp=(ledOnOffMask&0x1F);			// Make a bitmask from the current ledMask and zero the LEDs we're testing.
    3d96:	90 91 39 01 	lds	r25, 0x0139
    3d9a:	9f 71       	andi	r25, 0x1F	; 31

	if(scaledEncoderValue&(1<<0))
    3d9c:	80 fd       	sbrc	r24, 0
	{
		temp|=(1<<7);	// OR in this bit to the mask to the LEDs.
    3d9e:	90 68       	ori	r25, 0x80	; 128
	}
	if(scaledEncoderValue&(1<<1))
    3da0:	81 fd       	sbrc	r24, 1
	{
		temp|=(1<<6);	// OR in this bit to the mask to the LEDs.
    3da2:	90 64       	ori	r25, 0x40	; 64
	}
	if(scaledEncoderValue&(1<<2))
    3da4:	82 fd       	sbrc	r24, 2
	{
		temp|=(1<<5);	// OR in this bit to the mask to the LEDs.
    3da6:	90 62       	ori	r25, 0x20	; 32
	}

	ledOnOffMask=temp;		// Update the leds.
    3da8:	90 93 39 01 	sts	0x0139, r25
		}
	}

	StopUnusedInterrupts();			// If we've enabled an interrupt and we aren't using it, disable it.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
    3dac:	60 91 2c 01 	lds	r22, 0x012C
// Looks at the current bank and decides how to set the LEDs.
{
	unsigned char
		temp;

	temp=ledOnOffMask&0xE0;		// Mask off the LEDs we care about, then turn them on if appropriate.
    3db0:	29 2f       	mov	r18, r25
    3db2:	20 7e       	andi	r18, 0xE0	; 224

	if(bankStates[theBank].audioFunction==AUDIO_RECORD)
    3db4:	86 2f       	mov	r24, r22
    3db6:	90 e0       	ldi	r25, 0x00	; 0
    3db8:	fc 01       	movw	r30, r24
    3dba:	05 e0       	ldi	r16, 0x05	; 5
    3dbc:	ee 0f       	add	r30, r30
    3dbe:	ff 1f       	adc	r31, r31
    3dc0:	0a 95       	dec	r16
    3dc2:	e1 f7       	brne	.-8      	; 0x3dbc <DoSampler+0x138c>
    3dc4:	88 0f       	add	r24, r24
    3dc6:	99 1f       	adc	r25, r25
    3dc8:	e8 0f       	add	r30, r24
    3dca:	f9 1f       	adc	r31, r25
    3dcc:	e3 58       	subi	r30, 0x83	; 131
    3dce:	fd 4f       	sbci	r31, 0xFD	; 253
    3dd0:	80 81       	ld	r24, Z
    3dd2:	83 30       	cpi	r24, 0x03	; 3
    3dd4:	09 f4       	brne	.+2      	; 0x3dd8 <DoSampler+0x13a8>
	{
		temp|=Om_LED_REC;
    3dd6:	21 60       	ori	r18, 0x01	; 1
	}
	if(bankStates[theBank].audioFunction==AUDIO_PLAYBACK)
    3dd8:	86 2f       	mov	r24, r22
    3dda:	90 e0       	ldi	r25, 0x00	; 0
    3ddc:	fc 01       	movw	r30, r24
    3dde:	b5 e0       	ldi	r27, 0x05	; 5
    3de0:	ee 0f       	add	r30, r30
    3de2:	ff 1f       	adc	r31, r31
    3de4:	ba 95       	dec	r27
    3de6:	e1 f7       	brne	.-8      	; 0x3de0 <DoSampler+0x13b0>
    3de8:	88 0f       	add	r24, r24
    3dea:	99 1f       	adc	r25, r25
    3dec:	e8 0f       	add	r30, r24
    3dee:	f9 1f       	adc	r31, r25
    3df0:	e3 58       	subi	r30, 0x83	; 131
    3df2:	fd 4f       	sbci	r31, 0xFD	; 253
    3df4:	80 81       	ld	r24, Z
    3df6:	84 30       	cpi	r24, 0x04	; 4
    3df8:	09 f4       	brne	.+2      	; 0x3dfc <DoSampler+0x13cc>
	{
		temp|=Om_LED_PLAY;
    3dfa:	24 60       	ori	r18, 0x04	; 4
	}
	if(bankStates[theBank].audioFunction==AUDIO_OVERDUB)
    3dfc:	86 2f       	mov	r24, r22
    3dfe:	90 e0       	ldi	r25, 0x00	; 0
    3e00:	fc 01       	movw	r30, r24
    3e02:	75 e0       	ldi	r23, 0x05	; 5
    3e04:	ee 0f       	add	r30, r30
    3e06:	ff 1f       	adc	r31, r31
    3e08:	7a 95       	dec	r23
    3e0a:	e1 f7       	brne	.-8      	; 0x3e04 <DoSampler+0x13d4>
    3e0c:	88 0f       	add	r24, r24
    3e0e:	99 1f       	adc	r25, r25
    3e10:	e8 0f       	add	r30, r24
    3e12:	f9 1f       	adc	r31, r25
    3e14:	e3 58       	subi	r30, 0x83	; 131
    3e16:	fd 4f       	sbci	r31, 0xFD	; 253
    3e18:	80 81       	ld	r24, Z
    3e1a:	85 30       	cpi	r24, 0x05	; 5
    3e1c:	09 f4       	brne	.+2      	; 0x3e20 <DoSampler+0x13f0>
	{
		temp|=Om_LED_ODUB;
    3e1e:	22 60       	ori	r18, 0x02	; 2
	}
	if(bankStates[theBank].audioFunction==AUDIO_REALTIME)		// Weird light display for this guy.
    3e20:	86 2f       	mov	r24, r22
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	fc 01       	movw	r30, r24
    3e26:	45 e0       	ldi	r20, 0x05	; 5
    3e28:	ee 0f       	add	r30, r30
    3e2a:	ff 1f       	adc	r31, r31
    3e2c:	4a 95       	dec	r20
    3e2e:	e1 f7       	brne	.-8      	; 0x3e28 <DoSampler+0x13f8>
    3e30:	88 0f       	add	r24, r24
    3e32:	99 1f       	adc	r25, r25
    3e34:	e8 0f       	add	r30, r24
    3e36:	f9 1f       	adc	r31, r25
    3e38:	e3 58       	subi	r30, 0x83	; 131
    3e3a:	fd 4f       	sbci	r31, 0xFD	; 253
    3e3c:	80 81       	ld	r24, Z
    3e3e:	82 30       	cpi	r24, 0x02	; 2
    3e40:	09 f4       	brne	.+2      	; 0x3e44 <DoSampler+0x1414>
	{
		temp|=Om_LED_REC;
		temp|=Om_LED_PLAY;
		temp|=Om_LED_ODUB;
    3e42:	27 60       	ori	r18, 0x07	; 7
	}

	if(outOfRam==true)
    3e44:	80 91 40 01 	lds	r24, 0x0140
    3e48:	81 30       	cpi	r24, 0x01	; 1
    3e4a:	09 f4       	brne	.+2      	; 0x3e4e <DoSampler+0x141e>
	{
		temp|=Om_LED_OUT_OF_MEM;
    3e4c:	28 60       	ori	r18, 0x08	; 8
	}
	if(theBank==BANK_1)
    3e4e:	61 30       	cpi	r22, 0x01	; 1
    3e50:	09 f4       	brne	.+2      	; 0x3e54 <DoSampler+0x1424>
	{
		temp|=Om_LED_BANK;
    3e52:	20 61       	ori	r18, 0x10	; 16
	}

	ledOnOffMask=temp;
    3e54:	20 93 39 01 	sts	0x0139, r18

	if(bankStates[theBank].startAddress==bankStates[theBank].endAddress)		// If we don't have a sample in this bank...
    3e58:	86 2f       	mov	r24, r22
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	fc 01       	movw	r30, r24
    3e5e:	05 e0       	ldi	r16, 0x05	; 5
    3e60:	ee 0f       	add	r30, r30
    3e62:	ff 1f       	adc	r31, r31
    3e64:	0a 95       	dec	r16
    3e66:	e1 f7       	brne	.-8      	; 0x3e60 <DoSampler+0x1430>
    3e68:	88 0f       	add	r24, r24
    3e6a:	99 1f       	adc	r25, r25
    3e6c:	e8 0f       	add	r30, r24
    3e6e:	f9 1f       	adc	r31, r25
    3e70:	e3 58       	subi	r30, 0x83	; 131
    3e72:	fd 4f       	sbci	r31, 0xFD	; 253
    3e74:	27 85       	ldd	r18, Z+15	; 0x0f
    3e76:	30 89       	ldd	r19, Z+16	; 0x10
    3e78:	41 89       	ldd	r20, Z+17	; 0x11
    3e7a:	52 89       	ldd	r21, Z+18	; 0x12
    3e7c:	86 2f       	mov	r24, r22
    3e7e:	90 e0       	ldi	r25, 0x00	; 0
    3e80:	fc 01       	movw	r30, r24
    3e82:	b5 e0       	ldi	r27, 0x05	; 5
    3e84:	ee 0f       	add	r30, r30
    3e86:	ff 1f       	adc	r31, r31
    3e88:	ba 95       	dec	r27
    3e8a:	e1 f7       	brne	.-8      	; 0x3e84 <DoSampler+0x1454>
    3e8c:	88 0f       	add	r24, r24
    3e8e:	99 1f       	adc	r25, r25
    3e90:	e8 0f       	add	r30, r24
    3e92:	f9 1f       	adc	r31, r25
    3e94:	e3 58       	subi	r30, 0x83	; 131
    3e96:	fd 4f       	sbci	r31, 0xFD	; 253
    3e98:	83 85       	ldd	r24, Z+11	; 0x0b
    3e9a:	94 85       	ldd	r25, Z+12	; 0x0c
    3e9c:	a5 85       	ldd	r26, Z+13	; 0x0d
    3e9e:	b6 85       	ldd	r27, Z+14	; 0x0e
    3ea0:	28 17       	cp	r18, r24
    3ea2:	39 07       	cpc	r19, r25
    3ea4:	4a 07       	cpc	r20, r26
    3ea6:	5b 07       	cpc	r21, r27
    3ea8:	39 f4       	brne	.+14     	; 0x3eb8 <DoSampler+0x1488>
	{
		if(!(ledBlinkMask&Om_LED_PLAY))			// And we aren't already a-twinkle,
    3eaa:	80 91 3a 01 	lds	r24, 0x013A
    3eae:	82 fd       	sbrc	r24, 2
    3eb0:	07 c0       	rjmp	.+14     	; 0x3ec0 <DoSampler+0x1490>
		{
			BlinkLeds(Om_LED_PLAY);				// Blink the play LED to indicate we have no sample ready to go in our current bank.
    3eb2:	84 e0       	ldi	r24, 0x04	; 4
    3eb4:	90 e0       	ldi	r25, 0x00	; 0
    3eb6:	02 c0       	rjmp	.+4      	; 0x3ebc <DoSampler+0x148c>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    3eb8:	80 e0       	ldi	r24, 0x00	; 0
    3eba:	90 e0       	ldi	r25, 0x00	; 0
    3ebc:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
	}

	StopUnusedInterrupts();			// If we've enabled an interrupt and we aren't using it, disable it.
	EncoderReadingToLeds();			// Display our encoder's relative value on the leds.
	BankStatesToLeds(currentBank);	// Display the current bank's data on the LEDs.
}
    3ec0:	df 91       	pop	r29
    3ec2:	cf 91       	pop	r28
    3ec4:	1f 91       	pop	r17
    3ec6:	0f 91       	pop	r16
    3ec8:	ff 90       	pop	r15
    3eca:	ef 90       	pop	r14
    3ecc:	df 90       	pop	r13
    3ece:	cf 90       	pop	r12
    3ed0:	08 95       	ret

00003ed2 <SetMidiChannels>:


static void SetMidiChannels(void)
// This is a state the user can enter at startup where they set and store desired midi channels using the switches.
{	
	if(subState==SS_0)
    3ed2:	80 91 3f 01 	lds	r24, 0x013F
    3ed6:	88 23       	and	r24, r24
    3ed8:	a1 f4       	brne	.+40     	; 0x3f02 <SetMidiChannels+0x30>
	{
		midiChannelNumberA=GetMidiChannel(BANK_0);					// Get the midi channels we have stored in memory.
    3eda:	0e 94 04 15 	call	0x2a08	; 0x2a08 <GetMidiChannel>
    3ede:	80 93 c3 02 	sts	0x02C3, r24
		midiChannelNumberB=GetMidiChannel(BANK_1);
    3ee2:	81 e0       	ldi	r24, 0x01	; 1
    3ee4:	0e 94 04 15 	call	0x2a08	; 0x2a08 <GetMidiChannel>
    3ee8:	80 93 dc 02 	sts	0x02DC, r24
		ledOnOffMask=(midiChannelNumberA)|(midiChannelNumberB<<4);	// Put the values on the LEDs.  The binary value of midi channel A is displayed on the top 4 leds and the bottom leds display midi channel B.
    3eec:	82 95       	swap	r24
    3eee:	80 7f       	andi	r24, 0xF0	; 240
    3ef0:	90 91 c3 02 	lds	r25, 0x02C3
    3ef4:	98 2b       	or	r25, r24
    3ef6:	90 93 39 01 	sts	0x0139, r25
		subState=SS_1;
    3efa:	81 e0       	ldi	r24, 0x01	; 1
    3efc:	80 93 3f 01 	sts	0x013F, r24
    3f00:	08 95       	ret
	}
	else
	{
		if(newKeys&Im_SWITCH_0)
    3f02:	80 91 3e 01 	lds	r24, 0x013E
    3f06:	28 2f       	mov	r18, r24
    3f08:	80 ff       	sbrs	r24, 0
    3f0a:	11 c0       	rjmp	.+34     	; 0x3f2e <SetMidiChannels+0x5c>
		{
			midiChannelNumberA++;
    3f0c:	80 91 c3 02 	lds	r24, 0x02C3
    3f10:	8f 5f       	subi	r24, 0xFF	; 255
    3f12:	80 93 c3 02 	sts	0x02C3, r24
			if(midiChannelNumberA>15)			// Roll around when we get to the max midi channel
    3f16:	80 31       	cpi	r24, 0x10	; 16
    3f18:	10 f0       	brcs	.+4      	; 0x3f1e <SetMidiChannels+0x4c>
			{
				midiChannelNumberA=0;
    3f1a:	10 92 c3 02 	sts	0x02C3, r1
			}

			ledOnOffMask&=~0x0F;				// Clear low nybble (upper LEDs).
    3f1e:	80 91 39 01 	lds	r24, 0x0139
    3f22:	80 7f       	andi	r24, 0xF0	; 240
			ledOnOffMask|=(midiChannelNumberA);	// Channel A displays on low nybble.
    3f24:	90 91 c3 02 	lds	r25, 0x02C3
    3f28:	89 2b       	or	r24, r25
    3f2a:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_1)
    3f2e:	21 ff       	sbrs	r18, 1
    3f30:	13 c0       	rjmp	.+38     	; 0x3f58 <SetMidiChannels+0x86>
		{
			midiChannelNumberB++;
    3f32:	80 91 dc 02 	lds	r24, 0x02DC
    3f36:	8f 5f       	subi	r24, 0xFF	; 255
    3f38:	80 93 dc 02 	sts	0x02DC, r24
			if(midiChannelNumberB>15)			// Roll around when we get to the max midi channel
    3f3c:	80 31       	cpi	r24, 0x10	; 16
    3f3e:	10 f0       	brcs	.+4      	; 0x3f44 <SetMidiChannels+0x72>
			{
				midiChannelNumberB=0;
    3f40:	10 92 dc 02 	sts	0x02DC, r1
			}

			ledOnOffMask&=~0xF0;					// Clear top nybble (leds near bottom of PCB).
    3f44:	90 91 39 01 	lds	r25, 0x0139
    3f48:	9f 70       	andi	r25, 0x0F	; 15
			ledOnOffMask|=(midiChannelNumberB<<4);	// Channel B displays on low nybble.		
    3f4a:	80 91 dc 02 	lds	r24, 0x02DC
    3f4e:	82 95       	swap	r24
    3f50:	80 7f       	andi	r24, 0xF0	; 240
    3f52:	89 2b       	or	r24, r25
    3f54:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_2)		// Write them to eeprom and get on with life.
    3f58:	22 ff       	sbrs	r18, 2
    3f5a:	14 c0       	rjmp	.+40     	; 0x3f84 <SetMidiChannels+0xb2>
static void StoreMidiChannel(unsigned char theBank, unsigned char theChannel)
// We store our midi channels in the 4th and 8th bytes of EEPROM for the respective channels.  This is pretty arbitrary.
{
	if(theBank==BANK_0)
	{
		EepromWrite(4,theChannel);	// Write the channel to EEPROM.
    3f5c:	84 e0       	ldi	r24, 0x04	; 4
    3f5e:	90 e0       	ldi	r25, 0x00	; 0
    3f60:	60 91 c3 02 	lds	r22, 0x02C3
    3f64:	0e 94 5f 20 	call	0x40be	; 0x40be <EepromWrite>
	}
	else if(theBank==BANK_1)
	{
		EepromWrite(8,theChannel);	// Write the channel to EEPROM.
    3f68:	88 e0       	ldi	r24, 0x08	; 8
    3f6a:	90 e0       	ldi	r25, 0x00	; 0
    3f6c:	60 91 dc 02 	lds	r22, 0x02DC
    3f70:	0e 94 5f 20 	call	0x40be	; 0x40be <EepromWrite>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at the first minor sub-state.
{
	State=newState;
    3f74:	88 e1       	ldi	r24, 0x18	; 24
    3f76:	95 e1       	ldi	r25, 0x15	; 21
    3f78:	90 93 7c 02 	sts	0x027C, r25
    3f7c:	80 93 7b 02 	sts	0x027B, r24
	subState=SS_0;
    3f80:	10 92 3f 01 	sts	0x013F, r1
    3f84:	08 95       	ret

00003f86 <DoSawtooth>:
	static unsigned char
		lastShuttleRead;
	unsigned char
		temp;

	if(subState==SS_0)
    3f86:	80 91 3f 01 	lds	r24, 0x013F
    3f8a:	88 23       	and	r24, r24
    3f8c:	61 f4       	brne	.+24     	; 0x3fa6 <DoSawtooth+0x20>
}

static void KillLeds(void)
// Turns off all LEDs immediately.
{
	ledOnOffMask=0;
    3f8e:	10 92 39 01 	sts	0x0139, r1
	BlinkLeds(0);		// Durrrr.....
    3f92:	80 e0       	ldi	r24, 0x00	; 0
    3f94:	90 e0       	ldi	r25, 0x00	; 0
    3f96:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
		temp;

	if(subState==SS_0)
	{
		KillLeds();							// Start with LEDs off.
		BlinkLeds((1<<LED_6)|(1<<LED_7));	// Blink Leds 6, 7.
    3f9a:	80 ec       	ldi	r24, 0xC0	; 192
    3f9c:	90 e0       	ldi	r25, 0x00	; 0
    3f9e:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
		subState=SS_1;
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
    3fa4:	19 c0       	rjmp	.+50     	; 0x3fd8 <DoSawtooth+0x52>
	}
	else if(subState==SS_1)
    3fa6:	81 30       	cpi	r24, 0x01	; 1
    3fa8:	d1 f4       	brne	.+52     	; 0x3fde <DoSawtooth+0x58>
	{
		cli();		// DONT EVER DO Interrupts this way if you care about not messing something up.
    3faa:	f8 94       	cli
		bankStates[BANK_0].audioFunction=AUDIO_SAWTOOTH;	// Set the external analog clock interrupt vector to make sawtooth waves.
    3fac:	80 93 7d 02 	sts	0x027D, r24
		bankStates[BANK_0].clockMode=CLK_EXTERNAL;
    3fb0:	80 93 85 02 	sts	0x0285, r24
		SetSampleClock(BANK_0,CLK_EXTERNAL,0);
    3fb4:	80 e0       	ldi	r24, 0x00	; 0
    3fb6:	61 e0       	ldi	r22, 0x01	; 1
    3fb8:	40 e0       	ldi	r20, 0x00	; 0
    3fba:	50 e0       	ldi	r21, 0x00	; 0
    3fbc:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <SetSampleClock>
		UpdateOutput=OutputAddBanks;	// Set our output function pointer to call this type of combination.
    3fc0:	82 e5       	ldi	r24, 0x52	; 82
    3fc2:	98 e0       	ldi	r25, 0x08	; 8
    3fc4:	90 93 7a 02 	sts	0x027A, r25
    3fc8:	80 93 79 02 	sts	0x0279, r24
		sei();		// DONT EVER DO Interrupts this way if you care about not messing something up.		
    3fcc:	78 94       	sei

		lastShuttleRead=encoderValue;	// Keep track of the original encoder reading so we can change the leds when it changes.
    3fce:	80 91 42 01 	lds	r24, 0x0142
    3fd2:	80 93 2d 01 	sts	0x012D, r24

		subState=SS_2;					// And wait forever.
    3fd6:	82 e0       	ldi	r24, 0x02	; 2
    3fd8:	80 93 3f 01 	sts	0x013F, r24
    3fdc:	08 95       	ret
	}
	else if(subState==SS_2)
    3fde:	82 30       	cpi	r24, 0x02	; 2
    3fe0:	09 f0       	breq	.+2      	; 0x3fe4 <DoSawtooth+0x5e>
    3fe2:	6c c0       	rjmp	.+216    	; 0x40bc <DoSawtooth+0x136>
	{
		if(newKeys&Im_SWITCH_0)
    3fe4:	80 91 3e 01 	lds	r24, 0x013E
    3fe8:	28 2f       	mov	r18, r24
    3fea:	80 ff       	sbrs	r24, 0
    3fec:	06 c0       	rjmp	.+12     	; 0x3ffa <DoSawtooth+0x74>
		{
			ledOnOffMask^=(1<<LED_0);	// Toggle the LED.
    3fee:	80 91 39 01 	lds	r24, 0x0139
    3ff2:	91 e0       	ldi	r25, 0x01	; 1
    3ff4:	89 27       	eor	r24, r25
    3ff6:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_1)
    3ffa:	21 ff       	sbrs	r18, 1
    3ffc:	06 c0       	rjmp	.+12     	; 0x400a <DoSawtooth+0x84>
		{
			ledOnOffMask^=(1<<LED_1);	// Toggle the LED.
    3ffe:	80 91 39 01 	lds	r24, 0x0139
    4002:	92 e0       	ldi	r25, 0x02	; 2
    4004:	89 27       	eor	r24, r25
    4006:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_2)
    400a:	22 ff       	sbrs	r18, 2
    400c:	06 c0       	rjmp	.+12     	; 0x401a <DoSawtooth+0x94>
		{
			ledOnOffMask^=(1<<LED_2);	// Toggle the LED.
    400e:	80 91 39 01 	lds	r24, 0x0139
    4012:	94 e0       	ldi	r25, 0x04	; 4
    4014:	89 27       	eor	r24, r25
    4016:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_3)
    401a:	23 ff       	sbrs	r18, 3
    401c:	06 c0       	rjmp	.+12     	; 0x402a <DoSawtooth+0xa4>
		{
			ledOnOffMask^=(1<<LED_3);	// Toggle the LED.
    401e:	80 91 39 01 	lds	r24, 0x0139
    4022:	98 e0       	ldi	r25, 0x08	; 8
    4024:	89 27       	eor	r24, r25
    4026:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_4)
    402a:	24 ff       	sbrs	r18, 4
    402c:	06 c0       	rjmp	.+12     	; 0x403a <DoSawtooth+0xb4>
		{
			ledOnOffMask^=(1<<LED_4);	// Toggle the LED.
    402e:	80 91 39 01 	lds	r24, 0x0139
    4032:	90 e1       	ldi	r25, 0x10	; 16
    4034:	89 27       	eor	r24, r25
    4036:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_5)
    403a:	25 ff       	sbrs	r18, 5
    403c:	06 c0       	rjmp	.+12     	; 0x404a <DoSawtooth+0xc4>
		{
			ledOnOffMask^=(1<<LED_5);	// Toggle the LED.
    403e:	80 91 39 01 	lds	r24, 0x0139
    4042:	90 e2       	ldi	r25, 0x20	; 32
    4044:	89 27       	eor	r24, r25
    4046:	80 93 39 01 	sts	0x0139, r24
		}
		if(newKeys&Im_SWITCH_6)
    404a:	26 ff       	sbrs	r18, 6
    404c:	11 c0       	rjmp	.+34     	; 0x4070 <DoSawtooth+0xea>
		{
			if(externalFlashEnabled)
    404e:	80 91 3c 01 	lds	r24, 0x013C
    4052:	88 23       	and	r24, r24
    4054:	19 f0       	breq	.+6      	; 0x405c <DoSawtooth+0xd6>
			{
				temp=GetTestByteFromFlash();	// Get our test byte from the flash.
    4056:	0e 94 bb 24 	call	0x4976	; 0x4976 <GetTestByteFromFlash>
    405a:	08 c0       	rjmp	.+16     	; 0x406c <DoSawtooth+0xe6>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    405c:	80 e0       	ldi	r24, 0x00	; 0
    405e:	90 e0       	ldi	r25, 0x00	; 0
    4060:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
				ledOnOffMask=temp;				// And display it.
			}
			else
			{
				StopBlinking();
				ledOnOffMask^=(1<<LED_6);	// Toggle the LED.
    4064:	80 91 39 01 	lds	r24, 0x0139
    4068:	90 e4       	ldi	r25, 0x40	; 64
    406a:	89 27       	eor	r24, r25
    406c:	80 93 39 01 	sts	0x0139, r24
			}
		}
		if(newKeys&Im_SWITCH_7)
    4070:	80 91 3e 01 	lds	r24, 0x013E
    4074:	87 ff       	sbrs	r24, 7
    4076:	12 c0       	rjmp	.+36     	; 0x409c <DoSawtooth+0x116>
		{
			if(externalFlashEnabled)
    4078:	80 91 3c 01 	lds	r24, 0x013C
    407c:	88 23       	and	r24, r24
    407e:	29 f0       	breq	.+10     	; 0x408a <DoSawtooth+0x104>
			{
				WriteTestByteToFlash(encoderValue);	// Put the encoder value into external flash
    4080:	80 91 42 01 	lds	r24, 0x0142
    4084:	0e 94 d0 24 	call	0x49a0	; 0x49a0 <WriteTestByteToFlash>
    4088:	09 c0       	rjmp	.+18     	; 0x409c <DoSawtooth+0x116>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    408a:	80 e0       	ldi	r24, 0x00	; 0
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
				WriteTestByteToFlash(encoderValue);	// Put the encoder value into external flash
			}
			else
			{
				StopBlinking();
				ledOnOffMask^=(1<<LED_7);	// Toggle the LED.
    4092:	80 91 39 01 	lds	r24, 0x0139
    4096:	80 58       	subi	r24, 0x80	; 128
    4098:	80 93 39 01 	sts	0x0139, r24
			}
		}
	
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
    409c:	90 91 2d 01 	lds	r25, 0x012D
    40a0:	80 91 42 01 	lds	r24, 0x0142
    40a4:	98 17       	cp	r25, r24
    40a6:	51 f0       	breq	.+20     	; 0x40bc <DoSawtooth+0x136>
}

static void StopBlinking(void)
// Stops all blinking LEDs.
{
	BlinkLeds(0);		// Durrrr.....
    40a8:	80 e0       	ldi	r24, 0x00	; 0
    40aa:	90 e0       	ldi	r25, 0x00	; 0
    40ac:	0e 94 58 12 	call	0x24b0	; 0x24b0 <BlinkLeds>
		}
	
		if(lastShuttleRead!=encoderValue)	// Change the leds to the new encoder value when we get a new value.
		{
			StopBlinking();
			ledOnOffMask=encoderValue;
    40b0:	80 91 42 01 	lds	r24, 0x0142
    40b4:	80 93 39 01 	sts	0x0139, r24
			lastShuttleRead=encoderValue;
    40b8:	80 93 2d 01 	sts	0x012D, r24
    40bc:	08 95       	ret

000040be <EepromWrite>:
// NOTE:  Accepted lore is not to use eeprom address 0 since it's the most likely one to get buggered in a crash.

#include "includes.h"

void EepromWrite(unsigned int theAddress, unsigned char theData)
{
    40be:	9c 01       	movw	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    40c0:	f9 99       	sbic	0x1f, 1	; 31
    40c2:	fe cf       	rjmp	.-4      	; 0x40c0 <EepromWrite+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    40c4:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    40c6:	f8 94       	cli

	EEAR=theAddress;
    40c8:	32 bd       	out	0x22, r19	; 34
    40ca:	21 bd       	out	0x21, r18	; 33
	EEDR=theData;
    40cc:	60 bd       	out	0x20, r22	; 32
	EECR|=(1<<EEMPE);	// Start the write.
    40ce:	fa 9a       	sbi	0x1f, 2	; 31
	EECR|=(1<<EEPE);	// Second start-write command.
    40d0:	f9 9a       	sbi	0x1f, 1	; 31

	SREG=sreg;			// Restore interrupts.
    40d2:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    40d4:	12 bc       	out	0x22, r1	; 34
    40d6:	11 bc       	out	0x21, r1	; 33
}
    40d8:	08 95       	ret

000040da <EepromRead>:

unsigned char EepromRead(unsigned char theAddress)
{
    40da:	28 2f       	mov	r18, r24
	unsigned char 
		sreg;

	while(EECR&(1<<EEPE))	// Spin until EEPROM is ready.
    40dc:	f9 99       	sbic	0x1f, 1	; 31
    40de:	fe cf       	rjmp	.-4      	; 0x40dc <EepromRead+0x2>
		;

	sreg=SREG;	// Keep operations atomic (interrupts can mess up eeprom access)
    40e0:	8f b7       	in	r24, 0x3f	; 63
	cli();		// Stop interrupts.
    40e2:	f8 94       	cli

	EEAR=theAddress;
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	32 bd       	out	0x22, r19	; 34
    40e8:	21 bd       	out	0x21, r18	; 33
	EECR|=(1<<EERE);	// Start reading.
    40ea:	f8 9a       	sbi	0x1f, 0	; 31

	SREG=sreg;			// Restore interrupts.
    40ec:	8f bf       	out	0x3f, r24	; 63
	EEAR=0;				// Point the address away from the registers we care about.
    40ee:	12 bc       	out	0x22, r1	; 34
    40f0:	11 bc       	out	0x21, r1	; 33
	
	return(EEDR);		// Pass the data back from eeprom.
    40f2:	80 b5       	in	r24, 0x20	; 32
}
    40f4:	08 95       	ret

000040f6 <Uart0GotByte>:
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    40f6:	80 91 c0 00 	lds	r24, 0x00C0
	}
	else
	{
		return(false);
	}
}
    40fa:	88 1f       	adc	r24, r24
    40fc:	88 27       	eor	r24, r24
    40fe:	88 1f       	adc	r24, r24
    4100:	08 95       	ret

00004102 <Uart0GetByte>:
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    4102:	80 91 c6 00 	lds	r24, 0x00C6
}
    4106:	08 95       	ret

00004108 <InitUart0>:
void InitUart0(void)
// This UART setup is for 31250 baud, 8 data bits, one stop bit, no parity, no flow control.
// Interrupts are disabled.
// I bet you could make this routine even smarter about configuring its own bits given just CPU frequency and baud...
{
	PRR&=~(1<<PRUSART0);					// Turn the USART power on.
    4108:	80 91 64 00 	lds	r24, 0x0064
    410c:	8d 7f       	andi	r24, 0xFD	; 253
    410e:	80 93 64 00 	sts	0x0064, r24
	UCSR0A&=~(1<<U2X0);						// Sets the USART to "normal rate" mode. 
    4112:	80 91 c0 00 	lds	r24, 0x00C0
    4116:	8d 7f       	andi	r24, 0xFD	; 253
    4118:	80 93 c0 00 	sts	0x00C0, r24
//	UCSR0A|=(1<<U2X0);						// Sets the USART to "double rate". 
	UCSR0B = ((1<<TXEN0)|(1<<RXEN0)); 		// Tx/Rx enable.  This overrides DDRs.  This turns interrupts off, too.
    411c:	88 e1       	ldi	r24, 0x18	; 24
    411e:	80 93 c1 00 	sts	0x00C1, r24
//	UBRR0L = ((F_CPU / (16 * BAUD)) - 1);  	// Formula for baud rate setting when the UART isn't set to double rate.
	UBRR0L = 39;  							// Value for normal rate 31.25k baud.
    4122:	87 e2       	ldi	r24, 0x27	; 39
    4124:	80 93 c4 00 	sts	0x00C4, r24
//	UBRR0L=64;  							// Value for double rate 38.4k baud, 20MHz.
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));		// No parity, one stop bit, 8 data bits.
    4128:	86 e0       	ldi	r24, 0x06	; 6
    412a:	80 93 c2 00 	sts	0x00C2, r24
//	fdevopen(Uart0PutChar, NULL);

	while(!(UCSR0A&(1<<UDRE0)))				// Waits until the transmit buffer is ready to move on.
    412e:	80 91 c0 00 	lds	r24, 0x00C0
    4132:	85 ff       	sbrs	r24, 5
    4134:	fc cf       	rjmp	.-8      	; 0x412e <InitUart0+0x26>
*/

bool Uart0GotByte(void)
// Returns true when there is unread data in the UART's receive buffer.
{
	if(UCSR0A&(1<<RXC0))	
    4136:	80 91 c0 00 	lds	r24, 0x00C0
    413a:	87 ff       	sbrs	r24, 7
    413c:	03 c0       	rjmp	.+6      	; 0x4144 <InitUart0+0x3c>
*/

unsigned char Uart0GetByte(void)
// Gets the first byte in the UART's receive buffer.
{
	return(UDR0);		// Get one byte back from the receive buffer.  Note that there may be (one) more in the FIFO.
    413e:	80 91 c6 00 	lds	r24, 0x00C6
    4142:	f9 cf       	rjmp	.-14     	; 0x4136 <InitUart0+0x2e>
    4144:	08 95       	ret

00004146 <SetTimer>:
}
*/
void SetTimer(unsigned char timerNum, unsigned int ticks_to_wait)
// Sets a software timer with an entry time and an amount of time before it expires.
{
	entryTime[timerNum]=systemTicks;
    4146:	e8 2f       	mov	r30, r24
    4148:	f0 e0       	ldi	r31, 0x00	; 0
    414a:	80 91 c1 02 	lds	r24, 0x02C1
    414e:	90 91 c2 02 	lds	r25, 0x02C2
    4152:	ee 0f       	add	r30, r30
    4154:	ff 1f       	adc	r31, r31
    4156:	df 01       	movw	r26, r30
    4158:	a0 5a       	subi	r26, 0xA0	; 160
    415a:	bd 4f       	sbci	r27, 0xFD	; 253
    415c:	8d 93       	st	X+, r24
    415e:	9c 93       	st	X, r25
	delayTime[timerNum]=ticks_to_wait;
    4160:	ea 59       	subi	r30, 0x9A	; 154
    4162:	fd 4f       	sbci	r31, 0xFD	; 253
    4164:	71 83       	std	Z+1, r23	; 0x01
    4166:	60 83       	st	Z, r22
}
    4168:	08 95       	ret

0000416a <CheckTimer>:

unsigned char CheckTimer(unsigned char timerNum)
// If the current system time MINUS the entry time is greater than (or equal to) the amount of ticks we're supposed to wait, we've waited long enough.  Return true.
// Ie, return true if the time is up, and false if it isn't.
{	
	if((systemTicks-entryTime[timerNum])>=delayTime[timerNum])
    416a:	20 91 c1 02 	lds	r18, 0x02C1
    416e:	30 91 c2 02 	lds	r19, 0x02C2
    4172:	e8 2f       	mov	r30, r24
    4174:	f0 e0       	ldi	r31, 0x00	; 0
    4176:	40 e0       	ldi	r20, 0x00	; 0
    4178:	ee 0f       	add	r30, r30
    417a:	ff 1f       	adc	r31, r31
    417c:	df 01       	movw	r26, r30
    417e:	a0 5a       	subi	r26, 0xA0	; 160
    4180:	bd 4f       	sbci	r27, 0xFD	; 253
    4182:	8d 91       	ld	r24, X+
    4184:	9c 91       	ld	r25, X
    4186:	28 1b       	sub	r18, r24
    4188:	39 0b       	sbc	r19, r25
    418a:	ea 59       	subi	r30, 0x9A	; 154
    418c:	fd 4f       	sbci	r31, 0xFD	; 253
    418e:	80 81       	ld	r24, Z
    4190:	91 81       	ldd	r25, Z+1	; 0x01
    4192:	28 17       	cp	r18, r24
    4194:	39 07       	cpc	r19, r25
    4196:	08 f0       	brcs	.+2      	; 0x419a <CheckTimer+0x30>
    4198:	41 e0       	ldi	r20, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    419a:	84 2f       	mov	r24, r20
    419c:	08 95       	ret

0000419e <GetMidiMessageFromIncomingFifo>:
void GetMidiMessageFromIncomingFifo(MIDI_MESSAGE *theMessage)
// Returns an entire 3-byte midi message if there are any in the fifo.
// If there are no messages in the fifo, do nothing.
// These "midi messages" have been formatted to something that makes sense to the sampler from the actual midi bytes by the input handler.
// Wed Apr 15 15:36:49 CDT 2009 -- added channel number info to midi messages to support multi-timbrality.
{
    419e:	cf 93       	push	r28
    41a0:	df 93       	push	r29
    41a2:	ac 01       	movw	r20, r24
	if(midiMessagesInIncomingFifo>0)			// Any messages in the fifo?
    41a4:	20 91 f5 02 	lds	r18, 0x02F5
    41a8:	22 23       	and	r18, r18
    41aa:	11 f1       	breq	.+68     	; 0x41f0 <GetMidiMessageFromIncomingFifo+0x52>
	{
		(*theMessage).messageType=midiMessageIncomingFifo[midiIncomingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    41ac:	90 91 74 02 	lds	r25, 0x0274
    41b0:	e9 2f       	mov	r30, r25
    41b2:	f0 e0       	ldi	r31, 0x00	; 0
    41b4:	ee 0f       	add	r30, r30
    41b6:	ff 1f       	adc	r31, r31
    41b8:	ee 0f       	add	r30, r30
    41ba:	ff 1f       	adc	r31, r31
    41bc:	df 01       	movw	r26, r30
    41be:	ac 53       	subi	r26, 0x3C	; 60
    41c0:	bd 4f       	sbci	r27, 0xFD	; 253
    41c2:	ed 01       	movw	r28, r26
    41c4:	89 81       	ldd	r24, Y+1	; 0x01
    41c6:	ea 01       	movw	r28, r20
    41c8:	89 83       	std	Y+1, r24	; 0x01
		(*theMessage).dataByteOne=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteOne;
    41ca:	ea 53       	subi	r30, 0x3A	; 58
    41cc:	fd 4f       	sbci	r31, 0xFD	; 253
    41ce:	80 81       	ld	r24, Z
    41d0:	8a 83       	std	Y+2, r24	; 0x02
		(*theMessage).dataByteTwo=midiMessageIncomingFifo[midiIncomingFifoReadPointer].dataByteTwo;	
    41d2:	fd 01       	movw	r30, r26
    41d4:	83 81       	ldd	r24, Z+3	; 0x03
    41d6:	8b 83       	std	Y+3, r24	; 0x03
		(*theMessage).channelNumber=midiMessageIncomingFifo[midiIncomingFifoReadPointer].channelNumber;	
    41d8:	8c 91       	ld	r24, X
    41da:	88 83       	st	Y, r24

		midiIncomingFifoReadPointer++;			// read from the next element next time
    41dc:	9f 5f       	subi	r25, 0xFF	; 255
    41de:	90 93 74 02 	sts	0x0274, r25
		if(midiIncomingFifoReadPointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    41e2:	96 30       	cpi	r25, 0x06	; 6
    41e4:	10 f0       	brcs	.+4      	; 0x41ea <GetMidiMessageFromIncomingFifo+0x4c>
		{
			midiIncomingFifoReadPointer=0;
    41e6:	10 92 74 02 	sts	0x0274, r1
		}

		midiMessagesInIncomingFifo--;		// One less message in the fifo.
    41ea:	21 50       	subi	r18, 0x01	; 1
    41ec:	20 93 f5 02 	sts	0x02F5, r18
	}
}
    41f0:	df 91       	pop	r29
    41f2:	cf 91       	pop	r28
    41f4:	08 95       	ret

000041f6 <PutMidiMessageInOutgoingFifo>:

void PutMidiMessageInOutgoingFifo(unsigned char theBank, unsigned char theMessage, unsigned char theDataByteOne, unsigned char theDataByteTwo)
// If there is room in the fifo, put a MIDI message into it.  Again, this is the sampler's idea of a midi message and must be interpreted by the midi output handler before it makes sense to real instruments.
// The format for passing in variables is slightly different as well (we use variables and not a pointer, as this makes it easier to use in the sampler routines). 
// If the fifo is full, don't do anything.
{
    41f6:	cf 93       	push	r28
    41f8:	df 93       	push	r29
	if(midiMessagesInOutgoingFifo<MIDI_MESSAGE_OUTGOING_FIFO_SIZE)		// Have room in the fifo?
    41fa:	30 91 f6 02 	lds	r19, 0x02F6
    41fe:	36 30       	cpi	r19, 0x06	; 6
    4200:	f0 f4       	brcc	.+60     	; 0x423e <PutMidiMessageInOutgoingFifo+0x48>
	{
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].messageType=theMessage;
    4202:	90 91 76 02 	lds	r25, 0x0276
    4206:	e9 2f       	mov	r30, r25
    4208:	f0 e0       	ldi	r31, 0x00	; 0
    420a:	ee 0f       	add	r30, r30
    420c:	ff 1f       	adc	r31, r31
    420e:	ee 0f       	add	r30, r30
    4210:	ff 1f       	adc	r31, r31
    4212:	df 01       	movw	r26, r30
    4214:	a3 52       	subi	r26, 0x23	; 35
    4216:	bd 4f       	sbci	r27, 0xFD	; 253
    4218:	ed 01       	movw	r28, r26
    421a:	69 83       	std	Y+1, r22	; 0x01
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteOne=theDataByteOne;
    421c:	e1 52       	subi	r30, 0x21	; 33
    421e:	fd 4f       	sbci	r31, 0xFD	; 253
    4220:	40 83       	st	Z, r20
		midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].dataByteTwo=theDataByteTwo;
    4222:	2b 83       	std	Y+3, r18	; 0x03
    4224:	80 91 c3 02 	lds	r24, 0x02C3
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;
		}
		else
		{
			midiMessageOutgoingFifo[midiOutgoingFifoWritePointer].channelNumber=midiChannelNumberA;		
    4228:	8c 93       	st	X, r24
		}
	
		midiOutgoingFifoWritePointer++;			// write to the next element next time
    422a:	9f 5f       	subi	r25, 0xFF	; 255
    422c:	90 93 76 02 	sts	0x0276, r25
		if(midiOutgoingFifoWritePointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    4230:	96 30       	cpi	r25, 0x06	; 6
    4232:	10 f0       	brcs	.+4      	; 0x4238 <PutMidiMessageInOutgoingFifo+0x42>
		{
			midiOutgoingFifoWritePointer=0;
    4234:	10 92 76 02 	sts	0x0276, r1
		}
		
		midiMessagesInOutgoingFifo++;								// One more message in the fifo.
    4238:	3f 5f       	subi	r19, 0xFF	; 255
    423a:	30 93 f6 02 	sts	0x02F6, r19
	}
}
    423e:	df 91       	pop	r29
    4240:	cf 91       	pop	r28
    4242:	08 95       	ret

00004244 <InitMidi>:
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
}

void InitMidi(void)
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
    4244:	89 e0       	ldi	r24, 0x09	; 9
    4246:	80 93 75 02 	sts	0x0275, r24
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
    424a:	10 92 78 02 	sts	0x0278, r1
}

static void InitMidiIncomingFifo(void)
// Initialize the MIDI receive fifo to empty.
{
	midiMessagesInIncomingFifo=0;		// No messages in FIFO yet.
    424e:	10 92 f5 02 	sts	0x02F5, r1
	midiIncomingFifoWritePointer=0;		// Next write is to 0.
    4252:	10 92 73 02 	sts	0x0273, r1
	midiIncomingFifoReadPointer=0;		// Next read is at 0.
    4256:	10 92 74 02 	sts	0x0274, r1
}

static void InitMidiOutgoingFifo(void)
// Initialize the MIDI transmit fifo to empty.
{
	midiMessagesInOutgoingFifo=0;		// No messages in FIFO yet.
    425a:	10 92 f6 02 	sts	0x02F6, r1
	midiOutgoingFifoWritePointer=0;		// Next write is to 0.
    425e:	10 92 76 02 	sts	0x0276, r1
	midiOutgoingFifoReadPointer=0;		// Next read is at 0.
    4262:	10 92 77 02 	sts	0x0277, r1
{
	midiIncomingMessageState=IGNORE_ME;					// Reset the midi message gathering state machine -- We need a status byte first.
	midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Output state machine ready to begin sending bytes.
	InitMidiIncomingFifo();								// Set up the receiving buffer.
	InitMidiOutgoingFifo();								// Set up xmit buffer.
}
    4266:	08 95       	ret

00004268 <HandleIncomingMidiByte>:
// type of status byte.  If the byte wasn't a status byte, we plug it into the state machine to see what we should do with the data.
// So, for instance, if we get a NOTE_ON status byte, we keep the NOTE_ON context for data bytes until we get a new STATUS. 
// This allows for expansion to handle different types of status messages, and makes sure we can handle "Running Status" style NOTE messages.
// Real time messages don't mung up the channel message state machine (they don't break running status states) but system common messages DO break running status.
// According to the MIDI spec, any voice / channel message should allow for running status, but it mostly seems to pertain to NOTE_ONs.
{
    4268:	cf 93       	push	r28
    426a:	df 93       	push	r29
    426c:	38 2f       	mov	r19, r24
		temporaryChannel;	// Use this to store the channel we think we're going to update while we collect the other data.

	MIDI_MESSAGE
		theMessage;
	
	if(theByte&0x80)									// First Check to if this byte is a status message.  Unimplemented status bytes should fall through.
    426e:	87 ff       	sbrs	r24, 7
    4270:	41 c0       	rjmp	.+130    	; 0x42f4 <HandleIncomingMidiByte+0x8c>
//			PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.
		}		

		// Not a system message we care about.  Channel / Voice Message on our channel?
*/
		if(((theByte&0x0F)==midiChannelNumberA)||((theByte&0x0F)==midiChannelNumberB))		// Are you talking a valid Channel?  Now see if it's a command we understand.  
    4272:	68 2f       	mov	r22, r24
    4274:	70 e0       	ldi	r23, 0x00	; 0
    4276:	9b 01       	movw	r18, r22
    4278:	2f 70       	andi	r18, 0x0F	; 15
    427a:	30 70       	andi	r19, 0x00	; 0
    427c:	80 91 c3 02 	lds	r24, 0x02C3
    4280:	48 2f       	mov	r20, r24
    4282:	50 e0       	ldi	r21, 0x00	; 0
    4284:	24 17       	cp	r18, r20
    4286:	35 07       	cpc	r19, r21
    4288:	39 f0       	breq	.+14     	; 0x4298 <HandleIncomingMidiByte+0x30>
    428a:	80 91 dc 02 	lds	r24, 0x02DC
    428e:	90 e0       	ldi	r25, 0x00	; 0
    4290:	28 17       	cp	r18, r24
    4292:	39 07       	cpc	r19, r25
    4294:	09 f0       	breq	.+2      	; 0x4298 <HandleIncomingMidiByte+0x30>
    4296:	3b c1       	rjmp	.+630    	; 0x450e <HandleIncomingMidiByte+0x2a6>
		{
			if((theByte&0xF0)==MIDI_NOTE_ON_MASK)				// Is the byte a NOTE_ON status byte?  Two Data bytes.
    4298:	cb 01       	movw	r24, r22
    429a:	80 7f       	andi	r24, 0xF0	; 240
    429c:	90 70       	andi	r25, 0x00	; 0
    429e:	80 39       	cpi	r24, 0x90	; 144
    42a0:	91 05       	cpc	r25, r1
    42a2:	19 f4       	brne	.+6      	; 0x42aa <HandleIncomingMidiByte+0x42>
			{
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE;		// Cool.  We're starting a new NOTE_ON state.
    42a4:	10 92 75 02 	sts	0x0275, r1
    42a8:	1b c0       	rjmp	.+54     	; 0x42e0 <HandleIncomingMidiByte+0x78>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_NOTE_OFF_MASK)			// Is the byte a NOTE_OFF status byte?
    42aa:	80 38       	cpi	r24, 0x80	; 128
    42ac:	91 05       	cpc	r25, r1
    42ae:	39 f4       	brne	.+14     	; 0x42be <HandleIncomingMidiByte+0x56>
			{
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// We're starting NOTE_OFFs.  2 data bytes.
    42b0:	81 e0       	ldi	r24, 0x01	; 1
    42b2:	80 93 75 02 	sts	0x0275, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    42b6:	24 17       	cp	r18, r20
    42b8:	35 07       	cpc	r19, r21
    42ba:	c9 f4       	brne	.+50     	; 0x42ee <HandleIncomingMidiByte+0x86>
    42bc:	14 c0       	rjmp	.+40     	; 0x42e6 <HandleIncomingMidiByte+0x7e>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PROGRAM_CHANGE_MASK)	// Program change started.  One data byte.
    42be:	80 3c       	cpi	r24, 0xC0	; 192
    42c0:	91 05       	cpc	r25, r1
    42c2:	11 f4       	brne	.+4      	; 0x42c8 <HandleIncomingMidiByte+0x60>
			{
				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// One data byte.  Running status applies here, too, in theory.  The CPS-101 doesn't send bytes this way, but something out there might.
    42c4:	82 e0       	ldi	r24, 0x02	; 2
    42c6:	0a c0       	rjmp	.+20     	; 0x42dc <HandleIncomingMidiByte+0x74>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_PITCH_WHEEL_MASK)		// Getting Pitch Wheel Data.  Pitch wheel is two data bytes, 2 data bytes, LSB then MSB.  0x2000 is no pitch change (bytes would be 0x00, 0x40 respectively).
    42c8:	80 3e       	cpi	r24, 0xE0	; 224
    42ca:	91 05       	cpc	r25, r1
    42cc:	11 f4       	brne	.+4      	; 0x42d2 <HandleIncomingMidiByte+0x6a>
			{
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;		// LSB then MSB.  AFAICT running status applies. 
    42ce:	87 e0       	ldi	r24, 0x07	; 7
    42d0:	05 c0       	rjmp	.+10     	; 0x42dc <HandleIncomingMidiByte+0x74>
				else
				{
					temporaryChannel=BANK_1;
				}
			}
			else if((theByte&0xF0)==MIDI_CONTROL_CHANGE_MASK)	// Control Changes (low res) have 2 data bytes -- the controller (or control) number, then the 7-bit value.
    42d2:	80 3b       	cpi	r24, 0xB0	; 176
    42d4:	91 05       	cpc	r25, r1
    42d6:	09 f0       	breq	.+2      	; 0x42da <HandleIncomingMidiByte+0x72>
    42d8:	1a c1       	rjmp	.+564    	; 0x450e <HandleIncomingMidiByte+0x2a6>
			{
				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Control number, then value.  AFAICT running status applies. 
    42da:	83 e0       	ldi	r24, 0x03	; 3
    42dc:	80 93 75 02 	sts	0x0275, r24

				if((theByte&0x0F)==midiChannelNumberA)				// Log the channel we're concerned with.
    42e0:	24 17       	cp	r18, r20
    42e2:	35 07       	cpc	r19, r21
    42e4:	19 f4       	brne	.+6      	; 0x42ec <HandleIncomingMidiByte+0x84>
				{
					temporaryChannel=BANK_0;
    42e6:	10 92 71 02 	sts	0x0271, r1
    42ea:	14 c1       	rjmp	.+552    	; 0x4514 <HandleIncomingMidiByte+0x2ac>
				}
				else
				{
					temporaryChannel=BANK_1;
    42ec:	81 e0       	ldi	r24, 0x01	; 1
    42ee:	80 93 71 02 	sts	0x0271, r24
    42f2:	10 c1       	rjmp	.+544    	; 0x4514 <HandleIncomingMidiByte+0x2ac>
		}
	}
	else
	// The byte we got wasn't a status byte.  Fall through to the state machine that handles data bytes.
	{
		switch(midiIncomingMessageState)
    42f4:	90 91 75 02 	lds	r25, 0x0275
    42f8:	94 30       	cpi	r25, 0x04	; 4
    42fa:	09 f4       	brne	.+2      	; 0x42fe <HandleIncomingMidiByte+0x96>
    42fc:	b7 c0       	rjmp	.+366    	; 0x446c <HandleIncomingMidiByte+0x204>
    42fe:	95 30       	cpi	r25, 0x05	; 5
    4300:	60 f4       	brcc	.+24     	; 0x431a <HandleIncomingMidiByte+0xb2>
    4302:	91 30       	cpi	r25, 0x01	; 1
    4304:	09 f4       	brne	.+2      	; 0x4308 <HandleIncomingMidiByte+0xa0>
    4306:	5e c0       	rjmp	.+188    	; 0x43c4 <HandleIncomingMidiByte+0x15c>
    4308:	91 30       	cpi	r25, 0x01	; 1
    430a:	c8 f0       	brcs	.+50     	; 0x433e <HandleIncomingMidiByte+0xd6>
    430c:	92 30       	cpi	r25, 0x02	; 2
    430e:	09 f4       	brne	.+2      	; 0x4312 <HandleIncomingMidiByte+0xaa>
    4310:	84 c0       	rjmp	.+264    	; 0x441a <HandleIncomingMidiByte+0x1b2>
    4312:	93 30       	cpi	r25, 0x03	; 3
    4314:	09 f0       	breq	.+2      	; 0x4318 <HandleIncomingMidiByte+0xb0>
    4316:	fb c0       	rjmp	.+502    	; 0x450e <HandleIncomingMidiByte+0x2a6>
    4318:	a5 c0       	rjmp	.+330    	; 0x4464 <HandleIncomingMidiByte+0x1fc>
    431a:	97 30       	cpi	r25, 0x07	; 7
    431c:	09 f4       	brne	.+2      	; 0x4320 <HandleIncomingMidiByte+0xb8>
    431e:	cc c0       	rjmp	.+408    	; 0x44b8 <HandleIncomingMidiByte+0x250>
    4320:	98 30       	cpi	r25, 0x08	; 8
    4322:	30 f4       	brcc	.+12     	; 0x4330 <HandleIncomingMidiByte+0xc8>
    4324:	95 30       	cpi	r25, 0x05	; 5
    4326:	79 f0       	breq	.+30     	; 0x4346 <HandleIncomingMidiByte+0xde>
    4328:	96 30       	cpi	r25, 0x06	; 6
    432a:	09 f0       	breq	.+2      	; 0x432e <HandleIncomingMidiByte+0xc6>
    432c:	f0 c0       	rjmp	.+480    	; 0x450e <HandleIncomingMidiByte+0x2a6>
    432e:	4e c0       	rjmp	.+156    	; 0x43cc <HandleIncomingMidiByte+0x164>
    4330:	98 30       	cpi	r25, 0x08	; 8
    4332:	09 f4       	brne	.+2      	; 0x4336 <HandleIncomingMidiByte+0xce>
    4334:	c5 c0       	rjmp	.+394    	; 0x44c0 <HandleIncomingMidiByte+0x258>
    4336:	99 30       	cpi	r25, 0x09	; 9
    4338:	09 f0       	breq	.+2      	; 0x433c <HandleIncomingMidiByte+0xd4>
    433a:	e9 c0       	rjmp	.+466    	; 0x450e <HandleIncomingMidiByte+0x2a6>
    433c:	eb c0       	rjmp	.+470    	; 0x4514 <HandleIncomingMidiByte+0x2ac>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;							// Got a note on, got a valid note -- now we need to get the velocity.
    433e:	80 93 72 02 	sts	0x0272, r24
				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_TWO;
    4342:	85 e0       	ldi	r24, 0x05	; 5
    4344:	e5 c0       	rjmp	.+458    	; 0x4510 <HandleIncomingMidiByte+0x2a8>
    4346:	40 91 72 02 	lds	r20, 0x0272
    434a:	50 91 71 02 	lds	r21, 0x0271
    434e:	20 91 f5 02 	lds	r18, 0x02F5
			}
			break;

			case GET_NOTE_ON_DATA_BYTE_TWO:					// Check velocity, and make the hardware do a note on, note off, or bug out if there's an error.
			if(theByte==0)									// This "note on" is really a "note off".
    4352:	88 23       	and	r24, r24
    4354:	a9 f4       	brne	.+42     	; 0x4380 <HandleIncomingMidiByte+0x118>

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    4356:	26 30       	cpi	r18, 0x06	; 6
    4358:	90 f5       	brcc	.+100    	; 0x43be <HandleIncomingMidiByte+0x156>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    435a:	90 91 73 02 	lds	r25, 0x0273
    435e:	e9 2f       	mov	r30, r25
    4360:	f0 e0       	ldi	r31, 0x00	; 0
    4362:	ee 0f       	add	r30, r30
    4364:	ff 1f       	adc	r31, r31
    4366:	ee 0f       	add	r30, r30
    4368:	ff 1f       	adc	r31, r31
    436a:	df 01       	movw	r26, r30
    436c:	ac 53       	subi	r26, 0x3C	; 60
    436e:	bd 4f       	sbci	r27, 0xFD	; 253
    4370:	82 e0       	ldi	r24, 0x02	; 2
    4372:	ed 01       	movw	r28, r26
    4374:	89 83       	std	Y+1, r24	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4376:	ea 53       	subi	r30, 0x3A	; 58
    4378:	fd 4f       	sbci	r31, 0xFD	; 253
    437a:	40 83       	st	Z, r20
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    437c:	1b 82       	std	Y+3, r1	; 0x03
    437e:	14 c0       	rjmp	.+40     	; 0x43a8 <HandleIncomingMidiByte+0x140>

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    4380:	26 30       	cpi	r18, 0x06	; 6
    4382:	e8 f4       	brcc	.+58     	; 0x43be <HandleIncomingMidiByte+0x156>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    4384:	90 91 73 02 	lds	r25, 0x0273
    4388:	e9 2f       	mov	r30, r25
    438a:	f0 e0       	ldi	r31, 0x00	; 0
    438c:	ee 0f       	add	r30, r30
    438e:	ff 1f       	adc	r31, r31
    4390:	ee 0f       	add	r30, r30
    4392:	ff 1f       	adc	r31, r31
    4394:	df 01       	movw	r26, r30
    4396:	ac 53       	subi	r26, 0x3C	; 60
    4398:	bd 4f       	sbci	r27, 0xFD	; 253
    439a:	81 e0       	ldi	r24, 0x01	; 1
    439c:	ed 01       	movw	r28, r26
    439e:	89 83       	std	Y+1, r24	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    43a0:	ea 53       	subi	r30, 0x3A	; 58
    43a2:	fd 4f       	sbci	r31, 0xFD	; 253
    43a4:	40 83       	st	Z, r20
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    43a6:	3b 83       	std	Y+3, r19	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    43a8:	5c 93       	st	X, r21
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    43aa:	9f 5f       	subi	r25, 0xFF	; 255
    43ac:	90 93 73 02 	sts	0x0273, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    43b0:	96 30       	cpi	r25, 0x06	; 6
    43b2:	10 f0       	brcs	.+4      	; 0x43b8 <HandleIncomingMidiByte+0x150>
		{
			midiIncomingFifoWritePointer=0;
    43b4:	10 92 73 02 	sts	0x0273, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    43b8:	2f 5f       	subi	r18, 0xFF	; 255
    43ba:	20 93 f5 02 	sts	0x02F5, r18
				theMessage.dataByteTwo=theByte;					// And what velocity?
				theMessage.channelNumber=temporaryChannel;		// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_NOTE_ON_DATA_BYTE_ONE; // And continue dealing with NOTE_ONs until we're told otherwise.
    43be:	10 92 75 02 	sts	0x0275, r1
    43c2:	a8 c0       	rjmp	.+336    	; 0x4514 <HandleIncomingMidiByte+0x2ac>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a note off for a valid note.  Get Velocity, like we care.
    43c4:	80 93 72 02 	sts	0x0272, r24
				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_TWO;
    43c8:	86 e0       	ldi	r24, 0x06	; 6
    43ca:	a2 c0       	rjmp	.+324    	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_NOTE_OFF;		// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;				// For what note?
    43cc:	40 91 72 02 	lds	r20, 0x0272
				theMessage.dataByteTwo=theByte;						// And what velocity?
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    43d0:	50 91 71 02 	lds	r21, 0x0271

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    43d4:	20 91 f5 02 	lds	r18, 0x02F5
    43d8:	26 30       	cpi	r18, 0x06	; 6
    43da:	e8 f4       	brcc	.+58     	; 0x4416 <HandleIncomingMidiByte+0x1ae>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    43dc:	90 91 73 02 	lds	r25, 0x0273
    43e0:	e9 2f       	mov	r30, r25
    43e2:	f0 e0       	ldi	r31, 0x00	; 0
    43e4:	ee 0f       	add	r30, r30
    43e6:	ff 1f       	adc	r31, r31
    43e8:	ee 0f       	add	r30, r30
    43ea:	ff 1f       	adc	r31, r31
    43ec:	df 01       	movw	r26, r30
    43ee:	ac 53       	subi	r26, 0x3C	; 60
    43f0:	bd 4f       	sbci	r27, 0xFD	; 253
    43f2:	82 e0       	ldi	r24, 0x02	; 2
    43f4:	ed 01       	movw	r28, r26
    43f6:	89 83       	std	Y+1, r24	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    43f8:	ea 53       	subi	r30, 0x3A	; 58
    43fa:	fd 4f       	sbci	r31, 0xFD	; 253
    43fc:	40 83       	st	Z, r20
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    43fe:	3b 83       	std	Y+3, r19	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    4400:	5c 93       	st	X, r21
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    4402:	9f 5f       	subi	r25, 0xFF	; 255
    4404:	90 93 73 02 	sts	0x0273, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    4408:	96 30       	cpi	r25, 0x06	; 6
    440a:	10 f0       	brcs	.+4      	; 0x4410 <HandleIncomingMidiByte+0x1a8>
		{
			midiIncomingFifoWritePointer=0;
    440c:	10 92 73 02 	sts	0x0273, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    4410:	2f 5f       	subi	r18, 0xFF	; 255
    4412:	20 93 f5 02 	sts	0x02F5, r18
				theMessage.dataByteTwo=theByte;						// And what velocity?
				theMessage.channelNumber=temporaryChannel;			// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_NOTE_OFF_DATA_BYTE_ONE;	// And continue dealing with NOTE_OFFs until we're told otherwise.
    4416:	81 e0       	ldi	r24, 0x01	; 1
    4418:	7b c0       	rjmp	.+246    	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PROGRAM_CHANGE;		// A program change...
				theMessage.dataByteOne=theByte;							// ...To this program
				theMessage.dataByteTwo=0;								// And no second data byte.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    441a:	40 91 71 02 	lds	r20, 0x0271

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    441e:	20 91 f5 02 	lds	r18, 0x02F5
    4422:	26 30       	cpi	r18, 0x06	; 6
    4424:	e8 f4       	brcc	.+58     	; 0x4460 <HandleIncomingMidiByte+0x1f8>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    4426:	90 91 73 02 	lds	r25, 0x0273
    442a:	e9 2f       	mov	r30, r25
    442c:	f0 e0       	ldi	r31, 0x00	; 0
    442e:	ee 0f       	add	r30, r30
    4430:	ff 1f       	adc	r31, r31
    4432:	ee 0f       	add	r30, r30
    4434:	ff 1f       	adc	r31, r31
    4436:	df 01       	movw	r26, r30
    4438:	ac 53       	subi	r26, 0x3C	; 60
    443a:	bd 4f       	sbci	r27, 0xFD	; 253
    443c:	83 e0       	ldi	r24, 0x03	; 3
    443e:	ed 01       	movw	r28, r26
    4440:	89 83       	std	Y+1, r24	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4442:	ea 53       	subi	r30, 0x3A	; 58
    4444:	fd 4f       	sbci	r31, 0xFD	; 253
    4446:	30 83       	st	Z, r19
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    4448:	1b 82       	std	Y+3, r1	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    444a:	4c 93       	st	X, r20
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    444c:	9f 5f       	subi	r25, 0xFF	; 255
    444e:	90 93 73 02 	sts	0x0273, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    4452:	96 30       	cpi	r25, 0x06	; 6
    4454:	10 f0       	brcs	.+4      	; 0x445a <HandleIncomingMidiByte+0x1f2>
		{
			midiIncomingFifoWritePointer=0;
    4456:	10 92 73 02 	sts	0x0273, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    445a:	2f 5f       	subi	r18, 0xFF	; 255
    445c:	20 93 f5 02 	sts	0x02F5, r18
				theMessage.dataByteTwo=0;								// And no second data byte.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
				
				PutMidiMessageInIncomingFifo(&theMessage);			// Send that to the fifo.

				midiIncomingMessageState=GET_PROGRAM_CHANGE_DATA_BYTE;	// AFAICT, theoretically, program changes are subject to running status.
    4460:	82 e0       	ldi	r24, 0x02	; 2
    4462:	56 c0       	rjmp	.+172    	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got a valid CC number.  Get the value next.
    4464:	80 93 72 02 	sts	0x0272, r24
				midiIncomingMessageState=GET_CONTROL_CHANGE_VALUE;
    4468:	84 e0       	ldi	r24, 0x04	; 4
    446a:	52 c0       	rjmp	.+164    	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_CONTROL_CHANGE;		// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;					// This is the CC number.
    446c:	40 91 72 02 	lds	r20, 0x0272
				theMessage.dataByteTwo=theByte;							// And the value.
				theMessage.channelNumber=temporaryChannel;				// And what channel?
    4470:	50 91 71 02 	lds	r21, 0x0271

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    4474:	20 91 f5 02 	lds	r18, 0x02F5
    4478:	26 30       	cpi	r18, 0x06	; 6
    447a:	e0 f4       	brcc	.+56     	; 0x44b4 <HandleIncomingMidiByte+0x24c>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    447c:	80 91 73 02 	lds	r24, 0x0273
    4480:	e8 2f       	mov	r30, r24
    4482:	f0 e0       	ldi	r31, 0x00	; 0
    4484:	ee 0f       	add	r30, r30
    4486:	ff 1f       	adc	r31, r31
    4488:	ee 0f       	add	r30, r30
    448a:	ff 1f       	adc	r31, r31
    448c:	df 01       	movw	r26, r30
    448e:	ac 53       	subi	r26, 0x3C	; 60
    4490:	bd 4f       	sbci	r27, 0xFD	; 253
    4492:	ed 01       	movw	r28, r26
    4494:	99 83       	std	Y+1, r25	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    4496:	ea 53       	subi	r30, 0x3A	; 58
    4498:	fd 4f       	sbci	r31, 0xFD	; 253
    449a:	40 83       	st	Z, r20
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    449c:	3b 83       	std	Y+3, r19	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    449e:	5c 93       	st	X, r21
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    44a0:	8f 5f       	subi	r24, 0xFF	; 255
    44a2:	80 93 73 02 	sts	0x0273, r24
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    44a6:	86 30       	cpi	r24, 0x06	; 6
    44a8:	10 f0       	brcs	.+4      	; 0x44ae <HandleIncomingMidiByte+0x246>
		{
			midiIncomingFifoWritePointer=0;
    44aa:	10 92 73 02 	sts	0x0273, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    44ae:	2f 5f       	subi	r18, 0xFF	; 255
    44b0:	20 93 f5 02 	sts	0x02F5, r18
				theMessage.dataByteTwo=theByte;							// And the value.
				theMessage.channelNumber=temporaryChannel;				// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);						// Send that to yr fifo.

				midiIncomingMessageState=GET_CONTROL_CHANGE_CONTROLLER_NUM;		// Unlikely to see running status here, but I guess it's possible.
    44b4:	83 e0       	ldi	r24, 0x03	; 3
    44b6:	2c c0       	rjmp	.+88     	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			{
				midiIncomingMessageState=IGNORE_ME;
			}
			else
			{
				firstDataByte=theByte;								// Got an LSB for the pitch wheel, now get the _important_ byte.
    44b8:	80 93 72 02 	sts	0x0272, r24
				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_MSB;
    44bc:	88 e0       	ldi	r24, 0x08	; 8
    44be:	28 c0       	rjmp	.+80     	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			}
			else
			{
				// Queue midi message
				theMessage.messageType=MESSAGE_TYPE_PITCH_WHEEL;	// What kind of message is this?
				theMessage.dataByteOne=firstDataByte;				// LSB
    44c0:	40 91 72 02 	lds	r20, 0x0272
				theMessage.dataByteTwo=theByte;						// MSB
				theMessage.channelNumber=temporaryChannel;			// And what channel?
    44c4:	50 91 71 02 	lds	r21, 0x0271

static void PutMidiMessageInIncomingFifo(MIDI_MESSAGE *theMessage)
// If there is room in the fifo, put a MIDI message into it.
// If the fifo is full, don't do anything.
{
	if(midiMessagesInIncomingFifo<MIDI_MESSAGE_INCOMING_FIFO_SIZE)		// Have room in the fifo?
    44c8:	20 91 f5 02 	lds	r18, 0x02F5
    44cc:	26 30       	cpi	r18, 0x06	; 6
    44ce:	e8 f4       	brcc	.+58     	; 0x450a <HandleIncomingMidiByte+0x2a2>
	{
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].messageType=(*theMessage).messageType;	// Transfer the contents of the pointer we've passed into this function to the fifo, at the write pointer.
    44d0:	90 91 73 02 	lds	r25, 0x0273
    44d4:	e9 2f       	mov	r30, r25
    44d6:	f0 e0       	ldi	r31, 0x00	; 0
    44d8:	ee 0f       	add	r30, r30
    44da:	ff 1f       	adc	r31, r31
    44dc:	ee 0f       	add	r30, r30
    44de:	ff 1f       	adc	r31, r31
    44e0:	df 01       	movw	r26, r30
    44e2:	ac 53       	subi	r26, 0x3C	; 60
    44e4:	bd 4f       	sbci	r27, 0xFD	; 253
    44e6:	87 e0       	ldi	r24, 0x07	; 7
    44e8:	ed 01       	movw	r28, r26
    44ea:	89 83       	std	Y+1, r24	; 0x01
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteOne=(*theMessage).dataByteOne;
    44ec:	ea 53       	subi	r30, 0x3A	; 58
    44ee:	fd 4f       	sbci	r31, 0xFD	; 253
    44f0:	40 83       	st	Z, r20
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].dataByteTwo=(*theMessage).dataByteTwo;
    44f2:	3b 83       	std	Y+3, r19	; 0x03
		midiMessageIncomingFifo[midiIncomingFifoWritePointer].channelNumber=(*theMessage).channelNumber;
    44f4:	5c 93       	st	X, r21
	
		midiIncomingFifoWritePointer++;			// write to the next element next time
    44f6:	9f 5f       	subi	r25, 0xFF	; 255
    44f8:	90 93 73 02 	sts	0x0273, r25
		if(midiIncomingFifoWritePointer>=MIDI_MESSAGE_INCOMING_FIFO_SIZE)	// handle wrapping at the end
    44fc:	96 30       	cpi	r25, 0x06	; 6
    44fe:	10 f0       	brcs	.+4      	; 0x4504 <HandleIncomingMidiByte+0x29c>
		{
			midiIncomingFifoWritePointer=0;
    4500:	10 92 73 02 	sts	0x0273, r1
		}
		
		midiMessagesInIncomingFifo++;								// One more message in the fifo.
    4504:	2f 5f       	subi	r18, 0xFF	; 255
    4506:	20 93 f5 02 	sts	0x02F5, r18
				theMessage.dataByteTwo=theByte;						// MSB
				theMessage.channelNumber=temporaryChannel;			// And what channel?

				PutMidiMessageInIncomingFifo(&theMessage);					// Send that to the fifo.

				midiIncomingMessageState=GET_PITCH_WHEEL_DATA_LSB;			// And continue dealing with Pitch Wheel wanking until we're told otherwise.
    450a:	87 e0       	ldi	r24, 0x07	; 7
    450c:	01 c0       	rjmp	.+2      	; 0x4510 <HandleIncomingMidiByte+0x2a8>
			case IGNORE_ME:
			// Don't do anything with the byte; it isn't something we care about.
			break;

			default:
			midiIncomingMessageState=IGNORE_ME;			// @@@ Should never happen.		
    450e:	89 e0       	ldi	r24, 0x09	; 9
    4510:	80 93 75 02 	sts	0x0275, r24
			break;
		}	
	}
}
    4514:	df 91       	pop	r29
    4516:	cf 91       	pop	r28
    4518:	08 95       	ret

0000451a <MidiTxBufferNotEmpty>:

bool MidiTxBufferNotEmpty(void)
{
	if(midiMessagesInOutgoingFifo||(midiOutgoingMessageState!=READY_FOR_NEW_MESSAGE))		// Got something to say?
    451a:	80 91 f6 02 	lds	r24, 0x02F6
    451e:	88 23       	and	r24, r24
    4520:	11 f0       	breq	.+4      	; 0x4526 <MidiTxBufferNotEmpty+0xc>
    4522:	81 e0       	ldi	r24, 0x01	; 1
    4524:	08 95       	ret
    4526:	80 91 78 02 	lds	r24, 0x0278
    452a:	81 11       	cpse	r24, r1
    452c:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return(false);
	}
}
    452e:	08 95       	ret

00004530 <PopOutgoingMidiByte>:
// It is the caller's responsibility to make sure there are messages in the outgoing FIFO before calling this.
// It is generally not as flexible as the midi input handler since it never has to worry about the sampler doing and sending certain things.
// NOTE:  this stack doesn't include handling for real-time events which would happen OUTSIDE of running status.
// NOTE:  this stack sends generic velocity data.
// NOTE:  this stack always sends a NOTE_ON with a velocity of zero when it wants to turn a NOTE_OFF.  It never sends a NOTE_OFF byte.  AFAICT, this is how all commercial synths do it.
{
    4530:	cf 93       	push	r28
    4532:	df 93       	push	r29
		theByte;

	static unsigned char
		lastStatusByte;		// Used to calculate running status.

	switch(midiOutgoingMessageState)
    4534:	80 91 78 02 	lds	r24, 0x0278
    4538:	83 30       	cpi	r24, 0x03	; 3
    453a:	09 f4       	brne	.+2      	; 0x453e <PopOutgoingMidiByte+0xe>
    453c:	8e c0       	rjmp	.+284    	; 0x465a <PopOutgoingMidiByte+0x12a>
    453e:	84 30       	cpi	r24, 0x04	; 4
    4540:	38 f4       	brcc	.+14     	; 0x4550 <PopOutgoingMidiByte+0x20>
    4542:	81 30       	cpi	r24, 0x01	; 1
    4544:	09 f4       	brne	.+2      	; 0x4548 <PopOutgoingMidiByte+0x18>
    4546:	85 c0       	rjmp	.+266    	; 0x4652 <PopOutgoingMidiByte+0x122>
    4548:	82 30       	cpi	r24, 0x02	; 2
    454a:	08 f0       	brcs	.+2      	; 0x454e <PopOutgoingMidiByte+0x1e>
    454c:	84 c0       	rjmp	.+264    	; 0x4656 <PopOutgoingMidiByte+0x126>
    454e:	0d c0       	rjmp	.+26     	; 0x456a <PopOutgoingMidiByte+0x3a>
    4550:	85 30       	cpi	r24, 0x05	; 5
    4552:	09 f4       	brne	.+2      	; 0x4556 <PopOutgoingMidiByte+0x26>
    4554:	89 c0       	rjmp	.+274    	; 0x4668 <PopOutgoingMidiByte+0x138>
    4556:	85 30       	cpi	r24, 0x05	; 5
    4558:	08 f4       	brcc	.+2      	; 0x455c <PopOutgoingMidiByte+0x2c>
    455a:	83 c0       	rjmp	.+262    	; 0x4662 <PopOutgoingMidiByte+0x132>
    455c:	86 30       	cpi	r24, 0x06	; 6
    455e:	09 f4       	brne	.+2      	; 0x4562 <PopOutgoingMidiByte+0x32>
    4560:	86 c0       	rjmp	.+268    	; 0x466e <PopOutgoingMidiByte+0x13e>
    4562:	87 30       	cpi	r24, 0x07	; 7
    4564:	09 f0       	breq	.+2      	; 0x4568 <PopOutgoingMidiByte+0x38>
    4566:	8e c0       	rjmp	.+284    	; 0x4684 <PopOutgoingMidiByte+0x154>
    4568:	88 c0       	rjmp	.+272    	; 0x467a <PopOutgoingMidiByte+0x14a>

static void GetMidiMessageFromOutgoingFifo(MIDI_MESSAGE *theMessage)
// Returns the data the sampler put into the output fifo.  This is generalized data and is turned into the correct midi bytes by the output handler.
// If there are no messages in the fifo, do nothing.
{
	if(midiMessagesInOutgoingFifo>0)			// Any messages in the fifo?
    456a:	20 91 f6 02 	lds	r18, 0x02F6
    456e:	22 23       	and	r18, r18
    4570:	21 f1       	breq	.+72     	; 0x45ba <PopOutgoingMidiByte+0x8a>
	{
		(*theMessage).messageType=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].messageType;		// Get the message at the current read pointer.
    4572:	90 91 77 02 	lds	r25, 0x0277
    4576:	e9 2f       	mov	r30, r25
    4578:	f0 e0       	ldi	r31, 0x00	; 0
    457a:	ee 0f       	add	r30, r30
    457c:	ff 1f       	adc	r31, r31
    457e:	ee 0f       	add	r30, r30
    4580:	ff 1f       	adc	r31, r31
    4582:	df 01       	movw	r26, r30
    4584:	a3 52       	subi	r26, 0x23	; 35
    4586:	bd 4f       	sbci	r27, 0xFD	; 253
    4588:	ed 01       	movw	r28, r26
    458a:	89 81       	ldd	r24, Y+1	; 0x01
    458c:	80 93 6e 02 	sts	0x026E, r24
		(*theMessage).dataByteOne=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteOne;
    4590:	e1 52       	subi	r30, 0x21	; 33
    4592:	fd 4f       	sbci	r31, 0xFD	; 253
    4594:	80 81       	ld	r24, Z
    4596:	80 93 6f 02 	sts	0x026F, r24
		(*theMessage).dataByteTwo=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].dataByteTwo;	
    459a:	8b 81       	ldd	r24, Y+3	; 0x03
    459c:	80 93 70 02 	sts	0x0270, r24
		(*theMessage).channelNumber=midiMessageOutgoingFifo[midiOutgoingFifoReadPointer].channelNumber;	
    45a0:	8c 91       	ld	r24, X
    45a2:	80 93 6d 02 	sts	0x026D, r24

		midiOutgoingFifoReadPointer++;										// read from the next element next time
    45a6:	9f 5f       	subi	r25, 0xFF	; 255
    45a8:	90 93 77 02 	sts	0x0277, r25
		if(midiOutgoingFifoReadPointer>=MIDI_MESSAGE_OUTGOING_FIFO_SIZE)	// handle wrapping at the end
    45ac:	96 30       	cpi	r25, 0x06	; 6
    45ae:	10 f0       	brcs	.+4      	; 0x45b4 <PopOutgoingMidiByte+0x84>
		{
			midiOutgoingFifoReadPointer=0;
    45b0:	10 92 77 02 	sts	0x0277, r1
		}

		midiMessagesInOutgoingFifo--;		// One less message in the fifo.
    45b4:	21 50       	subi	r18, 0x01	; 1
    45b6:	20 93 f6 02 	sts	0x02F6, r18
	switch(midiOutgoingMessageState)
	{
		case READY_FOR_NEW_MESSAGE:						// Finished popping off the last message.
		GetMidiMessageFromOutgoingFifo(&theMessage);	// Get the next one.

		switch(theMessage.messageType)					// What's the new status byte.
    45ba:	20 91 6e 02 	lds	r18, 0x026E
    45be:	22 30       	cpi	r18, 0x02	; 2
    45c0:	b9 f0       	breq	.+46     	; 0x45f0 <PopOutgoingMidiByte+0xc0>
    45c2:	23 30       	cpi	r18, 0x03	; 3
    45c4:	20 f4       	brcc	.+8      	; 0x45ce <PopOutgoingMidiByte+0x9e>
    45c6:	21 30       	cpi	r18, 0x01	; 1
    45c8:	09 f0       	breq	.+2      	; 0x45cc <PopOutgoingMidiByte+0x9c>
    45ca:	5c c0       	rjmp	.+184    	; 0x4684 <PopOutgoingMidiByte+0x154>
    45cc:	06 c0       	rjmp	.+12     	; 0x45da <PopOutgoingMidiByte+0xaa>
    45ce:	23 30       	cpi	r18, 0x03	; 3
    45d0:	f9 f0       	breq	.+62     	; 0x4610 <PopOutgoingMidiByte+0xe0>
    45d2:	24 30       	cpi	r18, 0x04	; 4
    45d4:	09 f0       	breq	.+2      	; 0x45d8 <PopOutgoingMidiByte+0xa8>
    45d6:	56 c0       	rjmp	.+172    	; 0x4684 <PopOutgoingMidiByte+0x154>
    45d8:	2b c0       	rjmp	.+86     	; 0x4630 <PopOutgoingMidiByte+0x100>
		{
			case MESSAGE_TYPE_NOTE_ON:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);	// Note on, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    45da:	90 91 6d 02 	lds	r25, 0x026D
    45de:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)								// Same status byte as last time?
    45e0:	80 91 6c 02 	lds	r24, 0x026C
    45e4:	89 17       	cp	r24, r25
    45e6:	79 f4       	brne	.+30     	; 0x4606 <PopOutgoingMidiByte+0xd6>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number) and skip sending the status byte.
    45e8:	90 91 6f 02 	lds	r25, 0x026F
				midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    45ec:	83 e0       	ldi	r24, 0x03	; 3
    45ee:	2a c0       	rjmp	.+84     	; 0x4644 <PopOutgoingMidiByte+0x114>

			}
			break;

			case MESSAGE_TYPE_NOTE_OFF:
			theByte=(MIDI_NOTE_ON_MASK)|(theMessage.channelNumber);		// Note off, current channel -- THIS IS THE SAME STATUS BYTE AS NOTE ON, MIND.
    45f0:	90 91 6d 02 	lds	r25, 0x026D
    45f4:	90 69       	ori	r25, 0x90	; 144
			if(lastStatusByte==theByte)									// Same status byte as last time (this method keeps running status whether the application passes note_ons or note_offs)
    45f6:	80 91 6c 02 	lds	r24, 0x026C
    45fa:	89 17       	cp	r24, r25
    45fc:	21 f4       	brne	.+8      	; 0x4606 <PopOutgoingMidiByte+0xd6>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (the note number)
    45fe:	90 91 6f 02 	lds	r25, 0x026F
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    4602:	84 e0       	ldi	r24, 0x04	; 4
    4604:	1f c0       	rjmp	.+62     	; 0x4644 <PopOutgoingMidiByte+0x114>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4606:	90 93 6c 02 	sts	0x026C, r25
				midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_ONE;	// Next time send the data byte.
    460a:	20 93 78 02 	sts	0x0278, r18
    460e:	3b c0       	rjmp	.+118    	; 0x4686 <PopOutgoingMidiByte+0x156>

			}
			break;

			case MESSAGE_TYPE_PROGRAM_CHANGE:
			theByte=(MIDI_PROGRAM_CHANGE_MASK)|(theMessage.channelNumber);	// Program change, current channel.
    4610:	90 91 6d 02 	lds	r25, 0x026D
    4614:	90 6c       	ori	r25, 0xC0	; 192
			if(lastStatusByte==theByte)										// Same status byte as last time?
    4616:	80 91 6c 02 	lds	r24, 0x026C
    461a:	89 17       	cp	r24, r25
    461c:	29 f4       	brne	.+10     	; 0x4628 <PopOutgoingMidiByte+0xf8>
			{
				theByte=theMessage.dataByteOne;						// Set up to return the first data byte (skip the status byte)
    461e:	90 91 6f 02 	lds	r25, 0x026F
				midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Restart state machine (PC messages only have one data byte)
    4622:	10 92 78 02 	sts	0x0278, r1
    4626:	2f c0       	rjmp	.+94     	; 0x4686 <PopOutgoingMidiByte+0x156>
			}	
			else
			{
				lastStatusByte=theByte;								// Update current running status.
    4628:	90 93 6c 02 	sts	0x026C, r25
				midiOutgoingMessageState=PROGRAM_CHANGE_DATA_BYTE;	// Next time send the data byte.
    462c:	85 e0       	ldi	r24, 0x05	; 5
    462e:	0a c0       	rjmp	.+20     	; 0x4644 <PopOutgoingMidiByte+0x114>

			}
			break;

			case MESSAGE_TYPE_CONTROL_CHANGE:
			theByte=(MIDI_CONTROL_CHANGE_MASK)|(theMessage.channelNumber);	// CC, current channel (status messages are 4 MSbs signifying a message type, followed by 4 signifying the channel number)
    4630:	90 91 6d 02 	lds	r25, 0x026D
    4634:	90 6b       	ori	r25, 0xB0	; 176
			if(lastStatusByte==theByte)										// Same status byte as last time?
    4636:	80 91 6c 02 	lds	r24, 0x026C
    463a:	89 17       	cp	r24, r25
    463c:	31 f4       	brne	.+12     	; 0x464a <PopOutgoingMidiByte+0x11a>
			{
				theByte=theMessage.dataByteOne;								// Set up to return the first data byte (the note number) and skip sending the status byte.
    463e:	90 91 6f 02 	lds	r25, 0x026F
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4642:	87 e0       	ldi	r24, 0x07	; 7
    4644:	80 93 78 02 	sts	0x0278, r24
    4648:	1e c0       	rjmp	.+60     	; 0x4686 <PopOutgoingMidiByte+0x156>
			}	
			else
			{
				lastStatusByte=theByte;										// Update current running status.
    464a:	90 93 6c 02 	sts	0x026C, r25
				midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_ONE;		// Next time send the data byte.
    464e:	86 e0       	ldi	r24, 0x06	; 6
    4650:	f9 cf       	rjmp	.-14     	; 0x4644 <PopOutgoingMidiByte+0x114>
		}
		return(theByte);		// Send out our byte.
		break;
		
		case NOTE_ON_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_ON_DATA_BYTE_TWO;		// Skip to second data byte next time.
    4652:	83 e0       	ldi	r24, 0x03	; 3
    4654:	0d c0       	rjmp	.+26     	; 0x4670 <PopOutgoingMidiByte+0x140>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_OFF_DATA_BYTE_ONE:
		midiOutgoingMessageState=NOTE_OFF_DATA_BYTE_TWO;	// Skip to second data byte next time.
    4656:	84 e0       	ldi	r24, 0x04	; 4
    4658:	0b c0       	rjmp	.+22     	; 0x4670 <PopOutgoingMidiByte+0x140>
		return(theMessage.dataByteOne);						// Return the first data byte.
		break;

		case NOTE_ON_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    465a:	10 92 78 02 	sts	0x0278, r1
    465e:	90 e4       	ldi	r25, 0x40	; 64
    4660:	12 c0       	rjmp	.+36     	; 0x4686 <PopOutgoingMidiByte+0x156>
		return(MIDI_GENERIC_VELOCITY);						// Return generic "note on" velocity.
		break;

		case NOTE_OFF_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4662:	10 92 78 02 	sts	0x0278, r1
    4666:	0e c0       	rjmp	.+28     	; 0x4684 <PopOutgoingMidiByte+0x154>
		return(0);											// Return a velocity of 0 (this means a note off)
		break;

		case PROGRAM_CHANGE_DATA_BYTE:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    4668:	10 92 78 02 	sts	0x0278, r1
    466c:	03 c0       	rjmp	.+6      	; 0x4674 <PopOutgoingMidiByte+0x144>
		return(theMessage.dataByteOne);						// Return the first (only) data byte.
		break;

		case CONTROL_CHANGE_DATA_BYTE_ONE:
		midiOutgoingMessageState=CONTROL_CHANGE_DATA_BYTE_TWO;		// Skip to second data byte next time.
    466e:	87 e0       	ldi	r24, 0x07	; 7
    4670:	80 93 78 02 	sts	0x0278, r24
		return(theMessage.dataByteOne);								// Return the first data byte.
    4674:	90 91 6f 02 	lds	r25, 0x026F
    4678:	06 c0       	rjmp	.+12     	; 0x4686 <PopOutgoingMidiByte+0x156>
		break;	

		case CONTROL_CHANGE_DATA_BYTE_TWO:
		midiOutgoingMessageState=READY_FOR_NEW_MESSAGE;		// Start state machine over.
    467a:	10 92 78 02 	sts	0x0278, r1
		return(theMessage.dataByteTwo);						// Return the second data byte.
    467e:	90 91 70 02 	lds	r25, 0x0270
    4682:	01 c0       	rjmp	.+2      	; 0x4686 <PopOutgoingMidiByte+0x156>
    4684:	90 e0       	ldi	r25, 0x00	; 0

		default:
		return(0);
		break;
	}
}
    4686:	89 2f       	mov	r24, r25
    4688:	df 91       	pop	r29
    468a:	cf 91       	pop	r28
    468c:	08 95       	ret

0000468e <FlashReady>:

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    468e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    4690:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4692:	80 91 c8 00 	lds	r24, 0x00C8
    4696:	85 ff       	sbrs	r24, 5
    4698:	fc cf       	rjmp	.-8      	; 0x4692 <FlashReady+0x4>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    469a:	85 e0       	ldi	r24, 0x05	; 5
    469c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    46a0:	80 91 c8 00 	lds	r24, 0x00C8
    46a4:	87 ff       	sbrs	r24, 7
    46a6:	fc cf       	rjmp	.-8      	; 0x46a0 <FlashReady+0x12>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    46a8:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    46ac:	80 91 c8 00 	lds	r24, 0x00C8
    46b0:	85 ff       	sbrs	r24, 5
    46b2:	fc cf       	rjmp	.-8      	; 0x46ac <FlashReady+0x1e>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    46b4:	8f ef       	ldi	r24, 0xFF	; 255
    46b6:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    46ba:	80 91 c8 00 	lds	r24, 0x00C8
    46be:	87 ff       	sbrs	r24, 7
    46c0:	fc cf       	rjmp	.-8      	; 0x46ba <FlashReady+0x2c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    46c2:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    46c6:	5d 9a       	sbi	0x0b, 5	; 11
    46c8:	80 95       	com	r24
	}
	else
	{
		return(true);	// Flash is available.
	}
}
    46ca:	81 70       	andi	r24, 0x01	; 1
    46cc:	08 95       	ret

000046ce <WriteEnableFlash>:

static void WriteEnableFlash(void)
{
	while(!FlashReady())	// Spin while flash is busy.
    46ce:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    46d2:	88 23       	and	r24, r24
    46d4:	e1 f3       	breq	.-8      	; 0x46ce <WriteEnableFlash>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    46d6:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    46d8:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    46da:	80 91 c8 00 	lds	r24, 0x00C8
    46de:	85 ff       	sbrs	r24, 5
    46e0:	fc cf       	rjmp	.-8      	; 0x46da <WriteEnableFlash+0xc>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    46e2:	86 e0       	ldi	r24, 0x06	; 6
    46e4:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    46e8:	80 91 c8 00 	lds	r24, 0x00C8
    46ec:	87 ff       	sbrs	r24, 7
    46ee:	fc cf       	rjmp	.-8      	; 0x46e8 <WriteEnableFlash+0x1a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    46f0:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    46f4:	5d 9a       	sbi	0x0b, 5	; 11
		;

	StartExternalFlashTransfer();			// New transaction with flash.
	TransferExternalFlashByte(SST_WREN);	// Enable writing the flash memory.
	EndExternalFlashTransfer();				// End transfer.
}
    46f6:	08 95       	ret

000046f8 <StartFlashPageProgram>:

static void StartFlashPageProgram(unsigned long thePage)
// The LSB of this should always be zeros, but they aren't don't cares, so leave this up to the user.
// IE, page size is 256 bytes and we should always be starting on a boundary.
{
    46f8:	ef 92       	push	r14
    46fa:	ff 92       	push	r15
    46fc:	0f 93       	push	r16
    46fe:	1f 93       	push	r17
    4700:	7b 01       	movw	r14, r22
    4702:	8c 01       	movw	r16, r24
	while(!FlashReady())	// Spin while flash is busy.
    4704:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    4708:	88 23       	and	r24, r24
    470a:	e1 f3       	breq	.-8      	; 0x4704 <StartFlashPageProgram+0xc>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    470c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    470e:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4710:	80 91 c8 00 	lds	r24, 0x00C8
    4714:	85 ff       	sbrs	r24, 5
    4716:	fc cf       	rjmp	.-8      	; 0x4710 <StartFlashPageProgram+0x18>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4718:	82 e0       	ldi	r24, 0x02	; 2
    471a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    471e:	80 91 c8 00 	lds	r24, 0x00C8
    4722:	87 ff       	sbrs	r24, 7
    4724:	fc cf       	rjmp	.-8      	; 0x471e <StartFlashPageProgram+0x26>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4726:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    472a:	80 91 c8 00 	lds	r24, 0x00C8
    472e:	85 ff       	sbrs	r24, 5
    4730:	fc cf       	rjmp	.-8      	; 0x472a <StartFlashPageProgram+0x32>
	while(!FlashReady())	// Spin while flash is busy.
		;

	StartExternalFlashTransfer();					// New transaction with flash.
	TransferExternalFlashByte(SST_PAGE_PROGRAM);	// Write a page to flash
	TransferExternalFlashByte(thePage>>16);			// (MSB of addy)
    4732:	c8 01       	movw	r24, r16
    4734:	aa 27       	eor	r26, r26
    4736:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4738:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    473c:	80 91 c8 00 	lds	r24, 0x00C8
    4740:	87 ff       	sbrs	r24, 7
    4742:	fc cf       	rjmp	.-8      	; 0x473c <StartFlashPageProgram+0x44>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4744:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4748:	80 91 c8 00 	lds	r24, 0x00C8
    474c:	85 ff       	sbrs	r24, 5
    474e:	fc cf       	rjmp	.-8      	; 0x4748 <StartFlashPageProgram+0x50>
		;

	StartExternalFlashTransfer();					// New transaction with flash.
	TransferExternalFlashByte(SST_PAGE_PROGRAM);	// Write a page to flash
	TransferExternalFlashByte(thePage>>16);			// (MSB of addy)
	TransferExternalFlashByte(thePage>>8);			// addy 
    4750:	bb 27       	eor	r27, r27
    4752:	a1 2f       	mov	r26, r17
    4754:	90 2f       	mov	r25, r16
    4756:	8f 2d       	mov	r24, r15
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4758:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    475c:	80 91 c8 00 	lds	r24, 0x00C8
    4760:	87 ff       	sbrs	r24, 7
    4762:	fc cf       	rjmp	.-8      	; 0x475c <StartFlashPageProgram+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4764:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4768:	80 91 c8 00 	lds	r24, 0x00C8
    476c:	85 ff       	sbrs	r24, 5
    476e:	fc cf       	rjmp	.-8      	; 0x4768 <StartFlashPageProgram+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4770:	e0 92 ce 00 	sts	0x00CE, r14

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4774:	80 91 c8 00 	lds	r24, 0x00C8
    4778:	87 ff       	sbrs	r24, 7
    477a:	fc cf       	rjmp	.-8      	; 0x4774 <StartFlashPageProgram+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    477c:	80 91 ce 00 	lds	r24, 0x00CE
	StartExternalFlashTransfer();					// New transaction with flash.
	TransferExternalFlashByte(SST_PAGE_PROGRAM);	// Write a page to flash
	TransferExternalFlashByte(thePage>>16);			// (MSB of addy)
	TransferExternalFlashByte(thePage>>8);			// addy 
	TransferExternalFlashByte(thePage);				// addy (LSB)
}
    4780:	1f 91       	pop	r17
    4782:	0f 91       	pop	r16
    4784:	ff 90       	pop	r15
    4786:	ef 90       	pop	r14
    4788:	08 95       	ret

0000478a <StartFlashRead>:

static void StartFlashRead(unsigned long theAddress)
// Array reads start the passed address and keep incrementing.
{
    478a:	ef 92       	push	r14
    478c:	ff 92       	push	r15
    478e:	0f 93       	push	r16
    4790:	1f 93       	push	r17
    4792:	7b 01       	movw	r14, r22
    4794:	8c 01       	movw	r16, r24
	while(!FlashReady())	// Spin while flash is busy.
    4796:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    479a:	88 23       	and	r24, r24
    479c:	e1 f3       	breq	.-8      	; 0x4796 <StartFlashRead+0xc>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    479e:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    47a0:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    47a2:	80 91 c8 00 	lds	r24, 0x00C8
    47a6:	85 ff       	sbrs	r24, 5
    47a8:	fc cf       	rjmp	.-8      	; 0x47a2 <StartFlashRead+0x18>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    47aa:	83 e0       	ldi	r24, 0x03	; 3
    47ac:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    47b0:	80 91 c8 00 	lds	r24, 0x00C8
    47b4:	87 ff       	sbrs	r24, 7
    47b6:	fc cf       	rjmp	.-8      	; 0x47b0 <StartFlashRead+0x26>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    47b8:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    47bc:	80 91 c8 00 	lds	r24, 0x00C8
    47c0:	85 ff       	sbrs	r24, 5
    47c2:	fc cf       	rjmp	.-8      	; 0x47bc <StartFlashRead+0x32>
	while(!FlashReady())	// Spin while flash is busy.
		;

	StartExternalFlashTransfer();				// New transaction with flash.
	TransferExternalFlashByte(SST_READ);		// Begin reading through the array at the passed address.
	TransferExternalFlashByte(theAddress>>16);	// (MSB of addy)
    47c4:	c8 01       	movw	r24, r16
    47c6:	aa 27       	eor	r26, r26
    47c8:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    47ca:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    47ce:	80 91 c8 00 	lds	r24, 0x00C8
    47d2:	87 ff       	sbrs	r24, 7
    47d4:	fc cf       	rjmp	.-8      	; 0x47ce <StartFlashRead+0x44>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    47d6:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    47da:	80 91 c8 00 	lds	r24, 0x00C8
    47de:	85 ff       	sbrs	r24, 5
    47e0:	fc cf       	rjmp	.-8      	; 0x47da <StartFlashRead+0x50>
		;

	StartExternalFlashTransfer();				// New transaction with flash.
	TransferExternalFlashByte(SST_READ);		// Begin reading through the array at the passed address.
	TransferExternalFlashByte(theAddress>>16);	// (MSB of addy)
	TransferExternalFlashByte(theAddress>>8);	// addy 
    47e2:	bb 27       	eor	r27, r27
    47e4:	a1 2f       	mov	r26, r17
    47e6:	90 2f       	mov	r25, r16
    47e8:	8f 2d       	mov	r24, r15
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    47ea:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    47ee:	80 91 c8 00 	lds	r24, 0x00C8
    47f2:	87 ff       	sbrs	r24, 7
    47f4:	fc cf       	rjmp	.-8      	; 0x47ee <StartFlashRead+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    47f6:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    47fa:	80 91 c8 00 	lds	r24, 0x00C8
    47fe:	85 ff       	sbrs	r24, 5
    4800:	fc cf       	rjmp	.-8      	; 0x47fa <StartFlashRead+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4802:	e0 92 ce 00 	sts	0x00CE, r14

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4806:	80 91 c8 00 	lds	r24, 0x00C8
    480a:	87 ff       	sbrs	r24, 7
    480c:	fc cf       	rjmp	.-8      	; 0x4806 <StartFlashRead+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    480e:	80 91 ce 00 	lds	r24, 0x00CE
	StartExternalFlashTransfer();				// New transaction with flash.
	TransferExternalFlashByte(SST_READ);		// Begin reading through the array at the passed address.
	TransferExternalFlashByte(theAddress>>16);	// (MSB of addy)
	TransferExternalFlashByte(theAddress>>8);	// addy 
	TransferExternalFlashByte(theAddress);		// addy (LSB)
}
    4812:	1f 91       	pop	r17
    4814:	0f 91       	pop	r16
    4816:	ff 90       	pop	r15
    4818:	ef 90       	pop	r14
    481a:	08 95       	ret

0000481c <EraseFlashSector>:
}

static void EraseFlashSector(unsigned long theSector)
// A sector is 4k.
// Low bits in this command are don't cares.
{
    481c:	ef 92       	push	r14
    481e:	ff 92       	push	r15
    4820:	0f 93       	push	r16
    4822:	1f 93       	push	r17
    4824:	7b 01       	movw	r14, r22
    4826:	8c 01       	movw	r16, r24
	while(!FlashReady())	// Spin while flash is busy.
    4828:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    482c:	88 23       	and	r24, r24
    482e:	e1 f3       	breq	.-8      	; 0x4828 <EraseFlashSector+0xc>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4830:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    4832:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4834:	80 91 c8 00 	lds	r24, 0x00C8
    4838:	85 ff       	sbrs	r24, 5
    483a:	fc cf       	rjmp	.-8      	; 0x4834 <EraseFlashSector+0x18>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    483c:	80 e2       	ldi	r24, 0x20	; 32
    483e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4842:	80 91 c8 00 	lds	r24, 0x00C8
    4846:	87 ff       	sbrs	r24, 7
    4848:	fc cf       	rjmp	.-8      	; 0x4842 <EraseFlashSector+0x26>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    484a:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    484e:	80 91 c8 00 	lds	r24, 0x00C8
    4852:	85 ff       	sbrs	r24, 5
    4854:	fc cf       	rjmp	.-8      	; 0x484e <EraseFlashSector+0x32>
	while(!FlashReady())	// Spin while flash is busy.
		;

	StartExternalFlashTransfer();				// New transaction with flash.
	TransferExternalFlashByte(SST_SECTOR_ERASE);// Set 4k of flash back to 0xFF
	TransferExternalFlashByte(theSector>>16);	// (MSB of addy)
    4856:	c8 01       	movw	r24, r16
    4858:	aa 27       	eor	r26, r26
    485a:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    485c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4860:	80 91 c8 00 	lds	r24, 0x00C8
    4864:	87 ff       	sbrs	r24, 7
    4866:	fc cf       	rjmp	.-8      	; 0x4860 <EraseFlashSector+0x44>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4868:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    486c:	80 91 c8 00 	lds	r24, 0x00C8
    4870:	85 ff       	sbrs	r24, 5
    4872:	fc cf       	rjmp	.-8      	; 0x486c <EraseFlashSector+0x50>
		;

	StartExternalFlashTransfer();				// New transaction with flash.
	TransferExternalFlashByte(SST_SECTOR_ERASE);// Set 4k of flash back to 0xFF
	TransferExternalFlashByte(theSector>>16);	// (MSB of addy)
	TransferExternalFlashByte(theSector>>8);	// addy cont'd
    4874:	bb 27       	eor	r27, r27
    4876:	a1 2f       	mov	r26, r17
    4878:	90 2f       	mov	r25, r16
    487a:	8f 2d       	mov	r24, r15
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    487c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4880:	80 91 c8 00 	lds	r24, 0x00C8
    4884:	87 ff       	sbrs	r24, 7
    4886:	fc cf       	rjmp	.-8      	; 0x4880 <EraseFlashSector+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4888:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    488c:	80 91 c8 00 	lds	r24, 0x00C8
    4890:	85 ff       	sbrs	r24, 5
    4892:	fc cf       	rjmp	.-8      	; 0x488c <EraseFlashSector+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4894:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4898:	80 91 c8 00 	lds	r24, 0x00C8
    489c:	87 ff       	sbrs	r24, 7
    489e:	fc cf       	rjmp	.-8      	; 0x4898 <EraseFlashSector+0x7c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    48a0:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    48a4:	5d 9a       	sbi	0x0b, 5	; 11
	TransferExternalFlashByte(SST_SECTOR_ERASE);// Set 4k of flash back to 0xFF
	TransferExternalFlashByte(theSector>>16);	// (MSB of addy)
	TransferExternalFlashByte(theSector>>8);	// addy cont'd
	TransferExternalFlashByte(0);				// Don't care bits
	EndExternalFlashTransfer();					// End transfer.
}
    48a6:	1f 91       	pop	r17
    48a8:	0f 91       	pop	r16
    48aa:	ff 90       	pop	r15
    48ac:	ef 90       	pop	r14
    48ae:	08 95       	ret

000048b0 <WriteProtectFlash>:

static void WriteProtectFlash(void)
// Disables writes to all the flash blocks using the block protect bits in the status register.
{
	while(!FlashReady())	// Spin while flash is busy.
    48b0:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    48b4:	88 23       	and	r24, r24
    48b6:	e1 f3       	breq	.-8      	; 0x48b0 <WriteProtectFlash>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    48b8:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    48ba:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    48bc:	80 91 c8 00 	lds	r24, 0x00C8
    48c0:	85 ff       	sbrs	r24, 5
    48c2:	fc cf       	rjmp	.-8      	; 0x48bc <WriteProtectFlash+0xc>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    48c4:	80 e5       	ldi	r24, 0x50	; 80
    48c6:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    48ca:	80 91 c8 00 	lds	r24, 0x00C8
    48ce:	87 ff       	sbrs	r24, 7
    48d0:	fc cf       	rjmp	.-8      	; 0x48ca <WriteProtectFlash+0x1a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    48d2:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    48d6:	5d 9a       	sbi	0x0b, 5	; 11

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    48d8:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    48da:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    48dc:	80 91 c8 00 	lds	r24, 0x00C8
    48e0:	85 ff       	sbrs	r24, 5
    48e2:	fc cf       	rjmp	.-8      	; 0x48dc <WriteProtectFlash+0x2c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    48e4:	81 e0       	ldi	r24, 0x01	; 1
    48e6:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    48ea:	80 91 c8 00 	lds	r24, 0x00C8
    48ee:	87 ff       	sbrs	r24, 7
    48f0:	fc cf       	rjmp	.-8      	; 0x48ea <WriteProtectFlash+0x3a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    48f2:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    48f6:	80 91 c8 00 	lds	r24, 0x00C8
    48fa:	85 ff       	sbrs	r24, 5
    48fc:	fc cf       	rjmp	.-8      	; 0x48f6 <WriteProtectFlash+0x46>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    48fe:	8c e3       	ldi	r24, 0x3C	; 60
    4900:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4904:	80 91 c8 00 	lds	r24, 0x00C8
    4908:	87 ff       	sbrs	r24, 7
    490a:	fc cf       	rjmp	.-8      	; 0x4904 <WriteProtectFlash+0x54>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    490c:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4910:	5d 9a       	sbi	0x0b, 5	; 11

	StartExternalFlashTransfer();			// New transaction with flash.
	TransferExternalFlashByte(SST_WRSR);	// Request a status register write.
	TransferExternalFlashByte(((1<<SST_STATUS_BP3)|(1<<SST_STATUS_BP2)|(1<<SST_STATUS_BP1)|(1<<SST_STATUS_BP0)));		// Protect all flash by writing 1s to the block protect bits.
	EndExternalFlashTransfer();				// End transfer.
}
    4912:	08 95       	ret

00004914 <UnWriteProtectFlash>:

static void UnWriteProtectFlash(void)
// Enables writing to any block in flash using the block protect bits in the status register.
// Note, the part powers up write protected.
{
	while(!FlashReady())	// Spin while flash is busy.
    4914:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    4918:	88 23       	and	r24, r24
    491a:	e1 f3       	breq	.-8      	; 0x4914 <UnWriteProtectFlash>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    491c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    491e:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4920:	80 91 c8 00 	lds	r24, 0x00C8
    4924:	85 ff       	sbrs	r24, 5
    4926:	fc cf       	rjmp	.-8      	; 0x4920 <UnWriteProtectFlash+0xc>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4928:	80 e5       	ldi	r24, 0x50	; 80
    492a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    492e:	80 91 c8 00 	lds	r24, 0x00C8
    4932:	87 ff       	sbrs	r24, 7
    4934:	fc cf       	rjmp	.-8      	; 0x492e <UnWriteProtectFlash+0x1a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4936:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    493a:	5d 9a       	sbi	0x0b, 5	; 11

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    493c:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    493e:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4940:	80 91 c8 00 	lds	r24, 0x00C8
    4944:	85 ff       	sbrs	r24, 5
    4946:	fc cf       	rjmp	.-8      	; 0x4940 <UnWriteProtectFlash+0x2c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4948:	81 e0       	ldi	r24, 0x01	; 1
    494a:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    494e:	80 91 c8 00 	lds	r24, 0x00C8
    4952:	87 ff       	sbrs	r24, 7
    4954:	fc cf       	rjmp	.-8      	; 0x494e <UnWriteProtectFlash+0x3a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4956:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    495a:	80 91 c8 00 	lds	r24, 0x00C8
    495e:	85 ff       	sbrs	r24, 5
    4960:	fc cf       	rjmp	.-8      	; 0x495a <UnWriteProtectFlash+0x46>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4962:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4966:	80 91 c8 00 	lds	r24, 0x00C8
    496a:	87 ff       	sbrs	r24, 7
    496c:	fc cf       	rjmp	.-8      	; 0x4966 <UnWriteProtectFlash+0x52>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    496e:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4972:	5d 9a       	sbi	0x0b, 5	; 11

	StartExternalFlashTransfer();			// New transaction with flash.
	TransferExternalFlashByte(SST_WRSR);	// Request a status register write.
	TransferExternalFlashByte(0);			// Un-protect all flash by clearing the status register.
	EndExternalFlashTransfer();				// End transfer.
}
    4974:	08 95       	ret

00004976 <GetTestByteFromFlash>:
// This is 4k + 1 because of the sector erase size.
{
	unsigned char
		theByte;

	StartFlashRead(1<<12);							// Begin reading at byte 4096
    4976:	60 e0       	ldi	r22, 0x00	; 0
    4978:	70 e1       	ldi	r23, 0x10	; 16
    497a:	80 e0       	ldi	r24, 0x00	; 0
    497c:	90 e0       	ldi	r25, 0x00	; 0
    497e:	0e 94 c5 23 	call	0x478a	; 0x478a <StartFlashRead>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4982:	80 91 c8 00 	lds	r24, 0x00C8
    4986:	85 ff       	sbrs	r24, 5
    4988:	fc cf       	rjmp	.-8      	; 0x4982 <GetTestByteFromFlash+0xc>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    498a:	8f ef       	ldi	r24, 0xFF	; 255
    498c:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4990:	80 91 c8 00 	lds	r24, 0x00C8
    4994:	87 ff       	sbrs	r24, 7
    4996:	fc cf       	rjmp	.-8      	; 0x4990 <GetTestByteFromFlash+0x1a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4998:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    499c:	5d 9a       	sbi	0x0b, 5	; 11

	StartFlashRead(1<<12);							// Begin reading at byte 4096
	theByte=TransferExternalFlashByte(DUMMY_BYTE);	// Clock in data from the flash.
	EndExternalFlashTransfer();						// End transfer.
	return(theByte);								// Let them know what we got.		
}
    499e:	08 95       	ret

000049a0 <WriteTestByteToFlash>:

void WriteTestByteToFlash(unsigned char theByte)
// Writes a byte to the first separately erasable location in flash after the TOC.
// This is 4k + 1 because of the sector erase size.
// IE, don't clobber TOC during a test.
{
    49a0:	1f 93       	push	r17
    49a2:	18 2f       	mov	r17, r24
	UnWriteProtectFlash();	// Enable writing the flash.
    49a4:	0e 94 8a 24 	call	0x4914	; 0x4914 <UnWriteProtectFlash>

	WriteEnableFlash();			// Send WREN command
    49a8:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>
	EraseFlashSector(1<<12);	// Erase second sector of flash.
    49ac:	60 e0       	ldi	r22, 0x00	; 0
    49ae:	70 e1       	ldi	r23, 0x10	; 16
    49b0:	80 e0       	ldi	r24, 0x00	; 0
    49b2:	90 e0       	ldi	r25, 0x00	; 0
    49b4:	0e 94 0e 24 	call	0x481c	; 0x481c <EraseFlashSector>
	
	WriteEnableFlash();					// Send WREN command
    49b8:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>
	StartFlashPageProgram(1<<12);		// Start programming page at addy 4096
    49bc:	60 e0       	ldi	r22, 0x00	; 0
    49be:	70 e1       	ldi	r23, 0x10	; 16
    49c0:	80 e0       	ldi	r24, 0x00	; 0
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	0e 94 7c 23 	call	0x46f8	; 0x46f8 <StartFlashPageProgram>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    49c8:	80 91 c8 00 	lds	r24, 0x00C8
    49cc:	85 ff       	sbrs	r24, 5
    49ce:	fc cf       	rjmp	.-8      	; 0x49c8 <WriteTestByteToFlash+0x28>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    49d0:	10 93 ce 00 	sts	0x00CE, r17

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    49d4:	80 91 c8 00 	lds	r24, 0x00C8
    49d8:	87 ff       	sbrs	r24, 7
    49da:	fc cf       	rjmp	.-8      	; 0x49d4 <WriteTestByteToFlash+0x34>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    49dc:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    49e0:	5d 9a       	sbi	0x0b, 5	; 11
	WriteEnableFlash();					// Send WREN command
	StartFlashPageProgram(1<<12);		// Start programming page at addy 4096
	TransferExternalFlashByte(theByte);	// Finally!  Put the byte in flash memory.
	EndExternalFlashTransfer();			// End transfer.

	WriteProtectFlash();	// Make flash safe again.
    49e2:	0e 94 58 24 	call	0x48b0	; 0x48b0 <WriteProtectFlash>
}
    49e6:	1f 91       	pop	r17
    49e8:	08 95       	ret

000049ea <IsFlashSlotFull>:
}

bool IsFlashSlotFull(unsigned char slotIndex)
// Returns true if a slot in the TOC is empty.
// An empty spot looks like erased flash, but check that it's not some other bogus value (must be 512k or less)
{
    49ea:	20 e0       	ldi	r18, 0x00	; 0
    49ec:	e8 2f       	mov	r30, r24
    49ee:	f0 e0       	ldi	r31, 0x00	; 0
    49f0:	ee 0f       	add	r30, r30
    49f2:	ff 1f       	adc	r31, r31
    49f4:	ee 0f       	add	r30, r30
    49f6:	ff 1f       	adc	r31, r31
    49f8:	e9 50       	subi	r30, 0x09	; 9
    49fa:	fd 4f       	sbci	r31, 0xFD	; 253
    49fc:	80 81       	ld	r24, Z
    49fe:	91 81       	ldd	r25, Z+1	; 0x01
    4a00:	a2 81       	ldd	r26, Z+2	; 0x02
    4a02:	b3 81       	ldd	r27, Z+3	; 0x03
    4a04:	81 50       	subi	r24, 0x01	; 1
    4a06:	90 40       	sbci	r25, 0x00	; 0
    4a08:	a8 40       	sbci	r26, 0x08	; 8
    4a0a:	b0 40       	sbci	r27, 0x00	; 0
    4a0c:	08 f4       	brcc	.+2      	; 0x4a10 <IsFlashSlotFull+0x26>
    4a0e:	21 e0       	ldi	r18, 0x01	; 1
	}
	else
	{
		return(true);
	}
}
    4a10:	82 2f       	mov	r24, r18
    4a12:	08 95       	ret

00004a14 <WriteSampleToSlot>:
// Takes the sample in the passed bank and puts it into the given slot in flash memory.
// Sample size is not checked since the slots in flash are currently as big as the entire RAM chip.
// This erases the slot in question first (a 512k block) then pauses interrupts once it starts reading from RAM.  The function exits with the ADJUSTED sample in the slot in flash,
// the TOC updated both locally and on the flash, and the sample in RAM unchanged.
// Since a block erase takes 25mS (max) and a page write takes 2.5mS (max) this could take as much as 5.5 seconds to save the longest sample!
{
    4a14:	2f 92       	push	r2
    4a16:	3f 92       	push	r3
    4a18:	4f 92       	push	r4
    4a1a:	5f 92       	push	r5
    4a1c:	6f 92       	push	r6
    4a1e:	7f 92       	push	r7
    4a20:	8f 92       	push	r8
    4a22:	9f 92       	push	r9
    4a24:	af 92       	push	r10
    4a26:	bf 92       	push	r11
    4a28:	cf 92       	push	r12
    4a2a:	df 92       	push	r13
    4a2c:	ef 92       	push	r14
    4a2e:	ff 92       	push	r15
    4a30:	0f 93       	push	r16
    4a32:	1f 93       	push	r17
    4a34:	df 93       	push	r29
    4a36:	cf 93       	push	r28
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
    4a3c:	28 97       	sbiw	r28, 0x08	; 8
    4a3e:	0f b6       	in	r0, 0x3f	; 63
    4a40:	f8 94       	cli
    4a42:	de bf       	out	0x3e, r29	; 62
    4a44:	0f be       	out	0x3f, r0	; 63
    4a46:	cd bf       	out	0x3d, r28	; 61
    4a48:	8a 83       	std	Y+2, r24	; 0x02
	unsigned int
		i;

	// Get important numbers first.

	if(theBank==BANK_0)		// Get the length of the sample.
    4a4a:	88 23       	and	r24, r24
    4a4c:	89 f4       	brne	.+34     	; 0x4a70 <WriteSampleToSlot+0x5c>
	{
		sampleLength=bankStates[BANK_0].adjustedEndAddress-bankStates[BANK_0].adjustedStartAddress;
    4a4e:	60 90 90 02 	lds	r6, 0x0290
    4a52:	70 90 91 02 	lds	r7, 0x0291
    4a56:	80 90 92 02 	lds	r8, 0x0292
    4a5a:	90 90 93 02 	lds	r9, 0x0293
    4a5e:	80 91 94 02 	lds	r24, 0x0294
    4a62:	90 91 95 02 	lds	r25, 0x0295
    4a66:	a0 91 96 02 	lds	r26, 0x0296
    4a6a:	b0 91 97 02 	lds	r27, 0x0297
    4a6e:	10 c0       	rjmp	.+32     	; 0x4a90 <WriteSampleToSlot+0x7c>
	}
	else
	{
		sampleLength=bankStates[BANK_1].adjustedStartAddress-bankStates[BANK_1].adjustedEndAddress;	
    4a70:	60 90 b6 02 	lds	r6, 0x02B6
    4a74:	70 90 b7 02 	lds	r7, 0x02B7
    4a78:	80 90 b8 02 	lds	r8, 0x02B8
    4a7c:	90 90 b9 02 	lds	r9, 0x02B9
    4a80:	80 91 b2 02 	lds	r24, 0x02B2
    4a84:	90 91 b3 02 	lds	r25, 0x02B3
    4a88:	a0 91 b4 02 	lds	r26, 0x02B4
    4a8c:	b0 91 b5 02 	lds	r27, 0x02B5
    4a90:	68 1a       	sub	r6, r24
    4a92:	79 0a       	sbc	r7, r25
    4a94:	8a 0a       	sbc	r8, r26
    4a96:	9b 0a       	sbc	r9, r27
	}

	ramPointer=bankStates[theBank].adjustedStartAddress;	// Where do we start reading from in RAM?
    4a98:	8a 81       	ldd	r24, Y+2	; 0x02
    4a9a:	90 e0       	ldi	r25, 0x00	; 0
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	b5 e0       	ldi	r27, 0x05	; 5
    4aa0:	ee 0f       	add	r30, r30
    4aa2:	ff 1f       	adc	r31, r31
    4aa4:	ba 95       	dec	r27
    4aa6:	e1 f7       	brne	.-8      	; 0x4aa0 <WriteSampleToSlot+0x8c>
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	e8 0f       	add	r30, r24
    4aae:	f9 1f       	adc	r31, r25
    4ab0:	e3 58       	subi	r30, 0x83	; 131
    4ab2:	fd 4f       	sbci	r31, 0xFD	; 253
    4ab4:	a7 88       	ldd	r10, Z+23	; 0x17
    4ab6:	b0 8c       	ldd	r11, Z+24	; 0x18
    4ab8:	c1 8c       	ldd	r12, Z+25	; 0x19
    4aba:	d2 8c       	ldd	r13, Z+26	; 0x1a
	flashWriteStartAddy=(slotIndex+1)*0x80000;	// Get start addy of erase/write (slots are 512k and the first one is 512k in)
    4abc:	86 2f       	mov	r24, r22
    4abe:	90 e0       	ldi	r25, 0x00	; 0
    4ac0:	01 96       	adiw	r24, 0x01	; 1
    4ac2:	1c 01       	movw	r2, r24
    4ac4:	44 24       	eor	r4, r4
    4ac6:	37 fc       	sbrc	r3, 7
    4ac8:	40 94       	com	r4
    4aca:	54 2c       	mov	r5, r4
    4acc:	01 97       	sbiw	r24, 0x01	; 1
    4ace:	98 87       	std	Y+8, r25	; 0x08
    4ad0:	8f 83       	std	Y+7, r24	; 0x07
    4ad2:	f3 e1       	ldi	r31, 0x13	; 19
    4ad4:	22 0c       	add	r2, r2
    4ad6:	33 1c       	adc	r3, r3
    4ad8:	44 1c       	adc	r4, r4
    4ada:	55 1c       	adc	r5, r5
    4adc:	fa 95       	dec	r31
    4ade:	d1 f7       	brne	.-12     	; 0x4ad4 <WriteSampleToSlot+0xc0>
	bytesTransferred=0;		// Nothing in the flash yet

	// Erase flash.

	UnWriteProtectFlash();			// Make flash writeable.
    4ae0:	0e 94 8a 24 	call	0x4914	; 0x4914 <UnWriteProtectFlash>
    4ae4:	82 01       	movw	r16, r4
    4ae6:	71 01       	movw	r14, r2
	
	for(i=0;i<8;i++)		// Erase the slot (512k in 64k chunks)
    4ae8:	d2 01       	movw	r26, r4
    4aea:	c1 01       	movw	r24, r2
    4aec:	80 50       	subi	r24, 0x00	; 0
    4aee:	90 40       	sbci	r25, 0x00	; 0
    4af0:	a8 4f       	sbci	r26, 0xF8	; 248
    4af2:	bf 4f       	sbci	r27, 0xFF	; 255
    4af4:	8b 83       	std	Y+3, r24	; 0x03
    4af6:	9c 83       	std	Y+4, r25	; 0x04
    4af8:	ad 83       	std	Y+5, r26	; 0x05
    4afa:	be 83       	std	Y+6, r27	; 0x06
	{
		WriteEnableFlash();										// Send WREN command
    4afc:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>
static void Erase64kFlashBlock(unsigned long theBlock)
// Sets 64k of flash back to 0xFF.
// Low bits in this command are don't cares.
// Takes 25mS max.
{
	while(!FlashReady())	// Spin while flash is busy.
    4b00:	0e 94 47 23 	call	0x468e	; 0x468e <FlashReady>
    4b04:	88 23       	and	r24, r24
    4b06:	e1 f3       	breq	.-8      	; 0x4b00 <WriteSampleToSlot+0xec>

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4b08:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    4b0a:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b0c:	80 91 c8 00 	lds	r24, 0x00C8
    4b10:	85 ff       	sbrs	r24, 5
    4b12:	fc cf       	rjmp	.-8      	; 0x4b0c <WriteSampleToSlot+0xf8>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b14:	98 ed       	ldi	r25, 0xD8	; 216
    4b16:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b1a:	80 91 c8 00 	lds	r24, 0x00C8
    4b1e:	87 ff       	sbrs	r24, 7
    4b20:	fc cf       	rjmp	.-8      	; 0x4b1a <WriteSampleToSlot+0x106>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b22:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b26:	80 91 c8 00 	lds	r24, 0x00C8
    4b2a:	85 ff       	sbrs	r24, 5
    4b2c:	fc cf       	rjmp	.-8      	; 0x4b26 <WriteSampleToSlot+0x112>
	while(!FlashReady())	// Spin while flash is busy.
		;

	StartExternalFlashTransfer();					// New transaction with flash.
	TransferExternalFlashByte(SST_64K_BLOCK_ERASE);	// Set 64k of flash back to 0xFF
	TransferExternalFlashByte(theBlock>>16);	// (MSB of addy)
    4b2e:	c8 01       	movw	r24, r16
    4b30:	aa 27       	eor	r26, r26
    4b32:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b34:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b38:	80 91 c8 00 	lds	r24, 0x00C8
    4b3c:	87 ff       	sbrs	r24, 7
    4b3e:	fc cf       	rjmp	.-8      	; 0x4b38 <WriteSampleToSlot+0x124>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b40:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b44:	80 91 c8 00 	lds	r24, 0x00C8
    4b48:	85 ff       	sbrs	r24, 5
    4b4a:	fc cf       	rjmp	.-8      	; 0x4b44 <WriteSampleToSlot+0x130>
		;

	StartExternalFlashTransfer();					// New transaction with flash.
	TransferExternalFlashByte(SST_64K_BLOCK_ERASE);	// Set 64k of flash back to 0xFF
	TransferExternalFlashByte(theBlock>>16);	// (MSB of addy)
	TransferExternalFlashByte(theBlock>>8);		// addy cont'd
    4b4c:	bb 27       	eor	r27, r27
    4b4e:	a1 2f       	mov	r26, r17
    4b50:	90 2f       	mov	r25, r16
    4b52:	8f 2d       	mov	r24, r15
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b54:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b58:	80 91 c8 00 	lds	r24, 0x00C8
    4b5c:	87 ff       	sbrs	r24, 7
    4b5e:	fc cf       	rjmp	.-8      	; 0x4b58 <WriteSampleToSlot+0x144>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b60:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4b64:	80 91 c8 00 	lds	r24, 0x00C8
    4b68:	85 ff       	sbrs	r24, 5
    4b6a:	fc cf       	rjmp	.-8      	; 0x4b64 <WriteSampleToSlot+0x150>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4b6c:	10 92 ce 00 	sts	0x00CE, r1

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4b70:	80 91 c8 00 	lds	r24, 0x00C8
    4b74:	87 ff       	sbrs	r24, 7
    4b76:	fc cf       	rjmp	.-8      	; 0x4b70 <WriteSampleToSlot+0x15c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4b78:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4b7c:	5d 9a       	sbi	0x0b, 5	; 11
    4b7e:	80 e0       	ldi	r24, 0x00	; 0
    4b80:	90 e0       	ldi	r25, 0x00	; 0
    4b82:	a1 e0       	ldi	r26, 0x01	; 1
    4b84:	b0 e0       	ldi	r27, 0x00	; 0
    4b86:	e8 0e       	add	r14, r24
    4b88:	f9 1e       	adc	r15, r25
    4b8a:	0a 1f       	adc	r16, r26
    4b8c:	1b 1f       	adc	r17, r27

	// Erase flash.

	UnWriteProtectFlash();			// Make flash writeable.
	
	for(i=0;i<8;i++)		// Erase the slot (512k in 64k chunks)
    4b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b90:	9c 81       	ldd	r25, Y+4	; 0x04
    4b92:	ad 81       	ldd	r26, Y+5	; 0x05
    4b94:	be 81       	ldd	r27, Y+6	; 0x06
    4b96:	e8 16       	cp	r14, r24
    4b98:	f9 06       	cpc	r15, r25
    4b9a:	0a 07       	cpc	r16, r26
    4b9c:	1b 07       	cpc	r17, r27
    4b9e:	09 f0       	breq	.+2      	; 0x4ba2 <WriteSampleToSlot+0x18e>
    4ba0:	ad cf       	rjmp	.-166    	; 0x4afc <WriteSampleToSlot+0xe8>
		Erase64kFlashBlock(flashWriteStartAddy+(i*0x10000));	// Erase flash 64k at a time.	
	}

	// Begin pulling in samples from RAM and putting them into the flash, page by page.

	sreg=SREG;		// Pause interrupts while we mess with RAM.
    4ba2:	9f b7       	in	r25, 0x3f	; 63
    4ba4:	99 83       	std	Y+1, r25	; 0x01
	cli();
    4ba6:	f8 94       	cli
    4ba8:	ee 24       	eor	r14, r14
    4baa:	ff 24       	eor	r15, r15
    4bac:	87 01       	movw	r16, r14
    4bae:	59 c0       	rjmp	.+178    	; 0x4c62 <WriteSampleToSlot+0x24e>
		
	while(bytesTransferred<sampleLength)	// While we've still got bytes to transfer, transfer them.
	{
		WriteEnableFlash();												// Send WREN command
    4bb0:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>
		StartFlashPageProgram(flashWriteStartAddy+bytesTransferred);	// Start page transfer (should always be on 256 byte boundary)
    4bb4:	c8 01       	movw	r24, r16
    4bb6:	b7 01       	movw	r22, r14
    4bb8:	62 0d       	add	r22, r2
    4bba:	73 1d       	adc	r23, r3
    4bbc:	84 1d       	adc	r24, r4
    4bbe:	95 1d       	adc	r25, r5
    4bc0:	0e 94 7c 23 	call	0x46f8	; 0x46f8 <StartFlashPageProgram>
    4bc4:	a8 01       	movw	r20, r16
    4bc6:	97 01       	movw	r18, r14

		for(i=0;i<256;i++)	// Load flash's buffer with 256 bytes.
    4bc8:	e1 2c       	mov	r14, r1
    4bca:	61 e0       	ldi	r22, 0x01	; 1
    4bcc:	f6 2e       	mov	r15, r22
    4bce:	01 2d       	mov	r16, r1
    4bd0:	11 2d       	mov	r17, r1
    4bd2:	e2 0e       	add	r14, r18
    4bd4:	f3 1e       	adc	r15, r19
    4bd6:	04 1f       	adc	r16, r20
    4bd8:	15 1f       	adc	r17, r21
		{
			// Get the byte from SRAM
			LATCH_PORT=(ramPointer&0xFF);			// Put the LSB of the address on the latch.
    4bda:	a5 b8       	out	0x05, r10	; 5
			PORTA|=(Om_RAM_L_ADR_LA);				// Strobe it to the latch output...
    4bdc:	13 9a       	sbi	0x02, 3	; 2
			PORTA&=~(Om_RAM_L_ADR_LA);				// ...Keep it there.
    4bde:	13 98       	cbi	0x02, 3	; 2

			LATCH_PORT=((ramPointer>>8)&0xFF);		// Put the middle byte of the address on the latch.
    4be0:	bb 27       	eor	r27, r27
    4be2:	ad 2d       	mov	r26, r13
    4be4:	9c 2d       	mov	r25, r12
    4be6:	8b 2d       	mov	r24, r11
    4be8:	85 b9       	out	0x05, r24	; 5
			PORTA|=(Om_RAM_H_ADR_LA);				// Strobe it to the latch output...
    4bea:	14 9a       	sbi	0x02, 4	; 2
			PORTA&=~(Om_RAM_H_ADR_LA);				// ...Keep it there.
    4bec:	14 98       	cbi	0x02, 4	; 2

			PORTC=(0x08|((ramPointer>>16)&0x07));	// Keep the switch OE high (hi z) (PC3) and the unused pins (PC4-7) low, and put the high addy bits on 0-2.
    4bee:	c6 01       	movw	r24, r12
    4bf0:	aa 27       	eor	r26, r26
    4bf2:	bb 27       	eor	r27, r27
    4bf4:	87 70       	andi	r24, 0x07	; 7
    4bf6:	88 60       	ori	r24, 0x08	; 8
    4bf8:	88 b9       	out	0x08, r24	; 8

			LATCH_DDR=0x00;						// Turn the data bus around (AVR's data port to inputs)
    4bfa:	14 b8       	out	0x04, r1	; 4
			PORTA&=~(Om_RAM_OE);				// RAM's IO pins to outputs.
    4bfc:	12 98       	cbi	0x02, 2	; 2

			asm volatile("nop"::);				// @@@ This is the magic spot for turn around time. All the other delays are unnecessary but we need at least this much delay (two nops) here for bus turnaround.  No delay gives no signal, and one nop is crusty.  Try to elegant this up later.
    4bfe:	00 00       	nop
			asm volatile("nop"::);
    4c00:	00 00       	nop
			
			byteToTransfer=LATCH_INPUT;				// Get the byte from this address in RAM.
    4c02:	93 b1       	in	r25, 0x03	; 3

			PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    4c04:	12 9a       	sbi	0x02, 2	; 2
			LATCH_DDR=0xFF;						// Turn the data bus around (AVR's data port to outputs)
    4c06:	af ef       	ldi	r26, 0xFF	; 255
    4c08:	a4 b9       	out	0x04, r26	; 4

			if(theBank==BANK_0)					// Move up in lower bank, move down in upper.
    4c0a:	ba 81       	ldd	r27, Y+2	; 0x02
    4c0c:	bb 23       	and	r27, r27
    4c0e:	31 f4       	brne	.+12     	; 0x4c1c <WriteSampleToSlot+0x208>
			{
				ramPointer++;
    4c10:	08 94       	sec
    4c12:	a1 1c       	adc	r10, r1
    4c14:	b1 1c       	adc	r11, r1
    4c16:	c1 1c       	adc	r12, r1
    4c18:	d1 1c       	adc	r13, r1
    4c1a:	05 c0       	rjmp	.+10     	; 0x4c26 <WriteSampleToSlot+0x212>
			}
			else
			{
				ramPointer--;
    4c1c:	08 94       	sec
    4c1e:	a1 08       	sbc	r10, r1
    4c20:	b1 08       	sbc	r11, r1
    4c22:	c1 08       	sbc	r12, r1
    4c24:	d1 08       	sbc	r13, r1
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4c26:	80 91 c8 00 	lds	r24, 0x00C8
    4c2a:	85 ff       	sbrs	r24, 5
    4c2c:	fc cf       	rjmp	.-8      	; 0x4c26 <WriteSampleToSlot+0x212>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4c2e:	90 93 ce 00 	sts	0x00CE, r25

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4c32:	80 91 c8 00 	lds	r24, 0x00C8
    4c36:	87 ff       	sbrs	r24, 7
    4c38:	fc cf       	rjmp	.-8      	; 0x4c32 <WriteSampleToSlot+0x21e>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4c3a:	80 91 ce 00 	lds	r24, 0x00CE
				ramPointer--;
			}

			// Put our byte in the flash
			TransferExternalFlashByte(byteToTransfer);	// Put the byte in flash.			
			bytesTransferred++;
    4c3e:	2f 5f       	subi	r18, 0xFF	; 255
    4c40:	3f 4f       	sbci	r19, 0xFF	; 255
    4c42:	4f 4f       	sbci	r20, 0xFF	; 255
    4c44:	5f 4f       	sbci	r21, 0xFF	; 255

			if(bytesTransferred==sampleLength)	// Break out of the for loop when the last page is a partial one.
    4c46:	26 15       	cp	r18, r6
    4c48:	37 05       	cpc	r19, r7
    4c4a:	48 05       	cpc	r20, r8
    4c4c:	59 05       	cpc	r21, r9
    4c4e:	31 f0       	breq	.+12     	; 0x4c5c <WriteSampleToSlot+0x248>
	while(bytesTransferred<sampleLength)	// While we've still got bytes to transfer, transfer them.
	{
		WriteEnableFlash();												// Send WREN command
		StartFlashPageProgram(flashWriteStartAddy+bytesTransferred);	// Start page transfer (should always be on 256 byte boundary)

		for(i=0;i<256;i++)	// Load flash's buffer with 256 bytes.
    4c50:	2e 15       	cp	r18, r14
    4c52:	3f 05       	cpc	r19, r15
    4c54:	40 07       	cpc	r20, r16
    4c56:	51 07       	cpc	r21, r17
    4c58:	09 f0       	breq	.+2      	; 0x4c5c <WriteSampleToSlot+0x248>
    4c5a:	bf cf       	rjmp	.-130    	; 0x4bda <WriteSampleToSlot+0x1c6>
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4c5c:	5d 9a       	sbi	0x0b, 5	; 11
    4c5e:	79 01       	movw	r14, r18
    4c60:	8a 01       	movw	r16, r20
	// Begin pulling in samples from RAM and putting them into the flash, page by page.

	sreg=SREG;		// Pause interrupts while we mess with RAM.
	cli();
		
	while(bytesTransferred<sampleLength)	// While we've still got bytes to transfer, transfer them.
    4c62:	e6 14       	cp	r14, r6
    4c64:	f7 04       	cpc	r15, r7
    4c66:	08 05       	cpc	r16, r8
    4c68:	19 05       	cpc	r17, r9
    4c6a:	08 f4       	brcc	.+2      	; 0x4c6e <WriteSampleToSlot+0x25a>
    4c6c:	a1 cf       	rjmp	.-190    	; 0x4bb0 <WriteSampleToSlot+0x19c>
		EndExternalFlashTransfer();			// End the page program command.	
	}

	// Sample is transferred.  Now update TOC.
	
	flashToc[slotIndex]=sampleLength;	// Update local copy.
    4c6e:	ef 81       	ldd	r30, Y+7	; 0x07
    4c70:	f8 85       	ldd	r31, Y+8	; 0x08
    4c72:	ee 0f       	add	r30, r30
    4c74:	ff 1f       	adc	r31, r31
    4c76:	ee 0f       	add	r30, r30
    4c78:	ff 1f       	adc	r31, r31
    4c7a:	e9 50       	subi	r30, 0x09	; 9
    4c7c:	fd 4f       	sbci	r31, 0xFD	; 253
    4c7e:	60 82       	st	Z, r6
    4c80:	71 82       	std	Z+1, r7	; 0x01
    4c82:	82 82       	std	Z+2, r8	; 0x02
    4c84:	93 82       	std	Z+3, r9	; 0x03
// Updates table of contents in external memory.
{
	unsigned char
		i;

	UnWriteProtectFlash();	// Enable writing the flash.
    4c86:	0e 94 8a 24 	call	0x4914	; 0x4914 <UnWriteProtectFlash>

	WriteEnableFlash();		// Send WREN command
    4c8a:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>
	EraseFlashSector(0);	// Erase first sector of flash.
    4c8e:	60 e0       	ldi	r22, 0x00	; 0
    4c90:	70 e0       	ldi	r23, 0x00	; 0
    4c92:	80 e0       	ldi	r24, 0x00	; 0
    4c94:	90 e0       	ldi	r25, 0x00	; 0
    4c96:	0e 94 0e 24 	call	0x481c	; 0x481c <EraseFlashSector>

	WriteEnableFlash();		// Send WREN command
    4c9a:	0e 94 67 23 	call	0x46ce	; 0x46ce <WriteEnableFlash>

	StartFlashPageProgram(0);			// Start programming page at addy 0
    4c9e:	60 e0       	ldi	r22, 0x00	; 0
    4ca0:	70 e0       	ldi	r23, 0x00	; 0
    4ca2:	80 e0       	ldi	r24, 0x00	; 0
    4ca4:	90 e0       	ldi	r25, 0x00	; 0
    4ca6:	0e 94 7c 23 	call	0x46f8	; 0x46f8 <StartFlashPageProgram>
    4caa:	e7 ef       	ldi	r30, 0xF7	; 247
    4cac:	f2 e0       	ldi	r31, 0x02	; 2

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
	{
		TransferExternalFlashByte(flashToc[i]>>24);	// MSByte (right shift prepends with zeros when unsigned)
    4cae:	20 81       	ld	r18, Z
    4cb0:	31 81       	ldd	r19, Z+1	; 0x01
    4cb2:	42 81       	ldd	r20, Z+2	; 0x02
    4cb4:	53 81       	ldd	r21, Z+3	; 0x03
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4cb6:	80 91 c8 00 	lds	r24, 0x00C8
    4cba:	85 ff       	sbrs	r24, 5
    4cbc:	fc cf       	rjmp	.-8      	; 0x4cb6 <WriteSampleToSlot+0x2a2>

	StartFlashPageProgram(0);			// Start programming page at addy 0

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
	{
		TransferExternalFlashByte(flashToc[i]>>24);	// MSByte (right shift prepends with zeros when unsigned)
    4cbe:	85 2f       	mov	r24, r21
    4cc0:	99 27       	eor	r25, r25
    4cc2:	aa 27       	eor	r26, r26
    4cc4:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4cc6:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4cca:	80 91 c8 00 	lds	r24, 0x00C8
    4cce:	87 ff       	sbrs	r24, 7
    4cd0:	fc cf       	rjmp	.-8      	; 0x4cca <WriteSampleToSlot+0x2b6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4cd2:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4cd6:	80 91 c8 00 	lds	r24, 0x00C8
    4cda:	85 ff       	sbrs	r24, 5
    4cdc:	fc cf       	rjmp	.-8      	; 0x4cd6 <WriteSampleToSlot+0x2c2>
	StartFlashPageProgram(0);			// Start programming page at addy 0

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
	{
		TransferExternalFlashByte(flashToc[i]>>24);	// MSByte (right shift prepends with zeros when unsigned)
		TransferExternalFlashByte(flashToc[i]>>16);	// MSByte-1.
    4cde:	ca 01       	movw	r24, r20
    4ce0:	aa 27       	eor	r26, r26
    4ce2:	bb 27       	eor	r27, r27
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4ce4:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4ce8:	80 91 c8 00 	lds	r24, 0x00C8
    4cec:	87 ff       	sbrs	r24, 7
    4cee:	fc cf       	rjmp	.-8      	; 0x4ce8 <WriteSampleToSlot+0x2d4>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4cf0:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4cf4:	80 91 c8 00 	lds	r24, 0x00C8
    4cf8:	85 ff       	sbrs	r24, 5
    4cfa:	fc cf       	rjmp	.-8      	; 0x4cf4 <WriteSampleToSlot+0x2e0>

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
	{
		TransferExternalFlashByte(flashToc[i]>>24);	// MSByte (right shift prepends with zeros when unsigned)
		TransferExternalFlashByte(flashToc[i]>>16);	// MSByte-1.
		TransferExternalFlashByte(flashToc[i]>>8);	// MSByte-2.
    4cfc:	bb 27       	eor	r27, r27
    4cfe:	a5 2f       	mov	r26, r21
    4d00:	94 2f       	mov	r25, r20
    4d02:	83 2f       	mov	r24, r19
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4d04:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4d08:	80 91 c8 00 	lds	r24, 0x00C8
    4d0c:	87 ff       	sbrs	r24, 7
    4d0e:	fc cf       	rjmp	.-8      	; 0x4d08 <WriteSampleToSlot+0x2f4>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4d10:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4d14:	80 91 c8 00 	lds	r24, 0x00C8
    4d18:	85 ff       	sbrs	r24, 5
    4d1a:	fc cf       	rjmp	.-8      	; 0x4d14 <WriteSampleToSlot+0x300>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4d1c:	20 93 ce 00 	sts	0x00CE, r18

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4d20:	80 91 c8 00 	lds	r24, 0x00C8
    4d24:	87 ff       	sbrs	r24, 7
    4d26:	fc cf       	rjmp	.-8      	; 0x4d20 <WriteSampleToSlot+0x30c>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4d28:	80 91 ce 00 	lds	r24, 0x00CE
    4d2c:	34 96       	adiw	r30, 0x04	; 4

	WriteEnableFlash();		// Send WREN command

	StartFlashPageProgram(0);			// Start programming page at addy 0

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
    4d2e:	b3 e0       	ldi	r27, 0x03	; 3
    4d30:	e3 33       	cpi	r30, 0x33	; 51
    4d32:	fb 07       	cpc	r31, r27
    4d34:	09 f0       	breq	.+2      	; 0x4d38 <WriteSampleToSlot+0x324>
    4d36:	bb cf       	rjmp	.-138    	; 0x4cae <WriteSampleToSlot+0x29a>
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4d38:	5d 9a       	sbi	0x0b, 5	; 11
		TransferExternalFlashByte(flashToc[i]>>8);	// MSByte-2.
		TransferExternalFlashByte(flashToc[i]);		// LSByte (drops high order bits when recast).
	}			

	EndExternalFlashTransfer();			// End transfer.
	WriteProtectFlash();				// Make flash safe again.
    4d3a:	0e 94 58 24 	call	0x48b0	; 0x48b0 <WriteProtectFlash>

	// Sample is transferred.  Now update TOC.
	
	flashToc[slotIndex]=sampleLength;	// Update local copy.
	WriteTocToFlash();					// Put it in flash (this exits write protected).
	SREG=sreg;							// Re-enable interrupts.
    4d3e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d40:	ef bf       	out	0x3f, r30	; 63
}
    4d42:	28 96       	adiw	r28, 0x08	; 8
    4d44:	0f b6       	in	r0, 0x3f	; 63
    4d46:	f8 94       	cli
    4d48:	de bf       	out	0x3e, r29	; 62
    4d4a:	0f be       	out	0x3f, r0	; 63
    4d4c:	cd bf       	out	0x3d, r28	; 61
    4d4e:	cf 91       	pop	r28
    4d50:	df 91       	pop	r29
    4d52:	1f 91       	pop	r17
    4d54:	0f 91       	pop	r16
    4d56:	ff 90       	pop	r15
    4d58:	ef 90       	pop	r14
    4d5a:	df 90       	pop	r13
    4d5c:	cf 90       	pop	r12
    4d5e:	bf 90       	pop	r11
    4d60:	af 90       	pop	r10
    4d62:	9f 90       	pop	r9
    4d64:	8f 90       	pop	r8
    4d66:	7f 90       	pop	r7
    4d68:	6f 90       	pop	r6
    4d6a:	5f 90       	pop	r5
    4d6c:	4f 90       	pop	r4
    4d6e:	3f 90       	pop	r3
    4d70:	2f 90       	pop	r2
    4d72:	08 95       	ret

00004d74 <ReadSampleFromSlot>:

void ReadSampleFromSlot(unsigned char theBank, unsigned char slotIndex)
// Gets the sample from the passed slot in flash and puts it into a bank in RAM.
{
    4d74:	8f 92       	push	r8
    4d76:	9f 92       	push	r9
    4d78:	af 92       	push	r10
    4d7a:	bf 92       	push	r11
    4d7c:	df 92       	push	r13
    4d7e:	ef 92       	push	r14
    4d80:	ff 92       	push	r15
    4d82:	0f 93       	push	r16
    4d84:	1f 93       	push	r17
    4d86:	cf 93       	push	r28
    4d88:	df 93       	push	r29
    4d8a:	d8 2e       	mov	r13, r24
		flashReadStartAddy,		// Slots get turned into flash-releveant addresses
		bytesTransferred;		// Counts bytes as they move from ram to flash

	// Get important numbers first.

	flashReadStartAddy=(slotIndex+1)*0x80000;		// Get start addy of erase/write (slots are 512k and the first one is 512k in)
    4d8c:	c6 2f       	mov	r28, r22
    4d8e:	d0 e0       	ldi	r29, 0x00	; 0
	bytesTransferred=0;								// Nothing in the flash yet

	// Begin pulling in samples from flash and loading them into RAM

	StartFlashRead(flashReadStartAddy);
    4d90:	21 96       	adiw	r28, 0x01	; 1
    4d92:	be 01       	movw	r22, r28
    4d94:	88 27       	eor	r24, r24
    4d96:	77 fd       	sbrc	r23, 7
    4d98:	80 95       	com	r24
    4d9a:	98 2f       	mov	r25, r24
    4d9c:	21 97       	sbiw	r28, 0x01	; 1
    4d9e:	43 e1       	ldi	r20, 0x13	; 19
    4da0:	66 0f       	add	r22, r22
    4da2:	77 1f       	adc	r23, r23
    4da4:	88 1f       	adc	r24, r24
    4da6:	99 1f       	adc	r25, r25
    4da8:	4a 95       	dec	r20
    4daa:	d1 f7       	brne	.-12     	; 0x4da0 <ReadSampleFromSlot+0x2c>
    4dac:	0e 94 c5 23 	call	0x478a	; 0x478a <StartFlashRead>

	sreg=SREG;		// Pause interrupts while we mess with RAM.
    4db0:	6f b7       	in	r22, 0x3f	; 63
	cli();
    4db2:	f8 94       	cli

	bankStates[theBank].currentAddress=bankStates[theBank].startAddress;	// Sync indices with the new sample that's going into RAM
    4db4:	8d 2d       	mov	r24, r13
    4db6:	90 e0       	ldi	r25, 0x00	; 0
    4db8:	fc 01       	movw	r30, r24
    4dba:	35 e0       	ldi	r19, 0x05	; 5
    4dbc:	ee 0f       	add	r30, r30
    4dbe:	ff 1f       	adc	r31, r31
    4dc0:	3a 95       	dec	r19
    4dc2:	e1 f7       	brne	.-8      	; 0x4dbc <ReadSampleFromSlot+0x48>
    4dc4:	88 0f       	add	r24, r24
    4dc6:	99 1f       	adc	r25, r25
    4dc8:	e8 0f       	add	r30, r24
    4dca:	f9 1f       	adc	r31, r25
    4dcc:	e3 58       	subi	r30, 0x83	; 131
    4dce:	fd 4f       	sbci	r31, 0xFD	; 253
    4dd0:	27 85       	ldd	r18, Z+15	; 0x0f
    4dd2:	30 89       	ldd	r19, Z+16	; 0x10
    4dd4:	41 89       	ldd	r20, Z+17	; 0x11
    4dd6:	52 89       	ldd	r21, Z+18	; 0x12
    4dd8:	8d 2d       	mov	r24, r13
    4dda:	90 e0       	ldi	r25, 0x00	; 0
    4ddc:	fc 01       	movw	r30, r24
    4dde:	05 e0       	ldi	r16, 0x05	; 5
    4de0:	ee 0f       	add	r30, r30
    4de2:	ff 1f       	adc	r31, r31
    4de4:	0a 95       	dec	r16
    4de6:	e1 f7       	brne	.-8      	; 0x4de0 <ReadSampleFromSlot+0x6c>
    4de8:	88 0f       	add	r24, r24
    4dea:	99 1f       	adc	r25, r25
    4dec:	e8 0f       	add	r30, r24
    4dee:	f9 1f       	adc	r31, r25
    4df0:	e3 58       	subi	r30, 0x83	; 131
    4df2:	fd 4f       	sbci	r31, 0xFD	; 253
    4df4:	26 8f       	std	Z+30, r18	; 0x1e
    4df6:	37 8f       	std	Z+31, r19	; 0x1f
    4df8:	40 a3       	std	Z+32, r20	; 0x20
    4dfa:	51 a3       	std	Z+33, r21	; 0x21
	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
    4dfc:	8d 2d       	mov	r24, r13
    4dfe:	90 e0       	ldi	r25, 0x00	; 0
    4e00:	fc 01       	movw	r30, r24
    4e02:	b5 e0       	ldi	r27, 0x05	; 5
    4e04:	ee 0f       	add	r30, r30
    4e06:	ff 1f       	adc	r31, r31
    4e08:	ba 95       	dec	r27
    4e0a:	e1 f7       	brne	.-8      	; 0x4e04 <ReadSampleFromSlot+0x90>
    4e0c:	88 0f       	add	r24, r24
    4e0e:	99 1f       	adc	r25, r25
    4e10:	e8 0f       	add	r30, r24
    4e12:	f9 1f       	adc	r31, r25
    4e14:	e3 58       	subi	r30, 0x83	; 131
    4e16:	fd 4f       	sbci	r31, 0xFD	; 253
    4e18:	27 85       	ldd	r18, Z+15	; 0x0f
    4e1a:	30 89       	ldd	r19, Z+16	; 0x10
    4e1c:	41 89       	ldd	r20, Z+17	; 0x11
    4e1e:	52 89       	ldd	r21, Z+18	; 0x12
    4e20:	8d 2d       	mov	r24, r13
    4e22:	90 e0       	ldi	r25, 0x00	; 0
    4e24:	fc 01       	movw	r30, r24
    4e26:	75 e0       	ldi	r23, 0x05	; 5
    4e28:	ee 0f       	add	r30, r30
    4e2a:	ff 1f       	adc	r31, r31
    4e2c:	7a 95       	dec	r23
    4e2e:	e1 f7       	brne	.-8      	; 0x4e28 <ReadSampleFromSlot+0xb4>
    4e30:	88 0f       	add	r24, r24
    4e32:	99 1f       	adc	r25, r25
    4e34:	e8 0f       	add	r30, r24
    4e36:	f9 1f       	adc	r31, r25
    4e38:	e3 58       	subi	r30, 0x83	; 131
    4e3a:	fd 4f       	sbci	r31, 0xFD	; 253
    4e3c:	27 8b       	std	Z+23, r18	; 0x17
    4e3e:	30 8f       	std	Z+24, r19	; 0x18
    4e40:	41 8f       	std	Z+25, r20	; 0x19
    4e42:	52 8f       	std	Z+26, r21	; 0x1a
	LATCH_DDR=0xFF;						// Data bus to output
    4e44:	8f ef       	ldi	r24, 0xFF	; 255
    4e46:	84 b9       	out	0x04, r24	; 4
	PORTA|=(Om_RAM_OE);					// Tristate the RAM.
    4e48:	12 9a       	sbi	0x02, 2	; 2
		
	while(bytesTransferred<flashToc[slotIndex])	// While we've still got bytes to transfer, transfer them.
    4e4a:	cc 0f       	add	r28, r28
    4e4c:	dd 1f       	adc	r29, r29
    4e4e:	cc 0f       	add	r28, r28
    4e50:	dd 1f       	adc	r29, r29
    4e52:	c9 50       	subi	r28, 0x09	; 9
    4e54:	dd 4f       	sbci	r29, 0xFD	; 253
    4e56:	88 80       	ld	r8, Y
    4e58:	99 80       	ldd	r9, Y+1	; 0x01
    4e5a:	aa 80       	ldd	r10, Y+2	; 0x02
    4e5c:	bb 80       	ldd	r11, Y+3	; 0x03
    4e5e:	ee 24       	eor	r14, r14
    4e60:	ff 24       	eor	r15, r15
    4e62:	87 01       	movw	r16, r14
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4e64:	7f ef       	ldi	r23, 0xFF	; 255
    4e66:	9c c0       	rjmp	.+312    	; 0x4fa0 <ReadSampleFromSlot+0x22c>
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    4e68:	80 91 c8 00 	lds	r24, 0x00C8
    4e6c:	85 ff       	sbrs	r24, 5
    4e6e:	fc cf       	rjmp	.-8      	; 0x4e68 <ReadSampleFromSlot+0xf4>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    4e70:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    4e74:	80 91 c8 00 	lds	r24, 0x00C8
    4e78:	87 ff       	sbrs	r24, 7
    4e7a:	fc cf       	rjmp	.-8      	; 0x4e74 <ReadSampleFromSlot+0x100>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    4e7c:	20 91 ce 00 	lds	r18, 0x00CE
		
	while(bytesTransferred<flashToc[slotIndex])	// While we've still got bytes to transfer, transfer them.
	{
		byteToTransfer=TransferExternalFlashByte(DUMMY_BYTE);	// Get byte from flash

		LATCH_PORT=(bankStates[theBank].currentAddress&0xFF);	// Put the LSB of the address on the latch.
    4e80:	8d 2d       	mov	r24, r13
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	fc 01       	movw	r30, r24
    4e86:	b5 e0       	ldi	r27, 0x05	; 5
    4e88:	ee 0f       	add	r30, r30
    4e8a:	ff 1f       	adc	r31, r31
    4e8c:	ba 95       	dec	r27
    4e8e:	e1 f7       	brne	.-8      	; 0x4e88 <ReadSampleFromSlot+0x114>
    4e90:	88 0f       	add	r24, r24
    4e92:	99 1f       	adc	r25, r25
    4e94:	e8 0f       	add	r30, r24
    4e96:	f9 1f       	adc	r31, r25
    4e98:	e3 58       	subi	r30, 0x83	; 131
    4e9a:	fd 4f       	sbci	r31, 0xFD	; 253
    4e9c:	86 8d       	ldd	r24, Z+30	; 0x1e
    4e9e:	97 8d       	ldd	r25, Z+31	; 0x1f
    4ea0:	a0 a1       	ldd	r26, Z+32	; 0x20
    4ea2:	b1 a1       	ldd	r27, Z+33	; 0x21
    4ea4:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_L_ADR_LA);								// Strobe it to the latch output...
    4ea6:	13 9a       	sbi	0x02, 3	; 2
		PORTA&=~(Om_RAM_L_ADR_LA);								// ...Keep it there.
    4ea8:	13 98       	cbi	0x02, 3	; 2

		LATCH_PORT=((bankStates[theBank].currentAddress>>8)&0xFF);	// Put the middle byte of the address on the latch.
    4eaa:	8d 2d       	mov	r24, r13
    4eac:	90 e0       	ldi	r25, 0x00	; 0
    4eae:	fc 01       	movw	r30, r24
    4eb0:	55 e0       	ldi	r21, 0x05	; 5
    4eb2:	ee 0f       	add	r30, r30
    4eb4:	ff 1f       	adc	r31, r31
    4eb6:	5a 95       	dec	r21
    4eb8:	e1 f7       	brne	.-8      	; 0x4eb2 <ReadSampleFromSlot+0x13e>
    4eba:	88 0f       	add	r24, r24
    4ebc:	99 1f       	adc	r25, r25
    4ebe:	e8 0f       	add	r30, r24
    4ec0:	f9 1f       	adc	r31, r25
    4ec2:	e3 58       	subi	r30, 0x83	; 131
    4ec4:	fd 4f       	sbci	r31, 0xFD	; 253
    4ec6:	86 8d       	ldd	r24, Z+30	; 0x1e
    4ec8:	97 8d       	ldd	r25, Z+31	; 0x1f
    4eca:	a0 a1       	ldd	r26, Z+32	; 0x20
    4ecc:	b1 a1       	ldd	r27, Z+33	; 0x21
    4ece:	89 2f       	mov	r24, r25
    4ed0:	9a 2f       	mov	r25, r26
    4ed2:	ab 2f       	mov	r26, r27
    4ed4:	bb 27       	eor	r27, r27
    4ed6:	85 b9       	out	0x05, r24	; 5
		PORTA|=(Om_RAM_H_ADR_LA);									// Strobe it to the latch output...
    4ed8:	14 9a       	sbi	0x02, 4	; 2
		PORTA&=~(Om_RAM_H_ADR_LA);									// ...Keep it there.
    4eda:	14 98       	cbi	0x02, 4	; 2

		PORTC=(0x08|((bankStates[theBank].currentAddress>>16)&0x07));	// Keep the switch OE high (hi z) (PC3) and the unused pins (PC4-7) low, and put the high addy bits on 0-2.
    4edc:	8d 2d       	mov	r24, r13
    4ede:	90 e0       	ldi	r25, 0x00	; 0
    4ee0:	fc 01       	movw	r30, r24
    4ee2:	b5 e0       	ldi	r27, 0x05	; 5
    4ee4:	ee 0f       	add	r30, r30
    4ee6:	ff 1f       	adc	r31, r31
    4ee8:	ba 95       	dec	r27
    4eea:	e1 f7       	brne	.-8      	; 0x4ee4 <ReadSampleFromSlot+0x170>
    4eec:	88 0f       	add	r24, r24
    4eee:	99 1f       	adc	r25, r25
    4ef0:	e8 0f       	add	r30, r24
    4ef2:	f9 1f       	adc	r31, r25
    4ef4:	e3 58       	subi	r30, 0x83	; 131
    4ef6:	fd 4f       	sbci	r31, 0xFD	; 253
    4ef8:	86 8d       	ldd	r24, Z+30	; 0x1e
    4efa:	97 8d       	ldd	r25, Z+31	; 0x1f
    4efc:	a0 a1       	ldd	r26, Z+32	; 0x20
    4efe:	b1 a1       	ldd	r27, Z+33	; 0x21
    4f00:	cd 01       	movw	r24, r26
    4f02:	aa 27       	eor	r26, r26
    4f04:	bb 27       	eor	r27, r27
    4f06:	87 70       	andi	r24, 0x07	; 7
    4f08:	88 60       	ori	r24, 0x08	; 8
    4f0a:	88 b9       	out	0x08, r24	; 8

		LATCH_PORT=byteToTransfer;				// Put the data to write on the RAM's input port
    4f0c:	25 b9       	out	0x05, r18	; 5

		PORTA&=~(Om_RAM_WE);				// Strobe Write Enable low.  This latches the data in.
    4f0e:	11 98       	cbi	0x02, 1	; 2
		PORTA|=(Om_RAM_WE);					// Disbale writes.
    4f10:	11 9a       	sbi	0x02, 1	; 2

		if(theBank==BANK_0)					// Move up in lower bank, move down in upper.
    4f12:	dd 20       	and	r13, r13
    4f14:	c1 f4       	brne	.+48     	; 0x4f46 <ReadSampleFromSlot+0x1d2>
		{
			bankStates[theBank].currentAddress++;
    4f16:	80 e0       	ldi	r24, 0x00	; 0
    4f18:	90 e0       	ldi	r25, 0x00	; 0
    4f1a:	fc 01       	movw	r30, r24
    4f1c:	55 e0       	ldi	r21, 0x05	; 5
    4f1e:	ee 0f       	add	r30, r30
    4f20:	ff 1f       	adc	r31, r31
    4f22:	5a 95       	dec	r21
    4f24:	e1 f7       	brne	.-8      	; 0x4f1e <ReadSampleFromSlot+0x1aa>
    4f26:	88 0f       	add	r24, r24
    4f28:	99 1f       	adc	r25, r25
    4f2a:	e8 0f       	add	r30, r24
    4f2c:	f9 1f       	adc	r31, r25
    4f2e:	e3 58       	subi	r30, 0x83	; 131
    4f30:	fd 4f       	sbci	r31, 0xFD	; 253
    4f32:	26 8d       	ldd	r18, Z+30	; 0x1e
    4f34:	37 8d       	ldd	r19, Z+31	; 0x1f
    4f36:	40 a1       	ldd	r20, Z+32	; 0x20
    4f38:	51 a1       	ldd	r21, Z+33	; 0x21
    4f3a:	2f 5f       	subi	r18, 0xFF	; 255
    4f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    4f3e:	4f 4f       	sbci	r20, 0xFF	; 255
    4f40:	5f 4f       	sbci	r21, 0xFF	; 255
    4f42:	80 e0       	ldi	r24, 0x00	; 0
    4f44:	17 c0       	rjmp	.+46     	; 0x4f74 <ReadSampleFromSlot+0x200>
		}
		else
		{
			bankStates[theBank].currentAddress--;
    4f46:	8d 2d       	mov	r24, r13
    4f48:	90 e0       	ldi	r25, 0x00	; 0
    4f4a:	fc 01       	movw	r30, r24
    4f4c:	35 e0       	ldi	r19, 0x05	; 5
    4f4e:	ee 0f       	add	r30, r30
    4f50:	ff 1f       	adc	r31, r31
    4f52:	3a 95       	dec	r19
    4f54:	e1 f7       	brne	.-8      	; 0x4f4e <ReadSampleFromSlot+0x1da>
    4f56:	88 0f       	add	r24, r24
    4f58:	99 1f       	adc	r25, r25
    4f5a:	e8 0f       	add	r30, r24
    4f5c:	f9 1f       	adc	r31, r25
    4f5e:	e3 58       	subi	r30, 0x83	; 131
    4f60:	fd 4f       	sbci	r31, 0xFD	; 253
    4f62:	26 8d       	ldd	r18, Z+30	; 0x1e
    4f64:	37 8d       	ldd	r19, Z+31	; 0x1f
    4f66:	40 a1       	ldd	r20, Z+32	; 0x20
    4f68:	51 a1       	ldd	r21, Z+33	; 0x21
    4f6a:	21 50       	subi	r18, 0x01	; 1
    4f6c:	30 40       	sbci	r19, 0x00	; 0
    4f6e:	40 40       	sbci	r20, 0x00	; 0
    4f70:	50 40       	sbci	r21, 0x00	; 0
    4f72:	8d 2d       	mov	r24, r13
    4f74:	90 e0       	ldi	r25, 0x00	; 0
    4f76:	fc 01       	movw	r30, r24
    4f78:	b5 e0       	ldi	r27, 0x05	; 5
    4f7a:	ee 0f       	add	r30, r30
    4f7c:	ff 1f       	adc	r31, r31
    4f7e:	ba 95       	dec	r27
    4f80:	e1 f7       	brne	.-8      	; 0x4f7a <ReadSampleFromSlot+0x206>
    4f82:	88 0f       	add	r24, r24
    4f84:	99 1f       	adc	r25, r25
    4f86:	e8 0f       	add	r30, r24
    4f88:	f9 1f       	adc	r31, r25
    4f8a:	e3 58       	subi	r30, 0x83	; 131
    4f8c:	fd 4f       	sbci	r31, 0xFD	; 253
    4f8e:	26 8f       	std	Z+30, r18	; 0x1e
    4f90:	37 8f       	std	Z+31, r19	; 0x1f
    4f92:	40 a3       	std	Z+32, r20	; 0x20
    4f94:	51 a3       	std	Z+33, r21	; 0x21
		}

		bytesTransferred++;		// One more byte transferred.
    4f96:	08 94       	sec
    4f98:	e1 1c       	adc	r14, r1
    4f9a:	f1 1c       	adc	r15, r1
    4f9c:	01 1d       	adc	r16, r1
    4f9e:	11 1d       	adc	r17, r1
	bankStates[theBank].currentAddress=bankStates[theBank].startAddress;	// Sync indices with the new sample that's going into RAM
	bankStates[theBank].adjustedStartAddress=bankStates[theBank].startAddress;
	LATCH_DDR=0xFF;						// Data bus to output
	PORTA|=(Om_RAM_OE);					// Tristate the RAM.
		
	while(bytesTransferred<flashToc[slotIndex])	// While we've still got bytes to transfer, transfer them.
    4fa0:	e8 14       	cp	r14, r8
    4fa2:	f9 04       	cpc	r15, r9
    4fa4:	0a 05       	cpc	r16, r10
    4fa6:	1b 05       	cpc	r17, r11
    4fa8:	08 f4       	brcc	.+2      	; 0x4fac <ReadSampleFromSlot+0x238>
    4faa:	5e cf       	rjmp	.-324    	; 0x4e68 <ReadSampleFromSlot+0xf4>
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    4fac:	5d 9a       	sbi	0x0b, 5	; 11
		bytesTransferred++;		// One more byte transferred.
	}
	
	EndExternalFlashTransfer();			// End the read

	bankStates[theBank].endAddress=bankStates[theBank].currentAddress;				// Sync sample indices.
    4fae:	8d 2d       	mov	r24, r13
    4fb0:	90 e0       	ldi	r25, 0x00	; 0
    4fb2:	fc 01       	movw	r30, r24
    4fb4:	15 e0       	ldi	r17, 0x05	; 5
    4fb6:	ee 0f       	add	r30, r30
    4fb8:	ff 1f       	adc	r31, r31
    4fba:	1a 95       	dec	r17
    4fbc:	e1 f7       	brne	.-8      	; 0x4fb6 <ReadSampleFromSlot+0x242>
    4fbe:	88 0f       	add	r24, r24
    4fc0:	99 1f       	adc	r25, r25
    4fc2:	e8 0f       	add	r30, r24
    4fc4:	f9 1f       	adc	r31, r25
    4fc6:	e3 58       	subi	r30, 0x83	; 131
    4fc8:	fd 4f       	sbci	r31, 0xFD	; 253
    4fca:	26 8d       	ldd	r18, Z+30	; 0x1e
    4fcc:	37 8d       	ldd	r19, Z+31	; 0x1f
    4fce:	40 a1       	ldd	r20, Z+32	; 0x20
    4fd0:	51 a1       	ldd	r21, Z+33	; 0x21
    4fd2:	8d 2d       	mov	r24, r13
    4fd4:	90 e0       	ldi	r25, 0x00	; 0
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	a5 e0       	ldi	r26, 0x05	; 5
    4fda:	ee 0f       	add	r30, r30
    4fdc:	ff 1f       	adc	r31, r31
    4fde:	aa 95       	dec	r26
    4fe0:	e1 f7       	brne	.-8      	; 0x4fda <ReadSampleFromSlot+0x266>
    4fe2:	88 0f       	add	r24, r24
    4fe4:	99 1f       	adc	r25, r25
    4fe6:	e8 0f       	add	r30, r24
    4fe8:	f9 1f       	adc	r31, r25
    4fea:	e3 58       	subi	r30, 0x83	; 131
    4fec:	fd 4f       	sbci	r31, 0xFD	; 253
    4fee:	23 87       	std	Z+11, r18	; 0x0b
    4ff0:	34 87       	std	Z+12, r19	; 0x0c
    4ff2:	45 87       	std	Z+13, r20	; 0x0d
    4ff4:	56 87       	std	Z+14, r21	; 0x0e
	bankStates[theBank].adjustedEndAddress=bankStates[theBank].currentAddress;
    4ff6:	8d 2d       	mov	r24, r13
    4ff8:	90 e0       	ldi	r25, 0x00	; 0
    4ffa:	fc 01       	movw	r30, r24
    4ffc:	35 e0       	ldi	r19, 0x05	; 5
    4ffe:	ee 0f       	add	r30, r30
    5000:	ff 1f       	adc	r31, r31
    5002:	3a 95       	dec	r19
    5004:	e1 f7       	brne	.-8      	; 0x4ffe <ReadSampleFromSlot+0x28a>
    5006:	88 0f       	add	r24, r24
    5008:	99 1f       	adc	r25, r25
    500a:	e8 0f       	add	r30, r24
    500c:	f9 1f       	adc	r31, r25
    500e:	e3 58       	subi	r30, 0x83	; 131
    5010:	fd 4f       	sbci	r31, 0xFD	; 253
    5012:	26 8d       	ldd	r18, Z+30	; 0x1e
    5014:	37 8d       	ldd	r19, Z+31	; 0x1f
    5016:	40 a1       	ldd	r20, Z+32	; 0x20
    5018:	51 a1       	ldd	r21, Z+33	; 0x21
    501a:	8d 2d       	mov	r24, r13
    501c:	90 e0       	ldi	r25, 0x00	; 0
    501e:	fc 01       	movw	r30, r24
    5020:	05 e0       	ldi	r16, 0x05	; 5
    5022:	ee 0f       	add	r30, r30
    5024:	ff 1f       	adc	r31, r31
    5026:	0a 95       	dec	r16
    5028:	e1 f7       	brne	.-8      	; 0x5022 <ReadSampleFromSlot+0x2ae>
    502a:	88 0f       	add	r24, r24
    502c:	99 1f       	adc	r25, r25
    502e:	e8 0f       	add	r30, r24
    5030:	f9 1f       	adc	r31, r25
    5032:	e3 58       	subi	r30, 0x83	; 131
    5034:	fd 4f       	sbci	r31, 0xFD	; 253
    5036:	23 8b       	std	Z+19, r18	; 0x13
    5038:	34 8b       	std	Z+20, r19	; 0x14
    503a:	45 8b       	std	Z+21, r20	; 0x15
    503c:	56 8b       	std	Z+22, r21	; 0x16

	SREG=sreg;							// Re-enable interrupts.
    503e:	6f bf       	out	0x3f, r22	; 63
}
    5040:	df 91       	pop	r29
    5042:	cf 91       	pop	r28
    5044:	1f 91       	pop	r17
    5046:	0f 91       	pop	r16
    5048:	ff 90       	pop	r15
    504a:	ef 90       	pop	r14
    504c:	df 90       	pop	r13
    504e:	bf 90       	pop	r11
    5050:	af 90       	pop	r10
    5052:	9f 90       	pop	r9
    5054:	8f 90       	pop	r8
    5056:	08 95       	ret

00005058 <InitFlashStorage>:
bool InitFlashStorage(void)
// Bring the AVR's hardware up.
// Look for a valid flash chip on the SPI bus.
// If it's there, report this to the program.
// If not, disable the AVR's hardware and report the lack of flash to the program.
{
    5058:	ef 92       	push	r14
    505a:	ff 92       	push	r15
    505c:	0f 93       	push	r16
    505e:	1f 93       	push	r17
// CS should always start high when beginning any transaction with the SST flash.
// The chip can run in SPI mode 3 or 0.  It automatically determines the SPI mode by looking at the idle state of the SCK pin on every falling CS.
// All instructions, addresses, and data are transferred with the most significant bit (MSb) first.
// We're starting with SCK = (Fosc / 4) or 5MHz with a 20MHz crystal.
{
	PRR&=~(1<<PRUSART1);				// Power on the UART.
    5060:	80 91 64 00 	lds	r24, 0x0064
    5064:	8f 7e       	andi	r24, 0xEF	; 239
    5066:	80 93 64 00 	sts	0x0064, r24
	UBRR1=0;							// The baud rate register must be 0 when the transmitter is enabled.
    506a:	10 92 cd 00 	sts	0x00CD, r1
    506e:	10 92 cc 00 	sts	0x00CC, r1
	DDRD|=(1<<PD4);						// Set the XCK1 (normally the UART external clock, now the SCK out) to an output -- since the MSPIM can only be an SPI Master (and that's what we want).
    5072:	54 9a       	sbi	0x0a, 4	; 10
	UCSR1C=((1<<UMSEL11) | (1<<UMSEL10) | (1<<UCPHA1) | (1<<UCPOL1));	// Set the USART to MPSIM mode, SPI mode 3, MSB first.
    5074:	83 ec       	ldi	r24, 0xC3	; 195
    5076:	80 93 ca 00 	sts	0x00CA, r24
	UCSR1B=((1<<RXEN1)|(1<<TXEN1)); 	// Enable the transmitter and receiver.
    507a:	88 e1       	ldi	r24, 0x18	; 24
    507c:	80 93 c9 00 	sts	0x00C9, r24
	UBRR1=1;							// According to the datasheet this should be "5MBaud" or a 5MHz clock.  NOTE:  The baud rate must be set properly AFTER the transmitter is enabled but before the first transmission.
    5080:	81 e0       	ldi	r24, 0x01	; 1
    5082:	90 e0       	ldi	r25, 0x00	; 0
    5084:	90 93 cd 00 	sts	0x00CD, r25
    5088:	80 93 cc 00 	sts	0x00CC, r24

	DDRD|=Om_FLASH_CS;			// CS pin to output.
    508c:	55 9a       	sbi	0x0a, 5	; 10
	PORTD|=Om_FLASH_CS;		// And start with CS high on the flash.
    508e:	5d 9a       	sbi	0x0b, 5	; 11

static void StartExternalFlashTransfer(void)
// Just bring the Chip Select (Slave Select) line from high to low.
// This will abort and restart a transfer if called in  the middle of a transfer process.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    5090:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD&=~Om_FLASH_CS;				// Then bring it low.
    5092:	5d 98       	cbi	0x0b, 5	; 11
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5094:	80 91 c8 00 	lds	r24, 0x00C8
    5098:	85 ff       	sbrs	r24, 5
    509a:	fc cf       	rjmp	.-8      	; 0x5094 <InitFlashStorage+0x3c>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    509c:	8f e9       	ldi	r24, 0x9F	; 159
    509e:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    50a2:	80 91 c8 00 	lds	r24, 0x00C8
    50a6:	87 ff       	sbrs	r24, 7
    50a8:	fc cf       	rjmp	.-8      	; 0x50a2 <InitFlashStorage+0x4a>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    50aa:	80 91 ce 00 	lds	r24, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    50ae:	80 91 c8 00 	lds	r24, 0x00C8
    50b2:	85 ff       	sbrs	r24, 5
    50b4:	fc cf       	rjmp	.-8      	; 0x50ae <InitFlashStorage+0x56>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    50b6:	8f ef       	ldi	r24, 0xFF	; 255
    50b8:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    50bc:	80 91 c8 00 	lds	r24, 0x00C8
    50c0:	87 ff       	sbrs	r24, 7
    50c2:	fc cf       	rjmp	.-8      	; 0x50bc <InitFlashStorage+0x64>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    50c4:	20 91 ce 00 	lds	r18, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    50c8:	80 91 c8 00 	lds	r24, 0x00C8
    50cc:	85 ff       	sbrs	r24, 5
    50ce:	fc cf       	rjmp	.-8      	; 0x50c8 <InitFlashStorage+0x70>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    50d0:	8f ef       	ldi	r24, 0xFF	; 255
    50d2:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    50d6:	80 91 c8 00 	lds	r24, 0x00C8
    50da:	87 ff       	sbrs	r24, 7
    50dc:	fc cf       	rjmp	.-8      	; 0x50d6 <InitFlashStorage+0x7e>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    50de:	90 91 ce 00 	lds	r25, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    50e2:	80 91 c8 00 	lds	r24, 0x00C8
    50e6:	85 ff       	sbrs	r24, 5
    50e8:	fc cf       	rjmp	.-8      	; 0x50e2 <InitFlashStorage+0x8a>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    50ea:	8f ef       	ldi	r24, 0xFF	; 255
    50ec:	80 93 ce 00 	sts	0x00CE, r24

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    50f0:	80 91 c8 00 	lds	r24, 0x00C8
    50f4:	87 ff       	sbrs	r24, 7
    50f6:	fc cf       	rjmp	.-8      	; 0x50f0 <InitFlashStorage+0x98>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    50f8:	80 91 ce 00 	lds	r24, 0x00CE
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    50fc:	5d 9a       	sbi	0x0b, 5	; 11
	idByte0=TransferExternalFlashByte(DUMMY_BYTE);	// Get the first one back (mfg)
	idByte1=TransferExternalFlashByte(DUMMY_BYTE);	// Get the first one back (mem type)
	idByte2=TransferExternalFlashByte(DUMMY_BYTE);	// Get the first one back (mem cap)
	EndExternalFlashTransfer();						// End transfer.

	if((idByte0==0xBF)&&(idByte1==0x25)&&(idByte2==0x4B))	// See the datasheet for an expalantion of these signature bytes.
    50fe:	2f 3b       	cpi	r18, 0xBF	; 191
    5100:	09 f0       	breq	.+2      	; 0x5104 <InitFlashStorage+0xac>
    5102:	74 c0       	rjmp	.+232    	; 0x51ec <InitFlashStorage+0x194>
    5104:	95 32       	cpi	r25, 0x25	; 37
    5106:	09 f0       	breq	.+2      	; 0x510a <InitFlashStorage+0xb2>
    5108:	71 c0       	rjmp	.+226    	; 0x51ec <InitFlashStorage+0x194>
    510a:	8b 34       	cpi	r24, 0x4B	; 75
    510c:	09 f0       	breq	.+2      	; 0x5110 <InitFlashStorage+0xb8>
    510e:	6e c0       	rjmp	.+220    	; 0x51ec <InitFlashStorage+0x194>
	unsigned char
		i;
	unsigned long
		tempTocEntry;

	StartFlashRead(0);								// Begin reading at byte 0
    5110:	60 e0       	ldi	r22, 0x00	; 0
    5112:	70 e0       	ldi	r23, 0x00	; 0
    5114:	80 e0       	ldi	r24, 0x00	; 0
    5116:	90 e0       	ldi	r25, 0x00	; 0
    5118:	0e 94 c5 23 	call	0x478a	; 0x478a <StartFlashRead>
    511c:	e7 ef       	ldi	r30, 0xF7	; 247
    511e:	f2 e0       	ldi	r31, 0x02	; 2
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5120:	7f ef       	ldi	r23, 0xFF	; 255
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5122:	80 91 c8 00 	lds	r24, 0x00C8
    5126:	85 ff       	sbrs	r24, 5
    5128:	fc cf       	rjmp	.-8      	; 0x5122 <InitFlashStorage+0xca>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    512a:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    512e:	80 91 c8 00 	lds	r24, 0x00C8
    5132:	87 ff       	sbrs	r24, 7
    5134:	fc cf       	rjmp	.-8      	; 0x512e <InitFlashStorage+0xd6>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5136:	20 91 ce 00 	lds	r18, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    513a:	80 91 c8 00 	lds	r24, 0x00C8
    513e:	85 ff       	sbrs	r24, 5
    5140:	fc cf       	rjmp	.-8      	; 0x513a <InitFlashStorage+0xe2>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5142:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5146:	80 91 c8 00 	lds	r24, 0x00C8
    514a:	87 ff       	sbrs	r24, 7
    514c:	fc cf       	rjmp	.-8      	; 0x5146 <InitFlashStorage+0xee>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    514e:	90 91 ce 00 	lds	r25, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    5152:	80 91 c8 00 	lds	r24, 0x00C8
    5156:	85 ff       	sbrs	r24, 5
    5158:	fc cf       	rjmp	.-8      	; 0x5152 <InitFlashStorage+0xfa>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    515a:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    515e:	80 91 c8 00 	lds	r24, 0x00C8
    5162:	87 ff       	sbrs	r24, 7
    5164:	fc cf       	rjmp	.-8      	; 0x515e <InitFlashStorage+0x106>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    5166:	60 91 ce 00 	lds	r22, 0x00CE
// Loads a theByte into the SPI transmit shift register, waits until the transfer is complete, and then returns the byte it's gotten from the Slave.
// The AVR's SPIF bit is cleared by first reading the SPI status register when the SPIF is set, and afterwards accessing SPDR.
// NOTE: Tue Oct 14 23:07:27 CDT 2008
// This is a little different now with the UART hardware.  The UART is double buffered and the example in the datasheet has you checking both transmit and recieve buffers every transmission.
{
	while(!(UCSR1A&(1<<UDRE1)))	// Spin until the transmit buffer is ready to receive data.
    516a:	80 91 c8 00 	lds	r24, 0x00C8
    516e:	85 ff       	sbrs	r24, 5
    5170:	fc cf       	rjmp	.-8      	; 0x516a <InitFlashStorage+0x112>
		;
	UDR1=theByte;				// Load the xmit buffer and start the transfer.
    5172:	70 93 ce 00 	sts	0x00CE, r23

	while(!(UCSR1A&(1<<RXC1)))	// Spin until the recieve buffer has unread data.
    5176:	80 91 c8 00 	lds	r24, 0x00C8
    517a:	87 ff       	sbrs	r24, 7
    517c:	fc cf       	rjmp	.-8      	; 0x5176 <InitFlashStorage+0x11e>
		;

	return(UDR1);				// Return the data clocked in from the slave.
    517e:	e0 90 ce 00 	lds	r14, 0x00CE

	StartFlashRead(0);								// Begin reading at byte 0

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
	{
		tempTocEntry=((unsigned long)TransferExternalFlashByte(DUMMY_BYTE)<<24);	// MSByte (unsigned ints in C are padded with 0 on the right when shifted)
    5182:	30 e0       	ldi	r19, 0x00	; 0
    5184:	40 e0       	ldi	r20, 0x00	; 0
    5186:	50 e0       	ldi	r21, 0x00	; 0
    5188:	52 2f       	mov	r21, r18
    518a:	44 27       	eor	r20, r20
    518c:	33 27       	eor	r19, r19
    518e:	22 27       	eor	r18, r18
		tempTocEntry|=((unsigned long)TransferExternalFlashByte(DUMMY_BYTE)<<16);	// MSByte-1.
    5190:	89 2f       	mov	r24, r25
    5192:	90 e0       	ldi	r25, 0x00	; 0
    5194:	a0 e0       	ldi	r26, 0x00	; 0
    5196:	b0 e0       	ldi	r27, 0x00	; 0
    5198:	dc 01       	movw	r26, r24
    519a:	99 27       	eor	r25, r25
    519c:	88 27       	eor	r24, r24
    519e:	28 2b       	or	r18, r24
    51a0:	39 2b       	or	r19, r25
    51a2:	4a 2b       	or	r20, r26
    51a4:	5b 2b       	or	r21, r27
		tempTocEntry|=((unsigned long)TransferExternalFlashByte(DUMMY_BYTE)<<8);	// MSByte-2.
    51a6:	ff 24       	eor	r15, r15
    51a8:	00 e0       	ldi	r16, 0x00	; 0
    51aa:	10 e0       	ldi	r17, 0x00	; 0
    51ac:	2e 29       	or	r18, r14
    51ae:	3f 29       	or	r19, r15
    51b0:	40 2b       	or	r20, r16
    51b2:	51 2b       	or	r21, r17
		tempTocEntry|=TransferExternalFlashByte(DUMMY_BYTE);						// LSByte.
		flashToc[i]=tempTocEntry;									// Put it in the TOC
    51b4:	86 2f       	mov	r24, r22
    51b6:	90 e0       	ldi	r25, 0x00	; 0
    51b8:	a0 e0       	ldi	r26, 0x00	; 0
    51ba:	b0 e0       	ldi	r27, 0x00	; 0
    51bc:	ba 2f       	mov	r27, r26
    51be:	a9 2f       	mov	r26, r25
    51c0:	98 2f       	mov	r25, r24
    51c2:	88 27       	eor	r24, r24
    51c4:	28 2b       	or	r18, r24
    51c6:	39 2b       	or	r19, r25
    51c8:	4a 2b       	or	r20, r26
    51ca:	5b 2b       	or	r21, r27
    51cc:	21 93       	st	Z+, r18
    51ce:	31 93       	st	Z+, r19
    51d0:	41 93       	st	Z+, r20
    51d2:	51 93       	st	Z+, r21
	unsigned long
		tempTocEntry;

	StartFlashRead(0);								// Begin reading at byte 0

	for(i=0;i<NUM_SLOTS_IN_FLASH;i++)		// Get stored bytes and make them into a long, then put them into the toc.
    51d4:	83 e0       	ldi	r24, 0x03	; 3
    51d6:	e3 33       	cpi	r30, 0x33	; 51
    51d8:	f8 07       	cpc	r31, r24
    51da:	09 f0       	breq	.+2      	; 0x51de <InitFlashStorage+0x186>
    51dc:	a2 cf       	rjmp	.-188    	; 0x5122 <InitFlashStorage+0xca>
//-----------------------------------------------------------------------

static void EndExternalFlashTransfer(void)
// This ends an SPI transfer.  If called while the CS line is already high or there is no transfer going on, nothing happens.
{
	PORTD|=Om_FLASH_CS;				// Make sure the CS (SS) line is high.
    51de:	5d 9a       	sbi	0x0b, 5	; 11
    51e0:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		UnInitExternalFlashInterface();
		return(false);
	}
}
    51e2:	1f 91       	pop	r17
    51e4:	0f 91       	pop	r16
    51e6:	ff 90       	pop	r15
    51e8:	ef 90       	pop	r14
    51ea:	08 95       	ret
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

static void UnInitExternalFlashInterface(void)
{
	DDRD&=~(Om_FLASH_CS|(1<<PD4));		// Flash specific outputs back to inputs.
    51ec:	8a b1       	in	r24, 0x0a	; 10
    51ee:	8f 7c       	andi	r24, 0xCF	; 207
    51f0:	8a b9       	out	0x0a, r24	; 10
	PORTD|=(Om_FLASH_CS|(1<<PD4));	// Pullup pins so they don't float
    51f2:	8b b1       	in	r24, 0x0b	; 11
    51f4:	80 63       	ori	r24, 0x30	; 48
    51f6:	8b b9       	out	0x0b, r24	; 11
	UCSR1B=0;						// Disable transmission / reception
    51f8:	10 92 c9 00 	sts	0x00C9, r1
	PRR|=(1<<PRUSART1);				// Power off the UART.	
    51fc:	80 91 64 00 	lds	r24, 0x0064
    5200:	80 61       	ori	r24, 0x10	; 16
    5202:	80 93 64 00 	sts	0x0064, r24
    5206:	80 e0       	ldi	r24, 0x00	; 0
    5208:	ec cf       	rjmp	.-40     	; 0x51e2 <InitFlashStorage+0x18a>

0000520a <__mulsi3>:
    520a:	62 9f       	mul	r22, r18
    520c:	d0 01       	movw	r26, r0
    520e:	73 9f       	mul	r23, r19
    5210:	f0 01       	movw	r30, r0
    5212:	82 9f       	mul	r24, r18
    5214:	e0 0d       	add	r30, r0
    5216:	f1 1d       	adc	r31, r1
    5218:	64 9f       	mul	r22, r20
    521a:	e0 0d       	add	r30, r0
    521c:	f1 1d       	adc	r31, r1
    521e:	92 9f       	mul	r25, r18
    5220:	f0 0d       	add	r31, r0
    5222:	83 9f       	mul	r24, r19
    5224:	f0 0d       	add	r31, r0
    5226:	74 9f       	mul	r23, r20
    5228:	f0 0d       	add	r31, r0
    522a:	65 9f       	mul	r22, r21
    522c:	f0 0d       	add	r31, r0
    522e:	99 27       	eor	r25, r25
    5230:	72 9f       	mul	r23, r18
    5232:	b0 0d       	add	r27, r0
    5234:	e1 1d       	adc	r30, r1
    5236:	f9 1f       	adc	r31, r25
    5238:	63 9f       	mul	r22, r19
    523a:	b0 0d       	add	r27, r0
    523c:	e1 1d       	adc	r30, r1
    523e:	f9 1f       	adc	r31, r25
    5240:	bd 01       	movw	r22, r26
    5242:	cf 01       	movw	r24, r30
    5244:	11 24       	eor	r1, r1
    5246:	08 95       	ret

00005248 <__udivmodqi4>:
    5248:	99 1b       	sub	r25, r25
    524a:	79 e0       	ldi	r23, 0x09	; 9
    524c:	04 c0       	rjmp	.+8      	; 0x5256 <__udivmodqi4_ep>

0000524e <__udivmodqi4_loop>:
    524e:	99 1f       	adc	r25, r25
    5250:	96 17       	cp	r25, r22
    5252:	08 f0       	brcs	.+2      	; 0x5256 <__udivmodqi4_ep>
    5254:	96 1b       	sub	r25, r22

00005256 <__udivmodqi4_ep>:
    5256:	88 1f       	adc	r24, r24
    5258:	7a 95       	dec	r23
    525a:	c9 f7       	brne	.-14     	; 0x524e <__udivmodqi4_loop>
    525c:	80 95       	com	r24
    525e:	08 95       	ret

00005260 <__divmodhi4>:
    5260:	97 fb       	bst	r25, 7
    5262:	09 2e       	mov	r0, r25
    5264:	07 26       	eor	r0, r23
    5266:	0a d0       	rcall	.+20     	; 0x527c <__divmodhi4_neg1>
    5268:	77 fd       	sbrc	r23, 7
    526a:	04 d0       	rcall	.+8      	; 0x5274 <__divmodhi4_neg2>
    526c:	2e d0       	rcall	.+92     	; 0x52ca <__udivmodhi4>
    526e:	06 d0       	rcall	.+12     	; 0x527c <__divmodhi4_neg1>
    5270:	00 20       	and	r0, r0
    5272:	1a f4       	brpl	.+6      	; 0x527a <__divmodhi4_exit>

00005274 <__divmodhi4_neg2>:
    5274:	70 95       	com	r23
    5276:	61 95       	neg	r22
    5278:	7f 4f       	sbci	r23, 0xFF	; 255

0000527a <__divmodhi4_exit>:
    527a:	08 95       	ret

0000527c <__divmodhi4_neg1>:
    527c:	f6 f7       	brtc	.-4      	; 0x527a <__divmodhi4_exit>
    527e:	90 95       	com	r25
    5280:	81 95       	neg	r24
    5282:	9f 4f       	sbci	r25, 0xFF	; 255
    5284:	08 95       	ret

00005286 <__udivmodsi4>:
    5286:	a1 e2       	ldi	r26, 0x21	; 33
    5288:	1a 2e       	mov	r1, r26
    528a:	aa 1b       	sub	r26, r26
    528c:	bb 1b       	sub	r27, r27
    528e:	fd 01       	movw	r30, r26
    5290:	0d c0       	rjmp	.+26     	; 0x52ac <__udivmodsi4_ep>

00005292 <__udivmodsi4_loop>:
    5292:	aa 1f       	adc	r26, r26
    5294:	bb 1f       	adc	r27, r27
    5296:	ee 1f       	adc	r30, r30
    5298:	ff 1f       	adc	r31, r31
    529a:	a2 17       	cp	r26, r18
    529c:	b3 07       	cpc	r27, r19
    529e:	e4 07       	cpc	r30, r20
    52a0:	f5 07       	cpc	r31, r21
    52a2:	20 f0       	brcs	.+8      	; 0x52ac <__udivmodsi4_ep>
    52a4:	a2 1b       	sub	r26, r18
    52a6:	b3 0b       	sbc	r27, r19
    52a8:	e4 0b       	sbc	r30, r20
    52aa:	f5 0b       	sbc	r31, r21

000052ac <__udivmodsi4_ep>:
    52ac:	66 1f       	adc	r22, r22
    52ae:	77 1f       	adc	r23, r23
    52b0:	88 1f       	adc	r24, r24
    52b2:	99 1f       	adc	r25, r25
    52b4:	1a 94       	dec	r1
    52b6:	69 f7       	brne	.-38     	; 0x5292 <__udivmodsi4_loop>
    52b8:	60 95       	com	r22
    52ba:	70 95       	com	r23
    52bc:	80 95       	com	r24
    52be:	90 95       	com	r25
    52c0:	9b 01       	movw	r18, r22
    52c2:	ac 01       	movw	r20, r24
    52c4:	bd 01       	movw	r22, r26
    52c6:	cf 01       	movw	r24, r30
    52c8:	08 95       	ret

000052ca <__udivmodhi4>:
    52ca:	aa 1b       	sub	r26, r26
    52cc:	bb 1b       	sub	r27, r27
    52ce:	51 e1       	ldi	r21, 0x11	; 17
    52d0:	07 c0       	rjmp	.+14     	; 0x52e0 <__udivmodhi4_ep>

000052d2 <__udivmodhi4_loop>:
    52d2:	aa 1f       	adc	r26, r26
    52d4:	bb 1f       	adc	r27, r27
    52d6:	a6 17       	cp	r26, r22
    52d8:	b7 07       	cpc	r27, r23
    52da:	10 f0       	brcs	.+4      	; 0x52e0 <__udivmodhi4_ep>
    52dc:	a6 1b       	sub	r26, r22
    52de:	b7 0b       	sbc	r27, r23

000052e0 <__udivmodhi4_ep>:
    52e0:	88 1f       	adc	r24, r24
    52e2:	99 1f       	adc	r25, r25
    52e4:	5a 95       	dec	r21
    52e6:	a9 f7       	brne	.-22     	; 0x52d2 <__udivmodhi4_loop>
    52e8:	80 95       	com	r24
    52ea:	90 95       	com	r25
    52ec:	bc 01       	movw	r22, r24
    52ee:	cd 01       	movw	r24, r26
    52f0:	08 95       	ret

000052f2 <_exit>:
    52f2:	f8 94       	cli

000052f4 <__stop_program>:
    52f4:	ff cf       	rjmp	.-2      	; 0x52f4 <__stop_program>
